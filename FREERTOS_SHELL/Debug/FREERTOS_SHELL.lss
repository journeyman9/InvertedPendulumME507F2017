
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004406  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c8  00802000  00004406  0000449a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a4  008020c8  008020c8  00004562  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004562  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004594  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c8  00000000  00000000  000045d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010f0e  00000000  00000000  00004c9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000062c6  00000000  00000000  00015baa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004f9c  00000000  00000000  0001be70  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001388  00000000  00000000  00020e0c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005ed8  00000000  00000000  00022194  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006176  00000000  00000000  0002806c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000568  00000000  00000000  0002e1e2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a7 02 	jmp	0x54e	; 0x54e <__ctors_end>
       4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      10:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      14:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      18:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      1c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      20:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      24:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      28:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      2c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      30:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      34:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      38:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      3c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      40:	0c 94 35 0c 	jmp	0x186a	; 0x186a <__vector_16>
      44:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      4c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      50:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      54:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      58:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      5c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      60:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      64:	0c 94 38 1c 	jmp	0x3870	; 0x3870 <__vector_25>
      68:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      6c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      70:	0c 94 96 1c 	jmp	0x392c	; 0x392c <__vector_28>
      74:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      78:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      7c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      80:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      84:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      88:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      8c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      90:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      94:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      98:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      9c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e8:	0c 94 b0 1d 	jmp	0x3b60	; 0x3b60 <__vector_58>
      ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      fc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     100:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     104:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     108:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     10c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     110:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     114:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     118:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     11c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     120:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     124:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     128:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     12c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     130:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     134:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     138:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     13c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     140:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     144:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     148:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     14c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     150:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     154:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     158:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     15c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     160:	0c 94 f4 1c 	jmp	0x39e8	; 0x39e8 <__vector_88>
     164:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     168:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     16c:	0c 94 52 1d 	jmp	0x3aa4	; 0x3aa4 <__vector_91>
     170:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     174:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     178:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     17c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     180:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     184:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     188:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     18c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     190:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     194:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     198:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     19c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1fc:	0c 1a       	sub	r0, r28
     1fe:	0f 1a       	sub	r0, r31
     200:	12 1a       	sub	r1, r18
     202:	15 1a       	sub	r1, r21
     204:	18 1a       	sub	r1, r24
     206:	1b 1a       	sub	r1, r27
     208:	1d 1a       	sub	r1, r29
     20a:	2e 1a       	sub	r2, r30
     20c:	36 1a       	sub	r3, r22
     20e:	40 1a       	sub	r4, r16
     210:	3e 1a       	sub	r3, r30

00000212 <__trampolines_start>:
     212:	0c 94 9c 1b 	jmp	0x3738	; 0x3738 <_ZN5rs23214check_for_charEv>
     216:	0c 94 b6 1e 	jmp	0x3d6c	; 0x3d6c <_GLOBAL__sub_I_counter>
     21a:	0c 94 0c 1a 	jmp	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21e:	0c 94 32 17 	jmp	0x2e64	; 0x2e64 <_ZN14frt_text_queue7getcharEv>
     222:	0c 94 b7 19 	jmp	0x336e	; 0x336e <_ZN8emstream12clear_screenEv>
     226:	0c 94 b1 19 	jmp	0x3362	; 0x3362 <_ZN8emstream7getcharEv>
     22a:	0c 94 11 08 	jmp	0x1022	; 0x1022 <_ZN9task_user3runEv>
     22e:	0c 94 0f 1a 	jmp	0x341e	; 0x341e <_ZN8emstreamlsE15ser_manipulator+0x24>
     232:	0c 94 b4 19 	jmp	0x3368	; 0x3368 <_ZN8emstream14check_for_charEv>
     236:	0c 94 b6 19 	jmp	0x336c	; 0x336c <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 40 1a 	jmp	0x3480	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
     23e:	0c 94 18 1a 	jmp	0x3430	; 0x3430 <_ZN8emstreamlsE15ser_manipulator+0x36>
     242:	0c 94 5b 17 	jmp	0x2eb6	; 0x2eb6 <_ZN14frt_text_queue7putcharEc>
     246:	0c 94 b9 0e 	jmp	0x1d72	; 0x1d72 <prvIdleTask>
     24a:	0c 94 18 19 	jmp	0x3230	; 0x3230 <__cxa_pure_virtual>
     24e:	0c 94 00 04 	jmp	0x800	; 0x800 <_ZN13LimitSwitches3runEv>
     252:	0c 94 90 03 	jmp	0x720	; 0x720 <_ZN15EncoderPendulum3runEv>
     256:	0c 94 a4 02 	jmp	0x548	; 0x548 <_call_static_run_method>
     25a:	0c 94 50 17 	jmp	0x2ea0	; 0x2ea0 <_ZN14frt_text_queue14check_for_charEv>
     25e:	0c 94 1d 1a 	jmp	0x343a	; 0x343a <_ZN8emstreamlsE15ser_manipulator+0x40>
     262:	0c 94 af 19 	jmp	0x335e	; 0x335e <_ZN8emstream13ready_to_sendEv>
     266:	0c 94 3e 1a 	jmp	0x347c	; 0x347c <_ZN8emstreamlsE15ser_manipulator+0x82>
     26a:	0c 94 36 1a 	jmp	0x346c	; 0x346c <_ZN8emstreamlsE15ser_manipulator+0x72>
     26e:	0c 94 e8 15 	jmp	0x2bd0	; 0x2bd0 <_ZN8frt_task12print_statusER8emstream>
     272:	0c 94 15 1a 	jmp	0x342a	; 0x342a <_ZN8emstreamlsE15ser_manipulator+0x30>
     276:	0c 94 df 02 	jmp	0x5be	; 0x5be <_ZN12EncoderMotor3runEv>
     27a:	0c 94 52 1b 	jmp	0x36a4	; 0x36a4 <_ZN5rs2327putcharEc>
     27e:	0c 94 1b 1a 	jmp	0x3436	; 0x3436 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     282:	0c 94 68 04 	jmp	0x8d0	; 0x8d0 <_ZN5Motor3runEv>
     286:	0c 94 2e 1a 	jmp	0x345c	; 0x345c <_ZN8emstreamlsE15ser_manipulator+0x62>
     28a:	0c 94 af 1b 	jmp	0x375e	; 0x375e <_ZN5rs23212clear_screenEv>
     28e:	0c 94 12 1a 	jmp	0x3424	; 0x3424 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     292:	0c 94 76 1b 	jmp	0x36ec	; 0x36ec <_ZN5rs2327getcharEv>

00000296 <__trampolines_end>:
     296:	2c 20       	and	r2, r12
     298:	54 43       	sbci	r21, 0x34	; 52
     29a:	43 30       	cpi	r20, 0x03	; 3
     29c:	43 43       	sbci	r20, 0x33	; 51
     29e:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a1 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a1:	2f 00                                               /.

000002a3 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b1 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b1:	54 69 6d 65 3a 20 00                                Time: .

000002b8 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b8:	4e 6f 76 20 32 38 20 32 30 31 37 00                 Nov 28 2017.

000002c4 <_ZZN9task_user11show_statusEvE3__c>:
     2c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     302:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000030d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     30d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     31d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34b:	6d 61 74 69 6f 6e 00                                mation.

00000352 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     352:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     362:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000373 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     373:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     383:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3a7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3b7:	68 65 20 41 56 52 00                                he AVR.

000003be <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3be:	20 68 65 6c 70 00                                    help.

000003c4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e3:	1b 5b 33 30 6d 00                                   .[30m.

000003e9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e9:	1b 5b 34 36 6d 00                                   .[46m.

000003ef <_ZZN9task_user3runEvE3__c_3>:
     3ef:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ff:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000040c <_ZZN9task_user3runEvE3__c_2>:
     40c:	3a 57 54 46 3f 00                                   :WTF?.

00000412 <_ZZN9task_user3runEvE3__c_1>:
     412:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     422:	65 00                                               e.

00000424 <_ZZN9task_user3runEvE3__c_0>:
     424:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000432 <_ZZN9task_user3runEvE3__c>:
     432:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     442:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000450 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     450:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045a <_ZZN8frt_task15emergency_resetEvE3__c>:
     45a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000469 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     469:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     479:	61 73 6b 20 00                                      ask .

0000047e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     47e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000048c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     48c:	20 63 72 65 61 74 65 64 00                           created.

00000495 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     495:	54 61 73 6b 20 00                                   Task .

0000049b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49b:	1b 5b 32 32 6d 00                                   .[22m.

000004a1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a1:	54 61 73 6b 3a 20 00                                Task: .

000004a8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a8:	1b 5b 31 6d 00                                      .[1m.

000004ad <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4ad:	1b 5b 32 32 6d 00                                   .[22m.

000004b3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004be <_ZZ17print_task_stacksP8emstreamE3__c>:
     4be:	1b 5b 31 6d 00                                      .[1m.

000004c3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c3:	09 09 00                                            ...

000004c6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4c6:	2f 00                                               /.

000004c8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d3:	09 2d 2d 2d 2d 00                                   .----.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004f6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4f6:	09 52 75 6e 73 00                                   .Runs.

000004fc <_ZZ15print_task_listP8emstreamE3__c_2>:
     4fc:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000508 <_ZZ15print_task_listP8emstreamE3__c_1>:
     508:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000519 <_ZZ15print_task_listP8emstreamE3__c_0>:
     519:	09 53 74 61 63 6b 00                                .Stack.

00000520 <_ZZ15print_task_listP8emstreamE3__c>:
     520:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52b:	09 00                                               ..

0000052d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     52d:	09 00                                               ..

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     52f:	2f 00                                               /.

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     533:	09 00                                               ..

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53b:	1b 5b 31 6d 00                                      .[1m.

00000540 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     545:	20 20 00                                              .

00000548 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     548:	0e 94 80 14 	call	0x2900	; 0x2900 <_ZN8frt_task22_call_users_run_methodEPS_>

0000054c <__ctors_start>:
     54c:	b6 1e       	adc	r11, r22

0000054e <__ctors_end>:
     54e:	11 24       	eor	r1, r1
     550:	1f be       	out	0x3f, r1	; 63
     552:	cf ef       	ldi	r28, 0xFF	; 255
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df e3       	ldi	r29, 0x3F	; 63
     558:	de bf       	out	0x3e, r29	; 62
     55a:	00 e0       	ldi	r16, 0x00	; 0
     55c:	0c bf       	out	0x3c, r16	; 60
     55e:	18 be       	out	0x38, r1	; 56
     560:	19 be       	out	0x39, r1	; 57
     562:	1a be       	out	0x3a, r1	; 58
     564:	1b be       	out	0x3b, r1	; 59

00000566 <__do_copy_data>:
     566:	10 e2       	ldi	r17, 0x20	; 32
     568:	a0 e0       	ldi	r26, 0x00	; 0
     56a:	b0 e2       	ldi	r27, 0x20	; 32
     56c:	e6 e0       	ldi	r30, 0x06	; 6
     56e:	f4 e4       	ldi	r31, 0x44	; 68
     570:	00 e0       	ldi	r16, 0x00	; 0
     572:	0b bf       	out	0x3b, r16	; 59
     574:	02 c0       	rjmp	.+4      	; 0x57a <__do_copy_data+0x14>
     576:	07 90       	elpm	r0, Z+
     578:	0d 92       	st	X+, r0
     57a:	a8 3c       	cpi	r26, 0xC8	; 200
     57c:	b1 07       	cpc	r27, r17
     57e:	d9 f7       	brne	.-10     	; 0x576 <__do_copy_data+0x10>
     580:	1b be       	out	0x3b, r1	; 59

00000582 <__do_clear_bss>:
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	a8 ec       	ldi	r26, 0xC8	; 200
     586:	b0 e2       	ldi	r27, 0x20	; 32
     588:	01 c0       	rjmp	.+2      	; 0x58c <.do_clear_bss_start>

0000058a <.do_clear_bss_loop>:
     58a:	1d 92       	st	X+, r1

0000058c <.do_clear_bss_start>:
     58c:	ac 36       	cpi	r26, 0x6C	; 108
     58e:	b2 07       	cpc	r27, r18
     590:	e1 f7       	brne	.-8      	; 0x58a <.do_clear_bss_loop>

00000592 <__do_global_ctors>:
     592:	12 e0       	ldi	r17, 0x02	; 2
     594:	c7 ea       	ldi	r28, 0xA7	; 167
     596:	d2 e0       	ldi	r29, 0x02	; 2
     598:	00 e0       	ldi	r16, 0x00	; 0
     59a:	06 c0       	rjmp	.+12     	; 0x5a8 <__do_global_ctors+0x16>
     59c:	21 97       	sbiw	r28, 0x01	; 1
     59e:	01 09       	sbc	r16, r1
     5a0:	80 2f       	mov	r24, r16
     5a2:	fe 01       	movw	r30, r28
     5a4:	0e 94 56 21 	call	0x42ac	; 0x42ac <__tablejump2__>
     5a8:	c6 3a       	cpi	r28, 0xA6	; 166
     5aa:	d1 07       	cpc	r29, r17
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 07       	cpc	r16, r24
     5b0:	a9 f7       	brne	.-22     	; 0x59c <__do_global_ctors+0xa>
     5b2:	0e 94 23 1e 	call	0x3c46	; 0x3c46 <main>
     5b6:	0c 94 01 22 	jmp	0x4402	; 0x4402 <_exit>

000005ba <__bad_interrupt>:
     5ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005be <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN12EncoderMotor3runEv+0x6>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5cc:	0e 94 58 10 	call	0x20b0	; 0x20b0 <xTaskGetTickCount>
     5d0:	69 83       	std	Y+1, r22	; 0x01
     5d2:	7a 83       	std	Y+2, r23	; 0x02
     5d4:	8b 83       	std	Y+3, r24	; 0x03
     5d6:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5d8:	e0 e8       	ldi	r30, 0x80	; 128
     5da:	f6 e0       	ldi	r31, 0x06	; 6
     5dc:	8c e0       	ldi	r24, 0x0C	; 12
     5de:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e0:	82 89       	ldd	r24, Z+18	; 0x12
     5e2:	83 60       	ori	r24, 0x03	; 3
     5e4:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5e6:	83 89       	ldd	r24, Z+19	; 0x13
     5e8:	83 60       	ori	r24, 0x03	; 3
     5ea:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	82 e7       	ldi	r24, 0x72	; 114
     5f2:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f4:	89 e0       	ldi	r24, 0x09	; 9
     5f6:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f8:	e0 e0       	ldi	r30, 0x00	; 0
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	88 e6       	ldi	r24, 0x68	; 104
     5fe:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	86 a3       	std	Z+38, r24	; 0x26
     606:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     60c:	0f 2e       	mov	r0, r31
     60e:	a1 2c       	mov	r10, r1
     610:	f9 e0       	ldi	r31, 0x09	; 9
     612:	bf 2e       	mov	r11, r31
     614:	f0 2d       	mov	r31, r0
     616:	f5 01       	movw	r30, r10
     618:	00 a1       	ldd	r16, Z+32	; 0x20
     61a:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     61c:	0f b6       	in	r0, 0x3f	; 63
     61e:	f8 94       	cli
     620:	0f 92       	push	r0
			the_data = new_data;
     622:	c8 01       	movw	r24, r16
     624:	88 0f       	add	r24, r24
     626:	99 1f       	adc	r25, r25
     628:	88 0f       	add	r24, r24
     62a:	99 1f       	adc	r25, r25
     62c:	88 0f       	add	r24, r24
     62e:	99 1f       	adc	r25, r25
     630:	80 0f       	add	r24, r16
     632:	91 1f       	adc	r25, r17
     634:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <thMotor>
     638:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <thMotor+0x1>
			portEXIT_CRITICAL ();
     63c:	0f 90       	pop	r0
     63e:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     640:	0f b6       	in	r0, 0x3f	; 63
     642:	f8 94       	cli
     644:	0f 92       	push	r0
			the_data = new_data;
     646:	c8 01       	movw	r24, r16
     648:	01 2e       	mov	r0, r17
     64a:	00 0c       	add	r0, r0
     64c:	aa 0b       	sbc	r26, r26
     64e:	bb 0b       	sbc	r27, r27
     650:	ac 01       	movw	r20, r24
     652:	bd 01       	movw	r22, r26
     654:	44 0f       	add	r20, r20
     656:	55 1f       	adc	r21, r21
     658:	66 1f       	adc	r22, r22
     65a:	77 1f       	adc	r23, r23
     65c:	3a 01       	movw	r6, r20
     65e:	4b 01       	movw	r8, r22
     660:	68 0e       	add	r6, r24
     662:	79 1e       	adc	r7, r25
     664:	8a 1e       	adc	r8, r26
     666:	9b 1e       	adc	r9, r27
     668:	c4 01       	movw	r24, r8
     66a:	b3 01       	movw	r22, r6
     66c:	24 e6       	ldi	r18, 0x64	; 100
     66e:	30 e0       	ldi	r19, 0x00	; 0
     670:	40 e0       	ldi	r20, 0x00	; 0
     672:	50 e0       	ldi	r21, 0x00	; 0
     674:	0e 94 37 21 	call	0x426e	; 0x426e <__divmodsi4>
     678:	20 93 58 31 	sts	0x3158, r18	; 0x803158 <linear_position>
     67c:	30 93 59 31 	sts	0x3159, r19	; 0x803159 <linear_position+0x1>
			portEXIT_CRITICAL ();
     680:	0f 90       	pop	r0
     682:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     684:	0f b6       	in	r0, 0x3f	; 63
     686:	f8 94       	cli
     688:	0f 92       	push	r0
			the_data = new_data;
     68a:	c8 01       	movw	r24, r16
     68c:	8c 19       	sub	r24, r12
     68e:	9d 09       	sbc	r25, r13
     690:	09 2e       	mov	r0, r25
     692:	00 0c       	add	r0, r0
     694:	aa 0b       	sbc	r26, r26
     696:	bb 0b       	sbc	r27, r27
     698:	ac 01       	movw	r20, r24
     69a:	bd 01       	movw	r22, r26
     69c:	44 0f       	add	r20, r20
     69e:	55 1f       	adc	r21, r21
     6a0:	66 1f       	adc	r22, r22
     6a2:	77 1f       	adc	r23, r23
     6a4:	84 0f       	add	r24, r20
     6a6:	95 1f       	adc	r25, r21
     6a8:	a6 1f       	adc	r26, r22
     6aa:	b7 1f       	adc	r27, r23
     6ac:	ac 01       	movw	r20, r24
     6ae:	bd 01       	movw	r22, r26
     6b0:	44 0f       	add	r20, r20
     6b2:	55 1f       	adc	r21, r21
     6b4:	66 1f       	adc	r22, r22
     6b6:	77 1f       	adc	r23, r23
     6b8:	44 0f       	add	r20, r20
     6ba:	55 1f       	adc	r21, r21
     6bc:	66 1f       	adc	r22, r22
     6be:	77 1f       	adc	r23, r23
     6c0:	84 0f       	add	r24, r20
     6c2:	95 1f       	adc	r25, r21
     6c4:	a6 1f       	adc	r26, r22
     6c6:	b7 1f       	adc	r27, r23
     6c8:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <thdMotor>
     6cc:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     6d0:	0f 90       	pop	r0
     6d2:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     6d4:	f7 01       	movw	r30, r14
     6d6:	86 85       	ldd	r24, Z+14	; 0x0e
     6d8:	97 85       	ldd	r25, Z+15	; 0x0f
     6da:	a0 89       	ldd	r26, Z+16	; 0x10
     6dc:	b1 89       	ldd	r27, Z+17	; 0x11
     6de:	01 96       	adiw	r24, 0x01	; 1
     6e0:	a1 1d       	adc	r26, r1
     6e2:	b1 1d       	adc	r27, r1
     6e4:	86 87       	std	Z+14, r24	; 0x0e
     6e6:	97 87       	std	Z+15, r25	; 0x0f
     6e8:	a0 8b       	std	Z+16, r26	; 0x10
     6ea:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     6ec:	41 e0       	ldi	r20, 0x01	; 1
     6ee:	50 e0       	ldi	r21, 0x00	; 0
     6f0:	60 e0       	ldi	r22, 0x00	; 0
     6f2:	70 e0       	ldi	r23, 0x00	; 0
     6f4:	ce 01       	movw	r24, r28
     6f6:	01 96       	adiw	r24, 0x01	; 1
     6f8:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vTaskDelayUntil>
		
		angularVelocity = ((int32_t) (encoder_count-last_encoder_count)*15)/dt;	// d_ec*60/(4*1000)/dt where dt is in ms so * 1000
		//*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6fc:	68 01       	movw	r12, r16
     6fe:	8b cf       	rjmp	.-234    	; 0x616 <_ZN12EncoderMotor3runEv+0x58>

00000700 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     70a:	0e 94 93 14 	call	0x2926	; 0x2926 <_ZN8frt_taskC1EPKchjP8emstream>
     70e:	8a e0       	ldi	r24, 0x0A	; 10
     710:	90 e2       	ldi	r25, 0x20	; 32
     712:	88 83       	st	Y, r24
     714:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     716:	df 91       	pop	r29
     718:	cf 91       	pop	r28
     71a:	1f 91       	pop	r17
     71c:	0f 91       	pop	r16
     71e:	08 95       	ret

00000720 <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     720:	cf 93       	push	r28
     722:	df 93       	push	r29
     724:	00 d0       	rcall	.+0      	; 0x726 <_ZN15EncoderPendulum3runEv+0x6>
     726:	1f 92       	push	r1
     728:	cd b7       	in	r28, 0x3d	; 61
     72a:	de b7       	in	r29, 0x3e	; 62
     72c:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     72e:	0e 94 58 10 	call	0x20b0	; 0x20b0 <xTaskGetTickCount>
     732:	69 83       	std	Y+1, r22	; 0x01
     734:	7a 83       	std	Y+2, r23	; 0x02
     736:	8b 83       	std	Y+3, r24	; 0x03
     738:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     73a:	e0 e8       	ldi	r30, 0x80	; 128
     73c:	f6 e0       	ldi	r31, 0x06	; 6
     73e:	83 e0       	ldi	r24, 0x03	; 3
     740:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     742:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     744:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     746:	e0 e8       	ldi	r30, 0x80	; 128
     748:	f1 e0       	ldi	r31, 0x01	; 1
     74a:	80 e7       	ldi	r24, 0x70	; 112
     74c:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     74e:	89 e0       	ldi	r24, 0x09	; 9
     750:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     752:	e0 e4       	ldi	r30, 0x40	; 64
     754:	f8 e0       	ldi	r31, 0x08	; 8
     756:	8a e6       	ldi	r24, 0x6A	; 106
     758:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     75a:	80 ea       	ldi	r24, 0xA0	; 160
     75c:	95 e0       	ldi	r25, 0x05	; 5
     75e:	86 a3       	std	Z+38, r24	; 0x26
     760:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     762:	81 e0       	ldi	r24, 0x01	; 1
     764:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     766:	68 94       	set
     768:	ee 24       	eor	r14, r14
     76a:	e6 f8       	bld	r14, 6
     76c:	ff 24       	eor	r15, r15
     76e:	f3 f8       	bld	r15, 3
     770:	f7 01       	movw	r30, r14
     772:	a0 a1       	ldd	r26, Z+32	; 0x20
     774:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     776:	0f b6       	in	r0, 0x3f	; 63
     778:	f8 94       	cli
     77a:	0f 92       	push	r0
			the_data = new_data;
     77c:	24 e6       	ldi	r18, 0x64	; 100
     77e:	30 e0       	ldi	r19, 0x00	; 0
     780:	0e 94 5f 21 	call	0x42be	; 0x42be <__usmulhisi3>
     784:	4b 01       	movw	r8, r22
     786:	5c 01       	movw	r10, r24
     788:	99 23       	and	r25, r25
     78a:	2c f4       	brge	.+10     	; 0x796 <_ZN15EncoderPendulum3runEv+0x76>
     78c:	f3 e0       	ldi	r31, 0x03	; 3
     78e:	8f 0e       	add	r8, r31
     790:	91 1c       	adc	r9, r1
     792:	a1 1c       	adc	r10, r1
     794:	b1 1c       	adc	r11, r1
     796:	d5 01       	movw	r26, r10
     798:	c4 01       	movw	r24, r8
     79a:	b5 95       	asr	r27
     79c:	a7 95       	ror	r26
     79e:	97 95       	ror	r25
     7a0:	87 95       	ror	r24
     7a2:	b5 95       	asr	r27
     7a4:	a7 95       	ror	r26
     7a6:	97 95       	ror	r25
     7a8:	87 95       	ror	r24
     7aa:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <thPendulum>
     7ae:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     7b2:	0f 90       	pop	r0
     7b4:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     7b6:	f8 01       	movw	r30, r16
     7b8:	86 85       	ldd	r24, Z+14	; 0x0e
     7ba:	97 85       	ldd	r25, Z+15	; 0x0f
     7bc:	a0 89       	ldd	r26, Z+16	; 0x10
     7be:	b1 89       	ldd	r27, Z+17	; 0x11
     7c0:	01 96       	adiw	r24, 0x01	; 1
     7c2:	a1 1d       	adc	r26, r1
     7c4:	b1 1d       	adc	r27, r1
     7c6:	86 87       	std	Z+14, r24	; 0x0e
     7c8:	97 87       	std	Z+15, r25	; 0x0f
     7ca:	a0 8b       	std	Z+16, r26	; 0x10
     7cc:	b1 8b       	std	Z+17, r27	; 0x11
     7ce:	44 e6       	ldi	r20, 0x64	; 100
     7d0:	50 e0       	ldi	r21, 0x00	; 0
     7d2:	60 e0       	ldi	r22, 0x00	; 0
     7d4:	70 e0       	ldi	r23, 0x00	; 0
     7d6:	ce 01       	movw	r24, r28
     7d8:	01 96       	adiw	r24, 0x01	; 1
     7da:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vTaskDelayUntil>
     7de:	c8 cf       	rjmp	.-112    	; 0x770 <_ZN15EncoderPendulum3runEv+0x50>

000007e0 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     7e0:	0f 93       	push	r16
     7e2:	1f 93       	push	r17
     7e4:	cf 93       	push	r28
     7e6:	df 93       	push	r29
     7e8:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7ea:	0e 94 93 14 	call	0x2926	; 0x2926 <_ZN8frt_taskC1EPKchjP8emstream>
     7ee:	82 e1       	ldi	r24, 0x12	; 18
     7f0:	90 e2       	ldi	r25, 0x20	; 32
     7f2:	88 83       	st	Y, r24
     7f4:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	1f 91       	pop	r17
     7fc:	0f 91       	pop	r16
     7fe:	08 95       	ret

00000800 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     800:	cf 93       	push	r28
     802:	df 93       	push	r29
     804:	00 d0       	rcall	.+0      	; 0x806 <_ZN13LimitSwitches3runEv+0x6>
     806:	1f 92       	push	r1
     808:	cd b7       	in	r28, 0x3d	; 61
     80a:	de b7       	in	r29, 0x3e	; 62
     80c:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     80e:	0e 94 58 10 	call	0x20b0	; 0x20b0 <xTaskGetTickCount>
     812:	69 83       	std	Y+1, r22	; 0x01
     814:	7a 83       	std	Y+2, r23	; 0x02
     816:	8b 83       	std	Y+3, r24	; 0x03
     818:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     81a:	e0 e6       	ldi	r30, 0x60	; 96
     81c:	f6 e0       	ldi	r31, 0x06	; 6
     81e:	81 e0       	ldi	r24, 0x01	; 1
     820:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     822:	84 e0       	ldi	r24, 0x04	; 4
     824:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     826:	88 e1       	ldi	r24, 0x18	; 24
     828:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     82a:	82 8b       	std	Z+18, r24	; 0x12
	bool rightLimit;
	bool leftLimit;
		
	while(1){
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     82c:	0f 2e       	mov	r0, r31
     82e:	f8 e6       	ldi	r31, 0x68	; 104
     830:	ef 2e       	mov	r14, r31
     832:	f6 e0       	ldi	r31, 0x06	; 6
     834:	ff 2e       	mov	r15, r31
     836:	f0 2d       	mov	r31, r0
     838:	f7 01       	movw	r30, r14
     83a:	80 81       	ld	r24, Z
     83c:	80 fd       	sbrc	r24, 0
     83e:	10 c0       	rjmp	.+32     	; 0x860 <_ZN13LimitSwitches3runEv+0x60>
		{	
			leftLimit = 1;
			*p_serial << "leftLimit: " << leftLimit << endl;
     840:	f8 01       	movw	r30, r16
     842:	c6 80       	ldd	r12, Z+6	; 0x06
     844:	d7 80       	ldd	r13, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     846:	66 e1       	ldi	r22, 0x16	; 22
     848:	70 e2       	ldi	r23, 0x20	; 32
     84a:	c6 01       	movw	r24, r12
     84c:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     850:	61 e0       	ldi	r22, 0x01	; 1
     852:	c6 01       	movw	r24, r12
     854:	0e 94 44 1a 	call	0x3488	; 0x3488 <_ZN8emstreamlsEb>
     858:	66 e0       	ldi	r22, 0x06	; 6
     85a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     85e:	13 c0       	rjmp	.+38     	; 0x886 <_ZN13LimitSwitches3runEv+0x86>
			
		}
		else if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     860:	f7 01       	movw	r30, r14
     862:	80 81       	ld	r24, Z
     864:	82 fd       	sbrc	r24, 2
     866:	0f c0       	rjmp	.+30     	; 0x886 <_ZN13LimitSwitches3runEv+0x86>
		{
			rightLimit = 1;
			*p_serial << "rightLimit: " << rightLimit << endl;
     868:	f8 01       	movw	r30, r16
     86a:	c6 80       	ldd	r12, Z+6	; 0x06
     86c:	d7 80       	ldd	r13, Z+7	; 0x07
     86e:	62 e2       	ldi	r22, 0x22	; 34
     870:	70 e2       	ldi	r23, 0x20	; 32
     872:	c6 01       	movw	r24, r12
     874:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     878:	61 e0       	ldi	r22, 0x01	; 1
     87a:	c6 01       	movw	r24, r12
     87c:	0e 94 44 1a 	call	0x3488	; 0x3488 <_ZN8emstreamlsEb>
     880:	66 e0       	ldi	r22, 0x06	; 6
     882:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
			leftLimit = 0;
			//*p_serial << "limits: " << rightLimit << leftLimit << endl;
		}
		
		// Increment counter for debugging
		runs++;
     886:	f8 01       	movw	r30, r16
     888:	86 85       	ldd	r24, Z+14	; 0x0e
     88a:	97 85       	ldd	r25, Z+15	; 0x0f
     88c:	a0 89       	ldd	r26, Z+16	; 0x10
     88e:	b1 89       	ldd	r27, Z+17	; 0x11
     890:	01 96       	adiw	r24, 0x01	; 1
     892:	a1 1d       	adc	r26, r1
     894:	b1 1d       	adc	r27, r1
     896:	86 87       	std	Z+14, r24	; 0x0e
     898:	97 87       	std	Z+15, r25	; 0x0f
     89a:	a0 8b       	std	Z+16, r26	; 0x10
     89c:	b1 8b       	std	Z+17, r27	; 0x11
     89e:	45 e0       	ldi	r20, 0x05	; 5
     8a0:	50 e0       	ldi	r21, 0x00	; 0
     8a2:	60 e0       	ldi	r22, 0x00	; 0
     8a4:	70 e0       	ldi	r23, 0x00	; 0
     8a6:	ce 01       	movw	r24, r28
     8a8:	01 96       	adiw	r24, 0x01	; 1
     8aa:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vTaskDelayUntil>
     8ae:	c4 cf       	rjmp	.-120    	; 0x838 <_ZN13LimitSwitches3runEv+0x38>

000008b0 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     8b0:	0f 93       	push	r16
     8b2:	1f 93       	push	r17
     8b4:	cf 93       	push	r28
     8b6:	df 93       	push	r29
     8b8:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8ba:	0e 94 93 14 	call	0x2926	; 0x2926 <_ZN8frt_taskC1EPKchjP8emstream>
     8be:	83 e3       	ldi	r24, 0x33	; 51
     8c0:	90 e2       	ldi	r25, 0x20	; 32
     8c2:	88 83       	st	Y, r24
     8c4:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     8c6:	df 91       	pop	r29
     8c8:	cf 91       	pop	r28
     8ca:	1f 91       	pop	r17
     8cc:	0f 91       	pop	r16
     8ce:	08 95       	ret

000008d0 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	00 d0       	rcall	.+0      	; 0x8d6 <_ZN5Motor3runEv+0x6>
     8d6:	00 d0       	rcall	.+0      	; 0x8d8 <_ZN5Motor3runEv+0x8>
     8d8:	cd b7       	in	r28, 0x3d	; 61
     8da:	de b7       	in	r29, 0x3e	; 62
     8dc:	3c 01       	movw	r6, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8de:	0e 94 58 10 	call	0x20b0	; 0x20b0 <xTaskGetTickCount>
     8e2:	69 83       	std	Y+1, r22	; 0x01
     8e4:	7a 83       	std	Y+2, r23	; 0x02
     8e6:	8b 83       	std	Y+3, r24	; 0x03
     8e8:	9c 83       	std	Y+4, r25	; 0x04

	dt = .008;
     8ea:	f3 01       	movw	r30, r6
     8ec:	fe 96       	adiw	r30, 0x3e	; 62
     8ee:	8f e6       	ldi	r24, 0x6F	; 111
     8f0:	92 e1       	ldi	r25, 0x12	; 18
     8f2:	a3 e0       	ldi	r26, 0x03	; 3
     8f4:	bc e3       	ldi	r27, 0x3C	; 60
     8f6:	80 83       	st	Z, r24
     8f8:	91 83       	std	Z+1, r25	; 0x01
     8fa:	a2 83       	std	Z+2, r26	; 0x02
     8fc:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	f3 01       	movw	r30, r6
     904:	84 af       	std	Z+60, r24	; 0x3c
     906:	95 af       	std	Z+61, r25	; 0x3d
		runs++;
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     908:	68 94       	set
     90a:	44 24       	eor	r4, r4
     90c:	41 f8       	bld	r4, 1
     90e:	51 2c       	mov	r5, r1
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     910:	0f 2e       	mov	r0, r31
     912:	ff e3       	ldi	r31, 0x3F	; 63
     914:	2f 2e       	mov	r2, r31
     916:	f0 2d       	mov	r31, r0
     918:	0f 2e       	mov	r0, r31
     91a:	fc e3       	ldi	r31, 0x3C	; 60
     91c:	3f 2e       	mov	r3, r31
     91e:	f0 2d       	mov	r31, r0
	dt = .008;
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     920:	f3 01       	movw	r30, r6
     922:	86 85       	ldd	r24, Z+14	; 0x0e
     924:	97 85       	ldd	r25, Z+15	; 0x0f
     926:	a0 89       	ldd	r26, Z+16	; 0x10
     928:	b1 89       	ldd	r27, Z+17	; 0x11
     92a:	01 96       	adiw	r24, 0x01	; 1
     92c:	a1 1d       	adc	r26, r1
     92e:	b1 1d       	adc	r27, r1
     930:	86 87       	std	Z+14, r24	; 0x0e
     932:	97 87       	std	Z+15, r25	; 0x0f
     934:	a0 8b       	std	Z+16, r26	; 0x10
     936:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     938:	42 8e       	std	Z+26, r4	; 0x1a
     93a:	53 8e       	std	Z+27, r5	; 0x1b

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
     93c:	16 8e       	std	Z+30, r1	; 0x1e
     93e:	17 8e       	std	Z+31, r1	; 0x1f
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     940:	2f 92       	push	r2
     942:	1f 92       	push	r1
     944:	1f 92       	push	r1
     946:	1f 92       	push	r1
     948:	3f 92       	push	r3
     94a:	f3 e2       	ldi	r31, 0x23	; 35
     94c:	ff 93       	push	r31
     94e:	27 ed       	ldi	r18, 0xD7	; 215
     950:	2f 93       	push	r18
     952:	3a e0       	ldi	r19, 0x0A	; 10
     954:	3f 93       	push	r19
     956:	0f 2e       	mov	r0, r31
     958:	fd ec       	ldi	r31, 0xCD	; 205
     95a:	8f 2e       	mov	r8, r31
     95c:	fc ec       	ldi	r31, 0xCC	; 204
     95e:	9f 2e       	mov	r9, r31
     960:	a9 2c       	mov	r10, r9
     962:	fd e3       	ldi	r31, 0x3D	; 61
     964:	bf 2e       	mov	r11, r31
     966:	f0 2d       	mov	r31, r0
     968:	0f 2e       	mov	r0, r31
     96a:	f4 e1       	ldi	r31, 0x14	; 20
     96c:	cf 2e       	mov	r12, r31
     96e:	fe ea       	ldi	r31, 0xAE	; 174
     970:	df 2e       	mov	r13, r31
     972:	ff e8       	ldi	r31, 0x8F	; 143
     974:	ef 2e       	mov	r14, r31
     976:	ff eb       	ldi	r31, 0xBF	; 191
     978:	ff 2e       	mov	r15, r31
     97a:	f0 2d       	mov	r31, r0
     97c:	04 e1       	ldi	r16, 0x14	; 20
     97e:	1e ea       	ldi	r17, 0xAE	; 174
     980:	2f e8       	ldi	r18, 0x8F	; 143
     982:	3f e3       	ldi	r19, 0x3F	; 63
     984:	b5 01       	movw	r22, r10
     986:	a4 01       	movw	r20, r8
     988:	ce 01       	movw	r24, r28
     98a:	05 96       	adiw	r24, 0x05	; 5
     98c:	0e 94 9d 05 	call	0xb3a	; 0xb3a <_ZN3PIDC1Edddddd>
		double Tset = pidTorque.calculate(omegam_set, omegam_measured);
     990:	f3 01       	movw	r30, r6
     992:	66 8d       	ldd	r22, Z+30	; 0x1e
     994:	77 8d       	ldd	r23, Z+31	; 0x1f
     996:	02 8d       	ldd	r16, Z+26	; 0x1a
     998:	13 8d       	ldd	r17, Z+27	; 0x1b
     99a:	07 2e       	mov	r0, r23
     99c:	00 0c       	add	r0, r0
     99e:	88 0b       	sbc	r24, r24
     9a0:	99 0b       	sbc	r25, r25
     9a2:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <__floatsisf>
     9a6:	6b 01       	movw	r12, r22
     9a8:	7c 01       	movw	r14, r24
     9aa:	b8 01       	movw	r22, r16
     9ac:	11 0f       	add	r17, r17
     9ae:	88 0b       	sbc	r24, r24
     9b0:	99 0b       	sbc	r25, r25
     9b2:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <__floatsisf>
     9b6:	ab 01       	movw	r20, r22
     9b8:	bc 01       	movw	r22, r24
     9ba:	97 01       	movw	r18, r14
     9bc:	86 01       	movw	r16, r12
     9be:	ce 01       	movw	r24, r28
     9c0:	05 96       	adiw	r24, 0x05	; 5
     9c2:	0e 94 c4 06 	call	0xd88	; 0xd88 <_ZN3PID9calculateEdd>
     9c6:	6b 01       	movw	r12, r22
     9c8:	7c 01       	movw	r14, r24
		//printf("val:% 7.3f inc:% 7.3f\n", omegam_measured, inc);
		omegam_measured += inc;
     9ca:	f3 01       	movw	r30, r6
     9cc:	24 ad       	ldd	r18, Z+60	; 0x3c
     9ce:	35 ad       	ldd	r19, Z+61	; 0x3d
     9d0:	86 8d       	ldd	r24, Z+30	; 0x1e
     9d2:	97 8d       	ldd	r25, Z+31	; 0x1f
     9d4:	82 0f       	add	r24, r18
     9d6:	93 1f       	adc	r25, r19
     9d8:	86 8f       	std	Z+30, r24	; 0x1e
     9da:	97 8f       	std	Z+31, r25	; 0x1f

		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     9dc:	10 a6       	std	Z+40, r1	; 0x28
     9de:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     9e0:	60 a5       	ldd	r22, Z+40	; 0x28
     9e2:	71 a5       	ldd	r23, Z+41	; 0x29
     9e4:	07 2e       	mov	r0, r23
     9e6:	00 0c       	add	r0, r0
     9e8:	88 0b       	sbc	r24, r24
     9ea:	99 0b       	sbc	r25, r25
     9ec:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <__floatsisf>
     9f0:	9b 01       	movw	r18, r22
     9f2:	ac 01       	movw	r20, r24
     9f4:	c7 01       	movw	r24, r14
     9f6:	b6 01       	movw	r22, r12
     9f8:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <__divsf3>
     9fc:	0e 94 ab 1f 	call	0x3f56	; 0x3f56 <__fixsfsi>
     a00:	f3 01       	movw	r30, r6
     a02:	64 a3       	std	Z+36, r22	; 0x24
     a04:	75 a3       	std	Z+37, r23	; 0x25

		// Saturater for current
		
		if(Im_set > 17.4) {
     a06:	64 a1       	ldd	r22, Z+36	; 0x24
     a08:	75 a1       	ldd	r23, Z+37	; 0x25
     a0a:	07 2e       	mov	r0, r23
     a0c:	00 0c       	add	r0, r0
     a0e:	88 0b       	sbc	r24, r24
     a10:	99 0b       	sbc	r25, r25
     a12:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <__floatsisf>
     a16:	cd bf       	out	0x3d, r28	; 61
     a18:	de bf       	out	0x3e, r29	; 62
     a1a:	23 e3       	ldi	r18, 0x33	; 51
     a1c:	33 e3       	ldi	r19, 0x33	; 51
     a1e:	4b e8       	ldi	r20, 0x8B	; 139
     a20:	51 e4       	ldi	r21, 0x41	; 65
     a22:	0e 94 93 20 	call	0x4126	; 0x4126 <__gesf2>
     a26:	18 16       	cp	r1, r24
     a28:	34 f4       	brge	.+12     	; 0xa36 <_ZN5Motor3runEv+0x166>
			Im_set = 17.4;
     a2a:	21 e1       	ldi	r18, 0x11	; 17
     a2c:	30 e0       	ldi	r19, 0x00	; 0
     a2e:	f3 01       	movw	r30, r6
     a30:	24 a3       	std	Z+36, r18	; 0x24
     a32:	35 a3       	std	Z+37, r19	; 0x25
     a34:	16 c0       	rjmp	.+44     	; 0xa62 <_ZN5Motor3runEv+0x192>
		} else if(Im_set < -17.4) {
     a36:	f3 01       	movw	r30, r6
     a38:	64 a1       	ldd	r22, Z+36	; 0x24
     a3a:	75 a1       	ldd	r23, Z+37	; 0x25
     a3c:	07 2e       	mov	r0, r23
     a3e:	00 0c       	add	r0, r0
     a40:	88 0b       	sbc	r24, r24
     a42:	99 0b       	sbc	r25, r25
     a44:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <__floatsisf>
     a48:	23 e3       	ldi	r18, 0x33	; 51
     a4a:	33 e3       	ldi	r19, 0x33	; 51
     a4c:	4b e8       	ldi	r20, 0x8B	; 139
     a4e:	51 ec       	ldi	r21, 0xC1	; 193
     a50:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <__cmpsf2>
     a54:	88 23       	and	r24, r24
     a56:	2c f4       	brge	.+10     	; 0xa62 <_ZN5Motor3runEv+0x192>
			Im_set = -17.4;
     a58:	2f ee       	ldi	r18, 0xEF	; 239
     a5a:	3f ef       	ldi	r19, 0xFF	; 255
     a5c:	f3 01       	movw	r30, r6
     a5e:	24 a3       	std	Z+36, r18	; 0x24
     a60:	35 a3       	std	Z+37, r19	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     a62:	f3 01       	movw	r30, r6
     a64:	16 aa       	std	Z+54, r1	; 0x36
     a66:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     a68:	60 a5       	ldd	r22, Z+40	; 0x28
     a6a:	71 a5       	ldd	r23, Z+41	; 0x29
     a6c:	06 a9       	ldd	r16, Z+54	; 0x36
     a6e:	17 a9       	ldd	r17, Z+55	; 0x37
     a70:	07 2e       	mov	r0, r23
     a72:	00 0c       	add	r0, r0
     a74:	88 0b       	sbc	r24, r24
     a76:	99 0b       	sbc	r25, r25
     a78:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <__floatsisf>
     a7c:	20 e5       	ldi	r18, 0x50	; 80
     a7e:	3a e6       	ldi	r19, 0x6A	; 106
     a80:	41 ea       	ldi	r20, 0xA1	; 161
     a82:	57 e4       	ldi	r21, 0x47	; 71
     a84:	0e 94 98 20 	call	0x4130	; 0x4130 <__mulsf3>
     a88:	6b 01       	movw	r12, r22
     a8a:	7c 01       	movw	r14, r24
     a8c:	b8 01       	movw	r22, r16
     a8e:	11 0f       	add	r17, r17
     a90:	88 0b       	sbc	r24, r24
     a92:	99 0b       	sbc	r25, r25
     a94:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <__floatsisf>
     a98:	9b 01       	movw	r18, r22
     a9a:	ac 01       	movw	r20, r24
     a9c:	c7 01       	movw	r24, r14
     a9e:	b6 01       	movw	r22, r12
     aa0:	0e 94 98 20 	call	0x4130	; 0x4130 <__mulsf3>
     aa4:	0e 94 ab 1f 	call	0x3f56	; 0x3f56 <__fixsfsi>
     aa8:	f3 01       	movw	r30, r6
     aaa:	62 ab       	std	Z+50, r22	; 0x32
     aac:	73 ab       	std	Z+51, r23	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     aae:	46 a9       	ldd	r20, Z+54	; 0x36
     ab0:	57 a9       	ldd	r21, Z+55	; 0x37
     ab2:	26 8d       	ldd	r18, Z+30	; 0x1e
     ab4:	37 8d       	ldd	r19, Z+31	; 0x1f
     ab6:	42 9f       	mul	r20, r18
     ab8:	c0 01       	movw	r24, r0
     aba:	43 9f       	mul	r20, r19
     abc:	90 0d       	add	r25, r0
     abe:	52 9f       	mul	r21, r18
     ac0:	90 0d       	add	r25, r0
     ac2:	11 24       	eor	r1, r1
     ac4:	84 ab       	std	Z+52, r24	; 0x34
     ac6:	95 ab       	std	Z+53, r25	; 0x35

		V_m = V_R + V_E;
     ac8:	20 a9       	ldd	r18, Z+48	; 0x30
     aca:	31 a9       	ldd	r19, Z+49	; 0x31
     acc:	84 a9       	ldd	r24, Z+52	; 0x34
     ace:	95 a9       	ldd	r25, Z+53	; 0x35
     ad0:	82 0f       	add	r24, r18
     ad2:	93 1f       	adc	r25, r19
     ad4:	80 af       	std	Z+56, r24	; 0x38
     ad6:	91 af       	std	Z+57, r25	; 0x39

		// Saturater for voltage
		if (V_m > 24) {
     ad8:	80 ad       	ldd	r24, Z+56	; 0x38
     ada:	91 ad       	ldd	r25, Z+57	; 0x39
     adc:	49 97       	sbiw	r24, 0x19	; 25
     ade:	2c f0       	brlt	.+10     	; 0xaea <_ZN5Motor3runEv+0x21a>
			V_m = 24;
     ae0:	28 e1       	ldi	r18, 0x18	; 24
     ae2:	30 e0       	ldi	r19, 0x00	; 0
     ae4:	20 af       	std	Z+56, r18	; 0x38
     ae6:	31 af       	std	Z+57, r19	; 0x39
     ae8:	0b c0       	rjmp	.+22     	; 0xb00 <_ZN5Motor3runEv+0x230>
		} else if(V_m < -24) {
     aea:	f3 01       	movw	r30, r6
     aec:	80 ad       	ldd	r24, Z+56	; 0x38
     aee:	91 ad       	ldd	r25, Z+57	; 0x39
     af0:	88 3e       	cpi	r24, 0xE8	; 232
     af2:	9f 4f       	sbci	r25, 0xFF	; 255
     af4:	2c f4       	brge	.+10     	; 0xb00 <_ZN5Motor3runEv+0x230>
			V_m = -24;
     af6:	28 ee       	ldi	r18, 0xE8	; 232
     af8:	3f ef       	ldi	r19, 0xFF	; 255
     afa:	f3 01       	movw	r30, r6
     afc:	20 af       	std	Z+56, r18	; 0x38
     afe:	31 af       	std	Z+57, r19	; 0x39
     b00:	41 e0       	ldi	r20, 0x01	; 1
     b02:	50 e0       	ldi	r21, 0x00	; 0
     b04:	60 e0       	ldi	r22, 0x00	; 0
     b06:	70 e0       	ldi	r23, 0x00	; 0
     b08:	ce 01       	movw	r24, r28
     b0a:	01 96       	adiw	r24, 0x01	; 1
     b0c:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vTaskDelayUntil>
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     b10:	ce 01       	movw	r24, r28
     b12:	05 96       	adiw	r24, 0x05	; 5
     b14:	0e 94 04 06 	call	0xc08	; 0xc08 <_ZN3PIDD1Ev>
	portTickType previousTicks = xTaskGetTickCount ();

	dt = .008;
	inc = 1;
	
	while(1){
     b18:	03 cf       	rjmp	.-506    	; 0x920 <_ZN5Motor3runEv+0x50>

00000b1a <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     b1a:	0f 93       	push	r16
     b1c:	1f 93       	push	r17
     b1e:	cf 93       	push	r28
     b20:	df 93       	push	r29
     b22:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     b24:	0e 94 93 14 	call	0x2926	; 0x2926 <_ZN8frt_taskC1EPKchjP8emstream>
     b28:	8b e3       	ldi	r24, 0x3B	; 59
     b2a:	90 e2       	ldi	r25, 0x20	; 32
     b2c:	88 83       	st	Y, r24
     b2e:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	1f 91       	pop	r17
     b36:	0f 91       	pop	r16
     b38:	08 95       	ret

00000b3a <_ZN3PIDC1Edddddd>:
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}
     b3a:	2f 92       	push	r2
     b3c:	3f 92       	push	r3
     b3e:	4f 92       	push	r4
     b40:	5f 92       	push	r5
     b42:	6f 92       	push	r6
     b44:	7f 92       	push	r7
     b46:	8f 92       	push	r8
     b48:	9f 92       	push	r9
     b4a:	af 92       	push	r10
     b4c:	bf 92       	push	r11
     b4e:	cf 92       	push	r12
     b50:	df 92       	push	r13
     b52:	ef 92       	push	r14
     b54:	ff 92       	push	r15
     b56:	0f 93       	push	r16
     b58:	1f 93       	push	r17
     b5a:	cf 93       	push	r28
     b5c:	df 93       	push	r29
     b5e:	00 d0       	rcall	.+0      	; 0xb60 <_ZN3PIDC1Edddddd+0x26>
     b60:	1f 92       	push	r1
     b62:	cd b7       	in	r28, 0x3d	; 61
     b64:	de b7       	in	r29, 0x3e	; 62
     b66:	1c 01       	movw	r2, r24
     b68:	2a 01       	movw	r4, r20
     b6a:	3b 01       	movw	r6, r22
     b6c:	09 83       	std	Y+1, r16	; 0x01
     b6e:	1a 83       	std	Y+2, r17	; 0x02
     b70:	2b 83       	std	Y+3, r18	; 0x03
     b72:	3c 83       	std	Y+4, r19	; 0x04
     b74:	80 e2       	ldi	r24, 0x20	; 32
     b76:	90 e0       	ldi	r25, 0x00	; 0
     b78:	0e 94 0d 19 	call	0x321a	; 0x321a <_Znwj>
     b7c:	fc 01       	movw	r30, r24
     b7e:	40 82       	st	Z, r4
     b80:	51 82       	std	Z+1, r5	; 0x01
     b82:	62 82       	std	Z+2, r6	; 0x02
     b84:	73 82       	std	Z+3, r7	; 0x03
     b86:	89 81       	ldd	r24, Y+1	; 0x01
     b88:	9a 81       	ldd	r25, Y+2	; 0x02
     b8a:	ab 81       	ldd	r26, Y+3	; 0x03
     b8c:	bc 81       	ldd	r27, Y+4	; 0x04
     b8e:	84 83       	std	Z+4, r24	; 0x04
     b90:	95 83       	std	Z+5, r25	; 0x05
     b92:	a6 83       	std	Z+6, r26	; 0x06
     b94:	b7 83       	std	Z+7, r27	; 0x07
     b96:	c0 86       	std	Z+8, r12	; 0x08
     b98:	d1 86       	std	Z+9, r13	; 0x09
     b9a:	e2 86       	std	Z+10, r14	; 0x0a
     b9c:	f3 86       	std	Z+11, r15	; 0x0b
     b9e:	84 86       	std	Z+12, r8	; 0x0c
     ba0:	95 86       	std	Z+13, r9	; 0x0d
     ba2:	a6 86       	std	Z+14, r10	; 0x0e
     ba4:	b7 86       	std	Z+15, r11	; 0x0f
     ba6:	4a 8d       	ldd	r20, Y+26	; 0x1a
     ba8:	5b 8d       	ldd	r21, Y+27	; 0x1b
     baa:	6c 8d       	ldd	r22, Y+28	; 0x1c
     bac:	7d 8d       	ldd	r23, Y+29	; 0x1d
     bae:	40 8b       	std	Z+16, r20	; 0x10
     bb0:	51 8b       	std	Z+17, r21	; 0x11
     bb2:	62 8b       	std	Z+18, r22	; 0x12
     bb4:	73 8b       	std	Z+19, r23	; 0x13
     bb6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bb8:	9f 8d       	ldd	r25, Y+31	; 0x1f
     bba:	a8 a1       	ldd	r26, Y+32	; 0x20
     bbc:	b9 a1       	ldd	r27, Y+33	; 0x21
     bbe:	84 8b       	std	Z+20, r24	; 0x14
     bc0:	95 8b       	std	Z+21, r25	; 0x15
     bc2:	a6 8b       	std	Z+22, r26	; 0x16
     bc4:	b7 8b       	std	Z+23, r27	; 0x17
     bc6:	10 8e       	std	Z+24, r1	; 0x18
     bc8:	11 8e       	std	Z+25, r1	; 0x19
     bca:	12 8e       	std	Z+26, r1	; 0x1a
     bcc:	13 8e       	std	Z+27, r1	; 0x1b
     bce:	14 8e       	std	Z+28, r1	; 0x1c
     bd0:	15 8e       	std	Z+29, r1	; 0x1d
     bd2:	16 8e       	std	Z+30, r1	; 0x1e
     bd4:	17 8e       	std	Z+31, r1	; 0x1f
     bd6:	d1 01       	movw	r26, r2
     bd8:	ed 93       	st	X+, r30
     bda:	fc 93       	st	X, r31
     bdc:	24 96       	adiw	r28, 0x04	; 4
     bde:	cd bf       	out	0x3d, r28	; 61
     be0:	de bf       	out	0x3e, r29	; 62
     be2:	df 91       	pop	r29
     be4:	cf 91       	pop	r28
     be6:	1f 91       	pop	r17
     be8:	0f 91       	pop	r16
     bea:	ff 90       	pop	r15
     bec:	ef 90       	pop	r14
     bee:	df 90       	pop	r13
     bf0:	cf 90       	pop	r12
     bf2:	bf 90       	pop	r11
     bf4:	af 90       	pop	r10
     bf6:	9f 90       	pop	r9
     bf8:	8f 90       	pop	r8
     bfa:	7f 90       	pop	r7
     bfc:	6f 90       	pop	r6
     bfe:	5f 90       	pop	r5
     c00:	4f 90       	pop	r4
     c02:	3f 90       	pop	r3
     c04:	2f 90       	pop	r2
     c06:	08 95       	ret

00000c08 <_ZN3PIDD1Ev>:
     c08:	fc 01       	movw	r30, r24
     c0a:	80 81       	ld	r24, Z
     c0c:	91 81       	ldd	r25, Z+1	; 0x01
     c0e:	00 97       	sbiw	r24, 0x00	; 0
     c10:	11 f0       	breq	.+4      	; 0xc16 <_ZN3PIDD1Ev+0xe>
     c12:	0e 94 10 19 	call	0x3220	; 0x3220 <_ZdlPv>
     c16:	08 95       	ret

00000c18 <_ZN7PIDImpl9calculateEdd>:

double PIDImpl::calculate( double setpoint, double pv )
{
     c18:	4f 92       	push	r4
     c1a:	5f 92       	push	r5
     c1c:	6f 92       	push	r6
     c1e:	7f 92       	push	r7
     c20:	8f 92       	push	r8
     c22:	9f 92       	push	r9
     c24:	af 92       	push	r10
     c26:	bf 92       	push	r11
     c28:	cf 92       	push	r12
     c2a:	df 92       	push	r13
     c2c:	ef 92       	push	r14
     c2e:	ff 92       	push	r15
     c30:	0f 93       	push	r16
     c32:	1f 93       	push	r17
     c34:	cf 93       	push	r28
     c36:	df 93       	push	r29
     c38:	00 d0       	rcall	.+0      	; 0xc3a <_ZN7PIDImpl9calculateEdd+0x22>
     c3a:	00 d0       	rcall	.+0      	; 0xc3c <_ZN7PIDImpl9calculateEdd+0x24>
     c3c:	cd b7       	in	r28, 0x3d	; 61
     c3e:	de b7       	in	r29, 0x3e	; 62
     c40:	8d 83       	std	Y+5, r24	; 0x05
     c42:	9e 83       	std	Y+6, r25	; 0x06
     c44:	cb 01       	movw	r24, r22
     c46:	ba 01       	movw	r22, r20
    
    // Calculate error
    double error = setpoint - pv;
     c48:	a9 01       	movw	r20, r18
     c4a:	98 01       	movw	r18, r16
     c4c:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <__subsf3>
     c50:	6b 01       	movw	r12, r22
     c52:	7c 01       	movw	r14, r24

    // Proportional term
    double Pout = _Kp * error;
     c54:	ed 81       	ldd	r30, Y+5	; 0x05
     c56:	fe 81       	ldd	r31, Y+6	; 0x06
     c58:	24 85       	ldd	r18, Z+12	; 0x0c
     c5a:	35 85       	ldd	r19, Z+13	; 0x0d
     c5c:	46 85       	ldd	r20, Z+14	; 0x0e
     c5e:	57 85       	ldd	r21, Z+15	; 0x0f
     c60:	0e 94 98 20 	call	0x4130	; 0x4130 <__mulsf3>
     c64:	69 83       	std	Y+1, r22	; 0x01
     c66:	7a 83       	std	Y+2, r23	; 0x02
     c68:	8b 83       	std	Y+3, r24	; 0x03
     c6a:	9c 83       	std	Y+4, r25	; 0x04

    // Integral term
    _integral += error * _dt;
     c6c:	ed 81       	ldd	r30, Y+5	; 0x05
     c6e:	fe 81       	ldd	r31, Y+6	; 0x06
     c70:	40 80       	ld	r4, Z
     c72:	51 80       	ldd	r5, Z+1	; 0x01
     c74:	62 80       	ldd	r6, Z+2	; 0x02
     c76:	73 80       	ldd	r7, Z+3	; 0x03
     c78:	a3 01       	movw	r20, r6
     c7a:	92 01       	movw	r18, r4
     c7c:	c7 01       	movw	r24, r14
     c7e:	b6 01       	movw	r22, r12
     c80:	0e 94 98 20 	call	0x4130	; 0x4130 <__mulsf3>
     c84:	ed 81       	ldd	r30, Y+5	; 0x05
     c86:	fe 81       	ldd	r31, Y+6	; 0x06
     c88:	24 8d       	ldd	r18, Z+28	; 0x1c
     c8a:	35 8d       	ldd	r19, Z+29	; 0x1d
     c8c:	46 8d       	ldd	r20, Z+30	; 0x1e
     c8e:	57 8d       	ldd	r21, Z+31	; 0x1f
     c90:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <__addsf3>
     c94:	4b 01       	movw	r8, r22
     c96:	5c 01       	movw	r10, r24
     c98:	ed 81       	ldd	r30, Y+5	; 0x05
     c9a:	fe 81       	ldd	r31, Y+6	; 0x06
     c9c:	64 8f       	std	Z+28, r22	; 0x1c
     c9e:	75 8f       	std	Z+29, r23	; 0x1d
     ca0:	86 8f       	std	Z+30, r24	; 0x1e
     ca2:	97 8f       	std	Z+31, r25	; 0x1f
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     ca4:	20 8d       	ldd	r18, Z+24	; 0x18
     ca6:	31 8d       	ldd	r19, Z+25	; 0x19
     ca8:	42 8d       	ldd	r20, Z+26	; 0x1a
     caa:	53 8d       	ldd	r21, Z+27	; 0x1b
     cac:	c7 01       	movw	r24, r14
     cae:	b6 01       	movw	r22, r12
     cb0:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <__subsf3>
     cb4:	a3 01       	movw	r20, r6
     cb6:	92 01       	movw	r18, r4
     cb8:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <__divsf3>
     cbc:	ed 81       	ldd	r30, Y+5	; 0x05
     cbe:	fe 81       	ldd	r31, Y+6	; 0x06
     cc0:	20 89       	ldd	r18, Z+16	; 0x10
     cc2:	31 89       	ldd	r19, Z+17	; 0x11
     cc4:	42 89       	ldd	r20, Z+18	; 0x12
     cc6:	53 89       	ldd	r21, Z+19	; 0x13
     cc8:	0e 94 98 20 	call	0x4130	; 0x4130 <__mulsf3>
     ccc:	2b 01       	movw	r4, r22
     cce:	3c 01       	movw	r6, r24
     cd0:	ed 81       	ldd	r30, Y+5	; 0x05
     cd2:	fe 81       	ldd	r31, Y+6	; 0x06
     cd4:	24 89       	ldd	r18, Z+20	; 0x14
     cd6:	35 89       	ldd	r19, Z+21	; 0x15
     cd8:	46 89       	ldd	r20, Z+22	; 0x16
     cda:	57 89       	ldd	r21, Z+23	; 0x17
     cdc:	c5 01       	movw	r24, r10
     cde:	b4 01       	movw	r22, r8
     ce0:	0e 94 98 20 	call	0x4130	; 0x4130 <__mulsf3>
     ce4:	29 81       	ldd	r18, Y+1	; 0x01
     ce6:	3a 81       	ldd	r19, Y+2	; 0x02
     ce8:	4b 81       	ldd	r20, Y+3	; 0x03
     cea:	5c 81       	ldd	r21, Y+4	; 0x04
     cec:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <__addsf3>
     cf0:	9b 01       	movw	r18, r22
     cf2:	ac 01       	movw	r20, r24
     cf4:	c3 01       	movw	r24, r6
     cf6:	b2 01       	movw	r22, r4
     cf8:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <__addsf3>
     cfc:	b6 2e       	mov	r11, r22
     cfe:	a7 2e       	mov	r10, r23
     d00:	98 2e       	mov	r9, r24
     d02:	89 2e       	mov	r8, r25

    // Restrict to max/min
    if( output > _max )
     d04:	ed 81       	ldd	r30, Y+5	; 0x05
     d06:	fe 81       	ldd	r31, Y+6	; 0x06
     d08:	74 80       	ldd	r7, Z+4	; 0x04
     d0a:	65 80       	ldd	r6, Z+5	; 0x05
     d0c:	56 80       	ldd	r5, Z+6	; 0x06
     d0e:	47 80       	ldd	r4, Z+7	; 0x07
     d10:	27 2d       	mov	r18, r7
     d12:	36 2d       	mov	r19, r6
     d14:	45 2d       	mov	r20, r5
     d16:	54 2d       	mov	r21, r4
     d18:	0e 94 93 20 	call	0x4126	; 0x4126 <__gesf2>
     d1c:	18 16       	cp	r1, r24
     d1e:	b4 f0       	brlt	.+44     	; 0xd4c <_ZN7PIDImpl9calculateEdd+0x134>
        output = _max;
    else if( output < _min )
     d20:	ed 81       	ldd	r30, Y+5	; 0x05
     d22:	fe 81       	ldd	r31, Y+6	; 0x06
     d24:	70 84       	ldd	r7, Z+8	; 0x08
     d26:	61 84       	ldd	r6, Z+9	; 0x09
     d28:	52 84       	ldd	r5, Z+10	; 0x0a
     d2a:	43 84       	ldd	r4, Z+11	; 0x0b
     d2c:	27 2d       	mov	r18, r7
     d2e:	36 2d       	mov	r19, r6
     d30:	45 2d       	mov	r20, r5
     d32:	54 2d       	mov	r21, r4
     d34:	6b 2d       	mov	r22, r11
     d36:	7a 2d       	mov	r23, r10
     d38:	89 2d       	mov	r24, r9
     d3a:	98 2d       	mov	r25, r8
     d3c:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <__cmpsf2>
     d40:	88 23       	and	r24, r24
     d42:	24 f0       	brlt	.+8      	; 0xd4c <_ZN7PIDImpl9calculateEdd+0x134>
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     d44:	7b 2c       	mov	r7, r11
     d46:	6a 2c       	mov	r6, r10
     d48:	59 2c       	mov	r5, r9
     d4a:	48 2c       	mov	r4, r8
        output = _max;
    else if( output < _min )
        output = _min;

    // Save error to previous error
    _pre_error = error;
     d4c:	ed 81       	ldd	r30, Y+5	; 0x05
     d4e:	fe 81       	ldd	r31, Y+6	; 0x06
     d50:	c0 8e       	std	Z+24, r12	; 0x18
     d52:	d1 8e       	std	Z+25, r13	; 0x19
     d54:	e2 8e       	std	Z+26, r14	; 0x1a
     d56:	f3 8e       	std	Z+27, r15	; 0x1b

    return output;
}
     d58:	67 2d       	mov	r22, r7
     d5a:	76 2d       	mov	r23, r6
     d5c:	85 2d       	mov	r24, r5
     d5e:	94 2d       	mov	r25, r4
     d60:	26 96       	adiw	r28, 0x06	; 6
     d62:	cd bf       	out	0x3d, r28	; 61
     d64:	de bf       	out	0x3e, r29	; 62
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	1f 91       	pop	r17
     d6c:	0f 91       	pop	r16
     d6e:	ff 90       	pop	r15
     d70:	ef 90       	pop	r14
     d72:	df 90       	pop	r13
     d74:	cf 90       	pop	r12
     d76:	bf 90       	pop	r11
     d78:	af 90       	pop	r10
     d7a:	9f 90       	pop	r9
     d7c:	8f 90       	pop	r8
     d7e:	7f 90       	pop	r7
     d80:	6f 90       	pop	r6
     d82:	5f 90       	pop	r5
     d84:	4f 90       	pop	r4
     d86:	08 95       	ret

00000d88 <_ZN3PID9calculateEdd>:
PID::PID( double dt, double max, double min, double Kp, double Kd, double Ki )
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
double PID::calculate( double setpoint, double pv )
{
     d88:	0f 93       	push	r16
     d8a:	1f 93       	push	r17
    return pimpl->calculate(setpoint,pv);
     d8c:	fc 01       	movw	r30, r24
     d8e:	80 81       	ld	r24, Z
     d90:	91 81       	ldd	r25, Z+1	; 0x01
     d92:	0e 94 0c 06 	call	0xc18	; 0xc18 <_ZN7PIDImpl9calculateEdd>
}
     d96:	1f 91       	pop	r17
     d98:	0f 91       	pop	r16
     d9a:	08 95       	ret

00000d9c <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     d9c:	0f 93       	push	r16
     d9e:	1f 93       	push	r17
     da0:	cf 93       	push	r28
     da2:	df 93       	push	r29
     da4:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     da6:	0e 94 93 14 	call	0x2926	; 0x2926 <_ZN8frt_taskC1EPKchjP8emstream>
     daa:	83 e4       	ldi	r24, 0x43	; 67
     dac:	90 e2       	ldi	r25, 0x20	; 32
     dae:	88 83       	st	Y, r24
     db0:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	0f 91       	pop	r16
     dba:	08 95       	ret

00000dbc <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     dbc:	0f 93       	push	r16
     dbe:	1f 93       	push	r17
     dc0:	cf 93       	push	r28
     dc2:	df 93       	push	r29
     dc4:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     dc6:	6a e0       	ldi	r22, 0x0A	; 10
     dc8:	8e 81       	ldd	r24, Y+6	; 0x06
     dca:	9f 81       	ldd	r25, Y+7	; 0x07
     dcc:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     dd0:	8c 01       	movw	r16, r24
     dd2:	69 ee       	ldi	r22, 0xE9	; 233
     dd4:	73 e0       	ldi	r23, 0x03	; 3
     dd6:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     dda:	6a e0       	ldi	r22, 0x0A	; 10
     ddc:	c8 01       	movw	r24, r16
     dde:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     de2:	8c 01       	movw	r16, r24
     de4:	63 ee       	ldi	r22, 0xE3	; 227
     de6:	73 e0       	ldi	r23, 0x03	; 3
     de8:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     dec:	67 e0       	ldi	r22, 0x07	; 7
     dee:	c8 01       	movw	r24, r16
     df0:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     df4:	6a e0       	ldi	r22, 0x0A	; 10
     df6:	8e 81       	ldd	r24, Y+6	; 0x06
     df8:	9f 81       	ldd	r25, Y+7	; 0x07
     dfa:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     dfe:	8c 01       	movw	r16, r24
     e00:	64 ec       	ldi	r22, 0xC4	; 196
     e02:	73 e0       	ldi	r23, 0x03	; 3
     e04:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     e08:	6a e0       	ldi	r22, 0x0A	; 10
     e0a:	c8 01       	movw	r24, r16
     e0c:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     e10:	8c 01       	movw	r16, r24
     e12:	6e eb       	ldi	r22, 0xBE	; 190
     e14:	73 e0       	ldi	r23, 0x03	; 3
     e16:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     e1a:	66 e0       	ldi	r22, 0x06	; 6
     e1c:	c8 01       	movw	r24, r16
     e1e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e22:	6a e0       	ldi	r22, 0x0A	; 10
     e24:	8e 81       	ldd	r24, Y+6	; 0x06
     e26:	9f 81       	ldd	r25, Y+7	; 0x07
     e28:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     e2c:	8c 01       	movw	r16, r24
     e2e:	67 ea       	ldi	r22, 0xA7	; 167
     e30:	73 e0       	ldi	r23, 0x03	; 3
     e32:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     e36:	66 e0       	ldi	r22, 0x06	; 6
     e38:	c8 01       	movw	r24, r16
     e3a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e3e:	6a e0       	ldi	r22, 0x0A	; 10
     e40:	8e 81       	ldd	r24, Y+6	; 0x06
     e42:	9f 81       	ldd	r25, Y+7	; 0x07
     e44:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     e48:	8c 01       	movw	r16, r24
     e4a:	6b e8       	ldi	r22, 0x8B	; 139
     e4c:	73 e0       	ldi	r23, 0x03	; 3
     e4e:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     e52:	66 e0       	ldi	r22, 0x06	; 6
     e54:	c8 01       	movw	r24, r16
     e56:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e5a:	6a e0       	ldi	r22, 0x0A	; 10
     e5c:	8e 81       	ldd	r24, Y+6	; 0x06
     e5e:	9f 81       	ldd	r25, Y+7	; 0x07
     e60:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     e64:	8c 01       	movw	r16, r24
     e66:	63 e7       	ldi	r22, 0x73	; 115
     e68:	73 e0       	ldi	r23, 0x03	; 3
     e6a:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     e6e:	66 e0       	ldi	r22, 0x06	; 6
     e70:	c8 01       	movw	r24, r16
     e72:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e76:	6a e0       	ldi	r22, 0x0A	; 10
     e78:	8e 81       	ldd	r24, Y+6	; 0x06
     e7a:	9f 81       	ldd	r25, Y+7	; 0x07
     e7c:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     e80:	8c 01       	movw	r16, r24
     e82:	62 e5       	ldi	r22, 0x52	; 82
     e84:	73 e0       	ldi	r23, 0x03	; 3
     e86:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     e8a:	66 e0       	ldi	r22, 0x06	; 6
     e8c:	c8 01       	movw	r24, r16
     e8e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e92:	6a e0       	ldi	r22, 0x0A	; 10
     e94:	8e 81       	ldd	r24, Y+6	; 0x06
     e96:	9f 81       	ldd	r25, Y+7	; 0x07
     e98:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     e9c:	8c 01       	movw	r16, r24
     e9e:	6b e2       	ldi	r22, 0x2B	; 43
     ea0:	73 e0       	ldi	r23, 0x03	; 3
     ea2:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     ea6:	66 e0       	ldi	r22, 0x06	; 6
     ea8:	c8 01       	movw	r24, r16
     eaa:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     eae:	6a e0       	ldi	r22, 0x0A	; 10
     eb0:	8e 81       	ldd	r24, Y+6	; 0x06
     eb2:	9f 81       	ldd	r25, Y+7	; 0x07
     eb4:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     eb8:	8c 01       	movw	r16, r24
     eba:	6d e0       	ldi	r22, 0x0D	; 13
     ebc:	73 e0       	ldi	r23, 0x03	; 3
     ebe:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     ec2:	66 e0       	ldi	r22, 0x06	; 6
     ec4:	c8 01       	movw	r24, r16
     ec6:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     eca:	6a e0       	ldi	r22, 0x0A	; 10
     ecc:	8e 81       	ldd	r24, Y+6	; 0x06
     ece:	9f 81       	ldd	r25, Y+7	; 0x07
     ed0:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     ed4:	8c 01       	movw	r16, r24
     ed6:	62 ef       	ldi	r22, 0xF2	; 242
     ed8:	72 e0       	ldi	r23, 0x02	; 2
     eda:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     ede:	66 e0       	ldi	r22, 0x06	; 6
     ee0:	c8 01       	movw	r24, r16
     ee2:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     ee6:	6a e0       	ldi	r22, 0x0A	; 10
     ee8:	8e 81       	ldd	r24, Y+6	; 0x06
     eea:	9f 81       	ldd	r25, Y+7	; 0x07
     eec:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     ef0:	ec 01       	movw	r28, r24
     ef2:	63 ee       	ldi	r22, 0xE3	; 227
     ef4:	72 e0       	ldi	r23, 0x02	; 2
     ef6:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     efa:	66 e0       	ldi	r22, 0x06	; 6
     efc:	ce 01       	movw	r24, r28
     efe:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
}
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	1f 91       	pop	r17
     f08:	0f 91       	pop	r16
     f0a:	08 95       	ret

00000f0c <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     f0c:	af 92       	push	r10
     f0e:	bf 92       	push	r11
     f10:	cf 92       	push	r12
     f12:	df 92       	push	r13
     f14:	ef 92       	push	r14
     f16:	ff 92       	push	r15
     f18:	0f 93       	push	r16
     f1a:	1f 93       	push	r17
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	00 d0       	rcall	.+0      	; 0xf22 <_ZN9task_user11show_statusEv+0x16>
     f22:	00 d0       	rcall	.+0      	; 0xf24 <_ZN9task_user11show_statusEv+0x18>
     f24:	cd b7       	in	r28, 0x3d	; 61
     f26:	de b7       	in	r29, 0x3e	; 62
     f28:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f2a:	19 82       	std	Y+1, r1	; 0x01
     f2c:	1a 82       	std	Y+2, r1	; 0x02
     f2e:	1b 82       	std	Y+3, r1	; 0x03
     f30:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f32:	1d 82       	std	Y+5, r1	; 0x05
     f34:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f36:	0e 94 0b 0a 	call	0x1416	; 0x1416 <xPortGetFreeHeapSize>
     f3a:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f3c:	ce 01       	movw	r24, r28
     f3e:	01 96       	adiw	r24, 0x01	; 1
     f40:	0e 94 44 18 	call	0x3088	; 0x3088 <_ZN10time_stamp10set_to_nowEv>
     f44:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f46:	66 e0       	ldi	r22, 0x06	; 6
     f48:	f8 01       	movw	r30, r16
     f4a:	86 81       	ldd	r24, Z+6	; 0x06
     f4c:	97 81       	ldd	r25, Z+7	; 0x07
     f4e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     f52:	6a e0       	ldi	r22, 0x0A	; 10
     f54:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     f58:	7c 01       	movw	r14, r24
     f5a:	64 ec       	ldi	r22, 0xC4	; 196
     f5c:	72 e0       	ldi	r23, 0x02	; 2
     f5e:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     f62:	6a e0       	ldi	r22, 0x0A	; 10
     f64:	c7 01       	movw	r24, r14
     f66:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     f6a:	7c 01       	movw	r14, r24
     f6c:	68 eb       	ldi	r22, 0xB8	; 184
     f6e:	72 e0       	ldi	r23, 0x02	; 2
     f70:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     f74:	66 e0       	ldi	r22, 0x06	; 6
     f76:	c7 01       	movw	r24, r14
     f78:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f7c:	6a e0       	ldi	r22, 0x0A	; 10
     f7e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     f82:	7c 01       	movw	r14, r24
     f84:	61 eb       	ldi	r22, 0xB1	; 177
     f86:	72 e0       	ldi	r23, 0x02	; 2
     f88:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     f8c:	b5 01       	movw	r22, r10
     f8e:	c7 01       	movw	r24, r14
     f90:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f94:	6a e0       	ldi	r22, 0x0A	; 10
     f96:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     f9a:	7c 01       	movw	r14, r24
     f9c:	63 ea       	ldi	r22, 0xA3	; 163
     f9e:	72 e0       	ldi	r23, 0x02	; 2
     fa0:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     fa4:	b6 01       	movw	r22, r12
     fa6:	c7 01       	movw	r24, r14
     fa8:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <_ZN8emstreamlsEj>
     fac:	6a e0       	ldi	r22, 0x0A	; 10
     fae:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     fb2:	7c 01       	movw	r14, r24
     fb4:	61 ea       	ldi	r22, 0xA1	; 161
     fb6:	72 e0       	ldi	r23, 0x02	; 2
     fb8:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     fbc:	4f ef       	ldi	r20, 0xFF	; 255
     fbe:	5f e0       	ldi	r21, 0x0F	; 15
     fc0:	60 e0       	ldi	r22, 0x00	; 0
     fc2:	70 e0       	ldi	r23, 0x00	; 0
     fc4:	c7 01       	movw	r24, r14
     fc6:	0e 94 90 1a 	call	0x3520	; 0x3520 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     fca:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     fce:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     fd2:	6a e0       	ldi	r22, 0x0A	; 10
     fd4:	f8 01       	movw	r30, r16
     fd6:	86 81       	ldd	r24, Z+6	; 0x06
     fd8:	97 81       	ldd	r25, Z+7	; 0x07
     fda:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     fde:	7c 01       	movw	r14, r24
     fe0:	66 e9       	ldi	r22, 0x96	; 150
     fe2:	72 e0       	ldi	r23, 0x02	; 2
     fe4:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
     fe8:	b6 01       	movw	r22, r12
     fea:	c7 01       	movw	r24, r14
     fec:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <_ZN8emstreamlsEj>
     ff0:	66 e0       	ldi	r22, 0x06	; 6
     ff2:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
     ff6:	66 e0       	ldi	r22, 0x06	; 6
     ff8:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     ffc:	f8 01       	movw	r30, r16
     ffe:	86 81       	ldd	r24, Z+6	; 0x06
    1000:	97 81       	ldd	r25, Z+7	; 0x07
    1002:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <_Z15print_task_listP8emstream>
}
    1006:	26 96       	adiw	r28, 0x06	; 6
    1008:	cd bf       	out	0x3d, r28	; 61
    100a:	de bf       	out	0x3e, r29	; 62
    100c:	df 91       	pop	r29
    100e:	cf 91       	pop	r28
    1010:	1f 91       	pop	r17
    1012:	0f 91       	pop	r16
    1014:	ff 90       	pop	r15
    1016:	ef 90       	pop	r14
    1018:	df 90       	pop	r13
    101a:	cf 90       	pop	r12
    101c:	bf 90       	pop	r11
    101e:	af 90       	pop	r10
    1020:	08 95       	ret

00001022 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1022:	cf 93       	push	r28
    1024:	df 93       	push	r29
    1026:	00 d0       	rcall	.+0      	; 0x1028 <_ZN9task_user3runEv+0x6>
    1028:	00 d0       	rcall	.+0      	; 0x102a <_ZN9task_user3runEv+0x8>
    102a:	cd b7       	in	r28, 0x3d	; 61
    102c:	de b7       	in	r29, 0x3e	; 62
    102e:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1030:	19 82       	std	Y+1, r1	; 0x01
    1032:	1a 82       	std	Y+2, r1	; 0x02
    1034:	1b 82       	std	Y+3, r1	; 0x03
    1036:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1038:	1d 82       	std	Y+5, r1	; 0x05
    103a:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    103c:	6a e0       	ldi	r22, 0x0A	; 10
    103e:	dc 01       	movw	r26, r24
    1040:	16 96       	adiw	r26, 0x06	; 6
    1042:	8d 91       	ld	r24, X+
    1044:	9c 91       	ld	r25, X
    1046:	17 97       	sbiw	r26, 0x07	; 7
    1048:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    104c:	7c 01       	movw	r14, r24
    104e:	62 e3       	ldi	r22, 0x32	; 50
    1050:	74 e0       	ldi	r23, 0x04	; 4
    1052:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    1056:	66 e0       	ldi	r22, 0x06	; 6
    1058:	c7 01       	movw	r24, r14
    105a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    105e:	f8 01       	movw	r30, r16
    1060:	84 85       	ldd	r24, Z+12	; 0x0c
    1062:	88 23       	and	r24, r24
    1064:	21 f0       	breq	.+8      	; 0x106e <_ZN9task_user3runEv+0x4c>
    1066:	81 30       	cpi	r24, 0x01	; 1
    1068:	09 f4       	brne	.+2      	; 0x106c <_ZN9task_user3runEv+0x4a>
    106a:	5d c0       	rjmp	.+186    	; 0x1126 <_ZN9task_user3runEv+0x104>
    106c:	d8 c0       	rjmp	.+432    	; 0x121e <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    106e:	86 81       	ldd	r24, Z+6	; 0x06
    1070:	97 81       	ldd	r25, Z+7	; 0x07
    1072:	dc 01       	movw	r26, r24
    1074:	ed 91       	ld	r30, X+
    1076:	fc 91       	ld	r31, X
    1078:	04 80       	ldd	r0, Z+4	; 0x04
    107a:	f5 81       	ldd	r31, Z+5	; 0x05
    107c:	e0 2d       	mov	r30, r0
    107e:	19 95       	eicall
    1080:	88 23       	and	r24, r24
    1082:	a9 f1       	breq	.+106    	; 0x10ee <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1084:	f8 01       	movw	r30, r16
    1086:	86 81       	ldd	r24, Z+6	; 0x06
    1088:	97 81       	ldd	r25, Z+7	; 0x07
    108a:	dc 01       	movw	r26, r24
    108c:	ed 91       	ld	r30, X+
    108e:	fc 91       	ld	r31, X
    1090:	06 80       	ldd	r0, Z+6	; 0x06
    1092:	f7 81       	ldd	r31, Z+7	; 0x07
    1094:	e0 2d       	mov	r30, r0
    1096:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1098:	99 27       	eor	r25, r25
    109a:	81 30       	cpi	r24, 0x01	; 1
    109c:	91 05       	cpc	r25, r1
    109e:	f9 f0       	breq	.+62     	; 0x10de <_ZN9task_user3runEv+0xbc>
    10a0:	03 97       	sbiw	r24, 0x03	; 3
    10a2:	09 f0       	breq	.+2      	; 0x10a6 <_ZN9task_user3runEv+0x84>
    10a4:	d8 c0       	rjmp	.+432    	; 0x1256 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    10a6:	6a e0       	ldi	r22, 0x0A	; 10
    10a8:	f8 01       	movw	r30, r16
    10aa:	86 81       	ldd	r24, Z+6	; 0x06
    10ac:	97 81       	ldd	r25, Z+7	; 0x07
    10ae:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    10b2:	8c 01       	movw	r16, r24
    10b4:	64 e2       	ldi	r22, 0x24	; 36
    10b6:	74 e0       	ldi	r23, 0x04	; 4
    10b8:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    10bc:	66 e0       	ldi	r22, 0x06	; 6
    10be:	c8 01       	movw	r24, r16
    10c0:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10c4:	93 e0       	ldi	r25, 0x03	; 3
    10c6:	88 ed       	ldi	r24, 0xD8	; 216
    10c8:	08 b6       	in	r0, 0x38	; 56
    10ca:	18 be       	out	0x38, r1	; 56
    10cc:	84 bf       	out	0x34, r24	; 52
    10ce:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10d2:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10d6:	81 fd       	sbrc	r24, 1
    10d8:	fc cf       	rjmp	.-8      	; 0x10d2 <_ZN9task_user3runEv+0xb0>
    10da:	08 be       	out	0x38, r0	; 56
    10dc:	ff cf       	rjmp	.-2      	; 0x10dc <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10de:	c8 01       	movw	r24, r16
    10e0:	0e 94 de 06 	call	0xdbc	; 0xdbc <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10e4:	61 e0       	ldi	r22, 0x01	; 1
    10e6:	c8 01       	movw	r24, r16
    10e8:	0e 94 8f 14 	call	0x291e	; 0x291e <_ZN8frt_task13transition_toEh>
							break;
    10ec:	b4 c0       	rjmp	.+360    	; 0x1256 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10ee:	8a e5       	ldi	r24, 0x5A	; 90
    10f0:	91 e3       	ldi	r25, 0x31	; 49
    10f2:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <_ZN14frt_text_queue14check_for_charEv>
    10f6:	88 23       	and	r24, r24
    10f8:	09 f4       	brne	.+2      	; 0x10fc <_ZN9task_user3runEv+0xda>
    10fa:	ad c0       	rjmp	.+346    	; 0x1256 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    10fc:	d8 01       	movw	r26, r16
    10fe:	16 96       	adiw	r26, 0x06	; 6
    1100:	ed 91       	ld	r30, X+
    1102:	fc 91       	ld	r31, X
    1104:	17 97       	sbiw	r26, 0x07	; 7
    1106:	01 90       	ld	r0, Z+
    1108:	f0 81       	ld	r31, Z
    110a:	e0 2d       	mov	r30, r0
    110c:	e2 80       	ldd	r14, Z+2	; 0x02
    110e:	f3 80       	ldd	r15, Z+3	; 0x03
    1110:	8a e5       	ldi	r24, 0x5A	; 90
    1112:	91 e3       	ldi	r25, 0x31	; 49
    1114:	0e 94 32 17 	call	0x2e64	; 0x2e64 <_ZN14frt_text_queue7getcharEv>
    1118:	68 2f       	mov	r22, r24
    111a:	f8 01       	movw	r30, r16
    111c:	86 81       	ldd	r24, Z+6	; 0x06
    111e:	97 81       	ldd	r25, Z+7	; 0x07
    1120:	f7 01       	movw	r30, r14
    1122:	19 95       	eicall
    1124:	98 c0       	rjmp	.+304    	; 0x1256 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1126:	86 81       	ldd	r24, Z+6	; 0x06
    1128:	97 81       	ldd	r25, Z+7	; 0x07
    112a:	dc 01       	movw	r26, r24
    112c:	ed 91       	ld	r30, X+
    112e:	fc 91       	ld	r31, X
    1130:	04 80       	ldd	r0, Z+4	; 0x04
    1132:	f5 81       	ldd	r31, Z+5	; 0x05
    1134:	e0 2d       	mov	r30, r0
    1136:	19 95       	eicall
    1138:	88 23       	and	r24, r24
    113a:	09 f4       	brne	.+2      	; 0x113e <_ZN9task_user3runEv+0x11c>
    113c:	8c c0       	rjmp	.+280    	; 0x1256 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    113e:	f8 01       	movw	r30, r16
    1140:	86 81       	ldd	r24, Z+6	; 0x06
    1142:	97 81       	ldd	r25, Z+7	; 0x07
    1144:	dc 01       	movw	r26, r24
    1146:	ed 91       	ld	r30, X+
    1148:	fc 91       	ld	r31, X
    114a:	06 80       	ldd	r0, Z+6	; 0x06
    114c:	f7 81       	ldd	r31, Z+7	; 0x07
    114e:	e0 2d       	mov	r30, r0
    1150:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1152:	9c 01       	movw	r18, r24
    1154:	33 27       	eor	r19, r19
    1156:	28 36       	cpi	r18, 0x68	; 104
    1158:	31 05       	cpc	r19, r1
    115a:	59 f1       	breq	.+86     	; 0x11b2 <_ZN9task_user3runEv+0x190>
    115c:	3c f4       	brge	.+14     	; 0x116c <_ZN9task_user3runEv+0x14a>
    115e:	2b 31       	cpi	r18, 0x1B	; 27
    1160:	31 05       	cpc	r19, r1
    1162:	59 f1       	breq	.+86     	; 0x11ba <_ZN9task_user3runEv+0x198>
    1164:	25 36       	cpi	r18, 0x65	; 101
    1166:	31 05       	cpc	r19, r1
    1168:	41 f1       	breq	.+80     	; 0x11ba <_ZN9task_user3runEv+0x198>
    116a:	3b c0       	rjmp	.+118    	; 0x11e2 <_ZN9task_user3runEv+0x1c0>
    116c:	23 37       	cpi	r18, 0x73	; 115
    116e:	31 05       	cpc	r19, r1
    1170:	c1 f0       	breq	.+48     	; 0x11a2 <_ZN9task_user3runEv+0x180>
    1172:	26 37       	cpi	r18, 0x76	; 118
    1174:	31 05       	cpc	r19, r1
    1176:	89 f0       	breq	.+34     	; 0x119a <_ZN9task_user3runEv+0x178>
    1178:	2e 36       	cpi	r18, 0x6E	; 110
    117a:	31 05       	cpc	r19, r1
    117c:	91 f5       	brne	.+100    	; 0x11e2 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    117e:	ce 01       	movw	r24, r28
    1180:	01 96       	adiw	r24, 0x01	; 1
    1182:	0e 94 44 18 	call	0x3088	; 0x3088 <_ZN10time_stamp10set_to_nowEv>
    1186:	bc 01       	movw	r22, r24
    1188:	f8 01       	movw	r30, r16
    118a:	86 81       	ldd	r24, Z+6	; 0x06
    118c:	97 81       	ldd	r25, Z+7	; 0x07
    118e:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <_ZlsR8emstreamR10time_stamp>
    1192:	66 e0       	ldi	r22, 0x06	; 6
    1194:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
							break;
    1198:	5e c0       	rjmp	.+188    	; 0x1256 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    119a:	c8 01       	movw	r24, r16
    119c:	0e 94 86 07 	call	0xf0c	; 0xf0c <_ZN9task_user11show_statusEv>
							break;
    11a0:	5a c0       	rjmp	.+180    	; 0x1256 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    11a2:	d8 01       	movw	r26, r16
    11a4:	16 96       	adiw	r26, 0x06	; 6
    11a6:	8d 91       	ld	r24, X+
    11a8:	9c 91       	ld	r25, X
    11aa:	17 97       	sbiw	r26, 0x07	; 7
    11ac:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <_Z17print_task_stacksP8emstream>
							break;
    11b0:	52 c0       	rjmp	.+164    	; 0x1256 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    11b2:	c8 01       	movw	r24, r16
    11b4:	0e 94 de 06 	call	0xdbc	; 0xdbc <_ZN9task_user18print_help_messageEv>
							break;
    11b8:	4e c0       	rjmp	.+156    	; 0x1256 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    11ba:	6a e0       	ldi	r22, 0x0A	; 10
    11bc:	f8 01       	movw	r30, r16
    11be:	86 81       	ldd	r24, Z+6	; 0x06
    11c0:	97 81       	ldd	r25, Z+7	; 0x07
    11c2:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    11c6:	7c 01       	movw	r14, r24
    11c8:	62 e1       	ldi	r22, 0x12	; 18
    11ca:	74 e0       	ldi	r23, 0x04	; 4
    11cc:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    11d0:	66 e0       	ldi	r22, 0x06	; 6
    11d2:	c7 01       	movw	r24, r14
    11d4:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11d8:	60 e0       	ldi	r22, 0x00	; 0
    11da:	c8 01       	movw	r24, r16
    11dc:	0e 94 8f 14 	call	0x291e	; 0x291e <_ZN8frt_task13transition_toEh>
							break;
    11e0:	3a c0       	rjmp	.+116    	; 0x1256 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11e2:	f8 01       	movw	r30, r16
    11e4:	a6 81       	ldd	r26, Z+6	; 0x06
    11e6:	b7 81       	ldd	r27, Z+7	; 0x07
    11e8:	ed 91       	ld	r30, X+
    11ea:	fc 91       	ld	r31, X
    11ec:	11 97       	sbiw	r26, 0x01	; 1
    11ee:	02 80       	ldd	r0, Z+2	; 0x02
    11f0:	f3 81       	ldd	r31, Z+3	; 0x03
    11f2:	e0 2d       	mov	r30, r0
    11f4:	68 2f       	mov	r22, r24
    11f6:	cd 01       	movw	r24, r26
    11f8:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    11fa:	6a e0       	ldi	r22, 0x0A	; 10
    11fc:	d8 01       	movw	r26, r16
    11fe:	16 96       	adiw	r26, 0x06	; 6
    1200:	8d 91       	ld	r24, X+
    1202:	9c 91       	ld	r25, X
    1204:	17 97       	sbiw	r26, 0x07	; 7
    1206:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    120a:	7c 01       	movw	r14, r24
    120c:	6c e0       	ldi	r22, 0x0C	; 12
    120e:	74 e0       	ldi	r23, 0x04	; 4
    1210:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    1214:	66 e0       	ldi	r22, 0x06	; 6
    1216:	c7 01       	movw	r24, r14
    1218:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
							break;
    121c:	1c c0       	rjmp	.+56     	; 0x1256 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    121e:	6a e0       	ldi	r22, 0x0A	; 10
    1220:	f8 01       	movw	r30, r16
    1222:	86 81       	ldd	r24, Z+6	; 0x06
    1224:	97 81       	ldd	r25, Z+7	; 0x07
    1226:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    122a:	8c 01       	movw	r16, r24
    122c:	6f ee       	ldi	r22, 0xEF	; 239
    122e:	73 e0       	ldi	r23, 0x03	; 3
    1230:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    1234:	66 e0       	ldi	r22, 0x06	; 6
    1236:	c8 01       	movw	r24, r16
    1238:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    123c:	93 e0       	ldi	r25, 0x03	; 3
    123e:	88 ed       	ldi	r24, 0xD8	; 216
    1240:	08 b6       	in	r0, 0x38	; 56
    1242:	18 be       	out	0x38, r1	; 56
    1244:	84 bf       	out	0x34, r24	; 52
    1246:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    124a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    124e:	81 fd       	sbrc	r24, 1
    1250:	fc cf       	rjmp	.-8      	; 0x124a <_ZN9task_user3runEv+0x228>
    1252:	08 be       	out	0x38, r0	; 56
    1254:	ff cf       	rjmp	.-2      	; 0x1254 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1256:	f8 01       	movw	r30, r16
    1258:	86 85       	ldd	r24, Z+14	; 0x0e
    125a:	97 85       	ldd	r25, Z+15	; 0x0f
    125c:	a0 89       	ldd	r26, Z+16	; 0x10
    125e:	b1 89       	ldd	r27, Z+17	; 0x11
    1260:	01 96       	adiw	r24, 0x01	; 1
    1262:	a1 1d       	adc	r26, r1
    1264:	b1 1d       	adc	r27, r1
    1266:	86 87       	std	Z+14, r24	; 0x0e
    1268:	97 87       	std	Z+15, r25	; 0x0f
    126a:	a0 8b       	std	Z+16, r26	; 0x10
    126c:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    126e:	61 e0       	ldi	r22, 0x01	; 1
    1270:	70 e0       	ldi	r23, 0x00	; 0
    1272:	80 e0       	ldi	r24, 0x00	; 0
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	0e 94 63 12 	call	0x24c6	; 0x24c6 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    127a:	f1 ce       	rjmp	.-542    	; 0x105e <_ZN9task_user3runEv+0x3c>

0000127c <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    127c:	0f 93       	push	r16
    127e:	1f 93       	push	r17
    1280:	cf 93       	push	r28
    1282:	df 93       	push	r29
    1284:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1286:	0e 94 52 10 	call	0x20a4	; 0x20a4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    128a:	80 91 c8 20 	lds	r24, 0x20C8	; 0x8020c8 <__data_end>
    128e:	81 11       	cpse	r24, r1
    1290:	1d c0       	rjmp	.+58     	; 0x12cc <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1292:	ad ec       	ldi	r26, 0xCD	; 205
    1294:	b0 e2       	ldi	r27, 0x20	; 32
    1296:	e1 ed       	ldi	r30, 0xD1	; 209
    1298:	f0 e2       	ldi	r31, 0x20	; 32
    129a:	ed 93       	st	X+, r30
    129c:	fc 93       	st	X, r31
    129e:	11 97       	sbiw	r26, 0x01	; 1
    12a0:	12 96       	adiw	r26, 0x02	; 2
    12a2:	1d 92       	st	X+, r1
    12a4:	1c 92       	st	X, r1
    12a6:	13 97       	sbiw	r26, 0x03	; 3
    12a8:	a9 ec       	ldi	r26, 0xC9	; 201
    12aa:	b0 e2       	ldi	r27, 0x20	; 32
    12ac:	8f ef       	ldi	r24, 0xFF	; 255
    12ae:	9f e0       	ldi	r25, 0x0F	; 15
    12b0:	12 96       	adiw	r26, 0x02	; 2
    12b2:	8d 93       	st	X+, r24
    12b4:	9c 93       	st	X, r25
    12b6:	13 97       	sbiw	r26, 0x03	; 3
    12b8:	1d 92       	st	X+, r1
    12ba:	1c 92       	st	X, r1
    12bc:	11 97       	sbiw	r26, 0x01	; 1
    12be:	82 83       	std	Z+2, r24	; 0x02
    12c0:	93 83       	std	Z+3, r25	; 0x03
    12c2:	a0 83       	st	Z, r26
    12c4:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    12c6:	81 e0       	ldi	r24, 0x01	; 1
    12c8:	80 93 c8 20 	sts	0x20C8, r24	; 0x8020c8 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12cc:	20 97       	sbiw	r28, 0x00	; 0
    12ce:	09 f4       	brne	.+2      	; 0x12d2 <pvPortMalloc+0x56>
    12d0:	5f c0       	rjmp	.+190    	; 0x1390 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12d2:	9e 01       	movw	r18, r28
    12d4:	2b 5f       	subi	r18, 0xFB	; 251
    12d6:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    12d8:	24 96       	adiw	r28, 0x04	; 4
    12da:	ce 3f       	cpi	r28, 0xFE	; 254
    12dc:	df 40       	sbci	r29, 0x0F	; 15
    12de:	08 f0       	brcs	.+2      	; 0x12e2 <pvPortMalloc+0x66>
    12e0:	5a c0       	rjmp	.+180    	; 0x1396 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    12e2:	e0 91 cd 20 	lds	r30, 0x20CD	; 0x8020cd <xStart>
    12e6:	f0 91 ce 20 	lds	r31, 0x20CE	; 0x8020ce <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    12ea:	ad ec       	ldi	r26, 0xCD	; 205
    12ec:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12ee:	02 c0       	rjmp	.+4      	; 0x12f4 <pvPortMalloc+0x78>
    12f0:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    12f2:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12f4:	82 81       	ldd	r24, Z+2	; 0x02
    12f6:	93 81       	ldd	r25, Z+3	; 0x03
    12f8:	82 17       	cp	r24, r18
    12fa:	93 07       	cpc	r25, r19
    12fc:	20 f4       	brcc	.+8      	; 0x1306 <pvPortMalloc+0x8a>
    12fe:	80 81       	ld	r24, Z
    1300:	91 81       	ldd	r25, Z+1	; 0x01
    1302:	00 97       	sbiw	r24, 0x00	; 0
    1304:	a9 f7       	brne	.-22     	; 0x12f0 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1306:	c0 e2       	ldi	r28, 0x20	; 32
    1308:	e9 3c       	cpi	r30, 0xC9	; 201
    130a:	fc 07       	cpc	r31, r28
    130c:	09 f4       	brne	.+2      	; 0x1310 <pvPortMalloc+0x94>
    130e:	46 c0       	rjmp	.+140    	; 0x139c <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1310:	cd 91       	ld	r28, X+
    1312:	dc 91       	ld	r29, X
    1314:	11 97       	sbiw	r26, 0x01	; 1
    1316:	8e 01       	movw	r16, r28
    1318:	0b 5f       	subi	r16, 0xFB	; 251
    131a:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    131c:	80 81       	ld	r24, Z
    131e:	91 81       	ldd	r25, Z+1	; 0x01
    1320:	8d 93       	st	X+, r24
    1322:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1324:	82 81       	ldd	r24, Z+2	; 0x02
    1326:	93 81       	ldd	r25, Z+3	; 0x03
    1328:	82 1b       	sub	r24, r18
    132a:	93 0b       	sbc	r25, r19
    132c:	8b 30       	cpi	r24, 0x0B	; 11
    132e:	91 05       	cpc	r25, r1
    1330:	10 f1       	brcs	.+68     	; 0x1376 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1332:	bf 01       	movw	r22, r30
    1334:	62 0f       	add	r22, r18
    1336:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1338:	db 01       	movw	r26, r22
    133a:	12 96       	adiw	r26, 0x02	; 2
    133c:	8d 93       	st	X+, r24
    133e:	9c 93       	st	X, r25
    1340:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1342:	22 83       	std	Z+2, r18	; 0x02
    1344:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1346:	12 96       	adiw	r26, 0x02	; 2
    1348:	4d 91       	ld	r20, X+
    134a:	5c 91       	ld	r21, X
    134c:	13 97       	sbiw	r26, 0x03	; 3
    134e:	8d ec       	ldi	r24, 0xCD	; 205
    1350:	90 e2       	ldi	r25, 0x20	; 32
    1352:	01 c0       	rjmp	.+2      	; 0x1356 <pvPortMalloc+0xda>
    1354:	cd 01       	movw	r24, r26
    1356:	ec 01       	movw	r28, r24
    1358:	a8 81       	ld	r26, Y
    135a:	b9 81       	ldd	r27, Y+1	; 0x01
    135c:	12 96       	adiw	r26, 0x02	; 2
    135e:	2d 91       	ld	r18, X+
    1360:	3c 91       	ld	r19, X
    1362:	13 97       	sbiw	r26, 0x03	; 3
    1364:	24 17       	cp	r18, r20
    1366:	35 07       	cpc	r19, r21
    1368:	a8 f3       	brcs	.-22     	; 0x1354 <pvPortMalloc+0xd8>
    136a:	eb 01       	movw	r28, r22
    136c:	a8 83       	st	Y, r26
    136e:	b9 83       	std	Y+1, r27	; 0x01
    1370:	dc 01       	movw	r26, r24
    1372:	6d 93       	st	X+, r22
    1374:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1376:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    137a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    137e:	22 81       	ldd	r18, Z+2	; 0x02
    1380:	33 81       	ldd	r19, Z+3	; 0x03
    1382:	82 1b       	sub	r24, r18
    1384:	93 0b       	sbc	r25, r19
    1386:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    138a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    138e:	08 c0       	rjmp	.+16     	; 0x13a0 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1390:	00 e0       	ldi	r16, 0x00	; 0
    1392:	10 e0       	ldi	r17, 0x00	; 0
    1394:	05 c0       	rjmp	.+10     	; 0x13a0 <pvPortMalloc+0x124>
    1396:	00 e0       	ldi	r16, 0x00	; 0
    1398:	10 e0       	ldi	r17, 0x00	; 0
    139a:	02 c0       	rjmp	.+4      	; 0x13a0 <pvPortMalloc+0x124>
    139c:	00 e0       	ldi	r16, 0x00	; 0
    139e:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    13a0:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    13a4:	c8 01       	movw	r24, r16
    13a6:	df 91       	pop	r29
    13a8:	cf 91       	pop	r28
    13aa:	1f 91       	pop	r17
    13ac:	0f 91       	pop	r16
    13ae:	08 95       	ret

000013b0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    13b0:	0f 93       	push	r16
    13b2:	1f 93       	push	r17
    13b4:	cf 93       	push	r28
    13b6:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    13b8:	00 97       	sbiw	r24, 0x00	; 0
    13ba:	41 f1       	breq	.+80     	; 0x140c <vPortFree+0x5c>
    13bc:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    13be:	8c 01       	movw	r16, r24
    13c0:	05 50       	subi	r16, 0x05	; 5
    13c2:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    13c4:	0e 94 52 10 	call	0x20a4	; 0x20a4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    13c8:	f8 01       	movw	r30, r16
    13ca:	42 81       	ldd	r20, Z+2	; 0x02
    13cc:	53 81       	ldd	r21, Z+3	; 0x03
    13ce:	ad ec       	ldi	r26, 0xCD	; 205
    13d0:	b0 e2       	ldi	r27, 0x20	; 32
    13d2:	01 c0       	rjmp	.+2      	; 0x13d6 <vPortFree+0x26>
    13d4:	df 01       	movw	r26, r30
    13d6:	ed 91       	ld	r30, X+
    13d8:	fc 91       	ld	r31, X
    13da:	11 97       	sbiw	r26, 0x01	; 1
    13dc:	22 81       	ldd	r18, Z+2	; 0x02
    13de:	33 81       	ldd	r19, Z+3	; 0x03
    13e0:	24 17       	cp	r18, r20
    13e2:	35 07       	cpc	r19, r21
    13e4:	b8 f3       	brcs	.-18     	; 0x13d4 <vPortFree+0x24>
    13e6:	25 97       	sbiw	r28, 0x05	; 5
    13e8:	e8 83       	st	Y, r30
    13ea:	f9 83       	std	Y+1, r31	; 0x01
    13ec:	0d 93       	st	X+, r16
    13ee:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    13f0:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    13f4:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    13f8:	8a 81       	ldd	r24, Y+2	; 0x02
    13fa:	9b 81       	ldd	r25, Y+3	; 0x03
    13fc:	82 0f       	add	r24, r18
    13fe:	93 1f       	adc	r25, r19
    1400:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1404:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1408:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
	}
}
    140c:	df 91       	pop	r29
    140e:	cf 91       	pop	r28
    1410:	1f 91       	pop	r17
    1412:	0f 91       	pop	r16
    1414:	08 95       	ret

00001416 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1416:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    141a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    141e:	08 95       	ret

00001420 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1420:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1422:	03 96       	adiw	r24, 0x03	; 3
    1424:	81 83       	std	Z+1, r24	; 0x01
    1426:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1428:	4f ef       	ldi	r20, 0xFF	; 255
    142a:	5f ef       	ldi	r21, 0xFF	; 255
    142c:	ba 01       	movw	r22, r20
    142e:	43 83       	std	Z+3, r20	; 0x03
    1430:	54 83       	std	Z+4, r21	; 0x04
    1432:	65 83       	std	Z+5, r22	; 0x05
    1434:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1436:	87 83       	std	Z+7, r24	; 0x07
    1438:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    143a:	81 87       	std	Z+9, r24	; 0x09
    143c:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    143e:	10 82       	st	Z, r1
    1440:	08 95       	ret

00001442 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1442:	fc 01       	movw	r30, r24
    1444:	12 86       	std	Z+10, r1	; 0x0a
    1446:	13 86       	std	Z+11, r1	; 0x0b
    1448:	08 95       	ret

0000144a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    144a:	cf 93       	push	r28
    144c:	df 93       	push	r29
    144e:	fc 01       	movw	r30, r24
    1450:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1452:	21 81       	ldd	r18, Z+1	; 0x01
    1454:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1456:	e9 01       	movw	r28, r18
    1458:	8c 81       	ldd	r24, Y+4	; 0x04
    145a:	9d 81       	ldd	r25, Y+5	; 0x05
    145c:	14 96       	adiw	r26, 0x04	; 4
    145e:	8d 93       	st	X+, r24
    1460:	9c 93       	st	X, r25
    1462:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1464:	81 81       	ldd	r24, Z+1	; 0x01
    1466:	92 81       	ldd	r25, Z+2	; 0x02
    1468:	16 96       	adiw	r26, 0x06	; 6
    146a:	8d 93       	st	X+, r24
    146c:	9c 93       	st	X, r25
    146e:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1470:	8c 81       	ldd	r24, Y+4	; 0x04
    1472:	9d 81       	ldd	r25, Y+5	; 0x05
    1474:	ec 01       	movw	r28, r24
    1476:	6e 83       	std	Y+6, r22	; 0x06
    1478:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    147a:	e9 01       	movw	r28, r18
    147c:	6c 83       	std	Y+4, r22	; 0x04
    147e:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1480:	61 83       	std	Z+1, r22	; 0x01
    1482:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1484:	1a 96       	adiw	r26, 0x0a	; 10
    1486:	ed 93       	st	X+, r30
    1488:	fc 93       	st	X, r31
    148a:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    148c:	80 81       	ld	r24, Z
    148e:	8f 5f       	subi	r24, 0xFF	; 255
    1490:	80 83       	st	Z, r24
}
    1492:	df 91       	pop	r29
    1494:	cf 91       	pop	r28
    1496:	08 95       	ret

00001498 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1498:	0f 93       	push	r16
    149a:	1f 93       	push	r17
    149c:	cf 93       	push	r28
    149e:	df 93       	push	r29
    14a0:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    14a2:	08 81       	ld	r16, Y
    14a4:	19 81       	ldd	r17, Y+1	; 0x01
    14a6:	2a 81       	ldd	r18, Y+2	; 0x02
    14a8:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14aa:	0f 3f       	cpi	r16, 0xFF	; 255
    14ac:	4f ef       	ldi	r20, 0xFF	; 255
    14ae:	14 07       	cpc	r17, r20
    14b0:	24 07       	cpc	r18, r20
    14b2:	34 07       	cpc	r19, r20
    14b4:	31 f4       	brne	.+12     	; 0x14c2 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14b6:	dc 01       	movw	r26, r24
    14b8:	19 96       	adiw	r26, 0x09	; 9
    14ba:	ed 91       	ld	r30, X+
    14bc:	fc 91       	ld	r31, X
    14be:	1a 97       	sbiw	r26, 0x0a	; 10
    14c0:	1f c0       	rjmp	.+62     	; 0x1500 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14c2:	fc 01       	movw	r30, r24
    14c4:	33 96       	adiw	r30, 0x03	; 3
    14c6:	dc 01       	movw	r26, r24
    14c8:	17 96       	adiw	r26, 0x07	; 7
    14ca:	4d 91       	ld	r20, X+
    14cc:	5c 91       	ld	r21, X
    14ce:	18 97       	sbiw	r26, 0x08	; 8
    14d0:	da 01       	movw	r26, r20
    14d2:	4d 91       	ld	r20, X+
    14d4:	5d 91       	ld	r21, X+
    14d6:	6d 91       	ld	r22, X+
    14d8:	7c 91       	ld	r23, X
    14da:	04 17       	cp	r16, r20
    14dc:	15 07       	cpc	r17, r21
    14de:	26 07       	cpc	r18, r22
    14e0:	37 07       	cpc	r19, r23
    14e2:	70 f0       	brcs	.+28     	; 0x1500 <vListInsert+0x68>
    14e4:	04 80       	ldd	r0, Z+4	; 0x04
    14e6:	f5 81       	ldd	r31, Z+5	; 0x05
    14e8:	e0 2d       	mov	r30, r0
    14ea:	a4 81       	ldd	r26, Z+4	; 0x04
    14ec:	b5 81       	ldd	r27, Z+5	; 0x05
    14ee:	4d 91       	ld	r20, X+
    14f0:	5d 91       	ld	r21, X+
    14f2:	6d 91       	ld	r22, X+
    14f4:	7c 91       	ld	r23, X
    14f6:	04 17       	cp	r16, r20
    14f8:	15 07       	cpc	r17, r21
    14fa:	26 07       	cpc	r18, r22
    14fc:	37 07       	cpc	r19, r23
    14fe:	90 f7       	brcc	.-28     	; 0x14e4 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1500:	a4 81       	ldd	r26, Z+4	; 0x04
    1502:	b5 81       	ldd	r27, Z+5	; 0x05
    1504:	ac 83       	std	Y+4, r26	; 0x04
    1506:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1508:	16 96       	adiw	r26, 0x06	; 6
    150a:	cd 93       	st	X+, r28
    150c:	dc 93       	st	X, r29
    150e:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1510:	ee 83       	std	Y+6, r30	; 0x06
    1512:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1514:	c4 83       	std	Z+4, r28	; 0x04
    1516:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1518:	8a 87       	std	Y+10, r24	; 0x0a
    151a:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    151c:	fc 01       	movw	r30, r24
    151e:	20 81       	ld	r18, Z
    1520:	2f 5f       	subi	r18, 0xFF	; 255
    1522:	20 83       	st	Z, r18
}
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	1f 91       	pop	r17
    152a:	0f 91       	pop	r16
    152c:	08 95       	ret

0000152e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    152e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1530:	a4 81       	ldd	r26, Z+4	; 0x04
    1532:	b5 81       	ldd	r27, Z+5	; 0x05
    1534:	86 81       	ldd	r24, Z+6	; 0x06
    1536:	97 81       	ldd	r25, Z+7	; 0x07
    1538:	16 96       	adiw	r26, 0x06	; 6
    153a:	8d 93       	st	X+, r24
    153c:	9c 93       	st	X, r25
    153e:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1540:	a6 81       	ldd	r26, Z+6	; 0x06
    1542:	b7 81       	ldd	r27, Z+7	; 0x07
    1544:	84 81       	ldd	r24, Z+4	; 0x04
    1546:	95 81       	ldd	r25, Z+5	; 0x05
    1548:	14 96       	adiw	r26, 0x04	; 4
    154a:	8d 93       	st	X+, r24
    154c:	9c 93       	st	X, r25
    154e:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1550:	a2 85       	ldd	r26, Z+10	; 0x0a
    1552:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1554:	11 96       	adiw	r26, 0x01	; 1
    1556:	8d 91       	ld	r24, X+
    1558:	9c 91       	ld	r25, X
    155a:	12 97       	sbiw	r26, 0x02	; 2
    155c:	e8 17       	cp	r30, r24
    155e:	f9 07       	cpc	r31, r25
    1560:	31 f4       	brne	.+12     	; 0x156e <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1562:	86 81       	ldd	r24, Z+6	; 0x06
    1564:	97 81       	ldd	r25, Z+7	; 0x07
    1566:	11 96       	adiw	r26, 0x01	; 1
    1568:	8d 93       	st	X+, r24
    156a:	9c 93       	st	X, r25
    156c:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    156e:	12 86       	std	Z+10, r1	; 0x0a
    1570:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1572:	8c 91       	ld	r24, X
    1574:	81 50       	subi	r24, 0x01	; 1
    1576:	8c 93       	st	X, r24
    1578:	08 95       	ret

0000157a <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    157a:	80 93 6a 31 	sts	0x316A, r24	; 0x80316a <portStackTopForTask>
    157e:	90 93 6b 31 	sts	0x316B, r25	; 0x80316b <portStackTopForTask+0x1>
    1582:	31 e1       	ldi	r19, 0x11	; 17
    1584:	fc 01       	movw	r30, r24
    1586:	30 83       	st	Z, r19
    1588:	31 97       	sbiw	r30, 0x01	; 1
    158a:	22 e2       	ldi	r18, 0x22	; 34
    158c:	20 83       	st	Z, r18
    158e:	31 97       	sbiw	r30, 0x01	; 1
    1590:	a3 e3       	ldi	r26, 0x33	; 51
    1592:	a0 83       	st	Z, r26
    1594:	31 97       	sbiw	r30, 0x01	; 1
    1596:	60 83       	st	Z, r22
    1598:	31 97       	sbiw	r30, 0x01	; 1
    159a:	70 83       	st	Z, r23
    159c:	31 97       	sbiw	r30, 0x01	; 1
    159e:	10 82       	st	Z, r1
    15a0:	31 97       	sbiw	r30, 0x01	; 1
    15a2:	10 82       	st	Z, r1
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	60 e8       	ldi	r22, 0x80	; 128
    15a8:	60 83       	st	Z, r22
    15aa:	31 97       	sbiw	r30, 0x01	; 1
    15ac:	10 82       	st	Z, r1
    15ae:	31 97       	sbiw	r30, 0x01	; 1
    15b0:	10 82       	st	Z, r1
    15b2:	31 97       	sbiw	r30, 0x01	; 1
    15b4:	10 82       	st	Z, r1
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	62 e0       	ldi	r22, 0x02	; 2
    15ba:	60 83       	st	Z, r22
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	63 e0       	ldi	r22, 0x03	; 3
    15c0:	60 83       	st	Z, r22
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	64 e0       	ldi	r22, 0x04	; 4
    15c6:	60 83       	st	Z, r22
    15c8:	31 97       	sbiw	r30, 0x01	; 1
    15ca:	65 e0       	ldi	r22, 0x05	; 5
    15cc:	60 83       	st	Z, r22
    15ce:	31 97       	sbiw	r30, 0x01	; 1
    15d0:	66 e0       	ldi	r22, 0x06	; 6
    15d2:	60 83       	st	Z, r22
    15d4:	31 97       	sbiw	r30, 0x01	; 1
    15d6:	67 e0       	ldi	r22, 0x07	; 7
    15d8:	60 83       	st	Z, r22
    15da:	31 97       	sbiw	r30, 0x01	; 1
    15dc:	68 e0       	ldi	r22, 0x08	; 8
    15de:	60 83       	st	Z, r22
    15e0:	31 97       	sbiw	r30, 0x01	; 1
    15e2:	69 e0       	ldi	r22, 0x09	; 9
    15e4:	60 83       	st	Z, r22
    15e6:	31 97       	sbiw	r30, 0x01	; 1
    15e8:	60 e1       	ldi	r22, 0x10	; 16
    15ea:	60 83       	st	Z, r22
    15ec:	31 97       	sbiw	r30, 0x01	; 1
    15ee:	30 83       	st	Z, r19
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	32 e1       	ldi	r19, 0x12	; 18
    15f4:	30 83       	st	Z, r19
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	33 e1       	ldi	r19, 0x13	; 19
    15fa:	30 83       	st	Z, r19
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	34 e1       	ldi	r19, 0x14	; 20
    1600:	30 83       	st	Z, r19
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	35 e1       	ldi	r19, 0x15	; 21
    1606:	30 83       	st	Z, r19
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	36 e1       	ldi	r19, 0x16	; 22
    160c:	30 83       	st	Z, r19
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	37 e1       	ldi	r19, 0x17	; 23
    1612:	30 83       	st	Z, r19
    1614:	31 97       	sbiw	r30, 0x01	; 1
    1616:	38 e1       	ldi	r19, 0x18	; 24
    1618:	30 83       	st	Z, r19
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	39 e1       	ldi	r19, 0x19	; 25
    161e:	30 83       	st	Z, r19
    1620:	31 97       	sbiw	r30, 0x01	; 1
    1622:	30 e2       	ldi	r19, 0x20	; 32
    1624:	30 83       	st	Z, r19
    1626:	31 97       	sbiw	r30, 0x01	; 1
    1628:	31 e2       	ldi	r19, 0x21	; 33
    162a:	30 83       	st	Z, r19
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	20 83       	st	Z, r18
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	23 e2       	ldi	r18, 0x23	; 35
    1634:	20 83       	st	Z, r18
    1636:	31 97       	sbiw	r30, 0x01	; 1
    1638:	40 83       	st	Z, r20
    163a:	31 97       	sbiw	r30, 0x01	; 1
    163c:	50 83       	st	Z, r21
    163e:	31 97       	sbiw	r30, 0x01	; 1
    1640:	26 e2       	ldi	r18, 0x26	; 38
    1642:	20 83       	st	Z, r18
    1644:	31 97       	sbiw	r30, 0x01	; 1
    1646:	27 e2       	ldi	r18, 0x27	; 39
    1648:	20 83       	st	Z, r18
    164a:	31 97       	sbiw	r30, 0x01	; 1
    164c:	28 e2       	ldi	r18, 0x28	; 40
    164e:	20 83       	st	Z, r18
    1650:	31 97       	sbiw	r30, 0x01	; 1
    1652:	29 e2       	ldi	r18, 0x29	; 41
    1654:	20 83       	st	Z, r18
    1656:	31 97       	sbiw	r30, 0x01	; 1
    1658:	20 e3       	ldi	r18, 0x30	; 48
    165a:	20 83       	st	Z, r18
    165c:	31 97       	sbiw	r30, 0x01	; 1
    165e:	21 e3       	ldi	r18, 0x31	; 49
    1660:	20 83       	st	Z, r18
    1662:	89 97       	sbiw	r24, 0x29	; 41
    1664:	08 95       	ret

00001666 <xPortStartScheduler>:
    1666:	8c e7       	ldi	r24, 0x7C	; 124
    1668:	80 93 29 08 	sts	0x0829, r24	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    166c:	8f ef       	ldi	r24, 0xFF	; 255
    166e:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    1678:	91 e1       	ldi	r25, 0x11	; 17
    167a:	90 93 01 08 	sts	0x0801, r25	; 0x800801 <__TEXT_REGION_LENGTH__+0x700801>
    167e:	80 93 07 08 	sts	0x0807, r24	; 0x800807 <__TEXT_REGION_LENGTH__+0x700807>
    1682:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1686:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    168a:	cd 91       	ld	r28, X+
    168c:	cd bf       	out	0x3d, r28	; 61
    168e:	dd 91       	ld	r29, X+
    1690:	de bf       	out	0x3e, r29	; 62
    1692:	ff 91       	pop	r31
    1694:	ef 91       	pop	r30
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	bf 91       	pop	r27
    169c:	af 91       	pop	r26
    169e:	9f 91       	pop	r25
    16a0:	8f 91       	pop	r24
    16a2:	7f 91       	pop	r23
    16a4:	6f 91       	pop	r22
    16a6:	5f 91       	pop	r21
    16a8:	4f 91       	pop	r20
    16aa:	3f 91       	pop	r19
    16ac:	2f 91       	pop	r18
    16ae:	1f 91       	pop	r17
    16b0:	0f 91       	pop	r16
    16b2:	ff 90       	pop	r15
    16b4:	ef 90       	pop	r14
    16b6:	df 90       	pop	r13
    16b8:	cf 90       	pop	r12
    16ba:	bf 90       	pop	r11
    16bc:	af 90       	pop	r10
    16be:	9f 90       	pop	r9
    16c0:	8f 90       	pop	r8
    16c2:	7f 90       	pop	r7
    16c4:	6f 90       	pop	r6
    16c6:	5f 90       	pop	r5
    16c8:	4f 90       	pop	r4
    16ca:	3f 90       	pop	r3
    16cc:	2f 90       	pop	r2
    16ce:	1f 90       	pop	r1
    16d0:	0f 90       	pop	r0
    16d2:	0c be       	out	0x3c, r0	; 60
    16d4:	0f 90       	pop	r0
    16d6:	0b be       	out	0x3b, r0	; 59
    16d8:	0f 90       	pop	r0
    16da:	0f be       	out	0x3f, r0	; 63
    16dc:	0f 90       	pop	r0
    16de:	08 95       	ret
    16e0:	08 95       	ret

000016e2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16e2:	0f 92       	push	r0
    16e4:	0f b6       	in	r0, 0x3f	; 63
    16e6:	f8 94       	cli
    16e8:	0f 92       	push	r0
    16ea:	0b b6       	in	r0, 0x3b	; 59
    16ec:	0f 92       	push	r0
    16ee:	0c b6       	in	r0, 0x3c	; 60
    16f0:	0f 92       	push	r0
    16f2:	1f 92       	push	r1
    16f4:	11 24       	eor	r1, r1
    16f6:	2f 92       	push	r2
    16f8:	3f 92       	push	r3
    16fa:	4f 92       	push	r4
    16fc:	5f 92       	push	r5
    16fe:	6f 92       	push	r6
    1700:	7f 92       	push	r7
    1702:	8f 92       	push	r8
    1704:	9f 92       	push	r9
    1706:	af 92       	push	r10
    1708:	bf 92       	push	r11
    170a:	cf 92       	push	r12
    170c:	df 92       	push	r13
    170e:	ef 92       	push	r14
    1710:	ff 92       	push	r15
    1712:	0f 93       	push	r16
    1714:	1f 93       	push	r17
    1716:	2f 93       	push	r18
    1718:	3f 93       	push	r19
    171a:	4f 93       	push	r20
    171c:	5f 93       	push	r21
    171e:	6f 93       	push	r22
    1720:	7f 93       	push	r23
    1722:	8f 93       	push	r24
    1724:	9f 93       	push	r25
    1726:	af 93       	push	r26
    1728:	bf 93       	push	r27
    172a:	cf 93       	push	r28
    172c:	df 93       	push	r29
    172e:	ef 93       	push	r30
    1730:	ff 93       	push	r31
    1732:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1736:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    173a:	0d b6       	in	r0, 0x3d	; 61
    173c:	0d 92       	st	X+, r0
    173e:	0e b6       	in	r0, 0x3e	; 62
    1740:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1742:	0e 94 91 12 	call	0x2522	; 0x2522 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1746:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    174a:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    174e:	cd 91       	ld	r28, X+
    1750:	cd bf       	out	0x3d, r28	; 61
    1752:	dd 91       	ld	r29, X+
    1754:	de bf       	out	0x3e, r29	; 62
    1756:	ff 91       	pop	r31
    1758:	ef 91       	pop	r30
    175a:	df 91       	pop	r29
    175c:	cf 91       	pop	r28
    175e:	bf 91       	pop	r27
    1760:	af 91       	pop	r26
    1762:	9f 91       	pop	r25
    1764:	8f 91       	pop	r24
    1766:	7f 91       	pop	r23
    1768:	6f 91       	pop	r22
    176a:	5f 91       	pop	r21
    176c:	4f 91       	pop	r20
    176e:	3f 91       	pop	r19
    1770:	2f 91       	pop	r18
    1772:	1f 91       	pop	r17
    1774:	0f 91       	pop	r16
    1776:	ff 90       	pop	r15
    1778:	ef 90       	pop	r14
    177a:	df 90       	pop	r13
    177c:	cf 90       	pop	r12
    177e:	bf 90       	pop	r11
    1780:	af 90       	pop	r10
    1782:	9f 90       	pop	r9
    1784:	8f 90       	pop	r8
    1786:	7f 90       	pop	r7
    1788:	6f 90       	pop	r6
    178a:	5f 90       	pop	r5
    178c:	4f 90       	pop	r4
    178e:	3f 90       	pop	r3
    1790:	2f 90       	pop	r2
    1792:	1f 90       	pop	r1
    1794:	0f 90       	pop	r0
    1796:	0c be       	out	0x3c, r0	; 60
    1798:	0f 90       	pop	r0
    179a:	0b be       	out	0x3b, r0	; 59
    179c:	0f 90       	pop	r0
    179e:	0f be       	out	0x3f, r0	; 63
    17a0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17a2:	08 95       	ret

000017a4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17a4:	0f 92       	push	r0
    17a6:	0f b6       	in	r0, 0x3f	; 63
    17a8:	f8 94       	cli
    17aa:	0f 92       	push	r0
    17ac:	0b b6       	in	r0, 0x3b	; 59
    17ae:	0f 92       	push	r0
    17b0:	0c b6       	in	r0, 0x3c	; 60
    17b2:	0f 92       	push	r0
    17b4:	1f 92       	push	r1
    17b6:	11 24       	eor	r1, r1
    17b8:	2f 92       	push	r2
    17ba:	3f 92       	push	r3
    17bc:	4f 92       	push	r4
    17be:	5f 92       	push	r5
    17c0:	6f 92       	push	r6
    17c2:	7f 92       	push	r7
    17c4:	8f 92       	push	r8
    17c6:	9f 92       	push	r9
    17c8:	af 92       	push	r10
    17ca:	bf 92       	push	r11
    17cc:	cf 92       	push	r12
    17ce:	df 92       	push	r13
    17d0:	ef 92       	push	r14
    17d2:	ff 92       	push	r15
    17d4:	0f 93       	push	r16
    17d6:	1f 93       	push	r17
    17d8:	2f 93       	push	r18
    17da:	3f 93       	push	r19
    17dc:	4f 93       	push	r20
    17de:	5f 93       	push	r21
    17e0:	6f 93       	push	r22
    17e2:	7f 93       	push	r23
    17e4:	8f 93       	push	r24
    17e6:	9f 93       	push	r25
    17e8:	af 93       	push	r26
    17ea:	bf 93       	push	r27
    17ec:	cf 93       	push	r28
    17ee:	df 93       	push	r29
    17f0:	ef 93       	push	r30
    17f2:	ff 93       	push	r31
    17f4:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    17f8:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    17fc:	0d b6       	in	r0, 0x3d	; 61
    17fe:	0d 92       	st	X+, r0
    1800:	0e b6       	in	r0, 0x3e	; 62
    1802:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1804:	0e 94 73 10 	call	0x20e6	; 0x20e6 <vTaskIncrementTick>
	vTaskSwitchContext();
    1808:	0e 94 91 12 	call	0x2522	; 0x2522 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    180c:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1810:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1814:	cd 91       	ld	r28, X+
    1816:	cd bf       	out	0x3d, r28	; 61
    1818:	dd 91       	ld	r29, X+
    181a:	de bf       	out	0x3e, r29	; 62
    181c:	ff 91       	pop	r31
    181e:	ef 91       	pop	r30
    1820:	df 91       	pop	r29
    1822:	cf 91       	pop	r28
    1824:	bf 91       	pop	r27
    1826:	af 91       	pop	r26
    1828:	9f 91       	pop	r25
    182a:	8f 91       	pop	r24
    182c:	7f 91       	pop	r23
    182e:	6f 91       	pop	r22
    1830:	5f 91       	pop	r21
    1832:	4f 91       	pop	r20
    1834:	3f 91       	pop	r19
    1836:	2f 91       	pop	r18
    1838:	1f 91       	pop	r17
    183a:	0f 91       	pop	r16
    183c:	ff 90       	pop	r15
    183e:	ef 90       	pop	r14
    1840:	df 90       	pop	r13
    1842:	cf 90       	pop	r12
    1844:	bf 90       	pop	r11
    1846:	af 90       	pop	r10
    1848:	9f 90       	pop	r9
    184a:	8f 90       	pop	r8
    184c:	7f 90       	pop	r7
    184e:	6f 90       	pop	r6
    1850:	5f 90       	pop	r5
    1852:	4f 90       	pop	r4
    1854:	3f 90       	pop	r3
    1856:	2f 90       	pop	r2
    1858:	1f 90       	pop	r1
    185a:	0f 90       	pop	r0
    185c:	0c be       	out	0x3c, r0	; 60
    185e:	0f 90       	pop	r0
    1860:	0b be       	out	0x3b, r0	; 59
    1862:	0f 90       	pop	r0
    1864:	0f be       	out	0x3f, r0	; 63
    1866:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1868:	08 95       	ret

0000186a <__vector_16>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    186a:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    186e:	18 95       	reti

00001870 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1870:	cf 93       	push	r28
    1872:	df 93       	push	r29
    1874:	ec 01       	movw	r28, r24
    1876:	88 a1       	ldd	r24, Y+32	; 0x20
    1878:	81 11       	cpse	r24, r1
    187a:	0b c0       	rjmp	.+22     	; 0x1892 <prvCopyDataToQueue+0x22>
    187c:	88 81       	ld	r24, Y
    187e:	99 81       	ldd	r25, Y+1	; 0x01
    1880:	89 2b       	or	r24, r25
    1882:	e1 f5       	brne	.+120    	; 0x18fc <prvCopyDataToQueue+0x8c>
    1884:	8a 81       	ldd	r24, Y+2	; 0x02
    1886:	9b 81       	ldd	r25, Y+3	; 0x03
    1888:	0e 94 4c 14 	call	0x2898	; 0x2898 <vTaskPriorityDisinherit>
    188c:	1a 82       	std	Y+2, r1	; 0x02
    188e:	1b 82       	std	Y+3, r1	; 0x03
    1890:	35 c0       	rjmp	.+106    	; 0x18fc <prvCopyDataToQueue+0x8c>
    1892:	41 11       	cpse	r20, r1
    1894:	17 c0       	rjmp	.+46     	; 0x18c4 <prvCopyDataToQueue+0x54>
    1896:	48 2f       	mov	r20, r24
    1898:	50 e0       	ldi	r21, 0x00	; 0
    189a:	8c 81       	ldd	r24, Y+4	; 0x04
    189c:	9d 81       	ldd	r25, Y+5	; 0x05
    189e:	0e 94 80 21 	call	0x4300	; 0x4300 <memcpy>
    18a2:	28 a1       	ldd	r18, Y+32	; 0x20
    18a4:	8c 81       	ldd	r24, Y+4	; 0x04
    18a6:	9d 81       	ldd	r25, Y+5	; 0x05
    18a8:	82 0f       	add	r24, r18
    18aa:	91 1d       	adc	r25, r1
    18ac:	8c 83       	std	Y+4, r24	; 0x04
    18ae:	9d 83       	std	Y+5, r25	; 0x05
    18b0:	2a 81       	ldd	r18, Y+2	; 0x02
    18b2:	3b 81       	ldd	r19, Y+3	; 0x03
    18b4:	82 17       	cp	r24, r18
    18b6:	93 07       	cpc	r25, r19
    18b8:	08 f1       	brcs	.+66     	; 0x18fc <prvCopyDataToQueue+0x8c>
    18ba:	88 81       	ld	r24, Y
    18bc:	99 81       	ldd	r25, Y+1	; 0x01
    18be:	8c 83       	std	Y+4, r24	; 0x04
    18c0:	9d 83       	std	Y+5, r25	; 0x05
    18c2:	1c c0       	rjmp	.+56     	; 0x18fc <prvCopyDataToQueue+0x8c>
    18c4:	48 2f       	mov	r20, r24
    18c6:	50 e0       	ldi	r21, 0x00	; 0
    18c8:	8e 81       	ldd	r24, Y+6	; 0x06
    18ca:	9f 81       	ldd	r25, Y+7	; 0x07
    18cc:	0e 94 80 21 	call	0x4300	; 0x4300 <memcpy>
    18d0:	88 a1       	ldd	r24, Y+32	; 0x20
    18d2:	90 e0       	ldi	r25, 0x00	; 0
    18d4:	91 95       	neg	r25
    18d6:	81 95       	neg	r24
    18d8:	91 09       	sbc	r25, r1
    18da:	2e 81       	ldd	r18, Y+6	; 0x06
    18dc:	3f 81       	ldd	r19, Y+7	; 0x07
    18de:	28 0f       	add	r18, r24
    18e0:	39 1f       	adc	r19, r25
    18e2:	2e 83       	std	Y+6, r18	; 0x06
    18e4:	3f 83       	std	Y+7, r19	; 0x07
    18e6:	48 81       	ld	r20, Y
    18e8:	59 81       	ldd	r21, Y+1	; 0x01
    18ea:	24 17       	cp	r18, r20
    18ec:	35 07       	cpc	r19, r21
    18ee:	30 f4       	brcc	.+12     	; 0x18fc <prvCopyDataToQueue+0x8c>
    18f0:	2a 81       	ldd	r18, Y+2	; 0x02
    18f2:	3b 81       	ldd	r19, Y+3	; 0x03
    18f4:	82 0f       	add	r24, r18
    18f6:	93 1f       	adc	r25, r19
    18f8:	8e 83       	std	Y+6, r24	; 0x06
    18fa:	9f 83       	std	Y+7, r25	; 0x07
    18fc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18fe:	8f 5f       	subi	r24, 0xFF	; 255
    1900:	8e 8f       	std	Y+30, r24	; 0x1e
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	08 95       	ret

00001908 <prvCopyDataFromQueue>:
    1908:	fc 01       	movw	r30, r24
    190a:	80 81       	ld	r24, Z
    190c:	91 81       	ldd	r25, Z+1	; 0x01
    190e:	00 97       	sbiw	r24, 0x00	; 0
    1910:	a1 f0       	breq	.+40     	; 0x193a <prvCopyDataFromQueue+0x32>
    1912:	40 a1       	ldd	r20, Z+32	; 0x20
    1914:	50 e0       	ldi	r21, 0x00	; 0
    1916:	26 81       	ldd	r18, Z+6	; 0x06
    1918:	37 81       	ldd	r19, Z+7	; 0x07
    191a:	24 0f       	add	r18, r20
    191c:	35 1f       	adc	r19, r21
    191e:	26 83       	std	Z+6, r18	; 0x06
    1920:	37 83       	std	Z+7, r19	; 0x07
    1922:	a2 81       	ldd	r26, Z+2	; 0x02
    1924:	b3 81       	ldd	r27, Z+3	; 0x03
    1926:	2a 17       	cp	r18, r26
    1928:	3b 07       	cpc	r19, r27
    192a:	10 f0       	brcs	.+4      	; 0x1930 <prvCopyDataFromQueue+0x28>
    192c:	86 83       	std	Z+6, r24	; 0x06
    192e:	97 83       	std	Z+7, r25	; 0x07
    1930:	cb 01       	movw	r24, r22
    1932:	66 81       	ldd	r22, Z+6	; 0x06
    1934:	77 81       	ldd	r23, Z+7	; 0x07
    1936:	0e 94 80 21 	call	0x4300	; 0x4300 <memcpy>
    193a:	08 95       	ret

0000193c <prvUnlockQueue>:
    193c:	0f 93       	push	r16
    193e:	1f 93       	push	r17
    1940:	cf 93       	push	r28
    1942:	df 93       	push	r29
    1944:	ec 01       	movw	r28, r24
    1946:	0f b6       	in	r0, 0x3f	; 63
    1948:	f8 94       	cli
    194a:	0f 92       	push	r0
    194c:	8a a1       	ldd	r24, Y+34	; 0x22
    194e:	18 16       	cp	r1, r24
    1950:	b4 f4       	brge	.+44     	; 0x197e <prvUnlockQueue+0x42>
    1952:	8b 89       	ldd	r24, Y+19	; 0x13
    1954:	81 11       	cpse	r24, r1
    1956:	05 c0       	rjmp	.+10     	; 0x1962 <prvUnlockQueue+0x26>
    1958:	12 c0       	rjmp	.+36     	; 0x197e <prvUnlockQueue+0x42>
    195a:	8b 89       	ldd	r24, Y+19	; 0x13
    195c:	81 11       	cpse	r24, r1
    195e:	04 c0       	rjmp	.+8      	; 0x1968 <prvUnlockQueue+0x2c>
    1960:	0e c0       	rjmp	.+28     	; 0x197e <prvUnlockQueue+0x42>
    1962:	8e 01       	movw	r16, r28
    1964:	0d 5e       	subi	r16, 0xED	; 237
    1966:	1f 4f       	sbci	r17, 0xFF	; 255
    1968:	c8 01       	movw	r24, r16
    196a:	0e 94 18 13 	call	0x2630	; 0x2630 <xTaskRemoveFromEventList>
    196e:	81 11       	cpse	r24, r1
    1970:	0e 94 d5 13 	call	0x27aa	; 0x27aa <vTaskMissedYield>
    1974:	8a a1       	ldd	r24, Y+34	; 0x22
    1976:	81 50       	subi	r24, 0x01	; 1
    1978:	8a a3       	std	Y+34, r24	; 0x22
    197a:	18 16       	cp	r1, r24
    197c:	74 f3       	brlt	.-36     	; 0x195a <prvUnlockQueue+0x1e>
    197e:	8f ef       	ldi	r24, 0xFF	; 255
    1980:	8a a3       	std	Y+34, r24	; 0x22
    1982:	0f 90       	pop	r0
    1984:	0f be       	out	0x3f, r0	; 63
    1986:	0f b6       	in	r0, 0x3f	; 63
    1988:	f8 94       	cli
    198a:	0f 92       	push	r0
    198c:	89 a1       	ldd	r24, Y+33	; 0x21
    198e:	18 16       	cp	r1, r24
    1990:	b4 f4       	brge	.+44     	; 0x19be <prvUnlockQueue+0x82>
    1992:	88 85       	ldd	r24, Y+8	; 0x08
    1994:	81 11       	cpse	r24, r1
    1996:	05 c0       	rjmp	.+10     	; 0x19a2 <prvUnlockQueue+0x66>
    1998:	12 c0       	rjmp	.+36     	; 0x19be <prvUnlockQueue+0x82>
    199a:	88 85       	ldd	r24, Y+8	; 0x08
    199c:	81 11       	cpse	r24, r1
    199e:	04 c0       	rjmp	.+8      	; 0x19a8 <prvUnlockQueue+0x6c>
    19a0:	0e c0       	rjmp	.+28     	; 0x19be <prvUnlockQueue+0x82>
    19a2:	8e 01       	movw	r16, r28
    19a4:	08 5f       	subi	r16, 0xF8	; 248
    19a6:	1f 4f       	sbci	r17, 0xFF	; 255
    19a8:	c8 01       	movw	r24, r16
    19aa:	0e 94 18 13 	call	0x2630	; 0x2630 <xTaskRemoveFromEventList>
    19ae:	81 11       	cpse	r24, r1
    19b0:	0e 94 d5 13 	call	0x27aa	; 0x27aa <vTaskMissedYield>
    19b4:	89 a1       	ldd	r24, Y+33	; 0x21
    19b6:	81 50       	subi	r24, 0x01	; 1
    19b8:	89 a3       	std	Y+33, r24	; 0x21
    19ba:	18 16       	cp	r1, r24
    19bc:	74 f3       	brlt	.-36     	; 0x199a <prvUnlockQueue+0x5e>
    19be:	8f ef       	ldi	r24, 0xFF	; 255
    19c0:	89 a3       	std	Y+33, r24	; 0x21
    19c2:	0f 90       	pop	r0
    19c4:	0f be       	out	0x3f, r0	; 63
    19c6:	df 91       	pop	r29
    19c8:	cf 91       	pop	r28
    19ca:	1f 91       	pop	r17
    19cc:	0f 91       	pop	r16
    19ce:	08 95       	ret

000019d0 <xQueueGenericReset>:
    19d0:	1f 93       	push	r17
    19d2:	cf 93       	push	r28
    19d4:	df 93       	push	r29
    19d6:	61 30       	cpi	r22, 0x01	; 1
    19d8:	59 f0       	breq	.+22     	; 0x19f0 <xQueueGenericReset+0x20>
    19da:	fc 01       	movw	r30, r24
    19dc:	23 89       	ldd	r18, Z+19	; 0x13
    19de:	30 85       	ldd	r19, Z+8	; 0x08
    19e0:	31 11       	cpse	r19, r1
    19e2:	2c c0       	rjmp	.+88     	; 0x1a3c <xQueueGenericReset+0x6c>
    19e4:	11 e0       	ldi	r17, 0x01	; 1
    19e6:	21 11       	cpse	r18, r1
    19e8:	10 e0       	ldi	r17, 0x00	; 0
    19ea:	21 11       	cpse	r18, r1
    19ec:	28 c0       	rjmp	.+80     	; 0x1a3e <xQueueGenericReset+0x6e>
    19ee:	01 c0       	rjmp	.+2      	; 0x19f2 <xQueueGenericReset+0x22>
    19f0:	11 e0       	ldi	r17, 0x01	; 1
    19f2:	ec 01       	movw	r28, r24
    19f4:	48 81       	ld	r20, Y
    19f6:	59 81       	ldd	r21, Y+1	; 0x01
    19f8:	28 a1       	ldd	r18, Y+32	; 0x20
    19fa:	30 e0       	ldi	r19, 0x00	; 0
    19fc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    19fe:	62 9f       	mul	r22, r18
    1a00:	c0 01       	movw	r24, r0
    1a02:	63 9f       	mul	r22, r19
    1a04:	90 0d       	add	r25, r0
    1a06:	11 24       	eor	r1, r1
    1a08:	ba 01       	movw	r22, r20
    1a0a:	68 0f       	add	r22, r24
    1a0c:	79 1f       	adc	r23, r25
    1a0e:	6a 83       	std	Y+2, r22	; 0x02
    1a10:	7b 83       	std	Y+3, r23	; 0x03
    1a12:	1e 8e       	std	Y+30, r1	; 0x1e
    1a14:	4c 83       	std	Y+4, r20	; 0x04
    1a16:	5d 83       	std	Y+5, r21	; 0x05
    1a18:	82 1b       	sub	r24, r18
    1a1a:	93 0b       	sbc	r25, r19
    1a1c:	84 0f       	add	r24, r20
    1a1e:	95 1f       	adc	r25, r21
    1a20:	8e 83       	std	Y+6, r24	; 0x06
    1a22:	9f 83       	std	Y+7, r25	; 0x07
    1a24:	8f ef       	ldi	r24, 0xFF	; 255
    1a26:	89 a3       	std	Y+33, r24	; 0x21
    1a28:	8a a3       	std	Y+34, r24	; 0x22
    1a2a:	ce 01       	movw	r24, r28
    1a2c:	08 96       	adiw	r24, 0x08	; 8
    1a2e:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1a32:	ce 01       	movw	r24, r28
    1a34:	43 96       	adiw	r24, 0x13	; 19
    1a36:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1a3a:	01 c0       	rjmp	.+2      	; 0x1a3e <xQueueGenericReset+0x6e>
    1a3c:	10 e0       	ldi	r17, 0x00	; 0
    1a3e:	81 2f       	mov	r24, r17
    1a40:	df 91       	pop	r29
    1a42:	cf 91       	pop	r28
    1a44:	1f 91       	pop	r17
    1a46:	08 95       	ret

00001a48 <xQueueGenericCreate>:
    1a48:	0f 93       	push	r16
    1a4a:	1f 93       	push	r17
    1a4c:	cf 93       	push	r28
    1a4e:	df 93       	push	r29
    1a50:	88 23       	and	r24, r24
    1a52:	01 f1       	breq	.+64     	; 0x1a94 <xQueueGenericCreate+0x4c>
    1a54:	06 2f       	mov	r16, r22
    1a56:	18 2f       	mov	r17, r24
    1a58:	83 e2       	ldi	r24, 0x23	; 35
    1a5a:	90 e0       	ldi	r25, 0x00	; 0
    1a5c:	0e 94 3e 09 	call	0x127c	; 0x127c <pvPortMalloc>
    1a60:	ec 01       	movw	r28, r24
    1a62:	89 2b       	or	r24, r25
    1a64:	c9 f0       	breq	.+50     	; 0x1a98 <xQueueGenericCreate+0x50>
    1a66:	10 9f       	mul	r17, r16
    1a68:	c0 01       	movw	r24, r0
    1a6a:	11 24       	eor	r1, r1
    1a6c:	01 96       	adiw	r24, 0x01	; 1
    1a6e:	0e 94 3e 09 	call	0x127c	; 0x127c <pvPortMalloc>
    1a72:	88 83       	st	Y, r24
    1a74:	99 83       	std	Y+1, r25	; 0x01
    1a76:	89 2b       	or	r24, r25
    1a78:	39 f0       	breq	.+14     	; 0x1a88 <xQueueGenericCreate+0x40>
    1a7a:	1f 8f       	std	Y+31, r17	; 0x1f
    1a7c:	08 a3       	std	Y+32, r16	; 0x20
    1a7e:	61 e0       	ldi	r22, 0x01	; 1
    1a80:	ce 01       	movw	r24, r28
    1a82:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <xQueueGenericReset>
    1a86:	08 c0       	rjmp	.+16     	; 0x1a98 <xQueueGenericCreate+0x50>
    1a88:	ce 01       	movw	r24, r28
    1a8a:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <vPortFree>
    1a8e:	c0 e0       	ldi	r28, 0x00	; 0
    1a90:	d0 e0       	ldi	r29, 0x00	; 0
    1a92:	02 c0       	rjmp	.+4      	; 0x1a98 <xQueueGenericCreate+0x50>
    1a94:	c0 e0       	ldi	r28, 0x00	; 0
    1a96:	d0 e0       	ldi	r29, 0x00	; 0
    1a98:	ce 01       	movw	r24, r28
    1a9a:	df 91       	pop	r29
    1a9c:	cf 91       	pop	r28
    1a9e:	1f 91       	pop	r17
    1aa0:	0f 91       	pop	r16
    1aa2:	08 95       	ret

00001aa4 <xQueueGenericSend>:
    1aa4:	af 92       	push	r10
    1aa6:	bf 92       	push	r11
    1aa8:	cf 92       	push	r12
    1aaa:	df 92       	push	r13
    1aac:	ef 92       	push	r14
    1aae:	ff 92       	push	r15
    1ab0:	0f 93       	push	r16
    1ab2:	1f 93       	push	r17
    1ab4:	cf 93       	push	r28
    1ab6:	df 93       	push	r29
    1ab8:	cd b7       	in	r28, 0x3d	; 61
    1aba:	de b7       	in	r29, 0x3e	; 62
    1abc:	29 97       	sbiw	r28, 0x09	; 9
    1abe:	cd bf       	out	0x3d, r28	; 61
    1ac0:	de bf       	out	0x3e, r29	; 62
    1ac2:	7c 01       	movw	r14, r24
    1ac4:	5b 01       	movw	r10, r22
    1ac6:	2e 83       	std	Y+6, r18	; 0x06
    1ac8:	3f 83       	std	Y+7, r19	; 0x07
    1aca:	48 87       	std	Y+8, r20	; 0x08
    1acc:	59 87       	std	Y+9, r21	; 0x09
    1ace:	10 e0       	ldi	r17, 0x00	; 0
    1ad0:	6c 01       	movw	r12, r24
    1ad2:	88 e0       	ldi	r24, 0x08	; 8
    1ad4:	c8 0e       	add	r12, r24
    1ad6:	d1 1c       	adc	r13, r1
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
    1ade:	f7 01       	movw	r30, r14
    1ae0:	96 8d       	ldd	r25, Z+30	; 0x1e
    1ae2:	87 8d       	ldd	r24, Z+31	; 0x1f
    1ae4:	98 17       	cp	r25, r24
    1ae6:	a8 f4       	brcc	.+42     	; 0x1b12 <xQueueGenericSend+0x6e>
    1ae8:	40 2f       	mov	r20, r16
    1aea:	b5 01       	movw	r22, r10
    1aec:	c7 01       	movw	r24, r14
    1aee:	0e 94 38 0c 	call	0x1870	; 0x1870 <prvCopyDataToQueue>
    1af2:	f7 01       	movw	r30, r14
    1af4:	83 89       	ldd	r24, Z+19	; 0x13
    1af6:	88 23       	and	r24, r24
    1af8:	41 f0       	breq	.+16     	; 0x1b0a <xQueueGenericSend+0x66>
    1afa:	c7 01       	movw	r24, r14
    1afc:	43 96       	adiw	r24, 0x13	; 19
    1afe:	0e 94 18 13 	call	0x2630	; 0x2630 <xTaskRemoveFromEventList>
    1b02:	81 30       	cpi	r24, 0x01	; 1
    1b04:	11 f4       	brne	.+4      	; 0x1b0a <xQueueGenericSend+0x66>
    1b06:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
    1b0a:	0f 90       	pop	r0
    1b0c:	0f be       	out	0x3f, r0	; 63
    1b0e:	81 e0       	ldi	r24, 0x01	; 1
    1b10:	56 c0       	rjmp	.+172    	; 0x1bbe <xQueueGenericSend+0x11a>
    1b12:	8e 81       	ldd	r24, Y+6	; 0x06
    1b14:	9f 81       	ldd	r25, Y+7	; 0x07
    1b16:	a8 85       	ldd	r26, Y+8	; 0x08
    1b18:	b9 85       	ldd	r27, Y+9	; 0x09
    1b1a:	89 2b       	or	r24, r25
    1b1c:	8a 2b       	or	r24, r26
    1b1e:	8b 2b       	or	r24, r27
    1b20:	21 f4       	brne	.+8      	; 0x1b2a <xQueueGenericSend+0x86>
    1b22:	0f 90       	pop	r0
    1b24:	0f be       	out	0x3f, r0	; 63
    1b26:	80 e0       	ldi	r24, 0x00	; 0
    1b28:	4a c0       	rjmp	.+148    	; 0x1bbe <xQueueGenericSend+0x11a>
    1b2a:	11 11       	cpse	r17, r1
    1b2c:	05 c0       	rjmp	.+10     	; 0x1b38 <xQueueGenericSend+0x94>
    1b2e:	ce 01       	movw	r24, r28
    1b30:	01 96       	adiw	r24, 0x01	; 1
    1b32:	0e 94 57 13 	call	0x26ae	; 0x26ae <vTaskSetTimeOutState>
    1b36:	11 e0       	ldi	r17, 0x01	; 1
    1b38:	0f 90       	pop	r0
    1b3a:	0f be       	out	0x3f, r0	; 63
    1b3c:	0e 94 52 10 	call	0x20a4	; 0x20a4 <vTaskSuspendAll>
    1b40:	0f b6       	in	r0, 0x3f	; 63
    1b42:	f8 94       	cli
    1b44:	0f 92       	push	r0
    1b46:	f7 01       	movw	r30, r14
    1b48:	81 a1       	ldd	r24, Z+33	; 0x21
    1b4a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b4c:	09 f4       	brne	.+2      	; 0x1b50 <xQueueGenericSend+0xac>
    1b4e:	11 a2       	std	Z+33, r1	; 0x21
    1b50:	f7 01       	movw	r30, r14
    1b52:	82 a1       	ldd	r24, Z+34	; 0x22
    1b54:	8f 3f       	cpi	r24, 0xFF	; 255
    1b56:	09 f4       	brne	.+2      	; 0x1b5a <xQueueGenericSend+0xb6>
    1b58:	12 a2       	std	Z+34, r1	; 0x22
    1b5a:	0f 90       	pop	r0
    1b5c:	0f be       	out	0x3f, r0	; 63
    1b5e:	be 01       	movw	r22, r28
    1b60:	6a 5f       	subi	r22, 0xFA	; 250
    1b62:	7f 4f       	sbci	r23, 0xFF	; 255
    1b64:	ce 01       	movw	r24, r28
    1b66:	01 96       	adiw	r24, 0x01	; 1
    1b68:	0e 94 68 13 	call	0x26d0	; 0x26d0 <xTaskCheckForTimeOut>
    1b6c:	81 11       	cpse	r24, r1
    1b6e:	21 c0       	rjmp	.+66     	; 0x1bb2 <xQueueGenericSend+0x10e>
    1b70:	0f b6       	in	r0, 0x3f	; 63
    1b72:	f8 94       	cli
    1b74:	0f 92       	push	r0
    1b76:	f7 01       	movw	r30, r14
    1b78:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b7a:	0f 90       	pop	r0
    1b7c:	0f be       	out	0x3f, r0	; 63
    1b7e:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b80:	98 13       	cpse	r25, r24
    1b82:	11 c0       	rjmp	.+34     	; 0x1ba6 <xQueueGenericSend+0x102>
    1b84:	4e 81       	ldd	r20, Y+6	; 0x06
    1b86:	5f 81       	ldd	r21, Y+7	; 0x07
    1b88:	68 85       	ldd	r22, Y+8	; 0x08
    1b8a:	79 85       	ldd	r23, Y+9	; 0x09
    1b8c:	c6 01       	movw	r24, r12
    1b8e:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vTaskPlaceOnEventList>
    1b92:	c7 01       	movw	r24, r14
    1b94:	0e 94 9e 0c 	call	0x193c	; 0x193c <prvUnlockQueue>
    1b98:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
    1b9c:	81 11       	cpse	r24, r1
    1b9e:	9c cf       	rjmp	.-200    	; 0x1ad8 <xQueueGenericSend+0x34>
    1ba0:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
    1ba4:	99 cf       	rjmp	.-206    	; 0x1ad8 <xQueueGenericSend+0x34>
    1ba6:	c7 01       	movw	r24, r14
    1ba8:	0e 94 9e 0c 	call	0x193c	; 0x193c <prvUnlockQueue>
    1bac:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
    1bb0:	93 cf       	rjmp	.-218    	; 0x1ad8 <xQueueGenericSend+0x34>
    1bb2:	c7 01       	movw	r24, r14
    1bb4:	0e 94 9e 0c 	call	0x193c	; 0x193c <prvUnlockQueue>
    1bb8:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
    1bbc:	80 e0       	ldi	r24, 0x00	; 0
    1bbe:	29 96       	adiw	r28, 0x09	; 9
    1bc0:	cd bf       	out	0x3d, r28	; 61
    1bc2:	de bf       	out	0x3e, r29	; 62
    1bc4:	df 91       	pop	r29
    1bc6:	cf 91       	pop	r28
    1bc8:	1f 91       	pop	r17
    1bca:	0f 91       	pop	r16
    1bcc:	ff 90       	pop	r15
    1bce:	ef 90       	pop	r14
    1bd0:	df 90       	pop	r13
    1bd2:	cf 90       	pop	r12
    1bd4:	bf 90       	pop	r11
    1bd6:	af 90       	pop	r10
    1bd8:	08 95       	ret

00001bda <xQueueGenericReceive>:
    1bda:	af 92       	push	r10
    1bdc:	bf 92       	push	r11
    1bde:	cf 92       	push	r12
    1be0:	df 92       	push	r13
    1be2:	ef 92       	push	r14
    1be4:	ff 92       	push	r15
    1be6:	0f 93       	push	r16
    1be8:	1f 93       	push	r17
    1bea:	cf 93       	push	r28
    1bec:	df 93       	push	r29
    1bee:	cd b7       	in	r28, 0x3d	; 61
    1bf0:	de b7       	in	r29, 0x3e	; 62
    1bf2:	29 97       	sbiw	r28, 0x09	; 9
    1bf4:	cd bf       	out	0x3d, r28	; 61
    1bf6:	de bf       	out	0x3e, r29	; 62
    1bf8:	7c 01       	movw	r14, r24
    1bfa:	5b 01       	movw	r10, r22
    1bfc:	2e 83       	std	Y+6, r18	; 0x06
    1bfe:	3f 83       	std	Y+7, r19	; 0x07
    1c00:	48 87       	std	Y+8, r20	; 0x08
    1c02:	59 87       	std	Y+9, r21	; 0x09
    1c04:	10 e0       	ldi	r17, 0x00	; 0
    1c06:	6c 01       	movw	r12, r24
    1c08:	83 e1       	ldi	r24, 0x13	; 19
    1c0a:	c8 0e       	add	r12, r24
    1c0c:	d1 1c       	adc	r13, r1
    1c0e:	0f b6       	in	r0, 0x3f	; 63
    1c10:	f8 94       	cli
    1c12:	0f 92       	push	r0
    1c14:	f7 01       	movw	r30, r14
    1c16:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c18:	88 23       	and	r24, r24
    1c1a:	99 f1       	breq	.+102    	; 0x1c82 <xQueueGenericReceive+0xa8>
    1c1c:	c6 80       	ldd	r12, Z+6	; 0x06
    1c1e:	d7 80       	ldd	r13, Z+7	; 0x07
    1c20:	b5 01       	movw	r22, r10
    1c22:	c7 01       	movw	r24, r14
    1c24:	0e 94 84 0c 	call	0x1908	; 0x1908 <prvCopyDataFromQueue>
    1c28:	01 11       	cpse	r16, r1
    1c2a:	1a c0       	rjmp	.+52     	; 0x1c60 <xQueueGenericReceive+0x86>
    1c2c:	f7 01       	movw	r30, r14
    1c2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c30:	81 50       	subi	r24, 0x01	; 1
    1c32:	86 8f       	std	Z+30, r24	; 0x1e
    1c34:	80 81       	ld	r24, Z
    1c36:	91 81       	ldd	r25, Z+1	; 0x01
    1c38:	89 2b       	or	r24, r25
    1c3a:	29 f4       	brne	.+10     	; 0x1c46 <xQueueGenericReceive+0x6c>
    1c3c:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <xTaskGetCurrentTaskHandle>
    1c40:	f7 01       	movw	r30, r14
    1c42:	82 83       	std	Z+2, r24	; 0x02
    1c44:	93 83       	std	Z+3, r25	; 0x03
    1c46:	f7 01       	movw	r30, r14
    1c48:	80 85       	ldd	r24, Z+8	; 0x08
    1c4a:	88 23       	and	r24, r24
    1c4c:	b1 f0       	breq	.+44     	; 0x1c7a <xQueueGenericReceive+0xa0>
    1c4e:	c7 01       	movw	r24, r14
    1c50:	08 96       	adiw	r24, 0x08	; 8
    1c52:	0e 94 18 13 	call	0x2630	; 0x2630 <xTaskRemoveFromEventList>
    1c56:	81 30       	cpi	r24, 0x01	; 1
    1c58:	81 f4       	brne	.+32     	; 0x1c7a <xQueueGenericReceive+0xa0>
    1c5a:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
    1c5e:	0d c0       	rjmp	.+26     	; 0x1c7a <xQueueGenericReceive+0xa0>
    1c60:	f7 01       	movw	r30, r14
    1c62:	c6 82       	std	Z+6, r12	; 0x06
    1c64:	d7 82       	std	Z+7, r13	; 0x07
    1c66:	83 89       	ldd	r24, Z+19	; 0x13
    1c68:	88 23       	and	r24, r24
    1c6a:	39 f0       	breq	.+14     	; 0x1c7a <xQueueGenericReceive+0xa0>
    1c6c:	c7 01       	movw	r24, r14
    1c6e:	43 96       	adiw	r24, 0x13	; 19
    1c70:	0e 94 18 13 	call	0x2630	; 0x2630 <xTaskRemoveFromEventList>
    1c74:	81 11       	cpse	r24, r1
    1c76:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
    1c7a:	0f 90       	pop	r0
    1c7c:	0f be       	out	0x3f, r0	; 63
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	62 c0       	rjmp	.+196    	; 0x1d46 <xQueueGenericReceive+0x16c>
    1c82:	8e 81       	ldd	r24, Y+6	; 0x06
    1c84:	9f 81       	ldd	r25, Y+7	; 0x07
    1c86:	a8 85       	ldd	r26, Y+8	; 0x08
    1c88:	b9 85       	ldd	r27, Y+9	; 0x09
    1c8a:	89 2b       	or	r24, r25
    1c8c:	8a 2b       	or	r24, r26
    1c8e:	8b 2b       	or	r24, r27
    1c90:	21 f4       	brne	.+8      	; 0x1c9a <xQueueGenericReceive+0xc0>
    1c92:	0f 90       	pop	r0
    1c94:	0f be       	out	0x3f, r0	; 63
    1c96:	80 e0       	ldi	r24, 0x00	; 0
    1c98:	56 c0       	rjmp	.+172    	; 0x1d46 <xQueueGenericReceive+0x16c>
    1c9a:	11 11       	cpse	r17, r1
    1c9c:	05 c0       	rjmp	.+10     	; 0x1ca8 <xQueueGenericReceive+0xce>
    1c9e:	ce 01       	movw	r24, r28
    1ca0:	01 96       	adiw	r24, 0x01	; 1
    1ca2:	0e 94 57 13 	call	0x26ae	; 0x26ae <vTaskSetTimeOutState>
    1ca6:	11 e0       	ldi	r17, 0x01	; 1
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63
    1cac:	0e 94 52 10 	call	0x20a4	; 0x20a4 <vTaskSuspendAll>
    1cb0:	0f b6       	in	r0, 0x3f	; 63
    1cb2:	f8 94       	cli
    1cb4:	0f 92       	push	r0
    1cb6:	f7 01       	movw	r30, r14
    1cb8:	81 a1       	ldd	r24, Z+33	; 0x21
    1cba:	8f 3f       	cpi	r24, 0xFF	; 255
    1cbc:	09 f4       	brne	.+2      	; 0x1cc0 <xQueueGenericReceive+0xe6>
    1cbe:	11 a2       	std	Z+33, r1	; 0x21
    1cc0:	f7 01       	movw	r30, r14
    1cc2:	82 a1       	ldd	r24, Z+34	; 0x22
    1cc4:	8f 3f       	cpi	r24, 0xFF	; 255
    1cc6:	09 f4       	brne	.+2      	; 0x1cca <xQueueGenericReceive+0xf0>
    1cc8:	12 a2       	std	Z+34, r1	; 0x22
    1cca:	0f 90       	pop	r0
    1ccc:	0f be       	out	0x3f, r0	; 63
    1cce:	be 01       	movw	r22, r28
    1cd0:	6a 5f       	subi	r22, 0xFA	; 250
    1cd2:	7f 4f       	sbci	r23, 0xFF	; 255
    1cd4:	ce 01       	movw	r24, r28
    1cd6:	01 96       	adiw	r24, 0x01	; 1
    1cd8:	0e 94 68 13 	call	0x26d0	; 0x26d0 <xTaskCheckForTimeOut>
    1cdc:	81 11       	cpse	r24, r1
    1cde:	2d c0       	rjmp	.+90     	; 0x1d3a <xQueueGenericReceive+0x160>
    1ce0:	0f b6       	in	r0, 0x3f	; 63
    1ce2:	f8 94       	cli
    1ce4:	0f 92       	push	r0
    1ce6:	f7 01       	movw	r30, r14
    1ce8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cea:	0f 90       	pop	r0
    1cec:	0f be       	out	0x3f, r0	; 63
    1cee:	81 11       	cpse	r24, r1
    1cf0:	1e c0       	rjmp	.+60     	; 0x1d2e <xQueueGenericReceive+0x154>
    1cf2:	80 81       	ld	r24, Z
    1cf4:	91 81       	ldd	r25, Z+1	; 0x01
    1cf6:	89 2b       	or	r24, r25
    1cf8:	49 f4       	brne	.+18     	; 0x1d0c <xQueueGenericReceive+0x132>
    1cfa:	0f b6       	in	r0, 0x3f	; 63
    1cfc:	f8 94       	cli
    1cfe:	0f 92       	push	r0
    1d00:	82 81       	ldd	r24, Z+2	; 0x02
    1d02:	93 81       	ldd	r25, Z+3	; 0x03
    1d04:	0e 94 f7 13 	call	0x27ee	; 0x27ee <vTaskPriorityInherit>
    1d08:	0f 90       	pop	r0
    1d0a:	0f be       	out	0x3f, r0	; 63
    1d0c:	4e 81       	ldd	r20, Y+6	; 0x06
    1d0e:	5f 81       	ldd	r21, Y+7	; 0x07
    1d10:	68 85       	ldd	r22, Y+8	; 0x08
    1d12:	79 85       	ldd	r23, Y+9	; 0x09
    1d14:	c6 01       	movw	r24, r12
    1d16:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vTaskPlaceOnEventList>
    1d1a:	c7 01       	movw	r24, r14
    1d1c:	0e 94 9e 0c 	call	0x193c	; 0x193c <prvUnlockQueue>
    1d20:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
    1d24:	81 11       	cpse	r24, r1
    1d26:	73 cf       	rjmp	.-282    	; 0x1c0e <xQueueGenericReceive+0x34>
    1d28:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
    1d2c:	70 cf       	rjmp	.-288    	; 0x1c0e <xQueueGenericReceive+0x34>
    1d2e:	c7 01       	movw	r24, r14
    1d30:	0e 94 9e 0c 	call	0x193c	; 0x193c <prvUnlockQueue>
    1d34:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
    1d38:	6a cf       	rjmp	.-300    	; 0x1c0e <xQueueGenericReceive+0x34>
    1d3a:	c7 01       	movw	r24, r14
    1d3c:	0e 94 9e 0c 	call	0x193c	; 0x193c <prvUnlockQueue>
    1d40:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
    1d44:	80 e0       	ldi	r24, 0x00	; 0
    1d46:	29 96       	adiw	r28, 0x09	; 9
    1d48:	cd bf       	out	0x3d, r28	; 61
    1d4a:	de bf       	out	0x3e, r29	; 62
    1d4c:	df 91       	pop	r29
    1d4e:	cf 91       	pop	r28
    1d50:	1f 91       	pop	r17
    1d52:	0f 91       	pop	r16
    1d54:	ff 90       	pop	r15
    1d56:	ef 90       	pop	r14
    1d58:	df 90       	pop	r13
    1d5a:	cf 90       	pop	r12
    1d5c:	bf 90       	pop	r11
    1d5e:	af 90       	pop	r10
    1d60:	08 95       	ret

00001d62 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	f8 94       	cli
    1d66:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d68:	fc 01       	movw	r30, r24
    1d6a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d6c:	0f 90       	pop	r0
    1d6e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d70:	08 95       	ret

00001d72 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d72:	c4 e0       	ldi	r28, 0x04	; 4
    1d74:	d1 e3       	ldi	r29, 0x31	; 49
    1d76:	88 81       	ld	r24, Y
    1d78:	82 30       	cpi	r24, 0x02	; 2
    1d7a:	e8 f3       	brcs	.-6      	; 0x1d76 <prvIdleTask+0x4>
    1d7c:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
    1d80:	fa cf       	rjmp	.-12     	; 0x1d76 <prvIdleTask+0x4>

00001d82 <prvAddCurrentTaskToDelayedList>:
    1d82:	cf 92       	push	r12
    1d84:	df 92       	push	r13
    1d86:	ef 92       	push	r14
    1d88:	ff 92       	push	r15
    1d8a:	6b 01       	movw	r12, r22
    1d8c:	7c 01       	movw	r14, r24
    1d8e:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1d92:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1d96:	62 83       	std	Z+2, r22	; 0x02
    1d98:	73 83       	std	Z+3, r23	; 0x03
    1d9a:	84 83       	std	Z+4, r24	; 0x04
    1d9c:	95 83       	std	Z+5, r25	; 0x05
    1d9e:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    1da2:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1da6:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    1daa:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    1dae:	c8 16       	cp	r12, r24
    1db0:	d9 06       	cpc	r13, r25
    1db2:	ea 06       	cpc	r14, r26
    1db4:	fb 06       	cpc	r15, r27
    1db6:	68 f4       	brcc	.+26     	; 0x1dd2 <prvAddCurrentTaskToDelayedList+0x50>
    1db8:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    1dbc:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1dc0:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <pxOverflowDelayedTaskList>
    1dc4:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    1dc8:	6e 5f       	subi	r22, 0xFE	; 254
    1dca:	7f 4f       	sbci	r23, 0xFF	; 255
    1dcc:	0e 94 4c 0a 	call	0x1498	; 0x1498 <vListInsert>
    1dd0:	21 c0       	rjmp	.+66     	; 0x1e14 <prvAddCurrentTaskToDelayedList+0x92>
    1dd2:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    1dd6:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1dda:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1dde:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1de2:	6e 5f       	subi	r22, 0xFE	; 254
    1de4:	7f 4f       	sbci	r23, 0xFF	; 255
    1de6:	0e 94 4c 0a 	call	0x1498	; 0x1498 <vListInsert>
    1dea:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1dee:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1df2:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1df6:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dfa:	c8 16       	cp	r12, r24
    1dfc:	d9 06       	cpc	r13, r25
    1dfe:	ea 06       	cpc	r14, r26
    1e00:	fb 06       	cpc	r15, r27
    1e02:	40 f4       	brcc	.+16     	; 0x1e14 <prvAddCurrentTaskToDelayedList+0x92>
    1e04:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e08:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e0c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e10:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e14:	ff 90       	pop	r15
    1e16:	ef 90       	pop	r14
    1e18:	df 90       	pop	r13
    1e1a:	cf 90       	pop	r12
    1e1c:	08 95       	ret

00001e1e <xTaskGenericCreate>:
    1e1e:	4f 92       	push	r4
    1e20:	5f 92       	push	r5
    1e22:	6f 92       	push	r6
    1e24:	7f 92       	push	r7
    1e26:	8f 92       	push	r8
    1e28:	9f 92       	push	r9
    1e2a:	af 92       	push	r10
    1e2c:	bf 92       	push	r11
    1e2e:	cf 92       	push	r12
    1e30:	df 92       	push	r13
    1e32:	ef 92       	push	r14
    1e34:	ff 92       	push	r15
    1e36:	0f 93       	push	r16
    1e38:	1f 93       	push	r17
    1e3a:	cf 93       	push	r28
    1e3c:	df 93       	push	r29
    1e3e:	5c 01       	movw	r10, r24
    1e40:	4b 01       	movw	r8, r22
    1e42:	3a 01       	movw	r6, r20
    1e44:	29 01       	movw	r4, r18
    1e46:	88 e2       	ldi	r24, 0x28	; 40
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	0e 94 3e 09 	call	0x127c	; 0x127c <pvPortMalloc>
    1e4e:	ec 01       	movw	r28, r24
    1e50:	89 2b       	or	r24, r25
    1e52:	09 f4       	brne	.+2      	; 0x1e56 <xTaskGenericCreate+0x38>
    1e54:	d4 c0       	rjmp	.+424    	; 0x1ffe <xTaskGenericCreate+0x1e0>
    1e56:	c1 14       	cp	r12, r1
    1e58:	d1 04       	cpc	r13, r1
    1e5a:	09 f0       	breq	.+2      	; 0x1e5e <xTaskGenericCreate+0x40>
    1e5c:	cc c0       	rjmp	.+408    	; 0x1ff6 <xTaskGenericCreate+0x1d8>
    1e5e:	c3 01       	movw	r24, r6
    1e60:	0e 94 3e 09 	call	0x127c	; 0x127c <pvPortMalloc>
    1e64:	8b 8f       	std	Y+27, r24	; 0x1b
    1e66:	9c 8f       	std	Y+28, r25	; 0x1c
    1e68:	00 97       	sbiw	r24, 0x00	; 0
    1e6a:	21 f4       	brne	.+8      	; 0x1e74 <xTaskGenericCreate+0x56>
    1e6c:	ce 01       	movw	r24, r28
    1e6e:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <vPortFree>
    1e72:	c5 c0       	rjmp	.+394    	; 0x1ffe <xTaskGenericCreate+0x1e0>
    1e74:	a3 01       	movw	r20, r6
    1e76:	61 e1       	ldi	r22, 0x11	; 17
    1e78:	70 e0       	ldi	r23, 0x00	; 0
    1e7a:	0e 94 89 21 	call	0x4312	; 0x4312 <memset>
    1e7e:	93 01       	movw	r18, r6
    1e80:	21 50       	subi	r18, 0x01	; 1
    1e82:	31 09       	sbc	r19, r1
    1e84:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e86:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e88:	3c 01       	movw	r6, r24
    1e8a:	62 0e       	add	r6, r18
    1e8c:	73 1e       	adc	r7, r19
    1e8e:	4a e0       	ldi	r20, 0x0A	; 10
    1e90:	50 e0       	ldi	r21, 0x00	; 0
    1e92:	b4 01       	movw	r22, r8
    1e94:	ce 01       	movw	r24, r28
    1e96:	4d 96       	adiw	r24, 0x1d	; 29
    1e98:	0e 94 90 21 	call	0x4320	; 0x4320 <strncpy>
    1e9c:	1e a2       	std	Y+38, r1	; 0x26
    1e9e:	10 2f       	mov	r17, r16
    1ea0:	04 30       	cpi	r16, 0x04	; 4
    1ea2:	08 f0       	brcs	.+2      	; 0x1ea6 <xTaskGenericCreate+0x88>
    1ea4:	13 e0       	ldi	r17, 0x03	; 3
    1ea6:	1a 8f       	std	Y+26, r17	; 0x1a
    1ea8:	1f a3       	std	Y+39, r17	; 0x27
    1eaa:	6e 01       	movw	r12, r28
    1eac:	22 e0       	ldi	r18, 0x02	; 2
    1eae:	c2 0e       	add	r12, r18
    1eb0:	d1 1c       	adc	r13, r1
    1eb2:	c6 01       	movw	r24, r12
    1eb4:	0e 94 21 0a 	call	0x1442	; 0x1442 <vListInitialiseItem>
    1eb8:	ce 01       	movw	r24, r28
    1eba:	0e 96       	adiw	r24, 0x0e	; 14
    1ebc:	0e 94 21 0a 	call	0x1442	; 0x1442 <vListInitialiseItem>
    1ec0:	ca 87       	std	Y+10, r28	; 0x0a
    1ec2:	db 87       	std	Y+11, r29	; 0x0b
    1ec4:	84 e0       	ldi	r24, 0x04	; 4
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	a0 e0       	ldi	r26, 0x00	; 0
    1eca:	b0 e0       	ldi	r27, 0x00	; 0
    1ecc:	81 1b       	sub	r24, r17
    1ece:	91 09       	sbc	r25, r1
    1ed0:	a1 09       	sbc	r26, r1
    1ed2:	b1 09       	sbc	r27, r1
    1ed4:	8e 87       	std	Y+14, r24	; 0x0e
    1ed6:	9f 87       	std	Y+15, r25	; 0x0f
    1ed8:	a8 8b       	std	Y+16, r26	; 0x10
    1eda:	b9 8b       	std	Y+17, r27	; 0x11
    1edc:	ce 8b       	std	Y+22, r28	; 0x16
    1ede:	df 8b       	std	Y+23, r29	; 0x17
    1ee0:	a2 01       	movw	r20, r4
    1ee2:	b5 01       	movw	r22, r10
    1ee4:	c3 01       	movw	r24, r6
    1ee6:	0e 94 bd 0a 	call	0x157a	; 0x157a <pxPortInitialiseStack>
    1eea:	88 83       	st	Y, r24
    1eec:	99 83       	std	Y+1, r25	; 0x01
    1eee:	e1 14       	cp	r14, r1
    1ef0:	f1 04       	cpc	r15, r1
    1ef2:	19 f0       	breq	.+6      	; 0x1efa <xTaskGenericCreate+0xdc>
    1ef4:	f7 01       	movw	r30, r14
    1ef6:	c0 83       	st	Z, r28
    1ef8:	d1 83       	std	Z+1, r29	; 0x01
    1efa:	0f b6       	in	r0, 0x3f	; 63
    1efc:	f8 94       	cli
    1efe:	0f 92       	push	r0
    1f00:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    1f04:	8f 5f       	subi	r24, 0xFF	; 255
    1f06:	80 93 dc 30 	sts	0x30DC, r24	; 0x8030dc <uxCurrentNumberOfTasks>
    1f0a:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    1f0e:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1f12:	89 2b       	or	r24, r25
    1f14:	89 f5       	brne	.+98     	; 0x1f78 <xTaskGenericCreate+0x15a>
    1f16:	c0 93 30 31 	sts	0x3130, r28	; 0x803130 <pxCurrentTCB>
    1f1a:	d0 93 31 31 	sts	0x3131, r29	; 0x803131 <pxCurrentTCB+0x1>
    1f1e:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    1f22:	81 30       	cpi	r24, 0x01	; 1
    1f24:	c1 f5       	brne	.+112    	; 0x1f96 <xTaskGenericCreate+0x178>
    1f26:	84 e0       	ldi	r24, 0x04	; 4
    1f28:	91 e3       	ldi	r25, 0x31	; 49
    1f2a:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1f2e:	8f e0       	ldi	r24, 0x0F	; 15
    1f30:	91 e3       	ldi	r25, 0x31	; 49
    1f32:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1f36:	8a e1       	ldi	r24, 0x1A	; 26
    1f38:	91 e3       	ldi	r25, 0x31	; 49
    1f3a:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1f3e:	85 e2       	ldi	r24, 0x25	; 37
    1f40:	91 e3       	ldi	r25, 0x31	; 49
    1f42:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1f46:	89 ef       	ldi	r24, 0xF9	; 249
    1f48:	90 e3       	ldi	r25, 0x30	; 48
    1f4a:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1f4e:	8e ee       	ldi	r24, 0xEE	; 238
    1f50:	90 e3       	ldi	r25, 0x30	; 48
    1f52:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1f56:	8f ed       	ldi	r24, 0xDF	; 223
    1f58:	90 e3       	ldi	r25, 0x30	; 48
    1f5a:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInitialise>
    1f5e:	89 ef       	ldi	r24, 0xF9	; 249
    1f60:	90 e3       	ldi	r25, 0x30	; 48
    1f62:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxDelayedTaskList>
    1f66:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxDelayedTaskList+0x1>
    1f6a:	8e ee       	ldi	r24, 0xEE	; 238
    1f6c:	90 e3       	ldi	r25, 0x30	; 48
    1f6e:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <pxOverflowDelayedTaskList>
    1f72:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    1f76:	0f c0       	rjmp	.+30     	; 0x1f96 <xTaskGenericCreate+0x178>
    1f78:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <xSchedulerRunning>
    1f7c:	81 11       	cpse	r24, r1
    1f7e:	0b c0       	rjmp	.+22     	; 0x1f96 <xTaskGenericCreate+0x178>
    1f80:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1f84:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1f88:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f8a:	08 17       	cp	r16, r24
    1f8c:	20 f0       	brcs	.+8      	; 0x1f96 <xTaskGenericCreate+0x178>
    1f8e:	c0 93 30 31 	sts	0x3130, r28	; 0x803130 <pxCurrentTCB>
    1f92:	d0 93 31 31 	sts	0x3131, r29	; 0x803131 <pxCurrentTCB+0x1>
    1f96:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f98:	90 91 d7 30 	lds	r25, 0x30D7	; 0x8030d7 <uxTopUsedPriority>
    1f9c:	98 17       	cp	r25, r24
    1f9e:	10 f4       	brcc	.+4      	; 0x1fa4 <xTaskGenericCreate+0x186>
    1fa0:	80 93 d7 30 	sts	0x30D7, r24	; 0x8030d7 <uxTopUsedPriority>
    1fa4:	90 91 d0 30 	lds	r25, 0x30D0	; 0x8030d0 <uxTaskNumber>
    1fa8:	9f 5f       	subi	r25, 0xFF	; 255
    1faa:	90 93 d0 30 	sts	0x30D0, r25	; 0x8030d0 <uxTaskNumber>
    1fae:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    1fb2:	98 17       	cp	r25, r24
    1fb4:	10 f4       	brcc	.+4      	; 0x1fba <xTaskGenericCreate+0x19c>
    1fb6:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    1fba:	fb e0       	ldi	r31, 0x0B	; 11
    1fbc:	8f 9f       	mul	r24, r31
    1fbe:	c0 01       	movw	r24, r0
    1fc0:	11 24       	eor	r1, r1
    1fc2:	b6 01       	movw	r22, r12
    1fc4:	8c 5f       	subi	r24, 0xFC	; 252
    1fc6:	9e 4c       	sbci	r25, 0xCE	; 206
    1fc8:	0e 94 25 0a 	call	0x144a	; 0x144a <vListInsertEnd>
    1fcc:	0f 90       	pop	r0
    1fce:	0f be       	out	0x3f, r0	; 63
    1fd0:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <xSchedulerRunning>
    1fd4:	88 23       	and	r24, r24
    1fd6:	59 f0       	breq	.+22     	; 0x1fee <xTaskGenericCreate+0x1d0>
    1fd8:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1fdc:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1fe0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fe2:	80 17       	cp	r24, r16
    1fe4:	30 f4       	brcc	.+12     	; 0x1ff2 <xTaskGenericCreate+0x1d4>
    1fe6:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	09 c0       	rjmp	.+18     	; 0x2000 <xTaskGenericCreate+0x1e2>
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	07 c0       	rjmp	.+14     	; 0x2000 <xTaskGenericCreate+0x1e2>
    1ff2:	81 e0       	ldi	r24, 0x01	; 1
    1ff4:	05 c0       	rjmp	.+10     	; 0x2000 <xTaskGenericCreate+0x1e2>
    1ff6:	cb 8e       	std	Y+27, r12	; 0x1b
    1ff8:	dc 8e       	std	Y+28, r13	; 0x1c
    1ffa:	c6 01       	movw	r24, r12
    1ffc:	3b cf       	rjmp	.-394    	; 0x1e74 <xTaskGenericCreate+0x56>
    1ffe:	8f ef       	ldi	r24, 0xFF	; 255
    2000:	df 91       	pop	r29
    2002:	cf 91       	pop	r28
    2004:	1f 91       	pop	r17
    2006:	0f 91       	pop	r16
    2008:	ff 90       	pop	r15
    200a:	ef 90       	pop	r14
    200c:	df 90       	pop	r13
    200e:	cf 90       	pop	r12
    2010:	bf 90       	pop	r11
    2012:	af 90       	pop	r10
    2014:	9f 90       	pop	r9
    2016:	8f 90       	pop	r8
    2018:	7f 90       	pop	r7
    201a:	6f 90       	pop	r6
    201c:	5f 90       	pop	r5
    201e:	4f 90       	pop	r4
    2020:	08 95       	ret

00002022 <uxTaskPriorityGet>:
    2022:	0f b6       	in	r0, 0x3f	; 63
    2024:	f8 94       	cli
    2026:	0f 92       	push	r0
    2028:	00 97       	sbiw	r24, 0x00	; 0
    202a:	21 f4       	brne	.+8      	; 0x2034 <uxTaskPriorityGet+0x12>
    202c:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2030:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2034:	0f 90       	pop	r0
    2036:	0f be       	out	0x3f, r0	; 63
    2038:	fc 01       	movw	r30, r24
    203a:	82 8d       	ldd	r24, Z+26	; 0x1a
    203c:	08 95       	ret

0000203e <vTaskStartScheduler>:
    203e:	af 92       	push	r10
    2040:	bf 92       	push	r11
    2042:	cf 92       	push	r12
    2044:	df 92       	push	r13
    2046:	ef 92       	push	r14
    2048:	ff 92       	push	r15
    204a:	0f 93       	push	r16
    204c:	a1 2c       	mov	r10, r1
    204e:	b1 2c       	mov	r11, r1
    2050:	c1 2c       	mov	r12, r1
    2052:	d1 2c       	mov	r13, r1
    2054:	0f 2e       	mov	r0, r31
    2056:	fd ed       	ldi	r31, 0xDD	; 221
    2058:	ef 2e       	mov	r14, r31
    205a:	f0 e3       	ldi	r31, 0x30	; 48
    205c:	ff 2e       	mov	r15, r31
    205e:	f0 2d       	mov	r31, r0
    2060:	00 e0       	ldi	r16, 0x00	; 0
    2062:	20 e0       	ldi	r18, 0x00	; 0
    2064:	30 e0       	ldi	r19, 0x00	; 0
    2066:	44 e6       	ldi	r20, 0x64	; 100
    2068:	50 e0       	ldi	r21, 0x00	; 0
    206a:	67 e4       	ldi	r22, 0x47	; 71
    206c:	70 e2       	ldi	r23, 0x20	; 32
    206e:	89 eb       	ldi	r24, 0xB9	; 185
    2070:	9e e0       	ldi	r25, 0x0E	; 14
    2072:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <xTaskGenericCreate>
    2076:	81 30       	cpi	r24, 0x01	; 1
    2078:	69 f4       	brne	.+26     	; 0x2094 <vTaskStartScheduler+0x56>
    207a:	f8 94       	cli
    207c:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <xSchedulerRunning>
    2080:	10 92 d8 30 	sts	0x30D8, r1	; 0x8030d8 <xTickCount>
    2084:	10 92 d9 30 	sts	0x30D9, r1	; 0x8030d9 <xTickCount+0x1>
    2088:	10 92 da 30 	sts	0x30DA, r1	; 0x8030da <xTickCount+0x2>
    208c:	10 92 db 30 	sts	0x30DB, r1	; 0x8030db <xTickCount+0x3>
    2090:	0e 94 33 0b 	call	0x1666	; 0x1666 <xPortStartScheduler>
    2094:	0f 91       	pop	r16
    2096:	ff 90       	pop	r15
    2098:	ef 90       	pop	r14
    209a:	df 90       	pop	r13
    209c:	cf 90       	pop	r12
    209e:	bf 90       	pop	r11
    20a0:	af 90       	pop	r10
    20a2:	08 95       	ret

000020a4 <vTaskSuspendAll>:
    20a4:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    20a8:	8f 5f       	subi	r24, 0xFF	; 255
    20aa:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <uxSchedulerSuspended>
    20ae:	08 95       	ret

000020b0 <xTaskGetTickCount>:
    20b0:	0f b6       	in	r0, 0x3f	; 63
    20b2:	f8 94       	cli
    20b4:	0f 92       	push	r0
    20b6:	60 91 d8 30 	lds	r22, 0x30D8	; 0x8030d8 <xTickCount>
    20ba:	70 91 d9 30 	lds	r23, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    20be:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount+0x2>
    20c2:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x3>
    20c6:	0f 90       	pop	r0
    20c8:	0f be       	out	0x3f, r0	; 63
    20ca:	08 95       	ret

000020cc <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20cc:	00 97       	sbiw	r24, 0x00	; 0
    20ce:	21 f4       	brne	.+8      	; 0x20d8 <pcTaskGetTaskName+0xc>
    20d0:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    20d4:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20d8:	4d 96       	adiw	r24, 0x1d	; 29
    20da:	08 95       	ret

000020dc <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20dc:	80 91 dd 30 	lds	r24, 0x30DD	; 0x8030dd <xIdleTaskHandle>
    20e0:	90 91 de 30 	lds	r25, 0x30DE	; 0x8030de <xIdleTaskHandle+0x1>
    20e4:	08 95       	ret

000020e6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20e6:	ff 92       	push	r15
    20e8:	0f 93       	push	r16
    20ea:	1f 93       	push	r17
    20ec:	cf 93       	push	r28
    20ee:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20f0:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    20f4:	81 11       	cpse	r24, r1
    20f6:	ed c0       	rjmp	.+474    	; 0x22d2 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    20f8:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    20fc:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2100:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2104:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2108:	01 96       	adiw	r24, 0x01	; 1
    210a:	a1 1d       	adc	r26, r1
    210c:	b1 1d       	adc	r27, r1
    210e:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <xTickCount>
    2112:	90 93 d9 30 	sts	0x30D9, r25	; 0x8030d9 <xTickCount+0x1>
    2116:	a0 93 da 30 	sts	0x30DA, r26	; 0x8030da <xTickCount+0x2>
    211a:	b0 93 db 30 	sts	0x30DB, r27	; 0x8030db <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    211e:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2122:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2126:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    212a:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    212e:	89 2b       	or	r24, r25
    2130:	8a 2b       	or	r24, r26
    2132:	8b 2b       	or	r24, r27
    2134:	f1 f5       	brne	.+124    	; 0x21b2 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2136:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    213a:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    213e:	20 91 ea 30 	lds	r18, 0x30EA	; 0x8030ea <pxOverflowDelayedTaskList>
    2142:	30 91 eb 30 	lds	r19, 0x30EB	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    2146:	20 93 ec 30 	sts	0x30EC, r18	; 0x8030ec <pxDelayedTaskList>
    214a:	30 93 ed 30 	sts	0x30ED, r19	; 0x8030ed <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    214e:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <pxOverflowDelayedTaskList>
    2152:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2156:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    215a:	8f 5f       	subi	r24, 0xFF	; 255
    215c:	80 93 d1 30 	sts	0x30D1, r24	; 0x8030d1 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2160:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    2164:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    2168:	80 81       	ld	r24, Z
    216a:	81 11       	cpse	r24, r1
    216c:	0c c0       	rjmp	.+24     	; 0x2186 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    216e:	8f ef       	ldi	r24, 0xFF	; 255
    2170:	9f ef       	ldi	r25, 0xFF	; 255
    2172:	dc 01       	movw	r26, r24
    2174:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2178:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    217c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2180:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2184:	16 c0       	rjmp	.+44     	; 0x21b2 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2186:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    218a:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    218e:	07 80       	ldd	r0, Z+7	; 0x07
    2190:	f0 85       	ldd	r31, Z+8	; 0x08
    2192:	e0 2d       	mov	r30, r0
    2194:	00 84       	ldd	r0, Z+8	; 0x08
    2196:	f1 85       	ldd	r31, Z+9	; 0x09
    2198:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    219a:	82 81       	ldd	r24, Z+2	; 0x02
    219c:	93 81       	ldd	r25, Z+3	; 0x03
    219e:	a4 81       	ldd	r26, Z+4	; 0x04
    21a0:	b5 81       	ldd	r27, Z+5	; 0x05
    21a2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21a6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21aa:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21ae:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    21b2:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    21b6:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    21ba:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    21be:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    21c2:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    21c6:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21ca:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21ce:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21d2:	48 17       	cp	r20, r24
    21d4:	59 07       	cpc	r21, r25
    21d6:	6a 07       	cpc	r22, r26
    21d8:	7b 07       	cpc	r23, r27
    21da:	08 f4       	brcc	.+2      	; 0x21de <vTaskIncrementTick+0xf8>
    21dc:	7f c0       	rjmp	.+254    	; 0x22dc <vTaskIncrementTick+0x1f6>
    21de:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    21e2:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    21e6:	80 81       	ld	r24, Z
    21e8:	88 23       	and	r24, r24
    21ea:	f9 f0       	breq	.+62     	; 0x222a <vTaskIncrementTick+0x144>
    21ec:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    21f0:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    21f4:	07 80       	ldd	r0, Z+7	; 0x07
    21f6:	f0 85       	ldd	r31, Z+8	; 0x08
    21f8:	e0 2d       	mov	r30, r0
    21fa:	c0 85       	ldd	r28, Z+8	; 0x08
    21fc:	d1 85       	ldd	r29, Z+9	; 0x09
    21fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2200:	9b 81       	ldd	r25, Y+3	; 0x03
    2202:	ac 81       	ldd	r26, Y+4	; 0x04
    2204:	bd 81       	ldd	r27, Y+5	; 0x05
    2206:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    220a:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    220e:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    2212:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    2216:	48 17       	cp	r20, r24
    2218:	59 07       	cpc	r21, r25
    221a:	6a 07       	cpc	r22, r26
    221c:	7b 07       	cpc	r23, r27
    221e:	58 f1       	brcs	.+86     	; 0x2276 <vTaskIncrementTick+0x190>
    2220:	0f 2e       	mov	r0, r31
    2222:	fb e0       	ldi	r31, 0x0B	; 11
    2224:	ff 2e       	mov	r15, r31
    2226:	f0 2d       	mov	r31, r0
    2228:	2f c0       	rjmp	.+94     	; 0x2288 <vTaskIncrementTick+0x1a2>
    222a:	8f ef       	ldi	r24, 0xFF	; 255
    222c:	9f ef       	ldi	r25, 0xFF	; 255
    222e:	dc 01       	movw	r26, r24
    2230:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2234:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2238:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    223c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2240:	4d c0       	rjmp	.+154    	; 0x22dc <vTaskIncrementTick+0x1f6>
    2242:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    2246:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    224a:	07 80       	ldd	r0, Z+7	; 0x07
    224c:	f0 85       	ldd	r31, Z+8	; 0x08
    224e:	e0 2d       	mov	r30, r0
    2250:	c0 85       	ldd	r28, Z+8	; 0x08
    2252:	d1 85       	ldd	r29, Z+9	; 0x09
    2254:	8a 81       	ldd	r24, Y+2	; 0x02
    2256:	9b 81       	ldd	r25, Y+3	; 0x03
    2258:	ac 81       	ldd	r26, Y+4	; 0x04
    225a:	bd 81       	ldd	r27, Y+5	; 0x05
    225c:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    2260:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2264:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    2268:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    226c:	48 17       	cp	r20, r24
    226e:	59 07       	cpc	r21, r25
    2270:	6a 07       	cpc	r22, r26
    2272:	7b 07       	cpc	r23, r27
    2274:	48 f4       	brcc	.+18     	; 0x2288 <vTaskIncrementTick+0x1a2>
    2276:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    227a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    227e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2282:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2286:	2a c0       	rjmp	.+84     	; 0x22dc <vTaskIncrementTick+0x1f6>
    2288:	8e 01       	movw	r16, r28
    228a:	0e 5f       	subi	r16, 0xFE	; 254
    228c:	1f 4f       	sbci	r17, 0xFF	; 255
    228e:	c8 01       	movw	r24, r16
    2290:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>
    2294:	88 8d       	ldd	r24, Y+24	; 0x18
    2296:	99 8d       	ldd	r25, Y+25	; 0x19
    2298:	89 2b       	or	r24, r25
    229a:	21 f0       	breq	.+8      	; 0x22a4 <vTaskIncrementTick+0x1be>
    229c:	ce 01       	movw	r24, r28
    229e:	0e 96       	adiw	r24, 0x0e	; 14
    22a0:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>
    22a4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22a6:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    22aa:	98 17       	cp	r25, r24
    22ac:	10 f4       	brcc	.+4      	; 0x22b2 <vTaskIncrementTick+0x1cc>
    22ae:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    22b2:	f8 9e       	mul	r15, r24
    22b4:	c0 01       	movw	r24, r0
    22b6:	11 24       	eor	r1, r1
    22b8:	b8 01       	movw	r22, r16
    22ba:	8c 5f       	subi	r24, 0xFC	; 252
    22bc:	9e 4c       	sbci	r25, 0xCE	; 206
    22be:	0e 94 25 0a 	call	0x144a	; 0x144a <vListInsertEnd>
    22c2:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    22c6:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    22ca:	80 81       	ld	r24, Z
    22cc:	81 11       	cpse	r24, r1
    22ce:	b9 cf       	rjmp	.-142    	; 0x2242 <vTaskIncrementTick+0x15c>
    22d0:	ac cf       	rjmp	.-168    	; 0x222a <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22d2:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    22d6:	8f 5f       	subi	r24, 0xFF	; 255
    22d8:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22dc:	df 91       	pop	r29
    22de:	cf 91       	pop	r28
    22e0:	1f 91       	pop	r17
    22e2:	0f 91       	pop	r16
    22e4:	ff 90       	pop	r15
    22e6:	08 95       	ret

000022e8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22e8:	cf 92       	push	r12
    22ea:	df 92       	push	r13
    22ec:	ef 92       	push	r14
    22ee:	ff 92       	push	r15
    22f0:	0f 93       	push	r16
    22f2:	1f 93       	push	r17
    22f4:	cf 93       	push	r28
    22f6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    22f8:	0f b6       	in	r0, 0x3f	; 63
    22fa:	f8 94       	cli
    22fc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    22fe:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2302:	81 50       	subi	r24, 0x01	; 1
    2304:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2308:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    230c:	81 11       	cpse	r24, r1
    230e:	60 c0       	rjmp	.+192    	; 0x23d0 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2310:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    2314:	81 11       	cpse	r24, r1
    2316:	2c c0       	rjmp	.+88     	; 0x2370 <xTaskResumeAll+0x88>
    2318:	5e c0       	rjmp	.+188    	; 0x23d6 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    231a:	d7 01       	movw	r26, r14
    231c:	17 96       	adiw	r26, 0x07	; 7
    231e:	ed 91       	ld	r30, X+
    2320:	fc 91       	ld	r31, X
    2322:	18 97       	sbiw	r26, 0x08	; 8
    2324:	c0 85       	ldd	r28, Z+8	; 0x08
    2326:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2328:	ce 01       	movw	r24, r28
    232a:	0e 96       	adiw	r24, 0x0e	; 14
    232c:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2330:	8e 01       	movw	r16, r28
    2332:	0e 5f       	subi	r16, 0xFE	; 254
    2334:	1f 4f       	sbci	r17, 0xFF	; 255
    2336:	c8 01       	movw	r24, r16
    2338:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    233c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    233e:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2342:	98 17       	cp	r25, r24
    2344:	10 f4       	brcc	.+4      	; 0x234a <xTaskResumeAll+0x62>
    2346:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    234a:	d8 9e       	mul	r13, r24
    234c:	c0 01       	movw	r24, r0
    234e:	11 24       	eor	r1, r1
    2350:	b8 01       	movw	r22, r16
    2352:	8c 5f       	subi	r24, 0xFC	; 252
    2354:	9e 4c       	sbci	r25, 0xCE	; 206
    2356:	0e 94 25 0a 	call	0x144a	; 0x144a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    235a:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    235e:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2362:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2364:	82 8d       	ldd	r24, Z+26	; 0x1a
    2366:	98 17       	cp	r25, r24
    2368:	70 f0       	brcs	.+28     	; 0x2386 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    236a:	cc 24       	eor	r12, r12
    236c:	c3 94       	inc	r12
    236e:	0b c0       	rjmp	.+22     	; 0x2386 <xTaskResumeAll+0x9e>
    2370:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2372:	0f 2e       	mov	r0, r31
    2374:	ff ed       	ldi	r31, 0xDF	; 223
    2376:	ef 2e       	mov	r14, r31
    2378:	f0 e3       	ldi	r31, 0x30	; 48
    237a:	ff 2e       	mov	r15, r31
    237c:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    237e:	0f 2e       	mov	r0, r31
    2380:	fb e0       	ldi	r31, 0x0B	; 11
    2382:	df 2e       	mov	r13, r31
    2384:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2386:	f7 01       	movw	r30, r14
    2388:	80 81       	ld	r24, Z
    238a:	81 11       	cpse	r24, r1
    238c:	c6 cf       	rjmp	.-116    	; 0x231a <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    238e:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    2392:	88 23       	and	r24, r24
    2394:	81 f0       	breq	.+32     	; 0x23b6 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2396:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    239a:	88 23       	and	r24, r24
    239c:	99 f0       	breq	.+38     	; 0x23c4 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    239e:	0e 94 73 10 	call	0x20e6	; 0x20e6 <vTaskIncrementTick>
						--uxMissedTicks;
    23a2:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    23a6:	81 50       	subi	r24, 0x01	; 1
    23a8:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23ac:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    23b0:	81 11       	cpse	r24, r1
    23b2:	f5 cf       	rjmp	.-22     	; 0x239e <xTaskResumeAll+0xb6>
    23b4:	07 c0       	rjmp	.+14     	; 0x23c4 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    23b6:	f1 e0       	ldi	r31, 0x01	; 1
    23b8:	cf 16       	cp	r12, r31
    23ba:	21 f0       	breq	.+8      	; 0x23c4 <xTaskResumeAll+0xdc>
    23bc:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <xMissedYield>
    23c0:	81 30       	cpi	r24, 0x01	; 1
    23c2:	41 f4       	brne	.+16     	; 0x23d4 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23c4:	10 92 d2 30 	sts	0x30D2, r1	; 0x8030d2 <xMissedYield>
					portYIELD_WITHIN_API();
    23c8:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	03 c0       	rjmp	.+6      	; 0x23d6 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23d0:	80 e0       	ldi	r24, 0x00	; 0
    23d2:	01 c0       	rjmp	.+2      	; 0x23d6 <xTaskResumeAll+0xee>
    23d4:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23d6:	0f 90       	pop	r0
    23d8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23da:	df 91       	pop	r29
    23dc:	cf 91       	pop	r28
    23de:	1f 91       	pop	r17
    23e0:	0f 91       	pop	r16
    23e2:	ff 90       	pop	r15
    23e4:	ef 90       	pop	r14
    23e6:	df 90       	pop	r13
    23e8:	cf 90       	pop	r12
    23ea:	08 95       	ret

000023ec <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    23ec:	cf 92       	push	r12
    23ee:	df 92       	push	r13
    23f0:	ef 92       	push	r14
    23f2:	ff 92       	push	r15
    23f4:	cf 93       	push	r28
    23f6:	df 93       	push	r29
    23f8:	ec 01       	movw	r28, r24
    23fa:	6a 01       	movw	r12, r20
    23fc:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    23fe:	0e 94 52 10 	call	0x20a4	; 0x20a4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2402:	88 81       	ld	r24, Y
    2404:	99 81       	ldd	r25, Y+1	; 0x01
    2406:	aa 81       	ldd	r26, Y+2	; 0x02
    2408:	bb 81       	ldd	r27, Y+3	; 0x03
    240a:	c8 0e       	add	r12, r24
    240c:	d9 1e       	adc	r13, r25
    240e:	ea 1e       	adc	r14, r26
    2410:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2412:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    2416:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    241a:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    241e:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    2422:	48 17       	cp	r20, r24
    2424:	59 07       	cpc	r21, r25
    2426:	6a 07       	cpc	r22, r26
    2428:	7b 07       	cpc	r23, r27
    242a:	b8 f4       	brcc	.+46     	; 0x245a <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    242c:	c8 16       	cp	r12, r24
    242e:	d9 06       	cpc	r13, r25
    2430:	ea 06       	cpc	r14, r26
    2432:	fb 06       	cpc	r15, r27
    2434:	e0 f5       	brcc	.+120    	; 0x24ae <vTaskDelayUntil+0xc2>
    2436:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    243a:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    243e:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2442:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2446:	c8 82       	st	Y, r12
    2448:	d9 82       	std	Y+1, r13	; 0x01
    244a:	ea 82       	std	Y+2, r14	; 0x02
    244c:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    244e:	8c 15       	cp	r24, r12
    2450:	9d 05       	cpc	r25, r13
    2452:	ae 05       	cpc	r26, r14
    2454:	bf 05       	cpc	r27, r15
    2456:	f8 f4       	brcc	.+62     	; 0x2496 <vTaskDelayUntil+0xaa>
    2458:	13 c0       	rjmp	.+38     	; 0x2480 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    245a:	c8 16       	cp	r12, r24
    245c:	d9 06       	cpc	r13, r25
    245e:	ea 06       	cpc	r14, r26
    2460:	fb 06       	cpc	r15, r27
    2462:	00 f1       	brcs	.+64     	; 0x24a4 <vTaskDelayUntil+0xb8>
    2464:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2468:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    246c:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2470:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2474:	8c 15       	cp	r24, r12
    2476:	9d 05       	cpc	r25, r13
    2478:	ae 05       	cpc	r26, r14
    247a:	bf 05       	cpc	r27, r15
    247c:	98 f0       	brcs	.+38     	; 0x24a4 <vTaskDelayUntil+0xb8>
    247e:	17 c0       	rjmp	.+46     	; 0x24ae <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2480:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2484:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2488:	02 96       	adiw	r24, 0x02	; 2
    248a:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    248e:	c7 01       	movw	r24, r14
    2490:	b6 01       	movw	r22, r12
    2492:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2496:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    249a:	81 11       	cpse	r24, r1
    249c:	0d c0       	rjmp	.+26     	; 0x24b8 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    249e:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
		}
	}
    24a2:	0a c0       	rjmp	.+20     	; 0x24b8 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24a4:	c8 82       	st	Y, r12
    24a6:	d9 82       	std	Y+1, r13	; 0x01
    24a8:	ea 82       	std	Y+2, r14	; 0x02
    24aa:	fb 82       	std	Y+3, r15	; 0x03
    24ac:	e9 cf       	rjmp	.-46     	; 0x2480 <vTaskDelayUntil+0x94>
    24ae:	c8 82       	st	Y, r12
    24b0:	d9 82       	std	Y+1, r13	; 0x01
    24b2:	ea 82       	std	Y+2, r14	; 0x02
    24b4:	fb 82       	std	Y+3, r15	; 0x03
    24b6:	ef cf       	rjmp	.-34     	; 0x2496 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    24b8:	df 91       	pop	r29
    24ba:	cf 91       	pop	r28
    24bc:	ff 90       	pop	r15
    24be:	ef 90       	pop	r14
    24c0:	df 90       	pop	r13
    24c2:	cf 90       	pop	r12
    24c4:	08 95       	ret

000024c6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    24c6:	cf 92       	push	r12
    24c8:	df 92       	push	r13
    24ca:	ef 92       	push	r14
    24cc:	ff 92       	push	r15
    24ce:	6b 01       	movw	r12, r22
    24d0:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24d2:	67 2b       	or	r22, r23
    24d4:	68 2b       	or	r22, r24
    24d6:	69 2b       	or	r22, r25
    24d8:	e9 f0       	breq	.+58     	; 0x2514 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    24da:	0e 94 52 10 	call	0x20a4	; 0x20a4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24de:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    24e2:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    24e6:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    24ea:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    24ee:	c8 0e       	add	r12, r24
    24f0:	d9 1e       	adc	r13, r25
    24f2:	ea 1e       	adc	r14, r26
    24f4:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24f6:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    24fa:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    24fe:	02 96       	adiw	r24, 0x02	; 2
    2500:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2504:	c7 01       	movw	r24, r14
    2506:	b6 01       	movw	r22, r12
    2508:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    250c:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2510:	81 11       	cpse	r24, r1
    2512:	02 c0       	rjmp	.+4      	; 0x2518 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2514:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <vPortYield>
		}
	}
    2518:	ff 90       	pop	r15
    251a:	ef 90       	pop	r14
    251c:	df 90       	pop	r13
    251e:	cf 90       	pop	r12
    2520:	08 95       	ret

00002522 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2522:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2526:	81 11       	cpse	r24, r1
    2528:	0c c0       	rjmp	.+24     	; 0x2542 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    252a:	e0 91 d6 30 	lds	r30, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    252e:	4b e0       	ldi	r20, 0x0B	; 11
    2530:	e4 9f       	mul	r30, r20
    2532:	f0 01       	movw	r30, r0
    2534:	11 24       	eor	r1, r1
    2536:	ec 5f       	subi	r30, 0xFC	; 252
    2538:	fe 4c       	sbci	r31, 0xCE	; 206
    253a:	80 81       	ld	r24, Z
    253c:	88 23       	and	r24, r24
    253e:	29 f0       	breq	.+10     	; 0x254a <vTaskSwitchContext+0x28>
    2540:	14 c0       	rjmp	.+40     	; 0x256a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <xMissedYield>
    2548:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    254a:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    254c:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2550:	81 50       	subi	r24, 0x01	; 1
    2552:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2556:	e0 91 d6 30 	lds	r30, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    255a:	9e 9f       	mul	r25, r30
    255c:	f0 01       	movw	r30, r0
    255e:	11 24       	eor	r1, r1
    2560:	ec 5f       	subi	r30, 0xFC	; 252
    2562:	fe 4c       	sbci	r31, 0xCE	; 206
    2564:	80 81       	ld	r24, Z
    2566:	88 23       	and	r24, r24
    2568:	89 f3       	breq	.-30     	; 0x254c <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    256a:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    256e:	28 2f       	mov	r18, r24
    2570:	30 e0       	ldi	r19, 0x00	; 0
    2572:	4b e0       	ldi	r20, 0x0B	; 11
    2574:	84 9f       	mul	r24, r20
    2576:	c0 01       	movw	r24, r0
    2578:	11 24       	eor	r1, r1
    257a:	dc 01       	movw	r26, r24
    257c:	ac 5f       	subi	r26, 0xFC	; 252
    257e:	be 4c       	sbci	r27, 0xCE	; 206
    2580:	11 96       	adiw	r26, 0x01	; 1
    2582:	ed 91       	ld	r30, X+
    2584:	fc 91       	ld	r31, X
    2586:	12 97       	sbiw	r26, 0x02	; 2
    2588:	04 80       	ldd	r0, Z+4	; 0x04
    258a:	f5 81       	ldd	r31, Z+5	; 0x05
    258c:	e0 2d       	mov	r30, r0
    258e:	11 96       	adiw	r26, 0x01	; 1
    2590:	ed 93       	st	X+, r30
    2592:	fc 93       	st	X, r31
    2594:	12 97       	sbiw	r26, 0x02	; 2
    2596:	89 5f       	subi	r24, 0xF9	; 249
    2598:	9e 4c       	sbci	r25, 0xCE	; 206
    259a:	e8 17       	cp	r30, r24
    259c:	f9 07       	cpc	r31, r25
    259e:	61 f4       	brne	.+24     	; 0x25b8 <vTaskSwitchContext+0x96>
    25a0:	84 81       	ldd	r24, Z+4	; 0x04
    25a2:	95 81       	ldd	r25, Z+5	; 0x05
    25a4:	4b e0       	ldi	r20, 0x0B	; 11
    25a6:	42 9f       	mul	r20, r18
    25a8:	f0 01       	movw	r30, r0
    25aa:	43 9f       	mul	r20, r19
    25ac:	f0 0d       	add	r31, r0
    25ae:	11 24       	eor	r1, r1
    25b0:	ec 5f       	subi	r30, 0xFC	; 252
    25b2:	fe 4c       	sbci	r31, 0xCE	; 206
    25b4:	81 83       	std	Z+1, r24	; 0x01
    25b6:	92 83       	std	Z+2, r25	; 0x02
    25b8:	8b e0       	ldi	r24, 0x0B	; 11
    25ba:	82 9f       	mul	r24, r18
    25bc:	f0 01       	movw	r30, r0
    25be:	83 9f       	mul	r24, r19
    25c0:	f0 0d       	add	r31, r0
    25c2:	11 24       	eor	r1, r1
    25c4:	ec 5f       	subi	r30, 0xFC	; 252
    25c6:	fe 4c       	sbci	r31, 0xCE	; 206
    25c8:	01 80       	ldd	r0, Z+1	; 0x01
    25ca:	f2 81       	ldd	r31, Z+2	; 0x02
    25cc:	e0 2d       	mov	r30, r0
    25ce:	80 85       	ldd	r24, Z+8	; 0x08
    25d0:	91 85       	ldd	r25, Z+9	; 0x09
    25d2:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <pxCurrentTCB>
    25d6:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <pxCurrentTCB+0x1>
    25da:	08 95       	ret

000025dc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25dc:	cf 92       	push	r12
    25de:	df 92       	push	r13
    25e0:	ef 92       	push	r14
    25e2:	ff 92       	push	r15
    25e4:	6a 01       	movw	r12, r20
    25e6:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25e8:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    25ec:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    25f0:	62 5f       	subi	r22, 0xF2	; 242
    25f2:	7f 4f       	sbci	r23, 0xFF	; 255
    25f4:	0e 94 4c 0a 	call	0x1498	; 0x1498 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25f8:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    25fc:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2600:	02 96       	adiw	r24, 0x02	; 2
    2602:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2606:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    260a:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    260e:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2612:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2616:	bc 01       	movw	r22, r24
    2618:	cd 01       	movw	r24, r26
    261a:	6c 0d       	add	r22, r12
    261c:	7d 1d       	adc	r23, r13
    261e:	8e 1d       	adc	r24, r14
    2620:	9f 1d       	adc	r25, r15
    2622:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2626:	ff 90       	pop	r15
    2628:	ef 90       	pop	r14
    262a:	df 90       	pop	r13
    262c:	cf 90       	pop	r12
    262e:	08 95       	ret

00002630 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2630:	0f 93       	push	r16
    2632:	1f 93       	push	r17
    2634:	cf 93       	push	r28
    2636:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2638:	dc 01       	movw	r26, r24
    263a:	17 96       	adiw	r26, 0x07	; 7
    263c:	ed 91       	ld	r30, X+
    263e:	fc 91       	ld	r31, X
    2640:	18 97       	sbiw	r26, 0x08	; 8
    2642:	c0 85       	ldd	r28, Z+8	; 0x08
    2644:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2646:	8e 01       	movw	r16, r28
    2648:	02 5f       	subi	r16, 0xF2	; 242
    264a:	1f 4f       	sbci	r17, 0xFF	; 255
    264c:	c8 01       	movw	r24, r16
    264e:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2652:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2656:	81 11       	cpse	r24, r1
    2658:	16 c0       	rjmp	.+44     	; 0x2686 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    265a:	0c 50       	subi	r16, 0x0C	; 12
    265c:	11 09       	sbc	r17, r1
    265e:	c8 01       	movw	r24, r16
    2660:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2664:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2666:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    266a:	98 17       	cp	r25, r24
    266c:	10 f4       	brcc	.+4      	; 0x2672 <xTaskRemoveFromEventList+0x42>
    266e:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    2672:	bb e0       	ldi	r27, 0x0B	; 11
    2674:	8b 9f       	mul	r24, r27
    2676:	c0 01       	movw	r24, r0
    2678:	11 24       	eor	r1, r1
    267a:	b8 01       	movw	r22, r16
    267c:	8c 5f       	subi	r24, 0xFC	; 252
    267e:	9e 4c       	sbci	r25, 0xCE	; 206
    2680:	0e 94 25 0a 	call	0x144a	; 0x144a <vListInsertEnd>
    2684:	05 c0       	rjmp	.+10     	; 0x2690 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2686:	b8 01       	movw	r22, r16
    2688:	8f ed       	ldi	r24, 0xDF	; 223
    268a:	90 e3       	ldi	r25, 0x30	; 48
    268c:	0e 94 25 0a 	call	0x144a	; 0x144a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2690:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    2694:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2698:	81 e0       	ldi	r24, 0x01	; 1
    269a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    269c:	92 8d       	ldd	r25, Z+26	; 0x1a
    269e:	29 17       	cp	r18, r25
    26a0:	08 f4       	brcc	.+2      	; 0x26a4 <xTaskRemoveFromEventList+0x74>
    26a2:	80 e0       	ldi	r24, 0x00	; 0
}
    26a4:	df 91       	pop	r29
    26a6:	cf 91       	pop	r28
    26a8:	1f 91       	pop	r17
    26aa:	0f 91       	pop	r16
    26ac:	08 95       	ret

000026ae <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    26ae:	20 91 d1 30 	lds	r18, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    26b2:	fc 01       	movw	r30, r24
    26b4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    26b6:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    26ba:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    26be:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    26c2:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    26c6:	41 83       	std	Z+1, r20	; 0x01
    26c8:	52 83       	std	Z+2, r21	; 0x02
    26ca:	63 83       	std	Z+3, r22	; 0x03
    26cc:	74 83       	std	Z+4, r23	; 0x04
    26ce:	08 95       	ret

000026d0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26d0:	8f 92       	push	r8
    26d2:	9f 92       	push	r9
    26d4:	af 92       	push	r10
    26d6:	bf 92       	push	r11
    26d8:	cf 92       	push	r12
    26da:	df 92       	push	r13
    26dc:	ef 92       	push	r14
    26de:	ff 92       	push	r15
    26e0:	0f 93       	push	r16
    26e2:	1f 93       	push	r17
    26e4:	cf 93       	push	r28
    26e6:	df 93       	push	r29
    26e8:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26ea:	0f b6       	in	r0, 0x3f	; 63
    26ec:	f8 94       	cli
    26ee:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26f0:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    26f4:	90 81       	ld	r25, Z
    26f6:	98 17       	cp	r25, r24
    26f8:	89 f0       	breq	.+34     	; 0x271c <xTaskCheckForTimeOut+0x4c>
    26fa:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    26fe:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2702:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2706:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    270a:	01 81       	ldd	r16, Z+1	; 0x01
    270c:	12 81       	ldd	r17, Z+2	; 0x02
    270e:	23 81       	ldd	r18, Z+3	; 0x03
    2710:	34 81       	ldd	r19, Z+4	; 0x04
    2712:	80 17       	cp	r24, r16
    2714:	91 07       	cpc	r25, r17
    2716:	a2 07       	cpc	r26, r18
    2718:	b3 07       	cpc	r27, r19
    271a:	a8 f5       	brcc	.+106    	; 0x2786 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    271c:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2720:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2724:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2728:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    272c:	c1 80       	ldd	r12, Z+1	; 0x01
    272e:	d2 80       	ldd	r13, Z+2	; 0x02
    2730:	e3 80       	ldd	r14, Z+3	; 0x03
    2732:	f4 80       	ldd	r15, Z+4	; 0x04
    2734:	eb 01       	movw	r28, r22
    2736:	08 81       	ld	r16, Y
    2738:	19 81       	ldd	r17, Y+1	; 0x01
    273a:	2a 81       	ldd	r18, Y+2	; 0x02
    273c:	3b 81       	ldd	r19, Y+3	; 0x03
    273e:	8c 19       	sub	r24, r12
    2740:	9d 09       	sbc	r25, r13
    2742:	ae 09       	sbc	r26, r14
    2744:	bf 09       	sbc	r27, r15
    2746:	80 17       	cp	r24, r16
    2748:	91 07       	cpc	r25, r17
    274a:	a2 07       	cpc	r26, r18
    274c:	b3 07       	cpc	r27, r19
    274e:	e8 f4       	brcc	.+58     	; 0x278a <xTaskCheckForTimeOut+0xba>
    2750:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2752:	80 90 d8 30 	lds	r8, 0x30D8	; 0x8030d8 <xTickCount>
    2756:	90 90 d9 30 	lds	r9, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    275a:	a0 90 da 30 	lds	r10, 0x30DA	; 0x8030da <xTickCount+0x2>
    275e:	b0 90 db 30 	lds	r11, 0x30DB	; 0x8030db <xTickCount+0x3>
    2762:	b5 01       	movw	r22, r10
    2764:	a4 01       	movw	r20, r8
    2766:	4c 19       	sub	r20, r12
    2768:	5d 09       	sbc	r21, r13
    276a:	6e 09       	sbc	r22, r14
    276c:	7f 09       	sbc	r23, r15
    276e:	04 1b       	sub	r16, r20
    2770:	15 0b       	sbc	r17, r21
    2772:	26 0b       	sbc	r18, r22
    2774:	37 0b       	sbc	r19, r23
    2776:	08 83       	st	Y, r16
    2778:	19 83       	std	Y+1, r17	; 0x01
    277a:	2a 83       	std	Y+2, r18	; 0x02
    277c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    277e:	0e 94 57 13 	call	0x26ae	; 0x26ae <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2782:	80 e0       	ldi	r24, 0x00	; 0
    2784:	03 c0       	rjmp	.+6      	; 0x278c <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2786:	81 e0       	ldi	r24, 0x01	; 1
    2788:	01 c0       	rjmp	.+2      	; 0x278c <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    278a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    278c:	0f 90       	pop	r0
    278e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2790:	df 91       	pop	r29
    2792:	cf 91       	pop	r28
    2794:	1f 91       	pop	r17
    2796:	0f 91       	pop	r16
    2798:	ff 90       	pop	r15
    279a:	ef 90       	pop	r14
    279c:	df 90       	pop	r13
    279e:	cf 90       	pop	r12
    27a0:	bf 90       	pop	r11
    27a2:	af 90       	pop	r10
    27a4:	9f 90       	pop	r9
    27a6:	8f 90       	pop	r8
    27a8:	08 95       	ret

000027aa <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    27aa:	81 e0       	ldi	r24, 0x01	; 1
    27ac:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <xMissedYield>
    27b0:	08 95       	ret

000027b2 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27b2:	00 97       	sbiw	r24, 0x00	; 0
    27b4:	21 f4       	brne	.+8      	; 0x27be <uxTaskGetStackHighWaterMark+0xc>
    27b6:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    27ba:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    27be:	dc 01       	movw	r26, r24
    27c0:	5b 96       	adiw	r26, 0x1b	; 27
    27c2:	ed 91       	ld	r30, X+
    27c4:	fc 91       	ld	r31, X
    27c6:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27c8:	80 81       	ld	r24, Z
    27ca:	81 31       	cpi	r24, 0x11	; 17
    27cc:	41 f4       	brne	.+16     	; 0x27de <uxTaskGetStackHighWaterMark+0x2c>
    27ce:	31 96       	adiw	r30, 0x01	; 1
    27d0:	80 e0       	ldi	r24, 0x00	; 0
    27d2:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27d4:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27d6:	21 91       	ld	r18, Z+
    27d8:	21 31       	cpi	r18, 0x11	; 17
    27da:	e1 f3       	breq	.-8      	; 0x27d4 <uxTaskGetStackHighWaterMark+0x22>
    27dc:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27de:	80 e0       	ldi	r24, 0x00	; 0
    27e0:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27e2:	08 95       	ret

000027e4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27e4:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    27e8:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>

		return xReturn;
	}
    27ec:	08 95       	ret

000027ee <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27ee:	0f 93       	push	r16
    27f0:	1f 93       	push	r17
    27f2:	cf 93       	push	r28
    27f4:	df 93       	push	r29
    27f6:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    27f8:	22 8d       	ldd	r18, Z+26	; 0x1a
    27fa:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    27fe:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2802:	5a 96       	adiw	r26, 0x1a	; 26
    2804:	8c 91       	ld	r24, X
    2806:	28 17       	cp	r18, r24
    2808:	08 f0       	brcs	.+2      	; 0x280c <vTaskPriorityInherit+0x1e>
    280a:	41 c0       	rjmp	.+130    	; 0x288e <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    280c:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    2810:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2814:	5a 96       	adiw	r26, 0x1a	; 26
    2816:	3c 91       	ld	r19, X
    2818:	84 e0       	ldi	r24, 0x04	; 4
    281a:	90 e0       	ldi	r25, 0x00	; 0
    281c:	a0 e0       	ldi	r26, 0x00	; 0
    281e:	b0 e0       	ldi	r27, 0x00	; 0
    2820:	83 1b       	sub	r24, r19
    2822:	91 09       	sbc	r25, r1
    2824:	a1 09       	sbc	r26, r1
    2826:	b1 09       	sbc	r27, r1
    2828:	86 87       	std	Z+14, r24	; 0x0e
    282a:	97 87       	std	Z+15, r25	; 0x0f
    282c:	a0 8b       	std	Z+16, r26	; 0x10
    282e:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2830:	8b e0       	ldi	r24, 0x0B	; 11
    2832:	28 9f       	mul	r18, r24
    2834:	90 01       	movw	r18, r0
    2836:	11 24       	eor	r1, r1
    2838:	2c 5f       	subi	r18, 0xFC	; 252
    283a:	3e 4c       	sbci	r19, 0xCE	; 206
    283c:	84 85       	ldd	r24, Z+12	; 0x0c
    283e:	95 85       	ldd	r25, Z+13	; 0x0d
    2840:	82 17       	cp	r24, r18
    2842:	93 07       	cpc	r25, r19
    2844:	e9 f4       	brne	.+58     	; 0x2880 <vTaskPriorityInherit+0x92>
    2846:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2848:	ef 01       	movw	r28, r30
    284a:	22 96       	adiw	r28, 0x02	; 2
    284c:	ce 01       	movw	r24, r28
    284e:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2852:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    2856:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    285a:	82 8d       	ldd	r24, Z+26	; 0x1a
    285c:	f8 01       	movw	r30, r16
    285e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2860:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2864:	98 17       	cp	r25, r24
    2866:	10 f4       	brcc	.+4      	; 0x286c <vTaskPriorityInherit+0x7e>
    2868:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    286c:	fb e0       	ldi	r31, 0x0B	; 11
    286e:	8f 9f       	mul	r24, r31
    2870:	c0 01       	movw	r24, r0
    2872:	11 24       	eor	r1, r1
    2874:	be 01       	movw	r22, r28
    2876:	8c 5f       	subi	r24, 0xFC	; 252
    2878:	9e 4c       	sbci	r25, 0xCE	; 206
    287a:	0e 94 25 0a 	call	0x144a	; 0x144a <vListInsertEnd>
    287e:	07 c0       	rjmp	.+14     	; 0x288e <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2880:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    2884:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2888:	5a 96       	adiw	r26, 0x1a	; 26
    288a:	8c 91       	ld	r24, X
    288c:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    288e:	df 91       	pop	r29
    2890:	cf 91       	pop	r28
    2892:	1f 91       	pop	r17
    2894:	0f 91       	pop	r16
    2896:	08 95       	ret

00002898 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2898:	0f 93       	push	r16
    289a:	1f 93       	push	r17
    289c:	cf 93       	push	r28
    289e:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    28a0:	00 97       	sbiw	r24, 0x00	; 0
    28a2:	49 f1       	breq	.+82     	; 0x28f6 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    28a4:	fc 01       	movw	r30, r24
    28a6:	32 8d       	ldd	r19, Z+26	; 0x1a
    28a8:	27 a1       	ldd	r18, Z+39	; 0x27
    28aa:	32 17       	cp	r19, r18
    28ac:	21 f1       	breq	.+72     	; 0x28f6 <vTaskPriorityDisinherit+0x5e>
    28ae:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    28b0:	8c 01       	movw	r16, r24
    28b2:	0e 5f       	subi	r16, 0xFE	; 254
    28b4:	1f 4f       	sbci	r17, 0xFF	; 255
    28b6:	c8 01       	movw	r24, r16
    28b8:	0e 94 97 0a 	call	0x152e	; 0x152e <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28bc:	8f a1       	ldd	r24, Y+39	; 0x27
    28be:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28c0:	44 e0       	ldi	r20, 0x04	; 4
    28c2:	50 e0       	ldi	r21, 0x00	; 0
    28c4:	60 e0       	ldi	r22, 0x00	; 0
    28c6:	70 e0       	ldi	r23, 0x00	; 0
    28c8:	48 1b       	sub	r20, r24
    28ca:	51 09       	sbc	r21, r1
    28cc:	61 09       	sbc	r22, r1
    28ce:	71 09       	sbc	r23, r1
    28d0:	4e 87       	std	Y+14, r20	; 0x0e
    28d2:	5f 87       	std	Y+15, r21	; 0x0f
    28d4:	68 8b       	std	Y+16, r22	; 0x10
    28d6:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28d8:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    28dc:	98 17       	cp	r25, r24
    28de:	10 f4       	brcc	.+4      	; 0x28e4 <vTaskPriorityDisinherit+0x4c>
    28e0:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    28e4:	fb e0       	ldi	r31, 0x0B	; 11
    28e6:	8f 9f       	mul	r24, r31
    28e8:	c0 01       	movw	r24, r0
    28ea:	11 24       	eor	r1, r1
    28ec:	b8 01       	movw	r22, r16
    28ee:	8c 5f       	subi	r24, 0xFC	; 252
    28f0:	9e 4c       	sbci	r25, 0xCE	; 206
    28f2:	0e 94 25 0a 	call	0x144a	; 0x144a <vListInsertEnd>
			}
		}
	}
    28f6:	df 91       	pop	r29
    28f8:	cf 91       	pop	r28
    28fa:	1f 91       	pop	r17
    28fc:	0f 91       	pop	r16
    28fe:	08 95       	ret

00002900 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2900:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2902:	e8 81       	ld	r30, Y
    2904:	f9 81       	ldd	r31, Y+1	; 0x01
    2906:	01 90       	ld	r0, Z+
    2908:	f0 81       	ld	r31, Z
    290a:	e0 2d       	mov	r30, r0
    290c:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    290e:	1a 82       	std	Y+2, r1	; 0x02
    2910:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2912:	6f ef       	ldi	r22, 0xFF	; 255
    2914:	7f ef       	ldi	r23, 0xFF	; 255
    2916:	cb 01       	movw	r24, r22
    2918:	0e 94 63 12 	call	0x24c6	; 0x24c6 <vTaskDelay>
    291c:	fa cf       	rjmp	.-12     	; 0x2912 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000291e <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    291e:	fc 01       	movw	r30, r24
    2920:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2922:	65 87       	std	Z+13, r22	; 0x0d
    2924:	08 95       	ret

00002926 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2926:	4f 92       	push	r4
    2928:	5f 92       	push	r5
    292a:	6f 92       	push	r6
    292c:	7f 92       	push	r7
    292e:	8f 92       	push	r8
    2930:	9f 92       	push	r9
    2932:	af 92       	push	r10
    2934:	bf 92       	push	r11
    2936:	cf 92       	push	r12
    2938:	df 92       	push	r13
    293a:	ef 92       	push	r14
    293c:	ff 92       	push	r15
    293e:	0f 93       	push	r16
    2940:	1f 93       	push	r17
    2942:	cf 93       	push	r28
    2944:	df 93       	push	r29
    2946:	cd b7       	in	r28, 0x3d	; 61
    2948:	de b7       	in	r29, 0x3e	; 62
    294a:	2a 97       	sbiw	r28, 0x0a	; 10
    294c:	cd bf       	out	0x3d, r28	; 61
    294e:	de bf       	out	0x3e, r29	; 62
    2950:	4c 01       	movw	r8, r24
    2952:	29 01       	movw	r4, r18
    2954:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2956:	80 e5       	ldi	r24, 0x50	; 80
    2958:	90 e2       	ldi	r25, 0x20	; 32
    295a:	f4 01       	movw	r30, r8
    295c:	80 83       	st	Z, r24
    295e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2960:	fb 01       	movw	r30, r22
    2962:	80 81       	ld	r24, Z
    2964:	88 23       	and	r24, r24
    2966:	69 f0       	breq	.+26     	; 0x2982 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2968:	de 01       	movw	r26, r28
    296a:	11 96       	adiw	r26, 0x01	; 1
    296c:	31 96       	adiw	r30, 0x01	; 1
    296e:	90 e0       	ldi	r25, 0x00	; 0
    2970:	02 c0       	rjmp	.+4      	; 0x2976 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2972:	99 30       	cpi	r25, 0x09	; 9
    2974:	39 f0       	breq	.+14     	; 0x2984 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2976:	9f 5f       	subi	r25, 0xFF	; 255
    2978:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    297a:	81 91       	ld	r24, Z+
    297c:	81 11       	cpse	r24, r1
    297e:	f9 cf       	rjmp	.-14     	; 0x2972 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2980:	01 c0       	rjmp	.+2      	; 0x2984 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2982:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2984:	e1 e0       	ldi	r30, 0x01	; 1
    2986:	f0 e0       	ldi	r31, 0x00	; 0
    2988:	ec 0f       	add	r30, r28
    298a:	fd 1f       	adc	r31, r29
    298c:	e9 0f       	add	r30, r25
    298e:	f1 1d       	adc	r31, r1
    2990:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2992:	74 01       	movw	r14, r8
    2994:	f2 e0       	ldi	r31, 0x02	; 2
    2996:	ef 0e       	add	r14, r31
    2998:	f1 1c       	adc	r15, r1
    299a:	a1 2c       	mov	r10, r1
    299c:	b1 2c       	mov	r11, r1
    299e:	c1 2c       	mov	r12, r1
    29a0:	d1 2c       	mov	r13, r1
    29a2:	04 2f       	mov	r16, r20
    29a4:	94 01       	movw	r18, r8
    29a6:	a2 01       	movw	r20, r4
    29a8:	be 01       	movw	r22, r28
    29aa:	6f 5f       	subi	r22, 0xFF	; 255
    29ac:	7f 4f       	sbci	r23, 0xFF	; 255
    29ae:	84 ea       	ldi	r24, 0xA4	; 164
    29b0:	92 e0       	ldi	r25, 0x02	; 2
    29b2:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    29b6:	f4 01       	movw	r30, r8
    29b8:	66 82       	std	Z+6, r6	; 0x06
    29ba:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    29bc:	40 86       	std	Z+8, r4	; 0x08
    29be:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    29c0:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <last_created_task_pointer>
    29c4:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    29c8:	24 83       	std	Z+4, r18	; 0x04
    29ca:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29cc:	80 92 32 31 	sts	0x3132, r8	; 0x803132 <last_created_task_pointer>
    29d0:	90 92 33 31 	sts	0x3133, r9	; 0x803133 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29d4:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29d6:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29d8:	40 90 6a 31 	lds	r4, 0x316A	; 0x80316a <portStackTopForTask>
    29dc:	50 90 6b 31 	lds	r5, 0x316B	; 0x80316b <portStackTopForTask+0x1>
    29e0:	ff ef       	ldi	r31, 0xFF	; 255
    29e2:	4f 1a       	sub	r4, r31
    29e4:	5f 0a       	sbc	r5, r31
    29e6:	40 92 6a 31 	sts	0x316A, r4	; 0x80316a <portStackTopForTask>
    29ea:	50 92 6b 31 	sts	0x316B, r5	; 0x80316b <portStackTopForTask+0x1>
    29ee:	f4 01       	movw	r30, r8
    29f0:	42 86       	std	Z+10, r4	; 0x0a
    29f2:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    29f4:	16 86       	std	Z+14, r1	; 0x0e
    29f6:	17 86       	std	Z+15, r1	; 0x0f
    29f8:	10 8a       	std	Z+16, r1	; 0x10
    29fa:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    29fc:	61 14       	cp	r6, r1
    29fe:	71 04       	cpc	r7, r1
    2a00:	09 f4       	brne	.+2      	; 0x2a04 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a02:	44 c0       	rjmp	.+136    	; 0x2a8c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a04:	81 30       	cpi	r24, 0x01	; 1
    2a06:	79 f5       	brne	.+94     	; 0x2a66 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a08:	6a e0       	ldi	r22, 0x0A	; 10
    2a0a:	c3 01       	movw	r24, r6
    2a0c:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2a10:	7c 01       	movw	r14, r24
    2a12:	65 e9       	ldi	r22, 0x95	; 149
    2a14:	74 e0       	ldi	r23, 0x04	; 4
    2a16:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2a1a:	be 01       	movw	r22, r28
    2a1c:	6f 5f       	subi	r22, 0xFF	; 255
    2a1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a20:	c7 01       	movw	r24, r14
    2a22:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2a26:	6a e0       	ldi	r22, 0x0A	; 10
    2a28:	c7 01       	movw	r24, r14
    2a2a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2a2e:	7c 01       	movw	r14, r24
    2a30:	6c e8       	ldi	r22, 0x8C	; 140
    2a32:	74 e0       	ldi	r23, 0x04	; 4
    2a34:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a38:	6a e0       	ldi	r22, 0x0A	; 10
    2a3a:	c7 01       	movw	r24, r14
    2a3c:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2a40:	7c 01       	movw	r14, r24
    2a42:	6e e7       	ldi	r22, 0x7E	; 126
    2a44:	74 e0       	ldi	r23, 0x04	; 4
    2a46:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2a4a:	63 e0       	ldi	r22, 0x03	; 3
    2a4c:	c7 01       	movw	r24, r14
    2a4e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2a52:	b2 01       	movw	r22, r4
    2a54:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <_ZN8emstreamlsEj>
    2a58:	62 e0       	ldi	r22, 0x02	; 2
    2a5a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2a5e:	66 e0       	ldi	r22, 0x06	; 6
    2a60:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2a64:	13 c0       	rjmp	.+38     	; 0x2a8c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a66:	6a e0       	ldi	r22, 0x0A	; 10
    2a68:	c3 01       	movw	r24, r6
    2a6a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2a6e:	4c 01       	movw	r8, r24
    2a70:	69 e6       	ldi	r22, 0x69	; 105
    2a72:	74 e0       	ldi	r23, 0x04	; 4
    2a74:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2a78:	be 01       	movw	r22, r28
    2a7a:	6f 5f       	subi	r22, 0xFF	; 255
    2a7c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a7e:	c4 01       	movw	r24, r8
    2a80:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2a84:	66 e0       	ldi	r22, 0x06	; 6
    2a86:	c4 01       	movw	r24, r8
    2a88:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a8c:	2a 96       	adiw	r28, 0x0a	; 10
    2a8e:	cd bf       	out	0x3d, r28	; 61
    2a90:	de bf       	out	0x3e, r29	; 62
    2a92:	df 91       	pop	r29
    2a94:	cf 91       	pop	r28
    2a96:	1f 91       	pop	r17
    2a98:	0f 91       	pop	r16
    2a9a:	ff 90       	pop	r15
    2a9c:	ef 90       	pop	r14
    2a9e:	df 90       	pop	r13
    2aa0:	cf 90       	pop	r12
    2aa2:	bf 90       	pop	r11
    2aa4:	af 90       	pop	r10
    2aa6:	9f 90       	pop	r9
    2aa8:	8f 90       	pop	r8
    2aaa:	7f 90       	pop	r7
    2aac:	6f 90       	pop	r6
    2aae:	5f 90       	pop	r5
    2ab0:	4f 90       	pop	r4
    2ab2:	08 95       	ret

00002ab4 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2ab4:	cf 92       	push	r12
    2ab6:	df 92       	push	r13
    2ab8:	ef 92       	push	r14
    2aba:	ff 92       	push	r15
    2abc:	0f 93       	push	r16
    2abe:	1f 93       	push	r17
    2ac0:	cf 93       	push	r28
    2ac2:	df 93       	push	r29
    2ac4:	ec 01       	movw	r28, r24
    2ac6:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aca:	9b 81       	ldd	r25, Y+3	; 0x03
    2acc:	0e 94 66 10 	call	0x20cc	; 0x20cc <pcTaskGetTaskName>
    2ad0:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2ad2:	6a e0       	ldi	r22, 0x0A	; 10
    2ad4:	c7 01       	movw	r24, r14
    2ad6:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2ada:	8c 01       	movw	r16, r24
    2adc:	68 ea       	ldi	r22, 0xA8	; 168
    2ade:	74 e0       	ldi	r23, 0x04	; 4
    2ae0:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2ae4:	6a e0       	ldi	r22, 0x0A	; 10
    2ae6:	c8 01       	movw	r24, r16
    2ae8:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2aec:	8c 01       	movw	r16, r24
    2aee:	61 ea       	ldi	r22, 0xA1	; 161
    2af0:	74 e0       	ldi	r23, 0x04	; 4
    2af2:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2af6:	b6 01       	movw	r22, r12
    2af8:	c8 01       	movw	r24, r16
    2afa:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2afe:	6a e0       	ldi	r22, 0x0A	; 10
    2b00:	c8 01       	movw	r24, r16
    2b02:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2b06:	8c 01       	movw	r16, r24
    2b08:	6b e9       	ldi	r22, 0x9B	; 155
    2b0a:	74 e0       	ldi	r23, 0x04	; 4
    2b0c:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2b10:	66 e0       	ldi	r22, 0x06	; 6
    2b12:	c8 01       	movw	r24, r16
    2b14:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b18:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b1a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b1c:	e8 85       	ldd	r30, Y+8	; 0x08
    2b1e:	f9 85       	ldd	r31, Y+9	; 0x09
    2b20:	01 e1       	ldi	r16, 0x11	; 17
    2b22:	21 e0       	ldi	r18, 0x01	; 1
    2b24:	a7 01       	movw	r20, r14
    2b26:	bc 01       	movw	r22, r24
    2b28:	8e 1b       	sub	r24, r30
    2b2a:	9f 0b       	sbc	r25, r31
    2b2c:	0e 94 5c 18 	call	0x30b8	; 0x30b8 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b30:	8c 81       	ldd	r24, Y+4	; 0x04
    2b32:	9d 81       	ldd	r25, Y+5	; 0x05
    2b34:	00 97       	sbiw	r24, 0x00	; 0
    2b36:	19 f0       	breq	.+6      	; 0x2b3e <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b38:	b7 01       	movw	r22, r14
    2b3a:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b3e:	df 91       	pop	r29
    2b40:	cf 91       	pop	r28
    2b42:	1f 91       	pop	r17
    2b44:	0f 91       	pop	r16
    2b46:	ff 90       	pop	r15
    2b48:	ef 90       	pop	r14
    2b4a:	df 90       	pop	r13
    2b4c:	cf 90       	pop	r12
    2b4e:	08 95       	ret

00002b50 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b50:	0f 93       	push	r16
    2b52:	1f 93       	push	r17
    2b54:	cf 93       	push	r28
    2b56:	df 93       	push	r29
    2b58:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b5a:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <last_created_task_pointer>
    2b5e:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    2b62:	00 97       	sbiw	r24, 0x00	; 0
    2b64:	19 f0       	breq	.+6      	; 0x2b6c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b66:	be 01       	movw	r22, r28
    2b68:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b6c:	6a e0       	ldi	r22, 0x0A	; 10
    2b6e:	ce 01       	movw	r24, r28
    2b70:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2b74:	8c 01       	movw	r16, r24
    2b76:	6e eb       	ldi	r22, 0xBE	; 190
    2b78:	74 e0       	ldi	r23, 0x04	; 4
    2b7a:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2b7e:	6a e0       	ldi	r22, 0x0A	; 10
    2b80:	c8 01       	movw	r24, r16
    2b82:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2b86:	8c 01       	movw	r16, r24
    2b88:	63 eb       	ldi	r22, 0xB3	; 179
    2b8a:	74 e0       	ldi	r23, 0x04	; 4
    2b8c:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2b90:	6a e0       	ldi	r22, 0x0A	; 10
    2b92:	c8 01       	movw	r24, r16
    2b94:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2b98:	8c 01       	movw	r16, r24
    2b9a:	6d ea       	ldi	r22, 0xAD	; 173
    2b9c:	74 e0       	ldi	r23, 0x04	; 4
    2b9e:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2ba2:	66 e0       	ldi	r22, 0x06	; 6
    2ba4:	c8 01       	movw	r24, r16
    2ba6:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2baa:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <portStackTopForTask>
    2bae:	90 91 6b 31 	lds	r25, 0x316B	; 0x80316b <portStackTopForTask+0x1>
    2bb2:	bc 01       	movw	r22, r24
    2bb4:	6f 5f       	subi	r22, 0xFF	; 255
    2bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bb8:	01 e1       	ldi	r16, 0x11	; 17
    2bba:	21 e0       	ldi	r18, 0x01	; 1
    2bbc:	ae 01       	movw	r20, r28
    2bbe:	83 56       	subi	r24, 0x63	; 99
    2bc0:	91 09       	sbc	r25, r1
    2bc2:	0e 94 5c 18 	call	0x30b8	; 0x30b8 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2bc6:	df 91       	pop	r29
    2bc8:	cf 91       	pop	r28
    2bca:	1f 91       	pop	r17
    2bcc:	0f 91       	pop	r16
    2bce:	08 95       	ret

00002bd0 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2bd0:	8f 92       	push	r8
    2bd2:	9f 92       	push	r9
    2bd4:	af 92       	push	r10
    2bd6:	bf 92       	push	r11
    2bd8:	cf 92       	push	r12
    2bda:	df 92       	push	r13
    2bdc:	ef 92       	push	r14
    2bde:	ff 92       	push	r15
    2be0:	0f 93       	push	r16
    2be2:	1f 93       	push	r17
    2be4:	cf 93       	push	r28
    2be6:	df 93       	push	r29
    2be8:	ec 01       	movw	r28, r24
    2bea:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2bec:	8a 81       	ldd	r24, Y+2	; 0x02
    2bee:	9b 81       	ldd	r25, Y+3	; 0x03
    2bf0:	0e 94 66 10 	call	0x20cc	; 0x20cc <pcTaskGetTaskName>
    2bf4:	bc 01       	movw	r22, r24
    2bf6:	c8 01       	movw	r24, r16
    2bf8:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2bfc:	d8 01       	movw	r26, r16
    2bfe:	ed 91       	ld	r30, X+
    2c00:	fc 91       	ld	r31, X
    2c02:	02 80       	ldd	r0, Z+2	; 0x02
    2c04:	f3 81       	ldd	r31, Z+3	; 0x03
    2c06:	e0 2d       	mov	r30, r0
    2c08:	69 e0       	ldi	r22, 0x09	; 9
    2c0a:	c8 01       	movw	r24, r16
    2c0c:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c10:	9b 81       	ldd	r25, Y+3	; 0x03
    2c12:	0e 94 66 10 	call	0x20cc	; 0x20cc <pcTaskGetTaskName>
    2c16:	fc 01       	movw	r30, r24
    2c18:	01 90       	ld	r0, Z+
    2c1a:	00 20       	and	r0, r0
    2c1c:	e9 f7       	brne	.-6      	; 0x2c18 <_ZN8frt_task12print_statusER8emstream+0x48>
    2c1e:	31 97       	sbiw	r30, 0x01	; 1
    2c20:	e8 1b       	sub	r30, r24
    2c22:	f9 0b       	sbc	r31, r25
    2c24:	38 97       	sbiw	r30, 0x08	; 8
    2c26:	48 f4       	brcc	.+18     	; 0x2c3a <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2c28:	d8 01       	movw	r26, r16
    2c2a:	ed 91       	ld	r30, X+
    2c2c:	fc 91       	ld	r31, X
    2c2e:	02 80       	ldd	r0, Z+2	; 0x02
    2c30:	f3 81       	ldd	r31, Z+3	; 0x03
    2c32:	e0 2d       	mov	r30, r0
    2c34:	69 e0       	ldi	r22, 0x09	; 9
    2c36:	c8 01       	movw	r24, r16
    2c38:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c3a:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c3c:	df 84       	ldd	r13, Y+15	; 0x0f
    2c3e:	e8 88       	ldd	r14, Y+16	; 0x10
    2c40:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c42:	a8 84       	ldd	r10, Y+8	; 0x08
    2c44:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c46:	8a 81       	ldd	r24, Y+2	; 0x02
    2c48:	9b 81       	ldd	r25, Y+3	; 0x03
    2c4a:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <uxTaskGetStackHighWaterMark>
    2c4e:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c50:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c52:	8a 81       	ldd	r24, Y+2	; 0x02
    2c54:	9b 81       	ldd	r25, Y+3	; 0x03
    2c56:	0e 94 11 10 	call	0x2022	; 0x2022 <uxTaskPriorityGet>
    2c5a:	68 2f       	mov	r22, r24
    2c5c:	c8 01       	movw	r24, r16
    2c5e:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
    2c62:	6a e0       	ldi	r22, 0x0A	; 10
    2c64:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2c68:	ec 01       	movw	r28, r24
    2c6a:	63 e3       	ldi	r22, 0x33	; 51
    2c6c:	75 e0       	ldi	r23, 0x05	; 5
    2c6e:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c72:	68 2d       	mov	r22, r8
    2c74:	ce 01       	movw	r24, r28
    2c76:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c7a:	6a e0       	ldi	r22, 0x0A	; 10
    2c7c:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2c80:	ec 01       	movw	r28, r24
    2c82:	61 e3       	ldi	r22, 0x31	; 49
    2c84:	75 e0       	ldi	r23, 0x05	; 5
    2c86:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2c8a:	69 2d       	mov	r22, r9
    2c8c:	ce 01       	movw	r24, r28
    2c8e:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
    2c92:	6a e0       	ldi	r22, 0x0A	; 10
    2c94:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2c98:	ec 01       	movw	r28, r24
    2c9a:	6f e2       	ldi	r22, 0x2F	; 47
    2c9c:	75 e0       	ldi	r23, 0x05	; 5
    2c9e:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2ca2:	b5 01       	movw	r22, r10
    2ca4:	ce 01       	movw	r24, r28
    2ca6:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <_ZN8emstreamlsEj>
    2caa:	6a e0       	ldi	r22, 0x0A	; 10
    2cac:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2cb0:	ec 01       	movw	r28, r24
    2cb2:	6d e2       	ldi	r22, 0x2D	; 45
    2cb4:	75 e0       	ldi	r23, 0x05	; 5
    2cb6:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2cba:	6a e0       	ldi	r22, 0x0A	; 10
    2cbc:	ce 01       	movw	r24, r28
    2cbe:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2cc2:	ec 01       	movw	r28, r24
    2cc4:	6b e2       	ldi	r22, 0x2B	; 43
    2cc6:	75 e0       	ldi	r23, 0x05	; 5
    2cc8:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2ccc:	b7 01       	movw	r22, r14
    2cce:	a6 01       	movw	r20, r12
    2cd0:	ce 01       	movw	r24, r28
    2cd2:	0e 94 90 1a 	call	0x3520	; 0x3520 <_ZN8emstreamlsEm>
}
    2cd6:	df 91       	pop	r29
    2cd8:	cf 91       	pop	r28
    2cda:	1f 91       	pop	r17
    2cdc:	0f 91       	pop	r16
    2cde:	ff 90       	pop	r15
    2ce0:	ef 90       	pop	r14
    2ce2:	df 90       	pop	r13
    2ce4:	cf 90       	pop	r12
    2ce6:	bf 90       	pop	r11
    2ce8:	af 90       	pop	r10
    2cea:	9f 90       	pop	r9
    2cec:	8f 90       	pop	r8
    2cee:	08 95       	ret

00002cf0 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2cf0:	cf 93       	push	r28
    2cf2:	df 93       	push	r29
    2cf4:	ec 01       	movw	r28, r24
    2cf6:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2cf8:	db 01       	movw	r26, r22
    2cfa:	ed 91       	ld	r30, X+
    2cfc:	fc 91       	ld	r31, X
    2cfe:	02 80       	ldd	r0, Z+2	; 0x02
    2d00:	f3 81       	ldd	r31, Z+3	; 0x03
    2d02:	e0 2d       	mov	r30, r0
    2d04:	be 01       	movw	r22, r28
    2d06:	19 95       	eicall
	return (ser_dev);
}
    2d08:	ce 01       	movw	r24, r28
    2d0a:	df 91       	pop	r29
    2d0c:	cf 91       	pop	r28
    2d0e:	08 95       	ret

00002d10 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2d10:	0f 93       	push	r16
    2d12:	1f 93       	push	r17
    2d14:	cf 93       	push	r28
    2d16:	df 93       	push	r29
    2d18:	ec 01       	movw	r28, r24
    2d1a:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d1c:	bc 01       	movw	r22, r24
    2d1e:	c8 01       	movw	r24, r16
    2d20:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <_ZlsR8emstreamR8frt_task>
    2d24:	66 e0       	ldi	r22, 0x06	; 6
    2d26:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d2a:	8c 81       	ldd	r24, Y+4	; 0x04
    2d2c:	9d 81       	ldd	r25, Y+5	; 0x05
    2d2e:	00 97       	sbiw	r24, 0x00	; 0
    2d30:	19 f0       	breq	.+6      	; 0x2d38 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d32:	b8 01       	movw	r22, r16
    2d34:	0e 94 88 16 	call	0x2d10	; 0x2d10 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d38:	df 91       	pop	r29
    2d3a:	cf 91       	pop	r28
    2d3c:	1f 91       	pop	r17
    2d3e:	0f 91       	pop	r16
    2d40:	08 95       	ret

00002d42 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d42:	0f 93       	push	r16
    2d44:	1f 93       	push	r17
    2d46:	cf 93       	push	r28
    2d48:	df 93       	push	r29
    2d4a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d4c:	6a e0       	ldi	r22, 0x0A	; 10
    2d4e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2d52:	8c 01       	movw	r16, r24
    2d54:	60 e2       	ldi	r22, 0x20	; 32
    2d56:	75 e0       	ldi	r23, 0x05	; 5
    2d58:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d5c:	6a e0       	ldi	r22, 0x0A	; 10
    2d5e:	c8 01       	movw	r24, r16
    2d60:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2d64:	8c 01       	movw	r16, r24
    2d66:	69 e1       	ldi	r22, 0x19	; 25
    2d68:	75 e0       	ldi	r23, 0x05	; 5
    2d6a:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d6e:	66 e0       	ldi	r22, 0x06	; 6
    2d70:	c8 01       	movw	r24, r16
    2d72:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d76:	6a e0       	ldi	r22, 0x0A	; 10
    2d78:	ce 01       	movw	r24, r28
    2d7a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2d7e:	8c 01       	movw	r16, r24
    2d80:	68 e0       	ldi	r22, 0x08	; 8
    2d82:	75 e0       	ldi	r23, 0x05	; 5
    2d84:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2d88:	6a e0       	ldi	r22, 0x0A	; 10
    2d8a:	c8 01       	movw	r24, r16
    2d8c:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2d90:	8c 01       	movw	r16, r24
    2d92:	6c ef       	ldi	r22, 0xFC	; 252
    2d94:	74 e0       	ldi	r23, 0x04	; 4
    2d96:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2d9a:	6a e0       	ldi	r22, 0x0A	; 10
    2d9c:	c8 01       	movw	r24, r16
    2d9e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2da2:	8c 01       	movw	r16, r24
    2da4:	66 ef       	ldi	r22, 0xF6	; 246
    2da6:	74 e0       	ldi	r23, 0x04	; 4
    2da8:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2dac:	66 e0       	ldi	r22, 0x06	; 6
    2dae:	c8 01       	movw	r24, r16
    2db0:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2db4:	6a e0       	ldi	r22, 0x0A	; 10
    2db6:	ce 01       	movw	r24, r28
    2db8:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2dbc:	8c 01       	movw	r16, r24
    2dbe:	65 ee       	ldi	r22, 0xE5	; 229
    2dc0:	74 e0       	ldi	r23, 0x04	; 4
    2dc2:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2dc6:	6a e0       	ldi	r22, 0x0A	; 10
    2dc8:	c8 01       	movw	r24, r16
    2dca:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2dce:	8c 01       	movw	r16, r24
    2dd0:	69 ed       	ldi	r22, 0xD9	; 217
    2dd2:	74 e0       	ldi	r23, 0x04	; 4
    2dd4:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2dd8:	6a e0       	ldi	r22, 0x0A	; 10
    2dda:	c8 01       	movw	r24, r16
    2ddc:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2de0:	8c 01       	movw	r16, r24
    2de2:	63 ed       	ldi	r22, 0xD3	; 211
    2de4:	74 e0       	ldi	r23, 0x04	; 4
    2de6:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2dea:	66 e0       	ldi	r22, 0x06	; 6
    2dec:	c8 01       	movw	r24, r16
    2dee:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2df2:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <last_created_task_pointer>
    2df6:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    2dfa:	00 97       	sbiw	r24, 0x00	; 0
    2dfc:	19 f0       	breq	.+6      	; 0x2e04 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2dfe:	be 01       	movw	r22, r28
    2e00:	0e 94 88 16 	call	0x2d10	; 0x2d10 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e04:	0e 94 6e 10 	call	0x20dc	; 0x20dc <xTaskGetIdleTaskHandle>
    2e08:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <uxTaskGetStackHighWaterMark>
    2e0c:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2e0e:	6a e0       	ldi	r22, 0x0A	; 10
    2e10:	ce 01       	movw	r24, r28
    2e12:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2e16:	ec 01       	movw	r28, r24
    2e18:	68 ec       	ldi	r22, 0xC8	; 200
    2e1a:	74 e0       	ldi	r23, 0x04	; 4
    2e1c:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e20:	61 2f       	mov	r22, r17
    2e22:	ce 01       	movw	r24, r28
    2e24:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2e28:	6a e0       	ldi	r22, 0x0A	; 10
    2e2a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2e2e:	ec 01       	movw	r28, r24
    2e30:	66 ec       	ldi	r22, 0xC6	; 198
    2e32:	74 e0       	ldi	r23, 0x04	; 4
    2e34:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    2e38:	64 e6       	ldi	r22, 0x64	; 100
    2e3a:	70 e0       	ldi	r23, 0x00	; 0
    2e3c:	ce 01       	movw	r24, r28
    2e3e:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <_ZN8emstreamlsEj>
    2e42:	6a e0       	ldi	r22, 0x0A	; 10
    2e44:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    2e48:	ec 01       	movw	r28, r24
    2e4a:	63 ec       	ldi	r22, 0xC3	; 195
    2e4c:	74 e0       	ldi	r23, 0x04	; 4
    2e4e:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e52:	66 e0       	ldi	r22, 0x06	; 6
    2e54:	ce 01       	movw	r24, r28
    2e56:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
}
    2e5a:	df 91       	pop	r29
    2e5c:	cf 91       	pop	r28
    2e5e:	1f 91       	pop	r17
    2e60:	0f 91       	pop	r16
    2e62:	08 95       	ret

00002e64 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e64:	0f 93       	push	r16
    2e66:	cf 93       	push	r28
    2e68:	df 93       	push	r29
    2e6a:	1f 92       	push	r1
    2e6c:	cd b7       	in	r28, 0x3d	; 61
    2e6e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e70:	00 e0       	ldi	r16, 0x00	; 0
    2e72:	2f ef       	ldi	r18, 0xFF	; 255
    2e74:	3f ef       	ldi	r19, 0xFF	; 255
    2e76:	a9 01       	movw	r20, r18
    2e78:	be 01       	movw	r22, r28
    2e7a:	6f 5f       	subi	r22, 0xFF	; 255
    2e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e7e:	fc 01       	movw	r30, r24
    2e80:	80 85       	ldd	r24, Z+8	; 0x08
    2e82:	91 85       	ldd	r25, Z+9	; 0x09
    2e84:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <xQueueGenericReceive>
    2e88:	81 30       	cpi	r24, 0x01	; 1
    2e8a:	19 f4       	brne	.+6      	; 0x2e92 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e8c:	89 81       	ldd	r24, Y+1	; 0x01
    2e8e:	90 e0       	ldi	r25, 0x00	; 0
    2e90:	02 c0       	rjmp	.+4      	; 0x2e96 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2e92:	8f ef       	ldi	r24, 0xFF	; 255
    2e94:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2e96:	0f 90       	pop	r0
    2e98:	df 91       	pop	r29
    2e9a:	cf 91       	pop	r28
    2e9c:	0f 91       	pop	r16
    2e9e:	08 95       	ret

00002ea0 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2ea0:	fc 01       	movw	r30, r24
    2ea2:	80 85       	ldd	r24, Z+8	; 0x08
    2ea4:	91 85       	ldd	r25, Z+9	; 0x09
    2ea6:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <uxQueueMessagesWaiting>
    2eaa:	91 e0       	ldi	r25, 0x01	; 1
    2eac:	81 11       	cpse	r24, r1
    2eae:	01 c0       	rjmp	.+2      	; 0x2eb2 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2eb0:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2eb2:	89 2f       	mov	r24, r25
    2eb4:	08 95       	ret

00002eb6 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2eb6:	0f 93       	push	r16
    2eb8:	cf 93       	push	r28
    2eba:	df 93       	push	r29
    2ebc:	1f 92       	push	r1
    2ebe:	cd b7       	in	r28, 0x3d	; 61
    2ec0:	de b7       	in	r29, 0x3e	; 62
    2ec2:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2ec4:	fc 01       	movw	r30, r24
    2ec6:	22 85       	ldd	r18, Z+10	; 0x0a
    2ec8:	33 85       	ldd	r19, Z+11	; 0x0b
    2eca:	44 85       	ldd	r20, Z+12	; 0x0c
    2ecc:	55 85       	ldd	r21, Z+13	; 0x0d
    2ece:	00 e0       	ldi	r16, 0x00	; 0
    2ed0:	be 01       	movw	r22, r28
    2ed2:	6f 5f       	subi	r22, 0xFF	; 255
    2ed4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed6:	80 85       	ldd	r24, Z+8	; 0x08
    2ed8:	91 85       	ldd	r25, Z+9	; 0x09
    2eda:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <xQueueGenericSend>
    2ede:	91 e0       	ldi	r25, 0x01	; 1
    2ee0:	81 11       	cpse	r24, r1
    2ee2:	01 c0       	rjmp	.+2      	; 0x2ee6 <_ZN14frt_text_queue7putcharEc+0x30>
    2ee4:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2ee6:	89 2f       	mov	r24, r25
    2ee8:	0f 90       	pop	r0
    2eea:	df 91       	pop	r29
    2eec:	cf 91       	pop	r28
    2eee:	0f 91       	pop	r16
    2ef0:	08 95       	ret

00002ef2 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ef2:	8f 92       	push	r8
    2ef4:	9f 92       	push	r9
    2ef6:	bf 92       	push	r11
    2ef8:	cf 92       	push	r12
    2efa:	df 92       	push	r13
    2efc:	ef 92       	push	r14
    2efe:	ff 92       	push	r15
    2f00:	0f 93       	push	r16
    2f02:	1f 93       	push	r17
    2f04:	cf 93       	push	r28
    2f06:	df 93       	push	r29
    2f08:	ec 01       	movw	r28, r24
    2f0a:	b6 2e       	mov	r11, r22
    2f0c:	4a 01       	movw	r8, r20
    2f0e:	68 01       	movw	r12, r16
    2f10:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f12:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamC1Ev>
    2f16:	88 e5       	ldi	r24, 0x58	; 88
    2f18:	90 e2       	ldi	r25, 0x20	; 32
    2f1a:	88 83       	st	Y, r24
    2f1c:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f1e:	8e 86       	std	Y+14, r8	; 0x0e
    2f20:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f22:	40 e0       	ldi	r20, 0x00	; 0
    2f24:	61 e0       	ldi	r22, 0x01	; 1
    2f26:	8b 2d       	mov	r24, r11
    2f28:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <xQueueGenericCreate>
    2f2c:	88 87       	std	Y+8, r24	; 0x08
    2f2e:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f30:	ca 86       	std	Y+10, r12	; 0x0a
    2f32:	db 86       	std	Y+11, r13	; 0x0b
    2f34:	ec 86       	std	Y+12, r14	; 0x0c
    2f36:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f38:	df 91       	pop	r29
    2f3a:	cf 91       	pop	r28
    2f3c:	1f 91       	pop	r17
    2f3e:	0f 91       	pop	r16
    2f40:	ff 90       	pop	r15
    2f42:	ef 90       	pop	r14
    2f44:	df 90       	pop	r13
    2f46:	cf 90       	pop	r12
    2f48:	bf 90       	pop	r11
    2f4a:	9f 90       	pop	r9
    2f4c:	8f 90       	pop	r8
    2f4e:	08 95       	ret

00002f50 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f50:	cf 92       	push	r12
    2f52:	df 92       	push	r13
    2f54:	ef 92       	push	r14
    2f56:	ff 92       	push	r15
    2f58:	cf 93       	push	r28
    2f5a:	df 93       	push	r29
    2f5c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f5e:	68 81       	ld	r22, Y
    2f60:	79 81       	ldd	r23, Y+1	; 0x01
    2f62:	8a 81       	ldd	r24, Y+2	; 0x02
    2f64:	9b 81       	ldd	r25, Y+3	; 0x03
    2f66:	0f 2e       	mov	r0, r31
    2f68:	f8 ee       	ldi	r31, 0xE8	; 232
    2f6a:	cf 2e       	mov	r12, r31
    2f6c:	f3 e0       	ldi	r31, 0x03	; 3
    2f6e:	df 2e       	mov	r13, r31
    2f70:	e1 2c       	mov	r14, r1
    2f72:	f1 2c       	mov	r15, r1
    2f74:	f0 2d       	mov	r31, r0
    2f76:	a7 01       	movw	r20, r14
    2f78:	96 01       	movw	r18, r12
    2f7a:	0e 94 15 21 	call	0x422a	; 0x422a <__udivmodsi4>
    2f7e:	9b 01       	movw	r18, r22
    2f80:	ac 01       	movw	r20, r24
    2f82:	60 e4       	ldi	r22, 0x40	; 64
    2f84:	72 e4       	ldi	r23, 0x42	; 66
    2f86:	8f e0       	ldi	r24, 0x0F	; 15
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	0e 94 05 21 	call	0x420a	; 0x420a <__mulsi3>
    2f8e:	a7 01       	movw	r20, r14
    2f90:	96 01       	movw	r18, r12
    2f92:	0e 94 15 21 	call	0x422a	; 0x422a <__udivmodsi4>
    2f96:	69 01       	movw	r12, r18
    2f98:	7a 01       	movw	r14, r20
    2f9a:	ac 81       	ldd	r26, Y+4	; 0x04
    2f9c:	bd 81       	ldd	r27, Y+5	; 0x05
    2f9e:	20 e4       	ldi	r18, 0x40	; 64
    2fa0:	32 e4       	ldi	r19, 0x42	; 66
    2fa2:	4f e0       	ldi	r20, 0x0F	; 15
    2fa4:	50 e0       	ldi	r21, 0x00	; 0
    2fa6:	0e 94 66 21 	call	0x42cc	; 0x42cc <__muluhisi3>
    2faa:	20 e0       	ldi	r18, 0x00	; 0
    2fac:	38 e4       	ldi	r19, 0x48	; 72
    2fae:	48 ee       	ldi	r20, 0xE8	; 232
    2fb0:	51 e0       	ldi	r21, 0x01	; 1
    2fb2:	0e 94 15 21 	call	0x422a	; 0x422a <__udivmodsi4>
    2fb6:	c7 01       	movw	r24, r14
    2fb8:	b6 01       	movw	r22, r12
    2fba:	62 0f       	add	r22, r18
    2fbc:	73 1f       	adc	r23, r19
    2fbe:	84 1f       	adc	r24, r20
    2fc0:	95 1f       	adc	r25, r21
}
    2fc2:	df 91       	pop	r29
    2fc4:	cf 91       	pop	r28
    2fc6:	ff 90       	pop	r15
    2fc8:	ef 90       	pop	r14
    2fca:	df 90       	pop	r13
    2fcc:	cf 90       	pop	r12
    2fce:	08 95       	ret

00002fd0 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2fd0:	cf 92       	push	r12
    2fd2:	df 92       	push	r13
    2fd4:	ef 92       	push	r14
    2fd6:	ff 92       	push	r15
    2fd8:	0f 93       	push	r16
    2fda:	1f 93       	push	r17
    2fdc:	cf 93       	push	r28
    2fde:	df 93       	push	r29
    2fe0:	cd b7       	in	r28, 0x3d	; 61
    2fe2:	de b7       	in	r29, 0x3e	; 62
    2fe4:	2f 97       	sbiw	r28, 0x0f	; 15
    2fe6:	cd bf       	out	0x3d, r28	; 61
    2fe8:	de bf       	out	0x3e, r29	; 62
    2fea:	6c 01       	movw	r12, r24
    2fec:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2fee:	db 01       	movw	r26, r22
    2ff0:	6d 91       	ld	r22, X+
    2ff2:	7d 91       	ld	r23, X+
    2ff4:	8d 91       	ld	r24, X+
    2ff6:	9c 91       	ld	r25, X
    2ff8:	28 ee       	ldi	r18, 0xE8	; 232
    2ffa:	33 e0       	ldi	r19, 0x03	; 3
    2ffc:	40 e0       	ldi	r20, 0x00	; 0
    2ffe:	50 e0       	ldi	r21, 0x00	; 0
    3000:	0e 94 15 21 	call	0x422a	; 0x422a <__udivmodsi4>
    3004:	ba 01       	movw	r22, r20
    3006:	a9 01       	movw	r20, r18
    3008:	c6 01       	movw	r24, r12
    300a:	0e 94 90 1a 	call	0x3520	; 0x3520 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    300e:	d6 01       	movw	r26, r12
    3010:	ed 91       	ld	r30, X+
    3012:	fc 91       	ld	r31, X
    3014:	02 80       	ldd	r0, Z+2	; 0x02
    3016:	f3 81       	ldd	r31, Z+3	; 0x03
    3018:	e0 2d       	mov	r30, r0
    301a:	6e e2       	ldi	r22, 0x2E	; 46
    301c:	c6 01       	movw	r24, r12
    301e:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3020:	c8 01       	movw	r24, r16
    3022:	0e 94 a8 17 	call	0x2f50	; 0x2f50 <_ZN10time_stamp12get_microsecEv>
    3026:	8e 01       	movw	r16, r28
    3028:	09 5f       	subi	r16, 0xF9	; 249
    302a:	1f 4f       	sbci	r17, 0xFF	; 255
    302c:	fe 01       	movw	r30, r28
    302e:	31 96       	adiw	r30, 0x01	; 1
    3030:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3032:	2a e0       	ldi	r18, 0x0A	; 10
    3034:	30 e0       	ldi	r19, 0x00	; 0
    3036:	40 e0       	ldi	r20, 0x00	; 0
    3038:	50 e0       	ldi	r21, 0x00	; 0
    303a:	0e 94 37 21 	call	0x426e	; 0x426e <__divmodsi4>
    303e:	e6 2f       	mov	r30, r22
    3040:	28 87       	std	Y+8, r18	; 0x08
    3042:	39 87       	std	Y+9, r19	; 0x09
    3044:	4a 87       	std	Y+10, r20	; 0x0a
    3046:	5b 87       	std	Y+11, r21	; 0x0b
    3048:	68 85       	ldd	r22, Y+8	; 0x08
    304a:	79 85       	ldd	r23, Y+9	; 0x09
    304c:	8a 85       	ldd	r24, Y+10	; 0x0a
    304e:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3050:	20 e3       	ldi	r18, 0x30	; 48
    3052:	2e 0f       	add	r18, r30
    3054:	d8 01       	movw	r26, r16
    3056:	2e 93       	st	-X, r18
    3058:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    305a:	ae 15       	cp	r26, r14
    305c:	bf 05       	cpc	r27, r15
    305e:	49 f7       	brne	.-46     	; 0x3032 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3060:	1f 82       	std	Y+7, r1	; 0x07
    3062:	be 01       	movw	r22, r28
    3064:	6f 5f       	subi	r22, 0xFF	; 255
    3066:	7f 4f       	sbci	r23, 0xFF	; 255
    3068:	c6 01       	movw	r24, r12
    306a:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    306e:	c6 01       	movw	r24, r12
    3070:	2f 96       	adiw	r28, 0x0f	; 15
    3072:	cd bf       	out	0x3d, r28	; 61
    3074:	de bf       	out	0x3e, r29	; 62
    3076:	df 91       	pop	r29
    3078:	cf 91       	pop	r28
    307a:	1f 91       	pop	r17
    307c:	0f 91       	pop	r16
    307e:	ff 90       	pop	r15
    3080:	ef 90       	pop	r14
    3082:	df 90       	pop	r13
    3084:	cf 90       	pop	r12
    3086:	08 95       	ret

00003088 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3088:	cf 93       	push	r28
    308a:	df 93       	push	r29
    308c:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    308e:	0f b6       	in	r0, 0x3f	; 63
    3090:	f8 94       	cli
    3092:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3094:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3098:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    309c:	8c 83       	std	Y+4, r24	; 0x04
    309e:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    30a0:	0e 94 58 10 	call	0x20b0	; 0x20b0 <xTaskGetTickCount>
    30a4:	68 83       	st	Y, r22
    30a6:	79 83       	std	Y+1, r23	; 0x01
    30a8:	8a 83       	std	Y+2, r24	; 0x02
    30aa:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    30ac:	0f 90       	pop	r0
    30ae:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    30b0:	ce 01       	movw	r24, r28
    30b2:	df 91       	pop	r29
    30b4:	cf 91       	pop	r28
    30b6:	08 95       	ret

000030b8 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    30b8:	5f 92       	push	r5
    30ba:	6f 92       	push	r6
    30bc:	7f 92       	push	r7
    30be:	8f 92       	push	r8
    30c0:	9f 92       	push	r9
    30c2:	af 92       	push	r10
    30c4:	bf 92       	push	r11
    30c6:	cf 92       	push	r12
    30c8:	df 92       	push	r13
    30ca:	ef 92       	push	r14
    30cc:	ff 92       	push	r15
    30ce:	0f 93       	push	r16
    30d0:	1f 93       	push	r17
    30d2:	cf 93       	push	r28
    30d4:	df 93       	push	r29
    30d6:	5c 01       	movw	r10, r24
    30d8:	4b 01       	movw	r8, r22
    30da:	7a 01       	movw	r14, r20
    30dc:	12 2f       	mov	r17, r18
    30de:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    30e0:	63 e0       	ldi	r22, 0x03	; 3
    30e2:	ca 01       	movw	r24, r20
    30e4:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    30e8:	a8 14       	cp	r10, r8
    30ea:	b9 04       	cpc	r11, r9
    30ec:	08 f0       	brcs	.+2      	; 0x30f0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    30ee:	7d c0       	rjmp	.+250    	; 0x31ea <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30f0:	65 01       	movw	r12, r10
    30f2:	84 e1       	ldi	r24, 0x14	; 20
    30f4:	c8 0e       	add	r12, r24
    30f6:	d1 1c       	adc	r13, r1
    30f8:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    30fa:	6a 2c       	mov	r6, r10
    30fc:	5b 2c       	mov	r5, r11
    30fe:	b5 01       	movw	r22, r10
    3100:	c7 01       	movw	r24, r14
    3102:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <_ZN8emstreamlsEj>
    3106:	6a e0       	ldi	r22, 0x0A	; 10
    3108:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    310c:	65 e4       	ldi	r22, 0x45	; 69
    310e:	75 e0       	ldi	r23, 0x05	; 5
    3110:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3114:	11 23       	and	r17, r17
    3116:	09 f4       	brne	.+2      	; 0x311a <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3118:	6d c0       	rjmp	.+218    	; 0x31f4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    311a:	00 23       	and	r16, r16
    311c:	09 f4       	brne	.+2      	; 0x3120 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    311e:	6a c0       	rjmp	.+212    	; 0x31f4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3120:	6a e0       	ldi	r22, 0x0A	; 10
    3122:	c7 01       	movw	r24, r14
    3124:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    3128:	60 e4       	ldi	r22, 0x40	; 64
    312a:	75 e0       	ldi	r23, 0x05	; 5
    312c:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    3130:	61 c0       	rjmp	.+194    	; 0x31f4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3132:	11 23       	and	r17, r17
    3134:	71 f0       	breq	.+28     	; 0x3152 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3136:	01 11       	cpse	r16, r1
    3138:	0c c0       	rjmp	.+24     	; 0x3152 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    313a:	88 81       	ld	r24, Y
    313c:	87 15       	cp	r24, r7
    313e:	49 f0       	breq	.+18     	; 0x3152 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3140:	6a e0       	ldi	r22, 0x0A	; 10
    3142:	c7 01       	movw	r24, r14
    3144:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    3148:	6b e3       	ldi	r22, 0x3B	; 59
    314a:	75 e0       	ldi	r23, 0x05	; 5
    314c:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3150:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3152:	69 91       	ld	r22, Y+
    3154:	c7 01       	movw	r24, r14
    3156:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    315a:	dc 01       	movw	r26, r24
    315c:	ed 91       	ld	r30, X+
    315e:	fc 91       	ld	r31, X
    3160:	02 80       	ldd	r0, Z+2	; 0x02
    3162:	f3 81       	ldd	r31, Z+3	; 0x03
    3164:	e0 2d       	mov	r30, r0
    3166:	60 e2       	ldi	r22, 0x20	; 32
    3168:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    316a:	cc 16       	cp	r12, r28
    316c:	dd 06       	cpc	r13, r29
    316e:	09 f7       	brne	.-62     	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3170:	11 23       	and	r17, r17
    3172:	89 f0       	breq	.+34     	; 0x3196 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3174:	6a e0       	ldi	r22, 0x0A	; 10
    3176:	c7 01       	movw	r24, r14
    3178:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    317c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    317e:	65 e3       	ldi	r22, 0x35	; 53
    3180:	75 e0       	ldi	r23, 0x05	; 5
    3182:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3186:	e8 81       	ld	r30, Y
    3188:	f9 81       	ldd	r31, Y+1	; 0x01
    318a:	02 80       	ldd	r0, Z+2	; 0x02
    318c:	f3 81       	ldd	r31, Z+3	; 0x03
    318e:	e0 2d       	mov	r30, r0
    3190:	60 e2       	ldi	r22, 0x20	; 32
    3192:	ce 01       	movw	r24, r28
    3194:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3196:	c6 2d       	mov	r28, r6
    3198:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    319a:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    319c:	80 ee       	ldi	r24, 0xE0	; 224
    319e:	86 0f       	add	r24, r22
    31a0:	8f 35       	cpi	r24, 0x5F	; 95
    31a2:	48 f4       	brcc	.+18     	; 0x31b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    31a4:	d7 01       	movw	r26, r14
    31a6:	ed 91       	ld	r30, X+
    31a8:	fc 91       	ld	r31, X
    31aa:	02 80       	ldd	r0, Z+2	; 0x02
    31ac:	f3 81       	ldd	r31, Z+3	; 0x03
    31ae:	e0 2d       	mov	r30, r0
    31b0:	c7 01       	movw	r24, r14
    31b2:	19 95       	eicall
    31b4:	09 c0       	rjmp	.+18     	; 0x31c8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    31b6:	d7 01       	movw	r26, r14
    31b8:	ed 91       	ld	r30, X+
    31ba:	fc 91       	ld	r31, X
    31bc:	02 80       	ldd	r0, Z+2	; 0x02
    31be:	f3 81       	ldd	r31, Z+3	; 0x03
    31c0:	e0 2d       	mov	r30, r0
    31c2:	6e e2       	ldi	r22, 0x2E	; 46
    31c4:	c7 01       	movw	r24, r14
    31c6:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    31c8:	cc 16       	cp	r12, r28
    31ca:	dd 06       	cpc	r13, r29
    31cc:	31 f7       	brne	.-52     	; 0x319a <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31ce:	b4 e1       	ldi	r27, 0x14	; 20
    31d0:	ab 0e       	add	r10, r27
    31d2:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31d4:	66 e0       	ldi	r22, 0x06	; 6
    31d6:	c7 01       	movw	r24, r14
    31d8:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    31dc:	84 e1       	ldi	r24, 0x14	; 20
    31de:	c8 0e       	add	r12, r24
    31e0:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31e2:	a8 14       	cp	r10, r8
    31e4:	b9 04       	cpc	r11, r9
    31e6:	08 f4       	brcc	.+2      	; 0x31ea <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31e8:	88 cf       	rjmp	.-240    	; 0x30fa <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    31ea:	62 e0       	ldi	r22, 0x02	; 2
    31ec:	c7 01       	movw	r24, r14
    31ee:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
}
    31f2:	03 c0       	rjmp	.+6      	; 0x31fa <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31f4:	c6 2d       	mov	r28, r6
    31f6:	d5 2d       	mov	r29, r5
    31f8:	9c cf       	rjmp	.-200    	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    31fa:	df 91       	pop	r29
    31fc:	cf 91       	pop	r28
    31fe:	1f 91       	pop	r17
    3200:	0f 91       	pop	r16
    3202:	ff 90       	pop	r15
    3204:	ef 90       	pop	r14
    3206:	df 90       	pop	r13
    3208:	cf 90       	pop	r12
    320a:	bf 90       	pop	r11
    320c:	af 90       	pop	r10
    320e:	9f 90       	pop	r9
    3210:	8f 90       	pop	r8
    3212:	7f 90       	pop	r7
    3214:	6f 90       	pop	r6
    3216:	5f 90       	pop	r5
    3218:	08 95       	ret

0000321a <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    321a:	0e 94 3e 09 	call	0x127c	; 0x127c <pvPortMalloc>
    321e:	08 95       	ret

00003220 <_ZdlPv>:
    3220:	00 97       	sbiw	r24, 0x00	; 0
    3222:	11 f0       	breq	.+4      	; 0x3228 <_ZdlPv+0x8>
    3224:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <vPortFree>
    3228:	08 95       	ret

0000322a <_Znaj>:
    322a:	0e 94 3e 09 	call	0x127c	; 0x127c <pvPortMalloc>
    322e:	08 95       	ret

00003230 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3230:	08 95       	ret

00003232 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3232:	cf 93       	push	r28
    3234:	df 93       	push	r29
    3236:	fc 01       	movw	r30, r24
    3238:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    323a:	40 3a       	cpi	r20, 0xA0	; 160
    323c:	68 e0       	ldi	r22, 0x08	; 8
    323e:	56 07       	cpc	r21, r22
    3240:	49 f4       	brne	.+18     	; 0x3254 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3242:	80 e4       	ldi	r24, 0x40	; 64
    3244:	96 e0       	ldi	r25, 0x06	; 6
    3246:	82 83       	std	Z+2, r24	; 0x02
    3248:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    324a:	82 e0       	ldi	r24, 0x02	; 2
    324c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    324e:	83 e0       	ldi	r24, 0x03	; 3
    3250:	85 83       	std	Z+5, r24	; 0x05
    3252:	32 c0       	rjmp	.+100    	; 0x32b8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3254:	40 3b       	cpi	r20, 0xB0	; 176
    3256:	78 e0       	ldi	r23, 0x08	; 8
    3258:	57 07       	cpc	r21, r23
    325a:	49 f4       	brne	.+18     	; 0x326e <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    325c:	80 e4       	ldi	r24, 0x40	; 64
    325e:	96 e0       	ldi	r25, 0x06	; 6
    3260:	82 83       	std	Z+2, r24	; 0x02
    3262:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3264:	86 e0       	ldi	r24, 0x06	; 6
    3266:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3268:	87 e0       	ldi	r24, 0x07	; 7
    326a:	85 83       	std	Z+5, r24	; 0x05
    326c:	25 c0       	rjmp	.+74     	; 0x32b8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    326e:	40 3a       	cpi	r20, 0xA0	; 160
    3270:	89 e0       	ldi	r24, 0x09	; 9
    3272:	58 07       	cpc	r21, r24
    3274:	49 f4       	brne	.+18     	; 0x3288 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3276:	80 e6       	ldi	r24, 0x60	; 96
    3278:	96 e0       	ldi	r25, 0x06	; 6
    327a:	82 83       	std	Z+2, r24	; 0x02
    327c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    327e:	82 e0       	ldi	r24, 0x02	; 2
    3280:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3282:	83 e0       	ldi	r24, 0x03	; 3
    3284:	85 83       	std	Z+5, r24	; 0x05
    3286:	18 c0       	rjmp	.+48     	; 0x32b8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3288:	40 3b       	cpi	r20, 0xB0	; 176
    328a:	69 e0       	ldi	r22, 0x09	; 9
    328c:	56 07       	cpc	r21, r22
    328e:	49 f4       	brne	.+18     	; 0x32a2 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3290:	80 e6       	ldi	r24, 0x60	; 96
    3292:	96 e0       	ldi	r25, 0x06	; 6
    3294:	82 83       	std	Z+2, r24	; 0x02
    3296:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3298:	86 e0       	ldi	r24, 0x06	; 6
    329a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    329c:	87 e0       	ldi	r24, 0x07	; 7
    329e:	85 83       	std	Z+5, r24	; 0x05
    32a0:	0b c0       	rjmp	.+22     	; 0x32b8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    32a2:	40 3a       	cpi	r20, 0xA0	; 160
    32a4:	5a 40       	sbci	r21, 0x0A	; 10
    32a6:	41 f4       	brne	.+16     	; 0x32b8 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    32a8:	80 e8       	ldi	r24, 0x80	; 128
    32aa:	96 e0       	ldi	r25, 0x06	; 6
    32ac:	82 83       	std	Z+2, r24	; 0x02
    32ae:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32b0:	82 e0       	ldi	r24, 0x02	; 2
    32b2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32b4:	83 e0       	ldi	r24, 0x03	; 3
    32b6:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    32b8:	a6 83       	std	Z+6, r26	; 0x06
    32ba:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    32bc:	cd 01       	movw	r24, r26
    32be:	01 96       	adiw	r24, 0x01	; 1
    32c0:	80 87       	std	Z+8, r24	; 0x08
    32c2:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    32c4:	03 96       	adiw	r24, 0x03	; 3
    32c6:	82 87       	std	Z+10, r24	; 0x0a
    32c8:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    32ca:	25 81       	ldd	r18, Z+5	; 0x05
    32cc:	c2 81       	ldd	r28, Z+2	; 0x02
    32ce:	d3 81       	ldd	r29, Z+3	; 0x03
    32d0:	4c 81       	ldd	r20, Y+4	; 0x04
    32d2:	81 e0       	ldi	r24, 0x01	; 1
    32d4:	90 e0       	ldi	r25, 0x00	; 0
    32d6:	bc 01       	movw	r22, r24
    32d8:	02 c0       	rjmp	.+4      	; 0x32de <_ZN7base232C1EjP12USART_struct+0xac>
    32da:	66 0f       	add	r22, r22
    32dc:	77 1f       	adc	r23, r23
    32de:	2a 95       	dec	r18
    32e0:	e2 f7       	brpl	.-8      	; 0x32da <_ZN7base232C1EjP12USART_struct+0xa8>
    32e2:	9b 01       	movw	r18, r22
    32e4:	24 2b       	or	r18, r20
    32e6:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    32e8:	25 81       	ldd	r18, Z+5	; 0x05
    32ea:	c2 81       	ldd	r28, Z+2	; 0x02
    32ec:	d3 81       	ldd	r29, Z+3	; 0x03
    32ee:	48 81       	ld	r20, Y
    32f0:	bc 01       	movw	r22, r24
    32f2:	02 c0       	rjmp	.+4      	; 0x32f8 <_ZN7base232C1EjP12USART_struct+0xc6>
    32f4:	66 0f       	add	r22, r22
    32f6:	77 1f       	adc	r23, r23
    32f8:	2a 95       	dec	r18
    32fa:	e2 f7       	brpl	.-8      	; 0x32f4 <_ZN7base232C1EjP12USART_struct+0xc2>
    32fc:	9b 01       	movw	r18, r22
    32fe:	24 2b       	or	r18, r20
    3300:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3302:	34 81       	ldd	r19, Z+4	; 0x04
    3304:	c2 81       	ldd	r28, Z+2	; 0x02
    3306:	d3 81       	ldd	r29, Z+3	; 0x03
    3308:	28 81       	ld	r18, Y
    330a:	02 c0       	rjmp	.+4      	; 0x3310 <_ZN7base232C1EjP12USART_struct+0xde>
    330c:	88 0f       	add	r24, r24
    330e:	99 1f       	adc	r25, r25
    3310:	3a 95       	dec	r19
    3312:	e2 f7       	brpl	.-8      	; 0x330c <_ZN7base232C1EjP12USART_struct+0xda>
    3314:	80 95       	com	r24
    3316:	90 95       	com	r25
    3318:	82 23       	and	r24, r18
    331a:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    331c:	80 e1       	ldi	r24, 0x10	; 16
    331e:	13 96       	adiw	r26, 0x03	; 3
    3320:	8c 93       	st	X, r24
    3322:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3324:	83 e0       	ldi	r24, 0x03	; 3
    3326:	15 96       	adiw	r26, 0x05	; 5
    3328:	8c 93       	st	X, r24
    332a:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    332c:	80 ef       	ldi	r24, 0xF0	; 240
    332e:	17 96       	adiw	r26, 0x07	; 7
    3330:	8c 93       	st	X, r24
    3332:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3334:	81 e2       	ldi	r24, 0x21	; 33
    3336:	16 96       	adiw	r26, 0x06	; 6
    3338:	8c 93       	st	X, r24
    333a:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    333c:	88 e1       	ldi	r24, 0x18	; 24
    333e:	14 96       	adiw	r26, 0x04	; 4
    3340:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3342:	80 e8       	ldi	r24, 0x80	; 128
    3344:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3346:	80 e4       	ldi	r24, 0x40	; 64
    3348:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    334a:	80 e2       	ldi	r24, 0x20	; 32
    334c:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    334e:	06 80       	ldd	r0, Z+6	; 0x06
    3350:	f7 81       	ldd	r31, Z+7	; 0x07
    3352:	e0 2d       	mov	r30, r0
    3354:	80 81       	ld	r24, Z
    3356:	80 81       	ld	r24, Z
}
    3358:	df 91       	pop	r29
    335a:	cf 91       	pop	r28
    335c:	08 95       	ret

0000335e <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    335e:	81 e0       	ldi	r24, 0x01	; 1
    3360:	08 95       	ret

00003362 <_ZN8emstream7getcharEv>:
    3362:	80 e0       	ldi	r24, 0x00	; 0
    3364:	90 e0       	ldi	r25, 0x00	; 0
    3366:	08 95       	ret

00003368 <_ZN8emstream14check_for_charEv>:
    3368:	80 e0       	ldi	r24, 0x00	; 0
    336a:	08 95       	ret

0000336c <_ZN8emstream12transmit_nowEv>:
    336c:	08 95       	ret

0000336e <_ZN8emstream12clear_screenEv>:
    336e:	08 95       	ret

00003370 <_ZN8emstreamC1Ev>:
    3370:	fc 01       	movw	r30, r24
    3372:	88 e6       	ldi	r24, 0x68	; 104
    3374:	90 e2       	ldi	r25, 0x20	; 32
    3376:	80 83       	st	Z, r24
    3378:	91 83       	std	Z+1, r25	; 0x01
    337a:	8a e0       	ldi	r24, 0x0A	; 10
    337c:	82 83       	std	Z+2, r24	; 0x02
    337e:	13 82       	std	Z+3, r1	; 0x03
    3380:	83 e0       	ldi	r24, 0x03	; 3
    3382:	85 83       	std	Z+5, r24	; 0x05
    3384:	14 82       	std	Z+4, r1	; 0x04
    3386:	16 82       	std	Z+6, r1	; 0x06
    3388:	17 82       	std	Z+7, r1	; 0x07
    338a:	08 95       	ret

0000338c <_ZN8emstream4putsEPKc>:
    338c:	0f 93       	push	r16
    338e:	1f 93       	push	r17
    3390:	cf 93       	push	r28
    3392:	df 93       	push	r29
    3394:	8c 01       	movw	r16, r24
    3396:	fb 01       	movw	r30, r22
    3398:	dc 01       	movw	r26, r24
    339a:	14 96       	adiw	r26, 0x04	; 4
    339c:	8c 91       	ld	r24, X
    339e:	81 11       	cpse	r24, r1
    33a0:	04 c0       	rjmp	.+8      	; 0x33aa <_ZN8emstream4putsEPKc+0x1e>
    33a2:	60 81       	ld	r22, Z
    33a4:	61 11       	cpse	r22, r1
    33a6:	17 c0       	rjmp	.+46     	; 0x33d6 <_ZN8emstream4putsEPKc+0x4a>
    33a8:	23 c0       	rjmp	.+70     	; 0x33f0 <_ZN8emstream4putsEPKc+0x64>
    33aa:	d8 01       	movw	r26, r16
    33ac:	14 96       	adiw	r26, 0x04	; 4
    33ae:	1c 92       	st	X, r1
    33b0:	eb 01       	movw	r28, r22
    33b2:	21 96       	adiw	r28, 0x01	; 1
    33b4:	64 91       	lpm	r22, Z
    33b6:	66 23       	and	r22, r22
    33b8:	d9 f0       	breq	.+54     	; 0x33f0 <_ZN8emstream4putsEPKc+0x64>
    33ba:	d8 01       	movw	r26, r16
    33bc:	ed 91       	ld	r30, X+
    33be:	fc 91       	ld	r31, X
    33c0:	02 80       	ldd	r0, Z+2	; 0x02
    33c2:	f3 81       	ldd	r31, Z+3	; 0x03
    33c4:	e0 2d       	mov	r30, r0
    33c6:	c8 01       	movw	r24, r16
    33c8:	19 95       	eicall
    33ca:	fe 01       	movw	r30, r28
    33cc:	64 91       	lpm	r22, Z
    33ce:	21 96       	adiw	r28, 0x01	; 1
    33d0:	61 11       	cpse	r22, r1
    33d2:	f3 cf       	rjmp	.-26     	; 0x33ba <_ZN8emstream4putsEPKc+0x2e>
    33d4:	0d c0       	rjmp	.+26     	; 0x33f0 <_ZN8emstream4putsEPKc+0x64>
    33d6:	ef 01       	movw	r28, r30
    33d8:	21 96       	adiw	r28, 0x01	; 1
    33da:	d8 01       	movw	r26, r16
    33dc:	ed 91       	ld	r30, X+
    33de:	fc 91       	ld	r31, X
    33e0:	02 80       	ldd	r0, Z+2	; 0x02
    33e2:	f3 81       	ldd	r31, Z+3	; 0x03
    33e4:	e0 2d       	mov	r30, r0
    33e6:	c8 01       	movw	r24, r16
    33e8:	19 95       	eicall
    33ea:	69 91       	ld	r22, Y+
    33ec:	61 11       	cpse	r22, r1
    33ee:	f5 cf       	rjmp	.-22     	; 0x33da <_ZN8emstream4putsEPKc+0x4e>
    33f0:	df 91       	pop	r29
    33f2:	cf 91       	pop	r28
    33f4:	1f 91       	pop	r17
    33f6:	0f 91       	pop	r16
    33f8:	08 95       	ret

000033fa <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    33fa:	cf 93       	push	r28
    33fc:	df 93       	push	r29
    33fe:	ec 01       	movw	r28, r24
	switch (new_manip)
    3400:	86 2f       	mov	r24, r22
    3402:	90 e0       	ldi	r25, 0x00	; 0
    3404:	8b 30       	cpi	r24, 0x0B	; 11
    3406:	91 05       	cpc	r25, r1
    3408:	d8 f5       	brcc	.+118    	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
    340a:	fc 01       	movw	r30, r24
    340c:	88 27       	eor	r24, r24
    340e:	e2 50       	subi	r30, 0x02	; 2
    3410:	ff 4f       	sbci	r31, 0xFF	; 255
    3412:	8f 4f       	sbci	r24, 0xFF	; 255
    3414:	0c 94 56 21 	jmp	0x42ac	; 0x42ac <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3418:	82 e0       	ldi	r24, 0x02	; 2
    341a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    341c:	31 c0       	rjmp	.+98     	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    341e:	88 e0       	ldi	r24, 0x08	; 8
    3420:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3422:	2e c0       	rjmp	.+92     	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3424:	8a e0       	ldi	r24, 0x0A	; 10
    3426:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3428:	2b c0       	rjmp	.+86     	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    342a:	80 e1       	ldi	r24, 0x10	; 16
    342c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    342e:	28 c0       	rjmp	.+80     	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3430:	81 e0       	ldi	r24, 0x01	; 1
    3432:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3434:	25 c0       	rjmp	.+74     	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3436:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3438:	23 c0       	rjmp	.+70     	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    343a:	e8 81       	ld	r30, Y
    343c:	f9 81       	ldd	r31, Y+1	; 0x01
    343e:	02 80       	ldd	r0, Z+2	; 0x02
    3440:	f3 81       	ldd	r31, Z+3	; 0x03
    3442:	e0 2d       	mov	r30, r0
    3444:	6d e0       	ldi	r22, 0x0D	; 13
    3446:	ce 01       	movw	r24, r28
    3448:	19 95       	eicall
    344a:	e8 81       	ld	r30, Y
    344c:	f9 81       	ldd	r31, Y+1	; 0x01
    344e:	02 80       	ldd	r0, Z+2	; 0x02
    3450:	f3 81       	ldd	r31, Z+3	; 0x03
    3452:	e0 2d       	mov	r30, r0
    3454:	6a e0       	ldi	r22, 0x0A	; 10
    3456:	ce 01       	movw	r24, r28
    3458:	19 95       	eicall
			break;
    345a:	12 c0       	rjmp	.+36     	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    345c:	e8 81       	ld	r30, Y
    345e:	f9 81       	ldd	r31, Y+1	; 0x01
    3460:	02 84       	ldd	r0, Z+10	; 0x0a
    3462:	f3 85       	ldd	r31, Z+11	; 0x0b
    3464:	e0 2d       	mov	r30, r0
    3466:	ce 01       	movw	r24, r28
    3468:	19 95       	eicall
			break;
    346a:	0a c0       	rjmp	.+20     	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    346c:	e8 81       	ld	r30, Y
    346e:	f9 81       	ldd	r31, Y+1	; 0x01
    3470:	00 84       	ldd	r0, Z+8	; 0x08
    3472:	f1 85       	ldd	r31, Z+9	; 0x09
    3474:	e0 2d       	mov	r30, r0
    3476:	ce 01       	movw	r24, r28
    3478:	19 95       	eicall
			break;
    347a:	02 c0       	rjmp	.+4      	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    347c:	81 e0       	ldi	r24, 0x01	; 1
    347e:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3480:	ce 01       	movw	r24, r28
    3482:	df 91       	pop	r29
    3484:	cf 91       	pop	r28
    3486:	08 95       	ret

00003488 <_ZN8emstreamlsEb>:
 *          reference is used to string printable items together with "<<" operators
 *  @param value The boolean value to be written
 */

emstream& emstream::operator<< (bool value)
{
    3488:	cf 93       	push	r28
    348a:	df 93       	push	r29
    348c:	ec 01       	movw	r28, r24
	if (value)
    348e:	66 23       	and	r22, r22
    3490:	41 f0       	breq	.+16     	; 0x34a2 <_ZN8emstreamlsEb+0x1a>
		putchar ('T');
    3492:	e8 81       	ld	r30, Y
    3494:	f9 81       	ldd	r31, Y+1	; 0x01
    3496:	02 80       	ldd	r0, Z+2	; 0x02
    3498:	f3 81       	ldd	r31, Z+3	; 0x03
    349a:	e0 2d       	mov	r30, r0
    349c:	64 e5       	ldi	r22, 0x54	; 84
    349e:	19 95       	eicall
    34a0:	07 c0       	rjmp	.+14     	; 0x34b0 <_ZN8emstreamlsEb+0x28>
	else
		putchar ('F');
    34a2:	e8 81       	ld	r30, Y
    34a4:	f9 81       	ldd	r31, Y+1	; 0x01
    34a6:	02 80       	ldd	r0, Z+2	; 0x02
    34a8:	f3 81       	ldd	r31, Z+3	; 0x03
    34aa:	e0 2d       	mov	r30, r0
    34ac:	66 e4       	ldi	r22, 0x46	; 70
    34ae:	19 95       	eicall

	return (*this);
}
    34b0:	ce 01       	movw	r24, r28
    34b2:	df 91       	pop	r29
    34b4:	cf 91       	pop	r28
    34b6:	08 95       	ret

000034b8 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    34b8:	ff 92       	push	r15
    34ba:	0f 93       	push	r16
    34bc:	1f 93       	push	r17
    34be:	cf 93       	push	r28
    34c0:	df 93       	push	r29
    34c2:	cd b7       	in	r28, 0x3d	; 61
    34c4:	de b7       	in	r29, 0x3e	; 62
    34c6:	61 97       	sbiw	r28, 0x11	; 17
    34c8:	cd bf       	out	0x3d, r28	; 61
    34ca:	de bf       	out	0x3e, r29	; 62
    34cc:	8c 01       	movw	r16, r24
    34ce:	f6 2e       	mov	r15, r22
    34d0:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    34d2:	f8 01       	movw	r30, r16
    34d4:	42 81       	ldd	r20, Z+2	; 0x02
    34d6:	40 31       	cpi	r20, 0x10	; 16
    34d8:	21 f0       	breq	.+8      	; 0x34e2 <_ZN8emstreamlsEj+0x2a>
    34da:	48 30       	cpi	r20, 0x08	; 8
    34dc:	11 f0       	breq	.+4      	; 0x34e2 <_ZN8emstreamlsEj+0x2a>
    34de:	42 30       	cpi	r20, 0x02	; 2
    34e0:	41 f4       	brne	.+16     	; 0x34f2 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    34e2:	69 2f       	mov	r22, r25
    34e4:	c8 01       	movw	r24, r16
    34e6:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
    34ea:	6f 2d       	mov	r22, r15
    34ec:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
    34f0:	0d c0       	rjmp	.+26     	; 0x350c <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    34f2:	50 e0       	ldi	r21, 0x00	; 0
    34f4:	be 01       	movw	r22, r28
    34f6:	6f 5f       	subi	r22, 0xFF	; 255
    34f8:	7f 4f       	sbci	r23, 0xFF	; 255
    34fa:	8f 2d       	mov	r24, r15
    34fc:	0e 94 cc 21 	call	0x4398	; 0x4398 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3500:	be 01       	movw	r22, r28
    3502:	6f 5f       	subi	r22, 0xFF	; 255
    3504:	7f 4f       	sbci	r23, 0xFF	; 255
    3506:	c8 01       	movw	r24, r16
    3508:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    350c:	c8 01       	movw	r24, r16
    350e:	61 96       	adiw	r28, 0x11	; 17
    3510:	cd bf       	out	0x3d, r28	; 61
    3512:	de bf       	out	0x3e, r29	; 62
    3514:	df 91       	pop	r29
    3516:	cf 91       	pop	r28
    3518:	1f 91       	pop	r17
    351a:	0f 91       	pop	r16
    351c:	ff 90       	pop	r15
    351e:	08 95       	ret

00003520 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3520:	df 92       	push	r13
    3522:	ef 92       	push	r14
    3524:	ff 92       	push	r15
    3526:	0f 93       	push	r16
    3528:	1f 93       	push	r17
    352a:	cf 93       	push	r28
    352c:	df 93       	push	r29
    352e:	cd b7       	in	r28, 0x3d	; 61
    3530:	de b7       	in	r29, 0x3e	; 62
    3532:	a1 97       	sbiw	r28, 0x21	; 33
    3534:	cd bf       	out	0x3d, r28	; 61
    3536:	de bf       	out	0x3e, r29	; 62
    3538:	8c 01       	movw	r16, r24
    353a:	d4 2e       	mov	r13, r20
    353c:	e5 2e       	mov	r14, r21
    353e:	f6 2e       	mov	r15, r22
    3540:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3542:	f8 01       	movw	r30, r16
    3544:	22 81       	ldd	r18, Z+2	; 0x02
    3546:	20 31       	cpi	r18, 0x10	; 16
    3548:	21 f0       	breq	.+8      	; 0x3552 <_ZN8emstreamlsEm+0x32>
    354a:	28 30       	cpi	r18, 0x08	; 8
    354c:	11 f0       	breq	.+4      	; 0x3552 <_ZN8emstreamlsEm+0x32>
    354e:	22 30       	cpi	r18, 0x02	; 2
    3550:	71 f4       	brne	.+28     	; 0x356e <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3552:	69 2f       	mov	r22, r25
    3554:	c8 01       	movw	r24, r16
    3556:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
    355a:	6f 2d       	mov	r22, r15
    355c:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
    3560:	6e 2d       	mov	r22, r14
    3562:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
    3566:	6d 2d       	mov	r22, r13
    3568:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_ZN8emstreamlsEh>
    356c:	0f c0       	rjmp	.+30     	; 0x358c <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    356e:	30 e0       	ldi	r19, 0x00	; 0
    3570:	ae 01       	movw	r20, r28
    3572:	4f 5f       	subi	r20, 0xFF	; 255
    3574:	5f 4f       	sbci	r21, 0xFF	; 255
    3576:	6d 2d       	mov	r22, r13
    3578:	7e 2d       	mov	r23, r14
    357a:	8f 2d       	mov	r24, r15
    357c:	0e 94 9f 21 	call	0x433e	; 0x433e <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3580:	be 01       	movw	r22, r28
    3582:	6f 5f       	subi	r22, 0xFF	; 255
    3584:	7f 4f       	sbci	r23, 0xFF	; 255
    3586:	c8 01       	movw	r24, r16
    3588:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    358c:	c8 01       	movw	r24, r16
    358e:	a1 96       	adiw	r28, 0x21	; 33
    3590:	cd bf       	out	0x3d, r28	; 61
    3592:	de bf       	out	0x3e, r29	; 62
    3594:	df 91       	pop	r29
    3596:	cf 91       	pop	r28
    3598:	1f 91       	pop	r17
    359a:	0f 91       	pop	r16
    359c:	ff 90       	pop	r15
    359e:	ef 90       	pop	r14
    35a0:	df 90       	pop	r13
    35a2:	08 95       	ret

000035a4 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    35a4:	cf 92       	push	r12
    35a6:	df 92       	push	r13
    35a8:	ef 92       	push	r14
    35aa:	ff 92       	push	r15
    35ac:	0f 93       	push	r16
    35ae:	1f 93       	push	r17
    35b0:	cf 93       	push	r28
    35b2:	df 93       	push	r29
    35b4:	cd b7       	in	r28, 0x3d	; 61
    35b6:	de b7       	in	r29, 0x3e	; 62
    35b8:	29 97       	sbiw	r28, 0x09	; 9
    35ba:	cd bf       	out	0x3d, r28	; 61
    35bc:	de bf       	out	0x3e, r29	; 62
    35be:	8c 01       	movw	r16, r24
    35c0:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    35c2:	dc 01       	movw	r26, r24
    35c4:	13 96       	adiw	r26, 0x03	; 3
    35c6:	8c 91       	ld	r24, X
    35c8:	13 97       	sbiw	r26, 0x03	; 3
    35ca:	88 23       	and	r24, r24
    35cc:	41 f0       	breq	.+16     	; 0x35de <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    35ce:	ed 91       	ld	r30, X+
    35d0:	fc 91       	ld	r31, X
    35d2:	02 80       	ldd	r0, Z+2	; 0x02
    35d4:	f3 81       	ldd	r31, Z+3	; 0x03
    35d6:	e0 2d       	mov	r30, r0
    35d8:	c8 01       	movw	r24, r16
    35da:	19 95       	eicall
    35dc:	56 c0       	rjmp	.+172    	; 0x368a <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    35de:	f8 01       	movw	r30, r16
    35e0:	42 81       	ldd	r20, Z+2	; 0x02
    35e2:	42 30       	cpi	r20, 0x02	; 2
    35e4:	19 f5       	brne	.+70     	; 0x362c <_ZN8emstreamlsEh+0x88>
    35e6:	68 94       	set
    35e8:	cc 24       	eor	r12, r12
    35ea:	c3 f8       	bld	r12, 3
    35ec:	d1 2c       	mov	r13, r1
    35ee:	68 94       	set
    35f0:	ff 24       	eor	r15, r15
    35f2:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    35f4:	8e 2d       	mov	r24, r14
    35f6:	8f 21       	and	r24, r15
    35f8:	51 f0       	breq	.+20     	; 0x360e <_ZN8emstreamlsEh+0x6a>
    35fa:	d8 01       	movw	r26, r16
    35fc:	ed 91       	ld	r30, X+
    35fe:	fc 91       	ld	r31, X
    3600:	02 80       	ldd	r0, Z+2	; 0x02
    3602:	f3 81       	ldd	r31, Z+3	; 0x03
    3604:	e0 2d       	mov	r30, r0
    3606:	61 e3       	ldi	r22, 0x31	; 49
    3608:	c8 01       	movw	r24, r16
    360a:	19 95       	eicall
    360c:	09 c0       	rjmp	.+18     	; 0x3620 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    360e:	d8 01       	movw	r26, r16
    3610:	ed 91       	ld	r30, X+
    3612:	fc 91       	ld	r31, X
    3614:	02 80       	ldd	r0, Z+2	; 0x02
    3616:	f3 81       	ldd	r31, Z+3	; 0x03
    3618:	e0 2d       	mov	r30, r0
    361a:	60 e3       	ldi	r22, 0x30	; 48
    361c:	c8 01       	movw	r24, r16
    361e:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3620:	f6 94       	lsr	r15
    3622:	b1 e0       	ldi	r27, 0x01	; 1
    3624:	cb 1a       	sub	r12, r27
    3626:	d1 08       	sbc	r13, r1
    3628:	29 f7       	brne	.-54     	; 0x35f4 <_ZN8emstreamlsEh+0x50>
    362a:	2f c0       	rjmp	.+94     	; 0x368a <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    362c:	40 31       	cpi	r20, 0x10	; 16
    362e:	f9 f4       	brne	.+62     	; 0x366e <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3630:	62 95       	swap	r22
    3632:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3634:	01 90       	ld	r0, Z+
    3636:	f0 81       	ld	r31, Z
    3638:	e0 2d       	mov	r30, r0
    363a:	02 80       	ldd	r0, Z+2	; 0x02
    363c:	f3 81       	ldd	r31, Z+3	; 0x03
    363e:	e0 2d       	mov	r30, r0
    3640:	6a 30       	cpi	r22, 0x0A	; 10
    3642:	10 f0       	brcs	.+4      	; 0x3648 <_ZN8emstreamlsEh+0xa4>
    3644:	69 5c       	subi	r22, 0xC9	; 201
    3646:	01 c0       	rjmp	.+2      	; 0x364a <_ZN8emstreamlsEh+0xa6>
    3648:	60 5d       	subi	r22, 0xD0	; 208
    364a:	c8 01       	movw	r24, r16
    364c:	19 95       	eicall
		temp_char = num & 0x0F;
    364e:	6e 2d       	mov	r22, r14
    3650:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3652:	d8 01       	movw	r26, r16
    3654:	ed 91       	ld	r30, X+
    3656:	fc 91       	ld	r31, X
    3658:	02 80       	ldd	r0, Z+2	; 0x02
    365a:	f3 81       	ldd	r31, Z+3	; 0x03
    365c:	e0 2d       	mov	r30, r0
    365e:	6a 30       	cpi	r22, 0x0A	; 10
    3660:	10 f0       	brcs	.+4      	; 0x3666 <_ZN8emstreamlsEh+0xc2>
    3662:	69 5c       	subi	r22, 0xC9	; 201
    3664:	01 c0       	rjmp	.+2      	; 0x3668 <_ZN8emstreamlsEh+0xc4>
    3666:	60 5d       	subi	r22, 0xD0	; 208
    3668:	c8 01       	movw	r24, r16
    366a:	19 95       	eicall
    366c:	0e c0       	rjmp	.+28     	; 0x368a <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    366e:	50 e0       	ldi	r21, 0x00	; 0
    3670:	be 01       	movw	r22, r28
    3672:	6f 5f       	subi	r22, 0xFF	; 255
    3674:	7f 4f       	sbci	r23, 0xFF	; 255
    3676:	8e 2d       	mov	r24, r14
    3678:	90 e0       	ldi	r25, 0x00	; 0
    367a:	0e 94 cc 21 	call	0x4398	; 0x4398 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    367e:	be 01       	movw	r22, r28
    3680:	6f 5f       	subi	r22, 0xFF	; 255
    3682:	7f 4f       	sbci	r23, 0xFF	; 255
    3684:	c8 01       	movw	r24, r16
    3686:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    368a:	c8 01       	movw	r24, r16
    368c:	29 96       	adiw	r28, 0x09	; 9
    368e:	cd bf       	out	0x3d, r28	; 61
    3690:	de bf       	out	0x3e, r29	; 62
    3692:	df 91       	pop	r29
    3694:	cf 91       	pop	r28
    3696:	1f 91       	pop	r17
    3698:	0f 91       	pop	r16
    369a:	ff 90       	pop	r15
    369c:	ef 90       	pop	r14
    369e:	df 90       	pop	r13
    36a0:	cf 90       	pop	r12
    36a2:	08 95       	ret

000036a4 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    36a4:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36a6:	50 96       	adiw	r26, 0x10	; 16
    36a8:	ed 91       	ld	r30, X+
    36aa:	fc 91       	ld	r31, X
    36ac:	51 97       	sbiw	r26, 0x11	; 17
    36ae:	80 81       	ld	r24, Z
    36b0:	54 96       	adiw	r26, 0x14	; 20
    36b2:	4c 91       	ld	r20, X
    36b4:	54 97       	sbiw	r26, 0x14	; 20
    36b6:	84 23       	and	r24, r20
    36b8:	29 f0       	breq	.+10     	; 0x36c4 <_ZN5rs2327putcharEc+0x20>
    36ba:	09 c0       	rjmp	.+18     	; 0x36ce <_ZN5rs2327putcharEc+0x2a>
    36bc:	21 50       	subi	r18, 0x01	; 1
    36be:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    36c0:	19 f4       	brne	.+6      	; 0x36c8 <_ZN5rs2327putcharEc+0x24>
    36c2:	12 c0       	rjmp	.+36     	; 0x36e8 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36c4:	21 e2       	ldi	r18, 0x21	; 33
    36c6:	3e e4       	ldi	r19, 0x4E	; 78
    36c8:	90 81       	ld	r25, Z
    36ca:	94 23       	and	r25, r20
    36cc:	b9 f3       	breq	.-18     	; 0x36bc <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    36ce:	90 81       	ld	r25, Z
    36d0:	56 96       	adiw	r26, 0x16	; 22
    36d2:	8c 91       	ld	r24, X
    36d4:	56 97       	sbiw	r26, 0x16	; 22
    36d6:	89 2b       	or	r24, r25
    36d8:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    36da:	1e 96       	adiw	r26, 0x0e	; 14
    36dc:	ed 91       	ld	r30, X+
    36de:	fc 91       	ld	r31, X
    36e0:	1f 97       	sbiw	r26, 0x0f	; 15
    36e2:	60 83       	st	Z, r22
	return (true);
    36e4:	81 e0       	ldi	r24, 0x01	; 1
    36e6:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    36e8:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    36ea:	08 95       	ret

000036ec <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    36ec:	cf 93       	push	r28
    36ee:	df 93       	push	r29
    36f0:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    36f2:	c1 8d       	ldd	r28, Z+25	; 0x19
    36f4:	d2 8d       	ldd	r29, Z+26	; 0x1a
    36f6:	28 81       	ld	r18, Y
    36f8:	39 81       	ldd	r19, Y+1	; 0x01
    36fa:	a3 8d       	ldd	r26, Z+27	; 0x1b
    36fc:	b4 8d       	ldd	r27, Z+28	; 0x1c
    36fe:	4d 91       	ld	r20, X+
    3700:	5c 91       	ld	r21, X
    3702:	24 17       	cp	r18, r20
    3704:	35 07       	cpc	r19, r21
    3706:	e9 f3       	breq	.-6      	; 0x3702 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3708:	a7 89       	ldd	r26, Z+23	; 0x17
    370a:	b0 8d       	ldd	r27, Z+24	; 0x18
    370c:	0d 90       	ld	r0, X+
    370e:	bc 91       	ld	r27, X
    3710:	a0 2d       	mov	r26, r0
    3712:	a2 0f       	add	r26, r18
    3714:	b3 1f       	adc	r27, r19
    3716:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3718:	2f 5f       	subi	r18, 0xFF	; 255
    371a:	3f 4f       	sbci	r19, 0xFF	; 255
    371c:	28 83       	st	Y, r18
    371e:	39 83       	std	Y+1, r19	; 0x01
    3720:	24 36       	cpi	r18, 0x64	; 100
    3722:	31 05       	cpc	r19, r1
    3724:	28 f0       	brcs	.+10     	; 0x3730 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3726:	01 8c       	ldd	r0, Z+25	; 0x19
    3728:	f2 8d       	ldd	r31, Z+26	; 0x1a
    372a:	e0 2d       	mov	r30, r0
    372c:	10 82       	st	Z, r1
    372e:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3730:	90 e0       	ldi	r25, 0x00	; 0
    3732:	df 91       	pop	r29
    3734:	cf 91       	pop	r28
    3736:	08 95       	ret

00003738 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3738:	cf 93       	push	r28
    373a:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    373c:	ec 01       	movw	r28, r24
    373e:	a9 8d       	ldd	r26, Y+25	; 0x19
    3740:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3742:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3744:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3746:	81 e0       	ldi	r24, 0x01	; 1
    3748:	4d 91       	ld	r20, X+
    374a:	5c 91       	ld	r21, X
    374c:	20 81       	ld	r18, Z
    374e:	31 81       	ldd	r19, Z+1	; 0x01
    3750:	42 17       	cp	r20, r18
    3752:	53 07       	cpc	r21, r19
    3754:	09 f4       	brne	.+2      	; 0x3758 <_ZN5rs23214check_for_charEv+0x20>
    3756:	80 e0       	ldi	r24, 0x00	; 0
}
    3758:	df 91       	pop	r29
    375a:	cf 91       	pop	r28
    375c:	08 95       	ret

0000375e <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    375e:	dc 01       	movw	r26, r24
    3760:	ed 91       	ld	r30, X+
    3762:	fc 91       	ld	r31, X
    3764:	02 80       	ldd	r0, Z+2	; 0x02
    3766:	f3 81       	ldd	r31, Z+3	; 0x03
    3768:	e0 2d       	mov	r30, r0
    376a:	6c e0       	ldi	r22, 0x0C	; 12
    376c:	19 95       	eicall
    376e:	08 95       	ret

00003770 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3770:	ef 92       	push	r14
    3772:	ff 92       	push	r15
    3774:	0f 93       	push	r16
    3776:	1f 93       	push	r17
    3778:	cf 93       	push	r28
    377a:	df 93       	push	r29
    377c:	ec 01       	movw	r28, r24
    377e:	7b 01       	movw	r14, r22
    3780:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3782:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamC1Ev>
    3786:	a8 01       	movw	r20, r16
    3788:	b7 01       	movw	r22, r14
    378a:	ce 01       	movw	r24, r28
    378c:	08 96       	adiw	r24, 0x08	; 8
    378e:	0e 94 19 19 	call	0x3232	; 0x3232 <_ZN7base232C1EjP12USART_struct>
    3792:	88 e7       	ldi	r24, 0x78	; 120
    3794:	90 e2       	ldi	r25, 0x20	; 32
    3796:	88 83       	st	Y, r24
    3798:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    379a:	00 3a       	cpi	r16, 0xA0	; 160
    379c:	88 e0       	ldi	r24, 0x08	; 8
    379e:	18 07       	cpc	r17, r24
    37a0:	69 f4       	brne	.+26     	; 0x37bc <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    37a2:	80 e5       	ldi	r24, 0x50	; 80
    37a4:	91 e3       	ldi	r25, 0x31	; 49
    37a6:	8f 8b       	std	Y+23, r24	; 0x17
    37a8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    37aa:	86 e4       	ldi	r24, 0x46	; 70
    37ac:	91 e3       	ldi	r25, 0x31	; 49
    37ae:	89 8f       	std	Y+25, r24	; 0x19
    37b0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    37b2:	8c e3       	ldi	r24, 0x3C	; 60
    37b4:	91 e3       	ldi	r25, 0x31	; 49
    37b6:	8b 8f       	std	Y+27, r24	; 0x1b
    37b8:	9c 8f       	std	Y+28, r25	; 0x1c
    37ba:	42 c0       	rjmp	.+132    	; 0x3840 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    37bc:	00 3b       	cpi	r16, 0xB0	; 176
    37be:	e8 e0       	ldi	r30, 0x08	; 8
    37c0:	1e 07       	cpc	r17, r30
    37c2:	69 f4       	brne	.+26     	; 0x37de <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    37c4:	8e e4       	ldi	r24, 0x4E	; 78
    37c6:	91 e3       	ldi	r25, 0x31	; 49
    37c8:	8f 8b       	std	Y+23, r24	; 0x17
    37ca:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    37cc:	84 e4       	ldi	r24, 0x44	; 68
    37ce:	91 e3       	ldi	r25, 0x31	; 49
    37d0:	89 8f       	std	Y+25, r24	; 0x19
    37d2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    37d4:	8a e3       	ldi	r24, 0x3A	; 58
    37d6:	91 e3       	ldi	r25, 0x31	; 49
    37d8:	8b 8f       	std	Y+27, r24	; 0x1b
    37da:	9c 8f       	std	Y+28, r25	; 0x1c
    37dc:	31 c0       	rjmp	.+98     	; 0x3840 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    37de:	00 3a       	cpi	r16, 0xA0	; 160
    37e0:	f9 e0       	ldi	r31, 0x09	; 9
    37e2:	1f 07       	cpc	r17, r31
    37e4:	69 f4       	brne	.+26     	; 0x3800 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    37e6:	8c e4       	ldi	r24, 0x4C	; 76
    37e8:	91 e3       	ldi	r25, 0x31	; 49
    37ea:	8f 8b       	std	Y+23, r24	; 0x17
    37ec:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    37ee:	82 e4       	ldi	r24, 0x42	; 66
    37f0:	91 e3       	ldi	r25, 0x31	; 49
    37f2:	89 8f       	std	Y+25, r24	; 0x19
    37f4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    37f6:	88 e3       	ldi	r24, 0x38	; 56
    37f8:	91 e3       	ldi	r25, 0x31	; 49
    37fa:	8b 8f       	std	Y+27, r24	; 0x1b
    37fc:	9c 8f       	std	Y+28, r25	; 0x1c
    37fe:	20 c0       	rjmp	.+64     	; 0x3840 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3800:	00 3b       	cpi	r16, 0xB0	; 176
    3802:	89 e0       	ldi	r24, 0x09	; 9
    3804:	18 07       	cpc	r17, r24
    3806:	69 f4       	brne	.+26     	; 0x3822 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3808:	8a e4       	ldi	r24, 0x4A	; 74
    380a:	91 e3       	ldi	r25, 0x31	; 49
    380c:	8f 8b       	std	Y+23, r24	; 0x17
    380e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3810:	80 e4       	ldi	r24, 0x40	; 64
    3812:	91 e3       	ldi	r25, 0x31	; 49
    3814:	89 8f       	std	Y+25, r24	; 0x19
    3816:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3818:	86 e3       	ldi	r24, 0x36	; 54
    381a:	91 e3       	ldi	r25, 0x31	; 49
    381c:	8b 8f       	std	Y+27, r24	; 0x1b
    381e:	9c 8f       	std	Y+28, r25	; 0x1c
    3820:	0f c0       	rjmp	.+30     	; 0x3840 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3822:	00 3a       	cpi	r16, 0xA0	; 160
    3824:	1a 40       	sbci	r17, 0x0A	; 10
    3826:	61 f4       	brne	.+24     	; 0x3840 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3828:	88 e4       	ldi	r24, 0x48	; 72
    382a:	91 e3       	ldi	r25, 0x31	; 49
    382c:	8f 8b       	std	Y+23, r24	; 0x17
    382e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3830:	8e e3       	ldi	r24, 0x3E	; 62
    3832:	91 e3       	ldi	r25, 0x31	; 49
    3834:	89 8f       	std	Y+25, r24	; 0x19
    3836:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3838:	84 e3       	ldi	r24, 0x34	; 52
    383a:	91 e3       	ldi	r25, 0x31	; 49
    383c:	8b 8f       	std	Y+27, r24	; 0x1b
    383e:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3840:	0f 89       	ldd	r16, Y+23	; 0x17
    3842:	18 8d       	ldd	r17, Y+24	; 0x18
    3844:	84 e6       	ldi	r24, 0x64	; 100
    3846:	90 e0       	ldi	r25, 0x00	; 0
    3848:	0e 94 15 19 	call	0x322a	; 0x322a <_Znaj>
    384c:	f8 01       	movw	r30, r16
    384e:	80 83       	st	Z, r24
    3850:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3852:	e9 8d       	ldd	r30, Y+25	; 0x19
    3854:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3856:	10 82       	st	Z, r1
    3858:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    385a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    385c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    385e:	10 82       	st	Z, r1
    3860:	11 82       	std	Z+1, r1	; 0x01
}
    3862:	df 91       	pop	r29
    3864:	cf 91       	pop	r28
    3866:	1f 91       	pop	r17
    3868:	0f 91       	pop	r16
    386a:	ff 90       	pop	r15
    386c:	ef 90       	pop	r14
    386e:	08 95       	ret

00003870 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3870:	1f 92       	push	r1
    3872:	0f 92       	push	r0
    3874:	0f b6       	in	r0, 0x3f	; 63
    3876:	0f 92       	push	r0
    3878:	11 24       	eor	r1, r1
    387a:	08 b6       	in	r0, 0x38	; 56
    387c:	0f 92       	push	r0
    387e:	18 be       	out	0x38, r1	; 56
    3880:	0b b6       	in	r0, 0x3b	; 59
    3882:	0f 92       	push	r0
    3884:	1b be       	out	0x3b, r1	; 59
    3886:	2f 93       	push	r18
    3888:	3f 93       	push	r19
    388a:	8f 93       	push	r24
    388c:	9f 93       	push	r25
    388e:	ef 93       	push	r30
    3890:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3892:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3896:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <rcvC0_buffer>
    389a:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <rcvC0_buffer+0x1>
    389e:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    38a2:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    38a6:	e8 0f       	add	r30, r24
    38a8:	f9 1f       	adc	r31, r25
    38aa:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    38ac:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    38b0:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    38b4:	01 96       	adiw	r24, 0x01	; 1
    38b6:	84 36       	cpi	r24, 0x64	; 100
    38b8:	91 05       	cpc	r25, r1
    38ba:	60 f4       	brcc	.+24     	; 0x38d4 <__vector_25+0x64>
    38bc:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <rcvC0_write_index>
    38c0:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    38c4:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <rcvC0_read_index>
    38c8:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <rcvC0_read_index+0x1>
    38cc:	82 17       	cp	r24, r18
    38ce:	93 07       	cpc	r25, r19
    38d0:	f1 f4       	brne	.+60     	; 0x390e <__vector_25+0x9e>
    38d2:	0c c0       	rjmp	.+24     	; 0x38ec <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    38d4:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rcvC0_write_index>
    38d8:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    38dc:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvC0_read_index>
    38e0:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvC0_read_index+0x1>
    38e4:	18 16       	cp	r1, r24
    38e6:	19 06       	cpc	r1, r25
    38e8:	91 f4       	brne	.+36     	; 0x390e <__vector_25+0x9e>
    38ea:	0e c0       	rjmp	.+28     	; 0x3908 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    38ec:	01 96       	adiw	r24, 0x01	; 1
    38ee:	84 36       	cpi	r24, 0x64	; 100
    38f0:	91 05       	cpc	r25, r1
    38f2:	28 f4       	brcc	.+10     	; 0x38fe <__vector_25+0x8e>
    38f4:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvC0_read_index>
    38f8:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvC0_read_index+0x1>
    38fc:	08 c0       	rjmp	.+16     	; 0x390e <__vector_25+0x9e>
			rcvC0_read_index = 0;
    38fe:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvC0_read_index>
    3902:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvC0_read_index+0x1>
}
    3906:	03 c0       	rjmp	.+6      	; 0x390e <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3908:	81 e0       	ldi	r24, 0x01	; 1
    390a:	90 e0       	ldi	r25, 0x00	; 0
    390c:	f3 cf       	rjmp	.-26     	; 0x38f4 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    390e:	ff 91       	pop	r31
    3910:	ef 91       	pop	r30
    3912:	9f 91       	pop	r25
    3914:	8f 91       	pop	r24
    3916:	3f 91       	pop	r19
    3918:	2f 91       	pop	r18
    391a:	0f 90       	pop	r0
    391c:	0b be       	out	0x3b, r0	; 59
    391e:	0f 90       	pop	r0
    3920:	08 be       	out	0x38, r0	; 56
    3922:	0f 90       	pop	r0
    3924:	0f be       	out	0x3f, r0	; 63
    3926:	0f 90       	pop	r0
    3928:	1f 90       	pop	r1
    392a:	18 95       	reti

0000392c <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    392c:	1f 92       	push	r1
    392e:	0f 92       	push	r0
    3930:	0f b6       	in	r0, 0x3f	; 63
    3932:	0f 92       	push	r0
    3934:	11 24       	eor	r1, r1
    3936:	08 b6       	in	r0, 0x38	; 56
    3938:	0f 92       	push	r0
    393a:	18 be       	out	0x38, r1	; 56
    393c:	0b b6       	in	r0, 0x3b	; 59
    393e:	0f 92       	push	r0
    3940:	1b be       	out	0x3b, r1	; 59
    3942:	2f 93       	push	r18
    3944:	3f 93       	push	r19
    3946:	8f 93       	push	r24
    3948:	9f 93       	push	r25
    394a:	ef 93       	push	r30
    394c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    394e:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3952:	e0 91 4e 31 	lds	r30, 0x314E	; 0x80314e <rcvC1_buffer>
    3956:	f0 91 4f 31 	lds	r31, 0x314F	; 0x80314f <rcvC1_buffer+0x1>
    395a:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC1_write_index>
    395e:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC1_write_index+0x1>
    3962:	e8 0f       	add	r30, r24
    3964:	f9 1f       	adc	r31, r25
    3966:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3968:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC1_write_index>
    396c:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC1_write_index+0x1>
    3970:	01 96       	adiw	r24, 0x01	; 1
    3972:	84 36       	cpi	r24, 0x64	; 100
    3974:	91 05       	cpc	r25, r1
    3976:	60 f4       	brcc	.+24     	; 0x3990 <__vector_28+0x64>
    3978:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC1_write_index>
    397c:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3980:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <rcvC1_read_index>
    3984:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <rcvC1_read_index+0x1>
    3988:	82 17       	cp	r24, r18
    398a:	93 07       	cpc	r25, r19
    398c:	f1 f4       	brne	.+60     	; 0x39ca <__vector_28+0x9e>
    398e:	0c c0       	rjmp	.+24     	; 0x39a8 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3990:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC1_write_index>
    3994:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3998:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <rcvC1_read_index>
    399c:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <rcvC1_read_index+0x1>
    39a0:	18 16       	cp	r1, r24
    39a2:	19 06       	cpc	r1, r25
    39a4:	91 f4       	brne	.+36     	; 0x39ca <__vector_28+0x9e>
    39a6:	0e c0       	rjmp	.+28     	; 0x39c4 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    39a8:	01 96       	adiw	r24, 0x01	; 1
    39aa:	84 36       	cpi	r24, 0x64	; 100
    39ac:	91 05       	cpc	r25, r1
    39ae:	28 f4       	brcc	.+10     	; 0x39ba <__vector_28+0x8e>
    39b0:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <rcvC1_read_index>
    39b4:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <rcvC1_read_index+0x1>
    39b8:	08 c0       	rjmp	.+16     	; 0x39ca <__vector_28+0x9e>
	rcvC1_read_index = 0;
    39ba:	10 92 44 31 	sts	0x3144, r1	; 0x803144 <rcvC1_read_index>
    39be:	10 92 45 31 	sts	0x3145, r1	; 0x803145 <rcvC1_read_index+0x1>
}
    39c2:	03 c0       	rjmp	.+6      	; 0x39ca <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    39c4:	81 e0       	ldi	r24, 0x01	; 1
    39c6:	90 e0       	ldi	r25, 0x00	; 0
    39c8:	f3 cf       	rjmp	.-26     	; 0x39b0 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    39ca:	ff 91       	pop	r31
    39cc:	ef 91       	pop	r30
    39ce:	9f 91       	pop	r25
    39d0:	8f 91       	pop	r24
    39d2:	3f 91       	pop	r19
    39d4:	2f 91       	pop	r18
    39d6:	0f 90       	pop	r0
    39d8:	0b be       	out	0x3b, r0	; 59
    39da:	0f 90       	pop	r0
    39dc:	08 be       	out	0x38, r0	; 56
    39de:	0f 90       	pop	r0
    39e0:	0f be       	out	0x3f, r0	; 63
    39e2:	0f 90       	pop	r0
    39e4:	1f 90       	pop	r1
    39e6:	18 95       	reti

000039e8 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    39e8:	1f 92       	push	r1
    39ea:	0f 92       	push	r0
    39ec:	0f b6       	in	r0, 0x3f	; 63
    39ee:	0f 92       	push	r0
    39f0:	11 24       	eor	r1, r1
    39f2:	08 b6       	in	r0, 0x38	; 56
    39f4:	0f 92       	push	r0
    39f6:	18 be       	out	0x38, r1	; 56
    39f8:	0b b6       	in	r0, 0x3b	; 59
    39fa:	0f 92       	push	r0
    39fc:	1b be       	out	0x3b, r1	; 59
    39fe:	2f 93       	push	r18
    3a00:	3f 93       	push	r19
    3a02:	8f 93       	push	r24
    3a04:	9f 93       	push	r25
    3a06:	ef 93       	push	r30
    3a08:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3a0a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3a0e:	e0 91 4c 31 	lds	r30, 0x314C	; 0x80314c <rcvD0_buffer>
    3a12:	f0 91 4d 31 	lds	r31, 0x314D	; 0x80314d <rcvD0_buffer+0x1>
    3a16:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    3a1a:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    3a1e:	e8 0f       	add	r30, r24
    3a20:	f9 1f       	adc	r31, r25
    3a22:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3a24:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvD0_write_index>
    3a28:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvD0_write_index+0x1>
    3a2c:	01 96       	adiw	r24, 0x01	; 1
    3a2e:	84 36       	cpi	r24, 0x64	; 100
    3a30:	91 05       	cpc	r25, r1
    3a32:	60 f4       	brcc	.+24     	; 0x3a4c <__vector_88+0x64>
    3a34:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvD0_write_index>
    3a38:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a3c:	20 91 42 31 	lds	r18, 0x3142	; 0x803142 <rcvD0_read_index>
    3a40:	30 91 43 31 	lds	r19, 0x3143	; 0x803143 <rcvD0_read_index+0x1>
    3a44:	82 17       	cp	r24, r18
    3a46:	93 07       	cpc	r25, r19
    3a48:	f1 f4       	brne	.+60     	; 0x3a86 <__vector_88+0x9e>
    3a4a:	0c c0       	rjmp	.+24     	; 0x3a64 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3a4c:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvD0_write_index>
    3a50:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a54:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvD0_read_index>
    3a58:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvD0_read_index+0x1>
    3a5c:	18 16       	cp	r1, r24
    3a5e:	19 06       	cpc	r1, r25
    3a60:	91 f4       	brne	.+36     	; 0x3a86 <__vector_88+0x9e>
    3a62:	0e c0       	rjmp	.+28     	; 0x3a80 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a64:	01 96       	adiw	r24, 0x01	; 1
    3a66:	84 36       	cpi	r24, 0x64	; 100
    3a68:	91 05       	cpc	r25, r1
    3a6a:	28 f4       	brcc	.+10     	; 0x3a76 <__vector_88+0x8e>
    3a6c:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <rcvD0_read_index>
    3a70:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <rcvD0_read_index+0x1>
    3a74:	08 c0       	rjmp	.+16     	; 0x3a86 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3a76:	10 92 42 31 	sts	0x3142, r1	; 0x803142 <rcvD0_read_index>
    3a7a:	10 92 43 31 	sts	0x3143, r1	; 0x803143 <rcvD0_read_index+0x1>
}
    3a7e:	03 c0       	rjmp	.+6      	; 0x3a86 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a80:	81 e0       	ldi	r24, 0x01	; 1
    3a82:	90 e0       	ldi	r25, 0x00	; 0
    3a84:	f3 cf       	rjmp	.-26     	; 0x3a6c <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3a86:	ff 91       	pop	r31
    3a88:	ef 91       	pop	r30
    3a8a:	9f 91       	pop	r25
    3a8c:	8f 91       	pop	r24
    3a8e:	3f 91       	pop	r19
    3a90:	2f 91       	pop	r18
    3a92:	0f 90       	pop	r0
    3a94:	0b be       	out	0x3b, r0	; 59
    3a96:	0f 90       	pop	r0
    3a98:	08 be       	out	0x38, r0	; 56
    3a9a:	0f 90       	pop	r0
    3a9c:	0f be       	out	0x3f, r0	; 63
    3a9e:	0f 90       	pop	r0
    3aa0:	1f 90       	pop	r1
    3aa2:	18 95       	reti

00003aa4 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3aa4:	1f 92       	push	r1
    3aa6:	0f 92       	push	r0
    3aa8:	0f b6       	in	r0, 0x3f	; 63
    3aaa:	0f 92       	push	r0
    3aac:	11 24       	eor	r1, r1
    3aae:	08 b6       	in	r0, 0x38	; 56
    3ab0:	0f 92       	push	r0
    3ab2:	18 be       	out	0x38, r1	; 56
    3ab4:	0b b6       	in	r0, 0x3b	; 59
    3ab6:	0f 92       	push	r0
    3ab8:	1b be       	out	0x3b, r1	; 59
    3aba:	2f 93       	push	r18
    3abc:	3f 93       	push	r19
    3abe:	8f 93       	push	r24
    3ac0:	9f 93       	push	r25
    3ac2:	ef 93       	push	r30
    3ac4:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3ac6:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3aca:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <rcvD1_buffer>
    3ace:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <rcvD1_buffer+0x1>
    3ad2:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD1_write_index>
    3ad6:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD1_write_index+0x1>
    3ada:	e8 0f       	add	r30, r24
    3adc:	f9 1f       	adc	r31, r25
    3ade:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3ae0:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD1_write_index>
    3ae4:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD1_write_index+0x1>
    3ae8:	01 96       	adiw	r24, 0x01	; 1
    3aea:	84 36       	cpi	r24, 0x64	; 100
    3aec:	91 05       	cpc	r25, r1
    3aee:	60 f4       	brcc	.+24     	; 0x3b08 <__vector_91+0x64>
    3af0:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD1_write_index>
    3af4:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3af8:	20 91 40 31 	lds	r18, 0x3140	; 0x803140 <rcvD1_read_index>
    3afc:	30 91 41 31 	lds	r19, 0x3141	; 0x803141 <rcvD1_read_index+0x1>
    3b00:	82 17       	cp	r24, r18
    3b02:	93 07       	cpc	r25, r19
    3b04:	f1 f4       	brne	.+60     	; 0x3b42 <__vector_91+0x9e>
    3b06:	0c c0       	rjmp	.+24     	; 0x3b20 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3b08:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD1_write_index>
    3b0c:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b10:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvD1_read_index>
    3b14:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvD1_read_index+0x1>
    3b18:	18 16       	cp	r1, r24
    3b1a:	19 06       	cpc	r1, r25
    3b1c:	91 f4       	brne	.+36     	; 0x3b42 <__vector_91+0x9e>
    3b1e:	0e c0       	rjmp	.+28     	; 0x3b3c <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b20:	01 96       	adiw	r24, 0x01	; 1
    3b22:	84 36       	cpi	r24, 0x64	; 100
    3b24:	91 05       	cpc	r25, r1
    3b26:	28 f4       	brcc	.+10     	; 0x3b32 <__vector_91+0x8e>
    3b28:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <rcvD1_read_index>
    3b2c:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <rcvD1_read_index+0x1>
    3b30:	08 c0       	rjmp	.+16     	; 0x3b42 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3b32:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rcvD1_read_index>
    3b36:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <rcvD1_read_index+0x1>
}
    3b3a:	03 c0       	rjmp	.+6      	; 0x3b42 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b3c:	81 e0       	ldi	r24, 0x01	; 1
    3b3e:	90 e0       	ldi	r25, 0x00	; 0
    3b40:	f3 cf       	rjmp	.-26     	; 0x3b28 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3b42:	ff 91       	pop	r31
    3b44:	ef 91       	pop	r30
    3b46:	9f 91       	pop	r25
    3b48:	8f 91       	pop	r24
    3b4a:	3f 91       	pop	r19
    3b4c:	2f 91       	pop	r18
    3b4e:	0f 90       	pop	r0
    3b50:	0b be       	out	0x3b, r0	; 59
    3b52:	0f 90       	pop	r0
    3b54:	08 be       	out	0x38, r0	; 56
    3b56:	0f 90       	pop	r0
    3b58:	0f be       	out	0x3f, r0	; 63
    3b5a:	0f 90       	pop	r0
    3b5c:	1f 90       	pop	r1
    3b5e:	18 95       	reti

00003b60 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3b60:	1f 92       	push	r1
    3b62:	0f 92       	push	r0
    3b64:	0f b6       	in	r0, 0x3f	; 63
    3b66:	0f 92       	push	r0
    3b68:	11 24       	eor	r1, r1
    3b6a:	08 b6       	in	r0, 0x38	; 56
    3b6c:	0f 92       	push	r0
    3b6e:	18 be       	out	0x38, r1	; 56
    3b70:	0b b6       	in	r0, 0x3b	; 59
    3b72:	0f 92       	push	r0
    3b74:	1b be       	out	0x3b, r1	; 59
    3b76:	2f 93       	push	r18
    3b78:	3f 93       	push	r19
    3b7a:	8f 93       	push	r24
    3b7c:	9f 93       	push	r25
    3b7e:	ef 93       	push	r30
    3b80:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3b82:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3b86:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <rcvE0_buffer>
    3b8a:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <rcvE0_buffer+0x1>
    3b8e:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvE0_write_index>
    3b92:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvE0_write_index+0x1>
    3b96:	e8 0f       	add	r30, r24
    3b98:	f9 1f       	adc	r31, r25
    3b9a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3b9c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvE0_write_index>
    3ba0:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvE0_write_index+0x1>
    3ba4:	01 96       	adiw	r24, 0x01	; 1
    3ba6:	84 36       	cpi	r24, 0x64	; 100
    3ba8:	91 05       	cpc	r25, r1
    3baa:	60 f4       	brcc	.+24     	; 0x3bc4 <__vector_58+0x64>
    3bac:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvE0_write_index>
    3bb0:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3bb4:	20 91 3e 31 	lds	r18, 0x313E	; 0x80313e <rcvE0_read_index>
    3bb8:	30 91 3f 31 	lds	r19, 0x313F	; 0x80313f <rcvE0_read_index+0x1>
    3bbc:	82 17       	cp	r24, r18
    3bbe:	93 07       	cpc	r25, r19
    3bc0:	f1 f4       	brne	.+60     	; 0x3bfe <__vector_58+0x9e>
    3bc2:	0c c0       	rjmp	.+24     	; 0x3bdc <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3bc4:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvE0_write_index>
    3bc8:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3bcc:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvE0_read_index>
    3bd0:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvE0_read_index+0x1>
    3bd4:	18 16       	cp	r1, r24
    3bd6:	19 06       	cpc	r1, r25
    3bd8:	91 f4       	brne	.+36     	; 0x3bfe <__vector_58+0x9e>
    3bda:	0e c0       	rjmp	.+28     	; 0x3bf8 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3bdc:	01 96       	adiw	r24, 0x01	; 1
    3bde:	84 36       	cpi	r24, 0x64	; 100
    3be0:	91 05       	cpc	r25, r1
    3be2:	28 f4       	brcc	.+10     	; 0x3bee <__vector_58+0x8e>
    3be4:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <rcvE0_read_index>
    3be8:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <rcvE0_read_index+0x1>
    3bec:	08 c0       	rjmp	.+16     	; 0x3bfe <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3bee:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <rcvE0_read_index>
    3bf2:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <rcvE0_read_index+0x1>
}
    3bf6:	03 c0       	rjmp	.+6      	; 0x3bfe <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3bf8:	81 e0       	ldi	r24, 0x01	; 1
    3bfa:	90 e0       	ldi	r25, 0x00	; 0
    3bfc:	f3 cf       	rjmp	.-26     	; 0x3be4 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3bfe:	ff 91       	pop	r31
    3c00:	ef 91       	pop	r30
    3c02:	9f 91       	pop	r25
    3c04:	8f 91       	pop	r24
    3c06:	3f 91       	pop	r19
    3c08:	2f 91       	pop	r18
    3c0a:	0f 90       	pop	r0
    3c0c:	0b be       	out	0x3b, r0	; 59
    3c0e:	0f 90       	pop	r0
    3c10:	08 be       	out	0x38, r0	; 56
    3c12:	0f 90       	pop	r0
    3c14:	0f be       	out	0x3f, r0	; 63
    3c16:	0f 90       	pop	r0
    3c18:	1f 90       	pop	r1
    3c1a:	18 95       	reti

00003c1c <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3c1c:	0f 93       	push	r16
    3c1e:	cf 93       	push	r28
    3c20:	df 93       	push	r29
    3c22:	1f 92       	push	r1
    3c24:	cd b7       	in	r28, 0x3d	; 61
    3c26:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3c28:	2f b7       	in	r18, 0x3f	; 63
    3c2a:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3c2c:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3c2e:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3c30:	fc 01       	movw	r30, r24
    3c32:	08 ed       	ldi	r16, 0xD8	; 216
    3c34:	04 bf       	out	0x34, r16	; 52
    3c36:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3c38:	89 81       	ldd	r24, Y+1	; 0x01
    3c3a:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3c3c:	0f 90       	pop	r0
    3c3e:	df 91       	pop	r29
    3c40:	cf 91       	pop	r28
    3c42:	0f 91       	pop	r16
    3c44:	08 95       	ret

00003c46 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3c46:	0f 93       	push	r16
    3c48:	1f 93       	push	r17
    3c4a:	cf 93       	push	r28
    3c4c:	df 93       	push	r29
    3c4e:	cd b7       	in	r28, 0x3d	; 61
    3c50:	de b7       	in	r29, 0x3e	; 62
    3c52:	6d 97       	sbiw	r28, 0x1d	; 29
    3c54:	cd bf       	out	0x3d, r28	; 61
    3c56:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN4_bm;									// set pin D4 as output LED1: turns on when power is on.
    3c58:	e0 e6       	ldi	r30, 0x60	; 96
    3c5a:	f6 e0       	ldi	r31, 0x06	; 6
    3c5c:	80 e1       	ldi	r24, 0x10	; 16
    3c5e:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN5_bm;									// set pin D5 as output LED2
    3c60:	90 e2       	ldi	r25, 0x20	; 32
    3c62:	91 83       	std	Z+1, r25	; 0x01
	PORTD.DIRSET = PIN6_bm;									// set pin D6 as output LED3
    3c64:	90 e4       	ldi	r25, 0x40	; 64
    3c66:	91 83       	std	Z+1, r25	; 0x01
	
	PORTD.OUTSET = PIN4_bm;									// set pin high, LED 1
    3c68:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN6_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3c6a:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3c6c:	e0 e5       	ldi	r30, 0x50	; 80
    3c6e:	f0 e0       	ldi	r31, 0x00	; 0
    3c70:	80 81       	ld	r24, Z
    3c72:	82 60       	ori	r24, 0x02	; 2
    3c74:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3c76:	81 81       	ldd	r24, Z+1	; 0x01
    3c78:	81 ff       	sbrs	r24, 1
    3c7a:	fd cf       	rjmp	.-6      	; 0x3c76 <main+0x30>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3c7c:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3c80:	68 7f       	andi	r22, 0xF8	; 248
    3c82:	61 60       	ori	r22, 0x01	; 1
    3c84:	80 e4       	ldi	r24, 0x40	; 64
    3c86:	90 e0       	ldi	r25, 0x00	; 0
    3c88:	0e 94 0e 1e 	call	0x3c1c	; 0x3c1c <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3c8c:	e0 e5       	ldi	r30, 0x50	; 80
    3c8e:	f0 e0       	ldi	r31, 0x00	; 0
    3c90:	80 81       	ld	r24, Z
    3c92:	8e 7f       	andi	r24, 0xFE	; 254
    3c94:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3c96:	9d ef       	ldi	r25, 0xFD	; 253
    3c98:	88 ed       	ldi	r24, 0xD8	; 216
    3c9a:	08 b6       	in	r0, 0x38	; 56
    3c9c:	18 be       	out	0x38, r1	; 56
    3c9e:	84 bf       	out	0x34, r24	; 52
    3ca0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3ca4:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3ca6:	40 eb       	ldi	r20, 0xB0	; 176
    3ca8:	58 e0       	ldi	r21, 0x08	; 8
    3caa:	60 e0       	ldi	r22, 0x00	; 0
    3cac:	70 e0       	ldi	r23, 0x00	; 0
    3cae:	ce 01       	movw	r24, r28
    3cb0:	01 96       	adiw	r24, 0x01	; 1
    3cb2:	0e 94 b8 1b 	call	0x3770	; 0x3770 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3cb6:	67 e0       	ldi	r22, 0x07	; 7
    3cb8:	ce 01       	movw	r24, r28
    3cba:	01 96       	adiw	r24, 0x01	; 1
    3cbc:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    3cc0:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3cc2:	64 e8       	ldi	r22, 0x84	; 132
    3cc4:	70 e2       	ldi	r23, 0x20	; 32
    3cc6:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstream4putsEPKc>
    3cca:	66 e0       	ldi	r22, 0x06	; 6
    3ccc:	c8 01       	movw	r24, r16
    3cce:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
    3cd2:	66 e0       	ldi	r22, 0x06	; 6
    3cd4:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3cd8:	82 e1       	ldi	r24, 0x12	; 18
    3cda:	90 e0       	ldi	r25, 0x00	; 0
    3cdc:	0e 94 0d 19 	call	0x321a	; 0x321a <_Znwj>
    3ce0:	8e 01       	movw	r16, r28
    3ce2:	0f 5f       	subi	r16, 0xFF	; 255
    3ce4:	1f 4f       	sbci	r17, 0xFF	; 255
    3ce6:	24 e0       	ldi	r18, 0x04	; 4
    3ce8:	31 e0       	ldi	r19, 0x01	; 1
    3cea:	40 e0       	ldi	r20, 0x00	; 0
    3cec:	63 ea       	ldi	r22, 0xA3	; 163
    3cee:	70 e2       	ldi	r23, 0x20	; 32
    3cf0:	0e 94 ce 06 	call	0xd9c	; 0xd9c <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3cf4:	82 e1       	ldi	r24, 0x12	; 18
    3cf6:	90 e0       	ldi	r25, 0x00	; 0
    3cf8:	0e 94 0d 19 	call	0x321a	; 0x321a <_Znwj>
    3cfc:	24 e0       	ldi	r18, 0x04	; 4
    3cfe:	31 e0       	ldi	r19, 0x01	; 1
    3d00:	42 e0       	ldi	r20, 0x02	; 2
    3d02:	6b ea       	ldi	r22, 0xAB	; 171
    3d04:	70 e2       	ldi	r23, 0x20	; 32
    3d06:	0e 94 80 03 	call	0x700	; 0x700 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3d0a:	82 e1       	ldi	r24, 0x12	; 18
    3d0c:	90 e0       	ldi	r25, 0x00	; 0
    3d0e:	0e 94 0d 19 	call	0x321a	; 0x321a <_Znwj>
    3d12:	24 e0       	ldi	r18, 0x04	; 4
    3d14:	31 e0       	ldi	r19, 0x01	; 1
    3d16:	43 e0       	ldi	r20, 0x03	; 3
    3d18:	62 eb       	ldi	r22, 0xB2	; 178
    3d1a:	70 e2       	ldi	r23, 0x20	; 32
    3d1c:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3d20:	82 e1       	ldi	r24, 0x12	; 18
    3d22:	90 e0       	ldi	r25, 0x00	; 0
    3d24:	0e 94 0d 19 	call	0x321a	; 0x321a <_Znwj>
    3d28:	24 e0       	ldi	r18, 0x04	; 4
    3d2a:	31 e0       	ldi	r19, 0x01	; 1
    3d2c:	44 e0       	ldi	r20, 0x04	; 4
    3d2e:	69 eb       	ldi	r22, 0xB9	; 185
    3d30:	70 e2       	ldi	r23, 0x20	; 32
    3d32:	0e 94 58 04 	call	0x8b0	; 0x8b0 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(1), 260, &ser_dev);
    3d36:	82 e4       	ldi	r24, 0x42	; 66
    3d38:	90 e0       	ldi	r25, 0x00	; 0
    3d3a:	0e 94 0d 19 	call	0x321a	; 0x321a <_Znwj>
    3d3e:	24 e0       	ldi	r18, 0x04	; 4
    3d40:	31 e0       	ldi	r19, 0x01	; 1
    3d42:	41 e0       	ldi	r20, 0x01	; 1
    3d44:	62 ec       	ldi	r22, 0xC2	; 194
    3d46:	70 e2       	ldi	r23, 0x20	; 32
    3d48:	0e 94 8d 05 	call	0xb1a	; 0xb1a <_ZN5MotorC1EPKchjP8emstream>

	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3d4c:	87 e0       	ldi	r24, 0x07	; 7
    3d4e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3d52:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3d54:	0e 94 1f 10 	call	0x203e	; 0x203e <vTaskStartScheduler>
	
	
	return 0;
    3d58:	80 e0       	ldi	r24, 0x00	; 0
    3d5a:	90 e0       	ldi	r25, 0x00	; 0
    3d5c:	6d 96       	adiw	r28, 0x1d	; 29
    3d5e:	cd bf       	out	0x3d, r28	; 61
    3d60:	de bf       	out	0x3e, r29	; 62
    3d62:	df 91       	pop	r29
    3d64:	cf 91       	pop	r28
    3d66:	1f 91       	pop	r17
    3d68:	0f 91       	pop	r16
    3d6a:	08 95       	ret

00003d6c <_GLOBAL__sub_I_counter>:
    3d6c:	0f 93       	push	r16
    3d6e:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3d70:	0a e0       	ldi	r16, 0x0A	; 10
    3d72:	10 e0       	ldi	r17, 0x00	; 0
    3d74:	20 e0       	ldi	r18, 0x00	; 0
    3d76:	30 e0       	ldi	r19, 0x00	; 0
    3d78:	40 e0       	ldi	r20, 0x00	; 0
    3d7a:	50 e0       	ldi	r21, 0x00	; 0
    3d7c:	60 e2       	ldi	r22, 0x20	; 32
    3d7e:	70 e0       	ldi	r23, 0x00	; 0
    3d80:	8a e5       	ldi	r24, 0x5A	; 90
    3d82:	91 e3       	ldi	r25, 0x31	; 49
    3d84:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3d88:	1f 91       	pop	r17
    3d8a:	0f 91       	pop	r16
    3d8c:	08 95       	ret

00003d8e <__subsf3>:
    3d8e:	50 58       	subi	r21, 0x80	; 128

00003d90 <__addsf3>:
    3d90:	bb 27       	eor	r27, r27
    3d92:	aa 27       	eor	r26, r26
    3d94:	0e 94 df 1e 	call	0x3dbe	; 0x3dbe <__addsf3x>
    3d98:	0c 94 59 20 	jmp	0x40b2	; 0x40b2 <__fp_round>
    3d9c:	0e 94 4b 20 	call	0x4096	; 0x4096 <__fp_pscA>
    3da0:	38 f0       	brcs	.+14     	; 0x3db0 <__addsf3+0x20>
    3da2:	0e 94 52 20 	call	0x40a4	; 0x40a4 <__fp_pscB>
    3da6:	20 f0       	brcs	.+8      	; 0x3db0 <__addsf3+0x20>
    3da8:	39 f4       	brne	.+14     	; 0x3db8 <__addsf3+0x28>
    3daa:	9f 3f       	cpi	r25, 0xFF	; 255
    3dac:	19 f4       	brne	.+6      	; 0x3db4 <__addsf3+0x24>
    3dae:	26 f4       	brtc	.+8      	; 0x3db8 <__addsf3+0x28>
    3db0:	0c 94 48 20 	jmp	0x4090	; 0x4090 <__fp_nan>
    3db4:	0e f4       	brtc	.+2      	; 0x3db8 <__addsf3+0x28>
    3db6:	e0 95       	com	r30
    3db8:	e7 fb       	bst	r30, 7
    3dba:	0c 94 42 20 	jmp	0x4084	; 0x4084 <__fp_inf>

00003dbe <__addsf3x>:
    3dbe:	e9 2f       	mov	r30, r25
    3dc0:	0e 94 6a 20 	call	0x40d4	; 0x40d4 <__fp_split3>
    3dc4:	58 f3       	brcs	.-42     	; 0x3d9c <__addsf3+0xc>
    3dc6:	ba 17       	cp	r27, r26
    3dc8:	62 07       	cpc	r22, r18
    3dca:	73 07       	cpc	r23, r19
    3dcc:	84 07       	cpc	r24, r20
    3dce:	95 07       	cpc	r25, r21
    3dd0:	20 f0       	brcs	.+8      	; 0x3dda <__addsf3x+0x1c>
    3dd2:	79 f4       	brne	.+30     	; 0x3df2 <__addsf3x+0x34>
    3dd4:	a6 f5       	brtc	.+104    	; 0x3e3e <__addsf3x+0x80>
    3dd6:	0c 94 8c 20 	jmp	0x4118	; 0x4118 <__fp_zero>
    3dda:	0e f4       	brtc	.+2      	; 0x3dde <__addsf3x+0x20>
    3ddc:	e0 95       	com	r30
    3dde:	0b 2e       	mov	r0, r27
    3de0:	ba 2f       	mov	r27, r26
    3de2:	a0 2d       	mov	r26, r0
    3de4:	0b 01       	movw	r0, r22
    3de6:	b9 01       	movw	r22, r18
    3de8:	90 01       	movw	r18, r0
    3dea:	0c 01       	movw	r0, r24
    3dec:	ca 01       	movw	r24, r20
    3dee:	a0 01       	movw	r20, r0
    3df0:	11 24       	eor	r1, r1
    3df2:	ff 27       	eor	r31, r31
    3df4:	59 1b       	sub	r21, r25
    3df6:	99 f0       	breq	.+38     	; 0x3e1e <__addsf3x+0x60>
    3df8:	59 3f       	cpi	r21, 0xF9	; 249
    3dfa:	50 f4       	brcc	.+20     	; 0x3e10 <__addsf3x+0x52>
    3dfc:	50 3e       	cpi	r21, 0xE0	; 224
    3dfe:	68 f1       	brcs	.+90     	; 0x3e5a <__addsf3x+0x9c>
    3e00:	1a 16       	cp	r1, r26
    3e02:	f0 40       	sbci	r31, 0x00	; 0
    3e04:	a2 2f       	mov	r26, r18
    3e06:	23 2f       	mov	r18, r19
    3e08:	34 2f       	mov	r19, r20
    3e0a:	44 27       	eor	r20, r20
    3e0c:	58 5f       	subi	r21, 0xF8	; 248
    3e0e:	f3 cf       	rjmp	.-26     	; 0x3df6 <__addsf3x+0x38>
    3e10:	46 95       	lsr	r20
    3e12:	37 95       	ror	r19
    3e14:	27 95       	ror	r18
    3e16:	a7 95       	ror	r26
    3e18:	f0 40       	sbci	r31, 0x00	; 0
    3e1a:	53 95       	inc	r21
    3e1c:	c9 f7       	brne	.-14     	; 0x3e10 <__addsf3x+0x52>
    3e1e:	7e f4       	brtc	.+30     	; 0x3e3e <__addsf3x+0x80>
    3e20:	1f 16       	cp	r1, r31
    3e22:	ba 0b       	sbc	r27, r26
    3e24:	62 0b       	sbc	r22, r18
    3e26:	73 0b       	sbc	r23, r19
    3e28:	84 0b       	sbc	r24, r20
    3e2a:	ba f0       	brmi	.+46     	; 0x3e5a <__addsf3x+0x9c>
    3e2c:	91 50       	subi	r25, 0x01	; 1
    3e2e:	a1 f0       	breq	.+40     	; 0x3e58 <__addsf3x+0x9a>
    3e30:	ff 0f       	add	r31, r31
    3e32:	bb 1f       	adc	r27, r27
    3e34:	66 1f       	adc	r22, r22
    3e36:	77 1f       	adc	r23, r23
    3e38:	88 1f       	adc	r24, r24
    3e3a:	c2 f7       	brpl	.-16     	; 0x3e2c <__addsf3x+0x6e>
    3e3c:	0e c0       	rjmp	.+28     	; 0x3e5a <__addsf3x+0x9c>
    3e3e:	ba 0f       	add	r27, r26
    3e40:	62 1f       	adc	r22, r18
    3e42:	73 1f       	adc	r23, r19
    3e44:	84 1f       	adc	r24, r20
    3e46:	48 f4       	brcc	.+18     	; 0x3e5a <__addsf3x+0x9c>
    3e48:	87 95       	ror	r24
    3e4a:	77 95       	ror	r23
    3e4c:	67 95       	ror	r22
    3e4e:	b7 95       	ror	r27
    3e50:	f7 95       	ror	r31
    3e52:	9e 3f       	cpi	r25, 0xFE	; 254
    3e54:	08 f0       	brcs	.+2      	; 0x3e58 <__addsf3x+0x9a>
    3e56:	b0 cf       	rjmp	.-160    	; 0x3db8 <__addsf3+0x28>
    3e58:	93 95       	inc	r25
    3e5a:	88 0f       	add	r24, r24
    3e5c:	08 f0       	brcs	.+2      	; 0x3e60 <__addsf3x+0xa2>
    3e5e:	99 27       	eor	r25, r25
    3e60:	ee 0f       	add	r30, r30
    3e62:	97 95       	ror	r25
    3e64:	87 95       	ror	r24
    3e66:	08 95       	ret

00003e68 <__cmpsf2>:
    3e68:	0e 94 1e 20 	call	0x403c	; 0x403c <__fp_cmp>
    3e6c:	08 f4       	brcc	.+2      	; 0x3e70 <__cmpsf2+0x8>
    3e6e:	81 e0       	ldi	r24, 0x01	; 1
    3e70:	08 95       	ret

00003e72 <__divsf3>:
    3e72:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <__divsf3x>
    3e76:	0c 94 59 20 	jmp	0x40b2	; 0x40b2 <__fp_round>
    3e7a:	0e 94 52 20 	call	0x40a4	; 0x40a4 <__fp_pscB>
    3e7e:	58 f0       	brcs	.+22     	; 0x3e96 <__divsf3+0x24>
    3e80:	0e 94 4b 20 	call	0x4096	; 0x4096 <__fp_pscA>
    3e84:	40 f0       	brcs	.+16     	; 0x3e96 <__divsf3+0x24>
    3e86:	29 f4       	brne	.+10     	; 0x3e92 <__divsf3+0x20>
    3e88:	5f 3f       	cpi	r21, 0xFF	; 255
    3e8a:	29 f0       	breq	.+10     	; 0x3e96 <__divsf3+0x24>
    3e8c:	0c 94 42 20 	jmp	0x4084	; 0x4084 <__fp_inf>
    3e90:	51 11       	cpse	r21, r1
    3e92:	0c 94 8d 20 	jmp	0x411a	; 0x411a <__fp_szero>
    3e96:	0c 94 48 20 	jmp	0x4090	; 0x4090 <__fp_nan>

00003e9a <__divsf3x>:
    3e9a:	0e 94 6a 20 	call	0x40d4	; 0x40d4 <__fp_split3>
    3e9e:	68 f3       	brcs	.-38     	; 0x3e7a <__divsf3+0x8>

00003ea0 <__divsf3_pse>:
    3ea0:	99 23       	and	r25, r25
    3ea2:	b1 f3       	breq	.-20     	; 0x3e90 <__divsf3+0x1e>
    3ea4:	55 23       	and	r21, r21
    3ea6:	91 f3       	breq	.-28     	; 0x3e8c <__divsf3+0x1a>
    3ea8:	95 1b       	sub	r25, r21
    3eaa:	55 0b       	sbc	r21, r21
    3eac:	bb 27       	eor	r27, r27
    3eae:	aa 27       	eor	r26, r26
    3eb0:	62 17       	cp	r22, r18
    3eb2:	73 07       	cpc	r23, r19
    3eb4:	84 07       	cpc	r24, r20
    3eb6:	38 f0       	brcs	.+14     	; 0x3ec6 <__divsf3_pse+0x26>
    3eb8:	9f 5f       	subi	r25, 0xFF	; 255
    3eba:	5f 4f       	sbci	r21, 0xFF	; 255
    3ebc:	22 0f       	add	r18, r18
    3ebe:	33 1f       	adc	r19, r19
    3ec0:	44 1f       	adc	r20, r20
    3ec2:	aa 1f       	adc	r26, r26
    3ec4:	a9 f3       	breq	.-22     	; 0x3eb0 <__divsf3_pse+0x10>
    3ec6:	35 d0       	rcall	.+106    	; 0x3f32 <__divsf3_pse+0x92>
    3ec8:	0e 2e       	mov	r0, r30
    3eca:	3a f0       	brmi	.+14     	; 0x3eda <__divsf3_pse+0x3a>
    3ecc:	e0 e8       	ldi	r30, 0x80	; 128
    3ece:	32 d0       	rcall	.+100    	; 0x3f34 <__divsf3_pse+0x94>
    3ed0:	91 50       	subi	r25, 0x01	; 1
    3ed2:	50 40       	sbci	r21, 0x00	; 0
    3ed4:	e6 95       	lsr	r30
    3ed6:	00 1c       	adc	r0, r0
    3ed8:	ca f7       	brpl	.-14     	; 0x3ecc <__divsf3_pse+0x2c>
    3eda:	2b d0       	rcall	.+86     	; 0x3f32 <__divsf3_pse+0x92>
    3edc:	fe 2f       	mov	r31, r30
    3ede:	29 d0       	rcall	.+82     	; 0x3f32 <__divsf3_pse+0x92>
    3ee0:	66 0f       	add	r22, r22
    3ee2:	77 1f       	adc	r23, r23
    3ee4:	88 1f       	adc	r24, r24
    3ee6:	bb 1f       	adc	r27, r27
    3ee8:	26 17       	cp	r18, r22
    3eea:	37 07       	cpc	r19, r23
    3eec:	48 07       	cpc	r20, r24
    3eee:	ab 07       	cpc	r26, r27
    3ef0:	b0 e8       	ldi	r27, 0x80	; 128
    3ef2:	09 f0       	breq	.+2      	; 0x3ef6 <__divsf3_pse+0x56>
    3ef4:	bb 0b       	sbc	r27, r27
    3ef6:	80 2d       	mov	r24, r0
    3ef8:	bf 01       	movw	r22, r30
    3efa:	ff 27       	eor	r31, r31
    3efc:	93 58       	subi	r25, 0x83	; 131
    3efe:	5f 4f       	sbci	r21, 0xFF	; 255
    3f00:	3a f0       	brmi	.+14     	; 0x3f10 <__divsf3_pse+0x70>
    3f02:	9e 3f       	cpi	r25, 0xFE	; 254
    3f04:	51 05       	cpc	r21, r1
    3f06:	78 f0       	brcs	.+30     	; 0x3f26 <__divsf3_pse+0x86>
    3f08:	0c 94 42 20 	jmp	0x4084	; 0x4084 <__fp_inf>
    3f0c:	0c 94 8d 20 	jmp	0x411a	; 0x411a <__fp_szero>
    3f10:	5f 3f       	cpi	r21, 0xFF	; 255
    3f12:	e4 f3       	brlt	.-8      	; 0x3f0c <__divsf3_pse+0x6c>
    3f14:	98 3e       	cpi	r25, 0xE8	; 232
    3f16:	d4 f3       	brlt	.-12     	; 0x3f0c <__divsf3_pse+0x6c>
    3f18:	86 95       	lsr	r24
    3f1a:	77 95       	ror	r23
    3f1c:	67 95       	ror	r22
    3f1e:	b7 95       	ror	r27
    3f20:	f7 95       	ror	r31
    3f22:	9f 5f       	subi	r25, 0xFF	; 255
    3f24:	c9 f7       	brne	.-14     	; 0x3f18 <__divsf3_pse+0x78>
    3f26:	88 0f       	add	r24, r24
    3f28:	91 1d       	adc	r25, r1
    3f2a:	96 95       	lsr	r25
    3f2c:	87 95       	ror	r24
    3f2e:	97 f9       	bld	r25, 7
    3f30:	08 95       	ret
    3f32:	e1 e0       	ldi	r30, 0x01	; 1
    3f34:	66 0f       	add	r22, r22
    3f36:	77 1f       	adc	r23, r23
    3f38:	88 1f       	adc	r24, r24
    3f3a:	bb 1f       	adc	r27, r27
    3f3c:	62 17       	cp	r22, r18
    3f3e:	73 07       	cpc	r23, r19
    3f40:	84 07       	cpc	r24, r20
    3f42:	ba 07       	cpc	r27, r26
    3f44:	20 f0       	brcs	.+8      	; 0x3f4e <__divsf3_pse+0xae>
    3f46:	62 1b       	sub	r22, r18
    3f48:	73 0b       	sbc	r23, r19
    3f4a:	84 0b       	sbc	r24, r20
    3f4c:	ba 0b       	sbc	r27, r26
    3f4e:	ee 1f       	adc	r30, r30
    3f50:	88 f7       	brcc	.-30     	; 0x3f34 <__divsf3_pse+0x94>
    3f52:	e0 95       	com	r30
    3f54:	08 95       	ret

00003f56 <__fixsfsi>:
    3f56:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <__fixunssfsi>
    3f5a:	68 94       	set
    3f5c:	b1 11       	cpse	r27, r1
    3f5e:	0c 94 8d 20 	jmp	0x411a	; 0x411a <__fp_szero>
    3f62:	08 95       	ret

00003f64 <__fixunssfsi>:
    3f64:	0e 94 72 20 	call	0x40e4	; 0x40e4 <__fp_splitA>
    3f68:	88 f0       	brcs	.+34     	; 0x3f8c <__fixunssfsi+0x28>
    3f6a:	9f 57       	subi	r25, 0x7F	; 127
    3f6c:	98 f0       	brcs	.+38     	; 0x3f94 <__fixunssfsi+0x30>
    3f6e:	b9 2f       	mov	r27, r25
    3f70:	99 27       	eor	r25, r25
    3f72:	b7 51       	subi	r27, 0x17	; 23
    3f74:	b0 f0       	brcs	.+44     	; 0x3fa2 <__fixunssfsi+0x3e>
    3f76:	e1 f0       	breq	.+56     	; 0x3fb0 <__fixunssfsi+0x4c>
    3f78:	66 0f       	add	r22, r22
    3f7a:	77 1f       	adc	r23, r23
    3f7c:	88 1f       	adc	r24, r24
    3f7e:	99 1f       	adc	r25, r25
    3f80:	1a f0       	brmi	.+6      	; 0x3f88 <__fixunssfsi+0x24>
    3f82:	ba 95       	dec	r27
    3f84:	c9 f7       	brne	.-14     	; 0x3f78 <__fixunssfsi+0x14>
    3f86:	14 c0       	rjmp	.+40     	; 0x3fb0 <__fixunssfsi+0x4c>
    3f88:	b1 30       	cpi	r27, 0x01	; 1
    3f8a:	91 f0       	breq	.+36     	; 0x3fb0 <__fixunssfsi+0x4c>
    3f8c:	0e 94 8c 20 	call	0x4118	; 0x4118 <__fp_zero>
    3f90:	b1 e0       	ldi	r27, 0x01	; 1
    3f92:	08 95       	ret
    3f94:	0c 94 8c 20 	jmp	0x4118	; 0x4118 <__fp_zero>
    3f98:	67 2f       	mov	r22, r23
    3f9a:	78 2f       	mov	r23, r24
    3f9c:	88 27       	eor	r24, r24
    3f9e:	b8 5f       	subi	r27, 0xF8	; 248
    3fa0:	39 f0       	breq	.+14     	; 0x3fb0 <__fixunssfsi+0x4c>
    3fa2:	b9 3f       	cpi	r27, 0xF9	; 249
    3fa4:	cc f3       	brlt	.-14     	; 0x3f98 <__fixunssfsi+0x34>
    3fa6:	86 95       	lsr	r24
    3fa8:	77 95       	ror	r23
    3faa:	67 95       	ror	r22
    3fac:	b3 95       	inc	r27
    3fae:	d9 f7       	brne	.-10     	; 0x3fa6 <__fixunssfsi+0x42>
    3fb0:	3e f4       	brtc	.+14     	; 0x3fc0 <__fixunssfsi+0x5c>
    3fb2:	90 95       	com	r25
    3fb4:	80 95       	com	r24
    3fb6:	70 95       	com	r23
    3fb8:	61 95       	neg	r22
    3fba:	7f 4f       	sbci	r23, 0xFF	; 255
    3fbc:	8f 4f       	sbci	r24, 0xFF	; 255
    3fbe:	9f 4f       	sbci	r25, 0xFF	; 255
    3fc0:	08 95       	ret

00003fc2 <__floatunsisf>:
    3fc2:	e8 94       	clt
    3fc4:	09 c0       	rjmp	.+18     	; 0x3fd8 <__floatsisf+0x12>

00003fc6 <__floatsisf>:
    3fc6:	97 fb       	bst	r25, 7
    3fc8:	3e f4       	brtc	.+14     	; 0x3fd8 <__floatsisf+0x12>
    3fca:	90 95       	com	r25
    3fcc:	80 95       	com	r24
    3fce:	70 95       	com	r23
    3fd0:	61 95       	neg	r22
    3fd2:	7f 4f       	sbci	r23, 0xFF	; 255
    3fd4:	8f 4f       	sbci	r24, 0xFF	; 255
    3fd6:	9f 4f       	sbci	r25, 0xFF	; 255
    3fd8:	99 23       	and	r25, r25
    3fda:	a9 f0       	breq	.+42     	; 0x4006 <__stack+0x7>
    3fdc:	f9 2f       	mov	r31, r25
    3fde:	96 e9       	ldi	r25, 0x96	; 150
    3fe0:	bb 27       	eor	r27, r27
    3fe2:	93 95       	inc	r25
    3fe4:	f6 95       	lsr	r31
    3fe6:	87 95       	ror	r24
    3fe8:	77 95       	ror	r23
    3fea:	67 95       	ror	r22
    3fec:	b7 95       	ror	r27
    3fee:	f1 11       	cpse	r31, r1
    3ff0:	f8 cf       	rjmp	.-16     	; 0x3fe2 <__floatsisf+0x1c>
    3ff2:	fa f4       	brpl	.+62     	; 0x4032 <__stack+0x33>
    3ff4:	bb 0f       	add	r27, r27
    3ff6:	11 f4       	brne	.+4      	; 0x3ffc <__floatsisf+0x36>
    3ff8:	60 ff       	sbrs	r22, 0
    3ffa:	1b c0       	rjmp	.+54     	; 0x4032 <__stack+0x33>
    3ffc:	6f 5f       	subi	r22, 0xFF	; 255
    3ffe:	7f 4f       	sbci	r23, 0xFF	; 255
    4000:	8f 4f       	sbci	r24, 0xFF	; 255
    4002:	9f 4f       	sbci	r25, 0xFF	; 255
    4004:	16 c0       	rjmp	.+44     	; 0x4032 <__stack+0x33>
    4006:	88 23       	and	r24, r24
    4008:	11 f0       	breq	.+4      	; 0x400e <__stack+0xf>
    400a:	96 e9       	ldi	r25, 0x96	; 150
    400c:	11 c0       	rjmp	.+34     	; 0x4030 <__stack+0x31>
    400e:	77 23       	and	r23, r23
    4010:	21 f0       	breq	.+8      	; 0x401a <__stack+0x1b>
    4012:	9e e8       	ldi	r25, 0x8E	; 142
    4014:	87 2f       	mov	r24, r23
    4016:	76 2f       	mov	r23, r22
    4018:	05 c0       	rjmp	.+10     	; 0x4024 <__stack+0x25>
    401a:	66 23       	and	r22, r22
    401c:	71 f0       	breq	.+28     	; 0x403a <__stack+0x3b>
    401e:	96 e8       	ldi	r25, 0x86	; 134
    4020:	86 2f       	mov	r24, r22
    4022:	70 e0       	ldi	r23, 0x00	; 0
    4024:	60 e0       	ldi	r22, 0x00	; 0
    4026:	2a f0       	brmi	.+10     	; 0x4032 <__stack+0x33>
    4028:	9a 95       	dec	r25
    402a:	66 0f       	add	r22, r22
    402c:	77 1f       	adc	r23, r23
    402e:	88 1f       	adc	r24, r24
    4030:	da f7       	brpl	.-10     	; 0x4028 <__stack+0x29>
    4032:	88 0f       	add	r24, r24
    4034:	96 95       	lsr	r25
    4036:	87 95       	ror	r24
    4038:	97 f9       	bld	r25, 7
    403a:	08 95       	ret

0000403c <__fp_cmp>:
    403c:	99 0f       	add	r25, r25
    403e:	00 08       	sbc	r0, r0
    4040:	55 0f       	add	r21, r21
    4042:	aa 0b       	sbc	r26, r26
    4044:	e0 e8       	ldi	r30, 0x80	; 128
    4046:	fe ef       	ldi	r31, 0xFE	; 254
    4048:	16 16       	cp	r1, r22
    404a:	17 06       	cpc	r1, r23
    404c:	e8 07       	cpc	r30, r24
    404e:	f9 07       	cpc	r31, r25
    4050:	c0 f0       	brcs	.+48     	; 0x4082 <__fp_cmp+0x46>
    4052:	12 16       	cp	r1, r18
    4054:	13 06       	cpc	r1, r19
    4056:	e4 07       	cpc	r30, r20
    4058:	f5 07       	cpc	r31, r21
    405a:	98 f0       	brcs	.+38     	; 0x4082 <__fp_cmp+0x46>
    405c:	62 1b       	sub	r22, r18
    405e:	73 0b       	sbc	r23, r19
    4060:	84 0b       	sbc	r24, r20
    4062:	95 0b       	sbc	r25, r21
    4064:	39 f4       	brne	.+14     	; 0x4074 <__fp_cmp+0x38>
    4066:	0a 26       	eor	r0, r26
    4068:	61 f0       	breq	.+24     	; 0x4082 <__fp_cmp+0x46>
    406a:	23 2b       	or	r18, r19
    406c:	24 2b       	or	r18, r20
    406e:	25 2b       	or	r18, r21
    4070:	21 f4       	brne	.+8      	; 0x407a <__fp_cmp+0x3e>
    4072:	08 95       	ret
    4074:	0a 26       	eor	r0, r26
    4076:	09 f4       	brne	.+2      	; 0x407a <__fp_cmp+0x3e>
    4078:	a1 40       	sbci	r26, 0x01	; 1
    407a:	a6 95       	lsr	r26
    407c:	8f ef       	ldi	r24, 0xFF	; 255
    407e:	81 1d       	adc	r24, r1
    4080:	81 1d       	adc	r24, r1
    4082:	08 95       	ret

00004084 <__fp_inf>:
    4084:	97 f9       	bld	r25, 7
    4086:	9f 67       	ori	r25, 0x7F	; 127
    4088:	80 e8       	ldi	r24, 0x80	; 128
    408a:	70 e0       	ldi	r23, 0x00	; 0
    408c:	60 e0       	ldi	r22, 0x00	; 0
    408e:	08 95       	ret

00004090 <__fp_nan>:
    4090:	9f ef       	ldi	r25, 0xFF	; 255
    4092:	80 ec       	ldi	r24, 0xC0	; 192
    4094:	08 95       	ret

00004096 <__fp_pscA>:
    4096:	00 24       	eor	r0, r0
    4098:	0a 94       	dec	r0
    409a:	16 16       	cp	r1, r22
    409c:	17 06       	cpc	r1, r23
    409e:	18 06       	cpc	r1, r24
    40a0:	09 06       	cpc	r0, r25
    40a2:	08 95       	ret

000040a4 <__fp_pscB>:
    40a4:	00 24       	eor	r0, r0
    40a6:	0a 94       	dec	r0
    40a8:	12 16       	cp	r1, r18
    40aa:	13 06       	cpc	r1, r19
    40ac:	14 06       	cpc	r1, r20
    40ae:	05 06       	cpc	r0, r21
    40b0:	08 95       	ret

000040b2 <__fp_round>:
    40b2:	09 2e       	mov	r0, r25
    40b4:	03 94       	inc	r0
    40b6:	00 0c       	add	r0, r0
    40b8:	11 f4       	brne	.+4      	; 0x40be <__fp_round+0xc>
    40ba:	88 23       	and	r24, r24
    40bc:	52 f0       	brmi	.+20     	; 0x40d2 <__fp_round+0x20>
    40be:	bb 0f       	add	r27, r27
    40c0:	40 f4       	brcc	.+16     	; 0x40d2 <__fp_round+0x20>
    40c2:	bf 2b       	or	r27, r31
    40c4:	11 f4       	brne	.+4      	; 0x40ca <__fp_round+0x18>
    40c6:	60 ff       	sbrs	r22, 0
    40c8:	04 c0       	rjmp	.+8      	; 0x40d2 <__fp_round+0x20>
    40ca:	6f 5f       	subi	r22, 0xFF	; 255
    40cc:	7f 4f       	sbci	r23, 0xFF	; 255
    40ce:	8f 4f       	sbci	r24, 0xFF	; 255
    40d0:	9f 4f       	sbci	r25, 0xFF	; 255
    40d2:	08 95       	ret

000040d4 <__fp_split3>:
    40d4:	57 fd       	sbrc	r21, 7
    40d6:	90 58       	subi	r25, 0x80	; 128
    40d8:	44 0f       	add	r20, r20
    40da:	55 1f       	adc	r21, r21
    40dc:	59 f0       	breq	.+22     	; 0x40f4 <__fp_splitA+0x10>
    40de:	5f 3f       	cpi	r21, 0xFF	; 255
    40e0:	71 f0       	breq	.+28     	; 0x40fe <__fp_splitA+0x1a>
    40e2:	47 95       	ror	r20

000040e4 <__fp_splitA>:
    40e4:	88 0f       	add	r24, r24
    40e6:	97 fb       	bst	r25, 7
    40e8:	99 1f       	adc	r25, r25
    40ea:	61 f0       	breq	.+24     	; 0x4104 <__fp_splitA+0x20>
    40ec:	9f 3f       	cpi	r25, 0xFF	; 255
    40ee:	79 f0       	breq	.+30     	; 0x410e <__fp_splitA+0x2a>
    40f0:	87 95       	ror	r24
    40f2:	08 95       	ret
    40f4:	12 16       	cp	r1, r18
    40f6:	13 06       	cpc	r1, r19
    40f8:	14 06       	cpc	r1, r20
    40fa:	55 1f       	adc	r21, r21
    40fc:	f2 cf       	rjmp	.-28     	; 0x40e2 <__fp_split3+0xe>
    40fe:	46 95       	lsr	r20
    4100:	f1 df       	rcall	.-30     	; 0x40e4 <__fp_splitA>
    4102:	08 c0       	rjmp	.+16     	; 0x4114 <__fp_splitA+0x30>
    4104:	16 16       	cp	r1, r22
    4106:	17 06       	cpc	r1, r23
    4108:	18 06       	cpc	r1, r24
    410a:	99 1f       	adc	r25, r25
    410c:	f1 cf       	rjmp	.-30     	; 0x40f0 <__fp_splitA+0xc>
    410e:	86 95       	lsr	r24
    4110:	71 05       	cpc	r23, r1
    4112:	61 05       	cpc	r22, r1
    4114:	08 94       	sec
    4116:	08 95       	ret

00004118 <__fp_zero>:
    4118:	e8 94       	clt

0000411a <__fp_szero>:
    411a:	bb 27       	eor	r27, r27
    411c:	66 27       	eor	r22, r22
    411e:	77 27       	eor	r23, r23
    4120:	cb 01       	movw	r24, r22
    4122:	97 f9       	bld	r25, 7
    4124:	08 95       	ret

00004126 <__gesf2>:
    4126:	0e 94 1e 20 	call	0x403c	; 0x403c <__fp_cmp>
    412a:	08 f4       	brcc	.+2      	; 0x412e <__gesf2+0x8>
    412c:	8f ef       	ldi	r24, 0xFF	; 255
    412e:	08 95       	ret

00004130 <__mulsf3>:
    4130:	0e 94 ab 20 	call	0x4156	; 0x4156 <__mulsf3x>
    4134:	0c 94 59 20 	jmp	0x40b2	; 0x40b2 <__fp_round>
    4138:	0e 94 4b 20 	call	0x4096	; 0x4096 <__fp_pscA>
    413c:	38 f0       	brcs	.+14     	; 0x414c <__mulsf3+0x1c>
    413e:	0e 94 52 20 	call	0x40a4	; 0x40a4 <__fp_pscB>
    4142:	20 f0       	brcs	.+8      	; 0x414c <__mulsf3+0x1c>
    4144:	95 23       	and	r25, r21
    4146:	11 f0       	breq	.+4      	; 0x414c <__mulsf3+0x1c>
    4148:	0c 94 42 20 	jmp	0x4084	; 0x4084 <__fp_inf>
    414c:	0c 94 48 20 	jmp	0x4090	; 0x4090 <__fp_nan>
    4150:	11 24       	eor	r1, r1
    4152:	0c 94 8d 20 	jmp	0x411a	; 0x411a <__fp_szero>

00004156 <__mulsf3x>:
    4156:	0e 94 6a 20 	call	0x40d4	; 0x40d4 <__fp_split3>
    415a:	70 f3       	brcs	.-36     	; 0x4138 <__mulsf3+0x8>

0000415c <__mulsf3_pse>:
    415c:	95 9f       	mul	r25, r21
    415e:	c1 f3       	breq	.-16     	; 0x4150 <__mulsf3+0x20>
    4160:	95 0f       	add	r25, r21
    4162:	50 e0       	ldi	r21, 0x00	; 0
    4164:	55 1f       	adc	r21, r21
    4166:	62 9f       	mul	r22, r18
    4168:	f0 01       	movw	r30, r0
    416a:	72 9f       	mul	r23, r18
    416c:	bb 27       	eor	r27, r27
    416e:	f0 0d       	add	r31, r0
    4170:	b1 1d       	adc	r27, r1
    4172:	63 9f       	mul	r22, r19
    4174:	aa 27       	eor	r26, r26
    4176:	f0 0d       	add	r31, r0
    4178:	b1 1d       	adc	r27, r1
    417a:	aa 1f       	adc	r26, r26
    417c:	64 9f       	mul	r22, r20
    417e:	66 27       	eor	r22, r22
    4180:	b0 0d       	add	r27, r0
    4182:	a1 1d       	adc	r26, r1
    4184:	66 1f       	adc	r22, r22
    4186:	82 9f       	mul	r24, r18
    4188:	22 27       	eor	r18, r18
    418a:	b0 0d       	add	r27, r0
    418c:	a1 1d       	adc	r26, r1
    418e:	62 1f       	adc	r22, r18
    4190:	73 9f       	mul	r23, r19
    4192:	b0 0d       	add	r27, r0
    4194:	a1 1d       	adc	r26, r1
    4196:	62 1f       	adc	r22, r18
    4198:	83 9f       	mul	r24, r19
    419a:	a0 0d       	add	r26, r0
    419c:	61 1d       	adc	r22, r1
    419e:	22 1f       	adc	r18, r18
    41a0:	74 9f       	mul	r23, r20
    41a2:	33 27       	eor	r19, r19
    41a4:	a0 0d       	add	r26, r0
    41a6:	61 1d       	adc	r22, r1
    41a8:	23 1f       	adc	r18, r19
    41aa:	84 9f       	mul	r24, r20
    41ac:	60 0d       	add	r22, r0
    41ae:	21 1d       	adc	r18, r1
    41b0:	82 2f       	mov	r24, r18
    41b2:	76 2f       	mov	r23, r22
    41b4:	6a 2f       	mov	r22, r26
    41b6:	11 24       	eor	r1, r1
    41b8:	9f 57       	subi	r25, 0x7F	; 127
    41ba:	50 40       	sbci	r21, 0x00	; 0
    41bc:	9a f0       	brmi	.+38     	; 0x41e4 <__mulsf3_pse+0x88>
    41be:	f1 f0       	breq	.+60     	; 0x41fc <__mulsf3_pse+0xa0>
    41c0:	88 23       	and	r24, r24
    41c2:	4a f0       	brmi	.+18     	; 0x41d6 <__mulsf3_pse+0x7a>
    41c4:	ee 0f       	add	r30, r30
    41c6:	ff 1f       	adc	r31, r31
    41c8:	bb 1f       	adc	r27, r27
    41ca:	66 1f       	adc	r22, r22
    41cc:	77 1f       	adc	r23, r23
    41ce:	88 1f       	adc	r24, r24
    41d0:	91 50       	subi	r25, 0x01	; 1
    41d2:	50 40       	sbci	r21, 0x00	; 0
    41d4:	a9 f7       	brne	.-22     	; 0x41c0 <__mulsf3_pse+0x64>
    41d6:	9e 3f       	cpi	r25, 0xFE	; 254
    41d8:	51 05       	cpc	r21, r1
    41da:	80 f0       	brcs	.+32     	; 0x41fc <__mulsf3_pse+0xa0>
    41dc:	0c 94 42 20 	jmp	0x4084	; 0x4084 <__fp_inf>
    41e0:	0c 94 8d 20 	jmp	0x411a	; 0x411a <__fp_szero>
    41e4:	5f 3f       	cpi	r21, 0xFF	; 255
    41e6:	e4 f3       	brlt	.-8      	; 0x41e0 <__mulsf3_pse+0x84>
    41e8:	98 3e       	cpi	r25, 0xE8	; 232
    41ea:	d4 f3       	brlt	.-12     	; 0x41e0 <__mulsf3_pse+0x84>
    41ec:	86 95       	lsr	r24
    41ee:	77 95       	ror	r23
    41f0:	67 95       	ror	r22
    41f2:	b7 95       	ror	r27
    41f4:	f7 95       	ror	r31
    41f6:	e7 95       	ror	r30
    41f8:	9f 5f       	subi	r25, 0xFF	; 255
    41fa:	c1 f7       	brne	.-16     	; 0x41ec <__mulsf3_pse+0x90>
    41fc:	fe 2b       	or	r31, r30
    41fe:	88 0f       	add	r24, r24
    4200:	91 1d       	adc	r25, r1
    4202:	96 95       	lsr	r25
    4204:	87 95       	ror	r24
    4206:	97 f9       	bld	r25, 7
    4208:	08 95       	ret

0000420a <__mulsi3>:
    420a:	db 01       	movw	r26, r22
    420c:	8f 93       	push	r24
    420e:	9f 93       	push	r25
    4210:	0e 94 66 21 	call	0x42cc	; 0x42cc <__muluhisi3>
    4214:	bf 91       	pop	r27
    4216:	af 91       	pop	r26
    4218:	a2 9f       	mul	r26, r18
    421a:	80 0d       	add	r24, r0
    421c:	91 1d       	adc	r25, r1
    421e:	a3 9f       	mul	r26, r19
    4220:	90 0d       	add	r25, r0
    4222:	b2 9f       	mul	r27, r18
    4224:	90 0d       	add	r25, r0
    4226:	11 24       	eor	r1, r1
    4228:	08 95       	ret

0000422a <__udivmodsi4>:
    422a:	a1 e2       	ldi	r26, 0x21	; 33
    422c:	1a 2e       	mov	r1, r26
    422e:	aa 1b       	sub	r26, r26
    4230:	bb 1b       	sub	r27, r27
    4232:	fd 01       	movw	r30, r26
    4234:	0d c0       	rjmp	.+26     	; 0x4250 <__udivmodsi4_ep>

00004236 <__udivmodsi4_loop>:
    4236:	aa 1f       	adc	r26, r26
    4238:	bb 1f       	adc	r27, r27
    423a:	ee 1f       	adc	r30, r30
    423c:	ff 1f       	adc	r31, r31
    423e:	a2 17       	cp	r26, r18
    4240:	b3 07       	cpc	r27, r19
    4242:	e4 07       	cpc	r30, r20
    4244:	f5 07       	cpc	r31, r21
    4246:	20 f0       	brcs	.+8      	; 0x4250 <__udivmodsi4_ep>
    4248:	a2 1b       	sub	r26, r18
    424a:	b3 0b       	sbc	r27, r19
    424c:	e4 0b       	sbc	r30, r20
    424e:	f5 0b       	sbc	r31, r21

00004250 <__udivmodsi4_ep>:
    4250:	66 1f       	adc	r22, r22
    4252:	77 1f       	adc	r23, r23
    4254:	88 1f       	adc	r24, r24
    4256:	99 1f       	adc	r25, r25
    4258:	1a 94       	dec	r1
    425a:	69 f7       	brne	.-38     	; 0x4236 <__udivmodsi4_loop>
    425c:	60 95       	com	r22
    425e:	70 95       	com	r23
    4260:	80 95       	com	r24
    4262:	90 95       	com	r25
    4264:	9b 01       	movw	r18, r22
    4266:	ac 01       	movw	r20, r24
    4268:	bd 01       	movw	r22, r26
    426a:	cf 01       	movw	r24, r30
    426c:	08 95       	ret

0000426e <__divmodsi4>:
    426e:	05 2e       	mov	r0, r21
    4270:	97 fb       	bst	r25, 7
    4272:	1e f4       	brtc	.+6      	; 0x427a <__divmodsi4+0xc>
    4274:	00 94       	com	r0
    4276:	0e 94 4e 21 	call	0x429c	; 0x429c <__negsi2>
    427a:	57 fd       	sbrc	r21, 7
    427c:	07 d0       	rcall	.+14     	; 0x428c <__divmodsi4_neg2>
    427e:	0e 94 15 21 	call	0x422a	; 0x422a <__udivmodsi4>
    4282:	07 fc       	sbrc	r0, 7
    4284:	03 d0       	rcall	.+6      	; 0x428c <__divmodsi4_neg2>
    4286:	4e f4       	brtc	.+18     	; 0x429a <__divmodsi4_exit>
    4288:	0c 94 4e 21 	jmp	0x429c	; 0x429c <__negsi2>

0000428c <__divmodsi4_neg2>:
    428c:	50 95       	com	r21
    428e:	40 95       	com	r20
    4290:	30 95       	com	r19
    4292:	21 95       	neg	r18
    4294:	3f 4f       	sbci	r19, 0xFF	; 255
    4296:	4f 4f       	sbci	r20, 0xFF	; 255
    4298:	5f 4f       	sbci	r21, 0xFF	; 255

0000429a <__divmodsi4_exit>:
    429a:	08 95       	ret

0000429c <__negsi2>:
    429c:	90 95       	com	r25
    429e:	80 95       	com	r24
    42a0:	70 95       	com	r23
    42a2:	61 95       	neg	r22
    42a4:	7f 4f       	sbci	r23, 0xFF	; 255
    42a6:	8f 4f       	sbci	r24, 0xFF	; 255
    42a8:	9f 4f       	sbci	r25, 0xFF	; 255
    42aa:	08 95       	ret

000042ac <__tablejump2__>:
    42ac:	ee 0f       	add	r30, r30
    42ae:	ff 1f       	adc	r31, r31
    42b0:	88 1f       	adc	r24, r24
    42b2:	8b bf       	out	0x3b, r24	; 59
    42b4:	07 90       	elpm	r0, Z+
    42b6:	f6 91       	elpm	r31, Z
    42b8:	e0 2d       	mov	r30, r0
    42ba:	1b be       	out	0x3b, r1	; 59
    42bc:	19 94       	eijmp

000042be <__usmulhisi3>:
    42be:	0e 94 71 21 	call	0x42e2	; 0x42e2 <__umulhisi3>

000042c2 <__usmulhisi3_tail>:
    42c2:	b7 ff       	sbrs	r27, 7
    42c4:	08 95       	ret
    42c6:	82 1b       	sub	r24, r18
    42c8:	93 0b       	sbc	r25, r19
    42ca:	08 95       	ret

000042cc <__muluhisi3>:
    42cc:	0e 94 71 21 	call	0x42e2	; 0x42e2 <__umulhisi3>
    42d0:	a5 9f       	mul	r26, r21
    42d2:	90 0d       	add	r25, r0
    42d4:	b4 9f       	mul	r27, r20
    42d6:	90 0d       	add	r25, r0
    42d8:	a4 9f       	mul	r26, r20
    42da:	80 0d       	add	r24, r0
    42dc:	91 1d       	adc	r25, r1
    42de:	11 24       	eor	r1, r1
    42e0:	08 95       	ret

000042e2 <__umulhisi3>:
    42e2:	a2 9f       	mul	r26, r18
    42e4:	b0 01       	movw	r22, r0
    42e6:	b3 9f       	mul	r27, r19
    42e8:	c0 01       	movw	r24, r0
    42ea:	a3 9f       	mul	r26, r19
    42ec:	70 0d       	add	r23, r0
    42ee:	81 1d       	adc	r24, r1
    42f0:	11 24       	eor	r1, r1
    42f2:	91 1d       	adc	r25, r1
    42f4:	b2 9f       	mul	r27, r18
    42f6:	70 0d       	add	r23, r0
    42f8:	81 1d       	adc	r24, r1
    42fa:	11 24       	eor	r1, r1
    42fc:	91 1d       	adc	r25, r1
    42fe:	08 95       	ret

00004300 <memcpy>:
    4300:	fb 01       	movw	r30, r22
    4302:	dc 01       	movw	r26, r24
    4304:	02 c0       	rjmp	.+4      	; 0x430a <memcpy+0xa>
    4306:	01 90       	ld	r0, Z+
    4308:	0d 92       	st	X+, r0
    430a:	41 50       	subi	r20, 0x01	; 1
    430c:	50 40       	sbci	r21, 0x00	; 0
    430e:	d8 f7       	brcc	.-10     	; 0x4306 <memcpy+0x6>
    4310:	08 95       	ret

00004312 <memset>:
    4312:	dc 01       	movw	r26, r24
    4314:	01 c0       	rjmp	.+2      	; 0x4318 <memset+0x6>
    4316:	6d 93       	st	X+, r22
    4318:	41 50       	subi	r20, 0x01	; 1
    431a:	50 40       	sbci	r21, 0x00	; 0
    431c:	e0 f7       	brcc	.-8      	; 0x4316 <memset+0x4>
    431e:	08 95       	ret

00004320 <strncpy>:
    4320:	fb 01       	movw	r30, r22
    4322:	dc 01       	movw	r26, r24
    4324:	41 50       	subi	r20, 0x01	; 1
    4326:	50 40       	sbci	r21, 0x00	; 0
    4328:	48 f0       	brcs	.+18     	; 0x433c <strncpy+0x1c>
    432a:	01 90       	ld	r0, Z+
    432c:	0d 92       	st	X+, r0
    432e:	00 20       	and	r0, r0
    4330:	c9 f7       	brne	.-14     	; 0x4324 <strncpy+0x4>
    4332:	01 c0       	rjmp	.+2      	; 0x4336 <strncpy+0x16>
    4334:	1d 92       	st	X+, r1
    4336:	41 50       	subi	r20, 0x01	; 1
    4338:	50 40       	sbci	r21, 0x00	; 0
    433a:	e0 f7       	brcc	.-8      	; 0x4334 <strncpy+0x14>
    433c:	08 95       	ret

0000433e <ultoa>:
    433e:	25 32       	cpi	r18, 0x25	; 37
    4340:	31 05       	cpc	r19, r1
    4342:	20 f4       	brcc	.+8      	; 0x434c <ultoa+0xe>
    4344:	22 30       	cpi	r18, 0x02	; 2
    4346:	10 f0       	brcs	.+4      	; 0x434c <ultoa+0xe>
    4348:	0c 94 aa 21 	jmp	0x4354	; 0x4354 <__ultoa_ncheck>
    434c:	fa 01       	movw	r30, r20
    434e:	10 82       	st	Z, r1
    4350:	ca 01       	movw	r24, r20
    4352:	08 95       	ret

00004354 <__ultoa_ncheck>:
    4354:	bb 27       	eor	r27, r27

00004356 <__ultoa_common>:
    4356:	fa 01       	movw	r30, r20
    4358:	a6 2f       	mov	r26, r22
    435a:	62 17       	cp	r22, r18
    435c:	71 05       	cpc	r23, r1
    435e:	81 05       	cpc	r24, r1
    4360:	91 05       	cpc	r25, r1
    4362:	33 0b       	sbc	r19, r19
    4364:	30 fb       	bst	r19, 0
    4366:	66 f0       	brts	.+24     	; 0x4380 <__ultoa_common+0x2a>
    4368:	aa 27       	eor	r26, r26
    436a:	66 0f       	add	r22, r22
    436c:	77 1f       	adc	r23, r23
    436e:	88 1f       	adc	r24, r24
    4370:	99 1f       	adc	r25, r25
    4372:	aa 1f       	adc	r26, r26
    4374:	a2 17       	cp	r26, r18
    4376:	10 f0       	brcs	.+4      	; 0x437c <__ultoa_common+0x26>
    4378:	a2 1b       	sub	r26, r18
    437a:	63 95       	inc	r22
    437c:	38 50       	subi	r19, 0x08	; 8
    437e:	a9 f7       	brne	.-22     	; 0x436a <__ultoa_common+0x14>
    4380:	a0 5d       	subi	r26, 0xD0	; 208
    4382:	aa 33       	cpi	r26, 0x3A	; 58
    4384:	08 f0       	brcs	.+2      	; 0x4388 <__ultoa_common+0x32>
    4386:	a9 5d       	subi	r26, 0xD9	; 217
    4388:	a1 93       	st	Z+, r26
    438a:	36 f7       	brtc	.-52     	; 0x4358 <__ultoa_common+0x2>
    438c:	b1 11       	cpse	r27, r1
    438e:	b1 93       	st	Z+, r27
    4390:	10 82       	st	Z, r1
    4392:	ca 01       	movw	r24, r20
    4394:	0c 94 f1 21 	jmp	0x43e2	; 0x43e2 <strrev>

00004398 <utoa>:
    4398:	45 32       	cpi	r20, 0x25	; 37
    439a:	51 05       	cpc	r21, r1
    439c:	20 f4       	brcc	.+8      	; 0x43a6 <utoa+0xe>
    439e:	42 30       	cpi	r20, 0x02	; 2
    43a0:	10 f0       	brcs	.+4      	; 0x43a6 <utoa+0xe>
    43a2:	0c 94 d7 21 	jmp	0x43ae	; 0x43ae <__utoa_ncheck>
    43a6:	fb 01       	movw	r30, r22
    43a8:	10 82       	st	Z, r1
    43aa:	cb 01       	movw	r24, r22
    43ac:	08 95       	ret

000043ae <__utoa_ncheck>:
    43ae:	bb 27       	eor	r27, r27

000043b0 <__utoa_common>:
    43b0:	fb 01       	movw	r30, r22
    43b2:	55 27       	eor	r21, r21
    43b4:	aa 27       	eor	r26, r26
    43b6:	88 0f       	add	r24, r24
    43b8:	99 1f       	adc	r25, r25
    43ba:	aa 1f       	adc	r26, r26
    43bc:	a4 17       	cp	r26, r20
    43be:	10 f0       	brcs	.+4      	; 0x43c4 <__utoa_common+0x14>
    43c0:	a4 1b       	sub	r26, r20
    43c2:	83 95       	inc	r24
    43c4:	50 51       	subi	r21, 0x10	; 16
    43c6:	b9 f7       	brne	.-18     	; 0x43b6 <__utoa_common+0x6>
    43c8:	a0 5d       	subi	r26, 0xD0	; 208
    43ca:	aa 33       	cpi	r26, 0x3A	; 58
    43cc:	08 f0       	brcs	.+2      	; 0x43d0 <__utoa_common+0x20>
    43ce:	a9 5d       	subi	r26, 0xD9	; 217
    43d0:	a1 93       	st	Z+, r26
    43d2:	00 97       	sbiw	r24, 0x00	; 0
    43d4:	79 f7       	brne	.-34     	; 0x43b4 <__utoa_common+0x4>
    43d6:	b1 11       	cpse	r27, r1
    43d8:	b1 93       	st	Z+, r27
    43da:	11 92       	st	Z+, r1
    43dc:	cb 01       	movw	r24, r22
    43de:	0c 94 f1 21 	jmp	0x43e2	; 0x43e2 <strrev>

000043e2 <strrev>:
    43e2:	dc 01       	movw	r26, r24
    43e4:	fc 01       	movw	r30, r24
    43e6:	67 2f       	mov	r22, r23
    43e8:	71 91       	ld	r23, Z+
    43ea:	77 23       	and	r23, r23
    43ec:	e1 f7       	brne	.-8      	; 0x43e6 <strrev+0x4>
    43ee:	32 97       	sbiw	r30, 0x02	; 2
    43f0:	04 c0       	rjmp	.+8      	; 0x43fa <strrev+0x18>
    43f2:	7c 91       	ld	r23, X
    43f4:	6d 93       	st	X+, r22
    43f6:	70 83       	st	Z, r23
    43f8:	62 91       	ld	r22, -Z
    43fa:	ae 17       	cp	r26, r30
    43fc:	bf 07       	cpc	r27, r31
    43fe:	c8 f3       	brcs	.-14     	; 0x43f2 <strrev+0x10>
    4400:	08 95       	ret

00004402 <_exit>:
    4402:	f8 94       	cli

00004404 <__stop_program>:
    4404:	ff cf       	rjmp	.-2      	; 0x4404 <__stop_program>
