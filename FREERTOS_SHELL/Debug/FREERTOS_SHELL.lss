
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000434c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b0  00802000  0000434c  000043e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a4  008020b0  008020b0  00004490  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004490  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000044c0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006a8  00000000  00000000  00004500  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010c04  00000000  00000000  00004ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000061bf  00000000  00000000  000157ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004edd  00000000  00000000  0001b96b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001358  00000000  00000000  00020848  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005eb1  00000000  00000000  00021ba0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000603c  00000000  00000000  00027a51  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000558  00000000  00000000  0002da8d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a7 02 	jmp	0x54e	; 0x54e <__ctors_end>
       4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      10:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      14:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      18:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      1c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      20:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      24:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      28:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      2c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      30:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      34:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      38:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      3c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      40:	0c 94 f0 0b 	jmp	0x17e0	; 0x17e0 <__vector_16>
      44:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      4c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      50:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      54:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      58:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      5c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      60:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      64:	0c 94 db 1b 	jmp	0x37b6	; 0x37b6 <__vector_25>
      68:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      6c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      70:	0c 94 39 1c 	jmp	0x3872	; 0x3872 <__vector_28>
      74:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      78:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      7c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      80:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      84:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      88:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      8c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      90:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      94:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      98:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      9c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e8:	0c 94 53 1d 	jmp	0x3aa6	; 0x3aa6 <__vector_58>
      ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      fc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     100:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     104:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     108:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     10c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     110:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     114:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     118:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     11c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     120:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     124:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     128:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     12c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     130:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     134:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     138:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     13c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     140:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     144:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     148:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     14c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     150:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     154:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     158:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     15c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     160:	0c 94 97 1c 	jmp	0x392e	; 0x392e <__vector_88>
     164:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     168:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     16c:	0c 94 f5 1c 	jmp	0x39ea	; 0x39ea <__vector_91>
     170:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     174:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     178:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     17c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     180:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     184:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     188:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     18c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     190:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     194:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     198:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     19c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1fc:	c7 19       	sub	r28, r7
     1fe:	ca 19       	sub	r28, r10
     200:	cd 19       	sub	r28, r13
     202:	d0 19       	sub	r29, r0
     204:	d3 19       	sub	r29, r3
     206:	d6 19       	sub	r29, r6
     208:	d8 19       	sub	r29, r8
     20a:	e9 19       	sub	r30, r9
     20c:	f1 19       	sub	r31, r1
     20e:	fb 19       	sub	r31, r11
     210:	f9 19       	sub	r31, r9

00000212 <__trampolines_start>:
     212:	0c 94 3f 1b 	jmp	0x367e	; 0x367e <_ZN5rs23214check_for_charEv>
     216:	0c 94 59 1e 	jmp	0x3cb2	; 0x3cb2 <_GLOBAL__sub_I_counter>
     21a:	0c 94 c7 19 	jmp	0x338e	; 0x338e <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21e:	0c 94 ed 16 	jmp	0x2dda	; 0x2dda <_ZN14frt_text_queue7getcharEv>
     222:	0c 94 72 19 	jmp	0x32e4	; 0x32e4 <_ZN8emstream12clear_screenEv>
     226:	0c 94 6c 19 	jmp	0x32d8	; 0x32d8 <_ZN8emstream7getcharEv>
     22a:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <_ZN9task_user3runEv>
     22e:	0c 94 ca 19 	jmp	0x3394	; 0x3394 <_ZN8emstreamlsE15ser_manipulator+0x24>
     232:	0c 94 6f 19 	jmp	0x32de	; 0x32de <_ZN8emstream14check_for_charEv>
     236:	0c 94 71 19 	jmp	0x32e2	; 0x32e2 <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 fb 19 	jmp	0x33f6	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
     23e:	0c 94 d3 19 	jmp	0x33a6	; 0x33a6 <_ZN8emstreamlsE15ser_manipulator+0x36>
     242:	0c 94 23 04 	jmp	0x846	; 0x846 <_ZN5Motor3runEv>
     246:	0c 94 16 17 	jmp	0x2e2c	; 0x2e2c <_ZN14frt_text_queue7putcharEc>
     24a:	0c 94 74 0e 	jmp	0x1ce8	; 0x1ce8 <prvIdleTask>
     24e:	0c 94 d3 18 	jmp	0x31a6	; 0x31a6 <__cxa_pure_virtual>
     252:	0c 94 de 03 	jmp	0x7bc	; 0x7bc <_ZN13LimitSwitches3runEv>
     256:	0c 94 6e 03 	jmp	0x6dc	; 0x6dc <_ZN15EncoderPendulum3runEv>
     25a:	0c 94 a4 02 	jmp	0x548	; 0x548 <_call_static_run_method>
     25e:	0c 94 0b 17 	jmp	0x2e16	; 0x2e16 <_ZN14frt_text_queue14check_for_charEv>
     262:	0c 94 d8 19 	jmp	0x33b0	; 0x33b0 <_ZN8emstreamlsE15ser_manipulator+0x40>
     266:	0c 94 6a 19 	jmp	0x32d4	; 0x32d4 <_ZN8emstream13ready_to_sendEv>
     26a:	0c 94 f9 19 	jmp	0x33f2	; 0x33f2 <_ZN8emstreamlsE15ser_manipulator+0x82>
     26e:	0c 94 f1 19 	jmp	0x33e2	; 0x33e2 <_ZN8emstreamlsE15ser_manipulator+0x72>
     272:	0c 94 a3 15 	jmp	0x2b46	; 0x2b46 <_ZN8frt_task12print_statusER8emstream>
     276:	0c 94 d0 19 	jmp	0x33a0	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x30>
     27a:	0c 94 df 02 	jmp	0x5be	; 0x5be <_ZN12EncoderMotor3runEv>
     27e:	0c 94 f5 1a 	jmp	0x35ea	; 0x35ea <_ZN5rs2327putcharEc>
     282:	0c 94 d6 19 	jmp	0x33ac	; 0x33ac <_ZN8emstreamlsE15ser_manipulator+0x3c>
     286:	0c 94 e9 19 	jmp	0x33d2	; 0x33d2 <_ZN8emstreamlsE15ser_manipulator+0x62>
     28a:	0c 94 52 1b 	jmp	0x36a4	; 0x36a4 <_ZN5rs23212clear_screenEv>
     28e:	0c 94 cd 19 	jmp	0x339a	; 0x339a <_ZN8emstreamlsE15ser_manipulator+0x2a>
     292:	0c 94 19 1b 	jmp	0x3632	; 0x3632 <_ZN5rs2327getcharEv>

00000296 <__trampolines_end>:
     296:	2c 20       	and	r2, r12
     298:	54 43       	sbci	r21, 0x34	; 52
     29a:	43 30       	cpi	r20, 0x03	; 3
     29c:	43 43       	sbci	r20, 0x33	; 51
     29e:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a1 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a1:	2f 00                                               /.

000002a3 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b1 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b1:	54 69 6d 65 3a 20 00                                Time: .

000002b8 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b8:	4e 6f 76 20 32 38 20 32 30 31 37 00                 Nov 28 2017.

000002c4 <_ZZN9task_user11show_statusEvE3__c>:
     2c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     302:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000030d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     30d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     31d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34b:	6d 61 74 69 6f 6e 00                                mation.

00000352 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     352:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     362:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000373 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     373:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     383:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3a7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3b7:	68 65 20 41 56 52 00                                he AVR.

000003be <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3be:	20 68 65 6c 70 00                                    help.

000003c4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e3:	1b 5b 33 30 6d 00                                   .[30m.

000003e9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e9:	1b 5b 34 36 6d 00                                   .[46m.

000003ef <_ZZN9task_user3runEvE3__c_3>:
     3ef:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ff:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000040c <_ZZN9task_user3runEvE3__c_2>:
     40c:	3a 57 54 46 3f 00                                   :WTF?.

00000412 <_ZZN9task_user3runEvE3__c_1>:
     412:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     422:	65 00                                               e.

00000424 <_ZZN9task_user3runEvE3__c_0>:
     424:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000432 <_ZZN9task_user3runEvE3__c>:
     432:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     442:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000450 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     450:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045a <_ZZN8frt_task15emergency_resetEvE3__c>:
     45a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000469 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     469:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     479:	61 73 6b 20 00                                      ask .

0000047e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     47e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000048c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     48c:	20 63 72 65 61 74 65 64 00                           created.

00000495 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     495:	54 61 73 6b 20 00                                   Task .

0000049b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49b:	1b 5b 32 32 6d 00                                   .[22m.

000004a1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a1:	54 61 73 6b 3a 20 00                                Task: .

000004a8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a8:	1b 5b 31 6d 00                                      .[1m.

000004ad <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4ad:	1b 5b 32 32 6d 00                                   .[22m.

000004b3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004be <_ZZ17print_task_stacksP8emstreamE3__c>:
     4be:	1b 5b 31 6d 00                                      .[1m.

000004c3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c3:	09 09 00                                            ...

000004c6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4c6:	2f 00                                               /.

000004c8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d3:	09 2d 2d 2d 2d 00                                   .----.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004f6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4f6:	09 52 75 6e 73 00                                   .Runs.

000004fc <_ZZ15print_task_listP8emstreamE3__c_2>:
     4fc:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000508 <_ZZ15print_task_listP8emstreamE3__c_1>:
     508:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000519 <_ZZ15print_task_listP8emstreamE3__c_0>:
     519:	09 53 74 61 63 6b 00                                .Stack.

00000520 <_ZZ15print_task_listP8emstreamE3__c>:
     520:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52b:	09 00                                               ..

0000052d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     52d:	09 00                                               ..

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     52f:	2f 00                                               /.

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     533:	09 00                                               ..

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53b:	1b 5b 31 6d 00                                      .[1m.

00000540 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     545:	20 20 00                                              .

00000548 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     548:	0e 94 3b 14 	call	0x2876	; 0x2876 <_ZN8frt_task22_call_users_run_methodEPS_>

0000054c <__ctors_start>:
     54c:	59 1e       	adc	r5, r25

0000054e <__ctors_end>:
     54e:	11 24       	eor	r1, r1
     550:	1f be       	out	0x3f, r1	; 63
     552:	cf ef       	ldi	r28, 0xFF	; 255
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df e3       	ldi	r29, 0x3F	; 63
     558:	de bf       	out	0x3e, r29	; 62
     55a:	00 e0       	ldi	r16, 0x00	; 0
     55c:	0c bf       	out	0x3c, r16	; 60
     55e:	18 be       	out	0x38, r1	; 56
     560:	19 be       	out	0x39, r1	; 57
     562:	1a be       	out	0x3a, r1	; 58
     564:	1b be       	out	0x3b, r1	; 59

00000566 <__do_copy_data>:
     566:	10 e2       	ldi	r17, 0x20	; 32
     568:	a0 e0       	ldi	r26, 0x00	; 0
     56a:	b0 e2       	ldi	r27, 0x20	; 32
     56c:	ec e4       	ldi	r30, 0x4C	; 76
     56e:	f3 e4       	ldi	r31, 0x43	; 67
     570:	00 e0       	ldi	r16, 0x00	; 0
     572:	0b bf       	out	0x3b, r16	; 59
     574:	02 c0       	rjmp	.+4      	; 0x57a <__do_copy_data+0x14>
     576:	07 90       	elpm	r0, Z+
     578:	0d 92       	st	X+, r0
     57a:	a0 3b       	cpi	r26, 0xB0	; 176
     57c:	b1 07       	cpc	r27, r17
     57e:	d9 f7       	brne	.-10     	; 0x576 <__do_copy_data+0x10>
     580:	1b be       	out	0x3b, r1	; 59

00000582 <__do_clear_bss>:
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	a0 eb       	ldi	r26, 0xB0	; 176
     586:	b0 e2       	ldi	r27, 0x20	; 32
     588:	01 c0       	rjmp	.+2      	; 0x58c <.do_clear_bss_start>

0000058a <.do_clear_bss_loop>:
     58a:	1d 92       	st	X+, r1

0000058c <.do_clear_bss_start>:
     58c:	a4 35       	cpi	r26, 0x54	; 84
     58e:	b2 07       	cpc	r27, r18
     590:	e1 f7       	brne	.-8      	; 0x58a <.do_clear_bss_loop>

00000592 <__do_global_ctors>:
     592:	12 e0       	ldi	r17, 0x02	; 2
     594:	c7 ea       	ldi	r28, 0xA7	; 167
     596:	d2 e0       	ldi	r29, 0x02	; 2
     598:	00 e0       	ldi	r16, 0x00	; 0
     59a:	06 c0       	rjmp	.+12     	; 0x5a8 <__do_global_ctors+0x16>
     59c:	21 97       	sbiw	r28, 0x01	; 1
     59e:	01 09       	sbc	r16, r1
     5a0:	80 2f       	mov	r24, r16
     5a2:	fe 01       	movw	r30, r28
     5a4:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <__tablejump2__>
     5a8:	c6 3a       	cpi	r28, 0xA6	; 166
     5aa:	d1 07       	cpc	r29, r17
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 07       	cpc	r16, r24
     5b0:	a9 f7       	brne	.-22     	; 0x59c <__do_global_ctors+0xa>
     5b2:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <main>
     5b6:	0c 94 a4 21 	jmp	0x4348	; 0x4348 <_exit>

000005ba <__bad_interrupt>:
     5ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005be <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN12EncoderMotor3runEv+0x6>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5cc:	0e 94 13 10 	call	0x2026	; 0x2026 <xTaskGetTickCount>
     5d0:	69 83       	std	Y+1, r22	; 0x01
     5d2:	7a 83       	std	Y+2, r23	; 0x02
     5d4:	8b 83       	std	Y+3, r24	; 0x03
     5d6:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5d8:	e0 e8       	ldi	r30, 0x80	; 128
     5da:	f6 e0       	ldi	r31, 0x06	; 6
     5dc:	8c e0       	ldi	r24, 0x0C	; 12
     5de:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e0:	82 89       	ldd	r24, Z+18	; 0x12
     5e2:	83 60       	ori	r24, 0x03	; 3
     5e4:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5e6:	83 89       	ldd	r24, Z+19	; 0x13
     5e8:	83 60       	ori	r24, 0x03	; 3
     5ea:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	82 e7       	ldi	r24, 0x72	; 114
     5f2:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f4:	89 e0       	ldi	r24, 0x09	; 9
     5f6:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f8:	e0 e0       	ldi	r30, 0x00	; 0
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	88 e6       	ldi	r24, 0x68	; 104
     5fe:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	86 a3       	std	Z+38, r24	; 0x26
     606:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	80 83       	st	Z, r24
	while(1){
		
		//encoder_count = TCD0.CNT;											// get count
		//*p_serial << "Encoder Pulses: " << encoder_count << endl;
		
		angularPosition = ( (int32_t) encoder_count*9);						// count/(4*1000)*360 deg * 100
     60c:	c1 2c       	mov	r12, r1
     60e:	d1 2c       	mov	r13, r1
		//*p_serial << "angularPosition: " << angularPosition << endl;		// divide by a hundred to read degrees
		thMotor.put(angularPosition);
		
		x = ( (int32_t) encoder_count*3)/100;								// PPMM = (4*1000)/(pi*38)
     610:	e1 2c       	mov	r14, r1
     612:	f1 2c       	mov	r15, r1
		
		angularVelocity = ((int32_t) (encoder_count-last_encoder_count)*15)/dt;	// d_ec*60/(4*1000)/dt where dt is in ms so * 1000
		//*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     614:	a1 2c       	mov	r10, r1
     616:	b1 2c       	mov	r11, r1
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     618:	0f b6       	in	r0, 0x3f	; 63
     61a:	f8 94       	cli
     61c:	0f 92       	push	r0
			the_data = new_data;
     61e:	c0 92 3e 31 	sts	0x313E, r12	; 0x80313e <thMotor>
     622:	d0 92 3f 31 	sts	0x313F, r13	; 0x80313f <thMotor+0x1>
			portEXIT_CRITICAL ();
     626:	0f 90       	pop	r0
     628:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     62a:	0f b6       	in	r0, 0x3f	; 63
     62c:	f8 94       	cli
     62e:	0f 92       	push	r0
			the_data = new_data;
     630:	e0 92 40 31 	sts	0x3140, r14	; 0x803140 <linear_position>
     634:	f0 92 41 31 	sts	0x3141, r15	; 0x803141 <linear_position+0x1>
			portEXIT_CRITICAL ();
     638:	0f 90       	pop	r0
     63a:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     63c:	0f b6       	in	r0, 0x3f	; 63
     63e:	f8 94       	cli
     640:	0f 92       	push	r0
			the_data = new_data;
     642:	88 27       	eor	r24, r24
     644:	99 27       	eor	r25, r25
     646:	88 19       	sub	r24, r8
     648:	99 09       	sbc	r25, r9
     64a:	09 2e       	mov	r0, r25
     64c:	00 0c       	add	r0, r0
     64e:	aa 0b       	sbc	r26, r26
     650:	bb 0b       	sbc	r27, r27
     652:	ac 01       	movw	r20, r24
     654:	bd 01       	movw	r22, r26
     656:	44 0f       	add	r20, r20
     658:	55 1f       	adc	r21, r21
     65a:	66 1f       	adc	r22, r22
     65c:	77 1f       	adc	r23, r23
     65e:	84 0f       	add	r24, r20
     660:	95 1f       	adc	r25, r21
     662:	a6 1f       	adc	r26, r22
     664:	b7 1f       	adc	r27, r23
     666:	ac 01       	movw	r20, r24
     668:	bd 01       	movw	r22, r26
     66a:	44 0f       	add	r20, r20
     66c:	55 1f       	adc	r21, r21
     66e:	66 1f       	adc	r22, r22
     670:	77 1f       	adc	r23, r23
     672:	44 0f       	add	r20, r20
     674:	55 1f       	adc	r21, r21
     676:	66 1f       	adc	r22, r22
     678:	77 1f       	adc	r23, r23
     67a:	84 0f       	add	r24, r20
     67c:	95 1f       	adc	r25, r21
     67e:	a6 1f       	adc	r26, r22
     680:	b7 1f       	adc	r27, r23
     682:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <thdMotor>
     686:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     68a:	0f 90       	pop	r0
     68c:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     68e:	f8 01       	movw	r30, r16
     690:	86 85       	ldd	r24, Z+14	; 0x0e
     692:	97 85       	ldd	r25, Z+15	; 0x0f
     694:	a0 89       	ldd	r26, Z+16	; 0x10
     696:	b1 89       	ldd	r27, Z+17	; 0x11
     698:	01 96       	adiw	r24, 0x01	; 1
     69a:	a1 1d       	adc	r26, r1
     69c:	b1 1d       	adc	r27, r1
     69e:	86 87       	std	Z+14, r24	; 0x0e
     6a0:	97 87       	std	Z+15, r25	; 0x0f
     6a2:	a0 8b       	std	Z+16, r26	; 0x10
     6a4:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     6a6:	41 e0       	ldi	r20, 0x01	; 1
     6a8:	50 e0       	ldi	r21, 0x00	; 0
     6aa:	60 e0       	ldi	r22, 0x00	; 0
     6ac:	70 e0       	ldi	r23, 0x00	; 0
     6ae:	ce 01       	movw	r24, r28
     6b0:	01 96       	adiw	r24, 0x01	; 1
     6b2:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
		
		angularVelocity = ((int32_t) (encoder_count-last_encoder_count)*15)/dt;	// d_ec*60/(4*1000)/dt where dt is in ms so * 1000
		//*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6b6:	8a 2c       	mov	r8, r10
     6b8:	9b 2c       	mov	r9, r11
     6ba:	ae cf       	rjmp	.-164    	; 0x618 <_ZN12EncoderMotor3runEv+0x5a>

000006bc <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     6bc:	0f 93       	push	r16
     6be:	1f 93       	push	r17
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6c6:	0e 94 4e 14 	call	0x289c	; 0x289c <_ZN8frt_taskC1EPKchjP8emstream>
     6ca:	8a e0       	ldi	r24, 0x0A	; 10
     6cc:	90 e2       	ldi	r25, 0x20	; 32
     6ce:	88 83       	st	Y, r24
     6d0:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6d2:	df 91       	pop	r29
     6d4:	cf 91       	pop	r28
     6d6:	1f 91       	pop	r17
     6d8:	0f 91       	pop	r16
     6da:	08 95       	ret

000006dc <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	00 d0       	rcall	.+0      	; 0x6e2 <_ZN15EncoderPendulum3runEv+0x6>
     6e2:	1f 92       	push	r1
     6e4:	cd b7       	in	r28, 0x3d	; 61
     6e6:	de b7       	in	r29, 0x3e	; 62
     6e8:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6ea:	0e 94 13 10 	call	0x2026	; 0x2026 <xTaskGetTickCount>
     6ee:	69 83       	std	Y+1, r22	; 0x01
     6f0:	7a 83       	std	Y+2, r23	; 0x02
     6f2:	8b 83       	std	Y+3, r24	; 0x03
     6f4:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     6f6:	e0 e8       	ldi	r30, 0x80	; 128
     6f8:	f6 e0       	ldi	r31, 0x06	; 6
     6fa:	83 e0       	ldi	r24, 0x03	; 3
     6fc:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     6fe:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     700:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     702:	e0 e8       	ldi	r30, 0x80	; 128
     704:	f1 e0       	ldi	r31, 0x01	; 1
     706:	80 e7       	ldi	r24, 0x70	; 112
     708:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     70a:	89 e0       	ldi	r24, 0x09	; 9
     70c:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     70e:	e0 e4       	ldi	r30, 0x40	; 64
     710:	f8 e0       	ldi	r31, 0x08	; 8
     712:	8a e6       	ldi	r24, 0x6A	; 106
     714:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     716:	80 ea       	ldi	r24, 0xA0	; 160
     718:	95 e0       	ldi	r25, 0x05	; 5
     71a:	86 a3       	std	Z+38, r24	; 0x26
     71c:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     71e:	81 e0       	ldi	r24, 0x01	; 1
     720:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     722:	68 94       	set
     724:	ee 24       	eor	r14, r14
     726:	e6 f8       	bld	r14, 6
     728:	ff 24       	eor	r15, r15
     72a:	f3 f8       	bld	r15, 3
     72c:	f7 01       	movw	r30, r14
     72e:	a0 a1       	ldd	r26, Z+32	; 0x20
     730:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     732:	0f b6       	in	r0, 0x3f	; 63
     734:	f8 94       	cli
     736:	0f 92       	push	r0
			the_data = new_data;
     738:	24 e6       	ldi	r18, 0x64	; 100
     73a:	30 e0       	ldi	r19, 0x00	; 0
     73c:	0e 94 02 21 	call	0x4204	; 0x4204 <__usmulhisi3>
     740:	4b 01       	movw	r8, r22
     742:	5c 01       	movw	r10, r24
     744:	99 23       	and	r25, r25
     746:	2c f4       	brge	.+10     	; 0x752 <_ZN15EncoderPendulum3runEv+0x76>
     748:	f3 e0       	ldi	r31, 0x03	; 3
     74a:	8f 0e       	add	r8, r31
     74c:	91 1c       	adc	r9, r1
     74e:	a1 1c       	adc	r10, r1
     750:	b1 1c       	adc	r11, r1
     752:	d5 01       	movw	r26, r10
     754:	c4 01       	movw	r24, r8
     756:	b5 95       	asr	r27
     758:	a7 95       	ror	r26
     75a:	97 95       	ror	r25
     75c:	87 95       	ror	r24
     75e:	b5 95       	asr	r27
     760:	a7 95       	ror	r26
     762:	97 95       	ror	r25
     764:	87 95       	ror	r24
     766:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <thPendulum>
     76a:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <thPendulum+0x1>
			portEXIT_CRITICAL ();
     76e:	0f 90       	pop	r0
     770:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     772:	f8 01       	movw	r30, r16
     774:	86 85       	ldd	r24, Z+14	; 0x0e
     776:	97 85       	ldd	r25, Z+15	; 0x0f
     778:	a0 89       	ldd	r26, Z+16	; 0x10
     77a:	b1 89       	ldd	r27, Z+17	; 0x11
     77c:	01 96       	adiw	r24, 0x01	; 1
     77e:	a1 1d       	adc	r26, r1
     780:	b1 1d       	adc	r27, r1
     782:	86 87       	std	Z+14, r24	; 0x0e
     784:	97 87       	std	Z+15, r25	; 0x0f
     786:	a0 8b       	std	Z+16, r26	; 0x10
     788:	b1 8b       	std	Z+17, r27	; 0x11
     78a:	44 e6       	ldi	r20, 0x64	; 100
     78c:	50 e0       	ldi	r21, 0x00	; 0
     78e:	60 e0       	ldi	r22, 0x00	; 0
     790:	70 e0       	ldi	r23, 0x00	; 0
     792:	ce 01       	movw	r24, r28
     794:	01 96       	adiw	r24, 0x01	; 1
     796:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
     79a:	c8 cf       	rjmp	.-112    	; 0x72c <_ZN15EncoderPendulum3runEv+0x50>

0000079c <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     79c:	0f 93       	push	r16
     79e:	1f 93       	push	r17
     7a0:	cf 93       	push	r28
     7a2:	df 93       	push	r29
     7a4:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7a6:	0e 94 4e 14 	call	0x289c	; 0x289c <_ZN8frt_taskC1EPKchjP8emstream>
     7aa:	82 e1       	ldi	r24, 0x12	; 18
     7ac:	90 e2       	ldi	r25, 0x20	; 32
     7ae:	88 83       	st	Y, r24
     7b0:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     7b2:	df 91       	pop	r29
     7b4:	cf 91       	pop	r28
     7b6:	1f 91       	pop	r17
     7b8:	0f 91       	pop	r16
     7ba:	08 95       	ret

000007bc <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     7bc:	cf 93       	push	r28
     7be:	df 93       	push	r29
     7c0:	00 d0       	rcall	.+0      	; 0x7c2 <_ZN13LimitSwitches3runEv+0x6>
     7c2:	1f 92       	push	r1
     7c4:	cd b7       	in	r28, 0x3d	; 61
     7c6:	de b7       	in	r29, 0x3e	; 62
     7c8:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7ca:	0e 94 13 10 	call	0x2026	; 0x2026 <xTaskGetTickCount>
     7ce:	69 83       	std	Y+1, r22	; 0x01
     7d0:	7a 83       	std	Y+2, r23	; 0x02
     7d2:	8b 83       	std	Y+3, r24	; 0x03
     7d4:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     7d6:	e0 e6       	ldi	r30, 0x60	; 96
     7d8:	f6 e0       	ldi	r31, 0x06	; 6
     7da:	81 e0       	ldi	r24, 0x01	; 1
     7dc:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     7de:	84 e0       	ldi	r24, 0x04	; 4
     7e0:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     7e2:	88 e1       	ldi	r24, 0x18	; 24
     7e4:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     7e6:	82 8b       	std	Z+18, r24	; 0x12
	bool rightLimit;
	bool leftLimit;

	while(1){
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     7e8:	0f 2e       	mov	r0, r31
     7ea:	f8 e6       	ldi	r31, 0x68	; 104
     7ec:	ef 2e       	mov	r14, r31
     7ee:	f6 e0       	ldi	r31, 0x06	; 6
     7f0:	ff 2e       	mov	r15, r31
     7f2:	f0 2d       	mov	r31, r0
     7f4:	f7 01       	movw	r30, r14
     7f6:	80 81       	ld	r24, Z
     7f8:	80 fd       	sbrc	r24, 0
		{	
			leftLimit = 1;
			//p_serial << "leftLimit: " << leftLimit << endl;
			
		}
		else if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     7fa:	80 81       	ld	r24, Z
			leftLimit = 0;
			//*p_serial << "limits: " << rightLimit << leftLimit << endl;
		}
		
		// Increment counter for debugging
		runs++;
     7fc:	f8 01       	movw	r30, r16
     7fe:	86 85       	ldd	r24, Z+14	; 0x0e
     800:	97 85       	ldd	r25, Z+15	; 0x0f
     802:	a0 89       	ldd	r26, Z+16	; 0x10
     804:	b1 89       	ldd	r27, Z+17	; 0x11
     806:	01 96       	adiw	r24, 0x01	; 1
     808:	a1 1d       	adc	r26, r1
     80a:	b1 1d       	adc	r27, r1
     80c:	86 87       	std	Z+14, r24	; 0x0e
     80e:	97 87       	std	Z+15, r25	; 0x0f
     810:	a0 8b       	std	Z+16, r26	; 0x10
     812:	b1 8b       	std	Z+17, r27	; 0x11
     814:	45 e0       	ldi	r20, 0x05	; 5
     816:	50 e0       	ldi	r21, 0x00	; 0
     818:	60 e0       	ldi	r22, 0x00	; 0
     81a:	70 e0       	ldi	r23, 0x00	; 0
     81c:	ce 01       	movw	r24, r28
     81e:	01 96       	adiw	r24, 0x01	; 1
     820:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
     824:	e7 cf       	rjmp	.-50     	; 0x7f4 <_ZN13LimitSwitches3runEv+0x38>

00000826 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     826:	0f 93       	push	r16
     828:	1f 93       	push	r17
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     830:	0e 94 4e 14 	call	0x289c	; 0x289c <_ZN8frt_taskC1EPKchjP8emstream>
     834:	8a e1       	ldi	r24, 0x1A	; 26
     836:	90 e2       	ldi	r25, 0x20	; 32
     838:	88 83       	st	Y, r24
     83a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     83c:	df 91       	pop	r29
     83e:	cf 91       	pop	r28
     840:	1f 91       	pop	r17
     842:	0f 91       	pop	r16
     844:	08 95       	ret

00000846 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     846:	cf 93       	push	r28
     848:	df 93       	push	r29
     84a:	00 d0       	rcall	.+0      	; 0x84c <_ZN5Motor3runEv+0x6>
     84c:	00 d0       	rcall	.+0      	; 0x84e <_ZN5Motor3runEv+0x8>
     84e:	cd b7       	in	r28, 0x3d	; 61
     850:	de b7       	in	r29, 0x3e	; 62
     852:	3c 01       	movw	r6, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     854:	0e 94 13 10 	call	0x2026	; 0x2026 <xTaskGetTickCount>
     858:	69 83       	std	Y+1, r22	; 0x01
     85a:	7a 83       	std	Y+2, r23	; 0x02
     85c:	8b 83       	std	Y+3, r24	; 0x03
     85e:	9c 83       	std	Y+4, r25	; 0x04

	dt = .008;
     860:	f3 01       	movw	r30, r6
     862:	fe 96       	adiw	r30, 0x3e	; 62
     864:	8f e6       	ldi	r24, 0x6F	; 111
     866:	92 e1       	ldi	r25, 0x12	; 18
     868:	a3 e0       	ldi	r26, 0x03	; 3
     86a:	bc e3       	ldi	r27, 0x3C	; 60
     86c:	80 83       	st	Z, r24
     86e:	91 83       	std	Z+1, r25	; 0x01
     870:	a2 83       	std	Z+2, r26	; 0x02
     872:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	f3 01       	movw	r30, r6
     87a:	84 af       	std	Z+60, r24	; 0x3c
     87c:	95 af       	std	Z+61, r25	; 0x3d
		runs++;
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     87e:	68 94       	set
     880:	44 24       	eor	r4, r4
     882:	41 f8       	bld	r4, 1
     884:	51 2c       	mov	r5, r1
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     886:	0f 2e       	mov	r0, r31
     888:	ff e3       	ldi	r31, 0x3F	; 63
     88a:	2f 2e       	mov	r2, r31
     88c:	f0 2d       	mov	r31, r0
     88e:	0f 2e       	mov	r0, r31
     890:	fc e3       	ldi	r31, 0x3C	; 60
     892:	3f 2e       	mov	r3, r31
     894:	f0 2d       	mov	r31, r0
	dt = .008;
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     896:	f3 01       	movw	r30, r6
     898:	86 85       	ldd	r24, Z+14	; 0x0e
     89a:	97 85       	ldd	r25, Z+15	; 0x0f
     89c:	a0 89       	ldd	r26, Z+16	; 0x10
     89e:	b1 89       	ldd	r27, Z+17	; 0x11
     8a0:	01 96       	adiw	r24, 0x01	; 1
     8a2:	a1 1d       	adc	r26, r1
     8a4:	b1 1d       	adc	r27, r1
     8a6:	86 87       	std	Z+14, r24	; 0x0e
     8a8:	97 87       	std	Z+15, r25	; 0x0f
     8aa:	a0 8b       	std	Z+16, r26	; 0x10
     8ac:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     8ae:	42 8e       	std	Z+26, r4	; 0x1a
     8b0:	53 8e       	std	Z+27, r5	; 0x1b

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
     8b2:	16 8e       	std	Z+30, r1	; 0x1e
     8b4:	17 8e       	std	Z+31, r1	; 0x1f
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     8b6:	2f 92       	push	r2
     8b8:	1f 92       	push	r1
     8ba:	1f 92       	push	r1
     8bc:	1f 92       	push	r1
     8be:	3f 92       	push	r3
     8c0:	f3 e2       	ldi	r31, 0x23	; 35
     8c2:	ff 93       	push	r31
     8c4:	27 ed       	ldi	r18, 0xD7	; 215
     8c6:	2f 93       	push	r18
     8c8:	3a e0       	ldi	r19, 0x0A	; 10
     8ca:	3f 93       	push	r19
     8cc:	0f 2e       	mov	r0, r31
     8ce:	fd ec       	ldi	r31, 0xCD	; 205
     8d0:	8f 2e       	mov	r8, r31
     8d2:	fc ec       	ldi	r31, 0xCC	; 204
     8d4:	9f 2e       	mov	r9, r31
     8d6:	a9 2c       	mov	r10, r9
     8d8:	fd e3       	ldi	r31, 0x3D	; 61
     8da:	bf 2e       	mov	r11, r31
     8dc:	f0 2d       	mov	r31, r0
     8de:	0f 2e       	mov	r0, r31
     8e0:	f4 e1       	ldi	r31, 0x14	; 20
     8e2:	cf 2e       	mov	r12, r31
     8e4:	fe ea       	ldi	r31, 0xAE	; 174
     8e6:	df 2e       	mov	r13, r31
     8e8:	ff e8       	ldi	r31, 0x8F	; 143
     8ea:	ef 2e       	mov	r14, r31
     8ec:	ff eb       	ldi	r31, 0xBF	; 191
     8ee:	ff 2e       	mov	r15, r31
     8f0:	f0 2d       	mov	r31, r0
     8f2:	04 e1       	ldi	r16, 0x14	; 20
     8f4:	1e ea       	ldi	r17, 0xAE	; 174
     8f6:	2f e8       	ldi	r18, 0x8F	; 143
     8f8:	3f e3       	ldi	r19, 0x3F	; 63
     8fa:	b5 01       	movw	r22, r10
     8fc:	a4 01       	movw	r20, r8
     8fe:	ce 01       	movw	r24, r28
     900:	05 96       	adiw	r24, 0x05	; 5
     902:	0e 94 58 05 	call	0xab0	; 0xab0 <_ZN3PIDC1Edddddd>
		double Tset = pidTorque.calculate(omegam_set, omegam_measured);
     906:	f3 01       	movw	r30, r6
     908:	66 8d       	ldd	r22, Z+30	; 0x1e
     90a:	77 8d       	ldd	r23, Z+31	; 0x1f
     90c:	02 8d       	ldd	r16, Z+26	; 0x1a
     90e:	13 8d       	ldd	r17, Z+27	; 0x1b
     910:	07 2e       	mov	r0, r23
     912:	00 0c       	add	r0, r0
     914:	88 0b       	sbc	r24, r24
     916:	99 0b       	sbc	r25, r25
     918:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__floatsisf>
     91c:	6b 01       	movw	r12, r22
     91e:	7c 01       	movw	r14, r24
     920:	b8 01       	movw	r22, r16
     922:	11 0f       	add	r17, r17
     924:	88 0b       	sbc	r24, r24
     926:	99 0b       	sbc	r25, r25
     928:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__floatsisf>
     92c:	ab 01       	movw	r20, r22
     92e:	bc 01       	movw	r22, r24
     930:	97 01       	movw	r18, r14
     932:	86 01       	movw	r16, r12
     934:	ce 01       	movw	r24, r28
     936:	05 96       	adiw	r24, 0x05	; 5
     938:	0e 94 7f 06 	call	0xcfe	; 0xcfe <_ZN3PID9calculateEdd>
     93c:	6b 01       	movw	r12, r22
     93e:	7c 01       	movw	r14, r24
		//printf("val:% 7.3f inc:% 7.3f\n", omegam_measured, inc);
		omegam_measured += inc;
     940:	f3 01       	movw	r30, r6
     942:	24 ad       	ldd	r18, Z+60	; 0x3c
     944:	35 ad       	ldd	r19, Z+61	; 0x3d
     946:	86 8d       	ldd	r24, Z+30	; 0x1e
     948:	97 8d       	ldd	r25, Z+31	; 0x1f
     94a:	82 0f       	add	r24, r18
     94c:	93 1f       	adc	r25, r19
     94e:	86 8f       	std	Z+30, r24	; 0x1e
     950:	97 8f       	std	Z+31, r25	; 0x1f

		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     952:	10 a6       	std	Z+40, r1	; 0x28
     954:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     956:	60 a5       	ldd	r22, Z+40	; 0x28
     958:	71 a5       	ldd	r23, Z+41	; 0x29
     95a:	07 2e       	mov	r0, r23
     95c:	00 0c       	add	r0, r0
     95e:	88 0b       	sbc	r24, r24
     960:	99 0b       	sbc	r25, r25
     962:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__floatsisf>
     966:	9b 01       	movw	r18, r22
     968:	ac 01       	movw	r20, r24
     96a:	c7 01       	movw	r24, r14
     96c:	b6 01       	movw	r22, r12
     96e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <__divsf3>
     972:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <__fixsfsi>
     976:	f3 01       	movw	r30, r6
     978:	64 a3       	std	Z+36, r22	; 0x24
     97a:	75 a3       	std	Z+37, r23	; 0x25

		// Saturater for current
		
		if(Im_set > 17.4) {
     97c:	64 a1       	ldd	r22, Z+36	; 0x24
     97e:	75 a1       	ldd	r23, Z+37	; 0x25
     980:	07 2e       	mov	r0, r23
     982:	00 0c       	add	r0, r0
     984:	88 0b       	sbc	r24, r24
     986:	99 0b       	sbc	r25, r25
     988:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__floatsisf>
     98c:	cd bf       	out	0x3d, r28	; 61
     98e:	de bf       	out	0x3e, r29	; 62
     990:	23 e3       	ldi	r18, 0x33	; 51
     992:	33 e3       	ldi	r19, 0x33	; 51
     994:	4b e8       	ldi	r20, 0x8B	; 139
     996:	51 e4       	ldi	r21, 0x41	; 65
     998:	0e 94 36 20 	call	0x406c	; 0x406c <__gesf2>
     99c:	18 16       	cp	r1, r24
     99e:	34 f4       	brge	.+12     	; 0x9ac <_ZN5Motor3runEv+0x166>
			Im_set = 17.4;
     9a0:	21 e1       	ldi	r18, 0x11	; 17
     9a2:	30 e0       	ldi	r19, 0x00	; 0
     9a4:	f3 01       	movw	r30, r6
     9a6:	24 a3       	std	Z+36, r18	; 0x24
     9a8:	35 a3       	std	Z+37, r19	; 0x25
     9aa:	16 c0       	rjmp	.+44     	; 0x9d8 <_ZN5Motor3runEv+0x192>
		} else if(Im_set < -17.4) {
     9ac:	f3 01       	movw	r30, r6
     9ae:	64 a1       	ldd	r22, Z+36	; 0x24
     9b0:	75 a1       	ldd	r23, Z+37	; 0x25
     9b2:	07 2e       	mov	r0, r23
     9b4:	00 0c       	add	r0, r0
     9b6:	88 0b       	sbc	r24, r24
     9b8:	99 0b       	sbc	r25, r25
     9ba:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__floatsisf>
     9be:	23 e3       	ldi	r18, 0x33	; 51
     9c0:	33 e3       	ldi	r19, 0x33	; 51
     9c2:	4b e8       	ldi	r20, 0x8B	; 139
     9c4:	51 ec       	ldi	r21, 0xC1	; 193
     9c6:	0e 94 d7 1e 	call	0x3dae	; 0x3dae <__cmpsf2>
     9ca:	88 23       	and	r24, r24
     9cc:	2c f4       	brge	.+10     	; 0x9d8 <_ZN5Motor3runEv+0x192>
			Im_set = -17.4;
     9ce:	2f ee       	ldi	r18, 0xEF	; 239
     9d0:	3f ef       	ldi	r19, 0xFF	; 255
     9d2:	f3 01       	movw	r30, r6
     9d4:	24 a3       	std	Z+36, r18	; 0x24
     9d6:	35 a3       	std	Z+37, r19	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     9d8:	f3 01       	movw	r30, r6
     9da:	16 aa       	std	Z+54, r1	; 0x36
     9dc:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     9de:	60 a5       	ldd	r22, Z+40	; 0x28
     9e0:	71 a5       	ldd	r23, Z+41	; 0x29
     9e2:	06 a9       	ldd	r16, Z+54	; 0x36
     9e4:	17 a9       	ldd	r17, Z+55	; 0x37
     9e6:	07 2e       	mov	r0, r23
     9e8:	00 0c       	add	r0, r0
     9ea:	88 0b       	sbc	r24, r24
     9ec:	99 0b       	sbc	r25, r25
     9ee:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__floatsisf>
     9f2:	20 e5       	ldi	r18, 0x50	; 80
     9f4:	3a e6       	ldi	r19, 0x6A	; 106
     9f6:	41 ea       	ldi	r20, 0xA1	; 161
     9f8:	57 e4       	ldi	r21, 0x47	; 71
     9fa:	0e 94 3b 20 	call	0x4076	; 0x4076 <__mulsf3>
     9fe:	6b 01       	movw	r12, r22
     a00:	7c 01       	movw	r14, r24
     a02:	b8 01       	movw	r22, r16
     a04:	11 0f       	add	r17, r17
     a06:	88 0b       	sbc	r24, r24
     a08:	99 0b       	sbc	r25, r25
     a0a:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <__floatsisf>
     a0e:	9b 01       	movw	r18, r22
     a10:	ac 01       	movw	r20, r24
     a12:	c7 01       	movw	r24, r14
     a14:	b6 01       	movw	r22, r12
     a16:	0e 94 3b 20 	call	0x4076	; 0x4076 <__mulsf3>
     a1a:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <__fixsfsi>
     a1e:	f3 01       	movw	r30, r6
     a20:	62 ab       	std	Z+50, r22	; 0x32
     a22:	73 ab       	std	Z+51, r23	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     a24:	46 a9       	ldd	r20, Z+54	; 0x36
     a26:	57 a9       	ldd	r21, Z+55	; 0x37
     a28:	26 8d       	ldd	r18, Z+30	; 0x1e
     a2a:	37 8d       	ldd	r19, Z+31	; 0x1f
     a2c:	42 9f       	mul	r20, r18
     a2e:	c0 01       	movw	r24, r0
     a30:	43 9f       	mul	r20, r19
     a32:	90 0d       	add	r25, r0
     a34:	52 9f       	mul	r21, r18
     a36:	90 0d       	add	r25, r0
     a38:	11 24       	eor	r1, r1
     a3a:	84 ab       	std	Z+52, r24	; 0x34
     a3c:	95 ab       	std	Z+53, r25	; 0x35

		V_m = V_R + V_E;
     a3e:	20 a9       	ldd	r18, Z+48	; 0x30
     a40:	31 a9       	ldd	r19, Z+49	; 0x31
     a42:	84 a9       	ldd	r24, Z+52	; 0x34
     a44:	95 a9       	ldd	r25, Z+53	; 0x35
     a46:	82 0f       	add	r24, r18
     a48:	93 1f       	adc	r25, r19
     a4a:	80 af       	std	Z+56, r24	; 0x38
     a4c:	91 af       	std	Z+57, r25	; 0x39

		// Saturater for voltage
		if (V_m > 24) {
     a4e:	80 ad       	ldd	r24, Z+56	; 0x38
     a50:	91 ad       	ldd	r25, Z+57	; 0x39
     a52:	49 97       	sbiw	r24, 0x19	; 25
     a54:	2c f0       	brlt	.+10     	; 0xa60 <_ZN5Motor3runEv+0x21a>
			V_m = 24;
     a56:	28 e1       	ldi	r18, 0x18	; 24
     a58:	30 e0       	ldi	r19, 0x00	; 0
     a5a:	20 af       	std	Z+56, r18	; 0x38
     a5c:	31 af       	std	Z+57, r19	; 0x39
     a5e:	0b c0       	rjmp	.+22     	; 0xa76 <_ZN5Motor3runEv+0x230>
		} else if(V_m < -24) {
     a60:	f3 01       	movw	r30, r6
     a62:	80 ad       	ldd	r24, Z+56	; 0x38
     a64:	91 ad       	ldd	r25, Z+57	; 0x39
     a66:	88 3e       	cpi	r24, 0xE8	; 232
     a68:	9f 4f       	sbci	r25, 0xFF	; 255
     a6a:	2c f4       	brge	.+10     	; 0xa76 <_ZN5Motor3runEv+0x230>
			V_m = -24;
     a6c:	28 ee       	ldi	r18, 0xE8	; 232
     a6e:	3f ef       	ldi	r19, 0xFF	; 255
     a70:	f3 01       	movw	r30, r6
     a72:	20 af       	std	Z+56, r18	; 0x38
     a74:	31 af       	std	Z+57, r19	; 0x39
     a76:	41 e0       	ldi	r20, 0x01	; 1
     a78:	50 e0       	ldi	r21, 0x00	; 0
     a7a:	60 e0       	ldi	r22, 0x00	; 0
     a7c:	70 e0       	ldi	r23, 0x00	; 0
     a7e:	ce 01       	movw	r24, r28
     a80:	01 96       	adiw	r24, 0x01	; 1
     a82:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     a86:	ce 01       	movw	r24, r28
     a88:	05 96       	adiw	r24, 0x05	; 5
     a8a:	0e 94 bf 05 	call	0xb7e	; 0xb7e <_ZN3PIDD1Ev>
	portTickType previousTicks = xTaskGetTickCount ();

	dt = .008;
	inc = 1;
	
	while(1){
     a8e:	03 cf       	rjmp	.-506    	; 0x896 <_ZN5Motor3runEv+0x50>

00000a90 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     a90:	0f 93       	push	r16
     a92:	1f 93       	push	r17
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a9a:	0e 94 4e 14 	call	0x289c	; 0x289c <_ZN8frt_taskC1EPKchjP8emstream>
     a9e:	82 e2       	ldi	r24, 0x22	; 34
     aa0:	90 e2       	ldi	r25, 0x20	; 32
     aa2:	88 83       	st	Y, r24
     aa4:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     aa6:	df 91       	pop	r29
     aa8:	cf 91       	pop	r28
     aaa:	1f 91       	pop	r17
     aac:	0f 91       	pop	r16
     aae:	08 95       	ret

00000ab0 <_ZN3PIDC1Edddddd>:
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}
     ab0:	2f 92       	push	r2
     ab2:	3f 92       	push	r3
     ab4:	4f 92       	push	r4
     ab6:	5f 92       	push	r5
     ab8:	6f 92       	push	r6
     aba:	7f 92       	push	r7
     abc:	8f 92       	push	r8
     abe:	9f 92       	push	r9
     ac0:	af 92       	push	r10
     ac2:	bf 92       	push	r11
     ac4:	cf 92       	push	r12
     ac6:	df 92       	push	r13
     ac8:	ef 92       	push	r14
     aca:	ff 92       	push	r15
     acc:	0f 93       	push	r16
     ace:	1f 93       	push	r17
     ad0:	cf 93       	push	r28
     ad2:	df 93       	push	r29
     ad4:	00 d0       	rcall	.+0      	; 0xad6 <_ZN3PIDC1Edddddd+0x26>
     ad6:	1f 92       	push	r1
     ad8:	cd b7       	in	r28, 0x3d	; 61
     ada:	de b7       	in	r29, 0x3e	; 62
     adc:	1c 01       	movw	r2, r24
     ade:	2a 01       	movw	r4, r20
     ae0:	3b 01       	movw	r6, r22
     ae2:	09 83       	std	Y+1, r16	; 0x01
     ae4:	1a 83       	std	Y+2, r17	; 0x02
     ae6:	2b 83       	std	Y+3, r18	; 0x03
     ae8:	3c 83       	std	Y+4, r19	; 0x04
     aea:	80 e2       	ldi	r24, 0x20	; 32
     aec:	90 e0       	ldi	r25, 0x00	; 0
     aee:	0e 94 c8 18 	call	0x3190	; 0x3190 <_Znwj>
     af2:	fc 01       	movw	r30, r24
     af4:	40 82       	st	Z, r4
     af6:	51 82       	std	Z+1, r5	; 0x01
     af8:	62 82       	std	Z+2, r6	; 0x02
     afa:	73 82       	std	Z+3, r7	; 0x03
     afc:	89 81       	ldd	r24, Y+1	; 0x01
     afe:	9a 81       	ldd	r25, Y+2	; 0x02
     b00:	ab 81       	ldd	r26, Y+3	; 0x03
     b02:	bc 81       	ldd	r27, Y+4	; 0x04
     b04:	84 83       	std	Z+4, r24	; 0x04
     b06:	95 83       	std	Z+5, r25	; 0x05
     b08:	a6 83       	std	Z+6, r26	; 0x06
     b0a:	b7 83       	std	Z+7, r27	; 0x07
     b0c:	c0 86       	std	Z+8, r12	; 0x08
     b0e:	d1 86       	std	Z+9, r13	; 0x09
     b10:	e2 86       	std	Z+10, r14	; 0x0a
     b12:	f3 86       	std	Z+11, r15	; 0x0b
     b14:	84 86       	std	Z+12, r8	; 0x0c
     b16:	95 86       	std	Z+13, r9	; 0x0d
     b18:	a6 86       	std	Z+14, r10	; 0x0e
     b1a:	b7 86       	std	Z+15, r11	; 0x0f
     b1c:	4a 8d       	ldd	r20, Y+26	; 0x1a
     b1e:	5b 8d       	ldd	r21, Y+27	; 0x1b
     b20:	6c 8d       	ldd	r22, Y+28	; 0x1c
     b22:	7d 8d       	ldd	r23, Y+29	; 0x1d
     b24:	40 8b       	std	Z+16, r20	; 0x10
     b26:	51 8b       	std	Z+17, r21	; 0x11
     b28:	62 8b       	std	Z+18, r22	; 0x12
     b2a:	73 8b       	std	Z+19, r23	; 0x13
     b2c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b2e:	9f 8d       	ldd	r25, Y+31	; 0x1f
     b30:	a8 a1       	ldd	r26, Y+32	; 0x20
     b32:	b9 a1       	ldd	r27, Y+33	; 0x21
     b34:	84 8b       	std	Z+20, r24	; 0x14
     b36:	95 8b       	std	Z+21, r25	; 0x15
     b38:	a6 8b       	std	Z+22, r26	; 0x16
     b3a:	b7 8b       	std	Z+23, r27	; 0x17
     b3c:	10 8e       	std	Z+24, r1	; 0x18
     b3e:	11 8e       	std	Z+25, r1	; 0x19
     b40:	12 8e       	std	Z+26, r1	; 0x1a
     b42:	13 8e       	std	Z+27, r1	; 0x1b
     b44:	14 8e       	std	Z+28, r1	; 0x1c
     b46:	15 8e       	std	Z+29, r1	; 0x1d
     b48:	16 8e       	std	Z+30, r1	; 0x1e
     b4a:	17 8e       	std	Z+31, r1	; 0x1f
     b4c:	d1 01       	movw	r26, r2
     b4e:	ed 93       	st	X+, r30
     b50:	fc 93       	st	X, r31
     b52:	24 96       	adiw	r28, 0x04	; 4
     b54:	cd bf       	out	0x3d, r28	; 61
     b56:	de bf       	out	0x3e, r29	; 62
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	1f 91       	pop	r17
     b5e:	0f 91       	pop	r16
     b60:	ff 90       	pop	r15
     b62:	ef 90       	pop	r14
     b64:	df 90       	pop	r13
     b66:	cf 90       	pop	r12
     b68:	bf 90       	pop	r11
     b6a:	af 90       	pop	r10
     b6c:	9f 90       	pop	r9
     b6e:	8f 90       	pop	r8
     b70:	7f 90       	pop	r7
     b72:	6f 90       	pop	r6
     b74:	5f 90       	pop	r5
     b76:	4f 90       	pop	r4
     b78:	3f 90       	pop	r3
     b7a:	2f 90       	pop	r2
     b7c:	08 95       	ret

00000b7e <_ZN3PIDD1Ev>:
     b7e:	fc 01       	movw	r30, r24
     b80:	80 81       	ld	r24, Z
     b82:	91 81       	ldd	r25, Z+1	; 0x01
     b84:	00 97       	sbiw	r24, 0x00	; 0
     b86:	11 f0       	breq	.+4      	; 0xb8c <_ZN3PIDD1Ev+0xe>
     b88:	0e 94 cb 18 	call	0x3196	; 0x3196 <_ZdlPv>
     b8c:	08 95       	ret

00000b8e <_ZN7PIDImpl9calculateEdd>:

double PIDImpl::calculate( double setpoint, double pv )
{
     b8e:	4f 92       	push	r4
     b90:	5f 92       	push	r5
     b92:	6f 92       	push	r6
     b94:	7f 92       	push	r7
     b96:	8f 92       	push	r8
     b98:	9f 92       	push	r9
     b9a:	af 92       	push	r10
     b9c:	bf 92       	push	r11
     b9e:	cf 92       	push	r12
     ba0:	df 92       	push	r13
     ba2:	ef 92       	push	r14
     ba4:	ff 92       	push	r15
     ba6:	0f 93       	push	r16
     ba8:	1f 93       	push	r17
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	00 d0       	rcall	.+0      	; 0xbb0 <_ZN7PIDImpl9calculateEdd+0x22>
     bb0:	00 d0       	rcall	.+0      	; 0xbb2 <_ZN7PIDImpl9calculateEdd+0x24>
     bb2:	cd b7       	in	r28, 0x3d	; 61
     bb4:	de b7       	in	r29, 0x3e	; 62
     bb6:	8d 83       	std	Y+5, r24	; 0x05
     bb8:	9e 83       	std	Y+6, r25	; 0x06
     bba:	cb 01       	movw	r24, r22
     bbc:	ba 01       	movw	r22, r20
    
    // Calculate error
    double error = setpoint - pv;
     bbe:	a9 01       	movw	r20, r18
     bc0:	98 01       	movw	r18, r16
     bc2:	0e 94 6a 1e 	call	0x3cd4	; 0x3cd4 <__subsf3>
     bc6:	6b 01       	movw	r12, r22
     bc8:	7c 01       	movw	r14, r24

    // Proportional term
    double Pout = _Kp * error;
     bca:	ed 81       	ldd	r30, Y+5	; 0x05
     bcc:	fe 81       	ldd	r31, Y+6	; 0x06
     bce:	24 85       	ldd	r18, Z+12	; 0x0c
     bd0:	35 85       	ldd	r19, Z+13	; 0x0d
     bd2:	46 85       	ldd	r20, Z+14	; 0x0e
     bd4:	57 85       	ldd	r21, Z+15	; 0x0f
     bd6:	0e 94 3b 20 	call	0x4076	; 0x4076 <__mulsf3>
     bda:	69 83       	std	Y+1, r22	; 0x01
     bdc:	7a 83       	std	Y+2, r23	; 0x02
     bde:	8b 83       	std	Y+3, r24	; 0x03
     be0:	9c 83       	std	Y+4, r25	; 0x04

    // Integral term
    _integral += error * _dt;
     be2:	ed 81       	ldd	r30, Y+5	; 0x05
     be4:	fe 81       	ldd	r31, Y+6	; 0x06
     be6:	40 80       	ld	r4, Z
     be8:	51 80       	ldd	r5, Z+1	; 0x01
     bea:	62 80       	ldd	r6, Z+2	; 0x02
     bec:	73 80       	ldd	r7, Z+3	; 0x03
     bee:	a3 01       	movw	r20, r6
     bf0:	92 01       	movw	r18, r4
     bf2:	c7 01       	movw	r24, r14
     bf4:	b6 01       	movw	r22, r12
     bf6:	0e 94 3b 20 	call	0x4076	; 0x4076 <__mulsf3>
     bfa:	ed 81       	ldd	r30, Y+5	; 0x05
     bfc:	fe 81       	ldd	r31, Y+6	; 0x06
     bfe:	24 8d       	ldd	r18, Z+28	; 0x1c
     c00:	35 8d       	ldd	r19, Z+29	; 0x1d
     c02:	46 8d       	ldd	r20, Z+30	; 0x1e
     c04:	57 8d       	ldd	r21, Z+31	; 0x1f
     c06:	0e 94 6b 1e 	call	0x3cd6	; 0x3cd6 <__addsf3>
     c0a:	4b 01       	movw	r8, r22
     c0c:	5c 01       	movw	r10, r24
     c0e:	ed 81       	ldd	r30, Y+5	; 0x05
     c10:	fe 81       	ldd	r31, Y+6	; 0x06
     c12:	64 8f       	std	Z+28, r22	; 0x1c
     c14:	75 8f       	std	Z+29, r23	; 0x1d
     c16:	86 8f       	std	Z+30, r24	; 0x1e
     c18:	97 8f       	std	Z+31, r25	; 0x1f
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     c1a:	20 8d       	ldd	r18, Z+24	; 0x18
     c1c:	31 8d       	ldd	r19, Z+25	; 0x19
     c1e:	42 8d       	ldd	r20, Z+26	; 0x1a
     c20:	53 8d       	ldd	r21, Z+27	; 0x1b
     c22:	c7 01       	movw	r24, r14
     c24:	b6 01       	movw	r22, r12
     c26:	0e 94 6a 1e 	call	0x3cd4	; 0x3cd4 <__subsf3>
     c2a:	a3 01       	movw	r20, r6
     c2c:	92 01       	movw	r18, r4
     c2e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <__divsf3>
     c32:	ed 81       	ldd	r30, Y+5	; 0x05
     c34:	fe 81       	ldd	r31, Y+6	; 0x06
     c36:	20 89       	ldd	r18, Z+16	; 0x10
     c38:	31 89       	ldd	r19, Z+17	; 0x11
     c3a:	42 89       	ldd	r20, Z+18	; 0x12
     c3c:	53 89       	ldd	r21, Z+19	; 0x13
     c3e:	0e 94 3b 20 	call	0x4076	; 0x4076 <__mulsf3>
     c42:	2b 01       	movw	r4, r22
     c44:	3c 01       	movw	r6, r24
     c46:	ed 81       	ldd	r30, Y+5	; 0x05
     c48:	fe 81       	ldd	r31, Y+6	; 0x06
     c4a:	24 89       	ldd	r18, Z+20	; 0x14
     c4c:	35 89       	ldd	r19, Z+21	; 0x15
     c4e:	46 89       	ldd	r20, Z+22	; 0x16
     c50:	57 89       	ldd	r21, Z+23	; 0x17
     c52:	c5 01       	movw	r24, r10
     c54:	b4 01       	movw	r22, r8
     c56:	0e 94 3b 20 	call	0x4076	; 0x4076 <__mulsf3>
     c5a:	29 81       	ldd	r18, Y+1	; 0x01
     c5c:	3a 81       	ldd	r19, Y+2	; 0x02
     c5e:	4b 81       	ldd	r20, Y+3	; 0x03
     c60:	5c 81       	ldd	r21, Y+4	; 0x04
     c62:	0e 94 6b 1e 	call	0x3cd6	; 0x3cd6 <__addsf3>
     c66:	9b 01       	movw	r18, r22
     c68:	ac 01       	movw	r20, r24
     c6a:	c3 01       	movw	r24, r6
     c6c:	b2 01       	movw	r22, r4
     c6e:	0e 94 6b 1e 	call	0x3cd6	; 0x3cd6 <__addsf3>
     c72:	b6 2e       	mov	r11, r22
     c74:	a7 2e       	mov	r10, r23
     c76:	98 2e       	mov	r9, r24
     c78:	89 2e       	mov	r8, r25

    // Restrict to max/min
    if( output > _max )
     c7a:	ed 81       	ldd	r30, Y+5	; 0x05
     c7c:	fe 81       	ldd	r31, Y+6	; 0x06
     c7e:	74 80       	ldd	r7, Z+4	; 0x04
     c80:	65 80       	ldd	r6, Z+5	; 0x05
     c82:	56 80       	ldd	r5, Z+6	; 0x06
     c84:	47 80       	ldd	r4, Z+7	; 0x07
     c86:	27 2d       	mov	r18, r7
     c88:	36 2d       	mov	r19, r6
     c8a:	45 2d       	mov	r20, r5
     c8c:	54 2d       	mov	r21, r4
     c8e:	0e 94 36 20 	call	0x406c	; 0x406c <__gesf2>
     c92:	18 16       	cp	r1, r24
     c94:	b4 f0       	brlt	.+44     	; 0xcc2 <_ZN7PIDImpl9calculateEdd+0x134>
        output = _max;
    else if( output < _min )
     c96:	ed 81       	ldd	r30, Y+5	; 0x05
     c98:	fe 81       	ldd	r31, Y+6	; 0x06
     c9a:	70 84       	ldd	r7, Z+8	; 0x08
     c9c:	61 84       	ldd	r6, Z+9	; 0x09
     c9e:	52 84       	ldd	r5, Z+10	; 0x0a
     ca0:	43 84       	ldd	r4, Z+11	; 0x0b
     ca2:	27 2d       	mov	r18, r7
     ca4:	36 2d       	mov	r19, r6
     ca6:	45 2d       	mov	r20, r5
     ca8:	54 2d       	mov	r21, r4
     caa:	6b 2d       	mov	r22, r11
     cac:	7a 2d       	mov	r23, r10
     cae:	89 2d       	mov	r24, r9
     cb0:	98 2d       	mov	r25, r8
     cb2:	0e 94 d7 1e 	call	0x3dae	; 0x3dae <__cmpsf2>
     cb6:	88 23       	and	r24, r24
     cb8:	24 f0       	brlt	.+8      	; 0xcc2 <_ZN7PIDImpl9calculateEdd+0x134>
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     cba:	7b 2c       	mov	r7, r11
     cbc:	6a 2c       	mov	r6, r10
     cbe:	59 2c       	mov	r5, r9
     cc0:	48 2c       	mov	r4, r8
        output = _max;
    else if( output < _min )
        output = _min;

    // Save error to previous error
    _pre_error = error;
     cc2:	ed 81       	ldd	r30, Y+5	; 0x05
     cc4:	fe 81       	ldd	r31, Y+6	; 0x06
     cc6:	c0 8e       	std	Z+24, r12	; 0x18
     cc8:	d1 8e       	std	Z+25, r13	; 0x19
     cca:	e2 8e       	std	Z+26, r14	; 0x1a
     ccc:	f3 8e       	std	Z+27, r15	; 0x1b

    return output;
}
     cce:	67 2d       	mov	r22, r7
     cd0:	76 2d       	mov	r23, r6
     cd2:	85 2d       	mov	r24, r5
     cd4:	94 2d       	mov	r25, r4
     cd6:	26 96       	adiw	r28, 0x06	; 6
     cd8:	cd bf       	out	0x3d, r28	; 61
     cda:	de bf       	out	0x3e, r29	; 62
     cdc:	df 91       	pop	r29
     cde:	cf 91       	pop	r28
     ce0:	1f 91       	pop	r17
     ce2:	0f 91       	pop	r16
     ce4:	ff 90       	pop	r15
     ce6:	ef 90       	pop	r14
     ce8:	df 90       	pop	r13
     cea:	cf 90       	pop	r12
     cec:	bf 90       	pop	r11
     cee:	af 90       	pop	r10
     cf0:	9f 90       	pop	r9
     cf2:	8f 90       	pop	r8
     cf4:	7f 90       	pop	r7
     cf6:	6f 90       	pop	r6
     cf8:	5f 90       	pop	r5
     cfa:	4f 90       	pop	r4
     cfc:	08 95       	ret

00000cfe <_ZN3PID9calculateEdd>:
PID::PID( double dt, double max, double min, double Kp, double Kd, double Ki )
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
double PID::calculate( double setpoint, double pv )
{
     cfe:	0f 93       	push	r16
     d00:	1f 93       	push	r17
    return pimpl->calculate(setpoint,pv);
     d02:	fc 01       	movw	r30, r24
     d04:	80 81       	ld	r24, Z
     d06:	91 81       	ldd	r25, Z+1	; 0x01
     d08:	0e 94 c7 05 	call	0xb8e	; 0xb8e <_ZN7PIDImpl9calculateEdd>
}
     d0c:	1f 91       	pop	r17
     d0e:	0f 91       	pop	r16
     d10:	08 95       	ret

00000d12 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     d12:	0f 93       	push	r16
     d14:	1f 93       	push	r17
     d16:	cf 93       	push	r28
     d18:	df 93       	push	r29
     d1a:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d1c:	0e 94 4e 14 	call	0x289c	; 0x289c <_ZN8frt_taskC1EPKchjP8emstream>
     d20:	8a e2       	ldi	r24, 0x2A	; 42
     d22:	90 e2       	ldi	r25, 0x20	; 32
     d24:	88 83       	st	Y, r24
     d26:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	1f 91       	pop	r17
     d2e:	0f 91       	pop	r16
     d30:	08 95       	ret

00000d32 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     d32:	0f 93       	push	r16
     d34:	1f 93       	push	r17
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     d3c:	6a e0       	ldi	r22, 0x0A	; 10
     d3e:	8e 81       	ldd	r24, Y+6	; 0x06
     d40:	9f 81       	ldd	r25, Y+7	; 0x07
     d42:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     d46:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     d48:	69 ee       	ldi	r22, 0xE9	; 233
     d4a:	73 e0       	ldi	r23, 0x03	; 3
     d4c:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     d50:	6a e0       	ldi	r22, 0x0A	; 10
     d52:	c8 01       	movw	r24, r16
     d54:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     d58:	8c 01       	movw	r16, r24
     d5a:	63 ee       	ldi	r22, 0xE3	; 227
     d5c:	73 e0       	ldi	r23, 0x03	; 3
     d5e:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     d62:	67 e0       	ldi	r22, 0x07	; 7
     d64:	c8 01       	movw	r24, r16
     d66:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     d6a:	6a e0       	ldi	r22, 0x0A	; 10
     d6c:	8e 81       	ldd	r24, Y+6	; 0x06
     d6e:	9f 81       	ldd	r25, Y+7	; 0x07
     d70:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     d74:	8c 01       	movw	r16, r24
     d76:	64 ec       	ldi	r22, 0xC4	; 196
     d78:	73 e0       	ldi	r23, 0x03	; 3
     d7a:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     d7e:	6a e0       	ldi	r22, 0x0A	; 10
     d80:	c8 01       	movw	r24, r16
     d82:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     d86:	8c 01       	movw	r16, r24
     d88:	6e eb       	ldi	r22, 0xBE	; 190
     d8a:	73 e0       	ldi	r23, 0x03	; 3
     d8c:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     d90:	66 e0       	ldi	r22, 0x06	; 6
     d92:	c8 01       	movw	r24, r16
     d94:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     d98:	6a e0       	ldi	r22, 0x0A	; 10
     d9a:	8e 81       	ldd	r24, Y+6	; 0x06
     d9c:	9f 81       	ldd	r25, Y+7	; 0x07
     d9e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     da2:	8c 01       	movw	r16, r24
     da4:	67 ea       	ldi	r22, 0xA7	; 167
     da6:	73 e0       	ldi	r23, 0x03	; 3
     da8:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     dac:	66 e0       	ldi	r22, 0x06	; 6
     dae:	c8 01       	movw	r24, r16
     db0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     db4:	6a e0       	ldi	r22, 0x0A	; 10
     db6:	8e 81       	ldd	r24, Y+6	; 0x06
     db8:	9f 81       	ldd	r25, Y+7	; 0x07
     dba:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     dbe:	8c 01       	movw	r16, r24
     dc0:	6b e8       	ldi	r22, 0x8B	; 139
     dc2:	73 e0       	ldi	r23, 0x03	; 3
     dc4:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     dc8:	66 e0       	ldi	r22, 0x06	; 6
     dca:	c8 01       	movw	r24, r16
     dcc:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     dd0:	6a e0       	ldi	r22, 0x0A	; 10
     dd2:	8e 81       	ldd	r24, Y+6	; 0x06
     dd4:	9f 81       	ldd	r25, Y+7	; 0x07
     dd6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     dda:	8c 01       	movw	r16, r24
     ddc:	63 e7       	ldi	r22, 0x73	; 115
     dde:	73 e0       	ldi	r23, 0x03	; 3
     de0:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     de4:	66 e0       	ldi	r22, 0x06	; 6
     de6:	c8 01       	movw	r24, r16
     de8:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     dec:	6a e0       	ldi	r22, 0x0A	; 10
     dee:	8e 81       	ldd	r24, Y+6	; 0x06
     df0:	9f 81       	ldd	r25, Y+7	; 0x07
     df2:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     df6:	8c 01       	movw	r16, r24
     df8:	62 e5       	ldi	r22, 0x52	; 82
     dfa:	73 e0       	ldi	r23, 0x03	; 3
     dfc:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     e00:	66 e0       	ldi	r22, 0x06	; 6
     e02:	c8 01       	movw	r24, r16
     e04:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e08:	6a e0       	ldi	r22, 0x0A	; 10
     e0a:	8e 81       	ldd	r24, Y+6	; 0x06
     e0c:	9f 81       	ldd	r25, Y+7	; 0x07
     e0e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     e12:	8c 01       	movw	r16, r24
     e14:	6b e2       	ldi	r22, 0x2B	; 43
     e16:	73 e0       	ldi	r23, 0x03	; 3
     e18:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     e1c:	66 e0       	ldi	r22, 0x06	; 6
     e1e:	c8 01       	movw	r24, r16
     e20:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     e24:	6a e0       	ldi	r22, 0x0A	; 10
     e26:	8e 81       	ldd	r24, Y+6	; 0x06
     e28:	9f 81       	ldd	r25, Y+7	; 0x07
     e2a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     e2e:	8c 01       	movw	r16, r24
     e30:	6d e0       	ldi	r22, 0x0D	; 13
     e32:	73 e0       	ldi	r23, 0x03	; 3
     e34:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     e38:	66 e0       	ldi	r22, 0x06	; 6
     e3a:	c8 01       	movw	r24, r16
     e3c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     e40:	6a e0       	ldi	r22, 0x0A	; 10
     e42:	8e 81       	ldd	r24, Y+6	; 0x06
     e44:	9f 81       	ldd	r25, Y+7	; 0x07
     e46:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     e4a:	8c 01       	movw	r16, r24
     e4c:	62 ef       	ldi	r22, 0xF2	; 242
     e4e:	72 e0       	ldi	r23, 0x02	; 2
     e50:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     e54:	66 e0       	ldi	r22, 0x06	; 6
     e56:	c8 01       	movw	r24, r16
     e58:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     e5c:	6a e0       	ldi	r22, 0x0A	; 10
     e5e:	8e 81       	ldd	r24, Y+6	; 0x06
     e60:	9f 81       	ldd	r25, Y+7	; 0x07
     e62:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     e66:	ec 01       	movw	r28, r24
     e68:	63 ee       	ldi	r22, 0xE3	; 227
     e6a:	72 e0       	ldi	r23, 0x02	; 2
     e6c:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     e70:	66 e0       	ldi	r22, 0x06	; 6
     e72:	ce 01       	movw	r24, r28
     e74:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
}
     e78:	df 91       	pop	r29
     e7a:	cf 91       	pop	r28
     e7c:	1f 91       	pop	r17
     e7e:	0f 91       	pop	r16
     e80:	08 95       	ret

00000e82 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     e82:	af 92       	push	r10
     e84:	bf 92       	push	r11
     e86:	cf 92       	push	r12
     e88:	df 92       	push	r13
     e8a:	ef 92       	push	r14
     e8c:	ff 92       	push	r15
     e8e:	0f 93       	push	r16
     e90:	1f 93       	push	r17
     e92:	cf 93       	push	r28
     e94:	df 93       	push	r29
     e96:	00 d0       	rcall	.+0      	; 0xe98 <_ZN9task_user11show_statusEv+0x16>
     e98:	00 d0       	rcall	.+0      	; 0xe9a <_ZN9task_user11show_statusEv+0x18>
     e9a:	cd b7       	in	r28, 0x3d	; 61
     e9c:	de b7       	in	r29, 0x3e	; 62
     e9e:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     ea0:	19 82       	std	Y+1, r1	; 0x01
     ea2:	1a 82       	std	Y+2, r1	; 0x02
     ea4:	1b 82       	std	Y+3, r1	; 0x03
     ea6:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     ea8:	1d 82       	std	Y+5, r1	; 0x05
     eaa:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     eac:	0e 94 c6 09 	call	0x138c	; 0x138c <xPortGetFreeHeapSize>
     eb0:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     eb2:	ce 01       	movw	r24, r28
     eb4:	01 96       	adiw	r24, 0x01	; 1
     eb6:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <_ZN10time_stamp10set_to_nowEv>
     eba:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     ebc:	66 e0       	ldi	r22, 0x06	; 6
     ebe:	f8 01       	movw	r30, r16
     ec0:	86 81       	ldd	r24, Z+6	; 0x06
     ec2:	97 81       	ldd	r25, Z+7	; 0x07
     ec4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     ec8:	6a e0       	ldi	r22, 0x0A	; 10
     eca:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     ece:	7c 01       	movw	r14, r24
     ed0:	64 ec       	ldi	r22, 0xC4	; 196
     ed2:	72 e0       	ldi	r23, 0x02	; 2
     ed4:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     ed8:	6a e0       	ldi	r22, 0x0A	; 10
     eda:	c7 01       	movw	r24, r14
     edc:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     ee0:	7c 01       	movw	r14, r24
     ee2:	68 eb       	ldi	r22, 0xB8	; 184
     ee4:	72 e0       	ldi	r23, 0x02	; 2
     ee6:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     eea:	66 e0       	ldi	r22, 0x06	; 6
     eec:	c7 01       	movw	r24, r14
     eee:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     ef2:	6a e0       	ldi	r22, 0x0A	; 10
     ef4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     ef8:	7c 01       	movw	r14, r24
     efa:	61 eb       	ldi	r22, 0xB1	; 177
     efc:	72 e0       	ldi	r23, 0x02	; 2
     efe:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     f02:	b5 01       	movw	r22, r10
     f04:	c7 01       	movw	r24, r14
     f06:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f0a:	6a e0       	ldi	r22, 0x0A	; 10
     f0c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     f10:	7c 01       	movw	r14, r24
     f12:	63 ea       	ldi	r22, 0xA3	; 163
     f14:	72 e0       	ldi	r23, 0x02	; 2
     f16:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     f1a:	b6 01       	movw	r22, r12
     f1c:	c7 01       	movw	r24, r14
     f1e:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsEj>
     f22:	6a e0       	ldi	r22, 0x0A	; 10
     f24:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     f28:	7c 01       	movw	r14, r24
     f2a:	61 ea       	ldi	r22, 0xA1	; 161
     f2c:	72 e0       	ldi	r23, 0x02	; 2
     f2e:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     f32:	4f ef       	ldi	r20, 0xFF	; 255
     f34:	5f e0       	ldi	r21, 0x0F	; 15
     f36:	60 e0       	ldi	r22, 0x00	; 0
     f38:	70 e0       	ldi	r23, 0x00	; 0
     f3a:	c7 01       	movw	r24, r14
     f3c:	0e 94 33 1a 	call	0x3466	; 0x3466 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     f40:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     f44:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     f48:	6a e0       	ldi	r22, 0x0A	; 10
     f4a:	f8 01       	movw	r30, r16
     f4c:	86 81       	ldd	r24, Z+6	; 0x06
     f4e:	97 81       	ldd	r25, Z+7	; 0x07
     f50:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     f54:	7c 01       	movw	r14, r24
     f56:	66 e9       	ldi	r22, 0x96	; 150
     f58:	72 e0       	ldi	r23, 0x02	; 2
     f5a:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     f5e:	b6 01       	movw	r22, r12
     f60:	c7 01       	movw	r24, r14
     f62:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsEj>
     f66:	66 e0       	ldi	r22, 0x06	; 6
     f68:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     f6c:	66 e0       	ldi	r22, 0x06	; 6
     f6e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     f72:	f8 01       	movw	r30, r16
     f74:	86 81       	ldd	r24, Z+6	; 0x06
     f76:	97 81       	ldd	r25, Z+7	; 0x07
     f78:	0e 94 5c 16 	call	0x2cb8	; 0x2cb8 <_Z15print_task_listP8emstream>
}
     f7c:	26 96       	adiw	r28, 0x06	; 6
     f7e:	cd bf       	out	0x3d, r28	; 61
     f80:	de bf       	out	0x3e, r29	; 62
     f82:	df 91       	pop	r29
     f84:	cf 91       	pop	r28
     f86:	1f 91       	pop	r17
     f88:	0f 91       	pop	r16
     f8a:	ff 90       	pop	r15
     f8c:	ef 90       	pop	r14
     f8e:	df 90       	pop	r13
     f90:	cf 90       	pop	r12
     f92:	bf 90       	pop	r11
     f94:	af 90       	pop	r10
     f96:	08 95       	ret

00000f98 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <_ZN9task_user3runEv+0x6>
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <_ZN9task_user3runEv+0x8>
     fa0:	cd b7       	in	r28, 0x3d	; 61
     fa2:	de b7       	in	r29, 0x3e	; 62
     fa4:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     fa6:	19 82       	std	Y+1, r1	; 0x01
     fa8:	1a 82       	std	Y+2, r1	; 0x02
     faa:	1b 82       	std	Y+3, r1	; 0x03
     fac:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     fae:	1d 82       	std	Y+5, r1	; 0x05
     fb0:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     fb2:	6a e0       	ldi	r22, 0x0A	; 10
     fb4:	dc 01       	movw	r26, r24
     fb6:	16 96       	adiw	r26, 0x06	; 6
     fb8:	8d 91       	ld	r24, X+
     fba:	9c 91       	ld	r25, X
     fbc:	17 97       	sbiw	r26, 0x07	; 7
     fbe:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
     fc2:	7c 01       	movw	r14, r24
     fc4:	62 e3       	ldi	r22, 0x32	; 50
     fc6:	74 e0       	ldi	r23, 0x04	; 4
     fc8:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
     fcc:	66 e0       	ldi	r22, 0x06	; 6
     fce:	c7 01       	movw	r24, r14
     fd0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     fd4:	f8 01       	movw	r30, r16
     fd6:	84 85       	ldd	r24, Z+12	; 0x0c
     fd8:	88 23       	and	r24, r24
     fda:	21 f0       	breq	.+8      	; 0xfe4 <_ZN9task_user3runEv+0x4c>
     fdc:	81 30       	cpi	r24, 0x01	; 1
     fde:	09 f4       	brne	.+2      	; 0xfe2 <_ZN9task_user3runEv+0x4a>
     fe0:	5d c0       	rjmp	.+186    	; 0x109c <_ZN9task_user3runEv+0x104>
     fe2:	d8 c0       	rjmp	.+432    	; 0x1194 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     fe4:	86 81       	ldd	r24, Z+6	; 0x06
     fe6:	97 81       	ldd	r25, Z+7	; 0x07
     fe8:	dc 01       	movw	r26, r24
     fea:	ed 91       	ld	r30, X+
     fec:	fc 91       	ld	r31, X
     fee:	04 80       	ldd	r0, Z+4	; 0x04
     ff0:	f5 81       	ldd	r31, Z+5	; 0x05
     ff2:	e0 2d       	mov	r30, r0
     ff4:	19 95       	eicall
     ff6:	88 23       	and	r24, r24
     ff8:	a9 f1       	breq	.+106    	; 0x1064 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     ffa:	f8 01       	movw	r30, r16
     ffc:	86 81       	ldd	r24, Z+6	; 0x06
     ffe:	97 81       	ldd	r25, Z+7	; 0x07
    1000:	dc 01       	movw	r26, r24
    1002:	ed 91       	ld	r30, X+
    1004:	fc 91       	ld	r31, X
    1006:	06 80       	ldd	r0, Z+6	; 0x06
    1008:	f7 81       	ldd	r31, Z+7	; 0x07
    100a:	e0 2d       	mov	r30, r0
    100c:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    100e:	99 27       	eor	r25, r25
    1010:	81 30       	cpi	r24, 0x01	; 1
    1012:	91 05       	cpc	r25, r1
    1014:	f9 f0       	breq	.+62     	; 0x1054 <_ZN9task_user3runEv+0xbc>
    1016:	03 97       	sbiw	r24, 0x03	; 3
    1018:	09 f0       	breq	.+2      	; 0x101c <_ZN9task_user3runEv+0x84>
    101a:	d8 c0       	rjmp	.+432    	; 0x11cc <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    101c:	6a e0       	ldi	r22, 0x0A	; 10
    101e:	f8 01       	movw	r30, r16
    1020:	86 81       	ldd	r24, Z+6	; 0x06
    1022:	97 81       	ldd	r25, Z+7	; 0x07
    1024:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    1028:	8c 01       	movw	r16, r24
    102a:	64 e2       	ldi	r22, 0x24	; 36
    102c:	74 e0       	ldi	r23, 0x04	; 4
    102e:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    1032:	66 e0       	ldi	r22, 0x06	; 6
    1034:	c8 01       	movw	r24, r16
    1036:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    103a:	93 e0       	ldi	r25, 0x03	; 3
    103c:	88 ed       	ldi	r24, 0xD8	; 216
    103e:	08 b6       	in	r0, 0x38	; 56
    1040:	18 be       	out	0x38, r1	; 56
    1042:	84 bf       	out	0x34, r24	; 52
    1044:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1048:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    104c:	81 fd       	sbrc	r24, 1
    104e:	fc cf       	rjmp	.-8      	; 0x1048 <_ZN9task_user3runEv+0xb0>
    1050:	08 be       	out	0x38, r0	; 56
    1052:	ff cf       	rjmp	.-2      	; 0x1052 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1054:	c8 01       	movw	r24, r16
    1056:	0e 94 99 06 	call	0xd32	; 0xd32 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    105a:	61 e0       	ldi	r22, 0x01	; 1
    105c:	c8 01       	movw	r24, r16
    105e:	0e 94 4a 14 	call	0x2894	; 0x2894 <_ZN8frt_task13transition_toEh>
							break;
    1062:	b4 c0       	rjmp	.+360    	; 0x11cc <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1064:	82 e4       	ldi	r24, 0x42	; 66
    1066:	91 e3       	ldi	r25, 0x31	; 49
    1068:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <_ZN14frt_text_queue14check_for_charEv>
    106c:	88 23       	and	r24, r24
    106e:	09 f4       	brne	.+2      	; 0x1072 <_ZN9task_user3runEv+0xda>
    1070:	ad c0       	rjmp	.+346    	; 0x11cc <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1072:	d8 01       	movw	r26, r16
    1074:	16 96       	adiw	r26, 0x06	; 6
    1076:	ed 91       	ld	r30, X+
    1078:	fc 91       	ld	r31, X
    107a:	17 97       	sbiw	r26, 0x07	; 7
    107c:	01 90       	ld	r0, Z+
    107e:	f0 81       	ld	r31, Z
    1080:	e0 2d       	mov	r30, r0
    1082:	e2 80       	ldd	r14, Z+2	; 0x02
    1084:	f3 80       	ldd	r15, Z+3	; 0x03
    1086:	82 e4       	ldi	r24, 0x42	; 66
    1088:	91 e3       	ldi	r25, 0x31	; 49
    108a:	0e 94 ed 16 	call	0x2dda	; 0x2dda <_ZN14frt_text_queue7getcharEv>
    108e:	68 2f       	mov	r22, r24
    1090:	f8 01       	movw	r30, r16
    1092:	86 81       	ldd	r24, Z+6	; 0x06
    1094:	97 81       	ldd	r25, Z+7	; 0x07
    1096:	f7 01       	movw	r30, r14
    1098:	19 95       	eicall
    109a:	98 c0       	rjmp	.+304    	; 0x11cc <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    109c:	86 81       	ldd	r24, Z+6	; 0x06
    109e:	97 81       	ldd	r25, Z+7	; 0x07
    10a0:	dc 01       	movw	r26, r24
    10a2:	ed 91       	ld	r30, X+
    10a4:	fc 91       	ld	r31, X
    10a6:	04 80       	ldd	r0, Z+4	; 0x04
    10a8:	f5 81       	ldd	r31, Z+5	; 0x05
    10aa:	e0 2d       	mov	r30, r0
    10ac:	19 95       	eicall
    10ae:	88 23       	and	r24, r24
    10b0:	09 f4       	brne	.+2      	; 0x10b4 <_ZN9task_user3runEv+0x11c>
    10b2:	8c c0       	rjmp	.+280    	; 0x11cc <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    10b4:	f8 01       	movw	r30, r16
    10b6:	86 81       	ldd	r24, Z+6	; 0x06
    10b8:	97 81       	ldd	r25, Z+7	; 0x07
    10ba:	dc 01       	movw	r26, r24
    10bc:	ed 91       	ld	r30, X+
    10be:	fc 91       	ld	r31, X
    10c0:	06 80       	ldd	r0, Z+6	; 0x06
    10c2:	f7 81       	ldd	r31, Z+7	; 0x07
    10c4:	e0 2d       	mov	r30, r0
    10c6:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    10c8:	9c 01       	movw	r18, r24
    10ca:	33 27       	eor	r19, r19
    10cc:	28 36       	cpi	r18, 0x68	; 104
    10ce:	31 05       	cpc	r19, r1
    10d0:	59 f1       	breq	.+86     	; 0x1128 <_ZN9task_user3runEv+0x190>
    10d2:	3c f4       	brge	.+14     	; 0x10e2 <_ZN9task_user3runEv+0x14a>
    10d4:	2b 31       	cpi	r18, 0x1B	; 27
    10d6:	31 05       	cpc	r19, r1
    10d8:	59 f1       	breq	.+86     	; 0x1130 <_ZN9task_user3runEv+0x198>
    10da:	25 36       	cpi	r18, 0x65	; 101
    10dc:	31 05       	cpc	r19, r1
    10de:	41 f1       	breq	.+80     	; 0x1130 <_ZN9task_user3runEv+0x198>
    10e0:	3b c0       	rjmp	.+118    	; 0x1158 <_ZN9task_user3runEv+0x1c0>
    10e2:	23 37       	cpi	r18, 0x73	; 115
    10e4:	31 05       	cpc	r19, r1
    10e6:	c1 f0       	breq	.+48     	; 0x1118 <_ZN9task_user3runEv+0x180>
    10e8:	26 37       	cpi	r18, 0x76	; 118
    10ea:	31 05       	cpc	r19, r1
    10ec:	89 f0       	breq	.+34     	; 0x1110 <_ZN9task_user3runEv+0x178>
    10ee:	2e 36       	cpi	r18, 0x6E	; 110
    10f0:	31 05       	cpc	r19, r1
    10f2:	91 f5       	brne	.+100    	; 0x1158 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    10f4:	ce 01       	movw	r24, r28
    10f6:	01 96       	adiw	r24, 0x01	; 1
    10f8:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <_ZN10time_stamp10set_to_nowEv>
    10fc:	bc 01       	movw	r22, r24
    10fe:	f8 01       	movw	r30, r16
    1100:	86 81       	ldd	r24, Z+6	; 0x06
    1102:	97 81       	ldd	r25, Z+7	; 0x07
    1104:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <_ZlsR8emstreamR10time_stamp>
    1108:	66 e0       	ldi	r22, 0x06	; 6
    110a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
							break;
    110e:	5e c0       	rjmp	.+188    	; 0x11cc <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1110:	c8 01       	movw	r24, r16
    1112:	0e 94 41 07 	call	0xe82	; 0xe82 <_ZN9task_user11show_statusEv>
							break;
    1116:	5a c0       	rjmp	.+180    	; 0x11cc <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1118:	d8 01       	movw	r26, r16
    111a:	16 96       	adiw	r26, 0x06	; 6
    111c:	8d 91       	ld	r24, X+
    111e:	9c 91       	ld	r25, X
    1120:	17 97       	sbiw	r26, 0x07	; 7
    1122:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <_Z17print_task_stacksP8emstream>
							break;
    1126:	52 c0       	rjmp	.+164    	; 0x11cc <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1128:	c8 01       	movw	r24, r16
    112a:	0e 94 99 06 	call	0xd32	; 0xd32 <_ZN9task_user18print_help_messageEv>
							break;
    112e:	4e c0       	rjmp	.+156    	; 0x11cc <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1130:	6a e0       	ldi	r22, 0x0A	; 10
    1132:	f8 01       	movw	r30, r16
    1134:	86 81       	ldd	r24, Z+6	; 0x06
    1136:	97 81       	ldd	r25, Z+7	; 0x07
    1138:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    113c:	7c 01       	movw	r14, r24
    113e:	62 e1       	ldi	r22, 0x12	; 18
    1140:	74 e0       	ldi	r23, 0x04	; 4
    1142:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    1146:	66 e0       	ldi	r22, 0x06	; 6
    1148:	c7 01       	movw	r24, r14
    114a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    114e:	60 e0       	ldi	r22, 0x00	; 0
    1150:	c8 01       	movw	r24, r16
    1152:	0e 94 4a 14 	call	0x2894	; 0x2894 <_ZN8frt_task13transition_toEh>
							break;
    1156:	3a c0       	rjmp	.+116    	; 0x11cc <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1158:	f8 01       	movw	r30, r16
    115a:	a6 81       	ldd	r26, Z+6	; 0x06
    115c:	b7 81       	ldd	r27, Z+7	; 0x07
    115e:	ed 91       	ld	r30, X+
    1160:	fc 91       	ld	r31, X
    1162:	11 97       	sbiw	r26, 0x01	; 1
    1164:	02 80       	ldd	r0, Z+2	; 0x02
    1166:	f3 81       	ldd	r31, Z+3	; 0x03
    1168:	e0 2d       	mov	r30, r0
    116a:	68 2f       	mov	r22, r24
    116c:	cd 01       	movw	r24, r26
    116e:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1170:	6a e0       	ldi	r22, 0x0A	; 10
    1172:	d8 01       	movw	r26, r16
    1174:	16 96       	adiw	r26, 0x06	; 6
    1176:	8d 91       	ld	r24, X+
    1178:	9c 91       	ld	r25, X
    117a:	17 97       	sbiw	r26, 0x07	; 7
    117c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    1180:	7c 01       	movw	r14, r24
    1182:	6c e0       	ldi	r22, 0x0C	; 12
    1184:	74 e0       	ldi	r23, 0x04	; 4
    1186:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    118a:	66 e0       	ldi	r22, 0x06	; 6
    118c:	c7 01       	movw	r24, r14
    118e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1192:	1c c0       	rjmp	.+56     	; 0x11cc <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1194:	6a e0       	ldi	r22, 0x0A	; 10
    1196:	f8 01       	movw	r30, r16
    1198:	86 81       	ldd	r24, Z+6	; 0x06
    119a:	97 81       	ldd	r25, Z+7	; 0x07
    119c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    11a0:	8c 01       	movw	r16, r24
    11a2:	6f ee       	ldi	r22, 0xEF	; 239
    11a4:	73 e0       	ldi	r23, 0x03	; 3
    11a6:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    11aa:	66 e0       	ldi	r22, 0x06	; 6
    11ac:	c8 01       	movw	r24, r16
    11ae:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    11b2:	93 e0       	ldi	r25, 0x03	; 3
    11b4:	88 ed       	ldi	r24, 0xD8	; 216
    11b6:	08 b6       	in	r0, 0x38	; 56
    11b8:	18 be       	out	0x38, r1	; 56
    11ba:	84 bf       	out	0x34, r24	; 52
    11bc:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    11c0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    11c4:	81 fd       	sbrc	r24, 1
    11c6:	fc cf       	rjmp	.-8      	; 0x11c0 <_ZN9task_user3runEv+0x228>
    11c8:	08 be       	out	0x38, r0	; 56
    11ca:	ff cf       	rjmp	.-2      	; 0x11ca <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    11cc:	f8 01       	movw	r30, r16
    11ce:	86 85       	ldd	r24, Z+14	; 0x0e
    11d0:	97 85       	ldd	r25, Z+15	; 0x0f
    11d2:	a0 89       	ldd	r26, Z+16	; 0x10
    11d4:	b1 89       	ldd	r27, Z+17	; 0x11
    11d6:	01 96       	adiw	r24, 0x01	; 1
    11d8:	a1 1d       	adc	r26, r1
    11da:	b1 1d       	adc	r27, r1
    11dc:	86 87       	std	Z+14, r24	; 0x0e
    11de:	97 87       	std	Z+15, r25	; 0x0f
    11e0:	a0 8b       	std	Z+16, r26	; 0x10
    11e2:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    11e4:	61 e0       	ldi	r22, 0x01	; 1
    11e6:	70 e0       	ldi	r23, 0x00	; 0
    11e8:	80 e0       	ldi	r24, 0x00	; 0
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	0e 94 1e 12 	call	0x243c	; 0x243c <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    11f0:	f1 ce       	rjmp	.-542    	; 0xfd4 <_ZN9task_user3runEv+0x3c>

000011f2 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    11f2:	0f 93       	push	r16
    11f4:	1f 93       	push	r17
    11f6:	cf 93       	push	r28
    11f8:	df 93       	push	r29
    11fa:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    11fc:	0e 94 0d 10 	call	0x201a	; 0x201a <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1200:	80 91 b0 20 	lds	r24, 0x20B0	; 0x8020b0 <__data_end>
    1204:	81 11       	cpse	r24, r1
    1206:	1d c0       	rjmp	.+58     	; 0x1242 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1208:	a5 eb       	ldi	r26, 0xB5	; 181
    120a:	b0 e2       	ldi	r27, 0x20	; 32
    120c:	e9 eb       	ldi	r30, 0xB9	; 185
    120e:	f0 e2       	ldi	r31, 0x20	; 32
    1210:	ed 93       	st	X+, r30
    1212:	fc 93       	st	X, r31
    1214:	11 97       	sbiw	r26, 0x01	; 1
    1216:	12 96       	adiw	r26, 0x02	; 2
    1218:	1d 92       	st	X+, r1
    121a:	1c 92       	st	X, r1
    121c:	13 97       	sbiw	r26, 0x03	; 3
    121e:	a1 eb       	ldi	r26, 0xB1	; 177
    1220:	b0 e2       	ldi	r27, 0x20	; 32
    1222:	8f ef       	ldi	r24, 0xFF	; 255
    1224:	9f e0       	ldi	r25, 0x0F	; 15
    1226:	12 96       	adiw	r26, 0x02	; 2
    1228:	8d 93       	st	X+, r24
    122a:	9c 93       	st	X, r25
    122c:	13 97       	sbiw	r26, 0x03	; 3
    122e:	1d 92       	st	X+, r1
    1230:	1c 92       	st	X, r1
    1232:	11 97       	sbiw	r26, 0x01	; 1
    1234:	82 83       	std	Z+2, r24	; 0x02
    1236:	93 83       	std	Z+3, r25	; 0x03
    1238:	a0 83       	st	Z, r26
    123a:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	80 93 b0 20 	sts	0x20B0, r24	; 0x8020b0 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1242:	20 97       	sbiw	r28, 0x00	; 0
    1244:	09 f4       	brne	.+2      	; 0x1248 <pvPortMalloc+0x56>
    1246:	5f c0       	rjmp	.+190    	; 0x1306 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1248:	9e 01       	movw	r18, r28
    124a:	2b 5f       	subi	r18, 0xFB	; 251
    124c:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    124e:	24 96       	adiw	r28, 0x04	; 4
    1250:	ce 3f       	cpi	r28, 0xFE	; 254
    1252:	df 40       	sbci	r29, 0x0F	; 15
    1254:	08 f0       	brcs	.+2      	; 0x1258 <pvPortMalloc+0x66>
    1256:	5a c0       	rjmp	.+180    	; 0x130c <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1258:	e0 91 b5 20 	lds	r30, 0x20B5	; 0x8020b5 <xStart>
    125c:	f0 91 b6 20 	lds	r31, 0x20B6	; 0x8020b6 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1260:	a5 eb       	ldi	r26, 0xB5	; 181
    1262:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1264:	02 c0       	rjmp	.+4      	; 0x126a <pvPortMalloc+0x78>
    1266:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1268:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    126a:	82 81       	ldd	r24, Z+2	; 0x02
    126c:	93 81       	ldd	r25, Z+3	; 0x03
    126e:	82 17       	cp	r24, r18
    1270:	93 07       	cpc	r25, r19
    1272:	20 f4       	brcc	.+8      	; 0x127c <pvPortMalloc+0x8a>
    1274:	80 81       	ld	r24, Z
    1276:	91 81       	ldd	r25, Z+1	; 0x01
    1278:	00 97       	sbiw	r24, 0x00	; 0
    127a:	a9 f7       	brne	.-22     	; 0x1266 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    127c:	c0 e2       	ldi	r28, 0x20	; 32
    127e:	e1 3b       	cpi	r30, 0xB1	; 177
    1280:	fc 07       	cpc	r31, r28
    1282:	09 f4       	brne	.+2      	; 0x1286 <pvPortMalloc+0x94>
    1284:	46 c0       	rjmp	.+140    	; 0x1312 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1286:	cd 91       	ld	r28, X+
    1288:	dc 91       	ld	r29, X
    128a:	11 97       	sbiw	r26, 0x01	; 1
    128c:	8e 01       	movw	r16, r28
    128e:	0b 5f       	subi	r16, 0xFB	; 251
    1290:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1292:	80 81       	ld	r24, Z
    1294:	91 81       	ldd	r25, Z+1	; 0x01
    1296:	8d 93       	st	X+, r24
    1298:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    129a:	82 81       	ldd	r24, Z+2	; 0x02
    129c:	93 81       	ldd	r25, Z+3	; 0x03
    129e:	82 1b       	sub	r24, r18
    12a0:	93 0b       	sbc	r25, r19
    12a2:	8b 30       	cpi	r24, 0x0B	; 11
    12a4:	91 05       	cpc	r25, r1
    12a6:	10 f1       	brcs	.+68     	; 0x12ec <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    12a8:	bf 01       	movw	r22, r30
    12aa:	62 0f       	add	r22, r18
    12ac:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    12ae:	db 01       	movw	r26, r22
    12b0:	12 96       	adiw	r26, 0x02	; 2
    12b2:	8d 93       	st	X+, r24
    12b4:	9c 93       	st	X, r25
    12b6:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    12b8:	22 83       	std	Z+2, r18	; 0x02
    12ba:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    12bc:	12 96       	adiw	r26, 0x02	; 2
    12be:	4d 91       	ld	r20, X+
    12c0:	5c 91       	ld	r21, X
    12c2:	13 97       	sbiw	r26, 0x03	; 3
    12c4:	85 eb       	ldi	r24, 0xB5	; 181
    12c6:	90 e2       	ldi	r25, 0x20	; 32
    12c8:	01 c0       	rjmp	.+2      	; 0x12cc <pvPortMalloc+0xda>
    12ca:	cd 01       	movw	r24, r26
    12cc:	ec 01       	movw	r28, r24
    12ce:	a8 81       	ld	r26, Y
    12d0:	b9 81       	ldd	r27, Y+1	; 0x01
    12d2:	12 96       	adiw	r26, 0x02	; 2
    12d4:	2d 91       	ld	r18, X+
    12d6:	3c 91       	ld	r19, X
    12d8:	13 97       	sbiw	r26, 0x03	; 3
    12da:	24 17       	cp	r18, r20
    12dc:	35 07       	cpc	r19, r21
    12de:	a8 f3       	brcs	.-22     	; 0x12ca <pvPortMalloc+0xd8>
    12e0:	eb 01       	movw	r28, r22
    12e2:	a8 83       	st	Y, r26
    12e4:	b9 83       	std	Y+1, r27	; 0x01
    12e6:	dc 01       	movw	r26, r24
    12e8:	6d 93       	st	X+, r22
    12ea:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    12ec:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    12f0:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    12f4:	22 81       	ldd	r18, Z+2	; 0x02
    12f6:	33 81       	ldd	r19, Z+3	; 0x03
    12f8:	82 1b       	sub	r24, r18
    12fa:	93 0b       	sbc	r25, r19
    12fc:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1300:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1304:	08 c0       	rjmp	.+16     	; 0x1316 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1306:	00 e0       	ldi	r16, 0x00	; 0
    1308:	10 e0       	ldi	r17, 0x00	; 0
    130a:	05 c0       	rjmp	.+10     	; 0x1316 <pvPortMalloc+0x124>
    130c:	00 e0       	ldi	r16, 0x00	; 0
    130e:	10 e0       	ldi	r17, 0x00	; 0
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <pvPortMalloc+0x124>
    1312:	00 e0       	ldi	r16, 0x00	; 0
    1314:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1316:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    131a:	c8 01       	movw	r24, r16
    131c:	df 91       	pop	r29
    131e:	cf 91       	pop	r28
    1320:	1f 91       	pop	r17
    1322:	0f 91       	pop	r16
    1324:	08 95       	ret

00001326 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1326:	0f 93       	push	r16
    1328:	1f 93       	push	r17
    132a:	cf 93       	push	r28
    132c:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    132e:	00 97       	sbiw	r24, 0x00	; 0
    1330:	41 f1       	breq	.+80     	; 0x1382 <vPortFree+0x5c>
    1332:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1334:	8c 01       	movw	r16, r24
    1336:	05 50       	subi	r16, 0x05	; 5
    1338:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    133a:	0e 94 0d 10 	call	0x201a	; 0x201a <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    133e:	f8 01       	movw	r30, r16
    1340:	42 81       	ldd	r20, Z+2	; 0x02
    1342:	53 81       	ldd	r21, Z+3	; 0x03
    1344:	a5 eb       	ldi	r26, 0xB5	; 181
    1346:	b0 e2       	ldi	r27, 0x20	; 32
    1348:	01 c0       	rjmp	.+2      	; 0x134c <vPortFree+0x26>
    134a:	df 01       	movw	r26, r30
    134c:	ed 91       	ld	r30, X+
    134e:	fc 91       	ld	r31, X
    1350:	11 97       	sbiw	r26, 0x01	; 1
    1352:	22 81       	ldd	r18, Z+2	; 0x02
    1354:	33 81       	ldd	r19, Z+3	; 0x03
    1356:	24 17       	cp	r18, r20
    1358:	35 07       	cpc	r19, r21
    135a:	b8 f3       	brcs	.-18     	; 0x134a <vPortFree+0x24>
    135c:	25 97       	sbiw	r28, 0x05	; 5
    135e:	e8 83       	st	Y, r30
    1360:	f9 83       	std	Y+1, r31	; 0x01
    1362:	0d 93       	st	X+, r16
    1364:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1366:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    136a:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    136e:	8a 81       	ldd	r24, Y+2	; 0x02
    1370:	9b 81       	ldd	r25, Y+3	; 0x03
    1372:	82 0f       	add	r24, r18
    1374:	93 1f       	adc	r25, r19
    1376:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    137a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    137e:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
	}
}
    1382:	df 91       	pop	r29
    1384:	cf 91       	pop	r28
    1386:	1f 91       	pop	r17
    1388:	0f 91       	pop	r16
    138a:	08 95       	ret

0000138c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    138c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1390:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1394:	08 95       	ret

00001396 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1396:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1398:	03 96       	adiw	r24, 0x03	; 3
    139a:	81 83       	std	Z+1, r24	; 0x01
    139c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    139e:	4f ef       	ldi	r20, 0xFF	; 255
    13a0:	5f ef       	ldi	r21, 0xFF	; 255
    13a2:	ba 01       	movw	r22, r20
    13a4:	43 83       	std	Z+3, r20	; 0x03
    13a6:	54 83       	std	Z+4, r21	; 0x04
    13a8:	65 83       	std	Z+5, r22	; 0x05
    13aa:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    13ac:	87 83       	std	Z+7, r24	; 0x07
    13ae:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    13b0:	81 87       	std	Z+9, r24	; 0x09
    13b2:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    13b4:	10 82       	st	Z, r1
    13b6:	08 95       	ret

000013b8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    13b8:	fc 01       	movw	r30, r24
    13ba:	12 86       	std	Z+10, r1	; 0x0a
    13bc:	13 86       	std	Z+11, r1	; 0x0b
    13be:	08 95       	ret

000013c0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    13c0:	cf 93       	push	r28
    13c2:	df 93       	push	r29
    13c4:	fc 01       	movw	r30, r24
    13c6:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    13c8:	21 81       	ldd	r18, Z+1	; 0x01
    13ca:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    13cc:	e9 01       	movw	r28, r18
    13ce:	8c 81       	ldd	r24, Y+4	; 0x04
    13d0:	9d 81       	ldd	r25, Y+5	; 0x05
    13d2:	14 96       	adiw	r26, 0x04	; 4
    13d4:	8d 93       	st	X+, r24
    13d6:	9c 93       	st	X, r25
    13d8:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    13da:	81 81       	ldd	r24, Z+1	; 0x01
    13dc:	92 81       	ldd	r25, Z+2	; 0x02
    13de:	16 96       	adiw	r26, 0x06	; 6
    13e0:	8d 93       	st	X+, r24
    13e2:	9c 93       	st	X, r25
    13e4:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    13e6:	8c 81       	ldd	r24, Y+4	; 0x04
    13e8:	9d 81       	ldd	r25, Y+5	; 0x05
    13ea:	ec 01       	movw	r28, r24
    13ec:	6e 83       	std	Y+6, r22	; 0x06
    13ee:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    13f0:	e9 01       	movw	r28, r18
    13f2:	6c 83       	std	Y+4, r22	; 0x04
    13f4:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    13f6:	61 83       	std	Z+1, r22	; 0x01
    13f8:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    13fa:	1a 96       	adiw	r26, 0x0a	; 10
    13fc:	ed 93       	st	X+, r30
    13fe:	fc 93       	st	X, r31
    1400:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1402:	80 81       	ld	r24, Z
    1404:	8f 5f       	subi	r24, 0xFF	; 255
    1406:	80 83       	st	Z, r24
}
    1408:	df 91       	pop	r29
    140a:	cf 91       	pop	r28
    140c:	08 95       	ret

0000140e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    140e:	0f 93       	push	r16
    1410:	1f 93       	push	r17
    1412:	cf 93       	push	r28
    1414:	df 93       	push	r29
    1416:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1418:	08 81       	ld	r16, Y
    141a:	19 81       	ldd	r17, Y+1	; 0x01
    141c:	2a 81       	ldd	r18, Y+2	; 0x02
    141e:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1420:	0f 3f       	cpi	r16, 0xFF	; 255
    1422:	4f ef       	ldi	r20, 0xFF	; 255
    1424:	14 07       	cpc	r17, r20
    1426:	24 07       	cpc	r18, r20
    1428:	34 07       	cpc	r19, r20
    142a:	31 f4       	brne	.+12     	; 0x1438 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    142c:	dc 01       	movw	r26, r24
    142e:	19 96       	adiw	r26, 0x09	; 9
    1430:	ed 91       	ld	r30, X+
    1432:	fc 91       	ld	r31, X
    1434:	1a 97       	sbiw	r26, 0x0a	; 10
    1436:	1f c0       	rjmp	.+62     	; 0x1476 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1438:	fc 01       	movw	r30, r24
    143a:	33 96       	adiw	r30, 0x03	; 3
    143c:	dc 01       	movw	r26, r24
    143e:	17 96       	adiw	r26, 0x07	; 7
    1440:	4d 91       	ld	r20, X+
    1442:	5c 91       	ld	r21, X
    1444:	18 97       	sbiw	r26, 0x08	; 8
    1446:	da 01       	movw	r26, r20
    1448:	4d 91       	ld	r20, X+
    144a:	5d 91       	ld	r21, X+
    144c:	6d 91       	ld	r22, X+
    144e:	7c 91       	ld	r23, X
    1450:	04 17       	cp	r16, r20
    1452:	15 07       	cpc	r17, r21
    1454:	26 07       	cpc	r18, r22
    1456:	37 07       	cpc	r19, r23
    1458:	70 f0       	brcs	.+28     	; 0x1476 <vListInsert+0x68>
    145a:	04 80       	ldd	r0, Z+4	; 0x04
    145c:	f5 81       	ldd	r31, Z+5	; 0x05
    145e:	e0 2d       	mov	r30, r0
    1460:	a4 81       	ldd	r26, Z+4	; 0x04
    1462:	b5 81       	ldd	r27, Z+5	; 0x05
    1464:	4d 91       	ld	r20, X+
    1466:	5d 91       	ld	r21, X+
    1468:	6d 91       	ld	r22, X+
    146a:	7c 91       	ld	r23, X
    146c:	04 17       	cp	r16, r20
    146e:	15 07       	cpc	r17, r21
    1470:	26 07       	cpc	r18, r22
    1472:	37 07       	cpc	r19, r23
    1474:	90 f7       	brcc	.-28     	; 0x145a <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1476:	a4 81       	ldd	r26, Z+4	; 0x04
    1478:	b5 81       	ldd	r27, Z+5	; 0x05
    147a:	ac 83       	std	Y+4, r26	; 0x04
    147c:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    147e:	16 96       	adiw	r26, 0x06	; 6
    1480:	cd 93       	st	X+, r28
    1482:	dc 93       	st	X, r29
    1484:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1486:	ee 83       	std	Y+6, r30	; 0x06
    1488:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    148a:	c4 83       	std	Z+4, r28	; 0x04
    148c:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    148e:	8a 87       	std	Y+10, r24	; 0x0a
    1490:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1492:	fc 01       	movw	r30, r24
    1494:	20 81       	ld	r18, Z
    1496:	2f 5f       	subi	r18, 0xFF	; 255
    1498:	20 83       	st	Z, r18
}
    149a:	df 91       	pop	r29
    149c:	cf 91       	pop	r28
    149e:	1f 91       	pop	r17
    14a0:	0f 91       	pop	r16
    14a2:	08 95       	ret

000014a4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    14a4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    14a6:	a4 81       	ldd	r26, Z+4	; 0x04
    14a8:	b5 81       	ldd	r27, Z+5	; 0x05
    14aa:	86 81       	ldd	r24, Z+6	; 0x06
    14ac:	97 81       	ldd	r25, Z+7	; 0x07
    14ae:	16 96       	adiw	r26, 0x06	; 6
    14b0:	8d 93       	st	X+, r24
    14b2:	9c 93       	st	X, r25
    14b4:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    14b6:	a6 81       	ldd	r26, Z+6	; 0x06
    14b8:	b7 81       	ldd	r27, Z+7	; 0x07
    14ba:	84 81       	ldd	r24, Z+4	; 0x04
    14bc:	95 81       	ldd	r25, Z+5	; 0x05
    14be:	14 96       	adiw	r26, 0x04	; 4
    14c0:	8d 93       	st	X+, r24
    14c2:	9c 93       	st	X, r25
    14c4:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    14c6:	a2 85       	ldd	r26, Z+10	; 0x0a
    14c8:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    14ca:	11 96       	adiw	r26, 0x01	; 1
    14cc:	8d 91       	ld	r24, X+
    14ce:	9c 91       	ld	r25, X
    14d0:	12 97       	sbiw	r26, 0x02	; 2
    14d2:	e8 17       	cp	r30, r24
    14d4:	f9 07       	cpc	r31, r25
    14d6:	31 f4       	brne	.+12     	; 0x14e4 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    14d8:	86 81       	ldd	r24, Z+6	; 0x06
    14da:	97 81       	ldd	r25, Z+7	; 0x07
    14dc:	11 96       	adiw	r26, 0x01	; 1
    14de:	8d 93       	st	X+, r24
    14e0:	9c 93       	st	X, r25
    14e2:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    14e4:	12 86       	std	Z+10, r1	; 0x0a
    14e6:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    14e8:	8c 91       	ld	r24, X
    14ea:	81 50       	subi	r24, 0x01	; 1
    14ec:	8c 93       	st	X, r24
    14ee:	08 95       	ret

000014f0 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    14f0:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <portStackTopForTask>
    14f4:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <portStackTopForTask+0x1>
    14f8:	31 e1       	ldi	r19, 0x11	; 17
    14fa:	fc 01       	movw	r30, r24
    14fc:	30 83       	st	Z, r19
    14fe:	31 97       	sbiw	r30, 0x01	; 1
    1500:	22 e2       	ldi	r18, 0x22	; 34
    1502:	20 83       	st	Z, r18
    1504:	31 97       	sbiw	r30, 0x01	; 1
    1506:	a3 e3       	ldi	r26, 0x33	; 51
    1508:	a0 83       	st	Z, r26
    150a:	31 97       	sbiw	r30, 0x01	; 1
    150c:	60 83       	st	Z, r22
    150e:	31 97       	sbiw	r30, 0x01	; 1
    1510:	70 83       	st	Z, r23
    1512:	31 97       	sbiw	r30, 0x01	; 1
    1514:	10 82       	st	Z, r1
    1516:	31 97       	sbiw	r30, 0x01	; 1
    1518:	10 82       	st	Z, r1
    151a:	31 97       	sbiw	r30, 0x01	; 1
    151c:	60 e8       	ldi	r22, 0x80	; 128
    151e:	60 83       	st	Z, r22
    1520:	31 97       	sbiw	r30, 0x01	; 1
    1522:	10 82       	st	Z, r1
    1524:	31 97       	sbiw	r30, 0x01	; 1
    1526:	10 82       	st	Z, r1
    1528:	31 97       	sbiw	r30, 0x01	; 1
    152a:	10 82       	st	Z, r1
    152c:	31 97       	sbiw	r30, 0x01	; 1
    152e:	62 e0       	ldi	r22, 0x02	; 2
    1530:	60 83       	st	Z, r22
    1532:	31 97       	sbiw	r30, 0x01	; 1
    1534:	63 e0       	ldi	r22, 0x03	; 3
    1536:	60 83       	st	Z, r22
    1538:	31 97       	sbiw	r30, 0x01	; 1
    153a:	64 e0       	ldi	r22, 0x04	; 4
    153c:	60 83       	st	Z, r22
    153e:	31 97       	sbiw	r30, 0x01	; 1
    1540:	65 e0       	ldi	r22, 0x05	; 5
    1542:	60 83       	st	Z, r22
    1544:	31 97       	sbiw	r30, 0x01	; 1
    1546:	66 e0       	ldi	r22, 0x06	; 6
    1548:	60 83       	st	Z, r22
    154a:	31 97       	sbiw	r30, 0x01	; 1
    154c:	67 e0       	ldi	r22, 0x07	; 7
    154e:	60 83       	st	Z, r22
    1550:	31 97       	sbiw	r30, 0x01	; 1
    1552:	68 e0       	ldi	r22, 0x08	; 8
    1554:	60 83       	st	Z, r22
    1556:	31 97       	sbiw	r30, 0x01	; 1
    1558:	69 e0       	ldi	r22, 0x09	; 9
    155a:	60 83       	st	Z, r22
    155c:	31 97       	sbiw	r30, 0x01	; 1
    155e:	60 e1       	ldi	r22, 0x10	; 16
    1560:	60 83       	st	Z, r22
    1562:	31 97       	sbiw	r30, 0x01	; 1
    1564:	30 83       	st	Z, r19
    1566:	31 97       	sbiw	r30, 0x01	; 1
    1568:	32 e1       	ldi	r19, 0x12	; 18
    156a:	30 83       	st	Z, r19
    156c:	31 97       	sbiw	r30, 0x01	; 1
    156e:	33 e1       	ldi	r19, 0x13	; 19
    1570:	30 83       	st	Z, r19
    1572:	31 97       	sbiw	r30, 0x01	; 1
    1574:	34 e1       	ldi	r19, 0x14	; 20
    1576:	30 83       	st	Z, r19
    1578:	31 97       	sbiw	r30, 0x01	; 1
    157a:	35 e1       	ldi	r19, 0x15	; 21
    157c:	30 83       	st	Z, r19
    157e:	31 97       	sbiw	r30, 0x01	; 1
    1580:	36 e1       	ldi	r19, 0x16	; 22
    1582:	30 83       	st	Z, r19
    1584:	31 97       	sbiw	r30, 0x01	; 1
    1586:	37 e1       	ldi	r19, 0x17	; 23
    1588:	30 83       	st	Z, r19
    158a:	31 97       	sbiw	r30, 0x01	; 1
    158c:	38 e1       	ldi	r19, 0x18	; 24
    158e:	30 83       	st	Z, r19
    1590:	31 97       	sbiw	r30, 0x01	; 1
    1592:	39 e1       	ldi	r19, 0x19	; 25
    1594:	30 83       	st	Z, r19
    1596:	31 97       	sbiw	r30, 0x01	; 1
    1598:	30 e2       	ldi	r19, 0x20	; 32
    159a:	30 83       	st	Z, r19
    159c:	31 97       	sbiw	r30, 0x01	; 1
    159e:	31 e2       	ldi	r19, 0x21	; 33
    15a0:	30 83       	st	Z, r19
    15a2:	31 97       	sbiw	r30, 0x01	; 1
    15a4:	20 83       	st	Z, r18
    15a6:	31 97       	sbiw	r30, 0x01	; 1
    15a8:	23 e2       	ldi	r18, 0x23	; 35
    15aa:	20 83       	st	Z, r18
    15ac:	31 97       	sbiw	r30, 0x01	; 1
    15ae:	40 83       	st	Z, r20
    15b0:	31 97       	sbiw	r30, 0x01	; 1
    15b2:	50 83       	st	Z, r21
    15b4:	31 97       	sbiw	r30, 0x01	; 1
    15b6:	26 e2       	ldi	r18, 0x26	; 38
    15b8:	20 83       	st	Z, r18
    15ba:	31 97       	sbiw	r30, 0x01	; 1
    15bc:	27 e2       	ldi	r18, 0x27	; 39
    15be:	20 83       	st	Z, r18
    15c0:	31 97       	sbiw	r30, 0x01	; 1
    15c2:	28 e2       	ldi	r18, 0x28	; 40
    15c4:	20 83       	st	Z, r18
    15c6:	31 97       	sbiw	r30, 0x01	; 1
    15c8:	29 e2       	ldi	r18, 0x29	; 41
    15ca:	20 83       	st	Z, r18
    15cc:	31 97       	sbiw	r30, 0x01	; 1
    15ce:	20 e3       	ldi	r18, 0x30	; 48
    15d0:	20 83       	st	Z, r18
    15d2:	31 97       	sbiw	r30, 0x01	; 1
    15d4:	21 e3       	ldi	r18, 0x31	; 49
    15d6:	20 83       	st	Z, r18
    15d8:	89 97       	sbiw	r24, 0x29	; 41
    15da:	08 95       	ret

000015dc <xPortStartScheduler>:
    15dc:	8c e7       	ldi	r24, 0x7C	; 124
    15de:	80 93 29 08 	sts	0x0829, r24	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    15e2:	8f ef       	ldi	r24, 0xFF	; 255
    15e4:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    15e8:	81 e0       	ldi	r24, 0x01	; 1
    15ea:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    15ee:	91 e1       	ldi	r25, 0x11	; 17
    15f0:	90 93 01 08 	sts	0x0801, r25	; 0x800801 <__TEXT_REGION_LENGTH__+0x700801>
    15f4:	80 93 07 08 	sts	0x0807, r24	; 0x800807 <__TEXT_REGION_LENGTH__+0x700807>
    15f8:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    15fc:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1600:	cd 91       	ld	r28, X+
    1602:	cd bf       	out	0x3d, r28	; 61
    1604:	dd 91       	ld	r29, X+
    1606:	de bf       	out	0x3e, r29	; 62
    1608:	ff 91       	pop	r31
    160a:	ef 91       	pop	r30
    160c:	df 91       	pop	r29
    160e:	cf 91       	pop	r28
    1610:	bf 91       	pop	r27
    1612:	af 91       	pop	r26
    1614:	9f 91       	pop	r25
    1616:	8f 91       	pop	r24
    1618:	7f 91       	pop	r23
    161a:	6f 91       	pop	r22
    161c:	5f 91       	pop	r21
    161e:	4f 91       	pop	r20
    1620:	3f 91       	pop	r19
    1622:	2f 91       	pop	r18
    1624:	1f 91       	pop	r17
    1626:	0f 91       	pop	r16
    1628:	ff 90       	pop	r15
    162a:	ef 90       	pop	r14
    162c:	df 90       	pop	r13
    162e:	cf 90       	pop	r12
    1630:	bf 90       	pop	r11
    1632:	af 90       	pop	r10
    1634:	9f 90       	pop	r9
    1636:	8f 90       	pop	r8
    1638:	7f 90       	pop	r7
    163a:	6f 90       	pop	r6
    163c:	5f 90       	pop	r5
    163e:	4f 90       	pop	r4
    1640:	3f 90       	pop	r3
    1642:	2f 90       	pop	r2
    1644:	1f 90       	pop	r1
    1646:	0f 90       	pop	r0
    1648:	0c be       	out	0x3c, r0	; 60
    164a:	0f 90       	pop	r0
    164c:	0b be       	out	0x3b, r0	; 59
    164e:	0f 90       	pop	r0
    1650:	0f be       	out	0x3f, r0	; 63
    1652:	0f 90       	pop	r0
    1654:	08 95       	ret
    1656:	08 95       	ret

00001658 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1658:	0f 92       	push	r0
    165a:	0f b6       	in	r0, 0x3f	; 63
    165c:	f8 94       	cli
    165e:	0f 92       	push	r0
    1660:	0b b6       	in	r0, 0x3b	; 59
    1662:	0f 92       	push	r0
    1664:	0c b6       	in	r0, 0x3c	; 60
    1666:	0f 92       	push	r0
    1668:	1f 92       	push	r1
    166a:	11 24       	eor	r1, r1
    166c:	2f 92       	push	r2
    166e:	3f 92       	push	r3
    1670:	4f 92       	push	r4
    1672:	5f 92       	push	r5
    1674:	6f 92       	push	r6
    1676:	7f 92       	push	r7
    1678:	8f 92       	push	r8
    167a:	9f 92       	push	r9
    167c:	af 92       	push	r10
    167e:	bf 92       	push	r11
    1680:	cf 92       	push	r12
    1682:	df 92       	push	r13
    1684:	ef 92       	push	r14
    1686:	ff 92       	push	r15
    1688:	0f 93       	push	r16
    168a:	1f 93       	push	r17
    168c:	2f 93       	push	r18
    168e:	3f 93       	push	r19
    1690:	4f 93       	push	r20
    1692:	5f 93       	push	r21
    1694:	6f 93       	push	r22
    1696:	7f 93       	push	r23
    1698:	8f 93       	push	r24
    169a:	9f 93       	push	r25
    169c:	af 93       	push	r26
    169e:	bf 93       	push	r27
    16a0:	cf 93       	push	r28
    16a2:	df 93       	push	r29
    16a4:	ef 93       	push	r30
    16a6:	ff 93       	push	r31
    16a8:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    16ac:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    16b0:	0d b6       	in	r0, 0x3d	; 61
    16b2:	0d 92       	st	X+, r0
    16b4:	0e b6       	in	r0, 0x3e	; 62
    16b6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    16b8:	0e 94 4c 12 	call	0x2498	; 0x2498 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    16bc:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    16c0:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    16c4:	cd 91       	ld	r28, X+
    16c6:	cd bf       	out	0x3d, r28	; 61
    16c8:	dd 91       	ld	r29, X+
    16ca:	de bf       	out	0x3e, r29	; 62
    16cc:	ff 91       	pop	r31
    16ce:	ef 91       	pop	r30
    16d0:	df 91       	pop	r29
    16d2:	cf 91       	pop	r28
    16d4:	bf 91       	pop	r27
    16d6:	af 91       	pop	r26
    16d8:	9f 91       	pop	r25
    16da:	8f 91       	pop	r24
    16dc:	7f 91       	pop	r23
    16de:	6f 91       	pop	r22
    16e0:	5f 91       	pop	r21
    16e2:	4f 91       	pop	r20
    16e4:	3f 91       	pop	r19
    16e6:	2f 91       	pop	r18
    16e8:	1f 91       	pop	r17
    16ea:	0f 91       	pop	r16
    16ec:	ff 90       	pop	r15
    16ee:	ef 90       	pop	r14
    16f0:	df 90       	pop	r13
    16f2:	cf 90       	pop	r12
    16f4:	bf 90       	pop	r11
    16f6:	af 90       	pop	r10
    16f8:	9f 90       	pop	r9
    16fa:	8f 90       	pop	r8
    16fc:	7f 90       	pop	r7
    16fe:	6f 90       	pop	r6
    1700:	5f 90       	pop	r5
    1702:	4f 90       	pop	r4
    1704:	3f 90       	pop	r3
    1706:	2f 90       	pop	r2
    1708:	1f 90       	pop	r1
    170a:	0f 90       	pop	r0
    170c:	0c be       	out	0x3c, r0	; 60
    170e:	0f 90       	pop	r0
    1710:	0b be       	out	0x3b, r0	; 59
    1712:	0f 90       	pop	r0
    1714:	0f be       	out	0x3f, r0	; 63
    1716:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1718:	08 95       	ret

0000171a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    171a:	0f 92       	push	r0
    171c:	0f b6       	in	r0, 0x3f	; 63
    171e:	f8 94       	cli
    1720:	0f 92       	push	r0
    1722:	0b b6       	in	r0, 0x3b	; 59
    1724:	0f 92       	push	r0
    1726:	0c b6       	in	r0, 0x3c	; 60
    1728:	0f 92       	push	r0
    172a:	1f 92       	push	r1
    172c:	11 24       	eor	r1, r1
    172e:	2f 92       	push	r2
    1730:	3f 92       	push	r3
    1732:	4f 92       	push	r4
    1734:	5f 92       	push	r5
    1736:	6f 92       	push	r6
    1738:	7f 92       	push	r7
    173a:	8f 92       	push	r8
    173c:	9f 92       	push	r9
    173e:	af 92       	push	r10
    1740:	bf 92       	push	r11
    1742:	cf 92       	push	r12
    1744:	df 92       	push	r13
    1746:	ef 92       	push	r14
    1748:	ff 92       	push	r15
    174a:	0f 93       	push	r16
    174c:	1f 93       	push	r17
    174e:	2f 93       	push	r18
    1750:	3f 93       	push	r19
    1752:	4f 93       	push	r20
    1754:	5f 93       	push	r21
    1756:	6f 93       	push	r22
    1758:	7f 93       	push	r23
    175a:	8f 93       	push	r24
    175c:	9f 93       	push	r25
    175e:	af 93       	push	r26
    1760:	bf 93       	push	r27
    1762:	cf 93       	push	r28
    1764:	df 93       	push	r29
    1766:	ef 93       	push	r30
    1768:	ff 93       	push	r31
    176a:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    176e:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1772:	0d b6       	in	r0, 0x3d	; 61
    1774:	0d 92       	st	X+, r0
    1776:	0e b6       	in	r0, 0x3e	; 62
    1778:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    177a:	0e 94 2e 10 	call	0x205c	; 0x205c <vTaskIncrementTick>
	vTaskSwitchContext();
    177e:	0e 94 4c 12 	call	0x2498	; 0x2498 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1782:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1786:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    178a:	cd 91       	ld	r28, X+
    178c:	cd bf       	out	0x3d, r28	; 61
    178e:	dd 91       	ld	r29, X+
    1790:	de bf       	out	0x3e, r29	; 62
    1792:	ff 91       	pop	r31
    1794:	ef 91       	pop	r30
    1796:	df 91       	pop	r29
    1798:	cf 91       	pop	r28
    179a:	bf 91       	pop	r27
    179c:	af 91       	pop	r26
    179e:	9f 91       	pop	r25
    17a0:	8f 91       	pop	r24
    17a2:	7f 91       	pop	r23
    17a4:	6f 91       	pop	r22
    17a6:	5f 91       	pop	r21
    17a8:	4f 91       	pop	r20
    17aa:	3f 91       	pop	r19
    17ac:	2f 91       	pop	r18
    17ae:	1f 91       	pop	r17
    17b0:	0f 91       	pop	r16
    17b2:	ff 90       	pop	r15
    17b4:	ef 90       	pop	r14
    17b6:	df 90       	pop	r13
    17b8:	cf 90       	pop	r12
    17ba:	bf 90       	pop	r11
    17bc:	af 90       	pop	r10
    17be:	9f 90       	pop	r9
    17c0:	8f 90       	pop	r8
    17c2:	7f 90       	pop	r7
    17c4:	6f 90       	pop	r6
    17c6:	5f 90       	pop	r5
    17c8:	4f 90       	pop	r4
    17ca:	3f 90       	pop	r3
    17cc:	2f 90       	pop	r2
    17ce:	1f 90       	pop	r1
    17d0:	0f 90       	pop	r0
    17d2:	0c be       	out	0x3c, r0	; 60
    17d4:	0f 90       	pop	r0
    17d6:	0b be       	out	0x3b, r0	; 59
    17d8:	0f 90       	pop	r0
    17da:	0f be       	out	0x3f, r0	; 63
    17dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17de:	08 95       	ret

000017e0 <__vector_16>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    17e0:	0e 94 8d 0b 	call	0x171a	; 0x171a <vPortYieldFromTick>
		asm volatile ( "reti" );
    17e4:	18 95       	reti

000017e6 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17e6:	cf 93       	push	r28
    17e8:	df 93       	push	r29
    17ea:	ec 01       	movw	r28, r24
    17ec:	88 a1       	ldd	r24, Y+32	; 0x20
    17ee:	81 11       	cpse	r24, r1
    17f0:	0b c0       	rjmp	.+22     	; 0x1808 <prvCopyDataToQueue+0x22>
    17f2:	88 81       	ld	r24, Y
    17f4:	99 81       	ldd	r25, Y+1	; 0x01
    17f6:	89 2b       	or	r24, r25
    17f8:	e1 f5       	brne	.+120    	; 0x1872 <prvCopyDataToQueue+0x8c>
    17fa:	8a 81       	ldd	r24, Y+2	; 0x02
    17fc:	9b 81       	ldd	r25, Y+3	; 0x03
    17fe:	0e 94 07 14 	call	0x280e	; 0x280e <vTaskPriorityDisinherit>
    1802:	1a 82       	std	Y+2, r1	; 0x02
    1804:	1b 82       	std	Y+3, r1	; 0x03
    1806:	35 c0       	rjmp	.+106    	; 0x1872 <prvCopyDataToQueue+0x8c>
    1808:	41 11       	cpse	r20, r1
    180a:	17 c0       	rjmp	.+46     	; 0x183a <prvCopyDataToQueue+0x54>
    180c:	48 2f       	mov	r20, r24
    180e:	50 e0       	ldi	r21, 0x00	; 0
    1810:	8c 81       	ldd	r24, Y+4	; 0x04
    1812:	9d 81       	ldd	r25, Y+5	; 0x05
    1814:	0e 94 23 21 	call	0x4246	; 0x4246 <memcpy>
    1818:	28 a1       	ldd	r18, Y+32	; 0x20
    181a:	8c 81       	ldd	r24, Y+4	; 0x04
    181c:	9d 81       	ldd	r25, Y+5	; 0x05
    181e:	82 0f       	add	r24, r18
    1820:	91 1d       	adc	r25, r1
    1822:	8c 83       	std	Y+4, r24	; 0x04
    1824:	9d 83       	std	Y+5, r25	; 0x05
    1826:	2a 81       	ldd	r18, Y+2	; 0x02
    1828:	3b 81       	ldd	r19, Y+3	; 0x03
    182a:	82 17       	cp	r24, r18
    182c:	93 07       	cpc	r25, r19
    182e:	08 f1       	brcs	.+66     	; 0x1872 <prvCopyDataToQueue+0x8c>
    1830:	88 81       	ld	r24, Y
    1832:	99 81       	ldd	r25, Y+1	; 0x01
    1834:	8c 83       	std	Y+4, r24	; 0x04
    1836:	9d 83       	std	Y+5, r25	; 0x05
    1838:	1c c0       	rjmp	.+56     	; 0x1872 <prvCopyDataToQueue+0x8c>
    183a:	48 2f       	mov	r20, r24
    183c:	50 e0       	ldi	r21, 0x00	; 0
    183e:	8e 81       	ldd	r24, Y+6	; 0x06
    1840:	9f 81       	ldd	r25, Y+7	; 0x07
    1842:	0e 94 23 21 	call	0x4246	; 0x4246 <memcpy>
    1846:	88 a1       	ldd	r24, Y+32	; 0x20
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	91 95       	neg	r25
    184c:	81 95       	neg	r24
    184e:	91 09       	sbc	r25, r1
    1850:	2e 81       	ldd	r18, Y+6	; 0x06
    1852:	3f 81       	ldd	r19, Y+7	; 0x07
    1854:	28 0f       	add	r18, r24
    1856:	39 1f       	adc	r19, r25
    1858:	2e 83       	std	Y+6, r18	; 0x06
    185a:	3f 83       	std	Y+7, r19	; 0x07
    185c:	48 81       	ld	r20, Y
    185e:	59 81       	ldd	r21, Y+1	; 0x01
    1860:	24 17       	cp	r18, r20
    1862:	35 07       	cpc	r19, r21
    1864:	30 f4       	brcc	.+12     	; 0x1872 <prvCopyDataToQueue+0x8c>
    1866:	2a 81       	ldd	r18, Y+2	; 0x02
    1868:	3b 81       	ldd	r19, Y+3	; 0x03
    186a:	82 0f       	add	r24, r18
    186c:	93 1f       	adc	r25, r19
    186e:	8e 83       	std	Y+6, r24	; 0x06
    1870:	9f 83       	std	Y+7, r25	; 0x07
    1872:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1874:	8f 5f       	subi	r24, 0xFF	; 255
    1876:	8e 8f       	std	Y+30, r24	; 0x1e
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	08 95       	ret

0000187e <prvCopyDataFromQueue>:
    187e:	fc 01       	movw	r30, r24
    1880:	80 81       	ld	r24, Z
    1882:	91 81       	ldd	r25, Z+1	; 0x01
    1884:	00 97       	sbiw	r24, 0x00	; 0
    1886:	a1 f0       	breq	.+40     	; 0x18b0 <prvCopyDataFromQueue+0x32>
    1888:	40 a1       	ldd	r20, Z+32	; 0x20
    188a:	50 e0       	ldi	r21, 0x00	; 0
    188c:	26 81       	ldd	r18, Z+6	; 0x06
    188e:	37 81       	ldd	r19, Z+7	; 0x07
    1890:	24 0f       	add	r18, r20
    1892:	35 1f       	adc	r19, r21
    1894:	26 83       	std	Z+6, r18	; 0x06
    1896:	37 83       	std	Z+7, r19	; 0x07
    1898:	a2 81       	ldd	r26, Z+2	; 0x02
    189a:	b3 81       	ldd	r27, Z+3	; 0x03
    189c:	2a 17       	cp	r18, r26
    189e:	3b 07       	cpc	r19, r27
    18a0:	10 f0       	brcs	.+4      	; 0x18a6 <prvCopyDataFromQueue+0x28>
    18a2:	86 83       	std	Z+6, r24	; 0x06
    18a4:	97 83       	std	Z+7, r25	; 0x07
    18a6:	cb 01       	movw	r24, r22
    18a8:	66 81       	ldd	r22, Z+6	; 0x06
    18aa:	77 81       	ldd	r23, Z+7	; 0x07
    18ac:	0e 94 23 21 	call	0x4246	; 0x4246 <memcpy>
    18b0:	08 95       	ret

000018b2 <prvUnlockQueue>:
    18b2:	0f 93       	push	r16
    18b4:	1f 93       	push	r17
    18b6:	cf 93       	push	r28
    18b8:	df 93       	push	r29
    18ba:	ec 01       	movw	r28, r24
    18bc:	0f b6       	in	r0, 0x3f	; 63
    18be:	f8 94       	cli
    18c0:	0f 92       	push	r0
    18c2:	8a a1       	ldd	r24, Y+34	; 0x22
    18c4:	18 16       	cp	r1, r24
    18c6:	b4 f4       	brge	.+44     	; 0x18f4 <prvUnlockQueue+0x42>
    18c8:	8b 89       	ldd	r24, Y+19	; 0x13
    18ca:	81 11       	cpse	r24, r1
    18cc:	05 c0       	rjmp	.+10     	; 0x18d8 <prvUnlockQueue+0x26>
    18ce:	12 c0       	rjmp	.+36     	; 0x18f4 <prvUnlockQueue+0x42>
    18d0:	8b 89       	ldd	r24, Y+19	; 0x13
    18d2:	81 11       	cpse	r24, r1
    18d4:	04 c0       	rjmp	.+8      	; 0x18de <prvUnlockQueue+0x2c>
    18d6:	0e c0       	rjmp	.+28     	; 0x18f4 <prvUnlockQueue+0x42>
    18d8:	8e 01       	movw	r16, r28
    18da:	0d 5e       	subi	r16, 0xED	; 237
    18dc:	1f 4f       	sbci	r17, 0xFF	; 255
    18de:	c8 01       	movw	r24, r16
    18e0:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <xTaskRemoveFromEventList>
    18e4:	81 11       	cpse	r24, r1
    18e6:	0e 94 90 13 	call	0x2720	; 0x2720 <vTaskMissedYield>
    18ea:	8a a1       	ldd	r24, Y+34	; 0x22
    18ec:	81 50       	subi	r24, 0x01	; 1
    18ee:	8a a3       	std	Y+34, r24	; 0x22
    18f0:	18 16       	cp	r1, r24
    18f2:	74 f3       	brlt	.-36     	; 0x18d0 <prvUnlockQueue+0x1e>
    18f4:	8f ef       	ldi	r24, 0xFF	; 255
    18f6:	8a a3       	std	Y+34, r24	; 0x22
    18f8:	0f 90       	pop	r0
    18fa:	0f be       	out	0x3f, r0	; 63
    18fc:	0f b6       	in	r0, 0x3f	; 63
    18fe:	f8 94       	cli
    1900:	0f 92       	push	r0
    1902:	89 a1       	ldd	r24, Y+33	; 0x21
    1904:	18 16       	cp	r1, r24
    1906:	b4 f4       	brge	.+44     	; 0x1934 <prvUnlockQueue+0x82>
    1908:	88 85       	ldd	r24, Y+8	; 0x08
    190a:	81 11       	cpse	r24, r1
    190c:	05 c0       	rjmp	.+10     	; 0x1918 <prvUnlockQueue+0x66>
    190e:	12 c0       	rjmp	.+36     	; 0x1934 <prvUnlockQueue+0x82>
    1910:	88 85       	ldd	r24, Y+8	; 0x08
    1912:	81 11       	cpse	r24, r1
    1914:	04 c0       	rjmp	.+8      	; 0x191e <prvUnlockQueue+0x6c>
    1916:	0e c0       	rjmp	.+28     	; 0x1934 <prvUnlockQueue+0x82>
    1918:	8e 01       	movw	r16, r28
    191a:	08 5f       	subi	r16, 0xF8	; 248
    191c:	1f 4f       	sbci	r17, 0xFF	; 255
    191e:	c8 01       	movw	r24, r16
    1920:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <xTaskRemoveFromEventList>
    1924:	81 11       	cpse	r24, r1
    1926:	0e 94 90 13 	call	0x2720	; 0x2720 <vTaskMissedYield>
    192a:	89 a1       	ldd	r24, Y+33	; 0x21
    192c:	81 50       	subi	r24, 0x01	; 1
    192e:	89 a3       	std	Y+33, r24	; 0x21
    1930:	18 16       	cp	r1, r24
    1932:	74 f3       	brlt	.-36     	; 0x1910 <prvUnlockQueue+0x5e>
    1934:	8f ef       	ldi	r24, 0xFF	; 255
    1936:	89 a3       	std	Y+33, r24	; 0x21
    1938:	0f 90       	pop	r0
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	df 91       	pop	r29
    193e:	cf 91       	pop	r28
    1940:	1f 91       	pop	r17
    1942:	0f 91       	pop	r16
    1944:	08 95       	ret

00001946 <xQueueGenericReset>:
    1946:	1f 93       	push	r17
    1948:	cf 93       	push	r28
    194a:	df 93       	push	r29
    194c:	61 30       	cpi	r22, 0x01	; 1
    194e:	59 f0       	breq	.+22     	; 0x1966 <xQueueGenericReset+0x20>
    1950:	fc 01       	movw	r30, r24
    1952:	23 89       	ldd	r18, Z+19	; 0x13
    1954:	30 85       	ldd	r19, Z+8	; 0x08
    1956:	31 11       	cpse	r19, r1
    1958:	2c c0       	rjmp	.+88     	; 0x19b2 <xQueueGenericReset+0x6c>
    195a:	11 e0       	ldi	r17, 0x01	; 1
    195c:	21 11       	cpse	r18, r1
    195e:	10 e0       	ldi	r17, 0x00	; 0
    1960:	21 11       	cpse	r18, r1
    1962:	28 c0       	rjmp	.+80     	; 0x19b4 <xQueueGenericReset+0x6e>
    1964:	01 c0       	rjmp	.+2      	; 0x1968 <xQueueGenericReset+0x22>
    1966:	11 e0       	ldi	r17, 0x01	; 1
    1968:	ec 01       	movw	r28, r24
    196a:	48 81       	ld	r20, Y
    196c:	59 81       	ldd	r21, Y+1	; 0x01
    196e:	28 a1       	ldd	r18, Y+32	; 0x20
    1970:	30 e0       	ldi	r19, 0x00	; 0
    1972:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1974:	62 9f       	mul	r22, r18
    1976:	c0 01       	movw	r24, r0
    1978:	63 9f       	mul	r22, r19
    197a:	90 0d       	add	r25, r0
    197c:	11 24       	eor	r1, r1
    197e:	ba 01       	movw	r22, r20
    1980:	68 0f       	add	r22, r24
    1982:	79 1f       	adc	r23, r25
    1984:	6a 83       	std	Y+2, r22	; 0x02
    1986:	7b 83       	std	Y+3, r23	; 0x03
    1988:	1e 8e       	std	Y+30, r1	; 0x1e
    198a:	4c 83       	std	Y+4, r20	; 0x04
    198c:	5d 83       	std	Y+5, r21	; 0x05
    198e:	82 1b       	sub	r24, r18
    1990:	93 0b       	sbc	r25, r19
    1992:	84 0f       	add	r24, r20
    1994:	95 1f       	adc	r25, r21
    1996:	8e 83       	std	Y+6, r24	; 0x06
    1998:	9f 83       	std	Y+7, r25	; 0x07
    199a:	8f ef       	ldi	r24, 0xFF	; 255
    199c:	89 a3       	std	Y+33, r24	; 0x21
    199e:	8a a3       	std	Y+34, r24	; 0x22
    19a0:	ce 01       	movw	r24, r28
    19a2:	08 96       	adiw	r24, 0x08	; 8
    19a4:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    19a8:	ce 01       	movw	r24, r28
    19aa:	43 96       	adiw	r24, 0x13	; 19
    19ac:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    19b0:	01 c0       	rjmp	.+2      	; 0x19b4 <xQueueGenericReset+0x6e>
    19b2:	10 e0       	ldi	r17, 0x00	; 0
    19b4:	81 2f       	mov	r24, r17
    19b6:	df 91       	pop	r29
    19b8:	cf 91       	pop	r28
    19ba:	1f 91       	pop	r17
    19bc:	08 95       	ret

000019be <xQueueGenericCreate>:
    19be:	0f 93       	push	r16
    19c0:	1f 93       	push	r17
    19c2:	cf 93       	push	r28
    19c4:	df 93       	push	r29
    19c6:	88 23       	and	r24, r24
    19c8:	01 f1       	breq	.+64     	; 0x1a0a <xQueueGenericCreate+0x4c>
    19ca:	06 2f       	mov	r16, r22
    19cc:	18 2f       	mov	r17, r24
    19ce:	83 e2       	ldi	r24, 0x23	; 35
    19d0:	90 e0       	ldi	r25, 0x00	; 0
    19d2:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <pvPortMalloc>
    19d6:	ec 01       	movw	r28, r24
    19d8:	89 2b       	or	r24, r25
    19da:	c9 f0       	breq	.+50     	; 0x1a0e <xQueueGenericCreate+0x50>
    19dc:	10 9f       	mul	r17, r16
    19de:	c0 01       	movw	r24, r0
    19e0:	11 24       	eor	r1, r1
    19e2:	01 96       	adiw	r24, 0x01	; 1
    19e4:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <pvPortMalloc>
    19e8:	88 83       	st	Y, r24
    19ea:	99 83       	std	Y+1, r25	; 0x01
    19ec:	89 2b       	or	r24, r25
    19ee:	39 f0       	breq	.+14     	; 0x19fe <xQueueGenericCreate+0x40>
    19f0:	1f 8f       	std	Y+31, r17	; 0x1f
    19f2:	08 a3       	std	Y+32, r16	; 0x20
    19f4:	61 e0       	ldi	r22, 0x01	; 1
    19f6:	ce 01       	movw	r24, r28
    19f8:	0e 94 a3 0c 	call	0x1946	; 0x1946 <xQueueGenericReset>
    19fc:	08 c0       	rjmp	.+16     	; 0x1a0e <xQueueGenericCreate+0x50>
    19fe:	ce 01       	movw	r24, r28
    1a00:	0e 94 93 09 	call	0x1326	; 0x1326 <vPortFree>
    1a04:	c0 e0       	ldi	r28, 0x00	; 0
    1a06:	d0 e0       	ldi	r29, 0x00	; 0
    1a08:	02 c0       	rjmp	.+4      	; 0x1a0e <xQueueGenericCreate+0x50>
    1a0a:	c0 e0       	ldi	r28, 0x00	; 0
    1a0c:	d0 e0       	ldi	r29, 0x00	; 0
    1a0e:	ce 01       	movw	r24, r28
    1a10:	df 91       	pop	r29
    1a12:	cf 91       	pop	r28
    1a14:	1f 91       	pop	r17
    1a16:	0f 91       	pop	r16
    1a18:	08 95       	ret

00001a1a <xQueueGenericSend>:
    1a1a:	af 92       	push	r10
    1a1c:	bf 92       	push	r11
    1a1e:	cf 92       	push	r12
    1a20:	df 92       	push	r13
    1a22:	ef 92       	push	r14
    1a24:	ff 92       	push	r15
    1a26:	0f 93       	push	r16
    1a28:	1f 93       	push	r17
    1a2a:	cf 93       	push	r28
    1a2c:	df 93       	push	r29
    1a2e:	cd b7       	in	r28, 0x3d	; 61
    1a30:	de b7       	in	r29, 0x3e	; 62
    1a32:	29 97       	sbiw	r28, 0x09	; 9
    1a34:	cd bf       	out	0x3d, r28	; 61
    1a36:	de bf       	out	0x3e, r29	; 62
    1a38:	7c 01       	movw	r14, r24
    1a3a:	5b 01       	movw	r10, r22
    1a3c:	2e 83       	std	Y+6, r18	; 0x06
    1a3e:	3f 83       	std	Y+7, r19	; 0x07
    1a40:	48 87       	std	Y+8, r20	; 0x08
    1a42:	59 87       	std	Y+9, r21	; 0x09
    1a44:	10 e0       	ldi	r17, 0x00	; 0
    1a46:	6c 01       	movw	r12, r24
    1a48:	88 e0       	ldi	r24, 0x08	; 8
    1a4a:	c8 0e       	add	r12, r24
    1a4c:	d1 1c       	adc	r13, r1
    1a4e:	0f b6       	in	r0, 0x3f	; 63
    1a50:	f8 94       	cli
    1a52:	0f 92       	push	r0
    1a54:	f7 01       	movw	r30, r14
    1a56:	96 8d       	ldd	r25, Z+30	; 0x1e
    1a58:	87 8d       	ldd	r24, Z+31	; 0x1f
    1a5a:	98 17       	cp	r25, r24
    1a5c:	a8 f4       	brcc	.+42     	; 0x1a88 <xQueueGenericSend+0x6e>
    1a5e:	40 2f       	mov	r20, r16
    1a60:	b5 01       	movw	r22, r10
    1a62:	c7 01       	movw	r24, r14
    1a64:	0e 94 f3 0b 	call	0x17e6	; 0x17e6 <prvCopyDataToQueue>
    1a68:	f7 01       	movw	r30, r14
    1a6a:	83 89       	ldd	r24, Z+19	; 0x13
    1a6c:	88 23       	and	r24, r24
    1a6e:	41 f0       	breq	.+16     	; 0x1a80 <xQueueGenericSend+0x66>
    1a70:	c7 01       	movw	r24, r14
    1a72:	43 96       	adiw	r24, 0x13	; 19
    1a74:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <xTaskRemoveFromEventList>
    1a78:	81 30       	cpi	r24, 0x01	; 1
    1a7a:	11 f4       	brne	.+4      	; 0x1a80 <xQueueGenericSend+0x66>
    1a7c:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
    1a80:	0f 90       	pop	r0
    1a82:	0f be       	out	0x3f, r0	; 63
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	56 c0       	rjmp	.+172    	; 0x1b34 <xQueueGenericSend+0x11a>
    1a88:	8e 81       	ldd	r24, Y+6	; 0x06
    1a8a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a8c:	a8 85       	ldd	r26, Y+8	; 0x08
    1a8e:	b9 85       	ldd	r27, Y+9	; 0x09
    1a90:	89 2b       	or	r24, r25
    1a92:	8a 2b       	or	r24, r26
    1a94:	8b 2b       	or	r24, r27
    1a96:	21 f4       	brne	.+8      	; 0x1aa0 <xQueueGenericSend+0x86>
    1a98:	0f 90       	pop	r0
    1a9a:	0f be       	out	0x3f, r0	; 63
    1a9c:	80 e0       	ldi	r24, 0x00	; 0
    1a9e:	4a c0       	rjmp	.+148    	; 0x1b34 <xQueueGenericSend+0x11a>
    1aa0:	11 11       	cpse	r17, r1
    1aa2:	05 c0       	rjmp	.+10     	; 0x1aae <xQueueGenericSend+0x94>
    1aa4:	ce 01       	movw	r24, r28
    1aa6:	01 96       	adiw	r24, 0x01	; 1
    1aa8:	0e 94 12 13 	call	0x2624	; 0x2624 <vTaskSetTimeOutState>
    1aac:	11 e0       	ldi	r17, 0x01	; 1
    1aae:	0f 90       	pop	r0
    1ab0:	0f be       	out	0x3f, r0	; 63
    1ab2:	0e 94 0d 10 	call	0x201a	; 0x201a <vTaskSuspendAll>
    1ab6:	0f b6       	in	r0, 0x3f	; 63
    1ab8:	f8 94       	cli
    1aba:	0f 92       	push	r0
    1abc:	f7 01       	movw	r30, r14
    1abe:	81 a1       	ldd	r24, Z+33	; 0x21
    1ac0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ac2:	09 f4       	brne	.+2      	; 0x1ac6 <xQueueGenericSend+0xac>
    1ac4:	11 a2       	std	Z+33, r1	; 0x21
    1ac6:	f7 01       	movw	r30, r14
    1ac8:	82 a1       	ldd	r24, Z+34	; 0x22
    1aca:	8f 3f       	cpi	r24, 0xFF	; 255
    1acc:	09 f4       	brne	.+2      	; 0x1ad0 <xQueueGenericSend+0xb6>
    1ace:	12 a2       	std	Z+34, r1	; 0x22
    1ad0:	0f 90       	pop	r0
    1ad2:	0f be       	out	0x3f, r0	; 63
    1ad4:	be 01       	movw	r22, r28
    1ad6:	6a 5f       	subi	r22, 0xFA	; 250
    1ad8:	7f 4f       	sbci	r23, 0xFF	; 255
    1ada:	ce 01       	movw	r24, r28
    1adc:	01 96       	adiw	r24, 0x01	; 1
    1ade:	0e 94 23 13 	call	0x2646	; 0x2646 <xTaskCheckForTimeOut>
    1ae2:	81 11       	cpse	r24, r1
    1ae4:	21 c0       	rjmp	.+66     	; 0x1b28 <xQueueGenericSend+0x10e>
    1ae6:	0f b6       	in	r0, 0x3f	; 63
    1ae8:	f8 94       	cli
    1aea:	0f 92       	push	r0
    1aec:	f7 01       	movw	r30, r14
    1aee:	96 8d       	ldd	r25, Z+30	; 0x1e
    1af0:	0f 90       	pop	r0
    1af2:	0f be       	out	0x3f, r0	; 63
    1af4:	87 8d       	ldd	r24, Z+31	; 0x1f
    1af6:	98 13       	cpse	r25, r24
    1af8:	11 c0       	rjmp	.+34     	; 0x1b1c <xQueueGenericSend+0x102>
    1afa:	4e 81       	ldd	r20, Y+6	; 0x06
    1afc:	5f 81       	ldd	r21, Y+7	; 0x07
    1afe:	68 85       	ldd	r22, Y+8	; 0x08
    1b00:	79 85       	ldd	r23, Y+9	; 0x09
    1b02:	c6 01       	movw	r24, r12
    1b04:	0e 94 a9 12 	call	0x2552	; 0x2552 <vTaskPlaceOnEventList>
    1b08:	c7 01       	movw	r24, r14
    1b0a:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <prvUnlockQueue>
    1b0e:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
    1b12:	81 11       	cpse	r24, r1
    1b14:	9c cf       	rjmp	.-200    	; 0x1a4e <xQueueGenericSend+0x34>
    1b16:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
    1b1a:	99 cf       	rjmp	.-206    	; 0x1a4e <xQueueGenericSend+0x34>
    1b1c:	c7 01       	movw	r24, r14
    1b1e:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <prvUnlockQueue>
    1b22:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
    1b26:	93 cf       	rjmp	.-218    	; 0x1a4e <xQueueGenericSend+0x34>
    1b28:	c7 01       	movw	r24, r14
    1b2a:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <prvUnlockQueue>
    1b2e:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
    1b32:	80 e0       	ldi	r24, 0x00	; 0
    1b34:	29 96       	adiw	r28, 0x09	; 9
    1b36:	cd bf       	out	0x3d, r28	; 61
    1b38:	de bf       	out	0x3e, r29	; 62
    1b3a:	df 91       	pop	r29
    1b3c:	cf 91       	pop	r28
    1b3e:	1f 91       	pop	r17
    1b40:	0f 91       	pop	r16
    1b42:	ff 90       	pop	r15
    1b44:	ef 90       	pop	r14
    1b46:	df 90       	pop	r13
    1b48:	cf 90       	pop	r12
    1b4a:	bf 90       	pop	r11
    1b4c:	af 90       	pop	r10
    1b4e:	08 95       	ret

00001b50 <xQueueGenericReceive>:
    1b50:	af 92       	push	r10
    1b52:	bf 92       	push	r11
    1b54:	cf 92       	push	r12
    1b56:	df 92       	push	r13
    1b58:	ef 92       	push	r14
    1b5a:	ff 92       	push	r15
    1b5c:	0f 93       	push	r16
    1b5e:	1f 93       	push	r17
    1b60:	cf 93       	push	r28
    1b62:	df 93       	push	r29
    1b64:	cd b7       	in	r28, 0x3d	; 61
    1b66:	de b7       	in	r29, 0x3e	; 62
    1b68:	29 97       	sbiw	r28, 0x09	; 9
    1b6a:	cd bf       	out	0x3d, r28	; 61
    1b6c:	de bf       	out	0x3e, r29	; 62
    1b6e:	7c 01       	movw	r14, r24
    1b70:	5b 01       	movw	r10, r22
    1b72:	2e 83       	std	Y+6, r18	; 0x06
    1b74:	3f 83       	std	Y+7, r19	; 0x07
    1b76:	48 87       	std	Y+8, r20	; 0x08
    1b78:	59 87       	std	Y+9, r21	; 0x09
    1b7a:	10 e0       	ldi	r17, 0x00	; 0
    1b7c:	6c 01       	movw	r12, r24
    1b7e:	83 e1       	ldi	r24, 0x13	; 19
    1b80:	c8 0e       	add	r12, r24
    1b82:	d1 1c       	adc	r13, r1
    1b84:	0f b6       	in	r0, 0x3f	; 63
    1b86:	f8 94       	cli
    1b88:	0f 92       	push	r0
    1b8a:	f7 01       	movw	r30, r14
    1b8c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b8e:	88 23       	and	r24, r24
    1b90:	99 f1       	breq	.+102    	; 0x1bf8 <xQueueGenericReceive+0xa8>
    1b92:	c6 80       	ldd	r12, Z+6	; 0x06
    1b94:	d7 80       	ldd	r13, Z+7	; 0x07
    1b96:	b5 01       	movw	r22, r10
    1b98:	c7 01       	movw	r24, r14
    1b9a:	0e 94 3f 0c 	call	0x187e	; 0x187e <prvCopyDataFromQueue>
    1b9e:	01 11       	cpse	r16, r1
    1ba0:	1a c0       	rjmp	.+52     	; 0x1bd6 <xQueueGenericReceive+0x86>
    1ba2:	f7 01       	movw	r30, r14
    1ba4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ba6:	81 50       	subi	r24, 0x01	; 1
    1ba8:	86 8f       	std	Z+30, r24	; 0x1e
    1baa:	80 81       	ld	r24, Z
    1bac:	91 81       	ldd	r25, Z+1	; 0x01
    1bae:	89 2b       	or	r24, r25
    1bb0:	29 f4       	brne	.+10     	; 0x1bbc <xQueueGenericReceive+0x6c>
    1bb2:	0e 94 ad 13 	call	0x275a	; 0x275a <xTaskGetCurrentTaskHandle>
    1bb6:	f7 01       	movw	r30, r14
    1bb8:	82 83       	std	Z+2, r24	; 0x02
    1bba:	93 83       	std	Z+3, r25	; 0x03
    1bbc:	f7 01       	movw	r30, r14
    1bbe:	80 85       	ldd	r24, Z+8	; 0x08
    1bc0:	88 23       	and	r24, r24
    1bc2:	b1 f0       	breq	.+44     	; 0x1bf0 <xQueueGenericReceive+0xa0>
    1bc4:	c7 01       	movw	r24, r14
    1bc6:	08 96       	adiw	r24, 0x08	; 8
    1bc8:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <xTaskRemoveFromEventList>
    1bcc:	81 30       	cpi	r24, 0x01	; 1
    1bce:	81 f4       	brne	.+32     	; 0x1bf0 <xQueueGenericReceive+0xa0>
    1bd0:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
    1bd4:	0d c0       	rjmp	.+26     	; 0x1bf0 <xQueueGenericReceive+0xa0>
    1bd6:	f7 01       	movw	r30, r14
    1bd8:	c6 82       	std	Z+6, r12	; 0x06
    1bda:	d7 82       	std	Z+7, r13	; 0x07
    1bdc:	83 89       	ldd	r24, Z+19	; 0x13
    1bde:	88 23       	and	r24, r24
    1be0:	39 f0       	breq	.+14     	; 0x1bf0 <xQueueGenericReceive+0xa0>
    1be2:	c7 01       	movw	r24, r14
    1be4:	43 96       	adiw	r24, 0x13	; 19
    1be6:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <xTaskRemoveFromEventList>
    1bea:	81 11       	cpse	r24, r1
    1bec:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
    1bf0:	0f 90       	pop	r0
    1bf2:	0f be       	out	0x3f, r0	; 63
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
    1bf6:	62 c0       	rjmp	.+196    	; 0x1cbc <xQueueGenericReceive+0x16c>
    1bf8:	8e 81       	ldd	r24, Y+6	; 0x06
    1bfa:	9f 81       	ldd	r25, Y+7	; 0x07
    1bfc:	a8 85       	ldd	r26, Y+8	; 0x08
    1bfe:	b9 85       	ldd	r27, Y+9	; 0x09
    1c00:	89 2b       	or	r24, r25
    1c02:	8a 2b       	or	r24, r26
    1c04:	8b 2b       	or	r24, r27
    1c06:	21 f4       	brne	.+8      	; 0x1c10 <xQueueGenericReceive+0xc0>
    1c08:	0f 90       	pop	r0
    1c0a:	0f be       	out	0x3f, r0	; 63
    1c0c:	80 e0       	ldi	r24, 0x00	; 0
    1c0e:	56 c0       	rjmp	.+172    	; 0x1cbc <xQueueGenericReceive+0x16c>
    1c10:	11 11       	cpse	r17, r1
    1c12:	05 c0       	rjmp	.+10     	; 0x1c1e <xQueueGenericReceive+0xce>
    1c14:	ce 01       	movw	r24, r28
    1c16:	01 96       	adiw	r24, 0x01	; 1
    1c18:	0e 94 12 13 	call	0x2624	; 0x2624 <vTaskSetTimeOutState>
    1c1c:	11 e0       	ldi	r17, 0x01	; 1
    1c1e:	0f 90       	pop	r0
    1c20:	0f be       	out	0x3f, r0	; 63
    1c22:	0e 94 0d 10 	call	0x201a	; 0x201a <vTaskSuspendAll>
    1c26:	0f b6       	in	r0, 0x3f	; 63
    1c28:	f8 94       	cli
    1c2a:	0f 92       	push	r0
    1c2c:	f7 01       	movw	r30, r14
    1c2e:	81 a1       	ldd	r24, Z+33	; 0x21
    1c30:	8f 3f       	cpi	r24, 0xFF	; 255
    1c32:	09 f4       	brne	.+2      	; 0x1c36 <xQueueGenericReceive+0xe6>
    1c34:	11 a2       	std	Z+33, r1	; 0x21
    1c36:	f7 01       	movw	r30, r14
    1c38:	82 a1       	ldd	r24, Z+34	; 0x22
    1c3a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c3c:	09 f4       	brne	.+2      	; 0x1c40 <xQueueGenericReceive+0xf0>
    1c3e:	12 a2       	std	Z+34, r1	; 0x22
    1c40:	0f 90       	pop	r0
    1c42:	0f be       	out	0x3f, r0	; 63
    1c44:	be 01       	movw	r22, r28
    1c46:	6a 5f       	subi	r22, 0xFA	; 250
    1c48:	7f 4f       	sbci	r23, 0xFF	; 255
    1c4a:	ce 01       	movw	r24, r28
    1c4c:	01 96       	adiw	r24, 0x01	; 1
    1c4e:	0e 94 23 13 	call	0x2646	; 0x2646 <xTaskCheckForTimeOut>
    1c52:	81 11       	cpse	r24, r1
    1c54:	2d c0       	rjmp	.+90     	; 0x1cb0 <xQueueGenericReceive+0x160>
    1c56:	0f b6       	in	r0, 0x3f	; 63
    1c58:	f8 94       	cli
    1c5a:	0f 92       	push	r0
    1c5c:	f7 01       	movw	r30, r14
    1c5e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c60:	0f 90       	pop	r0
    1c62:	0f be       	out	0x3f, r0	; 63
    1c64:	81 11       	cpse	r24, r1
    1c66:	1e c0       	rjmp	.+60     	; 0x1ca4 <xQueueGenericReceive+0x154>
    1c68:	80 81       	ld	r24, Z
    1c6a:	91 81       	ldd	r25, Z+1	; 0x01
    1c6c:	89 2b       	or	r24, r25
    1c6e:	49 f4       	brne	.+18     	; 0x1c82 <xQueueGenericReceive+0x132>
    1c70:	0f b6       	in	r0, 0x3f	; 63
    1c72:	f8 94       	cli
    1c74:	0f 92       	push	r0
    1c76:	82 81       	ldd	r24, Z+2	; 0x02
    1c78:	93 81       	ldd	r25, Z+3	; 0x03
    1c7a:	0e 94 b2 13 	call	0x2764	; 0x2764 <vTaskPriorityInherit>
    1c7e:	0f 90       	pop	r0
    1c80:	0f be       	out	0x3f, r0	; 63
    1c82:	4e 81       	ldd	r20, Y+6	; 0x06
    1c84:	5f 81       	ldd	r21, Y+7	; 0x07
    1c86:	68 85       	ldd	r22, Y+8	; 0x08
    1c88:	79 85       	ldd	r23, Y+9	; 0x09
    1c8a:	c6 01       	movw	r24, r12
    1c8c:	0e 94 a9 12 	call	0x2552	; 0x2552 <vTaskPlaceOnEventList>
    1c90:	c7 01       	movw	r24, r14
    1c92:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <prvUnlockQueue>
    1c96:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
    1c9a:	81 11       	cpse	r24, r1
    1c9c:	73 cf       	rjmp	.-282    	; 0x1b84 <xQueueGenericReceive+0x34>
    1c9e:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
    1ca2:	70 cf       	rjmp	.-288    	; 0x1b84 <xQueueGenericReceive+0x34>
    1ca4:	c7 01       	movw	r24, r14
    1ca6:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <prvUnlockQueue>
    1caa:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
    1cae:	6a cf       	rjmp	.-300    	; 0x1b84 <xQueueGenericReceive+0x34>
    1cb0:	c7 01       	movw	r24, r14
    1cb2:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <prvUnlockQueue>
    1cb6:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
    1cba:	80 e0       	ldi	r24, 0x00	; 0
    1cbc:	29 96       	adiw	r28, 0x09	; 9
    1cbe:	cd bf       	out	0x3d, r28	; 61
    1cc0:	de bf       	out	0x3e, r29	; 62
    1cc2:	df 91       	pop	r29
    1cc4:	cf 91       	pop	r28
    1cc6:	1f 91       	pop	r17
    1cc8:	0f 91       	pop	r16
    1cca:	ff 90       	pop	r15
    1ccc:	ef 90       	pop	r14
    1cce:	df 90       	pop	r13
    1cd0:	cf 90       	pop	r12
    1cd2:	bf 90       	pop	r11
    1cd4:	af 90       	pop	r10
    1cd6:	08 95       	ret

00001cd8 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1cd8:	0f b6       	in	r0, 0x3f	; 63
    1cda:	f8 94       	cli
    1cdc:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1cde:	fc 01       	movw	r30, r24
    1ce0:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1ce2:	0f 90       	pop	r0
    1ce4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1ce6:	08 95       	ret

00001ce8 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1ce8:	cc ee       	ldi	r28, 0xEC	; 236
    1cea:	d0 e3       	ldi	r29, 0x30	; 48
    1cec:	88 81       	ld	r24, Y
    1cee:	82 30       	cpi	r24, 0x02	; 2
    1cf0:	e8 f3       	brcs	.-6      	; 0x1cec <prvIdleTask+0x4>
    1cf2:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
    1cf6:	fa cf       	rjmp	.-12     	; 0x1cec <prvIdleTask+0x4>

00001cf8 <prvAddCurrentTaskToDelayedList>:
    1cf8:	cf 92       	push	r12
    1cfa:	df 92       	push	r13
    1cfc:	ef 92       	push	r14
    1cfe:	ff 92       	push	r15
    1d00:	6b 01       	movw	r12, r22
    1d02:	7c 01       	movw	r14, r24
    1d04:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    1d08:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1d0c:	62 83       	std	Z+2, r22	; 0x02
    1d0e:	73 83       	std	Z+3, r23	; 0x03
    1d10:	84 83       	std	Z+4, r24	; 0x04
    1d12:	95 83       	std	Z+5, r25	; 0x05
    1d14:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    1d18:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    1d1c:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    1d20:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    1d24:	c8 16       	cp	r12, r24
    1d26:	d9 06       	cpc	r13, r25
    1d28:	ea 06       	cpc	r14, r26
    1d2a:	fb 06       	cpc	r15, r27
    1d2c:	68 f4       	brcc	.+26     	; 0x1d48 <prvAddCurrentTaskToDelayedList+0x50>
    1d2e:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    1d32:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1d36:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    1d3a:	90 91 d3 30 	lds	r25, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    1d3e:	6e 5f       	subi	r22, 0xFE	; 254
    1d40:	7f 4f       	sbci	r23, 0xFF	; 255
    1d42:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInsert>
    1d46:	21 c0       	rjmp	.+66     	; 0x1d8a <prvAddCurrentTaskToDelayedList+0x92>
    1d48:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    1d4c:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1d50:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    1d54:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    1d58:	6e 5f       	subi	r22, 0xFE	; 254
    1d5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d5c:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInsert>
    1d60:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1d64:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d68:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d6c:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d70:	c8 16       	cp	r12, r24
    1d72:	d9 06       	cpc	r13, r25
    1d74:	ea 06       	cpc	r14, r26
    1d76:	fb 06       	cpc	r15, r27
    1d78:	40 f4       	brcc	.+16     	; 0x1d8a <prvAddCurrentTaskToDelayedList+0x92>
    1d7a:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1d7e:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d82:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d86:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d8a:	ff 90       	pop	r15
    1d8c:	ef 90       	pop	r14
    1d8e:	df 90       	pop	r13
    1d90:	cf 90       	pop	r12
    1d92:	08 95       	ret

00001d94 <xTaskGenericCreate>:
    1d94:	4f 92       	push	r4
    1d96:	5f 92       	push	r5
    1d98:	6f 92       	push	r6
    1d9a:	7f 92       	push	r7
    1d9c:	8f 92       	push	r8
    1d9e:	9f 92       	push	r9
    1da0:	af 92       	push	r10
    1da2:	bf 92       	push	r11
    1da4:	cf 92       	push	r12
    1da6:	df 92       	push	r13
    1da8:	ef 92       	push	r14
    1daa:	ff 92       	push	r15
    1dac:	0f 93       	push	r16
    1dae:	1f 93       	push	r17
    1db0:	cf 93       	push	r28
    1db2:	df 93       	push	r29
    1db4:	5c 01       	movw	r10, r24
    1db6:	4b 01       	movw	r8, r22
    1db8:	3a 01       	movw	r6, r20
    1dba:	29 01       	movw	r4, r18
    1dbc:	88 e2       	ldi	r24, 0x28	; 40
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <pvPortMalloc>
    1dc4:	ec 01       	movw	r28, r24
    1dc6:	89 2b       	or	r24, r25
    1dc8:	09 f4       	brne	.+2      	; 0x1dcc <xTaskGenericCreate+0x38>
    1dca:	d4 c0       	rjmp	.+424    	; 0x1f74 <xTaskGenericCreate+0x1e0>
    1dcc:	c1 14       	cp	r12, r1
    1dce:	d1 04       	cpc	r13, r1
    1dd0:	09 f0       	breq	.+2      	; 0x1dd4 <xTaskGenericCreate+0x40>
    1dd2:	cc c0       	rjmp	.+408    	; 0x1f6c <xTaskGenericCreate+0x1d8>
    1dd4:	c3 01       	movw	r24, r6
    1dd6:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <pvPortMalloc>
    1dda:	8b 8f       	std	Y+27, r24	; 0x1b
    1ddc:	9c 8f       	std	Y+28, r25	; 0x1c
    1dde:	00 97       	sbiw	r24, 0x00	; 0
    1de0:	21 f4       	brne	.+8      	; 0x1dea <xTaskGenericCreate+0x56>
    1de2:	ce 01       	movw	r24, r28
    1de4:	0e 94 93 09 	call	0x1326	; 0x1326 <vPortFree>
    1de8:	c5 c0       	rjmp	.+394    	; 0x1f74 <xTaskGenericCreate+0x1e0>
    1dea:	a3 01       	movw	r20, r6
    1dec:	61 e1       	ldi	r22, 0x11	; 17
    1dee:	70 e0       	ldi	r23, 0x00	; 0
    1df0:	0e 94 2c 21 	call	0x4258	; 0x4258 <memset>
    1df4:	93 01       	movw	r18, r6
    1df6:	21 50       	subi	r18, 0x01	; 1
    1df8:	31 09       	sbc	r19, r1
    1dfa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1dfc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1dfe:	3c 01       	movw	r6, r24
    1e00:	62 0e       	add	r6, r18
    1e02:	73 1e       	adc	r7, r19
    1e04:	4a e0       	ldi	r20, 0x0A	; 10
    1e06:	50 e0       	ldi	r21, 0x00	; 0
    1e08:	b4 01       	movw	r22, r8
    1e0a:	ce 01       	movw	r24, r28
    1e0c:	4d 96       	adiw	r24, 0x1d	; 29
    1e0e:	0e 94 33 21 	call	0x4266	; 0x4266 <strncpy>
    1e12:	1e a2       	std	Y+38, r1	; 0x26
    1e14:	10 2f       	mov	r17, r16
    1e16:	04 30       	cpi	r16, 0x04	; 4
    1e18:	08 f0       	brcs	.+2      	; 0x1e1c <xTaskGenericCreate+0x88>
    1e1a:	13 e0       	ldi	r17, 0x03	; 3
    1e1c:	1a 8f       	std	Y+26, r17	; 0x1a
    1e1e:	1f a3       	std	Y+39, r17	; 0x27
    1e20:	6e 01       	movw	r12, r28
    1e22:	22 e0       	ldi	r18, 0x02	; 2
    1e24:	c2 0e       	add	r12, r18
    1e26:	d1 1c       	adc	r13, r1
    1e28:	c6 01       	movw	r24, r12
    1e2a:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <vListInitialiseItem>
    1e2e:	ce 01       	movw	r24, r28
    1e30:	0e 96       	adiw	r24, 0x0e	; 14
    1e32:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <vListInitialiseItem>
    1e36:	ca 87       	std	Y+10, r28	; 0x0a
    1e38:	db 87       	std	Y+11, r29	; 0x0b
    1e3a:	84 e0       	ldi	r24, 0x04	; 4
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	a0 e0       	ldi	r26, 0x00	; 0
    1e40:	b0 e0       	ldi	r27, 0x00	; 0
    1e42:	81 1b       	sub	r24, r17
    1e44:	91 09       	sbc	r25, r1
    1e46:	a1 09       	sbc	r26, r1
    1e48:	b1 09       	sbc	r27, r1
    1e4a:	8e 87       	std	Y+14, r24	; 0x0e
    1e4c:	9f 87       	std	Y+15, r25	; 0x0f
    1e4e:	a8 8b       	std	Y+16, r26	; 0x10
    1e50:	b9 8b       	std	Y+17, r27	; 0x11
    1e52:	ce 8b       	std	Y+22, r28	; 0x16
    1e54:	df 8b       	std	Y+23, r29	; 0x17
    1e56:	a2 01       	movw	r20, r4
    1e58:	b5 01       	movw	r22, r10
    1e5a:	c3 01       	movw	r24, r6
    1e5c:	0e 94 78 0a 	call	0x14f0	; 0x14f0 <pxPortInitialiseStack>
    1e60:	88 83       	st	Y, r24
    1e62:	99 83       	std	Y+1, r25	; 0x01
    1e64:	e1 14       	cp	r14, r1
    1e66:	f1 04       	cpc	r15, r1
    1e68:	19 f0       	breq	.+6      	; 0x1e70 <xTaskGenericCreate+0xdc>
    1e6a:	f7 01       	movw	r30, r14
    1e6c:	c0 83       	st	Z, r28
    1e6e:	d1 83       	std	Z+1, r29	; 0x01
    1e70:	0f b6       	in	r0, 0x3f	; 63
    1e72:	f8 94       	cli
    1e74:	0f 92       	push	r0
    1e76:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    1e7a:	8f 5f       	subi	r24, 0xFF	; 255
    1e7c:	80 93 c4 30 	sts	0x30C4, r24	; 0x8030c4 <uxCurrentNumberOfTasks>
    1e80:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    1e84:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1e88:	89 2b       	or	r24, r25
    1e8a:	89 f5       	brne	.+98     	; 0x1eee <xTaskGenericCreate+0x15a>
    1e8c:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    1e90:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    1e94:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    1e98:	81 30       	cpi	r24, 0x01	; 1
    1e9a:	c1 f5       	brne	.+112    	; 0x1f0c <xTaskGenericCreate+0x178>
    1e9c:	8c ee       	ldi	r24, 0xEC	; 236
    1e9e:	90 e3       	ldi	r25, 0x30	; 48
    1ea0:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    1ea4:	87 ef       	ldi	r24, 0xF7	; 247
    1ea6:	90 e3       	ldi	r25, 0x30	; 48
    1ea8:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    1eac:	82 e0       	ldi	r24, 0x02	; 2
    1eae:	91 e3       	ldi	r25, 0x31	; 49
    1eb0:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    1eb4:	8d e0       	ldi	r24, 0x0D	; 13
    1eb6:	91 e3       	ldi	r25, 0x31	; 49
    1eb8:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    1ebc:	81 ee       	ldi	r24, 0xE1	; 225
    1ebe:	90 e3       	ldi	r25, 0x30	; 48
    1ec0:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    1ec4:	86 ed       	ldi	r24, 0xD6	; 214
    1ec6:	90 e3       	ldi	r25, 0x30	; 48
    1ec8:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    1ecc:	87 ec       	ldi	r24, 0xC7	; 199
    1ece:	90 e3       	ldi	r25, 0x30	; 48
    1ed0:	0e 94 cb 09 	call	0x1396	; 0x1396 <vListInitialise>
    1ed4:	81 ee       	ldi	r24, 0xE1	; 225
    1ed6:	90 e3       	ldi	r25, 0x30	; 48
    1ed8:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <pxDelayedTaskList>
    1edc:	90 93 d5 30 	sts	0x30D5, r25	; 0x8030d5 <pxDelayedTaskList+0x1>
    1ee0:	86 ed       	ldi	r24, 0xD6	; 214
    1ee2:	90 e3       	ldi	r25, 0x30	; 48
    1ee4:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    1ee8:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    1eec:	0f c0       	rjmp	.+30     	; 0x1f0c <xTaskGenericCreate+0x178>
    1eee:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    1ef2:	81 11       	cpse	r24, r1
    1ef4:	0b c0       	rjmp	.+22     	; 0x1f0c <xTaskGenericCreate+0x178>
    1ef6:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    1efa:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1efe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f00:	08 17       	cp	r16, r24
    1f02:	20 f0       	brcs	.+8      	; 0x1f0c <xTaskGenericCreate+0x178>
    1f04:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    1f08:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    1f0c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f0e:	90 91 bf 30 	lds	r25, 0x30BF	; 0x8030bf <uxTopUsedPriority>
    1f12:	98 17       	cp	r25, r24
    1f14:	10 f4       	brcc	.+4      	; 0x1f1a <xTaskGenericCreate+0x186>
    1f16:	80 93 bf 30 	sts	0x30BF, r24	; 0x8030bf <uxTopUsedPriority>
    1f1a:	90 91 b8 30 	lds	r25, 0x30B8	; 0x8030b8 <uxTaskNumber>
    1f1e:	9f 5f       	subi	r25, 0xFF	; 255
    1f20:	90 93 b8 30 	sts	0x30B8, r25	; 0x8030b8 <uxTaskNumber>
    1f24:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    1f28:	98 17       	cp	r25, r24
    1f2a:	10 f4       	brcc	.+4      	; 0x1f30 <xTaskGenericCreate+0x19c>
    1f2c:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    1f30:	fb e0       	ldi	r31, 0x0B	; 11
    1f32:	8f 9f       	mul	r24, r31
    1f34:	c0 01       	movw	r24, r0
    1f36:	11 24       	eor	r1, r1
    1f38:	b6 01       	movw	r22, r12
    1f3a:	84 51       	subi	r24, 0x14	; 20
    1f3c:	9f 4c       	sbci	r25, 0xCF	; 207
    1f3e:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <vListInsertEnd>
    1f42:	0f 90       	pop	r0
    1f44:	0f be       	out	0x3f, r0	; 63
    1f46:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    1f4a:	88 23       	and	r24, r24
    1f4c:	59 f0       	breq	.+22     	; 0x1f64 <xTaskGenericCreate+0x1d0>
    1f4e:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    1f52:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1f56:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f58:	80 17       	cp	r24, r16
    1f5a:	30 f4       	brcc	.+12     	; 0x1f68 <xTaskGenericCreate+0x1d4>
    1f5c:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	09 c0       	rjmp	.+18     	; 0x1f76 <xTaskGenericCreate+0x1e2>
    1f64:	81 e0       	ldi	r24, 0x01	; 1
    1f66:	07 c0       	rjmp	.+14     	; 0x1f76 <xTaskGenericCreate+0x1e2>
    1f68:	81 e0       	ldi	r24, 0x01	; 1
    1f6a:	05 c0       	rjmp	.+10     	; 0x1f76 <xTaskGenericCreate+0x1e2>
    1f6c:	cb 8e       	std	Y+27, r12	; 0x1b
    1f6e:	dc 8e       	std	Y+28, r13	; 0x1c
    1f70:	c6 01       	movw	r24, r12
    1f72:	3b cf       	rjmp	.-394    	; 0x1dea <xTaskGenericCreate+0x56>
    1f74:	8f ef       	ldi	r24, 0xFF	; 255
    1f76:	df 91       	pop	r29
    1f78:	cf 91       	pop	r28
    1f7a:	1f 91       	pop	r17
    1f7c:	0f 91       	pop	r16
    1f7e:	ff 90       	pop	r15
    1f80:	ef 90       	pop	r14
    1f82:	df 90       	pop	r13
    1f84:	cf 90       	pop	r12
    1f86:	bf 90       	pop	r11
    1f88:	af 90       	pop	r10
    1f8a:	9f 90       	pop	r9
    1f8c:	8f 90       	pop	r8
    1f8e:	7f 90       	pop	r7
    1f90:	6f 90       	pop	r6
    1f92:	5f 90       	pop	r5
    1f94:	4f 90       	pop	r4
    1f96:	08 95       	ret

00001f98 <uxTaskPriorityGet>:
    1f98:	0f b6       	in	r0, 0x3f	; 63
    1f9a:	f8 94       	cli
    1f9c:	0f 92       	push	r0
    1f9e:	00 97       	sbiw	r24, 0x00	; 0
    1fa0:	21 f4       	brne	.+8      	; 0x1faa <uxTaskPriorityGet+0x12>
    1fa2:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    1fa6:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1faa:	0f 90       	pop	r0
    1fac:	0f be       	out	0x3f, r0	; 63
    1fae:	fc 01       	movw	r30, r24
    1fb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb2:	08 95       	ret

00001fb4 <vTaskStartScheduler>:
    1fb4:	af 92       	push	r10
    1fb6:	bf 92       	push	r11
    1fb8:	cf 92       	push	r12
    1fba:	df 92       	push	r13
    1fbc:	ef 92       	push	r14
    1fbe:	ff 92       	push	r15
    1fc0:	0f 93       	push	r16
    1fc2:	a1 2c       	mov	r10, r1
    1fc4:	b1 2c       	mov	r11, r1
    1fc6:	c1 2c       	mov	r12, r1
    1fc8:	d1 2c       	mov	r13, r1
    1fca:	0f 2e       	mov	r0, r31
    1fcc:	f5 ec       	ldi	r31, 0xC5	; 197
    1fce:	ef 2e       	mov	r14, r31
    1fd0:	f0 e3       	ldi	r31, 0x30	; 48
    1fd2:	ff 2e       	mov	r15, r31
    1fd4:	f0 2d       	mov	r31, r0
    1fd6:	00 e0       	ldi	r16, 0x00	; 0
    1fd8:	20 e0       	ldi	r18, 0x00	; 0
    1fda:	30 e0       	ldi	r19, 0x00	; 0
    1fdc:	44 e6       	ldi	r20, 0x64	; 100
    1fde:	50 e0       	ldi	r21, 0x00	; 0
    1fe0:	6e e2       	ldi	r22, 0x2E	; 46
    1fe2:	70 e2       	ldi	r23, 0x20	; 32
    1fe4:	84 e7       	ldi	r24, 0x74	; 116
    1fe6:	9e e0       	ldi	r25, 0x0E	; 14
    1fe8:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGenericCreate>
    1fec:	81 30       	cpi	r24, 0x01	; 1
    1fee:	69 f4       	brne	.+26     	; 0x200a <vTaskStartScheduler+0x56>
    1ff0:	f8 94       	cli
    1ff2:	80 93 bd 30 	sts	0x30BD, r24	; 0x8030bd <xSchedulerRunning>
    1ff6:	10 92 c0 30 	sts	0x30C0, r1	; 0x8030c0 <xTickCount>
    1ffa:	10 92 c1 30 	sts	0x30C1, r1	; 0x8030c1 <xTickCount+0x1>
    1ffe:	10 92 c2 30 	sts	0x30C2, r1	; 0x8030c2 <xTickCount+0x2>
    2002:	10 92 c3 30 	sts	0x30C3, r1	; 0x8030c3 <xTickCount+0x3>
    2006:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <xPortStartScheduler>
    200a:	0f 91       	pop	r16
    200c:	ff 90       	pop	r15
    200e:	ef 90       	pop	r14
    2010:	df 90       	pop	r13
    2012:	cf 90       	pop	r12
    2014:	bf 90       	pop	r11
    2016:	af 90       	pop	r10
    2018:	08 95       	ret

0000201a <vTaskSuspendAll>:
    201a:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    201e:	8f 5f       	subi	r24, 0xFF	; 255
    2020:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>
    2024:	08 95       	ret

00002026 <xTaskGetTickCount>:
    2026:	0f b6       	in	r0, 0x3f	; 63
    2028:	f8 94       	cli
    202a:	0f 92       	push	r0
    202c:	60 91 c0 30 	lds	r22, 0x30C0	; 0x8030c0 <xTickCount>
    2030:	70 91 c1 30 	lds	r23, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2034:	80 91 c2 30 	lds	r24, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2038:	90 91 c3 30 	lds	r25, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    203c:	0f 90       	pop	r0
    203e:	0f be       	out	0x3f, r0	; 63
    2040:	08 95       	ret

00002042 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2042:	00 97       	sbiw	r24, 0x00	; 0
    2044:	21 f4       	brne	.+8      	; 0x204e <pcTaskGetTaskName+0xc>
    2046:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    204a:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    204e:	4d 96       	adiw	r24, 0x1d	; 29
    2050:	08 95       	ret

00002052 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2052:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xIdleTaskHandle>
    2056:	90 91 c6 30 	lds	r25, 0x30C6	; 0x8030c6 <xIdleTaskHandle+0x1>
    205a:	08 95       	ret

0000205c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    205c:	ff 92       	push	r15
    205e:	0f 93       	push	r16
    2060:	1f 93       	push	r17
    2062:	cf 93       	push	r28
    2064:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2066:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    206a:	81 11       	cpse	r24, r1
    206c:	ed c0       	rjmp	.+474    	; 0x2248 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    206e:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2072:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2076:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    207a:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    207e:	01 96       	adiw	r24, 0x01	; 1
    2080:	a1 1d       	adc	r26, r1
    2082:	b1 1d       	adc	r27, r1
    2084:	80 93 c0 30 	sts	0x30C0, r24	; 0x8030c0 <xTickCount>
    2088:	90 93 c1 30 	sts	0x30C1, r25	; 0x8030c1 <xTickCount+0x1>
    208c:	a0 93 c2 30 	sts	0x30C2, r26	; 0x8030c2 <xTickCount+0x2>
    2090:	b0 93 c3 30 	sts	0x30C3, r27	; 0x8030c3 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2094:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2098:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    209c:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    20a0:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    20a4:	89 2b       	or	r24, r25
    20a6:	8a 2b       	or	r24, r26
    20a8:	8b 2b       	or	r24, r27
    20aa:	f1 f5       	brne	.+124    	; 0x2128 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    20ac:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    20b0:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    20b4:	20 91 d2 30 	lds	r18, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    20b8:	30 91 d3 30 	lds	r19, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    20bc:	20 93 d4 30 	sts	0x30D4, r18	; 0x8030d4 <pxDelayedTaskList>
    20c0:	30 93 d5 30 	sts	0x30D5, r19	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    20c4:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    20c8:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    20cc:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    20d0:	8f 5f       	subi	r24, 0xFF	; 255
    20d2:	80 93 b9 30 	sts	0x30B9, r24	; 0x8030b9 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    20d6:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    20da:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    20de:	80 81       	ld	r24, Z
    20e0:	81 11       	cpse	r24, r1
    20e2:	0c c0       	rjmp	.+24     	; 0x20fc <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    20e4:	8f ef       	ldi	r24, 0xFF	; 255
    20e6:	9f ef       	ldi	r25, 0xFF	; 255
    20e8:	dc 01       	movw	r26, r24
    20ea:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    20ee:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    20f2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    20f6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    20fa:	16 c0       	rjmp	.+44     	; 0x2128 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    20fc:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2100:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2104:	07 80       	ldd	r0, Z+7	; 0x07
    2106:	f0 85       	ldd	r31, Z+8	; 0x08
    2108:	e0 2d       	mov	r30, r0
    210a:	00 84       	ldd	r0, Z+8	; 0x08
    210c:	f1 85       	ldd	r31, Z+9	; 0x09
    210e:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2110:	82 81       	ldd	r24, Z+2	; 0x02
    2112:	93 81       	ldd	r25, Z+3	; 0x03
    2114:	a4 81       	ldd	r26, Z+4	; 0x04
    2116:	b5 81       	ldd	r27, Z+5	; 0x05
    2118:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    211c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2120:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2124:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2128:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    212c:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2130:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2134:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2138:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    213c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2140:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2144:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2148:	48 17       	cp	r20, r24
    214a:	59 07       	cpc	r21, r25
    214c:	6a 07       	cpc	r22, r26
    214e:	7b 07       	cpc	r23, r27
    2150:	08 f4       	brcc	.+2      	; 0x2154 <vTaskIncrementTick+0xf8>
    2152:	7f c0       	rjmp	.+254    	; 0x2252 <vTaskIncrementTick+0x1f6>
    2154:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2158:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    215c:	80 81       	ld	r24, Z
    215e:	88 23       	and	r24, r24
    2160:	f9 f0       	breq	.+62     	; 0x21a0 <vTaskIncrementTick+0x144>
    2162:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2166:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    216a:	07 80       	ldd	r0, Z+7	; 0x07
    216c:	f0 85       	ldd	r31, Z+8	; 0x08
    216e:	e0 2d       	mov	r30, r0
    2170:	c0 85       	ldd	r28, Z+8	; 0x08
    2172:	d1 85       	ldd	r29, Z+9	; 0x09
    2174:	8a 81       	ldd	r24, Y+2	; 0x02
    2176:	9b 81       	ldd	r25, Y+3	; 0x03
    2178:	ac 81       	ldd	r26, Y+4	; 0x04
    217a:	bd 81       	ldd	r27, Y+5	; 0x05
    217c:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    2180:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2184:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2188:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    218c:	48 17       	cp	r20, r24
    218e:	59 07       	cpc	r21, r25
    2190:	6a 07       	cpc	r22, r26
    2192:	7b 07       	cpc	r23, r27
    2194:	58 f1       	brcs	.+86     	; 0x21ec <vTaskIncrementTick+0x190>
    2196:	0f 2e       	mov	r0, r31
    2198:	fb e0       	ldi	r31, 0x0B	; 11
    219a:	ff 2e       	mov	r15, r31
    219c:	f0 2d       	mov	r31, r0
    219e:	2f c0       	rjmp	.+94     	; 0x21fe <vTaskIncrementTick+0x1a2>
    21a0:	8f ef       	ldi	r24, 0xFF	; 255
    21a2:	9f ef       	ldi	r25, 0xFF	; 255
    21a4:	dc 01       	movw	r26, r24
    21a6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21aa:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21ae:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21b2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    21b6:	4d c0       	rjmp	.+154    	; 0x2252 <vTaskIncrementTick+0x1f6>
    21b8:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    21bc:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    21c0:	07 80       	ldd	r0, Z+7	; 0x07
    21c2:	f0 85       	ldd	r31, Z+8	; 0x08
    21c4:	e0 2d       	mov	r30, r0
    21c6:	c0 85       	ldd	r28, Z+8	; 0x08
    21c8:	d1 85       	ldd	r29, Z+9	; 0x09
    21ca:	8a 81       	ldd	r24, Y+2	; 0x02
    21cc:	9b 81       	ldd	r25, Y+3	; 0x03
    21ce:	ac 81       	ldd	r26, Y+4	; 0x04
    21d0:	bd 81       	ldd	r27, Y+5	; 0x05
    21d2:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    21d6:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    21da:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    21de:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    21e2:	48 17       	cp	r20, r24
    21e4:	59 07       	cpc	r21, r25
    21e6:	6a 07       	cpc	r22, r26
    21e8:	7b 07       	cpc	r23, r27
    21ea:	48 f4       	brcc	.+18     	; 0x21fe <vTaskIncrementTick+0x1a2>
    21ec:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21f0:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21f4:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21f8:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    21fc:	2a c0       	rjmp	.+84     	; 0x2252 <vTaskIncrementTick+0x1f6>
    21fe:	8e 01       	movw	r16, r28
    2200:	0e 5f       	subi	r16, 0xFE	; 254
    2202:	1f 4f       	sbci	r17, 0xFF	; 255
    2204:	c8 01       	movw	r24, r16
    2206:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>
    220a:	88 8d       	ldd	r24, Y+24	; 0x18
    220c:	99 8d       	ldd	r25, Y+25	; 0x19
    220e:	89 2b       	or	r24, r25
    2210:	21 f0       	breq	.+8      	; 0x221a <vTaskIncrementTick+0x1be>
    2212:	ce 01       	movw	r24, r28
    2214:	0e 96       	adiw	r24, 0x0e	; 14
    2216:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>
    221a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    221c:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2220:	98 17       	cp	r25, r24
    2222:	10 f4       	brcc	.+4      	; 0x2228 <vTaskIncrementTick+0x1cc>
    2224:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2228:	f8 9e       	mul	r15, r24
    222a:	c0 01       	movw	r24, r0
    222c:	11 24       	eor	r1, r1
    222e:	b8 01       	movw	r22, r16
    2230:	84 51       	subi	r24, 0x14	; 20
    2232:	9f 4c       	sbci	r25, 0xCF	; 207
    2234:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <vListInsertEnd>
    2238:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    223c:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2240:	80 81       	ld	r24, Z
    2242:	81 11       	cpse	r24, r1
    2244:	b9 cf       	rjmp	.-142    	; 0x21b8 <vTaskIncrementTick+0x15c>
    2246:	ac cf       	rjmp	.-168    	; 0x21a0 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    2248:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    224c:	8f 5f       	subi	r24, 0xFF	; 255
    224e:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2252:	df 91       	pop	r29
    2254:	cf 91       	pop	r28
    2256:	1f 91       	pop	r17
    2258:	0f 91       	pop	r16
    225a:	ff 90       	pop	r15
    225c:	08 95       	ret

0000225e <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    225e:	cf 92       	push	r12
    2260:	df 92       	push	r13
    2262:	ef 92       	push	r14
    2264:	ff 92       	push	r15
    2266:	0f 93       	push	r16
    2268:	1f 93       	push	r17
    226a:	cf 93       	push	r28
    226c:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    226e:	0f b6       	in	r0, 0x3f	; 63
    2270:	f8 94       	cli
    2272:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2274:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2278:	81 50       	subi	r24, 0x01	; 1
    227a:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    227e:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2282:	81 11       	cpse	r24, r1
    2284:	60 c0       	rjmp	.+192    	; 0x2346 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2286:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    228a:	81 11       	cpse	r24, r1
    228c:	2c c0       	rjmp	.+88     	; 0x22e6 <xTaskResumeAll+0x88>
    228e:	5e c0       	rjmp	.+188    	; 0x234c <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2290:	d7 01       	movw	r26, r14
    2292:	17 96       	adiw	r26, 0x07	; 7
    2294:	ed 91       	ld	r30, X+
    2296:	fc 91       	ld	r31, X
    2298:	18 97       	sbiw	r26, 0x08	; 8
    229a:	c0 85       	ldd	r28, Z+8	; 0x08
    229c:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    229e:	ce 01       	movw	r24, r28
    22a0:	0e 96       	adiw	r24, 0x0e	; 14
    22a2:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    22a6:	8e 01       	movw	r16, r28
    22a8:	0e 5f       	subi	r16, 0xFE	; 254
    22aa:	1f 4f       	sbci	r17, 0xFF	; 255
    22ac:	c8 01       	movw	r24, r16
    22ae:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    22b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22b4:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    22b8:	98 17       	cp	r25, r24
    22ba:	10 f4       	brcc	.+4      	; 0x22c0 <xTaskResumeAll+0x62>
    22bc:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    22c0:	d8 9e       	mul	r13, r24
    22c2:	c0 01       	movw	r24, r0
    22c4:	11 24       	eor	r1, r1
    22c6:	b8 01       	movw	r22, r16
    22c8:	84 51       	subi	r24, 0x14	; 20
    22ca:	9f 4c       	sbci	r25, 0xCF	; 207
    22cc:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    22d0:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    22d4:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    22d8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    22da:	82 8d       	ldd	r24, Z+26	; 0x1a
    22dc:	98 17       	cp	r25, r24
    22de:	70 f0       	brcs	.+28     	; 0x22fc <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    22e0:	cc 24       	eor	r12, r12
    22e2:	c3 94       	inc	r12
    22e4:	0b c0       	rjmp	.+22     	; 0x22fc <xTaskResumeAll+0x9e>
    22e6:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    22e8:	0f 2e       	mov	r0, r31
    22ea:	f7 ec       	ldi	r31, 0xC7	; 199
    22ec:	ef 2e       	mov	r14, r31
    22ee:	f0 e3       	ldi	r31, 0x30	; 48
    22f0:	ff 2e       	mov	r15, r31
    22f2:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    22f4:	0f 2e       	mov	r0, r31
    22f6:	fb e0       	ldi	r31, 0x0B	; 11
    22f8:	df 2e       	mov	r13, r31
    22fa:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    22fc:	f7 01       	movw	r30, r14
    22fe:	80 81       	ld	r24, Z
    2300:	81 11       	cpse	r24, r1
    2302:	c6 cf       	rjmp	.-116    	; 0x2290 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2304:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2308:	88 23       	and	r24, r24
    230a:	81 f0       	breq	.+32     	; 0x232c <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    230c:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2310:	88 23       	and	r24, r24
    2312:	99 f0       	breq	.+38     	; 0x233a <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2314:	0e 94 2e 10 	call	0x205c	; 0x205c <vTaskIncrementTick>
						--uxMissedTicks;
    2318:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    231c:	81 50       	subi	r24, 0x01	; 1
    231e:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2322:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2326:	81 11       	cpse	r24, r1
    2328:	f5 cf       	rjmp	.-22     	; 0x2314 <xTaskResumeAll+0xb6>
    232a:	07 c0       	rjmp	.+14     	; 0x233a <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    232c:	f1 e0       	ldi	r31, 0x01	; 1
    232e:	cf 16       	cp	r12, r31
    2330:	21 f0       	breq	.+8      	; 0x233a <xTaskResumeAll+0xdc>
    2332:	80 91 ba 30 	lds	r24, 0x30BA	; 0x8030ba <xMissedYield>
    2336:	81 30       	cpi	r24, 0x01	; 1
    2338:	41 f4       	brne	.+16     	; 0x234a <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    233a:	10 92 ba 30 	sts	0x30BA, r1	; 0x8030ba <xMissedYield>
					portYIELD_WITHIN_API();
    233e:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	03 c0       	rjmp	.+6      	; 0x234c <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2346:	80 e0       	ldi	r24, 0x00	; 0
    2348:	01 c0       	rjmp	.+2      	; 0x234c <xTaskResumeAll+0xee>
    234a:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    234c:	0f 90       	pop	r0
    234e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2350:	df 91       	pop	r29
    2352:	cf 91       	pop	r28
    2354:	1f 91       	pop	r17
    2356:	0f 91       	pop	r16
    2358:	ff 90       	pop	r15
    235a:	ef 90       	pop	r14
    235c:	df 90       	pop	r13
    235e:	cf 90       	pop	r12
    2360:	08 95       	ret

00002362 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2362:	cf 92       	push	r12
    2364:	df 92       	push	r13
    2366:	ef 92       	push	r14
    2368:	ff 92       	push	r15
    236a:	cf 93       	push	r28
    236c:	df 93       	push	r29
    236e:	ec 01       	movw	r28, r24
    2370:	6a 01       	movw	r12, r20
    2372:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2374:	0e 94 0d 10 	call	0x201a	; 0x201a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2378:	88 81       	ld	r24, Y
    237a:	99 81       	ldd	r25, Y+1	; 0x01
    237c:	aa 81       	ldd	r26, Y+2	; 0x02
    237e:	bb 81       	ldd	r27, Y+3	; 0x03
    2380:	c8 0e       	add	r12, r24
    2382:	d9 1e       	adc	r13, r25
    2384:	ea 1e       	adc	r14, r26
    2386:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2388:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    238c:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2390:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2394:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2398:	48 17       	cp	r20, r24
    239a:	59 07       	cpc	r21, r25
    239c:	6a 07       	cpc	r22, r26
    239e:	7b 07       	cpc	r23, r27
    23a0:	b8 f4       	brcc	.+46     	; 0x23d0 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    23a2:	c8 16       	cp	r12, r24
    23a4:	d9 06       	cpc	r13, r25
    23a6:	ea 06       	cpc	r14, r26
    23a8:	fb 06       	cpc	r15, r27
    23aa:	e0 f5       	brcc	.+120    	; 0x2424 <vTaskDelayUntil+0xc2>
    23ac:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    23b0:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    23b4:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    23b8:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    23bc:	c8 82       	st	Y, r12
    23be:	d9 82       	std	Y+1, r13	; 0x01
    23c0:	ea 82       	std	Y+2, r14	; 0x02
    23c2:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    23c4:	8c 15       	cp	r24, r12
    23c6:	9d 05       	cpc	r25, r13
    23c8:	ae 05       	cpc	r26, r14
    23ca:	bf 05       	cpc	r27, r15
    23cc:	f8 f4       	brcc	.+62     	; 0x240c <vTaskDelayUntil+0xaa>
    23ce:	13 c0       	rjmp	.+38     	; 0x23f6 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    23d0:	c8 16       	cp	r12, r24
    23d2:	d9 06       	cpc	r13, r25
    23d4:	ea 06       	cpc	r14, r26
    23d6:	fb 06       	cpc	r15, r27
    23d8:	00 f1       	brcs	.+64     	; 0x241a <vTaskDelayUntil+0xb8>
    23da:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    23de:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    23e2:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    23e6:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    23ea:	8c 15       	cp	r24, r12
    23ec:	9d 05       	cpc	r25, r13
    23ee:	ae 05       	cpc	r26, r14
    23f0:	bf 05       	cpc	r27, r15
    23f2:	98 f0       	brcs	.+38     	; 0x241a <vTaskDelayUntil+0xb8>
    23f4:	17 c0       	rjmp	.+46     	; 0x2424 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    23f6:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    23fa:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    23fe:	02 96       	adiw	r24, 0x02	; 2
    2400:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2404:	c7 01       	movw	r24, r14
    2406:	b6 01       	movw	r22, r12
    2408:	0e 94 7c 0e 	call	0x1cf8	; 0x1cf8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    240c:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2410:	81 11       	cpse	r24, r1
    2412:	0d c0       	rjmp	.+26     	; 0x242e <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2414:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
		}
	}
    2418:	0a c0       	rjmp	.+20     	; 0x242e <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    241a:	c8 82       	st	Y, r12
    241c:	d9 82       	std	Y+1, r13	; 0x01
    241e:	ea 82       	std	Y+2, r14	; 0x02
    2420:	fb 82       	std	Y+3, r15	; 0x03
    2422:	e9 cf       	rjmp	.-46     	; 0x23f6 <vTaskDelayUntil+0x94>
    2424:	c8 82       	st	Y, r12
    2426:	d9 82       	std	Y+1, r13	; 0x01
    2428:	ea 82       	std	Y+2, r14	; 0x02
    242a:	fb 82       	std	Y+3, r15	; 0x03
    242c:	ef cf       	rjmp	.-34     	; 0x240c <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    242e:	df 91       	pop	r29
    2430:	cf 91       	pop	r28
    2432:	ff 90       	pop	r15
    2434:	ef 90       	pop	r14
    2436:	df 90       	pop	r13
    2438:	cf 90       	pop	r12
    243a:	08 95       	ret

0000243c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    243c:	cf 92       	push	r12
    243e:	df 92       	push	r13
    2440:	ef 92       	push	r14
    2442:	ff 92       	push	r15
    2444:	6b 01       	movw	r12, r22
    2446:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2448:	67 2b       	or	r22, r23
    244a:	68 2b       	or	r22, r24
    244c:	69 2b       	or	r22, r25
    244e:	e9 f0       	breq	.+58     	; 0x248a <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2450:	0e 94 0d 10 	call	0x201a	; 0x201a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2454:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2458:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    245c:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2460:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2464:	c8 0e       	add	r12, r24
    2466:	d9 1e       	adc	r13, r25
    2468:	ea 1e       	adc	r14, r26
    246a:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    246c:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2470:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2474:	02 96       	adiw	r24, 0x02	; 2
    2476:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    247a:	c7 01       	movw	r24, r14
    247c:	b6 01       	movw	r22, r12
    247e:	0e 94 7c 0e 	call	0x1cf8	; 0x1cf8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2482:	0e 94 2f 11 	call	0x225e	; 0x225e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2486:	81 11       	cpse	r24, r1
    2488:	02 c0       	rjmp	.+4      	; 0x248e <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    248a:	0e 94 2c 0b 	call	0x1658	; 0x1658 <vPortYield>
		}
	}
    248e:	ff 90       	pop	r15
    2490:	ef 90       	pop	r14
    2492:	df 90       	pop	r13
    2494:	cf 90       	pop	r12
    2496:	08 95       	ret

00002498 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2498:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    249c:	81 11       	cpse	r24, r1
    249e:	0c c0       	rjmp	.+24     	; 0x24b8 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    24a0:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    24a4:	4b e0       	ldi	r20, 0x0B	; 11
    24a6:	e4 9f       	mul	r30, r20
    24a8:	f0 01       	movw	r30, r0
    24aa:	11 24       	eor	r1, r1
    24ac:	e4 51       	subi	r30, 0x14	; 20
    24ae:	ff 4c       	sbci	r31, 0xCF	; 207
    24b0:	80 81       	ld	r24, Z
    24b2:	88 23       	and	r24, r24
    24b4:	29 f0       	breq	.+10     	; 0x24c0 <vTaskSwitchContext+0x28>
    24b6:	14 c0       	rjmp	.+40     	; 0x24e0 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    24b8:	81 e0       	ldi	r24, 0x01	; 1
    24ba:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    24be:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    24c0:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    24c2:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    24c6:	81 50       	subi	r24, 0x01	; 1
    24c8:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    24cc:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    24d0:	9e 9f       	mul	r25, r30
    24d2:	f0 01       	movw	r30, r0
    24d4:	11 24       	eor	r1, r1
    24d6:	e4 51       	subi	r30, 0x14	; 20
    24d8:	ff 4c       	sbci	r31, 0xCF	; 207
    24da:	80 81       	ld	r24, Z
    24dc:	88 23       	and	r24, r24
    24de:	89 f3       	breq	.-30     	; 0x24c2 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    24e0:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    24e4:	28 2f       	mov	r18, r24
    24e6:	30 e0       	ldi	r19, 0x00	; 0
    24e8:	4b e0       	ldi	r20, 0x0B	; 11
    24ea:	84 9f       	mul	r24, r20
    24ec:	c0 01       	movw	r24, r0
    24ee:	11 24       	eor	r1, r1
    24f0:	dc 01       	movw	r26, r24
    24f2:	a4 51       	subi	r26, 0x14	; 20
    24f4:	bf 4c       	sbci	r27, 0xCF	; 207
    24f6:	11 96       	adiw	r26, 0x01	; 1
    24f8:	ed 91       	ld	r30, X+
    24fa:	fc 91       	ld	r31, X
    24fc:	12 97       	sbiw	r26, 0x02	; 2
    24fe:	04 80       	ldd	r0, Z+4	; 0x04
    2500:	f5 81       	ldd	r31, Z+5	; 0x05
    2502:	e0 2d       	mov	r30, r0
    2504:	11 96       	adiw	r26, 0x01	; 1
    2506:	ed 93       	st	X+, r30
    2508:	fc 93       	st	X, r31
    250a:	12 97       	sbiw	r26, 0x02	; 2
    250c:	81 51       	subi	r24, 0x11	; 17
    250e:	9f 4c       	sbci	r25, 0xCF	; 207
    2510:	e8 17       	cp	r30, r24
    2512:	f9 07       	cpc	r31, r25
    2514:	61 f4       	brne	.+24     	; 0x252e <vTaskSwitchContext+0x96>
    2516:	84 81       	ldd	r24, Z+4	; 0x04
    2518:	95 81       	ldd	r25, Z+5	; 0x05
    251a:	4b e0       	ldi	r20, 0x0B	; 11
    251c:	42 9f       	mul	r20, r18
    251e:	f0 01       	movw	r30, r0
    2520:	43 9f       	mul	r20, r19
    2522:	f0 0d       	add	r31, r0
    2524:	11 24       	eor	r1, r1
    2526:	e4 51       	subi	r30, 0x14	; 20
    2528:	ff 4c       	sbci	r31, 0xCF	; 207
    252a:	81 83       	std	Z+1, r24	; 0x01
    252c:	92 83       	std	Z+2, r25	; 0x02
    252e:	8b e0       	ldi	r24, 0x0B	; 11
    2530:	82 9f       	mul	r24, r18
    2532:	f0 01       	movw	r30, r0
    2534:	83 9f       	mul	r24, r19
    2536:	f0 0d       	add	r31, r0
    2538:	11 24       	eor	r1, r1
    253a:	e4 51       	subi	r30, 0x14	; 20
    253c:	ff 4c       	sbci	r31, 0xCF	; 207
    253e:	01 80       	ldd	r0, Z+1	; 0x01
    2540:	f2 81       	ldd	r31, Z+2	; 0x02
    2542:	e0 2d       	mov	r30, r0
    2544:	80 85       	ldd	r24, Z+8	; 0x08
    2546:	91 85       	ldd	r25, Z+9	; 0x09
    2548:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <pxCurrentTCB>
    254c:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <pxCurrentTCB+0x1>
    2550:	08 95       	ret

00002552 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2552:	cf 92       	push	r12
    2554:	df 92       	push	r13
    2556:	ef 92       	push	r14
    2558:	ff 92       	push	r15
    255a:	6a 01       	movw	r12, r20
    255c:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    255e:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    2562:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2566:	62 5f       	subi	r22, 0xF2	; 242
    2568:	7f 4f       	sbci	r23, 0xFF	; 255
    256a:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    256e:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2572:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2576:	02 96       	adiw	r24, 0x02	; 2
    2578:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    257c:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2580:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2584:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2588:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    258c:	bc 01       	movw	r22, r24
    258e:	cd 01       	movw	r24, r26
    2590:	6c 0d       	add	r22, r12
    2592:	7d 1d       	adc	r23, r13
    2594:	8e 1d       	adc	r24, r14
    2596:	9f 1d       	adc	r25, r15
    2598:	0e 94 7c 0e 	call	0x1cf8	; 0x1cf8 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    259c:	ff 90       	pop	r15
    259e:	ef 90       	pop	r14
    25a0:	df 90       	pop	r13
    25a2:	cf 90       	pop	r12
    25a4:	08 95       	ret

000025a6 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    25a6:	0f 93       	push	r16
    25a8:	1f 93       	push	r17
    25aa:	cf 93       	push	r28
    25ac:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    25ae:	dc 01       	movw	r26, r24
    25b0:	17 96       	adiw	r26, 0x07	; 7
    25b2:	ed 91       	ld	r30, X+
    25b4:	fc 91       	ld	r31, X
    25b6:	18 97       	sbiw	r26, 0x08	; 8
    25b8:	c0 85       	ldd	r28, Z+8	; 0x08
    25ba:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    25bc:	8e 01       	movw	r16, r28
    25be:	02 5f       	subi	r16, 0xF2	; 242
    25c0:	1f 4f       	sbci	r17, 0xFF	; 255
    25c2:	c8 01       	movw	r24, r16
    25c4:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    25c8:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    25cc:	81 11       	cpse	r24, r1
    25ce:	16 c0       	rjmp	.+44     	; 0x25fc <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    25d0:	0c 50       	subi	r16, 0x0C	; 12
    25d2:	11 09       	sbc	r17, r1
    25d4:	c8 01       	movw	r24, r16
    25d6:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    25da:	8a 8d       	ldd	r24, Y+26	; 0x1a
    25dc:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    25e0:	98 17       	cp	r25, r24
    25e2:	10 f4       	brcc	.+4      	; 0x25e8 <xTaskRemoveFromEventList+0x42>
    25e4:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    25e8:	bb e0       	ldi	r27, 0x0B	; 11
    25ea:	8b 9f       	mul	r24, r27
    25ec:	c0 01       	movw	r24, r0
    25ee:	11 24       	eor	r1, r1
    25f0:	b8 01       	movw	r22, r16
    25f2:	84 51       	subi	r24, 0x14	; 20
    25f4:	9f 4c       	sbci	r25, 0xCF	; 207
    25f6:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <vListInsertEnd>
    25fa:	05 c0       	rjmp	.+10     	; 0x2606 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    25fc:	b8 01       	movw	r22, r16
    25fe:	87 ec       	ldi	r24, 0xC7	; 199
    2600:	90 e3       	ldi	r25, 0x30	; 48
    2602:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2606:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    260a:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2612:	92 8d       	ldd	r25, Z+26	; 0x1a
    2614:	29 17       	cp	r18, r25
    2616:	08 f4       	brcc	.+2      	; 0x261a <xTaskRemoveFromEventList+0x74>
    2618:	80 e0       	ldi	r24, 0x00	; 0
}
    261a:	df 91       	pop	r29
    261c:	cf 91       	pop	r28
    261e:	1f 91       	pop	r17
    2620:	0f 91       	pop	r16
    2622:	08 95       	ret

00002624 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2624:	20 91 b9 30 	lds	r18, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2628:	fc 01       	movw	r30, r24
    262a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    262c:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    2630:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2634:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2638:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    263c:	41 83       	std	Z+1, r20	; 0x01
    263e:	52 83       	std	Z+2, r21	; 0x02
    2640:	63 83       	std	Z+3, r22	; 0x03
    2642:	74 83       	std	Z+4, r23	; 0x04
    2644:	08 95       	ret

00002646 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2646:	8f 92       	push	r8
    2648:	9f 92       	push	r9
    264a:	af 92       	push	r10
    264c:	bf 92       	push	r11
    264e:	cf 92       	push	r12
    2650:	df 92       	push	r13
    2652:	ef 92       	push	r14
    2654:	ff 92       	push	r15
    2656:	0f 93       	push	r16
    2658:	1f 93       	push	r17
    265a:	cf 93       	push	r28
    265c:	df 93       	push	r29
    265e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2660:	0f b6       	in	r0, 0x3f	; 63
    2662:	f8 94       	cli
    2664:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2666:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    266a:	90 81       	ld	r25, Z
    266c:	98 17       	cp	r25, r24
    266e:	89 f0       	breq	.+34     	; 0x2692 <xTaskCheckForTimeOut+0x4c>
    2670:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2674:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2678:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    267c:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2680:	01 81       	ldd	r16, Z+1	; 0x01
    2682:	12 81       	ldd	r17, Z+2	; 0x02
    2684:	23 81       	ldd	r18, Z+3	; 0x03
    2686:	34 81       	ldd	r19, Z+4	; 0x04
    2688:	80 17       	cp	r24, r16
    268a:	91 07       	cpc	r25, r17
    268c:	a2 07       	cpc	r26, r18
    268e:	b3 07       	cpc	r27, r19
    2690:	a8 f5       	brcc	.+106    	; 0x26fc <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2692:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2696:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    269a:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    269e:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    26a2:	c1 80       	ldd	r12, Z+1	; 0x01
    26a4:	d2 80       	ldd	r13, Z+2	; 0x02
    26a6:	e3 80       	ldd	r14, Z+3	; 0x03
    26a8:	f4 80       	ldd	r15, Z+4	; 0x04
    26aa:	eb 01       	movw	r28, r22
    26ac:	08 81       	ld	r16, Y
    26ae:	19 81       	ldd	r17, Y+1	; 0x01
    26b0:	2a 81       	ldd	r18, Y+2	; 0x02
    26b2:	3b 81       	ldd	r19, Y+3	; 0x03
    26b4:	8c 19       	sub	r24, r12
    26b6:	9d 09       	sbc	r25, r13
    26b8:	ae 09       	sbc	r26, r14
    26ba:	bf 09       	sbc	r27, r15
    26bc:	80 17       	cp	r24, r16
    26be:	91 07       	cpc	r25, r17
    26c0:	a2 07       	cpc	r26, r18
    26c2:	b3 07       	cpc	r27, r19
    26c4:	e8 f4       	brcc	.+58     	; 0x2700 <xTaskCheckForTimeOut+0xba>
    26c6:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    26c8:	80 90 c0 30 	lds	r8, 0x30C0	; 0x8030c0 <xTickCount>
    26cc:	90 90 c1 30 	lds	r9, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    26d0:	a0 90 c2 30 	lds	r10, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    26d4:	b0 90 c3 30 	lds	r11, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    26d8:	b5 01       	movw	r22, r10
    26da:	a4 01       	movw	r20, r8
    26dc:	4c 19       	sub	r20, r12
    26de:	5d 09       	sbc	r21, r13
    26e0:	6e 09       	sbc	r22, r14
    26e2:	7f 09       	sbc	r23, r15
    26e4:	04 1b       	sub	r16, r20
    26e6:	15 0b       	sbc	r17, r21
    26e8:	26 0b       	sbc	r18, r22
    26ea:	37 0b       	sbc	r19, r23
    26ec:	08 83       	st	Y, r16
    26ee:	19 83       	std	Y+1, r17	; 0x01
    26f0:	2a 83       	std	Y+2, r18	; 0x02
    26f2:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    26f4:	0e 94 12 13 	call	0x2624	; 0x2624 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    26f8:	80 e0       	ldi	r24, 0x00	; 0
    26fa:	03 c0       	rjmp	.+6      	; 0x2702 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	01 c0       	rjmp	.+2      	; 0x2702 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2700:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2702:	0f 90       	pop	r0
    2704:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2706:	df 91       	pop	r29
    2708:	cf 91       	pop	r28
    270a:	1f 91       	pop	r17
    270c:	0f 91       	pop	r16
    270e:	ff 90       	pop	r15
    2710:	ef 90       	pop	r14
    2712:	df 90       	pop	r13
    2714:	cf 90       	pop	r12
    2716:	bf 90       	pop	r11
    2718:	af 90       	pop	r10
    271a:	9f 90       	pop	r9
    271c:	8f 90       	pop	r8
    271e:	08 95       	ret

00002720 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    2726:	08 95       	ret

00002728 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2728:	00 97       	sbiw	r24, 0x00	; 0
    272a:	21 f4       	brne	.+8      	; 0x2734 <uxTaskGetStackHighWaterMark+0xc>
    272c:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2730:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2734:	dc 01       	movw	r26, r24
    2736:	5b 96       	adiw	r26, 0x1b	; 27
    2738:	ed 91       	ld	r30, X+
    273a:	fc 91       	ld	r31, X
    273c:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    273e:	80 81       	ld	r24, Z
    2740:	81 31       	cpi	r24, 0x11	; 17
    2742:	41 f4       	brne	.+16     	; 0x2754 <uxTaskGetStackHighWaterMark+0x2c>
    2744:	31 96       	adiw	r30, 0x01	; 1
    2746:	80 e0       	ldi	r24, 0x00	; 0
    2748:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    274a:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    274c:	21 91       	ld	r18, Z+
    274e:	21 31       	cpi	r18, 0x11	; 17
    2750:	e1 f3       	breq	.-8      	; 0x274a <uxTaskGetStackHighWaterMark+0x22>
    2752:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2754:	80 e0       	ldi	r24, 0x00	; 0
    2756:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2758:	08 95       	ret

0000275a <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    275a:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    275e:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2762:	08 95       	ret

00002764 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2764:	0f 93       	push	r16
    2766:	1f 93       	push	r17
    2768:	cf 93       	push	r28
    276a:	df 93       	push	r29
    276c:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    276e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2770:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2774:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2778:	5a 96       	adiw	r26, 0x1a	; 26
    277a:	8c 91       	ld	r24, X
    277c:	28 17       	cp	r18, r24
    277e:	08 f0       	brcs	.+2      	; 0x2782 <vTaskPriorityInherit+0x1e>
    2780:	41 c0       	rjmp	.+130    	; 0x2804 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2782:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2786:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    278a:	5a 96       	adiw	r26, 0x1a	; 26
    278c:	3c 91       	ld	r19, X
    278e:	84 e0       	ldi	r24, 0x04	; 4
    2790:	90 e0       	ldi	r25, 0x00	; 0
    2792:	a0 e0       	ldi	r26, 0x00	; 0
    2794:	b0 e0       	ldi	r27, 0x00	; 0
    2796:	83 1b       	sub	r24, r19
    2798:	91 09       	sbc	r25, r1
    279a:	a1 09       	sbc	r26, r1
    279c:	b1 09       	sbc	r27, r1
    279e:	86 87       	std	Z+14, r24	; 0x0e
    27a0:	97 87       	std	Z+15, r25	; 0x0f
    27a2:	a0 8b       	std	Z+16, r26	; 0x10
    27a4:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    27a6:	8b e0       	ldi	r24, 0x0B	; 11
    27a8:	28 9f       	mul	r18, r24
    27aa:	90 01       	movw	r18, r0
    27ac:	11 24       	eor	r1, r1
    27ae:	24 51       	subi	r18, 0x14	; 20
    27b0:	3f 4c       	sbci	r19, 0xCF	; 207
    27b2:	84 85       	ldd	r24, Z+12	; 0x0c
    27b4:	95 85       	ldd	r25, Z+13	; 0x0d
    27b6:	82 17       	cp	r24, r18
    27b8:	93 07       	cpc	r25, r19
    27ba:	e9 f4       	brne	.+58     	; 0x27f6 <vTaskPriorityInherit+0x92>
    27bc:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    27be:	ef 01       	movw	r28, r30
    27c0:	22 96       	adiw	r28, 0x02	; 2
    27c2:	ce 01       	movw	r24, r28
    27c4:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    27c8:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    27cc:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    27d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    27d2:	f8 01       	movw	r30, r16
    27d4:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    27d6:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    27da:	98 17       	cp	r25, r24
    27dc:	10 f4       	brcc	.+4      	; 0x27e2 <vTaskPriorityInherit+0x7e>
    27de:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    27e2:	fb e0       	ldi	r31, 0x0B	; 11
    27e4:	8f 9f       	mul	r24, r31
    27e6:	c0 01       	movw	r24, r0
    27e8:	11 24       	eor	r1, r1
    27ea:	be 01       	movw	r22, r28
    27ec:	84 51       	subi	r24, 0x14	; 20
    27ee:	9f 4c       	sbci	r25, 0xCF	; 207
    27f0:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <vListInsertEnd>
    27f4:	07 c0       	rjmp	.+14     	; 0x2804 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    27f6:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    27fa:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    27fe:	5a 96       	adiw	r26, 0x1a	; 26
    2800:	8c 91       	ld	r24, X
    2802:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2804:	df 91       	pop	r29
    2806:	cf 91       	pop	r28
    2808:	1f 91       	pop	r17
    280a:	0f 91       	pop	r16
    280c:	08 95       	ret

0000280e <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    280e:	0f 93       	push	r16
    2810:	1f 93       	push	r17
    2812:	cf 93       	push	r28
    2814:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2816:	00 97       	sbiw	r24, 0x00	; 0
    2818:	49 f1       	breq	.+82     	; 0x286c <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    281a:	fc 01       	movw	r30, r24
    281c:	32 8d       	ldd	r19, Z+26	; 0x1a
    281e:	27 a1       	ldd	r18, Z+39	; 0x27
    2820:	32 17       	cp	r19, r18
    2822:	21 f1       	breq	.+72     	; 0x286c <vTaskPriorityDisinherit+0x5e>
    2824:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2826:	8c 01       	movw	r16, r24
    2828:	0e 5f       	subi	r16, 0xFE	; 254
    282a:	1f 4f       	sbci	r17, 0xFF	; 255
    282c:	c8 01       	movw	r24, r16
    282e:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2832:	8f a1       	ldd	r24, Y+39	; 0x27
    2834:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2836:	44 e0       	ldi	r20, 0x04	; 4
    2838:	50 e0       	ldi	r21, 0x00	; 0
    283a:	60 e0       	ldi	r22, 0x00	; 0
    283c:	70 e0       	ldi	r23, 0x00	; 0
    283e:	48 1b       	sub	r20, r24
    2840:	51 09       	sbc	r21, r1
    2842:	61 09       	sbc	r22, r1
    2844:	71 09       	sbc	r23, r1
    2846:	4e 87       	std	Y+14, r20	; 0x0e
    2848:	5f 87       	std	Y+15, r21	; 0x0f
    284a:	68 8b       	std	Y+16, r22	; 0x10
    284c:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    284e:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2852:	98 17       	cp	r25, r24
    2854:	10 f4       	brcc	.+4      	; 0x285a <vTaskPriorityDisinherit+0x4c>
    2856:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    285a:	fb e0       	ldi	r31, 0x0B	; 11
    285c:	8f 9f       	mul	r24, r31
    285e:	c0 01       	movw	r24, r0
    2860:	11 24       	eor	r1, r1
    2862:	b8 01       	movw	r22, r16
    2864:	84 51       	subi	r24, 0x14	; 20
    2866:	9f 4c       	sbci	r25, 0xCF	; 207
    2868:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <vListInsertEnd>
			}
		}
	}
    286c:	df 91       	pop	r29
    286e:	cf 91       	pop	r28
    2870:	1f 91       	pop	r17
    2872:	0f 91       	pop	r16
    2874:	08 95       	ret

00002876 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2876:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2878:	e8 81       	ld	r30, Y
    287a:	f9 81       	ldd	r31, Y+1	; 0x01
    287c:	01 90       	ld	r0, Z+
    287e:	f0 81       	ld	r31, Z
    2880:	e0 2d       	mov	r30, r0
    2882:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2884:	1a 82       	std	Y+2, r1	; 0x02
    2886:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2888:	6f ef       	ldi	r22, 0xFF	; 255
    288a:	7f ef       	ldi	r23, 0xFF	; 255
    288c:	cb 01       	movw	r24, r22
    288e:	0e 94 1e 12 	call	0x243c	; 0x243c <vTaskDelay>
    2892:	fa cf       	rjmp	.-12     	; 0x2888 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002894 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2894:	fc 01       	movw	r30, r24
    2896:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2898:	65 87       	std	Z+13, r22	; 0x0d
    289a:	08 95       	ret

0000289c <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    289c:	4f 92       	push	r4
    289e:	5f 92       	push	r5
    28a0:	6f 92       	push	r6
    28a2:	7f 92       	push	r7
    28a4:	8f 92       	push	r8
    28a6:	9f 92       	push	r9
    28a8:	af 92       	push	r10
    28aa:	bf 92       	push	r11
    28ac:	cf 92       	push	r12
    28ae:	df 92       	push	r13
    28b0:	ef 92       	push	r14
    28b2:	ff 92       	push	r15
    28b4:	0f 93       	push	r16
    28b6:	1f 93       	push	r17
    28b8:	cf 93       	push	r28
    28ba:	df 93       	push	r29
    28bc:	cd b7       	in	r28, 0x3d	; 61
    28be:	de b7       	in	r29, 0x3e	; 62
    28c0:	2a 97       	sbiw	r28, 0x0a	; 10
    28c2:	cd bf       	out	0x3d, r28	; 61
    28c4:	de bf       	out	0x3e, r29	; 62
    28c6:	4c 01       	movw	r8, r24
    28c8:	29 01       	movw	r4, r18
    28ca:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    28cc:	87 e3       	ldi	r24, 0x37	; 55
    28ce:	90 e2       	ldi	r25, 0x20	; 32
    28d0:	f4 01       	movw	r30, r8
    28d2:	80 83       	st	Z, r24
    28d4:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    28d6:	fb 01       	movw	r30, r22
    28d8:	80 81       	ld	r24, Z
    28da:	88 23       	and	r24, r24
    28dc:	69 f0       	breq	.+26     	; 0x28f8 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    28de:	de 01       	movw	r26, r28
    28e0:	11 96       	adiw	r26, 0x01	; 1
    28e2:	31 96       	adiw	r30, 0x01	; 1
    28e4:	90 e0       	ldi	r25, 0x00	; 0
    28e6:	02 c0       	rjmp	.+4      	; 0x28ec <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    28e8:	99 30       	cpi	r25, 0x09	; 9
    28ea:	39 f0       	breq	.+14     	; 0x28fa <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    28ec:	9f 5f       	subi	r25, 0xFF	; 255
    28ee:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    28f0:	81 91       	ld	r24, Z+
    28f2:	81 11       	cpse	r24, r1
    28f4:	f9 cf       	rjmp	.-14     	; 0x28e8 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    28f6:	01 c0       	rjmp	.+2      	; 0x28fa <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    28f8:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    28fa:	e1 e0       	ldi	r30, 0x01	; 1
    28fc:	f0 e0       	ldi	r31, 0x00	; 0
    28fe:	ec 0f       	add	r30, r28
    2900:	fd 1f       	adc	r31, r29
    2902:	e9 0f       	add	r30, r25
    2904:	f1 1d       	adc	r31, r1
    2906:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2908:	74 01       	movw	r14, r8
    290a:	f2 e0       	ldi	r31, 0x02	; 2
    290c:	ef 0e       	add	r14, r31
    290e:	f1 1c       	adc	r15, r1
    2910:	a1 2c       	mov	r10, r1
    2912:	b1 2c       	mov	r11, r1
    2914:	c1 2c       	mov	r12, r1
    2916:	d1 2c       	mov	r13, r1
    2918:	04 2f       	mov	r16, r20
    291a:	94 01       	movw	r18, r8
    291c:	a2 01       	movw	r20, r4
    291e:	be 01       	movw	r22, r28
    2920:	6f 5f       	subi	r22, 0xFF	; 255
    2922:	7f 4f       	sbci	r23, 0xFF	; 255
    2924:	84 ea       	ldi	r24, 0xA4	; 164
    2926:	92 e0       	ldi	r25, 0x02	; 2
    2928:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    292c:	f4 01       	movw	r30, r8
    292e:	66 82       	std	Z+6, r6	; 0x06
    2930:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2932:	40 86       	std	Z+8, r4	; 0x08
    2934:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2936:	20 91 1a 31 	lds	r18, 0x311A	; 0x80311a <last_created_task_pointer>
    293a:	30 91 1b 31 	lds	r19, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    293e:	24 83       	std	Z+4, r18	; 0x04
    2940:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2942:	80 92 1a 31 	sts	0x311A, r8	; 0x80311a <last_created_task_pointer>
    2946:	90 92 1b 31 	sts	0x311B, r9	; 0x80311b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    294a:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    294c:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    294e:	40 90 52 31 	lds	r4, 0x3152	; 0x803152 <portStackTopForTask>
    2952:	50 90 53 31 	lds	r5, 0x3153	; 0x803153 <portStackTopForTask+0x1>
    2956:	ff ef       	ldi	r31, 0xFF	; 255
    2958:	4f 1a       	sub	r4, r31
    295a:	5f 0a       	sbc	r5, r31
    295c:	40 92 52 31 	sts	0x3152, r4	; 0x803152 <portStackTopForTask>
    2960:	50 92 53 31 	sts	0x3153, r5	; 0x803153 <portStackTopForTask+0x1>
    2964:	f4 01       	movw	r30, r8
    2966:	42 86       	std	Z+10, r4	; 0x0a
    2968:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    296a:	16 86       	std	Z+14, r1	; 0x0e
    296c:	17 86       	std	Z+15, r1	; 0x0f
    296e:	10 8a       	std	Z+16, r1	; 0x10
    2970:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2972:	61 14       	cp	r6, r1
    2974:	71 04       	cpc	r7, r1
    2976:	09 f4       	brne	.+2      	; 0x297a <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2978:	44 c0       	rjmp	.+136    	; 0x2a02 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    297a:	81 30       	cpi	r24, 0x01	; 1
    297c:	79 f5       	brne	.+94     	; 0x29dc <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    297e:	6a e0       	ldi	r22, 0x0A	; 10
    2980:	c3 01       	movw	r24, r6
    2982:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2986:	7c 01       	movw	r14, r24
    2988:	65 e9       	ldi	r22, 0x95	; 149
    298a:	74 e0       	ldi	r23, 0x04	; 4
    298c:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2990:	be 01       	movw	r22, r28
    2992:	6f 5f       	subi	r22, 0xFF	; 255
    2994:	7f 4f       	sbci	r23, 0xFF	; 255
    2996:	c7 01       	movw	r24, r14
    2998:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    299c:	6a e0       	ldi	r22, 0x0A	; 10
    299e:	c7 01       	movw	r24, r14
    29a0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    29a4:	7c 01       	movw	r14, r24
    29a6:	6c e8       	ldi	r22, 0x8C	; 140
    29a8:	74 e0       	ldi	r23, 0x04	; 4
    29aa:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    29ae:	6a e0       	ldi	r22, 0x0A	; 10
    29b0:	c7 01       	movw	r24, r14
    29b2:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    29b6:	7c 01       	movw	r14, r24
    29b8:	6e e7       	ldi	r22, 0x7E	; 126
    29ba:	74 e0       	ldi	r23, 0x04	; 4
    29bc:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    29c0:	63 e0       	ldi	r22, 0x03	; 3
    29c2:	c7 01       	movw	r24, r14
    29c4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    29c8:	b2 01       	movw	r22, r4
    29ca:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsEj>
    29ce:	62 e0       	ldi	r22, 0x02	; 2
    29d0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    29d4:	66 e0       	ldi	r22, 0x06	; 6
    29d6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    29da:	13 c0       	rjmp	.+38     	; 0x2a02 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    29dc:	6a e0       	ldi	r22, 0x0A	; 10
    29de:	c3 01       	movw	r24, r6
    29e0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    29e4:	4c 01       	movw	r8, r24
    29e6:	69 e6       	ldi	r22, 0x69	; 105
    29e8:	74 e0       	ldi	r23, 0x04	; 4
    29ea:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    29ee:	be 01       	movw	r22, r28
    29f0:	6f 5f       	subi	r22, 0xFF	; 255
    29f2:	7f 4f       	sbci	r23, 0xFF	; 255
    29f4:	c4 01       	movw	r24, r8
    29f6:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    29fa:	66 e0       	ldi	r22, 0x06	; 6
    29fc:	c4 01       	movw	r24, r8
    29fe:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a02:	2a 96       	adiw	r28, 0x0a	; 10
    2a04:	cd bf       	out	0x3d, r28	; 61
    2a06:	de bf       	out	0x3e, r29	; 62
    2a08:	df 91       	pop	r29
    2a0a:	cf 91       	pop	r28
    2a0c:	1f 91       	pop	r17
    2a0e:	0f 91       	pop	r16
    2a10:	ff 90       	pop	r15
    2a12:	ef 90       	pop	r14
    2a14:	df 90       	pop	r13
    2a16:	cf 90       	pop	r12
    2a18:	bf 90       	pop	r11
    2a1a:	af 90       	pop	r10
    2a1c:	9f 90       	pop	r9
    2a1e:	8f 90       	pop	r8
    2a20:	7f 90       	pop	r7
    2a22:	6f 90       	pop	r6
    2a24:	5f 90       	pop	r5
    2a26:	4f 90       	pop	r4
    2a28:	08 95       	ret

00002a2a <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2a2a:	cf 92       	push	r12
    2a2c:	df 92       	push	r13
    2a2e:	ef 92       	push	r14
    2a30:	ff 92       	push	r15
    2a32:	0f 93       	push	r16
    2a34:	1f 93       	push	r17
    2a36:	cf 93       	push	r28
    2a38:	df 93       	push	r29
    2a3a:	ec 01       	movw	r28, r24
    2a3c:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a40:	9b 81       	ldd	r25, Y+3	; 0x03
    2a42:	0e 94 21 10 	call	0x2042	; 0x2042 <pcTaskGetTaskName>
    2a46:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2a48:	6a e0       	ldi	r22, 0x0A	; 10
    2a4a:	c7 01       	movw	r24, r14
    2a4c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2a50:	8c 01       	movw	r16, r24
    2a52:	68 ea       	ldi	r22, 0xA8	; 168
    2a54:	74 e0       	ldi	r23, 0x04	; 4
    2a56:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2a5a:	6a e0       	ldi	r22, 0x0A	; 10
    2a5c:	c8 01       	movw	r24, r16
    2a5e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2a62:	8c 01       	movw	r16, r24
    2a64:	61 ea       	ldi	r22, 0xA1	; 161
    2a66:	74 e0       	ldi	r23, 0x04	; 4
    2a68:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2a6c:	b6 01       	movw	r22, r12
    2a6e:	c8 01       	movw	r24, r16
    2a70:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2a74:	6a e0       	ldi	r22, 0x0A	; 10
    2a76:	c8 01       	movw	r24, r16
    2a78:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2a7c:	8c 01       	movw	r16, r24
    2a7e:	6b e9       	ldi	r22, 0x9B	; 155
    2a80:	74 e0       	ldi	r23, 0x04	; 4
    2a82:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2a86:	66 e0       	ldi	r22, 0x06	; 6
    2a88:	c8 01       	movw	r24, r16
    2a8a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2a8e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a90:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a92:	e8 85       	ldd	r30, Y+8	; 0x08
    2a94:	f9 85       	ldd	r31, Y+9	; 0x09
    2a96:	01 e1       	ldi	r16, 0x11	; 17
    2a98:	21 e0       	ldi	r18, 0x01	; 1
    2a9a:	a7 01       	movw	r20, r14
    2a9c:	bc 01       	movw	r22, r24
    2a9e:	8e 1b       	sub	r24, r30
    2aa0:	9f 0b       	sbc	r25, r31
    2aa2:	0e 94 17 18 	call	0x302e	; 0x302e <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2aa6:	8c 81       	ldd	r24, Y+4	; 0x04
    2aa8:	9d 81       	ldd	r25, Y+5	; 0x05
    2aaa:	00 97       	sbiw	r24, 0x00	; 0
    2aac:	19 f0       	breq	.+6      	; 0x2ab4 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2aae:	b7 01       	movw	r22, r14
    2ab0:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2ab4:	df 91       	pop	r29
    2ab6:	cf 91       	pop	r28
    2ab8:	1f 91       	pop	r17
    2aba:	0f 91       	pop	r16
    2abc:	ff 90       	pop	r15
    2abe:	ef 90       	pop	r14
    2ac0:	df 90       	pop	r13
    2ac2:	cf 90       	pop	r12
    2ac4:	08 95       	ret

00002ac6 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2ad0:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    2ad4:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2ad8:	00 97       	sbiw	r24, 0x00	; 0
    2ada:	19 f0       	breq	.+6      	; 0x2ae2 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2adc:	be 01       	movw	r22, r28
    2ade:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2ae2:	6a e0       	ldi	r22, 0x0A	; 10
    2ae4:	ce 01       	movw	r24, r28
    2ae6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2aea:	8c 01       	movw	r16, r24
    2aec:	6e eb       	ldi	r22, 0xBE	; 190
    2aee:	74 e0       	ldi	r23, 0x04	; 4
    2af0:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2af4:	6a e0       	ldi	r22, 0x0A	; 10
    2af6:	c8 01       	movw	r24, r16
    2af8:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2afc:	8c 01       	movw	r16, r24
    2afe:	63 eb       	ldi	r22, 0xB3	; 179
    2b00:	74 e0       	ldi	r23, 0x04	; 4
    2b02:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2b06:	6a e0       	ldi	r22, 0x0A	; 10
    2b08:	c8 01       	movw	r24, r16
    2b0a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2b0e:	8c 01       	movw	r16, r24
    2b10:	6d ea       	ldi	r22, 0xAD	; 173
    2b12:	74 e0       	ldi	r23, 0x04	; 4
    2b14:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2b18:	66 e0       	ldi	r22, 0x06	; 6
    2b1a:	c8 01       	movw	r24, r16
    2b1c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2b20:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <portStackTopForTask>
    2b24:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <portStackTopForTask+0x1>
    2b28:	bc 01       	movw	r22, r24
    2b2a:	6f 5f       	subi	r22, 0xFF	; 255
    2b2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2b2e:	01 e1       	ldi	r16, 0x11	; 17
    2b30:	21 e0       	ldi	r18, 0x01	; 1
    2b32:	ae 01       	movw	r20, r28
    2b34:	83 56       	subi	r24, 0x63	; 99
    2b36:	91 09       	sbc	r25, r1
    2b38:	0e 94 17 18 	call	0x302e	; 0x302e <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2b3c:	df 91       	pop	r29
    2b3e:	cf 91       	pop	r28
    2b40:	1f 91       	pop	r17
    2b42:	0f 91       	pop	r16
    2b44:	08 95       	ret

00002b46 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2b46:	8f 92       	push	r8
    2b48:	9f 92       	push	r9
    2b4a:	af 92       	push	r10
    2b4c:	bf 92       	push	r11
    2b4e:	cf 92       	push	r12
    2b50:	df 92       	push	r13
    2b52:	ef 92       	push	r14
    2b54:	ff 92       	push	r15
    2b56:	0f 93       	push	r16
    2b58:	1f 93       	push	r17
    2b5a:	cf 93       	push	r28
    2b5c:	df 93       	push	r29
    2b5e:	ec 01       	movw	r28, r24
    2b60:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2b62:	8a 81       	ldd	r24, Y+2	; 0x02
    2b64:	9b 81       	ldd	r25, Y+3	; 0x03
    2b66:	0e 94 21 10 	call	0x2042	; 0x2042 <pcTaskGetTaskName>
    2b6a:	bc 01       	movw	r22, r24
    2b6c:	c8 01       	movw	r24, r16
    2b6e:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2b72:	d8 01       	movw	r26, r16
    2b74:	ed 91       	ld	r30, X+
    2b76:	fc 91       	ld	r31, X
    2b78:	02 80       	ldd	r0, Z+2	; 0x02
    2b7a:	f3 81       	ldd	r31, Z+3	; 0x03
    2b7c:	e0 2d       	mov	r30, r0
    2b7e:	69 e0       	ldi	r22, 0x09	; 9
    2b80:	c8 01       	movw	r24, r16
    2b82:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2b84:	8a 81       	ldd	r24, Y+2	; 0x02
    2b86:	9b 81       	ldd	r25, Y+3	; 0x03
    2b88:	0e 94 21 10 	call	0x2042	; 0x2042 <pcTaskGetTaskName>
    2b8c:	fc 01       	movw	r30, r24
    2b8e:	01 90       	ld	r0, Z+
    2b90:	00 20       	and	r0, r0
    2b92:	e9 f7       	brne	.-6      	; 0x2b8e <_ZN8frt_task12print_statusER8emstream+0x48>
    2b94:	31 97       	sbiw	r30, 0x01	; 1
    2b96:	e8 1b       	sub	r30, r24
    2b98:	f9 0b       	sbc	r31, r25
    2b9a:	38 97       	sbiw	r30, 0x08	; 8
    2b9c:	48 f4       	brcc	.+18     	; 0x2bb0 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2b9e:	d8 01       	movw	r26, r16
    2ba0:	ed 91       	ld	r30, X+
    2ba2:	fc 91       	ld	r31, X
    2ba4:	02 80       	ldd	r0, Z+2	; 0x02
    2ba6:	f3 81       	ldd	r31, Z+3	; 0x03
    2ba8:	e0 2d       	mov	r30, r0
    2baa:	69 e0       	ldi	r22, 0x09	; 9
    2bac:	c8 01       	movw	r24, r16
    2bae:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2bb0:	ce 84       	ldd	r12, Y+14	; 0x0e
    2bb2:	df 84       	ldd	r13, Y+15	; 0x0f
    2bb4:	e8 88       	ldd	r14, Y+16	; 0x10
    2bb6:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2bb8:	a8 84       	ldd	r10, Y+8	; 0x08
    2bba:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2bbc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bbe:	9b 81       	ldd	r25, Y+3	; 0x03
    2bc0:	0e 94 94 13 	call	0x2728	; 0x2728 <uxTaskGetStackHighWaterMark>
    2bc4:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2bc6:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2bc8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bca:	9b 81       	ldd	r25, Y+3	; 0x03
    2bcc:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <uxTaskPriorityGet>
    2bd0:	68 2f       	mov	r22, r24
    2bd2:	c8 01       	movw	r24, r16
    2bd4:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
    2bd8:	6a e0       	ldi	r22, 0x0A	; 10
    2bda:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2bde:	ec 01       	movw	r28, r24
    2be0:	63 e3       	ldi	r22, 0x33	; 51
    2be2:	75 e0       	ldi	r23, 0x05	; 5
    2be4:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2be8:	68 2d       	mov	r22, r8
    2bea:	ce 01       	movw	r24, r28
    2bec:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2bf0:	6a e0       	ldi	r22, 0x0A	; 10
    2bf2:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2bf6:	ec 01       	movw	r28, r24
    2bf8:	61 e3       	ldi	r22, 0x31	; 49
    2bfa:	75 e0       	ldi	r23, 0x05	; 5
    2bfc:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2c00:	69 2d       	mov	r22, r9
    2c02:	ce 01       	movw	r24, r28
    2c04:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
    2c08:	6a e0       	ldi	r22, 0x0A	; 10
    2c0a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2c0e:	ec 01       	movw	r28, r24
    2c10:	6f e2       	ldi	r22, 0x2F	; 47
    2c12:	75 e0       	ldi	r23, 0x05	; 5
    2c14:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2c18:	b5 01       	movw	r22, r10
    2c1a:	ce 01       	movw	r24, r28
    2c1c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsEj>
    2c20:	6a e0       	ldi	r22, 0x0A	; 10
    2c22:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2c26:	ec 01       	movw	r28, r24
    2c28:	6d e2       	ldi	r22, 0x2D	; 45
    2c2a:	75 e0       	ldi	r23, 0x05	; 5
    2c2c:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2c30:	6a e0       	ldi	r22, 0x0A	; 10
    2c32:	ce 01       	movw	r24, r28
    2c34:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2c38:	ec 01       	movw	r28, r24
    2c3a:	6b e2       	ldi	r22, 0x2B	; 43
    2c3c:	75 e0       	ldi	r23, 0x05	; 5
    2c3e:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2c42:	b7 01       	movw	r22, r14
    2c44:	a6 01       	movw	r20, r12
    2c46:	ce 01       	movw	r24, r28
    2c48:	0e 94 33 1a 	call	0x3466	; 0x3466 <_ZN8emstreamlsEm>
}
    2c4c:	df 91       	pop	r29
    2c4e:	cf 91       	pop	r28
    2c50:	1f 91       	pop	r17
    2c52:	0f 91       	pop	r16
    2c54:	ff 90       	pop	r15
    2c56:	ef 90       	pop	r14
    2c58:	df 90       	pop	r13
    2c5a:	cf 90       	pop	r12
    2c5c:	bf 90       	pop	r11
    2c5e:	af 90       	pop	r10
    2c60:	9f 90       	pop	r9
    2c62:	8f 90       	pop	r8
    2c64:	08 95       	ret

00002c66 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2c66:	cf 93       	push	r28
    2c68:	df 93       	push	r29
    2c6a:	ec 01       	movw	r28, r24
    2c6c:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2c6e:	db 01       	movw	r26, r22
    2c70:	ed 91       	ld	r30, X+
    2c72:	fc 91       	ld	r31, X
    2c74:	02 80       	ldd	r0, Z+2	; 0x02
    2c76:	f3 81       	ldd	r31, Z+3	; 0x03
    2c78:	e0 2d       	mov	r30, r0
    2c7a:	be 01       	movw	r22, r28
    2c7c:	19 95       	eicall
	return (ser_dev);
}
    2c7e:	ce 01       	movw	r24, r28
    2c80:	df 91       	pop	r29
    2c82:	cf 91       	pop	r28
    2c84:	08 95       	ret

00002c86 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2c86:	0f 93       	push	r16
    2c88:	1f 93       	push	r17
    2c8a:	cf 93       	push	r28
    2c8c:	df 93       	push	r29
    2c8e:	ec 01       	movw	r28, r24
    2c90:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2c92:	bc 01       	movw	r22, r24
    2c94:	c8 01       	movw	r24, r16
    2c96:	0e 94 33 16 	call	0x2c66	; 0x2c66 <_ZlsR8emstreamR8frt_task>
    2c9a:	66 e0       	ldi	r22, 0x06	; 6
    2c9c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2ca0:	8c 81       	ldd	r24, Y+4	; 0x04
    2ca2:	9d 81       	ldd	r25, Y+5	; 0x05
    2ca4:	00 97       	sbiw	r24, 0x00	; 0
    2ca6:	19 f0       	breq	.+6      	; 0x2cae <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2ca8:	b8 01       	movw	r22, r16
    2caa:	0e 94 43 16 	call	0x2c86	; 0x2c86 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2cae:	df 91       	pop	r29
    2cb0:	cf 91       	pop	r28
    2cb2:	1f 91       	pop	r17
    2cb4:	0f 91       	pop	r16
    2cb6:	08 95       	ret

00002cb8 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2cb8:	0f 93       	push	r16
    2cba:	1f 93       	push	r17
    2cbc:	cf 93       	push	r28
    2cbe:	df 93       	push	r29
    2cc0:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2cc2:	6a e0       	ldi	r22, 0x0A	; 10
    2cc4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2cc8:	8c 01       	movw	r16, r24
    2cca:	60 e2       	ldi	r22, 0x20	; 32
    2ccc:	75 e0       	ldi	r23, 0x05	; 5
    2cce:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2cd2:	6a e0       	ldi	r22, 0x0A	; 10
    2cd4:	c8 01       	movw	r24, r16
    2cd6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2cda:	8c 01       	movw	r16, r24
    2cdc:	69 e1       	ldi	r22, 0x19	; 25
    2cde:	75 e0       	ldi	r23, 0x05	; 5
    2ce0:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2ce4:	66 e0       	ldi	r22, 0x06	; 6
    2ce6:	c8 01       	movw	r24, r16
    2ce8:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2cec:	6a e0       	ldi	r22, 0x0A	; 10
    2cee:	ce 01       	movw	r24, r28
    2cf0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2cf4:	8c 01       	movw	r16, r24
    2cf6:	68 e0       	ldi	r22, 0x08	; 8
    2cf8:	75 e0       	ldi	r23, 0x05	; 5
    2cfa:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2cfe:	6a e0       	ldi	r22, 0x0A	; 10
    2d00:	c8 01       	movw	r24, r16
    2d02:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2d06:	8c 01       	movw	r16, r24
    2d08:	6c ef       	ldi	r22, 0xFC	; 252
    2d0a:	74 e0       	ldi	r23, 0x04	; 4
    2d0c:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2d10:	6a e0       	ldi	r22, 0x0A	; 10
    2d12:	c8 01       	movw	r24, r16
    2d14:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2d18:	8c 01       	movw	r16, r24
    2d1a:	66 ef       	ldi	r22, 0xF6	; 246
    2d1c:	74 e0       	ldi	r23, 0x04	; 4
    2d1e:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2d22:	66 e0       	ldi	r22, 0x06	; 6
    2d24:	c8 01       	movw	r24, r16
    2d26:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2d2a:	6a e0       	ldi	r22, 0x0A	; 10
    2d2c:	ce 01       	movw	r24, r28
    2d2e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2d32:	8c 01       	movw	r16, r24
    2d34:	65 ee       	ldi	r22, 0xE5	; 229
    2d36:	74 e0       	ldi	r23, 0x04	; 4
    2d38:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2d3c:	6a e0       	ldi	r22, 0x0A	; 10
    2d3e:	c8 01       	movw	r24, r16
    2d40:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2d44:	8c 01       	movw	r16, r24
    2d46:	69 ed       	ldi	r22, 0xD9	; 217
    2d48:	74 e0       	ldi	r23, 0x04	; 4
    2d4a:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2d4e:	6a e0       	ldi	r22, 0x0A	; 10
    2d50:	c8 01       	movw	r24, r16
    2d52:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2d56:	8c 01       	movw	r16, r24
    2d58:	63 ed       	ldi	r22, 0xD3	; 211
    2d5a:	74 e0       	ldi	r23, 0x04	; 4
    2d5c:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2d60:	66 e0       	ldi	r22, 0x06	; 6
    2d62:	c8 01       	movw	r24, r16
    2d64:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2d68:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    2d6c:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2d70:	00 97       	sbiw	r24, 0x00	; 0
    2d72:	19 f0       	breq	.+6      	; 0x2d7a <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2d74:	be 01       	movw	r22, r28
    2d76:	0e 94 43 16 	call	0x2c86	; 0x2c86 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2d7a:	0e 94 29 10 	call	0x2052	; 0x2052 <xTaskGetIdleTaskHandle>
    2d7e:	0e 94 94 13 	call	0x2728	; 0x2728 <uxTaskGetStackHighWaterMark>
    2d82:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2d84:	6a e0       	ldi	r22, 0x0A	; 10
    2d86:	ce 01       	movw	r24, r28
    2d88:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2d8c:	ec 01       	movw	r28, r24
    2d8e:	68 ec       	ldi	r22, 0xC8	; 200
    2d90:	74 e0       	ldi	r23, 0x04	; 4
    2d92:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2d96:	61 2f       	mov	r22, r17
    2d98:	ce 01       	movw	r24, r28
    2d9a:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2d9e:	6a e0       	ldi	r22, 0x0A	; 10
    2da0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2da4:	ec 01       	movw	r28, r24
    2da6:	66 ec       	ldi	r22, 0xC6	; 198
    2da8:	74 e0       	ldi	r23, 0x04	; 4
    2daa:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    2dae:	64 e6       	ldi	r22, 0x64	; 100
    2db0:	70 e0       	ldi	r23, 0x00	; 0
    2db2:	ce 01       	movw	r24, r28
    2db4:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsEj>
    2db8:	6a e0       	ldi	r22, 0x0A	; 10
    2dba:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    2dbe:	ec 01       	movw	r28, r24
    2dc0:	63 ec       	ldi	r22, 0xC3	; 195
    2dc2:	74 e0       	ldi	r23, 0x04	; 4
    2dc4:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2dc8:	66 e0       	ldi	r22, 0x06	; 6
    2dca:	ce 01       	movw	r24, r28
    2dcc:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
}
    2dd0:	df 91       	pop	r29
    2dd2:	cf 91       	pop	r28
    2dd4:	1f 91       	pop	r17
    2dd6:	0f 91       	pop	r16
    2dd8:	08 95       	ret

00002dda <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2dda:	0f 93       	push	r16
    2ddc:	cf 93       	push	r28
    2dde:	df 93       	push	r29
    2de0:	1f 92       	push	r1
    2de2:	cd b7       	in	r28, 0x3d	; 61
    2de4:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2de6:	00 e0       	ldi	r16, 0x00	; 0
    2de8:	2f ef       	ldi	r18, 0xFF	; 255
    2dea:	3f ef       	ldi	r19, 0xFF	; 255
    2dec:	a9 01       	movw	r20, r18
    2dee:	be 01       	movw	r22, r28
    2df0:	6f 5f       	subi	r22, 0xFF	; 255
    2df2:	7f 4f       	sbci	r23, 0xFF	; 255
    2df4:	fc 01       	movw	r30, r24
    2df6:	80 85       	ldd	r24, Z+8	; 0x08
    2df8:	91 85       	ldd	r25, Z+9	; 0x09
    2dfa:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <xQueueGenericReceive>
    2dfe:	81 30       	cpi	r24, 0x01	; 1
    2e00:	19 f4       	brne	.+6      	; 0x2e08 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e02:	89 81       	ldd	r24, Y+1	; 0x01
    2e04:	90 e0       	ldi	r25, 0x00	; 0
    2e06:	02 c0       	rjmp	.+4      	; 0x2e0c <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2e08:	8f ef       	ldi	r24, 0xFF	; 255
    2e0a:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2e0c:	0f 90       	pop	r0
    2e0e:	df 91       	pop	r29
    2e10:	cf 91       	pop	r28
    2e12:	0f 91       	pop	r16
    2e14:	08 95       	ret

00002e16 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2e16:	fc 01       	movw	r30, r24
    2e18:	80 85       	ldd	r24, Z+8	; 0x08
    2e1a:	91 85       	ldd	r25, Z+9	; 0x09
    2e1c:	0e 94 6c 0e 	call	0x1cd8	; 0x1cd8 <uxQueueMessagesWaiting>
    2e20:	91 e0       	ldi	r25, 0x01	; 1
    2e22:	81 11       	cpse	r24, r1
    2e24:	01 c0       	rjmp	.+2      	; 0x2e28 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2e26:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2e28:	89 2f       	mov	r24, r25
    2e2a:	08 95       	ret

00002e2c <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2e2c:	0f 93       	push	r16
    2e2e:	cf 93       	push	r28
    2e30:	df 93       	push	r29
    2e32:	1f 92       	push	r1
    2e34:	cd b7       	in	r28, 0x3d	; 61
    2e36:	de b7       	in	r29, 0x3e	; 62
    2e38:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2e3a:	fc 01       	movw	r30, r24
    2e3c:	22 85       	ldd	r18, Z+10	; 0x0a
    2e3e:	33 85       	ldd	r19, Z+11	; 0x0b
    2e40:	44 85       	ldd	r20, Z+12	; 0x0c
    2e42:	55 85       	ldd	r21, Z+13	; 0x0d
    2e44:	00 e0       	ldi	r16, 0x00	; 0
    2e46:	be 01       	movw	r22, r28
    2e48:	6f 5f       	subi	r22, 0xFF	; 255
    2e4a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e4c:	80 85       	ldd	r24, Z+8	; 0x08
    2e4e:	91 85       	ldd	r25, Z+9	; 0x09
    2e50:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <xQueueGenericSend>
    2e54:	91 e0       	ldi	r25, 0x01	; 1
    2e56:	81 11       	cpse	r24, r1
    2e58:	01 c0       	rjmp	.+2      	; 0x2e5c <_ZN14frt_text_queue7putcharEc+0x30>
    2e5a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2e5c:	89 2f       	mov	r24, r25
    2e5e:	0f 90       	pop	r0
    2e60:	df 91       	pop	r29
    2e62:	cf 91       	pop	r28
    2e64:	0f 91       	pop	r16
    2e66:	08 95       	ret

00002e68 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2e68:	8f 92       	push	r8
    2e6a:	9f 92       	push	r9
    2e6c:	bf 92       	push	r11
    2e6e:	cf 92       	push	r12
    2e70:	df 92       	push	r13
    2e72:	ef 92       	push	r14
    2e74:	ff 92       	push	r15
    2e76:	0f 93       	push	r16
    2e78:	1f 93       	push	r17
    2e7a:	cf 93       	push	r28
    2e7c:	df 93       	push	r29
    2e7e:	ec 01       	movw	r28, r24
    2e80:	b6 2e       	mov	r11, r22
    2e82:	4a 01       	movw	r8, r20
    2e84:	68 01       	movw	r12, r16
    2e86:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2e88:	0e 94 73 19 	call	0x32e6	; 0x32e6 <_ZN8emstreamC1Ev>
    2e8c:	8f e3       	ldi	r24, 0x3F	; 63
    2e8e:	90 e2       	ldi	r25, 0x20	; 32
    2e90:	88 83       	st	Y, r24
    2e92:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2e94:	8e 86       	std	Y+14, r8	; 0x0e
    2e96:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2e98:	40 e0       	ldi	r20, 0x00	; 0
    2e9a:	61 e0       	ldi	r22, 0x01	; 1
    2e9c:	8b 2d       	mov	r24, r11
    2e9e:	0e 94 df 0c 	call	0x19be	; 0x19be <xQueueGenericCreate>
    2ea2:	88 87       	std	Y+8, r24	; 0x08
    2ea4:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2ea6:	ca 86       	std	Y+10, r12	; 0x0a
    2ea8:	db 86       	std	Y+11, r13	; 0x0b
    2eaa:	ec 86       	std	Y+12, r14	; 0x0c
    2eac:	fd 86       	std	Y+13, r15	; 0x0d
}
    2eae:	df 91       	pop	r29
    2eb0:	cf 91       	pop	r28
    2eb2:	1f 91       	pop	r17
    2eb4:	0f 91       	pop	r16
    2eb6:	ff 90       	pop	r15
    2eb8:	ef 90       	pop	r14
    2eba:	df 90       	pop	r13
    2ebc:	cf 90       	pop	r12
    2ebe:	bf 90       	pop	r11
    2ec0:	9f 90       	pop	r9
    2ec2:	8f 90       	pop	r8
    2ec4:	08 95       	ret

00002ec6 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2ec6:	cf 92       	push	r12
    2ec8:	df 92       	push	r13
    2eca:	ef 92       	push	r14
    2ecc:	ff 92       	push	r15
    2ece:	cf 93       	push	r28
    2ed0:	df 93       	push	r29
    2ed2:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2ed4:	68 81       	ld	r22, Y
    2ed6:	79 81       	ldd	r23, Y+1	; 0x01
    2ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eda:	9b 81       	ldd	r25, Y+3	; 0x03
    2edc:	0f 2e       	mov	r0, r31
    2ede:	f8 ee       	ldi	r31, 0xE8	; 232
    2ee0:	cf 2e       	mov	r12, r31
    2ee2:	f3 e0       	ldi	r31, 0x03	; 3
    2ee4:	df 2e       	mov	r13, r31
    2ee6:	e1 2c       	mov	r14, r1
    2ee8:	f1 2c       	mov	r15, r1
    2eea:	f0 2d       	mov	r31, r0
    2eec:	a7 01       	movw	r20, r14
    2eee:	96 01       	movw	r18, r12
    2ef0:	0e 94 b8 20 	call	0x4170	; 0x4170 <__udivmodsi4>
    2ef4:	9b 01       	movw	r18, r22
    2ef6:	ac 01       	movw	r20, r24
    2ef8:	60 e4       	ldi	r22, 0x40	; 64
    2efa:	72 e4       	ldi	r23, 0x42	; 66
    2efc:	8f e0       	ldi	r24, 0x0F	; 15
    2efe:	90 e0       	ldi	r25, 0x00	; 0
    2f00:	0e 94 a8 20 	call	0x4150	; 0x4150 <__mulsi3>
    2f04:	a7 01       	movw	r20, r14
    2f06:	96 01       	movw	r18, r12
    2f08:	0e 94 b8 20 	call	0x4170	; 0x4170 <__udivmodsi4>
    2f0c:	69 01       	movw	r12, r18
    2f0e:	7a 01       	movw	r14, r20
    2f10:	ac 81       	ldd	r26, Y+4	; 0x04
    2f12:	bd 81       	ldd	r27, Y+5	; 0x05
    2f14:	20 e4       	ldi	r18, 0x40	; 64
    2f16:	32 e4       	ldi	r19, 0x42	; 66
    2f18:	4f e0       	ldi	r20, 0x0F	; 15
    2f1a:	50 e0       	ldi	r21, 0x00	; 0
    2f1c:	0e 94 09 21 	call	0x4212	; 0x4212 <__muluhisi3>
    2f20:	20 e0       	ldi	r18, 0x00	; 0
    2f22:	38 e4       	ldi	r19, 0x48	; 72
    2f24:	48 ee       	ldi	r20, 0xE8	; 232
    2f26:	51 e0       	ldi	r21, 0x01	; 1
    2f28:	0e 94 b8 20 	call	0x4170	; 0x4170 <__udivmodsi4>
    2f2c:	c7 01       	movw	r24, r14
    2f2e:	b6 01       	movw	r22, r12
    2f30:	62 0f       	add	r22, r18
    2f32:	73 1f       	adc	r23, r19
    2f34:	84 1f       	adc	r24, r20
    2f36:	95 1f       	adc	r25, r21
}
    2f38:	df 91       	pop	r29
    2f3a:	cf 91       	pop	r28
    2f3c:	ff 90       	pop	r15
    2f3e:	ef 90       	pop	r14
    2f40:	df 90       	pop	r13
    2f42:	cf 90       	pop	r12
    2f44:	08 95       	ret

00002f46 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2f46:	cf 92       	push	r12
    2f48:	df 92       	push	r13
    2f4a:	ef 92       	push	r14
    2f4c:	ff 92       	push	r15
    2f4e:	0f 93       	push	r16
    2f50:	1f 93       	push	r17
    2f52:	cf 93       	push	r28
    2f54:	df 93       	push	r29
    2f56:	cd b7       	in	r28, 0x3d	; 61
    2f58:	de b7       	in	r29, 0x3e	; 62
    2f5a:	2f 97       	sbiw	r28, 0x0f	; 15
    2f5c:	cd bf       	out	0x3d, r28	; 61
    2f5e:	de bf       	out	0x3e, r29	; 62
    2f60:	6c 01       	movw	r12, r24
    2f62:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2f64:	db 01       	movw	r26, r22
    2f66:	6d 91       	ld	r22, X+
    2f68:	7d 91       	ld	r23, X+
    2f6a:	8d 91       	ld	r24, X+
    2f6c:	9c 91       	ld	r25, X
    2f6e:	28 ee       	ldi	r18, 0xE8	; 232
    2f70:	33 e0       	ldi	r19, 0x03	; 3
    2f72:	40 e0       	ldi	r20, 0x00	; 0
    2f74:	50 e0       	ldi	r21, 0x00	; 0
    2f76:	0e 94 b8 20 	call	0x4170	; 0x4170 <__udivmodsi4>
    2f7a:	ba 01       	movw	r22, r20
    2f7c:	a9 01       	movw	r20, r18
    2f7e:	c6 01       	movw	r24, r12
    2f80:	0e 94 33 1a 	call	0x3466	; 0x3466 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2f84:	d6 01       	movw	r26, r12
    2f86:	ed 91       	ld	r30, X+
    2f88:	fc 91       	ld	r31, X
    2f8a:	02 80       	ldd	r0, Z+2	; 0x02
    2f8c:	f3 81       	ldd	r31, Z+3	; 0x03
    2f8e:	e0 2d       	mov	r30, r0
    2f90:	6e e2       	ldi	r22, 0x2E	; 46
    2f92:	c6 01       	movw	r24, r12
    2f94:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2f96:	c8 01       	movw	r24, r16
    2f98:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <_ZN10time_stamp12get_microsecEv>
    2f9c:	8e 01       	movw	r16, r28
    2f9e:	09 5f       	subi	r16, 0xF9	; 249
    2fa0:	1f 4f       	sbci	r17, 0xFF	; 255
    2fa2:	fe 01       	movw	r30, r28
    2fa4:	31 96       	adiw	r30, 0x01	; 1
    2fa6:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2fa8:	2a e0       	ldi	r18, 0x0A	; 10
    2faa:	30 e0       	ldi	r19, 0x00	; 0
    2fac:	40 e0       	ldi	r20, 0x00	; 0
    2fae:	50 e0       	ldi	r21, 0x00	; 0
    2fb0:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__divmodsi4>
    2fb4:	e6 2f       	mov	r30, r22
    2fb6:	28 87       	std	Y+8, r18	; 0x08
    2fb8:	39 87       	std	Y+9, r19	; 0x09
    2fba:	4a 87       	std	Y+10, r20	; 0x0a
    2fbc:	5b 87       	std	Y+11, r21	; 0x0b
    2fbe:	68 85       	ldd	r22, Y+8	; 0x08
    2fc0:	79 85       	ldd	r23, Y+9	; 0x09
    2fc2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fc4:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2fc6:	20 e3       	ldi	r18, 0x30	; 48
    2fc8:	2e 0f       	add	r18, r30
    2fca:	d8 01       	movw	r26, r16
    2fcc:	2e 93       	st	-X, r18
    2fce:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2fd0:	ae 15       	cp	r26, r14
    2fd2:	bf 05       	cpc	r27, r15
    2fd4:	49 f7       	brne	.-46     	; 0x2fa8 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2fd6:	1f 82       	std	Y+7, r1	; 0x07
    2fd8:	be 01       	movw	r22, r28
    2fda:	6f 5f       	subi	r22, 0xFF	; 255
    2fdc:	7f 4f       	sbci	r23, 0xFF	; 255
    2fde:	c6 01       	movw	r24, r12
    2fe0:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2fe4:	c6 01       	movw	r24, r12
    2fe6:	2f 96       	adiw	r28, 0x0f	; 15
    2fe8:	cd bf       	out	0x3d, r28	; 61
    2fea:	de bf       	out	0x3e, r29	; 62
    2fec:	df 91       	pop	r29
    2fee:	cf 91       	pop	r28
    2ff0:	1f 91       	pop	r17
    2ff2:	0f 91       	pop	r16
    2ff4:	ff 90       	pop	r15
    2ff6:	ef 90       	pop	r14
    2ff8:	df 90       	pop	r13
    2ffa:	cf 90       	pop	r12
    2ffc:	08 95       	ret

00002ffe <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2ffe:	cf 93       	push	r28
    3000:	df 93       	push	r29
    3002:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3004:	0f b6       	in	r0, 0x3f	; 63
    3006:	f8 94       	cli
    3008:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    300a:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    300e:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3012:	8c 83       	std	Y+4, r24	; 0x04
    3014:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3016:	0e 94 13 10 	call	0x2026	; 0x2026 <xTaskGetTickCount>
    301a:	68 83       	st	Y, r22
    301c:	79 83       	std	Y+1, r23	; 0x01
    301e:	8a 83       	std	Y+2, r24	; 0x02
    3020:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3022:	0f 90       	pop	r0
    3024:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3026:	ce 01       	movw	r24, r28
    3028:	df 91       	pop	r29
    302a:	cf 91       	pop	r28
    302c:	08 95       	ret

0000302e <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    302e:	5f 92       	push	r5
    3030:	6f 92       	push	r6
    3032:	7f 92       	push	r7
    3034:	8f 92       	push	r8
    3036:	9f 92       	push	r9
    3038:	af 92       	push	r10
    303a:	bf 92       	push	r11
    303c:	cf 92       	push	r12
    303e:	df 92       	push	r13
    3040:	ef 92       	push	r14
    3042:	ff 92       	push	r15
    3044:	0f 93       	push	r16
    3046:	1f 93       	push	r17
    3048:	cf 93       	push	r28
    304a:	df 93       	push	r29
    304c:	5c 01       	movw	r10, r24
    304e:	4b 01       	movw	r8, r22
    3050:	7a 01       	movw	r14, r20
    3052:	12 2f       	mov	r17, r18
    3054:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3056:	63 e0       	ldi	r22, 0x03	; 3
    3058:	ca 01       	movw	r24, r20
    305a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    305e:	a8 14       	cp	r10, r8
    3060:	b9 04       	cpc	r11, r9
    3062:	08 f0       	brcs	.+2      	; 0x3066 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3064:	7d c0       	rjmp	.+250    	; 0x3160 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3066:	65 01       	movw	r12, r10
    3068:	84 e1       	ldi	r24, 0x14	; 20
    306a:	c8 0e       	add	r12, r24
    306c:	d1 1c       	adc	r13, r1
    306e:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3070:	6a 2c       	mov	r6, r10
    3072:	5b 2c       	mov	r5, r11
    3074:	b5 01       	movw	r22, r10
    3076:	c7 01       	movw	r24, r14
    3078:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsEj>
    307c:	6a e0       	ldi	r22, 0x0A	; 10
    307e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    3082:	65 e4       	ldi	r22, 0x45	; 69
    3084:	75 e0       	ldi	r23, 0x05	; 5
    3086:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    308a:	11 23       	and	r17, r17
    308c:	09 f4       	brne	.+2      	; 0x3090 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    308e:	6d c0       	rjmp	.+218    	; 0x316a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3090:	00 23       	and	r16, r16
    3092:	09 f4       	brne	.+2      	; 0x3096 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3094:	6a c0       	rjmp	.+212    	; 0x316a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3096:	6a e0       	ldi	r22, 0x0A	; 10
    3098:	c7 01       	movw	r24, r14
    309a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    309e:	60 e4       	ldi	r22, 0x40	; 64
    30a0:	75 e0       	ldi	r23, 0x05	; 5
    30a2:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    30a6:	61 c0       	rjmp	.+194    	; 0x316a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    30a8:	11 23       	and	r17, r17
    30aa:	71 f0       	breq	.+28     	; 0x30c8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    30ac:	01 11       	cpse	r16, r1
    30ae:	0c c0       	rjmp	.+24     	; 0x30c8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    30b0:	88 81       	ld	r24, Y
    30b2:	87 15       	cp	r24, r7
    30b4:	49 f0       	breq	.+18     	; 0x30c8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    30b6:	6a e0       	ldi	r22, 0x0A	; 10
    30b8:	c7 01       	movw	r24, r14
    30ba:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    30be:	6b e3       	ldi	r22, 0x3B	; 59
    30c0:	75 e0       	ldi	r23, 0x05	; 5
    30c2:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    30c6:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    30c8:	69 91       	ld	r22, Y+
    30ca:	c7 01       	movw	r24, r14
    30cc:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    30d0:	dc 01       	movw	r26, r24
    30d2:	ed 91       	ld	r30, X+
    30d4:	fc 91       	ld	r31, X
    30d6:	02 80       	ldd	r0, Z+2	; 0x02
    30d8:	f3 81       	ldd	r31, Z+3	; 0x03
    30da:	e0 2d       	mov	r30, r0
    30dc:	60 e2       	ldi	r22, 0x20	; 32
    30de:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    30e0:	cc 16       	cp	r12, r28
    30e2:	dd 06       	cpc	r13, r29
    30e4:	09 f7       	brne	.-62     	; 0x30a8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    30e6:	11 23       	and	r17, r17
    30e8:	89 f0       	breq	.+34     	; 0x310c <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    30ea:	6a e0       	ldi	r22, 0x0A	; 10
    30ec:	c7 01       	movw	r24, r14
    30ee:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    30f2:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    30f4:	65 e3       	ldi	r22, 0x35	; 53
    30f6:	75 e0       	ldi	r23, 0x05	; 5
    30f8:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    30fc:	e8 81       	ld	r30, Y
    30fe:	f9 81       	ldd	r31, Y+1	; 0x01
    3100:	02 80       	ldd	r0, Z+2	; 0x02
    3102:	f3 81       	ldd	r31, Z+3	; 0x03
    3104:	e0 2d       	mov	r30, r0
    3106:	60 e2       	ldi	r22, 0x20	; 32
    3108:	ce 01       	movw	r24, r28
    310a:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    310c:	c6 2d       	mov	r28, r6
    310e:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3110:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3112:	80 ee       	ldi	r24, 0xE0	; 224
    3114:	86 0f       	add	r24, r22
    3116:	8f 35       	cpi	r24, 0x5F	; 95
    3118:	48 f4       	brcc	.+18     	; 0x312c <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    311a:	d7 01       	movw	r26, r14
    311c:	ed 91       	ld	r30, X+
    311e:	fc 91       	ld	r31, X
    3120:	02 80       	ldd	r0, Z+2	; 0x02
    3122:	f3 81       	ldd	r31, Z+3	; 0x03
    3124:	e0 2d       	mov	r30, r0
    3126:	c7 01       	movw	r24, r14
    3128:	19 95       	eicall
    312a:	09 c0       	rjmp	.+18     	; 0x313e <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    312c:	d7 01       	movw	r26, r14
    312e:	ed 91       	ld	r30, X+
    3130:	fc 91       	ld	r31, X
    3132:	02 80       	ldd	r0, Z+2	; 0x02
    3134:	f3 81       	ldd	r31, Z+3	; 0x03
    3136:	e0 2d       	mov	r30, r0
    3138:	6e e2       	ldi	r22, 0x2E	; 46
    313a:	c7 01       	movw	r24, r14
    313c:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    313e:	cc 16       	cp	r12, r28
    3140:	dd 06       	cpc	r13, r29
    3142:	31 f7       	brne	.-52     	; 0x3110 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3144:	b4 e1       	ldi	r27, 0x14	; 20
    3146:	ab 0e       	add	r10, r27
    3148:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    314a:	66 e0       	ldi	r22, 0x06	; 6
    314c:	c7 01       	movw	r24, r14
    314e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    3152:	84 e1       	ldi	r24, 0x14	; 20
    3154:	c8 0e       	add	r12, r24
    3156:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3158:	a8 14       	cp	r10, r8
    315a:	b9 04       	cpc	r11, r9
    315c:	08 f4       	brcc	.+2      	; 0x3160 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    315e:	88 cf       	rjmp	.-240    	; 0x3070 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3160:	62 e0       	ldi	r22, 0x02	; 2
    3162:	c7 01       	movw	r24, r14
    3164:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
}
    3168:	03 c0       	rjmp	.+6      	; 0x3170 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    316a:	c6 2d       	mov	r28, r6
    316c:	d5 2d       	mov	r29, r5
    316e:	9c cf       	rjmp	.-200    	; 0x30a8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3170:	df 91       	pop	r29
    3172:	cf 91       	pop	r28
    3174:	1f 91       	pop	r17
    3176:	0f 91       	pop	r16
    3178:	ff 90       	pop	r15
    317a:	ef 90       	pop	r14
    317c:	df 90       	pop	r13
    317e:	cf 90       	pop	r12
    3180:	bf 90       	pop	r11
    3182:	af 90       	pop	r10
    3184:	9f 90       	pop	r9
    3186:	8f 90       	pop	r8
    3188:	7f 90       	pop	r7
    318a:	6f 90       	pop	r6
    318c:	5f 90       	pop	r5
    318e:	08 95       	ret

00003190 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3190:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <pvPortMalloc>
    3194:	08 95       	ret

00003196 <_ZdlPv>:
    3196:	00 97       	sbiw	r24, 0x00	; 0
    3198:	11 f0       	breq	.+4      	; 0x319e <_ZdlPv+0x8>
    319a:	0e 94 93 09 	call	0x1326	; 0x1326 <vPortFree>
    319e:	08 95       	ret

000031a0 <_Znaj>:
    31a0:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <pvPortMalloc>
    31a4:	08 95       	ret

000031a6 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    31a6:	08 95       	ret

000031a8 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    31a8:	cf 93       	push	r28
    31aa:	df 93       	push	r29
    31ac:	fc 01       	movw	r30, r24
    31ae:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    31b0:	40 3a       	cpi	r20, 0xA0	; 160
    31b2:	68 e0       	ldi	r22, 0x08	; 8
    31b4:	56 07       	cpc	r21, r22
    31b6:	49 f4       	brne	.+18     	; 0x31ca <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    31b8:	80 e4       	ldi	r24, 0x40	; 64
    31ba:	96 e0       	ldi	r25, 0x06	; 6
    31bc:	82 83       	std	Z+2, r24	; 0x02
    31be:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    31c0:	82 e0       	ldi	r24, 0x02	; 2
    31c2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    31c4:	83 e0       	ldi	r24, 0x03	; 3
    31c6:	85 83       	std	Z+5, r24	; 0x05
    31c8:	32 c0       	rjmp	.+100    	; 0x322e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    31ca:	40 3b       	cpi	r20, 0xB0	; 176
    31cc:	78 e0       	ldi	r23, 0x08	; 8
    31ce:	57 07       	cpc	r21, r23
    31d0:	49 f4       	brne	.+18     	; 0x31e4 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    31d2:	80 e4       	ldi	r24, 0x40	; 64
    31d4:	96 e0       	ldi	r25, 0x06	; 6
    31d6:	82 83       	std	Z+2, r24	; 0x02
    31d8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    31da:	86 e0       	ldi	r24, 0x06	; 6
    31dc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    31de:	87 e0       	ldi	r24, 0x07	; 7
    31e0:	85 83       	std	Z+5, r24	; 0x05
    31e2:	25 c0       	rjmp	.+74     	; 0x322e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    31e4:	40 3a       	cpi	r20, 0xA0	; 160
    31e6:	89 e0       	ldi	r24, 0x09	; 9
    31e8:	58 07       	cpc	r21, r24
    31ea:	49 f4       	brne	.+18     	; 0x31fe <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    31ec:	80 e6       	ldi	r24, 0x60	; 96
    31ee:	96 e0       	ldi	r25, 0x06	; 6
    31f0:	82 83       	std	Z+2, r24	; 0x02
    31f2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    31f4:	82 e0       	ldi	r24, 0x02	; 2
    31f6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    31f8:	83 e0       	ldi	r24, 0x03	; 3
    31fa:	85 83       	std	Z+5, r24	; 0x05
    31fc:	18 c0       	rjmp	.+48     	; 0x322e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    31fe:	40 3b       	cpi	r20, 0xB0	; 176
    3200:	69 e0       	ldi	r22, 0x09	; 9
    3202:	56 07       	cpc	r21, r22
    3204:	49 f4       	brne	.+18     	; 0x3218 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3206:	80 e6       	ldi	r24, 0x60	; 96
    3208:	96 e0       	ldi	r25, 0x06	; 6
    320a:	82 83       	std	Z+2, r24	; 0x02
    320c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    320e:	86 e0       	ldi	r24, 0x06	; 6
    3210:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3212:	87 e0       	ldi	r24, 0x07	; 7
    3214:	85 83       	std	Z+5, r24	; 0x05
    3216:	0b c0       	rjmp	.+22     	; 0x322e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3218:	40 3a       	cpi	r20, 0xA0	; 160
    321a:	5a 40       	sbci	r21, 0x0A	; 10
    321c:	41 f4       	brne	.+16     	; 0x322e <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    321e:	80 e8       	ldi	r24, 0x80	; 128
    3220:	96 e0       	ldi	r25, 0x06	; 6
    3222:	82 83       	std	Z+2, r24	; 0x02
    3224:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3226:	82 e0       	ldi	r24, 0x02	; 2
    3228:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    322a:	83 e0       	ldi	r24, 0x03	; 3
    322c:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    322e:	a6 83       	std	Z+6, r26	; 0x06
    3230:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3232:	cd 01       	movw	r24, r26
    3234:	01 96       	adiw	r24, 0x01	; 1
    3236:	80 87       	std	Z+8, r24	; 0x08
    3238:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    323a:	03 96       	adiw	r24, 0x03	; 3
    323c:	82 87       	std	Z+10, r24	; 0x0a
    323e:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3240:	25 81       	ldd	r18, Z+5	; 0x05
    3242:	c2 81       	ldd	r28, Z+2	; 0x02
    3244:	d3 81       	ldd	r29, Z+3	; 0x03
    3246:	4c 81       	ldd	r20, Y+4	; 0x04
    3248:	81 e0       	ldi	r24, 0x01	; 1
    324a:	90 e0       	ldi	r25, 0x00	; 0
    324c:	bc 01       	movw	r22, r24
    324e:	02 c0       	rjmp	.+4      	; 0x3254 <_ZN7base232C1EjP12USART_struct+0xac>
    3250:	66 0f       	add	r22, r22
    3252:	77 1f       	adc	r23, r23
    3254:	2a 95       	dec	r18
    3256:	e2 f7       	brpl	.-8      	; 0x3250 <_ZN7base232C1EjP12USART_struct+0xa8>
    3258:	9b 01       	movw	r18, r22
    325a:	24 2b       	or	r18, r20
    325c:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    325e:	25 81       	ldd	r18, Z+5	; 0x05
    3260:	c2 81       	ldd	r28, Z+2	; 0x02
    3262:	d3 81       	ldd	r29, Z+3	; 0x03
    3264:	48 81       	ld	r20, Y
    3266:	bc 01       	movw	r22, r24
    3268:	02 c0       	rjmp	.+4      	; 0x326e <_ZN7base232C1EjP12USART_struct+0xc6>
    326a:	66 0f       	add	r22, r22
    326c:	77 1f       	adc	r23, r23
    326e:	2a 95       	dec	r18
    3270:	e2 f7       	brpl	.-8      	; 0x326a <_ZN7base232C1EjP12USART_struct+0xc2>
    3272:	9b 01       	movw	r18, r22
    3274:	24 2b       	or	r18, r20
    3276:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3278:	34 81       	ldd	r19, Z+4	; 0x04
    327a:	c2 81       	ldd	r28, Z+2	; 0x02
    327c:	d3 81       	ldd	r29, Z+3	; 0x03
    327e:	28 81       	ld	r18, Y
    3280:	02 c0       	rjmp	.+4      	; 0x3286 <_ZN7base232C1EjP12USART_struct+0xde>
    3282:	88 0f       	add	r24, r24
    3284:	99 1f       	adc	r25, r25
    3286:	3a 95       	dec	r19
    3288:	e2 f7       	brpl	.-8      	; 0x3282 <_ZN7base232C1EjP12USART_struct+0xda>
    328a:	80 95       	com	r24
    328c:	90 95       	com	r25
    328e:	82 23       	and	r24, r18
    3290:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3292:	80 e1       	ldi	r24, 0x10	; 16
    3294:	13 96       	adiw	r26, 0x03	; 3
    3296:	8c 93       	st	X, r24
    3298:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    329a:	83 e0       	ldi	r24, 0x03	; 3
    329c:	15 96       	adiw	r26, 0x05	; 5
    329e:	8c 93       	st	X, r24
    32a0:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    32a2:	80 ef       	ldi	r24, 0xF0	; 240
    32a4:	17 96       	adiw	r26, 0x07	; 7
    32a6:	8c 93       	st	X, r24
    32a8:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    32aa:	81 e2       	ldi	r24, 0x21	; 33
    32ac:	16 96       	adiw	r26, 0x06	; 6
    32ae:	8c 93       	st	X, r24
    32b0:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    32b2:	88 e1       	ldi	r24, 0x18	; 24
    32b4:	14 96       	adiw	r26, 0x04	; 4
    32b6:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    32b8:	80 e8       	ldi	r24, 0x80	; 128
    32ba:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    32bc:	80 e4       	ldi	r24, 0x40	; 64
    32be:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    32c0:	80 e2       	ldi	r24, 0x20	; 32
    32c2:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    32c4:	06 80       	ldd	r0, Z+6	; 0x06
    32c6:	f7 81       	ldd	r31, Z+7	; 0x07
    32c8:	e0 2d       	mov	r30, r0
    32ca:	80 81       	ld	r24, Z
    32cc:	80 81       	ld	r24, Z
}
    32ce:	df 91       	pop	r29
    32d0:	cf 91       	pop	r28
    32d2:	08 95       	ret

000032d4 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    32d4:	81 e0       	ldi	r24, 0x01	; 1
    32d6:	08 95       	ret

000032d8 <_ZN8emstream7getcharEv>:
    32d8:	80 e0       	ldi	r24, 0x00	; 0
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	08 95       	ret

000032de <_ZN8emstream14check_for_charEv>:
    32de:	80 e0       	ldi	r24, 0x00	; 0
    32e0:	08 95       	ret

000032e2 <_ZN8emstream12transmit_nowEv>:
    32e2:	08 95       	ret

000032e4 <_ZN8emstream12clear_screenEv>:
    32e4:	08 95       	ret

000032e6 <_ZN8emstreamC1Ev>:
    32e6:	fc 01       	movw	r30, r24
    32e8:	8f e4       	ldi	r24, 0x4F	; 79
    32ea:	90 e2       	ldi	r25, 0x20	; 32
    32ec:	80 83       	st	Z, r24
    32ee:	91 83       	std	Z+1, r25	; 0x01
    32f0:	8a e0       	ldi	r24, 0x0A	; 10
    32f2:	82 83       	std	Z+2, r24	; 0x02
    32f4:	13 82       	std	Z+3, r1	; 0x03
    32f6:	83 e0       	ldi	r24, 0x03	; 3
    32f8:	85 83       	std	Z+5, r24	; 0x05
    32fa:	14 82       	std	Z+4, r1	; 0x04
    32fc:	16 82       	std	Z+6, r1	; 0x06
    32fe:	17 82       	std	Z+7, r1	; 0x07
    3300:	08 95       	ret

00003302 <_ZN8emstream4putsEPKc>:
    3302:	0f 93       	push	r16
    3304:	1f 93       	push	r17
    3306:	cf 93       	push	r28
    3308:	df 93       	push	r29
    330a:	8c 01       	movw	r16, r24
    330c:	fb 01       	movw	r30, r22
    330e:	dc 01       	movw	r26, r24
    3310:	14 96       	adiw	r26, 0x04	; 4
    3312:	8c 91       	ld	r24, X
    3314:	81 11       	cpse	r24, r1
    3316:	04 c0       	rjmp	.+8      	; 0x3320 <_ZN8emstream4putsEPKc+0x1e>
    3318:	60 81       	ld	r22, Z
    331a:	61 11       	cpse	r22, r1
    331c:	17 c0       	rjmp	.+46     	; 0x334c <_ZN8emstream4putsEPKc+0x4a>
    331e:	23 c0       	rjmp	.+70     	; 0x3366 <_ZN8emstream4putsEPKc+0x64>
    3320:	d8 01       	movw	r26, r16
    3322:	14 96       	adiw	r26, 0x04	; 4
    3324:	1c 92       	st	X, r1
    3326:	eb 01       	movw	r28, r22
    3328:	21 96       	adiw	r28, 0x01	; 1
    332a:	64 91       	lpm	r22, Z
    332c:	66 23       	and	r22, r22
    332e:	d9 f0       	breq	.+54     	; 0x3366 <_ZN8emstream4putsEPKc+0x64>
    3330:	d8 01       	movw	r26, r16
    3332:	ed 91       	ld	r30, X+
    3334:	fc 91       	ld	r31, X
    3336:	02 80       	ldd	r0, Z+2	; 0x02
    3338:	f3 81       	ldd	r31, Z+3	; 0x03
    333a:	e0 2d       	mov	r30, r0
    333c:	c8 01       	movw	r24, r16
    333e:	19 95       	eicall
    3340:	fe 01       	movw	r30, r28
    3342:	64 91       	lpm	r22, Z
    3344:	21 96       	adiw	r28, 0x01	; 1
    3346:	61 11       	cpse	r22, r1
    3348:	f3 cf       	rjmp	.-26     	; 0x3330 <_ZN8emstream4putsEPKc+0x2e>
    334a:	0d c0       	rjmp	.+26     	; 0x3366 <_ZN8emstream4putsEPKc+0x64>
    334c:	ef 01       	movw	r28, r30
    334e:	21 96       	adiw	r28, 0x01	; 1
    3350:	d8 01       	movw	r26, r16
    3352:	ed 91       	ld	r30, X+
    3354:	fc 91       	ld	r31, X
    3356:	02 80       	ldd	r0, Z+2	; 0x02
    3358:	f3 81       	ldd	r31, Z+3	; 0x03
    335a:	e0 2d       	mov	r30, r0
    335c:	c8 01       	movw	r24, r16
    335e:	19 95       	eicall
    3360:	69 91       	ld	r22, Y+
    3362:	61 11       	cpse	r22, r1
    3364:	f5 cf       	rjmp	.-22     	; 0x3350 <_ZN8emstream4putsEPKc+0x4e>
    3366:	df 91       	pop	r29
    3368:	cf 91       	pop	r28
    336a:	1f 91       	pop	r17
    336c:	0f 91       	pop	r16
    336e:	08 95       	ret

00003370 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3370:	cf 93       	push	r28
    3372:	df 93       	push	r29
    3374:	ec 01       	movw	r28, r24
	switch (new_manip)
    3376:	86 2f       	mov	r24, r22
    3378:	90 e0       	ldi	r25, 0x00	; 0
    337a:	8b 30       	cpi	r24, 0x0B	; 11
    337c:	91 05       	cpc	r25, r1
    337e:	d8 f5       	brcc	.+118    	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
    3380:	fc 01       	movw	r30, r24
    3382:	88 27       	eor	r24, r24
    3384:	e2 50       	subi	r30, 0x02	; 2
    3386:	ff 4f       	sbci	r31, 0xFF	; 255
    3388:	8f 4f       	sbci	r24, 0xFF	; 255
    338a:	0c 94 f9 20 	jmp	0x41f2	; 0x41f2 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    338e:	82 e0       	ldi	r24, 0x02	; 2
    3390:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3392:	31 c0       	rjmp	.+98     	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3394:	88 e0       	ldi	r24, 0x08	; 8
    3396:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3398:	2e c0       	rjmp	.+92     	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    339a:	8a e0       	ldi	r24, 0x0A	; 10
    339c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    339e:	2b c0       	rjmp	.+86     	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    33a0:	80 e1       	ldi	r24, 0x10	; 16
    33a2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    33a4:	28 c0       	rjmp	.+80     	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    33a6:	81 e0       	ldi	r24, 0x01	; 1
    33a8:	8b 83       	std	Y+3, r24	; 0x03
			break;
    33aa:	25 c0       	rjmp	.+74     	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    33ac:	1b 82       	std	Y+3, r1	; 0x03
			break;
    33ae:	23 c0       	rjmp	.+70     	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    33b0:	e8 81       	ld	r30, Y
    33b2:	f9 81       	ldd	r31, Y+1	; 0x01
    33b4:	02 80       	ldd	r0, Z+2	; 0x02
    33b6:	f3 81       	ldd	r31, Z+3	; 0x03
    33b8:	e0 2d       	mov	r30, r0
    33ba:	6d e0       	ldi	r22, 0x0D	; 13
    33bc:	ce 01       	movw	r24, r28
    33be:	19 95       	eicall
    33c0:	e8 81       	ld	r30, Y
    33c2:	f9 81       	ldd	r31, Y+1	; 0x01
    33c4:	02 80       	ldd	r0, Z+2	; 0x02
    33c6:	f3 81       	ldd	r31, Z+3	; 0x03
    33c8:	e0 2d       	mov	r30, r0
    33ca:	6a e0       	ldi	r22, 0x0A	; 10
    33cc:	ce 01       	movw	r24, r28
    33ce:	19 95       	eicall
			break;
    33d0:	12 c0       	rjmp	.+36     	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    33d2:	e8 81       	ld	r30, Y
    33d4:	f9 81       	ldd	r31, Y+1	; 0x01
    33d6:	02 84       	ldd	r0, Z+10	; 0x0a
    33d8:	f3 85       	ldd	r31, Z+11	; 0x0b
    33da:	e0 2d       	mov	r30, r0
    33dc:	ce 01       	movw	r24, r28
    33de:	19 95       	eicall
			break;
    33e0:	0a c0       	rjmp	.+20     	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    33e2:	e8 81       	ld	r30, Y
    33e4:	f9 81       	ldd	r31, Y+1	; 0x01
    33e6:	00 84       	ldd	r0, Z+8	; 0x08
    33e8:	f1 85       	ldd	r31, Z+9	; 0x09
    33ea:	e0 2d       	mov	r30, r0
    33ec:	ce 01       	movw	r24, r28
    33ee:	19 95       	eicall
			break;
    33f0:	02 c0       	rjmp	.+4      	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    33f2:	81 e0       	ldi	r24, 0x01	; 1
    33f4:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    33f6:	ce 01       	movw	r24, r28
    33f8:	df 91       	pop	r29
    33fa:	cf 91       	pop	r28
    33fc:	08 95       	ret

000033fe <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    33fe:	ff 92       	push	r15
    3400:	0f 93       	push	r16
    3402:	1f 93       	push	r17
    3404:	cf 93       	push	r28
    3406:	df 93       	push	r29
    3408:	cd b7       	in	r28, 0x3d	; 61
    340a:	de b7       	in	r29, 0x3e	; 62
    340c:	61 97       	sbiw	r28, 0x11	; 17
    340e:	cd bf       	out	0x3d, r28	; 61
    3410:	de bf       	out	0x3e, r29	; 62
    3412:	8c 01       	movw	r16, r24
    3414:	f6 2e       	mov	r15, r22
    3416:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3418:	f8 01       	movw	r30, r16
    341a:	42 81       	ldd	r20, Z+2	; 0x02
    341c:	40 31       	cpi	r20, 0x10	; 16
    341e:	21 f0       	breq	.+8      	; 0x3428 <_ZN8emstreamlsEj+0x2a>
    3420:	48 30       	cpi	r20, 0x08	; 8
    3422:	11 f0       	breq	.+4      	; 0x3428 <_ZN8emstreamlsEj+0x2a>
    3424:	42 30       	cpi	r20, 0x02	; 2
    3426:	41 f4       	brne	.+16     	; 0x3438 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3428:	69 2f       	mov	r22, r25
    342a:	c8 01       	movw	r24, r16
    342c:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
    3430:	6f 2d       	mov	r22, r15
    3432:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
    3436:	0d c0       	rjmp	.+26     	; 0x3452 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3438:	50 e0       	ldi	r21, 0x00	; 0
    343a:	be 01       	movw	r22, r28
    343c:	6f 5f       	subi	r22, 0xFF	; 255
    343e:	7f 4f       	sbci	r23, 0xFF	; 255
    3440:	8f 2d       	mov	r24, r15
    3442:	0e 94 6f 21 	call	0x42de	; 0x42de <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3446:	be 01       	movw	r22, r28
    3448:	6f 5f       	subi	r22, 0xFF	; 255
    344a:	7f 4f       	sbci	r23, 0xFF	; 255
    344c:	c8 01       	movw	r24, r16
    344e:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3452:	c8 01       	movw	r24, r16
    3454:	61 96       	adiw	r28, 0x11	; 17
    3456:	cd bf       	out	0x3d, r28	; 61
    3458:	de bf       	out	0x3e, r29	; 62
    345a:	df 91       	pop	r29
    345c:	cf 91       	pop	r28
    345e:	1f 91       	pop	r17
    3460:	0f 91       	pop	r16
    3462:	ff 90       	pop	r15
    3464:	08 95       	ret

00003466 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3466:	df 92       	push	r13
    3468:	ef 92       	push	r14
    346a:	ff 92       	push	r15
    346c:	0f 93       	push	r16
    346e:	1f 93       	push	r17
    3470:	cf 93       	push	r28
    3472:	df 93       	push	r29
    3474:	cd b7       	in	r28, 0x3d	; 61
    3476:	de b7       	in	r29, 0x3e	; 62
    3478:	a1 97       	sbiw	r28, 0x21	; 33
    347a:	cd bf       	out	0x3d, r28	; 61
    347c:	de bf       	out	0x3e, r29	; 62
    347e:	8c 01       	movw	r16, r24
    3480:	d4 2e       	mov	r13, r20
    3482:	e5 2e       	mov	r14, r21
    3484:	f6 2e       	mov	r15, r22
    3486:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3488:	f8 01       	movw	r30, r16
    348a:	22 81       	ldd	r18, Z+2	; 0x02
    348c:	20 31       	cpi	r18, 0x10	; 16
    348e:	21 f0       	breq	.+8      	; 0x3498 <_ZN8emstreamlsEm+0x32>
    3490:	28 30       	cpi	r18, 0x08	; 8
    3492:	11 f0       	breq	.+4      	; 0x3498 <_ZN8emstreamlsEm+0x32>
    3494:	22 30       	cpi	r18, 0x02	; 2
    3496:	71 f4       	brne	.+28     	; 0x34b4 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3498:	69 2f       	mov	r22, r25
    349a:	c8 01       	movw	r24, r16
    349c:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
    34a0:	6f 2d       	mov	r22, r15
    34a2:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
    34a6:	6e 2d       	mov	r22, r14
    34a8:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
    34ac:	6d 2d       	mov	r22, r13
    34ae:	0e 94 75 1a 	call	0x34ea	; 0x34ea <_ZN8emstreamlsEh>
    34b2:	0f c0       	rjmp	.+30     	; 0x34d2 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    34b4:	30 e0       	ldi	r19, 0x00	; 0
    34b6:	ae 01       	movw	r20, r28
    34b8:	4f 5f       	subi	r20, 0xFF	; 255
    34ba:	5f 4f       	sbci	r21, 0xFF	; 255
    34bc:	6d 2d       	mov	r22, r13
    34be:	7e 2d       	mov	r23, r14
    34c0:	8f 2d       	mov	r24, r15
    34c2:	0e 94 42 21 	call	0x4284	; 0x4284 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    34c6:	be 01       	movw	r22, r28
    34c8:	6f 5f       	subi	r22, 0xFF	; 255
    34ca:	7f 4f       	sbci	r23, 0xFF	; 255
    34cc:	c8 01       	movw	r24, r16
    34ce:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    34d2:	c8 01       	movw	r24, r16
    34d4:	a1 96       	adiw	r28, 0x21	; 33
    34d6:	cd bf       	out	0x3d, r28	; 61
    34d8:	de bf       	out	0x3e, r29	; 62
    34da:	df 91       	pop	r29
    34dc:	cf 91       	pop	r28
    34de:	1f 91       	pop	r17
    34e0:	0f 91       	pop	r16
    34e2:	ff 90       	pop	r15
    34e4:	ef 90       	pop	r14
    34e6:	df 90       	pop	r13
    34e8:	08 95       	ret

000034ea <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    34ea:	cf 92       	push	r12
    34ec:	df 92       	push	r13
    34ee:	ef 92       	push	r14
    34f0:	ff 92       	push	r15
    34f2:	0f 93       	push	r16
    34f4:	1f 93       	push	r17
    34f6:	cf 93       	push	r28
    34f8:	df 93       	push	r29
    34fa:	cd b7       	in	r28, 0x3d	; 61
    34fc:	de b7       	in	r29, 0x3e	; 62
    34fe:	29 97       	sbiw	r28, 0x09	; 9
    3500:	cd bf       	out	0x3d, r28	; 61
    3502:	de bf       	out	0x3e, r29	; 62
    3504:	8c 01       	movw	r16, r24
    3506:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3508:	dc 01       	movw	r26, r24
    350a:	13 96       	adiw	r26, 0x03	; 3
    350c:	8c 91       	ld	r24, X
    350e:	13 97       	sbiw	r26, 0x03	; 3
    3510:	88 23       	and	r24, r24
    3512:	41 f0       	breq	.+16     	; 0x3524 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3514:	ed 91       	ld	r30, X+
    3516:	fc 91       	ld	r31, X
    3518:	02 80       	ldd	r0, Z+2	; 0x02
    351a:	f3 81       	ldd	r31, Z+3	; 0x03
    351c:	e0 2d       	mov	r30, r0
    351e:	c8 01       	movw	r24, r16
    3520:	19 95       	eicall
    3522:	56 c0       	rjmp	.+172    	; 0x35d0 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3524:	f8 01       	movw	r30, r16
    3526:	42 81       	ldd	r20, Z+2	; 0x02
    3528:	42 30       	cpi	r20, 0x02	; 2
    352a:	19 f5       	brne	.+70     	; 0x3572 <_ZN8emstreamlsEh+0x88>
    352c:	68 94       	set
    352e:	cc 24       	eor	r12, r12
    3530:	c3 f8       	bld	r12, 3
    3532:	d1 2c       	mov	r13, r1
    3534:	68 94       	set
    3536:	ff 24       	eor	r15, r15
    3538:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    353a:	8e 2d       	mov	r24, r14
    353c:	8f 21       	and	r24, r15
    353e:	51 f0       	breq	.+20     	; 0x3554 <_ZN8emstreamlsEh+0x6a>
    3540:	d8 01       	movw	r26, r16
    3542:	ed 91       	ld	r30, X+
    3544:	fc 91       	ld	r31, X
    3546:	02 80       	ldd	r0, Z+2	; 0x02
    3548:	f3 81       	ldd	r31, Z+3	; 0x03
    354a:	e0 2d       	mov	r30, r0
    354c:	61 e3       	ldi	r22, 0x31	; 49
    354e:	c8 01       	movw	r24, r16
    3550:	19 95       	eicall
    3552:	09 c0       	rjmp	.+18     	; 0x3566 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3554:	d8 01       	movw	r26, r16
    3556:	ed 91       	ld	r30, X+
    3558:	fc 91       	ld	r31, X
    355a:	02 80       	ldd	r0, Z+2	; 0x02
    355c:	f3 81       	ldd	r31, Z+3	; 0x03
    355e:	e0 2d       	mov	r30, r0
    3560:	60 e3       	ldi	r22, 0x30	; 48
    3562:	c8 01       	movw	r24, r16
    3564:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3566:	f6 94       	lsr	r15
    3568:	b1 e0       	ldi	r27, 0x01	; 1
    356a:	cb 1a       	sub	r12, r27
    356c:	d1 08       	sbc	r13, r1
    356e:	29 f7       	brne	.-54     	; 0x353a <_ZN8emstreamlsEh+0x50>
    3570:	2f c0       	rjmp	.+94     	; 0x35d0 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3572:	40 31       	cpi	r20, 0x10	; 16
    3574:	f9 f4       	brne	.+62     	; 0x35b4 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3576:	62 95       	swap	r22
    3578:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    357a:	01 90       	ld	r0, Z+
    357c:	f0 81       	ld	r31, Z
    357e:	e0 2d       	mov	r30, r0
    3580:	02 80       	ldd	r0, Z+2	; 0x02
    3582:	f3 81       	ldd	r31, Z+3	; 0x03
    3584:	e0 2d       	mov	r30, r0
    3586:	6a 30       	cpi	r22, 0x0A	; 10
    3588:	10 f0       	brcs	.+4      	; 0x358e <_ZN8emstreamlsEh+0xa4>
    358a:	69 5c       	subi	r22, 0xC9	; 201
    358c:	01 c0       	rjmp	.+2      	; 0x3590 <_ZN8emstreamlsEh+0xa6>
    358e:	60 5d       	subi	r22, 0xD0	; 208
    3590:	c8 01       	movw	r24, r16
    3592:	19 95       	eicall
		temp_char = num & 0x0F;
    3594:	6e 2d       	mov	r22, r14
    3596:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3598:	d8 01       	movw	r26, r16
    359a:	ed 91       	ld	r30, X+
    359c:	fc 91       	ld	r31, X
    359e:	02 80       	ldd	r0, Z+2	; 0x02
    35a0:	f3 81       	ldd	r31, Z+3	; 0x03
    35a2:	e0 2d       	mov	r30, r0
    35a4:	6a 30       	cpi	r22, 0x0A	; 10
    35a6:	10 f0       	brcs	.+4      	; 0x35ac <_ZN8emstreamlsEh+0xc2>
    35a8:	69 5c       	subi	r22, 0xC9	; 201
    35aa:	01 c0       	rjmp	.+2      	; 0x35ae <_ZN8emstreamlsEh+0xc4>
    35ac:	60 5d       	subi	r22, 0xD0	; 208
    35ae:	c8 01       	movw	r24, r16
    35b0:	19 95       	eicall
    35b2:	0e c0       	rjmp	.+28     	; 0x35d0 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    35b4:	50 e0       	ldi	r21, 0x00	; 0
    35b6:	be 01       	movw	r22, r28
    35b8:	6f 5f       	subi	r22, 0xFF	; 255
    35ba:	7f 4f       	sbci	r23, 0xFF	; 255
    35bc:	8e 2d       	mov	r24, r14
    35be:	90 e0       	ldi	r25, 0x00	; 0
    35c0:	0e 94 6f 21 	call	0x42de	; 0x42de <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    35c4:	be 01       	movw	r22, r28
    35c6:	6f 5f       	subi	r22, 0xFF	; 255
    35c8:	7f 4f       	sbci	r23, 0xFF	; 255
    35ca:	c8 01       	movw	r24, r16
    35cc:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    35d0:	c8 01       	movw	r24, r16
    35d2:	29 96       	adiw	r28, 0x09	; 9
    35d4:	cd bf       	out	0x3d, r28	; 61
    35d6:	de bf       	out	0x3e, r29	; 62
    35d8:	df 91       	pop	r29
    35da:	cf 91       	pop	r28
    35dc:	1f 91       	pop	r17
    35de:	0f 91       	pop	r16
    35e0:	ff 90       	pop	r15
    35e2:	ef 90       	pop	r14
    35e4:	df 90       	pop	r13
    35e6:	cf 90       	pop	r12
    35e8:	08 95       	ret

000035ea <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    35ea:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    35ec:	50 96       	adiw	r26, 0x10	; 16
    35ee:	ed 91       	ld	r30, X+
    35f0:	fc 91       	ld	r31, X
    35f2:	51 97       	sbiw	r26, 0x11	; 17
    35f4:	80 81       	ld	r24, Z
    35f6:	54 96       	adiw	r26, 0x14	; 20
    35f8:	4c 91       	ld	r20, X
    35fa:	54 97       	sbiw	r26, 0x14	; 20
    35fc:	84 23       	and	r24, r20
    35fe:	29 f0       	breq	.+10     	; 0x360a <_ZN5rs2327putcharEc+0x20>
    3600:	09 c0       	rjmp	.+18     	; 0x3614 <_ZN5rs2327putcharEc+0x2a>
    3602:	21 50       	subi	r18, 0x01	; 1
    3604:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3606:	19 f4       	brne	.+6      	; 0x360e <_ZN5rs2327putcharEc+0x24>
    3608:	12 c0       	rjmp	.+36     	; 0x362e <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    360a:	21 e2       	ldi	r18, 0x21	; 33
    360c:	3e e4       	ldi	r19, 0x4E	; 78
    360e:	90 81       	ld	r25, Z
    3610:	94 23       	and	r25, r20
    3612:	b9 f3       	breq	.-18     	; 0x3602 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3614:	90 81       	ld	r25, Z
    3616:	56 96       	adiw	r26, 0x16	; 22
    3618:	8c 91       	ld	r24, X
    361a:	56 97       	sbiw	r26, 0x16	; 22
    361c:	89 2b       	or	r24, r25
    361e:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3620:	1e 96       	adiw	r26, 0x0e	; 14
    3622:	ed 91       	ld	r30, X+
    3624:	fc 91       	ld	r31, X
    3626:	1f 97       	sbiw	r26, 0x0f	; 15
    3628:	60 83       	st	Z, r22
	return (true);
    362a:	81 e0       	ldi	r24, 0x01	; 1
    362c:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    362e:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3630:	08 95       	ret

00003632 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3632:	cf 93       	push	r28
    3634:	df 93       	push	r29
    3636:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3638:	c1 8d       	ldd	r28, Z+25	; 0x19
    363a:	d2 8d       	ldd	r29, Z+26	; 0x1a
    363c:	28 81       	ld	r18, Y
    363e:	39 81       	ldd	r19, Y+1	; 0x01
    3640:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3642:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3644:	4d 91       	ld	r20, X+
    3646:	5c 91       	ld	r21, X
    3648:	24 17       	cp	r18, r20
    364a:	35 07       	cpc	r19, r21
    364c:	e9 f3       	breq	.-6      	; 0x3648 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    364e:	a7 89       	ldd	r26, Z+23	; 0x17
    3650:	b0 8d       	ldd	r27, Z+24	; 0x18
    3652:	0d 90       	ld	r0, X+
    3654:	bc 91       	ld	r27, X
    3656:	a0 2d       	mov	r26, r0
    3658:	a2 0f       	add	r26, r18
    365a:	b3 1f       	adc	r27, r19
    365c:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    365e:	2f 5f       	subi	r18, 0xFF	; 255
    3660:	3f 4f       	sbci	r19, 0xFF	; 255
    3662:	28 83       	st	Y, r18
    3664:	39 83       	std	Y+1, r19	; 0x01
    3666:	24 36       	cpi	r18, 0x64	; 100
    3668:	31 05       	cpc	r19, r1
    366a:	28 f0       	brcs	.+10     	; 0x3676 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    366c:	01 8c       	ldd	r0, Z+25	; 0x19
    366e:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3670:	e0 2d       	mov	r30, r0
    3672:	10 82       	st	Z, r1
    3674:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3676:	90 e0       	ldi	r25, 0x00	; 0
    3678:	df 91       	pop	r29
    367a:	cf 91       	pop	r28
    367c:	08 95       	ret

0000367e <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    367e:	cf 93       	push	r28
    3680:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3682:	ec 01       	movw	r28, r24
    3684:	a9 8d       	ldd	r26, Y+25	; 0x19
    3686:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3688:	eb 8d       	ldd	r30, Y+27	; 0x1b
    368a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    368c:	81 e0       	ldi	r24, 0x01	; 1
    368e:	4d 91       	ld	r20, X+
    3690:	5c 91       	ld	r21, X
    3692:	20 81       	ld	r18, Z
    3694:	31 81       	ldd	r19, Z+1	; 0x01
    3696:	42 17       	cp	r20, r18
    3698:	53 07       	cpc	r21, r19
    369a:	09 f4       	brne	.+2      	; 0x369e <_ZN5rs23214check_for_charEv+0x20>
    369c:	80 e0       	ldi	r24, 0x00	; 0
}
    369e:	df 91       	pop	r29
    36a0:	cf 91       	pop	r28
    36a2:	08 95       	ret

000036a4 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    36a4:	dc 01       	movw	r26, r24
    36a6:	ed 91       	ld	r30, X+
    36a8:	fc 91       	ld	r31, X
    36aa:	02 80       	ldd	r0, Z+2	; 0x02
    36ac:	f3 81       	ldd	r31, Z+3	; 0x03
    36ae:	e0 2d       	mov	r30, r0
    36b0:	6c e0       	ldi	r22, 0x0C	; 12
    36b2:	19 95       	eicall
    36b4:	08 95       	ret

000036b6 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    36b6:	ef 92       	push	r14
    36b8:	ff 92       	push	r15
    36ba:	0f 93       	push	r16
    36bc:	1f 93       	push	r17
    36be:	cf 93       	push	r28
    36c0:	df 93       	push	r29
    36c2:	ec 01       	movw	r28, r24
    36c4:	7b 01       	movw	r14, r22
    36c6:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    36c8:	0e 94 73 19 	call	0x32e6	; 0x32e6 <_ZN8emstreamC1Ev>
    36cc:	a8 01       	movw	r20, r16
    36ce:	b7 01       	movw	r22, r14
    36d0:	ce 01       	movw	r24, r28
    36d2:	08 96       	adiw	r24, 0x08	; 8
    36d4:	0e 94 d4 18 	call	0x31a8	; 0x31a8 <_ZN7base232C1EjP12USART_struct>
    36d8:	8f e5       	ldi	r24, 0x5F	; 95
    36da:	90 e2       	ldi	r25, 0x20	; 32
    36dc:	88 83       	st	Y, r24
    36de:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    36e0:	00 3a       	cpi	r16, 0xA0	; 160
    36e2:	88 e0       	ldi	r24, 0x08	; 8
    36e4:	18 07       	cpc	r17, r24
    36e6:	69 f4       	brne	.+26     	; 0x3702 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    36e8:	88 e3       	ldi	r24, 0x38	; 56
    36ea:	91 e3       	ldi	r25, 0x31	; 49
    36ec:	8f 8b       	std	Y+23, r24	; 0x17
    36ee:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    36f0:	8e e2       	ldi	r24, 0x2E	; 46
    36f2:	91 e3       	ldi	r25, 0x31	; 49
    36f4:	89 8f       	std	Y+25, r24	; 0x19
    36f6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    36f8:	84 e2       	ldi	r24, 0x24	; 36
    36fa:	91 e3       	ldi	r25, 0x31	; 49
    36fc:	8b 8f       	std	Y+27, r24	; 0x1b
    36fe:	9c 8f       	std	Y+28, r25	; 0x1c
    3700:	42 c0       	rjmp	.+132    	; 0x3786 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3702:	00 3b       	cpi	r16, 0xB0	; 176
    3704:	e8 e0       	ldi	r30, 0x08	; 8
    3706:	1e 07       	cpc	r17, r30
    3708:	69 f4       	brne	.+26     	; 0x3724 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    370a:	86 e3       	ldi	r24, 0x36	; 54
    370c:	91 e3       	ldi	r25, 0x31	; 49
    370e:	8f 8b       	std	Y+23, r24	; 0x17
    3710:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3712:	8c e2       	ldi	r24, 0x2C	; 44
    3714:	91 e3       	ldi	r25, 0x31	; 49
    3716:	89 8f       	std	Y+25, r24	; 0x19
    3718:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    371a:	82 e2       	ldi	r24, 0x22	; 34
    371c:	91 e3       	ldi	r25, 0x31	; 49
    371e:	8b 8f       	std	Y+27, r24	; 0x1b
    3720:	9c 8f       	std	Y+28, r25	; 0x1c
    3722:	31 c0       	rjmp	.+98     	; 0x3786 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3724:	00 3a       	cpi	r16, 0xA0	; 160
    3726:	f9 e0       	ldi	r31, 0x09	; 9
    3728:	1f 07       	cpc	r17, r31
    372a:	69 f4       	brne	.+26     	; 0x3746 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    372c:	84 e3       	ldi	r24, 0x34	; 52
    372e:	91 e3       	ldi	r25, 0x31	; 49
    3730:	8f 8b       	std	Y+23, r24	; 0x17
    3732:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3734:	8a e2       	ldi	r24, 0x2A	; 42
    3736:	91 e3       	ldi	r25, 0x31	; 49
    3738:	89 8f       	std	Y+25, r24	; 0x19
    373a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    373c:	80 e2       	ldi	r24, 0x20	; 32
    373e:	91 e3       	ldi	r25, 0x31	; 49
    3740:	8b 8f       	std	Y+27, r24	; 0x1b
    3742:	9c 8f       	std	Y+28, r25	; 0x1c
    3744:	20 c0       	rjmp	.+64     	; 0x3786 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3746:	00 3b       	cpi	r16, 0xB0	; 176
    3748:	89 e0       	ldi	r24, 0x09	; 9
    374a:	18 07       	cpc	r17, r24
    374c:	69 f4       	brne	.+26     	; 0x3768 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    374e:	82 e3       	ldi	r24, 0x32	; 50
    3750:	91 e3       	ldi	r25, 0x31	; 49
    3752:	8f 8b       	std	Y+23, r24	; 0x17
    3754:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3756:	88 e2       	ldi	r24, 0x28	; 40
    3758:	91 e3       	ldi	r25, 0x31	; 49
    375a:	89 8f       	std	Y+25, r24	; 0x19
    375c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    375e:	8e e1       	ldi	r24, 0x1E	; 30
    3760:	91 e3       	ldi	r25, 0x31	; 49
    3762:	8b 8f       	std	Y+27, r24	; 0x1b
    3764:	9c 8f       	std	Y+28, r25	; 0x1c
    3766:	0f c0       	rjmp	.+30     	; 0x3786 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3768:	00 3a       	cpi	r16, 0xA0	; 160
    376a:	1a 40       	sbci	r17, 0x0A	; 10
    376c:	61 f4       	brne	.+24     	; 0x3786 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    376e:	80 e3       	ldi	r24, 0x30	; 48
    3770:	91 e3       	ldi	r25, 0x31	; 49
    3772:	8f 8b       	std	Y+23, r24	; 0x17
    3774:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3776:	86 e2       	ldi	r24, 0x26	; 38
    3778:	91 e3       	ldi	r25, 0x31	; 49
    377a:	89 8f       	std	Y+25, r24	; 0x19
    377c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    377e:	8c e1       	ldi	r24, 0x1C	; 28
    3780:	91 e3       	ldi	r25, 0x31	; 49
    3782:	8b 8f       	std	Y+27, r24	; 0x1b
    3784:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3786:	0f 89       	ldd	r16, Y+23	; 0x17
    3788:	18 8d       	ldd	r17, Y+24	; 0x18
    378a:	84 e6       	ldi	r24, 0x64	; 100
    378c:	90 e0       	ldi	r25, 0x00	; 0
    378e:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <_Znaj>
    3792:	f8 01       	movw	r30, r16
    3794:	80 83       	st	Z, r24
    3796:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3798:	e9 8d       	ldd	r30, Y+25	; 0x19
    379a:	fa 8d       	ldd	r31, Y+26	; 0x1a
    379c:	10 82       	st	Z, r1
    379e:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    37a0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    37a2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    37a4:	10 82       	st	Z, r1
    37a6:	11 82       	std	Z+1, r1	; 0x01
}
    37a8:	df 91       	pop	r29
    37aa:	cf 91       	pop	r28
    37ac:	1f 91       	pop	r17
    37ae:	0f 91       	pop	r16
    37b0:	ff 90       	pop	r15
    37b2:	ef 90       	pop	r14
    37b4:	08 95       	ret

000037b6 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    37b6:	1f 92       	push	r1
    37b8:	0f 92       	push	r0
    37ba:	0f b6       	in	r0, 0x3f	; 63
    37bc:	0f 92       	push	r0
    37be:	11 24       	eor	r1, r1
    37c0:	08 b6       	in	r0, 0x38	; 56
    37c2:	0f 92       	push	r0
    37c4:	18 be       	out	0x38, r1	; 56
    37c6:	0b b6       	in	r0, 0x3b	; 59
    37c8:	0f 92       	push	r0
    37ca:	1b be       	out	0x3b, r1	; 59
    37cc:	2f 93       	push	r18
    37ce:	3f 93       	push	r19
    37d0:	8f 93       	push	r24
    37d2:	9f 93       	push	r25
    37d4:	ef 93       	push	r30
    37d6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    37d8:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    37dc:	e0 91 38 31 	lds	r30, 0x3138	; 0x803138 <rcvC0_buffer>
    37e0:	f0 91 39 31 	lds	r31, 0x3139	; 0x803139 <rcvC0_buffer+0x1>
    37e4:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    37e8:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    37ec:	e8 0f       	add	r30, r24
    37ee:	f9 1f       	adc	r31, r25
    37f0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    37f2:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    37f6:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    37fa:	01 96       	adiw	r24, 0x01	; 1
    37fc:	84 36       	cpi	r24, 0x64	; 100
    37fe:	91 05       	cpc	r25, r1
    3800:	60 f4       	brcc	.+24     	; 0x381a <__vector_25+0x64>
    3802:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <rcvC0_write_index>
    3806:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    380a:	20 91 2e 31 	lds	r18, 0x312E	; 0x80312e <rcvC0_read_index>
    380e:	30 91 2f 31 	lds	r19, 0x312F	; 0x80312f <rcvC0_read_index+0x1>
    3812:	82 17       	cp	r24, r18
    3814:	93 07       	cpc	r25, r19
    3816:	f1 f4       	brne	.+60     	; 0x3854 <__vector_25+0x9e>
    3818:	0c c0       	rjmp	.+24     	; 0x3832 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    381a:	10 92 24 31 	sts	0x3124, r1	; 0x803124 <rcvC0_write_index>
    381e:	10 92 25 31 	sts	0x3125, r1	; 0x803125 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3822:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC0_read_index>
    3826:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC0_read_index+0x1>
    382a:	18 16       	cp	r1, r24
    382c:	19 06       	cpc	r1, r25
    382e:	91 f4       	brne	.+36     	; 0x3854 <__vector_25+0x9e>
    3830:	0e c0       	rjmp	.+28     	; 0x384e <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3832:	01 96       	adiw	r24, 0x01	; 1
    3834:	84 36       	cpi	r24, 0x64	; 100
    3836:	91 05       	cpc	r25, r1
    3838:	28 f4       	brcc	.+10     	; 0x3844 <__vector_25+0x8e>
    383a:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC0_read_index>
    383e:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC0_read_index+0x1>
    3842:	08 c0       	rjmp	.+16     	; 0x3854 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3844:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC0_read_index>
    3848:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC0_read_index+0x1>
}
    384c:	03 c0       	rjmp	.+6      	; 0x3854 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    384e:	81 e0       	ldi	r24, 0x01	; 1
    3850:	90 e0       	ldi	r25, 0x00	; 0
    3852:	f3 cf       	rjmp	.-26     	; 0x383a <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3854:	ff 91       	pop	r31
    3856:	ef 91       	pop	r30
    3858:	9f 91       	pop	r25
    385a:	8f 91       	pop	r24
    385c:	3f 91       	pop	r19
    385e:	2f 91       	pop	r18
    3860:	0f 90       	pop	r0
    3862:	0b be       	out	0x3b, r0	; 59
    3864:	0f 90       	pop	r0
    3866:	08 be       	out	0x38, r0	; 56
    3868:	0f 90       	pop	r0
    386a:	0f be       	out	0x3f, r0	; 63
    386c:	0f 90       	pop	r0
    386e:	1f 90       	pop	r1
    3870:	18 95       	reti

00003872 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3872:	1f 92       	push	r1
    3874:	0f 92       	push	r0
    3876:	0f b6       	in	r0, 0x3f	; 63
    3878:	0f 92       	push	r0
    387a:	11 24       	eor	r1, r1
    387c:	08 b6       	in	r0, 0x38	; 56
    387e:	0f 92       	push	r0
    3880:	18 be       	out	0x38, r1	; 56
    3882:	0b b6       	in	r0, 0x3b	; 59
    3884:	0f 92       	push	r0
    3886:	1b be       	out	0x3b, r1	; 59
    3888:	2f 93       	push	r18
    388a:	3f 93       	push	r19
    388c:	8f 93       	push	r24
    388e:	9f 93       	push	r25
    3890:	ef 93       	push	r30
    3892:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3894:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3898:	e0 91 36 31 	lds	r30, 0x3136	; 0x803136 <rcvC1_buffer>
    389c:	f0 91 37 31 	lds	r31, 0x3137	; 0x803137 <rcvC1_buffer+0x1>
    38a0:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvC1_write_index>
    38a4:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvC1_write_index+0x1>
    38a8:	e8 0f       	add	r30, r24
    38aa:	f9 1f       	adc	r31, r25
    38ac:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    38ae:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvC1_write_index>
    38b2:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvC1_write_index+0x1>
    38b6:	01 96       	adiw	r24, 0x01	; 1
    38b8:	84 36       	cpi	r24, 0x64	; 100
    38ba:	91 05       	cpc	r25, r1
    38bc:	60 f4       	brcc	.+24     	; 0x38d6 <__vector_28+0x64>
    38be:	80 93 22 31 	sts	0x3122, r24	; 0x803122 <rcvC1_write_index>
    38c2:	90 93 23 31 	sts	0x3123, r25	; 0x803123 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    38c6:	20 91 2c 31 	lds	r18, 0x312C	; 0x80312c <rcvC1_read_index>
    38ca:	30 91 2d 31 	lds	r19, 0x312D	; 0x80312d <rcvC1_read_index+0x1>
    38ce:	82 17       	cp	r24, r18
    38d0:	93 07       	cpc	r25, r19
    38d2:	f1 f4       	brne	.+60     	; 0x3910 <__vector_28+0x9e>
    38d4:	0c c0       	rjmp	.+24     	; 0x38ee <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    38d6:	10 92 22 31 	sts	0x3122, r1	; 0x803122 <rcvC1_write_index>
    38da:	10 92 23 31 	sts	0x3123, r1	; 0x803123 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    38de:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvC1_read_index>
    38e2:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvC1_read_index+0x1>
    38e6:	18 16       	cp	r1, r24
    38e8:	19 06       	cpc	r1, r25
    38ea:	91 f4       	brne	.+36     	; 0x3910 <__vector_28+0x9e>
    38ec:	0e c0       	rjmp	.+28     	; 0x390a <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    38ee:	01 96       	adiw	r24, 0x01	; 1
    38f0:	84 36       	cpi	r24, 0x64	; 100
    38f2:	91 05       	cpc	r25, r1
    38f4:	28 f4       	brcc	.+10     	; 0x3900 <__vector_28+0x8e>
    38f6:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvC1_read_index>
    38fa:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvC1_read_index+0x1>
    38fe:	08 c0       	rjmp	.+16     	; 0x3910 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3900:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvC1_read_index>
    3904:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvC1_read_index+0x1>
}
    3908:	03 c0       	rjmp	.+6      	; 0x3910 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    390a:	81 e0       	ldi	r24, 0x01	; 1
    390c:	90 e0       	ldi	r25, 0x00	; 0
    390e:	f3 cf       	rjmp	.-26     	; 0x38f6 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3910:	ff 91       	pop	r31
    3912:	ef 91       	pop	r30
    3914:	9f 91       	pop	r25
    3916:	8f 91       	pop	r24
    3918:	3f 91       	pop	r19
    391a:	2f 91       	pop	r18
    391c:	0f 90       	pop	r0
    391e:	0b be       	out	0x3b, r0	; 59
    3920:	0f 90       	pop	r0
    3922:	08 be       	out	0x38, r0	; 56
    3924:	0f 90       	pop	r0
    3926:	0f be       	out	0x3f, r0	; 63
    3928:	0f 90       	pop	r0
    392a:	1f 90       	pop	r1
    392c:	18 95       	reti

0000392e <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    392e:	1f 92       	push	r1
    3930:	0f 92       	push	r0
    3932:	0f b6       	in	r0, 0x3f	; 63
    3934:	0f 92       	push	r0
    3936:	11 24       	eor	r1, r1
    3938:	08 b6       	in	r0, 0x38	; 56
    393a:	0f 92       	push	r0
    393c:	18 be       	out	0x38, r1	; 56
    393e:	0b b6       	in	r0, 0x3b	; 59
    3940:	0f 92       	push	r0
    3942:	1b be       	out	0x3b, r1	; 59
    3944:	2f 93       	push	r18
    3946:	3f 93       	push	r19
    3948:	8f 93       	push	r24
    394a:	9f 93       	push	r25
    394c:	ef 93       	push	r30
    394e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3950:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3954:	e0 91 34 31 	lds	r30, 0x3134	; 0x803134 <rcvD0_buffer>
    3958:	f0 91 35 31 	lds	r31, 0x3135	; 0x803135 <rcvD0_buffer+0x1>
    395c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3960:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    3964:	e8 0f       	add	r30, r24
    3966:	f9 1f       	adc	r31, r25
    3968:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    396a:	80 91 20 31 	lds	r24, 0x3120	; 0x803120 <rcvD0_write_index>
    396e:	90 91 21 31 	lds	r25, 0x3121	; 0x803121 <rcvD0_write_index+0x1>
    3972:	01 96       	adiw	r24, 0x01	; 1
    3974:	84 36       	cpi	r24, 0x64	; 100
    3976:	91 05       	cpc	r25, r1
    3978:	60 f4       	brcc	.+24     	; 0x3992 <__vector_88+0x64>
    397a:	80 93 20 31 	sts	0x3120, r24	; 0x803120 <rcvD0_write_index>
    397e:	90 93 21 31 	sts	0x3121, r25	; 0x803121 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3982:	20 91 2a 31 	lds	r18, 0x312A	; 0x80312a <rcvD0_read_index>
    3986:	30 91 2b 31 	lds	r19, 0x312B	; 0x80312b <rcvD0_read_index+0x1>
    398a:	82 17       	cp	r24, r18
    398c:	93 07       	cpc	r25, r19
    398e:	f1 f4       	brne	.+60     	; 0x39cc <__vector_88+0x9e>
    3990:	0c c0       	rjmp	.+24     	; 0x39aa <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3992:	10 92 20 31 	sts	0x3120, r1	; 0x803120 <rcvD0_write_index>
    3996:	10 92 21 31 	sts	0x3121, r1	; 0x803121 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    399a:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD0_read_index>
    399e:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD0_read_index+0x1>
    39a2:	18 16       	cp	r1, r24
    39a4:	19 06       	cpc	r1, r25
    39a6:	91 f4       	brne	.+36     	; 0x39cc <__vector_88+0x9e>
    39a8:	0e c0       	rjmp	.+28     	; 0x39c6 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    39aa:	01 96       	adiw	r24, 0x01	; 1
    39ac:	84 36       	cpi	r24, 0x64	; 100
    39ae:	91 05       	cpc	r25, r1
    39b0:	28 f4       	brcc	.+10     	; 0x39bc <__vector_88+0x8e>
    39b2:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD0_read_index>
    39b6:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD0_read_index+0x1>
    39ba:	08 c0       	rjmp	.+16     	; 0x39cc <__vector_88+0x9e>
	rcvD0_read_index = 0;
    39bc:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD0_read_index>
    39c0:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD0_read_index+0x1>
}
    39c4:	03 c0       	rjmp	.+6      	; 0x39cc <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    39c6:	81 e0       	ldi	r24, 0x01	; 1
    39c8:	90 e0       	ldi	r25, 0x00	; 0
    39ca:	f3 cf       	rjmp	.-26     	; 0x39b2 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    39cc:	ff 91       	pop	r31
    39ce:	ef 91       	pop	r30
    39d0:	9f 91       	pop	r25
    39d2:	8f 91       	pop	r24
    39d4:	3f 91       	pop	r19
    39d6:	2f 91       	pop	r18
    39d8:	0f 90       	pop	r0
    39da:	0b be       	out	0x3b, r0	; 59
    39dc:	0f 90       	pop	r0
    39de:	08 be       	out	0x38, r0	; 56
    39e0:	0f 90       	pop	r0
    39e2:	0f be       	out	0x3f, r0	; 63
    39e4:	0f 90       	pop	r0
    39e6:	1f 90       	pop	r1
    39e8:	18 95       	reti

000039ea <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    39ea:	1f 92       	push	r1
    39ec:	0f 92       	push	r0
    39ee:	0f b6       	in	r0, 0x3f	; 63
    39f0:	0f 92       	push	r0
    39f2:	11 24       	eor	r1, r1
    39f4:	08 b6       	in	r0, 0x38	; 56
    39f6:	0f 92       	push	r0
    39f8:	18 be       	out	0x38, r1	; 56
    39fa:	0b b6       	in	r0, 0x3b	; 59
    39fc:	0f 92       	push	r0
    39fe:	1b be       	out	0x3b, r1	; 59
    3a00:	2f 93       	push	r18
    3a02:	3f 93       	push	r19
    3a04:	8f 93       	push	r24
    3a06:	9f 93       	push	r25
    3a08:	ef 93       	push	r30
    3a0a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3a0c:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3a10:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <rcvD1_buffer>
    3a14:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <rcvD1_buffer+0x1>
    3a18:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvD1_write_index>
    3a1c:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvD1_write_index+0x1>
    3a20:	e8 0f       	add	r30, r24
    3a22:	f9 1f       	adc	r31, r25
    3a24:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3a26:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvD1_write_index>
    3a2a:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvD1_write_index+0x1>
    3a2e:	01 96       	adiw	r24, 0x01	; 1
    3a30:	84 36       	cpi	r24, 0x64	; 100
    3a32:	91 05       	cpc	r25, r1
    3a34:	60 f4       	brcc	.+24     	; 0x3a4e <__vector_91+0x64>
    3a36:	80 93 1e 31 	sts	0x311E, r24	; 0x80311e <rcvD1_write_index>
    3a3a:	90 93 1f 31 	sts	0x311F, r25	; 0x80311f <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3a3e:	20 91 28 31 	lds	r18, 0x3128	; 0x803128 <rcvD1_read_index>
    3a42:	30 91 29 31 	lds	r19, 0x3129	; 0x803129 <rcvD1_read_index+0x1>
    3a46:	82 17       	cp	r24, r18
    3a48:	93 07       	cpc	r25, r19
    3a4a:	f1 f4       	brne	.+60     	; 0x3a88 <__vector_91+0x9e>
    3a4c:	0c c0       	rjmp	.+24     	; 0x3a66 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3a4e:	10 92 1e 31 	sts	0x311E, r1	; 0x80311e <rcvD1_write_index>
    3a52:	10 92 1f 31 	sts	0x311F, r1	; 0x80311f <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3a56:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvD1_read_index>
    3a5a:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvD1_read_index+0x1>
    3a5e:	18 16       	cp	r1, r24
    3a60:	19 06       	cpc	r1, r25
    3a62:	91 f4       	brne	.+36     	; 0x3a88 <__vector_91+0x9e>
    3a64:	0e c0       	rjmp	.+28     	; 0x3a82 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3a66:	01 96       	adiw	r24, 0x01	; 1
    3a68:	84 36       	cpi	r24, 0x64	; 100
    3a6a:	91 05       	cpc	r25, r1
    3a6c:	28 f4       	brcc	.+10     	; 0x3a78 <__vector_91+0x8e>
    3a6e:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvD1_read_index>
    3a72:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvD1_read_index+0x1>
    3a76:	08 c0       	rjmp	.+16     	; 0x3a88 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3a78:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvD1_read_index>
    3a7c:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvD1_read_index+0x1>
}
    3a80:	03 c0       	rjmp	.+6      	; 0x3a88 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3a82:	81 e0       	ldi	r24, 0x01	; 1
    3a84:	90 e0       	ldi	r25, 0x00	; 0
    3a86:	f3 cf       	rjmp	.-26     	; 0x3a6e <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3a88:	ff 91       	pop	r31
    3a8a:	ef 91       	pop	r30
    3a8c:	9f 91       	pop	r25
    3a8e:	8f 91       	pop	r24
    3a90:	3f 91       	pop	r19
    3a92:	2f 91       	pop	r18
    3a94:	0f 90       	pop	r0
    3a96:	0b be       	out	0x3b, r0	; 59
    3a98:	0f 90       	pop	r0
    3a9a:	08 be       	out	0x38, r0	; 56
    3a9c:	0f 90       	pop	r0
    3a9e:	0f be       	out	0x3f, r0	; 63
    3aa0:	0f 90       	pop	r0
    3aa2:	1f 90       	pop	r1
    3aa4:	18 95       	reti

00003aa6 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3aa6:	1f 92       	push	r1
    3aa8:	0f 92       	push	r0
    3aaa:	0f b6       	in	r0, 0x3f	; 63
    3aac:	0f 92       	push	r0
    3aae:	11 24       	eor	r1, r1
    3ab0:	08 b6       	in	r0, 0x38	; 56
    3ab2:	0f 92       	push	r0
    3ab4:	18 be       	out	0x38, r1	; 56
    3ab6:	0b b6       	in	r0, 0x3b	; 59
    3ab8:	0f 92       	push	r0
    3aba:	1b be       	out	0x3b, r1	; 59
    3abc:	2f 93       	push	r18
    3abe:	3f 93       	push	r19
    3ac0:	8f 93       	push	r24
    3ac2:	9f 93       	push	r25
    3ac4:	ef 93       	push	r30
    3ac6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3ac8:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3acc:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <rcvE0_buffer>
    3ad0:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <rcvE0_buffer+0x1>
    3ad4:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvE0_write_index>
    3ad8:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvE0_write_index+0x1>
    3adc:	e8 0f       	add	r30, r24
    3ade:	f9 1f       	adc	r31, r25
    3ae0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3ae2:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvE0_write_index>
    3ae6:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvE0_write_index+0x1>
    3aea:	01 96       	adiw	r24, 0x01	; 1
    3aec:	84 36       	cpi	r24, 0x64	; 100
    3aee:	91 05       	cpc	r25, r1
    3af0:	60 f4       	brcc	.+24     	; 0x3b0a <__vector_58+0x64>
    3af2:	80 93 1c 31 	sts	0x311C, r24	; 0x80311c <rcvE0_write_index>
    3af6:	90 93 1d 31 	sts	0x311D, r25	; 0x80311d <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3afa:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <rcvE0_read_index>
    3afe:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <rcvE0_read_index+0x1>
    3b02:	82 17       	cp	r24, r18
    3b04:	93 07       	cpc	r25, r19
    3b06:	f1 f4       	brne	.+60     	; 0x3b44 <__vector_58+0x9e>
    3b08:	0c c0       	rjmp	.+24     	; 0x3b22 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3b0a:	10 92 1c 31 	sts	0x311C, r1	; 0x80311c <rcvE0_write_index>
    3b0e:	10 92 1d 31 	sts	0x311D, r1	; 0x80311d <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3b12:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <rcvE0_read_index>
    3b16:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <rcvE0_read_index+0x1>
    3b1a:	18 16       	cp	r1, r24
    3b1c:	19 06       	cpc	r1, r25
    3b1e:	91 f4       	brne	.+36     	; 0x3b44 <__vector_58+0x9e>
    3b20:	0e c0       	rjmp	.+28     	; 0x3b3e <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3b22:	01 96       	adiw	r24, 0x01	; 1
    3b24:	84 36       	cpi	r24, 0x64	; 100
    3b26:	91 05       	cpc	r25, r1
    3b28:	28 f4       	brcc	.+10     	; 0x3b34 <__vector_58+0x8e>
    3b2a:	80 93 26 31 	sts	0x3126, r24	; 0x803126 <rcvE0_read_index>
    3b2e:	90 93 27 31 	sts	0x3127, r25	; 0x803127 <rcvE0_read_index+0x1>
    3b32:	08 c0       	rjmp	.+16     	; 0x3b44 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3b34:	10 92 26 31 	sts	0x3126, r1	; 0x803126 <rcvE0_read_index>
    3b38:	10 92 27 31 	sts	0x3127, r1	; 0x803127 <rcvE0_read_index+0x1>
}
    3b3c:	03 c0       	rjmp	.+6      	; 0x3b44 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3b3e:	81 e0       	ldi	r24, 0x01	; 1
    3b40:	90 e0       	ldi	r25, 0x00	; 0
    3b42:	f3 cf       	rjmp	.-26     	; 0x3b2a <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3b44:	ff 91       	pop	r31
    3b46:	ef 91       	pop	r30
    3b48:	9f 91       	pop	r25
    3b4a:	8f 91       	pop	r24
    3b4c:	3f 91       	pop	r19
    3b4e:	2f 91       	pop	r18
    3b50:	0f 90       	pop	r0
    3b52:	0b be       	out	0x3b, r0	; 59
    3b54:	0f 90       	pop	r0
    3b56:	08 be       	out	0x38, r0	; 56
    3b58:	0f 90       	pop	r0
    3b5a:	0f be       	out	0x3f, r0	; 63
    3b5c:	0f 90       	pop	r0
    3b5e:	1f 90       	pop	r1
    3b60:	18 95       	reti

00003b62 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3b62:	0f 93       	push	r16
    3b64:	cf 93       	push	r28
    3b66:	df 93       	push	r29
    3b68:	1f 92       	push	r1
    3b6a:	cd b7       	in	r28, 0x3d	; 61
    3b6c:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3b6e:	2f b7       	in	r18, 0x3f	; 63
    3b70:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3b72:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3b74:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3b76:	fc 01       	movw	r30, r24
    3b78:	08 ed       	ldi	r16, 0xD8	; 216
    3b7a:	04 bf       	out	0x34, r16	; 52
    3b7c:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3b7e:	89 81       	ldd	r24, Y+1	; 0x01
    3b80:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3b82:	0f 90       	pop	r0
    3b84:	df 91       	pop	r29
    3b86:	cf 91       	pop	r28
    3b88:	0f 91       	pop	r16
    3b8a:	08 95       	ret

00003b8c <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3b8c:	0f 93       	push	r16
    3b8e:	1f 93       	push	r17
    3b90:	cf 93       	push	r28
    3b92:	df 93       	push	r29
    3b94:	cd b7       	in	r28, 0x3d	; 61
    3b96:	de b7       	in	r29, 0x3e	; 62
    3b98:	6d 97       	sbiw	r28, 0x1d	; 29
    3b9a:	cd bf       	out	0x3d, r28	; 61
    3b9c:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D6 as output LED3: turns on when power is on.
    3b9e:	e0 e6       	ldi	r30, 0x60	; 96
    3ba0:	f6 e0       	ldi	r31, 0x06	; 6
    3ba2:	80 e4       	ldi	r24, 0x40	; 64
    3ba4:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN5_bm;									// set pin D5 as output LED2
    3ba6:	90 e2       	ldi	r25, 0x20	; 32
    3ba8:	91 83       	std	Z+1, r25	; 0x01
	PORTD.DIRSET = PIN4_bm;									// set pin D4 as output LED1
    3baa:	90 e1       	ldi	r25, 0x10	; 16
    3bac:	91 83       	std	Z+1, r25	; 0x01
	
	PORTD.OUTSET = PIN6_bm;										//set pin high, LED 3
    3bae:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.OUTSET = PIN5_bm;									//set pin high, LED 2
	//PORTD.OUTSET = PIN4_bm;									//set pin high, LED 1
	
	//Clear any interrupts
	cli();
    3bb0:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3bb2:	e0 e5       	ldi	r30, 0x50	; 80
    3bb4:	f0 e0       	ldi	r31, 0x00	; 0
    3bb6:	80 81       	ld	r24, Z
    3bb8:	82 60       	ori	r24, 0x02	; 2
    3bba:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3bbc:	81 81       	ldd	r24, Z+1	; 0x01
    3bbe:	81 ff       	sbrs	r24, 1
    3bc0:	fd cf       	rjmp	.-6      	; 0x3bbc <main+0x30>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3bc2:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3bc6:	68 7f       	andi	r22, 0xF8	; 248
    3bc8:	61 60       	ori	r22, 0x01	; 1
    3bca:	80 e4       	ldi	r24, 0x40	; 64
    3bcc:	90 e0       	ldi	r25, 0x00	; 0
    3bce:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3bd2:	e0 e5       	ldi	r30, 0x50	; 80
    3bd4:	f0 e0       	ldi	r31, 0x00	; 0
    3bd6:	80 81       	ld	r24, Z
    3bd8:	8e 7f       	andi	r24, 0xFE	; 254
    3bda:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3bdc:	9d ef       	ldi	r25, 0xFD	; 253
    3bde:	88 ed       	ldi	r24, 0xD8	; 216
    3be0:	08 b6       	in	r0, 0x38	; 56
    3be2:	18 be       	out	0x38, r1	; 56
    3be4:	84 bf       	out	0x34, r24	; 52
    3be6:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3bea:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3bec:	40 eb       	ldi	r20, 0xB0	; 176
    3bee:	58 e0       	ldi	r21, 0x08	; 8
    3bf0:	60 e0       	ldi	r22, 0x00	; 0
    3bf2:	70 e0       	ldi	r23, 0x00	; 0
    3bf4:	ce 01       	movw	r24, r28
    3bf6:	01 96       	adiw	r24, 0x01	; 1
    3bf8:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3bfc:	67 e0       	ldi	r22, 0x07	; 7
    3bfe:	ce 01       	movw	r24, r28
    3c00:	01 96       	adiw	r24, 0x01	; 1
    3c02:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    3c06:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c08:	6b e6       	ldi	r22, 0x6B	; 107
    3c0a:	70 e2       	ldi	r23, 0x20	; 32
    3c0c:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN8emstream4putsEPKc>
    3c10:	66 e0       	ldi	r22, 0x06	; 6
    3c12:	c8 01       	movw	r24, r16
    3c14:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
    3c18:	66 e0       	ldi	r22, 0x06	; 6
    3c1a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3c1e:	82 e1       	ldi	r24, 0x12	; 18
    3c20:	90 e0       	ldi	r25, 0x00	; 0
    3c22:	0e 94 c8 18 	call	0x3190	; 0x3190 <_Znwj>
    3c26:	8e 01       	movw	r16, r28
    3c28:	0f 5f       	subi	r16, 0xFF	; 255
    3c2a:	1f 4f       	sbci	r17, 0xFF	; 255
    3c2c:	24 e0       	ldi	r18, 0x04	; 4
    3c2e:	31 e0       	ldi	r19, 0x01	; 1
    3c30:	40 e0       	ldi	r20, 0x00	; 0
    3c32:	6a e8       	ldi	r22, 0x8A	; 138
    3c34:	70 e2       	ldi	r23, 0x20	; 32
    3c36:	0e 94 89 06 	call	0xd12	; 0xd12 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3c3a:	82 e1       	ldi	r24, 0x12	; 18
    3c3c:	90 e0       	ldi	r25, 0x00	; 0
    3c3e:	0e 94 c8 18 	call	0x3190	; 0x3190 <_Znwj>
    3c42:	24 e0       	ldi	r18, 0x04	; 4
    3c44:	31 e0       	ldi	r19, 0x01	; 1
    3c46:	42 e0       	ldi	r20, 0x02	; 2
    3c48:	62 e9       	ldi	r22, 0x92	; 146
    3c4a:	70 e2       	ldi	r23, 0x20	; 32
    3c4c:	0e 94 5e 03 	call	0x6bc	; 0x6bc <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3c50:	82 e1       	ldi	r24, 0x12	; 18
    3c52:	90 e0       	ldi	r25, 0x00	; 0
    3c54:	0e 94 c8 18 	call	0x3190	; 0x3190 <_Znwj>
    3c58:	24 e0       	ldi	r18, 0x04	; 4
    3c5a:	31 e0       	ldi	r19, 0x01	; 1
    3c5c:	43 e0       	ldi	r20, 0x03	; 3
    3c5e:	69 e9       	ldi	r22, 0x99	; 153
    3c60:	70 e2       	ldi	r23, 0x20	; 32
    3c62:	0e 94 ce 03 	call	0x79c	; 0x79c <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3c66:	82 e1       	ldi	r24, 0x12	; 18
    3c68:	90 e0       	ldi	r25, 0x00	; 0
    3c6a:	0e 94 c8 18 	call	0x3190	; 0x3190 <_Znwj>
    3c6e:	24 e0       	ldi	r18, 0x04	; 4
    3c70:	31 e0       	ldi	r19, 0x01	; 1
    3c72:	44 e0       	ldi	r20, 0x04	; 4
    3c74:	60 ea       	ldi	r22, 0xA0	; 160
    3c76:	70 e2       	ldi	r23, 0x20	; 32
    3c78:	0e 94 13 04 	call	0x826	; 0x826 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(1), 260, &ser_dev);
    3c7c:	82 e4       	ldi	r24, 0x42	; 66
    3c7e:	90 e0       	ldi	r25, 0x00	; 0
    3c80:	0e 94 c8 18 	call	0x3190	; 0x3190 <_Znwj>
    3c84:	24 e0       	ldi	r18, 0x04	; 4
    3c86:	31 e0       	ldi	r19, 0x01	; 1
    3c88:	41 e0       	ldi	r20, 0x01	; 1
    3c8a:	69 ea       	ldi	r22, 0xA9	; 169
    3c8c:	70 e2       	ldi	r23, 0x20	; 32
    3c8e:	0e 94 48 05 	call	0xa90	; 0xa90 <_ZN5MotorC1EPKchjP8emstream>

	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3c92:	87 e0       	ldi	r24, 0x07	; 7
    3c94:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3c98:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3c9a:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vTaskStartScheduler>
	
	
	return 0;
    3c9e:	80 e0       	ldi	r24, 0x00	; 0
    3ca0:	90 e0       	ldi	r25, 0x00	; 0
    3ca2:	6d 96       	adiw	r28, 0x1d	; 29
    3ca4:	cd bf       	out	0x3d, r28	; 61
    3ca6:	de bf       	out	0x3e, r29	; 62
    3ca8:	df 91       	pop	r29
    3caa:	cf 91       	pop	r28
    3cac:	1f 91       	pop	r17
    3cae:	0f 91       	pop	r16
    3cb0:	08 95       	ret

00003cb2 <_GLOBAL__sub_I_counter>:
    3cb2:	0f 93       	push	r16
    3cb4:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3cb6:	0a e0       	ldi	r16, 0x0A	; 10
    3cb8:	10 e0       	ldi	r17, 0x00	; 0
    3cba:	20 e0       	ldi	r18, 0x00	; 0
    3cbc:	30 e0       	ldi	r19, 0x00	; 0
    3cbe:	40 e0       	ldi	r20, 0x00	; 0
    3cc0:	50 e0       	ldi	r21, 0x00	; 0
    3cc2:	60 e2       	ldi	r22, 0x20	; 32
    3cc4:	70 e0       	ldi	r23, 0x00	; 0
    3cc6:	82 e4       	ldi	r24, 0x42	; 66
    3cc8:	91 e3       	ldi	r25, 0x31	; 49
    3cca:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3cce:	1f 91       	pop	r17
    3cd0:	0f 91       	pop	r16
    3cd2:	08 95       	ret

00003cd4 <__subsf3>:
    3cd4:	50 58       	subi	r21, 0x80	; 128

00003cd6 <__addsf3>:
    3cd6:	bb 27       	eor	r27, r27
    3cd8:	aa 27       	eor	r26, r26
    3cda:	0e 94 82 1e 	call	0x3d04	; 0x3d04 <__addsf3x>
    3cde:	0c 94 fc 1f 	jmp	0x3ff8	; 0x3ff8 <__fp_round>
    3ce2:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <__fp_pscA>
    3ce6:	38 f0       	brcs	.+14     	; 0x3cf6 <__addsf3+0x20>
    3ce8:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <__fp_pscB>
    3cec:	20 f0       	brcs	.+8      	; 0x3cf6 <__addsf3+0x20>
    3cee:	39 f4       	brne	.+14     	; 0x3cfe <__addsf3+0x28>
    3cf0:	9f 3f       	cpi	r25, 0xFF	; 255
    3cf2:	19 f4       	brne	.+6      	; 0x3cfa <__addsf3+0x24>
    3cf4:	26 f4       	brtc	.+8      	; 0x3cfe <__addsf3+0x28>
    3cf6:	0c 94 eb 1f 	jmp	0x3fd6	; 0x3fd6 <__fp_nan>
    3cfa:	0e f4       	brtc	.+2      	; 0x3cfe <__addsf3+0x28>
    3cfc:	e0 95       	com	r30
    3cfe:	e7 fb       	bst	r30, 7
    3d00:	0c 94 e5 1f 	jmp	0x3fca	; 0x3fca <__fp_inf>

00003d04 <__addsf3x>:
    3d04:	e9 2f       	mov	r30, r25
    3d06:	0e 94 0d 20 	call	0x401a	; 0x401a <__fp_split3>
    3d0a:	58 f3       	brcs	.-42     	; 0x3ce2 <__addsf3+0xc>
    3d0c:	ba 17       	cp	r27, r26
    3d0e:	62 07       	cpc	r22, r18
    3d10:	73 07       	cpc	r23, r19
    3d12:	84 07       	cpc	r24, r20
    3d14:	95 07       	cpc	r25, r21
    3d16:	20 f0       	brcs	.+8      	; 0x3d20 <__addsf3x+0x1c>
    3d18:	79 f4       	brne	.+30     	; 0x3d38 <__addsf3x+0x34>
    3d1a:	a6 f5       	brtc	.+104    	; 0x3d84 <__addsf3x+0x80>
    3d1c:	0c 94 2f 20 	jmp	0x405e	; 0x405e <__fp_zero>
    3d20:	0e f4       	brtc	.+2      	; 0x3d24 <__addsf3x+0x20>
    3d22:	e0 95       	com	r30
    3d24:	0b 2e       	mov	r0, r27
    3d26:	ba 2f       	mov	r27, r26
    3d28:	a0 2d       	mov	r26, r0
    3d2a:	0b 01       	movw	r0, r22
    3d2c:	b9 01       	movw	r22, r18
    3d2e:	90 01       	movw	r18, r0
    3d30:	0c 01       	movw	r0, r24
    3d32:	ca 01       	movw	r24, r20
    3d34:	a0 01       	movw	r20, r0
    3d36:	11 24       	eor	r1, r1
    3d38:	ff 27       	eor	r31, r31
    3d3a:	59 1b       	sub	r21, r25
    3d3c:	99 f0       	breq	.+38     	; 0x3d64 <__addsf3x+0x60>
    3d3e:	59 3f       	cpi	r21, 0xF9	; 249
    3d40:	50 f4       	brcc	.+20     	; 0x3d56 <__addsf3x+0x52>
    3d42:	50 3e       	cpi	r21, 0xE0	; 224
    3d44:	68 f1       	brcs	.+90     	; 0x3da0 <__addsf3x+0x9c>
    3d46:	1a 16       	cp	r1, r26
    3d48:	f0 40       	sbci	r31, 0x00	; 0
    3d4a:	a2 2f       	mov	r26, r18
    3d4c:	23 2f       	mov	r18, r19
    3d4e:	34 2f       	mov	r19, r20
    3d50:	44 27       	eor	r20, r20
    3d52:	58 5f       	subi	r21, 0xF8	; 248
    3d54:	f3 cf       	rjmp	.-26     	; 0x3d3c <__addsf3x+0x38>
    3d56:	46 95       	lsr	r20
    3d58:	37 95       	ror	r19
    3d5a:	27 95       	ror	r18
    3d5c:	a7 95       	ror	r26
    3d5e:	f0 40       	sbci	r31, 0x00	; 0
    3d60:	53 95       	inc	r21
    3d62:	c9 f7       	brne	.-14     	; 0x3d56 <__addsf3x+0x52>
    3d64:	7e f4       	brtc	.+30     	; 0x3d84 <__addsf3x+0x80>
    3d66:	1f 16       	cp	r1, r31
    3d68:	ba 0b       	sbc	r27, r26
    3d6a:	62 0b       	sbc	r22, r18
    3d6c:	73 0b       	sbc	r23, r19
    3d6e:	84 0b       	sbc	r24, r20
    3d70:	ba f0       	brmi	.+46     	; 0x3da0 <__addsf3x+0x9c>
    3d72:	91 50       	subi	r25, 0x01	; 1
    3d74:	a1 f0       	breq	.+40     	; 0x3d9e <__addsf3x+0x9a>
    3d76:	ff 0f       	add	r31, r31
    3d78:	bb 1f       	adc	r27, r27
    3d7a:	66 1f       	adc	r22, r22
    3d7c:	77 1f       	adc	r23, r23
    3d7e:	88 1f       	adc	r24, r24
    3d80:	c2 f7       	brpl	.-16     	; 0x3d72 <__addsf3x+0x6e>
    3d82:	0e c0       	rjmp	.+28     	; 0x3da0 <__addsf3x+0x9c>
    3d84:	ba 0f       	add	r27, r26
    3d86:	62 1f       	adc	r22, r18
    3d88:	73 1f       	adc	r23, r19
    3d8a:	84 1f       	adc	r24, r20
    3d8c:	48 f4       	brcc	.+18     	; 0x3da0 <__addsf3x+0x9c>
    3d8e:	87 95       	ror	r24
    3d90:	77 95       	ror	r23
    3d92:	67 95       	ror	r22
    3d94:	b7 95       	ror	r27
    3d96:	f7 95       	ror	r31
    3d98:	9e 3f       	cpi	r25, 0xFE	; 254
    3d9a:	08 f0       	brcs	.+2      	; 0x3d9e <__addsf3x+0x9a>
    3d9c:	b0 cf       	rjmp	.-160    	; 0x3cfe <__addsf3+0x28>
    3d9e:	93 95       	inc	r25
    3da0:	88 0f       	add	r24, r24
    3da2:	08 f0       	brcs	.+2      	; 0x3da6 <__addsf3x+0xa2>
    3da4:	99 27       	eor	r25, r25
    3da6:	ee 0f       	add	r30, r30
    3da8:	97 95       	ror	r25
    3daa:	87 95       	ror	r24
    3dac:	08 95       	ret

00003dae <__cmpsf2>:
    3dae:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <__fp_cmp>
    3db2:	08 f4       	brcc	.+2      	; 0x3db6 <__cmpsf2+0x8>
    3db4:	81 e0       	ldi	r24, 0x01	; 1
    3db6:	08 95       	ret

00003db8 <__divsf3>:
    3db8:	0e 94 f0 1e 	call	0x3de0	; 0x3de0 <__divsf3x>
    3dbc:	0c 94 fc 1f 	jmp	0x3ff8	; 0x3ff8 <__fp_round>
    3dc0:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <__fp_pscB>
    3dc4:	58 f0       	brcs	.+22     	; 0x3ddc <__divsf3+0x24>
    3dc6:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <__fp_pscA>
    3dca:	40 f0       	brcs	.+16     	; 0x3ddc <__divsf3+0x24>
    3dcc:	29 f4       	brne	.+10     	; 0x3dd8 <__divsf3+0x20>
    3dce:	5f 3f       	cpi	r21, 0xFF	; 255
    3dd0:	29 f0       	breq	.+10     	; 0x3ddc <__divsf3+0x24>
    3dd2:	0c 94 e5 1f 	jmp	0x3fca	; 0x3fca <__fp_inf>
    3dd6:	51 11       	cpse	r21, r1
    3dd8:	0c 94 30 20 	jmp	0x4060	; 0x4060 <__fp_szero>
    3ddc:	0c 94 eb 1f 	jmp	0x3fd6	; 0x3fd6 <__fp_nan>

00003de0 <__divsf3x>:
    3de0:	0e 94 0d 20 	call	0x401a	; 0x401a <__fp_split3>
    3de4:	68 f3       	brcs	.-38     	; 0x3dc0 <__divsf3+0x8>

00003de6 <__divsf3_pse>:
    3de6:	99 23       	and	r25, r25
    3de8:	b1 f3       	breq	.-20     	; 0x3dd6 <__divsf3+0x1e>
    3dea:	55 23       	and	r21, r21
    3dec:	91 f3       	breq	.-28     	; 0x3dd2 <__divsf3+0x1a>
    3dee:	95 1b       	sub	r25, r21
    3df0:	55 0b       	sbc	r21, r21
    3df2:	bb 27       	eor	r27, r27
    3df4:	aa 27       	eor	r26, r26
    3df6:	62 17       	cp	r22, r18
    3df8:	73 07       	cpc	r23, r19
    3dfa:	84 07       	cpc	r24, r20
    3dfc:	38 f0       	brcs	.+14     	; 0x3e0c <__divsf3_pse+0x26>
    3dfe:	9f 5f       	subi	r25, 0xFF	; 255
    3e00:	5f 4f       	sbci	r21, 0xFF	; 255
    3e02:	22 0f       	add	r18, r18
    3e04:	33 1f       	adc	r19, r19
    3e06:	44 1f       	adc	r20, r20
    3e08:	aa 1f       	adc	r26, r26
    3e0a:	a9 f3       	breq	.-22     	; 0x3df6 <__divsf3_pse+0x10>
    3e0c:	35 d0       	rcall	.+106    	; 0x3e78 <__divsf3_pse+0x92>
    3e0e:	0e 2e       	mov	r0, r30
    3e10:	3a f0       	brmi	.+14     	; 0x3e20 <__divsf3_pse+0x3a>
    3e12:	e0 e8       	ldi	r30, 0x80	; 128
    3e14:	32 d0       	rcall	.+100    	; 0x3e7a <__divsf3_pse+0x94>
    3e16:	91 50       	subi	r25, 0x01	; 1
    3e18:	50 40       	sbci	r21, 0x00	; 0
    3e1a:	e6 95       	lsr	r30
    3e1c:	00 1c       	adc	r0, r0
    3e1e:	ca f7       	brpl	.-14     	; 0x3e12 <__divsf3_pse+0x2c>
    3e20:	2b d0       	rcall	.+86     	; 0x3e78 <__divsf3_pse+0x92>
    3e22:	fe 2f       	mov	r31, r30
    3e24:	29 d0       	rcall	.+82     	; 0x3e78 <__divsf3_pse+0x92>
    3e26:	66 0f       	add	r22, r22
    3e28:	77 1f       	adc	r23, r23
    3e2a:	88 1f       	adc	r24, r24
    3e2c:	bb 1f       	adc	r27, r27
    3e2e:	26 17       	cp	r18, r22
    3e30:	37 07       	cpc	r19, r23
    3e32:	48 07       	cpc	r20, r24
    3e34:	ab 07       	cpc	r26, r27
    3e36:	b0 e8       	ldi	r27, 0x80	; 128
    3e38:	09 f0       	breq	.+2      	; 0x3e3c <__divsf3_pse+0x56>
    3e3a:	bb 0b       	sbc	r27, r27
    3e3c:	80 2d       	mov	r24, r0
    3e3e:	bf 01       	movw	r22, r30
    3e40:	ff 27       	eor	r31, r31
    3e42:	93 58       	subi	r25, 0x83	; 131
    3e44:	5f 4f       	sbci	r21, 0xFF	; 255
    3e46:	3a f0       	brmi	.+14     	; 0x3e56 <__divsf3_pse+0x70>
    3e48:	9e 3f       	cpi	r25, 0xFE	; 254
    3e4a:	51 05       	cpc	r21, r1
    3e4c:	78 f0       	brcs	.+30     	; 0x3e6c <__divsf3_pse+0x86>
    3e4e:	0c 94 e5 1f 	jmp	0x3fca	; 0x3fca <__fp_inf>
    3e52:	0c 94 30 20 	jmp	0x4060	; 0x4060 <__fp_szero>
    3e56:	5f 3f       	cpi	r21, 0xFF	; 255
    3e58:	e4 f3       	brlt	.-8      	; 0x3e52 <__divsf3_pse+0x6c>
    3e5a:	98 3e       	cpi	r25, 0xE8	; 232
    3e5c:	d4 f3       	brlt	.-12     	; 0x3e52 <__divsf3_pse+0x6c>
    3e5e:	86 95       	lsr	r24
    3e60:	77 95       	ror	r23
    3e62:	67 95       	ror	r22
    3e64:	b7 95       	ror	r27
    3e66:	f7 95       	ror	r31
    3e68:	9f 5f       	subi	r25, 0xFF	; 255
    3e6a:	c9 f7       	brne	.-14     	; 0x3e5e <__divsf3_pse+0x78>
    3e6c:	88 0f       	add	r24, r24
    3e6e:	91 1d       	adc	r25, r1
    3e70:	96 95       	lsr	r25
    3e72:	87 95       	ror	r24
    3e74:	97 f9       	bld	r25, 7
    3e76:	08 95       	ret
    3e78:	e1 e0       	ldi	r30, 0x01	; 1
    3e7a:	66 0f       	add	r22, r22
    3e7c:	77 1f       	adc	r23, r23
    3e7e:	88 1f       	adc	r24, r24
    3e80:	bb 1f       	adc	r27, r27
    3e82:	62 17       	cp	r22, r18
    3e84:	73 07       	cpc	r23, r19
    3e86:	84 07       	cpc	r24, r20
    3e88:	ba 07       	cpc	r27, r26
    3e8a:	20 f0       	brcs	.+8      	; 0x3e94 <__divsf3_pse+0xae>
    3e8c:	62 1b       	sub	r22, r18
    3e8e:	73 0b       	sbc	r23, r19
    3e90:	84 0b       	sbc	r24, r20
    3e92:	ba 0b       	sbc	r27, r26
    3e94:	ee 1f       	adc	r30, r30
    3e96:	88 f7       	brcc	.-30     	; 0x3e7a <__divsf3_pse+0x94>
    3e98:	e0 95       	com	r30
    3e9a:	08 95       	ret

00003e9c <__fixsfsi>:
    3e9c:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <__fixunssfsi>
    3ea0:	68 94       	set
    3ea2:	b1 11       	cpse	r27, r1
    3ea4:	0c 94 30 20 	jmp	0x4060	; 0x4060 <__fp_szero>
    3ea8:	08 95       	ret

00003eaa <__fixunssfsi>:
    3eaa:	0e 94 15 20 	call	0x402a	; 0x402a <__fp_splitA>
    3eae:	88 f0       	brcs	.+34     	; 0x3ed2 <__fixunssfsi+0x28>
    3eb0:	9f 57       	subi	r25, 0x7F	; 127
    3eb2:	98 f0       	brcs	.+38     	; 0x3eda <__fixunssfsi+0x30>
    3eb4:	b9 2f       	mov	r27, r25
    3eb6:	99 27       	eor	r25, r25
    3eb8:	b7 51       	subi	r27, 0x17	; 23
    3eba:	b0 f0       	brcs	.+44     	; 0x3ee8 <__fixunssfsi+0x3e>
    3ebc:	e1 f0       	breq	.+56     	; 0x3ef6 <__fixunssfsi+0x4c>
    3ebe:	66 0f       	add	r22, r22
    3ec0:	77 1f       	adc	r23, r23
    3ec2:	88 1f       	adc	r24, r24
    3ec4:	99 1f       	adc	r25, r25
    3ec6:	1a f0       	brmi	.+6      	; 0x3ece <__fixunssfsi+0x24>
    3ec8:	ba 95       	dec	r27
    3eca:	c9 f7       	brne	.-14     	; 0x3ebe <__fixunssfsi+0x14>
    3ecc:	14 c0       	rjmp	.+40     	; 0x3ef6 <__fixunssfsi+0x4c>
    3ece:	b1 30       	cpi	r27, 0x01	; 1
    3ed0:	91 f0       	breq	.+36     	; 0x3ef6 <__fixunssfsi+0x4c>
    3ed2:	0e 94 2f 20 	call	0x405e	; 0x405e <__fp_zero>
    3ed6:	b1 e0       	ldi	r27, 0x01	; 1
    3ed8:	08 95       	ret
    3eda:	0c 94 2f 20 	jmp	0x405e	; 0x405e <__fp_zero>
    3ede:	67 2f       	mov	r22, r23
    3ee0:	78 2f       	mov	r23, r24
    3ee2:	88 27       	eor	r24, r24
    3ee4:	b8 5f       	subi	r27, 0xF8	; 248
    3ee6:	39 f0       	breq	.+14     	; 0x3ef6 <__fixunssfsi+0x4c>
    3ee8:	b9 3f       	cpi	r27, 0xF9	; 249
    3eea:	cc f3       	brlt	.-14     	; 0x3ede <__fixunssfsi+0x34>
    3eec:	86 95       	lsr	r24
    3eee:	77 95       	ror	r23
    3ef0:	67 95       	ror	r22
    3ef2:	b3 95       	inc	r27
    3ef4:	d9 f7       	brne	.-10     	; 0x3eec <__fixunssfsi+0x42>
    3ef6:	3e f4       	brtc	.+14     	; 0x3f06 <__fixunssfsi+0x5c>
    3ef8:	90 95       	com	r25
    3efa:	80 95       	com	r24
    3efc:	70 95       	com	r23
    3efe:	61 95       	neg	r22
    3f00:	7f 4f       	sbci	r23, 0xFF	; 255
    3f02:	8f 4f       	sbci	r24, 0xFF	; 255
    3f04:	9f 4f       	sbci	r25, 0xFF	; 255
    3f06:	08 95       	ret

00003f08 <__floatunsisf>:
    3f08:	e8 94       	clt
    3f0a:	09 c0       	rjmp	.+18     	; 0x3f1e <__floatsisf+0x12>

00003f0c <__floatsisf>:
    3f0c:	97 fb       	bst	r25, 7
    3f0e:	3e f4       	brtc	.+14     	; 0x3f1e <__floatsisf+0x12>
    3f10:	90 95       	com	r25
    3f12:	80 95       	com	r24
    3f14:	70 95       	com	r23
    3f16:	61 95       	neg	r22
    3f18:	7f 4f       	sbci	r23, 0xFF	; 255
    3f1a:	8f 4f       	sbci	r24, 0xFF	; 255
    3f1c:	9f 4f       	sbci	r25, 0xFF	; 255
    3f1e:	99 23       	and	r25, r25
    3f20:	a9 f0       	breq	.+42     	; 0x3f4c <__floatsisf+0x40>
    3f22:	f9 2f       	mov	r31, r25
    3f24:	96 e9       	ldi	r25, 0x96	; 150
    3f26:	bb 27       	eor	r27, r27
    3f28:	93 95       	inc	r25
    3f2a:	f6 95       	lsr	r31
    3f2c:	87 95       	ror	r24
    3f2e:	77 95       	ror	r23
    3f30:	67 95       	ror	r22
    3f32:	b7 95       	ror	r27
    3f34:	f1 11       	cpse	r31, r1
    3f36:	f8 cf       	rjmp	.-16     	; 0x3f28 <__floatsisf+0x1c>
    3f38:	fa f4       	brpl	.+62     	; 0x3f78 <__floatsisf+0x6c>
    3f3a:	bb 0f       	add	r27, r27
    3f3c:	11 f4       	brne	.+4      	; 0x3f42 <__floatsisf+0x36>
    3f3e:	60 ff       	sbrs	r22, 0
    3f40:	1b c0       	rjmp	.+54     	; 0x3f78 <__floatsisf+0x6c>
    3f42:	6f 5f       	subi	r22, 0xFF	; 255
    3f44:	7f 4f       	sbci	r23, 0xFF	; 255
    3f46:	8f 4f       	sbci	r24, 0xFF	; 255
    3f48:	9f 4f       	sbci	r25, 0xFF	; 255
    3f4a:	16 c0       	rjmp	.+44     	; 0x3f78 <__floatsisf+0x6c>
    3f4c:	88 23       	and	r24, r24
    3f4e:	11 f0       	breq	.+4      	; 0x3f54 <__floatsisf+0x48>
    3f50:	96 e9       	ldi	r25, 0x96	; 150
    3f52:	11 c0       	rjmp	.+34     	; 0x3f76 <__floatsisf+0x6a>
    3f54:	77 23       	and	r23, r23
    3f56:	21 f0       	breq	.+8      	; 0x3f60 <__floatsisf+0x54>
    3f58:	9e e8       	ldi	r25, 0x8E	; 142
    3f5a:	87 2f       	mov	r24, r23
    3f5c:	76 2f       	mov	r23, r22
    3f5e:	05 c0       	rjmp	.+10     	; 0x3f6a <__floatsisf+0x5e>
    3f60:	66 23       	and	r22, r22
    3f62:	71 f0       	breq	.+28     	; 0x3f80 <__floatsisf+0x74>
    3f64:	96 e8       	ldi	r25, 0x86	; 134
    3f66:	86 2f       	mov	r24, r22
    3f68:	70 e0       	ldi	r23, 0x00	; 0
    3f6a:	60 e0       	ldi	r22, 0x00	; 0
    3f6c:	2a f0       	brmi	.+10     	; 0x3f78 <__floatsisf+0x6c>
    3f6e:	9a 95       	dec	r25
    3f70:	66 0f       	add	r22, r22
    3f72:	77 1f       	adc	r23, r23
    3f74:	88 1f       	adc	r24, r24
    3f76:	da f7       	brpl	.-10     	; 0x3f6e <__floatsisf+0x62>
    3f78:	88 0f       	add	r24, r24
    3f7a:	96 95       	lsr	r25
    3f7c:	87 95       	ror	r24
    3f7e:	97 f9       	bld	r25, 7
    3f80:	08 95       	ret

00003f82 <__fp_cmp>:
    3f82:	99 0f       	add	r25, r25
    3f84:	00 08       	sbc	r0, r0
    3f86:	55 0f       	add	r21, r21
    3f88:	aa 0b       	sbc	r26, r26
    3f8a:	e0 e8       	ldi	r30, 0x80	; 128
    3f8c:	fe ef       	ldi	r31, 0xFE	; 254
    3f8e:	16 16       	cp	r1, r22
    3f90:	17 06       	cpc	r1, r23
    3f92:	e8 07       	cpc	r30, r24
    3f94:	f9 07       	cpc	r31, r25
    3f96:	c0 f0       	brcs	.+48     	; 0x3fc8 <__fp_cmp+0x46>
    3f98:	12 16       	cp	r1, r18
    3f9a:	13 06       	cpc	r1, r19
    3f9c:	e4 07       	cpc	r30, r20
    3f9e:	f5 07       	cpc	r31, r21
    3fa0:	98 f0       	brcs	.+38     	; 0x3fc8 <__fp_cmp+0x46>
    3fa2:	62 1b       	sub	r22, r18
    3fa4:	73 0b       	sbc	r23, r19
    3fa6:	84 0b       	sbc	r24, r20
    3fa8:	95 0b       	sbc	r25, r21
    3faa:	39 f4       	brne	.+14     	; 0x3fba <__fp_cmp+0x38>
    3fac:	0a 26       	eor	r0, r26
    3fae:	61 f0       	breq	.+24     	; 0x3fc8 <__fp_cmp+0x46>
    3fb0:	23 2b       	or	r18, r19
    3fb2:	24 2b       	or	r18, r20
    3fb4:	25 2b       	or	r18, r21
    3fb6:	21 f4       	brne	.+8      	; 0x3fc0 <__fp_cmp+0x3e>
    3fb8:	08 95       	ret
    3fba:	0a 26       	eor	r0, r26
    3fbc:	09 f4       	brne	.+2      	; 0x3fc0 <__fp_cmp+0x3e>
    3fbe:	a1 40       	sbci	r26, 0x01	; 1
    3fc0:	a6 95       	lsr	r26
    3fc2:	8f ef       	ldi	r24, 0xFF	; 255
    3fc4:	81 1d       	adc	r24, r1
    3fc6:	81 1d       	adc	r24, r1
    3fc8:	08 95       	ret

00003fca <__fp_inf>:
    3fca:	97 f9       	bld	r25, 7
    3fcc:	9f 67       	ori	r25, 0x7F	; 127
    3fce:	80 e8       	ldi	r24, 0x80	; 128
    3fd0:	70 e0       	ldi	r23, 0x00	; 0
    3fd2:	60 e0       	ldi	r22, 0x00	; 0
    3fd4:	08 95       	ret

00003fd6 <__fp_nan>:
    3fd6:	9f ef       	ldi	r25, 0xFF	; 255
    3fd8:	80 ec       	ldi	r24, 0xC0	; 192
    3fda:	08 95       	ret

00003fdc <__fp_pscA>:
    3fdc:	00 24       	eor	r0, r0
    3fde:	0a 94       	dec	r0
    3fe0:	16 16       	cp	r1, r22
    3fe2:	17 06       	cpc	r1, r23
    3fe4:	18 06       	cpc	r1, r24
    3fe6:	09 06       	cpc	r0, r25
    3fe8:	08 95       	ret

00003fea <__fp_pscB>:
    3fea:	00 24       	eor	r0, r0
    3fec:	0a 94       	dec	r0
    3fee:	12 16       	cp	r1, r18
    3ff0:	13 06       	cpc	r1, r19
    3ff2:	14 06       	cpc	r1, r20
    3ff4:	05 06       	cpc	r0, r21
    3ff6:	08 95       	ret

00003ff8 <__fp_round>:
    3ff8:	09 2e       	mov	r0, r25
    3ffa:	03 94       	inc	r0
    3ffc:	00 0c       	add	r0, r0
    3ffe:	11 f4       	brne	.+4      	; 0x4004 <__stack+0x5>
    4000:	88 23       	and	r24, r24
    4002:	52 f0       	brmi	.+20     	; 0x4018 <__stack+0x19>
    4004:	bb 0f       	add	r27, r27
    4006:	40 f4       	brcc	.+16     	; 0x4018 <__stack+0x19>
    4008:	bf 2b       	or	r27, r31
    400a:	11 f4       	brne	.+4      	; 0x4010 <__stack+0x11>
    400c:	60 ff       	sbrs	r22, 0
    400e:	04 c0       	rjmp	.+8      	; 0x4018 <__stack+0x19>
    4010:	6f 5f       	subi	r22, 0xFF	; 255
    4012:	7f 4f       	sbci	r23, 0xFF	; 255
    4014:	8f 4f       	sbci	r24, 0xFF	; 255
    4016:	9f 4f       	sbci	r25, 0xFF	; 255
    4018:	08 95       	ret

0000401a <__fp_split3>:
    401a:	57 fd       	sbrc	r21, 7
    401c:	90 58       	subi	r25, 0x80	; 128
    401e:	44 0f       	add	r20, r20
    4020:	55 1f       	adc	r21, r21
    4022:	59 f0       	breq	.+22     	; 0x403a <__fp_splitA+0x10>
    4024:	5f 3f       	cpi	r21, 0xFF	; 255
    4026:	71 f0       	breq	.+28     	; 0x4044 <__fp_splitA+0x1a>
    4028:	47 95       	ror	r20

0000402a <__fp_splitA>:
    402a:	88 0f       	add	r24, r24
    402c:	97 fb       	bst	r25, 7
    402e:	99 1f       	adc	r25, r25
    4030:	61 f0       	breq	.+24     	; 0x404a <__fp_splitA+0x20>
    4032:	9f 3f       	cpi	r25, 0xFF	; 255
    4034:	79 f0       	breq	.+30     	; 0x4054 <__fp_splitA+0x2a>
    4036:	87 95       	ror	r24
    4038:	08 95       	ret
    403a:	12 16       	cp	r1, r18
    403c:	13 06       	cpc	r1, r19
    403e:	14 06       	cpc	r1, r20
    4040:	55 1f       	adc	r21, r21
    4042:	f2 cf       	rjmp	.-28     	; 0x4028 <__fp_split3+0xe>
    4044:	46 95       	lsr	r20
    4046:	f1 df       	rcall	.-30     	; 0x402a <__fp_splitA>
    4048:	08 c0       	rjmp	.+16     	; 0x405a <__fp_splitA+0x30>
    404a:	16 16       	cp	r1, r22
    404c:	17 06       	cpc	r1, r23
    404e:	18 06       	cpc	r1, r24
    4050:	99 1f       	adc	r25, r25
    4052:	f1 cf       	rjmp	.-30     	; 0x4036 <__fp_splitA+0xc>
    4054:	86 95       	lsr	r24
    4056:	71 05       	cpc	r23, r1
    4058:	61 05       	cpc	r22, r1
    405a:	08 94       	sec
    405c:	08 95       	ret

0000405e <__fp_zero>:
    405e:	e8 94       	clt

00004060 <__fp_szero>:
    4060:	bb 27       	eor	r27, r27
    4062:	66 27       	eor	r22, r22
    4064:	77 27       	eor	r23, r23
    4066:	cb 01       	movw	r24, r22
    4068:	97 f9       	bld	r25, 7
    406a:	08 95       	ret

0000406c <__gesf2>:
    406c:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <__fp_cmp>
    4070:	08 f4       	brcc	.+2      	; 0x4074 <__gesf2+0x8>
    4072:	8f ef       	ldi	r24, 0xFF	; 255
    4074:	08 95       	ret

00004076 <__mulsf3>:
    4076:	0e 94 4e 20 	call	0x409c	; 0x409c <__mulsf3x>
    407a:	0c 94 fc 1f 	jmp	0x3ff8	; 0x3ff8 <__fp_round>
    407e:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <__fp_pscA>
    4082:	38 f0       	brcs	.+14     	; 0x4092 <__mulsf3+0x1c>
    4084:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <__fp_pscB>
    4088:	20 f0       	brcs	.+8      	; 0x4092 <__mulsf3+0x1c>
    408a:	95 23       	and	r25, r21
    408c:	11 f0       	breq	.+4      	; 0x4092 <__mulsf3+0x1c>
    408e:	0c 94 e5 1f 	jmp	0x3fca	; 0x3fca <__fp_inf>
    4092:	0c 94 eb 1f 	jmp	0x3fd6	; 0x3fd6 <__fp_nan>
    4096:	11 24       	eor	r1, r1
    4098:	0c 94 30 20 	jmp	0x4060	; 0x4060 <__fp_szero>

0000409c <__mulsf3x>:
    409c:	0e 94 0d 20 	call	0x401a	; 0x401a <__fp_split3>
    40a0:	70 f3       	brcs	.-36     	; 0x407e <__mulsf3+0x8>

000040a2 <__mulsf3_pse>:
    40a2:	95 9f       	mul	r25, r21
    40a4:	c1 f3       	breq	.-16     	; 0x4096 <__mulsf3+0x20>
    40a6:	95 0f       	add	r25, r21
    40a8:	50 e0       	ldi	r21, 0x00	; 0
    40aa:	55 1f       	adc	r21, r21
    40ac:	62 9f       	mul	r22, r18
    40ae:	f0 01       	movw	r30, r0
    40b0:	72 9f       	mul	r23, r18
    40b2:	bb 27       	eor	r27, r27
    40b4:	f0 0d       	add	r31, r0
    40b6:	b1 1d       	adc	r27, r1
    40b8:	63 9f       	mul	r22, r19
    40ba:	aa 27       	eor	r26, r26
    40bc:	f0 0d       	add	r31, r0
    40be:	b1 1d       	adc	r27, r1
    40c0:	aa 1f       	adc	r26, r26
    40c2:	64 9f       	mul	r22, r20
    40c4:	66 27       	eor	r22, r22
    40c6:	b0 0d       	add	r27, r0
    40c8:	a1 1d       	adc	r26, r1
    40ca:	66 1f       	adc	r22, r22
    40cc:	82 9f       	mul	r24, r18
    40ce:	22 27       	eor	r18, r18
    40d0:	b0 0d       	add	r27, r0
    40d2:	a1 1d       	adc	r26, r1
    40d4:	62 1f       	adc	r22, r18
    40d6:	73 9f       	mul	r23, r19
    40d8:	b0 0d       	add	r27, r0
    40da:	a1 1d       	adc	r26, r1
    40dc:	62 1f       	adc	r22, r18
    40de:	83 9f       	mul	r24, r19
    40e0:	a0 0d       	add	r26, r0
    40e2:	61 1d       	adc	r22, r1
    40e4:	22 1f       	adc	r18, r18
    40e6:	74 9f       	mul	r23, r20
    40e8:	33 27       	eor	r19, r19
    40ea:	a0 0d       	add	r26, r0
    40ec:	61 1d       	adc	r22, r1
    40ee:	23 1f       	adc	r18, r19
    40f0:	84 9f       	mul	r24, r20
    40f2:	60 0d       	add	r22, r0
    40f4:	21 1d       	adc	r18, r1
    40f6:	82 2f       	mov	r24, r18
    40f8:	76 2f       	mov	r23, r22
    40fa:	6a 2f       	mov	r22, r26
    40fc:	11 24       	eor	r1, r1
    40fe:	9f 57       	subi	r25, 0x7F	; 127
    4100:	50 40       	sbci	r21, 0x00	; 0
    4102:	9a f0       	brmi	.+38     	; 0x412a <__mulsf3_pse+0x88>
    4104:	f1 f0       	breq	.+60     	; 0x4142 <__mulsf3_pse+0xa0>
    4106:	88 23       	and	r24, r24
    4108:	4a f0       	brmi	.+18     	; 0x411c <__mulsf3_pse+0x7a>
    410a:	ee 0f       	add	r30, r30
    410c:	ff 1f       	adc	r31, r31
    410e:	bb 1f       	adc	r27, r27
    4110:	66 1f       	adc	r22, r22
    4112:	77 1f       	adc	r23, r23
    4114:	88 1f       	adc	r24, r24
    4116:	91 50       	subi	r25, 0x01	; 1
    4118:	50 40       	sbci	r21, 0x00	; 0
    411a:	a9 f7       	brne	.-22     	; 0x4106 <__mulsf3_pse+0x64>
    411c:	9e 3f       	cpi	r25, 0xFE	; 254
    411e:	51 05       	cpc	r21, r1
    4120:	80 f0       	brcs	.+32     	; 0x4142 <__mulsf3_pse+0xa0>
    4122:	0c 94 e5 1f 	jmp	0x3fca	; 0x3fca <__fp_inf>
    4126:	0c 94 30 20 	jmp	0x4060	; 0x4060 <__fp_szero>
    412a:	5f 3f       	cpi	r21, 0xFF	; 255
    412c:	e4 f3       	brlt	.-8      	; 0x4126 <__mulsf3_pse+0x84>
    412e:	98 3e       	cpi	r25, 0xE8	; 232
    4130:	d4 f3       	brlt	.-12     	; 0x4126 <__mulsf3_pse+0x84>
    4132:	86 95       	lsr	r24
    4134:	77 95       	ror	r23
    4136:	67 95       	ror	r22
    4138:	b7 95       	ror	r27
    413a:	f7 95       	ror	r31
    413c:	e7 95       	ror	r30
    413e:	9f 5f       	subi	r25, 0xFF	; 255
    4140:	c1 f7       	brne	.-16     	; 0x4132 <__mulsf3_pse+0x90>
    4142:	fe 2b       	or	r31, r30
    4144:	88 0f       	add	r24, r24
    4146:	91 1d       	adc	r25, r1
    4148:	96 95       	lsr	r25
    414a:	87 95       	ror	r24
    414c:	97 f9       	bld	r25, 7
    414e:	08 95       	ret

00004150 <__mulsi3>:
    4150:	db 01       	movw	r26, r22
    4152:	8f 93       	push	r24
    4154:	9f 93       	push	r25
    4156:	0e 94 09 21 	call	0x4212	; 0x4212 <__muluhisi3>
    415a:	bf 91       	pop	r27
    415c:	af 91       	pop	r26
    415e:	a2 9f       	mul	r26, r18
    4160:	80 0d       	add	r24, r0
    4162:	91 1d       	adc	r25, r1
    4164:	a3 9f       	mul	r26, r19
    4166:	90 0d       	add	r25, r0
    4168:	b2 9f       	mul	r27, r18
    416a:	90 0d       	add	r25, r0
    416c:	11 24       	eor	r1, r1
    416e:	08 95       	ret

00004170 <__udivmodsi4>:
    4170:	a1 e2       	ldi	r26, 0x21	; 33
    4172:	1a 2e       	mov	r1, r26
    4174:	aa 1b       	sub	r26, r26
    4176:	bb 1b       	sub	r27, r27
    4178:	fd 01       	movw	r30, r26
    417a:	0d c0       	rjmp	.+26     	; 0x4196 <__udivmodsi4_ep>

0000417c <__udivmodsi4_loop>:
    417c:	aa 1f       	adc	r26, r26
    417e:	bb 1f       	adc	r27, r27
    4180:	ee 1f       	adc	r30, r30
    4182:	ff 1f       	adc	r31, r31
    4184:	a2 17       	cp	r26, r18
    4186:	b3 07       	cpc	r27, r19
    4188:	e4 07       	cpc	r30, r20
    418a:	f5 07       	cpc	r31, r21
    418c:	20 f0       	brcs	.+8      	; 0x4196 <__udivmodsi4_ep>
    418e:	a2 1b       	sub	r26, r18
    4190:	b3 0b       	sbc	r27, r19
    4192:	e4 0b       	sbc	r30, r20
    4194:	f5 0b       	sbc	r31, r21

00004196 <__udivmodsi4_ep>:
    4196:	66 1f       	adc	r22, r22
    4198:	77 1f       	adc	r23, r23
    419a:	88 1f       	adc	r24, r24
    419c:	99 1f       	adc	r25, r25
    419e:	1a 94       	dec	r1
    41a0:	69 f7       	brne	.-38     	; 0x417c <__udivmodsi4_loop>
    41a2:	60 95       	com	r22
    41a4:	70 95       	com	r23
    41a6:	80 95       	com	r24
    41a8:	90 95       	com	r25
    41aa:	9b 01       	movw	r18, r22
    41ac:	ac 01       	movw	r20, r24
    41ae:	bd 01       	movw	r22, r26
    41b0:	cf 01       	movw	r24, r30
    41b2:	08 95       	ret

000041b4 <__divmodsi4>:
    41b4:	05 2e       	mov	r0, r21
    41b6:	97 fb       	bst	r25, 7
    41b8:	1e f4       	brtc	.+6      	; 0x41c0 <__divmodsi4+0xc>
    41ba:	00 94       	com	r0
    41bc:	0e 94 f1 20 	call	0x41e2	; 0x41e2 <__negsi2>
    41c0:	57 fd       	sbrc	r21, 7
    41c2:	07 d0       	rcall	.+14     	; 0x41d2 <__divmodsi4_neg2>
    41c4:	0e 94 b8 20 	call	0x4170	; 0x4170 <__udivmodsi4>
    41c8:	07 fc       	sbrc	r0, 7
    41ca:	03 d0       	rcall	.+6      	; 0x41d2 <__divmodsi4_neg2>
    41cc:	4e f4       	brtc	.+18     	; 0x41e0 <__divmodsi4_exit>
    41ce:	0c 94 f1 20 	jmp	0x41e2	; 0x41e2 <__negsi2>

000041d2 <__divmodsi4_neg2>:
    41d2:	50 95       	com	r21
    41d4:	40 95       	com	r20
    41d6:	30 95       	com	r19
    41d8:	21 95       	neg	r18
    41da:	3f 4f       	sbci	r19, 0xFF	; 255
    41dc:	4f 4f       	sbci	r20, 0xFF	; 255
    41de:	5f 4f       	sbci	r21, 0xFF	; 255

000041e0 <__divmodsi4_exit>:
    41e0:	08 95       	ret

000041e2 <__negsi2>:
    41e2:	90 95       	com	r25
    41e4:	80 95       	com	r24
    41e6:	70 95       	com	r23
    41e8:	61 95       	neg	r22
    41ea:	7f 4f       	sbci	r23, 0xFF	; 255
    41ec:	8f 4f       	sbci	r24, 0xFF	; 255
    41ee:	9f 4f       	sbci	r25, 0xFF	; 255
    41f0:	08 95       	ret

000041f2 <__tablejump2__>:
    41f2:	ee 0f       	add	r30, r30
    41f4:	ff 1f       	adc	r31, r31
    41f6:	88 1f       	adc	r24, r24
    41f8:	8b bf       	out	0x3b, r24	; 59
    41fa:	07 90       	elpm	r0, Z+
    41fc:	f6 91       	elpm	r31, Z
    41fe:	e0 2d       	mov	r30, r0
    4200:	1b be       	out	0x3b, r1	; 59
    4202:	19 94       	eijmp

00004204 <__usmulhisi3>:
    4204:	0e 94 14 21 	call	0x4228	; 0x4228 <__umulhisi3>

00004208 <__usmulhisi3_tail>:
    4208:	b7 ff       	sbrs	r27, 7
    420a:	08 95       	ret
    420c:	82 1b       	sub	r24, r18
    420e:	93 0b       	sbc	r25, r19
    4210:	08 95       	ret

00004212 <__muluhisi3>:
    4212:	0e 94 14 21 	call	0x4228	; 0x4228 <__umulhisi3>
    4216:	a5 9f       	mul	r26, r21
    4218:	90 0d       	add	r25, r0
    421a:	b4 9f       	mul	r27, r20
    421c:	90 0d       	add	r25, r0
    421e:	a4 9f       	mul	r26, r20
    4220:	80 0d       	add	r24, r0
    4222:	91 1d       	adc	r25, r1
    4224:	11 24       	eor	r1, r1
    4226:	08 95       	ret

00004228 <__umulhisi3>:
    4228:	a2 9f       	mul	r26, r18
    422a:	b0 01       	movw	r22, r0
    422c:	b3 9f       	mul	r27, r19
    422e:	c0 01       	movw	r24, r0
    4230:	a3 9f       	mul	r26, r19
    4232:	70 0d       	add	r23, r0
    4234:	81 1d       	adc	r24, r1
    4236:	11 24       	eor	r1, r1
    4238:	91 1d       	adc	r25, r1
    423a:	b2 9f       	mul	r27, r18
    423c:	70 0d       	add	r23, r0
    423e:	81 1d       	adc	r24, r1
    4240:	11 24       	eor	r1, r1
    4242:	91 1d       	adc	r25, r1
    4244:	08 95       	ret

00004246 <memcpy>:
    4246:	fb 01       	movw	r30, r22
    4248:	dc 01       	movw	r26, r24
    424a:	02 c0       	rjmp	.+4      	; 0x4250 <memcpy+0xa>
    424c:	01 90       	ld	r0, Z+
    424e:	0d 92       	st	X+, r0
    4250:	41 50       	subi	r20, 0x01	; 1
    4252:	50 40       	sbci	r21, 0x00	; 0
    4254:	d8 f7       	brcc	.-10     	; 0x424c <memcpy+0x6>
    4256:	08 95       	ret

00004258 <memset>:
    4258:	dc 01       	movw	r26, r24
    425a:	01 c0       	rjmp	.+2      	; 0x425e <memset+0x6>
    425c:	6d 93       	st	X+, r22
    425e:	41 50       	subi	r20, 0x01	; 1
    4260:	50 40       	sbci	r21, 0x00	; 0
    4262:	e0 f7       	brcc	.-8      	; 0x425c <memset+0x4>
    4264:	08 95       	ret

00004266 <strncpy>:
    4266:	fb 01       	movw	r30, r22
    4268:	dc 01       	movw	r26, r24
    426a:	41 50       	subi	r20, 0x01	; 1
    426c:	50 40       	sbci	r21, 0x00	; 0
    426e:	48 f0       	brcs	.+18     	; 0x4282 <strncpy+0x1c>
    4270:	01 90       	ld	r0, Z+
    4272:	0d 92       	st	X+, r0
    4274:	00 20       	and	r0, r0
    4276:	c9 f7       	brne	.-14     	; 0x426a <strncpy+0x4>
    4278:	01 c0       	rjmp	.+2      	; 0x427c <strncpy+0x16>
    427a:	1d 92       	st	X+, r1
    427c:	41 50       	subi	r20, 0x01	; 1
    427e:	50 40       	sbci	r21, 0x00	; 0
    4280:	e0 f7       	brcc	.-8      	; 0x427a <strncpy+0x14>
    4282:	08 95       	ret

00004284 <ultoa>:
    4284:	25 32       	cpi	r18, 0x25	; 37
    4286:	31 05       	cpc	r19, r1
    4288:	20 f4       	brcc	.+8      	; 0x4292 <ultoa+0xe>
    428a:	22 30       	cpi	r18, 0x02	; 2
    428c:	10 f0       	brcs	.+4      	; 0x4292 <ultoa+0xe>
    428e:	0c 94 4d 21 	jmp	0x429a	; 0x429a <__ultoa_ncheck>
    4292:	fa 01       	movw	r30, r20
    4294:	10 82       	st	Z, r1
    4296:	ca 01       	movw	r24, r20
    4298:	08 95       	ret

0000429a <__ultoa_ncheck>:
    429a:	bb 27       	eor	r27, r27

0000429c <__ultoa_common>:
    429c:	fa 01       	movw	r30, r20
    429e:	a6 2f       	mov	r26, r22
    42a0:	62 17       	cp	r22, r18
    42a2:	71 05       	cpc	r23, r1
    42a4:	81 05       	cpc	r24, r1
    42a6:	91 05       	cpc	r25, r1
    42a8:	33 0b       	sbc	r19, r19
    42aa:	30 fb       	bst	r19, 0
    42ac:	66 f0       	brts	.+24     	; 0x42c6 <__ultoa_common+0x2a>
    42ae:	aa 27       	eor	r26, r26
    42b0:	66 0f       	add	r22, r22
    42b2:	77 1f       	adc	r23, r23
    42b4:	88 1f       	adc	r24, r24
    42b6:	99 1f       	adc	r25, r25
    42b8:	aa 1f       	adc	r26, r26
    42ba:	a2 17       	cp	r26, r18
    42bc:	10 f0       	brcs	.+4      	; 0x42c2 <__ultoa_common+0x26>
    42be:	a2 1b       	sub	r26, r18
    42c0:	63 95       	inc	r22
    42c2:	38 50       	subi	r19, 0x08	; 8
    42c4:	a9 f7       	brne	.-22     	; 0x42b0 <__ultoa_common+0x14>
    42c6:	a0 5d       	subi	r26, 0xD0	; 208
    42c8:	aa 33       	cpi	r26, 0x3A	; 58
    42ca:	08 f0       	brcs	.+2      	; 0x42ce <__ultoa_common+0x32>
    42cc:	a9 5d       	subi	r26, 0xD9	; 217
    42ce:	a1 93       	st	Z+, r26
    42d0:	36 f7       	brtc	.-52     	; 0x429e <__ultoa_common+0x2>
    42d2:	b1 11       	cpse	r27, r1
    42d4:	b1 93       	st	Z+, r27
    42d6:	10 82       	st	Z, r1
    42d8:	ca 01       	movw	r24, r20
    42da:	0c 94 94 21 	jmp	0x4328	; 0x4328 <strrev>

000042de <utoa>:
    42de:	45 32       	cpi	r20, 0x25	; 37
    42e0:	51 05       	cpc	r21, r1
    42e2:	20 f4       	brcc	.+8      	; 0x42ec <utoa+0xe>
    42e4:	42 30       	cpi	r20, 0x02	; 2
    42e6:	10 f0       	brcs	.+4      	; 0x42ec <utoa+0xe>
    42e8:	0c 94 7a 21 	jmp	0x42f4	; 0x42f4 <__utoa_ncheck>
    42ec:	fb 01       	movw	r30, r22
    42ee:	10 82       	st	Z, r1
    42f0:	cb 01       	movw	r24, r22
    42f2:	08 95       	ret

000042f4 <__utoa_ncheck>:
    42f4:	bb 27       	eor	r27, r27

000042f6 <__utoa_common>:
    42f6:	fb 01       	movw	r30, r22
    42f8:	55 27       	eor	r21, r21
    42fa:	aa 27       	eor	r26, r26
    42fc:	88 0f       	add	r24, r24
    42fe:	99 1f       	adc	r25, r25
    4300:	aa 1f       	adc	r26, r26
    4302:	a4 17       	cp	r26, r20
    4304:	10 f0       	brcs	.+4      	; 0x430a <__utoa_common+0x14>
    4306:	a4 1b       	sub	r26, r20
    4308:	83 95       	inc	r24
    430a:	50 51       	subi	r21, 0x10	; 16
    430c:	b9 f7       	brne	.-18     	; 0x42fc <__utoa_common+0x6>
    430e:	a0 5d       	subi	r26, 0xD0	; 208
    4310:	aa 33       	cpi	r26, 0x3A	; 58
    4312:	08 f0       	brcs	.+2      	; 0x4316 <__utoa_common+0x20>
    4314:	a9 5d       	subi	r26, 0xD9	; 217
    4316:	a1 93       	st	Z+, r26
    4318:	00 97       	sbiw	r24, 0x00	; 0
    431a:	79 f7       	brne	.-34     	; 0x42fa <__utoa_common+0x4>
    431c:	b1 11       	cpse	r27, r1
    431e:	b1 93       	st	Z+, r27
    4320:	11 92       	st	Z+, r1
    4322:	cb 01       	movw	r24, r22
    4324:	0c 94 94 21 	jmp	0x4328	; 0x4328 <strrev>

00004328 <strrev>:
    4328:	dc 01       	movw	r26, r24
    432a:	fc 01       	movw	r30, r24
    432c:	67 2f       	mov	r22, r23
    432e:	71 91       	ld	r23, Z+
    4330:	77 23       	and	r23, r23
    4332:	e1 f7       	brne	.-8      	; 0x432c <strrev+0x4>
    4334:	32 97       	sbiw	r30, 0x02	; 2
    4336:	04 c0       	rjmp	.+8      	; 0x4340 <strrev+0x18>
    4338:	7c 91       	ld	r23, X
    433a:	6d 93       	st	X+, r22
    433c:	70 83       	st	Z, r23
    433e:	62 91       	ld	r22, -Z
    4340:	ae 17       	cp	r26, r30
    4342:	bf 07       	cpc	r27, r31
    4344:	c8 f3       	brcs	.-14     	; 0x4338 <strrev+0x10>
    4346:	08 95       	ret

00004348 <_exit>:
    4348:	f8 94       	cli

0000434a <__stop_program>:
    434a:	ff cf       	rjmp	.-2      	; 0x434a <__stop_program>
