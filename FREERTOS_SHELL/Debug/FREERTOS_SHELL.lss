
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000455e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b0  00802000  0000455e  000045f2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  008020b0  008020b0  000046a2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000046a2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000046d4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006a0  00000000  00000000  00004714  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001235c  00000000  00000000  00004db4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000062f5  00000000  00000000  00017110  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005451  00000000  00000000  0001d405  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001244  00000000  00000000  00022858  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006188  00000000  00000000  00023a9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e25  00000000  00000000  00029c24  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000568  00000000  00000000  0002fa49  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 95 03 	jmp	0x72a	; 0x72a <__ctors_end>
       4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      10:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      14:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      18:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      1c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      20:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      24:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      28:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      2c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      30:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      34:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      38:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      3c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      40:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      44:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      48:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      4c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      50:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      54:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      58:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      5c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      60:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      64:	0c 94 83 1e 	jmp	0x3d06	; 0x3d06 <__vector_25>
      68:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      6c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      70:	0c 94 e1 1e 	jmp	0x3dc2	; 0x3dc2 <__vector_28>
      74:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      78:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      7c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      80:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      84:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      88:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      8c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      90:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      94:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      98:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      9c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c4:	0c 94 9d 0e 	jmp	0x1d3a	; 0x1d3a <__vector_49>
      c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e8:	0c 94 fb 1f 	jmp	0x3ff6	; 0x3ff6 <__vector_58>
      ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      fc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     100:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     104:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     108:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     10c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     110:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     114:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     118:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     11c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     120:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     124:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     128:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     12c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     130:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     134:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     138:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     13c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     140:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     144:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     148:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     14c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     150:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     154:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     158:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     15c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     160:	0c 94 3f 1f 	jmp	0x3e7e	; 0x3e7e <__vector_88>
     164:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     168:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     16c:	0c 94 9d 1f 	jmp	0x3f3a	; 0x3f3a <__vector_91>
     170:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     174:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     178:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     17c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     180:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     184:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     188:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     18c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     190:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     194:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     198:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     19c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1fc:	e4 0a       	sbc	r14, r20
     1fe:	5c 0b       	sbc	r21, r28
     200:	5c 0b       	sbc	r21, r28
     202:	5c 0b       	sbc	r21, r28
     204:	5c 0b       	sbc	r21, r28
     206:	5c 0b       	sbc	r21, r28
     208:	5c 0b       	sbc	r21, r28
     20a:	5c 0b       	sbc	r21, r28
     20c:	5c 0b       	sbc	r21, r28
     20e:	5c 0b       	sbc	r21, r28
     210:	5c 0b       	sbc	r21, r28
     212:	5c 0b       	sbc	r21, r28
     214:	5c 0b       	sbc	r21, r28
     216:	5c 0b       	sbc	r21, r28
     218:	5c 0b       	sbc	r21, r28
     21a:	5c 0b       	sbc	r21, r28
     21c:	5c 0b       	sbc	r21, r28
     21e:	5c 0b       	sbc	r21, r28
     220:	5c 0b       	sbc	r21, r28
     222:	5c 0b       	sbc	r21, r28
     224:	5c 0b       	sbc	r21, r28
     226:	5c 0b       	sbc	r21, r28
     228:	5c 0b       	sbc	r21, r28
     22a:	5c 0b       	sbc	r21, r28
     22c:	5c 0b       	sbc	r21, r28
     22e:	5c 0b       	sbc	r21, r28
     230:	5c 0b       	sbc	r21, r28
     232:	5c 0b       	sbc	r21, r28
     234:	5c 0b       	sbc	r21, r28
     236:	5c 0b       	sbc	r21, r28
     238:	5c 0b       	sbc	r21, r28
     23a:	5c 0b       	sbc	r21, r28
     23c:	5c 0b       	sbc	r21, r28
     23e:	5c 0b       	sbc	r21, r28
     240:	5c 0b       	sbc	r21, r28
     242:	5c 0b       	sbc	r21, r28
     244:	5c 0b       	sbc	r21, r28
     246:	5c 0b       	sbc	r21, r28
     248:	5c 0b       	sbc	r21, r28
     24a:	5c 0b       	sbc	r21, r28
     24c:	5c 0b       	sbc	r21, r28
     24e:	5c 0b       	sbc	r21, r28
     250:	5c 0b       	sbc	r21, r28
     252:	5c 0b       	sbc	r21, r28
     254:	5c 0b       	sbc	r21, r28
     256:	5c 0b       	sbc	r21, r28
     258:	5c 0b       	sbc	r21, r28
     25a:	5c 0b       	sbc	r21, r28
     25c:	5c 0b       	sbc	r21, r28
     25e:	5c 0b       	sbc	r21, r28
     260:	5c 0b       	sbc	r21, r28
     262:	5c 0b       	sbc	r21, r28
     264:	5c 0b       	sbc	r21, r28
     266:	5c 0b       	sbc	r21, r28
     268:	5c 0b       	sbc	r21, r28
     26a:	5c 0b       	sbc	r21, r28
     26c:	5c 0b       	sbc	r21, r28
     26e:	5c 0b       	sbc	r21, r28
     270:	5c 0b       	sbc	r21, r28
     272:	5c 0b       	sbc	r21, r28
     274:	5c 0b       	sbc	r21, r28
     276:	5c 0b       	sbc	r21, r28
     278:	5c 0b       	sbc	r21, r28
     27a:	5c 0b       	sbc	r21, r28
     27c:	5c 0b       	sbc	r21, r28
     27e:	5c 0b       	sbc	r21, r28
     280:	5c 0b       	sbc	r21, r28
     282:	5c 0b       	sbc	r21, r28
     284:	5c 0b       	sbc	r21, r28
     286:	5c 0b       	sbc	r21, r28
     288:	5c 0b       	sbc	r21, r28
     28a:	f8 0a       	sbc	r15, r24
     28c:	5c 0b       	sbc	r21, r28
     28e:	2a 0b       	sbc	r18, r26
     290:	e4 0a       	sbc	r14, r20
     292:	5c 0b       	sbc	r21, r28
     294:	12 0b       	sbc	r17, r18
     296:	e0 0a       	sbc	r14, r16
     298:	5c 0b       	sbc	r21, r28
     29a:	5c 0b       	sbc	r21, r28
     29c:	5c 0b       	sbc	r21, r28
     29e:	5c 0b       	sbc	r21, r28
     2a0:	5c 0b       	sbc	r21, r28
     2a2:	c6 0a       	sbc	r12, r22
     2a4:	5c 0b       	sbc	r21, r28
     2a6:	5c 0b       	sbc	r21, r28
     2a8:	5c 0b       	sbc	r21, r28
     2aa:	44 0b       	sbc	r20, r20
     2ac:	d8 0a       	sbc	r13, r24
     2ae:	5c 0b       	sbc	r21, r28
     2b0:	5c 0b       	sbc	r21, r28
     2b2:	d4 0a       	sbc	r13, r20
     2b4:	6f 1c       	adc	r6, r15
     2b6:	72 1c       	adc	r7, r2
     2b8:	75 1c       	adc	r7, r5
     2ba:	78 1c       	adc	r7, r8
     2bc:	7b 1c       	adc	r7, r11
     2be:	7e 1c       	adc	r7, r14
     2c0:	80 1c       	adc	r8, r0
     2c2:	91 1c       	adc	r9, r1
     2c4:	99 1c       	adc	r9, r9
     2c6:	a3 1c       	adc	r10, r3
     2c8:	a1 1c       	adc	r10, r1

000002ca <__trampolines_start>:
     2ca:	0c 94 19 1c 	jmp	0x3832	; 0x3832 <_ZN8emstream12transmit_nowEv>
     2ce:	0c 94 d8 0a 	jmp	0x15b0	; 0x15b0 <_ZN9task_user3runEv+0x170>
     2d2:	0c 94 20 0a 	jmp	0x1440	; 0x1440 <_ZN9task_user3runEv>
     2d6:	0c 94 92 03 	jmp	0x724	; 0x724 <_call_static_run_method>
     2da:	0c 94 12 0b 	jmp	0x1624	; 0x1624 <_ZN9task_user3runEv+0x1e4>
     2de:	0c 94 17 1c 	jmp	0x382e	; 0x382e <_ZN8emstream14check_for_charEv>
     2e2:	0c 94 d4 0a 	jmp	0x15a8	; 0x15a8 <_ZN9task_user3runEv+0x168>
     2e6:	0c 94 12 1c 	jmp	0x3824	; 0x3824 <_ZN8emstream13ready_to_sendEv>
     2ea:	0c 94 7e 1c 	jmp	0x38fc	; 0x38fc <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2ee:	0c 94 5c 0b 	jmp	0x16b8	; 0x16b8 <_ZN9task_user3runEv+0x278>
     2f2:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <_ZN8emstreamlsE15ser_manipulator+0x30>
     2f6:	0c 94 80 1c 	jmp	0x3900	; 0x3900 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2fa:	0c 94 19 05 	jmp	0xa32	; 0xa32 <_ZN5Motor3runEv>
     2fe:	0c 94 fd 20 	jmp	0x41fa	; 0x41fa <_GLOBAL__sub_I_counter>
     302:	0c 94 b4 04 	jmp	0x968	; 0x968 <_ZN13LimitSwitches3runEv>
     306:	0c 94 c3 19 	jmp	0x3386	; 0x3386 <_ZN14frt_text_queue7putcharEc>
     30a:	0c 94 21 11 	jmp	0x2242	; 0x2242 <prvIdleTask>
     30e:	0c 94 44 0b 	jmp	0x1688	; 0x1688 <_ZN9task_user3runEv+0x248>
     312:	0c 94 7b 1b 	jmp	0x36f6	; 0x36f6 <__cxa_pure_virtual>
     316:	0c 94 7b 1c 	jmp	0x38f6	; 0x38f6 <_ZN8emstreamlsE15ser_manipulator+0x36>
     31a:	0c 94 a3 1c 	jmp	0x3946	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
     31e:	0c 94 c1 1d 	jmp	0x3b82	; 0x3b82 <_ZN5rs2327getcharEv>
     322:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <_ZN15EncoderPendulum3runEv>
     326:	0c 94 f8 0a 	jmp	0x15f0	; 0x15f0 <_ZN9task_user3runEv+0x1b0>
     32a:	0c 94 6f 1c 	jmp	0x38de	; 0x38de <_ZN8emstreamlsE15ser_manipulator+0x1e>
     32e:	0c 94 50 18 	jmp	0x30a0	; 0x30a0 <_ZN8frt_task12print_statusER8emstream>
     332:	0c 94 a1 1c 	jmp	0x3942	; 0x3942 <_ZN8emstreamlsE15ser_manipulator+0x82>
     336:	0c 94 fa 1d 	jmp	0x3bf4	; 0x3bf4 <_ZN5rs23212clear_screenEv>
     33a:	0c 94 9a 19 	jmp	0x3334	; 0x3334 <_ZN14frt_text_queue7getcharEv>
     33e:	0c 94 99 1c 	jmp	0x3932	; 0x3932 <_ZN8emstreamlsE15ser_manipulator+0x72>
     342:	0c 94 b8 19 	jmp	0x3370	; 0x3370 <_ZN14frt_text_queue14check_for_charEv>
     346:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <_ZN9task_user3runEv+0x14c>
     34a:	0c 94 cd 03 	jmp	0x79a	; 0x79a <_ZN12EncoderMotor3runEv>
     34e:	0c 94 e7 1d 	jmp	0x3bce	; 0x3bce <_ZN5rs23214check_for_charEv>
     352:	0c 94 75 1c 	jmp	0x38ea	; 0x38ea <_ZN8emstreamlsE15ser_manipulator+0x2a>
     356:	0c 94 72 1c 	jmp	0x38e4	; 0x38e4 <_ZN8emstreamlsE15ser_manipulator+0x24>
     35a:	0c 94 14 1c 	jmp	0x3828	; 0x3828 <_ZN8emstream7getcharEv>
     35e:	0c 94 2a 0b 	jmp	0x1654	; 0x1654 <_ZN9task_user3runEv+0x214>
     362:	0c 94 e0 0a 	jmp	0x15c0	; 0x15c0 <_ZN9task_user3runEv+0x180>
     366:	0c 94 91 1c 	jmp	0x3922	; 0x3922 <_ZN8emstreamlsE15ser_manipulator+0x62>
     36a:	0c 94 e4 0a 	jmp	0x15c8	; 0x15c8 <_ZN9task_user3runEv+0x188>
     36e:	0c 94 9d 1d 	jmp	0x3b3a	; 0x3b3a <_ZN5rs2327putcharEc>
     372:	0c 94 1a 1c 	jmp	0x3834	; 0x3834 <_ZN8emstream12clear_screenEv>

00000376 <__trampolines_end>:
     376:	2c 20       	and	r2, r12
     378:	54 43       	sbci	r21, 0x34	; 52
     37a:	43 30       	cpi	r20, 0x03	; 3
     37c:	43 43       	sbci	r20, 0x33	; 51
     37e:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000381 <_ZZN9task_user11show_statusEvE3__c_3>:
     381:	2f 00                                               /.

00000383 <_ZZN9task_user11show_statusEvE3__c_2>:
     383:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000391 <_ZZN9task_user11show_statusEvE3__c_1>:
     391:	54 69 6d 65 3a 20 00                                Time: .

00000398 <_ZZN9task_user11show_statusEvE3__c_0>:
     398:	44 65 63 20 20 37 20 32 30 31 37 00                 Dec  7 2017.

000003a4 <_ZZN9task_user11show_statusEvE3__c>:
     3a4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3b4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003c3 <_ZZN9task_user18print_help_messageEvE3__c_14>:
     3c3:	20 20 20 20 72 3a 20 20 20 52 65 73 65 74 20 74         r:   Reset t
     3d3:	6f 20 49 64 6c 65 00                                o Idle.

000003da <_ZZN9task_user18print_help_messageEvE3__c_13>:
     3da:	20 20 20 20 64 3a 20 20 20 45 6d 65 72 67 65 6e         d:   Emergen
     3ea:	63 79 20 53 74 6f 70 00                             cy Stop.

000003f2 <_ZZN9task_user18print_help_messageEvE3__c_12>:
     3f2:	20 20 20 20 67 3a 20 20 20 53 77 69 6e 67 20 50         g:   Swing P
     402:	65 6e 64 75 6c 75 6d 20 55 70 72 69 67 68 74 2c     endulum Upright,
     412:	20 74 68 65 6e 20 47 6f 2e 00                        then Go..

0000041c <_ZZN9task_user18print_help_messageEvE3__c_11>:
     41c:	20 20 20 20 62 3a 20 20 20 42 65 67 69 6e 20 43         b:   Begin C
     42c:	61 6c 69 62 72 61 74 69 6f 6e 20 6f 66 20 49 6e     alibration of In
     43c:	76 65 72 74 65 64 20 50 65 6e 64 75 6c 75 6d 3f     verted Pendulum?
	...

0000044d <_ZZN9task_user18print_help_messageEvE3__c_10>:
     44d:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000045c <_ZZN9task_user18print_help_messageEvE3__c_9>:
     45c:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     46c:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000477 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     477:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     487:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000495 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     495:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     4a5:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     4b5:	6d 61 74 69 6f 6e 00                                mation.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_6>:
     4bc:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     4cc:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000004dd <_ZZN9task_user18print_help_messageEvE3__c_5>:
     4dd:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4ed:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004f5 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4f5:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     505:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000511 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     511:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     521:	68 65 20 41 56 52 00                                he AVR.

00000528 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     528:	20 68 65 6c 70 00                                    help.

0000052e <_ZZN9task_user18print_help_messageEvE3__c_1>:
     52e:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     53e:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000054d <_ZZN9task_user18print_help_messageEvE3__c_0>:
     54d:	1b 5b 33 30 6d 00                                   .[30m.

00000553 <_ZZN9task_user18print_help_messageEvE3__c>:
     553:	1b 5b 34 36 6d 00                                   .[46m.

00000559 <_ZZN9task_user3runEvE3__c_7>:
     559:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     569:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000576 <_ZZN9task_user3runEvE3__c_6>:
     576:	3a 57 54 46 3f 00                                   :WTF?.

0000057c <_ZZN9task_user3runEvE3__c_5>:
     57c:	52 65 73 65 74 2c 20 74 72 79 20 48 6f 6d 69 6e     Reset, try Homin
     58c:	67 20 61 67 61 69 6e 20 62 79 20 70 72 65 73 73     g again by press
     59c:	69 6e 67 20 27 62 27 00                             ing 'b'.

000005a4 <_ZZN9task_user3runEvE3__c_4>:
     5a4:	45 4d 45 52 47 45 4e 43 59 20 53 54 4f 50 00        EMERGENCY STOP.

000005b3 <_ZZN9task_user3runEvE3__c_3>:
     5b3:	43 6f 6d 6d 65 6e 63 65 20 42 61 6c 61 6e 63 65     Commence Balance
	...

000005c4 <_ZZN9task_user3runEvE3__c_2>:
     5c4:	42 65 67 69 6e 20 48 6f 6d 69 6e 67 00              Begin Homing.

000005d1 <_ZZN9task_user3runEvE3__c_1>:
     5d1:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     5e1:	65 00                                               e.

000005e3 <_ZZN9task_user3runEvE3__c_0>:
     5e3:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000005f1 <_ZZN9task_user3runEvE3__c>:
     5f1:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 74 6f 20     Press Ctrl-A to 
     601:	67 65 74 20 74 6f 20 63 6f 6d 6d 61 6e 64 20 6d     get to command m
     611:	6f 64 65 20 66 6f 72 20 49 6e 76 65 72 74 65 64     ode for Inverted
     621:	20 50 65 6e 64 75 6c 75 6d 00                        Pendulum.

0000062b <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     62b:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000635 <_ZZN8frt_task15emergency_resetEvE3__c>:
     635:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000644 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     644:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     654:	61 73 6b 20 00                                      ask .

00000659 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     659:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000667 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     667:	20 63 72 65 61 74 65 64 00                           created.

00000670 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     670:	54 61 73 6b 20 00                                   Task .

00000676 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     676:	1b 5b 32 32 6d 00                                   .[22m.

0000067c <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     67c:	54 61 73 6b 3a 20 00                                Task: .

00000683 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     683:	1b 5b 31 6d 00                                      .[1m.

00000688 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     688:	1b 5b 32 32 6d 00                                   .[22m.

0000068e <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     68e:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000699 <_ZZ17print_task_stacksP8emstreamE3__c>:
     699:	1b 5b 31 6d 00                                      .[1m.

0000069e <_ZZ15print_task_listP8emstreamE3__c_9>:
     69e:	09 09 00                                            ...

000006a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     6a1:	2f 00                                               /.

000006a3 <_ZZ15print_task_listP8emstreamE3__c_7>:
     6a3:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000006ae <_ZZ15print_task_listP8emstreamE3__c_6>:
     6ae:	09 2d 2d 2d 2d 00                                   .----.

000006b4 <_ZZ15print_task_listP8emstreamE3__c_5>:
     6b4:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000006c0 <_ZZ15print_task_listP8emstreamE3__c_4>:
     6c0:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000006d1 <_ZZ15print_task_listP8emstreamE3__c_3>:
     6d1:	09 52 75 6e 73 00                                   .Runs.

000006d7 <_ZZ15print_task_listP8emstreamE3__c_2>:
     6d7:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000006e3 <_ZZ15print_task_listP8emstreamE3__c_1>:
     6e3:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000006f4 <_ZZ15print_task_listP8emstreamE3__c_0>:
     6f4:	09 53 74 61 63 6b 00                                .Stack.

000006fb <_ZZ15print_task_listP8emstreamE3__c>:
     6fb:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000706 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     706:	09 00                                               ..

00000708 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     708:	09 00                                               ..

0000070a <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     70a:	2f 00                                               /.

0000070c <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     70c:	09 00                                               ..

0000070e <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     70e:	09 00                                               ..

00000710 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     710:	1b 5b 32 32 6d 00                                   .[22m.

00000716 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     716:	1b 5b 31 6d 00                                      .[1m.

0000071b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     71b:	1b 5b 31 6d 00                                      .[1m.

00000720 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     720:	20 20 00 00                                           ..

00000724 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     724:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <_ZN8frt_task22_call_users_run_methodEPS_>

00000728 <__ctors_start>:
     728:	fd 20       	and	r15, r13

0000072a <__ctors_end>:
     72a:	11 24       	eor	r1, r1
     72c:	1f be       	out	0x3f, r1	; 63
     72e:	cf ef       	ldi	r28, 0xFF	; 255
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df e3       	ldi	r29, 0x3F	; 63
     734:	de bf       	out	0x3e, r29	; 62
     736:	00 e0       	ldi	r16, 0x00	; 0
     738:	0c bf       	out	0x3c, r16	; 60
     73a:	18 be       	out	0x38, r1	; 56
     73c:	19 be       	out	0x39, r1	; 57
     73e:	1a be       	out	0x3a, r1	; 58
     740:	1b be       	out	0x3b, r1	; 59

00000742 <__do_copy_data>:
     742:	10 e2       	ldi	r17, 0x20	; 32
     744:	a0 e0       	ldi	r26, 0x00	; 0
     746:	b0 e2       	ldi	r27, 0x20	; 32
     748:	ee e5       	ldi	r30, 0x5E	; 94
     74a:	f5 e4       	ldi	r31, 0x45	; 69
     74c:	00 e0       	ldi	r16, 0x00	; 0
     74e:	0b bf       	out	0x3b, r16	; 59
     750:	02 c0       	rjmp	.+4      	; 0x756 <__do_copy_data+0x14>
     752:	07 90       	elpm	r0, Z+
     754:	0d 92       	st	X+, r0
     756:	a0 3b       	cpi	r26, 0xB0	; 176
     758:	b1 07       	cpc	r27, r17
     75a:	d9 f7       	brne	.-10     	; 0x752 <__do_copy_data+0x10>
     75c:	1b be       	out	0x3b, r1	; 59

0000075e <__do_clear_bss>:
     75e:	21 e3       	ldi	r18, 0x31	; 49
     760:	a0 eb       	ldi	r26, 0xB0	; 176
     762:	b0 e2       	ldi	r27, 0x20	; 32
     764:	01 c0       	rjmp	.+2      	; 0x768 <.do_clear_bss_start>

00000766 <.do_clear_bss_loop>:
     766:	1d 92       	st	X+, r1

00000768 <.do_clear_bss_start>:
     768:	aa 35       	cpi	r26, 0x5A	; 90
     76a:	b2 07       	cpc	r27, r18
     76c:	e1 f7       	brne	.-8      	; 0x766 <.do_clear_bss_loop>

0000076e <__do_global_ctors>:
     76e:	13 e0       	ldi	r17, 0x03	; 3
     770:	c5 e9       	ldi	r28, 0x95	; 149
     772:	d3 e0       	ldi	r29, 0x03	; 3
     774:	00 e0       	ldi	r16, 0x00	; 0
     776:	06 c0       	rjmp	.+12     	; 0x784 <__do_global_ctors+0x16>
     778:	21 97       	sbiw	r28, 0x01	; 1
     77a:	01 09       	sbc	r16, r1
     77c:	80 2f       	mov	r24, r16
     77e:	fe 01       	movw	r30, r28
     780:	0e 94 de 21 	call	0x43bc	; 0x43bc <__tablejump2__>
     784:	c4 39       	cpi	r28, 0x94	; 148
     786:	d1 07       	cpc	r29, r17
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	08 07       	cpc	r16, r24
     78c:	a9 f7       	brne	.-22     	; 0x778 <__do_global_ctors+0xa>
     78e:	0e 94 6e 20 	call	0x40dc	; 0x40dc <main>
     792:	0c 94 ad 22 	jmp	0x455a	; 0x455a <_exit>

00000796 <__bad_interrupt>:
     796:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000079a <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <_ZN12EncoderMotor3runEv+0x6>
     7a0:	1f 92       	push	r1
     7a2:	cd b7       	in	r28, 0x3d	; 61
     7a4:	de b7       	in	r29, 0x3e	; 62
     7a6:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7a8:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskGetTickCount>
     7ac:	69 83       	std	Y+1, r22	; 0x01
     7ae:	7a 83       	std	Y+2, r23	; 0x02
     7b0:	8b 83       	std	Y+3, r24	; 0x03
     7b2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     7b4:	e0 e8       	ldi	r30, 0x80	; 128
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	8c e0       	ldi	r24, 0x0C	; 12
     7ba:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     7bc:	82 89       	ldd	r24, Z+18	; 0x12
     7be:	83 60       	ori	r24, 0x03	; 3
     7c0:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     7c2:	83 89       	ldd	r24, Z+19	; 0x13
     7c4:	83 60       	ori	r24, 0x03	; 3
     7c6:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     7c8:	e0 e8       	ldi	r30, 0x80	; 128
     7ca:	f1 e0       	ldi	r31, 0x01	; 1
     7cc:	82 e7       	ldi	r24, 0x72	; 114
     7ce:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     7d0:	89 e0       	ldi	r24, 0x09	; 9
     7d2:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     7d4:	e0 e0       	ldi	r30, 0x00	; 0
     7d6:	f9 e0       	ldi	r31, 0x09	; 9
     7d8:	88 e6       	ldi	r24, 0x68	; 104
     7da:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	9f ef       	ldi	r25, 0xFF	; 255
     7e0:	86 a3       	std	Z+38, r24	; 0x26
     7e2:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     7e8:	0f 2e       	mov	r0, r31
     7ea:	a1 2c       	mov	r10, r1
     7ec:	f9 e0       	ldi	r31, 0x09	; 9
     7ee:	bf 2e       	mov	r11, r31
     7f0:	f0 2d       	mov	r31, r0
     7f2:	f5 01       	movw	r30, r10
     7f4:	00 a1       	ldd	r16, Z+32	; 0x20
     7f6:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     7f8:	0f b6       	in	r0, 0x3f	; 63
     7fa:	f8 94       	cli
     7fc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	0f 92       	push	r0
			the_data = new_data;
     808:	c8 01       	movw	r24, r16
     80a:	01 2e       	mov	r0, r17
     80c:	00 0c       	add	r0, r0
     80e:	aa 0b       	sbc	r26, r26
     810:	bb 0b       	sbc	r27, r27
     812:	ac 01       	movw	r20, r24
     814:	bd 01       	movw	r22, r26
     816:	44 0f       	add	r20, r20
     818:	55 1f       	adc	r21, r21
     81a:	66 1f       	adc	r22, r22
     81c:	77 1f       	adc	r23, r23
     81e:	3a 01       	movw	r6, r20
     820:	4b 01       	movw	r8, r22
     822:	68 0e       	add	r6, r24
     824:	79 1e       	adc	r7, r25
     826:	8a 1e       	adc	r8, r26
     828:	9b 1e       	adc	r9, r27
     82a:	c4 01       	movw	r24, r8
     82c:	b3 01       	movw	r22, r6
     82e:	24 e6       	ldi	r18, 0x64	; 100
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	0e 94 bf 21 	call	0x437e	; 0x437e <__divmodsi4>
     83a:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <linear_offset>
     83e:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <linear_offset+0x1>
     842:	28 1b       	sub	r18, r24
     844:	39 0b       	sbc	r19, r25
     846:	20 93 46 31 	sts	0x3146, r18	; 0x803146 <linear_position>
     84a:	30 93 47 31 	sts	0x3147, r19	; 0x803147 <linear_position+0x1>
			portEXIT_CRITICAL ();
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
			the_data = new_data;
     858:	c8 01       	movw	r24, r16
     85a:	8c 19       	sub	r24, r12
     85c:	9d 09       	sbc	r25, r13
     85e:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <thdMotor>
     862:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     86a:	f7 01       	movw	r30, r14
     86c:	86 85       	ldd	r24, Z+14	; 0x0e
     86e:	97 85       	ldd	r25, Z+15	; 0x0f
     870:	a0 89       	ldd	r26, Z+16	; 0x10
     872:	b1 89       	ldd	r27, Z+17	; 0x11
     874:	01 96       	adiw	r24, 0x01	; 1
     876:	a1 1d       	adc	r26, r1
     878:	b1 1d       	adc	r27, r1
     87a:	86 87       	std	Z+14, r24	; 0x0e
     87c:	97 87       	std	Z+15, r25	; 0x0f
     87e:	a0 8b       	std	Z+16, r26	; 0x10
     880:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     882:	41 e0       	ldi	r20, 0x01	; 1
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	ce 01       	movw	r24, r28
     88c:	01 96       	adiw	r24, 0x01	; 1
     88e:	0e 94 5e 14 	call	0x28bc	; 0x28bc <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     892:	68 01       	movw	r12, r16
     894:	ae cf       	rjmp	.-164    	; 0x7f2 <_ZN12EncoderMotor3runEv+0x58>

00000896 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a0:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <_ZN8frt_taskC1EPKchjP8emstream>
     8a4:	8a e0       	ldi	r24, 0x0A	; 10
     8a6:	90 e2       	ldi	r25, 0x20	; 32
     8a8:	88 83       	st	Y, r24
     8aa:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN15EncoderPendulum3runEv+0x6>
     8bc:	1f 92       	push	r1
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskGetTickCount>
     8c8:	69 83       	std	Y+1, r22	; 0x01
     8ca:	7a 83       	std	Y+2, r23	; 0x02
     8cc:	8b 83       	std	Y+3, r24	; 0x03
     8ce:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     8d0:	e0 e8       	ldi	r30, 0x80	; 128
     8d2:	f6 e0       	ldi	r31, 0x06	; 6
     8d4:	83 e0       	ldi	r24, 0x03	; 3
     8d6:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     8d8:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     8da:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     8dc:	e0 e8       	ldi	r30, 0x80	; 128
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	80 e7       	ldi	r24, 0x70	; 112
     8e2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     8e4:	89 e0       	ldi	r24, 0x09	; 9
     8e6:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     8e8:	e0 e4       	ldi	r30, 0x40	; 64
     8ea:	f8 e0       	ldi	r31, 0x08	; 8
     8ec:	8a e6       	ldi	r24, 0x6A	; 106
     8ee:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     8f0:	80 ea       	ldi	r24, 0xA0	; 160
     8f2:	95 e0       	ldi	r25, 0x05	; 5
     8f4:	86 a3       	std	Z+38, r24	; 0x26
     8f6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     8fc:	68 94       	set
     8fe:	ee 24       	eor	r14, r14
     900:	e6 f8       	bld	r14, 6
     902:	ff 24       	eor	r15, r15
     904:	f3 f8       	bld	r15, 3
     906:	f7 01       	movw	r30, r14
     908:	80 a1       	ldd	r24, Z+32	; 0x20
     90a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
			the_data = new_data;
     912:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <thPendulum>
     916:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     91a:	0f 90       	pop	r0
     91c:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     91e:	f8 01       	movw	r30, r16
     920:	86 85       	ldd	r24, Z+14	; 0x0e
     922:	97 85       	ldd	r25, Z+15	; 0x0f
     924:	a0 89       	ldd	r26, Z+16	; 0x10
     926:	b1 89       	ldd	r27, Z+17	; 0x11
     928:	01 96       	adiw	r24, 0x01	; 1
     92a:	a1 1d       	adc	r26, r1
     92c:	b1 1d       	adc	r27, r1
     92e:	86 87       	std	Z+14, r24	; 0x0e
     930:	97 87       	std	Z+15, r25	; 0x0f
     932:	a0 8b       	std	Z+16, r26	; 0x10
     934:	b1 8b       	std	Z+17, r27	; 0x11
     936:	41 e0       	ldi	r20, 0x01	; 1
     938:	50 e0       	ldi	r21, 0x00	; 0
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	70 e0       	ldi	r23, 0x00	; 0
     93e:	ce 01       	movw	r24, r28
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	0e 94 5e 14 	call	0x28bc	; 0x28bc <vTaskDelayUntil>
     946:	df cf       	rjmp	.-66     	; 0x906 <_ZN15EncoderPendulum3runEv+0x50>

00000948 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     952:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <_ZN8frt_taskC1EPKchjP8emstream>
     956:	82 e1       	ldi	r24, 0x12	; 18
     958:	90 e2       	ldi	r25, 0x20	; 32
     95a:	88 83       	st	Y, r24
     95c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	08 95       	ret

00000968 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	00 d0       	rcall	.+0      	; 0x96e <_ZN13LimitSwitches3runEv+0x6>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     976:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskGetTickCount>
     97a:	69 83       	std	Y+1, r22	; 0x01
     97c:	7a 83       	std	Y+2, r23	; 0x02
     97e:	8b 83       	std	Y+3, r24	; 0x03
     980:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     982:	e0 e6       	ldi	r30, 0x60	; 96
     984:	f6 e0       	ldi	r31, 0x06	; 6
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     98a:	84 e0       	ldi	r24, 0x04	; 4
     98c:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     98e:	88 e1       	ldi	r24, 0x18	; 24
     990:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     992:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     994:	08 e6       	ldi	r16, 0x68	; 104
     996:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     998:	dd 24       	eor	r13, r13
     99a:	d3 94       	inc	r13
     99c:	f8 01       	movw	r30, r16
     99e:	80 81       	ld	r24, Z
     9a0:	80 fd       	sbrc	r24, 0
     9a2:	08 c0       	rjmp	.+16     	; 0x9b4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
			the_data = new_data;
     9aa:	d0 92 41 31 	sts	0x3141, r13	; 0x803141 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9ae:	0f 90       	pop	r0
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	07 c0       	rjmp	.+14     	; 0x9c2 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	0f 92       	push	r0
			the_data = new_data;
     9ba:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     9c2:	f8 01       	movw	r30, r16
     9c4:	80 81       	ld	r24, Z
     9c6:	82 fd       	sbrc	r24, 2
     9c8:	08 c0       	rjmp	.+16     	; 0x9da <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
			the_data = new_data;
     9d0:	d0 92 40 31 	sts	0x3140, r13	; 0x803140 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	f8 94       	cli
     9de:	0f 92       	push	r0
			the_data = new_data;
     9e0:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     9e8:	f7 01       	movw	r30, r14
     9ea:	86 85       	ldd	r24, Z+14	; 0x0e
     9ec:	97 85       	ldd	r25, Z+15	; 0x0f
     9ee:	a0 89       	ldd	r26, Z+16	; 0x10
     9f0:	b1 89       	ldd	r27, Z+17	; 0x11
     9f2:	01 96       	adiw	r24, 0x01	; 1
     9f4:	a1 1d       	adc	r26, r1
     9f6:	b1 1d       	adc	r27, r1
     9f8:	86 87       	std	Z+14, r24	; 0x0e
     9fa:	97 87       	std	Z+15, r25	; 0x0f
     9fc:	a0 8b       	std	Z+16, r26	; 0x10
     9fe:	b1 8b       	std	Z+17, r27	; 0x11
     a00:	41 e0       	ldi	r20, 0x01	; 1
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	01 96       	adiw	r24, 0x01	; 1
     a0c:	0e 94 5e 14 	call	0x28bc	; 0x28bc <vTaskDelayUntil>
     a10:	c5 cf       	rjmp	.-118    	; 0x99c <_ZN13LimitSwitches3runEv+0x34>

00000a12 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a1c:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <_ZN8frt_taskC1EPKchjP8emstream>
     a20:	8a e1       	ldi	r24, 0x1A	; 26
     a22:	90 e2       	ldi	r25, 0x20	; 32
     a24:	88 83       	st	Y, r24
     a26:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	08 95       	ret

00000a32 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	6a 97       	sbiw	r28, 0x1a	; 26
     a3c:	cd bf       	out	0x3d, r28	; 61
     a3e:	de bf       	out	0x3e, r29	; 62
     a40:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     a42:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskGetTickCount>
     a46:	69 83       	std	Y+1, r22	; 0x01
     a48:	7a 83       	std	Y+2, r23	; 0x02
     a4a:	8b 83       	std	Y+3, r24	; 0x03
     a4c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     a4e:	f8 01       	movw	r30, r16
     a50:	fe 96       	adiw	r30, 0x3e	; 62
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	a0 e0       	ldi	r26, 0x00	; 0
     a58:	b0 e0       	ldi	r27, 0x00	; 0
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
     a5e:	a2 83       	std	Z+2, r26	; 0x02
     a60:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     a62:	d8 01       	movw	r26, r16
     a64:	dc 96       	adiw	r26, 0x3c	; 60
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     a6c:	a0 e4       	ldi	r26, 0x40	; 64
     a6e:	b6 e0       	ldi	r27, 0x06	; 6
     a70:	87 e0       	ldi	r24, 0x07	; 7
     a72:	11 96       	adiw	r26, 0x01	; 1
     a74:	8c 93       	st	X, r24
     a76:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     a78:	84 e0       	ldi	r24, 0x04	; 4
     a7a:	15 96       	adiw	r26, 0x05	; 5
     a7c:	8c 93       	st	X, r24
     a7e:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     a80:	e0 e0       	ldi	r30, 0x00	; 0
     a82:	f8 e0       	ldi	r31, 0x08	; 8
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     a88:	83 e0       	ldi	r24, 0x03	; 3
     a8a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     a8c:	a6 a3       	std	Z+38, r26	; 0x26
     a8e:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     a90:	10 a6       	std	Z+40, r1	; 0x28
     a92:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     a94:	12 a6       	std	Z+42, r1	; 0x2a
     a96:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     a98:	81 81       	ldd	r24, Z+1	; 0x01
     a9a:	80 63       	ori	r24, 0x30	; 48
     a9c:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	0f 92       	push	r0
			the_data = new_data;
     aa4:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <linear_offset>
     aa8:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <linear_offset+0x1>
			portEXIT_CRITICAL ();
     aac:	0f 90       	pop	r0
     aae:	0f be       	out	0x3f, r0	; 63
	linear_offset.put(0);								// Initialize motor offset	
	int16_t left_home;									// Initialize left distance to calculate center
	int16_t position_set;								// Setpoint of cart's position
	int16_t KP_pos = 100;								// P gain for cart position				
	int16_t position_error = 0;							// positional error	
	int16_t position_midpoint = 0;						// midpoint calculated from homing sequence
     ab0:	1f 8a       	std	Y+23, r1	; 0x17
     ab2:	18 8e       	std	Y+24, r1	; 0x18
				omegam_set = -10;	// [ticks/ms]
			
				if (leftLimitSwitch.get())
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     ab4:	58 01       	movw	r10, r16
     ab6:	b0 e5       	ldi	r27, 0x50	; 80
     ab8:	ab 0e       	add	r10, r27
     aba:	b1 1c       	adc	r11, r1
					output_correct = 0;
     abc:	68 01       	movw	r12, r16
     abe:	ee e5       	ldi	r30, 0x5E	; 94
     ac0:	ce 0e       	add	r12, r30
     ac2:	d1 1c       	adc	r13, r1
			// Home right
			case(0) :
				if (begin.get())											// If user begins Calibration Sequence
				{
					reset.put(0);											// turn off flag
					omegam_set = 10;	// [ticks/ms]
     ac4:	0f 2e       	mov	r0, r31
     ac6:	fa e0       	ldi	r31, 0x0A	; 10
     ac8:	2f 2e       	mov	r2, r31
     aca:	31 2c       	mov	r3, r1
     acc:	f0 2d       	mov	r31, r0
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     ace:	98 01       	movw	r18, r16
     ad0:	28 5b       	subi	r18, 0xB8	; 184
     ad2:	3f 4f       	sbci	r19, 0xFF	; 255
     ad4:	2f 87       	std	Y+15, r18	; 0x0f
     ad6:	38 8b       	std	Y+16, r19	; 0x10
		_Ki = .7*256;
     ad8:	c8 01       	movw	r24, r16
     ada:	84 5b       	subi	r24, 0xB4	; 180
     adc:	9f 4f       	sbci	r25, 0xFF	; 255
     ade:	8d 83       	std	Y+5, r24	; 0x05
     ae0:	9e 83       	std	Y+6, r25	; 0x06
		_Kd = 0;
     ae2:	d8 01       	movw	r26, r16
     ae4:	a6 5b       	subi	r26, 0xB6	; 182
     ae6:	bf 4f       	sbci	r27, 0xFF	; 255
     ae8:	a9 8b       	std	Y+17, r26	; 0x11
     aea:	ba 8b       	std	Y+18, r27	; 0x12
		antiwind_gain = .75*256;
     aec:	f8 01       	movw	r30, r16
     aee:	ec 59       	subi	r30, 0x9C	; 156
     af0:	ff 4f       	sbci	r31, 0xFF	; 255
     af2:	ef 83       	std	Y+7, r30	; 0x07
     af4:	f8 87       	std	Y+8, r31	; 0x08
		
		_max = 1600;
     af6:	24 50       	subi	r18, 0x04	; 4
     af8:	31 09       	sbc	r19, r1
     afa:	29 87       	std	Y+9, r18	; 0x09
     afc:	3a 87       	std	Y+10, r19	; 0x0a
		_min = -1600;
     afe:	06 97       	sbiw	r24, 0x06	; 6
     b00:	8d 87       	std	Y+13, r24	; 0x0d
     b02:	9e 87       	std	Y+14, r25	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     b04:	52 96       	adiw	r26, 0x12	; 18
     b06:	ab 8b       	std	Y+19, r26	; 0x13
     b08:	bc 8b       	std	Y+20, r27	; 0x14

		// Integral term
		error_int = error - antiwind_correct;
     b0a:	48 01       	movw	r8, r16
     b0c:	b6 e6       	ldi	r27, 0x66	; 102
     b0e:	8b 0e       	add	r8, r27
     b10:	91 1c       	adc	r9, r1
     b12:	34 96       	adiw	r30, 0x04	; 4
     b14:	ed 8b       	std	Y+21, r30	; 0x15
     b16:	fe 8b       	std	Y+22, r31	; 0x16
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     b18:	26 50       	subi	r18, 0x06	; 6
     b1a:	31 09       	sbc	r19, r1
     b1c:	2b 87       	std	Y+11, r18	; 0x0b
     b1e:	3c 87       	std	Y+12, r19	; 0x0c
	int16_t KP_angle = -1000;
	int16_t angle_set = 720;							// vertical setpoint for pendulum
	
	while(1){
		// Increment counter for debugging
		runs++;
     b20:	f8 01       	movw	r30, r16
     b22:	86 85       	ldd	r24, Z+14	; 0x0e
     b24:	97 85       	ldd	r25, Z+15	; 0x0f
     b26:	a0 89       	ldd	r26, Z+16	; 0x10
     b28:	b1 89       	ldd	r27, Z+17	; 0x11
     b2a:	01 96       	adiw	r24, 0x01	; 1
     b2c:	a1 1d       	adc	r26, r1
     b2e:	b1 1d       	adc	r27, r1
     b30:	86 87       	std	Z+14, r24	; 0x0e
     b32:	97 87       	std	Z+15, r25	; 0x0f
     b34:	a0 8b       	std	Z+16, r26	; 0x10
     b36:	b1 8b       	std	Z+17, r27	; 0x11
		
		switch (state)
     b38:	84 85       	ldd	r24, Z+12	; 0x0c
     b3a:	81 30       	cpi	r24, 0x01	; 1
     b3c:	09 f4       	brne	.+2      	; 0xb40 <_ZN5Motor3runEv+0x10e>
     b3e:	44 c0       	rjmp	.+136    	; 0xbc8 <_ZN5Motor3runEv+0x196>
     b40:	38 f0       	brcs	.+14     	; 0xb50 <_ZN5Motor3runEv+0x11e>
     b42:	82 30       	cpi	r24, 0x02	; 2
     b44:	09 f4       	brne	.+2      	; 0xb48 <_ZN5Motor3runEv+0x116>
     b46:	7c c0       	rjmp	.+248    	; 0xc40 <_ZN5Motor3runEv+0x20e>
     b48:	83 30       	cpi	r24, 0x03	; 3
     b4a:	09 f4       	brne	.+2      	; 0xb4e <_ZN5Motor3runEv+0x11c>
     b4c:	c0 c0       	rjmp	.+384    	; 0xcce <_ZN5Motor3runEv+0x29c>
     b4e:	1b c1       	rjmp	.+566    	; 0xd86 <_ZN5Motor3runEv+0x354>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b56:	0f 90       	pop	r0
     b58:	0f be       	out	0x3f, r0	; 63
		{
			// Home right
			case(0) :
				if (begin.get())											// If user begins Calibration Sequence
     b5a:	80 91 3d 31 	lds	r24, 0x313D	; 0x80313d <begin>
     b5e:	88 23       	and	r24, r24
     b60:	09 f4       	brne	.+2      	; 0xb64 <_ZN5Motor3runEv+0x132>
     b62:	17 c1       	rjmp	.+558    	; 0xd92 <_ZN5Motor3runEv+0x360>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b64:	0f b6       	in	r0, 0x3f	; 63
     b66:	f8 94       	cli
     b68:	0f 92       	push	r0
			the_data = new_data;
     b6a:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <reset>
			portEXIT_CRITICAL ();
     b6e:	0f 90       	pop	r0
     b70:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);											// turn off flag
					omegam_set = 10;	// [ticks/ms]
     b72:	22 8e       	std	Z+26, r2	; 0x1a
     b74:	33 8e       	std	Z+27, r3	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b76:	0f b6       	in	r0, 0x3f	; 63
     b78:	f8 94       	cli
     b7a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b7c:	0f 90       	pop	r0
     b7e:	0f be       	out	0x3f, r0	; 63

					if (rightLimitSwitch.get())
     b80:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rightLimitSwitch>
     b84:	88 23       	and	r24, r24
     b86:	09 f4       	brne	.+2      	; 0xb8a <_ZN5Motor3runEv+0x158>
     b88:	04 c1       	rjmp	.+520    	; 0xd92 <_ZN5Motor3runEv+0x360>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b8a:	0f b6       	in	r0, 0x3f	; 63
     b8c:	f8 94       	cli
     b8e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b90:	0f 90       	pop	r0
     b92:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b94:	0f b6       	in	r0, 0x3f	; 63
     b96:	f8 94       	cli
     b98:	0f 92       	push	r0
			the_data = new_data;
     b9a:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <linear_position>
     b9e:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <linear_position+0x1>
     ba2:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <linear_offset>
     ba6:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <linear_offset+0x1>
			portEXIT_CRITICAL ();
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
     bae:	f5 01       	movw	r30, r10
     bb0:	10 82       	st	Z, r1
     bb2:	11 82       	std	Z+1, r1	; 0x01
     bb4:	12 82       	std	Z+2, r1	; 0x02
     bb6:	13 82       	std	Z+3, r1	; 0x03
						output_correct = 0;
     bb8:	d6 01       	movw	r26, r12
     bba:	1d 92       	st	X+, r1
     bbc:	1c 92       	st	X, r1
						transition_to(1);									// if right Limit Switch is triggered 
     bbe:	61 e0       	ldi	r22, 0x01	; 1
     bc0:	c8 01       	movw	r24, r16
     bc2:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN8frt_task13transition_toEh>
     bc6:	e5 c0       	rjmp	.+458    	; 0xd92 <_ZN5Motor3runEv+0x360>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bc8:	0f b6       	in	r0, 0x3f	; 63
     bca:	f8 94       	cli
     bcc:	0f 92       	push	r0
			the_data = new_data;
     bce:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <begin>
			portEXIT_CRITICAL ();
     bd2:	0f 90       	pop	r0
     bd4:	0f be       	out	0x3f, r0	; 63
				break;
				
			// Home left
			case(1) :
				begin.put(0);		// turn off flag
				omegam_set = -10;	// [ticks/ms]
     bd6:	86 ef       	ldi	r24, 0xF6	; 246
     bd8:	9f ef       	ldi	r25, 0xFF	; 255
     bda:	f8 01       	movw	r30, r16
     bdc:	82 8f       	std	Z+26, r24	; 0x1a
     bde:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     be0:	0f b6       	in	r0, 0x3f	; 63
     be2:	f8 94       	cli
     be4:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     be6:	0f 90       	pop	r0
     be8:	0f be       	out	0x3f, r0	; 63
			
				if (leftLimitSwitch.get())
     bea:	80 91 41 31 	lds	r24, 0x3141	; 0x803141 <leftLimitSwitch>
     bee:	88 23       	and	r24, r24
     bf0:	c1 f0       	breq	.+48     	; 0xc22 <_ZN5Motor3runEv+0x1f0>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bf2:	0f b6       	in	r0, 0x3f	; 63
     bf4:	f8 94       	cli
     bf6:	0f 92       	push	r0
			temporary_copy = the_data;
     bf8:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <linear_position>
     bfc:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <linear_position+0x1>
     c00:	29 8f       	std	Y+25, r18	; 0x19
     c02:	3a 8f       	std	Y+26, r19	; 0x1a
			portEXIT_CRITICAL ();
     c04:	0f 90       	pop	r0
     c06:	0f be       	out	0x3f, r0	; 63
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     c08:	d5 01       	movw	r26, r10
     c0a:	1d 92       	st	X+, r1
     c0c:	1d 92       	st	X+, r1
     c0e:	1d 92       	st	X+, r1
     c10:	1c 92       	st	X, r1
     c12:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     c14:	f6 01       	movw	r30, r12
     c16:	10 82       	st	Z, r1
     c18:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     c1a:	62 e0       	ldi	r22, 0x02	; 2
     c1c:	c8 01       	movw	r24, r16
     c1e:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c22:	0f b6       	in	r0, 0x3f	; 63
     c24:	f8 94       	cli
     c26:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c28:	0f 90       	pop	r0
     c2a:	0f be       	out	0x3f, r0	; 63
				}
						
				if (reset.get() == 1)
     c2c:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <reset>
     c30:	88 23       	and	r24, r24
     c32:	09 f4       	brne	.+2      	; 0xc36 <_ZN5Motor3runEv+0x204>
     c34:	ae c0       	rjmp	.+348    	; 0xd92 <_ZN5Motor3runEv+0x360>
				{
					transition_to(0);
     c36:	60 e0       	ldi	r22, 0x00	; 0
     c38:	c8 01       	movw	r24, r16
     c3a:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN8frt_task13transition_toEh>
     c3e:	a9 c0       	rjmp	.+338    	; 0xd92 <_ZN5Motor3runEv+0x360>
							
				break;
			
			// Center Cart - Position Loop included
			case(2) :
				position_midpoint = left_home/2;
     c40:	89 8d       	ldd	r24, Y+25	; 0x19
     c42:	9a 8d       	ldd	r25, Y+26	; 0x1a
     c44:	99 23       	and	r25, r25
     c46:	0c f4       	brge	.+2      	; 0xc4a <_ZN5Motor3runEv+0x218>
     c48:	01 96       	adiw	r24, 0x01	; 1
     c4a:	9c 01       	movw	r18, r24
     c4c:	35 95       	asr	r19
     c4e:	27 95       	ror	r18
     c50:	2f 8b       	std	Y+23, r18	; 0x17
     c52:	38 8f       	std	Y+24, r19	; 0x18
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c54:	0f b6       	in	r0, 0x3f	; 63
     c56:	f8 94       	cli
     c58:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c5a:	0f 90       	pop	r0
     c5c:	0f be       	out	0x3f, r0	; 63
				position_set = position_midpoint;
				position_error = position_set - linear_position.get();  // 
				omegam_set = position_error*KP_pos/1000;
     c5e:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <linear_position>
     c62:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <linear_position+0x1>
     c66:	28 1b       	sub	r18, r24
     c68:	39 0b       	sbc	r19, r25
     c6a:	44 e6       	ldi	r20, 0x64	; 100
     c6c:	42 9f       	mul	r20, r18
     c6e:	c0 01       	movw	r24, r0
     c70:	43 9f       	mul	r20, r19
     c72:	90 0d       	add	r25, r0
     c74:	11 24       	eor	r1, r1
     c76:	68 ee       	ldi	r22, 0xE8	; 232
     c78:	73 e0       	ldi	r23, 0x03	; 3
     c7a:	0e 94 89 21 	call	0x4312	; 0x4312 <__divmodhi4>
     c7e:	d8 01       	movw	r26, r16
     c80:	5a 96       	adiw	r26, 0x1a	; 26
     c82:	6d 93       	st	X+, r22
     c84:	7c 93       	st	X, r23
     c86:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c88:	0f b6       	in	r0, 0x3f	; 63
     c8a:	f8 94       	cli
     c8c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c8e:	0f 90       	pop	r0
     c90:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get() == 1)			// if user hits reset
     c92:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <reset>
     c96:	88 23       	and	r24, r24
     c98:	59 f0       	breq	.+22     	; 0xcb0 <_ZN5Motor3runEv+0x27e>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     c9a:	0f b6       	in	r0, 0x3f	; 63
     c9c:	f8 94       	cli
     c9e:	0f 92       	push	r0
			the_data = new_data;
     ca0:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <reset>
			portEXIT_CRITICAL ();
     ca4:	0f 90       	pop	r0
     ca6:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);				// turn off flag
					transition_to(0);
     ca8:	60 e0       	ldi	r22, 0x00	; 0
     caa:	c8 01       	movw	r24, r16
     cac:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cb6:	0f 90       	pop	r0
     cb8:	0f be       	out	0x3f, r0	; 63
					
				}
				
				if(go.get() == 1)				// If user says pendulum is upright or angle = 720;
     cba:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <go>
     cbe:	88 23       	and	r24, r24
     cc0:	09 f4       	brne	.+2      	; 0xcc4 <_ZN5Motor3runEv+0x292>
     cc2:	67 c0       	rjmp	.+206    	; 0xd92 <_ZN5Motor3runEv+0x360>
				{
					transition_to(3);
     cc4:	63 e0       	ldi	r22, 0x03	; 3
     cc6:	c8 01       	movw	r24, r16
     cc8:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN8frt_task13transition_toEh>
     ccc:	62 c0       	rjmp	.+196    	; 0xd92 <_ZN5Motor3runEv+0x360>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     cce:	0f b6       	in	r0, 0x3f	; 63
     cd0:	f8 94       	cli
     cd2:	0f 92       	push	r0
			the_data = new_data;
     cd4:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <go>
			portEXIT_CRITICAL ();
     cd8:	0f 90       	pop	r0
     cda:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     ce2:	0f 90       	pop	r0
     ce4:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ce6:	0f b6       	in	r0, 0x3f	; 63
     ce8:	f8 94       	cli
     cea:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cec:	0f 90       	pop	r0
     cee:	0f be       	out	0x3f, r0	; 63
			case(3) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				position_set = position_midpoint + angle_error*KP_angle/1000;
				position_error = position_set - linear_position.get();  // 
				omegam_set = position_error*KP_pos/1000;
     cf0:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <thPendulum>
     cf4:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <thPendulum+0x1>
     cf8:	20 ed       	ldi	r18, 0xD0	; 208
     cfa:	32 e0       	ldi	r19, 0x02	; 2
     cfc:	28 1b       	sub	r18, r24
     cfe:	39 0b       	sbc	r19, r25
     d00:	48 e1       	ldi	r20, 0x18	; 24
     d02:	5c ef       	ldi	r21, 0xFC	; 252
     d04:	24 9f       	mul	r18, r20
     d06:	c0 01       	movw	r24, r0
     d08:	25 9f       	mul	r18, r21
     d0a:	90 0d       	add	r25, r0
     d0c:	34 9f       	mul	r19, r20
     d0e:	90 0d       	add	r25, r0
     d10:	11 24       	eor	r1, r1
     d12:	28 ee       	ldi	r18, 0xE8	; 232
     d14:	33 e0       	ldi	r19, 0x03	; 3
     d16:	b9 01       	movw	r22, r18
     d18:	0e 94 89 21 	call	0x4312	; 0x4312 <__divmodhi4>
     d1c:	ef 89       	ldd	r30, Y+23	; 0x17
     d1e:	f8 8d       	ldd	r31, Y+24	; 0x18
     d20:	6e 0f       	add	r22, r30
     d22:	7f 1f       	adc	r23, r31
     d24:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <linear_position>
     d28:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <linear_position+0x1>
     d2c:	68 1b       	sub	r22, r24
     d2e:	79 0b       	sbc	r23, r25
     d30:	44 e6       	ldi	r20, 0x64	; 100
     d32:	46 9f       	mul	r20, r22
     d34:	c0 01       	movw	r24, r0
     d36:	47 9f       	mul	r20, r23
     d38:	90 0d       	add	r25, r0
     d3a:	11 24       	eor	r1, r1
     d3c:	b9 01       	movw	r22, r18
     d3e:	0e 94 89 21 	call	0x4312	; 0x4312 <__divmodhi4>
     d42:	d8 01       	movw	r26, r16
     d44:	5a 96       	adiw	r26, 0x1a	; 26
     d46:	6d 93       	st	X+, r22
     d48:	7c 93       	st	X, r23
     d4a:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d4c:	0f b6       	in	r0, 0x3f	; 63
     d4e:	f8 94       	cli
     d50:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d52:	0f 90       	pop	r0
     d54:	0f be       	out	0x3f, r0	; 63
			
			if (stop.get())												// If emergency stop button was hit
     d56:	80 91 3b 31 	lds	r24, 0x313B	; 0x80313b <stop>
     d5a:	88 23       	and	r24, r24
     d5c:	d1 f0       	breq	.+52     	; 0xd92 <_ZN5Motor3runEv+0x360>
			{
				TCC0.CCA = 0;											// PWM  = 0
     d5e:	e0 e0       	ldi	r30, 0x00	; 0
     d60:	f8 e0       	ldi	r31, 0x08	; 8
     d62:	10 a6       	std	Z+40, r1	; 0x28
     d64:	11 a6       	std	Z+41, r1	; 0x29
				TCC0.CCB = 0;
     d66:	12 a6       	std	Z+42, r1	; 0x2a
     d68:	13 a6       	std	Z+43, r1	; 0x2b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d6a:	0f b6       	in	r0, 0x3f	; 63
     d6c:	f8 94       	cli
     d6e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d70:	0f 90       	pop	r0
     d72:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get())										// if user hits reset
     d74:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <reset>
     d78:	88 23       	and	r24, r24
     d7a:	59 f0       	breq	.+22     	; 0xd92 <_ZN5Motor3runEv+0x360>
				{
					transition_to(0);
     d7c:	60 e0       	ldi	r22, 0x00	; 0
     d7e:	c8 01       	movw	r24, r16
     d80:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN8frt_task13transition_toEh>
     d84:	06 c0       	rjmp	.+12     	; 0xd92 <_ZN5Motor3runEv+0x360>
				}
			}
			break;
			
			default :
				TCC0.CCA = 0;											// PWM  = 0
     d86:	e0 e0       	ldi	r30, 0x00	; 0
     d88:	f8 e0       	ldi	r31, 0x08	; 8
     d8a:	10 a6       	std	Z+40, r1	; 0x28
     d8c:	11 a6       	std	Z+41, r1	; 0x29
				TCC0.CCB = 0;
     d8e:	12 a6       	std	Z+42, r1	; 0x2a
     d90:	13 a6       	std	Z+43, r1	; 0x2b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d92:	0f b6       	in	r0, 0x3f	; 63
     d94:	f8 94       	cli
     d96:	0f 92       	push	r0
			temporary_copy = the_data;
     d98:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <thdMotor>
     d9c:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     da0:	0f 90       	pop	r0
     da2:	0f be       	out	0x3f, r0	; 63
				break;													
		
		};

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     da4:	f8 01       	movw	r30, r16
     da6:	86 8f       	std	Z+30, r24	; 0x1e
     da8:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     daa:	af 85       	ldd	r26, Y+15	; 0x0f
     dac:	b8 89       	ldd	r27, Y+16	; 0x10
     dae:	2d 92       	st	X+, r2
     db0:	3c 92       	st	X, r3
		_Ki = .7*256;
     db2:	23 eb       	ldi	r18, 0xB3	; 179
     db4:	30 e0       	ldi	r19, 0x00	; 0
     db6:	ed 81       	ldd	r30, Y+5	; 0x05
     db8:	fe 81       	ldd	r31, Y+6	; 0x06
     dba:	20 83       	st	Z, r18
     dbc:	31 83       	std	Z+1, r19	; 0x01
		_Kd = 0;
     dbe:	a9 89       	ldd	r26, Y+17	; 0x11
     dc0:	ba 89       	ldd	r27, Y+18	; 0x12
     dc2:	1d 92       	st	X+, r1
     dc4:	1c 92       	st	X, r1
		antiwind_gain = .75*256;
     dc6:	20 ec       	ldi	r18, 0xC0	; 192
     dc8:	30 e0       	ldi	r19, 0x00	; 0
     dca:	ef 81       	ldd	r30, Y+7	; 0x07
     dcc:	f8 85       	ldd	r31, Y+8	; 0x08
     dce:	20 83       	st	Z, r18
     dd0:	31 83       	std	Z+1, r19	; 0x01
		
		_max = 1600;
     dd2:	20 e4       	ldi	r18, 0x40	; 64
     dd4:	36 e0       	ldi	r19, 0x06	; 6
     dd6:	a9 85       	ldd	r26, Y+9	; 0x09
     dd8:	ba 85       	ldd	r27, Y+10	; 0x0a
     dda:	2d 93       	st	X+, r18
     ddc:	3c 93       	st	X, r19
		_min = -1600;
     dde:	20 ec       	ldi	r18, 0xC0	; 192
     de0:	39 ef       	ldi	r19, 0xF9	; 249
     de2:	ed 85       	ldd	r30, Y+13	; 0x0d
     de4:	fe 85       	ldd	r31, Y+14	; 0x0e
     de6:	20 83       	st	Z, r18
     de8:	31 83       	std	Z+1, r19	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     dea:	d8 01       	movw	r26, r16
     dec:	5a 96       	adiw	r26, 0x1a	; 26
     dee:	ed 90       	ld	r14, X+
     df0:	fc 90       	ld	r15, X
     df2:	5b 97       	sbiw	r26, 0x1b	; 27
     df4:	e8 1a       	sub	r14, r24
     df6:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     df8:	b7 01       	movw	r22, r14
     dfa:	c1 01       	movw	r24, r2
     dfc:	0e 94 93 08 	call	0x1126	; 0x1126 <_ZN7satmath20signed_saturated_mulEii>
     e00:	2b 01       	movw	r4, r22
     e02:	3c 01       	movw	r6, r24
     e04:	eb 89       	ldd	r30, Y+19	; 0x13
     e06:	fc 89       	ldd	r31, Y+20	; 0x14
     e08:	60 83       	st	Z, r22
     e0a:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     e0c:	d4 01       	movw	r26, r8
     e0e:	8d 91       	ld	r24, X+
     e10:	9c 91       	ld	r25, X
     e12:	f7 01       	movw	r30, r14
     e14:	e8 1b       	sub	r30, r24
     e16:	f9 0b       	sbc	r31, r25
     e18:	cf 01       	movw	r24, r30
     e1a:	ad 89       	ldd	r26, Y+21	; 0x15
     e1c:	be 89       	ldd	r27, Y+22	; 0x16
     e1e:	ed 93       	st	X+, r30
     e20:	fc 93       	st	X, r31
		error_int_gain = (_Ki * error_int);
     e22:	ed 81       	ldd	r30, Y+5	; 0x05
     e24:	fe 81       	ldd	r31, Y+6	; 0x06
     e26:	20 81       	ld	r18, Z
     e28:	31 81       	ldd	r19, Z+1	; 0x01
     e2a:	82 9f       	mul	r24, r18
     e2c:	d0 01       	movw	r26, r0
     e2e:	83 9f       	mul	r24, r19
     e30:	b0 0d       	add	r27, r0
     e32:	92 9f       	mul	r25, r18
     e34:	b0 0d       	add	r27, r0
     e36:	11 24       	eor	r1, r1
     e38:	f8 01       	movw	r30, r16
     e3a:	e6 59       	subi	r30, 0x96	; 150
     e3c:	ff 4f       	sbci	r31, 0xFF	; 255
     e3e:	a0 83       	st	Z, r26
     e40:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     e42:	eb 85       	ldd	r30, Y+11	; 0x0b
     e44:	fc 85       	ldd	r31, Y+12	; 0x0c
     e46:	20 81       	ld	r18, Z
     e48:	31 81       	ldd	r19, Z+1	; 0x01
     e4a:	42 81       	ldd	r20, Z+2	; 0x02
     e4c:	53 81       	ldd	r21, Z+3	; 0x03
     e4e:	0e 94 10 22 	call	0x4420	; 0x4420 <__mulshisi3>
     e52:	9b 01       	movw	r18, r22
     e54:	ac 01       	movw	r20, r24
     e56:	99 23       	and	r25, r25
     e58:	24 f4       	brge	.+8      	; 0xe62 <_ZN5Motor3runEv+0x430>
     e5a:	21 50       	subi	r18, 0x01	; 1
     e5c:	3f 4f       	sbci	r19, 0xFF	; 255
     e5e:	4f 4f       	sbci	r20, 0xFF	; 255
     e60:	5f 4f       	sbci	r21, 0xFF	; 255
     e62:	bb 27       	eor	r27, r27
     e64:	57 fd       	sbrc	r21, 7
     e66:	ba 95       	dec	r27
     e68:	a5 2f       	mov	r26, r21
     e6a:	94 2f       	mov	r25, r20
     e6c:	83 2f       	mov	r24, r19
     e6e:	f5 01       	movw	r30, r10
     e70:	40 81       	ld	r20, Z
     e72:	51 81       	ldd	r21, Z+1	; 0x01
     e74:	62 81       	ldd	r22, Z+2	; 0x02
     e76:	73 81       	ldd	r23, Z+3	; 0x03
     e78:	84 0f       	add	r24, r20
     e7a:	95 1f       	adc	r25, r21
     e7c:	a6 1f       	adc	r26, r22
     e7e:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     e80:	81 30       	cpi	r24, 0x01	; 1
     e82:	fa ec       	ldi	r31, 0xCA	; 202
     e84:	9f 07       	cpc	r25, r31
     e86:	fa e9       	ldi	r31, 0x9A	; 154
     e88:	af 07       	cpc	r26, r31
     e8a:	fb e3       	ldi	r31, 0x3B	; 59
     e8c:	bf 07       	cpc	r27, r31
     e8e:	54 f0       	brlt	.+20     	; 0xea4 <_ZN5Motor3runEv+0x472>
		{
			_integral = 1000000000;
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	9a ec       	ldi	r25, 0xCA	; 202
     e94:	aa e9       	ldi	r26, 0x9A	; 154
     e96:	bb e3       	ldi	r27, 0x3B	; 59
     e98:	f5 01       	movw	r30, r10
     e9a:	80 83       	st	Z, r24
     e9c:	91 83       	std	Z+1, r25	; 0x01
     e9e:	a2 83       	std	Z+2, r26	; 0x02
     ea0:	b3 83       	std	Z+3, r27	; 0x03
     ea2:	17 c0       	rjmp	.+46     	; 0xed2 <_ZN5Motor3runEv+0x4a0>
		}
		else if(_integral < -1000000000)
     ea4:	81 15       	cp	r24, r1
     ea6:	f6 e3       	ldi	r31, 0x36	; 54
     ea8:	9f 07       	cpc	r25, r31
     eaa:	f5 e6       	ldi	r31, 0x65	; 101
     eac:	af 07       	cpc	r26, r31
     eae:	f4 ec       	ldi	r31, 0xC4	; 196
     eb0:	bf 07       	cpc	r27, r31
     eb2:	34 f0       	brlt	.+12     	; 0xec0 <_ZN5Motor3runEv+0x48e>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     eb4:	f5 01       	movw	r30, r10
     eb6:	80 83       	st	Z, r24
     eb8:	91 83       	std	Z+1, r25	; 0x01
     eba:	a2 83       	std	Z+2, r26	; 0x02
     ebc:	b3 83       	std	Z+3, r27	; 0x03
     ebe:	09 c0       	rjmp	.+18     	; 0xed2 <_ZN5Motor3runEv+0x4a0>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
     ec0:	80 e0       	ldi	r24, 0x00	; 0
     ec2:	96 e3       	ldi	r25, 0x36	; 54
     ec4:	a5 e6       	ldi	r26, 0x65	; 101
     ec6:	b4 ec       	ldi	r27, 0xC4	; 196
     ec8:	f5 01       	movw	r30, r10
     eca:	80 83       	st	Z, r24
     ecc:	91 83       	std	Z+1, r25	; 0x01
     ece:	a2 83       	std	Z+2, r26	; 0x02
     ed0:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     ed2:	d5 01       	movw	r26, r10
     ed4:	6d 91       	ld	r22, X+
     ed6:	7c 91       	ld	r23, X
     ed8:	c2 01       	movw	r24, r4
     eda:	0e 94 77 08 	call	0x10ee	; 0x10ee <_ZN7satmath20signed_saturated_addEii>
     ede:	f8 01       	movw	r30, r16
     ee0:	e0 5a       	subi	r30, 0xA0	; 160
     ee2:	ff 4f       	sbci	r31, 0xFF	; 255
     ee4:	80 83       	st	Z, r24
     ee6:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     ee8:	f6 01       	movw	r30, r12
     eea:	80 83       	st	Z, r24
     eec:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     eee:	a9 85       	ldd	r26, Y+9	; 0x09
     ef0:	ba 85       	ldd	r27, Y+10	; 0x0a
     ef2:	2d 91       	ld	r18, X+
     ef4:	3c 91       	ld	r19, X
     ef6:	28 17       	cp	r18, r24
     ef8:	39 07       	cpc	r19, r25
     efa:	1c f4       	brge	.+6      	; 0xf02 <_ZN5Motor3runEv+0x4d0>
		output_correct = _max;
     efc:	20 83       	st	Z, r18
     efe:	31 83       	std	Z+1, r19	; 0x01
     f00:	0a c0       	rjmp	.+20     	; 0xf16 <_ZN5Motor3runEv+0x4e4>
		else if( output_correct < _min )
     f02:	ed 85       	ldd	r30, Y+13	; 0x0d
     f04:	fe 85       	ldd	r31, Y+14	; 0x0e
     f06:	20 81       	ld	r18, Z
     f08:	31 81       	ldd	r19, Z+1	; 0x01
     f0a:	82 17       	cp	r24, r18
     f0c:	93 07       	cpc	r25, r19
     f0e:	1c f4       	brge	.+6      	; 0xf16 <_ZN5Motor3runEv+0x4e4>
		output_correct = _min;
     f10:	d6 01       	movw	r26, r12
     f12:	2d 93       	st	X+, r18
     f14:	3c 93       	st	X, r19

		// Save error to previous error
		_pre_error = error;
     f16:	f8 01       	movw	r30, r16
     f18:	e2 5b       	subi	r30, 0xB2	; 178
     f1a:	ff 4f       	sbci	r31, 0xFF	; 255
     f1c:	e0 82       	st	Z, r14
     f1e:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     f20:	f6 01       	movw	r30, r12
     f22:	20 81       	ld	r18, Z
     f24:	31 81       	ldd	r19, Z+1	; 0x01
     f26:	82 1b       	sub	r24, r18
     f28:	93 0b       	sbc	r25, r19
     f2a:	f8 01       	movw	r30, r16
     f2c:	ee 59       	subi	r30, 0x9E	; 158
     f2e:	ff 4f       	sbci	r31, 0xFF	; 255
     f30:	80 83       	st	Z, r24
     f32:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     f34:	af 81       	ldd	r26, Y+7	; 0x07
     f36:	b8 85       	ldd	r27, Y+8	; 0x08
     f38:	4d 91       	ld	r20, X+
     f3a:	5c 91       	ld	r21, X
     f3c:	84 9f       	mul	r24, r20
     f3e:	90 01       	movw	r18, r0
     f40:	85 9f       	mul	r24, r21
     f42:	30 0d       	add	r19, r0
     f44:	94 9f       	mul	r25, r20
     f46:	30 0d       	add	r19, r0
     f48:	11 24       	eor	r1, r1
     f4a:	33 23       	and	r19, r19
     f4c:	14 f4       	brge	.+4      	; 0xf52 <_ZN5Motor3runEv+0x520>
     f4e:	21 50       	subi	r18, 0x01	; 1
     f50:	3f 4f       	sbci	r19, 0xFF	; 255
     f52:	83 2f       	mov	r24, r19
     f54:	88 0f       	add	r24, r24
     f56:	88 0b       	sbc	r24, r24
     f58:	f4 01       	movw	r30, r8
     f5a:	30 83       	st	Z, r19
     f5c:	81 83       	std	Z+1, r24	; 0x01
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     f5e:	0f b6       	in	r0, 0x3f	; 63
     f60:	f8 94       	cli
     f62:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     f64:	0f 90       	pop	r0
     f66:	0f be       	out	0x3f, r0	; 63
				//*p_serial << "linear set: " << position_set << endl;
				//*p_serial << "angle error: " << angle_error << endl;
			}
		
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     f68:	80 91 41 31 	lds	r24, 0x3141	; 0x803141 <leftLimitSwitch>
     f6c:	81 11       	cpse	r24, r1
     f6e:	09 c0       	rjmp	.+18     	; 0xf82 <_ZN5Motor3runEv+0x550>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	f8 94       	cli
     f74:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     f76:	0f 90       	pop	r0
     f78:	0f be       	out	0x3f, r0	; 63
     f7a:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rightLimitSwitch>
     f7e:	88 23       	and	r24, r24
     f80:	49 f0       	breq	.+18     	; 0xf94 <_ZN5Motor3runEv+0x562>
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     f82:	d5 01       	movw	r26, r10
     f84:	1d 92       	st	X+, r1
     f86:	1d 92       	st	X+, r1
     f88:	1d 92       	st	X+, r1
     f8a:	1c 92       	st	X, r1
     f8c:	13 97       	sbiw	r26, 0x03	; 3
			output_correct = 0;
     f8e:	f6 01       	movw	r30, r12
     f90:	10 82       	st	Z, r1
     f92:	11 82       	std	Z+1, r1	; 0x01
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     f94:	d8 01       	movw	r26, r16
     f96:	98 96       	adiw	r26, 0x28	; 40
     f98:	1d 92       	st	X+, r1
     f9a:	1c 92       	st	X, r1
     f9c:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
     f9e:	92 96       	adiw	r26, 0x22	; 34
     fa0:	8d 91       	ld	r24, X+
     fa2:	9c 91       	ld	r25, X
     fa4:	93 97       	sbiw	r26, 0x23	; 35
     fa6:	60 e0       	ldi	r22, 0x00	; 0
     fa8:	70 e0       	ldi	r23, 0x00	; 0
     faa:	0e 94 89 21 	call	0x4312	; 0x4312 <__divmodhi4>
     fae:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     fb0:	07 2e       	mov	r0, r23
     fb2:	00 0c       	add	r0, r0
     fb4:	88 0b       	sbc	r24, r24
     fb6:	99 0b       	sbc	r25, r25
     fb8:	0e 94 15 21 	call	0x422a	; 0x422a <__floatsisf>
     fbc:	2b 01       	movw	r4, r22
     fbe:	3c 01       	movw	r6, r24
     fc0:	23 e3       	ldi	r18, 0x33	; 51
     fc2:	33 e3       	ldi	r19, 0x33	; 51
     fc4:	4b e8       	ldi	r20, 0x8B	; 139
     fc6:	51 e4       	ldi	r21, 0x41	; 65
     fc8:	0e 94 74 21 	call	0x42e8	; 0x42e8 <__gesf2>
     fcc:	18 16       	cp	r1, r24
     fce:	34 f4       	brge	.+12     	; 0xfdc <_ZN5Motor3runEv+0x5aa>
			Im_set = 17.4;
     fd0:	81 e1       	ldi	r24, 0x11	; 17
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	f8 01       	movw	r30, r16
     fd6:	84 a3       	std	Z+36, r24	; 0x24
     fd8:	95 a3       	std	Z+37, r25	; 0x25
     fda:	15 c0       	rjmp	.+42     	; 0x1006 <_ZN5Motor3runEv+0x5d4>
		} else if(Im_set < -17.4) {
     fdc:	23 e3       	ldi	r18, 0x33	; 51
     fde:	33 e3       	ldi	r19, 0x33	; 51
     fe0:	4b e8       	ldi	r20, 0x8B	; 139
     fe2:	51 ec       	ldi	r21, 0xC1	; 193
     fe4:	c3 01       	movw	r24, r6
     fe6:	b2 01       	movw	r22, r4
     fe8:	0e 94 0e 21 	call	0x421c	; 0x421c <__cmpsf2>
     fec:	88 23       	and	r24, r24
     fee:	34 f0       	brlt	.+12     	; 0xffc <_ZN5Motor3runEv+0x5ca>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     ff0:	d8 01       	movw	r26, r16
     ff2:	94 96       	adiw	r26, 0x24	; 36
     ff4:	ed 92       	st	X+, r14
     ff6:	fc 92       	st	X, r15
     ff8:	95 97       	sbiw	r26, 0x25	; 37
     ffa:	05 c0       	rjmp	.+10     	; 0x1006 <_ZN5Motor3runEv+0x5d4>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     ffc:	8f ee       	ldi	r24, 0xEF	; 239
     ffe:	9f ef       	ldi	r25, 0xFF	; 255
    1000:	f8 01       	movw	r30, r16
    1002:	84 a3       	std	Z+36, r24	; 0x24
    1004:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
    1006:	d8 01       	movw	r26, r16
    1008:	d6 96       	adiw	r26, 0x36	; 54
    100a:	1d 92       	st	X+, r1
    100c:	1c 92       	st	X, r1
    100e:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
    1010:	d2 96       	adiw	r26, 0x32	; 50
    1012:	1d 92       	st	X+, r1
    1014:	1c 92       	st	X, r1
    1016:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
    1018:	d4 96       	adiw	r26, 0x34	; 52
    101a:	1d 92       	st	X+, r1
    101c:	1c 92       	st	X, r1
    101e:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
    1020:	d0 96       	adiw	r26, 0x30	; 48
    1022:	8d 91       	ld	r24, X+
    1024:	9c 91       	ld	r25, X
    1026:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
    1028:	89 31       	cpi	r24, 0x19	; 25
    102a:	91 05       	cpc	r25, r1
    102c:	3c f0       	brlt	.+14     	; 0x103c <_ZN5Motor3runEv+0x60a>
			V_m = 24;
    102e:	88 e1       	ldi	r24, 0x18	; 24
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	d8 96       	adiw	r26, 0x38	; 56
    1034:	8d 93       	st	X+, r24
    1036:	9c 93       	st	X, r25
    1038:	d9 97       	sbiw	r26, 0x39	; 57
    103a:	0f c0       	rjmp	.+30     	; 0x105a <_ZN5Motor3runEv+0x628>
		} else if(V_m < -24) {
    103c:	88 3e       	cpi	r24, 0xE8	; 232
    103e:	bf ef       	ldi	r27, 0xFF	; 255
    1040:	9b 07       	cpc	r25, r27
    1042:	24 f0       	brlt	.+8      	; 0x104c <_ZN5Motor3runEv+0x61a>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
    1044:	f8 01       	movw	r30, r16
    1046:	80 af       	std	Z+56, r24	; 0x38
    1048:	91 af       	std	Z+57, r25	; 0x39
    104a:	07 c0       	rjmp	.+14     	; 0x105a <_ZN5Motor3runEv+0x628>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
    104c:	88 ee       	ldi	r24, 0xE8	; 232
    104e:	9f ef       	ldi	r25, 0xFF	; 255
    1050:	d8 01       	movw	r26, r16
    1052:	d8 96       	adiw	r26, 0x38	; 56
    1054:	8d 93       	st	X+, r24
    1056:	9c 93       	st	X, r25
    1058:	d9 97       	sbiw	r26, 0x39	; 57
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
    105a:	f6 01       	movw	r30, r12
    105c:	80 81       	ld	r24, Z
    105e:	91 81       	ldd	r25, Z+1	; 0x01
    1060:	99 23       	and	r25, r25
    1062:	3c f0       	brlt	.+14     	; 0x1072 <_ZN5Motor3runEv+0x640>
		{
			TCC0.CCA = output_correct;
    1064:	e0 e0       	ldi	r30, 0x00	; 0
    1066:	f8 e0       	ldi	r31, 0x08	; 8
    1068:	80 a7       	std	Z+40, r24	; 0x28
    106a:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
    106c:	12 a6       	std	Z+42, r1	; 0x2a
    106e:	13 a6       	std	Z+43, r1	; 0x2b
    1070:	0c c0       	rjmp	.+24     	; 0x108a <_ZN5Motor3runEv+0x658>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
    1072:	e0 e0       	ldi	r30, 0x00	; 0
    1074:	f8 e0       	ldi	r31, 0x08	; 8
    1076:	10 a6       	std	Z+40, r1	; 0x28
    1078:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
    107a:	d6 01       	movw	r26, r12
    107c:	8d 91       	ld	r24, X+
    107e:	9c 91       	ld	r25, X
    1080:	91 95       	neg	r25
    1082:	81 95       	neg	r24
    1084:	91 09       	sbc	r25, r1
    1086:	82 a7       	std	Z+42, r24	; 0x2a
    1088:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
    108a:	eb 85       	ldd	r30, Y+11	; 0x0b
    108c:	fc 85       	ldd	r31, Y+12	; 0x0c
    108e:	20 81       	ld	r18, Z
    1090:	31 81       	ldd	r19, Z+1	; 0x01
    1092:	42 81       	ldd	r20, Z+2	; 0x02
    1094:	53 81       	ldd	r21, Z+3	; 0x03
    1096:	a8 ee       	ldi	r26, 0xE8	; 232
    1098:	b3 e0       	ldi	r27, 0x03	; 3
    109a:	0e 94 05 22 	call	0x440a	; 0x440a <__muluhisi3>
    109e:	68 3e       	cpi	r22, 0xE8	; 232
    10a0:	f3 e0       	ldi	r31, 0x03	; 3
    10a2:	7f 07       	cpc	r23, r31
    10a4:	81 05       	cpc	r24, r1
    10a6:	91 05       	cpc	r25, r1
    10a8:	48 f0       	brcs	.+18     	; 0x10bc <_ZN5Motor3runEv+0x68a>
    10aa:	28 ee       	ldi	r18, 0xE8	; 232
    10ac:	33 e0       	ldi	r19, 0x03	; 3
    10ae:	40 e0       	ldi	r20, 0x00	; 0
    10b0:	50 e0       	ldi	r21, 0x00	; 0
    10b2:	0e 94 9d 21 	call	0x433a	; 0x433a <__udivmodsi4>
    10b6:	ba 01       	movw	r22, r20
    10b8:	a9 01       	movw	r20, r18
    10ba:	04 c0       	rjmp	.+8      	; 0x10c4 <_ZN5Motor3runEv+0x692>
    10bc:	41 e0       	ldi	r20, 0x01	; 1
    10be:	50 e0       	ldi	r21, 0x00	; 0
    10c0:	60 e0       	ldi	r22, 0x00	; 0
    10c2:	70 e0       	ldi	r23, 0x00	; 0
    10c4:	ce 01       	movw	r24, r28
    10c6:	01 96       	adiw	r24, 0x01	; 1
    10c8:	0e 94 5e 14 	call	0x28bc	; 0x28bc <vTaskDelayUntil>
    10cc:	29 cd       	rjmp	.-1454   	; 0xb20 <_ZN5Motor3runEv+0xee>

000010ce <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
    10ce:	0f 93       	push	r16
    10d0:	1f 93       	push	r17
    10d2:	cf 93       	push	r28
    10d4:	df 93       	push	r29
    10d6:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    10d8:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <_ZN8frt_taskC1EPKchjP8emstream>
    10dc:	82 e2       	ldi	r24, 0x22	; 34
    10de:	90 e2       	ldi	r25, 0x20	; 32
    10e0:	88 83       	st	Y, r24
    10e2:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
    10e4:	df 91       	pop	r29
    10e6:	cf 91       	pop	r28
    10e8:	1f 91       	pop	r17
    10ea:	0f 91       	pop	r16
    10ec:	08 95       	ret

000010ee <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
    10ee:	9c 01       	movw	r18, r24
    10f0:	93 2f       	mov	r25, r19
    10f2:	99 1f       	adc	r25, r25
    10f4:	99 27       	eor	r25, r25
    10f6:	99 1f       	adc	r25, r25
    10f8:	89 2f       	mov	r24, r25
    10fa:	90 e0       	ldi	r25, 0x00	; 0
    10fc:	81 50       	subi	r24, 0x01	; 1
    10fe:	90 48       	sbci	r25, 0x80	; 128
    1100:	43 2f       	mov	r20, r19
    1102:	40 95       	com	r20
    1104:	44 1f       	adc	r20, r20
    1106:	44 27       	eor	r20, r20
    1108:	44 1f       	adc	r20, r20
    110a:	fc 01       	movw	r30, r24
    110c:	e2 1b       	sub	r30, r18
    110e:	f3 0b       	sbc	r31, r19
    1110:	51 e0       	ldi	r21, 0x01	; 1
    1112:	e6 17       	cp	r30, r22
    1114:	f7 07       	cpc	r31, r23
    1116:	0c f0       	brlt	.+2      	; 0x111a <_ZN7satmath20signed_saturated_addEii+0x2c>
    1118:	50 e0       	ldi	r21, 0x00	; 0
    111a:	45 17       	cp	r20, r21
    111c:	19 f0       	breq	.+6      	; 0x1124 <_ZN7satmath20signed_saturated_addEii+0x36>
    111e:	c9 01       	movw	r24, r18
    1120:	86 0f       	add	r24, r22
    1122:	97 1f       	adc	r25, r23
    1124:	08 95       	ret

00001126 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    1126:	81 15       	cp	r24, r1
    1128:	20 e8       	ldi	r18, 0x80	; 128
    112a:	92 07       	cpc	r25, r18
    112c:	21 f4       	brne	.+8      	; 0x1136 <_ZN7satmath20signed_saturated_mulEii+0x10>
    112e:	61 15       	cp	r22, r1
    1130:	20 e8       	ldi	r18, 0x80	; 128
    1132:	72 07       	cpc	r23, r18
    1134:	29 f0       	breq	.+10     	; 0x1140 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
    1136:	9c 01       	movw	r18, r24
    1138:	db 01       	movw	r26, r22
    113a:	0e 94 e7 21 	call	0x43ce	; 0x43ce <__mulhisi3>
    113e:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    1140:	6f ef       	ldi	r22, 0xFF	; 255
    1142:	7f ef       	ldi	r23, 0xFF	; 255
    1144:	8f ef       	ldi	r24, 0xFF	; 255
    1146:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
    1148:	08 95       	ret

0000114a <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    114a:	0f 93       	push	r16
    114c:	1f 93       	push	r17
    114e:	cf 93       	push	r28
    1150:	df 93       	push	r29
    1152:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    1154:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <_ZN8frt_taskC1EPKchjP8emstream>
    1158:	8a e2       	ldi	r24, 0x2A	; 42
    115a:	90 e2       	ldi	r25, 0x20	; 32
    115c:	88 83       	st	Y, r24
    115e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	1f 91       	pop	r17
    1166:	0f 91       	pop	r16
    1168:	08 95       	ret

0000116a <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    116a:	0f 93       	push	r16
    116c:	1f 93       	push	r17
    116e:	cf 93       	push	r28
    1170:	df 93       	push	r29
    1172:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    1174:	6a e0       	ldi	r22, 0x0A	; 10
    1176:	8e 81       	ldd	r24, Y+6	; 0x06
    1178:	9f 81       	ldd	r25, Y+7	; 0x07
    117a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    117e:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    1180:	63 e5       	ldi	r22, 0x53	; 83
    1182:	75 e0       	ldi	r23, 0x05	; 5
    1184:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1188:	6a e0       	ldi	r22, 0x0A	; 10
    118a:	c8 01       	movw	r24, r16
    118c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1190:	8c 01       	movw	r16, r24
    1192:	6d e4       	ldi	r22, 0x4D	; 77
    1194:	75 e0       	ldi	r23, 0x05	; 5
    1196:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    119a:	67 e0       	ldi	r22, 0x07	; 7
    119c:	c8 01       	movw	r24, r16
    119e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    11a2:	6a e0       	ldi	r22, 0x0A	; 10
    11a4:	8e 81       	ldd	r24, Y+6	; 0x06
    11a6:	9f 81       	ldd	r25, Y+7	; 0x07
    11a8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    11ac:	8c 01       	movw	r16, r24
    11ae:	6e e2       	ldi	r22, 0x2E	; 46
    11b0:	75 e0       	ldi	r23, 0x05	; 5
    11b2:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    11b6:	6a e0       	ldi	r22, 0x0A	; 10
    11b8:	c8 01       	movw	r24, r16
    11ba:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    11be:	8c 01       	movw	r16, r24
    11c0:	68 e2       	ldi	r22, 0x28	; 40
    11c2:	75 e0       	ldi	r23, 0x05	; 5
    11c4:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    11c8:	66 e0       	ldi	r22, 0x06	; 6
    11ca:	c8 01       	movw	r24, r16
    11cc:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    11d0:	6a e0       	ldi	r22, 0x0A	; 10
    11d2:	8e 81       	ldd	r24, Y+6	; 0x06
    11d4:	9f 81       	ldd	r25, Y+7	; 0x07
    11d6:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    11da:	8c 01       	movw	r16, r24
    11dc:	61 e1       	ldi	r22, 0x11	; 17
    11de:	75 e0       	ldi	r23, 0x05	; 5
    11e0:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    11e4:	66 e0       	ldi	r22, 0x06	; 6
    11e6:	c8 01       	movw	r24, r16
    11e8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    11ec:	6a e0       	ldi	r22, 0x0A	; 10
    11ee:	8e 81       	ldd	r24, Y+6	; 0x06
    11f0:	9f 81       	ldd	r25, Y+7	; 0x07
    11f2:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    11f6:	8c 01       	movw	r16, r24
    11f8:	65 ef       	ldi	r22, 0xF5	; 245
    11fa:	74 e0       	ldi	r23, 0x04	; 4
    11fc:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1200:	66 e0       	ldi	r22, 0x06	; 6
    1202:	c8 01       	movw	r24, r16
    1204:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1208:	6a e0       	ldi	r22, 0x0A	; 10
    120a:	8e 81       	ldd	r24, Y+6	; 0x06
    120c:	9f 81       	ldd	r25, Y+7	; 0x07
    120e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1212:	8c 01       	movw	r16, r24
    1214:	6d ed       	ldi	r22, 0xDD	; 221
    1216:	74 e0       	ldi	r23, 0x04	; 4
    1218:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    121c:	66 e0       	ldi	r22, 0x06	; 6
    121e:	c8 01       	movw	r24, r16
    1220:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1224:	6a e0       	ldi	r22, 0x0A	; 10
    1226:	8e 81       	ldd	r24, Y+6	; 0x06
    1228:	9f 81       	ldd	r25, Y+7	; 0x07
    122a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    122e:	8c 01       	movw	r16, r24
    1230:	6c eb       	ldi	r22, 0xBC	; 188
    1232:	74 e0       	ldi	r23, 0x04	; 4
    1234:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1238:	66 e0       	ldi	r22, 0x06	; 6
    123a:	c8 01       	movw	r24, r16
    123c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1240:	6a e0       	ldi	r22, 0x0A	; 10
    1242:	8e 81       	ldd	r24, Y+6	; 0x06
    1244:	9f 81       	ldd	r25, Y+7	; 0x07
    1246:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    124a:	8c 01       	movw	r16, r24
    124c:	65 e9       	ldi	r22, 0x95	; 149
    124e:	74 e0       	ldi	r23, 0x04	; 4
    1250:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1254:	66 e0       	ldi	r22, 0x06	; 6
    1256:	c8 01       	movw	r24, r16
    1258:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    125c:	6a e0       	ldi	r22, 0x0A	; 10
    125e:	8e 81       	ldd	r24, Y+6	; 0x06
    1260:	9f 81       	ldd	r25, Y+7	; 0x07
    1262:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1266:	8c 01       	movw	r16, r24
    1268:	67 e7       	ldi	r22, 0x77	; 119
    126a:	74 e0       	ldi	r23, 0x04	; 4
    126c:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1270:	66 e0       	ldi	r22, 0x06	; 6
    1272:	c8 01       	movw	r24, r16
    1274:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    1278:	6a e0       	ldi	r22, 0x0A	; 10
    127a:	8e 81       	ldd	r24, Y+6	; 0x06
    127c:	9f 81       	ldd	r25, Y+7	; 0x07
    127e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1282:	8c 01       	movw	r16, r24
    1284:	6c e5       	ldi	r22, 0x5C	; 92
    1286:	74 e0       	ldi	r23, 0x04	; 4
    1288:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    128c:	66 e0       	ldi	r22, 0x06	; 6
    128e:	c8 01       	movw	r24, r16
    1290:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    1294:	6a e0       	ldi	r22, 0x0A	; 10
    1296:	8e 81       	ldd	r24, Y+6	; 0x06
    1298:	9f 81       	ldd	r25, Y+7	; 0x07
    129a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    129e:	8c 01       	movw	r16, r24
    12a0:	6d e4       	ldi	r22, 0x4D	; 77
    12a2:	74 e0       	ldi	r23, 0x04	; 4
    12a4:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    12a8:	66 e0       	ldi	r22, 0x06	; 6
    12aa:	c8 01       	movw	r24, r16
    12ac:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    b:   Begin Calibration of Inverted Pendulum?") << endl;
    12b0:	6a e0       	ldi	r22, 0x0A	; 10
    12b2:	8e 81       	ldd	r24, Y+6	; 0x06
    12b4:	9f 81       	ldd	r25, Y+7	; 0x07
    12b6:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    12ba:	8c 01       	movw	r16, r24
    12bc:	6c e1       	ldi	r22, 0x1C	; 28
    12be:	74 e0       	ldi	r23, 0x04	; 4
    12c0:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    12c4:	66 e0       	ldi	r22, 0x06	; 6
    12c6:	c8 01       	movw	r24, r16
    12c8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    g:   Swing Pendulum Upright, then Go.") << endl;
    12cc:	6a e0       	ldi	r22, 0x0A	; 10
    12ce:	8e 81       	ldd	r24, Y+6	; 0x06
    12d0:	9f 81       	ldd	r25, Y+7	; 0x07
    12d2:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    12d6:	8c 01       	movw	r16, r24
    12d8:	62 ef       	ldi	r22, 0xF2	; 242
    12da:	73 e0       	ldi	r23, 0x03	; 3
    12dc:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    12e0:	66 e0       	ldi	r22, 0x06	; 6
    12e2:	c8 01       	movw	r24, r16
    12e4:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    d:   Emergency Stop") << endl;
    12e8:	6a e0       	ldi	r22, 0x0A	; 10
    12ea:	8e 81       	ldd	r24, Y+6	; 0x06
    12ec:	9f 81       	ldd	r25, Y+7	; 0x07
    12ee:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    12f2:	8c 01       	movw	r16, r24
    12f4:	6a ed       	ldi	r22, 0xDA	; 218
    12f6:	73 e0       	ldi	r23, 0x03	; 3
    12f8:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    12fc:	66 e0       	ldi	r22, 0x06	; 6
    12fe:	c8 01       	movw	r24, r16
    1300:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    r:   Reset to Idle") << endl;
    1304:	6a e0       	ldi	r22, 0x0A	; 10
    1306:	8e 81       	ldd	r24, Y+6	; 0x06
    1308:	9f 81       	ldd	r25, Y+7	; 0x07
    130a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    130e:	ec 01       	movw	r28, r24
    1310:	63 ec       	ldi	r22, 0xC3	; 195
    1312:	73 e0       	ldi	r23, 0x03	; 3
    1314:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1318:	66 e0       	ldi	r22, 0x06	; 6
    131a:	ce 01       	movw	r24, r28
    131c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
}
    1320:	df 91       	pop	r29
    1322:	cf 91       	pop	r28
    1324:	1f 91       	pop	r17
    1326:	0f 91       	pop	r16
    1328:	08 95       	ret

0000132a <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    132a:	af 92       	push	r10
    132c:	bf 92       	push	r11
    132e:	cf 92       	push	r12
    1330:	df 92       	push	r13
    1332:	ef 92       	push	r14
    1334:	ff 92       	push	r15
    1336:	0f 93       	push	r16
    1338:	1f 93       	push	r17
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	00 d0       	rcall	.+0      	; 0x1340 <_ZN9task_user11show_statusEv+0x16>
    1340:	00 d0       	rcall	.+0      	; 0x1342 <_ZN9task_user11show_statusEv+0x18>
    1342:	cd b7       	in	r28, 0x3d	; 61
    1344:	de b7       	in	r29, 0x3e	; 62
    1346:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1348:	19 82       	std	Y+1, r1	; 0x01
    134a:	1a 82       	std	Y+2, r1	; 0x02
    134c:	1b 82       	std	Y+3, r1	; 0x03
    134e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1350:	1d 82       	std	Y+5, r1	; 0x05
    1352:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1354:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <xPortGetFreeHeapSize>
    1358:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    135a:	ce 01       	movw	r24, r28
    135c:	01 96       	adiw	r24, 0x01	; 1
    135e:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN10time_stamp10set_to_nowEv>
    1362:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1364:	66 e0       	ldi	r22, 0x06	; 6
    1366:	f8 01       	movw	r30, r16
    1368:	86 81       	ldd	r24, Z+6	; 0x06
    136a:	97 81       	ldd	r25, Z+7	; 0x07
    136c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1370:	6a e0       	ldi	r22, 0x0A	; 10
    1372:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1376:	7c 01       	movw	r14, r24
    1378:	64 ea       	ldi	r22, 0xA4	; 164
    137a:	73 e0       	ldi	r23, 0x03	; 3
    137c:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1380:	6a e0       	ldi	r22, 0x0A	; 10
    1382:	c7 01       	movw	r24, r14
    1384:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1388:	7c 01       	movw	r14, r24
    138a:	68 e9       	ldi	r22, 0x98	; 152
    138c:	73 e0       	ldi	r23, 0x03	; 3
    138e:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1392:	66 e0       	ldi	r22, 0x06	; 6
    1394:	c7 01       	movw	r24, r14
    1396:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    139a:	6a e0       	ldi	r22, 0x0A	; 10
    139c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    13a0:	7c 01       	movw	r14, r24
    13a2:	61 e9       	ldi	r22, 0x91	; 145
    13a4:	73 e0       	ldi	r23, 0x03	; 3
    13a6:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    13aa:	b5 01       	movw	r22, r10
    13ac:	c7 01       	movw	r24, r14
    13ae:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    13b2:	6a e0       	ldi	r22, 0x0A	; 10
    13b4:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    13b8:	7c 01       	movw	r14, r24
    13ba:	63 e8       	ldi	r22, 0x83	; 131
    13bc:	73 e0       	ldi	r23, 0x03	; 3
    13be:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    13c2:	b6 01       	movw	r22, r12
    13c4:	c7 01       	movw	r24, r14
    13c6:	0e 94 a7 1c 	call	0x394e	; 0x394e <_ZN8emstreamlsEj>
    13ca:	6a e0       	ldi	r22, 0x0A	; 10
    13cc:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    13d0:	7c 01       	movw	r14, r24
    13d2:	61 e8       	ldi	r22, 0x81	; 129
    13d4:	73 e0       	ldi	r23, 0x03	; 3
    13d6:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    13da:	4f ef       	ldi	r20, 0xFF	; 255
    13dc:	5f e0       	ldi	r21, 0x0F	; 15
    13de:	60 e0       	ldi	r22, 0x00	; 0
    13e0:	70 e0       	ldi	r23, 0x00	; 0
    13e2:	c7 01       	movw	r24, r14
    13e4:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    13e8:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    13ec:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    13f0:	6a e0       	ldi	r22, 0x0A	; 10
    13f2:	f8 01       	movw	r30, r16
    13f4:	86 81       	ldd	r24, Z+6	; 0x06
    13f6:	97 81       	ldd	r25, Z+7	; 0x07
    13f8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    13fc:	7c 01       	movw	r14, r24
    13fe:	66 e7       	ldi	r22, 0x76	; 118
    1400:	73 e0       	ldi	r23, 0x03	; 3
    1402:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1406:	b6 01       	movw	r22, r12
    1408:	c7 01       	movw	r24, r14
    140a:	0e 94 a7 1c 	call	0x394e	; 0x394e <_ZN8emstreamlsEj>
    140e:	66 e0       	ldi	r22, 0x06	; 6
    1410:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1414:	66 e0       	ldi	r22, 0x06	; 6
    1416:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    141a:	f8 01       	movw	r30, r16
    141c:	86 81       	ldd	r24, Z+6	; 0x06
    141e:	97 81       	ldd	r25, Z+7	; 0x07
    1420:	0e 94 09 19 	call	0x3212	; 0x3212 <_Z15print_task_listP8emstream>
}
    1424:	26 96       	adiw	r28, 0x06	; 6
    1426:	cd bf       	out	0x3d, r28	; 61
    1428:	de bf       	out	0x3e, r29	; 62
    142a:	df 91       	pop	r29
    142c:	cf 91       	pop	r28
    142e:	1f 91       	pop	r17
    1430:	0f 91       	pop	r16
    1432:	ff 90       	pop	r15
    1434:	ef 90       	pop	r14
    1436:	df 90       	pop	r13
    1438:	cf 90       	pop	r12
    143a:	bf 90       	pop	r11
    143c:	af 90       	pop	r10
    143e:	08 95       	ret

00001440 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1440:	cf 93       	push	r28
    1442:	df 93       	push	r29
    1444:	00 d0       	rcall	.+0      	; 0x1446 <_ZN9task_user3runEv+0x6>
    1446:	00 d0       	rcall	.+0      	; 0x1448 <_ZN9task_user3runEv+0x8>
    1448:	cd b7       	in	r28, 0x3d	; 61
    144a:	de b7       	in	r29, 0x3e	; 62
    144c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    144e:	19 82       	std	Y+1, r1	; 0x01
    1450:	1a 82       	std	Y+2, r1	; 0x02
    1452:	1b 82       	std	Y+3, r1	; 0x03
    1454:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1456:	1d 82       	std	Y+5, r1	; 0x05
    1458:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;
    145a:	6a e0       	ldi	r22, 0x0A	; 10
    145c:	dc 01       	movw	r26, r24
    145e:	16 96       	adiw	r26, 0x06	; 6
    1460:	8d 91       	ld	r24, X+
    1462:	9c 91       	ld	r25, X
    1464:	17 97       	sbiw	r26, 0x07	; 7
    1466:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    146a:	7c 01       	movw	r14, r24
    146c:	61 ef       	ldi	r22, 0xF1	; 241
    146e:	75 e0       	ldi	r23, 0x05	; 5
    1470:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1474:	66 e0       	ldi	r22, 0x06	; 6
    1476:	c7 01       	movw	r24, r14
    1478:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    147c:	f8 01       	movw	r30, r16
    147e:	84 85       	ldd	r24, Z+12	; 0x0c
    1480:	88 23       	and	r24, r24
    1482:	21 f0       	breq	.+8      	; 0x148c <_ZN9task_user3runEv+0x4c>
    1484:	81 30       	cpi	r24, 0x01	; 1
    1486:	09 f4       	brne	.+2      	; 0x148a <_ZN9task_user3runEv+0x4a>
    1488:	5d c0       	rjmp	.+186    	; 0x1544 <_ZN9task_user3runEv+0x104>
    148a:	32 c1       	rjmp	.+612    	; 0x16f0 <_ZN9task_user3runEv+0x2b0>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    148c:	86 81       	ldd	r24, Z+6	; 0x06
    148e:	97 81       	ldd	r25, Z+7	; 0x07
    1490:	dc 01       	movw	r26, r24
    1492:	ed 91       	ld	r30, X+
    1494:	fc 91       	ld	r31, X
    1496:	04 80       	ldd	r0, Z+4	; 0x04
    1498:	f5 81       	ldd	r31, Z+5	; 0x05
    149a:	e0 2d       	mov	r30, r0
    149c:	19 95       	eicall
    149e:	88 23       	and	r24, r24
    14a0:	a9 f1       	breq	.+106    	; 0x150c <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    14a2:	f8 01       	movw	r30, r16
    14a4:	86 81       	ldd	r24, Z+6	; 0x06
    14a6:	97 81       	ldd	r25, Z+7	; 0x07
    14a8:	dc 01       	movw	r26, r24
    14aa:	ed 91       	ld	r30, X+
    14ac:	fc 91       	ld	r31, X
    14ae:	06 80       	ldd	r0, Z+6	; 0x06
    14b0:	f7 81       	ldd	r31, Z+7	; 0x07
    14b2:	e0 2d       	mov	r30, r0
    14b4:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    14b6:	99 27       	eor	r25, r25
    14b8:	81 30       	cpi	r24, 0x01	; 1
    14ba:	91 05       	cpc	r25, r1
    14bc:	f9 f0       	breq	.+62     	; 0x14fc <_ZN9task_user3runEv+0xbc>
    14be:	03 97       	sbiw	r24, 0x03	; 3
    14c0:	09 f0       	breq	.+2      	; 0x14c4 <_ZN9task_user3runEv+0x84>
    14c2:	31 c1       	rjmp	.+610    	; 0x1726 <_ZN9task_user3runEv+0x2e6>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    14c4:	6a e0       	ldi	r22, 0x0A	; 10
    14c6:	f8 01       	movw	r30, r16
    14c8:	86 81       	ldd	r24, Z+6	; 0x06
    14ca:	97 81       	ldd	r25, Z+7	; 0x07
    14cc:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    14d0:	8c 01       	movw	r16, r24
    14d2:	63 ee       	ldi	r22, 0xE3	; 227
    14d4:	75 e0       	ldi	r23, 0x05	; 5
    14d6:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    14da:	66 e0       	ldi	r22, 0x06	; 6
    14dc:	c8 01       	movw	r24, r16
    14de:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    14e2:	93 e0       	ldi	r25, 0x03	; 3
    14e4:	88 ed       	ldi	r24, 0xD8	; 216
    14e6:	08 b6       	in	r0, 0x38	; 56
    14e8:	18 be       	out	0x38, r1	; 56
    14ea:	84 bf       	out	0x34, r24	; 52
    14ec:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    14f0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    14f4:	81 fd       	sbrc	r24, 1
    14f6:	fc cf       	rjmp	.-8      	; 0x14f0 <_ZN9task_user3runEv+0xb0>
    14f8:	08 be       	out	0x38, r0	; 56
    14fa:	ff cf       	rjmp	.-2      	; 0x14fa <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    14fc:	c8 01       	movw	r24, r16
    14fe:	0e 94 b5 08 	call	0x116a	; 0x116a <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1502:	61 e0       	ldi	r22, 0x01	; 1
    1504:	c8 01       	movw	r24, r16
    1506:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN8frt_task13transition_toEh>
							break;
    150a:	0d c1       	rjmp	.+538    	; 0x1726 <_ZN9task_user3runEv+0x2e6>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    150c:	88 e4       	ldi	r24, 0x48	; 72
    150e:	91 e3       	ldi	r25, 0x31	; 49
    1510:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN14frt_text_queue14check_for_charEv>
    1514:	88 23       	and	r24, r24
    1516:	09 f4       	brne	.+2      	; 0x151a <_ZN9task_user3runEv+0xda>
    1518:	06 c1       	rjmp	.+524    	; 0x1726 <_ZN9task_user3runEv+0x2e6>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    151a:	d8 01       	movw	r26, r16
    151c:	16 96       	adiw	r26, 0x06	; 6
    151e:	ed 91       	ld	r30, X+
    1520:	fc 91       	ld	r31, X
    1522:	17 97       	sbiw	r26, 0x07	; 7
    1524:	01 90       	ld	r0, Z+
    1526:	f0 81       	ld	r31, Z
    1528:	e0 2d       	mov	r30, r0
    152a:	e2 80       	ldd	r14, Z+2	; 0x02
    152c:	f3 80       	ldd	r15, Z+3	; 0x03
    152e:	88 e4       	ldi	r24, 0x48	; 72
    1530:	91 e3       	ldi	r25, 0x31	; 49
    1532:	0e 94 9a 19 	call	0x3334	; 0x3334 <_ZN14frt_text_queue7getcharEv>
    1536:	68 2f       	mov	r22, r24
    1538:	f8 01       	movw	r30, r16
    153a:	86 81       	ldd	r24, Z+6	; 0x06
    153c:	97 81       	ldd	r25, Z+7	; 0x07
    153e:	f7 01       	movw	r30, r14
    1540:	19 95       	eicall
    1542:	f1 c0       	rjmp	.+482    	; 0x1726 <_ZN9task_user3runEv+0x2e6>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1544:	86 81       	ldd	r24, Z+6	; 0x06
    1546:	97 81       	ldd	r25, Z+7	; 0x07
    1548:	dc 01       	movw	r26, r24
    154a:	ed 91       	ld	r30, X+
    154c:	fc 91       	ld	r31, X
    154e:	04 80       	ldd	r0, Z+4	; 0x04
    1550:	f5 81       	ldd	r31, Z+5	; 0x05
    1552:	e0 2d       	mov	r30, r0
    1554:	19 95       	eicall
    1556:	88 23       	and	r24, r24
    1558:	09 f4       	brne	.+2      	; 0x155c <_ZN9task_user3runEv+0x11c>
    155a:	e5 c0       	rjmp	.+458    	; 0x1726 <_ZN9task_user3runEv+0x2e6>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    155c:	f8 01       	movw	r30, r16
    155e:	86 81       	ldd	r24, Z+6	; 0x06
    1560:	97 81       	ldd	r25, Z+7	; 0x07
    1562:	dc 01       	movw	r26, r24
    1564:	ed 91       	ld	r30, X+
    1566:	fc 91       	ld	r31, X
    1568:	06 80       	ldd	r0, Z+6	; 0x06
    156a:	f7 81       	ldd	r31, Z+7	; 0x07
    156c:	e0 2d       	mov	r30, r0
    156e:	19 95       	eicall
    1570:	bc 01       	movw	r22, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1572:	fc 01       	movw	r30, r24
    1574:	ff 27       	eor	r31, r31
    1576:	7b 97       	sbiw	r30, 0x1b	; 27
    1578:	ec 35       	cpi	r30, 0x5C	; 92
    157a:	f1 05       	cpc	r31, r1
    157c:	08 f0       	brcs	.+2      	; 0x1580 <_ZN9task_user3runEv+0x140>
    157e:	9c c0       	rjmp	.+312    	; 0x16b8 <_ZN9task_user3runEv+0x278>
    1580:	88 27       	eor	r24, r24
    1582:	e2 50       	subi	r30, 0x02	; 2
    1584:	ff 4f       	sbci	r31, 0xFF	; 255
    1586:	8f 4f       	sbci	r24, 0xFF	; 255
    1588:	0c 94 de 21 	jmp	0x43bc	; 0x43bc <__tablejump2__>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    158c:	ce 01       	movw	r24, r28
    158e:	01 96       	adiw	r24, 0x01	; 1
    1590:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN10time_stamp10set_to_nowEv>
    1594:	bc 01       	movw	r22, r24
    1596:	f8 01       	movw	r30, r16
    1598:	86 81       	ldd	r24, Z+6	; 0x06
    159a:	97 81       	ldd	r25, Z+7	; 0x07
    159c:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <_ZlsR8emstreamR10time_stamp>
    15a0:	66 e0       	ldi	r22, 0x06	; 6
    15a2:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    15a6:	bf c0       	rjmp	.+382    	; 0x1726 <_ZN9task_user3runEv+0x2e6>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    15a8:	c8 01       	movw	r24, r16
    15aa:	0e 94 95 09 	call	0x132a	; 0x132a <_ZN9task_user11show_statusEv>
							break;
    15ae:	bb c0       	rjmp	.+374    	; 0x1726 <_ZN9task_user3runEv+0x2e6>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    15b0:	d8 01       	movw	r26, r16
    15b2:	16 96       	adiw	r26, 0x06	; 6
    15b4:	8d 91       	ld	r24, X+
    15b6:	9c 91       	ld	r25, X
    15b8:	17 97       	sbiw	r26, 0x07	; 7
    15ba:	0e 94 10 18 	call	0x3020	; 0x3020 <_Z17print_task_stacksP8emstream>
							break;
    15be:	b3 c0       	rjmp	.+358    	; 0x1726 <_ZN9task_user3runEv+0x2e6>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    15c0:	c8 01       	movw	r24, r16
    15c2:	0e 94 b5 08 	call	0x116a	; 0x116a <_ZN9task_user18print_help_messageEv>
							break;
    15c6:	af c0       	rjmp	.+350    	; 0x1726 <_ZN9task_user3runEv+0x2e6>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    15c8:	6a e0       	ldi	r22, 0x0A	; 10
    15ca:	f8 01       	movw	r30, r16
    15cc:	86 81       	ldd	r24, Z+6	; 0x06
    15ce:	97 81       	ldd	r25, Z+7	; 0x07
    15d0:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    15d4:	7c 01       	movw	r14, r24
    15d6:	61 ed       	ldi	r22, 0xD1	; 209
    15d8:	75 e0       	ldi	r23, 0x05	; 5
    15da:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    15de:	66 e0       	ldi	r22, 0x06	; 6
    15e0:	c7 01       	movw	r24, r14
    15e2:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0); 
    15e6:	60 e0       	ldi	r22, 0x00	; 0
    15e8:	c8 01       	movw	r24, r16
    15ea:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN8frt_task13transition_toEh>
							break;
    15ee:	9b c0       	rjmp	.+310    	; 0x1726 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    15f0:	0f b6       	in	r0, 0x3f	; 63
    15f2:	f8 94       	cli
    15f4:	0f 92       	push	r0
			the_data = new_data;
    15f6:	81 e0       	ldi	r24, 0x01	; 1
    15f8:	80 93 3d 31 	sts	0x313D, r24	; 0x80313d <begin>
			portEXIT_CRITICAL ();
    15fc:	0f 90       	pop	r0
    15fe:	0f be       	out	0x3f, r0	; 63
							
						case ('b'):
							begin.put(true);
							*p_serial << PMS ("Begin Homing") << endl;
    1600:	6a e0       	ldi	r22, 0x0A	; 10
    1602:	d8 01       	movw	r26, r16
    1604:	16 96       	adiw	r26, 0x06	; 6
    1606:	8d 91       	ld	r24, X+
    1608:	9c 91       	ld	r25, X
    160a:	17 97       	sbiw	r26, 0x07	; 7
    160c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1610:	7c 01       	movw	r14, r24
    1612:	64 ec       	ldi	r22, 0xC4	; 196
    1614:	75 e0       	ldi	r23, 0x05	; 5
    1616:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    161a:	66 e0       	ldi	r22, 0x06	; 6
    161c:	c7 01       	movw	r24, r14
    161e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1622:	81 c0       	rjmp	.+258    	; 0x1726 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1624:	0f b6       	in	r0, 0x3f	; 63
    1626:	f8 94       	cli
    1628:	0f 92       	push	r0
			the_data = new_data;
    162a:	81 e0       	ldi	r24, 0x01	; 1
    162c:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <go>
			portEXIT_CRITICAL ();
    1630:	0f 90       	pop	r0
    1632:	0f be       	out	0x3f, r0	; 63
						
						case ('g'):
							go.put(true);
							*p_serial << PMS ("Commence Balance") << endl;
    1634:	6a e0       	ldi	r22, 0x0A	; 10
    1636:	f8 01       	movw	r30, r16
    1638:	86 81       	ldd	r24, Z+6	; 0x06
    163a:	97 81       	ldd	r25, Z+7	; 0x07
    163c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1640:	7c 01       	movw	r14, r24
    1642:	63 eb       	ldi	r22, 0xB3	; 179
    1644:	75 e0       	ldi	r23, 0x05	; 5
    1646:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    164a:	66 e0       	ldi	r22, 0x06	; 6
    164c:	c7 01       	movw	r24, r14
    164e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1652:	69 c0       	rjmp	.+210    	; 0x1726 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1654:	0f b6       	in	r0, 0x3f	; 63
    1656:	f8 94       	cli
    1658:	0f 92       	push	r0
			the_data = new_data;
    165a:	81 e0       	ldi	r24, 0x01	; 1
    165c:	80 93 3b 31 	sts	0x313B, r24	; 0x80313b <stop>
			portEXIT_CRITICAL ();
    1660:	0f 90       	pop	r0
    1662:	0f be       	out	0x3f, r0	; 63
						
						case('d'):
							stop.put(true);
							*p_serial << PMS ("EMERGENCY STOP") << endl;
    1664:	6a e0       	ldi	r22, 0x0A	; 10
    1666:	d8 01       	movw	r26, r16
    1668:	16 96       	adiw	r26, 0x06	; 6
    166a:	8d 91       	ld	r24, X+
    166c:	9c 91       	ld	r25, X
    166e:	17 97       	sbiw	r26, 0x07	; 7
    1670:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    1674:	7c 01       	movw	r14, r24
    1676:	64 ea       	ldi	r22, 0xA4	; 164
    1678:	75 e0       	ldi	r23, 0x05	; 5
    167a:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    167e:	66 e0       	ldi	r22, 0x06	; 6
    1680:	c7 01       	movw	r24, r14
    1682:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1686:	4f c0       	rjmp	.+158    	; 0x1726 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1688:	0f b6       	in	r0, 0x3f	; 63
    168a:	f8 94       	cli
    168c:	0f 92       	push	r0
			the_data = new_data;
    168e:	81 e0       	ldi	r24, 0x01	; 1
    1690:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <reset>
			portEXIT_CRITICAL ();
    1694:	0f 90       	pop	r0
    1696:	0f be       	out	0x3f, r0	; 63
						
						case('r'):
							reset.put(true);
							*p_serial << PMS ("Reset, try Homing again by pressing 'b'") << endl;
    1698:	6a e0       	ldi	r22, 0x0A	; 10
    169a:	f8 01       	movw	r30, r16
    169c:	86 81       	ldd	r24, Z+6	; 0x06
    169e:	97 81       	ldd	r25, Z+7	; 0x07
    16a0:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    16a4:	7c 01       	movw	r14, r24
    16a6:	6c e7       	ldi	r22, 0x7C	; 124
    16a8:	75 e0       	ldi	r23, 0x05	; 5
    16aa:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    16ae:	66 e0       	ldi	r22, 0x06	; 6
    16b0:	c7 01       	movw	r24, r14
    16b2:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    16b6:	37 c0       	rjmp	.+110    	; 0x1726 <_ZN9task_user3runEv+0x2e6>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    16b8:	d8 01       	movw	r26, r16
    16ba:	16 96       	adiw	r26, 0x06	; 6
    16bc:	8d 91       	ld	r24, X+
    16be:	9c 91       	ld	r25, X
    16c0:	17 97       	sbiw	r26, 0x07	; 7
    16c2:	dc 01       	movw	r26, r24
    16c4:	ed 91       	ld	r30, X+
    16c6:	fc 91       	ld	r31, X
    16c8:	02 80       	ldd	r0, Z+2	; 0x02
    16ca:	f3 81       	ldd	r31, Z+3	; 0x03
    16cc:	e0 2d       	mov	r30, r0
    16ce:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    16d0:	6a e0       	ldi	r22, 0x0A	; 10
    16d2:	f8 01       	movw	r30, r16
    16d4:	86 81       	ldd	r24, Z+6	; 0x06
    16d6:	97 81       	ldd	r25, Z+7	; 0x07
    16d8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    16dc:	7c 01       	movw	r14, r24
    16de:	66 e7       	ldi	r22, 0x76	; 118
    16e0:	75 e0       	ldi	r23, 0x05	; 5
    16e2:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    16e6:	66 e0       	ldi	r22, 0x06	; 6
    16e8:	c7 01       	movw	r24, r14
    16ea:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    16ee:	1b c0       	rjmp	.+54     	; 0x1726 <_ZN9task_user3runEv+0x2e6>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    16f0:	6a e0       	ldi	r22, 0x0A	; 10
    16f2:	86 81       	ldd	r24, Z+6	; 0x06
    16f4:	97 81       	ldd	r25, Z+7	; 0x07
    16f6:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    16fa:	8c 01       	movw	r16, r24
    16fc:	69 e5       	ldi	r22, 0x59	; 89
    16fe:	75 e0       	ldi	r23, 0x05	; 5
    1700:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    1704:	66 e0       	ldi	r22, 0x06	; 6
    1706:	c8 01       	movw	r24, r16
    1708:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    170c:	93 e0       	ldi	r25, 0x03	; 3
    170e:	88 ed       	ldi	r24, 0xD8	; 216
    1710:	08 b6       	in	r0, 0x38	; 56
    1712:	18 be       	out	0x38, r1	; 56
    1714:	84 bf       	out	0x34, r24	; 52
    1716:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    171a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    171e:	81 fd       	sbrc	r24, 1
    1720:	fc cf       	rjmp	.-8      	; 0x171a <_ZN9task_user3runEv+0x2da>
    1722:	08 be       	out	0x38, r0	; 56
    1724:	ff cf       	rjmp	.-2      	; 0x1724 <_ZN9task_user3runEv+0x2e4>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1726:	f8 01       	movw	r30, r16
    1728:	86 85       	ldd	r24, Z+14	; 0x0e
    172a:	97 85       	ldd	r25, Z+15	; 0x0f
    172c:	a0 89       	ldd	r26, Z+16	; 0x10
    172e:	b1 89       	ldd	r27, Z+17	; 0x11
    1730:	01 96       	adiw	r24, 0x01	; 1
    1732:	a1 1d       	adc	r26, r1
    1734:	b1 1d       	adc	r27, r1
    1736:	86 87       	std	Z+14, r24	; 0x0e
    1738:	97 87       	std	Z+15, r25	; 0x0f
    173a:	a0 8b       	std	Z+16, r26	; 0x10
    173c:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    173e:	61 e0       	ldi	r22, 0x01	; 1
    1740:	70 e0       	ldi	r23, 0x00	; 0
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	0e 94 cb 14 	call	0x2996	; 0x2996 <vTaskDelay>
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;

	
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    174a:	98 ce       	rjmp	.-720    	; 0x147c <_ZN9task_user3runEv+0x3c>

0000174c <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    174c:	0f 93       	push	r16
    174e:	1f 93       	push	r17
    1750:	cf 93       	push	r28
    1752:	df 93       	push	r29
    1754:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1756:	0e 94 ba 12 	call	0x2574	; 0x2574 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    175a:	80 91 b0 20 	lds	r24, 0x20B0	; 0x8020b0 <__data_end>
    175e:	81 11       	cpse	r24, r1
    1760:	1d c0       	rjmp	.+58     	; 0x179c <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1762:	a5 eb       	ldi	r26, 0xB5	; 181
    1764:	b0 e2       	ldi	r27, 0x20	; 32
    1766:	e9 eb       	ldi	r30, 0xB9	; 185
    1768:	f0 e2       	ldi	r31, 0x20	; 32
    176a:	ed 93       	st	X+, r30
    176c:	fc 93       	st	X, r31
    176e:	11 97       	sbiw	r26, 0x01	; 1
    1770:	12 96       	adiw	r26, 0x02	; 2
    1772:	1d 92       	st	X+, r1
    1774:	1c 92       	st	X, r1
    1776:	13 97       	sbiw	r26, 0x03	; 3
    1778:	a1 eb       	ldi	r26, 0xB1	; 177
    177a:	b0 e2       	ldi	r27, 0x20	; 32
    177c:	8f ef       	ldi	r24, 0xFF	; 255
    177e:	9f e0       	ldi	r25, 0x0F	; 15
    1780:	12 96       	adiw	r26, 0x02	; 2
    1782:	8d 93       	st	X+, r24
    1784:	9c 93       	st	X, r25
    1786:	13 97       	sbiw	r26, 0x03	; 3
    1788:	1d 92       	st	X+, r1
    178a:	1c 92       	st	X, r1
    178c:	11 97       	sbiw	r26, 0x01	; 1
    178e:	82 83       	std	Z+2, r24	; 0x02
    1790:	93 83       	std	Z+3, r25	; 0x03
    1792:	a0 83       	st	Z, r26
    1794:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1796:	81 e0       	ldi	r24, 0x01	; 1
    1798:	80 93 b0 20 	sts	0x20B0, r24	; 0x8020b0 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    179c:	20 97       	sbiw	r28, 0x00	; 0
    179e:	09 f4       	brne	.+2      	; 0x17a2 <pvPortMalloc+0x56>
    17a0:	5f c0       	rjmp	.+190    	; 0x1860 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    17a2:	9e 01       	movw	r18, r28
    17a4:	2b 5f       	subi	r18, 0xFB	; 251
    17a6:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    17a8:	24 96       	adiw	r28, 0x04	; 4
    17aa:	ce 3f       	cpi	r28, 0xFE	; 254
    17ac:	df 40       	sbci	r29, 0x0F	; 15
    17ae:	08 f0       	brcs	.+2      	; 0x17b2 <pvPortMalloc+0x66>
    17b0:	5a c0       	rjmp	.+180    	; 0x1866 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    17b2:	e0 91 b5 20 	lds	r30, 0x20B5	; 0x8020b5 <xStart>
    17b6:	f0 91 b6 20 	lds	r31, 0x20B6	; 0x8020b6 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    17ba:	a5 eb       	ldi	r26, 0xB5	; 181
    17bc:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17be:	02 c0       	rjmp	.+4      	; 0x17c4 <pvPortMalloc+0x78>
    17c0:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    17c2:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17c4:	82 81       	ldd	r24, Z+2	; 0x02
    17c6:	93 81       	ldd	r25, Z+3	; 0x03
    17c8:	82 17       	cp	r24, r18
    17ca:	93 07       	cpc	r25, r19
    17cc:	20 f4       	brcc	.+8      	; 0x17d6 <pvPortMalloc+0x8a>
    17ce:	80 81       	ld	r24, Z
    17d0:	91 81       	ldd	r25, Z+1	; 0x01
    17d2:	00 97       	sbiw	r24, 0x00	; 0
    17d4:	a9 f7       	brne	.-22     	; 0x17c0 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    17d6:	c0 e2       	ldi	r28, 0x20	; 32
    17d8:	e1 3b       	cpi	r30, 0xB1	; 177
    17da:	fc 07       	cpc	r31, r28
    17dc:	09 f4       	brne	.+2      	; 0x17e0 <pvPortMalloc+0x94>
    17de:	46 c0       	rjmp	.+140    	; 0x186c <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    17e0:	cd 91       	ld	r28, X+
    17e2:	dc 91       	ld	r29, X
    17e4:	11 97       	sbiw	r26, 0x01	; 1
    17e6:	8e 01       	movw	r16, r28
    17e8:	0b 5f       	subi	r16, 0xFB	; 251
    17ea:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    17ec:	80 81       	ld	r24, Z
    17ee:	91 81       	ldd	r25, Z+1	; 0x01
    17f0:	8d 93       	st	X+, r24
    17f2:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    17f4:	82 81       	ldd	r24, Z+2	; 0x02
    17f6:	93 81       	ldd	r25, Z+3	; 0x03
    17f8:	82 1b       	sub	r24, r18
    17fa:	93 0b       	sbc	r25, r19
    17fc:	8b 30       	cpi	r24, 0x0B	; 11
    17fe:	91 05       	cpc	r25, r1
    1800:	10 f1       	brcs	.+68     	; 0x1846 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1802:	bf 01       	movw	r22, r30
    1804:	62 0f       	add	r22, r18
    1806:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1808:	db 01       	movw	r26, r22
    180a:	12 96       	adiw	r26, 0x02	; 2
    180c:	8d 93       	st	X+, r24
    180e:	9c 93       	st	X, r25
    1810:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1812:	22 83       	std	Z+2, r18	; 0x02
    1814:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1816:	12 96       	adiw	r26, 0x02	; 2
    1818:	4d 91       	ld	r20, X+
    181a:	5c 91       	ld	r21, X
    181c:	13 97       	sbiw	r26, 0x03	; 3
    181e:	85 eb       	ldi	r24, 0xB5	; 181
    1820:	90 e2       	ldi	r25, 0x20	; 32
    1822:	01 c0       	rjmp	.+2      	; 0x1826 <pvPortMalloc+0xda>
    1824:	cd 01       	movw	r24, r26
    1826:	ec 01       	movw	r28, r24
    1828:	a8 81       	ld	r26, Y
    182a:	b9 81       	ldd	r27, Y+1	; 0x01
    182c:	12 96       	adiw	r26, 0x02	; 2
    182e:	2d 91       	ld	r18, X+
    1830:	3c 91       	ld	r19, X
    1832:	13 97       	sbiw	r26, 0x03	; 3
    1834:	24 17       	cp	r18, r20
    1836:	35 07       	cpc	r19, r21
    1838:	a8 f3       	brcs	.-22     	; 0x1824 <pvPortMalloc+0xd8>
    183a:	eb 01       	movw	r28, r22
    183c:	a8 83       	st	Y, r26
    183e:	b9 83       	std	Y+1, r27	; 0x01
    1840:	dc 01       	movw	r26, r24
    1842:	6d 93       	st	X+, r22
    1844:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1846:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    184a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    184e:	22 81       	ldd	r18, Z+2	; 0x02
    1850:	33 81       	ldd	r19, Z+3	; 0x03
    1852:	82 1b       	sub	r24, r18
    1854:	93 0b       	sbc	r25, r19
    1856:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    185a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    185e:	08 c0       	rjmp	.+16     	; 0x1870 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1860:	00 e0       	ldi	r16, 0x00	; 0
    1862:	10 e0       	ldi	r17, 0x00	; 0
    1864:	05 c0       	rjmp	.+10     	; 0x1870 <pvPortMalloc+0x124>
    1866:	00 e0       	ldi	r16, 0x00	; 0
    1868:	10 e0       	ldi	r17, 0x00	; 0
    186a:	02 c0       	rjmp	.+4      	; 0x1870 <pvPortMalloc+0x124>
    186c:	00 e0       	ldi	r16, 0x00	; 0
    186e:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1870:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1874:	c8 01       	movw	r24, r16
    1876:	df 91       	pop	r29
    1878:	cf 91       	pop	r28
    187a:	1f 91       	pop	r17
    187c:	0f 91       	pop	r16
    187e:	08 95       	ret

00001880 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1880:	0f 93       	push	r16
    1882:	1f 93       	push	r17
    1884:	cf 93       	push	r28
    1886:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1888:	00 97       	sbiw	r24, 0x00	; 0
    188a:	41 f1       	breq	.+80     	; 0x18dc <vPortFree+0x5c>
    188c:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    188e:	8c 01       	movw	r16, r24
    1890:	05 50       	subi	r16, 0x05	; 5
    1892:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1894:	0e 94 ba 12 	call	0x2574	; 0x2574 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1898:	f8 01       	movw	r30, r16
    189a:	42 81       	ldd	r20, Z+2	; 0x02
    189c:	53 81       	ldd	r21, Z+3	; 0x03
    189e:	a5 eb       	ldi	r26, 0xB5	; 181
    18a0:	b0 e2       	ldi	r27, 0x20	; 32
    18a2:	01 c0       	rjmp	.+2      	; 0x18a6 <vPortFree+0x26>
    18a4:	df 01       	movw	r26, r30
    18a6:	ed 91       	ld	r30, X+
    18a8:	fc 91       	ld	r31, X
    18aa:	11 97       	sbiw	r26, 0x01	; 1
    18ac:	22 81       	ldd	r18, Z+2	; 0x02
    18ae:	33 81       	ldd	r19, Z+3	; 0x03
    18b0:	24 17       	cp	r18, r20
    18b2:	35 07       	cpc	r19, r21
    18b4:	b8 f3       	brcs	.-18     	; 0x18a4 <vPortFree+0x24>
    18b6:	25 97       	sbiw	r28, 0x05	; 5
    18b8:	e8 83       	st	Y, r30
    18ba:	f9 83       	std	Y+1, r31	; 0x01
    18bc:	0d 93       	st	X+, r16
    18be:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    18c0:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    18c4:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    18c8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ca:	9b 81       	ldd	r25, Y+3	; 0x03
    18cc:	82 0f       	add	r24, r18
    18ce:	93 1f       	adc	r25, r19
    18d0:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    18d4:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    18d8:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
	}
}
    18dc:	df 91       	pop	r29
    18de:	cf 91       	pop	r28
    18e0:	1f 91       	pop	r17
    18e2:	0f 91       	pop	r16
    18e4:	08 95       	ret

000018e6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    18e6:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    18ea:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    18ee:	08 95       	ret

000018f0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    18f0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    18f2:	03 96       	adiw	r24, 0x03	; 3
    18f4:	81 83       	std	Z+1, r24	; 0x01
    18f6:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    18f8:	4f ef       	ldi	r20, 0xFF	; 255
    18fa:	5f ef       	ldi	r21, 0xFF	; 255
    18fc:	ba 01       	movw	r22, r20
    18fe:	43 83       	std	Z+3, r20	; 0x03
    1900:	54 83       	std	Z+4, r21	; 0x04
    1902:	65 83       	std	Z+5, r22	; 0x05
    1904:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1906:	87 83       	std	Z+7, r24	; 0x07
    1908:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    190a:	81 87       	std	Z+9, r24	; 0x09
    190c:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    190e:	10 82       	st	Z, r1
    1910:	08 95       	ret

00001912 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1912:	fc 01       	movw	r30, r24
    1914:	12 86       	std	Z+10, r1	; 0x0a
    1916:	13 86       	std	Z+11, r1	; 0x0b
    1918:	08 95       	ret

0000191a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    191a:	cf 93       	push	r28
    191c:	df 93       	push	r29
    191e:	fc 01       	movw	r30, r24
    1920:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1922:	21 81       	ldd	r18, Z+1	; 0x01
    1924:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1926:	e9 01       	movw	r28, r18
    1928:	8c 81       	ldd	r24, Y+4	; 0x04
    192a:	9d 81       	ldd	r25, Y+5	; 0x05
    192c:	14 96       	adiw	r26, 0x04	; 4
    192e:	8d 93       	st	X+, r24
    1930:	9c 93       	st	X, r25
    1932:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1934:	81 81       	ldd	r24, Z+1	; 0x01
    1936:	92 81       	ldd	r25, Z+2	; 0x02
    1938:	16 96       	adiw	r26, 0x06	; 6
    193a:	8d 93       	st	X+, r24
    193c:	9c 93       	st	X, r25
    193e:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1940:	8c 81       	ldd	r24, Y+4	; 0x04
    1942:	9d 81       	ldd	r25, Y+5	; 0x05
    1944:	ec 01       	movw	r28, r24
    1946:	6e 83       	std	Y+6, r22	; 0x06
    1948:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    194a:	e9 01       	movw	r28, r18
    194c:	6c 83       	std	Y+4, r22	; 0x04
    194e:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1950:	61 83       	std	Z+1, r22	; 0x01
    1952:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1954:	1a 96       	adiw	r26, 0x0a	; 10
    1956:	ed 93       	st	X+, r30
    1958:	fc 93       	st	X, r31
    195a:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    195c:	80 81       	ld	r24, Z
    195e:	8f 5f       	subi	r24, 0xFF	; 255
    1960:	80 83       	st	Z, r24
}
    1962:	df 91       	pop	r29
    1964:	cf 91       	pop	r28
    1966:	08 95       	ret

00001968 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1968:	0f 93       	push	r16
    196a:	1f 93       	push	r17
    196c:	cf 93       	push	r28
    196e:	df 93       	push	r29
    1970:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1972:	08 81       	ld	r16, Y
    1974:	19 81       	ldd	r17, Y+1	; 0x01
    1976:	2a 81       	ldd	r18, Y+2	; 0x02
    1978:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    197a:	0f 3f       	cpi	r16, 0xFF	; 255
    197c:	4f ef       	ldi	r20, 0xFF	; 255
    197e:	14 07       	cpc	r17, r20
    1980:	24 07       	cpc	r18, r20
    1982:	34 07       	cpc	r19, r20
    1984:	31 f4       	brne	.+12     	; 0x1992 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1986:	dc 01       	movw	r26, r24
    1988:	19 96       	adiw	r26, 0x09	; 9
    198a:	ed 91       	ld	r30, X+
    198c:	fc 91       	ld	r31, X
    198e:	1a 97       	sbiw	r26, 0x0a	; 10
    1990:	1f c0       	rjmp	.+62     	; 0x19d0 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1992:	fc 01       	movw	r30, r24
    1994:	33 96       	adiw	r30, 0x03	; 3
    1996:	dc 01       	movw	r26, r24
    1998:	17 96       	adiw	r26, 0x07	; 7
    199a:	4d 91       	ld	r20, X+
    199c:	5c 91       	ld	r21, X
    199e:	18 97       	sbiw	r26, 0x08	; 8
    19a0:	da 01       	movw	r26, r20
    19a2:	4d 91       	ld	r20, X+
    19a4:	5d 91       	ld	r21, X+
    19a6:	6d 91       	ld	r22, X+
    19a8:	7c 91       	ld	r23, X
    19aa:	04 17       	cp	r16, r20
    19ac:	15 07       	cpc	r17, r21
    19ae:	26 07       	cpc	r18, r22
    19b0:	37 07       	cpc	r19, r23
    19b2:	70 f0       	brcs	.+28     	; 0x19d0 <vListInsert+0x68>
    19b4:	04 80       	ldd	r0, Z+4	; 0x04
    19b6:	f5 81       	ldd	r31, Z+5	; 0x05
    19b8:	e0 2d       	mov	r30, r0
    19ba:	a4 81       	ldd	r26, Z+4	; 0x04
    19bc:	b5 81       	ldd	r27, Z+5	; 0x05
    19be:	4d 91       	ld	r20, X+
    19c0:	5d 91       	ld	r21, X+
    19c2:	6d 91       	ld	r22, X+
    19c4:	7c 91       	ld	r23, X
    19c6:	04 17       	cp	r16, r20
    19c8:	15 07       	cpc	r17, r21
    19ca:	26 07       	cpc	r18, r22
    19cc:	37 07       	cpc	r19, r23
    19ce:	90 f7       	brcc	.-28     	; 0x19b4 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    19d0:	a4 81       	ldd	r26, Z+4	; 0x04
    19d2:	b5 81       	ldd	r27, Z+5	; 0x05
    19d4:	ac 83       	std	Y+4, r26	; 0x04
    19d6:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19d8:	16 96       	adiw	r26, 0x06	; 6
    19da:	cd 93       	st	X+, r28
    19dc:	dc 93       	st	X, r29
    19de:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    19e0:	ee 83       	std	Y+6, r30	; 0x06
    19e2:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    19e4:	c4 83       	std	Z+4, r28	; 0x04
    19e6:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19e8:	8a 87       	std	Y+10, r24	; 0x0a
    19ea:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    19ec:	fc 01       	movw	r30, r24
    19ee:	20 81       	ld	r18, Z
    19f0:	2f 5f       	subi	r18, 0xFF	; 255
    19f2:	20 83       	st	Z, r18
}
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	1f 91       	pop	r17
    19fa:	0f 91       	pop	r16
    19fc:	08 95       	ret

000019fe <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    19fe:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1a00:	a4 81       	ldd	r26, Z+4	; 0x04
    1a02:	b5 81       	ldd	r27, Z+5	; 0x05
    1a04:	86 81       	ldd	r24, Z+6	; 0x06
    1a06:	97 81       	ldd	r25, Z+7	; 0x07
    1a08:	16 96       	adiw	r26, 0x06	; 6
    1a0a:	8d 93       	st	X+, r24
    1a0c:	9c 93       	st	X, r25
    1a0e:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1a10:	a6 81       	ldd	r26, Z+6	; 0x06
    1a12:	b7 81       	ldd	r27, Z+7	; 0x07
    1a14:	84 81       	ldd	r24, Z+4	; 0x04
    1a16:	95 81       	ldd	r25, Z+5	; 0x05
    1a18:	14 96       	adiw	r26, 0x04	; 4
    1a1a:	8d 93       	st	X+, r24
    1a1c:	9c 93       	st	X, r25
    1a1e:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1a20:	a2 85       	ldd	r26, Z+10	; 0x0a
    1a22:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1a24:	11 96       	adiw	r26, 0x01	; 1
    1a26:	8d 91       	ld	r24, X+
    1a28:	9c 91       	ld	r25, X
    1a2a:	12 97       	sbiw	r26, 0x02	; 2
    1a2c:	e8 17       	cp	r30, r24
    1a2e:	f9 07       	cpc	r31, r25
    1a30:	31 f4       	brne	.+12     	; 0x1a3e <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a32:	86 81       	ldd	r24, Z+6	; 0x06
    1a34:	97 81       	ldd	r25, Z+7	; 0x07
    1a36:	11 96       	adiw	r26, 0x01	; 1
    1a38:	8d 93       	st	X+, r24
    1a3a:	9c 93       	st	X, r25
    1a3c:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1a3e:	12 86       	std	Z+10, r1	; 0x0a
    1a40:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1a42:	8c 91       	ld	r24, X
    1a44:	81 50       	subi	r24, 0x01	; 1
    1a46:	8c 93       	st	X, r24
    1a48:	08 95       	ret

00001a4a <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a4a:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <portStackTopForTask>
    1a4e:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <portStackTopForTask+0x1>
    1a52:	31 e1       	ldi	r19, 0x11	; 17
    1a54:	fc 01       	movw	r30, r24
    1a56:	30 83       	st	Z, r19
    1a58:	31 97       	sbiw	r30, 0x01	; 1
    1a5a:	22 e2       	ldi	r18, 0x22	; 34
    1a5c:	20 83       	st	Z, r18
    1a5e:	31 97       	sbiw	r30, 0x01	; 1
    1a60:	a3 e3       	ldi	r26, 0x33	; 51
    1a62:	a0 83       	st	Z, r26
    1a64:	31 97       	sbiw	r30, 0x01	; 1
    1a66:	60 83       	st	Z, r22
    1a68:	31 97       	sbiw	r30, 0x01	; 1
    1a6a:	70 83       	st	Z, r23
    1a6c:	31 97       	sbiw	r30, 0x01	; 1
    1a6e:	10 82       	st	Z, r1
    1a70:	31 97       	sbiw	r30, 0x01	; 1
    1a72:	10 82       	st	Z, r1
    1a74:	31 97       	sbiw	r30, 0x01	; 1
    1a76:	60 e8       	ldi	r22, 0x80	; 128
    1a78:	60 83       	st	Z, r22
    1a7a:	31 97       	sbiw	r30, 0x01	; 1
    1a7c:	10 82       	st	Z, r1
    1a7e:	31 97       	sbiw	r30, 0x01	; 1
    1a80:	10 82       	st	Z, r1
    1a82:	31 97       	sbiw	r30, 0x01	; 1
    1a84:	10 82       	st	Z, r1
    1a86:	31 97       	sbiw	r30, 0x01	; 1
    1a88:	62 e0       	ldi	r22, 0x02	; 2
    1a8a:	60 83       	st	Z, r22
    1a8c:	31 97       	sbiw	r30, 0x01	; 1
    1a8e:	63 e0       	ldi	r22, 0x03	; 3
    1a90:	60 83       	st	Z, r22
    1a92:	31 97       	sbiw	r30, 0x01	; 1
    1a94:	64 e0       	ldi	r22, 0x04	; 4
    1a96:	60 83       	st	Z, r22
    1a98:	31 97       	sbiw	r30, 0x01	; 1
    1a9a:	65 e0       	ldi	r22, 0x05	; 5
    1a9c:	60 83       	st	Z, r22
    1a9e:	31 97       	sbiw	r30, 0x01	; 1
    1aa0:	66 e0       	ldi	r22, 0x06	; 6
    1aa2:	60 83       	st	Z, r22
    1aa4:	31 97       	sbiw	r30, 0x01	; 1
    1aa6:	67 e0       	ldi	r22, 0x07	; 7
    1aa8:	60 83       	st	Z, r22
    1aaa:	31 97       	sbiw	r30, 0x01	; 1
    1aac:	68 e0       	ldi	r22, 0x08	; 8
    1aae:	60 83       	st	Z, r22
    1ab0:	31 97       	sbiw	r30, 0x01	; 1
    1ab2:	69 e0       	ldi	r22, 0x09	; 9
    1ab4:	60 83       	st	Z, r22
    1ab6:	31 97       	sbiw	r30, 0x01	; 1
    1ab8:	60 e1       	ldi	r22, 0x10	; 16
    1aba:	60 83       	st	Z, r22
    1abc:	31 97       	sbiw	r30, 0x01	; 1
    1abe:	30 83       	st	Z, r19
    1ac0:	31 97       	sbiw	r30, 0x01	; 1
    1ac2:	32 e1       	ldi	r19, 0x12	; 18
    1ac4:	30 83       	st	Z, r19
    1ac6:	31 97       	sbiw	r30, 0x01	; 1
    1ac8:	33 e1       	ldi	r19, 0x13	; 19
    1aca:	30 83       	st	Z, r19
    1acc:	31 97       	sbiw	r30, 0x01	; 1
    1ace:	34 e1       	ldi	r19, 0x14	; 20
    1ad0:	30 83       	st	Z, r19
    1ad2:	31 97       	sbiw	r30, 0x01	; 1
    1ad4:	35 e1       	ldi	r19, 0x15	; 21
    1ad6:	30 83       	st	Z, r19
    1ad8:	31 97       	sbiw	r30, 0x01	; 1
    1ada:	36 e1       	ldi	r19, 0x16	; 22
    1adc:	30 83       	st	Z, r19
    1ade:	31 97       	sbiw	r30, 0x01	; 1
    1ae0:	37 e1       	ldi	r19, 0x17	; 23
    1ae2:	30 83       	st	Z, r19
    1ae4:	31 97       	sbiw	r30, 0x01	; 1
    1ae6:	38 e1       	ldi	r19, 0x18	; 24
    1ae8:	30 83       	st	Z, r19
    1aea:	31 97       	sbiw	r30, 0x01	; 1
    1aec:	39 e1       	ldi	r19, 0x19	; 25
    1aee:	30 83       	st	Z, r19
    1af0:	31 97       	sbiw	r30, 0x01	; 1
    1af2:	30 e2       	ldi	r19, 0x20	; 32
    1af4:	30 83       	st	Z, r19
    1af6:	31 97       	sbiw	r30, 0x01	; 1
    1af8:	31 e2       	ldi	r19, 0x21	; 33
    1afa:	30 83       	st	Z, r19
    1afc:	31 97       	sbiw	r30, 0x01	; 1
    1afe:	20 83       	st	Z, r18
    1b00:	31 97       	sbiw	r30, 0x01	; 1
    1b02:	23 e2       	ldi	r18, 0x23	; 35
    1b04:	20 83       	st	Z, r18
    1b06:	31 97       	sbiw	r30, 0x01	; 1
    1b08:	40 83       	st	Z, r20
    1b0a:	31 97       	sbiw	r30, 0x01	; 1
    1b0c:	50 83       	st	Z, r21
    1b0e:	31 97       	sbiw	r30, 0x01	; 1
    1b10:	26 e2       	ldi	r18, 0x26	; 38
    1b12:	20 83       	st	Z, r18
    1b14:	31 97       	sbiw	r30, 0x01	; 1
    1b16:	27 e2       	ldi	r18, 0x27	; 39
    1b18:	20 83       	st	Z, r18
    1b1a:	31 97       	sbiw	r30, 0x01	; 1
    1b1c:	28 e2       	ldi	r18, 0x28	; 40
    1b1e:	20 83       	st	Z, r18
    1b20:	31 97       	sbiw	r30, 0x01	; 1
    1b22:	29 e2       	ldi	r18, 0x29	; 41
    1b24:	20 83       	st	Z, r18
    1b26:	31 97       	sbiw	r30, 0x01	; 1
    1b28:	20 e3       	ldi	r18, 0x30	; 48
    1b2a:	20 83       	st	Z, r18
    1b2c:	31 97       	sbiw	r30, 0x01	; 1
    1b2e:	21 e3       	ldi	r18, 0x31	; 49
    1b30:	20 83       	st	Z, r18
    1b32:	89 97       	sbiw	r24, 0x29	; 41
    1b34:	08 95       	ret

00001b36 <xPortStartScheduler>:
    1b36:	8c e7       	ldi	r24, 0x7C	; 124
    1b38:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1b3c:	8f ef       	ldi	r24, 0xFF	; 255
    1b3e:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1b42:	81 e0       	ldi	r24, 0x01	; 1
    1b44:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1b48:	91 e1       	ldi	r25, 0x11	; 17
    1b4a:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1b4e:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1b52:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1b56:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1b5a:	cd 91       	ld	r28, X+
    1b5c:	cd bf       	out	0x3d, r28	; 61
    1b5e:	dd 91       	ld	r29, X+
    1b60:	de bf       	out	0x3e, r29	; 62
    1b62:	ff 91       	pop	r31
    1b64:	ef 91       	pop	r30
    1b66:	df 91       	pop	r29
    1b68:	cf 91       	pop	r28
    1b6a:	bf 91       	pop	r27
    1b6c:	af 91       	pop	r26
    1b6e:	9f 91       	pop	r25
    1b70:	8f 91       	pop	r24
    1b72:	7f 91       	pop	r23
    1b74:	6f 91       	pop	r22
    1b76:	5f 91       	pop	r21
    1b78:	4f 91       	pop	r20
    1b7a:	3f 91       	pop	r19
    1b7c:	2f 91       	pop	r18
    1b7e:	1f 91       	pop	r17
    1b80:	0f 91       	pop	r16
    1b82:	ff 90       	pop	r15
    1b84:	ef 90       	pop	r14
    1b86:	df 90       	pop	r13
    1b88:	cf 90       	pop	r12
    1b8a:	bf 90       	pop	r11
    1b8c:	af 90       	pop	r10
    1b8e:	9f 90       	pop	r9
    1b90:	8f 90       	pop	r8
    1b92:	7f 90       	pop	r7
    1b94:	6f 90       	pop	r6
    1b96:	5f 90       	pop	r5
    1b98:	4f 90       	pop	r4
    1b9a:	3f 90       	pop	r3
    1b9c:	2f 90       	pop	r2
    1b9e:	1f 90       	pop	r1
    1ba0:	0f 90       	pop	r0
    1ba2:	0c be       	out	0x3c, r0	; 60
    1ba4:	0f 90       	pop	r0
    1ba6:	0b be       	out	0x3b, r0	; 59
    1ba8:	0f 90       	pop	r0
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	0f 90       	pop	r0
    1bae:	08 95       	ret
    1bb0:	08 95       	ret

00001bb2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1bb2:	0f 92       	push	r0
    1bb4:	0f b6       	in	r0, 0x3f	; 63
    1bb6:	f8 94       	cli
    1bb8:	0f 92       	push	r0
    1bba:	0b b6       	in	r0, 0x3b	; 59
    1bbc:	0f 92       	push	r0
    1bbe:	0c b6       	in	r0, 0x3c	; 60
    1bc0:	0f 92       	push	r0
    1bc2:	1f 92       	push	r1
    1bc4:	11 24       	eor	r1, r1
    1bc6:	2f 92       	push	r2
    1bc8:	3f 92       	push	r3
    1bca:	4f 92       	push	r4
    1bcc:	5f 92       	push	r5
    1bce:	6f 92       	push	r6
    1bd0:	7f 92       	push	r7
    1bd2:	8f 92       	push	r8
    1bd4:	9f 92       	push	r9
    1bd6:	af 92       	push	r10
    1bd8:	bf 92       	push	r11
    1bda:	cf 92       	push	r12
    1bdc:	df 92       	push	r13
    1bde:	ef 92       	push	r14
    1be0:	ff 92       	push	r15
    1be2:	0f 93       	push	r16
    1be4:	1f 93       	push	r17
    1be6:	2f 93       	push	r18
    1be8:	3f 93       	push	r19
    1bea:	4f 93       	push	r20
    1bec:	5f 93       	push	r21
    1bee:	6f 93       	push	r22
    1bf0:	7f 93       	push	r23
    1bf2:	8f 93       	push	r24
    1bf4:	9f 93       	push	r25
    1bf6:	af 93       	push	r26
    1bf8:	bf 93       	push	r27
    1bfa:	cf 93       	push	r28
    1bfc:	df 93       	push	r29
    1bfe:	ef 93       	push	r30
    1c00:	ff 93       	push	r31
    1c02:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1c06:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1c0a:	0d b6       	in	r0, 0x3d	; 61
    1c0c:	0d 92       	st	X+, r0
    1c0e:	0e b6       	in	r0, 0x3e	; 62
    1c10:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1c12:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1c16:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1c1a:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1c1e:	cd 91       	ld	r28, X+
    1c20:	cd bf       	out	0x3d, r28	; 61
    1c22:	dd 91       	ld	r29, X+
    1c24:	de bf       	out	0x3e, r29	; 62
    1c26:	ff 91       	pop	r31
    1c28:	ef 91       	pop	r30
    1c2a:	df 91       	pop	r29
    1c2c:	cf 91       	pop	r28
    1c2e:	bf 91       	pop	r27
    1c30:	af 91       	pop	r26
    1c32:	9f 91       	pop	r25
    1c34:	8f 91       	pop	r24
    1c36:	7f 91       	pop	r23
    1c38:	6f 91       	pop	r22
    1c3a:	5f 91       	pop	r21
    1c3c:	4f 91       	pop	r20
    1c3e:	3f 91       	pop	r19
    1c40:	2f 91       	pop	r18
    1c42:	1f 91       	pop	r17
    1c44:	0f 91       	pop	r16
    1c46:	ff 90       	pop	r15
    1c48:	ef 90       	pop	r14
    1c4a:	df 90       	pop	r13
    1c4c:	cf 90       	pop	r12
    1c4e:	bf 90       	pop	r11
    1c50:	af 90       	pop	r10
    1c52:	9f 90       	pop	r9
    1c54:	8f 90       	pop	r8
    1c56:	7f 90       	pop	r7
    1c58:	6f 90       	pop	r6
    1c5a:	5f 90       	pop	r5
    1c5c:	4f 90       	pop	r4
    1c5e:	3f 90       	pop	r3
    1c60:	2f 90       	pop	r2
    1c62:	1f 90       	pop	r1
    1c64:	0f 90       	pop	r0
    1c66:	0c be       	out	0x3c, r0	; 60
    1c68:	0f 90       	pop	r0
    1c6a:	0b be       	out	0x3b, r0	; 59
    1c6c:	0f 90       	pop	r0
    1c6e:	0f be       	out	0x3f, r0	; 63
    1c70:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c72:	08 95       	ret

00001c74 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c74:	0f 92       	push	r0
    1c76:	0f b6       	in	r0, 0x3f	; 63
    1c78:	f8 94       	cli
    1c7a:	0f 92       	push	r0
    1c7c:	0b b6       	in	r0, 0x3b	; 59
    1c7e:	0f 92       	push	r0
    1c80:	0c b6       	in	r0, 0x3c	; 60
    1c82:	0f 92       	push	r0
    1c84:	1f 92       	push	r1
    1c86:	11 24       	eor	r1, r1
    1c88:	2f 92       	push	r2
    1c8a:	3f 92       	push	r3
    1c8c:	4f 92       	push	r4
    1c8e:	5f 92       	push	r5
    1c90:	6f 92       	push	r6
    1c92:	7f 92       	push	r7
    1c94:	8f 92       	push	r8
    1c96:	9f 92       	push	r9
    1c98:	af 92       	push	r10
    1c9a:	bf 92       	push	r11
    1c9c:	cf 92       	push	r12
    1c9e:	df 92       	push	r13
    1ca0:	ef 92       	push	r14
    1ca2:	ff 92       	push	r15
    1ca4:	0f 93       	push	r16
    1ca6:	1f 93       	push	r17
    1ca8:	2f 93       	push	r18
    1caa:	3f 93       	push	r19
    1cac:	4f 93       	push	r20
    1cae:	5f 93       	push	r21
    1cb0:	6f 93       	push	r22
    1cb2:	7f 93       	push	r23
    1cb4:	8f 93       	push	r24
    1cb6:	9f 93       	push	r25
    1cb8:	af 93       	push	r26
    1cba:	bf 93       	push	r27
    1cbc:	cf 93       	push	r28
    1cbe:	df 93       	push	r29
    1cc0:	ef 93       	push	r30
    1cc2:	ff 93       	push	r31
    1cc4:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1cc8:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1ccc:	0d b6       	in	r0, 0x3d	; 61
    1cce:	0d 92       	st	X+, r0
    1cd0:	0e b6       	in	r0, 0x3e	; 62
    1cd2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1cd4:	0e 94 db 12 	call	0x25b6	; 0x25b6 <vTaskIncrementTick>
	vTaskSwitchContext();
    1cd8:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1cdc:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1ce0:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1ce4:	cd 91       	ld	r28, X+
    1ce6:	cd bf       	out	0x3d, r28	; 61
    1ce8:	dd 91       	ld	r29, X+
    1cea:	de bf       	out	0x3e, r29	; 62
    1cec:	ff 91       	pop	r31
    1cee:	ef 91       	pop	r30
    1cf0:	df 91       	pop	r29
    1cf2:	cf 91       	pop	r28
    1cf4:	bf 91       	pop	r27
    1cf6:	af 91       	pop	r26
    1cf8:	9f 91       	pop	r25
    1cfa:	8f 91       	pop	r24
    1cfc:	7f 91       	pop	r23
    1cfe:	6f 91       	pop	r22
    1d00:	5f 91       	pop	r21
    1d02:	4f 91       	pop	r20
    1d04:	3f 91       	pop	r19
    1d06:	2f 91       	pop	r18
    1d08:	1f 91       	pop	r17
    1d0a:	0f 91       	pop	r16
    1d0c:	ff 90       	pop	r15
    1d0e:	ef 90       	pop	r14
    1d10:	df 90       	pop	r13
    1d12:	cf 90       	pop	r12
    1d14:	bf 90       	pop	r11
    1d16:	af 90       	pop	r10
    1d18:	9f 90       	pop	r9
    1d1a:	8f 90       	pop	r8
    1d1c:	7f 90       	pop	r7
    1d1e:	6f 90       	pop	r6
    1d20:	5f 90       	pop	r5
    1d22:	4f 90       	pop	r4
    1d24:	3f 90       	pop	r3
    1d26:	2f 90       	pop	r2
    1d28:	1f 90       	pop	r1
    1d2a:	0f 90       	pop	r0
    1d2c:	0c be       	out	0x3c, r0	; 60
    1d2e:	0f 90       	pop	r0
    1d30:	0b be       	out	0x3b, r0	; 59
    1d32:	0f 90       	pop	r0
    1d34:	0f be       	out	0x3f, r0	; 63
    1d36:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d38:	08 95       	ret

00001d3a <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1d3a:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1d3e:	18 95       	reti

00001d40 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1d40:	cf 93       	push	r28
    1d42:	df 93       	push	r29
    1d44:	ec 01       	movw	r28, r24
    1d46:	88 a1       	ldd	r24, Y+32	; 0x20
    1d48:	81 11       	cpse	r24, r1
    1d4a:	0b c0       	rjmp	.+22     	; 0x1d62 <prvCopyDataToQueue+0x22>
    1d4c:	88 81       	ld	r24, Y
    1d4e:	99 81       	ldd	r25, Y+1	; 0x01
    1d50:	89 2b       	or	r24, r25
    1d52:	e1 f5       	brne	.+120    	; 0x1dcc <prvCopyDataToQueue+0x8c>
    1d54:	8a 81       	ldd	r24, Y+2	; 0x02
    1d56:	9b 81       	ldd	r25, Y+3	; 0x03
    1d58:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <vTaskPriorityDisinherit>
    1d5c:	1a 82       	std	Y+2, r1	; 0x02
    1d5e:	1b 82       	std	Y+3, r1	; 0x03
    1d60:	35 c0       	rjmp	.+106    	; 0x1dcc <prvCopyDataToQueue+0x8c>
    1d62:	41 11       	cpse	r20, r1
    1d64:	17 c0       	rjmp	.+46     	; 0x1d94 <prvCopyDataToQueue+0x54>
    1d66:	48 2f       	mov	r20, r24
    1d68:	50 e0       	ldi	r21, 0x00	; 0
    1d6a:	8c 81       	ldd	r24, Y+4	; 0x04
    1d6c:	9d 81       	ldd	r25, Y+5	; 0x05
    1d6e:	0e 94 2c 22 	call	0x4458	; 0x4458 <memcpy>
    1d72:	28 a1       	ldd	r18, Y+32	; 0x20
    1d74:	8c 81       	ldd	r24, Y+4	; 0x04
    1d76:	9d 81       	ldd	r25, Y+5	; 0x05
    1d78:	82 0f       	add	r24, r18
    1d7a:	91 1d       	adc	r25, r1
    1d7c:	8c 83       	std	Y+4, r24	; 0x04
    1d7e:	9d 83       	std	Y+5, r25	; 0x05
    1d80:	2a 81       	ldd	r18, Y+2	; 0x02
    1d82:	3b 81       	ldd	r19, Y+3	; 0x03
    1d84:	82 17       	cp	r24, r18
    1d86:	93 07       	cpc	r25, r19
    1d88:	08 f1       	brcs	.+66     	; 0x1dcc <prvCopyDataToQueue+0x8c>
    1d8a:	88 81       	ld	r24, Y
    1d8c:	99 81       	ldd	r25, Y+1	; 0x01
    1d8e:	8c 83       	std	Y+4, r24	; 0x04
    1d90:	9d 83       	std	Y+5, r25	; 0x05
    1d92:	1c c0       	rjmp	.+56     	; 0x1dcc <prvCopyDataToQueue+0x8c>
    1d94:	48 2f       	mov	r20, r24
    1d96:	50 e0       	ldi	r21, 0x00	; 0
    1d98:	8e 81       	ldd	r24, Y+6	; 0x06
    1d9a:	9f 81       	ldd	r25, Y+7	; 0x07
    1d9c:	0e 94 2c 22 	call	0x4458	; 0x4458 <memcpy>
    1da0:	88 a1       	ldd	r24, Y+32	; 0x20
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	91 95       	neg	r25
    1da6:	81 95       	neg	r24
    1da8:	91 09       	sbc	r25, r1
    1daa:	2e 81       	ldd	r18, Y+6	; 0x06
    1dac:	3f 81       	ldd	r19, Y+7	; 0x07
    1dae:	28 0f       	add	r18, r24
    1db0:	39 1f       	adc	r19, r25
    1db2:	2e 83       	std	Y+6, r18	; 0x06
    1db4:	3f 83       	std	Y+7, r19	; 0x07
    1db6:	48 81       	ld	r20, Y
    1db8:	59 81       	ldd	r21, Y+1	; 0x01
    1dba:	24 17       	cp	r18, r20
    1dbc:	35 07       	cpc	r19, r21
    1dbe:	30 f4       	brcc	.+12     	; 0x1dcc <prvCopyDataToQueue+0x8c>
    1dc0:	2a 81       	ldd	r18, Y+2	; 0x02
    1dc2:	3b 81       	ldd	r19, Y+3	; 0x03
    1dc4:	82 0f       	add	r24, r18
    1dc6:	93 1f       	adc	r25, r19
    1dc8:	8e 83       	std	Y+6, r24	; 0x06
    1dca:	9f 83       	std	Y+7, r25	; 0x07
    1dcc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1dce:	8f 5f       	subi	r24, 0xFF	; 255
    1dd0:	8e 8f       	std	Y+30, r24	; 0x1e
    1dd2:	df 91       	pop	r29
    1dd4:	cf 91       	pop	r28
    1dd6:	08 95       	ret

00001dd8 <prvCopyDataFromQueue>:
    1dd8:	fc 01       	movw	r30, r24
    1dda:	80 81       	ld	r24, Z
    1ddc:	91 81       	ldd	r25, Z+1	; 0x01
    1dde:	00 97       	sbiw	r24, 0x00	; 0
    1de0:	a1 f0       	breq	.+40     	; 0x1e0a <prvCopyDataFromQueue+0x32>
    1de2:	40 a1       	ldd	r20, Z+32	; 0x20
    1de4:	50 e0       	ldi	r21, 0x00	; 0
    1de6:	26 81       	ldd	r18, Z+6	; 0x06
    1de8:	37 81       	ldd	r19, Z+7	; 0x07
    1dea:	24 0f       	add	r18, r20
    1dec:	35 1f       	adc	r19, r21
    1dee:	26 83       	std	Z+6, r18	; 0x06
    1df0:	37 83       	std	Z+7, r19	; 0x07
    1df2:	a2 81       	ldd	r26, Z+2	; 0x02
    1df4:	b3 81       	ldd	r27, Z+3	; 0x03
    1df6:	2a 17       	cp	r18, r26
    1df8:	3b 07       	cpc	r19, r27
    1dfa:	10 f0       	brcs	.+4      	; 0x1e00 <prvCopyDataFromQueue+0x28>
    1dfc:	86 83       	std	Z+6, r24	; 0x06
    1dfe:	97 83       	std	Z+7, r25	; 0x07
    1e00:	cb 01       	movw	r24, r22
    1e02:	66 81       	ldd	r22, Z+6	; 0x06
    1e04:	77 81       	ldd	r23, Z+7	; 0x07
    1e06:	0e 94 2c 22 	call	0x4458	; 0x4458 <memcpy>
    1e0a:	08 95       	ret

00001e0c <prvUnlockQueue>:
    1e0c:	0f 93       	push	r16
    1e0e:	1f 93       	push	r17
    1e10:	cf 93       	push	r28
    1e12:	df 93       	push	r29
    1e14:	ec 01       	movw	r28, r24
    1e16:	0f b6       	in	r0, 0x3f	; 63
    1e18:	f8 94       	cli
    1e1a:	0f 92       	push	r0
    1e1c:	8a a1       	ldd	r24, Y+34	; 0x22
    1e1e:	18 16       	cp	r1, r24
    1e20:	b4 f4       	brge	.+44     	; 0x1e4e <prvUnlockQueue+0x42>
    1e22:	8b 89       	ldd	r24, Y+19	; 0x13
    1e24:	81 11       	cpse	r24, r1
    1e26:	05 c0       	rjmp	.+10     	; 0x1e32 <prvUnlockQueue+0x26>
    1e28:	12 c0       	rjmp	.+36     	; 0x1e4e <prvUnlockQueue+0x42>
    1e2a:	8b 89       	ldd	r24, Y+19	; 0x13
    1e2c:	81 11       	cpse	r24, r1
    1e2e:	04 c0       	rjmp	.+8      	; 0x1e38 <prvUnlockQueue+0x2c>
    1e30:	0e c0       	rjmp	.+28     	; 0x1e4e <prvUnlockQueue+0x42>
    1e32:	8e 01       	movw	r16, r28
    1e34:	0d 5e       	subi	r16, 0xED	; 237
    1e36:	1f 4f       	sbci	r17, 0xFF	; 255
    1e38:	c8 01       	movw	r24, r16
    1e3a:	0e 94 80 15 	call	0x2b00	; 0x2b00 <xTaskRemoveFromEventList>
    1e3e:	81 11       	cpse	r24, r1
    1e40:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <vTaskMissedYield>
    1e44:	8a a1       	ldd	r24, Y+34	; 0x22
    1e46:	81 50       	subi	r24, 0x01	; 1
    1e48:	8a a3       	std	Y+34, r24	; 0x22
    1e4a:	18 16       	cp	r1, r24
    1e4c:	74 f3       	brlt	.-36     	; 0x1e2a <prvUnlockQueue+0x1e>
    1e4e:	8f ef       	ldi	r24, 0xFF	; 255
    1e50:	8a a3       	std	Y+34, r24	; 0x22
    1e52:	0f 90       	pop	r0
    1e54:	0f be       	out	0x3f, r0	; 63
    1e56:	0f b6       	in	r0, 0x3f	; 63
    1e58:	f8 94       	cli
    1e5a:	0f 92       	push	r0
    1e5c:	89 a1       	ldd	r24, Y+33	; 0x21
    1e5e:	18 16       	cp	r1, r24
    1e60:	b4 f4       	brge	.+44     	; 0x1e8e <prvUnlockQueue+0x82>
    1e62:	88 85       	ldd	r24, Y+8	; 0x08
    1e64:	81 11       	cpse	r24, r1
    1e66:	05 c0       	rjmp	.+10     	; 0x1e72 <prvUnlockQueue+0x66>
    1e68:	12 c0       	rjmp	.+36     	; 0x1e8e <prvUnlockQueue+0x82>
    1e6a:	88 85       	ldd	r24, Y+8	; 0x08
    1e6c:	81 11       	cpse	r24, r1
    1e6e:	04 c0       	rjmp	.+8      	; 0x1e78 <prvUnlockQueue+0x6c>
    1e70:	0e c0       	rjmp	.+28     	; 0x1e8e <prvUnlockQueue+0x82>
    1e72:	8e 01       	movw	r16, r28
    1e74:	08 5f       	subi	r16, 0xF8	; 248
    1e76:	1f 4f       	sbci	r17, 0xFF	; 255
    1e78:	c8 01       	movw	r24, r16
    1e7a:	0e 94 80 15 	call	0x2b00	; 0x2b00 <xTaskRemoveFromEventList>
    1e7e:	81 11       	cpse	r24, r1
    1e80:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <vTaskMissedYield>
    1e84:	89 a1       	ldd	r24, Y+33	; 0x21
    1e86:	81 50       	subi	r24, 0x01	; 1
    1e88:	89 a3       	std	Y+33, r24	; 0x21
    1e8a:	18 16       	cp	r1, r24
    1e8c:	74 f3       	brlt	.-36     	; 0x1e6a <prvUnlockQueue+0x5e>
    1e8e:	8f ef       	ldi	r24, 0xFF	; 255
    1e90:	89 a3       	std	Y+33, r24	; 0x21
    1e92:	0f 90       	pop	r0
    1e94:	0f be       	out	0x3f, r0	; 63
    1e96:	df 91       	pop	r29
    1e98:	cf 91       	pop	r28
    1e9a:	1f 91       	pop	r17
    1e9c:	0f 91       	pop	r16
    1e9e:	08 95       	ret

00001ea0 <xQueueGenericReset>:
    1ea0:	1f 93       	push	r17
    1ea2:	cf 93       	push	r28
    1ea4:	df 93       	push	r29
    1ea6:	61 30       	cpi	r22, 0x01	; 1
    1ea8:	59 f0       	breq	.+22     	; 0x1ec0 <xQueueGenericReset+0x20>
    1eaa:	fc 01       	movw	r30, r24
    1eac:	23 89       	ldd	r18, Z+19	; 0x13
    1eae:	30 85       	ldd	r19, Z+8	; 0x08
    1eb0:	31 11       	cpse	r19, r1
    1eb2:	2c c0       	rjmp	.+88     	; 0x1f0c <xQueueGenericReset+0x6c>
    1eb4:	11 e0       	ldi	r17, 0x01	; 1
    1eb6:	21 11       	cpse	r18, r1
    1eb8:	10 e0       	ldi	r17, 0x00	; 0
    1eba:	21 11       	cpse	r18, r1
    1ebc:	28 c0       	rjmp	.+80     	; 0x1f0e <xQueueGenericReset+0x6e>
    1ebe:	01 c0       	rjmp	.+2      	; 0x1ec2 <xQueueGenericReset+0x22>
    1ec0:	11 e0       	ldi	r17, 0x01	; 1
    1ec2:	ec 01       	movw	r28, r24
    1ec4:	48 81       	ld	r20, Y
    1ec6:	59 81       	ldd	r21, Y+1	; 0x01
    1ec8:	28 a1       	ldd	r18, Y+32	; 0x20
    1eca:	30 e0       	ldi	r19, 0x00	; 0
    1ecc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1ece:	62 9f       	mul	r22, r18
    1ed0:	c0 01       	movw	r24, r0
    1ed2:	63 9f       	mul	r22, r19
    1ed4:	90 0d       	add	r25, r0
    1ed6:	11 24       	eor	r1, r1
    1ed8:	ba 01       	movw	r22, r20
    1eda:	68 0f       	add	r22, r24
    1edc:	79 1f       	adc	r23, r25
    1ede:	6a 83       	std	Y+2, r22	; 0x02
    1ee0:	7b 83       	std	Y+3, r23	; 0x03
    1ee2:	1e 8e       	std	Y+30, r1	; 0x1e
    1ee4:	4c 83       	std	Y+4, r20	; 0x04
    1ee6:	5d 83       	std	Y+5, r21	; 0x05
    1ee8:	82 1b       	sub	r24, r18
    1eea:	93 0b       	sbc	r25, r19
    1eec:	84 0f       	add	r24, r20
    1eee:	95 1f       	adc	r25, r21
    1ef0:	8e 83       	std	Y+6, r24	; 0x06
    1ef2:	9f 83       	std	Y+7, r25	; 0x07
    1ef4:	8f ef       	ldi	r24, 0xFF	; 255
    1ef6:	89 a3       	std	Y+33, r24	; 0x21
    1ef8:	8a a3       	std	Y+34, r24	; 0x22
    1efa:	ce 01       	movw	r24, r28
    1efc:	08 96       	adiw	r24, 0x08	; 8
    1efe:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    1f02:	ce 01       	movw	r24, r28
    1f04:	43 96       	adiw	r24, 0x13	; 19
    1f06:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    1f0a:	01 c0       	rjmp	.+2      	; 0x1f0e <xQueueGenericReset+0x6e>
    1f0c:	10 e0       	ldi	r17, 0x00	; 0
    1f0e:	81 2f       	mov	r24, r17
    1f10:	df 91       	pop	r29
    1f12:	cf 91       	pop	r28
    1f14:	1f 91       	pop	r17
    1f16:	08 95       	ret

00001f18 <xQueueGenericCreate>:
    1f18:	0f 93       	push	r16
    1f1a:	1f 93       	push	r17
    1f1c:	cf 93       	push	r28
    1f1e:	df 93       	push	r29
    1f20:	88 23       	and	r24, r24
    1f22:	01 f1       	breq	.+64     	; 0x1f64 <xQueueGenericCreate+0x4c>
    1f24:	06 2f       	mov	r16, r22
    1f26:	18 2f       	mov	r17, r24
    1f28:	83 e2       	ldi	r24, 0x23	; 35
    1f2a:	90 e0       	ldi	r25, 0x00	; 0
    1f2c:	0e 94 a6 0b 	call	0x174c	; 0x174c <pvPortMalloc>
    1f30:	ec 01       	movw	r28, r24
    1f32:	89 2b       	or	r24, r25
    1f34:	c9 f0       	breq	.+50     	; 0x1f68 <xQueueGenericCreate+0x50>
    1f36:	10 9f       	mul	r17, r16
    1f38:	c0 01       	movw	r24, r0
    1f3a:	11 24       	eor	r1, r1
    1f3c:	01 96       	adiw	r24, 0x01	; 1
    1f3e:	0e 94 a6 0b 	call	0x174c	; 0x174c <pvPortMalloc>
    1f42:	88 83       	st	Y, r24
    1f44:	99 83       	std	Y+1, r25	; 0x01
    1f46:	89 2b       	or	r24, r25
    1f48:	39 f0       	breq	.+14     	; 0x1f58 <xQueueGenericCreate+0x40>
    1f4a:	1f 8f       	std	Y+31, r17	; 0x1f
    1f4c:	08 a3       	std	Y+32, r16	; 0x20
    1f4e:	61 e0       	ldi	r22, 0x01	; 1
    1f50:	ce 01       	movw	r24, r28
    1f52:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <xQueueGenericReset>
    1f56:	08 c0       	rjmp	.+16     	; 0x1f68 <xQueueGenericCreate+0x50>
    1f58:	ce 01       	movw	r24, r28
    1f5a:	0e 94 40 0c 	call	0x1880	; 0x1880 <vPortFree>
    1f5e:	c0 e0       	ldi	r28, 0x00	; 0
    1f60:	d0 e0       	ldi	r29, 0x00	; 0
    1f62:	02 c0       	rjmp	.+4      	; 0x1f68 <xQueueGenericCreate+0x50>
    1f64:	c0 e0       	ldi	r28, 0x00	; 0
    1f66:	d0 e0       	ldi	r29, 0x00	; 0
    1f68:	ce 01       	movw	r24, r28
    1f6a:	df 91       	pop	r29
    1f6c:	cf 91       	pop	r28
    1f6e:	1f 91       	pop	r17
    1f70:	0f 91       	pop	r16
    1f72:	08 95       	ret

00001f74 <xQueueGenericSend>:
    1f74:	af 92       	push	r10
    1f76:	bf 92       	push	r11
    1f78:	cf 92       	push	r12
    1f7a:	df 92       	push	r13
    1f7c:	ef 92       	push	r14
    1f7e:	ff 92       	push	r15
    1f80:	0f 93       	push	r16
    1f82:	1f 93       	push	r17
    1f84:	cf 93       	push	r28
    1f86:	df 93       	push	r29
    1f88:	cd b7       	in	r28, 0x3d	; 61
    1f8a:	de b7       	in	r29, 0x3e	; 62
    1f8c:	29 97       	sbiw	r28, 0x09	; 9
    1f8e:	cd bf       	out	0x3d, r28	; 61
    1f90:	de bf       	out	0x3e, r29	; 62
    1f92:	7c 01       	movw	r14, r24
    1f94:	5b 01       	movw	r10, r22
    1f96:	2e 83       	std	Y+6, r18	; 0x06
    1f98:	3f 83       	std	Y+7, r19	; 0x07
    1f9a:	48 87       	std	Y+8, r20	; 0x08
    1f9c:	59 87       	std	Y+9, r21	; 0x09
    1f9e:	10 e0       	ldi	r17, 0x00	; 0
    1fa0:	6c 01       	movw	r12, r24
    1fa2:	88 e0       	ldi	r24, 0x08	; 8
    1fa4:	c8 0e       	add	r12, r24
    1fa6:	d1 1c       	adc	r13, r1
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	0f 92       	push	r0
    1fae:	f7 01       	movw	r30, r14
    1fb0:	96 8d       	ldd	r25, Z+30	; 0x1e
    1fb2:	87 8d       	ldd	r24, Z+31	; 0x1f
    1fb4:	98 17       	cp	r25, r24
    1fb6:	a8 f4       	brcc	.+42     	; 0x1fe2 <xQueueGenericSend+0x6e>
    1fb8:	40 2f       	mov	r20, r16
    1fba:	b5 01       	movw	r22, r10
    1fbc:	c7 01       	movw	r24, r14
    1fbe:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <prvCopyDataToQueue>
    1fc2:	f7 01       	movw	r30, r14
    1fc4:	83 89       	ldd	r24, Z+19	; 0x13
    1fc6:	88 23       	and	r24, r24
    1fc8:	41 f0       	breq	.+16     	; 0x1fda <xQueueGenericSend+0x66>
    1fca:	c7 01       	movw	r24, r14
    1fcc:	43 96       	adiw	r24, 0x13	; 19
    1fce:	0e 94 80 15 	call	0x2b00	; 0x2b00 <xTaskRemoveFromEventList>
    1fd2:	81 30       	cpi	r24, 0x01	; 1
    1fd4:	11 f4       	brne	.+4      	; 0x1fda <xQueueGenericSend+0x66>
    1fd6:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
    1fda:	0f 90       	pop	r0
    1fdc:	0f be       	out	0x3f, r0	; 63
    1fde:	81 e0       	ldi	r24, 0x01	; 1
    1fe0:	56 c0       	rjmp	.+172    	; 0x208e <xQueueGenericSend+0x11a>
    1fe2:	8e 81       	ldd	r24, Y+6	; 0x06
    1fe4:	9f 81       	ldd	r25, Y+7	; 0x07
    1fe6:	a8 85       	ldd	r26, Y+8	; 0x08
    1fe8:	b9 85       	ldd	r27, Y+9	; 0x09
    1fea:	89 2b       	or	r24, r25
    1fec:	8a 2b       	or	r24, r26
    1fee:	8b 2b       	or	r24, r27
    1ff0:	21 f4       	brne	.+8      	; 0x1ffa <xQueueGenericSend+0x86>
    1ff2:	0f 90       	pop	r0
    1ff4:	0f be       	out	0x3f, r0	; 63
    1ff6:	80 e0       	ldi	r24, 0x00	; 0
    1ff8:	4a c0       	rjmp	.+148    	; 0x208e <xQueueGenericSend+0x11a>
    1ffa:	11 11       	cpse	r17, r1
    1ffc:	05 c0       	rjmp	.+10     	; 0x2008 <xQueueGenericSend+0x94>
    1ffe:	ce 01       	movw	r24, r28
    2000:	01 96       	adiw	r24, 0x01	; 1
    2002:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <vTaskSetTimeOutState>
    2006:	11 e0       	ldi	r17, 0x01	; 1
    2008:	0f 90       	pop	r0
    200a:	0f be       	out	0x3f, r0	; 63
    200c:	0e 94 ba 12 	call	0x2574	; 0x2574 <vTaskSuspendAll>
    2010:	0f b6       	in	r0, 0x3f	; 63
    2012:	f8 94       	cli
    2014:	0f 92       	push	r0
    2016:	f7 01       	movw	r30, r14
    2018:	81 a1       	ldd	r24, Z+33	; 0x21
    201a:	8f 3f       	cpi	r24, 0xFF	; 255
    201c:	09 f4       	brne	.+2      	; 0x2020 <xQueueGenericSend+0xac>
    201e:	11 a2       	std	Z+33, r1	; 0x21
    2020:	f7 01       	movw	r30, r14
    2022:	82 a1       	ldd	r24, Z+34	; 0x22
    2024:	8f 3f       	cpi	r24, 0xFF	; 255
    2026:	09 f4       	brne	.+2      	; 0x202a <xQueueGenericSend+0xb6>
    2028:	12 a2       	std	Z+34, r1	; 0x22
    202a:	0f 90       	pop	r0
    202c:	0f be       	out	0x3f, r0	; 63
    202e:	be 01       	movw	r22, r28
    2030:	6a 5f       	subi	r22, 0xFA	; 250
    2032:	7f 4f       	sbci	r23, 0xFF	; 255
    2034:	ce 01       	movw	r24, r28
    2036:	01 96       	adiw	r24, 0x01	; 1
    2038:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <xTaskCheckForTimeOut>
    203c:	81 11       	cpse	r24, r1
    203e:	21 c0       	rjmp	.+66     	; 0x2082 <xQueueGenericSend+0x10e>
    2040:	0f b6       	in	r0, 0x3f	; 63
    2042:	f8 94       	cli
    2044:	0f 92       	push	r0
    2046:	f7 01       	movw	r30, r14
    2048:	96 8d       	ldd	r25, Z+30	; 0x1e
    204a:	0f 90       	pop	r0
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	87 8d       	ldd	r24, Z+31	; 0x1f
    2050:	98 13       	cpse	r25, r24
    2052:	11 c0       	rjmp	.+34     	; 0x2076 <xQueueGenericSend+0x102>
    2054:	4e 81       	ldd	r20, Y+6	; 0x06
    2056:	5f 81       	ldd	r21, Y+7	; 0x07
    2058:	68 85       	ldd	r22, Y+8	; 0x08
    205a:	79 85       	ldd	r23, Y+9	; 0x09
    205c:	c6 01       	movw	r24, r12
    205e:	0e 94 56 15 	call	0x2aac	; 0x2aac <vTaskPlaceOnEventList>
    2062:	c7 01       	movw	r24, r14
    2064:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <prvUnlockQueue>
    2068:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    206c:	81 11       	cpse	r24, r1
    206e:	9c cf       	rjmp	.-200    	; 0x1fa8 <xQueueGenericSend+0x34>
    2070:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
    2074:	99 cf       	rjmp	.-206    	; 0x1fa8 <xQueueGenericSend+0x34>
    2076:	c7 01       	movw	r24, r14
    2078:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <prvUnlockQueue>
    207c:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    2080:	93 cf       	rjmp	.-218    	; 0x1fa8 <xQueueGenericSend+0x34>
    2082:	c7 01       	movw	r24, r14
    2084:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <prvUnlockQueue>
    2088:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    208c:	80 e0       	ldi	r24, 0x00	; 0
    208e:	29 96       	adiw	r28, 0x09	; 9
    2090:	cd bf       	out	0x3d, r28	; 61
    2092:	de bf       	out	0x3e, r29	; 62
    2094:	df 91       	pop	r29
    2096:	cf 91       	pop	r28
    2098:	1f 91       	pop	r17
    209a:	0f 91       	pop	r16
    209c:	ff 90       	pop	r15
    209e:	ef 90       	pop	r14
    20a0:	df 90       	pop	r13
    20a2:	cf 90       	pop	r12
    20a4:	bf 90       	pop	r11
    20a6:	af 90       	pop	r10
    20a8:	08 95       	ret

000020aa <xQueueGenericReceive>:
    20aa:	af 92       	push	r10
    20ac:	bf 92       	push	r11
    20ae:	cf 92       	push	r12
    20b0:	df 92       	push	r13
    20b2:	ef 92       	push	r14
    20b4:	ff 92       	push	r15
    20b6:	0f 93       	push	r16
    20b8:	1f 93       	push	r17
    20ba:	cf 93       	push	r28
    20bc:	df 93       	push	r29
    20be:	cd b7       	in	r28, 0x3d	; 61
    20c0:	de b7       	in	r29, 0x3e	; 62
    20c2:	29 97       	sbiw	r28, 0x09	; 9
    20c4:	cd bf       	out	0x3d, r28	; 61
    20c6:	de bf       	out	0x3e, r29	; 62
    20c8:	7c 01       	movw	r14, r24
    20ca:	5b 01       	movw	r10, r22
    20cc:	2e 83       	std	Y+6, r18	; 0x06
    20ce:	3f 83       	std	Y+7, r19	; 0x07
    20d0:	48 87       	std	Y+8, r20	; 0x08
    20d2:	59 87       	std	Y+9, r21	; 0x09
    20d4:	10 e0       	ldi	r17, 0x00	; 0
    20d6:	6c 01       	movw	r12, r24
    20d8:	83 e1       	ldi	r24, 0x13	; 19
    20da:	c8 0e       	add	r12, r24
    20dc:	d1 1c       	adc	r13, r1
    20de:	0f b6       	in	r0, 0x3f	; 63
    20e0:	f8 94       	cli
    20e2:	0f 92       	push	r0
    20e4:	f7 01       	movw	r30, r14
    20e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    20e8:	88 23       	and	r24, r24
    20ea:	99 f1       	breq	.+102    	; 0x2152 <xQueueGenericReceive+0xa8>
    20ec:	c6 80       	ldd	r12, Z+6	; 0x06
    20ee:	d7 80       	ldd	r13, Z+7	; 0x07
    20f0:	b5 01       	movw	r22, r10
    20f2:	c7 01       	movw	r24, r14
    20f4:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <prvCopyDataFromQueue>
    20f8:	01 11       	cpse	r16, r1
    20fa:	1a c0       	rjmp	.+52     	; 0x2130 <xQueueGenericReceive+0x86>
    20fc:	f7 01       	movw	r30, r14
    20fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    2100:	81 50       	subi	r24, 0x01	; 1
    2102:	86 8f       	std	Z+30, r24	; 0x1e
    2104:	80 81       	ld	r24, Z
    2106:	91 81       	ldd	r25, Z+1	; 0x01
    2108:	89 2b       	or	r24, r25
    210a:	29 f4       	brne	.+10     	; 0x2116 <xQueueGenericReceive+0x6c>
    210c:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <xTaskGetCurrentTaskHandle>
    2110:	f7 01       	movw	r30, r14
    2112:	82 83       	std	Z+2, r24	; 0x02
    2114:	93 83       	std	Z+3, r25	; 0x03
    2116:	f7 01       	movw	r30, r14
    2118:	80 85       	ldd	r24, Z+8	; 0x08
    211a:	88 23       	and	r24, r24
    211c:	b1 f0       	breq	.+44     	; 0x214a <xQueueGenericReceive+0xa0>
    211e:	c7 01       	movw	r24, r14
    2120:	08 96       	adiw	r24, 0x08	; 8
    2122:	0e 94 80 15 	call	0x2b00	; 0x2b00 <xTaskRemoveFromEventList>
    2126:	81 30       	cpi	r24, 0x01	; 1
    2128:	81 f4       	brne	.+32     	; 0x214a <xQueueGenericReceive+0xa0>
    212a:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
    212e:	0d c0       	rjmp	.+26     	; 0x214a <xQueueGenericReceive+0xa0>
    2130:	f7 01       	movw	r30, r14
    2132:	c6 82       	std	Z+6, r12	; 0x06
    2134:	d7 82       	std	Z+7, r13	; 0x07
    2136:	83 89       	ldd	r24, Z+19	; 0x13
    2138:	88 23       	and	r24, r24
    213a:	39 f0       	breq	.+14     	; 0x214a <xQueueGenericReceive+0xa0>
    213c:	c7 01       	movw	r24, r14
    213e:	43 96       	adiw	r24, 0x13	; 19
    2140:	0e 94 80 15 	call	0x2b00	; 0x2b00 <xTaskRemoveFromEventList>
    2144:	81 11       	cpse	r24, r1
    2146:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
    214a:	0f 90       	pop	r0
    214c:	0f be       	out	0x3f, r0	; 63
    214e:	81 e0       	ldi	r24, 0x01	; 1
    2150:	62 c0       	rjmp	.+196    	; 0x2216 <xQueueGenericReceive+0x16c>
    2152:	8e 81       	ldd	r24, Y+6	; 0x06
    2154:	9f 81       	ldd	r25, Y+7	; 0x07
    2156:	a8 85       	ldd	r26, Y+8	; 0x08
    2158:	b9 85       	ldd	r27, Y+9	; 0x09
    215a:	89 2b       	or	r24, r25
    215c:	8a 2b       	or	r24, r26
    215e:	8b 2b       	or	r24, r27
    2160:	21 f4       	brne	.+8      	; 0x216a <xQueueGenericReceive+0xc0>
    2162:	0f 90       	pop	r0
    2164:	0f be       	out	0x3f, r0	; 63
    2166:	80 e0       	ldi	r24, 0x00	; 0
    2168:	56 c0       	rjmp	.+172    	; 0x2216 <xQueueGenericReceive+0x16c>
    216a:	11 11       	cpse	r17, r1
    216c:	05 c0       	rjmp	.+10     	; 0x2178 <xQueueGenericReceive+0xce>
    216e:	ce 01       	movw	r24, r28
    2170:	01 96       	adiw	r24, 0x01	; 1
    2172:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <vTaskSetTimeOutState>
    2176:	11 e0       	ldi	r17, 0x01	; 1
    2178:	0f 90       	pop	r0
    217a:	0f be       	out	0x3f, r0	; 63
    217c:	0e 94 ba 12 	call	0x2574	; 0x2574 <vTaskSuspendAll>
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	f8 94       	cli
    2184:	0f 92       	push	r0
    2186:	f7 01       	movw	r30, r14
    2188:	81 a1       	ldd	r24, Z+33	; 0x21
    218a:	8f 3f       	cpi	r24, 0xFF	; 255
    218c:	09 f4       	brne	.+2      	; 0x2190 <xQueueGenericReceive+0xe6>
    218e:	11 a2       	std	Z+33, r1	; 0x21
    2190:	f7 01       	movw	r30, r14
    2192:	82 a1       	ldd	r24, Z+34	; 0x22
    2194:	8f 3f       	cpi	r24, 0xFF	; 255
    2196:	09 f4       	brne	.+2      	; 0x219a <xQueueGenericReceive+0xf0>
    2198:	12 a2       	std	Z+34, r1	; 0x22
    219a:	0f 90       	pop	r0
    219c:	0f be       	out	0x3f, r0	; 63
    219e:	be 01       	movw	r22, r28
    21a0:	6a 5f       	subi	r22, 0xFA	; 250
    21a2:	7f 4f       	sbci	r23, 0xFF	; 255
    21a4:	ce 01       	movw	r24, r28
    21a6:	01 96       	adiw	r24, 0x01	; 1
    21a8:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <xTaskCheckForTimeOut>
    21ac:	81 11       	cpse	r24, r1
    21ae:	2d c0       	rjmp	.+90     	; 0x220a <xQueueGenericReceive+0x160>
    21b0:	0f b6       	in	r0, 0x3f	; 63
    21b2:	f8 94       	cli
    21b4:	0f 92       	push	r0
    21b6:	f7 01       	movw	r30, r14
    21b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    21ba:	0f 90       	pop	r0
    21bc:	0f be       	out	0x3f, r0	; 63
    21be:	81 11       	cpse	r24, r1
    21c0:	1e c0       	rjmp	.+60     	; 0x21fe <xQueueGenericReceive+0x154>
    21c2:	80 81       	ld	r24, Z
    21c4:	91 81       	ldd	r25, Z+1	; 0x01
    21c6:	89 2b       	or	r24, r25
    21c8:	49 f4       	brne	.+18     	; 0x21dc <xQueueGenericReceive+0x132>
    21ca:	0f b6       	in	r0, 0x3f	; 63
    21cc:	f8 94       	cli
    21ce:	0f 92       	push	r0
    21d0:	82 81       	ldd	r24, Z+2	; 0x02
    21d2:	93 81       	ldd	r25, Z+3	; 0x03
    21d4:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <vTaskPriorityInherit>
    21d8:	0f 90       	pop	r0
    21da:	0f be       	out	0x3f, r0	; 63
    21dc:	4e 81       	ldd	r20, Y+6	; 0x06
    21de:	5f 81       	ldd	r21, Y+7	; 0x07
    21e0:	68 85       	ldd	r22, Y+8	; 0x08
    21e2:	79 85       	ldd	r23, Y+9	; 0x09
    21e4:	c6 01       	movw	r24, r12
    21e6:	0e 94 56 15 	call	0x2aac	; 0x2aac <vTaskPlaceOnEventList>
    21ea:	c7 01       	movw	r24, r14
    21ec:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <prvUnlockQueue>
    21f0:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    21f4:	81 11       	cpse	r24, r1
    21f6:	73 cf       	rjmp	.-282    	; 0x20de <xQueueGenericReceive+0x34>
    21f8:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
    21fc:	70 cf       	rjmp	.-288    	; 0x20de <xQueueGenericReceive+0x34>
    21fe:	c7 01       	movw	r24, r14
    2200:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <prvUnlockQueue>
    2204:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    2208:	6a cf       	rjmp	.-300    	; 0x20de <xQueueGenericReceive+0x34>
    220a:	c7 01       	movw	r24, r14
    220c:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <prvUnlockQueue>
    2210:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
    2214:	80 e0       	ldi	r24, 0x00	; 0
    2216:	29 96       	adiw	r28, 0x09	; 9
    2218:	cd bf       	out	0x3d, r28	; 61
    221a:	de bf       	out	0x3e, r29	; 62
    221c:	df 91       	pop	r29
    221e:	cf 91       	pop	r28
    2220:	1f 91       	pop	r17
    2222:	0f 91       	pop	r16
    2224:	ff 90       	pop	r15
    2226:	ef 90       	pop	r14
    2228:	df 90       	pop	r13
    222a:	cf 90       	pop	r12
    222c:	bf 90       	pop	r11
    222e:	af 90       	pop	r10
    2230:	08 95       	ret

00002232 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2232:	0f b6       	in	r0, 0x3f	; 63
    2234:	f8 94       	cli
    2236:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2238:	fc 01       	movw	r30, r24
    223a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    223c:	0f 90       	pop	r0
    223e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2240:	08 95       	ret

00002242 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    2242:	cc ee       	ldi	r28, 0xEC	; 236
    2244:	d0 e3       	ldi	r29, 0x30	; 48
    2246:	88 81       	ld	r24, Y
    2248:	82 30       	cpi	r24, 0x02	; 2
    224a:	e8 f3       	brcs	.-6      	; 0x2246 <prvIdleTask+0x4>
    224c:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
    2250:	fa cf       	rjmp	.-12     	; 0x2246 <prvIdleTask+0x4>

00002252 <prvAddCurrentTaskToDelayedList>:
    2252:	cf 92       	push	r12
    2254:	df 92       	push	r13
    2256:	ef 92       	push	r14
    2258:	ff 92       	push	r15
    225a:	6b 01       	movw	r12, r22
    225c:	7c 01       	movw	r14, r24
    225e:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2262:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2266:	62 83       	std	Z+2, r22	; 0x02
    2268:	73 83       	std	Z+3, r23	; 0x03
    226a:	84 83       	std	Z+4, r24	; 0x04
    226c:	95 83       	std	Z+5, r25	; 0x05
    226e:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2272:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2276:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    227a:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    227e:	c8 16       	cp	r12, r24
    2280:	d9 06       	cpc	r13, r25
    2282:	ea 06       	cpc	r14, r26
    2284:	fb 06       	cpc	r15, r27
    2286:	68 f4       	brcc	.+26     	; 0x22a2 <prvAddCurrentTaskToDelayedList+0x50>
    2288:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    228c:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2290:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    2294:	90 91 d3 30 	lds	r25, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    2298:	6e 5f       	subi	r22, 0xFE	; 254
    229a:	7f 4f       	sbci	r23, 0xFF	; 255
    229c:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListInsert>
    22a0:	21 c0       	rjmp	.+66     	; 0x22e4 <prvAddCurrentTaskToDelayedList+0x92>
    22a2:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    22a6:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    22aa:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    22ae:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    22b2:	6e 5f       	subi	r22, 0xFE	; 254
    22b4:	7f 4f       	sbci	r23, 0xFF	; 255
    22b6:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListInsert>
    22ba:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    22be:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    22c2:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    22c6:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    22ca:	c8 16       	cp	r12, r24
    22cc:	d9 06       	cpc	r13, r25
    22ce:	ea 06       	cpc	r14, r26
    22d0:	fb 06       	cpc	r15, r27
    22d2:	40 f4       	brcc	.+16     	; 0x22e4 <prvAddCurrentTaskToDelayedList+0x92>
    22d4:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    22d8:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    22dc:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    22e0:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    22e4:	ff 90       	pop	r15
    22e6:	ef 90       	pop	r14
    22e8:	df 90       	pop	r13
    22ea:	cf 90       	pop	r12
    22ec:	08 95       	ret

000022ee <xTaskGenericCreate>:
    22ee:	4f 92       	push	r4
    22f0:	5f 92       	push	r5
    22f2:	6f 92       	push	r6
    22f4:	7f 92       	push	r7
    22f6:	8f 92       	push	r8
    22f8:	9f 92       	push	r9
    22fa:	af 92       	push	r10
    22fc:	bf 92       	push	r11
    22fe:	cf 92       	push	r12
    2300:	df 92       	push	r13
    2302:	ef 92       	push	r14
    2304:	ff 92       	push	r15
    2306:	0f 93       	push	r16
    2308:	1f 93       	push	r17
    230a:	cf 93       	push	r28
    230c:	df 93       	push	r29
    230e:	5c 01       	movw	r10, r24
    2310:	4b 01       	movw	r8, r22
    2312:	3a 01       	movw	r6, r20
    2314:	29 01       	movw	r4, r18
    2316:	88 e2       	ldi	r24, 0x28	; 40
    2318:	90 e0       	ldi	r25, 0x00	; 0
    231a:	0e 94 a6 0b 	call	0x174c	; 0x174c <pvPortMalloc>
    231e:	ec 01       	movw	r28, r24
    2320:	89 2b       	or	r24, r25
    2322:	09 f4       	brne	.+2      	; 0x2326 <xTaskGenericCreate+0x38>
    2324:	d4 c0       	rjmp	.+424    	; 0x24ce <xTaskGenericCreate+0x1e0>
    2326:	c1 14       	cp	r12, r1
    2328:	d1 04       	cpc	r13, r1
    232a:	09 f0       	breq	.+2      	; 0x232e <xTaskGenericCreate+0x40>
    232c:	cc c0       	rjmp	.+408    	; 0x24c6 <xTaskGenericCreate+0x1d8>
    232e:	c3 01       	movw	r24, r6
    2330:	0e 94 a6 0b 	call	0x174c	; 0x174c <pvPortMalloc>
    2334:	8b 8f       	std	Y+27, r24	; 0x1b
    2336:	9c 8f       	std	Y+28, r25	; 0x1c
    2338:	00 97       	sbiw	r24, 0x00	; 0
    233a:	21 f4       	brne	.+8      	; 0x2344 <xTaskGenericCreate+0x56>
    233c:	ce 01       	movw	r24, r28
    233e:	0e 94 40 0c 	call	0x1880	; 0x1880 <vPortFree>
    2342:	c5 c0       	rjmp	.+394    	; 0x24ce <xTaskGenericCreate+0x1e0>
    2344:	a3 01       	movw	r20, r6
    2346:	61 e1       	ldi	r22, 0x11	; 17
    2348:	70 e0       	ldi	r23, 0x00	; 0
    234a:	0e 94 35 22 	call	0x446a	; 0x446a <memset>
    234e:	93 01       	movw	r18, r6
    2350:	21 50       	subi	r18, 0x01	; 1
    2352:	31 09       	sbc	r19, r1
    2354:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2356:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2358:	3c 01       	movw	r6, r24
    235a:	62 0e       	add	r6, r18
    235c:	73 1e       	adc	r7, r19
    235e:	4a e0       	ldi	r20, 0x0A	; 10
    2360:	50 e0       	ldi	r21, 0x00	; 0
    2362:	b4 01       	movw	r22, r8
    2364:	ce 01       	movw	r24, r28
    2366:	4d 96       	adiw	r24, 0x1d	; 29
    2368:	0e 94 3c 22 	call	0x4478	; 0x4478 <strncpy>
    236c:	1e a2       	std	Y+38, r1	; 0x26
    236e:	10 2f       	mov	r17, r16
    2370:	04 30       	cpi	r16, 0x04	; 4
    2372:	08 f0       	brcs	.+2      	; 0x2376 <xTaskGenericCreate+0x88>
    2374:	13 e0       	ldi	r17, 0x03	; 3
    2376:	1a 8f       	std	Y+26, r17	; 0x1a
    2378:	1f a3       	std	Y+39, r17	; 0x27
    237a:	6e 01       	movw	r12, r28
    237c:	22 e0       	ldi	r18, 0x02	; 2
    237e:	c2 0e       	add	r12, r18
    2380:	d1 1c       	adc	r13, r1
    2382:	c6 01       	movw	r24, r12
    2384:	0e 94 89 0c 	call	0x1912	; 0x1912 <vListInitialiseItem>
    2388:	ce 01       	movw	r24, r28
    238a:	0e 96       	adiw	r24, 0x0e	; 14
    238c:	0e 94 89 0c 	call	0x1912	; 0x1912 <vListInitialiseItem>
    2390:	ca 87       	std	Y+10, r28	; 0x0a
    2392:	db 87       	std	Y+11, r29	; 0x0b
    2394:	84 e0       	ldi	r24, 0x04	; 4
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	a0 e0       	ldi	r26, 0x00	; 0
    239a:	b0 e0       	ldi	r27, 0x00	; 0
    239c:	81 1b       	sub	r24, r17
    239e:	91 09       	sbc	r25, r1
    23a0:	a1 09       	sbc	r26, r1
    23a2:	b1 09       	sbc	r27, r1
    23a4:	8e 87       	std	Y+14, r24	; 0x0e
    23a6:	9f 87       	std	Y+15, r25	; 0x0f
    23a8:	a8 8b       	std	Y+16, r26	; 0x10
    23aa:	b9 8b       	std	Y+17, r27	; 0x11
    23ac:	ce 8b       	std	Y+22, r28	; 0x16
    23ae:	df 8b       	std	Y+23, r29	; 0x17
    23b0:	a2 01       	movw	r20, r4
    23b2:	b5 01       	movw	r22, r10
    23b4:	c3 01       	movw	r24, r6
    23b6:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <pxPortInitialiseStack>
    23ba:	88 83       	st	Y, r24
    23bc:	99 83       	std	Y+1, r25	; 0x01
    23be:	e1 14       	cp	r14, r1
    23c0:	f1 04       	cpc	r15, r1
    23c2:	19 f0       	breq	.+6      	; 0x23ca <xTaskGenericCreate+0xdc>
    23c4:	f7 01       	movw	r30, r14
    23c6:	c0 83       	st	Z, r28
    23c8:	d1 83       	std	Z+1, r29	; 0x01
    23ca:	0f b6       	in	r0, 0x3f	; 63
    23cc:	f8 94       	cli
    23ce:	0f 92       	push	r0
    23d0:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    23d4:	8f 5f       	subi	r24, 0xFF	; 255
    23d6:	80 93 c4 30 	sts	0x30C4, r24	; 0x8030c4 <uxCurrentNumberOfTasks>
    23da:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    23de:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    23e2:	89 2b       	or	r24, r25
    23e4:	89 f5       	brne	.+98     	; 0x2448 <xTaskGenericCreate+0x15a>
    23e6:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    23ea:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    23ee:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    23f2:	81 30       	cpi	r24, 0x01	; 1
    23f4:	c1 f5       	brne	.+112    	; 0x2466 <xTaskGenericCreate+0x178>
    23f6:	8c ee       	ldi	r24, 0xEC	; 236
    23f8:	90 e3       	ldi	r25, 0x30	; 48
    23fa:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    23fe:	87 ef       	ldi	r24, 0xF7	; 247
    2400:	90 e3       	ldi	r25, 0x30	; 48
    2402:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    2406:	82 e0       	ldi	r24, 0x02	; 2
    2408:	91 e3       	ldi	r25, 0x31	; 49
    240a:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    240e:	8d e0       	ldi	r24, 0x0D	; 13
    2410:	91 e3       	ldi	r25, 0x31	; 49
    2412:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    2416:	81 ee       	ldi	r24, 0xE1	; 225
    2418:	90 e3       	ldi	r25, 0x30	; 48
    241a:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    241e:	86 ed       	ldi	r24, 0xD6	; 214
    2420:	90 e3       	ldi	r25, 0x30	; 48
    2422:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    2426:	87 ec       	ldi	r24, 0xC7	; 199
    2428:	90 e3       	ldi	r25, 0x30	; 48
    242a:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vListInitialise>
    242e:	81 ee       	ldi	r24, 0xE1	; 225
    2430:	90 e3       	ldi	r25, 0x30	; 48
    2432:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <pxDelayedTaskList>
    2436:	90 93 d5 30 	sts	0x30D5, r25	; 0x8030d5 <pxDelayedTaskList+0x1>
    243a:	86 ed       	ldi	r24, 0xD6	; 214
    243c:	90 e3       	ldi	r25, 0x30	; 48
    243e:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    2442:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    2446:	0f c0       	rjmp	.+30     	; 0x2466 <xTaskGenericCreate+0x178>
    2448:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    244c:	81 11       	cpse	r24, r1
    244e:	0b c0       	rjmp	.+22     	; 0x2466 <xTaskGenericCreate+0x178>
    2450:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2454:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2458:	82 8d       	ldd	r24, Z+26	; 0x1a
    245a:	08 17       	cp	r16, r24
    245c:	20 f0       	brcs	.+8      	; 0x2466 <xTaskGenericCreate+0x178>
    245e:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    2462:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    2466:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2468:	90 91 bf 30 	lds	r25, 0x30BF	; 0x8030bf <uxTopUsedPriority>
    246c:	98 17       	cp	r25, r24
    246e:	10 f4       	brcc	.+4      	; 0x2474 <xTaskGenericCreate+0x186>
    2470:	80 93 bf 30 	sts	0x30BF, r24	; 0x8030bf <uxTopUsedPriority>
    2474:	90 91 b8 30 	lds	r25, 0x30B8	; 0x8030b8 <uxTaskNumber>
    2478:	9f 5f       	subi	r25, 0xFF	; 255
    247a:	90 93 b8 30 	sts	0x30B8, r25	; 0x8030b8 <uxTaskNumber>
    247e:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2482:	98 17       	cp	r25, r24
    2484:	10 f4       	brcc	.+4      	; 0x248a <xTaskGenericCreate+0x19c>
    2486:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    248a:	fb e0       	ldi	r31, 0x0B	; 11
    248c:	8f 9f       	mul	r24, r31
    248e:	c0 01       	movw	r24, r0
    2490:	11 24       	eor	r1, r1
    2492:	b6 01       	movw	r22, r12
    2494:	84 51       	subi	r24, 0x14	; 20
    2496:	9f 4c       	sbci	r25, 0xCF	; 207
    2498:	0e 94 8d 0c 	call	0x191a	; 0x191a <vListInsertEnd>
    249c:	0f 90       	pop	r0
    249e:	0f be       	out	0x3f, r0	; 63
    24a0:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    24a4:	88 23       	and	r24, r24
    24a6:	59 f0       	breq	.+22     	; 0x24be <xTaskGenericCreate+0x1d0>
    24a8:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    24ac:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    24b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    24b2:	80 17       	cp	r24, r16
    24b4:	30 f4       	brcc	.+12     	; 0x24c2 <xTaskGenericCreate+0x1d4>
    24b6:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
    24ba:	81 e0       	ldi	r24, 0x01	; 1
    24bc:	09 c0       	rjmp	.+18     	; 0x24d0 <xTaskGenericCreate+0x1e2>
    24be:	81 e0       	ldi	r24, 0x01	; 1
    24c0:	07 c0       	rjmp	.+14     	; 0x24d0 <xTaskGenericCreate+0x1e2>
    24c2:	81 e0       	ldi	r24, 0x01	; 1
    24c4:	05 c0       	rjmp	.+10     	; 0x24d0 <xTaskGenericCreate+0x1e2>
    24c6:	cb 8e       	std	Y+27, r12	; 0x1b
    24c8:	dc 8e       	std	Y+28, r13	; 0x1c
    24ca:	c6 01       	movw	r24, r12
    24cc:	3b cf       	rjmp	.-394    	; 0x2344 <xTaskGenericCreate+0x56>
    24ce:	8f ef       	ldi	r24, 0xFF	; 255
    24d0:	df 91       	pop	r29
    24d2:	cf 91       	pop	r28
    24d4:	1f 91       	pop	r17
    24d6:	0f 91       	pop	r16
    24d8:	ff 90       	pop	r15
    24da:	ef 90       	pop	r14
    24dc:	df 90       	pop	r13
    24de:	cf 90       	pop	r12
    24e0:	bf 90       	pop	r11
    24e2:	af 90       	pop	r10
    24e4:	9f 90       	pop	r9
    24e6:	8f 90       	pop	r8
    24e8:	7f 90       	pop	r7
    24ea:	6f 90       	pop	r6
    24ec:	5f 90       	pop	r5
    24ee:	4f 90       	pop	r4
    24f0:	08 95       	ret

000024f2 <uxTaskPriorityGet>:
    24f2:	0f b6       	in	r0, 0x3f	; 63
    24f4:	f8 94       	cli
    24f6:	0f 92       	push	r0
    24f8:	00 97       	sbiw	r24, 0x00	; 0
    24fa:	21 f4       	brne	.+8      	; 0x2504 <uxTaskPriorityGet+0x12>
    24fc:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2500:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2504:	0f 90       	pop	r0
    2506:	0f be       	out	0x3f, r0	; 63
    2508:	fc 01       	movw	r30, r24
    250a:	82 8d       	ldd	r24, Z+26	; 0x1a
    250c:	08 95       	ret

0000250e <vTaskStartScheduler>:
    250e:	af 92       	push	r10
    2510:	bf 92       	push	r11
    2512:	cf 92       	push	r12
    2514:	df 92       	push	r13
    2516:	ef 92       	push	r14
    2518:	ff 92       	push	r15
    251a:	0f 93       	push	r16
    251c:	a1 2c       	mov	r10, r1
    251e:	b1 2c       	mov	r11, r1
    2520:	c1 2c       	mov	r12, r1
    2522:	d1 2c       	mov	r13, r1
    2524:	0f 2e       	mov	r0, r31
    2526:	f5 ec       	ldi	r31, 0xC5	; 197
    2528:	ef 2e       	mov	r14, r31
    252a:	f0 e3       	ldi	r31, 0x30	; 48
    252c:	ff 2e       	mov	r15, r31
    252e:	f0 2d       	mov	r31, r0
    2530:	00 e0       	ldi	r16, 0x00	; 0
    2532:	20 e0       	ldi	r18, 0x00	; 0
    2534:	30 e0       	ldi	r19, 0x00	; 0
    2536:	44 e6       	ldi	r20, 0x64	; 100
    2538:	50 e0       	ldi	r21, 0x00	; 0
    253a:	6e e2       	ldi	r22, 0x2E	; 46
    253c:	70 e2       	ldi	r23, 0x20	; 32
    253e:	81 e2       	ldi	r24, 0x21	; 33
    2540:	91 e1       	ldi	r25, 0x11	; 17
    2542:	0e 94 77 11 	call	0x22ee	; 0x22ee <xTaskGenericCreate>
    2546:	81 30       	cpi	r24, 0x01	; 1
    2548:	69 f4       	brne	.+26     	; 0x2564 <vTaskStartScheduler+0x56>
    254a:	f8 94       	cli
    254c:	80 93 bd 30 	sts	0x30BD, r24	; 0x8030bd <xSchedulerRunning>
    2550:	10 92 c0 30 	sts	0x30C0, r1	; 0x8030c0 <xTickCount>
    2554:	10 92 c1 30 	sts	0x30C1, r1	; 0x8030c1 <xTickCount+0x1>
    2558:	10 92 c2 30 	sts	0x30C2, r1	; 0x8030c2 <xTickCount+0x2>
    255c:	10 92 c3 30 	sts	0x30C3, r1	; 0x8030c3 <xTickCount+0x3>
    2560:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <xPortStartScheduler>
    2564:	0f 91       	pop	r16
    2566:	ff 90       	pop	r15
    2568:	ef 90       	pop	r14
    256a:	df 90       	pop	r13
    256c:	cf 90       	pop	r12
    256e:	bf 90       	pop	r11
    2570:	af 90       	pop	r10
    2572:	08 95       	ret

00002574 <vTaskSuspendAll>:
    2574:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2578:	8f 5f       	subi	r24, 0xFF	; 255
    257a:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>
    257e:	08 95       	ret

00002580 <xTaskGetTickCount>:
    2580:	0f b6       	in	r0, 0x3f	; 63
    2582:	f8 94       	cli
    2584:	0f 92       	push	r0
    2586:	60 91 c0 30 	lds	r22, 0x30C0	; 0x8030c0 <xTickCount>
    258a:	70 91 c1 30 	lds	r23, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    258e:	80 91 c2 30 	lds	r24, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2592:	90 91 c3 30 	lds	r25, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2596:	0f 90       	pop	r0
    2598:	0f be       	out	0x3f, r0	; 63
    259a:	08 95       	ret

0000259c <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    259c:	00 97       	sbiw	r24, 0x00	; 0
    259e:	21 f4       	brne	.+8      	; 0x25a8 <pcTaskGetTaskName+0xc>
    25a0:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    25a4:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    25a8:	4d 96       	adiw	r24, 0x1d	; 29
    25aa:	08 95       	ret

000025ac <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    25ac:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xIdleTaskHandle>
    25b0:	90 91 c6 30 	lds	r25, 0x30C6	; 0x8030c6 <xIdleTaskHandle+0x1>
    25b4:	08 95       	ret

000025b6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    25b6:	ff 92       	push	r15
    25b8:	0f 93       	push	r16
    25ba:	1f 93       	push	r17
    25bc:	cf 93       	push	r28
    25be:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    25c0:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    25c4:	81 11       	cpse	r24, r1
    25c6:	ed c0       	rjmp	.+474    	; 0x27a2 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    25c8:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    25cc:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    25d0:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    25d4:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    25d8:	01 96       	adiw	r24, 0x01	; 1
    25da:	a1 1d       	adc	r26, r1
    25dc:	b1 1d       	adc	r27, r1
    25de:	80 93 c0 30 	sts	0x30C0, r24	; 0x8030c0 <xTickCount>
    25e2:	90 93 c1 30 	sts	0x30C1, r25	; 0x8030c1 <xTickCount+0x1>
    25e6:	a0 93 c2 30 	sts	0x30C2, r26	; 0x8030c2 <xTickCount+0x2>
    25ea:	b0 93 c3 30 	sts	0x30C3, r27	; 0x8030c3 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    25ee:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    25f2:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    25f6:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    25fa:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    25fe:	89 2b       	or	r24, r25
    2600:	8a 2b       	or	r24, r26
    2602:	8b 2b       	or	r24, r27
    2604:	f1 f5       	brne	.+124    	; 0x2682 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2606:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    260a:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    260e:	20 91 d2 30 	lds	r18, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    2612:	30 91 d3 30 	lds	r19, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    2616:	20 93 d4 30 	sts	0x30D4, r18	; 0x8030d4 <pxDelayedTaskList>
    261a:	30 93 d5 30 	sts	0x30D5, r19	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    261e:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    2622:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2626:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    262a:	8f 5f       	subi	r24, 0xFF	; 255
    262c:	80 93 b9 30 	sts	0x30B9, r24	; 0x8030b9 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2630:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2634:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2638:	80 81       	ld	r24, Z
    263a:	81 11       	cpse	r24, r1
    263c:	0c c0       	rjmp	.+24     	; 0x2656 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    263e:	8f ef       	ldi	r24, 0xFF	; 255
    2640:	9f ef       	ldi	r25, 0xFF	; 255
    2642:	dc 01       	movw	r26, r24
    2644:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2648:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    264c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2650:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2654:	16 c0       	rjmp	.+44     	; 0x2682 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2656:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    265a:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    265e:	07 80       	ldd	r0, Z+7	; 0x07
    2660:	f0 85       	ldd	r31, Z+8	; 0x08
    2662:	e0 2d       	mov	r30, r0
    2664:	00 84       	ldd	r0, Z+8	; 0x08
    2666:	f1 85       	ldd	r31, Z+9	; 0x09
    2668:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    266a:	82 81       	ldd	r24, Z+2	; 0x02
    266c:	93 81       	ldd	r25, Z+3	; 0x03
    266e:	a4 81       	ldd	r26, Z+4	; 0x04
    2670:	b5 81       	ldd	r27, Z+5	; 0x05
    2672:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2676:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    267a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    267e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2682:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    2686:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    268a:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    268e:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2692:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2696:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    269a:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    269e:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    26a2:	48 17       	cp	r20, r24
    26a4:	59 07       	cpc	r21, r25
    26a6:	6a 07       	cpc	r22, r26
    26a8:	7b 07       	cpc	r23, r27
    26aa:	08 f4       	brcc	.+2      	; 0x26ae <vTaskIncrementTick+0xf8>
    26ac:	7f c0       	rjmp	.+254    	; 0x27ac <vTaskIncrementTick+0x1f6>
    26ae:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    26b2:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    26b6:	80 81       	ld	r24, Z
    26b8:	88 23       	and	r24, r24
    26ba:	f9 f0       	breq	.+62     	; 0x26fa <vTaskIncrementTick+0x144>
    26bc:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    26c0:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    26c4:	07 80       	ldd	r0, Z+7	; 0x07
    26c6:	f0 85       	ldd	r31, Z+8	; 0x08
    26c8:	e0 2d       	mov	r30, r0
    26ca:	c0 85       	ldd	r28, Z+8	; 0x08
    26cc:	d1 85       	ldd	r29, Z+9	; 0x09
    26ce:	8a 81       	ldd	r24, Y+2	; 0x02
    26d0:	9b 81       	ldd	r25, Y+3	; 0x03
    26d2:	ac 81       	ldd	r26, Y+4	; 0x04
    26d4:	bd 81       	ldd	r27, Y+5	; 0x05
    26d6:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    26da:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    26de:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    26e2:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    26e6:	48 17       	cp	r20, r24
    26e8:	59 07       	cpc	r21, r25
    26ea:	6a 07       	cpc	r22, r26
    26ec:	7b 07       	cpc	r23, r27
    26ee:	58 f1       	brcs	.+86     	; 0x2746 <vTaskIncrementTick+0x190>
    26f0:	0f 2e       	mov	r0, r31
    26f2:	fb e0       	ldi	r31, 0x0B	; 11
    26f4:	ff 2e       	mov	r15, r31
    26f6:	f0 2d       	mov	r31, r0
    26f8:	2f c0       	rjmp	.+94     	; 0x2758 <vTaskIncrementTick+0x1a2>
    26fa:	8f ef       	ldi	r24, 0xFF	; 255
    26fc:	9f ef       	ldi	r25, 0xFF	; 255
    26fe:	dc 01       	movw	r26, r24
    2700:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2704:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2708:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    270c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2710:	4d c0       	rjmp	.+154    	; 0x27ac <vTaskIncrementTick+0x1f6>
    2712:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2716:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    271a:	07 80       	ldd	r0, Z+7	; 0x07
    271c:	f0 85       	ldd	r31, Z+8	; 0x08
    271e:	e0 2d       	mov	r30, r0
    2720:	c0 85       	ldd	r28, Z+8	; 0x08
    2722:	d1 85       	ldd	r29, Z+9	; 0x09
    2724:	8a 81       	ldd	r24, Y+2	; 0x02
    2726:	9b 81       	ldd	r25, Y+3	; 0x03
    2728:	ac 81       	ldd	r26, Y+4	; 0x04
    272a:	bd 81       	ldd	r27, Y+5	; 0x05
    272c:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    2730:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2734:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2738:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    273c:	48 17       	cp	r20, r24
    273e:	59 07       	cpc	r21, r25
    2740:	6a 07       	cpc	r22, r26
    2742:	7b 07       	cpc	r23, r27
    2744:	48 f4       	brcc	.+18     	; 0x2758 <vTaskIncrementTick+0x1a2>
    2746:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    274a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    274e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2752:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2756:	2a c0       	rjmp	.+84     	; 0x27ac <vTaskIncrementTick+0x1f6>
    2758:	8e 01       	movw	r16, r28
    275a:	0e 5f       	subi	r16, 0xFE	; 254
    275c:	1f 4f       	sbci	r17, 0xFF	; 255
    275e:	c8 01       	movw	r24, r16
    2760:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>
    2764:	88 8d       	ldd	r24, Y+24	; 0x18
    2766:	99 8d       	ldd	r25, Y+25	; 0x19
    2768:	89 2b       	or	r24, r25
    276a:	21 f0       	breq	.+8      	; 0x2774 <vTaskIncrementTick+0x1be>
    276c:	ce 01       	movw	r24, r28
    276e:	0e 96       	adiw	r24, 0x0e	; 14
    2770:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>
    2774:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2776:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    277a:	98 17       	cp	r25, r24
    277c:	10 f4       	brcc	.+4      	; 0x2782 <vTaskIncrementTick+0x1cc>
    277e:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2782:	f8 9e       	mul	r15, r24
    2784:	c0 01       	movw	r24, r0
    2786:	11 24       	eor	r1, r1
    2788:	b8 01       	movw	r22, r16
    278a:	84 51       	subi	r24, 0x14	; 20
    278c:	9f 4c       	sbci	r25, 0xCF	; 207
    278e:	0e 94 8d 0c 	call	0x191a	; 0x191a <vListInsertEnd>
    2792:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2796:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    279a:	80 81       	ld	r24, Z
    279c:	81 11       	cpse	r24, r1
    279e:	b9 cf       	rjmp	.-142    	; 0x2712 <vTaskIncrementTick+0x15c>
    27a0:	ac cf       	rjmp	.-168    	; 0x26fa <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    27a2:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    27a6:	8f 5f       	subi	r24, 0xFF	; 255
    27a8:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    27ac:	df 91       	pop	r29
    27ae:	cf 91       	pop	r28
    27b0:	1f 91       	pop	r17
    27b2:	0f 91       	pop	r16
    27b4:	ff 90       	pop	r15
    27b6:	08 95       	ret

000027b8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    27b8:	cf 92       	push	r12
    27ba:	df 92       	push	r13
    27bc:	ef 92       	push	r14
    27be:	ff 92       	push	r15
    27c0:	0f 93       	push	r16
    27c2:	1f 93       	push	r17
    27c4:	cf 93       	push	r28
    27c6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    27c8:	0f b6       	in	r0, 0x3f	; 63
    27ca:	f8 94       	cli
    27cc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    27ce:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    27d2:	81 50       	subi	r24, 0x01	; 1
    27d4:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    27d8:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    27dc:	81 11       	cpse	r24, r1
    27de:	60 c0       	rjmp	.+192    	; 0x28a0 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    27e0:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    27e4:	81 11       	cpse	r24, r1
    27e6:	2c c0       	rjmp	.+88     	; 0x2840 <xTaskResumeAll+0x88>
    27e8:	5e c0       	rjmp	.+188    	; 0x28a6 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    27ea:	d7 01       	movw	r26, r14
    27ec:	17 96       	adiw	r26, 0x07	; 7
    27ee:	ed 91       	ld	r30, X+
    27f0:	fc 91       	ld	r31, X
    27f2:	18 97       	sbiw	r26, 0x08	; 8
    27f4:	c0 85       	ldd	r28, Z+8	; 0x08
    27f6:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    27f8:	ce 01       	movw	r24, r28
    27fa:	0e 96       	adiw	r24, 0x0e	; 14
    27fc:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2800:	8e 01       	movw	r16, r28
    2802:	0e 5f       	subi	r16, 0xFE	; 254
    2804:	1f 4f       	sbci	r17, 0xFF	; 255
    2806:	c8 01       	movw	r24, r16
    2808:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    280c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    280e:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2812:	98 17       	cp	r25, r24
    2814:	10 f4       	brcc	.+4      	; 0x281a <xTaskResumeAll+0x62>
    2816:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    281a:	d8 9e       	mul	r13, r24
    281c:	c0 01       	movw	r24, r0
    281e:	11 24       	eor	r1, r1
    2820:	b8 01       	movw	r22, r16
    2822:	84 51       	subi	r24, 0x14	; 20
    2824:	9f 4c       	sbci	r25, 0xCF	; 207
    2826:	0e 94 8d 0c 	call	0x191a	; 0x191a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    282a:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    282e:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2832:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2834:	82 8d       	ldd	r24, Z+26	; 0x1a
    2836:	98 17       	cp	r25, r24
    2838:	70 f0       	brcs	.+28     	; 0x2856 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    283a:	cc 24       	eor	r12, r12
    283c:	c3 94       	inc	r12
    283e:	0b c0       	rjmp	.+22     	; 0x2856 <xTaskResumeAll+0x9e>
    2840:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2842:	0f 2e       	mov	r0, r31
    2844:	f7 ec       	ldi	r31, 0xC7	; 199
    2846:	ef 2e       	mov	r14, r31
    2848:	f0 e3       	ldi	r31, 0x30	; 48
    284a:	ff 2e       	mov	r15, r31
    284c:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    284e:	0f 2e       	mov	r0, r31
    2850:	fb e0       	ldi	r31, 0x0B	; 11
    2852:	df 2e       	mov	r13, r31
    2854:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2856:	f7 01       	movw	r30, r14
    2858:	80 81       	ld	r24, Z
    285a:	81 11       	cpse	r24, r1
    285c:	c6 cf       	rjmp	.-116    	; 0x27ea <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    285e:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2862:	88 23       	and	r24, r24
    2864:	81 f0       	breq	.+32     	; 0x2886 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2866:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    286a:	88 23       	and	r24, r24
    286c:	99 f0       	breq	.+38     	; 0x2894 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    286e:	0e 94 db 12 	call	0x25b6	; 0x25b6 <vTaskIncrementTick>
						--uxMissedTicks;
    2872:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2876:	81 50       	subi	r24, 0x01	; 1
    2878:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    287c:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2880:	81 11       	cpse	r24, r1
    2882:	f5 cf       	rjmp	.-22     	; 0x286e <xTaskResumeAll+0xb6>
    2884:	07 c0       	rjmp	.+14     	; 0x2894 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2886:	f1 e0       	ldi	r31, 0x01	; 1
    2888:	cf 16       	cp	r12, r31
    288a:	21 f0       	breq	.+8      	; 0x2894 <xTaskResumeAll+0xdc>
    288c:	80 91 ba 30 	lds	r24, 0x30BA	; 0x8030ba <xMissedYield>
    2890:	81 30       	cpi	r24, 0x01	; 1
    2892:	41 f4       	brne	.+16     	; 0x28a4 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2894:	10 92 ba 30 	sts	0x30BA, r1	; 0x8030ba <xMissedYield>
					portYIELD_WITHIN_API();
    2898:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	03 c0       	rjmp	.+6      	; 0x28a6 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    28a0:	80 e0       	ldi	r24, 0x00	; 0
    28a2:	01 c0       	rjmp	.+2      	; 0x28a6 <xTaskResumeAll+0xee>
    28a4:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    28a6:	0f 90       	pop	r0
    28a8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    28aa:	df 91       	pop	r29
    28ac:	cf 91       	pop	r28
    28ae:	1f 91       	pop	r17
    28b0:	0f 91       	pop	r16
    28b2:	ff 90       	pop	r15
    28b4:	ef 90       	pop	r14
    28b6:	df 90       	pop	r13
    28b8:	cf 90       	pop	r12
    28ba:	08 95       	ret

000028bc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    28bc:	cf 92       	push	r12
    28be:	df 92       	push	r13
    28c0:	ef 92       	push	r14
    28c2:	ff 92       	push	r15
    28c4:	cf 93       	push	r28
    28c6:	df 93       	push	r29
    28c8:	ec 01       	movw	r28, r24
    28ca:	6a 01       	movw	r12, r20
    28cc:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    28ce:	0e 94 ba 12 	call	0x2574	; 0x2574 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    28d2:	88 81       	ld	r24, Y
    28d4:	99 81       	ldd	r25, Y+1	; 0x01
    28d6:	aa 81       	ldd	r26, Y+2	; 0x02
    28d8:	bb 81       	ldd	r27, Y+3	; 0x03
    28da:	c8 0e       	add	r12, r24
    28dc:	d9 1e       	adc	r13, r25
    28de:	ea 1e       	adc	r14, r26
    28e0:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    28e2:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    28e6:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    28ea:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    28ee:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    28f2:	48 17       	cp	r20, r24
    28f4:	59 07       	cpc	r21, r25
    28f6:	6a 07       	cpc	r22, r26
    28f8:	7b 07       	cpc	r23, r27
    28fa:	b8 f4       	brcc	.+46     	; 0x292a <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    28fc:	c8 16       	cp	r12, r24
    28fe:	d9 06       	cpc	r13, r25
    2900:	ea 06       	cpc	r14, r26
    2902:	fb 06       	cpc	r15, r27
    2904:	e0 f5       	brcc	.+120    	; 0x297e <vTaskDelayUntil+0xc2>
    2906:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    290a:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    290e:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2912:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2916:	c8 82       	st	Y, r12
    2918:	d9 82       	std	Y+1, r13	; 0x01
    291a:	ea 82       	std	Y+2, r14	; 0x02
    291c:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    291e:	8c 15       	cp	r24, r12
    2920:	9d 05       	cpc	r25, r13
    2922:	ae 05       	cpc	r26, r14
    2924:	bf 05       	cpc	r27, r15
    2926:	f8 f4       	brcc	.+62     	; 0x2966 <vTaskDelayUntil+0xaa>
    2928:	13 c0       	rjmp	.+38     	; 0x2950 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    292a:	c8 16       	cp	r12, r24
    292c:	d9 06       	cpc	r13, r25
    292e:	ea 06       	cpc	r14, r26
    2930:	fb 06       	cpc	r15, r27
    2932:	00 f1       	brcs	.+64     	; 0x2974 <vTaskDelayUntil+0xb8>
    2934:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2938:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    293c:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2940:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2944:	8c 15       	cp	r24, r12
    2946:	9d 05       	cpc	r25, r13
    2948:	ae 05       	cpc	r26, r14
    294a:	bf 05       	cpc	r27, r15
    294c:	98 f0       	brcs	.+38     	; 0x2974 <vTaskDelayUntil+0xb8>
    294e:	17 c0       	rjmp	.+46     	; 0x297e <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2950:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2954:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2958:	02 96       	adiw	r24, 0x02	; 2
    295a:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    295e:	c7 01       	movw	r24, r14
    2960:	b6 01       	movw	r22, r12
    2962:	0e 94 29 11 	call	0x2252	; 0x2252 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2966:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    296a:	81 11       	cpse	r24, r1
    296c:	0d c0       	rjmp	.+26     	; 0x2988 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    296e:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
		}
	}
    2972:	0a c0       	rjmp	.+20     	; 0x2988 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2974:	c8 82       	st	Y, r12
    2976:	d9 82       	std	Y+1, r13	; 0x01
    2978:	ea 82       	std	Y+2, r14	; 0x02
    297a:	fb 82       	std	Y+3, r15	; 0x03
    297c:	e9 cf       	rjmp	.-46     	; 0x2950 <vTaskDelayUntil+0x94>
    297e:	c8 82       	st	Y, r12
    2980:	d9 82       	std	Y+1, r13	; 0x01
    2982:	ea 82       	std	Y+2, r14	; 0x02
    2984:	fb 82       	std	Y+3, r15	; 0x03
    2986:	ef cf       	rjmp	.-34     	; 0x2966 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2988:	df 91       	pop	r29
    298a:	cf 91       	pop	r28
    298c:	ff 90       	pop	r15
    298e:	ef 90       	pop	r14
    2990:	df 90       	pop	r13
    2992:	cf 90       	pop	r12
    2994:	08 95       	ret

00002996 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2996:	cf 92       	push	r12
    2998:	df 92       	push	r13
    299a:	ef 92       	push	r14
    299c:	ff 92       	push	r15
    299e:	6b 01       	movw	r12, r22
    29a0:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    29a2:	67 2b       	or	r22, r23
    29a4:	68 2b       	or	r22, r24
    29a6:	69 2b       	or	r22, r25
    29a8:	e9 f0       	breq	.+58     	; 0x29e4 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    29aa:	0e 94 ba 12 	call	0x2574	; 0x2574 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    29ae:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    29b2:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    29b6:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    29ba:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    29be:	c8 0e       	add	r12, r24
    29c0:	d9 1e       	adc	r13, r25
    29c2:	ea 1e       	adc	r14, r26
    29c4:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    29c6:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    29ca:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    29ce:	02 96       	adiw	r24, 0x02	; 2
    29d0:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    29d4:	c7 01       	movw	r24, r14
    29d6:	b6 01       	movw	r22, r12
    29d8:	0e 94 29 11 	call	0x2252	; 0x2252 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    29dc:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    29e0:	81 11       	cpse	r24, r1
    29e2:	02 c0       	rjmp	.+4      	; 0x29e8 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    29e4:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortYield>
		}
	}
    29e8:	ff 90       	pop	r15
    29ea:	ef 90       	pop	r14
    29ec:	df 90       	pop	r13
    29ee:	cf 90       	pop	r12
    29f0:	08 95       	ret

000029f2 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    29f2:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    29f6:	81 11       	cpse	r24, r1
    29f8:	0c c0       	rjmp	.+24     	; 0x2a12 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    29fa:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    29fe:	4b e0       	ldi	r20, 0x0B	; 11
    2a00:	e4 9f       	mul	r30, r20
    2a02:	f0 01       	movw	r30, r0
    2a04:	11 24       	eor	r1, r1
    2a06:	e4 51       	subi	r30, 0x14	; 20
    2a08:	ff 4c       	sbci	r31, 0xCF	; 207
    2a0a:	80 81       	ld	r24, Z
    2a0c:	88 23       	and	r24, r24
    2a0e:	29 f0       	breq	.+10     	; 0x2a1a <vTaskSwitchContext+0x28>
    2a10:	14 c0       	rjmp	.+40     	; 0x2a3a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2a12:	81 e0       	ldi	r24, 0x01	; 1
    2a14:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    2a18:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2a1a:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2a1c:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2a20:	81 50       	subi	r24, 0x01	; 1
    2a22:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2a26:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2a2a:	9e 9f       	mul	r25, r30
    2a2c:	f0 01       	movw	r30, r0
    2a2e:	11 24       	eor	r1, r1
    2a30:	e4 51       	subi	r30, 0x14	; 20
    2a32:	ff 4c       	sbci	r31, 0xCF	; 207
    2a34:	80 81       	ld	r24, Z
    2a36:	88 23       	and	r24, r24
    2a38:	89 f3       	breq	.-30     	; 0x2a1c <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2a3a:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2a3e:	28 2f       	mov	r18, r24
    2a40:	30 e0       	ldi	r19, 0x00	; 0
    2a42:	4b e0       	ldi	r20, 0x0B	; 11
    2a44:	84 9f       	mul	r24, r20
    2a46:	c0 01       	movw	r24, r0
    2a48:	11 24       	eor	r1, r1
    2a4a:	dc 01       	movw	r26, r24
    2a4c:	a4 51       	subi	r26, 0x14	; 20
    2a4e:	bf 4c       	sbci	r27, 0xCF	; 207
    2a50:	11 96       	adiw	r26, 0x01	; 1
    2a52:	ed 91       	ld	r30, X+
    2a54:	fc 91       	ld	r31, X
    2a56:	12 97       	sbiw	r26, 0x02	; 2
    2a58:	04 80       	ldd	r0, Z+4	; 0x04
    2a5a:	f5 81       	ldd	r31, Z+5	; 0x05
    2a5c:	e0 2d       	mov	r30, r0
    2a5e:	11 96       	adiw	r26, 0x01	; 1
    2a60:	ed 93       	st	X+, r30
    2a62:	fc 93       	st	X, r31
    2a64:	12 97       	sbiw	r26, 0x02	; 2
    2a66:	81 51       	subi	r24, 0x11	; 17
    2a68:	9f 4c       	sbci	r25, 0xCF	; 207
    2a6a:	e8 17       	cp	r30, r24
    2a6c:	f9 07       	cpc	r31, r25
    2a6e:	61 f4       	brne	.+24     	; 0x2a88 <vTaskSwitchContext+0x96>
    2a70:	84 81       	ldd	r24, Z+4	; 0x04
    2a72:	95 81       	ldd	r25, Z+5	; 0x05
    2a74:	4b e0       	ldi	r20, 0x0B	; 11
    2a76:	42 9f       	mul	r20, r18
    2a78:	f0 01       	movw	r30, r0
    2a7a:	43 9f       	mul	r20, r19
    2a7c:	f0 0d       	add	r31, r0
    2a7e:	11 24       	eor	r1, r1
    2a80:	e4 51       	subi	r30, 0x14	; 20
    2a82:	ff 4c       	sbci	r31, 0xCF	; 207
    2a84:	81 83       	std	Z+1, r24	; 0x01
    2a86:	92 83       	std	Z+2, r25	; 0x02
    2a88:	8b e0       	ldi	r24, 0x0B	; 11
    2a8a:	82 9f       	mul	r24, r18
    2a8c:	f0 01       	movw	r30, r0
    2a8e:	83 9f       	mul	r24, r19
    2a90:	f0 0d       	add	r31, r0
    2a92:	11 24       	eor	r1, r1
    2a94:	e4 51       	subi	r30, 0x14	; 20
    2a96:	ff 4c       	sbci	r31, 0xCF	; 207
    2a98:	01 80       	ldd	r0, Z+1	; 0x01
    2a9a:	f2 81       	ldd	r31, Z+2	; 0x02
    2a9c:	e0 2d       	mov	r30, r0
    2a9e:	80 85       	ldd	r24, Z+8	; 0x08
    2aa0:	91 85       	ldd	r25, Z+9	; 0x09
    2aa2:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <pxCurrentTCB>
    2aa6:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <pxCurrentTCB+0x1>
    2aaa:	08 95       	ret

00002aac <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2aac:	cf 92       	push	r12
    2aae:	df 92       	push	r13
    2ab0:	ef 92       	push	r14
    2ab2:	ff 92       	push	r15
    2ab4:	6a 01       	movw	r12, r20
    2ab6:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2ab8:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    2abc:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2ac0:	62 5f       	subi	r22, 0xF2	; 242
    2ac2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ac4:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ac8:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2acc:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2ad0:	02 96       	adiw	r24, 0x02	; 2
    2ad2:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2ad6:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2ada:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2ade:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2ae2:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ae6:	bc 01       	movw	r22, r24
    2ae8:	cd 01       	movw	r24, r26
    2aea:	6c 0d       	add	r22, r12
    2aec:	7d 1d       	adc	r23, r13
    2aee:	8e 1d       	adc	r24, r14
    2af0:	9f 1d       	adc	r25, r15
    2af2:	0e 94 29 11 	call	0x2252	; 0x2252 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2af6:	ff 90       	pop	r15
    2af8:	ef 90       	pop	r14
    2afa:	df 90       	pop	r13
    2afc:	cf 90       	pop	r12
    2afe:	08 95       	ret

00002b00 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2b00:	0f 93       	push	r16
    2b02:	1f 93       	push	r17
    2b04:	cf 93       	push	r28
    2b06:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2b08:	dc 01       	movw	r26, r24
    2b0a:	17 96       	adiw	r26, 0x07	; 7
    2b0c:	ed 91       	ld	r30, X+
    2b0e:	fc 91       	ld	r31, X
    2b10:	18 97       	sbiw	r26, 0x08	; 8
    2b12:	c0 85       	ldd	r28, Z+8	; 0x08
    2b14:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2b16:	8e 01       	movw	r16, r28
    2b18:	02 5f       	subi	r16, 0xF2	; 242
    2b1a:	1f 4f       	sbci	r17, 0xFF	; 255
    2b1c:	c8 01       	movw	r24, r16
    2b1e:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2b22:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2b26:	81 11       	cpse	r24, r1
    2b28:	16 c0       	rjmp	.+44     	; 0x2b56 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2b2a:	0c 50       	subi	r16, 0x0C	; 12
    2b2c:	11 09       	sbc	r17, r1
    2b2e:	c8 01       	movw	r24, r16
    2b30:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2b34:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b36:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2b3a:	98 17       	cp	r25, r24
    2b3c:	10 f4       	brcc	.+4      	; 0x2b42 <xTaskRemoveFromEventList+0x42>
    2b3e:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2b42:	bb e0       	ldi	r27, 0x0B	; 11
    2b44:	8b 9f       	mul	r24, r27
    2b46:	c0 01       	movw	r24, r0
    2b48:	11 24       	eor	r1, r1
    2b4a:	b8 01       	movw	r22, r16
    2b4c:	84 51       	subi	r24, 0x14	; 20
    2b4e:	9f 4c       	sbci	r25, 0xCF	; 207
    2b50:	0e 94 8d 0c 	call	0x191a	; 0x191a <vListInsertEnd>
    2b54:	05 c0       	rjmp	.+10     	; 0x2b60 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2b56:	b8 01       	movw	r22, r16
    2b58:	87 ec       	ldi	r24, 0xC7	; 199
    2b5a:	90 e3       	ldi	r25, 0x30	; 48
    2b5c:	0e 94 8d 0c 	call	0x191a	; 0x191a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2b60:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2b64:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2b68:	81 e0       	ldi	r24, 0x01	; 1
    2b6a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2b6c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b6e:	29 17       	cp	r18, r25
    2b70:	08 f4       	brcc	.+2      	; 0x2b74 <xTaskRemoveFromEventList+0x74>
    2b72:	80 e0       	ldi	r24, 0x00	; 0
}
    2b74:	df 91       	pop	r29
    2b76:	cf 91       	pop	r28
    2b78:	1f 91       	pop	r17
    2b7a:	0f 91       	pop	r16
    2b7c:	08 95       	ret

00002b7e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2b7e:	20 91 b9 30 	lds	r18, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2b82:	fc 01       	movw	r30, r24
    2b84:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2b86:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    2b8a:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2b8e:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2b92:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2b96:	41 83       	std	Z+1, r20	; 0x01
    2b98:	52 83       	std	Z+2, r21	; 0x02
    2b9a:	63 83       	std	Z+3, r22	; 0x03
    2b9c:	74 83       	std	Z+4, r23	; 0x04
    2b9e:	08 95       	ret

00002ba0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2ba0:	8f 92       	push	r8
    2ba2:	9f 92       	push	r9
    2ba4:	af 92       	push	r10
    2ba6:	bf 92       	push	r11
    2ba8:	cf 92       	push	r12
    2baa:	df 92       	push	r13
    2bac:	ef 92       	push	r14
    2bae:	ff 92       	push	r15
    2bb0:	0f 93       	push	r16
    2bb2:	1f 93       	push	r17
    2bb4:	cf 93       	push	r28
    2bb6:	df 93       	push	r29
    2bb8:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2bba:	0f b6       	in	r0, 0x3f	; 63
    2bbc:	f8 94       	cli
    2bbe:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2bc0:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2bc4:	90 81       	ld	r25, Z
    2bc6:	98 17       	cp	r25, r24
    2bc8:	89 f0       	breq	.+34     	; 0x2bec <xTaskCheckForTimeOut+0x4c>
    2bca:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2bce:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2bd2:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2bd6:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2bda:	01 81       	ldd	r16, Z+1	; 0x01
    2bdc:	12 81       	ldd	r17, Z+2	; 0x02
    2bde:	23 81       	ldd	r18, Z+3	; 0x03
    2be0:	34 81       	ldd	r19, Z+4	; 0x04
    2be2:	80 17       	cp	r24, r16
    2be4:	91 07       	cpc	r25, r17
    2be6:	a2 07       	cpc	r26, r18
    2be8:	b3 07       	cpc	r27, r19
    2bea:	a8 f5       	brcc	.+106    	; 0x2c56 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2bec:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2bf0:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2bf4:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2bf8:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2bfc:	c1 80       	ldd	r12, Z+1	; 0x01
    2bfe:	d2 80       	ldd	r13, Z+2	; 0x02
    2c00:	e3 80       	ldd	r14, Z+3	; 0x03
    2c02:	f4 80       	ldd	r15, Z+4	; 0x04
    2c04:	eb 01       	movw	r28, r22
    2c06:	08 81       	ld	r16, Y
    2c08:	19 81       	ldd	r17, Y+1	; 0x01
    2c0a:	2a 81       	ldd	r18, Y+2	; 0x02
    2c0c:	3b 81       	ldd	r19, Y+3	; 0x03
    2c0e:	8c 19       	sub	r24, r12
    2c10:	9d 09       	sbc	r25, r13
    2c12:	ae 09       	sbc	r26, r14
    2c14:	bf 09       	sbc	r27, r15
    2c16:	80 17       	cp	r24, r16
    2c18:	91 07       	cpc	r25, r17
    2c1a:	a2 07       	cpc	r26, r18
    2c1c:	b3 07       	cpc	r27, r19
    2c1e:	e8 f4       	brcc	.+58     	; 0x2c5a <xTaskCheckForTimeOut+0xba>
    2c20:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2c22:	80 90 c0 30 	lds	r8, 0x30C0	; 0x8030c0 <xTickCount>
    2c26:	90 90 c1 30 	lds	r9, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2c2a:	a0 90 c2 30 	lds	r10, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2c2e:	b0 90 c3 30 	lds	r11, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2c32:	b5 01       	movw	r22, r10
    2c34:	a4 01       	movw	r20, r8
    2c36:	4c 19       	sub	r20, r12
    2c38:	5d 09       	sbc	r21, r13
    2c3a:	6e 09       	sbc	r22, r14
    2c3c:	7f 09       	sbc	r23, r15
    2c3e:	04 1b       	sub	r16, r20
    2c40:	15 0b       	sbc	r17, r21
    2c42:	26 0b       	sbc	r18, r22
    2c44:	37 0b       	sbc	r19, r23
    2c46:	08 83       	st	Y, r16
    2c48:	19 83       	std	Y+1, r17	; 0x01
    2c4a:	2a 83       	std	Y+2, r18	; 0x02
    2c4c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2c4e:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2c52:	80 e0       	ldi	r24, 0x00	; 0
    2c54:	03 c0       	rjmp	.+6      	; 0x2c5c <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2c56:	81 e0       	ldi	r24, 0x01	; 1
    2c58:	01 c0       	rjmp	.+2      	; 0x2c5c <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2c5c:	0f 90       	pop	r0
    2c5e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2c60:	df 91       	pop	r29
    2c62:	cf 91       	pop	r28
    2c64:	1f 91       	pop	r17
    2c66:	0f 91       	pop	r16
    2c68:	ff 90       	pop	r15
    2c6a:	ef 90       	pop	r14
    2c6c:	df 90       	pop	r13
    2c6e:	cf 90       	pop	r12
    2c70:	bf 90       	pop	r11
    2c72:	af 90       	pop	r10
    2c74:	9f 90       	pop	r9
    2c76:	8f 90       	pop	r8
    2c78:	08 95       	ret

00002c7a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2c7a:	81 e0       	ldi	r24, 0x01	; 1
    2c7c:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    2c80:	08 95       	ret

00002c82 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2c82:	00 97       	sbiw	r24, 0x00	; 0
    2c84:	21 f4       	brne	.+8      	; 0x2c8e <uxTaskGetStackHighWaterMark+0xc>
    2c86:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2c8a:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2c8e:	dc 01       	movw	r26, r24
    2c90:	5b 96       	adiw	r26, 0x1b	; 27
    2c92:	ed 91       	ld	r30, X+
    2c94:	fc 91       	ld	r31, X
    2c96:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2c98:	80 81       	ld	r24, Z
    2c9a:	81 31       	cpi	r24, 0x11	; 17
    2c9c:	41 f4       	brne	.+16     	; 0x2cae <uxTaskGetStackHighWaterMark+0x2c>
    2c9e:	31 96       	adiw	r30, 0x01	; 1
    2ca0:	80 e0       	ldi	r24, 0x00	; 0
    2ca2:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2ca4:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2ca6:	21 91       	ld	r18, Z+
    2ca8:	21 31       	cpi	r18, 0x11	; 17
    2caa:	e1 f3       	breq	.-8      	; 0x2ca4 <uxTaskGetStackHighWaterMark+0x22>
    2cac:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2cae:	80 e0       	ldi	r24, 0x00	; 0
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2cb2:	08 95       	ret

00002cb4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2cb4:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2cb8:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2cbc:	08 95       	ret

00002cbe <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2cbe:	0f 93       	push	r16
    2cc0:	1f 93       	push	r17
    2cc2:	cf 93       	push	r28
    2cc4:	df 93       	push	r29
    2cc6:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2cc8:	22 8d       	ldd	r18, Z+26	; 0x1a
    2cca:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2cce:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2cd2:	5a 96       	adiw	r26, 0x1a	; 26
    2cd4:	8c 91       	ld	r24, X
    2cd6:	28 17       	cp	r18, r24
    2cd8:	08 f0       	brcs	.+2      	; 0x2cdc <vTaskPriorityInherit+0x1e>
    2cda:	41 c0       	rjmp	.+130    	; 0x2d5e <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2cdc:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2ce0:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2ce4:	5a 96       	adiw	r26, 0x1a	; 26
    2ce6:	3c 91       	ld	r19, X
    2ce8:	84 e0       	ldi	r24, 0x04	; 4
    2cea:	90 e0       	ldi	r25, 0x00	; 0
    2cec:	a0 e0       	ldi	r26, 0x00	; 0
    2cee:	b0 e0       	ldi	r27, 0x00	; 0
    2cf0:	83 1b       	sub	r24, r19
    2cf2:	91 09       	sbc	r25, r1
    2cf4:	a1 09       	sbc	r26, r1
    2cf6:	b1 09       	sbc	r27, r1
    2cf8:	86 87       	std	Z+14, r24	; 0x0e
    2cfa:	97 87       	std	Z+15, r25	; 0x0f
    2cfc:	a0 8b       	std	Z+16, r26	; 0x10
    2cfe:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2d00:	8b e0       	ldi	r24, 0x0B	; 11
    2d02:	28 9f       	mul	r18, r24
    2d04:	90 01       	movw	r18, r0
    2d06:	11 24       	eor	r1, r1
    2d08:	24 51       	subi	r18, 0x14	; 20
    2d0a:	3f 4c       	sbci	r19, 0xCF	; 207
    2d0c:	84 85       	ldd	r24, Z+12	; 0x0c
    2d0e:	95 85       	ldd	r25, Z+13	; 0x0d
    2d10:	82 17       	cp	r24, r18
    2d12:	93 07       	cpc	r25, r19
    2d14:	e9 f4       	brne	.+58     	; 0x2d50 <vTaskPriorityInherit+0x92>
    2d16:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2d18:	ef 01       	movw	r28, r30
    2d1a:	22 96       	adiw	r28, 0x02	; 2
    2d1c:	ce 01       	movw	r24, r28
    2d1e:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2d22:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2d26:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2d2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d2c:	f8 01       	movw	r30, r16
    2d2e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2d30:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2d34:	98 17       	cp	r25, r24
    2d36:	10 f4       	brcc	.+4      	; 0x2d3c <vTaskPriorityInherit+0x7e>
    2d38:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2d3c:	fb e0       	ldi	r31, 0x0B	; 11
    2d3e:	8f 9f       	mul	r24, r31
    2d40:	c0 01       	movw	r24, r0
    2d42:	11 24       	eor	r1, r1
    2d44:	be 01       	movw	r22, r28
    2d46:	84 51       	subi	r24, 0x14	; 20
    2d48:	9f 4c       	sbci	r25, 0xCF	; 207
    2d4a:	0e 94 8d 0c 	call	0x191a	; 0x191a <vListInsertEnd>
    2d4e:	07 c0       	rjmp	.+14     	; 0x2d5e <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2d50:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2d54:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2d58:	5a 96       	adiw	r26, 0x1a	; 26
    2d5a:	8c 91       	ld	r24, X
    2d5c:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2d5e:	df 91       	pop	r29
    2d60:	cf 91       	pop	r28
    2d62:	1f 91       	pop	r17
    2d64:	0f 91       	pop	r16
    2d66:	08 95       	ret

00002d68 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2d68:	0f 93       	push	r16
    2d6a:	1f 93       	push	r17
    2d6c:	cf 93       	push	r28
    2d6e:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2d70:	00 97       	sbiw	r24, 0x00	; 0
    2d72:	49 f1       	breq	.+82     	; 0x2dc6 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2d74:	fc 01       	movw	r30, r24
    2d76:	32 8d       	ldd	r19, Z+26	; 0x1a
    2d78:	27 a1       	ldd	r18, Z+39	; 0x27
    2d7a:	32 17       	cp	r19, r18
    2d7c:	21 f1       	breq	.+72     	; 0x2dc6 <vTaskPriorityDisinherit+0x5e>
    2d7e:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2d80:	8c 01       	movw	r16, r24
    2d82:	0e 5f       	subi	r16, 0xFE	; 254
    2d84:	1f 4f       	sbci	r17, 0xFF	; 255
    2d86:	c8 01       	movw	r24, r16
    2d88:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2d8c:	8f a1       	ldd	r24, Y+39	; 0x27
    2d8e:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2d90:	44 e0       	ldi	r20, 0x04	; 4
    2d92:	50 e0       	ldi	r21, 0x00	; 0
    2d94:	60 e0       	ldi	r22, 0x00	; 0
    2d96:	70 e0       	ldi	r23, 0x00	; 0
    2d98:	48 1b       	sub	r20, r24
    2d9a:	51 09       	sbc	r21, r1
    2d9c:	61 09       	sbc	r22, r1
    2d9e:	71 09       	sbc	r23, r1
    2da0:	4e 87       	std	Y+14, r20	; 0x0e
    2da2:	5f 87       	std	Y+15, r21	; 0x0f
    2da4:	68 8b       	std	Y+16, r22	; 0x10
    2da6:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2da8:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2dac:	98 17       	cp	r25, r24
    2dae:	10 f4       	brcc	.+4      	; 0x2db4 <vTaskPriorityDisinherit+0x4c>
    2db0:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2db4:	fb e0       	ldi	r31, 0x0B	; 11
    2db6:	8f 9f       	mul	r24, r31
    2db8:	c0 01       	movw	r24, r0
    2dba:	11 24       	eor	r1, r1
    2dbc:	b8 01       	movw	r22, r16
    2dbe:	84 51       	subi	r24, 0x14	; 20
    2dc0:	9f 4c       	sbci	r25, 0xCF	; 207
    2dc2:	0e 94 8d 0c 	call	0x191a	; 0x191a <vListInsertEnd>
			}
		}
	}
    2dc6:	df 91       	pop	r29
    2dc8:	cf 91       	pop	r28
    2dca:	1f 91       	pop	r17
    2dcc:	0f 91       	pop	r16
    2dce:	08 95       	ret

00002dd0 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2dd0:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2dd2:	e8 81       	ld	r30, Y
    2dd4:	f9 81       	ldd	r31, Y+1	; 0x01
    2dd6:	01 90       	ld	r0, Z+
    2dd8:	f0 81       	ld	r31, Z
    2dda:	e0 2d       	mov	r30, r0
    2ddc:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2dde:	1a 82       	std	Y+2, r1	; 0x02
    2de0:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2de2:	6f ef       	ldi	r22, 0xFF	; 255
    2de4:	7f ef       	ldi	r23, 0xFF	; 255
    2de6:	cb 01       	movw	r24, r22
    2de8:	0e 94 cb 14 	call	0x2996	; 0x2996 <vTaskDelay>
    2dec:	fa cf       	rjmp	.-12     	; 0x2de2 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002dee <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2dee:	fc 01       	movw	r30, r24
    2df0:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2df2:	65 87       	std	Z+13, r22	; 0x0d
    2df4:	08 95       	ret

00002df6 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2df6:	4f 92       	push	r4
    2df8:	5f 92       	push	r5
    2dfa:	6f 92       	push	r6
    2dfc:	7f 92       	push	r7
    2dfe:	8f 92       	push	r8
    2e00:	9f 92       	push	r9
    2e02:	af 92       	push	r10
    2e04:	bf 92       	push	r11
    2e06:	cf 92       	push	r12
    2e08:	df 92       	push	r13
    2e0a:	ef 92       	push	r14
    2e0c:	ff 92       	push	r15
    2e0e:	0f 93       	push	r16
    2e10:	1f 93       	push	r17
    2e12:	cf 93       	push	r28
    2e14:	df 93       	push	r29
    2e16:	cd b7       	in	r28, 0x3d	; 61
    2e18:	de b7       	in	r29, 0x3e	; 62
    2e1a:	2a 97       	sbiw	r28, 0x0a	; 10
    2e1c:	cd bf       	out	0x3d, r28	; 61
    2e1e:	de bf       	out	0x3e, r29	; 62
    2e20:	4c 01       	movw	r8, r24
    2e22:	29 01       	movw	r4, r18
    2e24:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2e26:	87 e3       	ldi	r24, 0x37	; 55
    2e28:	90 e2       	ldi	r25, 0x20	; 32
    2e2a:	f4 01       	movw	r30, r8
    2e2c:	80 83       	st	Z, r24
    2e2e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2e30:	fb 01       	movw	r30, r22
    2e32:	80 81       	ld	r24, Z
    2e34:	88 23       	and	r24, r24
    2e36:	69 f0       	breq	.+26     	; 0x2e52 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2e38:	de 01       	movw	r26, r28
    2e3a:	11 96       	adiw	r26, 0x01	; 1
    2e3c:	31 96       	adiw	r30, 0x01	; 1
    2e3e:	90 e0       	ldi	r25, 0x00	; 0
    2e40:	02 c0       	rjmp	.+4      	; 0x2e46 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2e42:	99 30       	cpi	r25, 0x09	; 9
    2e44:	39 f0       	breq	.+14     	; 0x2e54 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2e46:	9f 5f       	subi	r25, 0xFF	; 255
    2e48:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2e4a:	81 91       	ld	r24, Z+
    2e4c:	81 11       	cpse	r24, r1
    2e4e:	f9 cf       	rjmp	.-14     	; 0x2e42 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2e50:	01 c0       	rjmp	.+2      	; 0x2e54 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2e52:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2e54:	e1 e0       	ldi	r30, 0x01	; 1
    2e56:	f0 e0       	ldi	r31, 0x00	; 0
    2e58:	ec 0f       	add	r30, r28
    2e5a:	fd 1f       	adc	r31, r29
    2e5c:	e9 0f       	add	r30, r25
    2e5e:	f1 1d       	adc	r31, r1
    2e60:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2e62:	74 01       	movw	r14, r8
    2e64:	f2 e0       	ldi	r31, 0x02	; 2
    2e66:	ef 0e       	add	r14, r31
    2e68:	f1 1c       	adc	r15, r1
    2e6a:	a1 2c       	mov	r10, r1
    2e6c:	b1 2c       	mov	r11, r1
    2e6e:	c1 2c       	mov	r12, r1
    2e70:	d1 2c       	mov	r13, r1
    2e72:	04 2f       	mov	r16, r20
    2e74:	94 01       	movw	r18, r8
    2e76:	a2 01       	movw	r20, r4
    2e78:	be 01       	movw	r22, r28
    2e7a:	6f 5f       	subi	r22, 0xFF	; 255
    2e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e7e:	82 e9       	ldi	r24, 0x92	; 146
    2e80:	93 e0       	ldi	r25, 0x03	; 3
    2e82:	0e 94 77 11 	call	0x22ee	; 0x22ee <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2e86:	f4 01       	movw	r30, r8
    2e88:	66 82       	std	Z+6, r6	; 0x06
    2e8a:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2e8c:	40 86       	std	Z+8, r4	; 0x08
    2e8e:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2e90:	20 91 1a 31 	lds	r18, 0x311A	; 0x80311a <last_created_task_pointer>
    2e94:	30 91 1b 31 	lds	r19, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2e98:	24 83       	std	Z+4, r18	; 0x04
    2e9a:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2e9c:	80 92 1a 31 	sts	0x311A, r8	; 0x80311a <last_created_task_pointer>
    2ea0:	90 92 1b 31 	sts	0x311B, r9	; 0x80311b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2ea4:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2ea6:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2ea8:	40 90 58 31 	lds	r4, 0x3158	; 0x803158 <portStackTopForTask>
    2eac:	50 90 59 31 	lds	r5, 0x3159	; 0x803159 <portStackTopForTask+0x1>
    2eb0:	ff ef       	ldi	r31, 0xFF	; 255
    2eb2:	4f 1a       	sub	r4, r31
    2eb4:	5f 0a       	sbc	r5, r31
    2eb6:	40 92 58 31 	sts	0x3158, r4	; 0x803158 <portStackTopForTask>
    2eba:	50 92 59 31 	sts	0x3159, r5	; 0x803159 <portStackTopForTask+0x1>
    2ebe:	f4 01       	movw	r30, r8
    2ec0:	42 86       	std	Z+10, r4	; 0x0a
    2ec2:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2ec4:	16 86       	std	Z+14, r1	; 0x0e
    2ec6:	17 86       	std	Z+15, r1	; 0x0f
    2ec8:	10 8a       	std	Z+16, r1	; 0x10
    2eca:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2ecc:	61 14       	cp	r6, r1
    2ece:	71 04       	cpc	r7, r1
    2ed0:	09 f4       	brne	.+2      	; 0x2ed4 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2ed2:	44 c0       	rjmp	.+136    	; 0x2f5c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2ed4:	81 30       	cpi	r24, 0x01	; 1
    2ed6:	79 f5       	brne	.+94     	; 0x2f36 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2ed8:	6a e0       	ldi	r22, 0x0A	; 10
    2eda:	c3 01       	movw	r24, r6
    2edc:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2ee0:	7c 01       	movw	r14, r24
    2ee2:	60 e7       	ldi	r22, 0x70	; 112
    2ee4:	76 e0       	ldi	r23, 0x06	; 6
    2ee6:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    2eea:	be 01       	movw	r22, r28
    2eec:	6f 5f       	subi	r22, 0xFF	; 255
    2eee:	7f 4f       	sbci	r23, 0xFF	; 255
    2ef0:	c7 01       	movw	r24, r14
    2ef2:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    2ef6:	6a e0       	ldi	r22, 0x0A	; 10
    2ef8:	c7 01       	movw	r24, r14
    2efa:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2efe:	7c 01       	movw	r14, r24
    2f00:	67 e6       	ldi	r22, 0x67	; 103
    2f02:	76 e0       	ldi	r23, 0x06	; 6
    2f04:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2f08:	6a e0       	ldi	r22, 0x0A	; 10
    2f0a:	c7 01       	movw	r24, r14
    2f0c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2f10:	7c 01       	movw	r14, r24
    2f12:	69 e5       	ldi	r22, 0x59	; 89
    2f14:	76 e0       	ldi	r23, 0x06	; 6
    2f16:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    2f1a:	63 e0       	ldi	r22, 0x03	; 3
    2f1c:	c7 01       	movw	r24, r14
    2f1e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2f22:	b2 01       	movw	r22, r4
    2f24:	0e 94 a7 1c 	call	0x394e	; 0x394e <_ZN8emstreamlsEj>
    2f28:	62 e0       	ldi	r22, 0x02	; 2
    2f2a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2f2e:	66 e0       	ldi	r22, 0x06	; 6
    2f30:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2f34:	13 c0       	rjmp	.+38     	; 0x2f5c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2f36:	6a e0       	ldi	r22, 0x0A	; 10
    2f38:	c3 01       	movw	r24, r6
    2f3a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2f3e:	4c 01       	movw	r8, r24
    2f40:	64 e4       	ldi	r22, 0x44	; 68
    2f42:	76 e0       	ldi	r23, 0x06	; 6
    2f44:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    2f48:	be 01       	movw	r22, r28
    2f4a:	6f 5f       	subi	r22, 0xFF	; 255
    2f4c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f4e:	c4 01       	movw	r24, r8
    2f50:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    2f54:	66 e0       	ldi	r22, 0x06	; 6
    2f56:	c4 01       	movw	r24, r8
    2f58:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2f5c:	2a 96       	adiw	r28, 0x0a	; 10
    2f5e:	cd bf       	out	0x3d, r28	; 61
    2f60:	de bf       	out	0x3e, r29	; 62
    2f62:	df 91       	pop	r29
    2f64:	cf 91       	pop	r28
    2f66:	1f 91       	pop	r17
    2f68:	0f 91       	pop	r16
    2f6a:	ff 90       	pop	r15
    2f6c:	ef 90       	pop	r14
    2f6e:	df 90       	pop	r13
    2f70:	cf 90       	pop	r12
    2f72:	bf 90       	pop	r11
    2f74:	af 90       	pop	r10
    2f76:	9f 90       	pop	r9
    2f78:	8f 90       	pop	r8
    2f7a:	7f 90       	pop	r7
    2f7c:	6f 90       	pop	r6
    2f7e:	5f 90       	pop	r5
    2f80:	4f 90       	pop	r4
    2f82:	08 95       	ret

00002f84 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2f84:	cf 92       	push	r12
    2f86:	df 92       	push	r13
    2f88:	ef 92       	push	r14
    2f8a:	ff 92       	push	r15
    2f8c:	0f 93       	push	r16
    2f8e:	1f 93       	push	r17
    2f90:	cf 93       	push	r28
    2f92:	df 93       	push	r29
    2f94:	ec 01       	movw	r28, r24
    2f96:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2f98:	8a 81       	ldd	r24, Y+2	; 0x02
    2f9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f9c:	0e 94 ce 12 	call	0x259c	; 0x259c <pcTaskGetTaskName>
    2fa0:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2fa2:	6a e0       	ldi	r22, 0x0A	; 10
    2fa4:	c7 01       	movw	r24, r14
    2fa6:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2faa:	8c 01       	movw	r16, r24
    2fac:	63 e8       	ldi	r22, 0x83	; 131
    2fae:	76 e0       	ldi	r23, 0x06	; 6
    2fb0:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    2fb4:	6a e0       	ldi	r22, 0x0A	; 10
    2fb6:	c8 01       	movw	r24, r16
    2fb8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2fbc:	8c 01       	movw	r16, r24
    2fbe:	6c e7       	ldi	r22, 0x7C	; 124
    2fc0:	76 e0       	ldi	r23, 0x06	; 6
    2fc2:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    2fc6:	b6 01       	movw	r22, r12
    2fc8:	c8 01       	movw	r24, r16
    2fca:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2fce:	6a e0       	ldi	r22, 0x0A	; 10
    2fd0:	c8 01       	movw	r24, r16
    2fd2:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    2fd6:	8c 01       	movw	r16, r24
    2fd8:	66 e7       	ldi	r22, 0x76	; 118
    2fda:	76 e0       	ldi	r23, 0x06	; 6
    2fdc:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    2fe0:	66 e0       	ldi	r22, 0x06	; 6
    2fe2:	c8 01       	movw	r24, r16
    2fe4:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2fe8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fea:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fec:	e8 85       	ldd	r30, Y+8	; 0x08
    2fee:	f9 85       	ldd	r31, Y+9	; 0x09
    2ff0:	01 e1       	ldi	r16, 0x11	; 17
    2ff2:	21 e0       	ldi	r18, 0x01	; 1
    2ff4:	a7 01       	movw	r20, r14
    2ff6:	bc 01       	movw	r22, r24
    2ff8:	8e 1b       	sub	r24, r30
    2ffa:	9f 0b       	sbc	r25, r31
    2ffc:	0e 94 c4 1a 	call	0x3588	; 0x3588 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    3000:	8c 81       	ldd	r24, Y+4	; 0x04
    3002:	9d 81       	ldd	r25, Y+5	; 0x05
    3004:	00 97       	sbiw	r24, 0x00	; 0
    3006:	19 f0       	breq	.+6      	; 0x300e <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    3008:	b7 01       	movw	r22, r14
    300a:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    300e:	df 91       	pop	r29
    3010:	cf 91       	pop	r28
    3012:	1f 91       	pop	r17
    3014:	0f 91       	pop	r16
    3016:	ff 90       	pop	r15
    3018:	ef 90       	pop	r14
    301a:	df 90       	pop	r13
    301c:	cf 90       	pop	r12
    301e:	08 95       	ret

00003020 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3020:	0f 93       	push	r16
    3022:	1f 93       	push	r17
    3024:	cf 93       	push	r28
    3026:	df 93       	push	r29
    3028:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    302a:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    302e:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    3032:	00 97       	sbiw	r24, 0x00	; 0
    3034:	19 f0       	breq	.+6      	; 0x303c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3036:	be 01       	movw	r22, r28
    3038:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    303c:	6a e0       	ldi	r22, 0x0A	; 10
    303e:	ce 01       	movw	r24, r28
    3040:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3044:	8c 01       	movw	r16, r24
    3046:	69 e9       	ldi	r22, 0x99	; 153
    3048:	76 e0       	ldi	r23, 0x06	; 6
    304a:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    304e:	6a e0       	ldi	r22, 0x0A	; 10
    3050:	c8 01       	movw	r24, r16
    3052:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3056:	8c 01       	movw	r16, r24
    3058:	6e e8       	ldi	r22, 0x8E	; 142
    305a:	76 e0       	ldi	r23, 0x06	; 6
    305c:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    3060:	6a e0       	ldi	r22, 0x0A	; 10
    3062:	c8 01       	movw	r24, r16
    3064:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3068:	8c 01       	movw	r16, r24
    306a:	68 e8       	ldi	r22, 0x88	; 136
    306c:	76 e0       	ldi	r23, 0x06	; 6
    306e:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    3072:	66 e0       	ldi	r22, 0x06	; 6
    3074:	c8 01       	movw	r24, r16
    3076:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    307a:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <portStackTopForTask>
    307e:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <portStackTopForTask+0x1>
    3082:	bc 01       	movw	r22, r24
    3084:	6f 5f       	subi	r22, 0xFF	; 255
    3086:	7f 4f       	sbci	r23, 0xFF	; 255
    3088:	01 e1       	ldi	r16, 0x11	; 17
    308a:	21 e0       	ldi	r18, 0x01	; 1
    308c:	ae 01       	movw	r20, r28
    308e:	83 56       	subi	r24, 0x63	; 99
    3090:	91 09       	sbc	r25, r1
    3092:	0e 94 c4 1a 	call	0x3588	; 0x3588 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    3096:	df 91       	pop	r29
    3098:	cf 91       	pop	r28
    309a:	1f 91       	pop	r17
    309c:	0f 91       	pop	r16
    309e:	08 95       	ret

000030a0 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    30a0:	8f 92       	push	r8
    30a2:	9f 92       	push	r9
    30a4:	af 92       	push	r10
    30a6:	bf 92       	push	r11
    30a8:	cf 92       	push	r12
    30aa:	df 92       	push	r13
    30ac:	ef 92       	push	r14
    30ae:	ff 92       	push	r15
    30b0:	0f 93       	push	r16
    30b2:	1f 93       	push	r17
    30b4:	cf 93       	push	r28
    30b6:	df 93       	push	r29
    30b8:	ec 01       	movw	r28, r24
    30ba:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    30bc:	8a 81       	ldd	r24, Y+2	; 0x02
    30be:	9b 81       	ldd	r25, Y+3	; 0x03
    30c0:	0e 94 ce 12 	call	0x259c	; 0x259c <pcTaskGetTaskName>
    30c4:	bc 01       	movw	r22, r24
    30c6:	c8 01       	movw	r24, r16
    30c8:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    30cc:	d8 01       	movw	r26, r16
    30ce:	ed 91       	ld	r30, X+
    30d0:	fc 91       	ld	r31, X
    30d2:	02 80       	ldd	r0, Z+2	; 0x02
    30d4:	f3 81       	ldd	r31, Z+3	; 0x03
    30d6:	e0 2d       	mov	r30, r0
    30d8:	69 e0       	ldi	r22, 0x09	; 9
    30da:	c8 01       	movw	r24, r16
    30dc:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    30de:	8a 81       	ldd	r24, Y+2	; 0x02
    30e0:	9b 81       	ldd	r25, Y+3	; 0x03
    30e2:	0e 94 ce 12 	call	0x259c	; 0x259c <pcTaskGetTaskName>
    30e6:	fc 01       	movw	r30, r24
    30e8:	01 90       	ld	r0, Z+
    30ea:	00 20       	and	r0, r0
    30ec:	e9 f7       	brne	.-6      	; 0x30e8 <_ZN8frt_task12print_statusER8emstream+0x48>
    30ee:	31 97       	sbiw	r30, 0x01	; 1
    30f0:	e8 1b       	sub	r30, r24
    30f2:	f9 0b       	sbc	r31, r25
    30f4:	38 97       	sbiw	r30, 0x08	; 8
    30f6:	48 f4       	brcc	.+18     	; 0x310a <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    30f8:	d8 01       	movw	r26, r16
    30fa:	ed 91       	ld	r30, X+
    30fc:	fc 91       	ld	r31, X
    30fe:	02 80       	ldd	r0, Z+2	; 0x02
    3100:	f3 81       	ldd	r31, Z+3	; 0x03
    3102:	e0 2d       	mov	r30, r0
    3104:	69 e0       	ldi	r22, 0x09	; 9
    3106:	c8 01       	movw	r24, r16
    3108:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    310a:	ce 84       	ldd	r12, Y+14	; 0x0e
    310c:	df 84       	ldd	r13, Y+15	; 0x0f
    310e:	e8 88       	ldd	r14, Y+16	; 0x10
    3110:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    3112:	a8 84       	ldd	r10, Y+8	; 0x08
    3114:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3116:	8a 81       	ldd	r24, Y+2	; 0x02
    3118:	9b 81       	ldd	r25, Y+3	; 0x03
    311a:	0e 94 41 16 	call	0x2c82	; 0x2c82 <uxTaskGetStackHighWaterMark>
    311e:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3120:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3122:	8a 81       	ldd	r24, Y+2	; 0x02
    3124:	9b 81       	ldd	r25, Y+3	; 0x03
    3126:	0e 94 79 12 	call	0x24f2	; 0x24f2 <uxTaskPriorityGet>
    312a:	68 2f       	mov	r22, r24
    312c:	c8 01       	movw	r24, r16
    312e:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
    3132:	6a e0       	ldi	r22, 0x0A	; 10
    3134:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3138:	ec 01       	movw	r28, r24
    313a:	6e e0       	ldi	r22, 0x0E	; 14
    313c:	77 e0       	ldi	r23, 0x07	; 7
    313e:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3142:	68 2d       	mov	r22, r8
    3144:	ce 01       	movw	r24, r28
    3146:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    314a:	6a e0       	ldi	r22, 0x0A	; 10
    314c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3150:	ec 01       	movw	r28, r24
    3152:	6c e0       	ldi	r22, 0x0C	; 12
    3154:	77 e0       	ldi	r23, 0x07	; 7
    3156:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    315a:	69 2d       	mov	r22, r9
    315c:	ce 01       	movw	r24, r28
    315e:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
    3162:	6a e0       	ldi	r22, 0x0A	; 10
    3164:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3168:	ec 01       	movw	r28, r24
    316a:	6a e0       	ldi	r22, 0x0A	; 10
    316c:	77 e0       	ldi	r23, 0x07	; 7
    316e:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3172:	b5 01       	movw	r22, r10
    3174:	ce 01       	movw	r24, r28
    3176:	0e 94 a7 1c 	call	0x394e	; 0x394e <_ZN8emstreamlsEj>
    317a:	6a e0       	ldi	r22, 0x0A	; 10
    317c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3180:	ec 01       	movw	r28, r24
    3182:	68 e0       	ldi	r22, 0x08	; 8
    3184:	77 e0       	ldi	r23, 0x07	; 7
    3186:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    318a:	6a e0       	ldi	r22, 0x0A	; 10
    318c:	ce 01       	movw	r24, r28
    318e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3192:	ec 01       	movw	r28, r24
    3194:	66 e0       	ldi	r22, 0x06	; 6
    3196:	77 e0       	ldi	r23, 0x07	; 7
    3198:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    319c:	b7 01       	movw	r22, r14
    319e:	a6 01       	movw	r20, r12
    31a0:	ce 01       	movw	r24, r28
    31a2:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <_ZN8emstreamlsEm>
}
    31a6:	df 91       	pop	r29
    31a8:	cf 91       	pop	r28
    31aa:	1f 91       	pop	r17
    31ac:	0f 91       	pop	r16
    31ae:	ff 90       	pop	r15
    31b0:	ef 90       	pop	r14
    31b2:	df 90       	pop	r13
    31b4:	cf 90       	pop	r12
    31b6:	bf 90       	pop	r11
    31b8:	af 90       	pop	r10
    31ba:	9f 90       	pop	r9
    31bc:	8f 90       	pop	r8
    31be:	08 95       	ret

000031c0 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    31c0:	cf 93       	push	r28
    31c2:	df 93       	push	r29
    31c4:	ec 01       	movw	r28, r24
    31c6:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    31c8:	db 01       	movw	r26, r22
    31ca:	ed 91       	ld	r30, X+
    31cc:	fc 91       	ld	r31, X
    31ce:	02 80       	ldd	r0, Z+2	; 0x02
    31d0:	f3 81       	ldd	r31, Z+3	; 0x03
    31d2:	e0 2d       	mov	r30, r0
    31d4:	be 01       	movw	r22, r28
    31d6:	19 95       	eicall
	return (ser_dev);
}
    31d8:	ce 01       	movw	r24, r28
    31da:	df 91       	pop	r29
    31dc:	cf 91       	pop	r28
    31de:	08 95       	ret

000031e0 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    31e0:	0f 93       	push	r16
    31e2:	1f 93       	push	r17
    31e4:	cf 93       	push	r28
    31e6:	df 93       	push	r29
    31e8:	ec 01       	movw	r28, r24
    31ea:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    31ec:	bc 01       	movw	r22, r24
    31ee:	c8 01       	movw	r24, r16
    31f0:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <_ZlsR8emstreamR8frt_task>
    31f4:	66 e0       	ldi	r22, 0x06	; 6
    31f6:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    31fa:	8c 81       	ldd	r24, Y+4	; 0x04
    31fc:	9d 81       	ldd	r25, Y+5	; 0x05
    31fe:	00 97       	sbiw	r24, 0x00	; 0
    3200:	19 f0       	breq	.+6      	; 0x3208 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3202:	b8 01       	movw	r22, r16
    3204:	0e 94 f0 18 	call	0x31e0	; 0x31e0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    3208:	df 91       	pop	r29
    320a:	cf 91       	pop	r28
    320c:	1f 91       	pop	r17
    320e:	0f 91       	pop	r16
    3210:	08 95       	ret

00003212 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    3212:	0f 93       	push	r16
    3214:	1f 93       	push	r17
    3216:	cf 93       	push	r28
    3218:	df 93       	push	r29
    321a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    321c:	6a e0       	ldi	r22, 0x0A	; 10
    321e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3222:	8c 01       	movw	r16, r24
    3224:	6b ef       	ldi	r22, 0xFB	; 251
    3226:	76 e0       	ldi	r23, 0x06	; 6
    3228:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    322c:	6a e0       	ldi	r22, 0x0A	; 10
    322e:	c8 01       	movw	r24, r16
    3230:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3234:	8c 01       	movw	r16, r24
    3236:	64 ef       	ldi	r22, 0xF4	; 244
    3238:	76 e0       	ldi	r23, 0x06	; 6
    323a:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    323e:	66 e0       	ldi	r22, 0x06	; 6
    3240:	c8 01       	movw	r24, r16
    3242:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3246:	6a e0       	ldi	r22, 0x0A	; 10
    3248:	ce 01       	movw	r24, r28
    324a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    324e:	8c 01       	movw	r16, r24
    3250:	63 ee       	ldi	r22, 0xE3	; 227
    3252:	76 e0       	ldi	r23, 0x06	; 6
    3254:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    3258:	6a e0       	ldi	r22, 0x0A	; 10
    325a:	c8 01       	movw	r24, r16
    325c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3260:	8c 01       	movw	r16, r24
    3262:	67 ed       	ldi	r22, 0xD7	; 215
    3264:	76 e0       	ldi	r23, 0x06	; 6
    3266:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    326a:	6a e0       	ldi	r22, 0x0A	; 10
    326c:	c8 01       	movw	r24, r16
    326e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3272:	8c 01       	movw	r16, r24
    3274:	61 ed       	ldi	r22, 0xD1	; 209
    3276:	76 e0       	ldi	r23, 0x06	; 6
    3278:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    327c:	66 e0       	ldi	r22, 0x06	; 6
    327e:	c8 01       	movw	r24, r16
    3280:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3284:	6a e0       	ldi	r22, 0x0A	; 10
    3286:	ce 01       	movw	r24, r28
    3288:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    328c:	8c 01       	movw	r16, r24
    328e:	60 ec       	ldi	r22, 0xC0	; 192
    3290:	76 e0       	ldi	r23, 0x06	; 6
    3292:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    3296:	6a e0       	ldi	r22, 0x0A	; 10
    3298:	c8 01       	movw	r24, r16
    329a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    329e:	8c 01       	movw	r16, r24
    32a0:	64 eb       	ldi	r22, 0xB4	; 180
    32a2:	76 e0       	ldi	r23, 0x06	; 6
    32a4:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    32a8:	6a e0       	ldi	r22, 0x0A	; 10
    32aa:	c8 01       	movw	r24, r16
    32ac:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    32b0:	8c 01       	movw	r16, r24
    32b2:	6e ea       	ldi	r22, 0xAE	; 174
    32b4:	76 e0       	ldi	r23, 0x06	; 6
    32b6:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    32ba:	66 e0       	ldi	r22, 0x06	; 6
    32bc:	c8 01       	movw	r24, r16
    32be:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    32c2:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    32c6:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    32ca:	00 97       	sbiw	r24, 0x00	; 0
    32cc:	19 f0       	breq	.+6      	; 0x32d4 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    32ce:	be 01       	movw	r22, r28
    32d0:	0e 94 f0 18 	call	0x31e0	; 0x31e0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    32d4:	0e 94 d6 12 	call	0x25ac	; 0x25ac <xTaskGetIdleTaskHandle>
    32d8:	0e 94 41 16 	call	0x2c82	; 0x2c82 <uxTaskGetStackHighWaterMark>
    32dc:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    32de:	6a e0       	ldi	r22, 0x0A	; 10
    32e0:	ce 01       	movw	r24, r28
    32e2:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    32e6:	ec 01       	movw	r28, r24
    32e8:	63 ea       	ldi	r22, 0xA3	; 163
    32ea:	76 e0       	ldi	r23, 0x06	; 6
    32ec:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    32f0:	61 2f       	mov	r22, r17
    32f2:	ce 01       	movw	r24, r28
    32f4:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    32f8:	6a e0       	ldi	r22, 0x0A	; 10
    32fa:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    32fe:	ec 01       	movw	r28, r24
    3300:	61 ea       	ldi	r22, 0xA1	; 161
    3302:	76 e0       	ldi	r23, 0x06	; 6
    3304:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    3308:	64 e6       	ldi	r22, 0x64	; 100
    330a:	70 e0       	ldi	r23, 0x00	; 0
    330c:	ce 01       	movw	r24, r28
    330e:	0e 94 a7 1c 	call	0x394e	; 0x394e <_ZN8emstreamlsEj>
    3312:	6a e0       	ldi	r22, 0x0A	; 10
    3314:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3318:	ec 01       	movw	r28, r24
    331a:	6e e9       	ldi	r22, 0x9E	; 158
    331c:	76 e0       	ldi	r23, 0x06	; 6
    331e:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3322:	66 e0       	ldi	r22, 0x06	; 6
    3324:	ce 01       	movw	r24, r28
    3326:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
}
    332a:	df 91       	pop	r29
    332c:	cf 91       	pop	r28
    332e:	1f 91       	pop	r17
    3330:	0f 91       	pop	r16
    3332:	08 95       	ret

00003334 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3334:	0f 93       	push	r16
    3336:	cf 93       	push	r28
    3338:	df 93       	push	r29
    333a:	1f 92       	push	r1
    333c:	cd b7       	in	r28, 0x3d	; 61
    333e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3340:	00 e0       	ldi	r16, 0x00	; 0
    3342:	2f ef       	ldi	r18, 0xFF	; 255
    3344:	3f ef       	ldi	r19, 0xFF	; 255
    3346:	a9 01       	movw	r20, r18
    3348:	be 01       	movw	r22, r28
    334a:	6f 5f       	subi	r22, 0xFF	; 255
    334c:	7f 4f       	sbci	r23, 0xFF	; 255
    334e:	fc 01       	movw	r30, r24
    3350:	80 85       	ldd	r24, Z+8	; 0x08
    3352:	91 85       	ldd	r25, Z+9	; 0x09
    3354:	0e 94 55 10 	call	0x20aa	; 0x20aa <xQueueGenericReceive>
    3358:	81 30       	cpi	r24, 0x01	; 1
    335a:	19 f4       	brne	.+6      	; 0x3362 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    335c:	89 81       	ldd	r24, Y+1	; 0x01
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	02 c0       	rjmp	.+4      	; 0x3366 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3362:	8f ef       	ldi	r24, 0xFF	; 255
    3364:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3366:	0f 90       	pop	r0
    3368:	df 91       	pop	r29
    336a:	cf 91       	pop	r28
    336c:	0f 91       	pop	r16
    336e:	08 95       	ret

00003370 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3370:	fc 01       	movw	r30, r24
    3372:	80 85       	ldd	r24, Z+8	; 0x08
    3374:	91 85       	ldd	r25, Z+9	; 0x09
    3376:	0e 94 19 11 	call	0x2232	; 0x2232 <uxQueueMessagesWaiting>
    337a:	91 e0       	ldi	r25, 0x01	; 1
    337c:	81 11       	cpse	r24, r1
    337e:	01 c0       	rjmp	.+2      	; 0x3382 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3380:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3382:	89 2f       	mov	r24, r25
    3384:	08 95       	ret

00003386 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    3386:	0f 93       	push	r16
    3388:	cf 93       	push	r28
    338a:	df 93       	push	r29
    338c:	1f 92       	push	r1
    338e:	cd b7       	in	r28, 0x3d	; 61
    3390:	de b7       	in	r29, 0x3e	; 62
    3392:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3394:	fc 01       	movw	r30, r24
    3396:	22 85       	ldd	r18, Z+10	; 0x0a
    3398:	33 85       	ldd	r19, Z+11	; 0x0b
    339a:	44 85       	ldd	r20, Z+12	; 0x0c
    339c:	55 85       	ldd	r21, Z+13	; 0x0d
    339e:	00 e0       	ldi	r16, 0x00	; 0
    33a0:	be 01       	movw	r22, r28
    33a2:	6f 5f       	subi	r22, 0xFF	; 255
    33a4:	7f 4f       	sbci	r23, 0xFF	; 255
    33a6:	80 85       	ldd	r24, Z+8	; 0x08
    33a8:	91 85       	ldd	r25, Z+9	; 0x09
    33aa:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <xQueueGenericSend>
    33ae:	91 e0       	ldi	r25, 0x01	; 1
    33b0:	81 11       	cpse	r24, r1
    33b2:	01 c0       	rjmp	.+2      	; 0x33b6 <_ZN14frt_text_queue7putcharEc+0x30>
    33b4:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    33b6:	89 2f       	mov	r24, r25
    33b8:	0f 90       	pop	r0
    33ba:	df 91       	pop	r29
    33bc:	cf 91       	pop	r28
    33be:	0f 91       	pop	r16
    33c0:	08 95       	ret

000033c2 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    33c2:	8f 92       	push	r8
    33c4:	9f 92       	push	r9
    33c6:	bf 92       	push	r11
    33c8:	cf 92       	push	r12
    33ca:	df 92       	push	r13
    33cc:	ef 92       	push	r14
    33ce:	ff 92       	push	r15
    33d0:	0f 93       	push	r16
    33d2:	1f 93       	push	r17
    33d4:	cf 93       	push	r28
    33d6:	df 93       	push	r29
    33d8:	ec 01       	movw	r28, r24
    33da:	b6 2e       	mov	r11, r22
    33dc:	4a 01       	movw	r8, r20
    33de:	68 01       	movw	r12, r16
    33e0:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    33e2:	0e 94 1b 1c 	call	0x3836	; 0x3836 <_ZN8emstreamC1Ev>
    33e6:	8f e3       	ldi	r24, 0x3F	; 63
    33e8:	90 e2       	ldi	r25, 0x20	; 32
    33ea:	88 83       	st	Y, r24
    33ec:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    33ee:	8e 86       	std	Y+14, r8	; 0x0e
    33f0:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    33f2:	40 e0       	ldi	r20, 0x00	; 0
    33f4:	61 e0       	ldi	r22, 0x01	; 1
    33f6:	8b 2d       	mov	r24, r11
    33f8:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <xQueueGenericCreate>
    33fc:	88 87       	std	Y+8, r24	; 0x08
    33fe:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3400:	ca 86       	std	Y+10, r12	; 0x0a
    3402:	db 86       	std	Y+11, r13	; 0x0b
    3404:	ec 86       	std	Y+12, r14	; 0x0c
    3406:	fd 86       	std	Y+13, r15	; 0x0d
}
    3408:	df 91       	pop	r29
    340a:	cf 91       	pop	r28
    340c:	1f 91       	pop	r17
    340e:	0f 91       	pop	r16
    3410:	ff 90       	pop	r15
    3412:	ef 90       	pop	r14
    3414:	df 90       	pop	r13
    3416:	cf 90       	pop	r12
    3418:	bf 90       	pop	r11
    341a:	9f 90       	pop	r9
    341c:	8f 90       	pop	r8
    341e:	08 95       	ret

00003420 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3420:	cf 92       	push	r12
    3422:	df 92       	push	r13
    3424:	ef 92       	push	r14
    3426:	ff 92       	push	r15
    3428:	cf 93       	push	r28
    342a:	df 93       	push	r29
    342c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    342e:	68 81       	ld	r22, Y
    3430:	79 81       	ldd	r23, Y+1	; 0x01
    3432:	8a 81       	ldd	r24, Y+2	; 0x02
    3434:	9b 81       	ldd	r25, Y+3	; 0x03
    3436:	0f 2e       	mov	r0, r31
    3438:	f8 ee       	ldi	r31, 0xE8	; 232
    343a:	cf 2e       	mov	r12, r31
    343c:	f3 e0       	ldi	r31, 0x03	; 3
    343e:	df 2e       	mov	r13, r31
    3440:	e1 2c       	mov	r14, r1
    3442:	f1 2c       	mov	r15, r1
    3444:	f0 2d       	mov	r31, r0
    3446:	a7 01       	movw	r20, r14
    3448:	96 01       	movw	r18, r12
    344a:	0e 94 9d 21 	call	0x433a	; 0x433a <__udivmodsi4>
    344e:	9b 01       	movw	r18, r22
    3450:	ac 01       	movw	r20, r24
    3452:	60 e4       	ldi	r22, 0x40	; 64
    3454:	72 e4       	ldi	r23, 0x42	; 66
    3456:	8f e0       	ldi	r24, 0x0F	; 15
    3458:	90 e0       	ldi	r25, 0x00	; 0
    345a:	0e 94 79 21 	call	0x42f2	; 0x42f2 <__mulsi3>
    345e:	a7 01       	movw	r20, r14
    3460:	96 01       	movw	r18, r12
    3462:	0e 94 9d 21 	call	0x433a	; 0x433a <__udivmodsi4>
    3466:	69 01       	movw	r12, r18
    3468:	7a 01       	movw	r14, r20
    346a:	ac 81       	ldd	r26, Y+4	; 0x04
    346c:	bd 81       	ldd	r27, Y+5	; 0x05
    346e:	20 e4       	ldi	r18, 0x40	; 64
    3470:	32 e4       	ldi	r19, 0x42	; 66
    3472:	4f e0       	ldi	r20, 0x0F	; 15
    3474:	50 e0       	ldi	r21, 0x00	; 0
    3476:	0e 94 05 22 	call	0x440a	; 0x440a <__muluhisi3>
    347a:	20 e0       	ldi	r18, 0x00	; 0
    347c:	38 e4       	ldi	r19, 0x48	; 72
    347e:	48 ee       	ldi	r20, 0xE8	; 232
    3480:	51 e0       	ldi	r21, 0x01	; 1
    3482:	0e 94 9d 21 	call	0x433a	; 0x433a <__udivmodsi4>
    3486:	c7 01       	movw	r24, r14
    3488:	b6 01       	movw	r22, r12
    348a:	62 0f       	add	r22, r18
    348c:	73 1f       	adc	r23, r19
    348e:	84 1f       	adc	r24, r20
    3490:	95 1f       	adc	r25, r21
}
    3492:	df 91       	pop	r29
    3494:	cf 91       	pop	r28
    3496:	ff 90       	pop	r15
    3498:	ef 90       	pop	r14
    349a:	df 90       	pop	r13
    349c:	cf 90       	pop	r12
    349e:	08 95       	ret

000034a0 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    34a0:	cf 92       	push	r12
    34a2:	df 92       	push	r13
    34a4:	ef 92       	push	r14
    34a6:	ff 92       	push	r15
    34a8:	0f 93       	push	r16
    34aa:	1f 93       	push	r17
    34ac:	cf 93       	push	r28
    34ae:	df 93       	push	r29
    34b0:	cd b7       	in	r28, 0x3d	; 61
    34b2:	de b7       	in	r29, 0x3e	; 62
    34b4:	2f 97       	sbiw	r28, 0x0f	; 15
    34b6:	cd bf       	out	0x3d, r28	; 61
    34b8:	de bf       	out	0x3e, r29	; 62
    34ba:	6c 01       	movw	r12, r24
    34bc:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    34be:	db 01       	movw	r26, r22
    34c0:	6d 91       	ld	r22, X+
    34c2:	7d 91       	ld	r23, X+
    34c4:	8d 91       	ld	r24, X+
    34c6:	9c 91       	ld	r25, X
    34c8:	28 ee       	ldi	r18, 0xE8	; 232
    34ca:	33 e0       	ldi	r19, 0x03	; 3
    34cc:	40 e0       	ldi	r20, 0x00	; 0
    34ce:	50 e0       	ldi	r21, 0x00	; 0
    34d0:	0e 94 9d 21 	call	0x433a	; 0x433a <__udivmodsi4>
    34d4:	ba 01       	movw	r22, r20
    34d6:	a9 01       	movw	r20, r18
    34d8:	c6 01       	movw	r24, r12
    34da:	0e 94 db 1c 	call	0x39b6	; 0x39b6 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    34de:	d6 01       	movw	r26, r12
    34e0:	ed 91       	ld	r30, X+
    34e2:	fc 91       	ld	r31, X
    34e4:	02 80       	ldd	r0, Z+2	; 0x02
    34e6:	f3 81       	ldd	r31, Z+3	; 0x03
    34e8:	e0 2d       	mov	r30, r0
    34ea:	6e e2       	ldi	r22, 0x2E	; 46
    34ec:	c6 01       	movw	r24, r12
    34ee:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    34f0:	c8 01       	movw	r24, r16
    34f2:	0e 94 10 1a 	call	0x3420	; 0x3420 <_ZN10time_stamp12get_microsecEv>
    34f6:	8e 01       	movw	r16, r28
    34f8:	09 5f       	subi	r16, 0xF9	; 249
    34fa:	1f 4f       	sbci	r17, 0xFF	; 255
    34fc:	fe 01       	movw	r30, r28
    34fe:	31 96       	adiw	r30, 0x01	; 1
    3500:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3502:	2a e0       	ldi	r18, 0x0A	; 10
    3504:	30 e0       	ldi	r19, 0x00	; 0
    3506:	40 e0       	ldi	r20, 0x00	; 0
    3508:	50 e0       	ldi	r21, 0x00	; 0
    350a:	0e 94 bf 21 	call	0x437e	; 0x437e <__divmodsi4>
    350e:	e6 2f       	mov	r30, r22
    3510:	28 87       	std	Y+8, r18	; 0x08
    3512:	39 87       	std	Y+9, r19	; 0x09
    3514:	4a 87       	std	Y+10, r20	; 0x0a
    3516:	5b 87       	std	Y+11, r21	; 0x0b
    3518:	68 85       	ldd	r22, Y+8	; 0x08
    351a:	79 85       	ldd	r23, Y+9	; 0x09
    351c:	8a 85       	ldd	r24, Y+10	; 0x0a
    351e:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3520:	20 e3       	ldi	r18, 0x30	; 48
    3522:	2e 0f       	add	r18, r30
    3524:	d8 01       	movw	r26, r16
    3526:	2e 93       	st	-X, r18
    3528:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    352a:	ae 15       	cp	r26, r14
    352c:	bf 05       	cpc	r27, r15
    352e:	49 f7       	brne	.-46     	; 0x3502 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3530:	1f 82       	std	Y+7, r1	; 0x07
    3532:	be 01       	movw	r22, r28
    3534:	6f 5f       	subi	r22, 0xFF	; 255
    3536:	7f 4f       	sbci	r23, 0xFF	; 255
    3538:	c6 01       	movw	r24, r12
    353a:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    353e:	c6 01       	movw	r24, r12
    3540:	2f 96       	adiw	r28, 0x0f	; 15
    3542:	cd bf       	out	0x3d, r28	; 61
    3544:	de bf       	out	0x3e, r29	; 62
    3546:	df 91       	pop	r29
    3548:	cf 91       	pop	r28
    354a:	1f 91       	pop	r17
    354c:	0f 91       	pop	r16
    354e:	ff 90       	pop	r15
    3550:	ef 90       	pop	r14
    3552:	df 90       	pop	r13
    3554:	cf 90       	pop	r12
    3556:	08 95       	ret

00003558 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3558:	cf 93       	push	r28
    355a:	df 93       	push	r29
    355c:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    355e:	0f b6       	in	r0, 0x3f	; 63
    3560:	f8 94       	cli
    3562:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3564:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3568:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    356c:	8c 83       	std	Y+4, r24	; 0x04
    356e:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3570:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskGetTickCount>
    3574:	68 83       	st	Y, r22
    3576:	79 83       	std	Y+1, r23	; 0x01
    3578:	8a 83       	std	Y+2, r24	; 0x02
    357a:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    357c:	0f 90       	pop	r0
    357e:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3580:	ce 01       	movw	r24, r28
    3582:	df 91       	pop	r29
    3584:	cf 91       	pop	r28
    3586:	08 95       	ret

00003588 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3588:	5f 92       	push	r5
    358a:	6f 92       	push	r6
    358c:	7f 92       	push	r7
    358e:	8f 92       	push	r8
    3590:	9f 92       	push	r9
    3592:	af 92       	push	r10
    3594:	bf 92       	push	r11
    3596:	cf 92       	push	r12
    3598:	df 92       	push	r13
    359a:	ef 92       	push	r14
    359c:	ff 92       	push	r15
    359e:	0f 93       	push	r16
    35a0:	1f 93       	push	r17
    35a2:	cf 93       	push	r28
    35a4:	df 93       	push	r29
    35a6:	5c 01       	movw	r10, r24
    35a8:	4b 01       	movw	r8, r22
    35aa:	7a 01       	movw	r14, r20
    35ac:	12 2f       	mov	r17, r18
    35ae:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    35b0:	63 e0       	ldi	r22, 0x03	; 3
    35b2:	ca 01       	movw	r24, r20
    35b4:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    35b8:	a8 14       	cp	r10, r8
    35ba:	b9 04       	cpc	r11, r9
    35bc:	08 f0       	brcs	.+2      	; 0x35c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    35be:	7d c0       	rjmp	.+250    	; 0x36ba <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    35c0:	65 01       	movw	r12, r10
    35c2:	84 e1       	ldi	r24, 0x14	; 20
    35c4:	c8 0e       	add	r12, r24
    35c6:	d1 1c       	adc	r13, r1
    35c8:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    35ca:	6a 2c       	mov	r6, r10
    35cc:	5b 2c       	mov	r5, r11
    35ce:	b5 01       	movw	r22, r10
    35d0:	c7 01       	movw	r24, r14
    35d2:	0e 94 a7 1c 	call	0x394e	; 0x394e <_ZN8emstreamlsEj>
    35d6:	6a e0       	ldi	r22, 0x0A	; 10
    35d8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    35dc:	60 e2       	ldi	r22, 0x20	; 32
    35de:	77 e0       	ldi	r23, 0x07	; 7
    35e0:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    35e4:	11 23       	and	r17, r17
    35e6:	09 f4       	brne	.+2      	; 0x35ea <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    35e8:	6d c0       	rjmp	.+218    	; 0x36c4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    35ea:	00 23       	and	r16, r16
    35ec:	09 f4       	brne	.+2      	; 0x35f0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    35ee:	6a c0       	rjmp	.+212    	; 0x36c4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    35f0:	6a e0       	ldi	r22, 0x0A	; 10
    35f2:	c7 01       	movw	r24, r14
    35f4:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    35f8:	6b e1       	ldi	r22, 0x1B	; 27
    35fa:	77 e0       	ldi	r23, 0x07	; 7
    35fc:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    3600:	61 c0       	rjmp	.+194    	; 0x36c4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3602:	11 23       	and	r17, r17
    3604:	71 f0       	breq	.+28     	; 0x3622 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3606:	01 11       	cpse	r16, r1
    3608:	0c c0       	rjmp	.+24     	; 0x3622 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    360a:	88 81       	ld	r24, Y
    360c:	87 15       	cp	r24, r7
    360e:	49 f0       	breq	.+18     	; 0x3622 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3610:	6a e0       	ldi	r22, 0x0A	; 10
    3612:	c7 01       	movw	r24, r14
    3614:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    3618:	66 e1       	ldi	r22, 0x16	; 22
    361a:	77 e0       	ldi	r23, 0x07	; 7
    361c:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3620:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3622:	69 91       	ld	r22, Y+
    3624:	c7 01       	movw	r24, r14
    3626:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    362a:	dc 01       	movw	r26, r24
    362c:	ed 91       	ld	r30, X+
    362e:	fc 91       	ld	r31, X
    3630:	02 80       	ldd	r0, Z+2	; 0x02
    3632:	f3 81       	ldd	r31, Z+3	; 0x03
    3634:	e0 2d       	mov	r30, r0
    3636:	60 e2       	ldi	r22, 0x20	; 32
    3638:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    363a:	cc 16       	cp	r12, r28
    363c:	dd 06       	cpc	r13, r29
    363e:	09 f7       	brne	.-62     	; 0x3602 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3640:	11 23       	and	r17, r17
    3642:	89 f0       	breq	.+34     	; 0x3666 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3644:	6a e0       	ldi	r22, 0x0A	; 10
    3646:	c7 01       	movw	r24, r14
    3648:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    364c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    364e:	60 e1       	ldi	r22, 0x10	; 16
    3650:	77 e0       	ldi	r23, 0x07	; 7
    3652:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3656:	e8 81       	ld	r30, Y
    3658:	f9 81       	ldd	r31, Y+1	; 0x01
    365a:	02 80       	ldd	r0, Z+2	; 0x02
    365c:	f3 81       	ldd	r31, Z+3	; 0x03
    365e:	e0 2d       	mov	r30, r0
    3660:	60 e2       	ldi	r22, 0x20	; 32
    3662:	ce 01       	movw	r24, r28
    3664:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3666:	c6 2d       	mov	r28, r6
    3668:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    366a:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    366c:	80 ee       	ldi	r24, 0xE0	; 224
    366e:	86 0f       	add	r24, r22
    3670:	8f 35       	cpi	r24, 0x5F	; 95
    3672:	48 f4       	brcc	.+18     	; 0x3686 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3674:	d7 01       	movw	r26, r14
    3676:	ed 91       	ld	r30, X+
    3678:	fc 91       	ld	r31, X
    367a:	02 80       	ldd	r0, Z+2	; 0x02
    367c:	f3 81       	ldd	r31, Z+3	; 0x03
    367e:	e0 2d       	mov	r30, r0
    3680:	c7 01       	movw	r24, r14
    3682:	19 95       	eicall
    3684:	09 c0       	rjmp	.+18     	; 0x3698 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3686:	d7 01       	movw	r26, r14
    3688:	ed 91       	ld	r30, X+
    368a:	fc 91       	ld	r31, X
    368c:	02 80       	ldd	r0, Z+2	; 0x02
    368e:	f3 81       	ldd	r31, Z+3	; 0x03
    3690:	e0 2d       	mov	r30, r0
    3692:	6e e2       	ldi	r22, 0x2E	; 46
    3694:	c7 01       	movw	r24, r14
    3696:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3698:	cc 16       	cp	r12, r28
    369a:	dd 06       	cpc	r13, r29
    369c:	31 f7       	brne	.-52     	; 0x366a <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    369e:	b4 e1       	ldi	r27, 0x14	; 20
    36a0:	ab 0e       	add	r10, r27
    36a2:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    36a4:	66 e0       	ldi	r22, 0x06	; 6
    36a6:	c7 01       	movw	r24, r14
    36a8:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    36ac:	84 e1       	ldi	r24, 0x14	; 20
    36ae:	c8 0e       	add	r12, r24
    36b0:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    36b2:	a8 14       	cp	r10, r8
    36b4:	b9 04       	cpc	r11, r9
    36b6:	08 f4       	brcc	.+2      	; 0x36ba <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    36b8:	88 cf       	rjmp	.-240    	; 0x35ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    36ba:	62 e0       	ldi	r22, 0x02	; 2
    36bc:	c7 01       	movw	r24, r14
    36be:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
}
    36c2:	03 c0       	rjmp	.+6      	; 0x36ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    36c4:	c6 2d       	mov	r28, r6
    36c6:	d5 2d       	mov	r29, r5
    36c8:	9c cf       	rjmp	.-200    	; 0x3602 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    36ca:	df 91       	pop	r29
    36cc:	cf 91       	pop	r28
    36ce:	1f 91       	pop	r17
    36d0:	0f 91       	pop	r16
    36d2:	ff 90       	pop	r15
    36d4:	ef 90       	pop	r14
    36d6:	df 90       	pop	r13
    36d8:	cf 90       	pop	r12
    36da:	bf 90       	pop	r11
    36dc:	af 90       	pop	r10
    36de:	9f 90       	pop	r9
    36e0:	8f 90       	pop	r8
    36e2:	7f 90       	pop	r7
    36e4:	6f 90       	pop	r6
    36e6:	5f 90       	pop	r5
    36e8:	08 95       	ret

000036ea <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    36ea:	0e 94 a6 0b 	call	0x174c	; 0x174c <pvPortMalloc>
    36ee:	08 95       	ret

000036f0 <_Znaj>:
    36f0:	0e 94 a6 0b 	call	0x174c	; 0x174c <pvPortMalloc>
    36f4:	08 95       	ret

000036f6 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    36f6:	08 95       	ret

000036f8 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    36f8:	cf 93       	push	r28
    36fa:	df 93       	push	r29
    36fc:	fc 01       	movw	r30, r24
    36fe:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3700:	40 3a       	cpi	r20, 0xA0	; 160
    3702:	68 e0       	ldi	r22, 0x08	; 8
    3704:	56 07       	cpc	r21, r22
    3706:	49 f4       	brne	.+18     	; 0x371a <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3708:	80 e4       	ldi	r24, 0x40	; 64
    370a:	96 e0       	ldi	r25, 0x06	; 6
    370c:	82 83       	std	Z+2, r24	; 0x02
    370e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3710:	82 e0       	ldi	r24, 0x02	; 2
    3712:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3714:	83 e0       	ldi	r24, 0x03	; 3
    3716:	85 83       	std	Z+5, r24	; 0x05
    3718:	32 c0       	rjmp	.+100    	; 0x377e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    371a:	40 3b       	cpi	r20, 0xB0	; 176
    371c:	78 e0       	ldi	r23, 0x08	; 8
    371e:	57 07       	cpc	r21, r23
    3720:	49 f4       	brne	.+18     	; 0x3734 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3722:	80 e4       	ldi	r24, 0x40	; 64
    3724:	96 e0       	ldi	r25, 0x06	; 6
    3726:	82 83       	std	Z+2, r24	; 0x02
    3728:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    372a:	86 e0       	ldi	r24, 0x06	; 6
    372c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    372e:	87 e0       	ldi	r24, 0x07	; 7
    3730:	85 83       	std	Z+5, r24	; 0x05
    3732:	25 c0       	rjmp	.+74     	; 0x377e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3734:	40 3a       	cpi	r20, 0xA0	; 160
    3736:	89 e0       	ldi	r24, 0x09	; 9
    3738:	58 07       	cpc	r21, r24
    373a:	49 f4       	brne	.+18     	; 0x374e <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    373c:	80 e6       	ldi	r24, 0x60	; 96
    373e:	96 e0       	ldi	r25, 0x06	; 6
    3740:	82 83       	std	Z+2, r24	; 0x02
    3742:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3744:	82 e0       	ldi	r24, 0x02	; 2
    3746:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3748:	83 e0       	ldi	r24, 0x03	; 3
    374a:	85 83       	std	Z+5, r24	; 0x05
    374c:	18 c0       	rjmp	.+48     	; 0x377e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    374e:	40 3b       	cpi	r20, 0xB0	; 176
    3750:	69 e0       	ldi	r22, 0x09	; 9
    3752:	56 07       	cpc	r21, r22
    3754:	49 f4       	brne	.+18     	; 0x3768 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3756:	80 e6       	ldi	r24, 0x60	; 96
    3758:	96 e0       	ldi	r25, 0x06	; 6
    375a:	82 83       	std	Z+2, r24	; 0x02
    375c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    375e:	86 e0       	ldi	r24, 0x06	; 6
    3760:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3762:	87 e0       	ldi	r24, 0x07	; 7
    3764:	85 83       	std	Z+5, r24	; 0x05
    3766:	0b c0       	rjmp	.+22     	; 0x377e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3768:	40 3a       	cpi	r20, 0xA0	; 160
    376a:	5a 40       	sbci	r21, 0x0A	; 10
    376c:	41 f4       	brne	.+16     	; 0x377e <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    376e:	80 e8       	ldi	r24, 0x80	; 128
    3770:	96 e0       	ldi	r25, 0x06	; 6
    3772:	82 83       	std	Z+2, r24	; 0x02
    3774:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3776:	82 e0       	ldi	r24, 0x02	; 2
    3778:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    377a:	83 e0       	ldi	r24, 0x03	; 3
    377c:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    377e:	a6 83       	std	Z+6, r26	; 0x06
    3780:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3782:	cd 01       	movw	r24, r26
    3784:	01 96       	adiw	r24, 0x01	; 1
    3786:	80 87       	std	Z+8, r24	; 0x08
    3788:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    378a:	03 96       	adiw	r24, 0x03	; 3
    378c:	82 87       	std	Z+10, r24	; 0x0a
    378e:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3790:	25 81       	ldd	r18, Z+5	; 0x05
    3792:	c2 81       	ldd	r28, Z+2	; 0x02
    3794:	d3 81       	ldd	r29, Z+3	; 0x03
    3796:	4c 81       	ldd	r20, Y+4	; 0x04
    3798:	81 e0       	ldi	r24, 0x01	; 1
    379a:	90 e0       	ldi	r25, 0x00	; 0
    379c:	bc 01       	movw	r22, r24
    379e:	02 c0       	rjmp	.+4      	; 0x37a4 <_ZN7base232C1EjP12USART_struct+0xac>
    37a0:	66 0f       	add	r22, r22
    37a2:	77 1f       	adc	r23, r23
    37a4:	2a 95       	dec	r18
    37a6:	e2 f7       	brpl	.-8      	; 0x37a0 <_ZN7base232C1EjP12USART_struct+0xa8>
    37a8:	9b 01       	movw	r18, r22
    37aa:	24 2b       	or	r18, r20
    37ac:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    37ae:	25 81       	ldd	r18, Z+5	; 0x05
    37b0:	c2 81       	ldd	r28, Z+2	; 0x02
    37b2:	d3 81       	ldd	r29, Z+3	; 0x03
    37b4:	48 81       	ld	r20, Y
    37b6:	bc 01       	movw	r22, r24
    37b8:	02 c0       	rjmp	.+4      	; 0x37be <_ZN7base232C1EjP12USART_struct+0xc6>
    37ba:	66 0f       	add	r22, r22
    37bc:	77 1f       	adc	r23, r23
    37be:	2a 95       	dec	r18
    37c0:	e2 f7       	brpl	.-8      	; 0x37ba <_ZN7base232C1EjP12USART_struct+0xc2>
    37c2:	9b 01       	movw	r18, r22
    37c4:	24 2b       	or	r18, r20
    37c6:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    37c8:	34 81       	ldd	r19, Z+4	; 0x04
    37ca:	c2 81       	ldd	r28, Z+2	; 0x02
    37cc:	d3 81       	ldd	r29, Z+3	; 0x03
    37ce:	28 81       	ld	r18, Y
    37d0:	02 c0       	rjmp	.+4      	; 0x37d6 <_ZN7base232C1EjP12USART_struct+0xde>
    37d2:	88 0f       	add	r24, r24
    37d4:	99 1f       	adc	r25, r25
    37d6:	3a 95       	dec	r19
    37d8:	e2 f7       	brpl	.-8      	; 0x37d2 <_ZN7base232C1EjP12USART_struct+0xda>
    37da:	80 95       	com	r24
    37dc:	90 95       	com	r25
    37de:	82 23       	and	r24, r18
    37e0:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    37e2:	80 e1       	ldi	r24, 0x10	; 16
    37e4:	13 96       	adiw	r26, 0x03	; 3
    37e6:	8c 93       	st	X, r24
    37e8:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    37ea:	83 e0       	ldi	r24, 0x03	; 3
    37ec:	15 96       	adiw	r26, 0x05	; 5
    37ee:	8c 93       	st	X, r24
    37f0:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    37f2:	80 ef       	ldi	r24, 0xF0	; 240
    37f4:	17 96       	adiw	r26, 0x07	; 7
    37f6:	8c 93       	st	X, r24
    37f8:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    37fa:	81 e2       	ldi	r24, 0x21	; 33
    37fc:	16 96       	adiw	r26, 0x06	; 6
    37fe:	8c 93       	st	X, r24
    3800:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3802:	88 e1       	ldi	r24, 0x18	; 24
    3804:	14 96       	adiw	r26, 0x04	; 4
    3806:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3808:	80 e8       	ldi	r24, 0x80	; 128
    380a:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    380c:	80 e4       	ldi	r24, 0x40	; 64
    380e:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3810:	80 e2       	ldi	r24, 0x20	; 32
    3812:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3814:	06 80       	ldd	r0, Z+6	; 0x06
    3816:	f7 81       	ldd	r31, Z+7	; 0x07
    3818:	e0 2d       	mov	r30, r0
    381a:	80 81       	ld	r24, Z
    381c:	80 81       	ld	r24, Z
}
    381e:	df 91       	pop	r29
    3820:	cf 91       	pop	r28
    3822:	08 95       	ret

00003824 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3824:	81 e0       	ldi	r24, 0x01	; 1
    3826:	08 95       	ret

00003828 <_ZN8emstream7getcharEv>:
    3828:	80 e0       	ldi	r24, 0x00	; 0
    382a:	90 e0       	ldi	r25, 0x00	; 0
    382c:	08 95       	ret

0000382e <_ZN8emstream14check_for_charEv>:
    382e:	80 e0       	ldi	r24, 0x00	; 0
    3830:	08 95       	ret

00003832 <_ZN8emstream12transmit_nowEv>:
    3832:	08 95       	ret

00003834 <_ZN8emstream12clear_screenEv>:
    3834:	08 95       	ret

00003836 <_ZN8emstreamC1Ev>:
    3836:	fc 01       	movw	r30, r24
    3838:	8f e4       	ldi	r24, 0x4F	; 79
    383a:	90 e2       	ldi	r25, 0x20	; 32
    383c:	80 83       	st	Z, r24
    383e:	91 83       	std	Z+1, r25	; 0x01
    3840:	8a e0       	ldi	r24, 0x0A	; 10
    3842:	82 83       	std	Z+2, r24	; 0x02
    3844:	13 82       	std	Z+3, r1	; 0x03
    3846:	83 e0       	ldi	r24, 0x03	; 3
    3848:	85 83       	std	Z+5, r24	; 0x05
    384a:	14 82       	std	Z+4, r1	; 0x04
    384c:	16 82       	std	Z+6, r1	; 0x06
    384e:	17 82       	std	Z+7, r1	; 0x07
    3850:	08 95       	ret

00003852 <_ZN8emstream4putsEPKc>:
    3852:	0f 93       	push	r16
    3854:	1f 93       	push	r17
    3856:	cf 93       	push	r28
    3858:	df 93       	push	r29
    385a:	8c 01       	movw	r16, r24
    385c:	fb 01       	movw	r30, r22
    385e:	dc 01       	movw	r26, r24
    3860:	14 96       	adiw	r26, 0x04	; 4
    3862:	8c 91       	ld	r24, X
    3864:	81 11       	cpse	r24, r1
    3866:	04 c0       	rjmp	.+8      	; 0x3870 <_ZN8emstream4putsEPKc+0x1e>
    3868:	60 81       	ld	r22, Z
    386a:	61 11       	cpse	r22, r1
    386c:	17 c0       	rjmp	.+46     	; 0x389c <_ZN8emstream4putsEPKc+0x4a>
    386e:	23 c0       	rjmp	.+70     	; 0x38b6 <_ZN8emstream4putsEPKc+0x64>
    3870:	d8 01       	movw	r26, r16
    3872:	14 96       	adiw	r26, 0x04	; 4
    3874:	1c 92       	st	X, r1
    3876:	eb 01       	movw	r28, r22
    3878:	21 96       	adiw	r28, 0x01	; 1
    387a:	64 91       	lpm	r22, Z
    387c:	66 23       	and	r22, r22
    387e:	d9 f0       	breq	.+54     	; 0x38b6 <_ZN8emstream4putsEPKc+0x64>
    3880:	d8 01       	movw	r26, r16
    3882:	ed 91       	ld	r30, X+
    3884:	fc 91       	ld	r31, X
    3886:	02 80       	ldd	r0, Z+2	; 0x02
    3888:	f3 81       	ldd	r31, Z+3	; 0x03
    388a:	e0 2d       	mov	r30, r0
    388c:	c8 01       	movw	r24, r16
    388e:	19 95       	eicall
    3890:	fe 01       	movw	r30, r28
    3892:	64 91       	lpm	r22, Z
    3894:	21 96       	adiw	r28, 0x01	; 1
    3896:	61 11       	cpse	r22, r1
    3898:	f3 cf       	rjmp	.-26     	; 0x3880 <_ZN8emstream4putsEPKc+0x2e>
    389a:	0d c0       	rjmp	.+26     	; 0x38b6 <_ZN8emstream4putsEPKc+0x64>
    389c:	ef 01       	movw	r28, r30
    389e:	21 96       	adiw	r28, 0x01	; 1
    38a0:	d8 01       	movw	r26, r16
    38a2:	ed 91       	ld	r30, X+
    38a4:	fc 91       	ld	r31, X
    38a6:	02 80       	ldd	r0, Z+2	; 0x02
    38a8:	f3 81       	ldd	r31, Z+3	; 0x03
    38aa:	e0 2d       	mov	r30, r0
    38ac:	c8 01       	movw	r24, r16
    38ae:	19 95       	eicall
    38b0:	69 91       	ld	r22, Y+
    38b2:	61 11       	cpse	r22, r1
    38b4:	f5 cf       	rjmp	.-22     	; 0x38a0 <_ZN8emstream4putsEPKc+0x4e>
    38b6:	df 91       	pop	r29
    38b8:	cf 91       	pop	r28
    38ba:	1f 91       	pop	r17
    38bc:	0f 91       	pop	r16
    38be:	08 95       	ret

000038c0 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    38c0:	cf 93       	push	r28
    38c2:	df 93       	push	r29
    38c4:	ec 01       	movw	r28, r24
	switch (new_manip)
    38c6:	86 2f       	mov	r24, r22
    38c8:	90 e0       	ldi	r25, 0x00	; 0
    38ca:	8b 30       	cpi	r24, 0x0B	; 11
    38cc:	91 05       	cpc	r25, r1
    38ce:	d8 f5       	brcc	.+118    	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
    38d0:	fc 01       	movw	r30, r24
    38d2:	88 27       	eor	r24, r24
    38d4:	e6 5a       	subi	r30, 0xA6	; 166
    38d6:	fe 4f       	sbci	r31, 0xFE	; 254
    38d8:	8f 4f       	sbci	r24, 0xFF	; 255
    38da:	0c 94 de 21 	jmp	0x43bc	; 0x43bc <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    38de:	82 e0       	ldi	r24, 0x02	; 2
    38e0:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38e2:	31 c0       	rjmp	.+98     	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    38e4:	88 e0       	ldi	r24, 0x08	; 8
    38e6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38e8:	2e c0       	rjmp	.+92     	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    38ea:	8a e0       	ldi	r24, 0x0A	; 10
    38ec:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38ee:	2b c0       	rjmp	.+86     	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    38f0:	80 e1       	ldi	r24, 0x10	; 16
    38f2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38f4:	28 c0       	rjmp	.+80     	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    38f6:	81 e0       	ldi	r24, 0x01	; 1
    38f8:	8b 83       	std	Y+3, r24	; 0x03
			break;
    38fa:	25 c0       	rjmp	.+74     	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    38fc:	1b 82       	std	Y+3, r1	; 0x03
			break;
    38fe:	23 c0       	rjmp	.+70     	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3900:	e8 81       	ld	r30, Y
    3902:	f9 81       	ldd	r31, Y+1	; 0x01
    3904:	02 80       	ldd	r0, Z+2	; 0x02
    3906:	f3 81       	ldd	r31, Z+3	; 0x03
    3908:	e0 2d       	mov	r30, r0
    390a:	6d e0       	ldi	r22, 0x0D	; 13
    390c:	ce 01       	movw	r24, r28
    390e:	19 95       	eicall
    3910:	e8 81       	ld	r30, Y
    3912:	f9 81       	ldd	r31, Y+1	; 0x01
    3914:	02 80       	ldd	r0, Z+2	; 0x02
    3916:	f3 81       	ldd	r31, Z+3	; 0x03
    3918:	e0 2d       	mov	r30, r0
    391a:	6a e0       	ldi	r22, 0x0A	; 10
    391c:	ce 01       	movw	r24, r28
    391e:	19 95       	eicall
			break;
    3920:	12 c0       	rjmp	.+36     	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3922:	e8 81       	ld	r30, Y
    3924:	f9 81       	ldd	r31, Y+1	; 0x01
    3926:	02 84       	ldd	r0, Z+10	; 0x0a
    3928:	f3 85       	ldd	r31, Z+11	; 0x0b
    392a:	e0 2d       	mov	r30, r0
    392c:	ce 01       	movw	r24, r28
    392e:	19 95       	eicall
			break;
    3930:	0a c0       	rjmp	.+20     	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3932:	e8 81       	ld	r30, Y
    3934:	f9 81       	ldd	r31, Y+1	; 0x01
    3936:	00 84       	ldd	r0, Z+8	; 0x08
    3938:	f1 85       	ldd	r31, Z+9	; 0x09
    393a:	e0 2d       	mov	r30, r0
    393c:	ce 01       	movw	r24, r28
    393e:	19 95       	eicall
			break;
    3940:	02 c0       	rjmp	.+4      	; 0x3946 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3942:	81 e0       	ldi	r24, 0x01	; 1
    3944:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3946:	ce 01       	movw	r24, r28
    3948:	df 91       	pop	r29
    394a:	cf 91       	pop	r28
    394c:	08 95       	ret

0000394e <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    394e:	ff 92       	push	r15
    3950:	0f 93       	push	r16
    3952:	1f 93       	push	r17
    3954:	cf 93       	push	r28
    3956:	df 93       	push	r29
    3958:	cd b7       	in	r28, 0x3d	; 61
    395a:	de b7       	in	r29, 0x3e	; 62
    395c:	61 97       	sbiw	r28, 0x11	; 17
    395e:	cd bf       	out	0x3d, r28	; 61
    3960:	de bf       	out	0x3e, r29	; 62
    3962:	8c 01       	movw	r16, r24
    3964:	f6 2e       	mov	r15, r22
    3966:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3968:	f8 01       	movw	r30, r16
    396a:	42 81       	ldd	r20, Z+2	; 0x02
    396c:	40 31       	cpi	r20, 0x10	; 16
    396e:	21 f0       	breq	.+8      	; 0x3978 <_ZN8emstreamlsEj+0x2a>
    3970:	48 30       	cpi	r20, 0x08	; 8
    3972:	11 f0       	breq	.+4      	; 0x3978 <_ZN8emstreamlsEj+0x2a>
    3974:	42 30       	cpi	r20, 0x02	; 2
    3976:	41 f4       	brne	.+16     	; 0x3988 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3978:	69 2f       	mov	r22, r25
    397a:	c8 01       	movw	r24, r16
    397c:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
    3980:	6f 2d       	mov	r22, r15
    3982:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
    3986:	0d c0       	rjmp	.+26     	; 0x39a2 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3988:	50 e0       	ldi	r21, 0x00	; 0
    398a:	be 01       	movw	r22, r28
    398c:	6f 5f       	subi	r22, 0xFF	; 255
    398e:	7f 4f       	sbci	r23, 0xFF	; 255
    3990:	8f 2d       	mov	r24, r15
    3992:	0e 94 78 22 	call	0x44f0	; 0x44f0 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3996:	be 01       	movw	r22, r28
    3998:	6f 5f       	subi	r22, 0xFF	; 255
    399a:	7f 4f       	sbci	r23, 0xFF	; 255
    399c:	c8 01       	movw	r24, r16
    399e:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    39a2:	c8 01       	movw	r24, r16
    39a4:	61 96       	adiw	r28, 0x11	; 17
    39a6:	cd bf       	out	0x3d, r28	; 61
    39a8:	de bf       	out	0x3e, r29	; 62
    39aa:	df 91       	pop	r29
    39ac:	cf 91       	pop	r28
    39ae:	1f 91       	pop	r17
    39b0:	0f 91       	pop	r16
    39b2:	ff 90       	pop	r15
    39b4:	08 95       	ret

000039b6 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    39b6:	df 92       	push	r13
    39b8:	ef 92       	push	r14
    39ba:	ff 92       	push	r15
    39bc:	0f 93       	push	r16
    39be:	1f 93       	push	r17
    39c0:	cf 93       	push	r28
    39c2:	df 93       	push	r29
    39c4:	cd b7       	in	r28, 0x3d	; 61
    39c6:	de b7       	in	r29, 0x3e	; 62
    39c8:	a1 97       	sbiw	r28, 0x21	; 33
    39ca:	cd bf       	out	0x3d, r28	; 61
    39cc:	de bf       	out	0x3e, r29	; 62
    39ce:	8c 01       	movw	r16, r24
    39d0:	d4 2e       	mov	r13, r20
    39d2:	e5 2e       	mov	r14, r21
    39d4:	f6 2e       	mov	r15, r22
    39d6:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    39d8:	f8 01       	movw	r30, r16
    39da:	22 81       	ldd	r18, Z+2	; 0x02
    39dc:	20 31       	cpi	r18, 0x10	; 16
    39de:	21 f0       	breq	.+8      	; 0x39e8 <_ZN8emstreamlsEm+0x32>
    39e0:	28 30       	cpi	r18, 0x08	; 8
    39e2:	11 f0       	breq	.+4      	; 0x39e8 <_ZN8emstreamlsEm+0x32>
    39e4:	22 30       	cpi	r18, 0x02	; 2
    39e6:	71 f4       	brne	.+28     	; 0x3a04 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    39e8:	69 2f       	mov	r22, r25
    39ea:	c8 01       	movw	r24, r16
    39ec:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
    39f0:	6f 2d       	mov	r22, r15
    39f2:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
    39f6:	6e 2d       	mov	r22, r14
    39f8:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
    39fc:	6d 2d       	mov	r22, r13
    39fe:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <_ZN8emstreamlsEh>
    3a02:	0f c0       	rjmp	.+30     	; 0x3a22 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3a04:	30 e0       	ldi	r19, 0x00	; 0
    3a06:	ae 01       	movw	r20, r28
    3a08:	4f 5f       	subi	r20, 0xFF	; 255
    3a0a:	5f 4f       	sbci	r21, 0xFF	; 255
    3a0c:	6d 2d       	mov	r22, r13
    3a0e:	7e 2d       	mov	r23, r14
    3a10:	8f 2d       	mov	r24, r15
    3a12:	0e 94 4b 22 	call	0x4496	; 0x4496 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3a16:	be 01       	movw	r22, r28
    3a18:	6f 5f       	subi	r22, 0xFF	; 255
    3a1a:	7f 4f       	sbci	r23, 0xFF	; 255
    3a1c:	c8 01       	movw	r24, r16
    3a1e:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3a22:	c8 01       	movw	r24, r16
    3a24:	a1 96       	adiw	r28, 0x21	; 33
    3a26:	cd bf       	out	0x3d, r28	; 61
    3a28:	de bf       	out	0x3e, r29	; 62
    3a2a:	df 91       	pop	r29
    3a2c:	cf 91       	pop	r28
    3a2e:	1f 91       	pop	r17
    3a30:	0f 91       	pop	r16
    3a32:	ff 90       	pop	r15
    3a34:	ef 90       	pop	r14
    3a36:	df 90       	pop	r13
    3a38:	08 95       	ret

00003a3a <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3a3a:	cf 92       	push	r12
    3a3c:	df 92       	push	r13
    3a3e:	ef 92       	push	r14
    3a40:	ff 92       	push	r15
    3a42:	0f 93       	push	r16
    3a44:	1f 93       	push	r17
    3a46:	cf 93       	push	r28
    3a48:	df 93       	push	r29
    3a4a:	cd b7       	in	r28, 0x3d	; 61
    3a4c:	de b7       	in	r29, 0x3e	; 62
    3a4e:	29 97       	sbiw	r28, 0x09	; 9
    3a50:	cd bf       	out	0x3d, r28	; 61
    3a52:	de bf       	out	0x3e, r29	; 62
    3a54:	8c 01       	movw	r16, r24
    3a56:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3a58:	dc 01       	movw	r26, r24
    3a5a:	13 96       	adiw	r26, 0x03	; 3
    3a5c:	8c 91       	ld	r24, X
    3a5e:	13 97       	sbiw	r26, 0x03	; 3
    3a60:	88 23       	and	r24, r24
    3a62:	41 f0       	breq	.+16     	; 0x3a74 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3a64:	ed 91       	ld	r30, X+
    3a66:	fc 91       	ld	r31, X
    3a68:	02 80       	ldd	r0, Z+2	; 0x02
    3a6a:	f3 81       	ldd	r31, Z+3	; 0x03
    3a6c:	e0 2d       	mov	r30, r0
    3a6e:	c8 01       	movw	r24, r16
    3a70:	19 95       	eicall
    3a72:	56 c0       	rjmp	.+172    	; 0x3b20 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3a74:	f8 01       	movw	r30, r16
    3a76:	42 81       	ldd	r20, Z+2	; 0x02
    3a78:	42 30       	cpi	r20, 0x02	; 2
    3a7a:	19 f5       	brne	.+70     	; 0x3ac2 <_ZN8emstreamlsEh+0x88>
    3a7c:	68 94       	set
    3a7e:	cc 24       	eor	r12, r12
    3a80:	c3 f8       	bld	r12, 3
    3a82:	d1 2c       	mov	r13, r1
    3a84:	68 94       	set
    3a86:	ff 24       	eor	r15, r15
    3a88:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3a8a:	8e 2d       	mov	r24, r14
    3a8c:	8f 21       	and	r24, r15
    3a8e:	51 f0       	breq	.+20     	; 0x3aa4 <_ZN8emstreamlsEh+0x6a>
    3a90:	d8 01       	movw	r26, r16
    3a92:	ed 91       	ld	r30, X+
    3a94:	fc 91       	ld	r31, X
    3a96:	02 80       	ldd	r0, Z+2	; 0x02
    3a98:	f3 81       	ldd	r31, Z+3	; 0x03
    3a9a:	e0 2d       	mov	r30, r0
    3a9c:	61 e3       	ldi	r22, 0x31	; 49
    3a9e:	c8 01       	movw	r24, r16
    3aa0:	19 95       	eicall
    3aa2:	09 c0       	rjmp	.+18     	; 0x3ab6 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3aa4:	d8 01       	movw	r26, r16
    3aa6:	ed 91       	ld	r30, X+
    3aa8:	fc 91       	ld	r31, X
    3aaa:	02 80       	ldd	r0, Z+2	; 0x02
    3aac:	f3 81       	ldd	r31, Z+3	; 0x03
    3aae:	e0 2d       	mov	r30, r0
    3ab0:	60 e3       	ldi	r22, 0x30	; 48
    3ab2:	c8 01       	movw	r24, r16
    3ab4:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3ab6:	f6 94       	lsr	r15
    3ab8:	b1 e0       	ldi	r27, 0x01	; 1
    3aba:	cb 1a       	sub	r12, r27
    3abc:	d1 08       	sbc	r13, r1
    3abe:	29 f7       	brne	.-54     	; 0x3a8a <_ZN8emstreamlsEh+0x50>
    3ac0:	2f c0       	rjmp	.+94     	; 0x3b20 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3ac2:	40 31       	cpi	r20, 0x10	; 16
    3ac4:	f9 f4       	brne	.+62     	; 0x3b04 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3ac6:	62 95       	swap	r22
    3ac8:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3aca:	01 90       	ld	r0, Z+
    3acc:	f0 81       	ld	r31, Z
    3ace:	e0 2d       	mov	r30, r0
    3ad0:	02 80       	ldd	r0, Z+2	; 0x02
    3ad2:	f3 81       	ldd	r31, Z+3	; 0x03
    3ad4:	e0 2d       	mov	r30, r0
    3ad6:	6a 30       	cpi	r22, 0x0A	; 10
    3ad8:	10 f0       	brcs	.+4      	; 0x3ade <_ZN8emstreamlsEh+0xa4>
    3ada:	69 5c       	subi	r22, 0xC9	; 201
    3adc:	01 c0       	rjmp	.+2      	; 0x3ae0 <_ZN8emstreamlsEh+0xa6>
    3ade:	60 5d       	subi	r22, 0xD0	; 208
    3ae0:	c8 01       	movw	r24, r16
    3ae2:	19 95       	eicall
		temp_char = num & 0x0F;
    3ae4:	6e 2d       	mov	r22, r14
    3ae6:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3ae8:	d8 01       	movw	r26, r16
    3aea:	ed 91       	ld	r30, X+
    3aec:	fc 91       	ld	r31, X
    3aee:	02 80       	ldd	r0, Z+2	; 0x02
    3af0:	f3 81       	ldd	r31, Z+3	; 0x03
    3af2:	e0 2d       	mov	r30, r0
    3af4:	6a 30       	cpi	r22, 0x0A	; 10
    3af6:	10 f0       	brcs	.+4      	; 0x3afc <_ZN8emstreamlsEh+0xc2>
    3af8:	69 5c       	subi	r22, 0xC9	; 201
    3afa:	01 c0       	rjmp	.+2      	; 0x3afe <_ZN8emstreamlsEh+0xc4>
    3afc:	60 5d       	subi	r22, 0xD0	; 208
    3afe:	c8 01       	movw	r24, r16
    3b00:	19 95       	eicall
    3b02:	0e c0       	rjmp	.+28     	; 0x3b20 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3b04:	50 e0       	ldi	r21, 0x00	; 0
    3b06:	be 01       	movw	r22, r28
    3b08:	6f 5f       	subi	r22, 0xFF	; 255
    3b0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b0c:	8e 2d       	mov	r24, r14
    3b0e:	90 e0       	ldi	r25, 0x00	; 0
    3b10:	0e 94 78 22 	call	0x44f0	; 0x44f0 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3b14:	be 01       	movw	r22, r28
    3b16:	6f 5f       	subi	r22, 0xFF	; 255
    3b18:	7f 4f       	sbci	r23, 0xFF	; 255
    3b1a:	c8 01       	movw	r24, r16
    3b1c:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3b20:	c8 01       	movw	r24, r16
    3b22:	29 96       	adiw	r28, 0x09	; 9
    3b24:	cd bf       	out	0x3d, r28	; 61
    3b26:	de bf       	out	0x3e, r29	; 62
    3b28:	df 91       	pop	r29
    3b2a:	cf 91       	pop	r28
    3b2c:	1f 91       	pop	r17
    3b2e:	0f 91       	pop	r16
    3b30:	ff 90       	pop	r15
    3b32:	ef 90       	pop	r14
    3b34:	df 90       	pop	r13
    3b36:	cf 90       	pop	r12
    3b38:	08 95       	ret

00003b3a <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3b3a:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3b3c:	50 96       	adiw	r26, 0x10	; 16
    3b3e:	ed 91       	ld	r30, X+
    3b40:	fc 91       	ld	r31, X
    3b42:	51 97       	sbiw	r26, 0x11	; 17
    3b44:	80 81       	ld	r24, Z
    3b46:	54 96       	adiw	r26, 0x14	; 20
    3b48:	4c 91       	ld	r20, X
    3b4a:	54 97       	sbiw	r26, 0x14	; 20
    3b4c:	84 23       	and	r24, r20
    3b4e:	29 f0       	breq	.+10     	; 0x3b5a <_ZN5rs2327putcharEc+0x20>
    3b50:	09 c0       	rjmp	.+18     	; 0x3b64 <_ZN5rs2327putcharEc+0x2a>
    3b52:	21 50       	subi	r18, 0x01	; 1
    3b54:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3b56:	19 f4       	brne	.+6      	; 0x3b5e <_ZN5rs2327putcharEc+0x24>
    3b58:	12 c0       	rjmp	.+36     	; 0x3b7e <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3b5a:	21 e2       	ldi	r18, 0x21	; 33
    3b5c:	3e e4       	ldi	r19, 0x4E	; 78
    3b5e:	90 81       	ld	r25, Z
    3b60:	94 23       	and	r25, r20
    3b62:	b9 f3       	breq	.-18     	; 0x3b52 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3b64:	90 81       	ld	r25, Z
    3b66:	56 96       	adiw	r26, 0x16	; 22
    3b68:	8c 91       	ld	r24, X
    3b6a:	56 97       	sbiw	r26, 0x16	; 22
    3b6c:	89 2b       	or	r24, r25
    3b6e:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3b70:	1e 96       	adiw	r26, 0x0e	; 14
    3b72:	ed 91       	ld	r30, X+
    3b74:	fc 91       	ld	r31, X
    3b76:	1f 97       	sbiw	r26, 0x0f	; 15
    3b78:	60 83       	st	Z, r22
	return (true);
    3b7a:	81 e0       	ldi	r24, 0x01	; 1
    3b7c:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3b7e:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3b80:	08 95       	ret

00003b82 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3b82:	cf 93       	push	r28
    3b84:	df 93       	push	r29
    3b86:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3b88:	c1 8d       	ldd	r28, Z+25	; 0x19
    3b8a:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3b8c:	28 81       	ld	r18, Y
    3b8e:	39 81       	ldd	r19, Y+1	; 0x01
    3b90:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3b92:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3b94:	4d 91       	ld	r20, X+
    3b96:	5c 91       	ld	r21, X
    3b98:	24 17       	cp	r18, r20
    3b9a:	35 07       	cpc	r19, r21
    3b9c:	e9 f3       	breq	.-6      	; 0x3b98 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3b9e:	a7 89       	ldd	r26, Z+23	; 0x17
    3ba0:	b0 8d       	ldd	r27, Z+24	; 0x18
    3ba2:	0d 90       	ld	r0, X+
    3ba4:	bc 91       	ld	r27, X
    3ba6:	a0 2d       	mov	r26, r0
    3ba8:	a2 0f       	add	r26, r18
    3baa:	b3 1f       	adc	r27, r19
    3bac:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3bae:	2f 5f       	subi	r18, 0xFF	; 255
    3bb0:	3f 4f       	sbci	r19, 0xFF	; 255
    3bb2:	28 83       	st	Y, r18
    3bb4:	39 83       	std	Y+1, r19	; 0x01
    3bb6:	24 36       	cpi	r18, 0x64	; 100
    3bb8:	31 05       	cpc	r19, r1
    3bba:	28 f0       	brcs	.+10     	; 0x3bc6 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3bbc:	01 8c       	ldd	r0, Z+25	; 0x19
    3bbe:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3bc0:	e0 2d       	mov	r30, r0
    3bc2:	10 82       	st	Z, r1
    3bc4:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3bc6:	90 e0       	ldi	r25, 0x00	; 0
    3bc8:	df 91       	pop	r29
    3bca:	cf 91       	pop	r28
    3bcc:	08 95       	ret

00003bce <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3bce:	cf 93       	push	r28
    3bd0:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3bd2:	ec 01       	movw	r28, r24
    3bd4:	a9 8d       	ldd	r26, Y+25	; 0x19
    3bd6:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3bd8:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3bda:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3bdc:	81 e0       	ldi	r24, 0x01	; 1
    3bde:	4d 91       	ld	r20, X+
    3be0:	5c 91       	ld	r21, X
    3be2:	20 81       	ld	r18, Z
    3be4:	31 81       	ldd	r19, Z+1	; 0x01
    3be6:	42 17       	cp	r20, r18
    3be8:	53 07       	cpc	r21, r19
    3bea:	09 f4       	brne	.+2      	; 0x3bee <_ZN5rs23214check_for_charEv+0x20>
    3bec:	80 e0       	ldi	r24, 0x00	; 0
}
    3bee:	df 91       	pop	r29
    3bf0:	cf 91       	pop	r28
    3bf2:	08 95       	ret

00003bf4 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3bf4:	dc 01       	movw	r26, r24
    3bf6:	ed 91       	ld	r30, X+
    3bf8:	fc 91       	ld	r31, X
    3bfa:	02 80       	ldd	r0, Z+2	; 0x02
    3bfc:	f3 81       	ldd	r31, Z+3	; 0x03
    3bfe:	e0 2d       	mov	r30, r0
    3c00:	6c e0       	ldi	r22, 0x0C	; 12
    3c02:	19 95       	eicall
    3c04:	08 95       	ret

00003c06 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3c06:	ef 92       	push	r14
    3c08:	ff 92       	push	r15
    3c0a:	0f 93       	push	r16
    3c0c:	1f 93       	push	r17
    3c0e:	cf 93       	push	r28
    3c10:	df 93       	push	r29
    3c12:	ec 01       	movw	r28, r24
    3c14:	7b 01       	movw	r14, r22
    3c16:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3c18:	0e 94 1b 1c 	call	0x3836	; 0x3836 <_ZN8emstreamC1Ev>
    3c1c:	a8 01       	movw	r20, r16
    3c1e:	b7 01       	movw	r22, r14
    3c20:	ce 01       	movw	r24, r28
    3c22:	08 96       	adiw	r24, 0x08	; 8
    3c24:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <_ZN7base232C1EjP12USART_struct>
    3c28:	8f e5       	ldi	r24, 0x5F	; 95
    3c2a:	90 e2       	ldi	r25, 0x20	; 32
    3c2c:	88 83       	st	Y, r24
    3c2e:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3c30:	00 3a       	cpi	r16, 0xA0	; 160
    3c32:	88 e0       	ldi	r24, 0x08	; 8
    3c34:	18 07       	cpc	r17, r24
    3c36:	69 f4       	brne	.+26     	; 0x3c52 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3c38:	88 e3       	ldi	r24, 0x38	; 56
    3c3a:	91 e3       	ldi	r25, 0x31	; 49
    3c3c:	8f 8b       	std	Y+23, r24	; 0x17
    3c3e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3c40:	8e e2       	ldi	r24, 0x2E	; 46
    3c42:	91 e3       	ldi	r25, 0x31	; 49
    3c44:	89 8f       	std	Y+25, r24	; 0x19
    3c46:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3c48:	84 e2       	ldi	r24, 0x24	; 36
    3c4a:	91 e3       	ldi	r25, 0x31	; 49
    3c4c:	8b 8f       	std	Y+27, r24	; 0x1b
    3c4e:	9c 8f       	std	Y+28, r25	; 0x1c
    3c50:	42 c0       	rjmp	.+132    	; 0x3cd6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3c52:	00 3b       	cpi	r16, 0xB0	; 176
    3c54:	e8 e0       	ldi	r30, 0x08	; 8
    3c56:	1e 07       	cpc	r17, r30
    3c58:	69 f4       	brne	.+26     	; 0x3c74 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3c5a:	86 e3       	ldi	r24, 0x36	; 54
    3c5c:	91 e3       	ldi	r25, 0x31	; 49
    3c5e:	8f 8b       	std	Y+23, r24	; 0x17
    3c60:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3c62:	8c e2       	ldi	r24, 0x2C	; 44
    3c64:	91 e3       	ldi	r25, 0x31	; 49
    3c66:	89 8f       	std	Y+25, r24	; 0x19
    3c68:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3c6a:	82 e2       	ldi	r24, 0x22	; 34
    3c6c:	91 e3       	ldi	r25, 0x31	; 49
    3c6e:	8b 8f       	std	Y+27, r24	; 0x1b
    3c70:	9c 8f       	std	Y+28, r25	; 0x1c
    3c72:	31 c0       	rjmp	.+98     	; 0x3cd6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3c74:	00 3a       	cpi	r16, 0xA0	; 160
    3c76:	f9 e0       	ldi	r31, 0x09	; 9
    3c78:	1f 07       	cpc	r17, r31
    3c7a:	69 f4       	brne	.+26     	; 0x3c96 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3c7c:	84 e3       	ldi	r24, 0x34	; 52
    3c7e:	91 e3       	ldi	r25, 0x31	; 49
    3c80:	8f 8b       	std	Y+23, r24	; 0x17
    3c82:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3c84:	8a e2       	ldi	r24, 0x2A	; 42
    3c86:	91 e3       	ldi	r25, 0x31	; 49
    3c88:	89 8f       	std	Y+25, r24	; 0x19
    3c8a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3c8c:	80 e2       	ldi	r24, 0x20	; 32
    3c8e:	91 e3       	ldi	r25, 0x31	; 49
    3c90:	8b 8f       	std	Y+27, r24	; 0x1b
    3c92:	9c 8f       	std	Y+28, r25	; 0x1c
    3c94:	20 c0       	rjmp	.+64     	; 0x3cd6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3c96:	00 3b       	cpi	r16, 0xB0	; 176
    3c98:	89 e0       	ldi	r24, 0x09	; 9
    3c9a:	18 07       	cpc	r17, r24
    3c9c:	69 f4       	brne	.+26     	; 0x3cb8 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3c9e:	82 e3       	ldi	r24, 0x32	; 50
    3ca0:	91 e3       	ldi	r25, 0x31	; 49
    3ca2:	8f 8b       	std	Y+23, r24	; 0x17
    3ca4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3ca6:	88 e2       	ldi	r24, 0x28	; 40
    3ca8:	91 e3       	ldi	r25, 0x31	; 49
    3caa:	89 8f       	std	Y+25, r24	; 0x19
    3cac:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3cae:	8e e1       	ldi	r24, 0x1E	; 30
    3cb0:	91 e3       	ldi	r25, 0x31	; 49
    3cb2:	8b 8f       	std	Y+27, r24	; 0x1b
    3cb4:	9c 8f       	std	Y+28, r25	; 0x1c
    3cb6:	0f c0       	rjmp	.+30     	; 0x3cd6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3cb8:	00 3a       	cpi	r16, 0xA0	; 160
    3cba:	1a 40       	sbci	r17, 0x0A	; 10
    3cbc:	61 f4       	brne	.+24     	; 0x3cd6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3cbe:	80 e3       	ldi	r24, 0x30	; 48
    3cc0:	91 e3       	ldi	r25, 0x31	; 49
    3cc2:	8f 8b       	std	Y+23, r24	; 0x17
    3cc4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3cc6:	86 e2       	ldi	r24, 0x26	; 38
    3cc8:	91 e3       	ldi	r25, 0x31	; 49
    3cca:	89 8f       	std	Y+25, r24	; 0x19
    3ccc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3cce:	8c e1       	ldi	r24, 0x1C	; 28
    3cd0:	91 e3       	ldi	r25, 0x31	; 49
    3cd2:	8b 8f       	std	Y+27, r24	; 0x1b
    3cd4:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3cd6:	0f 89       	ldd	r16, Y+23	; 0x17
    3cd8:	18 8d       	ldd	r17, Y+24	; 0x18
    3cda:	84 e6       	ldi	r24, 0x64	; 100
    3cdc:	90 e0       	ldi	r25, 0x00	; 0
    3cde:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_Znaj>
    3ce2:	f8 01       	movw	r30, r16
    3ce4:	80 83       	st	Z, r24
    3ce6:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3ce8:	e9 8d       	ldd	r30, Y+25	; 0x19
    3cea:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3cec:	10 82       	st	Z, r1
    3cee:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3cf0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3cf2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3cf4:	10 82       	st	Z, r1
    3cf6:	11 82       	std	Z+1, r1	; 0x01
}
    3cf8:	df 91       	pop	r29
    3cfa:	cf 91       	pop	r28
    3cfc:	1f 91       	pop	r17
    3cfe:	0f 91       	pop	r16
    3d00:	ff 90       	pop	r15
    3d02:	ef 90       	pop	r14
    3d04:	08 95       	ret

00003d06 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3d06:	1f 92       	push	r1
    3d08:	0f 92       	push	r0
    3d0a:	0f b6       	in	r0, 0x3f	; 63
    3d0c:	0f 92       	push	r0
    3d0e:	11 24       	eor	r1, r1
    3d10:	08 b6       	in	r0, 0x38	; 56
    3d12:	0f 92       	push	r0
    3d14:	18 be       	out	0x38, r1	; 56
    3d16:	0b b6       	in	r0, 0x3b	; 59
    3d18:	0f 92       	push	r0
    3d1a:	1b be       	out	0x3b, r1	; 59
    3d1c:	2f 93       	push	r18
    3d1e:	3f 93       	push	r19
    3d20:	8f 93       	push	r24
    3d22:	9f 93       	push	r25
    3d24:	ef 93       	push	r30
    3d26:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3d28:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3d2c:	e0 91 38 31 	lds	r30, 0x3138	; 0x803138 <rcvC0_buffer>
    3d30:	f0 91 39 31 	lds	r31, 0x3139	; 0x803139 <rcvC0_buffer+0x1>
    3d34:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3d38:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    3d3c:	e8 0f       	add	r30, r24
    3d3e:	f9 1f       	adc	r31, r25
    3d40:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3d42:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3d46:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    3d4a:	01 96       	adiw	r24, 0x01	; 1
    3d4c:	84 36       	cpi	r24, 0x64	; 100
    3d4e:	91 05       	cpc	r25, r1
    3d50:	60 f4       	brcc	.+24     	; 0x3d6a <__vector_25+0x64>
    3d52:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <rcvC0_write_index>
    3d56:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3d5a:	20 91 2e 31 	lds	r18, 0x312E	; 0x80312e <rcvC0_read_index>
    3d5e:	30 91 2f 31 	lds	r19, 0x312F	; 0x80312f <rcvC0_read_index+0x1>
    3d62:	82 17       	cp	r24, r18
    3d64:	93 07       	cpc	r25, r19
    3d66:	f1 f4       	brne	.+60     	; 0x3da4 <__vector_25+0x9e>
    3d68:	0c c0       	rjmp	.+24     	; 0x3d82 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3d6a:	10 92 24 31 	sts	0x3124, r1	; 0x803124 <rcvC0_write_index>
    3d6e:	10 92 25 31 	sts	0x3125, r1	; 0x803125 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3d72:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC0_read_index>
    3d76:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC0_read_index+0x1>
    3d7a:	18 16       	cp	r1, r24
    3d7c:	19 06       	cpc	r1, r25
    3d7e:	91 f4       	brne	.+36     	; 0x3da4 <__vector_25+0x9e>
    3d80:	0e c0       	rjmp	.+28     	; 0x3d9e <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3d82:	01 96       	adiw	r24, 0x01	; 1
    3d84:	84 36       	cpi	r24, 0x64	; 100
    3d86:	91 05       	cpc	r25, r1
    3d88:	28 f4       	brcc	.+10     	; 0x3d94 <__vector_25+0x8e>
    3d8a:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC0_read_index>
    3d8e:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC0_read_index+0x1>
    3d92:	08 c0       	rjmp	.+16     	; 0x3da4 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3d94:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC0_read_index>
    3d98:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC0_read_index+0x1>
}
    3d9c:	03 c0       	rjmp	.+6      	; 0x3da4 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3d9e:	81 e0       	ldi	r24, 0x01	; 1
    3da0:	90 e0       	ldi	r25, 0x00	; 0
    3da2:	f3 cf       	rjmp	.-26     	; 0x3d8a <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3da4:	ff 91       	pop	r31
    3da6:	ef 91       	pop	r30
    3da8:	9f 91       	pop	r25
    3daa:	8f 91       	pop	r24
    3dac:	3f 91       	pop	r19
    3dae:	2f 91       	pop	r18
    3db0:	0f 90       	pop	r0
    3db2:	0b be       	out	0x3b, r0	; 59
    3db4:	0f 90       	pop	r0
    3db6:	08 be       	out	0x38, r0	; 56
    3db8:	0f 90       	pop	r0
    3dba:	0f be       	out	0x3f, r0	; 63
    3dbc:	0f 90       	pop	r0
    3dbe:	1f 90       	pop	r1
    3dc0:	18 95       	reti

00003dc2 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3dc2:	1f 92       	push	r1
    3dc4:	0f 92       	push	r0
    3dc6:	0f b6       	in	r0, 0x3f	; 63
    3dc8:	0f 92       	push	r0
    3dca:	11 24       	eor	r1, r1
    3dcc:	08 b6       	in	r0, 0x38	; 56
    3dce:	0f 92       	push	r0
    3dd0:	18 be       	out	0x38, r1	; 56
    3dd2:	0b b6       	in	r0, 0x3b	; 59
    3dd4:	0f 92       	push	r0
    3dd6:	1b be       	out	0x3b, r1	; 59
    3dd8:	2f 93       	push	r18
    3dda:	3f 93       	push	r19
    3ddc:	8f 93       	push	r24
    3dde:	9f 93       	push	r25
    3de0:	ef 93       	push	r30
    3de2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3de4:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3de8:	e0 91 36 31 	lds	r30, 0x3136	; 0x803136 <rcvC1_buffer>
    3dec:	f0 91 37 31 	lds	r31, 0x3137	; 0x803137 <rcvC1_buffer+0x1>
    3df0:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvC1_write_index>
    3df4:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvC1_write_index+0x1>
    3df8:	e8 0f       	add	r30, r24
    3dfa:	f9 1f       	adc	r31, r25
    3dfc:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3dfe:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvC1_write_index>
    3e02:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvC1_write_index+0x1>
    3e06:	01 96       	adiw	r24, 0x01	; 1
    3e08:	84 36       	cpi	r24, 0x64	; 100
    3e0a:	91 05       	cpc	r25, r1
    3e0c:	60 f4       	brcc	.+24     	; 0x3e26 <__vector_28+0x64>
    3e0e:	80 93 22 31 	sts	0x3122, r24	; 0x803122 <rcvC1_write_index>
    3e12:	90 93 23 31 	sts	0x3123, r25	; 0x803123 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3e16:	20 91 2c 31 	lds	r18, 0x312C	; 0x80312c <rcvC1_read_index>
    3e1a:	30 91 2d 31 	lds	r19, 0x312D	; 0x80312d <rcvC1_read_index+0x1>
    3e1e:	82 17       	cp	r24, r18
    3e20:	93 07       	cpc	r25, r19
    3e22:	f1 f4       	brne	.+60     	; 0x3e60 <__vector_28+0x9e>
    3e24:	0c c0       	rjmp	.+24     	; 0x3e3e <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3e26:	10 92 22 31 	sts	0x3122, r1	; 0x803122 <rcvC1_write_index>
    3e2a:	10 92 23 31 	sts	0x3123, r1	; 0x803123 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3e2e:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvC1_read_index>
    3e32:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvC1_read_index+0x1>
    3e36:	18 16       	cp	r1, r24
    3e38:	19 06       	cpc	r1, r25
    3e3a:	91 f4       	brne	.+36     	; 0x3e60 <__vector_28+0x9e>
    3e3c:	0e c0       	rjmp	.+28     	; 0x3e5a <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3e3e:	01 96       	adiw	r24, 0x01	; 1
    3e40:	84 36       	cpi	r24, 0x64	; 100
    3e42:	91 05       	cpc	r25, r1
    3e44:	28 f4       	brcc	.+10     	; 0x3e50 <__vector_28+0x8e>
    3e46:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvC1_read_index>
    3e4a:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvC1_read_index+0x1>
    3e4e:	08 c0       	rjmp	.+16     	; 0x3e60 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3e50:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvC1_read_index>
    3e54:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvC1_read_index+0x1>
}
    3e58:	03 c0       	rjmp	.+6      	; 0x3e60 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3e5a:	81 e0       	ldi	r24, 0x01	; 1
    3e5c:	90 e0       	ldi	r25, 0x00	; 0
    3e5e:	f3 cf       	rjmp	.-26     	; 0x3e46 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3e60:	ff 91       	pop	r31
    3e62:	ef 91       	pop	r30
    3e64:	9f 91       	pop	r25
    3e66:	8f 91       	pop	r24
    3e68:	3f 91       	pop	r19
    3e6a:	2f 91       	pop	r18
    3e6c:	0f 90       	pop	r0
    3e6e:	0b be       	out	0x3b, r0	; 59
    3e70:	0f 90       	pop	r0
    3e72:	08 be       	out	0x38, r0	; 56
    3e74:	0f 90       	pop	r0
    3e76:	0f be       	out	0x3f, r0	; 63
    3e78:	0f 90       	pop	r0
    3e7a:	1f 90       	pop	r1
    3e7c:	18 95       	reti

00003e7e <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3e7e:	1f 92       	push	r1
    3e80:	0f 92       	push	r0
    3e82:	0f b6       	in	r0, 0x3f	; 63
    3e84:	0f 92       	push	r0
    3e86:	11 24       	eor	r1, r1
    3e88:	08 b6       	in	r0, 0x38	; 56
    3e8a:	0f 92       	push	r0
    3e8c:	18 be       	out	0x38, r1	; 56
    3e8e:	0b b6       	in	r0, 0x3b	; 59
    3e90:	0f 92       	push	r0
    3e92:	1b be       	out	0x3b, r1	; 59
    3e94:	2f 93       	push	r18
    3e96:	3f 93       	push	r19
    3e98:	8f 93       	push	r24
    3e9a:	9f 93       	push	r25
    3e9c:	ef 93       	push	r30
    3e9e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3ea0:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3ea4:	e0 91 34 31 	lds	r30, 0x3134	; 0x803134 <rcvD0_buffer>
    3ea8:	f0 91 35 31 	lds	r31, 0x3135	; 0x803135 <rcvD0_buffer+0x1>
    3eac:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3eb0:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    3eb4:	e8 0f       	add	r30, r24
    3eb6:	f9 1f       	adc	r31, r25
    3eb8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3eba:	80 91 20 31 	lds	r24, 0x3120	; 0x803120 <rcvD0_write_index>
    3ebe:	90 91 21 31 	lds	r25, 0x3121	; 0x803121 <rcvD0_write_index+0x1>
    3ec2:	01 96       	adiw	r24, 0x01	; 1
    3ec4:	84 36       	cpi	r24, 0x64	; 100
    3ec6:	91 05       	cpc	r25, r1
    3ec8:	60 f4       	brcc	.+24     	; 0x3ee2 <__vector_88+0x64>
    3eca:	80 93 20 31 	sts	0x3120, r24	; 0x803120 <rcvD0_write_index>
    3ece:	90 93 21 31 	sts	0x3121, r25	; 0x803121 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3ed2:	20 91 2a 31 	lds	r18, 0x312A	; 0x80312a <rcvD0_read_index>
    3ed6:	30 91 2b 31 	lds	r19, 0x312B	; 0x80312b <rcvD0_read_index+0x1>
    3eda:	82 17       	cp	r24, r18
    3edc:	93 07       	cpc	r25, r19
    3ede:	f1 f4       	brne	.+60     	; 0x3f1c <__vector_88+0x9e>
    3ee0:	0c c0       	rjmp	.+24     	; 0x3efa <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3ee2:	10 92 20 31 	sts	0x3120, r1	; 0x803120 <rcvD0_write_index>
    3ee6:	10 92 21 31 	sts	0x3121, r1	; 0x803121 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3eea:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD0_read_index>
    3eee:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD0_read_index+0x1>
    3ef2:	18 16       	cp	r1, r24
    3ef4:	19 06       	cpc	r1, r25
    3ef6:	91 f4       	brne	.+36     	; 0x3f1c <__vector_88+0x9e>
    3ef8:	0e c0       	rjmp	.+28     	; 0x3f16 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3efa:	01 96       	adiw	r24, 0x01	; 1
    3efc:	84 36       	cpi	r24, 0x64	; 100
    3efe:	91 05       	cpc	r25, r1
    3f00:	28 f4       	brcc	.+10     	; 0x3f0c <__vector_88+0x8e>
    3f02:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD0_read_index>
    3f06:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD0_read_index+0x1>
    3f0a:	08 c0       	rjmp	.+16     	; 0x3f1c <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3f0c:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD0_read_index>
    3f10:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD0_read_index+0x1>
}
    3f14:	03 c0       	rjmp	.+6      	; 0x3f1c <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3f16:	81 e0       	ldi	r24, 0x01	; 1
    3f18:	90 e0       	ldi	r25, 0x00	; 0
    3f1a:	f3 cf       	rjmp	.-26     	; 0x3f02 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3f1c:	ff 91       	pop	r31
    3f1e:	ef 91       	pop	r30
    3f20:	9f 91       	pop	r25
    3f22:	8f 91       	pop	r24
    3f24:	3f 91       	pop	r19
    3f26:	2f 91       	pop	r18
    3f28:	0f 90       	pop	r0
    3f2a:	0b be       	out	0x3b, r0	; 59
    3f2c:	0f 90       	pop	r0
    3f2e:	08 be       	out	0x38, r0	; 56
    3f30:	0f 90       	pop	r0
    3f32:	0f be       	out	0x3f, r0	; 63
    3f34:	0f 90       	pop	r0
    3f36:	1f 90       	pop	r1
    3f38:	18 95       	reti

00003f3a <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3f3a:	1f 92       	push	r1
    3f3c:	0f 92       	push	r0
    3f3e:	0f b6       	in	r0, 0x3f	; 63
    3f40:	0f 92       	push	r0
    3f42:	11 24       	eor	r1, r1
    3f44:	08 b6       	in	r0, 0x38	; 56
    3f46:	0f 92       	push	r0
    3f48:	18 be       	out	0x38, r1	; 56
    3f4a:	0b b6       	in	r0, 0x3b	; 59
    3f4c:	0f 92       	push	r0
    3f4e:	1b be       	out	0x3b, r1	; 59
    3f50:	2f 93       	push	r18
    3f52:	3f 93       	push	r19
    3f54:	8f 93       	push	r24
    3f56:	9f 93       	push	r25
    3f58:	ef 93       	push	r30
    3f5a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3f5c:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3f60:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <rcvD1_buffer>
    3f64:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <rcvD1_buffer+0x1>
    3f68:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvD1_write_index>
    3f6c:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvD1_write_index+0x1>
    3f70:	e8 0f       	add	r30, r24
    3f72:	f9 1f       	adc	r31, r25
    3f74:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3f76:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvD1_write_index>
    3f7a:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvD1_write_index+0x1>
    3f7e:	01 96       	adiw	r24, 0x01	; 1
    3f80:	84 36       	cpi	r24, 0x64	; 100
    3f82:	91 05       	cpc	r25, r1
    3f84:	60 f4       	brcc	.+24     	; 0x3f9e <__vector_91+0x64>
    3f86:	80 93 1e 31 	sts	0x311E, r24	; 0x80311e <rcvD1_write_index>
    3f8a:	90 93 1f 31 	sts	0x311F, r25	; 0x80311f <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3f8e:	20 91 28 31 	lds	r18, 0x3128	; 0x803128 <rcvD1_read_index>
    3f92:	30 91 29 31 	lds	r19, 0x3129	; 0x803129 <rcvD1_read_index+0x1>
    3f96:	82 17       	cp	r24, r18
    3f98:	93 07       	cpc	r25, r19
    3f9a:	f1 f4       	brne	.+60     	; 0x3fd8 <__vector_91+0x9e>
    3f9c:	0c c0       	rjmp	.+24     	; 0x3fb6 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3f9e:	10 92 1e 31 	sts	0x311E, r1	; 0x80311e <rcvD1_write_index>
    3fa2:	10 92 1f 31 	sts	0x311F, r1	; 0x80311f <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3fa6:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvD1_read_index>
    3faa:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvD1_read_index+0x1>
    3fae:	18 16       	cp	r1, r24
    3fb0:	19 06       	cpc	r1, r25
    3fb2:	91 f4       	brne	.+36     	; 0x3fd8 <__vector_91+0x9e>
    3fb4:	0e c0       	rjmp	.+28     	; 0x3fd2 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3fb6:	01 96       	adiw	r24, 0x01	; 1
    3fb8:	84 36       	cpi	r24, 0x64	; 100
    3fba:	91 05       	cpc	r25, r1
    3fbc:	28 f4       	brcc	.+10     	; 0x3fc8 <__vector_91+0x8e>
    3fbe:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvD1_read_index>
    3fc2:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvD1_read_index+0x1>
    3fc6:	08 c0       	rjmp	.+16     	; 0x3fd8 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3fc8:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvD1_read_index>
    3fcc:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvD1_read_index+0x1>
}
    3fd0:	03 c0       	rjmp	.+6      	; 0x3fd8 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3fd2:	81 e0       	ldi	r24, 0x01	; 1
    3fd4:	90 e0       	ldi	r25, 0x00	; 0
    3fd6:	f3 cf       	rjmp	.-26     	; 0x3fbe <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3fd8:	ff 91       	pop	r31
    3fda:	ef 91       	pop	r30
    3fdc:	9f 91       	pop	r25
    3fde:	8f 91       	pop	r24
    3fe0:	3f 91       	pop	r19
    3fe2:	2f 91       	pop	r18
    3fe4:	0f 90       	pop	r0
    3fe6:	0b be       	out	0x3b, r0	; 59
    3fe8:	0f 90       	pop	r0
    3fea:	08 be       	out	0x38, r0	; 56
    3fec:	0f 90       	pop	r0
    3fee:	0f be       	out	0x3f, r0	; 63
    3ff0:	0f 90       	pop	r0
    3ff2:	1f 90       	pop	r1
    3ff4:	18 95       	reti

00003ff6 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3ff6:	1f 92       	push	r1
    3ff8:	0f 92       	push	r0
    3ffa:	0f b6       	in	r0, 0x3f	; 63
    3ffc:	0f 92       	push	r0
    3ffe:	11 24       	eor	r1, r1
    4000:	08 b6       	in	r0, 0x38	; 56
    4002:	0f 92       	push	r0
    4004:	18 be       	out	0x38, r1	; 56
    4006:	0b b6       	in	r0, 0x3b	; 59
    4008:	0f 92       	push	r0
    400a:	1b be       	out	0x3b, r1	; 59
    400c:	2f 93       	push	r18
    400e:	3f 93       	push	r19
    4010:	8f 93       	push	r24
    4012:	9f 93       	push	r25
    4014:	ef 93       	push	r30
    4016:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    4018:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    401c:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <rcvE0_buffer>
    4020:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <rcvE0_buffer+0x1>
    4024:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvE0_write_index>
    4028:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvE0_write_index+0x1>
    402c:	e8 0f       	add	r30, r24
    402e:	f9 1f       	adc	r31, r25
    4030:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4032:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvE0_write_index>
    4036:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvE0_write_index+0x1>
    403a:	01 96       	adiw	r24, 0x01	; 1
    403c:	84 36       	cpi	r24, 0x64	; 100
    403e:	91 05       	cpc	r25, r1
    4040:	60 f4       	brcc	.+24     	; 0x405a <__stack+0x5b>
    4042:	80 93 1c 31 	sts	0x311C, r24	; 0x80311c <rcvE0_write_index>
    4046:	90 93 1d 31 	sts	0x311D, r25	; 0x80311d <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    404a:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <rcvE0_read_index>
    404e:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <rcvE0_read_index+0x1>
    4052:	82 17       	cp	r24, r18
    4054:	93 07       	cpc	r25, r19
    4056:	f1 f4       	brne	.+60     	; 0x4094 <__stack+0x95>
    4058:	0c c0       	rjmp	.+24     	; 0x4072 <__stack+0x73>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    405a:	10 92 1c 31 	sts	0x311C, r1	; 0x80311c <rcvE0_write_index>
    405e:	10 92 1d 31 	sts	0x311D, r1	; 0x80311d <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4062:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <rcvE0_read_index>
    4066:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <rcvE0_read_index+0x1>
    406a:	18 16       	cp	r1, r24
    406c:	19 06       	cpc	r1, r25
    406e:	91 f4       	brne	.+36     	; 0x4094 <__stack+0x95>
    4070:	0e c0       	rjmp	.+28     	; 0x408e <__stack+0x8f>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4072:	01 96       	adiw	r24, 0x01	; 1
    4074:	84 36       	cpi	r24, 0x64	; 100
    4076:	91 05       	cpc	r25, r1
    4078:	28 f4       	brcc	.+10     	; 0x4084 <__stack+0x85>
    407a:	80 93 26 31 	sts	0x3126, r24	; 0x803126 <rcvE0_read_index>
    407e:	90 93 27 31 	sts	0x3127, r25	; 0x803127 <rcvE0_read_index+0x1>
    4082:	08 c0       	rjmp	.+16     	; 0x4094 <__stack+0x95>
	rcvE0_read_index = 0;
    4084:	10 92 26 31 	sts	0x3126, r1	; 0x803126 <rcvE0_read_index>
    4088:	10 92 27 31 	sts	0x3127, r1	; 0x803127 <rcvE0_read_index+0x1>
}
    408c:	03 c0       	rjmp	.+6      	; 0x4094 <__stack+0x95>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    408e:	81 e0       	ldi	r24, 0x01	; 1
    4090:	90 e0       	ldi	r25, 0x00	; 0
    4092:	f3 cf       	rjmp	.-26     	; 0x407a <__stack+0x7b>
	rcvE0_read_index = 0;
}
    4094:	ff 91       	pop	r31
    4096:	ef 91       	pop	r30
    4098:	9f 91       	pop	r25
    409a:	8f 91       	pop	r24
    409c:	3f 91       	pop	r19
    409e:	2f 91       	pop	r18
    40a0:	0f 90       	pop	r0
    40a2:	0b be       	out	0x3b, r0	; 59
    40a4:	0f 90       	pop	r0
    40a6:	08 be       	out	0x38, r0	; 56
    40a8:	0f 90       	pop	r0
    40aa:	0f be       	out	0x3f, r0	; 63
    40ac:	0f 90       	pop	r0
    40ae:	1f 90       	pop	r1
    40b0:	18 95       	reti

000040b2 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    40b2:	0f 93       	push	r16
    40b4:	cf 93       	push	r28
    40b6:	df 93       	push	r29
    40b8:	1f 92       	push	r1
    40ba:	cd b7       	in	r28, 0x3d	; 61
    40bc:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    40be:	2f b7       	in	r18, 0x3f	; 63
    40c0:	29 83       	std	Y+1, r18	; 0x01
	cli();
    40c2:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    40c4:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    40c6:	fc 01       	movw	r30, r24
    40c8:	08 ed       	ldi	r16, 0xD8	; 216
    40ca:	04 bf       	out	0x34, r16	; 52
    40cc:	60 83       	st	Z, r22

	SREG = saved_sreg;
    40ce:	89 81       	ldd	r24, Y+1	; 0x01
    40d0:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    40d2:	0f 90       	pop	r0
    40d4:	df 91       	pop	r29
    40d6:	cf 91       	pop	r28
    40d8:	0f 91       	pop	r16
    40da:	08 95       	ret

000040dc <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    40dc:	0f 93       	push	r16
    40de:	1f 93       	push	r17
    40e0:	cf 93       	push	r28
    40e2:	df 93       	push	r29
    40e4:	cd b7       	in	r28, 0x3d	; 61
    40e6:	de b7       	in	r29, 0x3e	; 62
    40e8:	6d 97       	sbiw	r28, 0x1d	; 29
    40ea:	cd bf       	out	0x3d, r28	; 61
    40ec:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    40ee:	e0 e6       	ldi	r30, 0x60	; 96
    40f0:	f6 e0       	ldi	r31, 0x06	; 6
    40f2:	80 e4       	ldi	r24, 0x40	; 64
    40f4:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    40f6:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    40f8:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    40fa:	e0 e5       	ldi	r30, 0x50	; 80
    40fc:	f0 e0       	ldi	r31, 0x00	; 0
    40fe:	80 81       	ld	r24, Z
    4100:	82 60       	ori	r24, 0x02	; 2
    4102:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4104:	81 81       	ldd	r24, Z+1	; 0x01
    4106:	81 ff       	sbrs	r24, 1
    4108:	fd cf       	rjmp	.-6      	; 0x4104 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    410a:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    410e:	68 7f       	andi	r22, 0xF8	; 248
    4110:	61 60       	ori	r22, 0x01	; 1
    4112:	80 e4       	ldi	r24, 0x40	; 64
    4114:	90 e0       	ldi	r25, 0x00	; 0
    4116:	0e 94 59 20 	call	0x40b2	; 0x40b2 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    411a:	e0 e5       	ldi	r30, 0x50	; 80
    411c:	f0 e0       	ldi	r31, 0x00	; 0
    411e:	80 81       	ld	r24, Z
    4120:	8e 7f       	andi	r24, 0xFE	; 254
    4122:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4124:	9d ef       	ldi	r25, 0xFD	; 253
    4126:	88 ed       	ldi	r24, 0xD8	; 216
    4128:	08 b6       	in	r0, 0x38	; 56
    412a:	18 be       	out	0x38, r1	; 56
    412c:	84 bf       	out	0x34, r24	; 52
    412e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4132:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    4134:	40 eb       	ldi	r20, 0xB0	; 176
    4136:	58 e0       	ldi	r21, 0x08	; 8
    4138:	60 e0       	ldi	r22, 0x00	; 0
    413a:	70 e0       	ldi	r23, 0x00	; 0
    413c:	ce 01       	movw	r24, r28
    413e:	01 96       	adiw	r24, 0x01	; 1
    4140:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    4144:	67 e0       	ldi	r22, 0x07	; 7
    4146:	ce 01       	movw	r24, r28
    4148:	01 96       	adiw	r24, 0x01	; 1
    414a:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    414e:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    4150:	6b e6       	ldi	r22, 0x6B	; 107
    4152:	70 e2       	ldi	r23, 0x20	; 32
    4154:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstream4putsEPKc>
    4158:	66 e0       	ldi	r22, 0x06	; 6
    415a:	c8 01       	movw	r24, r16
    415c:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
    4160:	66 e0       	ldi	r22, 0x06	; 6
    4162:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    4166:	82 e1       	ldi	r24, 0x12	; 18
    4168:	90 e0       	ldi	r25, 0x00	; 0
    416a:	0e 94 75 1b 	call	0x36ea	; 0x36ea <_Znwj>
    416e:	8e 01       	movw	r16, r28
    4170:	0f 5f       	subi	r16, 0xFF	; 255
    4172:	1f 4f       	sbci	r17, 0xFF	; 255
    4174:	24 e0       	ldi	r18, 0x04	; 4
    4176:	31 e0       	ldi	r19, 0x01	; 1
    4178:	40 e0       	ldi	r20, 0x00	; 0
    417a:	6a e8       	ldi	r22, 0x8A	; 138
    417c:	70 e2       	ldi	r23, 0x20	; 32
    417e:	0e 94 a5 08 	call	0x114a	; 0x114a <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    4182:	82 e1       	ldi	r24, 0x12	; 18
    4184:	90 e0       	ldi	r25, 0x00	; 0
    4186:	0e 94 75 1b 	call	0x36ea	; 0x36ea <_Znwj>
    418a:	24 e0       	ldi	r18, 0x04	; 4
    418c:	31 e0       	ldi	r19, 0x01	; 1
    418e:	42 e0       	ldi	r20, 0x02	; 2
    4190:	62 e9       	ldi	r22, 0x92	; 146
    4192:	70 e2       	ldi	r23, 0x20	; 32
    4194:	0e 94 4b 04 	call	0x896	; 0x896 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    4198:	82 e1       	ldi	r24, 0x12	; 18
    419a:	90 e0       	ldi	r25, 0x00	; 0
    419c:	0e 94 75 1b 	call	0x36ea	; 0x36ea <_Znwj>
    41a0:	24 e0       	ldi	r18, 0x04	; 4
    41a2:	31 e0       	ldi	r19, 0x01	; 1
    41a4:	43 e0       	ldi	r20, 0x03	; 3
    41a6:	69 e9       	ldi	r22, 0x99	; 153
    41a8:	70 e2       	ldi	r23, 0x20	; 32
    41aa:	0e 94 a4 04 	call	0x948	; 0x948 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    41ae:	82 e1       	ldi	r24, 0x12	; 18
    41b0:	90 e0       	ldi	r25, 0x00	; 0
    41b2:	0e 94 75 1b 	call	0x36ea	; 0x36ea <_Znwj>
    41b6:	24 e0       	ldi	r18, 0x04	; 4
    41b8:	31 e0       	ldi	r19, 0x01	; 1
    41ba:	44 e0       	ldi	r20, 0x04	; 4
    41bc:	60 ea       	ldi	r22, 0xA0	; 160
    41be:	70 e2       	ldi	r23, 0x20	; 32
    41c0:	0e 94 09 05 	call	0xa12	; 0xa12 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    41c4:	8c e6       	ldi	r24, 0x6C	; 108
    41c6:	90 e0       	ldi	r25, 0x00	; 0
    41c8:	0e 94 75 1b 	call	0x36ea	; 0x36ea <_Znwj>
    41cc:	24 e0       	ldi	r18, 0x04	; 4
    41ce:	31 e0       	ldi	r19, 0x01	; 1
    41d0:	43 e0       	ldi	r20, 0x03	; 3
    41d2:	69 ea       	ldi	r22, 0xA9	; 169
    41d4:	70 e2       	ldi	r23, 0x20	; 32
    41d6:	0e 94 67 08 	call	0x10ce	; 0x10ce <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    41da:	87 e0       	ldi	r24, 0x07	; 7
    41dc:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    41e0:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    41e2:	0e 94 87 12 	call	0x250e	; 0x250e <vTaskStartScheduler>
	
	
	return 0;
    41e6:	80 e0       	ldi	r24, 0x00	; 0
    41e8:	90 e0       	ldi	r25, 0x00	; 0
    41ea:	6d 96       	adiw	r28, 0x1d	; 29
    41ec:	cd bf       	out	0x3d, r28	; 61
    41ee:	de bf       	out	0x3e, r29	; 62
    41f0:	df 91       	pop	r29
    41f2:	cf 91       	pop	r28
    41f4:	1f 91       	pop	r17
    41f6:	0f 91       	pop	r16
    41f8:	08 95       	ret

000041fa <_GLOBAL__sub_I_counter>:
    41fa:	0f 93       	push	r16
    41fc:	1f 93       	push	r17
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    41fe:	0a e0       	ldi	r16, 0x0A	; 10
    4200:	10 e0       	ldi	r17, 0x00	; 0
    4202:	20 e0       	ldi	r18, 0x00	; 0
    4204:	30 e0       	ldi	r19, 0x00	; 0
    4206:	40 e0       	ldi	r20, 0x00	; 0
    4208:	50 e0       	ldi	r21, 0x00	; 0
    420a:	60 e2       	ldi	r22, 0x20	; 32
    420c:	70 e0       	ldi	r23, 0x00	; 0
    420e:	88 e4       	ldi	r24, 0x48	; 72
    4210:	91 e3       	ldi	r25, 0x31	; 49
    4212:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    4216:	1f 91       	pop	r17
    4218:	0f 91       	pop	r16
    421a:	08 95       	ret

0000421c <__cmpsf2>:
    421c:	0e 94 50 21 	call	0x42a0	; 0x42a0 <__fp_cmp>
    4220:	08 f4       	brcc	.+2      	; 0x4224 <__cmpsf2+0x8>
    4222:	81 e0       	ldi	r24, 0x01	; 1
    4224:	08 95       	ret

00004226 <__floatunsisf>:
    4226:	e8 94       	clt
    4228:	09 c0       	rjmp	.+18     	; 0x423c <__floatsisf+0x12>

0000422a <__floatsisf>:
    422a:	97 fb       	bst	r25, 7
    422c:	3e f4       	brtc	.+14     	; 0x423c <__floatsisf+0x12>
    422e:	90 95       	com	r25
    4230:	80 95       	com	r24
    4232:	70 95       	com	r23
    4234:	61 95       	neg	r22
    4236:	7f 4f       	sbci	r23, 0xFF	; 255
    4238:	8f 4f       	sbci	r24, 0xFF	; 255
    423a:	9f 4f       	sbci	r25, 0xFF	; 255
    423c:	99 23       	and	r25, r25
    423e:	a9 f0       	breq	.+42     	; 0x426a <__floatsisf+0x40>
    4240:	f9 2f       	mov	r31, r25
    4242:	96 e9       	ldi	r25, 0x96	; 150
    4244:	bb 27       	eor	r27, r27
    4246:	93 95       	inc	r25
    4248:	f6 95       	lsr	r31
    424a:	87 95       	ror	r24
    424c:	77 95       	ror	r23
    424e:	67 95       	ror	r22
    4250:	b7 95       	ror	r27
    4252:	f1 11       	cpse	r31, r1
    4254:	f8 cf       	rjmp	.-16     	; 0x4246 <__floatsisf+0x1c>
    4256:	fa f4       	brpl	.+62     	; 0x4296 <__floatsisf+0x6c>
    4258:	bb 0f       	add	r27, r27
    425a:	11 f4       	brne	.+4      	; 0x4260 <__floatsisf+0x36>
    425c:	60 ff       	sbrs	r22, 0
    425e:	1b c0       	rjmp	.+54     	; 0x4296 <__floatsisf+0x6c>
    4260:	6f 5f       	subi	r22, 0xFF	; 255
    4262:	7f 4f       	sbci	r23, 0xFF	; 255
    4264:	8f 4f       	sbci	r24, 0xFF	; 255
    4266:	9f 4f       	sbci	r25, 0xFF	; 255
    4268:	16 c0       	rjmp	.+44     	; 0x4296 <__floatsisf+0x6c>
    426a:	88 23       	and	r24, r24
    426c:	11 f0       	breq	.+4      	; 0x4272 <__floatsisf+0x48>
    426e:	96 e9       	ldi	r25, 0x96	; 150
    4270:	11 c0       	rjmp	.+34     	; 0x4294 <__floatsisf+0x6a>
    4272:	77 23       	and	r23, r23
    4274:	21 f0       	breq	.+8      	; 0x427e <__floatsisf+0x54>
    4276:	9e e8       	ldi	r25, 0x8E	; 142
    4278:	87 2f       	mov	r24, r23
    427a:	76 2f       	mov	r23, r22
    427c:	05 c0       	rjmp	.+10     	; 0x4288 <__floatsisf+0x5e>
    427e:	66 23       	and	r22, r22
    4280:	71 f0       	breq	.+28     	; 0x429e <__floatsisf+0x74>
    4282:	96 e8       	ldi	r25, 0x86	; 134
    4284:	86 2f       	mov	r24, r22
    4286:	70 e0       	ldi	r23, 0x00	; 0
    4288:	60 e0       	ldi	r22, 0x00	; 0
    428a:	2a f0       	brmi	.+10     	; 0x4296 <__floatsisf+0x6c>
    428c:	9a 95       	dec	r25
    428e:	66 0f       	add	r22, r22
    4290:	77 1f       	adc	r23, r23
    4292:	88 1f       	adc	r24, r24
    4294:	da f7       	brpl	.-10     	; 0x428c <__floatsisf+0x62>
    4296:	88 0f       	add	r24, r24
    4298:	96 95       	lsr	r25
    429a:	87 95       	ror	r24
    429c:	97 f9       	bld	r25, 7
    429e:	08 95       	ret

000042a0 <__fp_cmp>:
    42a0:	99 0f       	add	r25, r25
    42a2:	00 08       	sbc	r0, r0
    42a4:	55 0f       	add	r21, r21
    42a6:	aa 0b       	sbc	r26, r26
    42a8:	e0 e8       	ldi	r30, 0x80	; 128
    42aa:	fe ef       	ldi	r31, 0xFE	; 254
    42ac:	16 16       	cp	r1, r22
    42ae:	17 06       	cpc	r1, r23
    42b0:	e8 07       	cpc	r30, r24
    42b2:	f9 07       	cpc	r31, r25
    42b4:	c0 f0       	brcs	.+48     	; 0x42e6 <__fp_cmp+0x46>
    42b6:	12 16       	cp	r1, r18
    42b8:	13 06       	cpc	r1, r19
    42ba:	e4 07       	cpc	r30, r20
    42bc:	f5 07       	cpc	r31, r21
    42be:	98 f0       	brcs	.+38     	; 0x42e6 <__fp_cmp+0x46>
    42c0:	62 1b       	sub	r22, r18
    42c2:	73 0b       	sbc	r23, r19
    42c4:	84 0b       	sbc	r24, r20
    42c6:	95 0b       	sbc	r25, r21
    42c8:	39 f4       	brne	.+14     	; 0x42d8 <__fp_cmp+0x38>
    42ca:	0a 26       	eor	r0, r26
    42cc:	61 f0       	breq	.+24     	; 0x42e6 <__fp_cmp+0x46>
    42ce:	23 2b       	or	r18, r19
    42d0:	24 2b       	or	r18, r20
    42d2:	25 2b       	or	r18, r21
    42d4:	21 f4       	brne	.+8      	; 0x42de <__fp_cmp+0x3e>
    42d6:	08 95       	ret
    42d8:	0a 26       	eor	r0, r26
    42da:	09 f4       	brne	.+2      	; 0x42de <__fp_cmp+0x3e>
    42dc:	a1 40       	sbci	r26, 0x01	; 1
    42de:	a6 95       	lsr	r26
    42e0:	8f ef       	ldi	r24, 0xFF	; 255
    42e2:	81 1d       	adc	r24, r1
    42e4:	81 1d       	adc	r24, r1
    42e6:	08 95       	ret

000042e8 <__gesf2>:
    42e8:	0e 94 50 21 	call	0x42a0	; 0x42a0 <__fp_cmp>
    42ec:	08 f4       	brcc	.+2      	; 0x42f0 <__gesf2+0x8>
    42ee:	8f ef       	ldi	r24, 0xFF	; 255
    42f0:	08 95       	ret

000042f2 <__mulsi3>:
    42f2:	db 01       	movw	r26, r22
    42f4:	8f 93       	push	r24
    42f6:	9f 93       	push	r25
    42f8:	0e 94 05 22 	call	0x440a	; 0x440a <__muluhisi3>
    42fc:	bf 91       	pop	r27
    42fe:	af 91       	pop	r26
    4300:	a2 9f       	mul	r26, r18
    4302:	80 0d       	add	r24, r0
    4304:	91 1d       	adc	r25, r1
    4306:	a3 9f       	mul	r26, r19
    4308:	90 0d       	add	r25, r0
    430a:	b2 9f       	mul	r27, r18
    430c:	90 0d       	add	r25, r0
    430e:	11 24       	eor	r1, r1
    4310:	08 95       	ret

00004312 <__divmodhi4>:
    4312:	97 fb       	bst	r25, 7
    4314:	07 2e       	mov	r0, r23
    4316:	16 f4       	brtc	.+4      	; 0x431c <__divmodhi4+0xa>
    4318:	00 94       	com	r0
    431a:	07 d0       	rcall	.+14     	; 0x432a <__divmodhi4_neg1>
    431c:	77 fd       	sbrc	r23, 7
    431e:	09 d0       	rcall	.+18     	; 0x4332 <__divmodhi4_neg2>
    4320:	0e 94 18 22 	call	0x4430	; 0x4430 <__udivmodhi4>
    4324:	07 fc       	sbrc	r0, 7
    4326:	05 d0       	rcall	.+10     	; 0x4332 <__divmodhi4_neg2>
    4328:	3e f4       	brtc	.+14     	; 0x4338 <__divmodhi4_exit>

0000432a <__divmodhi4_neg1>:
    432a:	90 95       	com	r25
    432c:	81 95       	neg	r24
    432e:	9f 4f       	sbci	r25, 0xFF	; 255
    4330:	08 95       	ret

00004332 <__divmodhi4_neg2>:
    4332:	70 95       	com	r23
    4334:	61 95       	neg	r22
    4336:	7f 4f       	sbci	r23, 0xFF	; 255

00004338 <__divmodhi4_exit>:
    4338:	08 95       	ret

0000433a <__udivmodsi4>:
    433a:	a1 e2       	ldi	r26, 0x21	; 33
    433c:	1a 2e       	mov	r1, r26
    433e:	aa 1b       	sub	r26, r26
    4340:	bb 1b       	sub	r27, r27
    4342:	fd 01       	movw	r30, r26
    4344:	0d c0       	rjmp	.+26     	; 0x4360 <__udivmodsi4_ep>

00004346 <__udivmodsi4_loop>:
    4346:	aa 1f       	adc	r26, r26
    4348:	bb 1f       	adc	r27, r27
    434a:	ee 1f       	adc	r30, r30
    434c:	ff 1f       	adc	r31, r31
    434e:	a2 17       	cp	r26, r18
    4350:	b3 07       	cpc	r27, r19
    4352:	e4 07       	cpc	r30, r20
    4354:	f5 07       	cpc	r31, r21
    4356:	20 f0       	brcs	.+8      	; 0x4360 <__udivmodsi4_ep>
    4358:	a2 1b       	sub	r26, r18
    435a:	b3 0b       	sbc	r27, r19
    435c:	e4 0b       	sbc	r30, r20
    435e:	f5 0b       	sbc	r31, r21

00004360 <__udivmodsi4_ep>:
    4360:	66 1f       	adc	r22, r22
    4362:	77 1f       	adc	r23, r23
    4364:	88 1f       	adc	r24, r24
    4366:	99 1f       	adc	r25, r25
    4368:	1a 94       	dec	r1
    436a:	69 f7       	brne	.-38     	; 0x4346 <__udivmodsi4_loop>
    436c:	60 95       	com	r22
    436e:	70 95       	com	r23
    4370:	80 95       	com	r24
    4372:	90 95       	com	r25
    4374:	9b 01       	movw	r18, r22
    4376:	ac 01       	movw	r20, r24
    4378:	bd 01       	movw	r22, r26
    437a:	cf 01       	movw	r24, r30
    437c:	08 95       	ret

0000437e <__divmodsi4>:
    437e:	05 2e       	mov	r0, r21
    4380:	97 fb       	bst	r25, 7
    4382:	1e f4       	brtc	.+6      	; 0x438a <__divmodsi4+0xc>
    4384:	00 94       	com	r0
    4386:	0e 94 d6 21 	call	0x43ac	; 0x43ac <__negsi2>
    438a:	57 fd       	sbrc	r21, 7
    438c:	07 d0       	rcall	.+14     	; 0x439c <__divmodsi4_neg2>
    438e:	0e 94 9d 21 	call	0x433a	; 0x433a <__udivmodsi4>
    4392:	07 fc       	sbrc	r0, 7
    4394:	03 d0       	rcall	.+6      	; 0x439c <__divmodsi4_neg2>
    4396:	4e f4       	brtc	.+18     	; 0x43aa <__divmodsi4_exit>
    4398:	0c 94 d6 21 	jmp	0x43ac	; 0x43ac <__negsi2>

0000439c <__divmodsi4_neg2>:
    439c:	50 95       	com	r21
    439e:	40 95       	com	r20
    43a0:	30 95       	com	r19
    43a2:	21 95       	neg	r18
    43a4:	3f 4f       	sbci	r19, 0xFF	; 255
    43a6:	4f 4f       	sbci	r20, 0xFF	; 255
    43a8:	5f 4f       	sbci	r21, 0xFF	; 255

000043aa <__divmodsi4_exit>:
    43aa:	08 95       	ret

000043ac <__negsi2>:
    43ac:	90 95       	com	r25
    43ae:	80 95       	com	r24
    43b0:	70 95       	com	r23
    43b2:	61 95       	neg	r22
    43b4:	7f 4f       	sbci	r23, 0xFF	; 255
    43b6:	8f 4f       	sbci	r24, 0xFF	; 255
    43b8:	9f 4f       	sbci	r25, 0xFF	; 255
    43ba:	08 95       	ret

000043bc <__tablejump2__>:
    43bc:	ee 0f       	add	r30, r30
    43be:	ff 1f       	adc	r31, r31
    43c0:	88 1f       	adc	r24, r24
    43c2:	8b bf       	out	0x3b, r24	; 59
    43c4:	07 90       	elpm	r0, Z+
    43c6:	f6 91       	elpm	r31, Z
    43c8:	e0 2d       	mov	r30, r0
    43ca:	1b be       	out	0x3b, r1	; 59
    43cc:	19 94       	eijmp

000043ce <__mulhisi3>:
    43ce:	0e 94 ef 21 	call	0x43de	; 0x43de <__umulhisi3>
    43d2:	33 23       	and	r19, r19
    43d4:	12 f4       	brpl	.+4      	; 0x43da <__mulhisi3+0xc>
    43d6:	8a 1b       	sub	r24, r26
    43d8:	9b 0b       	sbc	r25, r27
    43da:	0c 94 00 22 	jmp	0x4400	; 0x4400 <__usmulhisi3_tail>

000043de <__umulhisi3>:
    43de:	a2 9f       	mul	r26, r18
    43e0:	b0 01       	movw	r22, r0
    43e2:	b3 9f       	mul	r27, r19
    43e4:	c0 01       	movw	r24, r0
    43e6:	a3 9f       	mul	r26, r19
    43e8:	70 0d       	add	r23, r0
    43ea:	81 1d       	adc	r24, r1
    43ec:	11 24       	eor	r1, r1
    43ee:	91 1d       	adc	r25, r1
    43f0:	b2 9f       	mul	r27, r18
    43f2:	70 0d       	add	r23, r0
    43f4:	81 1d       	adc	r24, r1
    43f6:	11 24       	eor	r1, r1
    43f8:	91 1d       	adc	r25, r1
    43fa:	08 95       	ret

000043fc <__usmulhisi3>:
    43fc:	0e 94 ef 21 	call	0x43de	; 0x43de <__umulhisi3>

00004400 <__usmulhisi3_tail>:
    4400:	b7 ff       	sbrs	r27, 7
    4402:	08 95       	ret
    4404:	82 1b       	sub	r24, r18
    4406:	93 0b       	sbc	r25, r19
    4408:	08 95       	ret

0000440a <__muluhisi3>:
    440a:	0e 94 ef 21 	call	0x43de	; 0x43de <__umulhisi3>
    440e:	a5 9f       	mul	r26, r21
    4410:	90 0d       	add	r25, r0
    4412:	b4 9f       	mul	r27, r20
    4414:	90 0d       	add	r25, r0
    4416:	a4 9f       	mul	r26, r20
    4418:	80 0d       	add	r24, r0
    441a:	91 1d       	adc	r25, r1
    441c:	11 24       	eor	r1, r1
    441e:	08 95       	ret

00004420 <__mulshisi3>:
    4420:	b7 ff       	sbrs	r27, 7
    4422:	0c 94 05 22 	jmp	0x440a	; 0x440a <__muluhisi3>

00004426 <__mulohisi3>:
    4426:	0e 94 05 22 	call	0x440a	; 0x440a <__muluhisi3>
    442a:	82 1b       	sub	r24, r18
    442c:	93 0b       	sbc	r25, r19
    442e:	08 95       	ret

00004430 <__udivmodhi4>:
    4430:	aa 1b       	sub	r26, r26
    4432:	bb 1b       	sub	r27, r27
    4434:	51 e1       	ldi	r21, 0x11	; 17
    4436:	07 c0       	rjmp	.+14     	; 0x4446 <__udivmodhi4_ep>

00004438 <__udivmodhi4_loop>:
    4438:	aa 1f       	adc	r26, r26
    443a:	bb 1f       	adc	r27, r27
    443c:	a6 17       	cp	r26, r22
    443e:	b7 07       	cpc	r27, r23
    4440:	10 f0       	brcs	.+4      	; 0x4446 <__udivmodhi4_ep>
    4442:	a6 1b       	sub	r26, r22
    4444:	b7 0b       	sbc	r27, r23

00004446 <__udivmodhi4_ep>:
    4446:	88 1f       	adc	r24, r24
    4448:	99 1f       	adc	r25, r25
    444a:	5a 95       	dec	r21
    444c:	a9 f7       	brne	.-22     	; 0x4438 <__udivmodhi4_loop>
    444e:	80 95       	com	r24
    4450:	90 95       	com	r25
    4452:	bc 01       	movw	r22, r24
    4454:	cd 01       	movw	r24, r26
    4456:	08 95       	ret

00004458 <memcpy>:
    4458:	fb 01       	movw	r30, r22
    445a:	dc 01       	movw	r26, r24
    445c:	02 c0       	rjmp	.+4      	; 0x4462 <memcpy+0xa>
    445e:	01 90       	ld	r0, Z+
    4460:	0d 92       	st	X+, r0
    4462:	41 50       	subi	r20, 0x01	; 1
    4464:	50 40       	sbci	r21, 0x00	; 0
    4466:	d8 f7       	brcc	.-10     	; 0x445e <memcpy+0x6>
    4468:	08 95       	ret

0000446a <memset>:
    446a:	dc 01       	movw	r26, r24
    446c:	01 c0       	rjmp	.+2      	; 0x4470 <memset+0x6>
    446e:	6d 93       	st	X+, r22
    4470:	41 50       	subi	r20, 0x01	; 1
    4472:	50 40       	sbci	r21, 0x00	; 0
    4474:	e0 f7       	brcc	.-8      	; 0x446e <memset+0x4>
    4476:	08 95       	ret

00004478 <strncpy>:
    4478:	fb 01       	movw	r30, r22
    447a:	dc 01       	movw	r26, r24
    447c:	41 50       	subi	r20, 0x01	; 1
    447e:	50 40       	sbci	r21, 0x00	; 0
    4480:	48 f0       	brcs	.+18     	; 0x4494 <strncpy+0x1c>
    4482:	01 90       	ld	r0, Z+
    4484:	0d 92       	st	X+, r0
    4486:	00 20       	and	r0, r0
    4488:	c9 f7       	brne	.-14     	; 0x447c <strncpy+0x4>
    448a:	01 c0       	rjmp	.+2      	; 0x448e <strncpy+0x16>
    448c:	1d 92       	st	X+, r1
    448e:	41 50       	subi	r20, 0x01	; 1
    4490:	50 40       	sbci	r21, 0x00	; 0
    4492:	e0 f7       	brcc	.-8      	; 0x448c <strncpy+0x14>
    4494:	08 95       	ret

00004496 <ultoa>:
    4496:	25 32       	cpi	r18, 0x25	; 37
    4498:	31 05       	cpc	r19, r1
    449a:	20 f4       	brcc	.+8      	; 0x44a4 <ultoa+0xe>
    449c:	22 30       	cpi	r18, 0x02	; 2
    449e:	10 f0       	brcs	.+4      	; 0x44a4 <ultoa+0xe>
    44a0:	0c 94 56 22 	jmp	0x44ac	; 0x44ac <__ultoa_ncheck>
    44a4:	fa 01       	movw	r30, r20
    44a6:	10 82       	st	Z, r1
    44a8:	ca 01       	movw	r24, r20
    44aa:	08 95       	ret

000044ac <__ultoa_ncheck>:
    44ac:	bb 27       	eor	r27, r27

000044ae <__ultoa_common>:
    44ae:	fa 01       	movw	r30, r20
    44b0:	a6 2f       	mov	r26, r22
    44b2:	62 17       	cp	r22, r18
    44b4:	71 05       	cpc	r23, r1
    44b6:	81 05       	cpc	r24, r1
    44b8:	91 05       	cpc	r25, r1
    44ba:	33 0b       	sbc	r19, r19
    44bc:	30 fb       	bst	r19, 0
    44be:	66 f0       	brts	.+24     	; 0x44d8 <__ultoa_common+0x2a>
    44c0:	aa 27       	eor	r26, r26
    44c2:	66 0f       	add	r22, r22
    44c4:	77 1f       	adc	r23, r23
    44c6:	88 1f       	adc	r24, r24
    44c8:	99 1f       	adc	r25, r25
    44ca:	aa 1f       	adc	r26, r26
    44cc:	a2 17       	cp	r26, r18
    44ce:	10 f0       	brcs	.+4      	; 0x44d4 <__ultoa_common+0x26>
    44d0:	a2 1b       	sub	r26, r18
    44d2:	63 95       	inc	r22
    44d4:	38 50       	subi	r19, 0x08	; 8
    44d6:	a9 f7       	brne	.-22     	; 0x44c2 <__ultoa_common+0x14>
    44d8:	a0 5d       	subi	r26, 0xD0	; 208
    44da:	aa 33       	cpi	r26, 0x3A	; 58
    44dc:	08 f0       	brcs	.+2      	; 0x44e0 <__ultoa_common+0x32>
    44de:	a9 5d       	subi	r26, 0xD9	; 217
    44e0:	a1 93       	st	Z+, r26
    44e2:	36 f7       	brtc	.-52     	; 0x44b0 <__ultoa_common+0x2>
    44e4:	b1 11       	cpse	r27, r1
    44e6:	b1 93       	st	Z+, r27
    44e8:	10 82       	st	Z, r1
    44ea:	ca 01       	movw	r24, r20
    44ec:	0c 94 9d 22 	jmp	0x453a	; 0x453a <strrev>

000044f0 <utoa>:
    44f0:	45 32       	cpi	r20, 0x25	; 37
    44f2:	51 05       	cpc	r21, r1
    44f4:	20 f4       	brcc	.+8      	; 0x44fe <utoa+0xe>
    44f6:	42 30       	cpi	r20, 0x02	; 2
    44f8:	10 f0       	brcs	.+4      	; 0x44fe <utoa+0xe>
    44fa:	0c 94 83 22 	jmp	0x4506	; 0x4506 <__utoa_ncheck>
    44fe:	fb 01       	movw	r30, r22
    4500:	10 82       	st	Z, r1
    4502:	cb 01       	movw	r24, r22
    4504:	08 95       	ret

00004506 <__utoa_ncheck>:
    4506:	bb 27       	eor	r27, r27

00004508 <__utoa_common>:
    4508:	fb 01       	movw	r30, r22
    450a:	55 27       	eor	r21, r21
    450c:	aa 27       	eor	r26, r26
    450e:	88 0f       	add	r24, r24
    4510:	99 1f       	adc	r25, r25
    4512:	aa 1f       	adc	r26, r26
    4514:	a4 17       	cp	r26, r20
    4516:	10 f0       	brcs	.+4      	; 0x451c <__utoa_common+0x14>
    4518:	a4 1b       	sub	r26, r20
    451a:	83 95       	inc	r24
    451c:	50 51       	subi	r21, 0x10	; 16
    451e:	b9 f7       	brne	.-18     	; 0x450e <__utoa_common+0x6>
    4520:	a0 5d       	subi	r26, 0xD0	; 208
    4522:	aa 33       	cpi	r26, 0x3A	; 58
    4524:	08 f0       	brcs	.+2      	; 0x4528 <__utoa_common+0x20>
    4526:	a9 5d       	subi	r26, 0xD9	; 217
    4528:	a1 93       	st	Z+, r26
    452a:	00 97       	sbiw	r24, 0x00	; 0
    452c:	79 f7       	brne	.-34     	; 0x450c <__utoa_common+0x4>
    452e:	b1 11       	cpse	r27, r1
    4530:	b1 93       	st	Z+, r27
    4532:	11 92       	st	Z+, r1
    4534:	cb 01       	movw	r24, r22
    4536:	0c 94 9d 22 	jmp	0x453a	; 0x453a <strrev>

0000453a <strrev>:
    453a:	dc 01       	movw	r26, r24
    453c:	fc 01       	movw	r30, r24
    453e:	67 2f       	mov	r22, r23
    4540:	71 91       	ld	r23, Z+
    4542:	77 23       	and	r23, r23
    4544:	e1 f7       	brne	.-8      	; 0x453e <strrev+0x4>
    4546:	32 97       	sbiw	r30, 0x02	; 2
    4548:	04 c0       	rjmp	.+8      	; 0x4552 <strrev+0x18>
    454a:	7c 91       	ld	r23, X
    454c:	6d 93       	st	X+, r22
    454e:	70 83       	st	Z, r23
    4550:	62 91       	ld	r22, -Z
    4552:	ae 17       	cp	r26, r30
    4554:	bf 07       	cpc	r27, r31
    4556:	c8 f3       	brcs	.-14     	; 0x454a <strrev+0x10>
    4558:	08 95       	ret

0000455a <_exit>:
    455a:	f8 94       	cli

0000455c <__stop_program>:
    455c:	ff cf       	rjmp	.-2      	; 0x455c <__stop_program>
