
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000041c8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000f4  00802000  000041c8  0000425c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ae  008020f4  008020f4  00004350  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004350  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004380  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000700  00000000  00000000  000043c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000124d5  00000000  00000000  00004ac0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000079f6  00000000  00000000  00016f95  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000529f  00000000  00000000  0001e98b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001370  00000000  00000000  00023c2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006e14  00000000  00000000  00024f9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005f16  00000000  00000000  0002bdb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005b0  00000000  00000000  00031cc6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ab 02 	jmp	0x556	; 0x556 <__ctors_end>
       4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
       8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
       c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      10:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      14:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      18:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      1c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      20:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      24:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      28:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      2c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      30:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      34:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      38:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      3c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      40:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      44:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      48:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      4c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      50:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      54:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      58:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      5c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      60:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      64:	0c 94 bf 1a 	jmp	0x357e	; 0x357e <__vector_25>
      68:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      6c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      70:	0c 94 1d 1b 	jmp	0x363a	; 0x363a <__vector_28>
      74:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      78:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      7c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      80:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      84:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      88:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      8c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      90:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      94:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      98:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      9c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      ac:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      bc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      cc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      dc:	0c 94 5c 0a 	jmp	0x14b8	; 0x14b8 <__vector_55>
      e0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      e4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      e8:	0c 94 37 1c 	jmp	0x386e	; 0x386e <__vector_58>
      ec:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      f0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      f4:	0c 94 95 1c 	jmp	0x392a	; 0x392a <__vector_61>
      f8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      fc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     100:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     104:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     108:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     10c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     110:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     114:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     118:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     11c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     120:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     124:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     128:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     12c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     130:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     134:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     138:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     13c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     140:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     144:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     148:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     14c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     150:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     154:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     158:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     15c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     160:	0c 94 7b 1b 	jmp	0x36f6	; 0x36f6 <__vector_88>
     164:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     168:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     16c:	0c 94 d9 1b 	jmp	0x37b2	; 0x37b2 <__vector_91>
     170:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     174:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     178:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     17c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     180:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     184:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     188:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     18c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     190:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     194:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     198:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     19c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1ac:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1bc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1cc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1dc:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__vector_119>
     1e0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1e4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1e8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1ec:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1fc:	48 18       	sub	r4, r8
     1fe:	4b 18       	sub	r4, r11
     200:	4e 18       	sub	r4, r14
     202:	51 18       	sub	r5, r1
     204:	54 18       	sub	r5, r4
     206:	57 18       	sub	r5, r7
     208:	59 18       	sub	r5, r9
     20a:	6a 18       	sub	r6, r10
     20c:	72 18       	sub	r7, r2
     20e:	7c 18       	sub	r7, r12
     210:	7a 18       	sub	r7, r10

00000212 <__trampolines_start>:
     212:	0c 94 01 1a 	jmp	0x3402	; 0x3402 <_ZN5rs23214check_for_charEv>
     216:	0c 94 48 18 	jmp	0x3090	; 0x3090 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21a:	0c 94 59 15 	jmp	0x2ab2	; 0x2ab2 <_ZN14frt_text_queue7getcharEv>
     21e:	0c 94 f3 17 	jmp	0x2fe6	; 0x2fe6 <_ZN8emstream12clear_screenEv>
     222:	0c 94 ed 17 	jmp	0x2fda	; 0x2fda <_ZN8emstream7getcharEv>
     226:	0c 94 36 06 	jmp	0xc6c	; 0xc6c <_ZN9task_user3runEv>
     22a:	0c 94 4b 18 	jmp	0x3096	; 0x3096 <_ZN8emstreamlsE15ser_manipulator+0x24>
     22e:	0c 94 8f 04 	jmp	0x91e	; 0x91e <_ZN3pid3runEv>
     232:	0c 94 f0 17 	jmp	0x2fe0	; 0x2fe0 <_ZN8emstream14check_for_charEv>
     236:	0c 94 5d 04 	jmp	0x8ba	; 0x8ba <_ZN5Motor3runEv>
     23a:	0c 94 f2 17 	jmp	0x2fe4	; 0x2fe4 <_ZN8emstream12transmit_nowEv>
     23e:	0c 94 7c 18 	jmp	0x30f8	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
     242:	0c 94 06 1e 	jmp	0x3c0c	; 0x3c0c <_GLOBAL__sub_I_counter>
     246:	0c 94 54 18 	jmp	0x30a8	; 0x30a8 <_ZN8emstreamlsE15ser_manipulator+0x36>
     24a:	0c 94 82 15 	jmp	0x2b04	; 0x2b04 <_ZN14frt_text_queue7putcharEc>
     24e:	0c 94 e0 0c 	jmp	0x19c0	; 0x19c0 <prvIdleTask>
     252:	0c 94 3a 17 	jmp	0x2e74	; 0x2e74 <__cxa_pure_virtual>
     256:	0c 94 a8 02 	jmp	0x550	; 0x550 <_call_static_run_method>
     25a:	0c 94 77 15 	jmp	0x2aee	; 0x2aee <_ZN14frt_text_queue14check_for_charEv>
     25e:	0c 94 59 18 	jmp	0x30b2	; 0x30b2 <_ZN8emstreamlsE15ser_manipulator+0x40>
     262:	0c 94 eb 17 	jmp	0x2fd6	; 0x2fd6 <_ZN8emstream13ready_to_sendEv>
     266:	0c 94 7a 18 	jmp	0x30f4	; 0x30f4 <_ZN8emstreamlsE15ser_manipulator+0x82>
     26a:	0c 94 72 18 	jmp	0x30e4	; 0x30e4 <_ZN8emstreamlsE15ser_manipulator+0x72>
     26e:	0c 94 0f 14 	jmp	0x281e	; 0x281e <_ZN8frt_task12print_statusER8emstream>
     272:	0c 94 51 18 	jmp	0x30a2	; 0x30a2 <_ZN8emstreamlsE15ser_manipulator+0x30>
     276:	0c 94 a4 03 	jmp	0x748	; 0x748 <_ZN15EncoderPendulum3runEv>
     27a:	0c 94 b7 19 	jmp	0x336e	; 0x336e <_ZN5rs2327putcharEc>
     27e:	0c 94 57 18 	jmp	0x30ae	; 0x30ae <_ZN8emstreamlsE15ser_manipulator+0x3c>
     282:	0c 94 f5 03 	jmp	0x7ea	; 0x7ea <_ZN13LimitSwitches3runEv>
     286:	0c 94 6a 18 	jmp	0x30d4	; 0x30d4 <_ZN8emstreamlsE15ser_manipulator+0x62>
     28a:	0c 94 14 1a 	jmp	0x3428	; 0x3428 <_ZN5rs23212clear_screenEv>
     28e:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <_ZN12EncoderMotor3runEv>
     292:	0c 94 c1 04 	jmp	0x982	; 0x982 <_ZN9PWMdriver3runEv>
     296:	0c 94 4e 18 	jmp	0x309c	; 0x309c <_ZN8emstreamlsE15ser_manipulator+0x2a>
     29a:	0c 94 db 19 	jmp	0x33b6	; 0x33b6 <_ZN5rs2327getcharEv>

0000029e <__trampolines_end>:
     29e:	2c 20       	and	r2, r12
     2a0:	54 43       	sbci	r21, 0x34	; 52
     2a2:	43 30       	cpi	r20, 0x03	; 3
     2a4:	43 43       	sbci	r20, 0x33	; 51
     2a6:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a9 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a9:	2f 00                                               /.

000002ab <_ZZN9task_user11show_statusEvE3__c_2>:
     2ab:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b9 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b9:	54 69 6d 65 3a 20 00                                Time: .

000002c0 <_ZZN9task_user11show_statusEvE3__c_0>:
     2c0:	4e 6f 76 20 32 35 20 32 30 31 37 00                 Nov 25 2017.

000002cc <_ZZN9task_user11show_statusEvE3__c>:
     2cc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2dc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002eb <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2eb:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002fa <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2fa:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     30a:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000315 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     315:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     325:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000333 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     333:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     343:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     353:	6d 61 74 69 6f 6e 00                                mation.

0000035a <_ZZN9task_user18print_help_messageEvE3__c_6>:
     35a:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     36a:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000037b <_ZZN9task_user18print_help_messageEvE3__c_5>:
     37b:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     38b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000393 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     393:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     3a3:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003af <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3af:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bf:	68 65 20 41 56 52 00                                he AVR.

000003c6 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c6:	20 68 65 6c 70 00                                    help.

000003cc <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3cc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3dc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003eb <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3eb:	1b 5b 33 30 6d 00                                   .[30m.

000003f1 <_ZZN9task_user18print_help_messageEvE3__c>:
     3f1:	1b 5b 34 36 6d 00                                   .[46m.

000003f7 <_ZZN9task_user3runEvE3__c_3>:
     3f7:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     407:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000414 <_ZZN9task_user3runEvE3__c_2>:
     414:	3a 57 54 46 3f 00                                   :WTF?.

0000041a <_ZZN9task_user3runEvE3__c_1>:
     41a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     42a:	65 00                                               e.

0000042c <_ZZN9task_user3runEvE3__c_0>:
     42c:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000043a <_ZZN9task_user3runEvE3__c>:
     43a:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     44a:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000458 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     458:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000462 <_ZZN8frt_task15emergency_resetEvE3__c>:
     462:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000471 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     471:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     481:	61 73 6b 20 00                                      ask .

00000486 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     486:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000494 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     494:	20 63 72 65 61 74 65 64 00                           created.

0000049d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     49d:	54 61 73 6b 20 00                                   Task .

000004a3 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     4a3:	1b 5b 32 32 6d 00                                   .[22m.

000004a9 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a9:	54 61 73 6b 3a 20 00                                Task: .

000004b0 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4b0:	1b 5b 31 6d 00                                      .[1m.

000004b5 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b5:	1b 5b 32 32 6d 00                                   .[22m.

000004bb <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4bb:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c6 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c6:	1b 5b 31 6d 00                                      .[1m.

000004cb <_ZZ15print_task_listP8emstreamE3__c_9>:
     4cb:	09 09 00                                            ...

000004ce <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ce:	2f 00                                               /.

000004d0 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4d0:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004db <_ZZ15print_task_listP8emstreamE3__c_6>:
     4db:	09 2d 2d 2d 2d 00                                   .----.

000004e1 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4e1:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004ed <_ZZ15print_task_listP8emstreamE3__c_4>:
     4ed:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fe <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fe:	09 52 75 6e 73 00                                   .Runs.

00000504 <_ZZ15print_task_listP8emstreamE3__c_2>:
     504:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000510 <_ZZ15print_task_listP8emstreamE3__c_1>:
     510:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000521 <_ZZ15print_task_listP8emstreamE3__c_0>:
     521:	09 53 74 61 63 6b 00                                .Stack.

00000528 <_ZZ15print_task_listP8emstreamE3__c>:
     528:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     533:	09 00                                               ..

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     537:	2f 00                                               /.

00000539 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     539:	09 00                                               ..

0000053b <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     53b:	09 00                                               ..

0000053d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     53d:	1b 5b 32 32 6d 00                                   .[22m.

00000543 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     543:	1b 5b 31 6d 00                                      .[1m.

00000548 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     548:	1b 5b 31 6d 00                                      .[1m.

0000054d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     54d:	20 20 00                                              .

00000550 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     550:	0e 94 a7 12 	call	0x254e	; 0x254e <_ZN8frt_task22_call_users_run_methodEPS_>

00000554 <__ctors_start>:
     554:	06 1e       	adc	r0, r22

00000556 <__ctors_end>:
     556:	11 24       	eor	r1, r1
     558:	1f be       	out	0x3f, r1	; 63
     55a:	cf ef       	ldi	r28, 0xFF	; 255
     55c:	cd bf       	out	0x3d, r28	; 61
     55e:	df e3       	ldi	r29, 0x3F	; 63
     560:	de bf       	out	0x3e, r29	; 62
     562:	00 e0       	ldi	r16, 0x00	; 0
     564:	0c bf       	out	0x3c, r16	; 60
     566:	18 be       	out	0x38, r1	; 56
     568:	19 be       	out	0x39, r1	; 57
     56a:	1a be       	out	0x3a, r1	; 58
     56c:	1b be       	out	0x3b, r1	; 59

0000056e <__do_copy_data>:
     56e:	10 e2       	ldi	r17, 0x20	; 32
     570:	a0 e0       	ldi	r26, 0x00	; 0
     572:	b0 e2       	ldi	r27, 0x20	; 32
     574:	e8 ec       	ldi	r30, 0xC8	; 200
     576:	f1 e4       	ldi	r31, 0x41	; 65
     578:	00 e0       	ldi	r16, 0x00	; 0
     57a:	0b bf       	out	0x3b, r16	; 59
     57c:	02 c0       	rjmp	.+4      	; 0x582 <__do_copy_data+0x14>
     57e:	07 90       	elpm	r0, Z+
     580:	0d 92       	st	X+, r0
     582:	a4 3f       	cpi	r26, 0xF4	; 244
     584:	b1 07       	cpc	r27, r17
     586:	d9 f7       	brne	.-10     	; 0x57e <__do_copy_data+0x10>
     588:	1b be       	out	0x3b, r1	; 59

0000058a <__do_clear_bss>:
     58a:	21 e3       	ldi	r18, 0x31	; 49
     58c:	a4 ef       	ldi	r26, 0xF4	; 244
     58e:	b0 e2       	ldi	r27, 0x20	; 32
     590:	01 c0       	rjmp	.+2      	; 0x594 <.do_clear_bss_start>

00000592 <.do_clear_bss_loop>:
     592:	1d 92       	st	X+, r1

00000594 <.do_clear_bss_start>:
     594:	a2 3a       	cpi	r26, 0xA2	; 162
     596:	b2 07       	cpc	r27, r18
     598:	e1 f7       	brne	.-8      	; 0x592 <.do_clear_bss_loop>

0000059a <__do_global_ctors>:
     59a:	12 e0       	ldi	r17, 0x02	; 2
     59c:	cb ea       	ldi	r28, 0xAB	; 171
     59e:	d2 e0       	ldi	r29, 0x02	; 2
     5a0:	00 e0       	ldi	r16, 0x00	; 0
     5a2:	06 c0       	rjmp	.+12     	; 0x5b0 <__do_global_ctors+0x16>
     5a4:	21 97       	sbiw	r28, 0x01	; 1
     5a6:	01 09       	sbc	r16, r1
     5a8:	80 2f       	mov	r24, r16
     5aa:	fe 01       	movw	r30, r28
     5ac:	0e 94 1f 20 	call	0x403e	; 0x403e <__tablejump2__>
     5b0:	ca 3a       	cpi	r28, 0xAA	; 170
     5b2:	d1 07       	cpc	r29, r17
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	08 07       	cpc	r16, r24
     5b8:	a9 f7       	brne	.-22     	; 0x5a4 <__do_global_ctors+0xa>
     5ba:	0e 94 66 1d 	call	0x3acc	; 0x3acc <main>
     5be:	0c 94 e2 20 	jmp	0x41c4	; 0x41c4 <_exit>

000005c2 <__bad_interrupt>:
     5c2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c6 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	00 d0       	rcall	.+0      	; 0x5cc <_ZN12EncoderMotor3runEv+0x6>
     5cc:	1f 92       	push	r1
     5ce:	cd b7       	in	r28, 0x3d	; 61
     5d0:	de b7       	in	r29, 0x3e	; 62
     5d2:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d4:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCount>
     5d8:	69 83       	std	Y+1, r22	; 0x01
     5da:	7a 83       	std	Y+2, r23	; 0x02
     5dc:	8b 83       	std	Y+3, r24	; 0x03
     5de:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN4_bm | PIN5_bm;										// Set both CHa and CHb for input
     5e0:	e0 e8       	ldi	r30, 0x80	; 128
     5e2:	f6 e0       	ldi	r31, 0x06	; 6
     5e4:	80 e3       	ldi	r24, 0x30	; 48
     5e6:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN4CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e8:	84 89       	ldd	r24, Z+20	; 0x14
     5ea:	83 60       	ori	r24, 0x03	; 3
     5ec:	84 8b       	std	Z+20, r24	; 0x14
	PORTE.PIN5CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ee:	85 89       	ldd	r24, Z+21	; 0x15
     5f0:	83 60       	ori	r24, 0x03	; 3
     5f2:	85 8b       	std	Z+21, r24	; 0x15
	
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTE_PIN4_gc;								// Configure CHa as a multiplexer input for event channel 1
     5f4:	e0 e8       	ldi	r30, 0x80	; 128
     5f6:	f1 e0       	ldi	r31, 0x01	; 1
     5f8:	84 e7       	ldi	r24, 0x74	; 116
     5fa:	81 83       	std	Z+1, r24	; 0x01
	EVSYS.CH1CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5fc:	89 e0       	ldi	r24, 0x09	; 9
     5fe:	81 87       	std	Z+9, r24	; 0x09
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH1_gc;						// Set the quadrature decoding as the event action for the timer
     600:	e0 e4       	ldi	r30, 0x40	; 64
     602:	f8 e0       	ldi	r31, 0x08	; 8
     604:	89 e6       	ldi	r24, 0x69	; 105
     606:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     608:	8f ef       	ldi	r24, 0xFF	; 255
     60a:	9f ef       	ldi	r25, 0xFF	; 255
     60c:	86 a3       	std	Z+38, r24	; 0x26
     60e:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     610:	81 e0       	ldi	r24, 0x01	; 1
     612:	80 83       	st	Z, r24
	int16_t angularVelocity;
	float x_calc;
	int16_t x;

	while(1){
		encoder_count = TCC1.CNT;											// get count
     614:	68 94       	set
     616:	88 24       	eor	r8, r8
     618:	86 f8       	bld	r8, 6
     61a:	99 24       	eor	r9, r9
     61c:	93 f8       	bld	r9, 3
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     61e:	0f 2e       	mov	r0, r31
     620:	f4 e6       	ldi	r31, 0x64	; 100
     622:	6f 2e       	mov	r6, r31
     624:	71 2c       	mov	r7, r1
     626:	f0 2d       	mov	r31, r0
     628:	0f 2e       	mov	r0, r31
     62a:	fc e3       	ldi	r31, 0x3C	; 60
     62c:	5f 2e       	mov	r5, r31
     62e:	f0 2d       	mov	r31, r0
     630:	f4 01       	movw	r30, r8
     632:	00 a1       	ldd	r16, Z+32	; 0x20
     634:	11 a1       	ldd	r17, Z+33	; 0x21
		*p_serial << "Encoder Pulses: " << encoder_count << endl;
     636:	f7 01       	movw	r30, r14
     638:	c6 80       	ldd	r12, Z+6	; 0x06
     63a:	d7 80       	ldd	r13, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     63c:	66 e0       	ldi	r22, 0x06	; 6
     63e:	70 e2       	ldi	r23, 0x20	; 32
     640:	c6 01       	movw	r24, r12
     642:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     646:	b8 01       	movw	r22, r16
     648:	c6 01       	movw	r24, r12
     64a:	0e 94 98 18 	call	0x3130	; 0x3130 <_ZN8emstreamlsEi>
     64e:	66 e0       	ldi	r22, 0x06	; 6
     650:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     654:	0f b6       	in	r0, 0x3f	; 63
     656:	f8 94       	cli
     658:	0f 92       	push	r0
			the_data = new_data;
     65a:	b8 01       	movw	r22, r16
     65c:	01 2e       	mov	r0, r17
     65e:	00 0c       	add	r0, r0
     660:	88 0b       	sbc	r24, r24
     662:	99 0b       	sbc	r25, r25
     664:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <__floatsisf>
     668:	20 e0       	ldi	r18, 0x00	; 0
     66a:	30 e0       	ldi	r19, 0x00	; 0
     66c:	4a e7       	ldi	r20, 0x7A	; 122
     66e:	55 e4       	ldi	r21, 0x45	; 69
     670:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <__divsf3>
     674:	20 e0       	ldi	r18, 0x00	; 0
     676:	30 e0       	ldi	r19, 0x00	; 0
     678:	44 eb       	ldi	r20, 0xB4	; 180
     67a:	53 e4       	ldi	r21, 0x43	; 67
     67c:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <__mulsf3>
     680:	0e 94 89 1e 	call	0x3d12	; 0x3d12 <__fixsfsi>
     684:	60 93 8c 31 	sts	0x318C, r22	; 0x80318c <thMotor>
     688:	70 93 8d 31 	sts	0x318D, r23	; 0x80318d <thMotor+0x1>
			portEXIT_CRITICAL ();
     68c:	0f 90       	pop	r0
     68e:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     690:	0f b6       	in	r0, 0x3f	; 63
     692:	f8 94       	cli
     694:	0f 92       	push	r0
			the_data = new_data;
     696:	c8 01       	movw	r24, r16
     698:	88 0f       	add	r24, r24
     69a:	99 1f       	adc	r25, r25
     69c:	80 0f       	add	r24, r16
     69e:	91 1f       	adc	r25, r17
     6a0:	b3 01       	movw	r22, r6
     6a2:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <__divmodhi4>
     6a6:	60 93 8e 31 	sts	0x318E, r22	; 0x80318e <linear_position>
     6aa:	70 93 8f 31 	sts	0x318F, r23	; 0x80318f <linear_position+0x1>
			portEXIT_CRITICAL ();
     6ae:	0f 90       	pop	r0
     6b0:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     6b2:	0f b6       	in	r0, 0x3f	; 63
     6b4:	f8 94       	cli
     6b6:	0f 92       	push	r0
			the_data = new_data;
     6b8:	c8 01       	movw	r24, r16
     6ba:	8a 19       	sub	r24, r10
     6bc:	9b 09       	sbc	r25, r11
     6be:	58 9e       	mul	r5, r24
     6c0:	b0 01       	movw	r22, r0
     6c2:	59 9e       	mul	r5, r25
     6c4:	70 0d       	add	r23, r0
     6c6:	11 24       	eor	r1, r1
     6c8:	07 2e       	mov	r0, r23
     6ca:	00 0c       	add	r0, r0
     6cc:	88 0b       	sbc	r24, r24
     6ce:	99 0b       	sbc	r25, r25
     6d0:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <__floatsisf>
     6d4:	20 e0       	ldi	r18, 0x00	; 0
     6d6:	30 e0       	ldi	r19, 0x00	; 0
     6d8:	4a e7       	ldi	r20, 0x7A	; 122
     6da:	55 e4       	ldi	r21, 0x45	; 69
     6dc:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <__divsf3>
     6e0:	2f e6       	ldi	r18, 0x6F	; 111
     6e2:	32 e1       	ldi	r19, 0x12	; 18
     6e4:	43 e8       	ldi	r20, 0x83	; 131
     6e6:	5a e3       	ldi	r21, 0x3A	; 58
     6e8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <__divsf3>
     6ec:	0e 94 89 1e 	call	0x3d12	; 0x3d12 <__fixsfsi>
     6f0:	60 93 8a 31 	sts	0x318A, r22	; 0x80318a <thdMotor>
     6f4:	70 93 8b 31 	sts	0x318B, r23	; 0x80318b <thdMotor+0x1>
			portEXIT_CRITICAL ();
     6f8:	0f 90       	pop	r0
     6fa:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     6fc:	f7 01       	movw	r30, r14
     6fe:	86 85       	ldd	r24, Z+14	; 0x0e
     700:	97 85       	ldd	r25, Z+15	; 0x0f
     702:	a0 89       	ldd	r26, Z+16	; 0x10
     704:	b1 89       	ldd	r27, Z+17	; 0x11
     706:	01 96       	adiw	r24, 0x01	; 1
     708:	a1 1d       	adc	r26, r1
     70a:	b1 1d       	adc	r27, r1
     70c:	86 87       	std	Z+14, r24	; 0x0e
     70e:	97 87       	std	Z+15, r25	; 0x0f
     710:	a0 8b       	std	Z+16, r26	; 0x10
     712:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     714:	41 e0       	ldi	r20, 0x01	; 1
     716:	50 e0       	ldi	r21, 0x00	; 0
     718:	60 e0       	ldi	r22, 0x00	; 0
     71a:	70 e0       	ldi	r23, 0x00	; 0
     71c:	ce 01       	movw	r24, r28
     71e:	01 96       	adiw	r24, 0x01	; 1
     720:	0e 94 1d 10 	call	0x203a	; 0x203a <vTaskDelayUntil>
		angularVelocityCalc = ((int16_t) (encoder_count-last_encoder_count))*60/(4.00000*1000.00000)/dt;	// convert to velocity [RPM]
		angularVelocity = angularVelocityCalc;
		//*p_serial << "Angular Velocity: " << AngularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     724:	58 01       	movw	r10, r16
     726:	84 cf       	rjmp	.-248    	; 0x630 <_ZN12EncoderMotor3runEv+0x6a>

00000728 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     728:	0f 93       	push	r16
     72a:	1f 93       	push	r17
     72c:	cf 93       	push	r28
     72e:	df 93       	push	r29
     730:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     732:	0e 94 ba 12 	call	0x2574	; 0x2574 <_ZN8frt_taskC1EPKchjP8emstream>
     736:	8b e1       	ldi	r24, 0x1B	; 27
     738:	90 e2       	ldi	r25, 0x20	; 32
     73a:	88 83       	st	Y, r24
     73c:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     73e:	df 91       	pop	r29
     740:	cf 91       	pop	r28
     742:	1f 91       	pop	r17
     744:	0f 91       	pop	r16
     746:	08 95       	ret

00000748 <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     748:	cf 93       	push	r28
     74a:	df 93       	push	r29
     74c:	00 d0       	rcall	.+0      	; 0x74e <_ZN15EncoderPendulum3runEv+0x6>
     74e:	1f 92       	push	r1
     750:	cd b7       	in	r28, 0x3d	; 61
     752:	de b7       	in	r29, 0x3e	; 62
     754:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     756:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCount>
     75a:	69 83       	std	Y+1, r22	; 0x01
     75c:	7a 83       	std	Y+2, r23	; 0x02
     75e:	8b 83       	std	Y+3, r24	; 0x03
     760:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTC.DIRCLR = (PIN4_bm | PIN5_bm);							// set C4 & C5 as inputs
     762:	e0 e4       	ldi	r30, 0x40	; 64
     764:	f6 e0       	ldi	r31, 0x06	; 6
     766:	80 e3       	ldi	r24, 0x30	; 48
     768:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN4CTRL = PORT_ISC_LEVEL_gc;							// set C4 for level sensing
     76a:	83 e0       	ldi	r24, 0x03	; 3
     76c:	84 8b       	std	Z+20, r24	; 0x14
	PORTC.PIN5CTRL = PORT_ISC_LEVEL_gc;							// set C5 for level sensing
     76e:	85 8b       	std	Z+21, r24	; 0x15
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTC_PIN4_gc;					// set PC4 as Multiplexer for Event Chan 0
     770:	e0 e8       	ldi	r30, 0x80	; 128
     772:	f1 e0       	ldi	r31, 0x01	; 1
     774:	84 e6       	ldi	r24, 0x64	; 100
     776:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     778:	89 e0       	ldi	r24, 0x09	; 9
     77a:	80 87       	std	Z+8, r24	; 0x08
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH1_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     77c:	e0 e4       	ldi	r30, 0x40	; 64
     77e:	f8 e0       	ldi	r31, 0x08	; 8
     780:	89 e6       	ldi	r24, 0x69	; 105
     782:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0xFFFF;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     784:	8f ef       	ldi	r24, 0xFF	; 255
     786:	9f ef       	ldi	r25, 0xFF	; 255
     788:	86 a3       	std	Z+38, r24	; 0x26
     78a:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	80 83       	st	Z, r24
	
	uint16_t count;												// contains the current encoder value
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT;
     790:	68 94       	set
     792:	ee 24       	eor	r14, r14
     794:	e6 f8       	bld	r14, 6
     796:	ff 24       	eor	r15, r15
     798:	f3 f8       	bld	r15, 3
     79a:	f7 01       	movw	r30, r14
     79c:	80 a1       	ldd	r24, Z+32	; 0x20
     79e:	91 a1       	ldd	r25, Z+33	; 0x21
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     7a0:	f8 01       	movw	r30, r16
     7a2:	86 85       	ldd	r24, Z+14	; 0x0e
     7a4:	97 85       	ldd	r25, Z+15	; 0x0f
     7a6:	a0 89       	ldd	r26, Z+16	; 0x10
     7a8:	b1 89       	ldd	r27, Z+17	; 0x11
     7aa:	01 96       	adiw	r24, 0x01	; 1
     7ac:	a1 1d       	adc	r26, r1
     7ae:	b1 1d       	adc	r27, r1
     7b0:	86 87       	std	Z+14, r24	; 0x0e
     7b2:	97 87       	std	Z+15, r25	; 0x0f
     7b4:	a0 8b       	std	Z+16, r26	; 0x10
     7b6:	b1 8b       	std	Z+17, r27	; 0x11
     7b8:	41 e0       	ldi	r20, 0x01	; 1
     7ba:	50 e0       	ldi	r21, 0x00	; 0
     7bc:	60 e0       	ldi	r22, 0x00	; 0
     7be:	70 e0       	ldi	r23, 0x00	; 0
     7c0:	ce 01       	movw	r24, r28
     7c2:	01 96       	adiw	r24, 0x01	; 1
     7c4:	0e 94 1d 10 	call	0x203a	; 0x203a <vTaskDelayUntil>
     7c8:	e8 cf       	rjmp	.-48     	; 0x79a <_ZN15EncoderPendulum3runEv+0x52>

000007ca <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     7ca:	0f 93       	push	r16
     7cc:	1f 93       	push	r17
     7ce:	cf 93       	push	r28
     7d0:	df 93       	push	r29
     7d2:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7d4:	0e 94 ba 12 	call	0x2574	; 0x2574 <_ZN8frt_taskC1EPKchjP8emstream>
     7d8:	83 e2       	ldi	r24, 0x23	; 35
     7da:	90 e2       	ldi	r25, 0x20	; 32
     7dc:	88 83       	st	Y, r24
     7de:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     7e0:	df 91       	pop	r29
     7e2:	cf 91       	pop	r28
     7e4:	1f 91       	pop	r17
     7e6:	0f 91       	pop	r16
     7e8:	08 95       	ret

000007ea <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     7ea:	cf 93       	push	r28
     7ec:	df 93       	push	r29
     7ee:	00 d0       	rcall	.+0      	; 0x7f0 <_ZN13LimitSwitches3runEv+0x6>
     7f0:	1f 92       	push	r1
     7f2:	cd b7       	in	r28, 0x3d	; 61
     7f4:	de b7       	in	r29, 0x3e	; 62
     7f6:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7f8:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCount>
     7fc:	69 83       	std	Y+1, r22	; 0x01
     7fe:	7a 83       	std	Y+2, r23	; 0x02
     800:	8b 83       	std	Y+3, r24	; 0x03
     802:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PK0 & PK2) and LED output
	PORTK.DIRCLR = PIN0_bm;									// set K0 as input
     804:	e0 e2       	ldi	r30, 0x20	; 32
     806:	f7 e0       	ldi	r31, 0x07	; 7
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	82 83       	std	Z+2, r24	; 0x02
	PORTK.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set K0 as pullup
     80c:	88 e1       	ldi	r24, 0x18	; 24
     80e:	80 8b       	std	Z+16, r24	; 0x10
	PORTK.DIRCLR = PIN2_bm;									// set K2 as input
     810:	94 e0       	ldi	r25, 0x04	; 4
     812:	92 83       	std	Z+2, r25	; 0x02
	PORTK.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set K2 as pullup
     814:	82 8b       	std	Z+18, r24	; 0x12
	bool rightLimit;
	bool leftLimit;

	while(1){
		
		if(!(PORTK_IN & PIN0_bm))							// check whether limit is pressed (pin K0 is high)
     816:	0f 2e       	mov	r0, r31
     818:	f8 e2       	ldi	r31, 0x28	; 40
     81a:	ef 2e       	mov	r14, r31
     81c:	f7 e0       	ldi	r31, 0x07	; 7
     81e:	ff 2e       	mov	r15, r31
     820:	f0 2d       	mov	r31, r0
     822:	f7 01       	movw	r30, r14
     824:	80 81       	ld	r24, Z
     826:	80 fd       	sbrc	r24, 0
     828:	10 c0       	rjmp	.+32     	; 0x84a <_ZN13LimitSwitches3runEv+0x60>
		{	
			rightLimit = 1;
			*p_serial << "rightLimit: " << rightLimit << endl;
     82a:	f8 01       	movw	r30, r16
     82c:	c6 80       	ldd	r12, Z+6	; 0x06
     82e:	d7 80       	ldd	r13, Z+7	; 0x07
     830:	67 e2       	ldi	r22, 0x27	; 39
     832:	70 e2       	ldi	r23, 0x20	; 32
     834:	c6 01       	movw	r24, r12
     836:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     83a:	61 e0       	ldi	r22, 0x01	; 1
     83c:	c6 01       	movw	r24, r12
     83e:	0e 94 80 18 	call	0x3100	; 0x3100 <_ZN8emstreamlsEb>
     842:	66 e0       	ldi	r22, 0x06	; 6
     844:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     848:	13 c0       	rjmp	.+38     	; 0x870 <_ZN13LimitSwitches3runEv+0x86>
			
		}
		else if (!(PORTK_IN & PIN2_bm))						// check whether limit is pressed (pin K2 is high)
     84a:	f7 01       	movw	r30, r14
     84c:	80 81       	ld	r24, Z
     84e:	82 fd       	sbrc	r24, 2
     850:	0f c0       	rjmp	.+30     	; 0x870 <_ZN13LimitSwitches3runEv+0x86>
		{
			leftLimit = 1;
			*p_serial << "leftLimit: " << leftLimit << endl;
     852:	f8 01       	movw	r30, r16
     854:	c6 80       	ldd	r12, Z+6	; 0x06
     856:	d7 80       	ldd	r13, Z+7	; 0x07
     858:	64 e3       	ldi	r22, 0x34	; 52
     85a:	70 e2       	ldi	r23, 0x20	; 32
     85c:	c6 01       	movw	r24, r12
     85e:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     862:	61 e0       	ldi	r22, 0x01	; 1
     864:	c6 01       	movw	r24, r12
     866:	0e 94 80 18 	call	0x3100	; 0x3100 <_ZN8emstreamlsEb>
     86a:	66 e0       	ldi	r22, 0x06	; 6
     86c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
			leftLimit = 0;
			//*p_serial << "limits: " << rightLimit << leftLimit << endl;
		}
		
		// Increment counter for debugging
		runs++;
     870:	f8 01       	movw	r30, r16
     872:	86 85       	ldd	r24, Z+14	; 0x0e
     874:	97 85       	ldd	r25, Z+15	; 0x0f
     876:	a0 89       	ldd	r26, Z+16	; 0x10
     878:	b1 89       	ldd	r27, Z+17	; 0x11
     87a:	01 96       	adiw	r24, 0x01	; 1
     87c:	a1 1d       	adc	r26, r1
     87e:	b1 1d       	adc	r27, r1
     880:	86 87       	std	Z+14, r24	; 0x0e
     882:	97 87       	std	Z+15, r25	; 0x0f
     884:	a0 8b       	std	Z+16, r26	; 0x10
     886:	b1 8b       	std	Z+17, r27	; 0x11
     888:	41 e0       	ldi	r20, 0x01	; 1
     88a:	50 e0       	ldi	r21, 0x00	; 0
     88c:	60 e0       	ldi	r22, 0x00	; 0
     88e:	70 e0       	ldi	r23, 0x00	; 0
     890:	ce 01       	movw	r24, r28
     892:	01 96       	adiw	r24, 0x01	; 1
     894:	0e 94 1d 10 	call	0x203a	; 0x203a <vTaskDelayUntil>
     898:	c4 cf       	rjmp	.-120    	; 0x822 <_ZN13LimitSwitches3runEv+0x38>

0000089a <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     89a:	0f 93       	push	r16
     89c:	1f 93       	push	r17
     89e:	cf 93       	push	r28
     8a0:	df 93       	push	r29
     8a2:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a4:	0e 94 ba 12 	call	0x2574	; 0x2574 <_ZN8frt_taskC1EPKchjP8emstream>
     8a8:	84 e4       	ldi	r24, 0x44	; 68
     8aa:	90 e2       	ldi	r25, 0x20	; 32
     8ac:	88 83       	st	Y, r24
     8ae:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     8b0:	df 91       	pop	r29
     8b2:	cf 91       	pop	r28
     8b4:	1f 91       	pop	r17
     8b6:	0f 91       	pop	r16
     8b8:	08 95       	ret

000008ba <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     8ba:	cf 93       	push	r28
     8bc:	df 93       	push	r29
     8be:	00 d0       	rcall	.+0      	; 0x8c0 <_ZN5Motor3runEv+0x6>
     8c0:	1f 92       	push	r1
     8c2:	cd b7       	in	r28, 0x3d	; 61
     8c4:	de b7       	in	r29, 0x3e	; 62
     8c6:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c8:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCount>
     8cc:	69 83       	std	Y+1, r22	; 0x01
     8ce:	7a 83       	std	Y+2, r23	; 0x02
     8d0:	8b 83       	std	Y+3, r24	; 0x03
     8d2:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     8d4:	f8 01       	movw	r30, r16
     8d6:	86 85       	ldd	r24, Z+14	; 0x0e
     8d8:	97 85       	ldd	r25, Z+15	; 0x0f
     8da:	a0 89       	ldd	r26, Z+16	; 0x10
     8dc:	b1 89       	ldd	r27, Z+17	; 0x11
     8de:	01 96       	adiw	r24, 0x01	; 1
     8e0:	a1 1d       	adc	r26, r1
     8e2:	b1 1d       	adc	r27, r1
     8e4:	86 87       	std	Z+14, r24	; 0x0e
     8e6:	97 87       	std	Z+15, r25	; 0x0f
     8e8:	a0 8b       	std	Z+16, r26	; 0x10
     8ea:	b1 8b       	std	Z+17, r27	; 0x11
     8ec:	41 e0       	ldi	r20, 0x01	; 1
     8ee:	50 e0       	ldi	r21, 0x00	; 0
     8f0:	60 e0       	ldi	r22, 0x00	; 0
     8f2:	70 e0       	ldi	r23, 0x00	; 0
     8f4:	ce 01       	movw	r24, r28
     8f6:	01 96       	adiw	r24, 0x01	; 1
     8f8:	0e 94 1d 10 	call	0x203a	; 0x203a <vTaskDelayUntil>
     8fc:	eb cf       	rjmp	.-42     	; 0x8d4 <_ZN5Motor3runEv+0x1a>

000008fe <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     8fe:	0f 93       	push	r16
     900:	1f 93       	push	r17
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
     906:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     908:	0e 94 ba 12 	call	0x2574	; 0x2574 <_ZN8frt_taskC1EPKchjP8emstream>
     90c:	8c e4       	ldi	r24, 0x4C	; 76
     90e:	90 e2       	ldi	r25, 0x20	; 32
     910:	88 83       	st	Y, r24
     912:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     914:	df 91       	pop	r29
     916:	cf 91       	pop	r28
     918:	1f 91       	pop	r17
     91a:	0f 91       	pop	r16
     91c:	08 95       	ret

0000091e <_ZN3pid3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void pid::run(void){
     91e:	cf 93       	push	r28
     920:	df 93       	push	r29
     922:	00 d0       	rcall	.+0      	; 0x924 <_ZN3pid3runEv+0x6>
     924:	1f 92       	push	r1
     926:	cd b7       	in	r28, 0x3d	; 61
     928:	de b7       	in	r29, 0x3e	; 62
     92a:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     92c:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCount>
     930:	69 83       	std	Y+1, r22	; 0x01
     932:	7a 83       	std	Y+2, r23	; 0x02
     934:	8b 83       	std	Y+3, r24	; 0x03
     936:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     938:	f8 01       	movw	r30, r16
     93a:	86 85       	ldd	r24, Z+14	; 0x0e
     93c:	97 85       	ldd	r25, Z+15	; 0x0f
     93e:	a0 89       	ldd	r26, Z+16	; 0x10
     940:	b1 89       	ldd	r27, Z+17	; 0x11
     942:	01 96       	adiw	r24, 0x01	; 1
     944:	a1 1d       	adc	r26, r1
     946:	b1 1d       	adc	r27, r1
     948:	86 87       	std	Z+14, r24	; 0x0e
     94a:	97 87       	std	Z+15, r25	; 0x0f
     94c:	a0 8b       	std	Z+16, r26	; 0x10
     94e:	b1 8b       	std	Z+17, r27	; 0x11
     950:	41 e0       	ldi	r20, 0x01	; 1
     952:	50 e0       	ldi	r21, 0x00	; 0
     954:	60 e0       	ldi	r22, 0x00	; 0
     956:	70 e0       	ldi	r23, 0x00	; 0
     958:	ce 01       	movw	r24, r28
     95a:	01 96       	adiw	r24, 0x01	; 1
     95c:	0e 94 1d 10 	call	0x203a	; 0x203a <vTaskDelayUntil>
     960:	eb cf       	rjmp	.-42     	; 0x938 <_ZN3pid3runEv+0x1a>

00000962 <_ZN3pidC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


pid::pid (const char* a_name,
     962:	0f 93       	push	r16
     964:	1f 93       	push	r17
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
     96a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     96c:	0e 94 ba 12 	call	0x2574	; 0x2574 <_ZN8frt_taskC1EPKchjP8emstream>
     970:	84 e5       	ldi	r24, 0x54	; 84
     972:	90 e2       	ldi	r25, 0x20	; 32
     974:	88 83       	st	Y, r24
     976:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	1f 91       	pop	r17
     97e:	0f 91       	pop	r16
     980:	08 95       	ret

00000982 <_ZN9PWMdriver3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void PWMdriver::run(void){
     982:	cf 93       	push	r28
     984:	df 93       	push	r29
     986:	00 d0       	rcall	.+0      	; 0x988 <_ZN9PWMdriver3runEv+0x6>
     988:	1f 92       	push	r1
     98a:	cd b7       	in	r28, 0x3d	; 61
     98c:	de b7       	in	r29, 0x3e	; 62
     98e:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     990:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCount>
     994:	69 83       	std	Y+1, r22	; 0x01
     996:	7a 83       	std	Y+2, r23	; 0x02
     998:	8b 83       	std	Y+3, r24	; 0x03
     99a:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     99c:	f8 01       	movw	r30, r16
     99e:	86 85       	ldd	r24, Z+14	; 0x0e
     9a0:	97 85       	ldd	r25, Z+15	; 0x0f
     9a2:	a0 89       	ldd	r26, Z+16	; 0x10
     9a4:	b1 89       	ldd	r27, Z+17	; 0x11
     9a6:	01 96       	adiw	r24, 0x01	; 1
     9a8:	a1 1d       	adc	r26, r1
     9aa:	b1 1d       	adc	r27, r1
     9ac:	86 87       	std	Z+14, r24	; 0x0e
     9ae:	97 87       	std	Z+15, r25	; 0x0f
     9b0:	a0 8b       	std	Z+16, r26	; 0x10
     9b2:	b1 8b       	std	Z+17, r27	; 0x11
     9b4:	41 e0       	ldi	r20, 0x01	; 1
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	ce 01       	movw	r24, r28
     9be:	01 96       	adiw	r24, 0x01	; 1
     9c0:	0e 94 1d 10 	call	0x203a	; 0x203a <vTaskDelayUntil>
     9c4:	eb cf       	rjmp	.-42     	; 0x99c <_ZN9PWMdriver3runEv+0x1a>

000009c6 <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


PWMdriver::PWMdriver(const char* a_name,
     9c6:	0f 93       	push	r16
     9c8:	1f 93       	push	r17
     9ca:	cf 93       	push	r28
     9cc:	df 93       	push	r29
     9ce:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     9d0:	0e 94 ba 12 	call	0x2574	; 0x2574 <_ZN8frt_taskC1EPKchjP8emstream>
     9d4:	8c e5       	ldi	r24, 0x5C	; 92
     9d6:	90 e2       	ldi	r25, 0x20	; 32
     9d8:	88 83       	st	Y, r24
     9da:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     9dc:	df 91       	pop	r29
     9de:	cf 91       	pop	r28
     9e0:	1f 91       	pop	r17
     9e2:	0f 91       	pop	r16
     9e4:	08 95       	ret

000009e6 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     9e6:	0f 93       	push	r16
     9e8:	1f 93       	push	r17
     9ea:	cf 93       	push	r28
     9ec:	df 93       	push	r29
     9ee:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     9f0:	0e 94 ba 12 	call	0x2574	; 0x2574 <_ZN8frt_taskC1EPKchjP8emstream>
     9f4:	84 e6       	ldi	r24, 0x64	; 100
     9f6:	90 e2       	ldi	r25, 0x20	; 32
     9f8:	88 83       	st	Y, r24
     9fa:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     9fc:	df 91       	pop	r29
     9fe:	cf 91       	pop	r28
     a00:	1f 91       	pop	r17
     a02:	0f 91       	pop	r16
     a04:	08 95       	ret

00000a06 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     a06:	0f 93       	push	r16
     a08:	1f 93       	push	r17
     a0a:	cf 93       	push	r28
     a0c:	df 93       	push	r29
     a0e:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     a10:	6a e0       	ldi	r22, 0x0A	; 10
     a12:	8e 81       	ldd	r24, Y+6	; 0x06
     a14:	9f 81       	ldd	r25, Y+7	; 0x07
     a16:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     a1a:	8c 01       	movw	r16, r24
     a1c:	61 ef       	ldi	r22, 0xF1	; 241
     a1e:	73 e0       	ldi	r23, 0x03	; 3
     a20:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     a24:	6a e0       	ldi	r22, 0x0A	; 10
     a26:	c8 01       	movw	r24, r16
     a28:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     a2c:	8c 01       	movw	r16, r24
     a2e:	6b ee       	ldi	r22, 0xEB	; 235
     a30:	73 e0       	ldi	r23, 0x03	; 3
     a32:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     a36:	67 e0       	ldi	r22, 0x07	; 7
     a38:	c8 01       	movw	r24, r16
     a3a:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     a3e:	6a e0       	ldi	r22, 0x0A	; 10
     a40:	8e 81       	ldd	r24, Y+6	; 0x06
     a42:	9f 81       	ldd	r25, Y+7	; 0x07
     a44:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     a48:	8c 01       	movw	r16, r24
     a4a:	6c ec       	ldi	r22, 0xCC	; 204
     a4c:	73 e0       	ldi	r23, 0x03	; 3
     a4e:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     a52:	6a e0       	ldi	r22, 0x0A	; 10
     a54:	c8 01       	movw	r24, r16
     a56:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     a5a:	8c 01       	movw	r16, r24
     a5c:	66 ec       	ldi	r22, 0xC6	; 198
     a5e:	73 e0       	ldi	r23, 0x03	; 3
     a60:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     a64:	66 e0       	ldi	r22, 0x06	; 6
     a66:	c8 01       	movw	r24, r16
     a68:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     a6c:	6a e0       	ldi	r22, 0x0A	; 10
     a6e:	8e 81       	ldd	r24, Y+6	; 0x06
     a70:	9f 81       	ldd	r25, Y+7	; 0x07
     a72:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     a76:	8c 01       	movw	r16, r24
     a78:	6f ea       	ldi	r22, 0xAF	; 175
     a7a:	73 e0       	ldi	r23, 0x03	; 3
     a7c:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     a80:	66 e0       	ldi	r22, 0x06	; 6
     a82:	c8 01       	movw	r24, r16
     a84:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     a88:	6a e0       	ldi	r22, 0x0A	; 10
     a8a:	8e 81       	ldd	r24, Y+6	; 0x06
     a8c:	9f 81       	ldd	r25, Y+7	; 0x07
     a8e:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     a92:	8c 01       	movw	r16, r24
     a94:	63 e9       	ldi	r22, 0x93	; 147
     a96:	73 e0       	ldi	r23, 0x03	; 3
     a98:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     a9c:	66 e0       	ldi	r22, 0x06	; 6
     a9e:	c8 01       	movw	r24, r16
     aa0:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     aa4:	6a e0       	ldi	r22, 0x0A	; 10
     aa6:	8e 81       	ldd	r24, Y+6	; 0x06
     aa8:	9f 81       	ldd	r25, Y+7	; 0x07
     aaa:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     aae:	8c 01       	movw	r16, r24
     ab0:	6b e7       	ldi	r22, 0x7B	; 123
     ab2:	73 e0       	ldi	r23, 0x03	; 3
     ab4:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     ab8:	66 e0       	ldi	r22, 0x06	; 6
     aba:	c8 01       	movw	r24, r16
     abc:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     ac0:	6a e0       	ldi	r22, 0x0A	; 10
     ac2:	8e 81       	ldd	r24, Y+6	; 0x06
     ac4:	9f 81       	ldd	r25, Y+7	; 0x07
     ac6:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     aca:	8c 01       	movw	r16, r24
     acc:	6a e5       	ldi	r22, 0x5A	; 90
     ace:	73 e0       	ldi	r23, 0x03	; 3
     ad0:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     ad4:	66 e0       	ldi	r22, 0x06	; 6
     ad6:	c8 01       	movw	r24, r16
     ad8:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     adc:	6a e0       	ldi	r22, 0x0A	; 10
     ade:	8e 81       	ldd	r24, Y+6	; 0x06
     ae0:	9f 81       	ldd	r25, Y+7	; 0x07
     ae2:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     ae6:	8c 01       	movw	r16, r24
     ae8:	63 e3       	ldi	r22, 0x33	; 51
     aea:	73 e0       	ldi	r23, 0x03	; 3
     aec:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     af0:	66 e0       	ldi	r22, 0x06	; 6
     af2:	c8 01       	movw	r24, r16
     af4:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     af8:	6a e0       	ldi	r22, 0x0A	; 10
     afa:	8e 81       	ldd	r24, Y+6	; 0x06
     afc:	9f 81       	ldd	r25, Y+7	; 0x07
     afe:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     b02:	8c 01       	movw	r16, r24
     b04:	65 e1       	ldi	r22, 0x15	; 21
     b06:	73 e0       	ldi	r23, 0x03	; 3
     b08:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     b0c:	66 e0       	ldi	r22, 0x06	; 6
     b0e:	c8 01       	movw	r24, r16
     b10:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     b14:	6a e0       	ldi	r22, 0x0A	; 10
     b16:	8e 81       	ldd	r24, Y+6	; 0x06
     b18:	9f 81       	ldd	r25, Y+7	; 0x07
     b1a:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     b1e:	8c 01       	movw	r16, r24
     b20:	6a ef       	ldi	r22, 0xFA	; 250
     b22:	72 e0       	ldi	r23, 0x02	; 2
     b24:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     b28:	66 e0       	ldi	r22, 0x06	; 6
     b2a:	c8 01       	movw	r24, r16
     b2c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     b30:	6a e0       	ldi	r22, 0x0A	; 10
     b32:	8e 81       	ldd	r24, Y+6	; 0x06
     b34:	9f 81       	ldd	r25, Y+7	; 0x07
     b36:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     b3a:	ec 01       	movw	r28, r24
     b3c:	6b ee       	ldi	r22, 0xEB	; 235
     b3e:	72 e0       	ldi	r23, 0x02	; 2
     b40:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     b44:	66 e0       	ldi	r22, 0x06	; 6
     b46:	ce 01       	movw	r24, r28
     b48:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
}
     b4c:	df 91       	pop	r29
     b4e:	cf 91       	pop	r28
     b50:	1f 91       	pop	r17
     b52:	0f 91       	pop	r16
     b54:	08 95       	ret

00000b56 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     b56:	af 92       	push	r10
     b58:	bf 92       	push	r11
     b5a:	cf 92       	push	r12
     b5c:	df 92       	push	r13
     b5e:	ef 92       	push	r14
     b60:	ff 92       	push	r15
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	00 d0       	rcall	.+0      	; 0xb6c <_ZN9task_user11show_statusEv+0x16>
     b6c:	00 d0       	rcall	.+0      	; 0xb6e <_ZN9task_user11show_statusEv+0x18>
     b6e:	cd b7       	in	r28, 0x3d	; 61
     b70:	de b7       	in	r29, 0x3e	; 62
     b72:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     b74:	19 82       	std	Y+1, r1	; 0x01
     b76:	1a 82       	std	Y+2, r1	; 0x02
     b78:	1b 82       	std	Y+3, r1	; 0x03
     b7a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     b7c:	1d 82       	std	Y+5, r1	; 0x05
     b7e:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     b80:	0e 94 30 08 	call	0x1060	; 0x1060 <xPortGetFreeHeapSize>
     b84:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     b86:	ce 01       	movw	r24, r28
     b88:	01 96       	adiw	r24, 0x01	; 1
     b8a:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <_ZN10time_stamp10set_to_nowEv>
     b8e:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     b90:	66 e0       	ldi	r22, 0x06	; 6
     b92:	f8 01       	movw	r30, r16
     b94:	86 81       	ldd	r24, Z+6	; 0x06
     b96:	97 81       	ldd	r25, Z+7	; 0x07
     b98:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     b9c:	6a e0       	ldi	r22, 0x0A	; 10
     b9e:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     ba2:	7c 01       	movw	r14, r24
     ba4:	6c ec       	ldi	r22, 0xCC	; 204
     ba6:	72 e0       	ldi	r23, 0x02	; 2
     ba8:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     bac:	6a e0       	ldi	r22, 0x0A	; 10
     bae:	c7 01       	movw	r24, r14
     bb0:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     bb4:	7c 01       	movw	r14, r24
     bb6:	60 ec       	ldi	r22, 0xC0	; 192
     bb8:	72 e0       	ldi	r23, 0x02	; 2
     bba:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     bbe:	66 e0       	ldi	r22, 0x06	; 6
     bc0:	c7 01       	movw	r24, r14
     bc2:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     bc6:	6a e0       	ldi	r22, 0x0A	; 10
     bc8:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     bcc:	7c 01       	movw	r14, r24
     bce:	69 eb       	ldi	r22, 0xB9	; 185
     bd0:	72 e0       	ldi	r23, 0x02	; 2
     bd2:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     bd6:	b5 01       	movw	r22, r10
     bd8:	c7 01       	movw	r24, r14
     bda:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     bde:	6a e0       	ldi	r22, 0x0A	; 10
     be0:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     be4:	7c 01       	movw	r14, r24
     be6:	6b ea       	ldi	r22, 0xAB	; 171
     be8:	72 e0       	ldi	r23, 0x02	; 2
     bea:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     bee:	b6 01       	movw	r22, r12
     bf0:	c7 01       	movw	r24, r14
     bf2:	0e 94 c1 18 	call	0x3182	; 0x3182 <_ZN8emstreamlsEj>
     bf6:	6a e0       	ldi	r22, 0x0A	; 10
     bf8:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     bfc:	7c 01       	movw	r14, r24
     bfe:	69 ea       	ldi	r22, 0xA9	; 169
     c00:	72 e0       	ldi	r23, 0x02	; 2
     c02:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     c06:	4f ef       	ldi	r20, 0xFF	; 255
     c08:	5f e0       	ldi	r21, 0x0F	; 15
     c0a:	60 e0       	ldi	r22, 0x00	; 0
     c0c:	70 e0       	ldi	r23, 0x00	; 0
     c0e:	c7 01       	movw	r24, r14
     c10:	0e 94 f5 18 	call	0x31ea	; 0x31ea <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     c14:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     c18:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     c1c:	6a e0       	ldi	r22, 0x0A	; 10
     c1e:	f8 01       	movw	r30, r16
     c20:	86 81       	ldd	r24, Z+6	; 0x06
     c22:	97 81       	ldd	r25, Z+7	; 0x07
     c24:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     c28:	7c 01       	movw	r14, r24
     c2a:	6e e9       	ldi	r22, 0x9E	; 158
     c2c:	72 e0       	ldi	r23, 0x02	; 2
     c2e:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     c32:	b6 01       	movw	r22, r12
     c34:	c7 01       	movw	r24, r14
     c36:	0e 94 c1 18 	call	0x3182	; 0x3182 <_ZN8emstreamlsEj>
     c3a:	66 e0       	ldi	r22, 0x06	; 6
     c3c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     c40:	66 e0       	ldi	r22, 0x06	; 6
     c42:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     c46:	f8 01       	movw	r30, r16
     c48:	86 81       	ldd	r24, Z+6	; 0x06
     c4a:	97 81       	ldd	r25, Z+7	; 0x07
     c4c:	0e 94 c8 14 	call	0x2990	; 0x2990 <_Z15print_task_listP8emstream>
}
     c50:	26 96       	adiw	r28, 0x06	; 6
     c52:	cd bf       	out	0x3d, r28	; 61
     c54:	de bf       	out	0x3e, r29	; 62
     c56:	df 91       	pop	r29
     c58:	cf 91       	pop	r28
     c5a:	1f 91       	pop	r17
     c5c:	0f 91       	pop	r16
     c5e:	ff 90       	pop	r15
     c60:	ef 90       	pop	r14
     c62:	df 90       	pop	r13
     c64:	cf 90       	pop	r12
     c66:	bf 90       	pop	r11
     c68:	af 90       	pop	r10
     c6a:	08 95       	ret

00000c6c <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     c6c:	cf 93       	push	r28
     c6e:	df 93       	push	r29
     c70:	00 d0       	rcall	.+0      	; 0xc72 <_ZN9task_user3runEv+0x6>
     c72:	00 d0       	rcall	.+0      	; 0xc74 <_ZN9task_user3runEv+0x8>
     c74:	cd b7       	in	r28, 0x3d	; 61
     c76:	de b7       	in	r29, 0x3e	; 62
     c78:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     c7a:	19 82       	std	Y+1, r1	; 0x01
     c7c:	1a 82       	std	Y+2, r1	; 0x02
     c7e:	1b 82       	std	Y+3, r1	; 0x03
     c80:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     c82:	1d 82       	std	Y+5, r1	; 0x05
     c84:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     c86:	6a e0       	ldi	r22, 0x0A	; 10
     c88:	dc 01       	movw	r26, r24
     c8a:	16 96       	adiw	r26, 0x06	; 6
     c8c:	8d 91       	ld	r24, X+
     c8e:	9c 91       	ld	r25, X
     c90:	17 97       	sbiw	r26, 0x07	; 7
     c92:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     c96:	7c 01       	movw	r14, r24
     c98:	6a e3       	ldi	r22, 0x3A	; 58
     c9a:	74 e0       	ldi	r23, 0x04	; 4
     c9c:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     ca0:	66 e0       	ldi	r22, 0x06	; 6
     ca2:	c7 01       	movw	r24, r14
     ca4:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     ca8:	f8 01       	movw	r30, r16
     caa:	84 85       	ldd	r24, Z+12	; 0x0c
     cac:	88 23       	and	r24, r24
     cae:	21 f0       	breq	.+8      	; 0xcb8 <_ZN9task_user3runEv+0x4c>
     cb0:	81 30       	cpi	r24, 0x01	; 1
     cb2:	09 f4       	brne	.+2      	; 0xcb6 <_ZN9task_user3runEv+0x4a>
     cb4:	5d c0       	rjmp	.+186    	; 0xd70 <_ZN9task_user3runEv+0x104>
     cb6:	d8 c0       	rjmp	.+432    	; 0xe68 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     cb8:	86 81       	ldd	r24, Z+6	; 0x06
     cba:	97 81       	ldd	r25, Z+7	; 0x07
     cbc:	dc 01       	movw	r26, r24
     cbe:	ed 91       	ld	r30, X+
     cc0:	fc 91       	ld	r31, X
     cc2:	04 80       	ldd	r0, Z+4	; 0x04
     cc4:	f5 81       	ldd	r31, Z+5	; 0x05
     cc6:	e0 2d       	mov	r30, r0
     cc8:	19 95       	eicall
     cca:	88 23       	and	r24, r24
     ccc:	a9 f1       	breq	.+106    	; 0xd38 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     cce:	f8 01       	movw	r30, r16
     cd0:	86 81       	ldd	r24, Z+6	; 0x06
     cd2:	97 81       	ldd	r25, Z+7	; 0x07
     cd4:	dc 01       	movw	r26, r24
     cd6:	ed 91       	ld	r30, X+
     cd8:	fc 91       	ld	r31, X
     cda:	06 80       	ldd	r0, Z+6	; 0x06
     cdc:	f7 81       	ldd	r31, Z+7	; 0x07
     cde:	e0 2d       	mov	r30, r0
     ce0:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     ce2:	99 27       	eor	r25, r25
     ce4:	81 30       	cpi	r24, 0x01	; 1
     ce6:	91 05       	cpc	r25, r1
     ce8:	f9 f0       	breq	.+62     	; 0xd28 <_ZN9task_user3runEv+0xbc>
     cea:	03 97       	sbiw	r24, 0x03	; 3
     cec:	09 f0       	breq	.+2      	; 0xcf0 <_ZN9task_user3runEv+0x84>
     cee:	d8 c0       	rjmp	.+432    	; 0xea0 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     cf0:	6a e0       	ldi	r22, 0x0A	; 10
     cf2:	f8 01       	movw	r30, r16
     cf4:	86 81       	ldd	r24, Z+6	; 0x06
     cf6:	97 81       	ldd	r25, Z+7	; 0x07
     cf8:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     cfc:	8c 01       	movw	r16, r24
     cfe:	6c e2       	ldi	r22, 0x2C	; 44
     d00:	74 e0       	ldi	r23, 0x04	; 4
     d02:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     d06:	66 e0       	ldi	r22, 0x06	; 6
     d08:	c8 01       	movw	r24, r16
     d0a:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     d0e:	93 e0       	ldi	r25, 0x03	; 3
     d10:	88 ed       	ldi	r24, 0xD8	; 216
     d12:	08 b6       	in	r0, 0x38	; 56
     d14:	18 be       	out	0x38, r1	; 56
     d16:	84 bf       	out	0x34, r24	; 52
     d18:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     d1c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     d20:	81 fd       	sbrc	r24, 1
     d22:	fc cf       	rjmp	.-8      	; 0xd1c <_ZN9task_user3runEv+0xb0>
     d24:	08 be       	out	0x38, r0	; 56
     d26:	ff cf       	rjmp	.-2      	; 0xd26 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     d28:	c8 01       	movw	r24, r16
     d2a:	0e 94 03 05 	call	0xa06	; 0xa06 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     d2e:	61 e0       	ldi	r22, 0x01	; 1
     d30:	c8 01       	movw	r24, r16
     d32:	0e 94 b6 12 	call	0x256c	; 0x256c <_ZN8frt_task13transition_toEh>
							break;
     d36:	b4 c0       	rjmp	.+360    	; 0xea0 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     d38:	80 e9       	ldi	r24, 0x90	; 144
     d3a:	91 e3       	ldi	r25, 0x31	; 49
     d3c:	0e 94 77 15 	call	0x2aee	; 0x2aee <_ZN14frt_text_queue14check_for_charEv>
     d40:	88 23       	and	r24, r24
     d42:	09 f4       	brne	.+2      	; 0xd46 <_ZN9task_user3runEv+0xda>
     d44:	ad c0       	rjmp	.+346    	; 0xea0 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     d46:	d8 01       	movw	r26, r16
     d48:	16 96       	adiw	r26, 0x06	; 6
     d4a:	ed 91       	ld	r30, X+
     d4c:	fc 91       	ld	r31, X
     d4e:	17 97       	sbiw	r26, 0x07	; 7
     d50:	01 90       	ld	r0, Z+
     d52:	f0 81       	ld	r31, Z
     d54:	e0 2d       	mov	r30, r0
     d56:	e2 80       	ldd	r14, Z+2	; 0x02
     d58:	f3 80       	ldd	r15, Z+3	; 0x03
     d5a:	80 e9       	ldi	r24, 0x90	; 144
     d5c:	91 e3       	ldi	r25, 0x31	; 49
     d5e:	0e 94 59 15 	call	0x2ab2	; 0x2ab2 <_ZN14frt_text_queue7getcharEv>
     d62:	68 2f       	mov	r22, r24
     d64:	f8 01       	movw	r30, r16
     d66:	86 81       	ldd	r24, Z+6	; 0x06
     d68:	97 81       	ldd	r25, Z+7	; 0x07
     d6a:	f7 01       	movw	r30, r14
     d6c:	19 95       	eicall
     d6e:	98 c0       	rjmp	.+304    	; 0xea0 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     d70:	86 81       	ldd	r24, Z+6	; 0x06
     d72:	97 81       	ldd	r25, Z+7	; 0x07
     d74:	dc 01       	movw	r26, r24
     d76:	ed 91       	ld	r30, X+
     d78:	fc 91       	ld	r31, X
     d7a:	04 80       	ldd	r0, Z+4	; 0x04
     d7c:	f5 81       	ldd	r31, Z+5	; 0x05
     d7e:	e0 2d       	mov	r30, r0
     d80:	19 95       	eicall
     d82:	88 23       	and	r24, r24
     d84:	09 f4       	brne	.+2      	; 0xd88 <_ZN9task_user3runEv+0x11c>
     d86:	8c c0       	rjmp	.+280    	; 0xea0 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     d88:	f8 01       	movw	r30, r16
     d8a:	86 81       	ldd	r24, Z+6	; 0x06
     d8c:	97 81       	ldd	r25, Z+7	; 0x07
     d8e:	dc 01       	movw	r26, r24
     d90:	ed 91       	ld	r30, X+
     d92:	fc 91       	ld	r31, X
     d94:	06 80       	ldd	r0, Z+6	; 0x06
     d96:	f7 81       	ldd	r31, Z+7	; 0x07
     d98:	e0 2d       	mov	r30, r0
     d9a:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     d9c:	9c 01       	movw	r18, r24
     d9e:	33 27       	eor	r19, r19
     da0:	28 36       	cpi	r18, 0x68	; 104
     da2:	31 05       	cpc	r19, r1
     da4:	59 f1       	breq	.+86     	; 0xdfc <_ZN9task_user3runEv+0x190>
     da6:	3c f4       	brge	.+14     	; 0xdb6 <_ZN9task_user3runEv+0x14a>
     da8:	2b 31       	cpi	r18, 0x1B	; 27
     daa:	31 05       	cpc	r19, r1
     dac:	59 f1       	breq	.+86     	; 0xe04 <_ZN9task_user3runEv+0x198>
     dae:	25 36       	cpi	r18, 0x65	; 101
     db0:	31 05       	cpc	r19, r1
     db2:	41 f1       	breq	.+80     	; 0xe04 <_ZN9task_user3runEv+0x198>
     db4:	3b c0       	rjmp	.+118    	; 0xe2c <_ZN9task_user3runEv+0x1c0>
     db6:	23 37       	cpi	r18, 0x73	; 115
     db8:	31 05       	cpc	r19, r1
     dba:	c1 f0       	breq	.+48     	; 0xdec <_ZN9task_user3runEv+0x180>
     dbc:	26 37       	cpi	r18, 0x76	; 118
     dbe:	31 05       	cpc	r19, r1
     dc0:	89 f0       	breq	.+34     	; 0xde4 <_ZN9task_user3runEv+0x178>
     dc2:	2e 36       	cpi	r18, 0x6E	; 110
     dc4:	31 05       	cpc	r19, r1
     dc6:	91 f5       	brne	.+100    	; 0xe2c <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     dc8:	ce 01       	movw	r24, r28
     dca:	01 96       	adiw	r24, 0x01	; 1
     dcc:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <_ZN10time_stamp10set_to_nowEv>
     dd0:	bc 01       	movw	r22, r24
     dd2:	f8 01       	movw	r30, r16
     dd4:	86 81       	ldd	r24, Z+6	; 0x06
     dd6:	97 81       	ldd	r25, Z+7	; 0x07
     dd8:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <_ZlsR8emstreamR10time_stamp>
     ddc:	66 e0       	ldi	r22, 0x06	; 6
     dde:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
							break;
     de2:	5e c0       	rjmp	.+188    	; 0xea0 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     de4:	c8 01       	movw	r24, r16
     de6:	0e 94 ab 05 	call	0xb56	; 0xb56 <_ZN9task_user11show_statusEv>
							break;
     dea:	5a c0       	rjmp	.+180    	; 0xea0 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     dec:	d8 01       	movw	r26, r16
     dee:	16 96       	adiw	r26, 0x06	; 6
     df0:	8d 91       	ld	r24, X+
     df2:	9c 91       	ld	r25, X
     df4:	17 97       	sbiw	r26, 0x07	; 7
     df6:	0e 94 cf 13 	call	0x279e	; 0x279e <_Z17print_task_stacksP8emstream>
							break;
     dfa:	52 c0       	rjmp	.+164    	; 0xea0 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     dfc:	c8 01       	movw	r24, r16
     dfe:	0e 94 03 05 	call	0xa06	; 0xa06 <_ZN9task_user18print_help_messageEv>
							break;
     e02:	4e c0       	rjmp	.+156    	; 0xea0 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     e04:	6a e0       	ldi	r22, 0x0A	; 10
     e06:	f8 01       	movw	r30, r16
     e08:	86 81       	ldd	r24, Z+6	; 0x06
     e0a:	97 81       	ldd	r25, Z+7	; 0x07
     e0c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     e10:	7c 01       	movw	r14, r24
     e12:	6a e1       	ldi	r22, 0x1A	; 26
     e14:	74 e0       	ldi	r23, 0x04	; 4
     e16:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     e1a:	66 e0       	ldi	r22, 0x06	; 6
     e1c:	c7 01       	movw	r24, r14
     e1e:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     e22:	60 e0       	ldi	r22, 0x00	; 0
     e24:	c8 01       	movw	r24, r16
     e26:	0e 94 b6 12 	call	0x256c	; 0x256c <_ZN8frt_task13transition_toEh>
							break;
     e2a:	3a c0       	rjmp	.+116    	; 0xea0 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     e2c:	f8 01       	movw	r30, r16
     e2e:	a6 81       	ldd	r26, Z+6	; 0x06
     e30:	b7 81       	ldd	r27, Z+7	; 0x07
     e32:	ed 91       	ld	r30, X+
     e34:	fc 91       	ld	r31, X
     e36:	11 97       	sbiw	r26, 0x01	; 1
     e38:	02 80       	ldd	r0, Z+2	; 0x02
     e3a:	f3 81       	ldd	r31, Z+3	; 0x03
     e3c:	e0 2d       	mov	r30, r0
     e3e:	68 2f       	mov	r22, r24
     e40:	cd 01       	movw	r24, r26
     e42:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     e44:	6a e0       	ldi	r22, 0x0A	; 10
     e46:	d8 01       	movw	r26, r16
     e48:	16 96       	adiw	r26, 0x06	; 6
     e4a:	8d 91       	ld	r24, X+
     e4c:	9c 91       	ld	r25, X
     e4e:	17 97       	sbiw	r26, 0x07	; 7
     e50:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     e54:	7c 01       	movw	r14, r24
     e56:	64 e1       	ldi	r22, 0x14	; 20
     e58:	74 e0       	ldi	r23, 0x04	; 4
     e5a:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     e5e:	66 e0       	ldi	r22, 0x06	; 6
     e60:	c7 01       	movw	r24, r14
     e62:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
							break;
     e66:	1c c0       	rjmp	.+56     	; 0xea0 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     e68:	6a e0       	ldi	r22, 0x0A	; 10
     e6a:	f8 01       	movw	r30, r16
     e6c:	86 81       	ldd	r24, Z+6	; 0x06
     e6e:	97 81       	ldd	r25, Z+7	; 0x07
     e70:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
     e74:	8c 01       	movw	r16, r24
     e76:	67 ef       	ldi	r22, 0xF7	; 247
     e78:	73 e0       	ldi	r23, 0x03	; 3
     e7a:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
     e7e:	66 e0       	ldi	r22, 0x06	; 6
     e80:	c8 01       	movw	r24, r16
     e82:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     e86:	93 e0       	ldi	r25, 0x03	; 3
     e88:	88 ed       	ldi	r24, 0xD8	; 216
     e8a:	08 b6       	in	r0, 0x38	; 56
     e8c:	18 be       	out	0x38, r1	; 56
     e8e:	84 bf       	out	0x34, r24	; 52
     e90:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     e94:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     e98:	81 fd       	sbrc	r24, 1
     e9a:	fc cf       	rjmp	.-8      	; 0xe94 <_ZN9task_user3runEv+0x228>
     e9c:	08 be       	out	0x38, r0	; 56
     e9e:	ff cf       	rjmp	.-2      	; 0xe9e <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     ea0:	f8 01       	movw	r30, r16
     ea2:	86 85       	ldd	r24, Z+14	; 0x0e
     ea4:	97 85       	ldd	r25, Z+15	; 0x0f
     ea6:	a0 89       	ldd	r26, Z+16	; 0x10
     ea8:	b1 89       	ldd	r27, Z+17	; 0x11
     eaa:	01 96       	adiw	r24, 0x01	; 1
     eac:	a1 1d       	adc	r26, r1
     eae:	b1 1d       	adc	r27, r1
     eb0:	86 87       	std	Z+14, r24	; 0x0e
     eb2:	97 87       	std	Z+15, r25	; 0x0f
     eb4:	a0 8b       	std	Z+16, r26	; 0x10
     eb6:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     eb8:	61 e0       	ldi	r22, 0x01	; 1
     eba:	70 e0       	ldi	r23, 0x00	; 0
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	0e 94 8a 10 	call	0x2114	; 0x2114 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     ec4:	f1 ce       	rjmp	.-542    	; 0xca8 <_ZN9task_user3runEv+0x3c>

00000ec6 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     ec6:	0f 93       	push	r16
     ec8:	1f 93       	push	r17
     eca:	cf 93       	push	r28
     ecc:	df 93       	push	r29
     ece:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     ed0:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     ed4:	80 91 f4 20 	lds	r24, 0x20F4	; 0x8020f4 <__data_end>
     ed8:	81 11       	cpse	r24, r1
     eda:	1d c0       	rjmp	.+58     	; 0xf16 <pvPortMalloc+0x50>
		{
			prvHeapInit();
     edc:	a9 ef       	ldi	r26, 0xF9	; 249
     ede:	b0 e2       	ldi	r27, 0x20	; 32
     ee0:	ed ef       	ldi	r30, 0xFD	; 253
     ee2:	f0 e2       	ldi	r31, 0x20	; 32
     ee4:	ed 93       	st	X+, r30
     ee6:	fc 93       	st	X, r31
     ee8:	11 97       	sbiw	r26, 0x01	; 1
     eea:	12 96       	adiw	r26, 0x02	; 2
     eec:	1d 92       	st	X+, r1
     eee:	1c 92       	st	X, r1
     ef0:	13 97       	sbiw	r26, 0x03	; 3
     ef2:	a5 ef       	ldi	r26, 0xF5	; 245
     ef4:	b0 e2       	ldi	r27, 0x20	; 32
     ef6:	8f ef       	ldi	r24, 0xFF	; 255
     ef8:	9f e0       	ldi	r25, 0x0F	; 15
     efa:	12 96       	adiw	r26, 0x02	; 2
     efc:	8d 93       	st	X+, r24
     efe:	9c 93       	st	X, r25
     f00:	13 97       	sbiw	r26, 0x03	; 3
     f02:	1d 92       	st	X+, r1
     f04:	1c 92       	st	X, r1
     f06:	11 97       	sbiw	r26, 0x01	; 1
     f08:	82 83       	std	Z+2, r24	; 0x02
     f0a:	93 83       	std	Z+3, r25	; 0x03
     f0c:	a0 83       	st	Z, r26
     f0e:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     f10:	81 e0       	ldi	r24, 0x01	; 1
     f12:	80 93 f4 20 	sts	0x20F4, r24	; 0x8020f4 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     f16:	20 97       	sbiw	r28, 0x00	; 0
     f18:	09 f4       	brne	.+2      	; 0xf1c <pvPortMalloc+0x56>
     f1a:	5f c0       	rjmp	.+190    	; 0xfda <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     f1c:	9e 01       	movw	r18, r28
     f1e:	2b 5f       	subi	r18, 0xFB	; 251
     f20:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     f22:	24 96       	adiw	r28, 0x04	; 4
     f24:	ce 3f       	cpi	r28, 0xFE	; 254
     f26:	df 40       	sbci	r29, 0x0F	; 15
     f28:	08 f0       	brcs	.+2      	; 0xf2c <pvPortMalloc+0x66>
     f2a:	5a c0       	rjmp	.+180    	; 0xfe0 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     f2c:	e0 91 f9 20 	lds	r30, 0x20F9	; 0x8020f9 <xStart>
     f30:	f0 91 fa 20 	lds	r31, 0x20FA	; 0x8020fa <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     f34:	a9 ef       	ldi	r26, 0xF9	; 249
     f36:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     f38:	02 c0       	rjmp	.+4      	; 0xf3e <pvPortMalloc+0x78>
     f3a:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     f3c:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     f3e:	82 81       	ldd	r24, Z+2	; 0x02
     f40:	93 81       	ldd	r25, Z+3	; 0x03
     f42:	82 17       	cp	r24, r18
     f44:	93 07       	cpc	r25, r19
     f46:	20 f4       	brcc	.+8      	; 0xf50 <pvPortMalloc+0x8a>
     f48:	80 81       	ld	r24, Z
     f4a:	91 81       	ldd	r25, Z+1	; 0x01
     f4c:	00 97       	sbiw	r24, 0x00	; 0
     f4e:	a9 f7       	brne	.-22     	; 0xf3a <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     f50:	c0 e2       	ldi	r28, 0x20	; 32
     f52:	e5 3f       	cpi	r30, 0xF5	; 245
     f54:	fc 07       	cpc	r31, r28
     f56:	09 f4       	brne	.+2      	; 0xf5a <pvPortMalloc+0x94>
     f58:	46 c0       	rjmp	.+140    	; 0xfe6 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     f5a:	cd 91       	ld	r28, X+
     f5c:	dc 91       	ld	r29, X
     f5e:	11 97       	sbiw	r26, 0x01	; 1
     f60:	8e 01       	movw	r16, r28
     f62:	0b 5f       	subi	r16, 0xFB	; 251
     f64:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     f66:	80 81       	ld	r24, Z
     f68:	91 81       	ldd	r25, Z+1	; 0x01
     f6a:	8d 93       	st	X+, r24
     f6c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     f6e:	82 81       	ldd	r24, Z+2	; 0x02
     f70:	93 81       	ldd	r25, Z+3	; 0x03
     f72:	82 1b       	sub	r24, r18
     f74:	93 0b       	sbc	r25, r19
     f76:	8b 30       	cpi	r24, 0x0B	; 11
     f78:	91 05       	cpc	r25, r1
     f7a:	10 f1       	brcs	.+68     	; 0xfc0 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     f7c:	bf 01       	movw	r22, r30
     f7e:	62 0f       	add	r22, r18
     f80:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     f82:	db 01       	movw	r26, r22
     f84:	12 96       	adiw	r26, 0x02	; 2
     f86:	8d 93       	st	X+, r24
     f88:	9c 93       	st	X, r25
     f8a:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     f8c:	22 83       	std	Z+2, r18	; 0x02
     f8e:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     f90:	12 96       	adiw	r26, 0x02	; 2
     f92:	4d 91       	ld	r20, X+
     f94:	5c 91       	ld	r21, X
     f96:	13 97       	sbiw	r26, 0x03	; 3
     f98:	89 ef       	ldi	r24, 0xF9	; 249
     f9a:	90 e2       	ldi	r25, 0x20	; 32
     f9c:	01 c0       	rjmp	.+2      	; 0xfa0 <pvPortMalloc+0xda>
     f9e:	cd 01       	movw	r24, r26
     fa0:	ec 01       	movw	r28, r24
     fa2:	a8 81       	ld	r26, Y
     fa4:	b9 81       	ldd	r27, Y+1	; 0x01
     fa6:	12 96       	adiw	r26, 0x02	; 2
     fa8:	2d 91       	ld	r18, X+
     faa:	3c 91       	ld	r19, X
     fac:	13 97       	sbiw	r26, 0x03	; 3
     fae:	24 17       	cp	r18, r20
     fb0:	35 07       	cpc	r19, r21
     fb2:	a8 f3       	brcs	.-22     	; 0xf9e <pvPortMalloc+0xd8>
     fb4:	eb 01       	movw	r28, r22
     fb6:	a8 83       	st	Y, r26
     fb8:	b9 83       	std	Y+1, r27	; 0x01
     fba:	dc 01       	movw	r26, r24
     fbc:	6d 93       	st	X+, r22
     fbe:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     fc0:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     fc4:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     fc8:	22 81       	ldd	r18, Z+2	; 0x02
     fca:	33 81       	ldd	r19, Z+3	; 0x03
     fcc:	82 1b       	sub	r24, r18
     fce:	93 0b       	sbc	r25, r19
     fd0:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     fd4:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     fd8:	08 c0       	rjmp	.+16     	; 0xfea <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     fda:	00 e0       	ldi	r16, 0x00	; 0
     fdc:	10 e0       	ldi	r17, 0x00	; 0
     fde:	05 c0       	rjmp	.+10     	; 0xfea <pvPortMalloc+0x124>
     fe0:	00 e0       	ldi	r16, 0x00	; 0
     fe2:	10 e0       	ldi	r17, 0x00	; 0
     fe4:	02 c0       	rjmp	.+4      	; 0xfea <pvPortMalloc+0x124>
     fe6:	00 e0       	ldi	r16, 0x00	; 0
     fe8:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     fea:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     fee:	c8 01       	movw	r24, r16
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	1f 91       	pop	r17
     ff6:	0f 91       	pop	r16
     ff8:	08 95       	ret

00000ffa <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     ffa:	0f 93       	push	r16
     ffc:	1f 93       	push	r17
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1002:	00 97       	sbiw	r24, 0x00	; 0
    1004:	41 f1       	breq	.+80     	; 0x1056 <vPortFree+0x5c>
    1006:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1008:	8c 01       	movw	r16, r24
    100a:	05 50       	subi	r16, 0x05	; 5
    100c:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    100e:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1012:	f8 01       	movw	r30, r16
    1014:	42 81       	ldd	r20, Z+2	; 0x02
    1016:	53 81       	ldd	r21, Z+3	; 0x03
    1018:	a9 ef       	ldi	r26, 0xF9	; 249
    101a:	b0 e2       	ldi	r27, 0x20	; 32
    101c:	01 c0       	rjmp	.+2      	; 0x1020 <vPortFree+0x26>
    101e:	df 01       	movw	r26, r30
    1020:	ed 91       	ld	r30, X+
    1022:	fc 91       	ld	r31, X
    1024:	11 97       	sbiw	r26, 0x01	; 1
    1026:	22 81       	ldd	r18, Z+2	; 0x02
    1028:	33 81       	ldd	r19, Z+3	; 0x03
    102a:	24 17       	cp	r18, r20
    102c:	35 07       	cpc	r19, r21
    102e:	b8 f3       	brcs	.-18     	; 0x101e <vPortFree+0x24>
    1030:	25 97       	sbiw	r28, 0x05	; 5
    1032:	e8 83       	st	Y, r30
    1034:	f9 83       	std	Y+1, r31	; 0x01
    1036:	0d 93       	st	X+, r16
    1038:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    103a:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    103e:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1042:	8a 81       	ldd	r24, Y+2	; 0x02
    1044:	9b 81       	ldd	r25, Y+3	; 0x03
    1046:	82 0f       	add	r24, r18
    1048:	93 1f       	adc	r25, r19
    104a:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    104e:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1052:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
	}
}
    1056:	df 91       	pop	r29
    1058:	cf 91       	pop	r28
    105a:	1f 91       	pop	r17
    105c:	0f 91       	pop	r16
    105e:	08 95       	ret

00001060 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1060:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1064:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1068:	08 95       	ret

0000106a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    106a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    106c:	03 96       	adiw	r24, 0x03	; 3
    106e:	81 83       	std	Z+1, r24	; 0x01
    1070:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1072:	4f ef       	ldi	r20, 0xFF	; 255
    1074:	5f ef       	ldi	r21, 0xFF	; 255
    1076:	ba 01       	movw	r22, r20
    1078:	43 83       	std	Z+3, r20	; 0x03
    107a:	54 83       	std	Z+4, r21	; 0x04
    107c:	65 83       	std	Z+5, r22	; 0x05
    107e:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1080:	87 83       	std	Z+7, r24	; 0x07
    1082:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1084:	81 87       	std	Z+9, r24	; 0x09
    1086:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1088:	10 82       	st	Z, r1
    108a:	08 95       	ret

0000108c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    108c:	fc 01       	movw	r30, r24
    108e:	12 86       	std	Z+10, r1	; 0x0a
    1090:	13 86       	std	Z+11, r1	; 0x0b
    1092:	08 95       	ret

00001094 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
    1098:	fc 01       	movw	r30, r24
    109a:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    109c:	21 81       	ldd	r18, Z+1	; 0x01
    109e:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    10a0:	e9 01       	movw	r28, r18
    10a2:	8c 81       	ldd	r24, Y+4	; 0x04
    10a4:	9d 81       	ldd	r25, Y+5	; 0x05
    10a6:	14 96       	adiw	r26, 0x04	; 4
    10a8:	8d 93       	st	X+, r24
    10aa:	9c 93       	st	X, r25
    10ac:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    10ae:	81 81       	ldd	r24, Z+1	; 0x01
    10b0:	92 81       	ldd	r25, Z+2	; 0x02
    10b2:	16 96       	adiw	r26, 0x06	; 6
    10b4:	8d 93       	st	X+, r24
    10b6:	9c 93       	st	X, r25
    10b8:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    10ba:	8c 81       	ldd	r24, Y+4	; 0x04
    10bc:	9d 81       	ldd	r25, Y+5	; 0x05
    10be:	ec 01       	movw	r28, r24
    10c0:	6e 83       	std	Y+6, r22	; 0x06
    10c2:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    10c4:	e9 01       	movw	r28, r18
    10c6:	6c 83       	std	Y+4, r22	; 0x04
    10c8:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    10ca:	61 83       	std	Z+1, r22	; 0x01
    10cc:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10ce:	1a 96       	adiw	r26, 0x0a	; 10
    10d0:	ed 93       	st	X+, r30
    10d2:	fc 93       	st	X, r31
    10d4:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    10d6:	80 81       	ld	r24, Z
    10d8:	8f 5f       	subi	r24, 0xFF	; 255
    10da:	80 83       	st	Z, r24
}
    10dc:	df 91       	pop	r29
    10de:	cf 91       	pop	r28
    10e0:	08 95       	ret

000010e2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    10e2:	0f 93       	push	r16
    10e4:	1f 93       	push	r17
    10e6:	cf 93       	push	r28
    10e8:	df 93       	push	r29
    10ea:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    10ec:	08 81       	ld	r16, Y
    10ee:	19 81       	ldd	r17, Y+1	; 0x01
    10f0:	2a 81       	ldd	r18, Y+2	; 0x02
    10f2:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    10f4:	0f 3f       	cpi	r16, 0xFF	; 255
    10f6:	4f ef       	ldi	r20, 0xFF	; 255
    10f8:	14 07       	cpc	r17, r20
    10fa:	24 07       	cpc	r18, r20
    10fc:	34 07       	cpc	r19, r20
    10fe:	31 f4       	brne	.+12     	; 0x110c <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1100:	dc 01       	movw	r26, r24
    1102:	19 96       	adiw	r26, 0x09	; 9
    1104:	ed 91       	ld	r30, X+
    1106:	fc 91       	ld	r31, X
    1108:	1a 97       	sbiw	r26, 0x0a	; 10
    110a:	1f c0       	rjmp	.+62     	; 0x114a <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    110c:	fc 01       	movw	r30, r24
    110e:	33 96       	adiw	r30, 0x03	; 3
    1110:	dc 01       	movw	r26, r24
    1112:	17 96       	adiw	r26, 0x07	; 7
    1114:	4d 91       	ld	r20, X+
    1116:	5c 91       	ld	r21, X
    1118:	18 97       	sbiw	r26, 0x08	; 8
    111a:	da 01       	movw	r26, r20
    111c:	4d 91       	ld	r20, X+
    111e:	5d 91       	ld	r21, X+
    1120:	6d 91       	ld	r22, X+
    1122:	7c 91       	ld	r23, X
    1124:	04 17       	cp	r16, r20
    1126:	15 07       	cpc	r17, r21
    1128:	26 07       	cpc	r18, r22
    112a:	37 07       	cpc	r19, r23
    112c:	70 f0       	brcs	.+28     	; 0x114a <vListInsert+0x68>
    112e:	04 80       	ldd	r0, Z+4	; 0x04
    1130:	f5 81       	ldd	r31, Z+5	; 0x05
    1132:	e0 2d       	mov	r30, r0
    1134:	a4 81       	ldd	r26, Z+4	; 0x04
    1136:	b5 81       	ldd	r27, Z+5	; 0x05
    1138:	4d 91       	ld	r20, X+
    113a:	5d 91       	ld	r21, X+
    113c:	6d 91       	ld	r22, X+
    113e:	7c 91       	ld	r23, X
    1140:	04 17       	cp	r16, r20
    1142:	15 07       	cpc	r17, r21
    1144:	26 07       	cpc	r18, r22
    1146:	37 07       	cpc	r19, r23
    1148:	90 f7       	brcc	.-28     	; 0x112e <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    114a:	a4 81       	ldd	r26, Z+4	; 0x04
    114c:	b5 81       	ldd	r27, Z+5	; 0x05
    114e:	ac 83       	std	Y+4, r26	; 0x04
    1150:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1152:	16 96       	adiw	r26, 0x06	; 6
    1154:	cd 93       	st	X+, r28
    1156:	dc 93       	st	X, r29
    1158:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    115a:	ee 83       	std	Y+6, r30	; 0x06
    115c:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    115e:	c4 83       	std	Z+4, r28	; 0x04
    1160:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1162:	8a 87       	std	Y+10, r24	; 0x0a
    1164:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1166:	fc 01       	movw	r30, r24
    1168:	20 81       	ld	r18, Z
    116a:	2f 5f       	subi	r18, 0xFF	; 255
    116c:	20 83       	st	Z, r18
}
    116e:	df 91       	pop	r29
    1170:	cf 91       	pop	r28
    1172:	1f 91       	pop	r17
    1174:	0f 91       	pop	r16
    1176:	08 95       	ret

00001178 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1178:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    117a:	a4 81       	ldd	r26, Z+4	; 0x04
    117c:	b5 81       	ldd	r27, Z+5	; 0x05
    117e:	86 81       	ldd	r24, Z+6	; 0x06
    1180:	97 81       	ldd	r25, Z+7	; 0x07
    1182:	16 96       	adiw	r26, 0x06	; 6
    1184:	8d 93       	st	X+, r24
    1186:	9c 93       	st	X, r25
    1188:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    118a:	a6 81       	ldd	r26, Z+6	; 0x06
    118c:	b7 81       	ldd	r27, Z+7	; 0x07
    118e:	84 81       	ldd	r24, Z+4	; 0x04
    1190:	95 81       	ldd	r25, Z+5	; 0x05
    1192:	14 96       	adiw	r26, 0x04	; 4
    1194:	8d 93       	st	X+, r24
    1196:	9c 93       	st	X, r25
    1198:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    119a:	a2 85       	ldd	r26, Z+10	; 0x0a
    119c:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    119e:	11 96       	adiw	r26, 0x01	; 1
    11a0:	8d 91       	ld	r24, X+
    11a2:	9c 91       	ld	r25, X
    11a4:	12 97       	sbiw	r26, 0x02	; 2
    11a6:	e8 17       	cp	r30, r24
    11a8:	f9 07       	cpc	r31, r25
    11aa:	31 f4       	brne	.+12     	; 0x11b8 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    11ac:	86 81       	ldd	r24, Z+6	; 0x06
    11ae:	97 81       	ldd	r25, Z+7	; 0x07
    11b0:	11 96       	adiw	r26, 0x01	; 1
    11b2:	8d 93       	st	X+, r24
    11b4:	9c 93       	st	X, r25
    11b6:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    11b8:	12 86       	std	Z+10, r1	; 0x0a
    11ba:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    11bc:	8c 91       	ld	r24, X
    11be:	81 50       	subi	r24, 0x01	; 1
    11c0:	8c 93       	st	X, r24
    11c2:	08 95       	ret

000011c4 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    11c4:	80 93 a0 31 	sts	0x31A0, r24	; 0x8031a0 <portStackTopForTask>
    11c8:	90 93 a1 31 	sts	0x31A1, r25	; 0x8031a1 <portStackTopForTask+0x1>
    11cc:	31 e1       	ldi	r19, 0x11	; 17
    11ce:	fc 01       	movw	r30, r24
    11d0:	30 83       	st	Z, r19
    11d2:	31 97       	sbiw	r30, 0x01	; 1
    11d4:	22 e2       	ldi	r18, 0x22	; 34
    11d6:	20 83       	st	Z, r18
    11d8:	31 97       	sbiw	r30, 0x01	; 1
    11da:	a3 e3       	ldi	r26, 0x33	; 51
    11dc:	a0 83       	st	Z, r26
    11de:	31 97       	sbiw	r30, 0x01	; 1
    11e0:	60 83       	st	Z, r22
    11e2:	31 97       	sbiw	r30, 0x01	; 1
    11e4:	70 83       	st	Z, r23
    11e6:	31 97       	sbiw	r30, 0x01	; 1
    11e8:	10 82       	st	Z, r1
    11ea:	31 97       	sbiw	r30, 0x01	; 1
    11ec:	10 82       	st	Z, r1
    11ee:	31 97       	sbiw	r30, 0x01	; 1
    11f0:	60 e8       	ldi	r22, 0x80	; 128
    11f2:	60 83       	st	Z, r22
    11f4:	31 97       	sbiw	r30, 0x01	; 1
    11f6:	10 82       	st	Z, r1
    11f8:	31 97       	sbiw	r30, 0x01	; 1
    11fa:	10 82       	st	Z, r1
    11fc:	31 97       	sbiw	r30, 0x01	; 1
    11fe:	10 82       	st	Z, r1
    1200:	31 97       	sbiw	r30, 0x01	; 1
    1202:	62 e0       	ldi	r22, 0x02	; 2
    1204:	60 83       	st	Z, r22
    1206:	31 97       	sbiw	r30, 0x01	; 1
    1208:	63 e0       	ldi	r22, 0x03	; 3
    120a:	60 83       	st	Z, r22
    120c:	31 97       	sbiw	r30, 0x01	; 1
    120e:	64 e0       	ldi	r22, 0x04	; 4
    1210:	60 83       	st	Z, r22
    1212:	31 97       	sbiw	r30, 0x01	; 1
    1214:	65 e0       	ldi	r22, 0x05	; 5
    1216:	60 83       	st	Z, r22
    1218:	31 97       	sbiw	r30, 0x01	; 1
    121a:	66 e0       	ldi	r22, 0x06	; 6
    121c:	60 83       	st	Z, r22
    121e:	31 97       	sbiw	r30, 0x01	; 1
    1220:	67 e0       	ldi	r22, 0x07	; 7
    1222:	60 83       	st	Z, r22
    1224:	31 97       	sbiw	r30, 0x01	; 1
    1226:	68 e0       	ldi	r22, 0x08	; 8
    1228:	60 83       	st	Z, r22
    122a:	31 97       	sbiw	r30, 0x01	; 1
    122c:	69 e0       	ldi	r22, 0x09	; 9
    122e:	60 83       	st	Z, r22
    1230:	31 97       	sbiw	r30, 0x01	; 1
    1232:	60 e1       	ldi	r22, 0x10	; 16
    1234:	60 83       	st	Z, r22
    1236:	31 97       	sbiw	r30, 0x01	; 1
    1238:	30 83       	st	Z, r19
    123a:	31 97       	sbiw	r30, 0x01	; 1
    123c:	32 e1       	ldi	r19, 0x12	; 18
    123e:	30 83       	st	Z, r19
    1240:	31 97       	sbiw	r30, 0x01	; 1
    1242:	33 e1       	ldi	r19, 0x13	; 19
    1244:	30 83       	st	Z, r19
    1246:	31 97       	sbiw	r30, 0x01	; 1
    1248:	34 e1       	ldi	r19, 0x14	; 20
    124a:	30 83       	st	Z, r19
    124c:	31 97       	sbiw	r30, 0x01	; 1
    124e:	35 e1       	ldi	r19, 0x15	; 21
    1250:	30 83       	st	Z, r19
    1252:	31 97       	sbiw	r30, 0x01	; 1
    1254:	36 e1       	ldi	r19, 0x16	; 22
    1256:	30 83       	st	Z, r19
    1258:	31 97       	sbiw	r30, 0x01	; 1
    125a:	37 e1       	ldi	r19, 0x17	; 23
    125c:	30 83       	st	Z, r19
    125e:	31 97       	sbiw	r30, 0x01	; 1
    1260:	38 e1       	ldi	r19, 0x18	; 24
    1262:	30 83       	st	Z, r19
    1264:	31 97       	sbiw	r30, 0x01	; 1
    1266:	39 e1       	ldi	r19, 0x19	; 25
    1268:	30 83       	st	Z, r19
    126a:	31 97       	sbiw	r30, 0x01	; 1
    126c:	30 e2       	ldi	r19, 0x20	; 32
    126e:	30 83       	st	Z, r19
    1270:	31 97       	sbiw	r30, 0x01	; 1
    1272:	31 e2       	ldi	r19, 0x21	; 33
    1274:	30 83       	st	Z, r19
    1276:	31 97       	sbiw	r30, 0x01	; 1
    1278:	20 83       	st	Z, r18
    127a:	31 97       	sbiw	r30, 0x01	; 1
    127c:	23 e2       	ldi	r18, 0x23	; 35
    127e:	20 83       	st	Z, r18
    1280:	31 97       	sbiw	r30, 0x01	; 1
    1282:	40 83       	st	Z, r20
    1284:	31 97       	sbiw	r30, 0x01	; 1
    1286:	50 83       	st	Z, r21
    1288:	31 97       	sbiw	r30, 0x01	; 1
    128a:	26 e2       	ldi	r18, 0x26	; 38
    128c:	20 83       	st	Z, r18
    128e:	31 97       	sbiw	r30, 0x01	; 1
    1290:	27 e2       	ldi	r18, 0x27	; 39
    1292:	20 83       	st	Z, r18
    1294:	31 97       	sbiw	r30, 0x01	; 1
    1296:	28 e2       	ldi	r18, 0x28	; 40
    1298:	20 83       	st	Z, r18
    129a:	31 97       	sbiw	r30, 0x01	; 1
    129c:	29 e2       	ldi	r18, 0x29	; 41
    129e:	20 83       	st	Z, r18
    12a0:	31 97       	sbiw	r30, 0x01	; 1
    12a2:	20 e3       	ldi	r18, 0x30	; 48
    12a4:	20 83       	st	Z, r18
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	21 e3       	ldi	r18, 0x31	; 49
    12aa:	20 83       	st	Z, r18
    12ac:	89 97       	sbiw	r24, 0x29	; 41
    12ae:	08 95       	ret

000012b0 <xPortStartScheduler>:
    12b0:	8c e7       	ldi	r24, 0x7C	; 124
    12b2:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
    12b6:	8f ef       	ldi	r24, 0xFF	; 255
    12b8:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    12c2:	81 e1       	ldi	r24, 0x11	; 17
    12c4:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    12c8:	83 e0       	ldi	r24, 0x03	; 3
    12ca:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
    12ce:	a0 91 5c 31 	lds	r26, 0x315C	; 0x80315c <pxCurrentTCB>
    12d2:	b0 91 5d 31 	lds	r27, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    12d6:	cd 91       	ld	r28, X+
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	dd 91       	ld	r29, X+
    12dc:	de bf       	out	0x3e, r29	; 62
    12de:	ff 91       	pop	r31
    12e0:	ef 91       	pop	r30
    12e2:	df 91       	pop	r29
    12e4:	cf 91       	pop	r28
    12e6:	bf 91       	pop	r27
    12e8:	af 91       	pop	r26
    12ea:	9f 91       	pop	r25
    12ec:	8f 91       	pop	r24
    12ee:	7f 91       	pop	r23
    12f0:	6f 91       	pop	r22
    12f2:	5f 91       	pop	r21
    12f4:	4f 91       	pop	r20
    12f6:	3f 91       	pop	r19
    12f8:	2f 91       	pop	r18
    12fa:	1f 91       	pop	r17
    12fc:	0f 91       	pop	r16
    12fe:	ff 90       	pop	r15
    1300:	ef 90       	pop	r14
    1302:	df 90       	pop	r13
    1304:	cf 90       	pop	r12
    1306:	bf 90       	pop	r11
    1308:	af 90       	pop	r10
    130a:	9f 90       	pop	r9
    130c:	8f 90       	pop	r8
    130e:	7f 90       	pop	r7
    1310:	6f 90       	pop	r6
    1312:	5f 90       	pop	r5
    1314:	4f 90       	pop	r4
    1316:	3f 90       	pop	r3
    1318:	2f 90       	pop	r2
    131a:	1f 90       	pop	r1
    131c:	0f 90       	pop	r0
    131e:	0c be       	out	0x3c, r0	; 60
    1320:	0f 90       	pop	r0
    1322:	0b be       	out	0x3b, r0	; 59
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63
    1328:	0f 90       	pop	r0
    132a:	08 95       	ret
    132c:	81 e0       	ldi	r24, 0x01	; 1
    132e:	08 95       	ret

00001330 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1330:	0f 92       	push	r0
    1332:	0f b6       	in	r0, 0x3f	; 63
    1334:	f8 94       	cli
    1336:	0f 92       	push	r0
    1338:	0b b6       	in	r0, 0x3b	; 59
    133a:	0f 92       	push	r0
    133c:	0c b6       	in	r0, 0x3c	; 60
    133e:	0f 92       	push	r0
    1340:	1f 92       	push	r1
    1342:	11 24       	eor	r1, r1
    1344:	2f 92       	push	r2
    1346:	3f 92       	push	r3
    1348:	4f 92       	push	r4
    134a:	5f 92       	push	r5
    134c:	6f 92       	push	r6
    134e:	7f 92       	push	r7
    1350:	8f 92       	push	r8
    1352:	9f 92       	push	r9
    1354:	af 92       	push	r10
    1356:	bf 92       	push	r11
    1358:	cf 92       	push	r12
    135a:	df 92       	push	r13
    135c:	ef 92       	push	r14
    135e:	ff 92       	push	r15
    1360:	0f 93       	push	r16
    1362:	1f 93       	push	r17
    1364:	2f 93       	push	r18
    1366:	3f 93       	push	r19
    1368:	4f 93       	push	r20
    136a:	5f 93       	push	r21
    136c:	6f 93       	push	r22
    136e:	7f 93       	push	r23
    1370:	8f 93       	push	r24
    1372:	9f 93       	push	r25
    1374:	af 93       	push	r26
    1376:	bf 93       	push	r27
    1378:	cf 93       	push	r28
    137a:	df 93       	push	r29
    137c:	ef 93       	push	r30
    137e:	ff 93       	push	r31
    1380:	a0 91 5c 31 	lds	r26, 0x315C	; 0x80315c <pxCurrentTCB>
    1384:	b0 91 5d 31 	lds	r27, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1388:	0d b6       	in	r0, 0x3d	; 61
    138a:	0d 92       	st	X+, r0
    138c:	0e b6       	in	r0, 0x3e	; 62
    138e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1390:	0e 94 b8 10 	call	0x2170	; 0x2170 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1394:	a0 91 5c 31 	lds	r26, 0x315C	; 0x80315c <pxCurrentTCB>
    1398:	b0 91 5d 31 	lds	r27, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    139c:	cd 91       	ld	r28, X+
    139e:	cd bf       	out	0x3d, r28	; 61
    13a0:	dd 91       	ld	r29, X+
    13a2:	de bf       	out	0x3e, r29	; 62
    13a4:	ff 91       	pop	r31
    13a6:	ef 91       	pop	r30
    13a8:	df 91       	pop	r29
    13aa:	cf 91       	pop	r28
    13ac:	bf 91       	pop	r27
    13ae:	af 91       	pop	r26
    13b0:	9f 91       	pop	r25
    13b2:	8f 91       	pop	r24
    13b4:	7f 91       	pop	r23
    13b6:	6f 91       	pop	r22
    13b8:	5f 91       	pop	r21
    13ba:	4f 91       	pop	r20
    13bc:	3f 91       	pop	r19
    13be:	2f 91       	pop	r18
    13c0:	1f 91       	pop	r17
    13c2:	0f 91       	pop	r16
    13c4:	ff 90       	pop	r15
    13c6:	ef 90       	pop	r14
    13c8:	df 90       	pop	r13
    13ca:	cf 90       	pop	r12
    13cc:	bf 90       	pop	r11
    13ce:	af 90       	pop	r10
    13d0:	9f 90       	pop	r9
    13d2:	8f 90       	pop	r8
    13d4:	7f 90       	pop	r7
    13d6:	6f 90       	pop	r6
    13d8:	5f 90       	pop	r5
    13da:	4f 90       	pop	r4
    13dc:	3f 90       	pop	r3
    13de:	2f 90       	pop	r2
    13e0:	1f 90       	pop	r1
    13e2:	0f 90       	pop	r0
    13e4:	0c be       	out	0x3c, r0	; 60
    13e6:	0f 90       	pop	r0
    13e8:	0b be       	out	0x3b, r0	; 59
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13f0:	08 95       	ret

000013f2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    13f2:	0f 92       	push	r0
    13f4:	0f b6       	in	r0, 0x3f	; 63
    13f6:	f8 94       	cli
    13f8:	0f 92       	push	r0
    13fa:	0b b6       	in	r0, 0x3b	; 59
    13fc:	0f 92       	push	r0
    13fe:	0c b6       	in	r0, 0x3c	; 60
    1400:	0f 92       	push	r0
    1402:	1f 92       	push	r1
    1404:	11 24       	eor	r1, r1
    1406:	2f 92       	push	r2
    1408:	3f 92       	push	r3
    140a:	4f 92       	push	r4
    140c:	5f 92       	push	r5
    140e:	6f 92       	push	r6
    1410:	7f 92       	push	r7
    1412:	8f 92       	push	r8
    1414:	9f 92       	push	r9
    1416:	af 92       	push	r10
    1418:	bf 92       	push	r11
    141a:	cf 92       	push	r12
    141c:	df 92       	push	r13
    141e:	ef 92       	push	r14
    1420:	ff 92       	push	r15
    1422:	0f 93       	push	r16
    1424:	1f 93       	push	r17
    1426:	2f 93       	push	r18
    1428:	3f 93       	push	r19
    142a:	4f 93       	push	r20
    142c:	5f 93       	push	r21
    142e:	6f 93       	push	r22
    1430:	7f 93       	push	r23
    1432:	8f 93       	push	r24
    1434:	9f 93       	push	r25
    1436:	af 93       	push	r26
    1438:	bf 93       	push	r27
    143a:	cf 93       	push	r28
    143c:	df 93       	push	r29
    143e:	ef 93       	push	r30
    1440:	ff 93       	push	r31
    1442:	a0 91 5c 31 	lds	r26, 0x315C	; 0x80315c <pxCurrentTCB>
    1446:	b0 91 5d 31 	lds	r27, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    144a:	0d b6       	in	r0, 0x3d	; 61
    144c:	0d 92       	st	X+, r0
    144e:	0e b6       	in	r0, 0x3e	; 62
    1450:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1452:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <vTaskIncrementTick>
	vTaskSwitchContext();
    1456:	0e 94 b8 10 	call	0x2170	; 0x2170 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    145a:	a0 91 5c 31 	lds	r26, 0x315C	; 0x80315c <pxCurrentTCB>
    145e:	b0 91 5d 31 	lds	r27, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1462:	cd 91       	ld	r28, X+
    1464:	cd bf       	out	0x3d, r28	; 61
    1466:	dd 91       	ld	r29, X+
    1468:	de bf       	out	0x3e, r29	; 62
    146a:	ff 91       	pop	r31
    146c:	ef 91       	pop	r30
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	bf 91       	pop	r27
    1474:	af 91       	pop	r26
    1476:	9f 91       	pop	r25
    1478:	8f 91       	pop	r24
    147a:	7f 91       	pop	r23
    147c:	6f 91       	pop	r22
    147e:	5f 91       	pop	r21
    1480:	4f 91       	pop	r20
    1482:	3f 91       	pop	r19
    1484:	2f 91       	pop	r18
    1486:	1f 91       	pop	r17
    1488:	0f 91       	pop	r16
    148a:	ff 90       	pop	r15
    148c:	ef 90       	pop	r14
    148e:	df 90       	pop	r13
    1490:	cf 90       	pop	r12
    1492:	bf 90       	pop	r11
    1494:	af 90       	pop	r10
    1496:	9f 90       	pop	r9
    1498:	8f 90       	pop	r8
    149a:	7f 90       	pop	r7
    149c:	6f 90       	pop	r6
    149e:	5f 90       	pop	r5
    14a0:	4f 90       	pop	r4
    14a2:	3f 90       	pop	r3
    14a4:	2f 90       	pop	r2
    14a6:	1f 90       	pop	r1
    14a8:	0f 90       	pop	r0
    14aa:	0c be       	out	0x3c, r0	; 60
    14ac:	0f 90       	pop	r0
    14ae:	0b be       	out	0x3b, r0	; 59
    14b0:	0f 90       	pop	r0
    14b2:	0f be       	out	0x3f, r0	; 63
    14b4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14b6:	08 95       	ret

000014b8 <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    14b8:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <vPortYieldFromTick>
		asm volatile ( "reti" );
    14bc:	18 95       	reti

000014be <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	ec 01       	movw	r28, r24
    14c4:	88 a1       	ldd	r24, Y+32	; 0x20
    14c6:	81 11       	cpse	r24, r1
    14c8:	0b c0       	rjmp	.+22     	; 0x14e0 <prvCopyDataToQueue+0x22>
    14ca:	88 81       	ld	r24, Y
    14cc:	99 81       	ldd	r25, Y+1	; 0x01
    14ce:	89 2b       	or	r24, r25
    14d0:	e1 f5       	brne	.+120    	; 0x154a <prvCopyDataToQueue+0x8c>
    14d2:	8a 81       	ldd	r24, Y+2	; 0x02
    14d4:	9b 81       	ldd	r25, Y+3	; 0x03
    14d6:	0e 94 73 12 	call	0x24e6	; 0x24e6 <vTaskPriorityDisinherit>
    14da:	1a 82       	std	Y+2, r1	; 0x02
    14dc:	1b 82       	std	Y+3, r1	; 0x03
    14de:	35 c0       	rjmp	.+106    	; 0x154a <prvCopyDataToQueue+0x8c>
    14e0:	41 11       	cpse	r20, r1
    14e2:	17 c0       	rjmp	.+46     	; 0x1512 <prvCopyDataToQueue+0x54>
    14e4:	48 2f       	mov	r20, r24
    14e6:	50 e0       	ldi	r21, 0x00	; 0
    14e8:	8c 81       	ldd	r24, Y+4	; 0x04
    14ea:	9d 81       	ldd	r25, Y+5	; 0x05
    14ec:	0e 94 56 20 	call	0x40ac	; 0x40ac <memcpy>
    14f0:	28 a1       	ldd	r18, Y+32	; 0x20
    14f2:	8c 81       	ldd	r24, Y+4	; 0x04
    14f4:	9d 81       	ldd	r25, Y+5	; 0x05
    14f6:	82 0f       	add	r24, r18
    14f8:	91 1d       	adc	r25, r1
    14fa:	8c 83       	std	Y+4, r24	; 0x04
    14fc:	9d 83       	std	Y+5, r25	; 0x05
    14fe:	2a 81       	ldd	r18, Y+2	; 0x02
    1500:	3b 81       	ldd	r19, Y+3	; 0x03
    1502:	82 17       	cp	r24, r18
    1504:	93 07       	cpc	r25, r19
    1506:	08 f1       	brcs	.+66     	; 0x154a <prvCopyDataToQueue+0x8c>
    1508:	88 81       	ld	r24, Y
    150a:	99 81       	ldd	r25, Y+1	; 0x01
    150c:	8c 83       	std	Y+4, r24	; 0x04
    150e:	9d 83       	std	Y+5, r25	; 0x05
    1510:	1c c0       	rjmp	.+56     	; 0x154a <prvCopyDataToQueue+0x8c>
    1512:	48 2f       	mov	r20, r24
    1514:	50 e0       	ldi	r21, 0x00	; 0
    1516:	8e 81       	ldd	r24, Y+6	; 0x06
    1518:	9f 81       	ldd	r25, Y+7	; 0x07
    151a:	0e 94 56 20 	call	0x40ac	; 0x40ac <memcpy>
    151e:	88 a1       	ldd	r24, Y+32	; 0x20
    1520:	90 e0       	ldi	r25, 0x00	; 0
    1522:	91 95       	neg	r25
    1524:	81 95       	neg	r24
    1526:	91 09       	sbc	r25, r1
    1528:	2e 81       	ldd	r18, Y+6	; 0x06
    152a:	3f 81       	ldd	r19, Y+7	; 0x07
    152c:	28 0f       	add	r18, r24
    152e:	39 1f       	adc	r19, r25
    1530:	2e 83       	std	Y+6, r18	; 0x06
    1532:	3f 83       	std	Y+7, r19	; 0x07
    1534:	48 81       	ld	r20, Y
    1536:	59 81       	ldd	r21, Y+1	; 0x01
    1538:	24 17       	cp	r18, r20
    153a:	35 07       	cpc	r19, r21
    153c:	30 f4       	brcc	.+12     	; 0x154a <prvCopyDataToQueue+0x8c>
    153e:	2a 81       	ldd	r18, Y+2	; 0x02
    1540:	3b 81       	ldd	r19, Y+3	; 0x03
    1542:	82 0f       	add	r24, r18
    1544:	93 1f       	adc	r25, r19
    1546:	8e 83       	std	Y+6, r24	; 0x06
    1548:	9f 83       	std	Y+7, r25	; 0x07
    154a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    154c:	8f 5f       	subi	r24, 0xFF	; 255
    154e:	8e 8f       	std	Y+30, r24	; 0x1e
    1550:	df 91       	pop	r29
    1552:	cf 91       	pop	r28
    1554:	08 95       	ret

00001556 <prvCopyDataFromQueue>:
    1556:	fc 01       	movw	r30, r24
    1558:	80 81       	ld	r24, Z
    155a:	91 81       	ldd	r25, Z+1	; 0x01
    155c:	00 97       	sbiw	r24, 0x00	; 0
    155e:	a1 f0       	breq	.+40     	; 0x1588 <prvCopyDataFromQueue+0x32>
    1560:	40 a1       	ldd	r20, Z+32	; 0x20
    1562:	50 e0       	ldi	r21, 0x00	; 0
    1564:	26 81       	ldd	r18, Z+6	; 0x06
    1566:	37 81       	ldd	r19, Z+7	; 0x07
    1568:	24 0f       	add	r18, r20
    156a:	35 1f       	adc	r19, r21
    156c:	26 83       	std	Z+6, r18	; 0x06
    156e:	37 83       	std	Z+7, r19	; 0x07
    1570:	a2 81       	ldd	r26, Z+2	; 0x02
    1572:	b3 81       	ldd	r27, Z+3	; 0x03
    1574:	2a 17       	cp	r18, r26
    1576:	3b 07       	cpc	r19, r27
    1578:	10 f0       	brcs	.+4      	; 0x157e <prvCopyDataFromQueue+0x28>
    157a:	86 83       	std	Z+6, r24	; 0x06
    157c:	97 83       	std	Z+7, r25	; 0x07
    157e:	cb 01       	movw	r24, r22
    1580:	66 81       	ldd	r22, Z+6	; 0x06
    1582:	77 81       	ldd	r23, Z+7	; 0x07
    1584:	0e 94 56 20 	call	0x40ac	; 0x40ac <memcpy>
    1588:	08 95       	ret

0000158a <prvUnlockQueue>:
    158a:	0f 93       	push	r16
    158c:	1f 93       	push	r17
    158e:	cf 93       	push	r28
    1590:	df 93       	push	r29
    1592:	ec 01       	movw	r28, r24
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	0f 92       	push	r0
    159a:	8a a1       	ldd	r24, Y+34	; 0x22
    159c:	18 16       	cp	r1, r24
    159e:	b4 f4       	brge	.+44     	; 0x15cc <prvUnlockQueue+0x42>
    15a0:	8b 89       	ldd	r24, Y+19	; 0x13
    15a2:	81 11       	cpse	r24, r1
    15a4:	05 c0       	rjmp	.+10     	; 0x15b0 <prvUnlockQueue+0x26>
    15a6:	12 c0       	rjmp	.+36     	; 0x15cc <prvUnlockQueue+0x42>
    15a8:	8b 89       	ldd	r24, Y+19	; 0x13
    15aa:	81 11       	cpse	r24, r1
    15ac:	04 c0       	rjmp	.+8      	; 0x15b6 <prvUnlockQueue+0x2c>
    15ae:	0e c0       	rjmp	.+28     	; 0x15cc <prvUnlockQueue+0x42>
    15b0:	8e 01       	movw	r16, r28
    15b2:	0d 5e       	subi	r16, 0xED	; 237
    15b4:	1f 4f       	sbci	r17, 0xFF	; 255
    15b6:	c8 01       	movw	r24, r16
    15b8:	0e 94 3f 11 	call	0x227e	; 0x227e <xTaskRemoveFromEventList>
    15bc:	81 11       	cpse	r24, r1
    15be:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vTaskMissedYield>
    15c2:	8a a1       	ldd	r24, Y+34	; 0x22
    15c4:	81 50       	subi	r24, 0x01	; 1
    15c6:	8a a3       	std	Y+34, r24	; 0x22
    15c8:	18 16       	cp	r1, r24
    15ca:	74 f3       	brlt	.-36     	; 0x15a8 <prvUnlockQueue+0x1e>
    15cc:	8f ef       	ldi	r24, 0xFF	; 255
    15ce:	8a a3       	std	Y+34, r24	; 0x22
    15d0:	0f 90       	pop	r0
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	0f b6       	in	r0, 0x3f	; 63
    15d6:	f8 94       	cli
    15d8:	0f 92       	push	r0
    15da:	89 a1       	ldd	r24, Y+33	; 0x21
    15dc:	18 16       	cp	r1, r24
    15de:	b4 f4       	brge	.+44     	; 0x160c <prvUnlockQueue+0x82>
    15e0:	88 85       	ldd	r24, Y+8	; 0x08
    15e2:	81 11       	cpse	r24, r1
    15e4:	05 c0       	rjmp	.+10     	; 0x15f0 <prvUnlockQueue+0x66>
    15e6:	12 c0       	rjmp	.+36     	; 0x160c <prvUnlockQueue+0x82>
    15e8:	88 85       	ldd	r24, Y+8	; 0x08
    15ea:	81 11       	cpse	r24, r1
    15ec:	04 c0       	rjmp	.+8      	; 0x15f6 <prvUnlockQueue+0x6c>
    15ee:	0e c0       	rjmp	.+28     	; 0x160c <prvUnlockQueue+0x82>
    15f0:	8e 01       	movw	r16, r28
    15f2:	08 5f       	subi	r16, 0xF8	; 248
    15f4:	1f 4f       	sbci	r17, 0xFF	; 255
    15f6:	c8 01       	movw	r24, r16
    15f8:	0e 94 3f 11 	call	0x227e	; 0x227e <xTaskRemoveFromEventList>
    15fc:	81 11       	cpse	r24, r1
    15fe:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vTaskMissedYield>
    1602:	89 a1       	ldd	r24, Y+33	; 0x21
    1604:	81 50       	subi	r24, 0x01	; 1
    1606:	89 a3       	std	Y+33, r24	; 0x21
    1608:	18 16       	cp	r1, r24
    160a:	74 f3       	brlt	.-36     	; 0x15e8 <prvUnlockQueue+0x5e>
    160c:	8f ef       	ldi	r24, 0xFF	; 255
    160e:	89 a3       	std	Y+33, r24	; 0x21
    1610:	0f 90       	pop	r0
    1612:	0f be       	out	0x3f, r0	; 63
    1614:	df 91       	pop	r29
    1616:	cf 91       	pop	r28
    1618:	1f 91       	pop	r17
    161a:	0f 91       	pop	r16
    161c:	08 95       	ret

0000161e <xQueueGenericReset>:
    161e:	1f 93       	push	r17
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
    1624:	61 30       	cpi	r22, 0x01	; 1
    1626:	59 f0       	breq	.+22     	; 0x163e <xQueueGenericReset+0x20>
    1628:	fc 01       	movw	r30, r24
    162a:	23 89       	ldd	r18, Z+19	; 0x13
    162c:	30 85       	ldd	r19, Z+8	; 0x08
    162e:	31 11       	cpse	r19, r1
    1630:	2c c0       	rjmp	.+88     	; 0x168a <xQueueGenericReset+0x6c>
    1632:	11 e0       	ldi	r17, 0x01	; 1
    1634:	21 11       	cpse	r18, r1
    1636:	10 e0       	ldi	r17, 0x00	; 0
    1638:	21 11       	cpse	r18, r1
    163a:	28 c0       	rjmp	.+80     	; 0x168c <xQueueGenericReset+0x6e>
    163c:	01 c0       	rjmp	.+2      	; 0x1640 <xQueueGenericReset+0x22>
    163e:	11 e0       	ldi	r17, 0x01	; 1
    1640:	ec 01       	movw	r28, r24
    1642:	48 81       	ld	r20, Y
    1644:	59 81       	ldd	r21, Y+1	; 0x01
    1646:	28 a1       	ldd	r18, Y+32	; 0x20
    1648:	30 e0       	ldi	r19, 0x00	; 0
    164a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    164c:	62 9f       	mul	r22, r18
    164e:	c0 01       	movw	r24, r0
    1650:	63 9f       	mul	r22, r19
    1652:	90 0d       	add	r25, r0
    1654:	11 24       	eor	r1, r1
    1656:	ba 01       	movw	r22, r20
    1658:	68 0f       	add	r22, r24
    165a:	79 1f       	adc	r23, r25
    165c:	6a 83       	std	Y+2, r22	; 0x02
    165e:	7b 83       	std	Y+3, r23	; 0x03
    1660:	1e 8e       	std	Y+30, r1	; 0x1e
    1662:	4c 83       	std	Y+4, r20	; 0x04
    1664:	5d 83       	std	Y+5, r21	; 0x05
    1666:	82 1b       	sub	r24, r18
    1668:	93 0b       	sbc	r25, r19
    166a:	84 0f       	add	r24, r20
    166c:	95 1f       	adc	r25, r21
    166e:	8e 83       	std	Y+6, r24	; 0x06
    1670:	9f 83       	std	Y+7, r25	; 0x07
    1672:	8f ef       	ldi	r24, 0xFF	; 255
    1674:	89 a3       	std	Y+33, r24	; 0x21
    1676:	8a a3       	std	Y+34, r24	; 0x22
    1678:	ce 01       	movw	r24, r28
    167a:	08 96       	adiw	r24, 0x08	; 8
    167c:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1680:	ce 01       	movw	r24, r28
    1682:	43 96       	adiw	r24, 0x13	; 19
    1684:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1688:	01 c0       	rjmp	.+2      	; 0x168c <xQueueGenericReset+0x6e>
    168a:	10 e0       	ldi	r17, 0x00	; 0
    168c:	81 2f       	mov	r24, r17
    168e:	df 91       	pop	r29
    1690:	cf 91       	pop	r28
    1692:	1f 91       	pop	r17
    1694:	08 95       	ret

00001696 <xQueueGenericCreate>:
    1696:	0f 93       	push	r16
    1698:	1f 93       	push	r17
    169a:	cf 93       	push	r28
    169c:	df 93       	push	r29
    169e:	88 23       	and	r24, r24
    16a0:	01 f1       	breq	.+64     	; 0x16e2 <xQueueGenericCreate+0x4c>
    16a2:	06 2f       	mov	r16, r22
    16a4:	18 2f       	mov	r17, r24
    16a6:	83 e2       	ldi	r24, 0x23	; 35
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	0e 94 63 07 	call	0xec6	; 0xec6 <pvPortMalloc>
    16ae:	ec 01       	movw	r28, r24
    16b0:	89 2b       	or	r24, r25
    16b2:	c9 f0       	breq	.+50     	; 0x16e6 <xQueueGenericCreate+0x50>
    16b4:	10 9f       	mul	r17, r16
    16b6:	c0 01       	movw	r24, r0
    16b8:	11 24       	eor	r1, r1
    16ba:	01 96       	adiw	r24, 0x01	; 1
    16bc:	0e 94 63 07 	call	0xec6	; 0xec6 <pvPortMalloc>
    16c0:	88 83       	st	Y, r24
    16c2:	99 83       	std	Y+1, r25	; 0x01
    16c4:	89 2b       	or	r24, r25
    16c6:	39 f0       	breq	.+14     	; 0x16d6 <xQueueGenericCreate+0x40>
    16c8:	1f 8f       	std	Y+31, r17	; 0x1f
    16ca:	08 a3       	std	Y+32, r16	; 0x20
    16cc:	61 e0       	ldi	r22, 0x01	; 1
    16ce:	ce 01       	movw	r24, r28
    16d0:	0e 94 0f 0b 	call	0x161e	; 0x161e <xQueueGenericReset>
    16d4:	08 c0       	rjmp	.+16     	; 0x16e6 <xQueueGenericCreate+0x50>
    16d6:	ce 01       	movw	r24, r28
    16d8:	0e 94 fd 07 	call	0xffa	; 0xffa <vPortFree>
    16dc:	c0 e0       	ldi	r28, 0x00	; 0
    16de:	d0 e0       	ldi	r29, 0x00	; 0
    16e0:	02 c0       	rjmp	.+4      	; 0x16e6 <xQueueGenericCreate+0x50>
    16e2:	c0 e0       	ldi	r28, 0x00	; 0
    16e4:	d0 e0       	ldi	r29, 0x00	; 0
    16e6:	ce 01       	movw	r24, r28
    16e8:	df 91       	pop	r29
    16ea:	cf 91       	pop	r28
    16ec:	1f 91       	pop	r17
    16ee:	0f 91       	pop	r16
    16f0:	08 95       	ret

000016f2 <xQueueGenericSend>:
    16f2:	af 92       	push	r10
    16f4:	bf 92       	push	r11
    16f6:	cf 92       	push	r12
    16f8:	df 92       	push	r13
    16fa:	ef 92       	push	r14
    16fc:	ff 92       	push	r15
    16fe:	0f 93       	push	r16
    1700:	1f 93       	push	r17
    1702:	cf 93       	push	r28
    1704:	df 93       	push	r29
    1706:	cd b7       	in	r28, 0x3d	; 61
    1708:	de b7       	in	r29, 0x3e	; 62
    170a:	29 97       	sbiw	r28, 0x09	; 9
    170c:	cd bf       	out	0x3d, r28	; 61
    170e:	de bf       	out	0x3e, r29	; 62
    1710:	7c 01       	movw	r14, r24
    1712:	5b 01       	movw	r10, r22
    1714:	2e 83       	std	Y+6, r18	; 0x06
    1716:	3f 83       	std	Y+7, r19	; 0x07
    1718:	48 87       	std	Y+8, r20	; 0x08
    171a:	59 87       	std	Y+9, r21	; 0x09
    171c:	10 e0       	ldi	r17, 0x00	; 0
    171e:	6c 01       	movw	r12, r24
    1720:	88 e0       	ldi	r24, 0x08	; 8
    1722:	c8 0e       	add	r12, r24
    1724:	d1 1c       	adc	r13, r1
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	f8 94       	cli
    172a:	0f 92       	push	r0
    172c:	f7 01       	movw	r30, r14
    172e:	96 8d       	ldd	r25, Z+30	; 0x1e
    1730:	87 8d       	ldd	r24, Z+31	; 0x1f
    1732:	98 17       	cp	r25, r24
    1734:	a8 f4       	brcc	.+42     	; 0x1760 <xQueueGenericSend+0x6e>
    1736:	40 2f       	mov	r20, r16
    1738:	b5 01       	movw	r22, r10
    173a:	c7 01       	movw	r24, r14
    173c:	0e 94 5f 0a 	call	0x14be	; 0x14be <prvCopyDataToQueue>
    1740:	f7 01       	movw	r30, r14
    1742:	83 89       	ldd	r24, Z+19	; 0x13
    1744:	88 23       	and	r24, r24
    1746:	41 f0       	breq	.+16     	; 0x1758 <xQueueGenericSend+0x66>
    1748:	c7 01       	movw	r24, r14
    174a:	43 96       	adiw	r24, 0x13	; 19
    174c:	0e 94 3f 11 	call	0x227e	; 0x227e <xTaskRemoveFromEventList>
    1750:	81 30       	cpi	r24, 0x01	; 1
    1752:	11 f4       	brne	.+4      	; 0x1758 <xQueueGenericSend+0x66>
    1754:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    1758:	0f 90       	pop	r0
    175a:	0f be       	out	0x3f, r0	; 63
    175c:	81 e0       	ldi	r24, 0x01	; 1
    175e:	56 c0       	rjmp	.+172    	; 0x180c <xQueueGenericSend+0x11a>
    1760:	8e 81       	ldd	r24, Y+6	; 0x06
    1762:	9f 81       	ldd	r25, Y+7	; 0x07
    1764:	a8 85       	ldd	r26, Y+8	; 0x08
    1766:	b9 85       	ldd	r27, Y+9	; 0x09
    1768:	89 2b       	or	r24, r25
    176a:	8a 2b       	or	r24, r26
    176c:	8b 2b       	or	r24, r27
    176e:	21 f4       	brne	.+8      	; 0x1778 <xQueueGenericSend+0x86>
    1770:	0f 90       	pop	r0
    1772:	0f be       	out	0x3f, r0	; 63
    1774:	80 e0       	ldi	r24, 0x00	; 0
    1776:	4a c0       	rjmp	.+148    	; 0x180c <xQueueGenericSend+0x11a>
    1778:	11 11       	cpse	r17, r1
    177a:	05 c0       	rjmp	.+10     	; 0x1786 <xQueueGenericSend+0x94>
    177c:	ce 01       	movw	r24, r28
    177e:	01 96       	adiw	r24, 0x01	; 1
    1780:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vTaskSetTimeOutState>
    1784:	11 e0       	ldi	r17, 0x01	; 1
    1786:	0f 90       	pop	r0
    1788:	0f be       	out	0x3f, r0	; 63
    178a:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskSuspendAll>
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	0f 92       	push	r0
    1794:	f7 01       	movw	r30, r14
    1796:	81 a1       	ldd	r24, Z+33	; 0x21
    1798:	8f 3f       	cpi	r24, 0xFF	; 255
    179a:	09 f4       	brne	.+2      	; 0x179e <xQueueGenericSend+0xac>
    179c:	11 a2       	std	Z+33, r1	; 0x21
    179e:	f7 01       	movw	r30, r14
    17a0:	82 a1       	ldd	r24, Z+34	; 0x22
    17a2:	8f 3f       	cpi	r24, 0xFF	; 255
    17a4:	09 f4       	brne	.+2      	; 0x17a8 <xQueueGenericSend+0xb6>
    17a6:	12 a2       	std	Z+34, r1	; 0x22
    17a8:	0f 90       	pop	r0
    17aa:	0f be       	out	0x3f, r0	; 63
    17ac:	be 01       	movw	r22, r28
    17ae:	6a 5f       	subi	r22, 0xFA	; 250
    17b0:	7f 4f       	sbci	r23, 0xFF	; 255
    17b2:	ce 01       	movw	r24, r28
    17b4:	01 96       	adiw	r24, 0x01	; 1
    17b6:	0e 94 8f 11 	call	0x231e	; 0x231e <xTaskCheckForTimeOut>
    17ba:	81 11       	cpse	r24, r1
    17bc:	21 c0       	rjmp	.+66     	; 0x1800 <xQueueGenericSend+0x10e>
    17be:	0f b6       	in	r0, 0x3f	; 63
    17c0:	f8 94       	cli
    17c2:	0f 92       	push	r0
    17c4:	f7 01       	movw	r30, r14
    17c6:	96 8d       	ldd	r25, Z+30	; 0x1e
    17c8:	0f 90       	pop	r0
    17ca:	0f be       	out	0x3f, r0	; 63
    17cc:	87 8d       	ldd	r24, Z+31	; 0x1f
    17ce:	98 13       	cpse	r25, r24
    17d0:	11 c0       	rjmp	.+34     	; 0x17f4 <xQueueGenericSend+0x102>
    17d2:	4e 81       	ldd	r20, Y+6	; 0x06
    17d4:	5f 81       	ldd	r21, Y+7	; 0x07
    17d6:	68 85       	ldd	r22, Y+8	; 0x08
    17d8:	79 85       	ldd	r23, Y+9	; 0x09
    17da:	c6 01       	movw	r24, r12
    17dc:	0e 94 15 11 	call	0x222a	; 0x222a <vTaskPlaceOnEventList>
    17e0:	c7 01       	movw	r24, r14
    17e2:	0e 94 c5 0a 	call	0x158a	; 0x158a <prvUnlockQueue>
    17e6:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
    17ea:	81 11       	cpse	r24, r1
    17ec:	9c cf       	rjmp	.-200    	; 0x1726 <xQueueGenericSend+0x34>
    17ee:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    17f2:	99 cf       	rjmp	.-206    	; 0x1726 <xQueueGenericSend+0x34>
    17f4:	c7 01       	movw	r24, r14
    17f6:	0e 94 c5 0a 	call	0x158a	; 0x158a <prvUnlockQueue>
    17fa:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
    17fe:	93 cf       	rjmp	.-218    	; 0x1726 <xQueueGenericSend+0x34>
    1800:	c7 01       	movw	r24, r14
    1802:	0e 94 c5 0a 	call	0x158a	; 0x158a <prvUnlockQueue>
    1806:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
    180a:	80 e0       	ldi	r24, 0x00	; 0
    180c:	29 96       	adiw	r28, 0x09	; 9
    180e:	cd bf       	out	0x3d, r28	; 61
    1810:	de bf       	out	0x3e, r29	; 62
    1812:	df 91       	pop	r29
    1814:	cf 91       	pop	r28
    1816:	1f 91       	pop	r17
    1818:	0f 91       	pop	r16
    181a:	ff 90       	pop	r15
    181c:	ef 90       	pop	r14
    181e:	df 90       	pop	r13
    1820:	cf 90       	pop	r12
    1822:	bf 90       	pop	r11
    1824:	af 90       	pop	r10
    1826:	08 95       	ret

00001828 <xQueueGenericReceive>:
    1828:	af 92       	push	r10
    182a:	bf 92       	push	r11
    182c:	cf 92       	push	r12
    182e:	df 92       	push	r13
    1830:	ef 92       	push	r14
    1832:	ff 92       	push	r15
    1834:	0f 93       	push	r16
    1836:	1f 93       	push	r17
    1838:	cf 93       	push	r28
    183a:	df 93       	push	r29
    183c:	cd b7       	in	r28, 0x3d	; 61
    183e:	de b7       	in	r29, 0x3e	; 62
    1840:	29 97       	sbiw	r28, 0x09	; 9
    1842:	cd bf       	out	0x3d, r28	; 61
    1844:	de bf       	out	0x3e, r29	; 62
    1846:	7c 01       	movw	r14, r24
    1848:	5b 01       	movw	r10, r22
    184a:	2e 83       	std	Y+6, r18	; 0x06
    184c:	3f 83       	std	Y+7, r19	; 0x07
    184e:	48 87       	std	Y+8, r20	; 0x08
    1850:	59 87       	std	Y+9, r21	; 0x09
    1852:	10 e0       	ldi	r17, 0x00	; 0
    1854:	6c 01       	movw	r12, r24
    1856:	83 e1       	ldi	r24, 0x13	; 19
    1858:	c8 0e       	add	r12, r24
    185a:	d1 1c       	adc	r13, r1
    185c:	0f b6       	in	r0, 0x3f	; 63
    185e:	f8 94       	cli
    1860:	0f 92       	push	r0
    1862:	f7 01       	movw	r30, r14
    1864:	86 8d       	ldd	r24, Z+30	; 0x1e
    1866:	88 23       	and	r24, r24
    1868:	99 f1       	breq	.+102    	; 0x18d0 <xQueueGenericReceive+0xa8>
    186a:	c6 80       	ldd	r12, Z+6	; 0x06
    186c:	d7 80       	ldd	r13, Z+7	; 0x07
    186e:	b5 01       	movw	r22, r10
    1870:	c7 01       	movw	r24, r14
    1872:	0e 94 ab 0a 	call	0x1556	; 0x1556 <prvCopyDataFromQueue>
    1876:	01 11       	cpse	r16, r1
    1878:	1a c0       	rjmp	.+52     	; 0x18ae <xQueueGenericReceive+0x86>
    187a:	f7 01       	movw	r30, r14
    187c:	86 8d       	ldd	r24, Z+30	; 0x1e
    187e:	81 50       	subi	r24, 0x01	; 1
    1880:	86 8f       	std	Z+30, r24	; 0x1e
    1882:	80 81       	ld	r24, Z
    1884:	91 81       	ldd	r25, Z+1	; 0x01
    1886:	89 2b       	or	r24, r25
    1888:	29 f4       	brne	.+10     	; 0x1894 <xQueueGenericReceive+0x6c>
    188a:	0e 94 19 12 	call	0x2432	; 0x2432 <xTaskGetCurrentTaskHandle>
    188e:	f7 01       	movw	r30, r14
    1890:	82 83       	std	Z+2, r24	; 0x02
    1892:	93 83       	std	Z+3, r25	; 0x03
    1894:	f7 01       	movw	r30, r14
    1896:	80 85       	ldd	r24, Z+8	; 0x08
    1898:	88 23       	and	r24, r24
    189a:	b1 f0       	breq	.+44     	; 0x18c8 <xQueueGenericReceive+0xa0>
    189c:	c7 01       	movw	r24, r14
    189e:	08 96       	adiw	r24, 0x08	; 8
    18a0:	0e 94 3f 11 	call	0x227e	; 0x227e <xTaskRemoveFromEventList>
    18a4:	81 30       	cpi	r24, 0x01	; 1
    18a6:	81 f4       	brne	.+32     	; 0x18c8 <xQueueGenericReceive+0xa0>
    18a8:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    18ac:	0d c0       	rjmp	.+26     	; 0x18c8 <xQueueGenericReceive+0xa0>
    18ae:	f7 01       	movw	r30, r14
    18b0:	c6 82       	std	Z+6, r12	; 0x06
    18b2:	d7 82       	std	Z+7, r13	; 0x07
    18b4:	83 89       	ldd	r24, Z+19	; 0x13
    18b6:	88 23       	and	r24, r24
    18b8:	39 f0       	breq	.+14     	; 0x18c8 <xQueueGenericReceive+0xa0>
    18ba:	c7 01       	movw	r24, r14
    18bc:	43 96       	adiw	r24, 0x13	; 19
    18be:	0e 94 3f 11 	call	0x227e	; 0x227e <xTaskRemoveFromEventList>
    18c2:	81 11       	cpse	r24, r1
    18c4:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    18c8:	0f 90       	pop	r0
    18ca:	0f be       	out	0x3f, r0	; 63
    18cc:	81 e0       	ldi	r24, 0x01	; 1
    18ce:	62 c0       	rjmp	.+196    	; 0x1994 <xQueueGenericReceive+0x16c>
    18d0:	8e 81       	ldd	r24, Y+6	; 0x06
    18d2:	9f 81       	ldd	r25, Y+7	; 0x07
    18d4:	a8 85       	ldd	r26, Y+8	; 0x08
    18d6:	b9 85       	ldd	r27, Y+9	; 0x09
    18d8:	89 2b       	or	r24, r25
    18da:	8a 2b       	or	r24, r26
    18dc:	8b 2b       	or	r24, r27
    18de:	21 f4       	brne	.+8      	; 0x18e8 <xQueueGenericReceive+0xc0>
    18e0:	0f 90       	pop	r0
    18e2:	0f be       	out	0x3f, r0	; 63
    18e4:	80 e0       	ldi	r24, 0x00	; 0
    18e6:	56 c0       	rjmp	.+172    	; 0x1994 <xQueueGenericReceive+0x16c>
    18e8:	11 11       	cpse	r17, r1
    18ea:	05 c0       	rjmp	.+10     	; 0x18f6 <xQueueGenericReceive+0xce>
    18ec:	ce 01       	movw	r24, r28
    18ee:	01 96       	adiw	r24, 0x01	; 1
    18f0:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vTaskSetTimeOutState>
    18f4:	11 e0       	ldi	r17, 0x01	; 1
    18f6:	0f 90       	pop	r0
    18f8:	0f be       	out	0x3f, r0	; 63
    18fa:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskSuspendAll>
    18fe:	0f b6       	in	r0, 0x3f	; 63
    1900:	f8 94       	cli
    1902:	0f 92       	push	r0
    1904:	f7 01       	movw	r30, r14
    1906:	81 a1       	ldd	r24, Z+33	; 0x21
    1908:	8f 3f       	cpi	r24, 0xFF	; 255
    190a:	09 f4       	brne	.+2      	; 0x190e <xQueueGenericReceive+0xe6>
    190c:	11 a2       	std	Z+33, r1	; 0x21
    190e:	f7 01       	movw	r30, r14
    1910:	82 a1       	ldd	r24, Z+34	; 0x22
    1912:	8f 3f       	cpi	r24, 0xFF	; 255
    1914:	09 f4       	brne	.+2      	; 0x1918 <xQueueGenericReceive+0xf0>
    1916:	12 a2       	std	Z+34, r1	; 0x22
    1918:	0f 90       	pop	r0
    191a:	0f be       	out	0x3f, r0	; 63
    191c:	be 01       	movw	r22, r28
    191e:	6a 5f       	subi	r22, 0xFA	; 250
    1920:	7f 4f       	sbci	r23, 0xFF	; 255
    1922:	ce 01       	movw	r24, r28
    1924:	01 96       	adiw	r24, 0x01	; 1
    1926:	0e 94 8f 11 	call	0x231e	; 0x231e <xTaskCheckForTimeOut>
    192a:	81 11       	cpse	r24, r1
    192c:	2d c0       	rjmp	.+90     	; 0x1988 <xQueueGenericReceive+0x160>
    192e:	0f b6       	in	r0, 0x3f	; 63
    1930:	f8 94       	cli
    1932:	0f 92       	push	r0
    1934:	f7 01       	movw	r30, r14
    1936:	86 8d       	ldd	r24, Z+30	; 0x1e
    1938:	0f 90       	pop	r0
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	81 11       	cpse	r24, r1
    193e:	1e c0       	rjmp	.+60     	; 0x197c <xQueueGenericReceive+0x154>
    1940:	80 81       	ld	r24, Z
    1942:	91 81       	ldd	r25, Z+1	; 0x01
    1944:	89 2b       	or	r24, r25
    1946:	49 f4       	brne	.+18     	; 0x195a <xQueueGenericReceive+0x132>
    1948:	0f b6       	in	r0, 0x3f	; 63
    194a:	f8 94       	cli
    194c:	0f 92       	push	r0
    194e:	82 81       	ldd	r24, Z+2	; 0x02
    1950:	93 81       	ldd	r25, Z+3	; 0x03
    1952:	0e 94 1e 12 	call	0x243c	; 0x243c <vTaskPriorityInherit>
    1956:	0f 90       	pop	r0
    1958:	0f be       	out	0x3f, r0	; 63
    195a:	4e 81       	ldd	r20, Y+6	; 0x06
    195c:	5f 81       	ldd	r21, Y+7	; 0x07
    195e:	68 85       	ldd	r22, Y+8	; 0x08
    1960:	79 85       	ldd	r23, Y+9	; 0x09
    1962:	c6 01       	movw	r24, r12
    1964:	0e 94 15 11 	call	0x222a	; 0x222a <vTaskPlaceOnEventList>
    1968:	c7 01       	movw	r24, r14
    196a:	0e 94 c5 0a 	call	0x158a	; 0x158a <prvUnlockQueue>
    196e:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
    1972:	81 11       	cpse	r24, r1
    1974:	73 cf       	rjmp	.-282    	; 0x185c <xQueueGenericReceive+0x34>
    1976:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    197a:	70 cf       	rjmp	.-288    	; 0x185c <xQueueGenericReceive+0x34>
    197c:	c7 01       	movw	r24, r14
    197e:	0e 94 c5 0a 	call	0x158a	; 0x158a <prvUnlockQueue>
    1982:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
    1986:	6a cf       	rjmp	.-300    	; 0x185c <xQueueGenericReceive+0x34>
    1988:	c7 01       	movw	r24, r14
    198a:	0e 94 c5 0a 	call	0x158a	; 0x158a <prvUnlockQueue>
    198e:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
    1992:	80 e0       	ldi	r24, 0x00	; 0
    1994:	29 96       	adiw	r28, 0x09	; 9
    1996:	cd bf       	out	0x3d, r28	; 61
    1998:	de bf       	out	0x3e, r29	; 62
    199a:	df 91       	pop	r29
    199c:	cf 91       	pop	r28
    199e:	1f 91       	pop	r17
    19a0:	0f 91       	pop	r16
    19a2:	ff 90       	pop	r15
    19a4:	ef 90       	pop	r14
    19a6:	df 90       	pop	r13
    19a8:	cf 90       	pop	r12
    19aa:	bf 90       	pop	r11
    19ac:	af 90       	pop	r10
    19ae:	08 95       	ret

000019b0 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19b0:	0f b6       	in	r0, 0x3f	; 63
    19b2:	f8 94       	cli
    19b4:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    19b6:	fc 01       	movw	r30, r24
    19b8:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    19ba:	0f 90       	pop	r0
    19bc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    19be:	08 95       	ret

000019c0 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    19c0:	c0 e3       	ldi	r28, 0x30	; 48
    19c2:	d1 e3       	ldi	r29, 0x31	; 49
    19c4:	88 81       	ld	r24, Y
    19c6:	82 30       	cpi	r24, 0x02	; 2
    19c8:	e8 f3       	brcs	.-6      	; 0x19c4 <prvIdleTask+0x4>
    19ca:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    19ce:	fa cf       	rjmp	.-12     	; 0x19c4 <prvIdleTask+0x4>

000019d0 <prvAddCurrentTaskToDelayedList>:
    19d0:	cf 92       	push	r12
    19d2:	df 92       	push	r13
    19d4:	ef 92       	push	r14
    19d6:	ff 92       	push	r15
    19d8:	6b 01       	movw	r12, r22
    19da:	7c 01       	movw	r14, r24
    19dc:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <pxCurrentTCB>
    19e0:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    19e4:	62 83       	std	Z+2, r22	; 0x02
    19e6:	73 83       	std	Z+3, r23	; 0x03
    19e8:	84 83       	std	Z+4, r24	; 0x04
    19ea:	95 83       	std	Z+5, r25	; 0x05
    19ec:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    19f0:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    19f4:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    19f8:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
    19fc:	c8 16       	cp	r12, r24
    19fe:	d9 06       	cpc	r13, r25
    1a00:	ea 06       	cpc	r14, r26
    1a02:	fb 06       	cpc	r15, r27
    1a04:	68 f4       	brcc	.+26     	; 0x1a20 <prvAddCurrentTaskToDelayedList+0x50>
    1a06:	60 91 5c 31 	lds	r22, 0x315C	; 0x80315c <pxCurrentTCB>
    1a0a:	70 91 5d 31 	lds	r23, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1a0e:	80 91 16 31 	lds	r24, 0x3116	; 0x803116 <pxOverflowDelayedTaskList>
    1a12:	90 91 17 31 	lds	r25, 0x3117	; 0x803117 <pxOverflowDelayedTaskList+0x1>
    1a16:	6e 5f       	subi	r22, 0xFE	; 254
    1a18:	7f 4f       	sbci	r23, 0xFF	; 255
    1a1a:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vListInsert>
    1a1e:	21 c0       	rjmp	.+66     	; 0x1a62 <prvAddCurrentTaskToDelayedList+0x92>
    1a20:	60 91 5c 31 	lds	r22, 0x315C	; 0x80315c <pxCurrentTCB>
    1a24:	70 91 5d 31 	lds	r23, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1a28:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxDelayedTaskList>
    1a2c:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxDelayedTaskList+0x1>
    1a30:	6e 5f       	subi	r22, 0xFE	; 254
    1a32:	7f 4f       	sbci	r23, 0xFF	; 255
    1a34:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vListInsert>
    1a38:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1a3c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1a40:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1a44:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1a48:	c8 16       	cp	r12, r24
    1a4a:	d9 06       	cpc	r13, r25
    1a4c:	ea 06       	cpc	r14, r26
    1a4e:	fb 06       	cpc	r15, r27
    1a50:	40 f4       	brcc	.+16     	; 0x1a62 <prvAddCurrentTaskToDelayedList+0x92>
    1a52:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1a56:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1a5a:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1a5e:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1a62:	ff 90       	pop	r15
    1a64:	ef 90       	pop	r14
    1a66:	df 90       	pop	r13
    1a68:	cf 90       	pop	r12
    1a6a:	08 95       	ret

00001a6c <xTaskGenericCreate>:
    1a6c:	4f 92       	push	r4
    1a6e:	5f 92       	push	r5
    1a70:	6f 92       	push	r6
    1a72:	7f 92       	push	r7
    1a74:	8f 92       	push	r8
    1a76:	9f 92       	push	r9
    1a78:	af 92       	push	r10
    1a7a:	bf 92       	push	r11
    1a7c:	cf 92       	push	r12
    1a7e:	df 92       	push	r13
    1a80:	ef 92       	push	r14
    1a82:	ff 92       	push	r15
    1a84:	0f 93       	push	r16
    1a86:	1f 93       	push	r17
    1a88:	cf 93       	push	r28
    1a8a:	df 93       	push	r29
    1a8c:	5c 01       	movw	r10, r24
    1a8e:	4b 01       	movw	r8, r22
    1a90:	3a 01       	movw	r6, r20
    1a92:	29 01       	movw	r4, r18
    1a94:	88 e2       	ldi	r24, 0x28	; 40
    1a96:	90 e0       	ldi	r25, 0x00	; 0
    1a98:	0e 94 63 07 	call	0xec6	; 0xec6 <pvPortMalloc>
    1a9c:	ec 01       	movw	r28, r24
    1a9e:	89 2b       	or	r24, r25
    1aa0:	09 f4       	brne	.+2      	; 0x1aa4 <xTaskGenericCreate+0x38>
    1aa2:	d4 c0       	rjmp	.+424    	; 0x1c4c <xTaskGenericCreate+0x1e0>
    1aa4:	c1 14       	cp	r12, r1
    1aa6:	d1 04       	cpc	r13, r1
    1aa8:	09 f0       	breq	.+2      	; 0x1aac <xTaskGenericCreate+0x40>
    1aaa:	cc c0       	rjmp	.+408    	; 0x1c44 <xTaskGenericCreate+0x1d8>
    1aac:	c3 01       	movw	r24, r6
    1aae:	0e 94 63 07 	call	0xec6	; 0xec6 <pvPortMalloc>
    1ab2:	8b 8f       	std	Y+27, r24	; 0x1b
    1ab4:	9c 8f       	std	Y+28, r25	; 0x1c
    1ab6:	00 97       	sbiw	r24, 0x00	; 0
    1ab8:	21 f4       	brne	.+8      	; 0x1ac2 <xTaskGenericCreate+0x56>
    1aba:	ce 01       	movw	r24, r28
    1abc:	0e 94 fd 07 	call	0xffa	; 0xffa <vPortFree>
    1ac0:	c5 c0       	rjmp	.+394    	; 0x1c4c <xTaskGenericCreate+0x1e0>
    1ac2:	a3 01       	movw	r20, r6
    1ac4:	61 e1       	ldi	r22, 0x11	; 17
    1ac6:	70 e0       	ldi	r23, 0x00	; 0
    1ac8:	0e 94 5f 20 	call	0x40be	; 0x40be <memset>
    1acc:	93 01       	movw	r18, r6
    1ace:	21 50       	subi	r18, 0x01	; 1
    1ad0:	31 09       	sbc	r19, r1
    1ad2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ad4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1ad6:	3c 01       	movw	r6, r24
    1ad8:	62 0e       	add	r6, r18
    1ada:	73 1e       	adc	r7, r19
    1adc:	4a e0       	ldi	r20, 0x0A	; 10
    1ade:	50 e0       	ldi	r21, 0x00	; 0
    1ae0:	b4 01       	movw	r22, r8
    1ae2:	ce 01       	movw	r24, r28
    1ae4:	4d 96       	adiw	r24, 0x1d	; 29
    1ae6:	0e 94 66 20 	call	0x40cc	; 0x40cc <strncpy>
    1aea:	1e a2       	std	Y+38, r1	; 0x26
    1aec:	10 2f       	mov	r17, r16
    1aee:	04 30       	cpi	r16, 0x04	; 4
    1af0:	08 f0       	brcs	.+2      	; 0x1af4 <xTaskGenericCreate+0x88>
    1af2:	13 e0       	ldi	r17, 0x03	; 3
    1af4:	1a 8f       	std	Y+26, r17	; 0x1a
    1af6:	1f a3       	std	Y+39, r17	; 0x27
    1af8:	6e 01       	movw	r12, r28
    1afa:	22 e0       	ldi	r18, 0x02	; 2
    1afc:	c2 0e       	add	r12, r18
    1afe:	d1 1c       	adc	r13, r1
    1b00:	c6 01       	movw	r24, r12
    1b02:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialiseItem>
    1b06:	ce 01       	movw	r24, r28
    1b08:	0e 96       	adiw	r24, 0x0e	; 14
    1b0a:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialiseItem>
    1b0e:	ca 87       	std	Y+10, r28	; 0x0a
    1b10:	db 87       	std	Y+11, r29	; 0x0b
    1b12:	84 e0       	ldi	r24, 0x04	; 4
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	a0 e0       	ldi	r26, 0x00	; 0
    1b18:	b0 e0       	ldi	r27, 0x00	; 0
    1b1a:	81 1b       	sub	r24, r17
    1b1c:	91 09       	sbc	r25, r1
    1b1e:	a1 09       	sbc	r26, r1
    1b20:	b1 09       	sbc	r27, r1
    1b22:	8e 87       	std	Y+14, r24	; 0x0e
    1b24:	9f 87       	std	Y+15, r25	; 0x0f
    1b26:	a8 8b       	std	Y+16, r26	; 0x10
    1b28:	b9 8b       	std	Y+17, r27	; 0x11
    1b2a:	ce 8b       	std	Y+22, r28	; 0x16
    1b2c:	df 8b       	std	Y+23, r29	; 0x17
    1b2e:	a2 01       	movw	r20, r4
    1b30:	b5 01       	movw	r22, r10
    1b32:	c3 01       	movw	r24, r6
    1b34:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <pxPortInitialiseStack>
    1b38:	88 83       	st	Y, r24
    1b3a:	99 83       	std	Y+1, r25	; 0x01
    1b3c:	e1 14       	cp	r14, r1
    1b3e:	f1 04       	cpc	r15, r1
    1b40:	19 f0       	breq	.+6      	; 0x1b48 <xTaskGenericCreate+0xdc>
    1b42:	f7 01       	movw	r30, r14
    1b44:	c0 83       	st	Z, r28
    1b46:	d1 83       	std	Z+1, r29	; 0x01
    1b48:	0f b6       	in	r0, 0x3f	; 63
    1b4a:	f8 94       	cli
    1b4c:	0f 92       	push	r0
    1b4e:	80 91 08 31 	lds	r24, 0x3108	; 0x803108 <uxCurrentNumberOfTasks>
    1b52:	8f 5f       	subi	r24, 0xFF	; 255
    1b54:	80 93 08 31 	sts	0x3108, r24	; 0x803108 <uxCurrentNumberOfTasks>
    1b58:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <pxCurrentTCB>
    1b5c:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1b60:	89 2b       	or	r24, r25
    1b62:	89 f5       	brne	.+98     	; 0x1bc6 <xTaskGenericCreate+0x15a>
    1b64:	c0 93 5c 31 	sts	0x315C, r28	; 0x80315c <pxCurrentTCB>
    1b68:	d0 93 5d 31 	sts	0x315D, r29	; 0x80315d <pxCurrentTCB+0x1>
    1b6c:	80 91 08 31 	lds	r24, 0x3108	; 0x803108 <uxCurrentNumberOfTasks>
    1b70:	81 30       	cpi	r24, 0x01	; 1
    1b72:	c1 f5       	brne	.+112    	; 0x1be4 <xTaskGenericCreate+0x178>
    1b74:	80 e3       	ldi	r24, 0x30	; 48
    1b76:	91 e3       	ldi	r25, 0x31	; 49
    1b78:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1b7c:	8b e3       	ldi	r24, 0x3B	; 59
    1b7e:	91 e3       	ldi	r25, 0x31	; 49
    1b80:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1b84:	86 e4       	ldi	r24, 0x46	; 70
    1b86:	91 e3       	ldi	r25, 0x31	; 49
    1b88:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1b8c:	81 e5       	ldi	r24, 0x51	; 81
    1b8e:	91 e3       	ldi	r25, 0x31	; 49
    1b90:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1b94:	85 e2       	ldi	r24, 0x25	; 37
    1b96:	91 e3       	ldi	r25, 0x31	; 49
    1b98:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1b9c:	8a e1       	ldi	r24, 0x1A	; 26
    1b9e:	91 e3       	ldi	r25, 0x31	; 49
    1ba0:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1ba4:	8b e0       	ldi	r24, 0x0B	; 11
    1ba6:	91 e3       	ldi	r25, 0x31	; 49
    1ba8:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
    1bac:	85 e2       	ldi	r24, 0x25	; 37
    1bae:	91 e3       	ldi	r25, 0x31	; 49
    1bb0:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <pxDelayedTaskList>
    1bb4:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <pxDelayedTaskList+0x1>
    1bb8:	8a e1       	ldi	r24, 0x1A	; 26
    1bba:	91 e3       	ldi	r25, 0x31	; 49
    1bbc:	80 93 16 31 	sts	0x3116, r24	; 0x803116 <pxOverflowDelayedTaskList>
    1bc0:	90 93 17 31 	sts	0x3117, r25	; 0x803117 <pxOverflowDelayedTaskList+0x1>
    1bc4:	0f c0       	rjmp	.+30     	; 0x1be4 <xTaskGenericCreate+0x178>
    1bc6:	80 91 01 31 	lds	r24, 0x3101	; 0x803101 <xSchedulerRunning>
    1bca:	81 11       	cpse	r24, r1
    1bcc:	0b c0       	rjmp	.+22     	; 0x1be4 <xTaskGenericCreate+0x178>
    1bce:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <pxCurrentTCB>
    1bd2:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1bd6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bd8:	08 17       	cp	r16, r24
    1bda:	20 f0       	brcs	.+8      	; 0x1be4 <xTaskGenericCreate+0x178>
    1bdc:	c0 93 5c 31 	sts	0x315C, r28	; 0x80315c <pxCurrentTCB>
    1be0:	d0 93 5d 31 	sts	0x315D, r29	; 0x80315d <pxCurrentTCB+0x1>
    1be4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1be6:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <uxTopUsedPriority>
    1bea:	98 17       	cp	r25, r24
    1bec:	10 f4       	brcc	.+4      	; 0x1bf2 <xTaskGenericCreate+0x186>
    1bee:	80 93 03 31 	sts	0x3103, r24	; 0x803103 <uxTopUsedPriority>
    1bf2:	90 91 fc 30 	lds	r25, 0x30FC	; 0x8030fc <uxTaskNumber>
    1bf6:	9f 5f       	subi	r25, 0xFF	; 255
    1bf8:	90 93 fc 30 	sts	0x30FC, r25	; 0x8030fc <uxTaskNumber>
    1bfc:	90 91 02 31 	lds	r25, 0x3102	; 0x803102 <uxTopReadyPriority>
    1c00:	98 17       	cp	r25, r24
    1c02:	10 f4       	brcc	.+4      	; 0x1c08 <xTaskGenericCreate+0x19c>
    1c04:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxTopReadyPriority>
    1c08:	fb e0       	ldi	r31, 0x0B	; 11
    1c0a:	8f 9f       	mul	r24, r31
    1c0c:	c0 01       	movw	r24, r0
    1c0e:	11 24       	eor	r1, r1
    1c10:	b6 01       	movw	r22, r12
    1c12:	80 5d       	subi	r24, 0xD0	; 208
    1c14:	9e 4c       	sbci	r25, 0xCE	; 206
    1c16:	0e 94 4a 08 	call	0x1094	; 0x1094 <vListInsertEnd>
    1c1a:	0f 90       	pop	r0
    1c1c:	0f be       	out	0x3f, r0	; 63
    1c1e:	80 91 01 31 	lds	r24, 0x3101	; 0x803101 <xSchedulerRunning>
    1c22:	88 23       	and	r24, r24
    1c24:	59 f0       	breq	.+22     	; 0x1c3c <xTaskGenericCreate+0x1d0>
    1c26:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <pxCurrentTCB>
    1c2a:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1c2e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c30:	80 17       	cp	r24, r16
    1c32:	30 f4       	brcc	.+12     	; 0x1c40 <xTaskGenericCreate+0x1d4>
    1c34:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
    1c38:	81 e0       	ldi	r24, 0x01	; 1
    1c3a:	09 c0       	rjmp	.+18     	; 0x1c4e <xTaskGenericCreate+0x1e2>
    1c3c:	81 e0       	ldi	r24, 0x01	; 1
    1c3e:	07 c0       	rjmp	.+14     	; 0x1c4e <xTaskGenericCreate+0x1e2>
    1c40:	81 e0       	ldi	r24, 0x01	; 1
    1c42:	05 c0       	rjmp	.+10     	; 0x1c4e <xTaskGenericCreate+0x1e2>
    1c44:	cb 8e       	std	Y+27, r12	; 0x1b
    1c46:	dc 8e       	std	Y+28, r13	; 0x1c
    1c48:	c6 01       	movw	r24, r12
    1c4a:	3b cf       	rjmp	.-394    	; 0x1ac2 <xTaskGenericCreate+0x56>
    1c4c:	8f ef       	ldi	r24, 0xFF	; 255
    1c4e:	df 91       	pop	r29
    1c50:	cf 91       	pop	r28
    1c52:	1f 91       	pop	r17
    1c54:	0f 91       	pop	r16
    1c56:	ff 90       	pop	r15
    1c58:	ef 90       	pop	r14
    1c5a:	df 90       	pop	r13
    1c5c:	cf 90       	pop	r12
    1c5e:	bf 90       	pop	r11
    1c60:	af 90       	pop	r10
    1c62:	9f 90       	pop	r9
    1c64:	8f 90       	pop	r8
    1c66:	7f 90       	pop	r7
    1c68:	6f 90       	pop	r6
    1c6a:	5f 90       	pop	r5
    1c6c:	4f 90       	pop	r4
    1c6e:	08 95       	ret

00001c70 <uxTaskPriorityGet>:
    1c70:	0f b6       	in	r0, 0x3f	; 63
    1c72:	f8 94       	cli
    1c74:	0f 92       	push	r0
    1c76:	00 97       	sbiw	r24, 0x00	; 0
    1c78:	21 f4       	brne	.+8      	; 0x1c82 <uxTaskPriorityGet+0x12>
    1c7a:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <pxCurrentTCB>
    1c7e:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1c82:	0f 90       	pop	r0
    1c84:	0f be       	out	0x3f, r0	; 63
    1c86:	fc 01       	movw	r30, r24
    1c88:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c8a:	08 95       	ret

00001c8c <vTaskStartScheduler>:
    1c8c:	af 92       	push	r10
    1c8e:	bf 92       	push	r11
    1c90:	cf 92       	push	r12
    1c92:	df 92       	push	r13
    1c94:	ef 92       	push	r14
    1c96:	ff 92       	push	r15
    1c98:	0f 93       	push	r16
    1c9a:	a1 2c       	mov	r10, r1
    1c9c:	b1 2c       	mov	r11, r1
    1c9e:	c1 2c       	mov	r12, r1
    1ca0:	d1 2c       	mov	r13, r1
    1ca2:	0f 2e       	mov	r0, r31
    1ca4:	f9 e0       	ldi	r31, 0x09	; 9
    1ca6:	ef 2e       	mov	r14, r31
    1ca8:	f1 e3       	ldi	r31, 0x31	; 49
    1caa:	ff 2e       	mov	r15, r31
    1cac:	f0 2d       	mov	r31, r0
    1cae:	00 e0       	ldi	r16, 0x00	; 0
    1cb0:	20 e0       	ldi	r18, 0x00	; 0
    1cb2:	30 e0       	ldi	r19, 0x00	; 0
    1cb4:	44 e6       	ldi	r20, 0x64	; 100
    1cb6:	50 e0       	ldi	r21, 0x00	; 0
    1cb8:	68 e6       	ldi	r22, 0x68	; 104
    1cba:	70 e2       	ldi	r23, 0x20	; 32
    1cbc:	80 ee       	ldi	r24, 0xE0	; 224
    1cbe:	9c e0       	ldi	r25, 0x0C	; 12
    1cc0:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <xTaskGenericCreate>
    1cc4:	81 30       	cpi	r24, 0x01	; 1
    1cc6:	69 f4       	brne	.+26     	; 0x1ce2 <vTaskStartScheduler+0x56>
    1cc8:	f8 94       	cli
    1cca:	80 93 01 31 	sts	0x3101, r24	; 0x803101 <xSchedulerRunning>
    1cce:	10 92 04 31 	sts	0x3104, r1	; 0x803104 <xTickCount>
    1cd2:	10 92 05 31 	sts	0x3105, r1	; 0x803105 <xTickCount+0x1>
    1cd6:	10 92 06 31 	sts	0x3106, r1	; 0x803106 <xTickCount+0x2>
    1cda:	10 92 07 31 	sts	0x3107, r1	; 0x803107 <xTickCount+0x3>
    1cde:	0e 94 58 09 	call	0x12b0	; 0x12b0 <xPortStartScheduler>
    1ce2:	0f 91       	pop	r16
    1ce4:	ff 90       	pop	r15
    1ce6:	ef 90       	pop	r14
    1ce8:	df 90       	pop	r13
    1cea:	cf 90       	pop	r12
    1cec:	bf 90       	pop	r11
    1cee:	af 90       	pop	r10
    1cf0:	08 95       	ret

00001cf2 <vTaskSuspendAll>:
    1cf2:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <uxSchedulerSuspended>
    1cf6:	8f 5f       	subi	r24, 0xFF	; 255
    1cf8:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxSchedulerSuspended>
    1cfc:	08 95       	ret

00001cfe <xTaskGetTickCount>:
    1cfe:	0f b6       	in	r0, 0x3f	; 63
    1d00:	f8 94       	cli
    1d02:	0f 92       	push	r0
    1d04:	60 91 04 31 	lds	r22, 0x3104	; 0x803104 <xTickCount>
    1d08:	70 91 05 31 	lds	r23, 0x3105	; 0x803105 <xTickCount+0x1>
    1d0c:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount+0x2>
    1d10:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x3>
    1d14:	0f 90       	pop	r0
    1d16:	0f be       	out	0x3f, r0	; 63
    1d18:	08 95       	ret

00001d1a <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1d1a:	00 97       	sbiw	r24, 0x00	; 0
    1d1c:	21 f4       	brne	.+8      	; 0x1d26 <pcTaskGetTaskName+0xc>
    1d1e:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <pxCurrentTCB>
    1d22:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1d26:	4d 96       	adiw	r24, 0x1d	; 29
    1d28:	08 95       	ret

00001d2a <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1d2a:	80 91 09 31 	lds	r24, 0x3109	; 0x803109 <xIdleTaskHandle>
    1d2e:	90 91 0a 31 	lds	r25, 0x310A	; 0x80310a <xIdleTaskHandle+0x1>
    1d32:	08 95       	ret

00001d34 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1d34:	ff 92       	push	r15
    1d36:	0f 93       	push	r16
    1d38:	1f 93       	push	r17
    1d3a:	cf 93       	push	r28
    1d3c:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1d3e:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <uxSchedulerSuspended>
    1d42:	81 11       	cpse	r24, r1
    1d44:	ed c0       	rjmp	.+474    	; 0x1f20 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    1d46:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    1d4a:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    1d4e:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    1d52:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
    1d56:	01 96       	adiw	r24, 0x01	; 1
    1d58:	a1 1d       	adc	r26, r1
    1d5a:	b1 1d       	adc	r27, r1
    1d5c:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <xTickCount>
    1d60:	90 93 05 31 	sts	0x3105, r25	; 0x803105 <xTickCount+0x1>
    1d64:	a0 93 06 31 	sts	0x3106, r26	; 0x803106 <xTickCount+0x2>
    1d68:	b0 93 07 31 	sts	0x3107, r27	; 0x803107 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    1d6c:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    1d70:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    1d74:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    1d78:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
    1d7c:	89 2b       	or	r24, r25
    1d7e:	8a 2b       	or	r24, r26
    1d80:	8b 2b       	or	r24, r27
    1d82:	f1 f5       	brne	.+124    	; 0x1e00 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1d84:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxDelayedTaskList>
    1d88:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1d8c:	20 91 16 31 	lds	r18, 0x3116	; 0x803116 <pxOverflowDelayedTaskList>
    1d90:	30 91 17 31 	lds	r19, 0x3117	; 0x803117 <pxOverflowDelayedTaskList+0x1>
    1d94:	20 93 18 31 	sts	0x3118, r18	; 0x803118 <pxDelayedTaskList>
    1d98:	30 93 19 31 	sts	0x3119, r19	; 0x803119 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    1d9c:	80 93 16 31 	sts	0x3116, r24	; 0x803116 <pxOverflowDelayedTaskList>
    1da0:	90 93 17 31 	sts	0x3117, r25	; 0x803117 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    1da4:	80 91 fd 30 	lds	r24, 0x30FD	; 0x8030fd <xNumOfOverflows>
    1da8:	8f 5f       	subi	r24, 0xFF	; 255
    1daa:	80 93 fd 30 	sts	0x30FD, r24	; 0x8030fd <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1dae:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxDelayedTaskList>
    1db2:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxDelayedTaskList+0x1>
    1db6:	80 81       	ld	r24, Z
    1db8:	81 11       	cpse	r24, r1
    1dba:	0c c0       	rjmp	.+24     	; 0x1dd4 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1dbc:	8f ef       	ldi	r24, 0xFF	; 255
    1dbe:	9f ef       	ldi	r25, 0xFF	; 255
    1dc0:	dc 01       	movw	r26, r24
    1dc2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1dc6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dca:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dce:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dd2:	16 c0       	rjmp	.+44     	; 0x1e00 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1dd4:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxDelayedTaskList>
    1dd8:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxDelayedTaskList+0x1>
    1ddc:	07 80       	ldd	r0, Z+7	; 0x07
    1dde:	f0 85       	ldd	r31, Z+8	; 0x08
    1de0:	e0 2d       	mov	r30, r0
    1de2:	00 84       	ldd	r0, Z+8	; 0x08
    1de4:	f1 85       	ldd	r31, Z+9	; 0x09
    1de6:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1de8:	82 81       	ldd	r24, Z+2	; 0x02
    1dea:	93 81       	ldd	r25, Z+3	; 0x03
    1dec:	a4 81       	ldd	r26, Z+4	; 0x04
    1dee:	b5 81       	ldd	r27, Z+5	; 0x05
    1df0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1df4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1df8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dfc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1e00:	40 91 04 31 	lds	r20, 0x3104	; 0x803104 <xTickCount>
    1e04:	50 91 05 31 	lds	r21, 0x3105	; 0x803105 <xTickCount+0x1>
    1e08:	60 91 06 31 	lds	r22, 0x3106	; 0x803106 <xTickCount+0x2>
    1e0c:	70 91 07 31 	lds	r23, 0x3107	; 0x803107 <xTickCount+0x3>
    1e10:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e14:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e18:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e1c:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e20:	48 17       	cp	r20, r24
    1e22:	59 07       	cpc	r21, r25
    1e24:	6a 07       	cpc	r22, r26
    1e26:	7b 07       	cpc	r23, r27
    1e28:	08 f4       	brcc	.+2      	; 0x1e2c <vTaskIncrementTick+0xf8>
    1e2a:	7f c0       	rjmp	.+254    	; 0x1f2a <vTaskIncrementTick+0x1f6>
    1e2c:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxDelayedTaskList>
    1e30:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxDelayedTaskList+0x1>
    1e34:	80 81       	ld	r24, Z
    1e36:	88 23       	and	r24, r24
    1e38:	f9 f0       	breq	.+62     	; 0x1e78 <vTaskIncrementTick+0x144>
    1e3a:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxDelayedTaskList>
    1e3e:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxDelayedTaskList+0x1>
    1e42:	07 80       	ldd	r0, Z+7	; 0x07
    1e44:	f0 85       	ldd	r31, Z+8	; 0x08
    1e46:	e0 2d       	mov	r30, r0
    1e48:	c0 85       	ldd	r28, Z+8	; 0x08
    1e4a:	d1 85       	ldd	r29, Z+9	; 0x09
    1e4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e4e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e50:	ac 81       	ldd	r26, Y+4	; 0x04
    1e52:	bd 81       	ldd	r27, Y+5	; 0x05
    1e54:	40 91 04 31 	lds	r20, 0x3104	; 0x803104 <xTickCount>
    1e58:	50 91 05 31 	lds	r21, 0x3105	; 0x803105 <xTickCount+0x1>
    1e5c:	60 91 06 31 	lds	r22, 0x3106	; 0x803106 <xTickCount+0x2>
    1e60:	70 91 07 31 	lds	r23, 0x3107	; 0x803107 <xTickCount+0x3>
    1e64:	48 17       	cp	r20, r24
    1e66:	59 07       	cpc	r21, r25
    1e68:	6a 07       	cpc	r22, r26
    1e6a:	7b 07       	cpc	r23, r27
    1e6c:	58 f1       	brcs	.+86     	; 0x1ec4 <vTaskIncrementTick+0x190>
    1e6e:	0f 2e       	mov	r0, r31
    1e70:	fb e0       	ldi	r31, 0x0B	; 11
    1e72:	ff 2e       	mov	r15, r31
    1e74:	f0 2d       	mov	r31, r0
    1e76:	2f c0       	rjmp	.+94     	; 0x1ed6 <vTaskIncrementTick+0x1a2>
    1e78:	8f ef       	ldi	r24, 0xFF	; 255
    1e7a:	9f ef       	ldi	r25, 0xFF	; 255
    1e7c:	dc 01       	movw	r26, r24
    1e7e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1e82:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e86:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e8a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e8e:	4d c0       	rjmp	.+154    	; 0x1f2a <vTaskIncrementTick+0x1f6>
    1e90:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxDelayedTaskList>
    1e94:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxDelayedTaskList+0x1>
    1e98:	07 80       	ldd	r0, Z+7	; 0x07
    1e9a:	f0 85       	ldd	r31, Z+8	; 0x08
    1e9c:	e0 2d       	mov	r30, r0
    1e9e:	c0 85       	ldd	r28, Z+8	; 0x08
    1ea0:	d1 85       	ldd	r29, Z+9	; 0x09
    1ea2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ea6:	ac 81       	ldd	r26, Y+4	; 0x04
    1ea8:	bd 81       	ldd	r27, Y+5	; 0x05
    1eaa:	40 91 04 31 	lds	r20, 0x3104	; 0x803104 <xTickCount>
    1eae:	50 91 05 31 	lds	r21, 0x3105	; 0x803105 <xTickCount+0x1>
    1eb2:	60 91 06 31 	lds	r22, 0x3106	; 0x803106 <xTickCount+0x2>
    1eb6:	70 91 07 31 	lds	r23, 0x3107	; 0x803107 <xTickCount+0x3>
    1eba:	48 17       	cp	r20, r24
    1ebc:	59 07       	cpc	r21, r25
    1ebe:	6a 07       	cpc	r22, r26
    1ec0:	7b 07       	cpc	r23, r27
    1ec2:	48 f4       	brcc	.+18     	; 0x1ed6 <vTaskIncrementTick+0x1a2>
    1ec4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1ec8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ecc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ed0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1ed4:	2a c0       	rjmp	.+84     	; 0x1f2a <vTaskIncrementTick+0x1f6>
    1ed6:	8e 01       	movw	r16, r28
    1ed8:	0e 5f       	subi	r16, 0xFE	; 254
    1eda:	1f 4f       	sbci	r17, 0xFF	; 255
    1edc:	c8 01       	movw	r24, r16
    1ede:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>
    1ee2:	88 8d       	ldd	r24, Y+24	; 0x18
    1ee4:	99 8d       	ldd	r25, Y+25	; 0x19
    1ee6:	89 2b       	or	r24, r25
    1ee8:	21 f0       	breq	.+8      	; 0x1ef2 <vTaskIncrementTick+0x1be>
    1eea:	ce 01       	movw	r24, r28
    1eec:	0e 96       	adiw	r24, 0x0e	; 14
    1eee:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>
    1ef2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ef4:	90 91 02 31 	lds	r25, 0x3102	; 0x803102 <uxTopReadyPriority>
    1ef8:	98 17       	cp	r25, r24
    1efa:	10 f4       	brcc	.+4      	; 0x1f00 <vTaskIncrementTick+0x1cc>
    1efc:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxTopReadyPriority>
    1f00:	f8 9e       	mul	r15, r24
    1f02:	c0 01       	movw	r24, r0
    1f04:	11 24       	eor	r1, r1
    1f06:	b8 01       	movw	r22, r16
    1f08:	80 5d       	subi	r24, 0xD0	; 208
    1f0a:	9e 4c       	sbci	r25, 0xCE	; 206
    1f0c:	0e 94 4a 08 	call	0x1094	; 0x1094 <vListInsertEnd>
    1f10:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxDelayedTaskList>
    1f14:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxDelayedTaskList+0x1>
    1f18:	80 81       	ld	r24, Z
    1f1a:	81 11       	cpse	r24, r1
    1f1c:	b9 cf       	rjmp	.-142    	; 0x1e90 <vTaskIncrementTick+0x15c>
    1f1e:	ac cf       	rjmp	.-168    	; 0x1e78 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    1f20:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <uxMissedTicks>
    1f24:	8f 5f       	subi	r24, 0xFF	; 255
    1f26:	80 93 ff 30 	sts	0x30FF, r24	; 0x8030ff <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1f2a:	df 91       	pop	r29
    1f2c:	cf 91       	pop	r28
    1f2e:	1f 91       	pop	r17
    1f30:	0f 91       	pop	r16
    1f32:	ff 90       	pop	r15
    1f34:	08 95       	ret

00001f36 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1f36:	cf 92       	push	r12
    1f38:	df 92       	push	r13
    1f3a:	ef 92       	push	r14
    1f3c:	ff 92       	push	r15
    1f3e:	0f 93       	push	r16
    1f40:	1f 93       	push	r17
    1f42:	cf 93       	push	r28
    1f44:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1f46:	0f b6       	in	r0, 0x3f	; 63
    1f48:	f8 94       	cli
    1f4a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1f4c:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <uxSchedulerSuspended>
    1f50:	81 50       	subi	r24, 0x01	; 1
    1f52:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f56:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <uxSchedulerSuspended>
    1f5a:	81 11       	cpse	r24, r1
    1f5c:	60 c0       	rjmp	.+192    	; 0x201e <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1f5e:	80 91 08 31 	lds	r24, 0x3108	; 0x803108 <uxCurrentNumberOfTasks>
    1f62:	81 11       	cpse	r24, r1
    1f64:	2c c0       	rjmp	.+88     	; 0x1fbe <xTaskResumeAll+0x88>
    1f66:	5e c0       	rjmp	.+188    	; 0x2024 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1f68:	d7 01       	movw	r26, r14
    1f6a:	17 96       	adiw	r26, 0x07	; 7
    1f6c:	ed 91       	ld	r30, X+
    1f6e:	fc 91       	ld	r31, X
    1f70:	18 97       	sbiw	r26, 0x08	; 8
    1f72:	c0 85       	ldd	r28, Z+8	; 0x08
    1f74:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    1f76:	ce 01       	movw	r24, r28
    1f78:	0e 96       	adiw	r24, 0x0e	; 14
    1f7a:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1f7e:	8e 01       	movw	r16, r28
    1f80:	0e 5f       	subi	r16, 0xFE	; 254
    1f82:	1f 4f       	sbci	r17, 0xFF	; 255
    1f84:	c8 01       	movw	r24, r16
    1f86:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1f8a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f8c:	90 91 02 31 	lds	r25, 0x3102	; 0x803102 <uxTopReadyPriority>
    1f90:	98 17       	cp	r25, r24
    1f92:	10 f4       	brcc	.+4      	; 0x1f98 <xTaskResumeAll+0x62>
    1f94:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxTopReadyPriority>
    1f98:	d8 9e       	mul	r13, r24
    1f9a:	c0 01       	movw	r24, r0
    1f9c:	11 24       	eor	r1, r1
    1f9e:	b8 01       	movw	r22, r16
    1fa0:	80 5d       	subi	r24, 0xD0	; 208
    1fa2:	9e 4c       	sbci	r25, 0xCE	; 206
    1fa4:	0e 94 4a 08 	call	0x1094	; 0x1094 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1fa8:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <pxCurrentTCB>
    1fac:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    1fb0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1fb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb4:	98 17       	cp	r25, r24
    1fb6:	70 f0       	brcs	.+28     	; 0x1fd4 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    1fb8:	cc 24       	eor	r12, r12
    1fba:	c3 94       	inc	r12
    1fbc:	0b c0       	rjmp	.+22     	; 0x1fd4 <xTaskResumeAll+0x9e>
    1fbe:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1fc0:	0f 2e       	mov	r0, r31
    1fc2:	fb e0       	ldi	r31, 0x0B	; 11
    1fc4:	ef 2e       	mov	r14, r31
    1fc6:	f1 e3       	ldi	r31, 0x31	; 49
    1fc8:	ff 2e       	mov	r15, r31
    1fca:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1fcc:	0f 2e       	mov	r0, r31
    1fce:	fb e0       	ldi	r31, 0x0B	; 11
    1fd0:	df 2e       	mov	r13, r31
    1fd2:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1fd4:	f7 01       	movw	r30, r14
    1fd6:	80 81       	ld	r24, Z
    1fd8:	81 11       	cpse	r24, r1
    1fda:	c6 cf       	rjmp	.-116    	; 0x1f68 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1fdc:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <uxMissedTicks>
    1fe0:	88 23       	and	r24, r24
    1fe2:	81 f0       	breq	.+32     	; 0x2004 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1fe4:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <uxMissedTicks>
    1fe8:	88 23       	and	r24, r24
    1fea:	99 f0       	breq	.+38     	; 0x2012 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    1fec:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <vTaskIncrementTick>
						--uxMissedTicks;
    1ff0:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <uxMissedTicks>
    1ff4:	81 50       	subi	r24, 0x01	; 1
    1ff6:	80 93 ff 30 	sts	0x30FF, r24	; 0x8030ff <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ffa:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <uxMissedTicks>
    1ffe:	81 11       	cpse	r24, r1
    2000:	f5 cf       	rjmp	.-22     	; 0x1fec <xTaskResumeAll+0xb6>
    2002:	07 c0       	rjmp	.+14     	; 0x2012 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2004:	f1 e0       	ldi	r31, 0x01	; 1
    2006:	cf 16       	cp	r12, r31
    2008:	21 f0       	breq	.+8      	; 0x2012 <xTaskResumeAll+0xdc>
    200a:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <xMissedYield>
    200e:	81 30       	cpi	r24, 0x01	; 1
    2010:	41 f4       	brne	.+16     	; 0x2022 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2012:	10 92 fe 30 	sts	0x30FE, r1	; 0x8030fe <xMissedYield>
					portYIELD_WITHIN_API();
    2016:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	03 c0       	rjmp	.+6      	; 0x2024 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    201e:	80 e0       	ldi	r24, 0x00	; 0
    2020:	01 c0       	rjmp	.+2      	; 0x2024 <xTaskResumeAll+0xee>
    2022:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2024:	0f 90       	pop	r0
    2026:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2028:	df 91       	pop	r29
    202a:	cf 91       	pop	r28
    202c:	1f 91       	pop	r17
    202e:	0f 91       	pop	r16
    2030:	ff 90       	pop	r15
    2032:	ef 90       	pop	r14
    2034:	df 90       	pop	r13
    2036:	cf 90       	pop	r12
    2038:	08 95       	ret

0000203a <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    203a:	cf 92       	push	r12
    203c:	df 92       	push	r13
    203e:	ef 92       	push	r14
    2040:	ff 92       	push	r15
    2042:	cf 93       	push	r28
    2044:	df 93       	push	r29
    2046:	ec 01       	movw	r28, r24
    2048:	6a 01       	movw	r12, r20
    204a:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    204c:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2050:	88 81       	ld	r24, Y
    2052:	99 81       	ldd	r25, Y+1	; 0x01
    2054:	aa 81       	ldd	r26, Y+2	; 0x02
    2056:	bb 81       	ldd	r27, Y+3	; 0x03
    2058:	c8 0e       	add	r12, r24
    205a:	d9 1e       	adc	r13, r25
    205c:	ea 1e       	adc	r14, r26
    205e:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2060:	40 91 04 31 	lds	r20, 0x3104	; 0x803104 <xTickCount>
    2064:	50 91 05 31 	lds	r21, 0x3105	; 0x803105 <xTickCount+0x1>
    2068:	60 91 06 31 	lds	r22, 0x3106	; 0x803106 <xTickCount+0x2>
    206c:	70 91 07 31 	lds	r23, 0x3107	; 0x803107 <xTickCount+0x3>
    2070:	48 17       	cp	r20, r24
    2072:	59 07       	cpc	r21, r25
    2074:	6a 07       	cpc	r22, r26
    2076:	7b 07       	cpc	r23, r27
    2078:	b8 f4       	brcc	.+46     	; 0x20a8 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    207a:	c8 16       	cp	r12, r24
    207c:	d9 06       	cpc	r13, r25
    207e:	ea 06       	cpc	r14, r26
    2080:	fb 06       	cpc	r15, r27
    2082:	e0 f5       	brcc	.+120    	; 0x20fc <vTaskDelayUntil+0xc2>
    2084:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    2088:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    208c:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    2090:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2094:	c8 82       	st	Y, r12
    2096:	d9 82       	std	Y+1, r13	; 0x01
    2098:	ea 82       	std	Y+2, r14	; 0x02
    209a:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    209c:	8c 15       	cp	r24, r12
    209e:	9d 05       	cpc	r25, r13
    20a0:	ae 05       	cpc	r26, r14
    20a2:	bf 05       	cpc	r27, r15
    20a4:	f8 f4       	brcc	.+62     	; 0x20e4 <vTaskDelayUntil+0xaa>
    20a6:	13 c0       	rjmp	.+38     	; 0x20ce <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    20a8:	c8 16       	cp	r12, r24
    20aa:	d9 06       	cpc	r13, r25
    20ac:	ea 06       	cpc	r14, r26
    20ae:	fb 06       	cpc	r15, r27
    20b0:	00 f1       	brcs	.+64     	; 0x20f2 <vTaskDelayUntil+0xb8>
    20b2:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    20b6:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    20ba:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    20be:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
    20c2:	8c 15       	cp	r24, r12
    20c4:	9d 05       	cpc	r25, r13
    20c6:	ae 05       	cpc	r26, r14
    20c8:	bf 05       	cpc	r27, r15
    20ca:	98 f0       	brcs	.+38     	; 0x20f2 <vTaskDelayUntil+0xb8>
    20cc:	17 c0       	rjmp	.+46     	; 0x20fc <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    20ce:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <pxCurrentTCB>
    20d2:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    20d6:	02 96       	adiw	r24, 0x02	; 2
    20d8:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    20dc:	c7 01       	movw	r24, r14
    20de:	b6 01       	movw	r22, r12
    20e0:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    20e4:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    20e8:	81 11       	cpse	r24, r1
    20ea:	0d c0       	rjmp	.+26     	; 0x2106 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    20ec:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
		}
	}
    20f0:	0a c0       	rjmp	.+20     	; 0x2106 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    20f2:	c8 82       	st	Y, r12
    20f4:	d9 82       	std	Y+1, r13	; 0x01
    20f6:	ea 82       	std	Y+2, r14	; 0x02
    20f8:	fb 82       	std	Y+3, r15	; 0x03
    20fa:	e9 cf       	rjmp	.-46     	; 0x20ce <vTaskDelayUntil+0x94>
    20fc:	c8 82       	st	Y, r12
    20fe:	d9 82       	std	Y+1, r13	; 0x01
    2100:	ea 82       	std	Y+2, r14	; 0x02
    2102:	fb 82       	std	Y+3, r15	; 0x03
    2104:	ef cf       	rjmp	.-34     	; 0x20e4 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2106:	df 91       	pop	r29
    2108:	cf 91       	pop	r28
    210a:	ff 90       	pop	r15
    210c:	ef 90       	pop	r14
    210e:	df 90       	pop	r13
    2110:	cf 90       	pop	r12
    2112:	08 95       	ret

00002114 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2114:	cf 92       	push	r12
    2116:	df 92       	push	r13
    2118:	ef 92       	push	r14
    211a:	ff 92       	push	r15
    211c:	6b 01       	movw	r12, r22
    211e:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2120:	67 2b       	or	r22, r23
    2122:	68 2b       	or	r22, r24
    2124:	69 2b       	or	r22, r25
    2126:	e9 f0       	breq	.+58     	; 0x2162 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2128:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    212c:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    2130:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    2134:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    2138:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
    213c:	c8 0e       	add	r12, r24
    213e:	d9 1e       	adc	r13, r25
    2140:	ea 1e       	adc	r14, r26
    2142:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2144:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <pxCurrentTCB>
    2148:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    214c:	02 96       	adiw	r24, 0x02	; 2
    214e:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2152:	c7 01       	movw	r24, r14
    2154:	b6 01       	movw	r22, r12
    2156:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    215a:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    215e:	81 11       	cpse	r24, r1
    2160:	02 c0       	rjmp	.+4      	; 0x2166 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2162:	0e 94 98 09 	call	0x1330	; 0x1330 <vPortYield>
		}
	}
    2166:	ff 90       	pop	r15
    2168:	ef 90       	pop	r14
    216a:	df 90       	pop	r13
    216c:	cf 90       	pop	r12
    216e:	08 95       	ret

00002170 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2170:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <uxSchedulerSuspended>
    2174:	81 11       	cpse	r24, r1
    2176:	0c c0       	rjmp	.+24     	; 0x2190 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2178:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <uxTopReadyPriority>
    217c:	4b e0       	ldi	r20, 0x0B	; 11
    217e:	e4 9f       	mul	r30, r20
    2180:	f0 01       	movw	r30, r0
    2182:	11 24       	eor	r1, r1
    2184:	e0 5d       	subi	r30, 0xD0	; 208
    2186:	fe 4c       	sbci	r31, 0xCE	; 206
    2188:	80 81       	ld	r24, Z
    218a:	88 23       	and	r24, r24
    218c:	29 f0       	breq	.+10     	; 0x2198 <vTaskSwitchContext+0x28>
    218e:	14 c0       	rjmp	.+40     	; 0x21b8 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2190:	81 e0       	ldi	r24, 0x01	; 1
    2192:	80 93 fe 30 	sts	0x30FE, r24	; 0x8030fe <xMissedYield>
    2196:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2198:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    219a:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <uxTopReadyPriority>
    219e:	81 50       	subi	r24, 0x01	; 1
    21a0:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    21a4:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <uxTopReadyPriority>
    21a8:	9e 9f       	mul	r25, r30
    21aa:	f0 01       	movw	r30, r0
    21ac:	11 24       	eor	r1, r1
    21ae:	e0 5d       	subi	r30, 0xD0	; 208
    21b0:	fe 4c       	sbci	r31, 0xCE	; 206
    21b2:	80 81       	ld	r24, Z
    21b4:	88 23       	and	r24, r24
    21b6:	89 f3       	breq	.-30     	; 0x219a <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    21b8:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <uxTopReadyPriority>
    21bc:	28 2f       	mov	r18, r24
    21be:	30 e0       	ldi	r19, 0x00	; 0
    21c0:	4b e0       	ldi	r20, 0x0B	; 11
    21c2:	84 9f       	mul	r24, r20
    21c4:	c0 01       	movw	r24, r0
    21c6:	11 24       	eor	r1, r1
    21c8:	dc 01       	movw	r26, r24
    21ca:	a0 5d       	subi	r26, 0xD0	; 208
    21cc:	be 4c       	sbci	r27, 0xCE	; 206
    21ce:	11 96       	adiw	r26, 0x01	; 1
    21d0:	ed 91       	ld	r30, X+
    21d2:	fc 91       	ld	r31, X
    21d4:	12 97       	sbiw	r26, 0x02	; 2
    21d6:	04 80       	ldd	r0, Z+4	; 0x04
    21d8:	f5 81       	ldd	r31, Z+5	; 0x05
    21da:	e0 2d       	mov	r30, r0
    21dc:	11 96       	adiw	r26, 0x01	; 1
    21de:	ed 93       	st	X+, r30
    21e0:	fc 93       	st	X, r31
    21e2:	12 97       	sbiw	r26, 0x02	; 2
    21e4:	8d 5c       	subi	r24, 0xCD	; 205
    21e6:	9e 4c       	sbci	r25, 0xCE	; 206
    21e8:	e8 17       	cp	r30, r24
    21ea:	f9 07       	cpc	r31, r25
    21ec:	61 f4       	brne	.+24     	; 0x2206 <vTaskSwitchContext+0x96>
    21ee:	84 81       	ldd	r24, Z+4	; 0x04
    21f0:	95 81       	ldd	r25, Z+5	; 0x05
    21f2:	4b e0       	ldi	r20, 0x0B	; 11
    21f4:	42 9f       	mul	r20, r18
    21f6:	f0 01       	movw	r30, r0
    21f8:	43 9f       	mul	r20, r19
    21fa:	f0 0d       	add	r31, r0
    21fc:	11 24       	eor	r1, r1
    21fe:	e0 5d       	subi	r30, 0xD0	; 208
    2200:	fe 4c       	sbci	r31, 0xCE	; 206
    2202:	81 83       	std	Z+1, r24	; 0x01
    2204:	92 83       	std	Z+2, r25	; 0x02
    2206:	8b e0       	ldi	r24, 0x0B	; 11
    2208:	82 9f       	mul	r24, r18
    220a:	f0 01       	movw	r30, r0
    220c:	83 9f       	mul	r24, r19
    220e:	f0 0d       	add	r31, r0
    2210:	11 24       	eor	r1, r1
    2212:	e0 5d       	subi	r30, 0xD0	; 208
    2214:	fe 4c       	sbci	r31, 0xCE	; 206
    2216:	01 80       	ldd	r0, Z+1	; 0x01
    2218:	f2 81       	ldd	r31, Z+2	; 0x02
    221a:	e0 2d       	mov	r30, r0
    221c:	80 85       	ldd	r24, Z+8	; 0x08
    221e:	91 85       	ldd	r25, Z+9	; 0x09
    2220:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <pxCurrentTCB>
    2224:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <pxCurrentTCB+0x1>
    2228:	08 95       	ret

0000222a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    222a:	cf 92       	push	r12
    222c:	df 92       	push	r13
    222e:	ef 92       	push	r14
    2230:	ff 92       	push	r15
    2232:	6a 01       	movw	r12, r20
    2234:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2236:	60 91 5c 31 	lds	r22, 0x315C	; 0x80315c <pxCurrentTCB>
    223a:	70 91 5d 31 	lds	r23, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    223e:	62 5f       	subi	r22, 0xF2	; 242
    2240:	7f 4f       	sbci	r23, 0xFF	; 255
    2242:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2246:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <pxCurrentTCB>
    224a:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    224e:	02 96       	adiw	r24, 0x02	; 2
    2250:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2254:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    2258:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    225c:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    2260:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2264:	bc 01       	movw	r22, r24
    2266:	cd 01       	movw	r24, r26
    2268:	6c 0d       	add	r22, r12
    226a:	7d 1d       	adc	r23, r13
    226c:	8e 1d       	adc	r24, r14
    226e:	9f 1d       	adc	r25, r15
    2270:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2274:	ff 90       	pop	r15
    2276:	ef 90       	pop	r14
    2278:	df 90       	pop	r13
    227a:	cf 90       	pop	r12
    227c:	08 95       	ret

0000227e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    227e:	0f 93       	push	r16
    2280:	1f 93       	push	r17
    2282:	cf 93       	push	r28
    2284:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2286:	dc 01       	movw	r26, r24
    2288:	17 96       	adiw	r26, 0x07	; 7
    228a:	ed 91       	ld	r30, X+
    228c:	fc 91       	ld	r31, X
    228e:	18 97       	sbiw	r26, 0x08	; 8
    2290:	c0 85       	ldd	r28, Z+8	; 0x08
    2292:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2294:	8e 01       	movw	r16, r28
    2296:	02 5f       	subi	r16, 0xF2	; 242
    2298:	1f 4f       	sbci	r17, 0xFF	; 255
    229a:	c8 01       	movw	r24, r16
    229c:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22a0:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <uxSchedulerSuspended>
    22a4:	81 11       	cpse	r24, r1
    22a6:	16 c0       	rjmp	.+44     	; 0x22d4 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    22a8:	0c 50       	subi	r16, 0x0C	; 12
    22aa:	11 09       	sbc	r17, r1
    22ac:	c8 01       	movw	r24, r16
    22ae:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    22b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22b4:	90 91 02 31 	lds	r25, 0x3102	; 0x803102 <uxTopReadyPriority>
    22b8:	98 17       	cp	r25, r24
    22ba:	10 f4       	brcc	.+4      	; 0x22c0 <xTaskRemoveFromEventList+0x42>
    22bc:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxTopReadyPriority>
    22c0:	bb e0       	ldi	r27, 0x0B	; 11
    22c2:	8b 9f       	mul	r24, r27
    22c4:	c0 01       	movw	r24, r0
    22c6:	11 24       	eor	r1, r1
    22c8:	b8 01       	movw	r22, r16
    22ca:	80 5d       	subi	r24, 0xD0	; 208
    22cc:	9e 4c       	sbci	r25, 0xCE	; 206
    22ce:	0e 94 4a 08 	call	0x1094	; 0x1094 <vListInsertEnd>
    22d2:	05 c0       	rjmp	.+10     	; 0x22de <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    22d4:	b8 01       	movw	r22, r16
    22d6:	8b e0       	ldi	r24, 0x0B	; 11
    22d8:	91 e3       	ldi	r25, 0x31	; 49
    22da:	0e 94 4a 08 	call	0x1094	; 0x1094 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    22de:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <pxCurrentTCB>
    22e2:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    22e6:	81 e0       	ldi	r24, 0x01	; 1
    22e8:	2a 8d       	ldd	r18, Y+26	; 0x1a
    22ea:	92 8d       	ldd	r25, Z+26	; 0x1a
    22ec:	29 17       	cp	r18, r25
    22ee:	08 f4       	brcc	.+2      	; 0x22f2 <xTaskRemoveFromEventList+0x74>
    22f0:	80 e0       	ldi	r24, 0x00	; 0
}
    22f2:	df 91       	pop	r29
    22f4:	cf 91       	pop	r28
    22f6:	1f 91       	pop	r17
    22f8:	0f 91       	pop	r16
    22fa:	08 95       	ret

000022fc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    22fc:	20 91 fd 30 	lds	r18, 0x30FD	; 0x8030fd <xNumOfOverflows>
    2300:	fc 01       	movw	r30, r24
    2302:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2304:	40 91 04 31 	lds	r20, 0x3104	; 0x803104 <xTickCount>
    2308:	50 91 05 31 	lds	r21, 0x3105	; 0x803105 <xTickCount+0x1>
    230c:	60 91 06 31 	lds	r22, 0x3106	; 0x803106 <xTickCount+0x2>
    2310:	70 91 07 31 	lds	r23, 0x3107	; 0x803107 <xTickCount+0x3>
    2314:	41 83       	std	Z+1, r20	; 0x01
    2316:	52 83       	std	Z+2, r21	; 0x02
    2318:	63 83       	std	Z+3, r22	; 0x03
    231a:	74 83       	std	Z+4, r23	; 0x04
    231c:	08 95       	ret

0000231e <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    231e:	8f 92       	push	r8
    2320:	9f 92       	push	r9
    2322:	af 92       	push	r10
    2324:	bf 92       	push	r11
    2326:	cf 92       	push	r12
    2328:	df 92       	push	r13
    232a:	ef 92       	push	r14
    232c:	ff 92       	push	r15
    232e:	0f 93       	push	r16
    2330:	1f 93       	push	r17
    2332:	cf 93       	push	r28
    2334:	df 93       	push	r29
    2336:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2338:	0f b6       	in	r0, 0x3f	; 63
    233a:	f8 94       	cli
    233c:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    233e:	80 91 fd 30 	lds	r24, 0x30FD	; 0x8030fd <xNumOfOverflows>
    2342:	90 81       	ld	r25, Z
    2344:	98 17       	cp	r25, r24
    2346:	89 f0       	breq	.+34     	; 0x236a <xTaskCheckForTimeOut+0x4c>
    2348:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    234c:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    2350:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    2354:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
    2358:	01 81       	ldd	r16, Z+1	; 0x01
    235a:	12 81       	ldd	r17, Z+2	; 0x02
    235c:	23 81       	ldd	r18, Z+3	; 0x03
    235e:	34 81       	ldd	r19, Z+4	; 0x04
    2360:	80 17       	cp	r24, r16
    2362:	91 07       	cpc	r25, r17
    2364:	a2 07       	cpc	r26, r18
    2366:	b3 07       	cpc	r27, r19
    2368:	a8 f5       	brcc	.+106    	; 0x23d4 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    236a:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount>
    236e:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x1>
    2372:	a0 91 06 31 	lds	r26, 0x3106	; 0x803106 <xTickCount+0x2>
    2376:	b0 91 07 31 	lds	r27, 0x3107	; 0x803107 <xTickCount+0x3>
    237a:	c1 80       	ldd	r12, Z+1	; 0x01
    237c:	d2 80       	ldd	r13, Z+2	; 0x02
    237e:	e3 80       	ldd	r14, Z+3	; 0x03
    2380:	f4 80       	ldd	r15, Z+4	; 0x04
    2382:	eb 01       	movw	r28, r22
    2384:	08 81       	ld	r16, Y
    2386:	19 81       	ldd	r17, Y+1	; 0x01
    2388:	2a 81       	ldd	r18, Y+2	; 0x02
    238a:	3b 81       	ldd	r19, Y+3	; 0x03
    238c:	8c 19       	sub	r24, r12
    238e:	9d 09       	sbc	r25, r13
    2390:	ae 09       	sbc	r26, r14
    2392:	bf 09       	sbc	r27, r15
    2394:	80 17       	cp	r24, r16
    2396:	91 07       	cpc	r25, r17
    2398:	a2 07       	cpc	r26, r18
    239a:	b3 07       	cpc	r27, r19
    239c:	e8 f4       	brcc	.+58     	; 0x23d8 <xTaskCheckForTimeOut+0xba>
    239e:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    23a0:	80 90 04 31 	lds	r8, 0x3104	; 0x803104 <xTickCount>
    23a4:	90 90 05 31 	lds	r9, 0x3105	; 0x803105 <xTickCount+0x1>
    23a8:	a0 90 06 31 	lds	r10, 0x3106	; 0x803106 <xTickCount+0x2>
    23ac:	b0 90 07 31 	lds	r11, 0x3107	; 0x803107 <xTickCount+0x3>
    23b0:	b5 01       	movw	r22, r10
    23b2:	a4 01       	movw	r20, r8
    23b4:	4c 19       	sub	r20, r12
    23b6:	5d 09       	sbc	r21, r13
    23b8:	6e 09       	sbc	r22, r14
    23ba:	7f 09       	sbc	r23, r15
    23bc:	04 1b       	sub	r16, r20
    23be:	15 0b       	sbc	r17, r21
    23c0:	26 0b       	sbc	r18, r22
    23c2:	37 0b       	sbc	r19, r23
    23c4:	08 83       	st	Y, r16
    23c6:	19 83       	std	Y+1, r17	; 0x01
    23c8:	2a 83       	std	Y+2, r18	; 0x02
    23ca:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    23cc:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    23d0:	80 e0       	ldi	r24, 0x00	; 0
    23d2:	03 c0       	rjmp	.+6      	; 0x23da <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    23d4:	81 e0       	ldi	r24, 0x01	; 1
    23d6:	01 c0       	rjmp	.+2      	; 0x23da <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    23d8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    23da:	0f 90       	pop	r0
    23dc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    23de:	df 91       	pop	r29
    23e0:	cf 91       	pop	r28
    23e2:	1f 91       	pop	r17
    23e4:	0f 91       	pop	r16
    23e6:	ff 90       	pop	r15
    23e8:	ef 90       	pop	r14
    23ea:	df 90       	pop	r13
    23ec:	cf 90       	pop	r12
    23ee:	bf 90       	pop	r11
    23f0:	af 90       	pop	r10
    23f2:	9f 90       	pop	r9
    23f4:	8f 90       	pop	r8
    23f6:	08 95       	ret

000023f8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    23f8:	81 e0       	ldi	r24, 0x01	; 1
    23fa:	80 93 fe 30 	sts	0x30FE, r24	; 0x8030fe <xMissedYield>
    23fe:	08 95       	ret

00002400 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2400:	00 97       	sbiw	r24, 0x00	; 0
    2402:	21 f4       	brne	.+8      	; 0x240c <uxTaskGetStackHighWaterMark+0xc>
    2404:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <pxCurrentTCB>
    2408:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    240c:	dc 01       	movw	r26, r24
    240e:	5b 96       	adiw	r26, 0x1b	; 27
    2410:	ed 91       	ld	r30, X+
    2412:	fc 91       	ld	r31, X
    2414:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2416:	80 81       	ld	r24, Z
    2418:	81 31       	cpi	r24, 0x11	; 17
    241a:	41 f4       	brne	.+16     	; 0x242c <uxTaskGetStackHighWaterMark+0x2c>
    241c:	31 96       	adiw	r30, 0x01	; 1
    241e:	80 e0       	ldi	r24, 0x00	; 0
    2420:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2422:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2424:	21 91       	ld	r18, Z+
    2426:	21 31       	cpi	r18, 0x11	; 17
    2428:	e1 f3       	breq	.-8      	; 0x2422 <uxTaskGetStackHighWaterMark+0x22>
    242a:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    242c:	80 e0       	ldi	r24, 0x00	; 0
    242e:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2430:	08 95       	ret

00002432 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2432:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <pxCurrentTCB>
    2436:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <pxCurrentTCB+0x1>

		return xReturn;
	}
    243a:	08 95       	ret

0000243c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    243c:	0f 93       	push	r16
    243e:	1f 93       	push	r17
    2440:	cf 93       	push	r28
    2442:	df 93       	push	r29
    2444:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2446:	22 8d       	ldd	r18, Z+26	; 0x1a
    2448:	a0 91 5c 31 	lds	r26, 0x315C	; 0x80315c <pxCurrentTCB>
    244c:	b0 91 5d 31 	lds	r27, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    2450:	5a 96       	adiw	r26, 0x1a	; 26
    2452:	8c 91       	ld	r24, X
    2454:	28 17       	cp	r18, r24
    2456:	08 f0       	brcs	.+2      	; 0x245a <vTaskPriorityInherit+0x1e>
    2458:	41 c0       	rjmp	.+130    	; 0x24dc <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    245a:	a0 91 5c 31 	lds	r26, 0x315C	; 0x80315c <pxCurrentTCB>
    245e:	b0 91 5d 31 	lds	r27, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    2462:	5a 96       	adiw	r26, 0x1a	; 26
    2464:	3c 91       	ld	r19, X
    2466:	84 e0       	ldi	r24, 0x04	; 4
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	a0 e0       	ldi	r26, 0x00	; 0
    246c:	b0 e0       	ldi	r27, 0x00	; 0
    246e:	83 1b       	sub	r24, r19
    2470:	91 09       	sbc	r25, r1
    2472:	a1 09       	sbc	r26, r1
    2474:	b1 09       	sbc	r27, r1
    2476:	86 87       	std	Z+14, r24	; 0x0e
    2478:	97 87       	std	Z+15, r25	; 0x0f
    247a:	a0 8b       	std	Z+16, r26	; 0x10
    247c:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    247e:	8b e0       	ldi	r24, 0x0B	; 11
    2480:	28 9f       	mul	r18, r24
    2482:	90 01       	movw	r18, r0
    2484:	11 24       	eor	r1, r1
    2486:	20 5d       	subi	r18, 0xD0	; 208
    2488:	3e 4c       	sbci	r19, 0xCE	; 206
    248a:	84 85       	ldd	r24, Z+12	; 0x0c
    248c:	95 85       	ldd	r25, Z+13	; 0x0d
    248e:	82 17       	cp	r24, r18
    2490:	93 07       	cpc	r25, r19
    2492:	e9 f4       	brne	.+58     	; 0x24ce <vTaskPriorityInherit+0x92>
    2494:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2496:	ef 01       	movw	r28, r30
    2498:	22 96       	adiw	r28, 0x02	; 2
    249a:	ce 01       	movw	r24, r28
    249c:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    24a0:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <pxCurrentTCB>
    24a4:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    24a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    24aa:	f8 01       	movw	r30, r16
    24ac:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    24ae:	90 91 02 31 	lds	r25, 0x3102	; 0x803102 <uxTopReadyPriority>
    24b2:	98 17       	cp	r25, r24
    24b4:	10 f4       	brcc	.+4      	; 0x24ba <vTaskPriorityInherit+0x7e>
    24b6:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxTopReadyPriority>
    24ba:	fb e0       	ldi	r31, 0x0B	; 11
    24bc:	8f 9f       	mul	r24, r31
    24be:	c0 01       	movw	r24, r0
    24c0:	11 24       	eor	r1, r1
    24c2:	be 01       	movw	r22, r28
    24c4:	80 5d       	subi	r24, 0xD0	; 208
    24c6:	9e 4c       	sbci	r25, 0xCE	; 206
    24c8:	0e 94 4a 08 	call	0x1094	; 0x1094 <vListInsertEnd>
    24cc:	07 c0       	rjmp	.+14     	; 0x24dc <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    24ce:	a0 91 5c 31 	lds	r26, 0x315C	; 0x80315c <pxCurrentTCB>
    24d2:	b0 91 5d 31 	lds	r27, 0x315D	; 0x80315d <pxCurrentTCB+0x1>
    24d6:	5a 96       	adiw	r26, 0x1a	; 26
    24d8:	8c 91       	ld	r24, X
    24da:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    24dc:	df 91       	pop	r29
    24de:	cf 91       	pop	r28
    24e0:	1f 91       	pop	r17
    24e2:	0f 91       	pop	r16
    24e4:	08 95       	ret

000024e6 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    24e6:	0f 93       	push	r16
    24e8:	1f 93       	push	r17
    24ea:	cf 93       	push	r28
    24ec:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    24ee:	00 97       	sbiw	r24, 0x00	; 0
    24f0:	49 f1       	breq	.+82     	; 0x2544 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    24f2:	fc 01       	movw	r30, r24
    24f4:	32 8d       	ldd	r19, Z+26	; 0x1a
    24f6:	27 a1       	ldd	r18, Z+39	; 0x27
    24f8:	32 17       	cp	r19, r18
    24fa:	21 f1       	breq	.+72     	; 0x2544 <vTaskPriorityDisinherit+0x5e>
    24fc:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    24fe:	8c 01       	movw	r16, r24
    2500:	0e 5f       	subi	r16, 0xFE	; 254
    2502:	1f 4f       	sbci	r17, 0xFF	; 255
    2504:	c8 01       	movw	r24, r16
    2506:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    250a:	8f a1       	ldd	r24, Y+39	; 0x27
    250c:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    250e:	44 e0       	ldi	r20, 0x04	; 4
    2510:	50 e0       	ldi	r21, 0x00	; 0
    2512:	60 e0       	ldi	r22, 0x00	; 0
    2514:	70 e0       	ldi	r23, 0x00	; 0
    2516:	48 1b       	sub	r20, r24
    2518:	51 09       	sbc	r21, r1
    251a:	61 09       	sbc	r22, r1
    251c:	71 09       	sbc	r23, r1
    251e:	4e 87       	std	Y+14, r20	; 0x0e
    2520:	5f 87       	std	Y+15, r21	; 0x0f
    2522:	68 8b       	std	Y+16, r22	; 0x10
    2524:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2526:	90 91 02 31 	lds	r25, 0x3102	; 0x803102 <uxTopReadyPriority>
    252a:	98 17       	cp	r25, r24
    252c:	10 f4       	brcc	.+4      	; 0x2532 <vTaskPriorityDisinherit+0x4c>
    252e:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxTopReadyPriority>
    2532:	fb e0       	ldi	r31, 0x0B	; 11
    2534:	8f 9f       	mul	r24, r31
    2536:	c0 01       	movw	r24, r0
    2538:	11 24       	eor	r1, r1
    253a:	b8 01       	movw	r22, r16
    253c:	80 5d       	subi	r24, 0xD0	; 208
    253e:	9e 4c       	sbci	r25, 0xCE	; 206
    2540:	0e 94 4a 08 	call	0x1094	; 0x1094 <vListInsertEnd>
			}
		}
	}
    2544:	df 91       	pop	r29
    2546:	cf 91       	pop	r28
    2548:	1f 91       	pop	r17
    254a:	0f 91       	pop	r16
    254c:	08 95       	ret

0000254e <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    254e:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2550:	e8 81       	ld	r30, Y
    2552:	f9 81       	ldd	r31, Y+1	; 0x01
    2554:	01 90       	ld	r0, Z+
    2556:	f0 81       	ld	r31, Z
    2558:	e0 2d       	mov	r30, r0
    255a:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    255c:	1a 82       	std	Y+2, r1	; 0x02
    255e:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2560:	6f ef       	ldi	r22, 0xFF	; 255
    2562:	7f ef       	ldi	r23, 0xFF	; 255
    2564:	cb 01       	movw	r24, r22
    2566:	0e 94 8a 10 	call	0x2114	; 0x2114 <vTaskDelay>
    256a:	fa cf       	rjmp	.-12     	; 0x2560 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000256c <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    256c:	fc 01       	movw	r30, r24
    256e:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2570:	65 87       	std	Z+13, r22	; 0x0d
    2572:	08 95       	ret

00002574 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2574:	4f 92       	push	r4
    2576:	5f 92       	push	r5
    2578:	6f 92       	push	r6
    257a:	7f 92       	push	r7
    257c:	8f 92       	push	r8
    257e:	9f 92       	push	r9
    2580:	af 92       	push	r10
    2582:	bf 92       	push	r11
    2584:	cf 92       	push	r12
    2586:	df 92       	push	r13
    2588:	ef 92       	push	r14
    258a:	ff 92       	push	r15
    258c:	0f 93       	push	r16
    258e:	1f 93       	push	r17
    2590:	cf 93       	push	r28
    2592:	df 93       	push	r29
    2594:	cd b7       	in	r28, 0x3d	; 61
    2596:	de b7       	in	r29, 0x3e	; 62
    2598:	2a 97       	sbiw	r28, 0x0a	; 10
    259a:	cd bf       	out	0x3d, r28	; 61
    259c:	de bf       	out	0x3e, r29	; 62
    259e:	4c 01       	movw	r8, r24
    25a0:	29 01       	movw	r4, r18
    25a2:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    25a4:	81 e7       	ldi	r24, 0x71	; 113
    25a6:	90 e2       	ldi	r25, 0x20	; 32
    25a8:	f4 01       	movw	r30, r8
    25aa:	80 83       	st	Z, r24
    25ac:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    25ae:	fb 01       	movw	r30, r22
    25b0:	80 81       	ld	r24, Z
    25b2:	88 23       	and	r24, r24
    25b4:	69 f0       	breq	.+26     	; 0x25d0 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    25b6:	de 01       	movw	r26, r28
    25b8:	11 96       	adiw	r26, 0x01	; 1
    25ba:	31 96       	adiw	r30, 0x01	; 1
    25bc:	90 e0       	ldi	r25, 0x00	; 0
    25be:	02 c0       	rjmp	.+4      	; 0x25c4 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    25c0:	99 30       	cpi	r25, 0x09	; 9
    25c2:	39 f0       	breq	.+14     	; 0x25d2 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    25c4:	9f 5f       	subi	r25, 0xFF	; 255
    25c6:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    25c8:	81 91       	ld	r24, Z+
    25ca:	81 11       	cpse	r24, r1
    25cc:	f9 cf       	rjmp	.-14     	; 0x25c0 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    25ce:	01 c0       	rjmp	.+2      	; 0x25d2 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    25d0:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    25d2:	e1 e0       	ldi	r30, 0x01	; 1
    25d4:	f0 e0       	ldi	r31, 0x00	; 0
    25d6:	ec 0f       	add	r30, r28
    25d8:	fd 1f       	adc	r31, r29
    25da:	e9 0f       	add	r30, r25
    25dc:	f1 1d       	adc	r31, r1
    25de:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    25e0:	74 01       	movw	r14, r8
    25e2:	f2 e0       	ldi	r31, 0x02	; 2
    25e4:	ef 0e       	add	r14, r31
    25e6:	f1 1c       	adc	r15, r1
    25e8:	a1 2c       	mov	r10, r1
    25ea:	b1 2c       	mov	r11, r1
    25ec:	c1 2c       	mov	r12, r1
    25ee:	d1 2c       	mov	r13, r1
    25f0:	04 2f       	mov	r16, r20
    25f2:	94 01       	movw	r18, r8
    25f4:	a2 01       	movw	r20, r4
    25f6:	be 01       	movw	r22, r28
    25f8:	6f 5f       	subi	r22, 0xFF	; 255
    25fa:	7f 4f       	sbci	r23, 0xFF	; 255
    25fc:	88 ea       	ldi	r24, 0xA8	; 168
    25fe:	92 e0       	ldi	r25, 0x02	; 2
    2600:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2604:	f4 01       	movw	r30, r8
    2606:	66 82       	std	Z+6, r6	; 0x06
    2608:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    260a:	40 86       	std	Z+8, r4	; 0x08
    260c:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    260e:	20 91 5e 31 	lds	r18, 0x315E	; 0x80315e <last_created_task_pointer>
    2612:	30 91 5f 31 	lds	r19, 0x315F	; 0x80315f <last_created_task_pointer+0x1>
    2616:	24 83       	std	Z+4, r18	; 0x04
    2618:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    261a:	80 92 5e 31 	sts	0x315E, r8	; 0x80315e <last_created_task_pointer>
    261e:	90 92 5f 31 	sts	0x315F, r9	; 0x80315f <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2622:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2624:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2626:	40 90 a0 31 	lds	r4, 0x31A0	; 0x8031a0 <portStackTopForTask>
    262a:	50 90 a1 31 	lds	r5, 0x31A1	; 0x8031a1 <portStackTopForTask+0x1>
    262e:	ff ef       	ldi	r31, 0xFF	; 255
    2630:	4f 1a       	sub	r4, r31
    2632:	5f 0a       	sbc	r5, r31
    2634:	40 92 a0 31 	sts	0x31A0, r4	; 0x8031a0 <portStackTopForTask>
    2638:	50 92 a1 31 	sts	0x31A1, r5	; 0x8031a1 <portStackTopForTask+0x1>
    263c:	f4 01       	movw	r30, r8
    263e:	42 86       	std	Z+10, r4	; 0x0a
    2640:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2642:	16 86       	std	Z+14, r1	; 0x0e
    2644:	17 86       	std	Z+15, r1	; 0x0f
    2646:	10 8a       	std	Z+16, r1	; 0x10
    2648:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    264a:	61 14       	cp	r6, r1
    264c:	71 04       	cpc	r7, r1
    264e:	09 f4       	brne	.+2      	; 0x2652 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2650:	44 c0       	rjmp	.+136    	; 0x26da <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2652:	81 30       	cpi	r24, 0x01	; 1
    2654:	79 f5       	brne	.+94     	; 0x26b4 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2656:	6a e0       	ldi	r22, 0x0A	; 10
    2658:	c3 01       	movw	r24, r6
    265a:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    265e:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2660:	6d e9       	ldi	r22, 0x9D	; 157
    2662:	74 e0       	ldi	r23, 0x04	; 4
    2664:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    2668:	be 01       	movw	r22, r28
    266a:	6f 5f       	subi	r22, 0xFF	; 255
    266c:	7f 4f       	sbci	r23, 0xFF	; 255
    266e:	c7 01       	movw	r24, r14
    2670:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    2674:	6a e0       	ldi	r22, 0x0A	; 10
    2676:	c7 01       	movw	r24, r14
    2678:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    267c:	7c 01       	movw	r14, r24
    267e:	64 e9       	ldi	r22, 0x94	; 148
    2680:	74 e0       	ldi	r23, 0x04	; 4
    2682:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2686:	6a e0       	ldi	r22, 0x0A	; 10
    2688:	c7 01       	movw	r24, r14
    268a:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    268e:	7c 01       	movw	r14, r24
    2690:	66 e8       	ldi	r22, 0x86	; 134
    2692:	74 e0       	ldi	r23, 0x04	; 4
    2694:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    2698:	63 e0       	ldi	r22, 0x03	; 3
    269a:	c7 01       	movw	r24, r14
    269c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    26a0:	b2 01       	movw	r22, r4
    26a2:	0e 94 c1 18 	call	0x3182	; 0x3182 <_ZN8emstreamlsEj>
    26a6:	62 e0       	ldi	r22, 0x02	; 2
    26a8:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    26ac:	66 e0       	ldi	r22, 0x06	; 6
    26ae:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    26b2:	13 c0       	rjmp	.+38     	; 0x26da <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    26b4:	6a e0       	ldi	r22, 0x0A	; 10
    26b6:	c3 01       	movw	r24, r6
    26b8:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    26bc:	4c 01       	movw	r8, r24
    26be:	61 e7       	ldi	r22, 0x71	; 113
    26c0:	74 e0       	ldi	r23, 0x04	; 4
    26c2:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    26c6:	be 01       	movw	r22, r28
    26c8:	6f 5f       	subi	r22, 0xFF	; 255
    26ca:	7f 4f       	sbci	r23, 0xFF	; 255
    26cc:	c4 01       	movw	r24, r8
    26ce:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    26d2:	66 e0       	ldi	r22, 0x06	; 6
    26d4:	c4 01       	movw	r24, r8
    26d6:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    26da:	2a 96       	adiw	r28, 0x0a	; 10
    26dc:	cd bf       	out	0x3d, r28	; 61
    26de:	de bf       	out	0x3e, r29	; 62
    26e0:	df 91       	pop	r29
    26e2:	cf 91       	pop	r28
    26e4:	1f 91       	pop	r17
    26e6:	0f 91       	pop	r16
    26e8:	ff 90       	pop	r15
    26ea:	ef 90       	pop	r14
    26ec:	df 90       	pop	r13
    26ee:	cf 90       	pop	r12
    26f0:	bf 90       	pop	r11
    26f2:	af 90       	pop	r10
    26f4:	9f 90       	pop	r9
    26f6:	8f 90       	pop	r8
    26f8:	7f 90       	pop	r7
    26fa:	6f 90       	pop	r6
    26fc:	5f 90       	pop	r5
    26fe:	4f 90       	pop	r4
    2700:	08 95       	ret

00002702 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2702:	cf 92       	push	r12
    2704:	df 92       	push	r13
    2706:	ef 92       	push	r14
    2708:	ff 92       	push	r15
    270a:	0f 93       	push	r16
    270c:	1f 93       	push	r17
    270e:	cf 93       	push	r28
    2710:	df 93       	push	r29
    2712:	ec 01       	movw	r28, r24
    2714:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2716:	8a 81       	ldd	r24, Y+2	; 0x02
    2718:	9b 81       	ldd	r25, Y+3	; 0x03
    271a:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <pcTaskGetTaskName>
    271e:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2720:	6a e0       	ldi	r22, 0x0A	; 10
    2722:	c7 01       	movw	r24, r14
    2724:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2728:	8c 01       	movw	r16, r24
    272a:	60 eb       	ldi	r22, 0xB0	; 176
    272c:	74 e0       	ldi	r23, 0x04	; 4
    272e:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    2732:	6a e0       	ldi	r22, 0x0A	; 10
    2734:	c8 01       	movw	r24, r16
    2736:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    273a:	8c 01       	movw	r16, r24
    273c:	69 ea       	ldi	r22, 0xA9	; 169
    273e:	74 e0       	ldi	r23, 0x04	; 4
    2740:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    2744:	b6 01       	movw	r22, r12
    2746:	c8 01       	movw	r24, r16
    2748:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    274c:	6a e0       	ldi	r22, 0x0A	; 10
    274e:	c8 01       	movw	r24, r16
    2750:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2754:	8c 01       	movw	r16, r24
    2756:	63 ea       	ldi	r22, 0xA3	; 163
    2758:	74 e0       	ldi	r23, 0x04	; 4
    275a:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    275e:	66 e0       	ldi	r22, 0x06	; 6
    2760:	c8 01       	movw	r24, r16
    2762:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2766:	8a 85       	ldd	r24, Y+10	; 0x0a
    2768:	9b 85       	ldd	r25, Y+11	; 0x0b
    276a:	e8 85       	ldd	r30, Y+8	; 0x08
    276c:	f9 85       	ldd	r31, Y+9	; 0x09
    276e:	01 e1       	ldi	r16, 0x11	; 17
    2770:	21 e0       	ldi	r18, 0x01	; 1
    2772:	a7 01       	movw	r20, r14
    2774:	bc 01       	movw	r22, r24
    2776:	8e 1b       	sub	r24, r30
    2778:	9f 0b       	sbc	r25, r31
    277a:	0e 94 83 16 	call	0x2d06	; 0x2d06 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    277e:	8c 81       	ldd	r24, Y+4	; 0x04
    2780:	9d 81       	ldd	r25, Y+5	; 0x05
    2782:	00 97       	sbiw	r24, 0x00	; 0
    2784:	19 f0       	breq	.+6      	; 0x278c <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2786:	b7 01       	movw	r22, r14
    2788:	0e 94 81 13 	call	0x2702	; 0x2702 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    278c:	df 91       	pop	r29
    278e:	cf 91       	pop	r28
    2790:	1f 91       	pop	r17
    2792:	0f 91       	pop	r16
    2794:	ff 90       	pop	r15
    2796:	ef 90       	pop	r14
    2798:	df 90       	pop	r13
    279a:	cf 90       	pop	r12
    279c:	08 95       	ret

0000279e <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    279e:	0f 93       	push	r16
    27a0:	1f 93       	push	r17
    27a2:	cf 93       	push	r28
    27a4:	df 93       	push	r29
    27a6:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    27a8:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <last_created_task_pointer>
    27ac:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <last_created_task_pointer+0x1>
    27b0:	00 97       	sbiw	r24, 0x00	; 0
    27b2:	19 f0       	breq	.+6      	; 0x27ba <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    27b4:	be 01       	movw	r22, r28
    27b6:	0e 94 81 13 	call	0x2702	; 0x2702 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    27ba:	6a e0       	ldi	r22, 0x0A	; 10
    27bc:	ce 01       	movw	r24, r28
    27be:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    27c2:	8c 01       	movw	r16, r24
    27c4:	66 ec       	ldi	r22, 0xC6	; 198
    27c6:	74 e0       	ldi	r23, 0x04	; 4
    27c8:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    27cc:	6a e0       	ldi	r22, 0x0A	; 10
    27ce:	c8 01       	movw	r24, r16
    27d0:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    27d4:	8c 01       	movw	r16, r24
    27d6:	6b eb       	ldi	r22, 0xBB	; 187
    27d8:	74 e0       	ldi	r23, 0x04	; 4
    27da:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    27de:	6a e0       	ldi	r22, 0x0A	; 10
    27e0:	c8 01       	movw	r24, r16
    27e2:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    27e6:	8c 01       	movw	r16, r24
    27e8:	65 eb       	ldi	r22, 0xB5	; 181
    27ea:	74 e0       	ldi	r23, 0x04	; 4
    27ec:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    27f0:	66 e0       	ldi	r22, 0x06	; 6
    27f2:	c8 01       	movw	r24, r16
    27f4:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    27f8:	80 91 a0 31 	lds	r24, 0x31A0	; 0x8031a0 <portStackTopForTask>
    27fc:	90 91 a1 31 	lds	r25, 0x31A1	; 0x8031a1 <portStackTopForTask+0x1>
    2800:	bc 01       	movw	r22, r24
    2802:	6f 5f       	subi	r22, 0xFF	; 255
    2804:	7f 4f       	sbci	r23, 0xFF	; 255
    2806:	01 e1       	ldi	r16, 0x11	; 17
    2808:	21 e0       	ldi	r18, 0x01	; 1
    280a:	ae 01       	movw	r20, r28
    280c:	83 56       	subi	r24, 0x63	; 99
    280e:	91 09       	sbc	r25, r1
    2810:	0e 94 83 16 	call	0x2d06	; 0x2d06 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2814:	df 91       	pop	r29
    2816:	cf 91       	pop	r28
    2818:	1f 91       	pop	r17
    281a:	0f 91       	pop	r16
    281c:	08 95       	ret

0000281e <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    281e:	8f 92       	push	r8
    2820:	9f 92       	push	r9
    2822:	af 92       	push	r10
    2824:	bf 92       	push	r11
    2826:	cf 92       	push	r12
    2828:	df 92       	push	r13
    282a:	ef 92       	push	r14
    282c:	ff 92       	push	r15
    282e:	0f 93       	push	r16
    2830:	1f 93       	push	r17
    2832:	cf 93       	push	r28
    2834:	df 93       	push	r29
    2836:	ec 01       	movw	r28, r24
    2838:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    283a:	8a 81       	ldd	r24, Y+2	; 0x02
    283c:	9b 81       	ldd	r25, Y+3	; 0x03
    283e:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <pcTaskGetTaskName>
    2842:	bc 01       	movw	r22, r24
    2844:	c8 01       	movw	r24, r16
    2846:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    284a:	d8 01       	movw	r26, r16
    284c:	ed 91       	ld	r30, X+
    284e:	fc 91       	ld	r31, X
    2850:	02 80       	ldd	r0, Z+2	; 0x02
    2852:	f3 81       	ldd	r31, Z+3	; 0x03
    2854:	e0 2d       	mov	r30, r0
    2856:	69 e0       	ldi	r22, 0x09	; 9
    2858:	c8 01       	movw	r24, r16
    285a:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    285c:	8a 81       	ldd	r24, Y+2	; 0x02
    285e:	9b 81       	ldd	r25, Y+3	; 0x03
    2860:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <pcTaskGetTaskName>
    2864:	fc 01       	movw	r30, r24
    2866:	01 90       	ld	r0, Z+
    2868:	00 20       	and	r0, r0
    286a:	e9 f7       	brne	.-6      	; 0x2866 <_ZN8frt_task12print_statusER8emstream+0x48>
    286c:	31 97       	sbiw	r30, 0x01	; 1
    286e:	e8 1b       	sub	r30, r24
    2870:	f9 0b       	sbc	r31, r25
    2872:	38 97       	sbiw	r30, 0x08	; 8
    2874:	48 f4       	brcc	.+18     	; 0x2888 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2876:	d8 01       	movw	r26, r16
    2878:	ed 91       	ld	r30, X+
    287a:	fc 91       	ld	r31, X
    287c:	02 80       	ldd	r0, Z+2	; 0x02
    287e:	f3 81       	ldd	r31, Z+3	; 0x03
    2880:	e0 2d       	mov	r30, r0
    2882:	69 e0       	ldi	r22, 0x09	; 9
    2884:	c8 01       	movw	r24, r16
    2886:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2888:	ce 84       	ldd	r12, Y+14	; 0x0e
    288a:	df 84       	ldd	r13, Y+15	; 0x0f
    288c:	e8 88       	ldd	r14, Y+16	; 0x10
    288e:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2890:	a8 84       	ldd	r10, Y+8	; 0x08
    2892:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2894:	8a 81       	ldd	r24, Y+2	; 0x02
    2896:	9b 81       	ldd	r25, Y+3	; 0x03
    2898:	0e 94 00 12 	call	0x2400	; 0x2400 <uxTaskGetStackHighWaterMark>
    289c:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    289e:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    28a0:	8a 81       	ldd	r24, Y+2	; 0x02
    28a2:	9b 81       	ldd	r25, Y+3	; 0x03
    28a4:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <uxTaskPriorityGet>
    28a8:	68 2f       	mov	r22, r24
    28aa:	c8 01       	movw	r24, r16
    28ac:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
    28b0:	6a e0       	ldi	r22, 0x0A	; 10
    28b2:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    28b6:	ec 01       	movw	r28, r24
    28b8:	6b e3       	ldi	r22, 0x3B	; 59
    28ba:	75 e0       	ldi	r23, 0x05	; 5
    28bc:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
			<< get_state ()
    28c0:	68 2d       	mov	r22, r8
    28c2:	ce 01       	movw	r24, r28
    28c4:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    28c8:	6a e0       	ldi	r22, 0x0A	; 10
    28ca:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    28ce:	ec 01       	movw	r28, r24
    28d0:	69 e3       	ldi	r22, 0x39	; 57
    28d2:	75 e0       	ldi	r23, 0x05	; 5
    28d4:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    28d8:	69 2d       	mov	r22, r9
    28da:	ce 01       	movw	r24, r28
    28dc:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
    28e0:	6a e0       	ldi	r22, 0x0A	; 10
    28e2:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    28e6:	ec 01       	movw	r28, r24
    28e8:	67 e3       	ldi	r22, 0x37	; 55
    28ea:	75 e0       	ldi	r23, 0x05	; 5
    28ec:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    28f0:	b5 01       	movw	r22, r10
    28f2:	ce 01       	movw	r24, r28
    28f4:	0e 94 c1 18 	call	0x3182	; 0x3182 <_ZN8emstreamlsEj>
    28f8:	6a e0       	ldi	r22, 0x0A	; 10
    28fa:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    28fe:	ec 01       	movw	r28, r24
    2900:	65 e3       	ldi	r22, 0x35	; 53
    2902:	75 e0       	ldi	r23, 0x05	; 5
    2904:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2908:	6a e0       	ldi	r22, 0x0A	; 10
    290a:	ce 01       	movw	r24, r28
    290c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2910:	ec 01       	movw	r28, r24
    2912:	63 e3       	ldi	r22, 0x33	; 51
    2914:	75 e0       	ldi	r23, 0x05	; 5
    2916:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    291a:	b7 01       	movw	r22, r14
    291c:	a6 01       	movw	r20, r12
    291e:	ce 01       	movw	r24, r28
    2920:	0e 94 f5 18 	call	0x31ea	; 0x31ea <_ZN8emstreamlsEm>
}
    2924:	df 91       	pop	r29
    2926:	cf 91       	pop	r28
    2928:	1f 91       	pop	r17
    292a:	0f 91       	pop	r16
    292c:	ff 90       	pop	r15
    292e:	ef 90       	pop	r14
    2930:	df 90       	pop	r13
    2932:	cf 90       	pop	r12
    2934:	bf 90       	pop	r11
    2936:	af 90       	pop	r10
    2938:	9f 90       	pop	r9
    293a:	8f 90       	pop	r8
    293c:	08 95       	ret

0000293e <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    293e:	cf 93       	push	r28
    2940:	df 93       	push	r29
    2942:	ec 01       	movw	r28, r24
    2944:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2946:	db 01       	movw	r26, r22
    2948:	ed 91       	ld	r30, X+
    294a:	fc 91       	ld	r31, X
    294c:	02 80       	ldd	r0, Z+2	; 0x02
    294e:	f3 81       	ldd	r31, Z+3	; 0x03
    2950:	e0 2d       	mov	r30, r0
    2952:	be 01       	movw	r22, r28
    2954:	19 95       	eicall
	return (ser_dev);
}
    2956:	ce 01       	movw	r24, r28
    2958:	df 91       	pop	r29
    295a:	cf 91       	pop	r28
    295c:	08 95       	ret

0000295e <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    295e:	0f 93       	push	r16
    2960:	1f 93       	push	r17
    2962:	cf 93       	push	r28
    2964:	df 93       	push	r29
    2966:	ec 01       	movw	r28, r24
    2968:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    296a:	bc 01       	movw	r22, r24
    296c:	c8 01       	movw	r24, r16
    296e:	0e 94 9f 14 	call	0x293e	; 0x293e <_ZlsR8emstreamR8frt_task>
    2972:	66 e0       	ldi	r22, 0x06	; 6
    2974:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2978:	8c 81       	ldd	r24, Y+4	; 0x04
    297a:	9d 81       	ldd	r25, Y+5	; 0x05
    297c:	00 97       	sbiw	r24, 0x00	; 0
    297e:	19 f0       	breq	.+6      	; 0x2986 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2980:	b8 01       	movw	r22, r16
    2982:	0e 94 af 14 	call	0x295e	; 0x295e <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2986:	df 91       	pop	r29
    2988:	cf 91       	pop	r28
    298a:	1f 91       	pop	r17
    298c:	0f 91       	pop	r16
    298e:	08 95       	ret

00002990 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2990:	0f 93       	push	r16
    2992:	1f 93       	push	r17
    2994:	cf 93       	push	r28
    2996:	df 93       	push	r29
    2998:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    299a:	6a e0       	ldi	r22, 0x0A	; 10
    299c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    29a0:	8c 01       	movw	r16, r24
    29a2:	68 e2       	ldi	r22, 0x28	; 40
    29a4:	75 e0       	ldi	r23, 0x05	; 5
    29a6:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    29aa:	6a e0       	ldi	r22, 0x0A	; 10
    29ac:	c8 01       	movw	r24, r16
    29ae:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    29b2:	8c 01       	movw	r16, r24
    29b4:	61 e2       	ldi	r22, 0x21	; 33
    29b6:	75 e0       	ldi	r23, 0x05	; 5
    29b8:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    29bc:	66 e0       	ldi	r22, 0x06	; 6
    29be:	c8 01       	movw	r24, r16
    29c0:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    29c4:	6a e0       	ldi	r22, 0x0A	; 10
    29c6:	ce 01       	movw	r24, r28
    29c8:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    29cc:	8c 01       	movw	r16, r24
    29ce:	60 e1       	ldi	r22, 0x10	; 16
    29d0:	75 e0       	ldi	r23, 0x05	; 5
    29d2:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    29d6:	6a e0       	ldi	r22, 0x0A	; 10
    29d8:	c8 01       	movw	r24, r16
    29da:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    29de:	8c 01       	movw	r16, r24
    29e0:	64 e0       	ldi	r22, 0x04	; 4
    29e2:	75 e0       	ldi	r23, 0x05	; 5
    29e4:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    29e8:	6a e0       	ldi	r22, 0x0A	; 10
    29ea:	c8 01       	movw	r24, r16
    29ec:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    29f0:	8c 01       	movw	r16, r24
    29f2:	6e ef       	ldi	r22, 0xFE	; 254
    29f4:	74 e0       	ldi	r23, 0x04	; 4
    29f6:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    29fa:	66 e0       	ldi	r22, 0x06	; 6
    29fc:	c8 01       	movw	r24, r16
    29fe:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2a02:	6a e0       	ldi	r22, 0x0A	; 10
    2a04:	ce 01       	movw	r24, r28
    2a06:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2a0a:	8c 01       	movw	r16, r24
    2a0c:	6d ee       	ldi	r22, 0xED	; 237
    2a0e:	74 e0       	ldi	r23, 0x04	; 4
    2a10:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2a14:	6a e0       	ldi	r22, 0x0A	; 10
    2a16:	c8 01       	movw	r24, r16
    2a18:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2a1c:	8c 01       	movw	r16, r24
    2a1e:	61 ee       	ldi	r22, 0xE1	; 225
    2a20:	74 e0       	ldi	r23, 0x04	; 4
    2a22:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2a26:	6a e0       	ldi	r22, 0x0A	; 10
    2a28:	c8 01       	movw	r24, r16
    2a2a:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2a2e:	8c 01       	movw	r16, r24
    2a30:	6b ed       	ldi	r22, 0xDB	; 219
    2a32:	74 e0       	ldi	r23, 0x04	; 4
    2a34:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    2a38:	66 e0       	ldi	r22, 0x06	; 6
    2a3a:	c8 01       	movw	r24, r16
    2a3c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2a40:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <last_created_task_pointer>
    2a44:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <last_created_task_pointer+0x1>
    2a48:	00 97       	sbiw	r24, 0x00	; 0
    2a4a:	19 f0       	breq	.+6      	; 0x2a52 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2a4c:	be 01       	movw	r22, r28
    2a4e:	0e 94 af 14 	call	0x295e	; 0x295e <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2a52:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <xTaskGetIdleTaskHandle>
    2a56:	0e 94 00 12 	call	0x2400	; 0x2400 <uxTaskGetStackHighWaterMark>
    2a5a:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2a5c:	6a e0       	ldi	r22, 0x0A	; 10
    2a5e:	ce 01       	movw	r24, r28
    2a60:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2a64:	ec 01       	movw	r28, r24
    2a66:	60 ed       	ldi	r22, 0xD0	; 208
    2a68:	74 e0       	ldi	r23, 0x04	; 4
    2a6a:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2a6e:	61 2f       	mov	r22, r17
    2a70:	ce 01       	movw	r24, r28
    2a72:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2a76:	6a e0       	ldi	r22, 0x0A	; 10
    2a78:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2a7c:	ec 01       	movw	r28, r24
    2a7e:	6e ec       	ldi	r22, 0xCE	; 206
    2a80:	74 e0       	ldi	r23, 0x04	; 4
    2a82:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    2a86:	64 e6       	ldi	r22, 0x64	; 100
    2a88:	70 e0       	ldi	r23, 0x00	; 0
    2a8a:	ce 01       	movw	r24, r28
    2a8c:	0e 94 c1 18 	call	0x3182	; 0x3182 <_ZN8emstreamlsEj>
    2a90:	6a e0       	ldi	r22, 0x0A	; 10
    2a92:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2a96:	ec 01       	movw	r28, r24
    2a98:	6b ec       	ldi	r22, 0xCB	; 203
    2a9a:	74 e0       	ldi	r23, 0x04	; 4
    2a9c:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2aa0:	66 e0       	ldi	r22, 0x06	; 6
    2aa2:	ce 01       	movw	r24, r28
    2aa4:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
}
    2aa8:	df 91       	pop	r29
    2aaa:	cf 91       	pop	r28
    2aac:	1f 91       	pop	r17
    2aae:	0f 91       	pop	r16
    2ab0:	08 95       	ret

00002ab2 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2ab2:	0f 93       	push	r16
    2ab4:	cf 93       	push	r28
    2ab6:	df 93       	push	r29
    2ab8:	1f 92       	push	r1
    2aba:	cd b7       	in	r28, 0x3d	; 61
    2abc:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2abe:	00 e0       	ldi	r16, 0x00	; 0
    2ac0:	2f ef       	ldi	r18, 0xFF	; 255
    2ac2:	3f ef       	ldi	r19, 0xFF	; 255
    2ac4:	a9 01       	movw	r20, r18
    2ac6:	be 01       	movw	r22, r28
    2ac8:	6f 5f       	subi	r22, 0xFF	; 255
    2aca:	7f 4f       	sbci	r23, 0xFF	; 255
    2acc:	fc 01       	movw	r30, r24
    2ace:	80 85       	ldd	r24, Z+8	; 0x08
    2ad0:	91 85       	ldd	r25, Z+9	; 0x09
    2ad2:	0e 94 14 0c 	call	0x1828	; 0x1828 <xQueueGenericReceive>
    2ad6:	81 30       	cpi	r24, 0x01	; 1
    2ad8:	19 f4       	brne	.+6      	; 0x2ae0 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2ada:	89 81       	ldd	r24, Y+1	; 0x01
    2adc:	90 e0       	ldi	r25, 0x00	; 0
    2ade:	02 c0       	rjmp	.+4      	; 0x2ae4 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2ae0:	8f ef       	ldi	r24, 0xFF	; 255
    2ae2:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2ae4:	0f 90       	pop	r0
    2ae6:	df 91       	pop	r29
    2ae8:	cf 91       	pop	r28
    2aea:	0f 91       	pop	r16
    2aec:	08 95       	ret

00002aee <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2aee:	fc 01       	movw	r30, r24
    2af0:	80 85       	ldd	r24, Z+8	; 0x08
    2af2:	91 85       	ldd	r25, Z+9	; 0x09
    2af4:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <uxQueueMessagesWaiting>
    2af8:	91 e0       	ldi	r25, 0x01	; 1
    2afa:	81 11       	cpse	r24, r1
    2afc:	01 c0       	rjmp	.+2      	; 0x2b00 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2afe:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2b00:	89 2f       	mov	r24, r25
    2b02:	08 95       	ret

00002b04 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2b04:	0f 93       	push	r16
    2b06:	cf 93       	push	r28
    2b08:	df 93       	push	r29
    2b0a:	1f 92       	push	r1
    2b0c:	cd b7       	in	r28, 0x3d	; 61
    2b0e:	de b7       	in	r29, 0x3e	; 62
    2b10:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2b12:	fc 01       	movw	r30, r24
    2b14:	22 85       	ldd	r18, Z+10	; 0x0a
    2b16:	33 85       	ldd	r19, Z+11	; 0x0b
    2b18:	44 85       	ldd	r20, Z+12	; 0x0c
    2b1a:	55 85       	ldd	r21, Z+13	; 0x0d
    2b1c:	00 e0       	ldi	r16, 0x00	; 0
    2b1e:	be 01       	movw	r22, r28
    2b20:	6f 5f       	subi	r22, 0xFF	; 255
    2b22:	7f 4f       	sbci	r23, 0xFF	; 255
    2b24:	80 85       	ldd	r24, Z+8	; 0x08
    2b26:	91 85       	ldd	r25, Z+9	; 0x09
    2b28:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xQueueGenericSend>
    2b2c:	91 e0       	ldi	r25, 0x01	; 1
    2b2e:	81 11       	cpse	r24, r1
    2b30:	01 c0       	rjmp	.+2      	; 0x2b34 <_ZN14frt_text_queue7putcharEc+0x30>
    2b32:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2b34:	89 2f       	mov	r24, r25
    2b36:	0f 90       	pop	r0
    2b38:	df 91       	pop	r29
    2b3a:	cf 91       	pop	r28
    2b3c:	0f 91       	pop	r16
    2b3e:	08 95       	ret

00002b40 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2b40:	8f 92       	push	r8
    2b42:	9f 92       	push	r9
    2b44:	bf 92       	push	r11
    2b46:	cf 92       	push	r12
    2b48:	df 92       	push	r13
    2b4a:	ef 92       	push	r14
    2b4c:	ff 92       	push	r15
    2b4e:	0f 93       	push	r16
    2b50:	1f 93       	push	r17
    2b52:	cf 93       	push	r28
    2b54:	df 93       	push	r29
    2b56:	ec 01       	movw	r28, r24
    2b58:	b6 2e       	mov	r11, r22
    2b5a:	4a 01       	movw	r8, r20
    2b5c:	68 01       	movw	r12, r16
    2b5e:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2b60:	0e 94 f4 17 	call	0x2fe8	; 0x2fe8 <_ZN8emstreamC1Ev>
    2b64:	89 e7       	ldi	r24, 0x79	; 121
    2b66:	90 e2       	ldi	r25, 0x20	; 32
    2b68:	88 83       	st	Y, r24
    2b6a:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2b6c:	8e 86       	std	Y+14, r8	; 0x0e
    2b6e:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2b70:	40 e0       	ldi	r20, 0x00	; 0
    2b72:	61 e0       	ldi	r22, 0x01	; 1
    2b74:	8b 2d       	mov	r24, r11
    2b76:	0e 94 4b 0b 	call	0x1696	; 0x1696 <xQueueGenericCreate>
    2b7a:	88 87       	std	Y+8, r24	; 0x08
    2b7c:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2b7e:	ca 86       	std	Y+10, r12	; 0x0a
    2b80:	db 86       	std	Y+11, r13	; 0x0b
    2b82:	ec 86       	std	Y+12, r14	; 0x0c
    2b84:	fd 86       	std	Y+13, r15	; 0x0d
}
    2b86:	df 91       	pop	r29
    2b88:	cf 91       	pop	r28
    2b8a:	1f 91       	pop	r17
    2b8c:	0f 91       	pop	r16
    2b8e:	ff 90       	pop	r15
    2b90:	ef 90       	pop	r14
    2b92:	df 90       	pop	r13
    2b94:	cf 90       	pop	r12
    2b96:	bf 90       	pop	r11
    2b98:	9f 90       	pop	r9
    2b9a:	8f 90       	pop	r8
    2b9c:	08 95       	ret

00002b9e <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2b9e:	cf 92       	push	r12
    2ba0:	df 92       	push	r13
    2ba2:	ef 92       	push	r14
    2ba4:	ff 92       	push	r15
    2ba6:	cf 93       	push	r28
    2ba8:	df 93       	push	r29
    2baa:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2bac:	68 81       	ld	r22, Y
    2bae:	79 81       	ldd	r23, Y+1	; 0x01
    2bb0:	8a 81       	ldd	r24, Y+2	; 0x02
    2bb2:	9b 81       	ldd	r25, Y+3	; 0x03
    2bb4:	0f 2e       	mov	r0, r31
    2bb6:	f8 ee       	ldi	r31, 0xE8	; 232
    2bb8:	cf 2e       	mov	r12, r31
    2bba:	f3 e0       	ldi	r31, 0x03	; 3
    2bbc:	df 2e       	mov	r13, r31
    2bbe:	e1 2c       	mov	r14, r1
    2bc0:	f1 2c       	mov	r15, r1
    2bc2:	f0 2d       	mov	r31, r0
    2bc4:	a7 01       	movw	r20, r14
    2bc6:	96 01       	movw	r18, r12
    2bc8:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <__udivmodsi4>
    2bcc:	9b 01       	movw	r18, r22
    2bce:	ac 01       	movw	r20, r24
    2bd0:	60 e4       	ldi	r22, 0x40	; 64
    2bd2:	72 e4       	ldi	r23, 0x42	; 66
    2bd4:	8f e0       	ldi	r24, 0x0F	; 15
    2bd6:	90 e0       	ldi	r25, 0x00	; 0
    2bd8:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <__mulsi3>
    2bdc:	a7 01       	movw	r20, r14
    2bde:	96 01       	movw	r18, r12
    2be0:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <__udivmodsi4>
    2be4:	69 01       	movw	r12, r18
    2be6:	7a 01       	movw	r14, r20
    2be8:	ac 81       	ldd	r26, Y+4	; 0x04
    2bea:	bd 81       	ldd	r27, Y+5	; 0x05
    2bec:	20 e4       	ldi	r18, 0x40	; 64
    2bee:	32 e4       	ldi	r19, 0x42	; 66
    2bf0:	4f e0       	ldi	r20, 0x0F	; 15
    2bf2:	50 e0       	ldi	r21, 0x00	; 0
    2bf4:	0e 94 28 20 	call	0x4050	; 0x4050 <__muluhisi3>
    2bf8:	20 e0       	ldi	r18, 0x00	; 0
    2bfa:	38 e4       	ldi	r19, 0x48	; 72
    2bfc:	48 ee       	ldi	r20, 0xE8	; 232
    2bfe:	51 e0       	ldi	r21, 0x01	; 1
    2c00:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <__udivmodsi4>
    2c04:	c7 01       	movw	r24, r14
    2c06:	b6 01       	movw	r22, r12
    2c08:	62 0f       	add	r22, r18
    2c0a:	73 1f       	adc	r23, r19
    2c0c:	84 1f       	adc	r24, r20
    2c0e:	95 1f       	adc	r25, r21
}
    2c10:	df 91       	pop	r29
    2c12:	cf 91       	pop	r28
    2c14:	ff 90       	pop	r15
    2c16:	ef 90       	pop	r14
    2c18:	df 90       	pop	r13
    2c1a:	cf 90       	pop	r12
    2c1c:	08 95       	ret

00002c1e <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2c1e:	cf 92       	push	r12
    2c20:	df 92       	push	r13
    2c22:	ef 92       	push	r14
    2c24:	ff 92       	push	r15
    2c26:	0f 93       	push	r16
    2c28:	1f 93       	push	r17
    2c2a:	cf 93       	push	r28
    2c2c:	df 93       	push	r29
    2c2e:	cd b7       	in	r28, 0x3d	; 61
    2c30:	de b7       	in	r29, 0x3e	; 62
    2c32:	2f 97       	sbiw	r28, 0x0f	; 15
    2c34:	cd bf       	out	0x3d, r28	; 61
    2c36:	de bf       	out	0x3e, r29	; 62
    2c38:	6c 01       	movw	r12, r24
    2c3a:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2c3c:	db 01       	movw	r26, r22
    2c3e:	6d 91       	ld	r22, X+
    2c40:	7d 91       	ld	r23, X+
    2c42:	8d 91       	ld	r24, X+
    2c44:	9c 91       	ld	r25, X
    2c46:	28 ee       	ldi	r18, 0xE8	; 232
    2c48:	33 e0       	ldi	r19, 0x03	; 3
    2c4a:	40 e0       	ldi	r20, 0x00	; 0
    2c4c:	50 e0       	ldi	r21, 0x00	; 0
    2c4e:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <__udivmodsi4>
    2c52:	ba 01       	movw	r22, r20
    2c54:	a9 01       	movw	r20, r18
    2c56:	c6 01       	movw	r24, r12
    2c58:	0e 94 f5 18 	call	0x31ea	; 0x31ea <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2c5c:	d6 01       	movw	r26, r12
    2c5e:	ed 91       	ld	r30, X+
    2c60:	fc 91       	ld	r31, X
    2c62:	02 80       	ldd	r0, Z+2	; 0x02
    2c64:	f3 81       	ldd	r31, Z+3	; 0x03
    2c66:	e0 2d       	mov	r30, r0
    2c68:	6e e2       	ldi	r22, 0x2E	; 46
    2c6a:	c6 01       	movw	r24, r12
    2c6c:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2c6e:	c8 01       	movw	r24, r16
    2c70:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <_ZN10time_stamp12get_microsecEv>
    2c74:	8e 01       	movw	r16, r28
    2c76:	09 5f       	subi	r16, 0xF9	; 249
    2c78:	1f 4f       	sbci	r17, 0xFF	; 255
    2c7a:	fe 01       	movw	r30, r28
    2c7c:	31 96       	adiw	r30, 0x01	; 1
    2c7e:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2c80:	2a e0       	ldi	r18, 0x0A	; 10
    2c82:	30 e0       	ldi	r19, 0x00	; 0
    2c84:	40 e0       	ldi	r20, 0x00	; 0
    2c86:	50 e0       	ldi	r21, 0x00	; 0
    2c88:	0e 94 00 20 	call	0x4000	; 0x4000 <__divmodsi4>
    2c8c:	e6 2f       	mov	r30, r22
    2c8e:	28 87       	std	Y+8, r18	; 0x08
    2c90:	39 87       	std	Y+9, r19	; 0x09
    2c92:	4a 87       	std	Y+10, r20	; 0x0a
    2c94:	5b 87       	std	Y+11, r21	; 0x0b
    2c96:	68 85       	ldd	r22, Y+8	; 0x08
    2c98:	79 85       	ldd	r23, Y+9	; 0x09
    2c9a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c9c:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2c9e:	20 e3       	ldi	r18, 0x30	; 48
    2ca0:	2e 0f       	add	r18, r30
    2ca2:	d8 01       	movw	r26, r16
    2ca4:	2e 93       	st	-X, r18
    2ca6:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2ca8:	ae 15       	cp	r26, r14
    2caa:	bf 05       	cpc	r27, r15
    2cac:	49 f7       	brne	.-46     	; 0x2c80 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2cae:	1f 82       	std	Y+7, r1	; 0x07
    2cb0:	be 01       	movw	r22, r28
    2cb2:	6f 5f       	subi	r22, 0xFF	; 255
    2cb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2cb6:	c6 01       	movw	r24, r12
    2cb8:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2cbc:	c6 01       	movw	r24, r12
    2cbe:	2f 96       	adiw	r28, 0x0f	; 15
    2cc0:	cd bf       	out	0x3d, r28	; 61
    2cc2:	de bf       	out	0x3e, r29	; 62
    2cc4:	df 91       	pop	r29
    2cc6:	cf 91       	pop	r28
    2cc8:	1f 91       	pop	r17
    2cca:	0f 91       	pop	r16
    2ccc:	ff 90       	pop	r15
    2cce:	ef 90       	pop	r14
    2cd0:	df 90       	pop	r13
    2cd2:	cf 90       	pop	r12
    2cd4:	08 95       	ret

00002cd6 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2cd6:	cf 93       	push	r28
    2cd8:	df 93       	push	r29
    2cda:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2cdc:	0f b6       	in	r0, 0x3f	; 63
    2cde:	f8 94       	cli
    2ce0:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2ce2:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2ce6:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2cea:	8c 83       	std	Y+4, r24	; 0x04
    2cec:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2cee:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCount>
    2cf2:	68 83       	st	Y, r22
    2cf4:	79 83       	std	Y+1, r23	; 0x01
    2cf6:	8a 83       	std	Y+2, r24	; 0x02
    2cf8:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2cfa:	0f 90       	pop	r0
    2cfc:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2cfe:	ce 01       	movw	r24, r28
    2d00:	df 91       	pop	r29
    2d02:	cf 91       	pop	r28
    2d04:	08 95       	ret

00002d06 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2d06:	5f 92       	push	r5
    2d08:	6f 92       	push	r6
    2d0a:	7f 92       	push	r7
    2d0c:	8f 92       	push	r8
    2d0e:	9f 92       	push	r9
    2d10:	af 92       	push	r10
    2d12:	bf 92       	push	r11
    2d14:	cf 92       	push	r12
    2d16:	df 92       	push	r13
    2d18:	ef 92       	push	r14
    2d1a:	ff 92       	push	r15
    2d1c:	0f 93       	push	r16
    2d1e:	1f 93       	push	r17
    2d20:	cf 93       	push	r28
    2d22:	df 93       	push	r29
    2d24:	5c 01       	movw	r10, r24
    2d26:	4b 01       	movw	r8, r22
    2d28:	7a 01       	movw	r14, r20
    2d2a:	12 2f       	mov	r17, r18
    2d2c:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2d2e:	63 e0       	ldi	r22, 0x03	; 3
    2d30:	ca 01       	movw	r24, r20
    2d32:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2d36:	a8 14       	cp	r10, r8
    2d38:	b9 04       	cpc	r11, r9
    2d3a:	08 f0       	brcs	.+2      	; 0x2d3e <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2d3c:	7d c0       	rjmp	.+250    	; 0x2e38 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2d3e:	65 01       	movw	r12, r10
    2d40:	84 e1       	ldi	r24, 0x14	; 20
    2d42:	c8 0e       	add	r12, r24
    2d44:	d1 1c       	adc	r13, r1
    2d46:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2d48:	6a 2c       	mov	r6, r10
    2d4a:	5b 2c       	mov	r5, r11
    2d4c:	b5 01       	movw	r22, r10
    2d4e:	c7 01       	movw	r24, r14
    2d50:	0e 94 c1 18 	call	0x3182	; 0x3182 <_ZN8emstreamlsEj>
    2d54:	6a e0       	ldi	r22, 0x0A	; 10
    2d56:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2d5a:	6d e4       	ldi	r22, 0x4D	; 77
    2d5c:	75 e0       	ldi	r23, 0x05	; 5
    2d5e:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2d62:	11 23       	and	r17, r17
    2d64:	09 f4       	brne	.+2      	; 0x2d68 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2d66:	6d c0       	rjmp	.+218    	; 0x2e42 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2d68:	00 23       	and	r16, r16
    2d6a:	09 f4       	brne	.+2      	; 0x2d6e <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2d6c:	6a c0       	rjmp	.+212    	; 0x2e42 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2d6e:	6a e0       	ldi	r22, 0x0A	; 10
    2d70:	c7 01       	movw	r24, r14
    2d72:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2d76:	68 e4       	ldi	r22, 0x48	; 72
    2d78:	75 e0       	ldi	r23, 0x05	; 5
    2d7a:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    2d7e:	61 c0       	rjmp	.+194    	; 0x2e42 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2d80:	11 23       	and	r17, r17
    2d82:	71 f0       	breq	.+28     	; 0x2da0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2d84:	01 11       	cpse	r16, r1
    2d86:	0c c0       	rjmp	.+24     	; 0x2da0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2d88:	88 81       	ld	r24, Y
    2d8a:	87 15       	cp	r24, r7
    2d8c:	49 f0       	breq	.+18     	; 0x2da0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2d8e:	6a e0       	ldi	r22, 0x0A	; 10
    2d90:	c7 01       	movw	r24, r14
    2d92:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2d96:	63 e4       	ldi	r22, 0x43	; 67
    2d98:	75 e0       	ldi	r23, 0x05	; 5
    2d9a:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2d9e:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2da0:	69 91       	ld	r22, Y+
    2da2:	c7 01       	movw	r24, r14
    2da4:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2da8:	dc 01       	movw	r26, r24
    2daa:	ed 91       	ld	r30, X+
    2dac:	fc 91       	ld	r31, X
    2dae:	02 80       	ldd	r0, Z+2	; 0x02
    2db0:	f3 81       	ldd	r31, Z+3	; 0x03
    2db2:	e0 2d       	mov	r30, r0
    2db4:	60 e2       	ldi	r22, 0x20	; 32
    2db6:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2db8:	cc 16       	cp	r12, r28
    2dba:	dd 06       	cpc	r13, r29
    2dbc:	09 f7       	brne	.-62     	; 0x2d80 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2dbe:	11 23       	and	r17, r17
    2dc0:	89 f0       	breq	.+34     	; 0x2de4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2dc2:	6a e0       	ldi	r22, 0x0A	; 10
    2dc4:	c7 01       	movw	r24, r14
    2dc6:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2dca:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2dcc:	6d e3       	ldi	r22, 0x3D	; 61
    2dce:	75 e0       	ldi	r23, 0x05	; 5
    2dd0:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2dd4:	e8 81       	ld	r30, Y
    2dd6:	f9 81       	ldd	r31, Y+1	; 0x01
    2dd8:	02 80       	ldd	r0, Z+2	; 0x02
    2dda:	f3 81       	ldd	r31, Z+3	; 0x03
    2ddc:	e0 2d       	mov	r30, r0
    2dde:	60 e2       	ldi	r22, 0x20	; 32
    2de0:	ce 01       	movw	r24, r28
    2de2:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2de4:	c6 2d       	mov	r28, r6
    2de6:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2de8:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2dea:	80 ee       	ldi	r24, 0xE0	; 224
    2dec:	86 0f       	add	r24, r22
    2dee:	8f 35       	cpi	r24, 0x5F	; 95
    2df0:	48 f4       	brcc	.+18     	; 0x2e04 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2df2:	d7 01       	movw	r26, r14
    2df4:	ed 91       	ld	r30, X+
    2df6:	fc 91       	ld	r31, X
    2df8:	02 80       	ldd	r0, Z+2	; 0x02
    2dfa:	f3 81       	ldd	r31, Z+3	; 0x03
    2dfc:	e0 2d       	mov	r30, r0
    2dfe:	c7 01       	movw	r24, r14
    2e00:	19 95       	eicall
    2e02:	09 c0       	rjmp	.+18     	; 0x2e16 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2e04:	d7 01       	movw	r26, r14
    2e06:	ed 91       	ld	r30, X+
    2e08:	fc 91       	ld	r31, X
    2e0a:	02 80       	ldd	r0, Z+2	; 0x02
    2e0c:	f3 81       	ldd	r31, Z+3	; 0x03
    2e0e:	e0 2d       	mov	r30, r0
    2e10:	6e e2       	ldi	r22, 0x2E	; 46
    2e12:	c7 01       	movw	r24, r14
    2e14:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2e16:	cc 16       	cp	r12, r28
    2e18:	dd 06       	cpc	r13, r29
    2e1a:	31 f7       	brne	.-52     	; 0x2de8 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2e1c:	b4 e1       	ldi	r27, 0x14	; 20
    2e1e:	ab 0e       	add	r10, r27
    2e20:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2e22:	66 e0       	ldi	r22, 0x06	; 6
    2e24:	c7 01       	movw	r24, r14
    2e26:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    2e2a:	84 e1       	ldi	r24, 0x14	; 20
    2e2c:	c8 0e       	add	r12, r24
    2e2e:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2e30:	a8 14       	cp	r10, r8
    2e32:	b9 04       	cpc	r11, r9
    2e34:	08 f4       	brcc	.+2      	; 0x2e38 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2e36:	88 cf       	rjmp	.-240    	; 0x2d48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2e38:	62 e0       	ldi	r22, 0x02	; 2
    2e3a:	c7 01       	movw	r24, r14
    2e3c:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
}
    2e40:	03 c0       	rjmp	.+6      	; 0x2e48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2e42:	c6 2d       	mov	r28, r6
    2e44:	d5 2d       	mov	r29, r5
    2e46:	9c cf       	rjmp	.-200    	; 0x2d80 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2e48:	df 91       	pop	r29
    2e4a:	cf 91       	pop	r28
    2e4c:	1f 91       	pop	r17
    2e4e:	0f 91       	pop	r16
    2e50:	ff 90       	pop	r15
    2e52:	ef 90       	pop	r14
    2e54:	df 90       	pop	r13
    2e56:	cf 90       	pop	r12
    2e58:	bf 90       	pop	r11
    2e5a:	af 90       	pop	r10
    2e5c:	9f 90       	pop	r9
    2e5e:	8f 90       	pop	r8
    2e60:	7f 90       	pop	r7
    2e62:	6f 90       	pop	r6
    2e64:	5f 90       	pop	r5
    2e66:	08 95       	ret

00002e68 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2e68:	0e 94 63 07 	call	0xec6	; 0xec6 <pvPortMalloc>
    2e6c:	08 95       	ret

00002e6e <_Znaj>:
    2e6e:	0e 94 63 07 	call	0xec6	; 0xec6 <pvPortMalloc>
    2e72:	08 95       	ret

00002e74 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2e74:	08 95       	ret

00002e76 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2e76:	cf 93       	push	r28
    2e78:	df 93       	push	r29
    2e7a:	fc 01       	movw	r30, r24
    2e7c:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2e7e:	40 3a       	cpi	r20, 0xA0	; 160
    2e80:	68 e0       	ldi	r22, 0x08	; 8
    2e82:	56 07       	cpc	r21, r22
    2e84:	49 f4       	brne	.+18     	; 0x2e98 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2e86:	80 e4       	ldi	r24, 0x40	; 64
    2e88:	96 e0       	ldi	r25, 0x06	; 6
    2e8a:	82 83       	std	Z+2, r24	; 0x02
    2e8c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e8e:	82 e0       	ldi	r24, 0x02	; 2
    2e90:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e92:	83 e0       	ldi	r24, 0x03	; 3
    2e94:	85 83       	std	Z+5, r24	; 0x05
    2e96:	4c c0       	rjmp	.+152    	; 0x2f30 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2e98:	40 3b       	cpi	r20, 0xB0	; 176
    2e9a:	78 e0       	ldi	r23, 0x08	; 8
    2e9c:	57 07       	cpc	r21, r23
    2e9e:	49 f4       	brne	.+18     	; 0x2eb2 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2ea0:	80 e4       	ldi	r24, 0x40	; 64
    2ea2:	96 e0       	ldi	r25, 0x06	; 6
    2ea4:	82 83       	std	Z+2, r24	; 0x02
    2ea6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2ea8:	86 e0       	ldi	r24, 0x06	; 6
    2eaa:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2eac:	87 e0       	ldi	r24, 0x07	; 7
    2eae:	85 83       	std	Z+5, r24	; 0x05
    2eb0:	3f c0       	rjmp	.+126    	; 0x2f30 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2eb2:	40 3a       	cpi	r20, 0xA0	; 160
    2eb4:	89 e0       	ldi	r24, 0x09	; 9
    2eb6:	58 07       	cpc	r21, r24
    2eb8:	49 f4       	brne	.+18     	; 0x2ecc <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2eba:	80 e6       	ldi	r24, 0x60	; 96
    2ebc:	96 e0       	ldi	r25, 0x06	; 6
    2ebe:	82 83       	std	Z+2, r24	; 0x02
    2ec0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2ec2:	82 e0       	ldi	r24, 0x02	; 2
    2ec4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2ec6:	83 e0       	ldi	r24, 0x03	; 3
    2ec8:	85 83       	std	Z+5, r24	; 0x05
    2eca:	32 c0       	rjmp	.+100    	; 0x2f30 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2ecc:	40 3b       	cpi	r20, 0xB0	; 176
    2ece:	69 e0       	ldi	r22, 0x09	; 9
    2ed0:	56 07       	cpc	r21, r22
    2ed2:	49 f4       	brne	.+18     	; 0x2ee6 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2ed4:	80 e6       	ldi	r24, 0x60	; 96
    2ed6:	96 e0       	ldi	r25, 0x06	; 6
    2ed8:	82 83       	std	Z+2, r24	; 0x02
    2eda:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2edc:	86 e0       	ldi	r24, 0x06	; 6
    2ede:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2ee0:	87 e0       	ldi	r24, 0x07	; 7
    2ee2:	85 83       	std	Z+5, r24	; 0x05
    2ee4:	25 c0       	rjmp	.+74     	; 0x2f30 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2ee6:	40 3a       	cpi	r20, 0xA0	; 160
    2ee8:	7a e0       	ldi	r23, 0x0A	; 10
    2eea:	57 07       	cpc	r21, r23
    2eec:	49 f4       	brne	.+18     	; 0x2f00 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    2eee:	80 e8       	ldi	r24, 0x80	; 128
    2ef0:	96 e0       	ldi	r25, 0x06	; 6
    2ef2:	82 83       	std	Z+2, r24	; 0x02
    2ef4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2ef6:	82 e0       	ldi	r24, 0x02	; 2
    2ef8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2efa:	83 e0       	ldi	r24, 0x03	; 3
    2efc:	85 83       	std	Z+5, r24	; 0x05
    2efe:	18 c0       	rjmp	.+48     	; 0x2f30 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    2f00:	40 3b       	cpi	r20, 0xB0	; 176
    2f02:	8a e0       	ldi	r24, 0x0A	; 10
    2f04:	58 07       	cpc	r21, r24
    2f06:	49 f4       	brne	.+18     	; 0x2f1a <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    2f08:	80 e8       	ldi	r24, 0x80	; 128
    2f0a:	96 e0       	ldi	r25, 0x06	; 6
    2f0c:	82 83       	std	Z+2, r24	; 0x02
    2f0e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2f10:	86 e0       	ldi	r24, 0x06	; 6
    2f12:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2f14:	87 e0       	ldi	r24, 0x07	; 7
    2f16:	85 83       	std	Z+5, r24	; 0x05
    2f18:	0b c0       	rjmp	.+22     	; 0x2f30 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    2f1a:	40 3a       	cpi	r20, 0xA0	; 160
    2f1c:	5b 40       	sbci	r21, 0x0B	; 11
    2f1e:	41 f4       	brne	.+16     	; 0x2f30 <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    2f20:	80 ea       	ldi	r24, 0xA0	; 160
    2f22:	96 e0       	ldi	r25, 0x06	; 6
    2f24:	82 83       	std	Z+2, r24	; 0x02
    2f26:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2f28:	82 e0       	ldi	r24, 0x02	; 2
    2f2a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2f2c:	83 e0       	ldi	r24, 0x03	; 3
    2f2e:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2f30:	a6 83       	std	Z+6, r26	; 0x06
    2f32:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2f34:	cd 01       	movw	r24, r26
    2f36:	01 96       	adiw	r24, 0x01	; 1
    2f38:	80 87       	std	Z+8, r24	; 0x08
    2f3a:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2f3c:	03 96       	adiw	r24, 0x03	; 3
    2f3e:	82 87       	std	Z+10, r24	; 0x0a
    2f40:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2f42:	25 81       	ldd	r18, Z+5	; 0x05
    2f44:	c2 81       	ldd	r28, Z+2	; 0x02
    2f46:	d3 81       	ldd	r29, Z+3	; 0x03
    2f48:	4c 81       	ldd	r20, Y+4	; 0x04
    2f4a:	81 e0       	ldi	r24, 0x01	; 1
    2f4c:	90 e0       	ldi	r25, 0x00	; 0
    2f4e:	bc 01       	movw	r22, r24
    2f50:	02 c0       	rjmp	.+4      	; 0x2f56 <_ZN7base232C1EjP12USART_struct+0xe0>
    2f52:	66 0f       	add	r22, r22
    2f54:	77 1f       	adc	r23, r23
    2f56:	2a 95       	dec	r18
    2f58:	e2 f7       	brpl	.-8      	; 0x2f52 <_ZN7base232C1EjP12USART_struct+0xdc>
    2f5a:	9b 01       	movw	r18, r22
    2f5c:	24 2b       	or	r18, r20
    2f5e:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2f60:	25 81       	ldd	r18, Z+5	; 0x05
    2f62:	c2 81       	ldd	r28, Z+2	; 0x02
    2f64:	d3 81       	ldd	r29, Z+3	; 0x03
    2f66:	48 81       	ld	r20, Y
    2f68:	bc 01       	movw	r22, r24
    2f6a:	02 c0       	rjmp	.+4      	; 0x2f70 <_ZN7base232C1EjP12USART_struct+0xfa>
    2f6c:	66 0f       	add	r22, r22
    2f6e:	77 1f       	adc	r23, r23
    2f70:	2a 95       	dec	r18
    2f72:	e2 f7       	brpl	.-8      	; 0x2f6c <_ZN7base232C1EjP12USART_struct+0xf6>
    2f74:	9b 01       	movw	r18, r22
    2f76:	24 2b       	or	r18, r20
    2f78:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2f7a:	34 81       	ldd	r19, Z+4	; 0x04
    2f7c:	c2 81       	ldd	r28, Z+2	; 0x02
    2f7e:	d3 81       	ldd	r29, Z+3	; 0x03
    2f80:	28 81       	ld	r18, Y
    2f82:	02 c0       	rjmp	.+4      	; 0x2f88 <_ZN7base232C1EjP12USART_struct+0x112>
    2f84:	88 0f       	add	r24, r24
    2f86:	99 1f       	adc	r25, r25
    2f88:	3a 95       	dec	r19
    2f8a:	e2 f7       	brpl	.-8      	; 0x2f84 <_ZN7base232C1EjP12USART_struct+0x10e>
    2f8c:	80 95       	com	r24
    2f8e:	90 95       	com	r25
    2f90:	82 23       	and	r24, r18
    2f92:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2f94:	80 e1       	ldi	r24, 0x10	; 16
    2f96:	13 96       	adiw	r26, 0x03	; 3
    2f98:	8c 93       	st	X, r24
    2f9a:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2f9c:	83 e0       	ldi	r24, 0x03	; 3
    2f9e:	15 96       	adiw	r26, 0x05	; 5
    2fa0:	8c 93       	st	X, r24
    2fa2:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2fa4:	80 ef       	ldi	r24, 0xF0	; 240
    2fa6:	17 96       	adiw	r26, 0x07	; 7
    2fa8:	8c 93       	st	X, r24
    2faa:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2fac:	81 e2       	ldi	r24, 0x21	; 33
    2fae:	16 96       	adiw	r26, 0x06	; 6
    2fb0:	8c 93       	st	X, r24
    2fb2:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2fb4:	88 e1       	ldi	r24, 0x18	; 24
    2fb6:	14 96       	adiw	r26, 0x04	; 4
    2fb8:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2fba:	80 e8       	ldi	r24, 0x80	; 128
    2fbc:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2fbe:	80 e4       	ldi	r24, 0x40	; 64
    2fc0:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2fc2:	80 e2       	ldi	r24, 0x20	; 32
    2fc4:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2fc6:	06 80       	ldd	r0, Z+6	; 0x06
    2fc8:	f7 81       	ldd	r31, Z+7	; 0x07
    2fca:	e0 2d       	mov	r30, r0
    2fcc:	80 81       	ld	r24, Z
    2fce:	80 81       	ld	r24, Z
}
    2fd0:	df 91       	pop	r29
    2fd2:	cf 91       	pop	r28
    2fd4:	08 95       	ret

00002fd6 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2fd6:	81 e0       	ldi	r24, 0x01	; 1
    2fd8:	08 95       	ret

00002fda <_ZN8emstream7getcharEv>:
    2fda:	80 e0       	ldi	r24, 0x00	; 0
    2fdc:	90 e0       	ldi	r25, 0x00	; 0
    2fde:	08 95       	ret

00002fe0 <_ZN8emstream14check_for_charEv>:
    2fe0:	80 e0       	ldi	r24, 0x00	; 0
    2fe2:	08 95       	ret

00002fe4 <_ZN8emstream12transmit_nowEv>:
    2fe4:	08 95       	ret

00002fe6 <_ZN8emstream12clear_screenEv>:
    2fe6:	08 95       	ret

00002fe8 <_ZN8emstreamC1Ev>:
    2fe8:	fc 01       	movw	r30, r24
    2fea:	89 e8       	ldi	r24, 0x89	; 137
    2fec:	90 e2       	ldi	r25, 0x20	; 32
    2fee:	80 83       	st	Z, r24
    2ff0:	91 83       	std	Z+1, r25	; 0x01
    2ff2:	8a e0       	ldi	r24, 0x0A	; 10
    2ff4:	82 83       	std	Z+2, r24	; 0x02
    2ff6:	13 82       	std	Z+3, r1	; 0x03
    2ff8:	83 e0       	ldi	r24, 0x03	; 3
    2ffa:	85 83       	std	Z+5, r24	; 0x05
    2ffc:	14 82       	std	Z+4, r1	; 0x04
    2ffe:	16 82       	std	Z+6, r1	; 0x06
    3000:	17 82       	std	Z+7, r1	; 0x07
    3002:	08 95       	ret

00003004 <_ZN8emstream4putsEPKc>:
    3004:	0f 93       	push	r16
    3006:	1f 93       	push	r17
    3008:	cf 93       	push	r28
    300a:	df 93       	push	r29
    300c:	8c 01       	movw	r16, r24
    300e:	fb 01       	movw	r30, r22
    3010:	dc 01       	movw	r26, r24
    3012:	14 96       	adiw	r26, 0x04	; 4
    3014:	8c 91       	ld	r24, X
    3016:	81 11       	cpse	r24, r1
    3018:	04 c0       	rjmp	.+8      	; 0x3022 <_ZN8emstream4putsEPKc+0x1e>
    301a:	60 81       	ld	r22, Z
    301c:	61 11       	cpse	r22, r1
    301e:	17 c0       	rjmp	.+46     	; 0x304e <_ZN8emstream4putsEPKc+0x4a>
    3020:	23 c0       	rjmp	.+70     	; 0x3068 <_ZN8emstream4putsEPKc+0x64>
    3022:	d8 01       	movw	r26, r16
    3024:	14 96       	adiw	r26, 0x04	; 4
    3026:	1c 92       	st	X, r1
    3028:	eb 01       	movw	r28, r22
    302a:	21 96       	adiw	r28, 0x01	; 1
    302c:	64 91       	lpm	r22, Z
    302e:	66 23       	and	r22, r22
    3030:	d9 f0       	breq	.+54     	; 0x3068 <_ZN8emstream4putsEPKc+0x64>
    3032:	d8 01       	movw	r26, r16
    3034:	ed 91       	ld	r30, X+
    3036:	fc 91       	ld	r31, X
    3038:	02 80       	ldd	r0, Z+2	; 0x02
    303a:	f3 81       	ldd	r31, Z+3	; 0x03
    303c:	e0 2d       	mov	r30, r0
    303e:	c8 01       	movw	r24, r16
    3040:	19 95       	eicall
    3042:	fe 01       	movw	r30, r28
    3044:	64 91       	lpm	r22, Z
    3046:	21 96       	adiw	r28, 0x01	; 1
    3048:	61 11       	cpse	r22, r1
    304a:	f3 cf       	rjmp	.-26     	; 0x3032 <_ZN8emstream4putsEPKc+0x2e>
    304c:	0d c0       	rjmp	.+26     	; 0x3068 <_ZN8emstream4putsEPKc+0x64>
    304e:	ef 01       	movw	r28, r30
    3050:	21 96       	adiw	r28, 0x01	; 1
    3052:	d8 01       	movw	r26, r16
    3054:	ed 91       	ld	r30, X+
    3056:	fc 91       	ld	r31, X
    3058:	02 80       	ldd	r0, Z+2	; 0x02
    305a:	f3 81       	ldd	r31, Z+3	; 0x03
    305c:	e0 2d       	mov	r30, r0
    305e:	c8 01       	movw	r24, r16
    3060:	19 95       	eicall
    3062:	69 91       	ld	r22, Y+
    3064:	61 11       	cpse	r22, r1
    3066:	f5 cf       	rjmp	.-22     	; 0x3052 <_ZN8emstream4putsEPKc+0x4e>
    3068:	df 91       	pop	r29
    306a:	cf 91       	pop	r28
    306c:	1f 91       	pop	r17
    306e:	0f 91       	pop	r16
    3070:	08 95       	ret

00003072 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3072:	cf 93       	push	r28
    3074:	df 93       	push	r29
    3076:	ec 01       	movw	r28, r24
	switch (new_manip)
    3078:	86 2f       	mov	r24, r22
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	8b 30       	cpi	r24, 0x0B	; 11
    307e:	91 05       	cpc	r25, r1
    3080:	d8 f5       	brcc	.+118    	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
    3082:	fc 01       	movw	r30, r24
    3084:	88 27       	eor	r24, r24
    3086:	e2 50       	subi	r30, 0x02	; 2
    3088:	ff 4f       	sbci	r31, 0xFF	; 255
    308a:	8f 4f       	sbci	r24, 0xFF	; 255
    308c:	0c 94 1f 20 	jmp	0x403e	; 0x403e <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3090:	82 e0       	ldi	r24, 0x02	; 2
    3092:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3094:	31 c0       	rjmp	.+98     	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3096:	88 e0       	ldi	r24, 0x08	; 8
    3098:	8a 83       	std	Y+2, r24	; 0x02
			break;
    309a:	2e c0       	rjmp	.+92     	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    309c:	8a e0       	ldi	r24, 0x0A	; 10
    309e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    30a0:	2b c0       	rjmp	.+86     	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    30a2:	80 e1       	ldi	r24, 0x10	; 16
    30a4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    30a6:	28 c0       	rjmp	.+80     	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    30a8:	81 e0       	ldi	r24, 0x01	; 1
    30aa:	8b 83       	std	Y+3, r24	; 0x03
			break;
    30ac:	25 c0       	rjmp	.+74     	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    30ae:	1b 82       	std	Y+3, r1	; 0x03
			break;
    30b0:	23 c0       	rjmp	.+70     	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    30b2:	e8 81       	ld	r30, Y
    30b4:	f9 81       	ldd	r31, Y+1	; 0x01
    30b6:	02 80       	ldd	r0, Z+2	; 0x02
    30b8:	f3 81       	ldd	r31, Z+3	; 0x03
    30ba:	e0 2d       	mov	r30, r0
    30bc:	6d e0       	ldi	r22, 0x0D	; 13
    30be:	ce 01       	movw	r24, r28
    30c0:	19 95       	eicall
    30c2:	e8 81       	ld	r30, Y
    30c4:	f9 81       	ldd	r31, Y+1	; 0x01
    30c6:	02 80       	ldd	r0, Z+2	; 0x02
    30c8:	f3 81       	ldd	r31, Z+3	; 0x03
    30ca:	e0 2d       	mov	r30, r0
    30cc:	6a e0       	ldi	r22, 0x0A	; 10
    30ce:	ce 01       	movw	r24, r28
    30d0:	19 95       	eicall
			break;
    30d2:	12 c0       	rjmp	.+36     	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    30d4:	e8 81       	ld	r30, Y
    30d6:	f9 81       	ldd	r31, Y+1	; 0x01
    30d8:	02 84       	ldd	r0, Z+10	; 0x0a
    30da:	f3 85       	ldd	r31, Z+11	; 0x0b
    30dc:	e0 2d       	mov	r30, r0
    30de:	ce 01       	movw	r24, r28
    30e0:	19 95       	eicall
			break;
    30e2:	0a c0       	rjmp	.+20     	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    30e4:	e8 81       	ld	r30, Y
    30e6:	f9 81       	ldd	r31, Y+1	; 0x01
    30e8:	00 84       	ldd	r0, Z+8	; 0x08
    30ea:	f1 85       	ldd	r31, Z+9	; 0x09
    30ec:	e0 2d       	mov	r30, r0
    30ee:	ce 01       	movw	r24, r28
    30f0:	19 95       	eicall
			break;
    30f2:	02 c0       	rjmp	.+4      	; 0x30f8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    30f4:	81 e0       	ldi	r24, 0x01	; 1
    30f6:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    30f8:	ce 01       	movw	r24, r28
    30fa:	df 91       	pop	r29
    30fc:	cf 91       	pop	r28
    30fe:	08 95       	ret

00003100 <_ZN8emstreamlsEb>:
 *          reference is used to string printable items together with "<<" operators
 *  @param value The boolean value to be written
 */

emstream& emstream::operator<< (bool value)
{
    3100:	cf 93       	push	r28
    3102:	df 93       	push	r29
    3104:	ec 01       	movw	r28, r24
	if (value)
    3106:	66 23       	and	r22, r22
    3108:	41 f0       	breq	.+16     	; 0x311a <_ZN8emstreamlsEb+0x1a>
		putchar ('T');
    310a:	e8 81       	ld	r30, Y
    310c:	f9 81       	ldd	r31, Y+1	; 0x01
    310e:	02 80       	ldd	r0, Z+2	; 0x02
    3110:	f3 81       	ldd	r31, Z+3	; 0x03
    3112:	e0 2d       	mov	r30, r0
    3114:	64 e5       	ldi	r22, 0x54	; 84
    3116:	19 95       	eicall
    3118:	07 c0       	rjmp	.+14     	; 0x3128 <_ZN8emstreamlsEb+0x28>
	else
		putchar ('F');
    311a:	e8 81       	ld	r30, Y
    311c:	f9 81       	ldd	r31, Y+1	; 0x01
    311e:	02 80       	ldd	r0, Z+2	; 0x02
    3120:	f3 81       	ldd	r31, Z+3	; 0x03
    3122:	e0 2d       	mov	r30, r0
    3124:	66 e4       	ldi	r22, 0x46	; 70
    3126:	19 95       	eicall

	return (*this);
}
    3128:	ce 01       	movw	r24, r28
    312a:	df 91       	pop	r29
    312c:	cf 91       	pop	r28
    312e:	08 95       	ret

00003130 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    3130:	0f 93       	push	r16
    3132:	1f 93       	push	r17
    3134:	cf 93       	push	r28
    3136:	df 93       	push	r29
    3138:	cd b7       	in	r28, 0x3d	; 61
    313a:	de b7       	in	r29, 0x3e	; 62
    313c:	61 97       	sbiw	r28, 0x11	; 17
    313e:	cd bf       	out	0x3d, r28	; 61
    3140:	de bf       	out	0x3e, r29	; 62
    3142:	8c 01       	movw	r16, r24
    3144:	9b 01       	movw	r18, r22
	if (base != 10)
    3146:	fc 01       	movw	r30, r24
    3148:	92 81       	ldd	r25, Z+2	; 0x02
    314a:	9a 30       	cpi	r25, 0x0A	; 10
    314c:	21 f0       	breq	.+8      	; 0x3156 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    314e:	c8 01       	movw	r24, r16
    3150:	0e 94 c1 18 	call	0x3182	; 0x3182 <_ZN8emstreamlsEj>
    3154:	0d c0       	rjmp	.+26     	; 0x3170 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3156:	4a e0       	ldi	r20, 0x0A	; 10
    3158:	be 01       	movw	r22, r28
    315a:	6f 5f       	subi	r22, 0xFF	; 255
    315c:	7f 4f       	sbci	r23, 0xFF	; 255
    315e:	c9 01       	movw	r24, r18
    3160:	0e 94 75 20 	call	0x40ea	; 0x40ea <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    3164:	be 01       	movw	r22, r28
    3166:	6f 5f       	subi	r22, 0xFF	; 255
    3168:	7f 4f       	sbci	r23, 0xFF	; 255
    316a:	c8 01       	movw	r24, r16
    316c:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3170:	c8 01       	movw	r24, r16
    3172:	61 96       	adiw	r28, 0x11	; 17
    3174:	cd bf       	out	0x3d, r28	; 61
    3176:	de bf       	out	0x3e, r29	; 62
    3178:	df 91       	pop	r29
    317a:	cf 91       	pop	r28
    317c:	1f 91       	pop	r17
    317e:	0f 91       	pop	r16
    3180:	08 95       	ret

00003182 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3182:	ff 92       	push	r15
    3184:	0f 93       	push	r16
    3186:	1f 93       	push	r17
    3188:	cf 93       	push	r28
    318a:	df 93       	push	r29
    318c:	cd b7       	in	r28, 0x3d	; 61
    318e:	de b7       	in	r29, 0x3e	; 62
    3190:	61 97       	sbiw	r28, 0x11	; 17
    3192:	cd bf       	out	0x3d, r28	; 61
    3194:	de bf       	out	0x3e, r29	; 62
    3196:	8c 01       	movw	r16, r24
    3198:	f6 2e       	mov	r15, r22
    319a:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    319c:	f8 01       	movw	r30, r16
    319e:	42 81       	ldd	r20, Z+2	; 0x02
    31a0:	40 31       	cpi	r20, 0x10	; 16
    31a2:	21 f0       	breq	.+8      	; 0x31ac <_ZN8emstreamlsEj+0x2a>
    31a4:	48 30       	cpi	r20, 0x08	; 8
    31a6:	11 f0       	breq	.+4      	; 0x31ac <_ZN8emstreamlsEj+0x2a>
    31a8:	42 30       	cpi	r20, 0x02	; 2
    31aa:	41 f4       	brne	.+16     	; 0x31bc <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    31ac:	69 2f       	mov	r22, r25
    31ae:	c8 01       	movw	r24, r16
    31b0:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
    31b4:	6f 2d       	mov	r22, r15
    31b6:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
    31ba:	0d c0       	rjmp	.+26     	; 0x31d6 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    31bc:	50 e0       	ldi	r21, 0x00	; 0
    31be:	be 01       	movw	r22, r28
    31c0:	6f 5f       	subi	r22, 0xFF	; 255
    31c2:	7f 4f       	sbci	r23, 0xFF	; 255
    31c4:	8f 2d       	mov	r24, r15
    31c6:	0e 94 ad 20 	call	0x415a	; 0x415a <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    31ca:	be 01       	movw	r22, r28
    31cc:	6f 5f       	subi	r22, 0xFF	; 255
    31ce:	7f 4f       	sbci	r23, 0xFF	; 255
    31d0:	c8 01       	movw	r24, r16
    31d2:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    31d6:	c8 01       	movw	r24, r16
    31d8:	61 96       	adiw	r28, 0x11	; 17
    31da:	cd bf       	out	0x3d, r28	; 61
    31dc:	de bf       	out	0x3e, r29	; 62
    31de:	df 91       	pop	r29
    31e0:	cf 91       	pop	r28
    31e2:	1f 91       	pop	r17
    31e4:	0f 91       	pop	r16
    31e6:	ff 90       	pop	r15
    31e8:	08 95       	ret

000031ea <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    31ea:	df 92       	push	r13
    31ec:	ef 92       	push	r14
    31ee:	ff 92       	push	r15
    31f0:	0f 93       	push	r16
    31f2:	1f 93       	push	r17
    31f4:	cf 93       	push	r28
    31f6:	df 93       	push	r29
    31f8:	cd b7       	in	r28, 0x3d	; 61
    31fa:	de b7       	in	r29, 0x3e	; 62
    31fc:	a1 97       	sbiw	r28, 0x21	; 33
    31fe:	cd bf       	out	0x3d, r28	; 61
    3200:	de bf       	out	0x3e, r29	; 62
    3202:	8c 01       	movw	r16, r24
    3204:	d4 2e       	mov	r13, r20
    3206:	e5 2e       	mov	r14, r21
    3208:	f6 2e       	mov	r15, r22
    320a:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    320c:	f8 01       	movw	r30, r16
    320e:	22 81       	ldd	r18, Z+2	; 0x02
    3210:	20 31       	cpi	r18, 0x10	; 16
    3212:	21 f0       	breq	.+8      	; 0x321c <_ZN8emstreamlsEm+0x32>
    3214:	28 30       	cpi	r18, 0x08	; 8
    3216:	11 f0       	breq	.+4      	; 0x321c <_ZN8emstreamlsEm+0x32>
    3218:	22 30       	cpi	r18, 0x02	; 2
    321a:	71 f4       	brne	.+28     	; 0x3238 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    321c:	69 2f       	mov	r22, r25
    321e:	c8 01       	movw	r24, r16
    3220:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
    3224:	6f 2d       	mov	r22, r15
    3226:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
    322a:	6e 2d       	mov	r22, r14
    322c:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
    3230:	6d 2d       	mov	r22, r13
    3232:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN8emstreamlsEh>
    3236:	0f c0       	rjmp	.+30     	; 0x3256 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3238:	30 e0       	ldi	r19, 0x00	; 0
    323a:	ae 01       	movw	r20, r28
    323c:	4f 5f       	subi	r20, 0xFF	; 255
    323e:	5f 4f       	sbci	r21, 0xFF	; 255
    3240:	6d 2d       	mov	r22, r13
    3242:	7e 2d       	mov	r23, r14
    3244:	8f 2d       	mov	r24, r15
    3246:	0e 94 80 20 	call	0x4100	; 0x4100 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    324a:	be 01       	movw	r22, r28
    324c:	6f 5f       	subi	r22, 0xFF	; 255
    324e:	7f 4f       	sbci	r23, 0xFF	; 255
    3250:	c8 01       	movw	r24, r16
    3252:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3256:	c8 01       	movw	r24, r16
    3258:	a1 96       	adiw	r28, 0x21	; 33
    325a:	cd bf       	out	0x3d, r28	; 61
    325c:	de bf       	out	0x3e, r29	; 62
    325e:	df 91       	pop	r29
    3260:	cf 91       	pop	r28
    3262:	1f 91       	pop	r17
    3264:	0f 91       	pop	r16
    3266:	ff 90       	pop	r15
    3268:	ef 90       	pop	r14
    326a:	df 90       	pop	r13
    326c:	08 95       	ret

0000326e <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    326e:	cf 92       	push	r12
    3270:	df 92       	push	r13
    3272:	ef 92       	push	r14
    3274:	ff 92       	push	r15
    3276:	0f 93       	push	r16
    3278:	1f 93       	push	r17
    327a:	cf 93       	push	r28
    327c:	df 93       	push	r29
    327e:	cd b7       	in	r28, 0x3d	; 61
    3280:	de b7       	in	r29, 0x3e	; 62
    3282:	29 97       	sbiw	r28, 0x09	; 9
    3284:	cd bf       	out	0x3d, r28	; 61
    3286:	de bf       	out	0x3e, r29	; 62
    3288:	8c 01       	movw	r16, r24
    328a:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    328c:	dc 01       	movw	r26, r24
    328e:	13 96       	adiw	r26, 0x03	; 3
    3290:	8c 91       	ld	r24, X
    3292:	13 97       	sbiw	r26, 0x03	; 3
    3294:	88 23       	and	r24, r24
    3296:	41 f0       	breq	.+16     	; 0x32a8 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3298:	ed 91       	ld	r30, X+
    329a:	fc 91       	ld	r31, X
    329c:	02 80       	ldd	r0, Z+2	; 0x02
    329e:	f3 81       	ldd	r31, Z+3	; 0x03
    32a0:	e0 2d       	mov	r30, r0
    32a2:	c8 01       	movw	r24, r16
    32a4:	19 95       	eicall
    32a6:	56 c0       	rjmp	.+172    	; 0x3354 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    32a8:	f8 01       	movw	r30, r16
    32aa:	42 81       	ldd	r20, Z+2	; 0x02
    32ac:	42 30       	cpi	r20, 0x02	; 2
    32ae:	19 f5       	brne	.+70     	; 0x32f6 <_ZN8emstreamlsEh+0x88>
    32b0:	68 94       	set
    32b2:	cc 24       	eor	r12, r12
    32b4:	c3 f8       	bld	r12, 3
    32b6:	d1 2c       	mov	r13, r1
    32b8:	68 94       	set
    32ba:	ff 24       	eor	r15, r15
    32bc:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    32be:	8e 2d       	mov	r24, r14
    32c0:	8f 21       	and	r24, r15
    32c2:	51 f0       	breq	.+20     	; 0x32d8 <_ZN8emstreamlsEh+0x6a>
    32c4:	d8 01       	movw	r26, r16
    32c6:	ed 91       	ld	r30, X+
    32c8:	fc 91       	ld	r31, X
    32ca:	02 80       	ldd	r0, Z+2	; 0x02
    32cc:	f3 81       	ldd	r31, Z+3	; 0x03
    32ce:	e0 2d       	mov	r30, r0
    32d0:	61 e3       	ldi	r22, 0x31	; 49
    32d2:	c8 01       	movw	r24, r16
    32d4:	19 95       	eicall
    32d6:	09 c0       	rjmp	.+18     	; 0x32ea <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    32d8:	d8 01       	movw	r26, r16
    32da:	ed 91       	ld	r30, X+
    32dc:	fc 91       	ld	r31, X
    32de:	02 80       	ldd	r0, Z+2	; 0x02
    32e0:	f3 81       	ldd	r31, Z+3	; 0x03
    32e2:	e0 2d       	mov	r30, r0
    32e4:	60 e3       	ldi	r22, 0x30	; 48
    32e6:	c8 01       	movw	r24, r16
    32e8:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    32ea:	f6 94       	lsr	r15
    32ec:	b1 e0       	ldi	r27, 0x01	; 1
    32ee:	cb 1a       	sub	r12, r27
    32f0:	d1 08       	sbc	r13, r1
    32f2:	29 f7       	brne	.-54     	; 0x32be <_ZN8emstreamlsEh+0x50>
    32f4:	2f c0       	rjmp	.+94     	; 0x3354 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    32f6:	40 31       	cpi	r20, 0x10	; 16
    32f8:	f9 f4       	brne	.+62     	; 0x3338 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    32fa:	62 95       	swap	r22
    32fc:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    32fe:	01 90       	ld	r0, Z+
    3300:	f0 81       	ld	r31, Z
    3302:	e0 2d       	mov	r30, r0
    3304:	02 80       	ldd	r0, Z+2	; 0x02
    3306:	f3 81       	ldd	r31, Z+3	; 0x03
    3308:	e0 2d       	mov	r30, r0
    330a:	6a 30       	cpi	r22, 0x0A	; 10
    330c:	10 f0       	brcs	.+4      	; 0x3312 <_ZN8emstreamlsEh+0xa4>
    330e:	69 5c       	subi	r22, 0xC9	; 201
    3310:	01 c0       	rjmp	.+2      	; 0x3314 <_ZN8emstreamlsEh+0xa6>
    3312:	60 5d       	subi	r22, 0xD0	; 208
    3314:	c8 01       	movw	r24, r16
    3316:	19 95       	eicall
		temp_char = num & 0x0F;
    3318:	6e 2d       	mov	r22, r14
    331a:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    331c:	d8 01       	movw	r26, r16
    331e:	ed 91       	ld	r30, X+
    3320:	fc 91       	ld	r31, X
    3322:	02 80       	ldd	r0, Z+2	; 0x02
    3324:	f3 81       	ldd	r31, Z+3	; 0x03
    3326:	e0 2d       	mov	r30, r0
    3328:	6a 30       	cpi	r22, 0x0A	; 10
    332a:	10 f0       	brcs	.+4      	; 0x3330 <_ZN8emstreamlsEh+0xc2>
    332c:	69 5c       	subi	r22, 0xC9	; 201
    332e:	01 c0       	rjmp	.+2      	; 0x3332 <_ZN8emstreamlsEh+0xc4>
    3330:	60 5d       	subi	r22, 0xD0	; 208
    3332:	c8 01       	movw	r24, r16
    3334:	19 95       	eicall
    3336:	0e c0       	rjmp	.+28     	; 0x3354 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3338:	50 e0       	ldi	r21, 0x00	; 0
    333a:	be 01       	movw	r22, r28
    333c:	6f 5f       	subi	r22, 0xFF	; 255
    333e:	7f 4f       	sbci	r23, 0xFF	; 255
    3340:	8e 2d       	mov	r24, r14
    3342:	90 e0       	ldi	r25, 0x00	; 0
    3344:	0e 94 ad 20 	call	0x415a	; 0x415a <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3348:	be 01       	movw	r22, r28
    334a:	6f 5f       	subi	r22, 0xFF	; 255
    334c:	7f 4f       	sbci	r23, 0xFF	; 255
    334e:	c8 01       	movw	r24, r16
    3350:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3354:	c8 01       	movw	r24, r16
    3356:	29 96       	adiw	r28, 0x09	; 9
    3358:	cd bf       	out	0x3d, r28	; 61
    335a:	de bf       	out	0x3e, r29	; 62
    335c:	df 91       	pop	r29
    335e:	cf 91       	pop	r28
    3360:	1f 91       	pop	r17
    3362:	0f 91       	pop	r16
    3364:	ff 90       	pop	r15
    3366:	ef 90       	pop	r14
    3368:	df 90       	pop	r13
    336a:	cf 90       	pop	r12
    336c:	08 95       	ret

0000336e <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    336e:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3370:	50 96       	adiw	r26, 0x10	; 16
    3372:	ed 91       	ld	r30, X+
    3374:	fc 91       	ld	r31, X
    3376:	51 97       	sbiw	r26, 0x11	; 17
    3378:	80 81       	ld	r24, Z
    337a:	54 96       	adiw	r26, 0x14	; 20
    337c:	4c 91       	ld	r20, X
    337e:	54 97       	sbiw	r26, 0x14	; 20
    3380:	84 23       	and	r24, r20
    3382:	29 f0       	breq	.+10     	; 0x338e <_ZN5rs2327putcharEc+0x20>
    3384:	09 c0       	rjmp	.+18     	; 0x3398 <_ZN5rs2327putcharEc+0x2a>
    3386:	21 50       	subi	r18, 0x01	; 1
    3388:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    338a:	19 f4       	brne	.+6      	; 0x3392 <_ZN5rs2327putcharEc+0x24>
    338c:	12 c0       	rjmp	.+36     	; 0x33b2 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    338e:	21 e2       	ldi	r18, 0x21	; 33
    3390:	3e e4       	ldi	r19, 0x4E	; 78
    3392:	90 81       	ld	r25, Z
    3394:	94 23       	and	r25, r20
    3396:	b9 f3       	breq	.-18     	; 0x3386 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3398:	90 81       	ld	r25, Z
    339a:	56 96       	adiw	r26, 0x16	; 22
    339c:	8c 91       	ld	r24, X
    339e:	56 97       	sbiw	r26, 0x16	; 22
    33a0:	89 2b       	or	r24, r25
    33a2:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    33a4:	1e 96       	adiw	r26, 0x0e	; 14
    33a6:	ed 91       	ld	r30, X+
    33a8:	fc 91       	ld	r31, X
    33aa:	1f 97       	sbiw	r26, 0x0f	; 15
    33ac:	60 83       	st	Z, r22
	return (true);
    33ae:	81 e0       	ldi	r24, 0x01	; 1
    33b0:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    33b2:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    33b4:	08 95       	ret

000033b6 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    33b6:	cf 93       	push	r28
    33b8:	df 93       	push	r29
    33ba:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    33bc:	c1 8d       	ldd	r28, Z+25	; 0x19
    33be:	d2 8d       	ldd	r29, Z+26	; 0x1a
    33c0:	28 81       	ld	r18, Y
    33c2:	39 81       	ldd	r19, Y+1	; 0x01
    33c4:	a3 8d       	ldd	r26, Z+27	; 0x1b
    33c6:	b4 8d       	ldd	r27, Z+28	; 0x1c
    33c8:	4d 91       	ld	r20, X+
    33ca:	5c 91       	ld	r21, X
    33cc:	24 17       	cp	r18, r20
    33ce:	35 07       	cpc	r19, r21
    33d0:	e9 f3       	breq	.-6      	; 0x33cc <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    33d2:	a7 89       	ldd	r26, Z+23	; 0x17
    33d4:	b0 8d       	ldd	r27, Z+24	; 0x18
    33d6:	0d 90       	ld	r0, X+
    33d8:	bc 91       	ld	r27, X
    33da:	a0 2d       	mov	r26, r0
    33dc:	a2 0f       	add	r26, r18
    33de:	b3 1f       	adc	r27, r19
    33e0:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    33e2:	2f 5f       	subi	r18, 0xFF	; 255
    33e4:	3f 4f       	sbci	r19, 0xFF	; 255
    33e6:	28 83       	st	Y, r18
    33e8:	39 83       	std	Y+1, r19	; 0x01
    33ea:	24 36       	cpi	r18, 0x64	; 100
    33ec:	31 05       	cpc	r19, r1
    33ee:	28 f0       	brcs	.+10     	; 0x33fa <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    33f0:	01 8c       	ldd	r0, Z+25	; 0x19
    33f2:	f2 8d       	ldd	r31, Z+26	; 0x1a
    33f4:	e0 2d       	mov	r30, r0
    33f6:	10 82       	st	Z, r1
    33f8:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    33fa:	90 e0       	ldi	r25, 0x00	; 0
    33fc:	df 91       	pop	r29
    33fe:	cf 91       	pop	r28
    3400:	08 95       	ret

00003402 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3402:	cf 93       	push	r28
    3404:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3406:	ec 01       	movw	r28, r24
    3408:	a9 8d       	ldd	r26, Y+25	; 0x19
    340a:	ba 8d       	ldd	r27, Y+26	; 0x1a
    340c:	eb 8d       	ldd	r30, Y+27	; 0x1b
    340e:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3410:	81 e0       	ldi	r24, 0x01	; 1
    3412:	4d 91       	ld	r20, X+
    3414:	5c 91       	ld	r21, X
    3416:	20 81       	ld	r18, Z
    3418:	31 81       	ldd	r19, Z+1	; 0x01
    341a:	42 17       	cp	r20, r18
    341c:	53 07       	cpc	r21, r19
    341e:	09 f4       	brne	.+2      	; 0x3422 <_ZN5rs23214check_for_charEv+0x20>
    3420:	80 e0       	ldi	r24, 0x00	; 0
}
    3422:	df 91       	pop	r29
    3424:	cf 91       	pop	r28
    3426:	08 95       	ret

00003428 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3428:	dc 01       	movw	r26, r24
    342a:	ed 91       	ld	r30, X+
    342c:	fc 91       	ld	r31, X
    342e:	02 80       	ldd	r0, Z+2	; 0x02
    3430:	f3 81       	ldd	r31, Z+3	; 0x03
    3432:	e0 2d       	mov	r30, r0
    3434:	6c e0       	ldi	r22, 0x0C	; 12
    3436:	19 95       	eicall
    3438:	08 95       	ret

0000343a <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    343a:	ef 92       	push	r14
    343c:	ff 92       	push	r15
    343e:	0f 93       	push	r16
    3440:	1f 93       	push	r17
    3442:	cf 93       	push	r28
    3444:	df 93       	push	r29
    3446:	ec 01       	movw	r28, r24
    3448:	7b 01       	movw	r14, r22
    344a:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    344c:	0e 94 f4 17 	call	0x2fe8	; 0x2fe8 <_ZN8emstreamC1Ev>
    3450:	a8 01       	movw	r20, r16
    3452:	b7 01       	movw	r22, r14
    3454:	ce 01       	movw	r24, r28
    3456:	08 96       	adiw	r24, 0x08	; 8
    3458:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <_ZN7base232C1EjP12USART_struct>
    345c:	89 e9       	ldi	r24, 0x99	; 153
    345e:	90 e2       	ldi	r25, 0x20	; 32
    3460:	88 83       	st	Y, r24
    3462:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3464:	00 3a       	cpi	r16, 0xA0	; 160
    3466:	88 e0       	ldi	r24, 0x08	; 8
    3468:	18 07       	cpc	r17, r24
    346a:	69 f4       	brne	.+26     	; 0x3486 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    346c:	88 e8       	ldi	r24, 0x88	; 136
    346e:	91 e3       	ldi	r25, 0x31	; 49
    3470:	8f 8b       	std	Y+23, r24	; 0x17
    3472:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3474:	8a e7       	ldi	r24, 0x7A	; 122
    3476:	91 e3       	ldi	r25, 0x31	; 49
    3478:	89 8f       	std	Y+25, r24	; 0x19
    347a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    347c:	8c e6       	ldi	r24, 0x6C	; 108
    347e:	91 e3       	ldi	r25, 0x31	; 49
    3480:	8b 8f       	std	Y+27, r24	; 0x1b
    3482:	9c 8f       	std	Y+28, r25	; 0x1c
    3484:	64 c0       	rjmp	.+200    	; 0x354e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3486:	00 3b       	cpi	r16, 0xB0	; 176
    3488:	e8 e0       	ldi	r30, 0x08	; 8
    348a:	1e 07       	cpc	r17, r30
    348c:	69 f4       	brne	.+26     	; 0x34a8 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    348e:	86 e8       	ldi	r24, 0x86	; 134
    3490:	91 e3       	ldi	r25, 0x31	; 49
    3492:	8f 8b       	std	Y+23, r24	; 0x17
    3494:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3496:	88 e7       	ldi	r24, 0x78	; 120
    3498:	91 e3       	ldi	r25, 0x31	; 49
    349a:	89 8f       	std	Y+25, r24	; 0x19
    349c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    349e:	8a e6       	ldi	r24, 0x6A	; 106
    34a0:	91 e3       	ldi	r25, 0x31	; 49
    34a2:	8b 8f       	std	Y+27, r24	; 0x1b
    34a4:	9c 8f       	std	Y+28, r25	; 0x1c
    34a6:	53 c0       	rjmp	.+166    	; 0x354e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    34a8:	00 3a       	cpi	r16, 0xA0	; 160
    34aa:	f9 e0       	ldi	r31, 0x09	; 9
    34ac:	1f 07       	cpc	r17, r31
    34ae:	69 f4       	brne	.+26     	; 0x34ca <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    34b0:	84 e8       	ldi	r24, 0x84	; 132
    34b2:	91 e3       	ldi	r25, 0x31	; 49
    34b4:	8f 8b       	std	Y+23, r24	; 0x17
    34b6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    34b8:	86 e7       	ldi	r24, 0x76	; 118
    34ba:	91 e3       	ldi	r25, 0x31	; 49
    34bc:	89 8f       	std	Y+25, r24	; 0x19
    34be:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    34c0:	88 e6       	ldi	r24, 0x68	; 104
    34c2:	91 e3       	ldi	r25, 0x31	; 49
    34c4:	8b 8f       	std	Y+27, r24	; 0x1b
    34c6:	9c 8f       	std	Y+28, r25	; 0x1c
    34c8:	42 c0       	rjmp	.+132    	; 0x354e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    34ca:	00 3b       	cpi	r16, 0xB0	; 176
    34cc:	89 e0       	ldi	r24, 0x09	; 9
    34ce:	18 07       	cpc	r17, r24
    34d0:	69 f4       	brne	.+26     	; 0x34ec <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    34d2:	82 e8       	ldi	r24, 0x82	; 130
    34d4:	91 e3       	ldi	r25, 0x31	; 49
    34d6:	8f 8b       	std	Y+23, r24	; 0x17
    34d8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    34da:	84 e7       	ldi	r24, 0x74	; 116
    34dc:	91 e3       	ldi	r25, 0x31	; 49
    34de:	89 8f       	std	Y+25, r24	; 0x19
    34e0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    34e2:	86 e6       	ldi	r24, 0x66	; 102
    34e4:	91 e3       	ldi	r25, 0x31	; 49
    34e6:	8b 8f       	std	Y+27, r24	; 0x1b
    34e8:	9c 8f       	std	Y+28, r25	; 0x1c
    34ea:	31 c0       	rjmp	.+98     	; 0x354e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    34ec:	00 3a       	cpi	r16, 0xA0	; 160
    34ee:	ea e0       	ldi	r30, 0x0A	; 10
    34f0:	1e 07       	cpc	r17, r30
    34f2:	69 f4       	brne	.+26     	; 0x350e <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    34f4:	80 e8       	ldi	r24, 0x80	; 128
    34f6:	91 e3       	ldi	r25, 0x31	; 49
    34f8:	8f 8b       	std	Y+23, r24	; 0x17
    34fa:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    34fc:	82 e7       	ldi	r24, 0x72	; 114
    34fe:	91 e3       	ldi	r25, 0x31	; 49
    3500:	89 8f       	std	Y+25, r24	; 0x19
    3502:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3504:	84 e6       	ldi	r24, 0x64	; 100
    3506:	91 e3       	ldi	r25, 0x31	; 49
    3508:	8b 8f       	std	Y+27, r24	; 0x1b
    350a:	9c 8f       	std	Y+28, r25	; 0x1c
    350c:	20 c0       	rjmp	.+64     	; 0x354e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    350e:	00 3b       	cpi	r16, 0xB0	; 176
    3510:	fa e0       	ldi	r31, 0x0A	; 10
    3512:	1f 07       	cpc	r17, r31
    3514:	69 f4       	brne	.+26     	; 0x3530 <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    3516:	8e e7       	ldi	r24, 0x7E	; 126
    3518:	91 e3       	ldi	r25, 0x31	; 49
    351a:	8f 8b       	std	Y+23, r24	; 0x17
    351c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    351e:	80 e7       	ldi	r24, 0x70	; 112
    3520:	91 e3       	ldi	r25, 0x31	; 49
    3522:	89 8f       	std	Y+25, r24	; 0x19
    3524:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    3526:	82 e6       	ldi	r24, 0x62	; 98
    3528:	91 e3       	ldi	r25, 0x31	; 49
    352a:	8b 8f       	std	Y+27, r24	; 0x1b
    352c:	9c 8f       	std	Y+28, r25	; 0x1c
    352e:	0f c0       	rjmp	.+30     	; 0x354e <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    3530:	00 3a       	cpi	r16, 0xA0	; 160
    3532:	1b 40       	sbci	r17, 0x0B	; 11
    3534:	61 f4       	brne	.+24     	; 0x354e <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    3536:	8c e7       	ldi	r24, 0x7C	; 124
    3538:	91 e3       	ldi	r25, 0x31	; 49
    353a:	8f 8b       	std	Y+23, r24	; 0x17
    353c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    353e:	8e e6       	ldi	r24, 0x6E	; 110
    3540:	91 e3       	ldi	r25, 0x31	; 49
    3542:	89 8f       	std	Y+25, r24	; 0x19
    3544:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    3546:	80 e6       	ldi	r24, 0x60	; 96
    3548:	91 e3       	ldi	r25, 0x31	; 49
    354a:	8b 8f       	std	Y+27, r24	; 0x1b
    354c:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    354e:	0f 89       	ldd	r16, Y+23	; 0x17
    3550:	18 8d       	ldd	r17, Y+24	; 0x18
    3552:	84 e6       	ldi	r24, 0x64	; 100
    3554:	90 e0       	ldi	r25, 0x00	; 0
    3556:	0e 94 37 17 	call	0x2e6e	; 0x2e6e <_Znaj>
    355a:	f8 01       	movw	r30, r16
    355c:	80 83       	st	Z, r24
    355e:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3560:	e9 8d       	ldd	r30, Y+25	; 0x19
    3562:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3564:	10 82       	st	Z, r1
    3566:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3568:	eb 8d       	ldd	r30, Y+27	; 0x1b
    356a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    356c:	10 82       	st	Z, r1
    356e:	11 82       	std	Z+1, r1	; 0x01
}
    3570:	df 91       	pop	r29
    3572:	cf 91       	pop	r28
    3574:	1f 91       	pop	r17
    3576:	0f 91       	pop	r16
    3578:	ff 90       	pop	r15
    357a:	ef 90       	pop	r14
    357c:	08 95       	ret

0000357e <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    357e:	1f 92       	push	r1
    3580:	0f 92       	push	r0
    3582:	0f b6       	in	r0, 0x3f	; 63
    3584:	0f 92       	push	r0
    3586:	11 24       	eor	r1, r1
    3588:	08 b6       	in	r0, 0x38	; 56
    358a:	0f 92       	push	r0
    358c:	18 be       	out	0x38, r1	; 56
    358e:	0b b6       	in	r0, 0x3b	; 59
    3590:	0f 92       	push	r0
    3592:	1b be       	out	0x3b, r1	; 59
    3594:	2f 93       	push	r18
    3596:	3f 93       	push	r19
    3598:	8f 93       	push	r24
    359a:	9f 93       	push	r25
    359c:	ef 93       	push	r30
    359e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    35a0:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    35a4:	e0 91 88 31 	lds	r30, 0x3188	; 0x803188 <rcvC0_buffer>
    35a8:	f0 91 89 31 	lds	r31, 0x3189	; 0x803189 <rcvC0_buffer+0x1>
    35ac:	80 91 6c 31 	lds	r24, 0x316C	; 0x80316c <rcvC0_write_index>
    35b0:	90 91 6d 31 	lds	r25, 0x316D	; 0x80316d <rcvC0_write_index+0x1>
    35b4:	e8 0f       	add	r30, r24
    35b6:	f9 1f       	adc	r31, r25
    35b8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    35ba:	80 91 6c 31 	lds	r24, 0x316C	; 0x80316c <rcvC0_write_index>
    35be:	90 91 6d 31 	lds	r25, 0x316D	; 0x80316d <rcvC0_write_index+0x1>
    35c2:	01 96       	adiw	r24, 0x01	; 1
    35c4:	84 36       	cpi	r24, 0x64	; 100
    35c6:	91 05       	cpc	r25, r1
    35c8:	60 f4       	brcc	.+24     	; 0x35e2 <__vector_25+0x64>
    35ca:	80 93 6c 31 	sts	0x316C, r24	; 0x80316c <rcvC0_write_index>
    35ce:	90 93 6d 31 	sts	0x316D, r25	; 0x80316d <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    35d2:	20 91 7a 31 	lds	r18, 0x317A	; 0x80317a <rcvC0_read_index>
    35d6:	30 91 7b 31 	lds	r19, 0x317B	; 0x80317b <rcvC0_read_index+0x1>
    35da:	82 17       	cp	r24, r18
    35dc:	93 07       	cpc	r25, r19
    35de:	f1 f4       	brne	.+60     	; 0x361c <__vector_25+0x9e>
    35e0:	0c c0       	rjmp	.+24     	; 0x35fa <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    35e2:	10 92 6c 31 	sts	0x316C, r1	; 0x80316c <rcvC0_write_index>
    35e6:	10 92 6d 31 	sts	0x316D, r1	; 0x80316d <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    35ea:	80 91 7a 31 	lds	r24, 0x317A	; 0x80317a <rcvC0_read_index>
    35ee:	90 91 7b 31 	lds	r25, 0x317B	; 0x80317b <rcvC0_read_index+0x1>
    35f2:	18 16       	cp	r1, r24
    35f4:	19 06       	cpc	r1, r25
    35f6:	91 f4       	brne	.+36     	; 0x361c <__vector_25+0x9e>
    35f8:	0e c0       	rjmp	.+28     	; 0x3616 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    35fa:	01 96       	adiw	r24, 0x01	; 1
    35fc:	84 36       	cpi	r24, 0x64	; 100
    35fe:	91 05       	cpc	r25, r1
    3600:	28 f4       	brcc	.+10     	; 0x360c <__vector_25+0x8e>
    3602:	80 93 7a 31 	sts	0x317A, r24	; 0x80317a <rcvC0_read_index>
    3606:	90 93 7b 31 	sts	0x317B, r25	; 0x80317b <rcvC0_read_index+0x1>
    360a:	08 c0       	rjmp	.+16     	; 0x361c <__vector_25+0x9e>
			rcvC0_read_index = 0;
    360c:	10 92 7a 31 	sts	0x317A, r1	; 0x80317a <rcvC0_read_index>
    3610:	10 92 7b 31 	sts	0x317B, r1	; 0x80317b <rcvC0_read_index+0x1>
}
    3614:	03 c0       	rjmp	.+6      	; 0x361c <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3616:	81 e0       	ldi	r24, 0x01	; 1
    3618:	90 e0       	ldi	r25, 0x00	; 0
    361a:	f3 cf       	rjmp	.-26     	; 0x3602 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    361c:	ff 91       	pop	r31
    361e:	ef 91       	pop	r30
    3620:	9f 91       	pop	r25
    3622:	8f 91       	pop	r24
    3624:	3f 91       	pop	r19
    3626:	2f 91       	pop	r18
    3628:	0f 90       	pop	r0
    362a:	0b be       	out	0x3b, r0	; 59
    362c:	0f 90       	pop	r0
    362e:	08 be       	out	0x38, r0	; 56
    3630:	0f 90       	pop	r0
    3632:	0f be       	out	0x3f, r0	; 63
    3634:	0f 90       	pop	r0
    3636:	1f 90       	pop	r1
    3638:	18 95       	reti

0000363a <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    363a:	1f 92       	push	r1
    363c:	0f 92       	push	r0
    363e:	0f b6       	in	r0, 0x3f	; 63
    3640:	0f 92       	push	r0
    3642:	11 24       	eor	r1, r1
    3644:	08 b6       	in	r0, 0x38	; 56
    3646:	0f 92       	push	r0
    3648:	18 be       	out	0x38, r1	; 56
    364a:	0b b6       	in	r0, 0x3b	; 59
    364c:	0f 92       	push	r0
    364e:	1b be       	out	0x3b, r1	; 59
    3650:	2f 93       	push	r18
    3652:	3f 93       	push	r19
    3654:	8f 93       	push	r24
    3656:	9f 93       	push	r25
    3658:	ef 93       	push	r30
    365a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    365c:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3660:	e0 91 86 31 	lds	r30, 0x3186	; 0x803186 <rcvC1_buffer>
    3664:	f0 91 87 31 	lds	r31, 0x3187	; 0x803187 <rcvC1_buffer+0x1>
    3668:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <rcvC1_write_index>
    366c:	90 91 6b 31 	lds	r25, 0x316B	; 0x80316b <rcvC1_write_index+0x1>
    3670:	e8 0f       	add	r30, r24
    3672:	f9 1f       	adc	r31, r25
    3674:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3676:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <rcvC1_write_index>
    367a:	90 91 6b 31 	lds	r25, 0x316B	; 0x80316b <rcvC1_write_index+0x1>
    367e:	01 96       	adiw	r24, 0x01	; 1
    3680:	84 36       	cpi	r24, 0x64	; 100
    3682:	91 05       	cpc	r25, r1
    3684:	60 f4       	brcc	.+24     	; 0x369e <__vector_28+0x64>
    3686:	80 93 6a 31 	sts	0x316A, r24	; 0x80316a <rcvC1_write_index>
    368a:	90 93 6b 31 	sts	0x316B, r25	; 0x80316b <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    368e:	20 91 78 31 	lds	r18, 0x3178	; 0x803178 <rcvC1_read_index>
    3692:	30 91 79 31 	lds	r19, 0x3179	; 0x803179 <rcvC1_read_index+0x1>
    3696:	82 17       	cp	r24, r18
    3698:	93 07       	cpc	r25, r19
    369a:	f1 f4       	brne	.+60     	; 0x36d8 <__vector_28+0x9e>
    369c:	0c c0       	rjmp	.+24     	; 0x36b6 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    369e:	10 92 6a 31 	sts	0x316A, r1	; 0x80316a <rcvC1_write_index>
    36a2:	10 92 6b 31 	sts	0x316B, r1	; 0x80316b <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    36a6:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <rcvC1_read_index>
    36aa:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <rcvC1_read_index+0x1>
    36ae:	18 16       	cp	r1, r24
    36b0:	19 06       	cpc	r1, r25
    36b2:	91 f4       	brne	.+36     	; 0x36d8 <__vector_28+0x9e>
    36b4:	0e c0       	rjmp	.+28     	; 0x36d2 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    36b6:	01 96       	adiw	r24, 0x01	; 1
    36b8:	84 36       	cpi	r24, 0x64	; 100
    36ba:	91 05       	cpc	r25, r1
    36bc:	28 f4       	brcc	.+10     	; 0x36c8 <__vector_28+0x8e>
    36be:	80 93 78 31 	sts	0x3178, r24	; 0x803178 <rcvC1_read_index>
    36c2:	90 93 79 31 	sts	0x3179, r25	; 0x803179 <rcvC1_read_index+0x1>
    36c6:	08 c0       	rjmp	.+16     	; 0x36d8 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    36c8:	10 92 78 31 	sts	0x3178, r1	; 0x803178 <rcvC1_read_index>
    36cc:	10 92 79 31 	sts	0x3179, r1	; 0x803179 <rcvC1_read_index+0x1>
}
    36d0:	03 c0       	rjmp	.+6      	; 0x36d8 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    36d2:	81 e0       	ldi	r24, 0x01	; 1
    36d4:	90 e0       	ldi	r25, 0x00	; 0
    36d6:	f3 cf       	rjmp	.-26     	; 0x36be <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    36d8:	ff 91       	pop	r31
    36da:	ef 91       	pop	r30
    36dc:	9f 91       	pop	r25
    36de:	8f 91       	pop	r24
    36e0:	3f 91       	pop	r19
    36e2:	2f 91       	pop	r18
    36e4:	0f 90       	pop	r0
    36e6:	0b be       	out	0x3b, r0	; 59
    36e8:	0f 90       	pop	r0
    36ea:	08 be       	out	0x38, r0	; 56
    36ec:	0f 90       	pop	r0
    36ee:	0f be       	out	0x3f, r0	; 63
    36f0:	0f 90       	pop	r0
    36f2:	1f 90       	pop	r1
    36f4:	18 95       	reti

000036f6 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    36f6:	1f 92       	push	r1
    36f8:	0f 92       	push	r0
    36fa:	0f b6       	in	r0, 0x3f	; 63
    36fc:	0f 92       	push	r0
    36fe:	11 24       	eor	r1, r1
    3700:	08 b6       	in	r0, 0x38	; 56
    3702:	0f 92       	push	r0
    3704:	18 be       	out	0x38, r1	; 56
    3706:	0b b6       	in	r0, 0x3b	; 59
    3708:	0f 92       	push	r0
    370a:	1b be       	out	0x3b, r1	; 59
    370c:	2f 93       	push	r18
    370e:	3f 93       	push	r19
    3710:	8f 93       	push	r24
    3712:	9f 93       	push	r25
    3714:	ef 93       	push	r30
    3716:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3718:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    371c:	e0 91 84 31 	lds	r30, 0x3184	; 0x803184 <rcvD0_buffer>
    3720:	f0 91 85 31 	lds	r31, 0x3185	; 0x803185 <rcvD0_buffer+0x1>
    3724:	80 91 6c 31 	lds	r24, 0x316C	; 0x80316c <rcvC0_write_index>
    3728:	90 91 6d 31 	lds	r25, 0x316D	; 0x80316d <rcvC0_write_index+0x1>
    372c:	e8 0f       	add	r30, r24
    372e:	f9 1f       	adc	r31, r25
    3730:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3732:	80 91 68 31 	lds	r24, 0x3168	; 0x803168 <rcvD0_write_index>
    3736:	90 91 69 31 	lds	r25, 0x3169	; 0x803169 <rcvD0_write_index+0x1>
    373a:	01 96       	adiw	r24, 0x01	; 1
    373c:	84 36       	cpi	r24, 0x64	; 100
    373e:	91 05       	cpc	r25, r1
    3740:	60 f4       	brcc	.+24     	; 0x375a <__vector_88+0x64>
    3742:	80 93 68 31 	sts	0x3168, r24	; 0x803168 <rcvD0_write_index>
    3746:	90 93 69 31 	sts	0x3169, r25	; 0x803169 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    374a:	20 91 76 31 	lds	r18, 0x3176	; 0x803176 <rcvD0_read_index>
    374e:	30 91 77 31 	lds	r19, 0x3177	; 0x803177 <rcvD0_read_index+0x1>
    3752:	82 17       	cp	r24, r18
    3754:	93 07       	cpc	r25, r19
    3756:	f1 f4       	brne	.+60     	; 0x3794 <__vector_88+0x9e>
    3758:	0c c0       	rjmp	.+24     	; 0x3772 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    375a:	10 92 68 31 	sts	0x3168, r1	; 0x803168 <rcvD0_write_index>
    375e:	10 92 69 31 	sts	0x3169, r1	; 0x803169 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3762:	80 91 76 31 	lds	r24, 0x3176	; 0x803176 <rcvD0_read_index>
    3766:	90 91 77 31 	lds	r25, 0x3177	; 0x803177 <rcvD0_read_index+0x1>
    376a:	18 16       	cp	r1, r24
    376c:	19 06       	cpc	r1, r25
    376e:	91 f4       	brne	.+36     	; 0x3794 <__vector_88+0x9e>
    3770:	0e c0       	rjmp	.+28     	; 0x378e <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3772:	01 96       	adiw	r24, 0x01	; 1
    3774:	84 36       	cpi	r24, 0x64	; 100
    3776:	91 05       	cpc	r25, r1
    3778:	28 f4       	brcc	.+10     	; 0x3784 <__vector_88+0x8e>
    377a:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <rcvD0_read_index>
    377e:	90 93 77 31 	sts	0x3177, r25	; 0x803177 <rcvD0_read_index+0x1>
    3782:	08 c0       	rjmp	.+16     	; 0x3794 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3784:	10 92 76 31 	sts	0x3176, r1	; 0x803176 <rcvD0_read_index>
    3788:	10 92 77 31 	sts	0x3177, r1	; 0x803177 <rcvD0_read_index+0x1>
}
    378c:	03 c0       	rjmp	.+6      	; 0x3794 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    378e:	81 e0       	ldi	r24, 0x01	; 1
    3790:	90 e0       	ldi	r25, 0x00	; 0
    3792:	f3 cf       	rjmp	.-26     	; 0x377a <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3794:	ff 91       	pop	r31
    3796:	ef 91       	pop	r30
    3798:	9f 91       	pop	r25
    379a:	8f 91       	pop	r24
    379c:	3f 91       	pop	r19
    379e:	2f 91       	pop	r18
    37a0:	0f 90       	pop	r0
    37a2:	0b be       	out	0x3b, r0	; 59
    37a4:	0f 90       	pop	r0
    37a6:	08 be       	out	0x38, r0	; 56
    37a8:	0f 90       	pop	r0
    37aa:	0f be       	out	0x3f, r0	; 63
    37ac:	0f 90       	pop	r0
    37ae:	1f 90       	pop	r1
    37b0:	18 95       	reti

000037b2 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    37b2:	1f 92       	push	r1
    37b4:	0f 92       	push	r0
    37b6:	0f b6       	in	r0, 0x3f	; 63
    37b8:	0f 92       	push	r0
    37ba:	11 24       	eor	r1, r1
    37bc:	08 b6       	in	r0, 0x38	; 56
    37be:	0f 92       	push	r0
    37c0:	18 be       	out	0x38, r1	; 56
    37c2:	0b b6       	in	r0, 0x3b	; 59
    37c4:	0f 92       	push	r0
    37c6:	1b be       	out	0x3b, r1	; 59
    37c8:	2f 93       	push	r18
    37ca:	3f 93       	push	r19
    37cc:	8f 93       	push	r24
    37ce:	9f 93       	push	r25
    37d0:	ef 93       	push	r30
    37d2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    37d4:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    37d8:	e0 91 82 31 	lds	r30, 0x3182	; 0x803182 <rcvD1_buffer>
    37dc:	f0 91 83 31 	lds	r31, 0x3183	; 0x803183 <rcvD1_buffer+0x1>
    37e0:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <rcvD1_write_index>
    37e4:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <rcvD1_write_index+0x1>
    37e8:	e8 0f       	add	r30, r24
    37ea:	f9 1f       	adc	r31, r25
    37ec:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    37ee:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <rcvD1_write_index>
    37f2:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <rcvD1_write_index+0x1>
    37f6:	01 96       	adiw	r24, 0x01	; 1
    37f8:	84 36       	cpi	r24, 0x64	; 100
    37fa:	91 05       	cpc	r25, r1
    37fc:	60 f4       	brcc	.+24     	; 0x3816 <__vector_91+0x64>
    37fe:	80 93 66 31 	sts	0x3166, r24	; 0x803166 <rcvD1_write_index>
    3802:	90 93 67 31 	sts	0x3167, r25	; 0x803167 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3806:	20 91 74 31 	lds	r18, 0x3174	; 0x803174 <rcvD1_read_index>
    380a:	30 91 75 31 	lds	r19, 0x3175	; 0x803175 <rcvD1_read_index+0x1>
    380e:	82 17       	cp	r24, r18
    3810:	93 07       	cpc	r25, r19
    3812:	f1 f4       	brne	.+60     	; 0x3850 <__vector_91+0x9e>
    3814:	0c c0       	rjmp	.+24     	; 0x382e <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3816:	10 92 66 31 	sts	0x3166, r1	; 0x803166 <rcvD1_write_index>
    381a:	10 92 67 31 	sts	0x3167, r1	; 0x803167 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    381e:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <rcvD1_read_index>
    3822:	90 91 75 31 	lds	r25, 0x3175	; 0x803175 <rcvD1_read_index+0x1>
    3826:	18 16       	cp	r1, r24
    3828:	19 06       	cpc	r1, r25
    382a:	91 f4       	brne	.+36     	; 0x3850 <__vector_91+0x9e>
    382c:	0e c0       	rjmp	.+28     	; 0x384a <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    382e:	01 96       	adiw	r24, 0x01	; 1
    3830:	84 36       	cpi	r24, 0x64	; 100
    3832:	91 05       	cpc	r25, r1
    3834:	28 f4       	brcc	.+10     	; 0x3840 <__vector_91+0x8e>
    3836:	80 93 74 31 	sts	0x3174, r24	; 0x803174 <rcvD1_read_index>
    383a:	90 93 75 31 	sts	0x3175, r25	; 0x803175 <rcvD1_read_index+0x1>
    383e:	08 c0       	rjmp	.+16     	; 0x3850 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3840:	10 92 74 31 	sts	0x3174, r1	; 0x803174 <rcvD1_read_index>
    3844:	10 92 75 31 	sts	0x3175, r1	; 0x803175 <rcvD1_read_index+0x1>
}
    3848:	03 c0       	rjmp	.+6      	; 0x3850 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    384a:	81 e0       	ldi	r24, 0x01	; 1
    384c:	90 e0       	ldi	r25, 0x00	; 0
    384e:	f3 cf       	rjmp	.-26     	; 0x3836 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3850:	ff 91       	pop	r31
    3852:	ef 91       	pop	r30
    3854:	9f 91       	pop	r25
    3856:	8f 91       	pop	r24
    3858:	3f 91       	pop	r19
    385a:	2f 91       	pop	r18
    385c:	0f 90       	pop	r0
    385e:	0b be       	out	0x3b, r0	; 59
    3860:	0f 90       	pop	r0
    3862:	08 be       	out	0x38, r0	; 56
    3864:	0f 90       	pop	r0
    3866:	0f be       	out	0x3f, r0	; 63
    3868:	0f 90       	pop	r0
    386a:	1f 90       	pop	r1
    386c:	18 95       	reti

0000386e <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    386e:	1f 92       	push	r1
    3870:	0f 92       	push	r0
    3872:	0f b6       	in	r0, 0x3f	; 63
    3874:	0f 92       	push	r0
    3876:	11 24       	eor	r1, r1
    3878:	08 b6       	in	r0, 0x38	; 56
    387a:	0f 92       	push	r0
    387c:	18 be       	out	0x38, r1	; 56
    387e:	0b b6       	in	r0, 0x3b	; 59
    3880:	0f 92       	push	r0
    3882:	1b be       	out	0x3b, r1	; 59
    3884:	2f 93       	push	r18
    3886:	3f 93       	push	r19
    3888:	8f 93       	push	r24
    388a:	9f 93       	push	r25
    388c:	ef 93       	push	r30
    388e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3890:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3894:	e0 91 80 31 	lds	r30, 0x3180	; 0x803180 <rcvE0_buffer>
    3898:	f0 91 81 31 	lds	r31, 0x3181	; 0x803181 <rcvE0_buffer+0x1>
    389c:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <rcvE0_write_index>
    38a0:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <rcvE0_write_index+0x1>
    38a4:	e8 0f       	add	r30, r24
    38a6:	f9 1f       	adc	r31, r25
    38a8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    38aa:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <rcvE0_write_index>
    38ae:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <rcvE0_write_index+0x1>
    38b2:	01 96       	adiw	r24, 0x01	; 1
    38b4:	84 36       	cpi	r24, 0x64	; 100
    38b6:	91 05       	cpc	r25, r1
    38b8:	60 f4       	brcc	.+24     	; 0x38d2 <__vector_58+0x64>
    38ba:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <rcvE0_write_index>
    38be:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    38c2:	20 91 72 31 	lds	r18, 0x3172	; 0x803172 <rcvE0_read_index>
    38c6:	30 91 73 31 	lds	r19, 0x3173	; 0x803173 <rcvE0_read_index+0x1>
    38ca:	82 17       	cp	r24, r18
    38cc:	93 07       	cpc	r25, r19
    38ce:	f1 f4       	brne	.+60     	; 0x390c <__vector_58+0x9e>
    38d0:	0c c0       	rjmp	.+24     	; 0x38ea <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    38d2:	10 92 64 31 	sts	0x3164, r1	; 0x803164 <rcvE0_write_index>
    38d6:	10 92 65 31 	sts	0x3165, r1	; 0x803165 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    38da:	80 91 72 31 	lds	r24, 0x3172	; 0x803172 <rcvE0_read_index>
    38de:	90 91 73 31 	lds	r25, 0x3173	; 0x803173 <rcvE0_read_index+0x1>
    38e2:	18 16       	cp	r1, r24
    38e4:	19 06       	cpc	r1, r25
    38e6:	91 f4       	brne	.+36     	; 0x390c <__vector_58+0x9e>
    38e8:	0e c0       	rjmp	.+28     	; 0x3906 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    38ea:	01 96       	adiw	r24, 0x01	; 1
    38ec:	84 36       	cpi	r24, 0x64	; 100
    38ee:	91 05       	cpc	r25, r1
    38f0:	28 f4       	brcc	.+10     	; 0x38fc <__vector_58+0x8e>
    38f2:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <rcvE0_read_index>
    38f6:	90 93 73 31 	sts	0x3173, r25	; 0x803173 <rcvE0_read_index+0x1>
    38fa:	08 c0       	rjmp	.+16     	; 0x390c <__vector_58+0x9e>
	rcvE0_read_index = 0;
    38fc:	10 92 72 31 	sts	0x3172, r1	; 0x803172 <rcvE0_read_index>
    3900:	10 92 73 31 	sts	0x3173, r1	; 0x803173 <rcvE0_read_index+0x1>
}
    3904:	03 c0       	rjmp	.+6      	; 0x390c <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3906:	81 e0       	ldi	r24, 0x01	; 1
    3908:	90 e0       	ldi	r25, 0x00	; 0
    390a:	f3 cf       	rjmp	.-26     	; 0x38f2 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    390c:	ff 91       	pop	r31
    390e:	ef 91       	pop	r30
    3910:	9f 91       	pop	r25
    3912:	8f 91       	pop	r24
    3914:	3f 91       	pop	r19
    3916:	2f 91       	pop	r18
    3918:	0f 90       	pop	r0
    391a:	0b be       	out	0x3b, r0	; 59
    391c:	0f 90       	pop	r0
    391e:	08 be       	out	0x38, r0	; 56
    3920:	0f 90       	pop	r0
    3922:	0f be       	out	0x3f, r0	; 63
    3924:	0f 90       	pop	r0
    3926:	1f 90       	pop	r1
    3928:	18 95       	reti

0000392a <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    392a:	1f 92       	push	r1
    392c:	0f 92       	push	r0
    392e:	0f b6       	in	r0, 0x3f	; 63
    3930:	0f 92       	push	r0
    3932:	11 24       	eor	r1, r1
    3934:	08 b6       	in	r0, 0x38	; 56
    3936:	0f 92       	push	r0
    3938:	18 be       	out	0x38, r1	; 56
    393a:	0b b6       	in	r0, 0x3b	; 59
    393c:	0f 92       	push	r0
    393e:	1b be       	out	0x3b, r1	; 59
    3940:	2f 93       	push	r18
    3942:	3f 93       	push	r19
    3944:	8f 93       	push	r24
    3946:	9f 93       	push	r25
    3948:	ef 93       	push	r30
    394a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    394c:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    3950:	e0 91 7e 31 	lds	r30, 0x317E	; 0x80317e <rcvE1_buffer>
    3954:	f0 91 7f 31 	lds	r31, 0x317F	; 0x80317f <rcvE1_buffer+0x1>
    3958:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <rcvE1_write_index>
    395c:	90 91 63 31 	lds	r25, 0x3163	; 0x803163 <rcvE1_write_index+0x1>
    3960:	e8 0f       	add	r30, r24
    3962:	f9 1f       	adc	r31, r25
    3964:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    3966:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <rcvE1_write_index>
    396a:	90 91 63 31 	lds	r25, 0x3163	; 0x803163 <rcvE1_write_index+0x1>
    396e:	01 96       	adiw	r24, 0x01	; 1
    3970:	84 36       	cpi	r24, 0x64	; 100
    3972:	91 05       	cpc	r25, r1
    3974:	60 f4       	brcc	.+24     	; 0x398e <__vector_61+0x64>
    3976:	80 93 62 31 	sts	0x3162, r24	; 0x803162 <rcvE1_write_index>
    397a:	90 93 63 31 	sts	0x3163, r25	; 0x803163 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    397e:	20 91 70 31 	lds	r18, 0x3170	; 0x803170 <rcvE1_read_index>
    3982:	30 91 71 31 	lds	r19, 0x3171	; 0x803171 <rcvE1_read_index+0x1>
    3986:	82 17       	cp	r24, r18
    3988:	93 07       	cpc	r25, r19
    398a:	f1 f4       	brne	.+60     	; 0x39c8 <__vector_61+0x9e>
    398c:	0c c0       	rjmp	.+24     	; 0x39a6 <__vector_61+0x7c>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    398e:	10 92 62 31 	sts	0x3162, r1	; 0x803162 <rcvE1_write_index>
    3992:	10 92 63 31 	sts	0x3163, r1	; 0x803163 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3996:	80 91 70 31 	lds	r24, 0x3170	; 0x803170 <rcvE1_read_index>
    399a:	90 91 71 31 	lds	r25, 0x3171	; 0x803171 <rcvE1_read_index+0x1>
    399e:	18 16       	cp	r1, r24
    39a0:	19 06       	cpc	r1, r25
    39a2:	91 f4       	brne	.+36     	; 0x39c8 <__vector_61+0x9e>
    39a4:	0e c0       	rjmp	.+28     	; 0x39c2 <__vector_61+0x98>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    39a6:	01 96       	adiw	r24, 0x01	; 1
    39a8:	84 36       	cpi	r24, 0x64	; 100
    39aa:	91 05       	cpc	r25, r1
    39ac:	28 f4       	brcc	.+10     	; 0x39b8 <__vector_61+0x8e>
    39ae:	80 93 70 31 	sts	0x3170, r24	; 0x803170 <rcvE1_read_index>
    39b2:	90 93 71 31 	sts	0x3171, r25	; 0x803171 <rcvE1_read_index+0x1>
    39b6:	08 c0       	rjmp	.+16     	; 0x39c8 <__vector_61+0x9e>
	rcvE1_read_index = 0;
    39b8:	10 92 70 31 	sts	0x3170, r1	; 0x803170 <rcvE1_read_index>
    39bc:	10 92 71 31 	sts	0x3171, r1	; 0x803171 <rcvE1_read_index+0x1>
}
    39c0:	03 c0       	rjmp	.+6      	; 0x39c8 <__vector_61+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    39c2:	81 e0       	ldi	r24, 0x01	; 1
    39c4:	90 e0       	ldi	r25, 0x00	; 0
    39c6:	f3 cf       	rjmp	.-26     	; 0x39ae <__vector_61+0x84>
	rcvE1_read_index = 0;
}
    39c8:	ff 91       	pop	r31
    39ca:	ef 91       	pop	r30
    39cc:	9f 91       	pop	r25
    39ce:	8f 91       	pop	r24
    39d0:	3f 91       	pop	r19
    39d2:	2f 91       	pop	r18
    39d4:	0f 90       	pop	r0
    39d6:	0b be       	out	0x3b, r0	; 59
    39d8:	0f 90       	pop	r0
    39da:	08 be       	out	0x38, r0	; 56
    39dc:	0f 90       	pop	r0
    39de:	0f be       	out	0x3f, r0	; 63
    39e0:	0f 90       	pop	r0
    39e2:	1f 90       	pop	r1
    39e4:	18 95       	reti

000039e6 <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    39e6:	1f 92       	push	r1
    39e8:	0f 92       	push	r0
    39ea:	0f b6       	in	r0, 0x3f	; 63
    39ec:	0f 92       	push	r0
    39ee:	11 24       	eor	r1, r1
    39f0:	08 b6       	in	r0, 0x38	; 56
    39f2:	0f 92       	push	r0
    39f4:	18 be       	out	0x38, r1	; 56
    39f6:	0b b6       	in	r0, 0x3b	; 59
    39f8:	0f 92       	push	r0
    39fa:	1b be       	out	0x3b, r1	; 59
    39fc:	2f 93       	push	r18
    39fe:	3f 93       	push	r19
    3a00:	8f 93       	push	r24
    3a02:	9f 93       	push	r25
    3a04:	ef 93       	push	r30
    3a06:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    3a08:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    3a0c:	e0 91 7c 31 	lds	r30, 0x317C	; 0x80317c <rcvF0_buffer>
    3a10:	f0 91 7d 31 	lds	r31, 0x317D	; 0x80317d <rcvF0_buffer+0x1>
    3a14:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvF0_write_index>
    3a18:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvF0_write_index+0x1>
    3a1c:	e8 0f       	add	r30, r24
    3a1e:	f9 1f       	adc	r31, r25
    3a20:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    3a22:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvF0_write_index>
    3a26:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvF0_write_index+0x1>
    3a2a:	01 96       	adiw	r24, 0x01	; 1
    3a2c:	84 36       	cpi	r24, 0x64	; 100
    3a2e:	91 05       	cpc	r25, r1
    3a30:	60 f4       	brcc	.+24     	; 0x3a4a <__vector_119+0x64>
    3a32:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <rcvF0_write_index>
    3a36:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3a3a:	20 91 6e 31 	lds	r18, 0x316E	; 0x80316e <rcvF0_read_index>
    3a3e:	30 91 6f 31 	lds	r19, 0x316F	; 0x80316f <rcvF0_read_index+0x1>
    3a42:	82 17       	cp	r24, r18
    3a44:	93 07       	cpc	r25, r19
    3a46:	f1 f4       	brne	.+60     	; 0x3a84 <__vector_119+0x9e>
    3a48:	0c c0       	rjmp	.+24     	; 0x3a62 <__vector_119+0x7c>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    3a4a:	10 92 60 31 	sts	0x3160, r1	; 0x803160 <rcvF0_write_index>
    3a4e:	10 92 61 31 	sts	0x3161, r1	; 0x803161 <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3a52:	80 91 6e 31 	lds	r24, 0x316E	; 0x80316e <rcvF0_read_index>
    3a56:	90 91 6f 31 	lds	r25, 0x316F	; 0x80316f <rcvF0_read_index+0x1>
    3a5a:	18 16       	cp	r1, r24
    3a5c:	19 06       	cpc	r1, r25
    3a5e:	91 f4       	brne	.+36     	; 0x3a84 <__vector_119+0x9e>
    3a60:	0e c0       	rjmp	.+28     	; 0x3a7e <__vector_119+0x98>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3a62:	01 96       	adiw	r24, 0x01	; 1
    3a64:	84 36       	cpi	r24, 0x64	; 100
    3a66:	91 05       	cpc	r25, r1
    3a68:	28 f4       	brcc	.+10     	; 0x3a74 <__vector_119+0x8e>
    3a6a:	80 93 6e 31 	sts	0x316E, r24	; 0x80316e <rcvF0_read_index>
    3a6e:	90 93 6f 31 	sts	0x316F, r25	; 0x80316f <rcvF0_read_index+0x1>
    3a72:	08 c0       	rjmp	.+16     	; 0x3a84 <__vector_119+0x9e>
	rcvF0_read_index = 0;
    3a74:	10 92 6e 31 	sts	0x316E, r1	; 0x80316e <rcvF0_read_index>
    3a78:	10 92 6f 31 	sts	0x316F, r1	; 0x80316f <rcvF0_read_index+0x1>
}
    3a7c:	03 c0       	rjmp	.+6      	; 0x3a84 <__vector_119+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3a7e:	81 e0       	ldi	r24, 0x01	; 1
    3a80:	90 e0       	ldi	r25, 0x00	; 0
    3a82:	f3 cf       	rjmp	.-26     	; 0x3a6a <__vector_119+0x84>
	rcvF0_read_index = 0;
}
    3a84:	ff 91       	pop	r31
    3a86:	ef 91       	pop	r30
    3a88:	9f 91       	pop	r25
    3a8a:	8f 91       	pop	r24
    3a8c:	3f 91       	pop	r19
    3a8e:	2f 91       	pop	r18
    3a90:	0f 90       	pop	r0
    3a92:	0b be       	out	0x3b, r0	; 59
    3a94:	0f 90       	pop	r0
    3a96:	08 be       	out	0x38, r0	; 56
    3a98:	0f 90       	pop	r0
    3a9a:	0f be       	out	0x3f, r0	; 63
    3a9c:	0f 90       	pop	r0
    3a9e:	1f 90       	pop	r1
    3aa0:	18 95       	reti

00003aa2 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3aa2:	0f 93       	push	r16
    3aa4:	cf 93       	push	r28
    3aa6:	df 93       	push	r29
    3aa8:	1f 92       	push	r1
    3aaa:	cd b7       	in	r28, 0x3d	; 61
    3aac:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3aae:	2f b7       	in	r18, 0x3f	; 63
    3ab0:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3ab2:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3ab4:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3ab6:	fc 01       	movw	r30, r24
    3ab8:	08 ed       	ldi	r16, 0xD8	; 216
    3aba:	04 bf       	out	0x34, r16	; 52
    3abc:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3abe:	89 81       	ldd	r24, Y+1	; 0x01
    3ac0:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3ac2:	0f 90       	pop	r0
    3ac4:	df 91       	pop	r29
    3ac6:	cf 91       	pop	r28
    3ac8:	0f 91       	pop	r16
    3aca:	08 95       	ret

00003acc <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3acc:	0f 93       	push	r16
    3ace:	1f 93       	push	r17
    3ad0:	cf 93       	push	r28
    3ad2:	df 93       	push	r29
    3ad4:	cd b7       	in	r28, 0x3d	; 61
    3ad6:	de b7       	in	r29, 0x3e	; 62
    3ad8:	6d 97       	sbiw	r28, 0x1d	; 29
    3ada:	cd bf       	out	0x3d, r28	; 61
    3adc:	de bf       	out	0x3e, r29	; 62
	//Clear any interrupts
	cli();
    3ade:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3ae0:	e0 e5       	ldi	r30, 0x50	; 80
    3ae2:	f0 e0       	ldi	r31, 0x00	; 0
    3ae4:	80 81       	ld	r24, Z
    3ae6:	82 60       	ori	r24, 0x02	; 2
    3ae8:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3aea:	81 81       	ldd	r24, Z+1	; 0x01
    3aec:	81 ff       	sbrs	r24, 1
    3aee:	fd cf       	rjmp	.-6      	; 0x3aea <main+0x1e>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3af0:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3af4:	68 7f       	andi	r22, 0xF8	; 248
    3af6:	61 60       	ori	r22, 0x01	; 1
    3af8:	80 e4       	ldi	r24, 0x40	; 64
    3afa:	90 e0       	ldi	r25, 0x00	; 0
    3afc:	0e 94 51 1d 	call	0x3aa2	; 0x3aa2 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3b00:	e0 e5       	ldi	r30, 0x50	; 80
    3b02:	f0 e0       	ldi	r31, 0x00	; 0
    3b04:	80 81       	ld	r24, Z
    3b06:	8e 7f       	andi	r24, 0xFE	; 254
    3b08:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3b0a:	9d ef       	ldi	r25, 0xFD	; 253
    3b0c:	88 ed       	ldi	r24, 0xD8	; 216
    3b0e:	08 b6       	in	r0, 0x38	; 56
    3b10:	18 be       	out	0x38, r1	; 56
    3b12:	84 bf       	out	0x34, r24	; 52
    3b14:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3b18:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
    3b1a:	40 ea       	ldi	r20, 0xA0	; 160
    3b1c:	58 e0       	ldi	r21, 0x08	; 8
    3b1e:	60 e0       	ldi	r22, 0x00	; 0
    3b20:	70 e0       	ldi	r23, 0x00	; 0
    3b22:	ce 01       	movw	r24, r28
    3b24:	01 96       	adiw	r24, 0x01	; 1
    3b26:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3b2a:	67 e0       	ldi	r22, 0x07	; 7
    3b2c:	ce 01       	movw	r24, r28
    3b2e:	01 96       	adiw	r24, 0x01	; 1
    3b30:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    3b34:	8c 01       	movw	r16, r24
    3b36:	65 ea       	ldi	r22, 0xA5	; 165
    3b38:	70 e2       	ldi	r23, 0x20	; 32
    3b3a:	0e 94 02 18 	call	0x3004	; 0x3004 <_ZN8emstream4putsEPKc>
    3b3e:	66 e0       	ldi	r22, 0x06	; 6
    3b40:	c8 01       	movw	r24, r16
    3b42:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
    3b46:	66 e0       	ldi	r22, 0x06	; 6
    3b48:	0e 94 39 18 	call	0x3072	; 0x3072 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3b4c:	82 e1       	ldi	r24, 0x12	; 18
    3b4e:	90 e0       	ldi	r25, 0x00	; 0
    3b50:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_Znwj>
    3b54:	8e 01       	movw	r16, r28
    3b56:	0f 5f       	subi	r16, 0xFF	; 255
    3b58:	1f 4f       	sbci	r17, 0xFF	; 255
    3b5a:	24 e0       	ldi	r18, 0x04	; 4
    3b5c:	31 e0       	ldi	r19, 0x01	; 1
    3b5e:	40 e0       	ldi	r20, 0x00	; 0
    3b60:	64 ec       	ldi	r22, 0xC4	; 196
    3b62:	70 e2       	ldi	r23, 0x20	; 32
    3b64:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(4), 260, &ser_dev);
    3b68:	82 e1       	ldi	r24, 0x12	; 18
    3b6a:	90 e0       	ldi	r25, 0x00	; 0
    3b6c:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_Znwj>
    3b70:	24 e0       	ldi	r18, 0x04	; 4
    3b72:	31 e0       	ldi	r19, 0x01	; 1
    3b74:	44 e0       	ldi	r20, 0x04	; 4
    3b76:	6c ec       	ldi	r22, 0xCC	; 204
    3b78:	70 e2       	ldi	r23, 0x20	; 32
    3b7a:	0e 94 94 03 	call	0x728	; 0x728 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(5), 260, &ser_dev);
    3b7e:	82 e1       	ldi	r24, 0x12	; 18
    3b80:	90 e0       	ldi	r25, 0x00	; 0
    3b82:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_Znwj>
    3b86:	24 e0       	ldi	r18, 0x04	; 4
    3b88:	31 e0       	ldi	r19, 0x01	; 1
    3b8a:	44 e0       	ldi	r20, 0x04	; 4
    3b8c:	63 ed       	ldi	r22, 0xD3	; 211
    3b8e:	70 e2       	ldi	r23, 0x20	; 32
    3b90:	0e 94 e5 03 	call	0x7ca	; 0x7ca <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(6), 260, &ser_dev);
    3b94:	82 e1       	ldi	r24, 0x12	; 18
    3b96:	90 e0       	ldi	r25, 0x00	; 0
    3b98:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_Znwj>
    3b9c:	24 e0       	ldi	r18, 0x04	; 4
    3b9e:	31 e0       	ldi	r19, 0x01	; 1
    3ba0:	44 e0       	ldi	r20, 0x04	; 4
    3ba2:	6a ed       	ldi	r22, 0xDA	; 218
    3ba4:	70 e2       	ldi	r23, 0x20	; 32
    3ba6:	0e 94 4d 04 	call	0x89a	; 0x89a <_ZN13LimitSwitchesC1EPKchjP8emstream>
	
	// The PWMdriver task converts V to a duty cycle
	new PWMdriver ("PWMdrv", task_priority(1), 260, &ser_dev);
    3baa:	82 e1       	ldi	r24, 0x12	; 18
    3bac:	90 e0       	ldi	r25, 0x00	; 0
    3bae:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_Znwj>
    3bb2:	24 e0       	ldi	r18, 0x04	; 4
    3bb4:	31 e0       	ldi	r19, 0x01	; 1
    3bb6:	41 e0       	ldi	r20, 0x01	; 1
    3bb8:	63 ee       	ldi	r22, 0xE3	; 227
    3bba:	70 e2       	ldi	r23, 0x20	; 32
    3bbc:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <_ZN9PWMdriverC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(2), 260, &ser_dev);
    3bc0:	8c e3       	ldi	r24, 0x3C	; 60
    3bc2:	90 e0       	ldi	r25, 0x00	; 0
    3bc4:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_Znwj>
    3bc8:	24 e0       	ldi	r18, 0x04	; 4
    3bca:	31 e0       	ldi	r19, 0x01	; 1
    3bcc:	42 e0       	ldi	r20, 0x02	; 2
    3bce:	6a ee       	ldi	r22, 0xEA	; 234
    3bd0:	70 e2       	ldi	r23, 0x20	; 32
    3bd2:	0e 94 7f 04 	call	0x8fe	; 0x8fe <_ZN5MotorC1EPKchjP8emstream>

	// The pid task takes in the error and determines the actuation signal
	new pid ("PID", task_priority(3), 260, &ser_dev);
    3bd6:	82 e1       	ldi	r24, 0x12	; 18
    3bd8:	90 e0       	ldi	r25, 0x00	; 0
    3bda:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_Znwj>
    3bde:	24 e0       	ldi	r18, 0x04	; 4
    3be0:	31 e0       	ldi	r19, 0x01	; 1
    3be2:	43 e0       	ldi	r20, 0x03	; 3
    3be4:	60 ef       	ldi	r22, 0xF0	; 240
    3be6:	70 e2       	ldi	r23, 0x20	; 32
    3be8:	0e 94 b1 04 	call	0x962	; 0x962 <_ZN3pidC1EPKchjP8emstream>

	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3bec:	87 e0       	ldi	r24, 0x07	; 7
    3bee:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3bf2:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3bf4:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <vTaskStartScheduler>
	
	return 0;
    3bf8:	80 e0       	ldi	r24, 0x00	; 0
    3bfa:	90 e0       	ldi	r25, 0x00	; 0
    3bfc:	6d 96       	adiw	r28, 0x1d	; 29
    3bfe:	cd bf       	out	0x3d, r28	; 61
    3c00:	de bf       	out	0x3e, r29	; 62
    3c02:	df 91       	pop	r29
    3c04:	cf 91       	pop	r28
    3c06:	1f 91       	pop	r17
    3c08:	0f 91       	pop	r16
    3c0a:	08 95       	ret

00003c0c <_GLOBAL__sub_I_counter>:
    3c0c:	0f 93       	push	r16
    3c0e:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3c10:	0a e0       	ldi	r16, 0x0A	; 10
    3c12:	10 e0       	ldi	r17, 0x00	; 0
    3c14:	20 e0       	ldi	r18, 0x00	; 0
    3c16:	30 e0       	ldi	r19, 0x00	; 0
    3c18:	40 e0       	ldi	r20, 0x00	; 0
    3c1a:	50 e0       	ldi	r21, 0x00	; 0
    3c1c:	60 e2       	ldi	r22, 0x20	; 32
    3c1e:	70 e0       	ldi	r23, 0x00	; 0
    3c20:	80 e9       	ldi	r24, 0x90	; 144
    3c22:	91 e3       	ldi	r25, 0x31	; 49
    3c24:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    3c28:	1f 91       	pop	r17
    3c2a:	0f 91       	pop	r16
    3c2c:	08 95       	ret

00003c2e <__divsf3>:
    3c2e:	0e 94 2b 1e 	call	0x3c56	; 0x3c56 <__divsf3x>
    3c32:	0c 94 13 1f 	jmp	0x3e26	; 0x3e26 <__fp_round>
    3c36:	0e 94 0c 1f 	call	0x3e18	; 0x3e18 <__fp_pscB>
    3c3a:	58 f0       	brcs	.+22     	; 0x3c52 <__divsf3+0x24>
    3c3c:	0e 94 05 1f 	call	0x3e0a	; 0x3e0a <__fp_pscA>
    3c40:	40 f0       	brcs	.+16     	; 0x3c52 <__divsf3+0x24>
    3c42:	29 f4       	brne	.+10     	; 0x3c4e <__divsf3+0x20>
    3c44:	5f 3f       	cpi	r21, 0xFF	; 255
    3c46:	29 f0       	breq	.+10     	; 0x3c52 <__divsf3+0x24>
    3c48:	0c 94 fc 1e 	jmp	0x3df8	; 0x3df8 <__fp_inf>
    3c4c:	51 11       	cpse	r21, r1
    3c4e:	0c 94 47 1f 	jmp	0x3e8e	; 0x3e8e <__fp_szero>
    3c52:	0c 94 02 1f 	jmp	0x3e04	; 0x3e04 <__fp_nan>

00003c56 <__divsf3x>:
    3c56:	0e 94 24 1f 	call	0x3e48	; 0x3e48 <__fp_split3>
    3c5a:	68 f3       	brcs	.-38     	; 0x3c36 <__divsf3+0x8>

00003c5c <__divsf3_pse>:
    3c5c:	99 23       	and	r25, r25
    3c5e:	b1 f3       	breq	.-20     	; 0x3c4c <__divsf3+0x1e>
    3c60:	55 23       	and	r21, r21
    3c62:	91 f3       	breq	.-28     	; 0x3c48 <__divsf3+0x1a>
    3c64:	95 1b       	sub	r25, r21
    3c66:	55 0b       	sbc	r21, r21
    3c68:	bb 27       	eor	r27, r27
    3c6a:	aa 27       	eor	r26, r26
    3c6c:	62 17       	cp	r22, r18
    3c6e:	73 07       	cpc	r23, r19
    3c70:	84 07       	cpc	r24, r20
    3c72:	38 f0       	brcs	.+14     	; 0x3c82 <__divsf3_pse+0x26>
    3c74:	9f 5f       	subi	r25, 0xFF	; 255
    3c76:	5f 4f       	sbci	r21, 0xFF	; 255
    3c78:	22 0f       	add	r18, r18
    3c7a:	33 1f       	adc	r19, r19
    3c7c:	44 1f       	adc	r20, r20
    3c7e:	aa 1f       	adc	r26, r26
    3c80:	a9 f3       	breq	.-22     	; 0x3c6c <__divsf3_pse+0x10>
    3c82:	35 d0       	rcall	.+106    	; 0x3cee <__divsf3_pse+0x92>
    3c84:	0e 2e       	mov	r0, r30
    3c86:	3a f0       	brmi	.+14     	; 0x3c96 <__divsf3_pse+0x3a>
    3c88:	e0 e8       	ldi	r30, 0x80	; 128
    3c8a:	32 d0       	rcall	.+100    	; 0x3cf0 <__divsf3_pse+0x94>
    3c8c:	91 50       	subi	r25, 0x01	; 1
    3c8e:	50 40       	sbci	r21, 0x00	; 0
    3c90:	e6 95       	lsr	r30
    3c92:	00 1c       	adc	r0, r0
    3c94:	ca f7       	brpl	.-14     	; 0x3c88 <__divsf3_pse+0x2c>
    3c96:	2b d0       	rcall	.+86     	; 0x3cee <__divsf3_pse+0x92>
    3c98:	fe 2f       	mov	r31, r30
    3c9a:	29 d0       	rcall	.+82     	; 0x3cee <__divsf3_pse+0x92>
    3c9c:	66 0f       	add	r22, r22
    3c9e:	77 1f       	adc	r23, r23
    3ca0:	88 1f       	adc	r24, r24
    3ca2:	bb 1f       	adc	r27, r27
    3ca4:	26 17       	cp	r18, r22
    3ca6:	37 07       	cpc	r19, r23
    3ca8:	48 07       	cpc	r20, r24
    3caa:	ab 07       	cpc	r26, r27
    3cac:	b0 e8       	ldi	r27, 0x80	; 128
    3cae:	09 f0       	breq	.+2      	; 0x3cb2 <__divsf3_pse+0x56>
    3cb0:	bb 0b       	sbc	r27, r27
    3cb2:	80 2d       	mov	r24, r0
    3cb4:	bf 01       	movw	r22, r30
    3cb6:	ff 27       	eor	r31, r31
    3cb8:	93 58       	subi	r25, 0x83	; 131
    3cba:	5f 4f       	sbci	r21, 0xFF	; 255
    3cbc:	3a f0       	brmi	.+14     	; 0x3ccc <__divsf3_pse+0x70>
    3cbe:	9e 3f       	cpi	r25, 0xFE	; 254
    3cc0:	51 05       	cpc	r21, r1
    3cc2:	78 f0       	brcs	.+30     	; 0x3ce2 <__divsf3_pse+0x86>
    3cc4:	0c 94 fc 1e 	jmp	0x3df8	; 0x3df8 <__fp_inf>
    3cc8:	0c 94 47 1f 	jmp	0x3e8e	; 0x3e8e <__fp_szero>
    3ccc:	5f 3f       	cpi	r21, 0xFF	; 255
    3cce:	e4 f3       	brlt	.-8      	; 0x3cc8 <__divsf3_pse+0x6c>
    3cd0:	98 3e       	cpi	r25, 0xE8	; 232
    3cd2:	d4 f3       	brlt	.-12     	; 0x3cc8 <__divsf3_pse+0x6c>
    3cd4:	86 95       	lsr	r24
    3cd6:	77 95       	ror	r23
    3cd8:	67 95       	ror	r22
    3cda:	b7 95       	ror	r27
    3cdc:	f7 95       	ror	r31
    3cde:	9f 5f       	subi	r25, 0xFF	; 255
    3ce0:	c9 f7       	brne	.-14     	; 0x3cd4 <__divsf3_pse+0x78>
    3ce2:	88 0f       	add	r24, r24
    3ce4:	91 1d       	adc	r25, r1
    3ce6:	96 95       	lsr	r25
    3ce8:	87 95       	ror	r24
    3cea:	97 f9       	bld	r25, 7
    3cec:	08 95       	ret
    3cee:	e1 e0       	ldi	r30, 0x01	; 1
    3cf0:	66 0f       	add	r22, r22
    3cf2:	77 1f       	adc	r23, r23
    3cf4:	88 1f       	adc	r24, r24
    3cf6:	bb 1f       	adc	r27, r27
    3cf8:	62 17       	cp	r22, r18
    3cfa:	73 07       	cpc	r23, r19
    3cfc:	84 07       	cpc	r24, r20
    3cfe:	ba 07       	cpc	r27, r26
    3d00:	20 f0       	brcs	.+8      	; 0x3d0a <__divsf3_pse+0xae>
    3d02:	62 1b       	sub	r22, r18
    3d04:	73 0b       	sbc	r23, r19
    3d06:	84 0b       	sbc	r24, r20
    3d08:	ba 0b       	sbc	r27, r26
    3d0a:	ee 1f       	adc	r30, r30
    3d0c:	88 f7       	brcc	.-30     	; 0x3cf0 <__divsf3_pse+0x94>
    3d0e:	e0 95       	com	r30
    3d10:	08 95       	ret

00003d12 <__fixsfsi>:
    3d12:	0e 94 90 1e 	call	0x3d20	; 0x3d20 <__fixunssfsi>
    3d16:	68 94       	set
    3d18:	b1 11       	cpse	r27, r1
    3d1a:	0c 94 47 1f 	jmp	0x3e8e	; 0x3e8e <__fp_szero>
    3d1e:	08 95       	ret

00003d20 <__fixunssfsi>:
    3d20:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__fp_splitA>
    3d24:	88 f0       	brcs	.+34     	; 0x3d48 <__fixunssfsi+0x28>
    3d26:	9f 57       	subi	r25, 0x7F	; 127
    3d28:	98 f0       	brcs	.+38     	; 0x3d50 <__fixunssfsi+0x30>
    3d2a:	b9 2f       	mov	r27, r25
    3d2c:	99 27       	eor	r25, r25
    3d2e:	b7 51       	subi	r27, 0x17	; 23
    3d30:	b0 f0       	brcs	.+44     	; 0x3d5e <__fixunssfsi+0x3e>
    3d32:	e1 f0       	breq	.+56     	; 0x3d6c <__fixunssfsi+0x4c>
    3d34:	66 0f       	add	r22, r22
    3d36:	77 1f       	adc	r23, r23
    3d38:	88 1f       	adc	r24, r24
    3d3a:	99 1f       	adc	r25, r25
    3d3c:	1a f0       	brmi	.+6      	; 0x3d44 <__fixunssfsi+0x24>
    3d3e:	ba 95       	dec	r27
    3d40:	c9 f7       	brne	.-14     	; 0x3d34 <__fixunssfsi+0x14>
    3d42:	14 c0       	rjmp	.+40     	; 0x3d6c <__fixunssfsi+0x4c>
    3d44:	b1 30       	cpi	r27, 0x01	; 1
    3d46:	91 f0       	breq	.+36     	; 0x3d6c <__fixunssfsi+0x4c>
    3d48:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <__fp_zero>
    3d4c:	b1 e0       	ldi	r27, 0x01	; 1
    3d4e:	08 95       	ret
    3d50:	0c 94 46 1f 	jmp	0x3e8c	; 0x3e8c <__fp_zero>
    3d54:	67 2f       	mov	r22, r23
    3d56:	78 2f       	mov	r23, r24
    3d58:	88 27       	eor	r24, r24
    3d5a:	b8 5f       	subi	r27, 0xF8	; 248
    3d5c:	39 f0       	breq	.+14     	; 0x3d6c <__fixunssfsi+0x4c>
    3d5e:	b9 3f       	cpi	r27, 0xF9	; 249
    3d60:	cc f3       	brlt	.-14     	; 0x3d54 <__fixunssfsi+0x34>
    3d62:	86 95       	lsr	r24
    3d64:	77 95       	ror	r23
    3d66:	67 95       	ror	r22
    3d68:	b3 95       	inc	r27
    3d6a:	d9 f7       	brne	.-10     	; 0x3d62 <__fixunssfsi+0x42>
    3d6c:	3e f4       	brtc	.+14     	; 0x3d7c <__fixunssfsi+0x5c>
    3d6e:	90 95       	com	r25
    3d70:	80 95       	com	r24
    3d72:	70 95       	com	r23
    3d74:	61 95       	neg	r22
    3d76:	7f 4f       	sbci	r23, 0xFF	; 255
    3d78:	8f 4f       	sbci	r24, 0xFF	; 255
    3d7a:	9f 4f       	sbci	r25, 0xFF	; 255
    3d7c:	08 95       	ret

00003d7e <__floatunsisf>:
    3d7e:	e8 94       	clt
    3d80:	09 c0       	rjmp	.+18     	; 0x3d94 <__floatsisf+0x12>

00003d82 <__floatsisf>:
    3d82:	97 fb       	bst	r25, 7
    3d84:	3e f4       	brtc	.+14     	; 0x3d94 <__floatsisf+0x12>
    3d86:	90 95       	com	r25
    3d88:	80 95       	com	r24
    3d8a:	70 95       	com	r23
    3d8c:	61 95       	neg	r22
    3d8e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d90:	8f 4f       	sbci	r24, 0xFF	; 255
    3d92:	9f 4f       	sbci	r25, 0xFF	; 255
    3d94:	99 23       	and	r25, r25
    3d96:	a9 f0       	breq	.+42     	; 0x3dc2 <__floatsisf+0x40>
    3d98:	f9 2f       	mov	r31, r25
    3d9a:	96 e9       	ldi	r25, 0x96	; 150
    3d9c:	bb 27       	eor	r27, r27
    3d9e:	93 95       	inc	r25
    3da0:	f6 95       	lsr	r31
    3da2:	87 95       	ror	r24
    3da4:	77 95       	ror	r23
    3da6:	67 95       	ror	r22
    3da8:	b7 95       	ror	r27
    3daa:	f1 11       	cpse	r31, r1
    3dac:	f8 cf       	rjmp	.-16     	; 0x3d9e <__floatsisf+0x1c>
    3dae:	fa f4       	brpl	.+62     	; 0x3dee <__floatsisf+0x6c>
    3db0:	bb 0f       	add	r27, r27
    3db2:	11 f4       	brne	.+4      	; 0x3db8 <__floatsisf+0x36>
    3db4:	60 ff       	sbrs	r22, 0
    3db6:	1b c0       	rjmp	.+54     	; 0x3dee <__floatsisf+0x6c>
    3db8:	6f 5f       	subi	r22, 0xFF	; 255
    3dba:	7f 4f       	sbci	r23, 0xFF	; 255
    3dbc:	8f 4f       	sbci	r24, 0xFF	; 255
    3dbe:	9f 4f       	sbci	r25, 0xFF	; 255
    3dc0:	16 c0       	rjmp	.+44     	; 0x3dee <__floatsisf+0x6c>
    3dc2:	88 23       	and	r24, r24
    3dc4:	11 f0       	breq	.+4      	; 0x3dca <__floatsisf+0x48>
    3dc6:	96 e9       	ldi	r25, 0x96	; 150
    3dc8:	11 c0       	rjmp	.+34     	; 0x3dec <__floatsisf+0x6a>
    3dca:	77 23       	and	r23, r23
    3dcc:	21 f0       	breq	.+8      	; 0x3dd6 <__floatsisf+0x54>
    3dce:	9e e8       	ldi	r25, 0x8E	; 142
    3dd0:	87 2f       	mov	r24, r23
    3dd2:	76 2f       	mov	r23, r22
    3dd4:	05 c0       	rjmp	.+10     	; 0x3de0 <__floatsisf+0x5e>
    3dd6:	66 23       	and	r22, r22
    3dd8:	71 f0       	breq	.+28     	; 0x3df6 <__floatsisf+0x74>
    3dda:	96 e8       	ldi	r25, 0x86	; 134
    3ddc:	86 2f       	mov	r24, r22
    3dde:	70 e0       	ldi	r23, 0x00	; 0
    3de0:	60 e0       	ldi	r22, 0x00	; 0
    3de2:	2a f0       	brmi	.+10     	; 0x3dee <__floatsisf+0x6c>
    3de4:	9a 95       	dec	r25
    3de6:	66 0f       	add	r22, r22
    3de8:	77 1f       	adc	r23, r23
    3dea:	88 1f       	adc	r24, r24
    3dec:	da f7       	brpl	.-10     	; 0x3de4 <__floatsisf+0x62>
    3dee:	88 0f       	add	r24, r24
    3df0:	96 95       	lsr	r25
    3df2:	87 95       	ror	r24
    3df4:	97 f9       	bld	r25, 7
    3df6:	08 95       	ret

00003df8 <__fp_inf>:
    3df8:	97 f9       	bld	r25, 7
    3dfa:	9f 67       	ori	r25, 0x7F	; 127
    3dfc:	80 e8       	ldi	r24, 0x80	; 128
    3dfe:	70 e0       	ldi	r23, 0x00	; 0
    3e00:	60 e0       	ldi	r22, 0x00	; 0
    3e02:	08 95       	ret

00003e04 <__fp_nan>:
    3e04:	9f ef       	ldi	r25, 0xFF	; 255
    3e06:	80 ec       	ldi	r24, 0xC0	; 192
    3e08:	08 95       	ret

00003e0a <__fp_pscA>:
    3e0a:	00 24       	eor	r0, r0
    3e0c:	0a 94       	dec	r0
    3e0e:	16 16       	cp	r1, r22
    3e10:	17 06       	cpc	r1, r23
    3e12:	18 06       	cpc	r1, r24
    3e14:	09 06       	cpc	r0, r25
    3e16:	08 95       	ret

00003e18 <__fp_pscB>:
    3e18:	00 24       	eor	r0, r0
    3e1a:	0a 94       	dec	r0
    3e1c:	12 16       	cp	r1, r18
    3e1e:	13 06       	cpc	r1, r19
    3e20:	14 06       	cpc	r1, r20
    3e22:	05 06       	cpc	r0, r21
    3e24:	08 95       	ret

00003e26 <__fp_round>:
    3e26:	09 2e       	mov	r0, r25
    3e28:	03 94       	inc	r0
    3e2a:	00 0c       	add	r0, r0
    3e2c:	11 f4       	brne	.+4      	; 0x3e32 <__fp_round+0xc>
    3e2e:	88 23       	and	r24, r24
    3e30:	52 f0       	brmi	.+20     	; 0x3e46 <__fp_round+0x20>
    3e32:	bb 0f       	add	r27, r27
    3e34:	40 f4       	brcc	.+16     	; 0x3e46 <__fp_round+0x20>
    3e36:	bf 2b       	or	r27, r31
    3e38:	11 f4       	brne	.+4      	; 0x3e3e <__fp_round+0x18>
    3e3a:	60 ff       	sbrs	r22, 0
    3e3c:	04 c0       	rjmp	.+8      	; 0x3e46 <__fp_round+0x20>
    3e3e:	6f 5f       	subi	r22, 0xFF	; 255
    3e40:	7f 4f       	sbci	r23, 0xFF	; 255
    3e42:	8f 4f       	sbci	r24, 0xFF	; 255
    3e44:	9f 4f       	sbci	r25, 0xFF	; 255
    3e46:	08 95       	ret

00003e48 <__fp_split3>:
    3e48:	57 fd       	sbrc	r21, 7
    3e4a:	90 58       	subi	r25, 0x80	; 128
    3e4c:	44 0f       	add	r20, r20
    3e4e:	55 1f       	adc	r21, r21
    3e50:	59 f0       	breq	.+22     	; 0x3e68 <__fp_splitA+0x10>
    3e52:	5f 3f       	cpi	r21, 0xFF	; 255
    3e54:	71 f0       	breq	.+28     	; 0x3e72 <__fp_splitA+0x1a>
    3e56:	47 95       	ror	r20

00003e58 <__fp_splitA>:
    3e58:	88 0f       	add	r24, r24
    3e5a:	97 fb       	bst	r25, 7
    3e5c:	99 1f       	adc	r25, r25
    3e5e:	61 f0       	breq	.+24     	; 0x3e78 <__fp_splitA+0x20>
    3e60:	9f 3f       	cpi	r25, 0xFF	; 255
    3e62:	79 f0       	breq	.+30     	; 0x3e82 <__fp_splitA+0x2a>
    3e64:	87 95       	ror	r24
    3e66:	08 95       	ret
    3e68:	12 16       	cp	r1, r18
    3e6a:	13 06       	cpc	r1, r19
    3e6c:	14 06       	cpc	r1, r20
    3e6e:	55 1f       	adc	r21, r21
    3e70:	f2 cf       	rjmp	.-28     	; 0x3e56 <__fp_split3+0xe>
    3e72:	46 95       	lsr	r20
    3e74:	f1 df       	rcall	.-30     	; 0x3e58 <__fp_splitA>
    3e76:	08 c0       	rjmp	.+16     	; 0x3e88 <__fp_splitA+0x30>
    3e78:	16 16       	cp	r1, r22
    3e7a:	17 06       	cpc	r1, r23
    3e7c:	18 06       	cpc	r1, r24
    3e7e:	99 1f       	adc	r25, r25
    3e80:	f1 cf       	rjmp	.-30     	; 0x3e64 <__fp_splitA+0xc>
    3e82:	86 95       	lsr	r24
    3e84:	71 05       	cpc	r23, r1
    3e86:	61 05       	cpc	r22, r1
    3e88:	08 94       	sec
    3e8a:	08 95       	ret

00003e8c <__fp_zero>:
    3e8c:	e8 94       	clt

00003e8e <__fp_szero>:
    3e8e:	bb 27       	eor	r27, r27
    3e90:	66 27       	eor	r22, r22
    3e92:	77 27       	eor	r23, r23
    3e94:	cb 01       	movw	r24, r22
    3e96:	97 f9       	bld	r25, 7
    3e98:	08 95       	ret

00003e9a <__mulsf3>:
    3e9a:	0e 94 60 1f 	call	0x3ec0	; 0x3ec0 <__mulsf3x>
    3e9e:	0c 94 13 1f 	jmp	0x3e26	; 0x3e26 <__fp_round>
    3ea2:	0e 94 05 1f 	call	0x3e0a	; 0x3e0a <__fp_pscA>
    3ea6:	38 f0       	brcs	.+14     	; 0x3eb6 <__mulsf3+0x1c>
    3ea8:	0e 94 0c 1f 	call	0x3e18	; 0x3e18 <__fp_pscB>
    3eac:	20 f0       	brcs	.+8      	; 0x3eb6 <__mulsf3+0x1c>
    3eae:	95 23       	and	r25, r21
    3eb0:	11 f0       	breq	.+4      	; 0x3eb6 <__mulsf3+0x1c>
    3eb2:	0c 94 fc 1e 	jmp	0x3df8	; 0x3df8 <__fp_inf>
    3eb6:	0c 94 02 1f 	jmp	0x3e04	; 0x3e04 <__fp_nan>
    3eba:	11 24       	eor	r1, r1
    3ebc:	0c 94 47 1f 	jmp	0x3e8e	; 0x3e8e <__fp_szero>

00003ec0 <__mulsf3x>:
    3ec0:	0e 94 24 1f 	call	0x3e48	; 0x3e48 <__fp_split3>
    3ec4:	70 f3       	brcs	.-36     	; 0x3ea2 <__mulsf3+0x8>

00003ec6 <__mulsf3_pse>:
    3ec6:	95 9f       	mul	r25, r21
    3ec8:	c1 f3       	breq	.-16     	; 0x3eba <__mulsf3+0x20>
    3eca:	95 0f       	add	r25, r21
    3ecc:	50 e0       	ldi	r21, 0x00	; 0
    3ece:	55 1f       	adc	r21, r21
    3ed0:	62 9f       	mul	r22, r18
    3ed2:	f0 01       	movw	r30, r0
    3ed4:	72 9f       	mul	r23, r18
    3ed6:	bb 27       	eor	r27, r27
    3ed8:	f0 0d       	add	r31, r0
    3eda:	b1 1d       	adc	r27, r1
    3edc:	63 9f       	mul	r22, r19
    3ede:	aa 27       	eor	r26, r26
    3ee0:	f0 0d       	add	r31, r0
    3ee2:	b1 1d       	adc	r27, r1
    3ee4:	aa 1f       	adc	r26, r26
    3ee6:	64 9f       	mul	r22, r20
    3ee8:	66 27       	eor	r22, r22
    3eea:	b0 0d       	add	r27, r0
    3eec:	a1 1d       	adc	r26, r1
    3eee:	66 1f       	adc	r22, r22
    3ef0:	82 9f       	mul	r24, r18
    3ef2:	22 27       	eor	r18, r18
    3ef4:	b0 0d       	add	r27, r0
    3ef6:	a1 1d       	adc	r26, r1
    3ef8:	62 1f       	adc	r22, r18
    3efa:	73 9f       	mul	r23, r19
    3efc:	b0 0d       	add	r27, r0
    3efe:	a1 1d       	adc	r26, r1
    3f00:	62 1f       	adc	r22, r18
    3f02:	83 9f       	mul	r24, r19
    3f04:	a0 0d       	add	r26, r0
    3f06:	61 1d       	adc	r22, r1
    3f08:	22 1f       	adc	r18, r18
    3f0a:	74 9f       	mul	r23, r20
    3f0c:	33 27       	eor	r19, r19
    3f0e:	a0 0d       	add	r26, r0
    3f10:	61 1d       	adc	r22, r1
    3f12:	23 1f       	adc	r18, r19
    3f14:	84 9f       	mul	r24, r20
    3f16:	60 0d       	add	r22, r0
    3f18:	21 1d       	adc	r18, r1
    3f1a:	82 2f       	mov	r24, r18
    3f1c:	76 2f       	mov	r23, r22
    3f1e:	6a 2f       	mov	r22, r26
    3f20:	11 24       	eor	r1, r1
    3f22:	9f 57       	subi	r25, 0x7F	; 127
    3f24:	50 40       	sbci	r21, 0x00	; 0
    3f26:	9a f0       	brmi	.+38     	; 0x3f4e <__mulsf3_pse+0x88>
    3f28:	f1 f0       	breq	.+60     	; 0x3f66 <__mulsf3_pse+0xa0>
    3f2a:	88 23       	and	r24, r24
    3f2c:	4a f0       	brmi	.+18     	; 0x3f40 <__mulsf3_pse+0x7a>
    3f2e:	ee 0f       	add	r30, r30
    3f30:	ff 1f       	adc	r31, r31
    3f32:	bb 1f       	adc	r27, r27
    3f34:	66 1f       	adc	r22, r22
    3f36:	77 1f       	adc	r23, r23
    3f38:	88 1f       	adc	r24, r24
    3f3a:	91 50       	subi	r25, 0x01	; 1
    3f3c:	50 40       	sbci	r21, 0x00	; 0
    3f3e:	a9 f7       	brne	.-22     	; 0x3f2a <__mulsf3_pse+0x64>
    3f40:	9e 3f       	cpi	r25, 0xFE	; 254
    3f42:	51 05       	cpc	r21, r1
    3f44:	80 f0       	brcs	.+32     	; 0x3f66 <__mulsf3_pse+0xa0>
    3f46:	0c 94 fc 1e 	jmp	0x3df8	; 0x3df8 <__fp_inf>
    3f4a:	0c 94 47 1f 	jmp	0x3e8e	; 0x3e8e <__fp_szero>
    3f4e:	5f 3f       	cpi	r21, 0xFF	; 255
    3f50:	e4 f3       	brlt	.-8      	; 0x3f4a <__mulsf3_pse+0x84>
    3f52:	98 3e       	cpi	r25, 0xE8	; 232
    3f54:	d4 f3       	brlt	.-12     	; 0x3f4a <__mulsf3_pse+0x84>
    3f56:	86 95       	lsr	r24
    3f58:	77 95       	ror	r23
    3f5a:	67 95       	ror	r22
    3f5c:	b7 95       	ror	r27
    3f5e:	f7 95       	ror	r31
    3f60:	e7 95       	ror	r30
    3f62:	9f 5f       	subi	r25, 0xFF	; 255
    3f64:	c1 f7       	brne	.-16     	; 0x3f56 <__mulsf3_pse+0x90>
    3f66:	fe 2b       	or	r31, r30
    3f68:	88 0f       	add	r24, r24
    3f6a:	91 1d       	adc	r25, r1
    3f6c:	96 95       	lsr	r25
    3f6e:	87 95       	ror	r24
    3f70:	97 f9       	bld	r25, 7
    3f72:	08 95       	ret

00003f74 <__mulsi3>:
    3f74:	db 01       	movw	r26, r22
    3f76:	8f 93       	push	r24
    3f78:	9f 93       	push	r25
    3f7a:	0e 94 28 20 	call	0x4050	; 0x4050 <__muluhisi3>
    3f7e:	bf 91       	pop	r27
    3f80:	af 91       	pop	r26
    3f82:	a2 9f       	mul	r26, r18
    3f84:	80 0d       	add	r24, r0
    3f86:	91 1d       	adc	r25, r1
    3f88:	a3 9f       	mul	r26, r19
    3f8a:	90 0d       	add	r25, r0
    3f8c:	b2 9f       	mul	r27, r18
    3f8e:	90 0d       	add	r25, r0
    3f90:	11 24       	eor	r1, r1
    3f92:	08 95       	ret

00003f94 <__divmodhi4>:
    3f94:	97 fb       	bst	r25, 7
    3f96:	07 2e       	mov	r0, r23
    3f98:	16 f4       	brtc	.+4      	; 0x3f9e <__divmodhi4+0xa>
    3f9a:	00 94       	com	r0
    3f9c:	07 d0       	rcall	.+14     	; 0x3fac <__divmodhi4_neg1>
    3f9e:	77 fd       	sbrc	r23, 7
    3fa0:	09 d0       	rcall	.+18     	; 0x3fb4 <__divmodhi4_neg2>
    3fa2:	0e 94 33 20 	call	0x4066	; 0x4066 <__udivmodhi4>
    3fa6:	07 fc       	sbrc	r0, 7
    3fa8:	05 d0       	rcall	.+10     	; 0x3fb4 <__divmodhi4_neg2>
    3faa:	3e f4       	brtc	.+14     	; 0x3fba <__divmodhi4_exit>

00003fac <__divmodhi4_neg1>:
    3fac:	90 95       	com	r25
    3fae:	81 95       	neg	r24
    3fb0:	9f 4f       	sbci	r25, 0xFF	; 255
    3fb2:	08 95       	ret

00003fb4 <__divmodhi4_neg2>:
    3fb4:	70 95       	com	r23
    3fb6:	61 95       	neg	r22
    3fb8:	7f 4f       	sbci	r23, 0xFF	; 255

00003fba <__divmodhi4_exit>:
    3fba:	08 95       	ret

00003fbc <__udivmodsi4>:
    3fbc:	a1 e2       	ldi	r26, 0x21	; 33
    3fbe:	1a 2e       	mov	r1, r26
    3fc0:	aa 1b       	sub	r26, r26
    3fc2:	bb 1b       	sub	r27, r27
    3fc4:	fd 01       	movw	r30, r26
    3fc6:	0d c0       	rjmp	.+26     	; 0x3fe2 <__udivmodsi4_ep>

00003fc8 <__udivmodsi4_loop>:
    3fc8:	aa 1f       	adc	r26, r26
    3fca:	bb 1f       	adc	r27, r27
    3fcc:	ee 1f       	adc	r30, r30
    3fce:	ff 1f       	adc	r31, r31
    3fd0:	a2 17       	cp	r26, r18
    3fd2:	b3 07       	cpc	r27, r19
    3fd4:	e4 07       	cpc	r30, r20
    3fd6:	f5 07       	cpc	r31, r21
    3fd8:	20 f0       	brcs	.+8      	; 0x3fe2 <__udivmodsi4_ep>
    3fda:	a2 1b       	sub	r26, r18
    3fdc:	b3 0b       	sbc	r27, r19
    3fde:	e4 0b       	sbc	r30, r20
    3fe0:	f5 0b       	sbc	r31, r21

00003fe2 <__udivmodsi4_ep>:
    3fe2:	66 1f       	adc	r22, r22
    3fe4:	77 1f       	adc	r23, r23
    3fe6:	88 1f       	adc	r24, r24
    3fe8:	99 1f       	adc	r25, r25
    3fea:	1a 94       	dec	r1
    3fec:	69 f7       	brne	.-38     	; 0x3fc8 <__udivmodsi4_loop>
    3fee:	60 95       	com	r22
    3ff0:	70 95       	com	r23
    3ff2:	80 95       	com	r24
    3ff4:	90 95       	com	r25
    3ff6:	9b 01       	movw	r18, r22
    3ff8:	ac 01       	movw	r20, r24
    3ffa:	bd 01       	movw	r22, r26
    3ffc:	cf 01       	movw	r24, r30
    3ffe:	08 95       	ret

00004000 <__divmodsi4>:
    4000:	05 2e       	mov	r0, r21
    4002:	97 fb       	bst	r25, 7
    4004:	1e f4       	brtc	.+6      	; 0x400c <__divmodsi4+0xc>
    4006:	00 94       	com	r0
    4008:	0e 94 17 20 	call	0x402e	; 0x402e <__negsi2>
    400c:	57 fd       	sbrc	r21, 7
    400e:	07 d0       	rcall	.+14     	; 0x401e <__divmodsi4_neg2>
    4010:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <__udivmodsi4>
    4014:	07 fc       	sbrc	r0, 7
    4016:	03 d0       	rcall	.+6      	; 0x401e <__divmodsi4_neg2>
    4018:	4e f4       	brtc	.+18     	; 0x402c <__divmodsi4_exit>
    401a:	0c 94 17 20 	jmp	0x402e	; 0x402e <__negsi2>

0000401e <__divmodsi4_neg2>:
    401e:	50 95       	com	r21
    4020:	40 95       	com	r20
    4022:	30 95       	com	r19
    4024:	21 95       	neg	r18
    4026:	3f 4f       	sbci	r19, 0xFF	; 255
    4028:	4f 4f       	sbci	r20, 0xFF	; 255
    402a:	5f 4f       	sbci	r21, 0xFF	; 255

0000402c <__divmodsi4_exit>:
    402c:	08 95       	ret

0000402e <__negsi2>:
    402e:	90 95       	com	r25
    4030:	80 95       	com	r24
    4032:	70 95       	com	r23
    4034:	61 95       	neg	r22
    4036:	7f 4f       	sbci	r23, 0xFF	; 255
    4038:	8f 4f       	sbci	r24, 0xFF	; 255
    403a:	9f 4f       	sbci	r25, 0xFF	; 255
    403c:	08 95       	ret

0000403e <__tablejump2__>:
    403e:	ee 0f       	add	r30, r30
    4040:	ff 1f       	adc	r31, r31
    4042:	88 1f       	adc	r24, r24
    4044:	8b bf       	out	0x3b, r24	; 59
    4046:	07 90       	elpm	r0, Z+
    4048:	f6 91       	elpm	r31, Z
    404a:	e0 2d       	mov	r30, r0
    404c:	1b be       	out	0x3b, r1	; 59
    404e:	19 94       	eijmp

00004050 <__muluhisi3>:
    4050:	0e 94 47 20 	call	0x408e	; 0x408e <__umulhisi3>
    4054:	a5 9f       	mul	r26, r21
    4056:	90 0d       	add	r25, r0
    4058:	b4 9f       	mul	r27, r20
    405a:	90 0d       	add	r25, r0
    405c:	a4 9f       	mul	r26, r20
    405e:	80 0d       	add	r24, r0
    4060:	91 1d       	adc	r25, r1
    4062:	11 24       	eor	r1, r1
    4064:	08 95       	ret

00004066 <__udivmodhi4>:
    4066:	aa 1b       	sub	r26, r26
    4068:	bb 1b       	sub	r27, r27
    406a:	51 e1       	ldi	r21, 0x11	; 17
    406c:	07 c0       	rjmp	.+14     	; 0x407c <__udivmodhi4_ep>

0000406e <__udivmodhi4_loop>:
    406e:	aa 1f       	adc	r26, r26
    4070:	bb 1f       	adc	r27, r27
    4072:	a6 17       	cp	r26, r22
    4074:	b7 07       	cpc	r27, r23
    4076:	10 f0       	brcs	.+4      	; 0x407c <__udivmodhi4_ep>
    4078:	a6 1b       	sub	r26, r22
    407a:	b7 0b       	sbc	r27, r23

0000407c <__udivmodhi4_ep>:
    407c:	88 1f       	adc	r24, r24
    407e:	99 1f       	adc	r25, r25
    4080:	5a 95       	dec	r21
    4082:	a9 f7       	brne	.-22     	; 0x406e <__udivmodhi4_loop>
    4084:	80 95       	com	r24
    4086:	90 95       	com	r25
    4088:	bc 01       	movw	r22, r24
    408a:	cd 01       	movw	r24, r26
    408c:	08 95       	ret

0000408e <__umulhisi3>:
    408e:	a2 9f       	mul	r26, r18
    4090:	b0 01       	movw	r22, r0
    4092:	b3 9f       	mul	r27, r19
    4094:	c0 01       	movw	r24, r0
    4096:	a3 9f       	mul	r26, r19
    4098:	70 0d       	add	r23, r0
    409a:	81 1d       	adc	r24, r1
    409c:	11 24       	eor	r1, r1
    409e:	91 1d       	adc	r25, r1
    40a0:	b2 9f       	mul	r27, r18
    40a2:	70 0d       	add	r23, r0
    40a4:	81 1d       	adc	r24, r1
    40a6:	11 24       	eor	r1, r1
    40a8:	91 1d       	adc	r25, r1
    40aa:	08 95       	ret

000040ac <memcpy>:
    40ac:	fb 01       	movw	r30, r22
    40ae:	dc 01       	movw	r26, r24
    40b0:	02 c0       	rjmp	.+4      	; 0x40b6 <memcpy+0xa>
    40b2:	01 90       	ld	r0, Z+
    40b4:	0d 92       	st	X+, r0
    40b6:	41 50       	subi	r20, 0x01	; 1
    40b8:	50 40       	sbci	r21, 0x00	; 0
    40ba:	d8 f7       	brcc	.-10     	; 0x40b2 <memcpy+0x6>
    40bc:	08 95       	ret

000040be <memset>:
    40be:	dc 01       	movw	r26, r24
    40c0:	01 c0       	rjmp	.+2      	; 0x40c4 <memset+0x6>
    40c2:	6d 93       	st	X+, r22
    40c4:	41 50       	subi	r20, 0x01	; 1
    40c6:	50 40       	sbci	r21, 0x00	; 0
    40c8:	e0 f7       	brcc	.-8      	; 0x40c2 <memset+0x4>
    40ca:	08 95       	ret

000040cc <strncpy>:
    40cc:	fb 01       	movw	r30, r22
    40ce:	dc 01       	movw	r26, r24
    40d0:	41 50       	subi	r20, 0x01	; 1
    40d2:	50 40       	sbci	r21, 0x00	; 0
    40d4:	48 f0       	brcs	.+18     	; 0x40e8 <strncpy+0x1c>
    40d6:	01 90       	ld	r0, Z+
    40d8:	0d 92       	st	X+, r0
    40da:	00 20       	and	r0, r0
    40dc:	c9 f7       	brne	.-14     	; 0x40d0 <strncpy+0x4>
    40de:	01 c0       	rjmp	.+2      	; 0x40e2 <strncpy+0x16>
    40e0:	1d 92       	st	X+, r1
    40e2:	41 50       	subi	r20, 0x01	; 1
    40e4:	50 40       	sbci	r21, 0x00	; 0
    40e6:	e0 f7       	brcc	.-8      	; 0x40e0 <strncpy+0x14>
    40e8:	08 95       	ret

000040ea <__itoa_ncheck>:
    40ea:	bb 27       	eor	r27, r27
    40ec:	4a 30       	cpi	r20, 0x0A	; 10
    40ee:	31 f4       	brne	.+12     	; 0x40fc <__itoa_ncheck+0x12>
    40f0:	99 23       	and	r25, r25
    40f2:	22 f4       	brpl	.+8      	; 0x40fc <__itoa_ncheck+0x12>
    40f4:	bd e2       	ldi	r27, 0x2D	; 45
    40f6:	90 95       	com	r25
    40f8:	81 95       	neg	r24
    40fa:	9f 4f       	sbci	r25, 0xFF	; 255
    40fc:	0c 94 b9 20 	jmp	0x4172	; 0x4172 <__utoa_common>

00004100 <ultoa>:
    4100:	25 32       	cpi	r18, 0x25	; 37
    4102:	31 05       	cpc	r19, r1
    4104:	20 f4       	brcc	.+8      	; 0x410e <ultoa+0xe>
    4106:	22 30       	cpi	r18, 0x02	; 2
    4108:	10 f0       	brcs	.+4      	; 0x410e <ultoa+0xe>
    410a:	0c 94 8b 20 	jmp	0x4116	; 0x4116 <__ultoa_ncheck>
    410e:	fa 01       	movw	r30, r20
    4110:	10 82       	st	Z, r1
    4112:	ca 01       	movw	r24, r20
    4114:	08 95       	ret

00004116 <__ultoa_ncheck>:
    4116:	bb 27       	eor	r27, r27

00004118 <__ultoa_common>:
    4118:	fa 01       	movw	r30, r20
    411a:	a6 2f       	mov	r26, r22
    411c:	62 17       	cp	r22, r18
    411e:	71 05       	cpc	r23, r1
    4120:	81 05       	cpc	r24, r1
    4122:	91 05       	cpc	r25, r1
    4124:	33 0b       	sbc	r19, r19
    4126:	30 fb       	bst	r19, 0
    4128:	66 f0       	brts	.+24     	; 0x4142 <__ultoa_common+0x2a>
    412a:	aa 27       	eor	r26, r26
    412c:	66 0f       	add	r22, r22
    412e:	77 1f       	adc	r23, r23
    4130:	88 1f       	adc	r24, r24
    4132:	99 1f       	adc	r25, r25
    4134:	aa 1f       	adc	r26, r26
    4136:	a2 17       	cp	r26, r18
    4138:	10 f0       	brcs	.+4      	; 0x413e <__ultoa_common+0x26>
    413a:	a2 1b       	sub	r26, r18
    413c:	63 95       	inc	r22
    413e:	38 50       	subi	r19, 0x08	; 8
    4140:	a9 f7       	brne	.-22     	; 0x412c <__ultoa_common+0x14>
    4142:	a0 5d       	subi	r26, 0xD0	; 208
    4144:	aa 33       	cpi	r26, 0x3A	; 58
    4146:	08 f0       	brcs	.+2      	; 0x414a <__ultoa_common+0x32>
    4148:	a9 5d       	subi	r26, 0xD9	; 217
    414a:	a1 93       	st	Z+, r26
    414c:	36 f7       	brtc	.-52     	; 0x411a <__ultoa_common+0x2>
    414e:	b1 11       	cpse	r27, r1
    4150:	b1 93       	st	Z+, r27
    4152:	10 82       	st	Z, r1
    4154:	ca 01       	movw	r24, r20
    4156:	0c 94 d2 20 	jmp	0x41a4	; 0x41a4 <strrev>

0000415a <utoa>:
    415a:	45 32       	cpi	r20, 0x25	; 37
    415c:	51 05       	cpc	r21, r1
    415e:	20 f4       	brcc	.+8      	; 0x4168 <utoa+0xe>
    4160:	42 30       	cpi	r20, 0x02	; 2
    4162:	10 f0       	brcs	.+4      	; 0x4168 <utoa+0xe>
    4164:	0c 94 b8 20 	jmp	0x4170	; 0x4170 <__utoa_ncheck>
    4168:	fb 01       	movw	r30, r22
    416a:	10 82       	st	Z, r1
    416c:	cb 01       	movw	r24, r22
    416e:	08 95       	ret

00004170 <__utoa_ncheck>:
    4170:	bb 27       	eor	r27, r27

00004172 <__utoa_common>:
    4172:	fb 01       	movw	r30, r22
    4174:	55 27       	eor	r21, r21
    4176:	aa 27       	eor	r26, r26
    4178:	88 0f       	add	r24, r24
    417a:	99 1f       	adc	r25, r25
    417c:	aa 1f       	adc	r26, r26
    417e:	a4 17       	cp	r26, r20
    4180:	10 f0       	brcs	.+4      	; 0x4186 <__utoa_common+0x14>
    4182:	a4 1b       	sub	r26, r20
    4184:	83 95       	inc	r24
    4186:	50 51       	subi	r21, 0x10	; 16
    4188:	b9 f7       	brne	.-18     	; 0x4178 <__utoa_common+0x6>
    418a:	a0 5d       	subi	r26, 0xD0	; 208
    418c:	aa 33       	cpi	r26, 0x3A	; 58
    418e:	08 f0       	brcs	.+2      	; 0x4192 <__utoa_common+0x20>
    4190:	a9 5d       	subi	r26, 0xD9	; 217
    4192:	a1 93       	st	Z+, r26
    4194:	00 97       	sbiw	r24, 0x00	; 0
    4196:	79 f7       	brne	.-34     	; 0x4176 <__utoa_common+0x4>
    4198:	b1 11       	cpse	r27, r1
    419a:	b1 93       	st	Z+, r27
    419c:	11 92       	st	Z+, r1
    419e:	cb 01       	movw	r24, r22
    41a0:	0c 94 d2 20 	jmp	0x41a4	; 0x41a4 <strrev>

000041a4 <strrev>:
    41a4:	dc 01       	movw	r26, r24
    41a6:	fc 01       	movw	r30, r24
    41a8:	67 2f       	mov	r22, r23
    41aa:	71 91       	ld	r23, Z+
    41ac:	77 23       	and	r23, r23
    41ae:	e1 f7       	brne	.-8      	; 0x41a8 <strrev+0x4>
    41b0:	32 97       	sbiw	r30, 0x02	; 2
    41b2:	04 c0       	rjmp	.+8      	; 0x41bc <strrev+0x18>
    41b4:	7c 91       	ld	r23, X
    41b6:	6d 93       	st	X+, r22
    41b8:	70 83       	st	Z, r23
    41ba:	62 91       	ld	r22, -Z
    41bc:	ae 17       	cp	r26, r30
    41be:	bf 07       	cpc	r27, r31
    41c0:	c8 f3       	brcs	.-14     	; 0x41b4 <strrev+0x10>
    41c2:	08 95       	ret

000041c4 <_exit>:
    41c4:	f8 94       	cli

000041c6 <__stop_program>:
    41c6:	ff cf       	rjmp	.-2      	; 0x41c6 <__stop_program>
