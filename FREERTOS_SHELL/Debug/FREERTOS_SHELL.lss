
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004160  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000f6  00802000  00004160  000041f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020f6  008020f6  000042ea  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000042ea  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000431c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000738  00000000  00000000  0000435c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001211a  00000000  00000000  00004a94  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006990  00000000  00000000  00016bae  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000056f8  00000000  00000000  0001d53e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000138c  00000000  00000000  00022c38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006421  00000000  00000000  00023fc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006184  00000000  00000000  0002a3e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005c0  00000000  00000000  00030569  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ad 02 	jmp	0x55a	; 0x55a <__ctors_end>
       4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
       8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
       c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      10:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      14:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      18:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      1c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      20:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      24:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      28:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      2c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      30:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      34:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      38:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      3c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      40:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      44:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      48:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      4c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      50:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      54:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      58:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      5c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      60:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      64:	0c 94 58 1c 	jmp	0x38b0	; 0x38b0 <__vector_25>
      68:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      6c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      70:	0c 94 b6 1c 	jmp	0x396c	; 0x396c <__vector_28>
      74:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      78:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      7c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      80:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      84:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      88:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      8c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      90:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      94:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      98:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      9c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      a0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      a4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      a8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      ac:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      b0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      b4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      b8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      bc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      c0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      c4:	0c 94 49 0c 	jmp	0x1892	; 0x1892 <__vector_49>
      c8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      cc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      d0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      d4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      d8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      dc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      e0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      e4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      e8:	0c 94 d0 1d 	jmp	0x3ba0	; 0x3ba0 <__vector_58>
      ec:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      f0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      f4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      f8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      fc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     100:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     104:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     108:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     10c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     110:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     114:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     118:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     11c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     120:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     124:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     128:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     12c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     130:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     134:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     138:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     13c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     140:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     144:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     148:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     14c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     150:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     154:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     158:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     15c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     160:	0c 94 14 1d 	jmp	0x3a28	; 0x3a28 <__vector_88>
     164:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     168:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     16c:	0c 94 72 1d 	jmp	0x3ae4	; 0x3ae4 <__vector_91>
     170:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     174:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     178:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     17c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     180:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     184:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     188:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     18c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     190:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     194:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     198:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     19c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1a0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1a4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1a8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1ac:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1b0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1b4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1b8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1bc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1c0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1c4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1c8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1cc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1d0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1d4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1d8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1dc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1e0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1e4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1e8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1ec:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1f0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1f4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1f8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1fc:	1b 1a       	sub	r1, r27
     1fe:	1e 1a       	sub	r1, r30
     200:	21 1a       	sub	r2, r17
     202:	24 1a       	sub	r2, r20
     204:	27 1a       	sub	r2, r23
     206:	2a 1a       	sub	r2, r26
     208:	2c 1a       	sub	r2, r28
     20a:	3d 1a       	sub	r3, r29
     20c:	45 1a       	sub	r4, r21
     20e:	4f 1a       	sub	r4, r31
     210:	4d 1a       	sub	r4, r29

00000212 <__trampolines_start>:
     212:	0c 94 00 08 	jmp	0x1000	; 0x1000 <_ZN9task_user3runEv>
     216:	0c 94 fc 15 	jmp	0x2bf8	; 0x2bf8 <_ZN8frt_task12print_statusER8emstream>
     21a:	0c 94 38 03 	jmp	0x670	; 0x670 <_ZN17task_EncoderMotor3runEv>
     21e:	0c 94 27 1a 	jmp	0x344e	; 0x344e <_ZN8emstreamlsE15ser_manipulator+0x36>
     222:	0c 94 aa 02 	jmp	0x554	; 0x554 <_call_static_run_method>
     226:	0c 94 2c 1a 	jmp	0x3458	; 0x3458 <_ZN8emstreamlsE15ser_manipulator+0x40>
     22a:	0c 94 46 17 	jmp	0x2e8c	; 0x2e8c <_ZN14frt_text_queue7getcharEv>
     22e:	0c 94 90 04 	jmp	0x920	; 0x920 <_ZN10task_Motor3runEv>
     232:	0c 94 c6 19 	jmp	0x338c	; 0x338c <_ZN8emstream12clear_screenEv>
     236:	0c 94 2a 1a 	jmp	0x3454	; 0x3454 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     23a:	0c 94 be 19 	jmp	0x337c	; 0x337c <_ZN8emstream13ready_to_sendEv>
     23e:	0c 94 96 1b 	jmp	0x372c	; 0x372c <_ZN5rs2327getcharEv>
     242:	0c 94 c3 19 	jmp	0x3386	; 0x3386 <_ZN8emstream14check_for_charEv>
     246:	0c 94 24 1a 	jmp	0x3448	; 0x3448 <_ZN8emstreamlsE15ser_manipulator+0x30>
     24a:	0c 94 c5 19 	jmp	0x338a	; 0x338a <_ZN8emstream12transmit_nowEv>
     24e:	0c 94 bb 03 	jmp	0x776	; 0x776 <_ZN20task_EncoderPendulum3runEv>
     252:	0c 94 21 1a 	jmp	0x3442	; 0x3442 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     256:	0c 94 27 19 	jmp	0x324e	; 0x324e <__cxa_pure_virtual>
     25a:	0c 94 c0 19 	jmp	0x3380	; 0x3380 <_ZN8emstream7getcharEv>
     25e:	0c 94 1e 1a 	jmp	0x343c	; 0x343c <_ZN8emstreamlsE15ser_manipulator+0x24>
     262:	0c 94 cf 1b 	jmp	0x379e	; 0x379e <_ZN5rs23212clear_screenEv>
     266:	0c 94 4f 1a 	jmp	0x349e	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
     26a:	0c 94 64 17 	jmp	0x2ec8	; 0x2ec8 <_ZN14frt_text_queue14check_for_charEv>
     26e:	0c 94 bc 1b 	jmp	0x3778	; 0x3778 <_ZN5rs23214check_for_charEv>
     272:	0c 94 72 1b 	jmp	0x36e4	; 0x36e4 <_ZN5rs2327putcharEc>
     276:	0c 94 2b 04 	jmp	0x856	; 0x856 <_ZN18task_LimitSwitches3runEv>
     27a:	0c 94 98 06 	jmp	0xd30	; 0xd30 <_ZN13task_Position3runEv>
     27e:	0c 94 6f 17 	jmp	0x2ede	; 0x2ede <_ZN14frt_text_queue7putcharEc>
     282:	0c 94 f3 1e 	jmp	0x3de6	; 0x3de6 <_GLOBAL__sub_I_counter>
     286:	0c 94 13 03 	jmp	0x626	; 0x626 <_ZN10task_Angle3runEv>
     28a:	0c 94 2d 09 	jmp	0x125a	; 0x125a <_ZN13task_Velocity3runEv>
     28e:	0c 94 cd 0e 	jmp	0x1d9a	; 0x1d9a <prvIdleTask>
     292:	0c 94 1b 1a 	jmp	0x3436	; 0x3436 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     296:	0c 94 45 1a 	jmp	0x348a	; 0x348a <_ZN8emstreamlsE15ser_manipulator+0x72>
     29a:	0c 94 4d 1a 	jmp	0x349a	; 0x349a <_ZN8emstreamlsE15ser_manipulator+0x82>
     29e:	0c 94 3d 1a 	jmp	0x347a	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x62>

000002a2 <__trampolines_end>:
     2a2:	2c 20       	and	r2, r12
     2a4:	54 43       	sbci	r21, 0x34	; 52
     2a6:	43 30       	cpi	r20, 0x03	; 3
     2a8:	43 43       	sbci	r20, 0x33	; 51
     2aa:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002ad <_ZZN9task_user11show_statusEvE3__c_3>:
     2ad:	2f 00                                               /.

000002af <_ZZN9task_user11show_statusEvE3__c_2>:
     2af:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002bd <_ZZN9task_user11show_statusEvE3__c_1>:
     2bd:	54 69 6d 65 3a 20 00                                Time: .

000002c4 <_ZZN9task_user11show_statusEvE3__c_0>:
     2c4:	44 65 63 20 20 36 20 32 30 31 37 00                 Dec  6 2017.

000002d0 <_ZZN9task_user11show_statusEvE3__c>:
     2d0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2e0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002ef <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2ef:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002fe <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2fe:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     30e:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000319 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     319:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     329:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000337 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     337:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     347:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     357:	6d 61 74 69 6f 6e 00                                mation.

0000035e <_ZZN9task_user18print_help_messageEvE3__c_6>:
     35e:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     36e:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000037f <_ZZN9task_user18print_help_messageEvE3__c_5>:
     37f:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     38f:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000397 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     397:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     3a7:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003b3 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3b3:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3c3:	68 65 20 41 56 52 00                                he AVR.

000003ca <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3ca:	20 68 65 6c 70 00                                    help.

000003d0 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3d0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3e0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003ef <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3ef:	1b 5b 33 30 6d 00                                   .[30m.

000003f5 <_ZZN9task_user18print_help_messageEvE3__c>:
     3f5:	1b 5b 34 36 6d 00                                   .[46m.

000003fb <_ZZN9task_user3runEvE3__c_3>:
     3fb:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     40b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000418 <_ZZN9task_user3runEvE3__c_2>:
     418:	3a 57 54 46 3f 00                                   :WTF?.

0000041e <_ZZN9task_user3runEvE3__c_1>:
     41e:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     42e:	65 00                                               e.

00000430 <_ZZN9task_user3runEvE3__c_0>:
     430:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000043e <_ZZN9task_user3runEvE3__c>:
     43e:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     44e:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

0000045c <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     45c:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000466 <_ZZN8frt_task15emergency_resetEvE3__c>:
     466:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000475 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     475:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     485:	61 73 6b 20 00                                      ask .

0000048a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     48a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000498 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     498:	20 63 72 65 61 74 65 64 00                           created.

000004a1 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     4a1:	54 61 73 6b 20 00                                   Task .

000004a7 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     4a7:	1b 5b 32 32 6d 00                                   .[22m.

000004ad <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4ad:	54 61 73 6b 3a 20 00                                Task: .

000004b4 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4b4:	1b 5b 31 6d 00                                      .[1m.

000004b9 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b9:	1b 5b 32 32 6d 00                                   .[22m.

000004bf <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4bf:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004ca <_ZZ17print_task_stacksP8emstreamE3__c>:
     4ca:	1b 5b 31 6d 00                                      .[1m.

000004cf <_ZZ15print_task_listP8emstreamE3__c_9>:
     4cf:	09 09 00                                            ...

000004d2 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4d2:	2f 00                                               /.

000004d4 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4d4:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004df <_ZZ15print_task_listP8emstreamE3__c_6>:
     4df:	09 2d 2d 2d 2d 00                                   .----.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4e5:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004f1 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4f1:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000502 <_ZZ15print_task_listP8emstreamE3__c_3>:
     502:	09 52 75 6e 73 00                                   .Runs.

00000508 <_ZZ15print_task_listP8emstreamE3__c_2>:
     508:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000514 <_ZZ15print_task_listP8emstreamE3__c_1>:
     514:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000525 <_ZZ15print_task_listP8emstreamE3__c_0>:
     525:	09 53 74 61 63 6b 00                                .Stack.

0000052c <_ZZ15print_task_listP8emstreamE3__c>:
     52c:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     537:	09 00                                               ..

00000539 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     539:	09 00                                               ..

0000053b <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     53b:	2f 00                                               /.

0000053d <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     53d:	09 00                                               ..

0000053f <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     53f:	09 00                                               ..

00000541 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     541:	1b 5b 32 32 6d 00                                   .[22m.

00000547 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     547:	1b 5b 31 6d 00                                      .[1m.

0000054c <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     54c:	1b 5b 31 6d 00                                      .[1m.

00000551 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     551:	20 20 00                                              .

00000554 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     554:	0e 94 94 14 	call	0x2928	; 0x2928 <_ZN8frt_task22_call_users_run_methodEPS_>

00000558 <__ctors_start>:
     558:	f3 1e       	adc	r15, r19

0000055a <__ctors_end>:
     55a:	11 24       	eor	r1, r1
     55c:	1f be       	out	0x3f, r1	; 63
     55e:	cf ef       	ldi	r28, 0xFF	; 255
     560:	cd bf       	out	0x3d, r28	; 61
     562:	df e3       	ldi	r29, 0x3F	; 63
     564:	de bf       	out	0x3e, r29	; 62
     566:	00 e0       	ldi	r16, 0x00	; 0
     568:	0c bf       	out	0x3c, r16	; 60
     56a:	18 be       	out	0x38, r1	; 56
     56c:	19 be       	out	0x39, r1	; 57
     56e:	1a be       	out	0x3a, r1	; 58
     570:	1b be       	out	0x3b, r1	; 59

00000572 <__do_copy_data>:
     572:	10 e2       	ldi	r17, 0x20	; 32
     574:	a0 e0       	ldi	r26, 0x00	; 0
     576:	b0 e2       	ldi	r27, 0x20	; 32
     578:	e0 e6       	ldi	r30, 0x60	; 96
     57a:	f1 e4       	ldi	r31, 0x41	; 65
     57c:	00 e0       	ldi	r16, 0x00	; 0
     57e:	0b bf       	out	0x3b, r16	; 59
     580:	02 c0       	rjmp	.+4      	; 0x586 <__do_copy_data+0x14>
     582:	07 90       	elpm	r0, Z+
     584:	0d 92       	st	X+, r0
     586:	a6 3f       	cpi	r26, 0xF6	; 246
     588:	b1 07       	cpc	r27, r17
     58a:	d9 f7       	brne	.-10     	; 0x582 <__do_copy_data+0x10>
     58c:	1b be       	out	0x3b, r1	; 59

0000058e <__do_clear_bss>:
     58e:	21 e3       	ldi	r18, 0x31	; 49
     590:	a6 ef       	ldi	r26, 0xF6	; 246
     592:	b0 e2       	ldi	r27, 0x20	; 32
     594:	01 c0       	rjmp	.+2      	; 0x598 <.do_clear_bss_start>

00000596 <.do_clear_bss_loop>:
     596:	1d 92       	st	X+, r1

00000598 <.do_clear_bss_start>:
     598:	ac 39       	cpi	r26, 0x9C	; 156
     59a:	b2 07       	cpc	r27, r18
     59c:	e1 f7       	brne	.-8      	; 0x596 <.do_clear_bss_loop>

0000059e <__do_global_ctors>:
     59e:	12 e0       	ldi	r17, 0x02	; 2
     5a0:	cd ea       	ldi	r28, 0xAD	; 173
     5a2:	d2 e0       	ldi	r29, 0x02	; 2
     5a4:	00 e0       	ldi	r16, 0x00	; 0
     5a6:	06 c0       	rjmp	.+12     	; 0x5b4 <__do_global_ctors+0x16>
     5a8:	21 97       	sbiw	r28, 0x01	; 1
     5aa:	01 09       	sbc	r16, r1
     5ac:	80 2f       	mov	r24, r16
     5ae:	fe 01       	movw	r30, r28
     5b0:	0e 94 d4 1f 	call	0x3fa8	; 0x3fa8 <__tablejump2__>
     5b4:	cc 3a       	cpi	r28, 0xAC	; 172
     5b6:	d1 07       	cpc	r29, r17
     5b8:	80 e0       	ldi	r24, 0x00	; 0
     5ba:	08 07       	cpc	r16, r24
     5bc:	a9 f7       	brne	.-22     	; 0x5a8 <__do_global_ctors+0xa>
     5be:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <main>
     5c2:	0c 94 ae 20 	jmp	0x415c	; 0x415c <_exit>

000005c6 <__bad_interrupt>:
     5c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005ca <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
     5ca:	9c 01       	movw	r18, r24
     5cc:	93 2f       	mov	r25, r19
     5ce:	99 1f       	adc	r25, r25
     5d0:	99 27       	eor	r25, r25
     5d2:	99 1f       	adc	r25, r25
     5d4:	89 2f       	mov	r24, r25
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	81 50       	subi	r24, 0x01	; 1
     5da:	90 48       	sbci	r25, 0x80	; 128
     5dc:	43 2f       	mov	r20, r19
     5de:	40 95       	com	r20
     5e0:	44 1f       	adc	r20, r20
     5e2:	44 27       	eor	r20, r20
     5e4:	44 1f       	adc	r20, r20
     5e6:	fc 01       	movw	r30, r24
     5e8:	e2 1b       	sub	r30, r18
     5ea:	f3 0b       	sbc	r31, r19
     5ec:	51 e0       	ldi	r21, 0x01	; 1
     5ee:	e6 17       	cp	r30, r22
     5f0:	f7 07       	cpc	r31, r23
     5f2:	0c f0       	brlt	.+2      	; 0x5f6 <_ZN7satmath20signed_saturated_addEii+0x2c>
     5f4:	50 e0       	ldi	r21, 0x00	; 0
     5f6:	45 17       	cp	r20, r21
     5f8:	19 f0       	breq	.+6      	; 0x600 <_ZN7satmath20signed_saturated_addEii+0x36>
     5fa:	c9 01       	movw	r24, r18
     5fc:	86 0f       	add	r24, r22
     5fe:	97 1f       	adc	r25, r23
     600:	08 95       	ret

00000602 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     602:	81 15       	cp	r24, r1
     604:	20 e8       	ldi	r18, 0x80	; 128
     606:	92 07       	cpc	r25, r18
     608:	21 f4       	brne	.+8      	; 0x612 <_ZN7satmath20signed_saturated_mulEii+0x10>
     60a:	61 15       	cp	r22, r1
     60c:	20 e8       	ldi	r18, 0x80	; 128
     60e:	72 07       	cpc	r23, r18
     610:	29 f0       	breq	.+10     	; 0x61c <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     612:	9c 01       	movw	r18, r24
     614:	db 01       	movw	r26, r22
     616:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <__mulhisi3>
     61a:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     61c:	6f ef       	ldi	r22, 0xFF	; 255
     61e:	7f ef       	ldi	r23, 0xFF	; 255
     620:	8f ef       	ldi	r24, 0xFF	; 255
     622:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     624:	08 95       	ret

00000626 <_ZN10task_Angle3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void task_Angle::run (void)
{
     626:	cf 93       	push	r28
     628:	df 93       	push	r29
     62a:	00 d0       	rcall	.+0      	; 0x62c <_ZN10task_Angle3runEv+0x6>
     62c:	1f 92       	push	r1
     62e:	cd b7       	in	r28, 0x3d	; 61
     630:	de b7       	in	r29, 0x3e	; 62
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     632:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <xTaskGetTickCount>
     636:	69 83       	std	Y+1, r22	; 0x01
     638:	7a 83       	std	Y+2, r23	; 0x02
     63a:	8b 83       	std	Y+3, r24	; 0x03
     63c:	9c 83       	std	Y+4, r25	; 0x04
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     63e:	42 e1       	ldi	r20, 0x12	; 18
     640:	50 e0       	ldi	r21, 0x00	; 0
     642:	60 e0       	ldi	r22, 0x00	; 0
     644:	70 e0       	ldi	r23, 0x00	; 0
     646:	ce 01       	movw	r24, r28
     648:	01 96       	adiw	r24, 0x01	; 1
     64a:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskDelayUntil>
     64e:	f7 cf       	rjmp	.-18     	; 0x63e <_ZN10task_Angle3runEv+0x18>

00000650 <_ZN10task_AngleC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_Angle::task_Angle(const char* a_name,
     650:	0f 93       	push	r16
     652:	1f 93       	push	r17
     654:	cf 93       	push	r28
     656:	df 93       	push	r29
     658:	ec 01       	movw	r28, r24
size_t a_stack_size,
emstream* p_ser_dev
)

// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     65a:	0e 94 a7 14 	call	0x294e	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream>
     65e:	8a e0       	ldi	r24, 0x0A	; 10
     660:	90 e2       	ldi	r25, 0x20	; 32
     662:	88 83       	st	Y, r24
     664:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	08 95       	ret

00000670 <_ZN17task_EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void task_EncoderMotor::run (void)
{ 
     670:	cf 93       	push	r28
     672:	df 93       	push	r29
     674:	00 d0       	rcall	.+0      	; 0x676 <_ZN17task_EncoderMotor3runEv+0x6>
     676:	1f 92       	push	r1
     678:	cd b7       	in	r28, 0x3d	; 61
     67a:	de b7       	in	r29, 0x3e	; 62
     67c:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     67e:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <xTaskGetTickCount>
     682:	69 83       	std	Y+1, r22	; 0x01
     684:	7a 83       	std	Y+2, r23	; 0x02
     686:	8b 83       	std	Y+3, r24	; 0x03
     688:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     68a:	e0 e8       	ldi	r30, 0x80	; 128
     68c:	f6 e0       	ldi	r31, 0x06	; 6
     68e:	8c e0       	ldi	r24, 0x0C	; 12
     690:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     692:	82 89       	ldd	r24, Z+18	; 0x12
     694:	83 60       	ori	r24, 0x03	; 3
     696:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     698:	83 89       	ldd	r24, Z+19	; 0x13
     69a:	83 60       	ori	r24, 0x03	; 3
     69c:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     69e:	e0 e8       	ldi	r30, 0x80	; 128
     6a0:	f1 e0       	ldi	r31, 0x01	; 1
     6a2:	82 e7       	ldi	r24, 0x72	; 114
     6a4:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     6a6:	89 e0       	ldi	r24, 0x09	; 9
     6a8:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     6aa:	e0 e0       	ldi	r30, 0x00	; 0
     6ac:	f9 e0       	ldi	r31, 0x09	; 9
     6ae:	88 e6       	ldi	r24, 0x68	; 104
     6b0:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     6b2:	8f ef       	ldi	r24, 0xFF	; 255
     6b4:	9f ef       	ldi	r25, 0xFF	; 255
     6b6:	86 a3       	std	Z+38, r24	; 0x26
     6b8:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     6ba:	81 e0       	ldi	r24, 0x01	; 1
     6bc:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     6be:	0f 2e       	mov	r0, r31
     6c0:	a1 2c       	mov	r10, r1
     6c2:	f9 e0       	ldi	r31, 0x09	; 9
     6c4:	bf 2e       	mov	r11, r31
     6c6:	f0 2d       	mov	r31, r0
     6c8:	f5 01       	movw	r30, r10
     6ca:	00 a1       	ldd	r16, Z+32	; 0x20
     6cc:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     6ce:	0f b6       	in	r0, 0x3f	; 63
     6d0:	f8 94       	cli
     6d2:	0f 92       	push	r0
			the_data = new_data;
     6d4:	c8 01       	movw	r24, r16
     6d6:	01 2e       	mov	r0, r17
     6d8:	00 0c       	add	r0, r0
     6da:	aa 0b       	sbc	r26, r26
     6dc:	bb 0b       	sbc	r27, r27
     6de:	ac 01       	movw	r20, r24
     6e0:	bd 01       	movw	r22, r26
     6e2:	44 0f       	add	r20, r20
     6e4:	55 1f       	adc	r21, r21
     6e6:	66 1f       	adc	r22, r22
     6e8:	77 1f       	adc	r23, r23
     6ea:	3a 01       	movw	r6, r20
     6ec:	4b 01       	movw	r8, r22
     6ee:	68 0e       	add	r6, r24
     6f0:	79 1e       	adc	r7, r25
     6f2:	8a 1e       	adc	r8, r26
     6f4:	9b 1e       	adc	r9, r27
     6f6:	c4 01       	movw	r24, r8
     6f8:	b3 01       	movw	r22, r6
     6fa:	24 e6       	ldi	r18, 0x64	; 100
     6fc:	30 e0       	ldi	r19, 0x00	; 0
     6fe:	40 e0       	ldi	r20, 0x00	; 0
     700:	50 e0       	ldi	r21, 0x00	; 0
     702:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <__divmodsi4>
     706:	20 93 88 31 	sts	0x3188, r18	; 0x803188 <linear_position>
     70a:	30 93 89 31 	sts	0x3189, r19	; 0x803189 <linear_position+0x1>
			portEXIT_CRITICAL ();
     70e:	0f 90       	pop	r0
     710:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	0f 92       	push	r0
			the_data = new_data;
     718:	c8 01       	movw	r24, r16
     71a:	8c 19       	sub	r24, r12
     71c:	9d 09       	sbc	r25, r13
     71e:	80 93 86 31 	sts	0x3186, r24	; 0x803186 <thdMotor>
     722:	90 93 87 31 	sts	0x3187, r25	; 0x803187 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     726:	0f 90       	pop	r0
     728:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     72a:	f7 01       	movw	r30, r14
     72c:	86 85       	ldd	r24, Z+14	; 0x0e
     72e:	97 85       	ldd	r25, Z+15	; 0x0f
     730:	a0 89       	ldd	r26, Z+16	; 0x10
     732:	b1 89       	ldd	r27, Z+17	; 0x11
     734:	01 96       	adiw	r24, 0x01	; 1
     736:	a1 1d       	adc	r26, r1
     738:	b1 1d       	adc	r27, r1
     73a:	86 87       	std	Z+14, r24	; 0x0e
     73c:	97 87       	std	Z+15, r25	; 0x0f
     73e:	a0 8b       	std	Z+16, r26	; 0x10
     740:	b1 8b       	std	Z+17, r27	; 0x11
     742:	41 e0       	ldi	r20, 0x01	; 1
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	60 e0       	ldi	r22, 0x00	; 0
     748:	70 e0       	ldi	r23, 0x00	; 0
     74a:	ce 01       	movw	r24, r28
     74c:	01 96       	adiw	r24, 0x01	; 1
     74e:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     752:	68 01       	movw	r12, r16
     754:	b9 cf       	rjmp	.-142    	; 0x6c8 <_ZN17task_EncoderMotor3runEv+0x58>

00000756 <_ZN17task_EncoderMotorC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_EncoderMotor::task_EncoderMotor(const char* a_name,
     756:	0f 93       	push	r16
     758:	1f 93       	push	r17
     75a:	cf 93       	push	r28
     75c:	df 93       	push	r29
     75e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     760:	0e 94 a7 14 	call	0x294e	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream>
     764:	82 e1       	ldi	r24, 0x12	; 18
     766:	90 e2       	ldi	r25, 0x20	; 32
     768:	88 83       	st	Y, r24
     76a:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	1f 91       	pop	r17
     772:	0f 91       	pop	r16
     774:	08 95       	ret

00000776 <_ZN20task_EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void task_EncoderPendulum::run(void){
     776:	cf 93       	push	r28
     778:	df 93       	push	r29
     77a:	00 d0       	rcall	.+0      	; 0x77c <_ZN20task_EncoderPendulum3runEv+0x6>
     77c:	1f 92       	push	r1
     77e:	cd b7       	in	r28, 0x3d	; 61
     780:	de b7       	in	r29, 0x3e	; 62
     782:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     784:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <xTaskGetTickCount>
     788:	69 83       	std	Y+1, r22	; 0x01
     78a:	7a 83       	std	Y+2, r23	; 0x02
     78c:	8b 83       	std	Y+3, r24	; 0x03
     78e:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     790:	e0 e8       	ldi	r30, 0x80	; 128
     792:	f6 e0       	ldi	r31, 0x06	; 6
     794:	83 e0       	ldi	r24, 0x03	; 3
     796:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     798:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     79a:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     79c:	e0 e8       	ldi	r30, 0x80	; 128
     79e:	f1 e0       	ldi	r31, 0x01	; 1
     7a0:	80 e7       	ldi	r24, 0x70	; 112
     7a2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     7a4:	89 e0       	ldi	r24, 0x09	; 9
     7a6:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     7a8:	e0 e4       	ldi	r30, 0x40	; 64
     7aa:	f8 e0       	ldi	r31, 0x08	; 8
     7ac:	8a e6       	ldi	r24, 0x6A	; 106
     7ae:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     7b0:	80 ea       	ldi	r24, 0xA0	; 160
     7b2:	95 e0       	ldi	r25, 0x05	; 5
     7b4:	86 a3       	std	Z+38, r24	; 0x26
     7b6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     7b8:	81 e0       	ldi	r24, 0x01	; 1
     7ba:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     7bc:	68 94       	set
     7be:	ee 24       	eor	r14, r14
     7c0:	e6 f8       	bld	r14, 6
     7c2:	ff 24       	eor	r15, r15
     7c4:	f3 f8       	bld	r15, 3
     7c6:	f7 01       	movw	r30, r14
     7c8:	a0 a1       	ldd	r26, Z+32	; 0x20
     7ca:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7cc:	0f b6       	in	r0, 0x3f	; 63
     7ce:	f8 94       	cli
     7d0:	0f 92       	push	r0
			the_data = new_data;
     7d2:	24 e6       	ldi	r18, 0x64	; 100
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <__usmulhisi3>
     7da:	4b 01       	movw	r8, r22
     7dc:	5c 01       	movw	r10, r24
     7de:	99 23       	and	r25, r25
     7e0:	2c f4       	brge	.+10     	; 0x7ec <_ZN20task_EncoderPendulum3runEv+0x76>
     7e2:	f3 e0       	ldi	r31, 0x03	; 3
     7e4:	8f 0e       	add	r8, r31
     7e6:	91 1c       	adc	r9, r1
     7e8:	a1 1c       	adc	r10, r1
     7ea:	b1 1c       	adc	r11, r1
     7ec:	d5 01       	movw	r26, r10
     7ee:	c4 01       	movw	r24, r8
     7f0:	b5 95       	asr	r27
     7f2:	a7 95       	ror	r26
     7f4:	97 95       	ror	r25
     7f6:	87 95       	ror	r24
     7f8:	b5 95       	asr	r27
     7fa:	a7 95       	ror	r26
     7fc:	97 95       	ror	r25
     7fe:	87 95       	ror	r24
     800:	80 93 84 31 	sts	0x3184, r24	; 0x803184 <thPendulum>
     804:	90 93 85 31 	sts	0x3185, r25	; 0x803185 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     808:	0f 90       	pop	r0
     80a:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     80c:	f8 01       	movw	r30, r16
     80e:	86 85       	ldd	r24, Z+14	; 0x0e
     810:	97 85       	ldd	r25, Z+15	; 0x0f
     812:	a0 89       	ldd	r26, Z+16	; 0x10
     814:	b1 89       	ldd	r27, Z+17	; 0x11
     816:	01 96       	adiw	r24, 0x01	; 1
     818:	a1 1d       	adc	r26, r1
     81a:	b1 1d       	adc	r27, r1
     81c:	86 87       	std	Z+14, r24	; 0x0e
     81e:	97 87       	std	Z+15, r25	; 0x0f
     820:	a0 8b       	std	Z+16, r26	; 0x10
     822:	b1 8b       	std	Z+17, r27	; 0x11
     824:	43 e0       	ldi	r20, 0x03	; 3
     826:	50 e0       	ldi	r21, 0x00	; 0
     828:	60 e0       	ldi	r22, 0x00	; 0
     82a:	70 e0       	ldi	r23, 0x00	; 0
     82c:	ce 01       	movw	r24, r28
     82e:	01 96       	adiw	r24, 0x01	; 1
     830:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskDelayUntil>
     834:	c8 cf       	rjmp	.-112    	; 0x7c6 <_ZN20task_EncoderPendulum3runEv+0x50>

00000836 <_ZN20task_EncoderPendulumC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_EncoderPendulum::task_EncoderPendulum(const char* a_name,
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     840:	0e 94 a7 14 	call	0x294e	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream>
     844:	8a e1       	ldi	r24, 0x1A	; 26
     846:	90 e2       	ldi	r25, 0x20	; 32
     848:	88 83       	st	Y, r24
     84a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	08 95       	ret

00000856 <_ZN18task_LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void task_LimitSwitches::run(void){
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	00 d0       	rcall	.+0      	; 0x85c <_ZN18task_LimitSwitches3runEv+0x6>
     85c:	1f 92       	push	r1
     85e:	cd b7       	in	r28, 0x3d	; 61
     860:	de b7       	in	r29, 0x3e	; 62
     862:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     864:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <xTaskGetTickCount>
     868:	69 83       	std	Y+1, r22	; 0x01
     86a:	7a 83       	std	Y+2, r23	; 0x02
     86c:	8b 83       	std	Y+3, r24	; 0x03
     86e:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     870:	e0 e6       	ldi	r30, 0x60	; 96
     872:	f6 e0       	ldi	r31, 0x06	; 6
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     878:	84 e0       	ldi	r24, 0x04	; 4
     87a:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     87c:	88 e1       	ldi	r24, 0x18	; 24
     87e:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     880:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     882:	08 e6       	ldi	r16, 0x68	; 104
     884:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     886:	dd 24       	eor	r13, r13
     888:	d3 94       	inc	r13
     88a:	f8 01       	movw	r30, r16
     88c:	80 81       	ld	r24, Z
     88e:	80 fd       	sbrc	r24, 0
     890:	08 c0       	rjmp	.+16     	; 0x8a2 <_ZN18task_LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	f8 94       	cli
     896:	0f 92       	push	r0
			the_data = new_data;
     898:	d0 92 83 31 	sts	0x3183, r13	; 0x803183 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     89c:	0f 90       	pop	r0
     89e:	0f be       	out	0x3f, r0	; 63
     8a0:	07 c0       	rjmp	.+14     	; 0x8b0 <_ZN18task_LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	f8 94       	cli
     8a6:	0f 92       	push	r0
			the_data = new_data;
     8a8:	10 92 83 31 	sts	0x3183, r1	; 0x803183 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     8ac:	0f 90       	pop	r0
     8ae:	0f be       	out	0x3f, r0	; 63
			*/

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     8b0:	f8 01       	movw	r30, r16
     8b2:	80 81       	ld	r24, Z
     8b4:	82 fd       	sbrc	r24, 2
     8b6:	08 c0       	rjmp	.+16     	; 0x8c8 <_ZN18task_LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8b8:	0f b6       	in	r0, 0x3f	; 63
     8ba:	f8 94       	cli
     8bc:	0f 92       	push	r0
			the_data = new_data;
     8be:	d0 92 82 31 	sts	0x3182, r13	; 0x803182 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     8c2:	0f 90       	pop	r0
     8c4:	0f be       	out	0x3f, r0	; 63
     8c6:	07 c0       	rjmp	.+14     	; 0x8d6 <_ZN18task_LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	f8 94       	cli
     8cc:	0f 92       	push	r0
			the_data = new_data;
     8ce:	10 92 82 31 	sts	0x3182, r1	; 0x803182 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     8d2:	0f 90       	pop	r0
     8d4:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     8d6:	f7 01       	movw	r30, r14
     8d8:	86 85       	ldd	r24, Z+14	; 0x0e
     8da:	97 85       	ldd	r25, Z+15	; 0x0f
     8dc:	a0 89       	ldd	r26, Z+16	; 0x10
     8de:	b1 89       	ldd	r27, Z+17	; 0x11
     8e0:	01 96       	adiw	r24, 0x01	; 1
     8e2:	a1 1d       	adc	r26, r1
     8e4:	b1 1d       	adc	r27, r1
     8e6:	86 87       	std	Z+14, r24	; 0x0e
     8e8:	97 87       	std	Z+15, r25	; 0x0f
     8ea:	a0 8b       	std	Z+16, r26	; 0x10
     8ec:	b1 8b       	std	Z+17, r27	; 0x11
     8ee:	43 e0       	ldi	r20, 0x03	; 3
     8f0:	50 e0       	ldi	r21, 0x00	; 0
     8f2:	60 e0       	ldi	r22, 0x00	; 0
     8f4:	70 e0       	ldi	r23, 0x00	; 0
     8f6:	ce 01       	movw	r24, r28
     8f8:	01 96       	adiw	r24, 0x01	; 1
     8fa:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskDelayUntil>
     8fe:	c5 cf       	rjmp	.-118    	; 0x88a <_ZN18task_LimitSwitches3runEv+0x34>

00000900 <_ZN18task_LimitSwitchesC1EPKchjP8emstream>:
#include "task_LimitSwitches.h"				// Header for Limit Switches
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

task_LimitSwitches::task_LimitSwitches(const char* a_name,
     900:	0f 93       	push	r16
     902:	1f 93       	push	r17
     904:	cf 93       	push	r28
     906:	df 93       	push	r29
     908:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     90a:	0e 94 a7 14 	call	0x294e	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream>
     90e:	82 e2       	ldi	r24, 0x22	; 34
     910:	90 e2       	ldi	r25, 0x20	; 32
     912:	88 83       	st	Y, r24
     914:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	08 95       	ret

00000920 <_ZN10task_Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void task_Motor::run(void){
     920:	cf 93       	push	r28
     922:	df 93       	push	r29
     924:	cd b7       	in	r28, 0x3d	; 61
     926:	de b7       	in	r29, 0x3e	; 62
     928:	66 97       	sbiw	r28, 0x16	; 22
     92a:	cd bf       	out	0x3d, r28	; 61
     92c:	de bf       	out	0x3e, r29	; 62
     92e:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     930:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <xTaskGetTickCount>
     934:	69 83       	std	Y+1, r22	; 0x01
     936:	7a 83       	std	Y+2, r23	; 0x02
     938:	8b 83       	std	Y+3, r24	; 0x03
     93a:	9c 83       	std	Y+4, r25	; 0x04

	dt = 5; // [ms]
     93c:	f8 01       	movw	r30, r16
     93e:	fe 96       	adiw	r30, 0x3e	; 62
     940:	85 e0       	ldi	r24, 0x05	; 5
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	a0 e0       	ldi	r26, 0x00	; 0
     946:	b0 e0       	ldi	r27, 0x00	; 0
     948:	80 83       	st	Z, r24
     94a:	91 83       	std	Z+1, r25	; 0x01
     94c:	a2 83       	std	Z+2, r26	; 0x02
     94e:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     950:	81 e0       	ldi	r24, 0x01	; 1
     952:	90 e0       	ldi	r25, 0x00	; 0
     954:	f8 01       	movw	r30, r16
     956:	84 af       	std	Z+60, r24	; 0x3c
     958:	95 af       	std	Z+61, r25	; 0x3d
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 7;
     95a:	18 01       	movw	r2, r16
     95c:	f8 e4       	ldi	r31, 0x48	; 72
     95e:	2f 0e       	add	r2, r31
     960:	31 1c       	adc	r3, r1
     962:	27 e0       	ldi	r18, 0x07	; 7
     964:	2d 8b       	std	Y+21, r18	; 0x15
     966:	1e 8a       	std	Y+22, r1	; 0x16
		_Ki = .7*256;
     968:	a8 01       	movw	r20, r16
     96a:	44 5b       	subi	r20, 0xB4	; 180
     96c:	5f 4f       	sbci	r21, 0xFF	; 255
     96e:	49 87       	std	Y+9, r20	; 0x09
     970:	5a 87       	std	Y+10, r21	; 0x0a
		_Kd = 0;
     972:	c8 01       	movw	r24, r16
     974:	86 5b       	subi	r24, 0xB6	; 182
     976:	9f 4f       	sbci	r25, 0xFF	; 255
     978:	8f 87       	std	Y+15, r24	; 0x0f
     97a:	98 8b       	std	Y+16, r25	; 0x10
		antiwind_gain = .95*256;
     97c:	f8 01       	movw	r30, r16
     97e:	ec 59       	subi	r30, 0x9C	; 156
     980:	ff 4f       	sbci	r31, 0xFF	; 255
     982:	eb 87       	std	Y+11, r30	; 0x0b
     984:	fc 87       	std	Y+12, r31	; 0x0c
		
		_max = 1600;
     986:	38 01       	movw	r6, r16
     988:	f4 e4       	ldi	r31, 0x44	; 68
     98a:	6f 0e       	add	r6, r31
     98c:	71 1c       	adc	r7, r1
		_min = -1600;
     98e:	98 01       	movw	r18, r16
     990:	2a 5b       	subi	r18, 0xBA	; 186
     992:	3f 4f       	sbci	r19, 0xFF	; 255
     994:	2d 87       	std	Y+13, r18	; 0x0d
     996:	3e 87       	std	Y+14, r19	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     998:	40 5f       	subi	r20, 0xF0	; 240
     99a:	5f 4f       	sbci	r21, 0xFF	; 255
     99c:	49 8b       	std	Y+17, r20	; 0x11
     99e:	5a 8b       	std	Y+18, r21	; 0x12

		// Integral term
		error_int = error - antiwind_correct;
     9a0:	28 01       	movw	r4, r16
     9a2:	56 e6       	ldi	r21, 0x66	; 102
     9a4:	45 0e       	add	r4, r21
     9a6:	51 1c       	adc	r5, r1
     9a8:	4e 96       	adiw	r24, 0x1e	; 30
     9aa:	8b 8b       	std	Y+19, r24	; 0x13
     9ac:	9c 8b       	std	Y+20, r25	; 0x14
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     9ae:	48 01       	movw	r8, r16
     9b0:	9e e3       	ldi	r25, 0x3E	; 62
     9b2:	89 0e       	add	r8, r25
     9b4:	91 1c       	adc	r9, r1
     9b6:	58 01       	movw	r10, r16
     9b8:	e0 e5       	ldi	r30, 0x50	; 80
     9ba:	ae 0e       	add	r10, r30
     9bc:	b1 1c       	adc	r11, r1

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);

		output_correct = output;
     9be:	68 01       	movw	r12, r16
     9c0:	fe e5       	ldi	r31, 0x5E	; 94
     9c2:	cf 0e       	add	r12, r31
     9c4:	d1 1c       	adc	r13, r1
	dt = 5; // [ms]
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     9c6:	f8 01       	movw	r30, r16
     9c8:	86 85       	ldd	r24, Z+14	; 0x0e
     9ca:	97 85       	ldd	r25, Z+15	; 0x0f
     9cc:	a0 89       	ldd	r26, Z+16	; 0x10
     9ce:	b1 89       	ldd	r27, Z+17	; 0x11
     9d0:	01 96       	adiw	r24, 0x01	; 1
     9d2:	a1 1d       	adc	r26, r1
     9d4:	b1 1d       	adc	r27, r1
     9d6:	86 87       	std	Z+14, r24	; 0x0e
     9d8:	97 87       	std	Z+15, r25	; 0x0f
     9da:	a0 8b       	std	Z+16, r26	; 0x10
     9dc:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
		omegam_set = 100; // [ticks/ms]
     9de:	24 e6       	ldi	r18, 0x64	; 100
     9e0:	30 e0       	ldi	r19, 0x00	; 0
     9e2:	22 8f       	std	Z+26, r18	; 0x1a
     9e4:	33 8f       	std	Z+27, r19	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     9e6:	0f b6       	in	r0, 0x3f	; 63
     9e8:	f8 94       	cli
     9ea:	0f 92       	push	r0
			temporary_copy = the_data;
     9ec:	80 91 86 31 	lds	r24, 0x3186	; 0x803186 <thdMotor>
     9f0:	90 91 87 31 	lds	r25, 0x3187	; 0x803187 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     9f4:	0f 90       	pop	r0
     9f6:	0f be       	out	0x3f, r0	; 63

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     9f8:	86 8f       	std	Z+30, r24	; 0x1e
     9fa:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 7;
     9fc:	4d 89       	ldd	r20, Y+21	; 0x15
     9fe:	f1 01       	movw	r30, r2
     a00:	40 83       	st	Z, r20
     a02:	5e 89       	ldd	r21, Y+22	; 0x16
     a04:	51 83       	std	Z+1, r21	; 0x01
		_Ki = .7*256;
     a06:	43 eb       	ldi	r20, 0xB3	; 179
     a08:	50 e0       	ldi	r21, 0x00	; 0
     a0a:	e9 85       	ldd	r30, Y+9	; 0x09
     a0c:	fa 85       	ldd	r31, Y+10	; 0x0a
     a0e:	40 83       	st	Z, r20
     a10:	51 83       	std	Z+1, r21	; 0x01
		_Kd = 0;
     a12:	ef 85       	ldd	r30, Y+15	; 0x0f
     a14:	f8 89       	ldd	r31, Y+16	; 0x10
     a16:	10 82       	st	Z, r1
     a18:	11 82       	std	Z+1, r1	; 0x01
		antiwind_gain = .95*256;
     a1a:	43 ef       	ldi	r20, 0xF3	; 243
     a1c:	50 e0       	ldi	r21, 0x00	; 0
     a1e:	eb 85       	ldd	r30, Y+11	; 0x0b
     a20:	fc 85       	ldd	r31, Y+12	; 0x0c
     a22:	40 83       	st	Z, r20
     a24:	51 83       	std	Z+1, r21	; 0x01
		
		_max = 1600;
     a26:	40 e4       	ldi	r20, 0x40	; 64
     a28:	56 e0       	ldi	r21, 0x06	; 6
     a2a:	f3 01       	movw	r30, r6
     a2c:	40 83       	st	Z, r20
     a2e:	51 83       	std	Z+1, r21	; 0x01
		_min = -1600;
     a30:	40 ec       	ldi	r20, 0xC0	; 192
     a32:	59 ef       	ldi	r21, 0xF9	; 249
     a34:	ed 85       	ldd	r30, Y+13	; 0x0d
     a36:	fe 85       	ldd	r31, Y+14	; 0x0e
     a38:	40 83       	st	Z, r20
     a3a:	51 83       	std	Z+1, r21	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     a3c:	79 01       	movw	r14, r18
     a3e:	e8 1a       	sub	r14, r24
     a40:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     a42:	b7 01       	movw	r22, r14
     a44:	87 e0       	ldi	r24, 0x07	; 7
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	0e 94 01 03 	call	0x602	; 0x602 <_ZN7satmath20signed_saturated_mulEii>
     a4c:	6d 83       	std	Y+5, r22	; 0x05
     a4e:	7e 83       	std	Y+6, r23	; 0x06
     a50:	8f 83       	std	Y+7, r24	; 0x07
     a52:	98 87       	std	Y+8, r25	; 0x08
     a54:	2d 81       	ldd	r18, Y+5	; 0x05
     a56:	3e 81       	ldd	r19, Y+6	; 0x06
     a58:	e9 89       	ldd	r30, Y+17	; 0x11
     a5a:	fa 89       	ldd	r31, Y+18	; 0x12
     a5c:	20 83       	st	Z, r18
     a5e:	31 83       	std	Z+1, r19	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     a60:	f2 01       	movw	r30, r4
     a62:	80 81       	ld	r24, Z
     a64:	91 81       	ldd	r25, Z+1	; 0x01
     a66:	97 01       	movw	r18, r14
     a68:	28 1b       	sub	r18, r24
     a6a:	39 0b       	sbc	r19, r25
     a6c:	c9 01       	movw	r24, r18
     a6e:	eb 89       	ldd	r30, Y+19	; 0x13
     a70:	fc 89       	ldd	r31, Y+20	; 0x14
     a72:	20 83       	st	Z, r18
     a74:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     a76:	e9 85       	ldd	r30, Y+9	; 0x09
     a78:	fa 85       	ldd	r31, Y+10	; 0x0a
     a7a:	20 81       	ld	r18, Z
     a7c:	31 81       	ldd	r19, Z+1	; 0x01
     a7e:	82 9f       	mul	r24, r18
     a80:	d0 01       	movw	r26, r0
     a82:	83 9f       	mul	r24, r19
     a84:	b0 0d       	add	r27, r0
     a86:	92 9f       	mul	r25, r18
     a88:	b0 0d       	add	r27, r0
     a8a:	11 24       	eor	r1, r1
     a8c:	f8 01       	movw	r30, r16
     a8e:	e6 59       	subi	r30, 0x96	; 150
     a90:	ff 4f       	sbci	r31, 0xFF	; 255
     a92:	a0 83       	st	Z, r26
     a94:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     a96:	f4 01       	movw	r30, r8
     a98:	20 81       	ld	r18, Z
     a9a:	31 81       	ldd	r19, Z+1	; 0x01
     a9c:	42 81       	ldd	r20, Z+2	; 0x02
     a9e:	53 81       	ldd	r21, Z+3	; 0x03
     aa0:	0e 94 06 20 	call	0x400c	; 0x400c <__mulshisi3>
     aa4:	9b 01       	movw	r18, r22
     aa6:	ac 01       	movw	r20, r24
     aa8:	99 23       	and	r25, r25
     aaa:	24 f4       	brge	.+8      	; 0xab4 <_ZN10task_Motor3runEv+0x194>
     aac:	21 50       	subi	r18, 0x01	; 1
     aae:	3f 4f       	sbci	r19, 0xFF	; 255
     ab0:	4f 4f       	sbci	r20, 0xFF	; 255
     ab2:	5f 4f       	sbci	r21, 0xFF	; 255
     ab4:	bb 27       	eor	r27, r27
     ab6:	57 fd       	sbrc	r21, 7
     ab8:	ba 95       	dec	r27
     aba:	a5 2f       	mov	r26, r21
     abc:	94 2f       	mov	r25, r20
     abe:	83 2f       	mov	r24, r19
     ac0:	f5 01       	movw	r30, r10
     ac2:	40 81       	ld	r20, Z
     ac4:	51 81       	ldd	r21, Z+1	; 0x01
     ac6:	62 81       	ldd	r22, Z+2	; 0x02
     ac8:	73 81       	ldd	r23, Z+3	; 0x03
     aca:	84 0f       	add	r24, r20
     acc:	95 1f       	adc	r25, r21
     ace:	a6 1f       	adc	r26, r22
     ad0:	b7 1f       	adc	r27, r23
		if(_integral < 1000000000)
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
     ad2:	81 30       	cpi	r24, 0x01	; 1
     ad4:	fa ec       	ldi	r31, 0xCA	; 202
     ad6:	9f 07       	cpc	r25, r31
     ad8:	fa e9       	ldi	r31, 0x9A	; 154
     ada:	af 07       	cpc	r26, r31
     adc:	fb e3       	ldi	r31, 0x3B	; 59
     ade:	bf 07       	cpc	r27, r31
     ae0:	34 f4       	brge	.+12     	; 0xaee <_ZN10task_Motor3runEv+0x1ce>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     ae2:	f5 01       	movw	r30, r10
     ae4:	80 83       	st	Z, r24
     ae6:	91 83       	std	Z+1, r25	; 0x01
     ae8:	a2 83       	std	Z+2, r26	; 0x02
     aea:	b3 83       	std	Z+3, r27	; 0x03
     aec:	09 c0       	rjmp	.+18     	; 0xb00 <_ZN10task_Motor3runEv+0x1e0>
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
		{
			_integral = 1000000000;
     aee:	80 e0       	ldi	r24, 0x00	; 0
     af0:	9a ec       	ldi	r25, 0xCA	; 202
     af2:	aa e9       	ldi	r26, 0x9A	; 154
     af4:	bb e3       	ldi	r27, 0x3B	; 59
     af6:	f5 01       	movw	r30, r10
     af8:	80 83       	st	Z, r24
     afa:	91 83       	std	Z+1, r25	; 0x01
     afc:	a2 83       	std	Z+2, r26	; 0x02
     afe:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     b00:	f5 01       	movw	r30, r10
     b02:	60 81       	ld	r22, Z
     b04:	71 81       	ldd	r23, Z+1	; 0x01
     b06:	8d 81       	ldd	r24, Y+5	; 0x05
     b08:	9e 81       	ldd	r25, Y+6	; 0x06
     b0a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <_ZN7satmath20signed_saturated_addEii>
     b0e:	f8 01       	movw	r30, r16
     b10:	e0 5a       	subi	r30, 0xA0	; 160
     b12:	ff 4f       	sbci	r31, 0xFF	; 255
     b14:	80 83       	st	Z, r24
     b16:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     b18:	f6 01       	movw	r30, r12
     b1a:	80 83       	st	Z, r24
     b1c:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     b1e:	f3 01       	movw	r30, r6
     b20:	20 81       	ld	r18, Z
     b22:	31 81       	ldd	r19, Z+1	; 0x01
     b24:	28 17       	cp	r18, r24
     b26:	39 07       	cpc	r19, r25
     b28:	24 f4       	brge	.+8      	; 0xb32 <_ZN10task_Motor3runEv+0x212>
		output_correct = _max;
     b2a:	f6 01       	movw	r30, r12
     b2c:	20 83       	st	Z, r18
     b2e:	31 83       	std	Z+1, r19	; 0x01
     b30:	0a c0       	rjmp	.+20     	; 0xb46 <_ZN10task_Motor3runEv+0x226>
		else if( output_correct < _min )
     b32:	ed 85       	ldd	r30, Y+13	; 0x0d
     b34:	fe 85       	ldd	r31, Y+14	; 0x0e
     b36:	20 81       	ld	r18, Z
     b38:	31 81       	ldd	r19, Z+1	; 0x01
     b3a:	82 17       	cp	r24, r18
     b3c:	93 07       	cpc	r25, r19
     b3e:	1c f4       	brge	.+6      	; 0xb46 <_ZN10task_Motor3runEv+0x226>
		output_correct = _min;
     b40:	f6 01       	movw	r30, r12
     b42:	20 83       	st	Z, r18
     b44:	31 83       	std	Z+1, r19	; 0x01

		// Save error to previous error
		_pre_error = error;
     b46:	f8 01       	movw	r30, r16
     b48:	e2 5b       	subi	r30, 0xB2	; 178
     b4a:	ff 4f       	sbci	r31, 0xFF	; 255
     b4c:	e0 82       	st	Z, r14
     b4e:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     b50:	f6 01       	movw	r30, r12
     b52:	e0 80       	ld	r14, Z
     b54:	f1 80       	ldd	r15, Z+1	; 0x01
     b56:	8e 19       	sub	r24, r14
     b58:	9f 09       	sbc	r25, r15
     b5a:	f8 01       	movw	r30, r16
     b5c:	ee 59       	subi	r30, 0x9E	; 158
     b5e:	ff 4f       	sbci	r31, 0xFF	; 255
     b60:	80 83       	st	Z, r24
     b62:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     b64:	eb 85       	ldd	r30, Y+11	; 0x0b
     b66:	fc 85       	ldd	r31, Y+12	; 0x0c
     b68:	40 81       	ld	r20, Z
     b6a:	51 81       	ldd	r21, Z+1	; 0x01
     b6c:	84 9f       	mul	r24, r20
     b6e:	90 01       	movw	r18, r0
     b70:	85 9f       	mul	r24, r21
     b72:	30 0d       	add	r19, r0
     b74:	94 9f       	mul	r25, r20
     b76:	30 0d       	add	r19, r0
     b78:	11 24       	eor	r1, r1
     b7a:	33 23       	and	r19, r19
     b7c:	14 f4       	brge	.+4      	; 0xb82 <_ZN10task_Motor3runEv+0x262>
     b7e:	21 50       	subi	r18, 0x01	; 1
     b80:	3f 4f       	sbci	r19, 0xFF	; 255
     b82:	83 2f       	mov	r24, r19
     b84:	88 0f       	add	r24, r24
     b86:	88 0b       	sbc	r24, r24
     b88:	f2 01       	movw	r30, r4
     b8a:	30 83       	st	Z, r19
     b8c:	81 83       	std	Z+1, r24	; 0x01
		
		
			if(runs%5==0){
     b8e:	f8 01       	movw	r30, r16
     b90:	66 85       	ldd	r22, Z+14	; 0x0e
     b92:	77 85       	ldd	r23, Z+15	; 0x0f
     b94:	80 89       	ldd	r24, Z+16	; 0x10
     b96:	91 89       	ldd	r25, Z+17	; 0x11
     b98:	25 e0       	ldi	r18, 0x05	; 5
     b9a:	30 e0       	ldi	r19, 0x00	; 0
     b9c:	40 e0       	ldi	r20, 0x00	; 0
     b9e:	50 e0       	ldi	r21, 0x00	; 0
     ba0:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__udivmodsi4>
     ba4:	67 2b       	or	r22, r23
     ba6:	68 2b       	or	r22, r24
     ba8:	69 2b       	or	r22, r25
     baa:	99 f4       	brne	.+38     	; 0xbd2 <_ZN10task_Motor3runEv+0x2b2>
				//*p_serial << "Ierror: " << Iout << endl;
				//*p_serial << "Pout: " << Pout << endl;
				//*p_serial << "error: " << error << endl;
				//*p_serial << "Integral: " << _integral << endl;
				//*p_serial << "Measured: " << omegam_measured << endl;
				*p_serial << "PWM Signal: " << output_correct << endl;
     bac:	f8 01       	movw	r30, r16
     bae:	06 80       	ldd	r0, Z+6	; 0x06
     bb0:	f7 81       	ldd	r31, Z+7	; 0x07
     bb2:	e0 2d       	mov	r30, r0
     bb4:	ed 83       	std	Y+5, r30	; 0x05
     bb6:	fe 83       	std	Y+6, r31	; 0x06
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     bb8:	66 e2       	ldi	r22, 0x26	; 38
     bba:	70 e2       	ldi	r23, 0x20	; 32
     bbc:	cf 01       	movw	r24, r30
     bbe:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     bc2:	b7 01       	movw	r22, r14
     bc4:	8d 81       	ldd	r24, Y+5	; 0x05
     bc6:	9e 81       	ldd	r25, Y+6	; 0x06
     bc8:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <_ZN8emstreamlsEi>
     bcc:	66 e0       	ldi	r22, 0x06	; 6
     bce:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bd2:	0f b6       	in	r0, 0x3f	; 63
     bd4:	f8 94       	cli
     bd6:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
				//*p_serial << omegam_measured << endl;
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     bdc:	80 91 83 31 	lds	r24, 0x3183	; 0x803183 <leftLimitSwitch>
     be0:	81 11       	cpse	r24, r1
     be2:	09 c0       	rjmp	.+18     	; 0xbf6 <_ZN10task_Motor3runEv+0x2d6>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     be4:	0f b6       	in	r0, 0x3f	; 63
     be6:	f8 94       	cli
     be8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bea:	0f 90       	pop	r0
     bec:	0f be       	out	0x3f, r0	; 63
     bee:	80 91 82 31 	lds	r24, 0x3182	; 0x803182 <rightLimitSwitch>
     bf2:	88 23       	and	r24, r24
     bf4:	59 f0       	breq	.+22     	; 0xc0c <_ZN10task_Motor3runEv+0x2ec>
		{
			omegam_set = 0; // [ticks/ms]
     bf6:	f8 01       	movw	r30, r16
     bf8:	12 8e       	std	Z+26, r1	; 0x1a
     bfa:	13 8e       	std	Z+27, r1	; 0x1b
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     bfc:	f5 01       	movw	r30, r10
     bfe:	10 82       	st	Z, r1
     c00:	11 82       	std	Z+1, r1	; 0x01
     c02:	12 82       	std	Z+2, r1	; 0x02
     c04:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;
     c06:	f6 01       	movw	r30, r12
     c08:	10 82       	st	Z, r1
     c0a:	11 82       	std	Z+1, r1	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     c0c:	0f b6       	in	r0, 0x3f	; 63
     c0e:	f8 94       	cli
     c10:	0f 92       	push	r0
			the_data = new_data;
     c12:	f6 01       	movw	r30, r12
     c14:	80 81       	ld	r24, Z
     c16:	91 81       	ldd	r25, Z+1	; 0x01
     c18:	80 93 80 31 	sts	0x3180, r24	; 0x803180 <PWMvalue>
     c1c:	90 93 81 31 	sts	0x3181, r25	; 0x803181 <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     c20:	0f 90       	pop	r0
     c22:	0f be       	out	0x3f, r0	; 63
			}
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     c24:	f8 01       	movw	r30, r16
     c26:	10 a6       	std	Z+40, r1	; 0x28
     c28:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     c2a:	82 a1       	ldd	r24, Z+34	; 0x22
     c2c:	93 a1       	ldd	r25, Z+35	; 0x23
     c2e:	60 e0       	ldi	r22, 0x00	; 0
     c30:	70 e0       	ldi	r23, 0x00	; 0
     c32:	0e 94 7f 1f 	call	0x3efe	; 0x3efe <__divmodhi4>
     c36:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     c38:	07 2e       	mov	r0, r23
     c3a:	00 0c       	add	r0, r0
     c3c:	88 0b       	sbc	r24, r24
     c3e:	99 0b       	sbc	r25, r25
     c40:	0e 94 0b 1f 	call	0x3e16	; 0x3e16 <__floatsisf>
     c44:	6d 83       	std	Y+5, r22	; 0x05
     c46:	7e 83       	std	Y+6, r23	; 0x06
     c48:	8f 83       	std	Y+7, r24	; 0x07
     c4a:	98 87       	std	Y+8, r25	; 0x08
     c4c:	23 e3       	ldi	r18, 0x33	; 51
     c4e:	33 e3       	ldi	r19, 0x33	; 51
     c50:	4b e8       	ldi	r20, 0x8B	; 139
     c52:	51 e4       	ldi	r21, 0x41	; 65
     c54:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <__gesf2>
     c58:	18 16       	cp	r1, r24
     c5a:	34 f4       	brge	.+12     	; 0xc68 <_ZN10task_Motor3runEv+0x348>
			Im_set = 17.4;
     c5c:	81 e1       	ldi	r24, 0x11	; 17
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	f8 01       	movw	r30, r16
     c62:	84 a3       	std	Z+36, r24	; 0x24
     c64:	95 a3       	std	Z+37, r25	; 0x25
     c66:	15 c0       	rjmp	.+42     	; 0xc92 <_ZN10task_Motor3runEv+0x372>
		} else if(Im_set < -17.4) {
     c68:	23 e3       	ldi	r18, 0x33	; 51
     c6a:	33 e3       	ldi	r19, 0x33	; 51
     c6c:	4b e8       	ldi	r20, 0x8B	; 139
     c6e:	51 ec       	ldi	r21, 0xC1	; 193
     c70:	6d 81       	ldd	r22, Y+5	; 0x05
     c72:	7e 81       	ldd	r23, Y+6	; 0x06
     c74:	8f 81       	ldd	r24, Y+7	; 0x07
     c76:	98 85       	ldd	r25, Y+8	; 0x08
     c78:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <__cmpsf2>
     c7c:	88 23       	and	r24, r24
     c7e:	24 f0       	brlt	.+8      	; 0xc88 <_ZN10task_Motor3runEv+0x368>
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     c80:	f8 01       	movw	r30, r16
     c82:	e4 a2       	std	Z+36, r14	; 0x24
     c84:	f5 a2       	std	Z+37, r15	; 0x25
     c86:	05 c0       	rjmp	.+10     	; 0xc92 <_ZN10task_Motor3runEv+0x372>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     c88:	8f ee       	ldi	r24, 0xEF	; 239
     c8a:	9f ef       	ldi	r25, 0xFF	; 255
     c8c:	f8 01       	movw	r30, r16
     c8e:	84 a3       	std	Z+36, r24	; 0x24
     c90:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     c92:	f8 01       	movw	r30, r16
     c94:	16 aa       	std	Z+54, r1	; 0x36
     c96:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     c98:	12 aa       	std	Z+50, r1	; 0x32
     c9a:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     c9c:	14 aa       	std	Z+52, r1	; 0x34
     c9e:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
     ca0:	80 a9       	ldd	r24, Z+48	; 0x30
     ca2:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
     ca4:	89 31       	cpi	r24, 0x19	; 25
     ca6:	91 05       	cpc	r25, r1
     ca8:	2c f0       	brlt	.+10     	; 0xcb4 <_ZN10task_Motor3runEv+0x394>
			V_m = 24;
     caa:	88 e1       	ldi	r24, 0x18	; 24
     cac:	90 e0       	ldi	r25, 0x00	; 0
     cae:	80 af       	std	Z+56, r24	; 0x38
     cb0:	91 af       	std	Z+57, r25	; 0x39
     cb2:	0d c0       	rjmp	.+26     	; 0xcce <_ZN10task_Motor3runEv+0x3ae>
		} else if(V_m < -24) {
     cb4:	88 3e       	cpi	r24, 0xE8	; 232
     cb6:	ff ef       	ldi	r31, 0xFF	; 255
     cb8:	9f 07       	cpc	r25, r31
     cba:	24 f0       	brlt	.+8      	; 0xcc4 <_ZN10task_Motor3runEv+0x3a4>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     cbc:	f8 01       	movw	r30, r16
     cbe:	80 af       	std	Z+56, r24	; 0x38
     cc0:	91 af       	std	Z+57, r25	; 0x39
     cc2:	05 c0       	rjmp	.+10     	; 0xcce <_ZN10task_Motor3runEv+0x3ae>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     cc4:	88 ee       	ldi	r24, 0xE8	; 232
     cc6:	9f ef       	ldi	r25, 0xFF	; 255
     cc8:	f8 01       	movw	r30, r16
     cca:	80 af       	std	Z+56, r24	; 0x38
     ccc:	91 af       	std	Z+57, r25	; 0x39

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
     cce:	f4 01       	movw	r30, r8
     cd0:	20 81       	ld	r18, Z
     cd2:	31 81       	ldd	r19, Z+1	; 0x01
     cd4:	42 81       	ldd	r20, Z+2	; 0x02
     cd6:	53 81       	ldd	r21, Z+3	; 0x03
     cd8:	a8 ee       	ldi	r26, 0xE8	; 232
     cda:	b3 e0       	ldi	r27, 0x03	; 3
     cdc:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <__muluhisi3>
     ce0:	68 3e       	cpi	r22, 0xE8	; 232
     ce2:	f3 e0       	ldi	r31, 0x03	; 3
     ce4:	7f 07       	cpc	r23, r31
     ce6:	81 05       	cpc	r24, r1
     ce8:	91 05       	cpc	r25, r1
     cea:	48 f0       	brcs	.+18     	; 0xcfe <_ZN10task_Motor3runEv+0x3de>
     cec:	28 ee       	ldi	r18, 0xE8	; 232
     cee:	33 e0       	ldi	r19, 0x03	; 3
     cf0:	40 e0       	ldi	r20, 0x00	; 0
     cf2:	50 e0       	ldi	r21, 0x00	; 0
     cf4:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__udivmodsi4>
     cf8:	ba 01       	movw	r22, r20
     cfa:	a9 01       	movw	r20, r18
     cfc:	04 c0       	rjmp	.+8      	; 0xd06 <_ZN10task_Motor3runEv+0x3e6>
     cfe:	41 e0       	ldi	r20, 0x01	; 1
     d00:	50 e0       	ldi	r21, 0x00	; 0
     d02:	60 e0       	ldi	r22, 0x00	; 0
     d04:	70 e0       	ldi	r23, 0x00	; 0
     d06:	ce 01       	movw	r24, r28
     d08:	01 96       	adiw	r24, 0x01	; 1
     d0a:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskDelayUntil>
     d0e:	5b ce       	rjmp	.-842    	; 0x9c6 <_ZN10task_Motor3runEv+0xa6>

00000d10 <_ZN10task_MotorC1EPKchjP8emstream>:
#include "task_LimitSwitches.h"				// Header for Limit Switches
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

task_Motor::task_Motor(const char* a_name,
     d10:	0f 93       	push	r16
     d12:	1f 93       	push	r17
     d14:	cf 93       	push	r28
     d16:	df 93       	push	r29
     d18:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d1a:	0e 94 a7 14 	call	0x294e	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream>
     d1e:	87 e3       	ldi	r24, 0x37	; 55
     d20:	90 e2       	ldi	r25, 0x20	; 32
     d22:	88 83       	st	Y, r24
     d24:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     d26:	df 91       	pop	r29
     d28:	cf 91       	pop	r28
     d2a:	1f 91       	pop	r17
     d2c:	0f 91       	pop	r16
     d2e:	08 95       	ret

00000d30 <_ZN13task_Position3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void task_Position::run (void)
{
     d30:	cf 93       	push	r28
     d32:	df 93       	push	r29
     d34:	00 d0       	rcall	.+0      	; 0xd36 <_ZN13task_Position3runEv+0x6>
     d36:	1f 92       	push	r1
     d38:	cd b7       	in	r28, 0x3d	; 61
     d3a:	de b7       	in	r29, 0x3e	; 62
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     d3c:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <xTaskGetTickCount>
     d40:	69 83       	std	Y+1, r22	; 0x01
     d42:	7a 83       	std	Y+2, r23	; 0x02
     d44:	8b 83       	std	Y+3, r24	; 0x03
     d46:	9c 83       	std	Y+4, r25	; 0x04
     d48:	46 e0       	ldi	r20, 0x06	; 6
     d4a:	50 e0       	ldi	r21, 0x00	; 0
     d4c:	60 e0       	ldi	r22, 0x00	; 0
     d4e:	70 e0       	ldi	r23, 0x00	; 0
     d50:	ce 01       	movw	r24, r28
     d52:	01 96       	adiw	r24, 0x01	; 1
     d54:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskDelayUntil>
     d58:	f7 cf       	rjmp	.-18     	; 0xd48 <_ZN13task_Position3runEv+0x18>

00000d5a <_ZN13task_PositionC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_Position::task_Position(const char* a_name,
     d5a:	0f 93       	push	r16
     d5c:	1f 93       	push	r17
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	ec 01       	movw	r28, r24
size_t a_stack_size,
emstream* p_ser_dev
)

// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d64:	0e 94 a7 14 	call	0x294e	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream>
     d68:	8f e3       	ldi	r24, 0x3F	; 63
     d6a:	90 e2       	ldi	r25, 0x20	; 32
     d6c:	88 83       	st	Y, r24
     d6e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     d70:	df 91       	pop	r29
     d72:	cf 91       	pop	r28
     d74:	1f 91       	pop	r17
     d76:	0f 91       	pop	r16
     d78:	08 95       	ret

00000d7a <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     d7a:	0f 93       	push	r16
     d7c:	1f 93       	push	r17
     d7e:	cf 93       	push	r28
     d80:	df 93       	push	r29
     d82:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d84:	0e 94 a7 14 	call	0x294e	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream>
     d88:	87 e4       	ldi	r24, 0x47	; 71
     d8a:	90 e2       	ldi	r25, 0x20	; 32
     d8c:	88 83       	st	Y, r24
     d8e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     d90:	df 91       	pop	r29
     d92:	cf 91       	pop	r28
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	08 95       	ret

00000d9a <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     d9a:	0f 93       	push	r16
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     da4:	6a e0       	ldi	r22, 0x0A	; 10
     da6:	8e 81       	ldd	r24, Y+6	; 0x06
     da8:	9f 81       	ldd	r25, Y+7	; 0x07
     daa:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     dae:	8c 01       	movw	r16, r24
     db0:	65 ef       	ldi	r22, 0xF5	; 245
     db2:	73 e0       	ldi	r23, 0x03	; 3
     db4:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     db8:	6a e0       	ldi	r22, 0x0A	; 10
     dba:	c8 01       	movw	r24, r16
     dbc:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     dc0:	8c 01       	movw	r16, r24
     dc2:	6f ee       	ldi	r22, 0xEF	; 239
     dc4:	73 e0       	ldi	r23, 0x03	; 3
     dc6:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     dca:	67 e0       	ldi	r22, 0x07	; 7
     dcc:	c8 01       	movw	r24, r16
     dce:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     dd2:	6a e0       	ldi	r22, 0x0A	; 10
     dd4:	8e 81       	ldd	r24, Y+6	; 0x06
     dd6:	9f 81       	ldd	r25, Y+7	; 0x07
     dd8:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     ddc:	8c 01       	movw	r16, r24
     dde:	60 ed       	ldi	r22, 0xD0	; 208
     de0:	73 e0       	ldi	r23, 0x03	; 3
     de2:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     de6:	6a e0       	ldi	r22, 0x0A	; 10
     de8:	c8 01       	movw	r24, r16
     dea:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     dee:	8c 01       	movw	r16, r24
     df0:	6a ec       	ldi	r22, 0xCA	; 202
     df2:	73 e0       	ldi	r23, 0x03	; 3
     df4:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     df8:	66 e0       	ldi	r22, 0x06	; 6
     dfa:	c8 01       	movw	r24, r16
     dfc:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e00:	6a e0       	ldi	r22, 0x0A	; 10
     e02:	8e 81       	ldd	r24, Y+6	; 0x06
     e04:	9f 81       	ldd	r25, Y+7	; 0x07
     e06:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     e0a:	8c 01       	movw	r16, r24
     e0c:	63 eb       	ldi	r22, 0xB3	; 179
     e0e:	73 e0       	ldi	r23, 0x03	; 3
     e10:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     e14:	66 e0       	ldi	r22, 0x06	; 6
     e16:	c8 01       	movw	r24, r16
     e18:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e1c:	6a e0       	ldi	r22, 0x0A	; 10
     e1e:	8e 81       	ldd	r24, Y+6	; 0x06
     e20:	9f 81       	ldd	r25, Y+7	; 0x07
     e22:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     e26:	8c 01       	movw	r16, r24
     e28:	67 e9       	ldi	r22, 0x97	; 151
     e2a:	73 e0       	ldi	r23, 0x03	; 3
     e2c:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     e30:	66 e0       	ldi	r22, 0x06	; 6
     e32:	c8 01       	movw	r24, r16
     e34:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e38:	6a e0       	ldi	r22, 0x0A	; 10
     e3a:	8e 81       	ldd	r24, Y+6	; 0x06
     e3c:	9f 81       	ldd	r25, Y+7	; 0x07
     e3e:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     e42:	8c 01       	movw	r16, r24
     e44:	6f e7       	ldi	r22, 0x7F	; 127
     e46:	73 e0       	ldi	r23, 0x03	; 3
     e48:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     e4c:	66 e0       	ldi	r22, 0x06	; 6
     e4e:	c8 01       	movw	r24, r16
     e50:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e54:	6a e0       	ldi	r22, 0x0A	; 10
     e56:	8e 81       	ldd	r24, Y+6	; 0x06
     e58:	9f 81       	ldd	r25, Y+7	; 0x07
     e5a:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     e5e:	8c 01       	movw	r16, r24
     e60:	6e e5       	ldi	r22, 0x5E	; 94
     e62:	73 e0       	ldi	r23, 0x03	; 3
     e64:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     e68:	66 e0       	ldi	r22, 0x06	; 6
     e6a:	c8 01       	movw	r24, r16
     e6c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e70:	6a e0       	ldi	r22, 0x0A	; 10
     e72:	8e 81       	ldd	r24, Y+6	; 0x06
     e74:	9f 81       	ldd	r25, Y+7	; 0x07
     e76:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     e7a:	8c 01       	movw	r16, r24
     e7c:	67 e3       	ldi	r22, 0x37	; 55
     e7e:	73 e0       	ldi	r23, 0x03	; 3
     e80:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     e84:	66 e0       	ldi	r22, 0x06	; 6
     e86:	c8 01       	movw	r24, r16
     e88:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     e8c:	6a e0       	ldi	r22, 0x0A	; 10
     e8e:	8e 81       	ldd	r24, Y+6	; 0x06
     e90:	9f 81       	ldd	r25, Y+7	; 0x07
     e92:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     e96:	8c 01       	movw	r16, r24
     e98:	69 e1       	ldi	r22, 0x19	; 25
     e9a:	73 e0       	ldi	r23, 0x03	; 3
     e9c:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     ea0:	66 e0       	ldi	r22, 0x06	; 6
     ea2:	c8 01       	movw	r24, r16
     ea4:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     ea8:	6a e0       	ldi	r22, 0x0A	; 10
     eaa:	8e 81       	ldd	r24, Y+6	; 0x06
     eac:	9f 81       	ldd	r25, Y+7	; 0x07
     eae:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     eb2:	8c 01       	movw	r16, r24
     eb4:	6e ef       	ldi	r22, 0xFE	; 254
     eb6:	72 e0       	ldi	r23, 0x02	; 2
     eb8:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     ebc:	66 e0       	ldi	r22, 0x06	; 6
     ebe:	c8 01       	movw	r24, r16
     ec0:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     ec4:	6a e0       	ldi	r22, 0x0A	; 10
     ec6:	8e 81       	ldd	r24, Y+6	; 0x06
     ec8:	9f 81       	ldd	r25, Y+7	; 0x07
     eca:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     ece:	ec 01       	movw	r28, r24
     ed0:	6f ee       	ldi	r22, 0xEF	; 239
     ed2:	72 e0       	ldi	r23, 0x02	; 2
     ed4:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     ed8:	66 e0       	ldi	r22, 0x06	; 6
     eda:	ce 01       	movw	r24, r28
     edc:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
}
     ee0:	df 91       	pop	r29
     ee2:	cf 91       	pop	r28
     ee4:	1f 91       	pop	r17
     ee6:	0f 91       	pop	r16
     ee8:	08 95       	ret

00000eea <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     eea:	af 92       	push	r10
     eec:	bf 92       	push	r11
     eee:	cf 92       	push	r12
     ef0:	df 92       	push	r13
     ef2:	ef 92       	push	r14
     ef4:	ff 92       	push	r15
     ef6:	0f 93       	push	r16
     ef8:	1f 93       	push	r17
     efa:	cf 93       	push	r28
     efc:	df 93       	push	r29
     efe:	00 d0       	rcall	.+0      	; 0xf00 <_ZN9task_user11show_statusEv+0x16>
     f00:	00 d0       	rcall	.+0      	; 0xf02 <_ZN9task_user11show_statusEv+0x18>
     f02:	cd b7       	in	r28, 0x3d	; 61
     f04:	de b7       	in	r29, 0x3e	; 62
     f06:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f08:	19 82       	std	Y+1, r1	; 0x01
     f0a:	1a 82       	std	Y+2, r1	; 0x02
     f0c:	1b 82       	std	Y+3, r1	; 0x03
     f0e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f10:	1d 82       	std	Y+5, r1	; 0x05
     f12:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f14:	0e 94 1f 0a 	call	0x143e	; 0x143e <xPortGetFreeHeapSize>
     f18:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f1a:	ce 01       	movw	r24, r28
     f1c:	01 96       	adiw	r24, 0x01	; 1
     f1e:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_ZN10time_stamp10set_to_nowEv>
     f22:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f24:	66 e0       	ldi	r22, 0x06	; 6
     f26:	f8 01       	movw	r30, r16
     f28:	86 81       	ldd	r24, Z+6	; 0x06
     f2a:	97 81       	ldd	r25, Z+7	; 0x07
     f2c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     f30:	6a e0       	ldi	r22, 0x0A	; 10
     f32:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     f36:	7c 01       	movw	r14, r24
     f38:	60 ed       	ldi	r22, 0xD0	; 208
     f3a:	72 e0       	ldi	r23, 0x02	; 2
     f3c:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     f40:	6a e0       	ldi	r22, 0x0A	; 10
     f42:	c7 01       	movw	r24, r14
     f44:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     f48:	7c 01       	movw	r14, r24
     f4a:	64 ec       	ldi	r22, 0xC4	; 196
     f4c:	72 e0       	ldi	r23, 0x02	; 2
     f4e:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     f52:	66 e0       	ldi	r22, 0x06	; 6
     f54:	c7 01       	movw	r24, r14
     f56:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f5a:	6a e0       	ldi	r22, 0x0A	; 10
     f5c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     f60:	7c 01       	movw	r14, r24
     f62:	6d eb       	ldi	r22, 0xBD	; 189
     f64:	72 e0       	ldi	r23, 0x02	; 2
     f66:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     f6a:	b5 01       	movw	r22, r10
     f6c:	c7 01       	movw	r24, r14
     f6e:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f72:	6a e0       	ldi	r22, 0x0A	; 10
     f74:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     f78:	7c 01       	movw	r14, r24
     f7a:	6f ea       	ldi	r22, 0xAF	; 175
     f7c:	72 e0       	ldi	r23, 0x02	; 2
     f7e:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     f82:	b6 01       	movw	r22, r12
     f84:	c7 01       	movw	r24, r14
     f86:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEj>
     f8a:	6a e0       	ldi	r22, 0x0A	; 10
     f8c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     f90:	7c 01       	movw	r14, r24
     f92:	6d ea       	ldi	r22, 0xAD	; 173
     f94:	72 e0       	ldi	r23, 0x02	; 2
     f96:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     f9a:	4f ef       	ldi	r20, 0xFF	; 255
     f9c:	5f e0       	ldi	r21, 0x0F	; 15
     f9e:	60 e0       	ldi	r22, 0x00	; 0
     fa0:	70 e0       	ldi	r23, 0x00	; 0
     fa2:	c7 01       	movw	r24, r14
     fa4:	0e 94 b0 1a 	call	0x3560	; 0x3560 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     fa8:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     fac:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     fb0:	6a e0       	ldi	r22, 0x0A	; 10
     fb2:	f8 01       	movw	r30, r16
     fb4:	86 81       	ldd	r24, Z+6	; 0x06
     fb6:	97 81       	ldd	r25, Z+7	; 0x07
     fb8:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     fbc:	7c 01       	movw	r14, r24
     fbe:	62 ea       	ldi	r22, 0xA2	; 162
     fc0:	72 e0       	ldi	r23, 0x02	; 2
     fc2:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
     fc6:	b6 01       	movw	r22, r12
     fc8:	c7 01       	movw	r24, r14
     fca:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEj>
     fce:	66 e0       	ldi	r22, 0x06	; 6
     fd0:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
     fd4:	66 e0       	ldi	r22, 0x06	; 6
     fd6:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     fda:	f8 01       	movw	r30, r16
     fdc:	86 81       	ldd	r24, Z+6	; 0x06
     fde:	97 81       	ldd	r25, Z+7	; 0x07
     fe0:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <_Z15print_task_listP8emstream>
}
     fe4:	26 96       	adiw	r28, 0x06	; 6
     fe6:	cd bf       	out	0x3d, r28	; 61
     fe8:	de bf       	out	0x3e, r29	; 62
     fea:	df 91       	pop	r29
     fec:	cf 91       	pop	r28
     fee:	1f 91       	pop	r17
     ff0:	0f 91       	pop	r16
     ff2:	ff 90       	pop	r15
     ff4:	ef 90       	pop	r14
     ff6:	df 90       	pop	r13
     ff8:	cf 90       	pop	r12
     ffa:	bf 90       	pop	r11
     ffc:	af 90       	pop	r10
     ffe:	08 95       	ret

00001000 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
    1004:	00 d0       	rcall	.+0      	; 0x1006 <_ZN9task_user3runEv+0x6>
    1006:	00 d0       	rcall	.+0      	; 0x1008 <_ZN9task_user3runEv+0x8>
    1008:	cd b7       	in	r28, 0x3d	; 61
    100a:	de b7       	in	r29, 0x3e	; 62
    100c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    100e:	19 82       	std	Y+1, r1	; 0x01
    1010:	1a 82       	std	Y+2, r1	; 0x02
    1012:	1b 82       	std	Y+3, r1	; 0x03
    1014:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1016:	1d 82       	std	Y+5, r1	; 0x05
    1018:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    101a:	6a e0       	ldi	r22, 0x0A	; 10
    101c:	dc 01       	movw	r26, r24
    101e:	16 96       	adiw	r26, 0x06	; 6
    1020:	8d 91       	ld	r24, X+
    1022:	9c 91       	ld	r25, X
    1024:	17 97       	sbiw	r26, 0x07	; 7
    1026:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    102a:	7c 01       	movw	r14, r24
    102c:	6e e3       	ldi	r22, 0x3E	; 62
    102e:	74 e0       	ldi	r23, 0x04	; 4
    1030:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    1034:	66 e0       	ldi	r22, 0x06	; 6
    1036:	c7 01       	movw	r24, r14
    1038:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    103c:	f8 01       	movw	r30, r16
    103e:	84 85       	ldd	r24, Z+12	; 0x0c
    1040:	88 23       	and	r24, r24
    1042:	21 f0       	breq	.+8      	; 0x104c <_ZN9task_user3runEv+0x4c>
    1044:	81 30       	cpi	r24, 0x01	; 1
    1046:	09 f4       	brne	.+2      	; 0x104a <_ZN9task_user3runEv+0x4a>
    1048:	5d c0       	rjmp	.+186    	; 0x1104 <_ZN9task_user3runEv+0x104>
    104a:	d8 c0       	rjmp	.+432    	; 0x11fc <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    104c:	86 81       	ldd	r24, Z+6	; 0x06
    104e:	97 81       	ldd	r25, Z+7	; 0x07
    1050:	dc 01       	movw	r26, r24
    1052:	ed 91       	ld	r30, X+
    1054:	fc 91       	ld	r31, X
    1056:	04 80       	ldd	r0, Z+4	; 0x04
    1058:	f5 81       	ldd	r31, Z+5	; 0x05
    105a:	e0 2d       	mov	r30, r0
    105c:	19 95       	eicall
    105e:	88 23       	and	r24, r24
    1060:	a9 f1       	breq	.+106    	; 0x10cc <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1062:	f8 01       	movw	r30, r16
    1064:	86 81       	ldd	r24, Z+6	; 0x06
    1066:	97 81       	ldd	r25, Z+7	; 0x07
    1068:	dc 01       	movw	r26, r24
    106a:	ed 91       	ld	r30, X+
    106c:	fc 91       	ld	r31, X
    106e:	06 80       	ldd	r0, Z+6	; 0x06
    1070:	f7 81       	ldd	r31, Z+7	; 0x07
    1072:	e0 2d       	mov	r30, r0
    1074:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1076:	99 27       	eor	r25, r25
    1078:	81 30       	cpi	r24, 0x01	; 1
    107a:	91 05       	cpc	r25, r1
    107c:	f9 f0       	breq	.+62     	; 0x10bc <_ZN9task_user3runEv+0xbc>
    107e:	03 97       	sbiw	r24, 0x03	; 3
    1080:	09 f0       	breq	.+2      	; 0x1084 <_ZN9task_user3runEv+0x84>
    1082:	d8 c0       	rjmp	.+432    	; 0x1234 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1084:	6a e0       	ldi	r22, 0x0A	; 10
    1086:	f8 01       	movw	r30, r16
    1088:	86 81       	ldd	r24, Z+6	; 0x06
    108a:	97 81       	ldd	r25, Z+7	; 0x07
    108c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    1090:	8c 01       	movw	r16, r24
    1092:	60 e3       	ldi	r22, 0x30	; 48
    1094:	74 e0       	ldi	r23, 0x04	; 4
    1096:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    109a:	66 e0       	ldi	r22, 0x06	; 6
    109c:	c8 01       	movw	r24, r16
    109e:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10a2:	93 e0       	ldi	r25, 0x03	; 3
    10a4:	88 ed       	ldi	r24, 0xD8	; 216
    10a6:	08 b6       	in	r0, 0x38	; 56
    10a8:	18 be       	out	0x38, r1	; 56
    10aa:	84 bf       	out	0x34, r24	; 52
    10ac:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10b0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10b4:	81 fd       	sbrc	r24, 1
    10b6:	fc cf       	rjmp	.-8      	; 0x10b0 <_ZN9task_user3runEv+0xb0>
    10b8:	08 be       	out	0x38, r0	; 56
    10ba:	ff cf       	rjmp	.-2      	; 0x10ba <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10bc:	c8 01       	movw	r24, r16
    10be:	0e 94 cd 06 	call	0xd9a	; 0xd9a <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10c2:	61 e0       	ldi	r22, 0x01	; 1
    10c4:	c8 01       	movw	r24, r16
    10c6:	0e 94 a3 14 	call	0x2946	; 0x2946 <_ZN8frt_task13transition_toEh>
							break;
    10ca:	b4 c0       	rjmp	.+360    	; 0x1234 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10cc:	8a e8       	ldi	r24, 0x8A	; 138
    10ce:	91 e3       	ldi	r25, 0x31	; 49
    10d0:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <_ZN14frt_text_queue14check_for_charEv>
    10d4:	88 23       	and	r24, r24
    10d6:	09 f4       	brne	.+2      	; 0x10da <_ZN9task_user3runEv+0xda>
    10d8:	ad c0       	rjmp	.+346    	; 0x1234 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    10da:	d8 01       	movw	r26, r16
    10dc:	16 96       	adiw	r26, 0x06	; 6
    10de:	ed 91       	ld	r30, X+
    10e0:	fc 91       	ld	r31, X
    10e2:	17 97       	sbiw	r26, 0x07	; 7
    10e4:	01 90       	ld	r0, Z+
    10e6:	f0 81       	ld	r31, Z
    10e8:	e0 2d       	mov	r30, r0
    10ea:	e2 80       	ldd	r14, Z+2	; 0x02
    10ec:	f3 80       	ldd	r15, Z+3	; 0x03
    10ee:	8a e8       	ldi	r24, 0x8A	; 138
    10f0:	91 e3       	ldi	r25, 0x31	; 49
    10f2:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <_ZN14frt_text_queue7getcharEv>
    10f6:	68 2f       	mov	r22, r24
    10f8:	f8 01       	movw	r30, r16
    10fa:	86 81       	ldd	r24, Z+6	; 0x06
    10fc:	97 81       	ldd	r25, Z+7	; 0x07
    10fe:	f7 01       	movw	r30, r14
    1100:	19 95       	eicall
    1102:	98 c0       	rjmp	.+304    	; 0x1234 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1104:	86 81       	ldd	r24, Z+6	; 0x06
    1106:	97 81       	ldd	r25, Z+7	; 0x07
    1108:	dc 01       	movw	r26, r24
    110a:	ed 91       	ld	r30, X+
    110c:	fc 91       	ld	r31, X
    110e:	04 80       	ldd	r0, Z+4	; 0x04
    1110:	f5 81       	ldd	r31, Z+5	; 0x05
    1112:	e0 2d       	mov	r30, r0
    1114:	19 95       	eicall
    1116:	88 23       	and	r24, r24
    1118:	09 f4       	brne	.+2      	; 0x111c <_ZN9task_user3runEv+0x11c>
    111a:	8c c0       	rjmp	.+280    	; 0x1234 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    111c:	f8 01       	movw	r30, r16
    111e:	86 81       	ldd	r24, Z+6	; 0x06
    1120:	97 81       	ldd	r25, Z+7	; 0x07
    1122:	dc 01       	movw	r26, r24
    1124:	ed 91       	ld	r30, X+
    1126:	fc 91       	ld	r31, X
    1128:	06 80       	ldd	r0, Z+6	; 0x06
    112a:	f7 81       	ldd	r31, Z+7	; 0x07
    112c:	e0 2d       	mov	r30, r0
    112e:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1130:	9c 01       	movw	r18, r24
    1132:	33 27       	eor	r19, r19
    1134:	28 36       	cpi	r18, 0x68	; 104
    1136:	31 05       	cpc	r19, r1
    1138:	59 f1       	breq	.+86     	; 0x1190 <_ZN9task_user3runEv+0x190>
    113a:	3c f4       	brge	.+14     	; 0x114a <_ZN9task_user3runEv+0x14a>
    113c:	2b 31       	cpi	r18, 0x1B	; 27
    113e:	31 05       	cpc	r19, r1
    1140:	59 f1       	breq	.+86     	; 0x1198 <_ZN9task_user3runEv+0x198>
    1142:	25 36       	cpi	r18, 0x65	; 101
    1144:	31 05       	cpc	r19, r1
    1146:	41 f1       	breq	.+80     	; 0x1198 <_ZN9task_user3runEv+0x198>
    1148:	3b c0       	rjmp	.+118    	; 0x11c0 <_ZN9task_user3runEv+0x1c0>
    114a:	23 37       	cpi	r18, 0x73	; 115
    114c:	31 05       	cpc	r19, r1
    114e:	c1 f0       	breq	.+48     	; 0x1180 <_ZN9task_user3runEv+0x180>
    1150:	26 37       	cpi	r18, 0x76	; 118
    1152:	31 05       	cpc	r19, r1
    1154:	89 f0       	breq	.+34     	; 0x1178 <_ZN9task_user3runEv+0x178>
    1156:	2e 36       	cpi	r18, 0x6E	; 110
    1158:	31 05       	cpc	r19, r1
    115a:	91 f5       	brne	.+100    	; 0x11c0 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    115c:	ce 01       	movw	r24, r28
    115e:	01 96       	adiw	r24, 0x01	; 1
    1160:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_ZN10time_stamp10set_to_nowEv>
    1164:	bc 01       	movw	r22, r24
    1166:	f8 01       	movw	r30, r16
    1168:	86 81       	ldd	r24, Z+6	; 0x06
    116a:	97 81       	ldd	r25, Z+7	; 0x07
    116c:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <_ZlsR8emstreamR10time_stamp>
    1170:	66 e0       	ldi	r22, 0x06	; 6
    1172:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1176:	5e c0       	rjmp	.+188    	; 0x1234 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1178:	c8 01       	movw	r24, r16
    117a:	0e 94 75 07 	call	0xeea	; 0xeea <_ZN9task_user11show_statusEv>
							break;
    117e:	5a c0       	rjmp	.+180    	; 0x1234 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1180:	d8 01       	movw	r26, r16
    1182:	16 96       	adiw	r26, 0x06	; 6
    1184:	8d 91       	ld	r24, X+
    1186:	9c 91       	ld	r25, X
    1188:	17 97       	sbiw	r26, 0x07	; 7
    118a:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_Z17print_task_stacksP8emstream>
							break;
    118e:	52 c0       	rjmp	.+164    	; 0x1234 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1190:	c8 01       	movw	r24, r16
    1192:	0e 94 cd 06 	call	0xd9a	; 0xd9a <_ZN9task_user18print_help_messageEv>
							break;
    1196:	4e c0       	rjmp	.+156    	; 0x1234 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1198:	6a e0       	ldi	r22, 0x0A	; 10
    119a:	f8 01       	movw	r30, r16
    119c:	86 81       	ldd	r24, Z+6	; 0x06
    119e:	97 81       	ldd	r25, Z+7	; 0x07
    11a0:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    11a4:	7c 01       	movw	r14, r24
    11a6:	6e e1       	ldi	r22, 0x1E	; 30
    11a8:	74 e0       	ldi	r23, 0x04	; 4
    11aa:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    11ae:	66 e0       	ldi	r22, 0x06	; 6
    11b0:	c7 01       	movw	r24, r14
    11b2:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11b6:	60 e0       	ldi	r22, 0x00	; 0
    11b8:	c8 01       	movw	r24, r16
    11ba:	0e 94 a3 14 	call	0x2946	; 0x2946 <_ZN8frt_task13transition_toEh>
							break;
    11be:	3a c0       	rjmp	.+116    	; 0x1234 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11c0:	f8 01       	movw	r30, r16
    11c2:	a6 81       	ldd	r26, Z+6	; 0x06
    11c4:	b7 81       	ldd	r27, Z+7	; 0x07
    11c6:	ed 91       	ld	r30, X+
    11c8:	fc 91       	ld	r31, X
    11ca:	11 97       	sbiw	r26, 0x01	; 1
    11cc:	02 80       	ldd	r0, Z+2	; 0x02
    11ce:	f3 81       	ldd	r31, Z+3	; 0x03
    11d0:	e0 2d       	mov	r30, r0
    11d2:	68 2f       	mov	r22, r24
    11d4:	cd 01       	movw	r24, r26
    11d6:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    11d8:	6a e0       	ldi	r22, 0x0A	; 10
    11da:	d8 01       	movw	r26, r16
    11dc:	16 96       	adiw	r26, 0x06	; 6
    11de:	8d 91       	ld	r24, X+
    11e0:	9c 91       	ld	r25, X
    11e2:	17 97       	sbiw	r26, 0x07	; 7
    11e4:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    11e8:	7c 01       	movw	r14, r24
    11ea:	68 e1       	ldi	r22, 0x18	; 24
    11ec:	74 e0       	ldi	r23, 0x04	; 4
    11ee:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    11f2:	66 e0       	ldi	r22, 0x06	; 6
    11f4:	c7 01       	movw	r24, r14
    11f6:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
							break;
    11fa:	1c c0       	rjmp	.+56     	; 0x1234 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    11fc:	6a e0       	ldi	r22, 0x0A	; 10
    11fe:	f8 01       	movw	r30, r16
    1200:	86 81       	ldd	r24, Z+6	; 0x06
    1202:	97 81       	ldd	r25, Z+7	; 0x07
    1204:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    1208:	8c 01       	movw	r16, r24
    120a:	6b ef       	ldi	r22, 0xFB	; 251
    120c:	73 e0       	ldi	r23, 0x03	; 3
    120e:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    1212:	66 e0       	ldi	r22, 0x06	; 6
    1214:	c8 01       	movw	r24, r16
    1216:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    121a:	93 e0       	ldi	r25, 0x03	; 3
    121c:	88 ed       	ldi	r24, 0xD8	; 216
    121e:	08 b6       	in	r0, 0x38	; 56
    1220:	18 be       	out	0x38, r1	; 56
    1222:	84 bf       	out	0x34, r24	; 52
    1224:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1228:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    122c:	81 fd       	sbrc	r24, 1
    122e:	fc cf       	rjmp	.-8      	; 0x1228 <_ZN9task_user3runEv+0x228>
    1230:	08 be       	out	0x38, r0	; 56
    1232:	ff cf       	rjmp	.-2      	; 0x1232 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1234:	f8 01       	movw	r30, r16
    1236:	86 85       	ldd	r24, Z+14	; 0x0e
    1238:	97 85       	ldd	r25, Z+15	; 0x0f
    123a:	a0 89       	ldd	r26, Z+16	; 0x10
    123c:	b1 89       	ldd	r27, Z+17	; 0x11
    123e:	01 96       	adiw	r24, 0x01	; 1
    1240:	a1 1d       	adc	r26, r1
    1242:	b1 1d       	adc	r27, r1
    1244:	86 87       	std	Z+14, r24	; 0x0e
    1246:	97 87       	std	Z+15, r25	; 0x0f
    1248:	a0 8b       	std	Z+16, r26	; 0x10
    124a:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    124c:	61 e0       	ldi	r22, 0x01	; 1
    124e:	70 e0       	ldi	r23, 0x00	; 0
    1250:	80 e0       	ldi	r24, 0x00	; 0
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1258:	f1 ce       	rjmp	.-542    	; 0x103c <_ZN9task_user3runEv+0x3c>

0000125a <_ZN13task_Velocity3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void task_Velocity::run (void)
{ 
    125a:	cf 93       	push	r28
    125c:	df 93       	push	r29
    125e:	00 d0       	rcall	.+0      	; 0x1260 <_ZN13task_Velocity3runEv+0x6>
    1260:	1f 92       	push	r1
    1262:	cd b7       	in	r28, 0x3d	; 61
    1264:	de b7       	in	r29, 0x3e	; 62
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
    1266:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <xTaskGetTickCount>
    126a:	69 83       	std	Y+1, r22	; 0x01
    126c:	7a 83       	std	Y+2, r23	; 0x02
    126e:	8b 83       	std	Y+3, r24	; 0x03
    1270:	9c 83       	std	Y+4, r25	; 0x04
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
    1272:	42 e0       	ldi	r20, 0x02	; 2
    1274:	50 e0       	ldi	r21, 0x00	; 0
    1276:	60 e0       	ldi	r22, 0x00	; 0
    1278:	70 e0       	ldi	r23, 0x00	; 0
    127a:	ce 01       	movw	r24, r28
    127c:	01 96       	adiw	r24, 0x01	; 1
    127e:	0e 94 0a 12 	call	0x2414	; 0x2414 <vTaskDelayUntil>
    1282:	f7 cf       	rjmp	.-18     	; 0x1272 <_ZN13task_Velocity3runEv+0x18>

00001284 <_ZN13task_VelocityC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_Velocity::task_Velocity(const char* a_name,
    1284:	0f 93       	push	r16
    1286:	1f 93       	push	r17
    1288:	cf 93       	push	r28
    128a:	df 93       	push	r29
    128c:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    128e:	0e 94 a7 14 	call	0x294e	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream>
    1292:	8f e4       	ldi	r24, 0x4F	; 79
    1294:	90 e2       	ldi	r25, 0x20	; 32
    1296:	88 83       	st	Y, r24
    1298:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	08 95       	ret

000012a4 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    12a4:	0f 93       	push	r16
    12a6:	1f 93       	push	r17
    12a8:	cf 93       	push	r28
    12aa:	df 93       	push	r29
    12ac:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    12ae:	0e 94 66 10 	call	0x20cc	; 0x20cc <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    12b2:	80 91 f6 20 	lds	r24, 0x20F6	; 0x8020f6 <__data_end>
    12b6:	81 11       	cpse	r24, r1
    12b8:	1d c0       	rjmp	.+58     	; 0x12f4 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    12ba:	ab ef       	ldi	r26, 0xFB	; 251
    12bc:	b0 e2       	ldi	r27, 0x20	; 32
    12be:	ef ef       	ldi	r30, 0xFF	; 255
    12c0:	f0 e2       	ldi	r31, 0x20	; 32
    12c2:	ed 93       	st	X+, r30
    12c4:	fc 93       	st	X, r31
    12c6:	11 97       	sbiw	r26, 0x01	; 1
    12c8:	12 96       	adiw	r26, 0x02	; 2
    12ca:	1d 92       	st	X+, r1
    12cc:	1c 92       	st	X, r1
    12ce:	13 97       	sbiw	r26, 0x03	; 3
    12d0:	a7 ef       	ldi	r26, 0xF7	; 247
    12d2:	b0 e2       	ldi	r27, 0x20	; 32
    12d4:	8f ef       	ldi	r24, 0xFF	; 255
    12d6:	9f e0       	ldi	r25, 0x0F	; 15
    12d8:	12 96       	adiw	r26, 0x02	; 2
    12da:	8d 93       	st	X+, r24
    12dc:	9c 93       	st	X, r25
    12de:	13 97       	sbiw	r26, 0x03	; 3
    12e0:	1d 92       	st	X+, r1
    12e2:	1c 92       	st	X, r1
    12e4:	11 97       	sbiw	r26, 0x01	; 1
    12e6:	82 83       	std	Z+2, r24	; 0x02
    12e8:	93 83       	std	Z+3, r25	; 0x03
    12ea:	a0 83       	st	Z, r26
    12ec:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	80 93 f6 20 	sts	0x20F6, r24	; 0x8020f6 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12f4:	20 97       	sbiw	r28, 0x00	; 0
    12f6:	09 f4       	brne	.+2      	; 0x12fa <pvPortMalloc+0x56>
    12f8:	5f c0       	rjmp	.+190    	; 0x13b8 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12fa:	9e 01       	movw	r18, r28
    12fc:	2b 5f       	subi	r18, 0xFB	; 251
    12fe:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1300:	24 96       	adiw	r28, 0x04	; 4
    1302:	ce 3f       	cpi	r28, 0xFE	; 254
    1304:	df 40       	sbci	r29, 0x0F	; 15
    1306:	08 f0       	brcs	.+2      	; 0x130a <pvPortMalloc+0x66>
    1308:	5a c0       	rjmp	.+180    	; 0x13be <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    130a:	e0 91 fb 20 	lds	r30, 0x20FB	; 0x8020fb <xStart>
    130e:	f0 91 fc 20 	lds	r31, 0x20FC	; 0x8020fc <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1312:	ab ef       	ldi	r26, 0xFB	; 251
    1314:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1316:	02 c0       	rjmp	.+4      	; 0x131c <pvPortMalloc+0x78>
    1318:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    131a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    131c:	82 81       	ldd	r24, Z+2	; 0x02
    131e:	93 81       	ldd	r25, Z+3	; 0x03
    1320:	82 17       	cp	r24, r18
    1322:	93 07       	cpc	r25, r19
    1324:	20 f4       	brcc	.+8      	; 0x132e <pvPortMalloc+0x8a>
    1326:	80 81       	ld	r24, Z
    1328:	91 81       	ldd	r25, Z+1	; 0x01
    132a:	00 97       	sbiw	r24, 0x00	; 0
    132c:	a9 f7       	brne	.-22     	; 0x1318 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    132e:	c0 e2       	ldi	r28, 0x20	; 32
    1330:	e7 3f       	cpi	r30, 0xF7	; 247
    1332:	fc 07       	cpc	r31, r28
    1334:	09 f4       	brne	.+2      	; 0x1338 <pvPortMalloc+0x94>
    1336:	46 c0       	rjmp	.+140    	; 0x13c4 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1338:	cd 91       	ld	r28, X+
    133a:	dc 91       	ld	r29, X
    133c:	11 97       	sbiw	r26, 0x01	; 1
    133e:	8e 01       	movw	r16, r28
    1340:	0b 5f       	subi	r16, 0xFB	; 251
    1342:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1344:	80 81       	ld	r24, Z
    1346:	91 81       	ldd	r25, Z+1	; 0x01
    1348:	8d 93       	st	X+, r24
    134a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    134c:	82 81       	ldd	r24, Z+2	; 0x02
    134e:	93 81       	ldd	r25, Z+3	; 0x03
    1350:	82 1b       	sub	r24, r18
    1352:	93 0b       	sbc	r25, r19
    1354:	8b 30       	cpi	r24, 0x0B	; 11
    1356:	91 05       	cpc	r25, r1
    1358:	10 f1       	brcs	.+68     	; 0x139e <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    135a:	bf 01       	movw	r22, r30
    135c:	62 0f       	add	r22, r18
    135e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1360:	db 01       	movw	r26, r22
    1362:	12 96       	adiw	r26, 0x02	; 2
    1364:	8d 93       	st	X+, r24
    1366:	9c 93       	st	X, r25
    1368:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    136a:	22 83       	std	Z+2, r18	; 0x02
    136c:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    136e:	12 96       	adiw	r26, 0x02	; 2
    1370:	4d 91       	ld	r20, X+
    1372:	5c 91       	ld	r21, X
    1374:	13 97       	sbiw	r26, 0x03	; 3
    1376:	8b ef       	ldi	r24, 0xFB	; 251
    1378:	90 e2       	ldi	r25, 0x20	; 32
    137a:	01 c0       	rjmp	.+2      	; 0x137e <pvPortMalloc+0xda>
    137c:	cd 01       	movw	r24, r26
    137e:	ec 01       	movw	r28, r24
    1380:	a8 81       	ld	r26, Y
    1382:	b9 81       	ldd	r27, Y+1	; 0x01
    1384:	12 96       	adiw	r26, 0x02	; 2
    1386:	2d 91       	ld	r18, X+
    1388:	3c 91       	ld	r19, X
    138a:	13 97       	sbiw	r26, 0x03	; 3
    138c:	24 17       	cp	r18, r20
    138e:	35 07       	cpc	r19, r21
    1390:	a8 f3       	brcs	.-22     	; 0x137c <pvPortMalloc+0xd8>
    1392:	eb 01       	movw	r28, r22
    1394:	a8 83       	st	Y, r26
    1396:	b9 83       	std	Y+1, r27	; 0x01
    1398:	dc 01       	movw	r26, r24
    139a:	6d 93       	st	X+, r22
    139c:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    139e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    13a2:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    13a6:	22 81       	ldd	r18, Z+2	; 0x02
    13a8:	33 81       	ldd	r19, Z+3	; 0x03
    13aa:	82 1b       	sub	r24, r18
    13ac:	93 0b       	sbc	r25, r19
    13ae:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    13b2:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    13b6:	08 c0       	rjmp	.+16     	; 0x13c8 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    13b8:	00 e0       	ldi	r16, 0x00	; 0
    13ba:	10 e0       	ldi	r17, 0x00	; 0
    13bc:	05 c0       	rjmp	.+10     	; 0x13c8 <pvPortMalloc+0x124>
    13be:	00 e0       	ldi	r16, 0x00	; 0
    13c0:	10 e0       	ldi	r17, 0x00	; 0
    13c2:	02 c0       	rjmp	.+4      	; 0x13c8 <pvPortMalloc+0x124>
    13c4:	00 e0       	ldi	r16, 0x00	; 0
    13c6:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    13c8:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    13cc:	c8 01       	movw	r24, r16
    13ce:	df 91       	pop	r29
    13d0:	cf 91       	pop	r28
    13d2:	1f 91       	pop	r17
    13d4:	0f 91       	pop	r16
    13d6:	08 95       	ret

000013d8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    13d8:	0f 93       	push	r16
    13da:	1f 93       	push	r17
    13dc:	cf 93       	push	r28
    13de:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    13e0:	00 97       	sbiw	r24, 0x00	; 0
    13e2:	41 f1       	breq	.+80     	; 0x1434 <vPortFree+0x5c>
    13e4:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    13e6:	8c 01       	movw	r16, r24
    13e8:	05 50       	subi	r16, 0x05	; 5
    13ea:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    13ec:	0e 94 66 10 	call	0x20cc	; 0x20cc <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    13f0:	f8 01       	movw	r30, r16
    13f2:	42 81       	ldd	r20, Z+2	; 0x02
    13f4:	53 81       	ldd	r21, Z+3	; 0x03
    13f6:	ab ef       	ldi	r26, 0xFB	; 251
    13f8:	b0 e2       	ldi	r27, 0x20	; 32
    13fa:	01 c0       	rjmp	.+2      	; 0x13fe <vPortFree+0x26>
    13fc:	df 01       	movw	r26, r30
    13fe:	ed 91       	ld	r30, X+
    1400:	fc 91       	ld	r31, X
    1402:	11 97       	sbiw	r26, 0x01	; 1
    1404:	22 81       	ldd	r18, Z+2	; 0x02
    1406:	33 81       	ldd	r19, Z+3	; 0x03
    1408:	24 17       	cp	r18, r20
    140a:	35 07       	cpc	r19, r21
    140c:	b8 f3       	brcs	.-18     	; 0x13fc <vPortFree+0x24>
    140e:	25 97       	sbiw	r28, 0x05	; 5
    1410:	e8 83       	st	Y, r30
    1412:	f9 83       	std	Y+1, r31	; 0x01
    1414:	0d 93       	st	X+, r16
    1416:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1418:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    141c:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1420:	8a 81       	ldd	r24, Y+2	; 0x02
    1422:	9b 81       	ldd	r25, Y+3	; 0x03
    1424:	82 0f       	add	r24, r18
    1426:	93 1f       	adc	r25, r19
    1428:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    142c:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1430:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
	}
}
    1434:	df 91       	pop	r29
    1436:	cf 91       	pop	r28
    1438:	1f 91       	pop	r17
    143a:	0f 91       	pop	r16
    143c:	08 95       	ret

0000143e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    143e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1442:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1446:	08 95       	ret

00001448 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1448:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    144a:	03 96       	adiw	r24, 0x03	; 3
    144c:	81 83       	std	Z+1, r24	; 0x01
    144e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1450:	4f ef       	ldi	r20, 0xFF	; 255
    1452:	5f ef       	ldi	r21, 0xFF	; 255
    1454:	ba 01       	movw	r22, r20
    1456:	43 83       	std	Z+3, r20	; 0x03
    1458:	54 83       	std	Z+4, r21	; 0x04
    145a:	65 83       	std	Z+5, r22	; 0x05
    145c:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    145e:	87 83       	std	Z+7, r24	; 0x07
    1460:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1462:	81 87       	std	Z+9, r24	; 0x09
    1464:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1466:	10 82       	st	Z, r1
    1468:	08 95       	ret

0000146a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    146a:	fc 01       	movw	r30, r24
    146c:	12 86       	std	Z+10, r1	; 0x0a
    146e:	13 86       	std	Z+11, r1	; 0x0b
    1470:	08 95       	ret

00001472 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	fc 01       	movw	r30, r24
    1478:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    147a:	21 81       	ldd	r18, Z+1	; 0x01
    147c:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    147e:	e9 01       	movw	r28, r18
    1480:	8c 81       	ldd	r24, Y+4	; 0x04
    1482:	9d 81       	ldd	r25, Y+5	; 0x05
    1484:	14 96       	adiw	r26, 0x04	; 4
    1486:	8d 93       	st	X+, r24
    1488:	9c 93       	st	X, r25
    148a:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    148c:	81 81       	ldd	r24, Z+1	; 0x01
    148e:	92 81       	ldd	r25, Z+2	; 0x02
    1490:	16 96       	adiw	r26, 0x06	; 6
    1492:	8d 93       	st	X+, r24
    1494:	9c 93       	st	X, r25
    1496:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1498:	8c 81       	ldd	r24, Y+4	; 0x04
    149a:	9d 81       	ldd	r25, Y+5	; 0x05
    149c:	ec 01       	movw	r28, r24
    149e:	6e 83       	std	Y+6, r22	; 0x06
    14a0:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    14a2:	e9 01       	movw	r28, r18
    14a4:	6c 83       	std	Y+4, r22	; 0x04
    14a6:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    14a8:	61 83       	std	Z+1, r22	; 0x01
    14aa:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14ac:	1a 96       	adiw	r26, 0x0a	; 10
    14ae:	ed 93       	st	X+, r30
    14b0:	fc 93       	st	X, r31
    14b2:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    14b4:	80 81       	ld	r24, Z
    14b6:	8f 5f       	subi	r24, 0xFF	; 255
    14b8:	80 83       	st	Z, r24
}
    14ba:	df 91       	pop	r29
    14bc:	cf 91       	pop	r28
    14be:	08 95       	ret

000014c0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    14c0:	0f 93       	push	r16
    14c2:	1f 93       	push	r17
    14c4:	cf 93       	push	r28
    14c6:	df 93       	push	r29
    14c8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    14ca:	08 81       	ld	r16, Y
    14cc:	19 81       	ldd	r17, Y+1	; 0x01
    14ce:	2a 81       	ldd	r18, Y+2	; 0x02
    14d0:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14d2:	0f 3f       	cpi	r16, 0xFF	; 255
    14d4:	4f ef       	ldi	r20, 0xFF	; 255
    14d6:	14 07       	cpc	r17, r20
    14d8:	24 07       	cpc	r18, r20
    14da:	34 07       	cpc	r19, r20
    14dc:	31 f4       	brne	.+12     	; 0x14ea <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14de:	dc 01       	movw	r26, r24
    14e0:	19 96       	adiw	r26, 0x09	; 9
    14e2:	ed 91       	ld	r30, X+
    14e4:	fc 91       	ld	r31, X
    14e6:	1a 97       	sbiw	r26, 0x0a	; 10
    14e8:	1f c0       	rjmp	.+62     	; 0x1528 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14ea:	fc 01       	movw	r30, r24
    14ec:	33 96       	adiw	r30, 0x03	; 3
    14ee:	dc 01       	movw	r26, r24
    14f0:	17 96       	adiw	r26, 0x07	; 7
    14f2:	4d 91       	ld	r20, X+
    14f4:	5c 91       	ld	r21, X
    14f6:	18 97       	sbiw	r26, 0x08	; 8
    14f8:	da 01       	movw	r26, r20
    14fa:	4d 91       	ld	r20, X+
    14fc:	5d 91       	ld	r21, X+
    14fe:	6d 91       	ld	r22, X+
    1500:	7c 91       	ld	r23, X
    1502:	04 17       	cp	r16, r20
    1504:	15 07       	cpc	r17, r21
    1506:	26 07       	cpc	r18, r22
    1508:	37 07       	cpc	r19, r23
    150a:	70 f0       	brcs	.+28     	; 0x1528 <vListInsert+0x68>
    150c:	04 80       	ldd	r0, Z+4	; 0x04
    150e:	f5 81       	ldd	r31, Z+5	; 0x05
    1510:	e0 2d       	mov	r30, r0
    1512:	a4 81       	ldd	r26, Z+4	; 0x04
    1514:	b5 81       	ldd	r27, Z+5	; 0x05
    1516:	4d 91       	ld	r20, X+
    1518:	5d 91       	ld	r21, X+
    151a:	6d 91       	ld	r22, X+
    151c:	7c 91       	ld	r23, X
    151e:	04 17       	cp	r16, r20
    1520:	15 07       	cpc	r17, r21
    1522:	26 07       	cpc	r18, r22
    1524:	37 07       	cpc	r19, r23
    1526:	90 f7       	brcc	.-28     	; 0x150c <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1528:	a4 81       	ldd	r26, Z+4	; 0x04
    152a:	b5 81       	ldd	r27, Z+5	; 0x05
    152c:	ac 83       	std	Y+4, r26	; 0x04
    152e:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1530:	16 96       	adiw	r26, 0x06	; 6
    1532:	cd 93       	st	X+, r28
    1534:	dc 93       	st	X, r29
    1536:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1538:	ee 83       	std	Y+6, r30	; 0x06
    153a:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    153c:	c4 83       	std	Z+4, r28	; 0x04
    153e:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1540:	8a 87       	std	Y+10, r24	; 0x0a
    1542:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1544:	fc 01       	movw	r30, r24
    1546:	20 81       	ld	r18, Z
    1548:	2f 5f       	subi	r18, 0xFF	; 255
    154a:	20 83       	st	Z, r18
}
    154c:	df 91       	pop	r29
    154e:	cf 91       	pop	r28
    1550:	1f 91       	pop	r17
    1552:	0f 91       	pop	r16
    1554:	08 95       	ret

00001556 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1556:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1558:	a4 81       	ldd	r26, Z+4	; 0x04
    155a:	b5 81       	ldd	r27, Z+5	; 0x05
    155c:	86 81       	ldd	r24, Z+6	; 0x06
    155e:	97 81       	ldd	r25, Z+7	; 0x07
    1560:	16 96       	adiw	r26, 0x06	; 6
    1562:	8d 93       	st	X+, r24
    1564:	9c 93       	st	X, r25
    1566:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1568:	a6 81       	ldd	r26, Z+6	; 0x06
    156a:	b7 81       	ldd	r27, Z+7	; 0x07
    156c:	84 81       	ldd	r24, Z+4	; 0x04
    156e:	95 81       	ldd	r25, Z+5	; 0x05
    1570:	14 96       	adiw	r26, 0x04	; 4
    1572:	8d 93       	st	X+, r24
    1574:	9c 93       	st	X, r25
    1576:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1578:	a2 85       	ldd	r26, Z+10	; 0x0a
    157a:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    157c:	11 96       	adiw	r26, 0x01	; 1
    157e:	8d 91       	ld	r24, X+
    1580:	9c 91       	ld	r25, X
    1582:	12 97       	sbiw	r26, 0x02	; 2
    1584:	e8 17       	cp	r30, r24
    1586:	f9 07       	cpc	r31, r25
    1588:	31 f4       	brne	.+12     	; 0x1596 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    158a:	86 81       	ldd	r24, Z+6	; 0x06
    158c:	97 81       	ldd	r25, Z+7	; 0x07
    158e:	11 96       	adiw	r26, 0x01	; 1
    1590:	8d 93       	st	X+, r24
    1592:	9c 93       	st	X, r25
    1594:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1596:	12 86       	std	Z+10, r1	; 0x0a
    1598:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    159a:	8c 91       	ld	r24, X
    159c:	81 50       	subi	r24, 0x01	; 1
    159e:	8c 93       	st	X, r24
    15a0:	08 95       	ret

000015a2 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    15a2:	80 93 9a 31 	sts	0x319A, r24	; 0x80319a <portStackTopForTask>
    15a6:	90 93 9b 31 	sts	0x319B, r25	; 0x80319b <portStackTopForTask+0x1>
    15aa:	31 e1       	ldi	r19, 0x11	; 17
    15ac:	fc 01       	movw	r30, r24
    15ae:	30 83       	st	Z, r19
    15b0:	31 97       	sbiw	r30, 0x01	; 1
    15b2:	22 e2       	ldi	r18, 0x22	; 34
    15b4:	20 83       	st	Z, r18
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	a3 e3       	ldi	r26, 0x33	; 51
    15ba:	a0 83       	st	Z, r26
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	60 83       	st	Z, r22
    15c0:	31 97       	sbiw	r30, 0x01	; 1
    15c2:	70 83       	st	Z, r23
    15c4:	31 97       	sbiw	r30, 0x01	; 1
    15c6:	10 82       	st	Z, r1
    15c8:	31 97       	sbiw	r30, 0x01	; 1
    15ca:	10 82       	st	Z, r1
    15cc:	31 97       	sbiw	r30, 0x01	; 1
    15ce:	60 e8       	ldi	r22, 0x80	; 128
    15d0:	60 83       	st	Z, r22
    15d2:	31 97       	sbiw	r30, 0x01	; 1
    15d4:	10 82       	st	Z, r1
    15d6:	31 97       	sbiw	r30, 0x01	; 1
    15d8:	10 82       	st	Z, r1
    15da:	31 97       	sbiw	r30, 0x01	; 1
    15dc:	10 82       	st	Z, r1
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	62 e0       	ldi	r22, 0x02	; 2
    15e2:	60 83       	st	Z, r22
    15e4:	31 97       	sbiw	r30, 0x01	; 1
    15e6:	63 e0       	ldi	r22, 0x03	; 3
    15e8:	60 83       	st	Z, r22
    15ea:	31 97       	sbiw	r30, 0x01	; 1
    15ec:	64 e0       	ldi	r22, 0x04	; 4
    15ee:	60 83       	st	Z, r22
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	65 e0       	ldi	r22, 0x05	; 5
    15f4:	60 83       	st	Z, r22
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	66 e0       	ldi	r22, 0x06	; 6
    15fa:	60 83       	st	Z, r22
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	67 e0       	ldi	r22, 0x07	; 7
    1600:	60 83       	st	Z, r22
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	68 e0       	ldi	r22, 0x08	; 8
    1606:	60 83       	st	Z, r22
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	69 e0       	ldi	r22, 0x09	; 9
    160c:	60 83       	st	Z, r22
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	60 e1       	ldi	r22, 0x10	; 16
    1612:	60 83       	st	Z, r22
    1614:	31 97       	sbiw	r30, 0x01	; 1
    1616:	30 83       	st	Z, r19
    1618:	31 97       	sbiw	r30, 0x01	; 1
    161a:	32 e1       	ldi	r19, 0x12	; 18
    161c:	30 83       	st	Z, r19
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	33 e1       	ldi	r19, 0x13	; 19
    1622:	30 83       	st	Z, r19
    1624:	31 97       	sbiw	r30, 0x01	; 1
    1626:	34 e1       	ldi	r19, 0x14	; 20
    1628:	30 83       	st	Z, r19
    162a:	31 97       	sbiw	r30, 0x01	; 1
    162c:	35 e1       	ldi	r19, 0x15	; 21
    162e:	30 83       	st	Z, r19
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	36 e1       	ldi	r19, 0x16	; 22
    1634:	30 83       	st	Z, r19
    1636:	31 97       	sbiw	r30, 0x01	; 1
    1638:	37 e1       	ldi	r19, 0x17	; 23
    163a:	30 83       	st	Z, r19
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	38 e1       	ldi	r19, 0x18	; 24
    1640:	30 83       	st	Z, r19
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	39 e1       	ldi	r19, 0x19	; 25
    1646:	30 83       	st	Z, r19
    1648:	31 97       	sbiw	r30, 0x01	; 1
    164a:	30 e2       	ldi	r19, 0x20	; 32
    164c:	30 83       	st	Z, r19
    164e:	31 97       	sbiw	r30, 0x01	; 1
    1650:	31 e2       	ldi	r19, 0x21	; 33
    1652:	30 83       	st	Z, r19
    1654:	31 97       	sbiw	r30, 0x01	; 1
    1656:	20 83       	st	Z, r18
    1658:	31 97       	sbiw	r30, 0x01	; 1
    165a:	23 e2       	ldi	r18, 0x23	; 35
    165c:	20 83       	st	Z, r18
    165e:	31 97       	sbiw	r30, 0x01	; 1
    1660:	40 83       	st	Z, r20
    1662:	31 97       	sbiw	r30, 0x01	; 1
    1664:	50 83       	st	Z, r21
    1666:	31 97       	sbiw	r30, 0x01	; 1
    1668:	26 e2       	ldi	r18, 0x26	; 38
    166a:	20 83       	st	Z, r18
    166c:	31 97       	sbiw	r30, 0x01	; 1
    166e:	27 e2       	ldi	r18, 0x27	; 39
    1670:	20 83       	st	Z, r18
    1672:	31 97       	sbiw	r30, 0x01	; 1
    1674:	28 e2       	ldi	r18, 0x28	; 40
    1676:	20 83       	st	Z, r18
    1678:	31 97       	sbiw	r30, 0x01	; 1
    167a:	29 e2       	ldi	r18, 0x29	; 41
    167c:	20 83       	st	Z, r18
    167e:	31 97       	sbiw	r30, 0x01	; 1
    1680:	20 e3       	ldi	r18, 0x30	; 48
    1682:	20 83       	st	Z, r18
    1684:	31 97       	sbiw	r30, 0x01	; 1
    1686:	21 e3       	ldi	r18, 0x31	; 49
    1688:	20 83       	st	Z, r18
    168a:	89 97       	sbiw	r24, 0x29	; 41
    168c:	08 95       	ret

0000168e <xPortStartScheduler>:
    168e:	8c e7       	ldi	r24, 0x7C	; 124
    1690:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1694:	8f ef       	ldi	r24, 0xFF	; 255
    1696:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    16a0:	91 e1       	ldi	r25, 0x11	; 17
    16a2:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    16a6:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    16aa:	a0 91 5e 31 	lds	r26, 0x315E	; 0x80315e <pxCurrentTCB>
    16ae:	b0 91 5f 31 	lds	r27, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    16b2:	cd 91       	ld	r28, X+
    16b4:	cd bf       	out	0x3d, r28	; 61
    16b6:	dd 91       	ld	r29, X+
    16b8:	de bf       	out	0x3e, r29	; 62
    16ba:	ff 91       	pop	r31
    16bc:	ef 91       	pop	r30
    16be:	df 91       	pop	r29
    16c0:	cf 91       	pop	r28
    16c2:	bf 91       	pop	r27
    16c4:	af 91       	pop	r26
    16c6:	9f 91       	pop	r25
    16c8:	8f 91       	pop	r24
    16ca:	7f 91       	pop	r23
    16cc:	6f 91       	pop	r22
    16ce:	5f 91       	pop	r21
    16d0:	4f 91       	pop	r20
    16d2:	3f 91       	pop	r19
    16d4:	2f 91       	pop	r18
    16d6:	1f 91       	pop	r17
    16d8:	0f 91       	pop	r16
    16da:	ff 90       	pop	r15
    16dc:	ef 90       	pop	r14
    16de:	df 90       	pop	r13
    16e0:	cf 90       	pop	r12
    16e2:	bf 90       	pop	r11
    16e4:	af 90       	pop	r10
    16e6:	9f 90       	pop	r9
    16e8:	8f 90       	pop	r8
    16ea:	7f 90       	pop	r7
    16ec:	6f 90       	pop	r6
    16ee:	5f 90       	pop	r5
    16f0:	4f 90       	pop	r4
    16f2:	3f 90       	pop	r3
    16f4:	2f 90       	pop	r2
    16f6:	1f 90       	pop	r1
    16f8:	0f 90       	pop	r0
    16fa:	0c be       	out	0x3c, r0	; 60
    16fc:	0f 90       	pop	r0
    16fe:	0b be       	out	0x3b, r0	; 59
    1700:	0f 90       	pop	r0
    1702:	0f be       	out	0x3f, r0	; 63
    1704:	0f 90       	pop	r0
    1706:	08 95       	ret
    1708:	08 95       	ret

0000170a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    170a:	0f 92       	push	r0
    170c:	0f b6       	in	r0, 0x3f	; 63
    170e:	f8 94       	cli
    1710:	0f 92       	push	r0
    1712:	0b b6       	in	r0, 0x3b	; 59
    1714:	0f 92       	push	r0
    1716:	0c b6       	in	r0, 0x3c	; 60
    1718:	0f 92       	push	r0
    171a:	1f 92       	push	r1
    171c:	11 24       	eor	r1, r1
    171e:	2f 92       	push	r2
    1720:	3f 92       	push	r3
    1722:	4f 92       	push	r4
    1724:	5f 92       	push	r5
    1726:	6f 92       	push	r6
    1728:	7f 92       	push	r7
    172a:	8f 92       	push	r8
    172c:	9f 92       	push	r9
    172e:	af 92       	push	r10
    1730:	bf 92       	push	r11
    1732:	cf 92       	push	r12
    1734:	df 92       	push	r13
    1736:	ef 92       	push	r14
    1738:	ff 92       	push	r15
    173a:	0f 93       	push	r16
    173c:	1f 93       	push	r17
    173e:	2f 93       	push	r18
    1740:	3f 93       	push	r19
    1742:	4f 93       	push	r20
    1744:	5f 93       	push	r21
    1746:	6f 93       	push	r22
    1748:	7f 93       	push	r23
    174a:	8f 93       	push	r24
    174c:	9f 93       	push	r25
    174e:	af 93       	push	r26
    1750:	bf 93       	push	r27
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
    1756:	ef 93       	push	r30
    1758:	ff 93       	push	r31
    175a:	a0 91 5e 31 	lds	r26, 0x315E	; 0x80315e <pxCurrentTCB>
    175e:	b0 91 5f 31 	lds	r27, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    1762:	0d b6       	in	r0, 0x3d	; 61
    1764:	0d 92       	st	X+, r0
    1766:	0e b6       	in	r0, 0x3e	; 62
    1768:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    176a:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    176e:	a0 91 5e 31 	lds	r26, 0x315E	; 0x80315e <pxCurrentTCB>
    1772:	b0 91 5f 31 	lds	r27, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    1776:	cd 91       	ld	r28, X+
    1778:	cd bf       	out	0x3d, r28	; 61
    177a:	dd 91       	ld	r29, X+
    177c:	de bf       	out	0x3e, r29	; 62
    177e:	ff 91       	pop	r31
    1780:	ef 91       	pop	r30
    1782:	df 91       	pop	r29
    1784:	cf 91       	pop	r28
    1786:	bf 91       	pop	r27
    1788:	af 91       	pop	r26
    178a:	9f 91       	pop	r25
    178c:	8f 91       	pop	r24
    178e:	7f 91       	pop	r23
    1790:	6f 91       	pop	r22
    1792:	5f 91       	pop	r21
    1794:	4f 91       	pop	r20
    1796:	3f 91       	pop	r19
    1798:	2f 91       	pop	r18
    179a:	1f 91       	pop	r17
    179c:	0f 91       	pop	r16
    179e:	ff 90       	pop	r15
    17a0:	ef 90       	pop	r14
    17a2:	df 90       	pop	r13
    17a4:	cf 90       	pop	r12
    17a6:	bf 90       	pop	r11
    17a8:	af 90       	pop	r10
    17aa:	9f 90       	pop	r9
    17ac:	8f 90       	pop	r8
    17ae:	7f 90       	pop	r7
    17b0:	6f 90       	pop	r6
    17b2:	5f 90       	pop	r5
    17b4:	4f 90       	pop	r4
    17b6:	3f 90       	pop	r3
    17b8:	2f 90       	pop	r2
    17ba:	1f 90       	pop	r1
    17bc:	0f 90       	pop	r0
    17be:	0c be       	out	0x3c, r0	; 60
    17c0:	0f 90       	pop	r0
    17c2:	0b be       	out	0x3b, r0	; 59
    17c4:	0f 90       	pop	r0
    17c6:	0f be       	out	0x3f, r0	; 63
    17c8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17ca:	08 95       	ret

000017cc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17cc:	0f 92       	push	r0
    17ce:	0f b6       	in	r0, 0x3f	; 63
    17d0:	f8 94       	cli
    17d2:	0f 92       	push	r0
    17d4:	0b b6       	in	r0, 0x3b	; 59
    17d6:	0f 92       	push	r0
    17d8:	0c b6       	in	r0, 0x3c	; 60
    17da:	0f 92       	push	r0
    17dc:	1f 92       	push	r1
    17de:	11 24       	eor	r1, r1
    17e0:	2f 92       	push	r2
    17e2:	3f 92       	push	r3
    17e4:	4f 92       	push	r4
    17e6:	5f 92       	push	r5
    17e8:	6f 92       	push	r6
    17ea:	7f 92       	push	r7
    17ec:	8f 92       	push	r8
    17ee:	9f 92       	push	r9
    17f0:	af 92       	push	r10
    17f2:	bf 92       	push	r11
    17f4:	cf 92       	push	r12
    17f6:	df 92       	push	r13
    17f8:	ef 92       	push	r14
    17fa:	ff 92       	push	r15
    17fc:	0f 93       	push	r16
    17fe:	1f 93       	push	r17
    1800:	2f 93       	push	r18
    1802:	3f 93       	push	r19
    1804:	4f 93       	push	r20
    1806:	5f 93       	push	r21
    1808:	6f 93       	push	r22
    180a:	7f 93       	push	r23
    180c:	8f 93       	push	r24
    180e:	9f 93       	push	r25
    1810:	af 93       	push	r26
    1812:	bf 93       	push	r27
    1814:	cf 93       	push	r28
    1816:	df 93       	push	r29
    1818:	ef 93       	push	r30
    181a:	ff 93       	push	r31
    181c:	a0 91 5e 31 	lds	r26, 0x315E	; 0x80315e <pxCurrentTCB>
    1820:	b0 91 5f 31 	lds	r27, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    1824:	0d b6       	in	r0, 0x3d	; 61
    1826:	0d 92       	st	X+, r0
    1828:	0e b6       	in	r0, 0x3e	; 62
    182a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    182c:	0e 94 87 10 	call	0x210e	; 0x210e <vTaskIncrementTick>
	vTaskSwitchContext();
    1830:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1834:	a0 91 5e 31 	lds	r26, 0x315E	; 0x80315e <pxCurrentTCB>
    1838:	b0 91 5f 31 	lds	r27, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    183c:	cd 91       	ld	r28, X+
    183e:	cd bf       	out	0x3d, r28	; 61
    1840:	dd 91       	ld	r29, X+
    1842:	de bf       	out	0x3e, r29	; 62
    1844:	ff 91       	pop	r31
    1846:	ef 91       	pop	r30
    1848:	df 91       	pop	r29
    184a:	cf 91       	pop	r28
    184c:	bf 91       	pop	r27
    184e:	af 91       	pop	r26
    1850:	9f 91       	pop	r25
    1852:	8f 91       	pop	r24
    1854:	7f 91       	pop	r23
    1856:	6f 91       	pop	r22
    1858:	5f 91       	pop	r21
    185a:	4f 91       	pop	r20
    185c:	3f 91       	pop	r19
    185e:	2f 91       	pop	r18
    1860:	1f 91       	pop	r17
    1862:	0f 91       	pop	r16
    1864:	ff 90       	pop	r15
    1866:	ef 90       	pop	r14
    1868:	df 90       	pop	r13
    186a:	cf 90       	pop	r12
    186c:	bf 90       	pop	r11
    186e:	af 90       	pop	r10
    1870:	9f 90       	pop	r9
    1872:	8f 90       	pop	r8
    1874:	7f 90       	pop	r7
    1876:	6f 90       	pop	r6
    1878:	5f 90       	pop	r5
    187a:	4f 90       	pop	r4
    187c:	3f 90       	pop	r3
    187e:	2f 90       	pop	r2
    1880:	1f 90       	pop	r1
    1882:	0f 90       	pop	r0
    1884:	0c be       	out	0x3c, r0	; 60
    1886:	0f 90       	pop	r0
    1888:	0b be       	out	0x3b, r0	; 59
    188a:	0f 90       	pop	r0
    188c:	0f be       	out	0x3f, r0	; 63
    188e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1890:	08 95       	ret

00001892 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1892:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <vPortYieldFromTick>
		asm volatile ( "reti" );
    1896:	18 95       	reti

00001898 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1898:	cf 93       	push	r28
    189a:	df 93       	push	r29
    189c:	ec 01       	movw	r28, r24
    189e:	88 a1       	ldd	r24, Y+32	; 0x20
    18a0:	81 11       	cpse	r24, r1
    18a2:	0b c0       	rjmp	.+22     	; 0x18ba <prvCopyDataToQueue+0x22>
    18a4:	88 81       	ld	r24, Y
    18a6:	99 81       	ldd	r25, Y+1	; 0x01
    18a8:	89 2b       	or	r24, r25
    18aa:	e1 f5       	brne	.+120    	; 0x1924 <prvCopyDataToQueue+0x8c>
    18ac:	8a 81       	ldd	r24, Y+2	; 0x02
    18ae:	9b 81       	ldd	r25, Y+3	; 0x03
    18b0:	0e 94 60 14 	call	0x28c0	; 0x28c0 <vTaskPriorityDisinherit>
    18b4:	1a 82       	std	Y+2, r1	; 0x02
    18b6:	1b 82       	std	Y+3, r1	; 0x03
    18b8:	35 c0       	rjmp	.+106    	; 0x1924 <prvCopyDataToQueue+0x8c>
    18ba:	41 11       	cpse	r20, r1
    18bc:	17 c0       	rjmp	.+46     	; 0x18ec <prvCopyDataToQueue+0x54>
    18be:	48 2f       	mov	r20, r24
    18c0:	50 e0       	ldi	r21, 0x00	; 0
    18c2:	8c 81       	ldd	r24, Y+4	; 0x04
    18c4:	9d 81       	ldd	r25, Y+5	; 0x05
    18c6:	0e 94 22 20 	call	0x4044	; 0x4044 <memcpy>
    18ca:	28 a1       	ldd	r18, Y+32	; 0x20
    18cc:	8c 81       	ldd	r24, Y+4	; 0x04
    18ce:	9d 81       	ldd	r25, Y+5	; 0x05
    18d0:	82 0f       	add	r24, r18
    18d2:	91 1d       	adc	r25, r1
    18d4:	8c 83       	std	Y+4, r24	; 0x04
    18d6:	9d 83       	std	Y+5, r25	; 0x05
    18d8:	2a 81       	ldd	r18, Y+2	; 0x02
    18da:	3b 81       	ldd	r19, Y+3	; 0x03
    18dc:	82 17       	cp	r24, r18
    18de:	93 07       	cpc	r25, r19
    18e0:	08 f1       	brcs	.+66     	; 0x1924 <prvCopyDataToQueue+0x8c>
    18e2:	88 81       	ld	r24, Y
    18e4:	99 81       	ldd	r25, Y+1	; 0x01
    18e6:	8c 83       	std	Y+4, r24	; 0x04
    18e8:	9d 83       	std	Y+5, r25	; 0x05
    18ea:	1c c0       	rjmp	.+56     	; 0x1924 <prvCopyDataToQueue+0x8c>
    18ec:	48 2f       	mov	r20, r24
    18ee:	50 e0       	ldi	r21, 0x00	; 0
    18f0:	8e 81       	ldd	r24, Y+6	; 0x06
    18f2:	9f 81       	ldd	r25, Y+7	; 0x07
    18f4:	0e 94 22 20 	call	0x4044	; 0x4044 <memcpy>
    18f8:	88 a1       	ldd	r24, Y+32	; 0x20
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	91 95       	neg	r25
    18fe:	81 95       	neg	r24
    1900:	91 09       	sbc	r25, r1
    1902:	2e 81       	ldd	r18, Y+6	; 0x06
    1904:	3f 81       	ldd	r19, Y+7	; 0x07
    1906:	28 0f       	add	r18, r24
    1908:	39 1f       	adc	r19, r25
    190a:	2e 83       	std	Y+6, r18	; 0x06
    190c:	3f 83       	std	Y+7, r19	; 0x07
    190e:	48 81       	ld	r20, Y
    1910:	59 81       	ldd	r21, Y+1	; 0x01
    1912:	24 17       	cp	r18, r20
    1914:	35 07       	cpc	r19, r21
    1916:	30 f4       	brcc	.+12     	; 0x1924 <prvCopyDataToQueue+0x8c>
    1918:	2a 81       	ldd	r18, Y+2	; 0x02
    191a:	3b 81       	ldd	r19, Y+3	; 0x03
    191c:	82 0f       	add	r24, r18
    191e:	93 1f       	adc	r25, r19
    1920:	8e 83       	std	Y+6, r24	; 0x06
    1922:	9f 83       	std	Y+7, r25	; 0x07
    1924:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1926:	8f 5f       	subi	r24, 0xFF	; 255
    1928:	8e 8f       	std	Y+30, r24	; 0x1e
    192a:	df 91       	pop	r29
    192c:	cf 91       	pop	r28
    192e:	08 95       	ret

00001930 <prvCopyDataFromQueue>:
    1930:	fc 01       	movw	r30, r24
    1932:	80 81       	ld	r24, Z
    1934:	91 81       	ldd	r25, Z+1	; 0x01
    1936:	00 97       	sbiw	r24, 0x00	; 0
    1938:	a1 f0       	breq	.+40     	; 0x1962 <prvCopyDataFromQueue+0x32>
    193a:	40 a1       	ldd	r20, Z+32	; 0x20
    193c:	50 e0       	ldi	r21, 0x00	; 0
    193e:	26 81       	ldd	r18, Z+6	; 0x06
    1940:	37 81       	ldd	r19, Z+7	; 0x07
    1942:	24 0f       	add	r18, r20
    1944:	35 1f       	adc	r19, r21
    1946:	26 83       	std	Z+6, r18	; 0x06
    1948:	37 83       	std	Z+7, r19	; 0x07
    194a:	a2 81       	ldd	r26, Z+2	; 0x02
    194c:	b3 81       	ldd	r27, Z+3	; 0x03
    194e:	2a 17       	cp	r18, r26
    1950:	3b 07       	cpc	r19, r27
    1952:	10 f0       	brcs	.+4      	; 0x1958 <prvCopyDataFromQueue+0x28>
    1954:	86 83       	std	Z+6, r24	; 0x06
    1956:	97 83       	std	Z+7, r25	; 0x07
    1958:	cb 01       	movw	r24, r22
    195a:	66 81       	ldd	r22, Z+6	; 0x06
    195c:	77 81       	ldd	r23, Z+7	; 0x07
    195e:	0e 94 22 20 	call	0x4044	; 0x4044 <memcpy>
    1962:	08 95       	ret

00001964 <prvUnlockQueue>:
    1964:	0f 93       	push	r16
    1966:	1f 93       	push	r17
    1968:	cf 93       	push	r28
    196a:	df 93       	push	r29
    196c:	ec 01       	movw	r28, r24
    196e:	0f b6       	in	r0, 0x3f	; 63
    1970:	f8 94       	cli
    1972:	0f 92       	push	r0
    1974:	8a a1       	ldd	r24, Y+34	; 0x22
    1976:	18 16       	cp	r1, r24
    1978:	b4 f4       	brge	.+44     	; 0x19a6 <prvUnlockQueue+0x42>
    197a:	8b 89       	ldd	r24, Y+19	; 0x13
    197c:	81 11       	cpse	r24, r1
    197e:	05 c0       	rjmp	.+10     	; 0x198a <prvUnlockQueue+0x26>
    1980:	12 c0       	rjmp	.+36     	; 0x19a6 <prvUnlockQueue+0x42>
    1982:	8b 89       	ldd	r24, Y+19	; 0x13
    1984:	81 11       	cpse	r24, r1
    1986:	04 c0       	rjmp	.+8      	; 0x1990 <prvUnlockQueue+0x2c>
    1988:	0e c0       	rjmp	.+28     	; 0x19a6 <prvUnlockQueue+0x42>
    198a:	8e 01       	movw	r16, r28
    198c:	0d 5e       	subi	r16, 0xED	; 237
    198e:	1f 4f       	sbci	r17, 0xFF	; 255
    1990:	c8 01       	movw	r24, r16
    1992:	0e 94 2c 13 	call	0x2658	; 0x2658 <xTaskRemoveFromEventList>
    1996:	81 11       	cpse	r24, r1
    1998:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <vTaskMissedYield>
    199c:	8a a1       	ldd	r24, Y+34	; 0x22
    199e:	81 50       	subi	r24, 0x01	; 1
    19a0:	8a a3       	std	Y+34, r24	; 0x22
    19a2:	18 16       	cp	r1, r24
    19a4:	74 f3       	brlt	.-36     	; 0x1982 <prvUnlockQueue+0x1e>
    19a6:	8f ef       	ldi	r24, 0xFF	; 255
    19a8:	8a a3       	std	Y+34, r24	; 0x22
    19aa:	0f 90       	pop	r0
    19ac:	0f be       	out	0x3f, r0	; 63
    19ae:	0f b6       	in	r0, 0x3f	; 63
    19b0:	f8 94       	cli
    19b2:	0f 92       	push	r0
    19b4:	89 a1       	ldd	r24, Y+33	; 0x21
    19b6:	18 16       	cp	r1, r24
    19b8:	b4 f4       	brge	.+44     	; 0x19e6 <prvUnlockQueue+0x82>
    19ba:	88 85       	ldd	r24, Y+8	; 0x08
    19bc:	81 11       	cpse	r24, r1
    19be:	05 c0       	rjmp	.+10     	; 0x19ca <prvUnlockQueue+0x66>
    19c0:	12 c0       	rjmp	.+36     	; 0x19e6 <prvUnlockQueue+0x82>
    19c2:	88 85       	ldd	r24, Y+8	; 0x08
    19c4:	81 11       	cpse	r24, r1
    19c6:	04 c0       	rjmp	.+8      	; 0x19d0 <prvUnlockQueue+0x6c>
    19c8:	0e c0       	rjmp	.+28     	; 0x19e6 <prvUnlockQueue+0x82>
    19ca:	8e 01       	movw	r16, r28
    19cc:	08 5f       	subi	r16, 0xF8	; 248
    19ce:	1f 4f       	sbci	r17, 0xFF	; 255
    19d0:	c8 01       	movw	r24, r16
    19d2:	0e 94 2c 13 	call	0x2658	; 0x2658 <xTaskRemoveFromEventList>
    19d6:	81 11       	cpse	r24, r1
    19d8:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <vTaskMissedYield>
    19dc:	89 a1       	ldd	r24, Y+33	; 0x21
    19de:	81 50       	subi	r24, 0x01	; 1
    19e0:	89 a3       	std	Y+33, r24	; 0x21
    19e2:	18 16       	cp	r1, r24
    19e4:	74 f3       	brlt	.-36     	; 0x19c2 <prvUnlockQueue+0x5e>
    19e6:	8f ef       	ldi	r24, 0xFF	; 255
    19e8:	89 a3       	std	Y+33, r24	; 0x21
    19ea:	0f 90       	pop	r0
    19ec:	0f be       	out	0x3f, r0	; 63
    19ee:	df 91       	pop	r29
    19f0:	cf 91       	pop	r28
    19f2:	1f 91       	pop	r17
    19f4:	0f 91       	pop	r16
    19f6:	08 95       	ret

000019f8 <xQueueGenericReset>:
    19f8:	1f 93       	push	r17
    19fa:	cf 93       	push	r28
    19fc:	df 93       	push	r29
    19fe:	61 30       	cpi	r22, 0x01	; 1
    1a00:	59 f0       	breq	.+22     	; 0x1a18 <xQueueGenericReset+0x20>
    1a02:	fc 01       	movw	r30, r24
    1a04:	23 89       	ldd	r18, Z+19	; 0x13
    1a06:	30 85       	ldd	r19, Z+8	; 0x08
    1a08:	31 11       	cpse	r19, r1
    1a0a:	2c c0       	rjmp	.+88     	; 0x1a64 <xQueueGenericReset+0x6c>
    1a0c:	11 e0       	ldi	r17, 0x01	; 1
    1a0e:	21 11       	cpse	r18, r1
    1a10:	10 e0       	ldi	r17, 0x00	; 0
    1a12:	21 11       	cpse	r18, r1
    1a14:	28 c0       	rjmp	.+80     	; 0x1a66 <xQueueGenericReset+0x6e>
    1a16:	01 c0       	rjmp	.+2      	; 0x1a1a <xQueueGenericReset+0x22>
    1a18:	11 e0       	ldi	r17, 0x01	; 1
    1a1a:	ec 01       	movw	r28, r24
    1a1c:	48 81       	ld	r20, Y
    1a1e:	59 81       	ldd	r21, Y+1	; 0x01
    1a20:	28 a1       	ldd	r18, Y+32	; 0x20
    1a22:	30 e0       	ldi	r19, 0x00	; 0
    1a24:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a26:	62 9f       	mul	r22, r18
    1a28:	c0 01       	movw	r24, r0
    1a2a:	63 9f       	mul	r22, r19
    1a2c:	90 0d       	add	r25, r0
    1a2e:	11 24       	eor	r1, r1
    1a30:	ba 01       	movw	r22, r20
    1a32:	68 0f       	add	r22, r24
    1a34:	79 1f       	adc	r23, r25
    1a36:	6a 83       	std	Y+2, r22	; 0x02
    1a38:	7b 83       	std	Y+3, r23	; 0x03
    1a3a:	1e 8e       	std	Y+30, r1	; 0x1e
    1a3c:	4c 83       	std	Y+4, r20	; 0x04
    1a3e:	5d 83       	std	Y+5, r21	; 0x05
    1a40:	82 1b       	sub	r24, r18
    1a42:	93 0b       	sbc	r25, r19
    1a44:	84 0f       	add	r24, r20
    1a46:	95 1f       	adc	r25, r21
    1a48:	8e 83       	std	Y+6, r24	; 0x06
    1a4a:	9f 83       	std	Y+7, r25	; 0x07
    1a4c:	8f ef       	ldi	r24, 0xFF	; 255
    1a4e:	89 a3       	std	Y+33, r24	; 0x21
    1a50:	8a a3       	std	Y+34, r24	; 0x22
    1a52:	ce 01       	movw	r24, r28
    1a54:	08 96       	adiw	r24, 0x08	; 8
    1a56:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1a5a:	ce 01       	movw	r24, r28
    1a5c:	43 96       	adiw	r24, 0x13	; 19
    1a5e:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1a62:	01 c0       	rjmp	.+2      	; 0x1a66 <xQueueGenericReset+0x6e>
    1a64:	10 e0       	ldi	r17, 0x00	; 0
    1a66:	81 2f       	mov	r24, r17
    1a68:	df 91       	pop	r29
    1a6a:	cf 91       	pop	r28
    1a6c:	1f 91       	pop	r17
    1a6e:	08 95       	ret

00001a70 <xQueueGenericCreate>:
    1a70:	0f 93       	push	r16
    1a72:	1f 93       	push	r17
    1a74:	cf 93       	push	r28
    1a76:	df 93       	push	r29
    1a78:	88 23       	and	r24, r24
    1a7a:	01 f1       	breq	.+64     	; 0x1abc <xQueueGenericCreate+0x4c>
    1a7c:	06 2f       	mov	r16, r22
    1a7e:	18 2f       	mov	r17, r24
    1a80:	83 e2       	ldi	r24, 0x23	; 35
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	0e 94 52 09 	call	0x12a4	; 0x12a4 <pvPortMalloc>
    1a88:	ec 01       	movw	r28, r24
    1a8a:	89 2b       	or	r24, r25
    1a8c:	c9 f0       	breq	.+50     	; 0x1ac0 <xQueueGenericCreate+0x50>
    1a8e:	10 9f       	mul	r17, r16
    1a90:	c0 01       	movw	r24, r0
    1a92:	11 24       	eor	r1, r1
    1a94:	01 96       	adiw	r24, 0x01	; 1
    1a96:	0e 94 52 09 	call	0x12a4	; 0x12a4 <pvPortMalloc>
    1a9a:	88 83       	st	Y, r24
    1a9c:	99 83       	std	Y+1, r25	; 0x01
    1a9e:	89 2b       	or	r24, r25
    1aa0:	39 f0       	breq	.+14     	; 0x1ab0 <xQueueGenericCreate+0x40>
    1aa2:	1f 8f       	std	Y+31, r17	; 0x1f
    1aa4:	08 a3       	std	Y+32, r16	; 0x20
    1aa6:	61 e0       	ldi	r22, 0x01	; 1
    1aa8:	ce 01       	movw	r24, r28
    1aaa:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReset>
    1aae:	08 c0       	rjmp	.+16     	; 0x1ac0 <xQueueGenericCreate+0x50>
    1ab0:	ce 01       	movw	r24, r28
    1ab2:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <vPortFree>
    1ab6:	c0 e0       	ldi	r28, 0x00	; 0
    1ab8:	d0 e0       	ldi	r29, 0x00	; 0
    1aba:	02 c0       	rjmp	.+4      	; 0x1ac0 <xQueueGenericCreate+0x50>
    1abc:	c0 e0       	ldi	r28, 0x00	; 0
    1abe:	d0 e0       	ldi	r29, 0x00	; 0
    1ac0:	ce 01       	movw	r24, r28
    1ac2:	df 91       	pop	r29
    1ac4:	cf 91       	pop	r28
    1ac6:	1f 91       	pop	r17
    1ac8:	0f 91       	pop	r16
    1aca:	08 95       	ret

00001acc <xQueueGenericSend>:
    1acc:	af 92       	push	r10
    1ace:	bf 92       	push	r11
    1ad0:	cf 92       	push	r12
    1ad2:	df 92       	push	r13
    1ad4:	ef 92       	push	r14
    1ad6:	ff 92       	push	r15
    1ad8:	0f 93       	push	r16
    1ada:	1f 93       	push	r17
    1adc:	cf 93       	push	r28
    1ade:	df 93       	push	r29
    1ae0:	cd b7       	in	r28, 0x3d	; 61
    1ae2:	de b7       	in	r29, 0x3e	; 62
    1ae4:	29 97       	sbiw	r28, 0x09	; 9
    1ae6:	cd bf       	out	0x3d, r28	; 61
    1ae8:	de bf       	out	0x3e, r29	; 62
    1aea:	7c 01       	movw	r14, r24
    1aec:	5b 01       	movw	r10, r22
    1aee:	2e 83       	std	Y+6, r18	; 0x06
    1af0:	3f 83       	std	Y+7, r19	; 0x07
    1af2:	48 87       	std	Y+8, r20	; 0x08
    1af4:	59 87       	std	Y+9, r21	; 0x09
    1af6:	10 e0       	ldi	r17, 0x00	; 0
    1af8:	6c 01       	movw	r12, r24
    1afa:	88 e0       	ldi	r24, 0x08	; 8
    1afc:	c8 0e       	add	r12, r24
    1afe:	d1 1c       	adc	r13, r1
    1b00:	0f b6       	in	r0, 0x3f	; 63
    1b02:	f8 94       	cli
    1b04:	0f 92       	push	r0
    1b06:	f7 01       	movw	r30, r14
    1b08:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b0a:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b0c:	98 17       	cp	r25, r24
    1b0e:	a8 f4       	brcc	.+42     	; 0x1b3a <xQueueGenericSend+0x6e>
    1b10:	40 2f       	mov	r20, r16
    1b12:	b5 01       	movw	r22, r10
    1b14:	c7 01       	movw	r24, r14
    1b16:	0e 94 4c 0c 	call	0x1898	; 0x1898 <prvCopyDataToQueue>
    1b1a:	f7 01       	movw	r30, r14
    1b1c:	83 89       	ldd	r24, Z+19	; 0x13
    1b1e:	88 23       	and	r24, r24
    1b20:	41 f0       	breq	.+16     	; 0x1b32 <xQueueGenericSend+0x66>
    1b22:	c7 01       	movw	r24, r14
    1b24:	43 96       	adiw	r24, 0x13	; 19
    1b26:	0e 94 2c 13 	call	0x2658	; 0x2658 <xTaskRemoveFromEventList>
    1b2a:	81 30       	cpi	r24, 0x01	; 1
    1b2c:	11 f4       	brne	.+4      	; 0x1b32 <xQueueGenericSend+0x66>
    1b2e:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
    1b32:	0f 90       	pop	r0
    1b34:	0f be       	out	0x3f, r0	; 63
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	56 c0       	rjmp	.+172    	; 0x1be6 <xQueueGenericSend+0x11a>
    1b3a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b3c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b3e:	a8 85       	ldd	r26, Y+8	; 0x08
    1b40:	b9 85       	ldd	r27, Y+9	; 0x09
    1b42:	89 2b       	or	r24, r25
    1b44:	8a 2b       	or	r24, r26
    1b46:	8b 2b       	or	r24, r27
    1b48:	21 f4       	brne	.+8      	; 0x1b52 <xQueueGenericSend+0x86>
    1b4a:	0f 90       	pop	r0
    1b4c:	0f be       	out	0x3f, r0	; 63
    1b4e:	80 e0       	ldi	r24, 0x00	; 0
    1b50:	4a c0       	rjmp	.+148    	; 0x1be6 <xQueueGenericSend+0x11a>
    1b52:	11 11       	cpse	r17, r1
    1b54:	05 c0       	rjmp	.+10     	; 0x1b60 <xQueueGenericSend+0x94>
    1b56:	ce 01       	movw	r24, r28
    1b58:	01 96       	adiw	r24, 0x01	; 1
    1b5a:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <vTaskSetTimeOutState>
    1b5e:	11 e0       	ldi	r17, 0x01	; 1
    1b60:	0f 90       	pop	r0
    1b62:	0f be       	out	0x3f, r0	; 63
    1b64:	0e 94 66 10 	call	0x20cc	; 0x20cc <vTaskSuspendAll>
    1b68:	0f b6       	in	r0, 0x3f	; 63
    1b6a:	f8 94       	cli
    1b6c:	0f 92       	push	r0
    1b6e:	f7 01       	movw	r30, r14
    1b70:	81 a1       	ldd	r24, Z+33	; 0x21
    1b72:	8f 3f       	cpi	r24, 0xFF	; 255
    1b74:	09 f4       	brne	.+2      	; 0x1b78 <xQueueGenericSend+0xac>
    1b76:	11 a2       	std	Z+33, r1	; 0x21
    1b78:	f7 01       	movw	r30, r14
    1b7a:	82 a1       	ldd	r24, Z+34	; 0x22
    1b7c:	8f 3f       	cpi	r24, 0xFF	; 255
    1b7e:	09 f4       	brne	.+2      	; 0x1b82 <xQueueGenericSend+0xb6>
    1b80:	12 a2       	std	Z+34, r1	; 0x22
    1b82:	0f 90       	pop	r0
    1b84:	0f be       	out	0x3f, r0	; 63
    1b86:	be 01       	movw	r22, r28
    1b88:	6a 5f       	subi	r22, 0xFA	; 250
    1b8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b8c:	ce 01       	movw	r24, r28
    1b8e:	01 96       	adiw	r24, 0x01	; 1
    1b90:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <xTaskCheckForTimeOut>
    1b94:	81 11       	cpse	r24, r1
    1b96:	21 c0       	rjmp	.+66     	; 0x1bda <xQueueGenericSend+0x10e>
    1b98:	0f b6       	in	r0, 0x3f	; 63
    1b9a:	f8 94       	cli
    1b9c:	0f 92       	push	r0
    1b9e:	f7 01       	movw	r30, r14
    1ba0:	96 8d       	ldd	r25, Z+30	; 0x1e
    1ba2:	0f 90       	pop	r0
    1ba4:	0f be       	out	0x3f, r0	; 63
    1ba6:	87 8d       	ldd	r24, Z+31	; 0x1f
    1ba8:	98 13       	cpse	r25, r24
    1baa:	11 c0       	rjmp	.+34     	; 0x1bce <xQueueGenericSend+0x102>
    1bac:	4e 81       	ldd	r20, Y+6	; 0x06
    1bae:	5f 81       	ldd	r21, Y+7	; 0x07
    1bb0:	68 85       	ldd	r22, Y+8	; 0x08
    1bb2:	79 85       	ldd	r23, Y+9	; 0x09
    1bb4:	c6 01       	movw	r24, r12
    1bb6:	0e 94 02 13 	call	0x2604	; 0x2604 <vTaskPlaceOnEventList>
    1bba:	c7 01       	movw	r24, r14
    1bbc:	0e 94 b2 0c 	call	0x1964	; 0x1964 <prvUnlockQueue>
    1bc0:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
    1bc4:	81 11       	cpse	r24, r1
    1bc6:	9c cf       	rjmp	.-200    	; 0x1b00 <xQueueGenericSend+0x34>
    1bc8:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
    1bcc:	99 cf       	rjmp	.-206    	; 0x1b00 <xQueueGenericSend+0x34>
    1bce:	c7 01       	movw	r24, r14
    1bd0:	0e 94 b2 0c 	call	0x1964	; 0x1964 <prvUnlockQueue>
    1bd4:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
    1bd8:	93 cf       	rjmp	.-218    	; 0x1b00 <xQueueGenericSend+0x34>
    1bda:	c7 01       	movw	r24, r14
    1bdc:	0e 94 b2 0c 	call	0x1964	; 0x1964 <prvUnlockQueue>
    1be0:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
    1be4:	80 e0       	ldi	r24, 0x00	; 0
    1be6:	29 96       	adiw	r28, 0x09	; 9
    1be8:	cd bf       	out	0x3d, r28	; 61
    1bea:	de bf       	out	0x3e, r29	; 62
    1bec:	df 91       	pop	r29
    1bee:	cf 91       	pop	r28
    1bf0:	1f 91       	pop	r17
    1bf2:	0f 91       	pop	r16
    1bf4:	ff 90       	pop	r15
    1bf6:	ef 90       	pop	r14
    1bf8:	df 90       	pop	r13
    1bfa:	cf 90       	pop	r12
    1bfc:	bf 90       	pop	r11
    1bfe:	af 90       	pop	r10
    1c00:	08 95       	ret

00001c02 <xQueueGenericReceive>:
    1c02:	af 92       	push	r10
    1c04:	bf 92       	push	r11
    1c06:	cf 92       	push	r12
    1c08:	df 92       	push	r13
    1c0a:	ef 92       	push	r14
    1c0c:	ff 92       	push	r15
    1c0e:	0f 93       	push	r16
    1c10:	1f 93       	push	r17
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	cd b7       	in	r28, 0x3d	; 61
    1c18:	de b7       	in	r29, 0x3e	; 62
    1c1a:	29 97       	sbiw	r28, 0x09	; 9
    1c1c:	cd bf       	out	0x3d, r28	; 61
    1c1e:	de bf       	out	0x3e, r29	; 62
    1c20:	7c 01       	movw	r14, r24
    1c22:	5b 01       	movw	r10, r22
    1c24:	2e 83       	std	Y+6, r18	; 0x06
    1c26:	3f 83       	std	Y+7, r19	; 0x07
    1c28:	48 87       	std	Y+8, r20	; 0x08
    1c2a:	59 87       	std	Y+9, r21	; 0x09
    1c2c:	10 e0       	ldi	r17, 0x00	; 0
    1c2e:	6c 01       	movw	r12, r24
    1c30:	83 e1       	ldi	r24, 0x13	; 19
    1c32:	c8 0e       	add	r12, r24
    1c34:	d1 1c       	adc	r13, r1
    1c36:	0f b6       	in	r0, 0x3f	; 63
    1c38:	f8 94       	cli
    1c3a:	0f 92       	push	r0
    1c3c:	f7 01       	movw	r30, r14
    1c3e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c40:	88 23       	and	r24, r24
    1c42:	99 f1       	breq	.+102    	; 0x1caa <xQueueGenericReceive+0xa8>
    1c44:	c6 80       	ldd	r12, Z+6	; 0x06
    1c46:	d7 80       	ldd	r13, Z+7	; 0x07
    1c48:	b5 01       	movw	r22, r10
    1c4a:	c7 01       	movw	r24, r14
    1c4c:	0e 94 98 0c 	call	0x1930	; 0x1930 <prvCopyDataFromQueue>
    1c50:	01 11       	cpse	r16, r1
    1c52:	1a c0       	rjmp	.+52     	; 0x1c88 <xQueueGenericReceive+0x86>
    1c54:	f7 01       	movw	r30, r14
    1c56:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c58:	81 50       	subi	r24, 0x01	; 1
    1c5a:	86 8f       	std	Z+30, r24	; 0x1e
    1c5c:	80 81       	ld	r24, Z
    1c5e:	91 81       	ldd	r25, Z+1	; 0x01
    1c60:	89 2b       	or	r24, r25
    1c62:	29 f4       	brne	.+10     	; 0x1c6e <xQueueGenericReceive+0x6c>
    1c64:	0e 94 06 14 	call	0x280c	; 0x280c <xTaskGetCurrentTaskHandle>
    1c68:	f7 01       	movw	r30, r14
    1c6a:	82 83       	std	Z+2, r24	; 0x02
    1c6c:	93 83       	std	Z+3, r25	; 0x03
    1c6e:	f7 01       	movw	r30, r14
    1c70:	80 85       	ldd	r24, Z+8	; 0x08
    1c72:	88 23       	and	r24, r24
    1c74:	b1 f0       	breq	.+44     	; 0x1ca2 <xQueueGenericReceive+0xa0>
    1c76:	c7 01       	movw	r24, r14
    1c78:	08 96       	adiw	r24, 0x08	; 8
    1c7a:	0e 94 2c 13 	call	0x2658	; 0x2658 <xTaskRemoveFromEventList>
    1c7e:	81 30       	cpi	r24, 0x01	; 1
    1c80:	81 f4       	brne	.+32     	; 0x1ca2 <xQueueGenericReceive+0xa0>
    1c82:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
    1c86:	0d c0       	rjmp	.+26     	; 0x1ca2 <xQueueGenericReceive+0xa0>
    1c88:	f7 01       	movw	r30, r14
    1c8a:	c6 82       	std	Z+6, r12	; 0x06
    1c8c:	d7 82       	std	Z+7, r13	; 0x07
    1c8e:	83 89       	ldd	r24, Z+19	; 0x13
    1c90:	88 23       	and	r24, r24
    1c92:	39 f0       	breq	.+14     	; 0x1ca2 <xQueueGenericReceive+0xa0>
    1c94:	c7 01       	movw	r24, r14
    1c96:	43 96       	adiw	r24, 0x13	; 19
    1c98:	0e 94 2c 13 	call	0x2658	; 0x2658 <xTaskRemoveFromEventList>
    1c9c:	81 11       	cpse	r24, r1
    1c9e:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
    1ca2:	0f 90       	pop	r0
    1ca4:	0f be       	out	0x3f, r0	; 63
    1ca6:	81 e0       	ldi	r24, 0x01	; 1
    1ca8:	62 c0       	rjmp	.+196    	; 0x1d6e <xQueueGenericReceive+0x16c>
    1caa:	8e 81       	ldd	r24, Y+6	; 0x06
    1cac:	9f 81       	ldd	r25, Y+7	; 0x07
    1cae:	a8 85       	ldd	r26, Y+8	; 0x08
    1cb0:	b9 85       	ldd	r27, Y+9	; 0x09
    1cb2:	89 2b       	or	r24, r25
    1cb4:	8a 2b       	or	r24, r26
    1cb6:	8b 2b       	or	r24, r27
    1cb8:	21 f4       	brne	.+8      	; 0x1cc2 <xQueueGenericReceive+0xc0>
    1cba:	0f 90       	pop	r0
    1cbc:	0f be       	out	0x3f, r0	; 63
    1cbe:	80 e0       	ldi	r24, 0x00	; 0
    1cc0:	56 c0       	rjmp	.+172    	; 0x1d6e <xQueueGenericReceive+0x16c>
    1cc2:	11 11       	cpse	r17, r1
    1cc4:	05 c0       	rjmp	.+10     	; 0x1cd0 <xQueueGenericReceive+0xce>
    1cc6:	ce 01       	movw	r24, r28
    1cc8:	01 96       	adiw	r24, 0x01	; 1
    1cca:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <vTaskSetTimeOutState>
    1cce:	11 e0       	ldi	r17, 0x01	; 1
    1cd0:	0f 90       	pop	r0
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	0e 94 66 10 	call	0x20cc	; 0x20cc <vTaskSuspendAll>
    1cd8:	0f b6       	in	r0, 0x3f	; 63
    1cda:	f8 94       	cli
    1cdc:	0f 92       	push	r0
    1cde:	f7 01       	movw	r30, r14
    1ce0:	81 a1       	ldd	r24, Z+33	; 0x21
    1ce2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce4:	09 f4       	brne	.+2      	; 0x1ce8 <xQueueGenericReceive+0xe6>
    1ce6:	11 a2       	std	Z+33, r1	; 0x21
    1ce8:	f7 01       	movw	r30, r14
    1cea:	82 a1       	ldd	r24, Z+34	; 0x22
    1cec:	8f 3f       	cpi	r24, 0xFF	; 255
    1cee:	09 f4       	brne	.+2      	; 0x1cf2 <xQueueGenericReceive+0xf0>
    1cf0:	12 a2       	std	Z+34, r1	; 0x22
    1cf2:	0f 90       	pop	r0
    1cf4:	0f be       	out	0x3f, r0	; 63
    1cf6:	be 01       	movw	r22, r28
    1cf8:	6a 5f       	subi	r22, 0xFA	; 250
    1cfa:	7f 4f       	sbci	r23, 0xFF	; 255
    1cfc:	ce 01       	movw	r24, r28
    1cfe:	01 96       	adiw	r24, 0x01	; 1
    1d00:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <xTaskCheckForTimeOut>
    1d04:	81 11       	cpse	r24, r1
    1d06:	2d c0       	rjmp	.+90     	; 0x1d62 <xQueueGenericReceive+0x160>
    1d08:	0f b6       	in	r0, 0x3f	; 63
    1d0a:	f8 94       	cli
    1d0c:	0f 92       	push	r0
    1d0e:	f7 01       	movw	r30, r14
    1d10:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d12:	0f 90       	pop	r0
    1d14:	0f be       	out	0x3f, r0	; 63
    1d16:	81 11       	cpse	r24, r1
    1d18:	1e c0       	rjmp	.+60     	; 0x1d56 <xQueueGenericReceive+0x154>
    1d1a:	80 81       	ld	r24, Z
    1d1c:	91 81       	ldd	r25, Z+1	; 0x01
    1d1e:	89 2b       	or	r24, r25
    1d20:	49 f4       	brne	.+18     	; 0x1d34 <xQueueGenericReceive+0x132>
    1d22:	0f b6       	in	r0, 0x3f	; 63
    1d24:	f8 94       	cli
    1d26:	0f 92       	push	r0
    1d28:	82 81       	ldd	r24, Z+2	; 0x02
    1d2a:	93 81       	ldd	r25, Z+3	; 0x03
    1d2c:	0e 94 0b 14 	call	0x2816	; 0x2816 <vTaskPriorityInherit>
    1d30:	0f 90       	pop	r0
    1d32:	0f be       	out	0x3f, r0	; 63
    1d34:	4e 81       	ldd	r20, Y+6	; 0x06
    1d36:	5f 81       	ldd	r21, Y+7	; 0x07
    1d38:	68 85       	ldd	r22, Y+8	; 0x08
    1d3a:	79 85       	ldd	r23, Y+9	; 0x09
    1d3c:	c6 01       	movw	r24, r12
    1d3e:	0e 94 02 13 	call	0x2604	; 0x2604 <vTaskPlaceOnEventList>
    1d42:	c7 01       	movw	r24, r14
    1d44:	0e 94 b2 0c 	call	0x1964	; 0x1964 <prvUnlockQueue>
    1d48:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
    1d4c:	81 11       	cpse	r24, r1
    1d4e:	73 cf       	rjmp	.-282    	; 0x1c36 <xQueueGenericReceive+0x34>
    1d50:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
    1d54:	70 cf       	rjmp	.-288    	; 0x1c36 <xQueueGenericReceive+0x34>
    1d56:	c7 01       	movw	r24, r14
    1d58:	0e 94 b2 0c 	call	0x1964	; 0x1964 <prvUnlockQueue>
    1d5c:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
    1d60:	6a cf       	rjmp	.-300    	; 0x1c36 <xQueueGenericReceive+0x34>
    1d62:	c7 01       	movw	r24, r14
    1d64:	0e 94 b2 0c 	call	0x1964	; 0x1964 <prvUnlockQueue>
    1d68:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
    1d6c:	80 e0       	ldi	r24, 0x00	; 0
    1d6e:	29 96       	adiw	r28, 0x09	; 9
    1d70:	cd bf       	out	0x3d, r28	; 61
    1d72:	de bf       	out	0x3e, r29	; 62
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	1f 91       	pop	r17
    1d7a:	0f 91       	pop	r16
    1d7c:	ff 90       	pop	r15
    1d7e:	ef 90       	pop	r14
    1d80:	df 90       	pop	r13
    1d82:	cf 90       	pop	r12
    1d84:	bf 90       	pop	r11
    1d86:	af 90       	pop	r10
    1d88:	08 95       	ret

00001d8a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d8a:	0f b6       	in	r0, 0x3f	; 63
    1d8c:	f8 94       	cli
    1d8e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d90:	fc 01       	movw	r30, r24
    1d92:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d94:	0f 90       	pop	r0
    1d96:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d98:	08 95       	ret

00001d9a <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d9a:	c2 e3       	ldi	r28, 0x32	; 50
    1d9c:	d1 e3       	ldi	r29, 0x31	; 49
    1d9e:	88 81       	ld	r24, Y
    1da0:	82 30       	cpi	r24, 0x02	; 2
    1da2:	e8 f3       	brcs	.-6      	; 0x1d9e <prvIdleTask+0x4>
    1da4:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
    1da8:	fa cf       	rjmp	.-12     	; 0x1d9e <prvIdleTask+0x4>

00001daa <prvAddCurrentTaskToDelayedList>:
    1daa:	cf 92       	push	r12
    1dac:	df 92       	push	r13
    1dae:	ef 92       	push	r14
    1db0:	ff 92       	push	r15
    1db2:	6b 01       	movw	r12, r22
    1db4:	7c 01       	movw	r14, r24
    1db6:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <pxCurrentTCB>
    1dba:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    1dbe:	62 83       	std	Z+2, r22	; 0x02
    1dc0:	73 83       	std	Z+3, r23	; 0x03
    1dc2:	84 83       	std	Z+4, r24	; 0x04
    1dc4:	95 83       	std	Z+5, r25	; 0x05
    1dc6:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    1dca:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    1dce:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    1dd2:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
    1dd6:	c8 16       	cp	r12, r24
    1dd8:	d9 06       	cpc	r13, r25
    1dda:	ea 06       	cpc	r14, r26
    1ddc:	fb 06       	cpc	r15, r27
    1dde:	68 f4       	brcc	.+26     	; 0x1dfa <prvAddCurrentTaskToDelayedList+0x50>
    1de0:	60 91 5e 31 	lds	r22, 0x315E	; 0x80315e <pxCurrentTCB>
    1de4:	70 91 5f 31 	lds	r23, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    1de8:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxOverflowDelayedTaskList>
    1dec:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxOverflowDelayedTaskList+0x1>
    1df0:	6e 5f       	subi	r22, 0xFE	; 254
    1df2:	7f 4f       	sbci	r23, 0xFF	; 255
    1df4:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <vListInsert>
    1df8:	21 c0       	rjmp	.+66     	; 0x1e3c <prvAddCurrentTaskToDelayedList+0x92>
    1dfa:	60 91 5e 31 	lds	r22, 0x315E	; 0x80315e <pxCurrentTCB>
    1dfe:	70 91 5f 31 	lds	r23, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    1e02:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <pxDelayedTaskList>
    1e06:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <pxDelayedTaskList+0x1>
    1e0a:	6e 5f       	subi	r22, 0xFE	; 254
    1e0c:	7f 4f       	sbci	r23, 0xFF	; 255
    1e0e:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <vListInsert>
    1e12:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e16:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e1a:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e1e:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e22:	c8 16       	cp	r12, r24
    1e24:	d9 06       	cpc	r13, r25
    1e26:	ea 06       	cpc	r14, r26
    1e28:	fb 06       	cpc	r15, r27
    1e2a:	40 f4       	brcc	.+16     	; 0x1e3c <prvAddCurrentTaskToDelayedList+0x92>
    1e2c:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e30:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e34:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e38:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e3c:	ff 90       	pop	r15
    1e3e:	ef 90       	pop	r14
    1e40:	df 90       	pop	r13
    1e42:	cf 90       	pop	r12
    1e44:	08 95       	ret

00001e46 <xTaskGenericCreate>:
    1e46:	4f 92       	push	r4
    1e48:	5f 92       	push	r5
    1e4a:	6f 92       	push	r6
    1e4c:	7f 92       	push	r7
    1e4e:	8f 92       	push	r8
    1e50:	9f 92       	push	r9
    1e52:	af 92       	push	r10
    1e54:	bf 92       	push	r11
    1e56:	cf 92       	push	r12
    1e58:	df 92       	push	r13
    1e5a:	ef 92       	push	r14
    1e5c:	ff 92       	push	r15
    1e5e:	0f 93       	push	r16
    1e60:	1f 93       	push	r17
    1e62:	cf 93       	push	r28
    1e64:	df 93       	push	r29
    1e66:	5c 01       	movw	r10, r24
    1e68:	4b 01       	movw	r8, r22
    1e6a:	3a 01       	movw	r6, r20
    1e6c:	29 01       	movw	r4, r18
    1e6e:	88 e2       	ldi	r24, 0x28	; 40
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	0e 94 52 09 	call	0x12a4	; 0x12a4 <pvPortMalloc>
    1e76:	ec 01       	movw	r28, r24
    1e78:	89 2b       	or	r24, r25
    1e7a:	09 f4       	brne	.+2      	; 0x1e7e <xTaskGenericCreate+0x38>
    1e7c:	d4 c0       	rjmp	.+424    	; 0x2026 <xTaskGenericCreate+0x1e0>
    1e7e:	c1 14       	cp	r12, r1
    1e80:	d1 04       	cpc	r13, r1
    1e82:	09 f0       	breq	.+2      	; 0x1e86 <xTaskGenericCreate+0x40>
    1e84:	cc c0       	rjmp	.+408    	; 0x201e <xTaskGenericCreate+0x1d8>
    1e86:	c3 01       	movw	r24, r6
    1e88:	0e 94 52 09 	call	0x12a4	; 0x12a4 <pvPortMalloc>
    1e8c:	8b 8f       	std	Y+27, r24	; 0x1b
    1e8e:	9c 8f       	std	Y+28, r25	; 0x1c
    1e90:	00 97       	sbiw	r24, 0x00	; 0
    1e92:	21 f4       	brne	.+8      	; 0x1e9c <xTaskGenericCreate+0x56>
    1e94:	ce 01       	movw	r24, r28
    1e96:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <vPortFree>
    1e9a:	c5 c0       	rjmp	.+394    	; 0x2026 <xTaskGenericCreate+0x1e0>
    1e9c:	a3 01       	movw	r20, r6
    1e9e:	61 e1       	ldi	r22, 0x11	; 17
    1ea0:	70 e0       	ldi	r23, 0x00	; 0
    1ea2:	0e 94 2b 20 	call	0x4056	; 0x4056 <memset>
    1ea6:	93 01       	movw	r18, r6
    1ea8:	21 50       	subi	r18, 0x01	; 1
    1eaa:	31 09       	sbc	r19, r1
    1eac:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1eae:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1eb0:	3c 01       	movw	r6, r24
    1eb2:	62 0e       	add	r6, r18
    1eb4:	73 1e       	adc	r7, r19
    1eb6:	4a e0       	ldi	r20, 0x0A	; 10
    1eb8:	50 e0       	ldi	r21, 0x00	; 0
    1eba:	b4 01       	movw	r22, r8
    1ebc:	ce 01       	movw	r24, r28
    1ebe:	4d 96       	adiw	r24, 0x1d	; 29
    1ec0:	0e 94 32 20 	call	0x4064	; 0x4064 <strncpy>
    1ec4:	1e a2       	std	Y+38, r1	; 0x26
    1ec6:	10 2f       	mov	r17, r16
    1ec8:	04 30       	cpi	r16, 0x04	; 4
    1eca:	08 f0       	brcs	.+2      	; 0x1ece <xTaskGenericCreate+0x88>
    1ecc:	13 e0       	ldi	r17, 0x03	; 3
    1ece:	1a 8f       	std	Y+26, r17	; 0x1a
    1ed0:	1f a3       	std	Y+39, r17	; 0x27
    1ed2:	6e 01       	movw	r12, r28
    1ed4:	22 e0       	ldi	r18, 0x02	; 2
    1ed6:	c2 0e       	add	r12, r18
    1ed8:	d1 1c       	adc	r13, r1
    1eda:	c6 01       	movw	r24, r12
    1edc:	0e 94 35 0a 	call	0x146a	; 0x146a <vListInitialiseItem>
    1ee0:	ce 01       	movw	r24, r28
    1ee2:	0e 96       	adiw	r24, 0x0e	; 14
    1ee4:	0e 94 35 0a 	call	0x146a	; 0x146a <vListInitialiseItem>
    1ee8:	ca 87       	std	Y+10, r28	; 0x0a
    1eea:	db 87       	std	Y+11, r29	; 0x0b
    1eec:	84 e0       	ldi	r24, 0x04	; 4
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	a0 e0       	ldi	r26, 0x00	; 0
    1ef2:	b0 e0       	ldi	r27, 0x00	; 0
    1ef4:	81 1b       	sub	r24, r17
    1ef6:	91 09       	sbc	r25, r1
    1ef8:	a1 09       	sbc	r26, r1
    1efa:	b1 09       	sbc	r27, r1
    1efc:	8e 87       	std	Y+14, r24	; 0x0e
    1efe:	9f 87       	std	Y+15, r25	; 0x0f
    1f00:	a8 8b       	std	Y+16, r26	; 0x10
    1f02:	b9 8b       	std	Y+17, r27	; 0x11
    1f04:	ce 8b       	std	Y+22, r28	; 0x16
    1f06:	df 8b       	std	Y+23, r29	; 0x17
    1f08:	a2 01       	movw	r20, r4
    1f0a:	b5 01       	movw	r22, r10
    1f0c:	c3 01       	movw	r24, r6
    1f0e:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <pxPortInitialiseStack>
    1f12:	88 83       	st	Y, r24
    1f14:	99 83       	std	Y+1, r25	; 0x01
    1f16:	e1 14       	cp	r14, r1
    1f18:	f1 04       	cpc	r15, r1
    1f1a:	19 f0       	breq	.+6      	; 0x1f22 <xTaskGenericCreate+0xdc>
    1f1c:	f7 01       	movw	r30, r14
    1f1e:	c0 83       	st	Z, r28
    1f20:	d1 83       	std	Z+1, r29	; 0x01
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	0f 92       	push	r0
    1f28:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <uxCurrentNumberOfTasks>
    1f2c:	8f 5f       	subi	r24, 0xFF	; 255
    1f2e:	80 93 0a 31 	sts	0x310A, r24	; 0x80310a <uxCurrentNumberOfTasks>
    1f32:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <pxCurrentTCB>
    1f36:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    1f3a:	89 2b       	or	r24, r25
    1f3c:	89 f5       	brne	.+98     	; 0x1fa0 <xTaskGenericCreate+0x15a>
    1f3e:	c0 93 5e 31 	sts	0x315E, r28	; 0x80315e <pxCurrentTCB>
    1f42:	d0 93 5f 31 	sts	0x315F, r29	; 0x80315f <pxCurrentTCB+0x1>
    1f46:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <uxCurrentNumberOfTasks>
    1f4a:	81 30       	cpi	r24, 0x01	; 1
    1f4c:	c1 f5       	brne	.+112    	; 0x1fbe <xTaskGenericCreate+0x178>
    1f4e:	82 e3       	ldi	r24, 0x32	; 50
    1f50:	91 e3       	ldi	r25, 0x31	; 49
    1f52:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1f56:	8d e3       	ldi	r24, 0x3D	; 61
    1f58:	91 e3       	ldi	r25, 0x31	; 49
    1f5a:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1f5e:	88 e4       	ldi	r24, 0x48	; 72
    1f60:	91 e3       	ldi	r25, 0x31	; 49
    1f62:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1f66:	83 e5       	ldi	r24, 0x53	; 83
    1f68:	91 e3       	ldi	r25, 0x31	; 49
    1f6a:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1f6e:	87 e2       	ldi	r24, 0x27	; 39
    1f70:	91 e3       	ldi	r25, 0x31	; 49
    1f72:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1f76:	8c e1       	ldi	r24, 0x1C	; 28
    1f78:	91 e3       	ldi	r25, 0x31	; 49
    1f7a:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1f7e:	8d e0       	ldi	r24, 0x0D	; 13
    1f80:	91 e3       	ldi	r25, 0x31	; 49
    1f82:	0e 94 24 0a 	call	0x1448	; 0x1448 <vListInitialise>
    1f86:	87 e2       	ldi	r24, 0x27	; 39
    1f88:	91 e3       	ldi	r25, 0x31	; 49
    1f8a:	80 93 1a 31 	sts	0x311A, r24	; 0x80311a <pxDelayedTaskList>
    1f8e:	90 93 1b 31 	sts	0x311B, r25	; 0x80311b <pxDelayedTaskList+0x1>
    1f92:	8c e1       	ldi	r24, 0x1C	; 28
    1f94:	91 e3       	ldi	r25, 0x31	; 49
    1f96:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <pxOverflowDelayedTaskList>
    1f9a:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <pxOverflowDelayedTaskList+0x1>
    1f9e:	0f c0       	rjmp	.+30     	; 0x1fbe <xTaskGenericCreate+0x178>
    1fa0:	80 91 03 31 	lds	r24, 0x3103	; 0x803103 <xSchedulerRunning>
    1fa4:	81 11       	cpse	r24, r1
    1fa6:	0b c0       	rjmp	.+22     	; 0x1fbe <xTaskGenericCreate+0x178>
    1fa8:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <pxCurrentTCB>
    1fac:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    1fb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb2:	08 17       	cp	r16, r24
    1fb4:	20 f0       	brcs	.+8      	; 0x1fbe <xTaskGenericCreate+0x178>
    1fb6:	c0 93 5e 31 	sts	0x315E, r28	; 0x80315e <pxCurrentTCB>
    1fba:	d0 93 5f 31 	sts	0x315F, r29	; 0x80315f <pxCurrentTCB+0x1>
    1fbe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fc0:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <uxTopUsedPriority>
    1fc4:	98 17       	cp	r25, r24
    1fc6:	10 f4       	brcc	.+4      	; 0x1fcc <xTaskGenericCreate+0x186>
    1fc8:	80 93 05 31 	sts	0x3105, r24	; 0x803105 <uxTopUsedPriority>
    1fcc:	90 91 fe 30 	lds	r25, 0x30FE	; 0x8030fe <uxTaskNumber>
    1fd0:	9f 5f       	subi	r25, 0xFF	; 255
    1fd2:	90 93 fe 30 	sts	0x30FE, r25	; 0x8030fe <uxTaskNumber>
    1fd6:	90 91 04 31 	lds	r25, 0x3104	; 0x803104 <uxTopReadyPriority>
    1fda:	98 17       	cp	r25, r24
    1fdc:	10 f4       	brcc	.+4      	; 0x1fe2 <xTaskGenericCreate+0x19c>
    1fde:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <uxTopReadyPriority>
    1fe2:	fb e0       	ldi	r31, 0x0B	; 11
    1fe4:	8f 9f       	mul	r24, r31
    1fe6:	c0 01       	movw	r24, r0
    1fe8:	11 24       	eor	r1, r1
    1fea:	b6 01       	movw	r22, r12
    1fec:	8e 5c       	subi	r24, 0xCE	; 206
    1fee:	9e 4c       	sbci	r25, 0xCE	; 206
    1ff0:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInsertEnd>
    1ff4:	0f 90       	pop	r0
    1ff6:	0f be       	out	0x3f, r0	; 63
    1ff8:	80 91 03 31 	lds	r24, 0x3103	; 0x803103 <xSchedulerRunning>
    1ffc:	88 23       	and	r24, r24
    1ffe:	59 f0       	breq	.+22     	; 0x2016 <xTaskGenericCreate+0x1d0>
    2000:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <pxCurrentTCB>
    2004:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    2008:	82 8d       	ldd	r24, Z+26	; 0x1a
    200a:	80 17       	cp	r24, r16
    200c:	30 f4       	brcc	.+12     	; 0x201a <xTaskGenericCreate+0x1d4>
    200e:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
    2012:	81 e0       	ldi	r24, 0x01	; 1
    2014:	09 c0       	rjmp	.+18     	; 0x2028 <xTaskGenericCreate+0x1e2>
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	07 c0       	rjmp	.+14     	; 0x2028 <xTaskGenericCreate+0x1e2>
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	05 c0       	rjmp	.+10     	; 0x2028 <xTaskGenericCreate+0x1e2>
    201e:	cb 8e       	std	Y+27, r12	; 0x1b
    2020:	dc 8e       	std	Y+28, r13	; 0x1c
    2022:	c6 01       	movw	r24, r12
    2024:	3b cf       	rjmp	.-394    	; 0x1e9c <xTaskGenericCreate+0x56>
    2026:	8f ef       	ldi	r24, 0xFF	; 255
    2028:	df 91       	pop	r29
    202a:	cf 91       	pop	r28
    202c:	1f 91       	pop	r17
    202e:	0f 91       	pop	r16
    2030:	ff 90       	pop	r15
    2032:	ef 90       	pop	r14
    2034:	df 90       	pop	r13
    2036:	cf 90       	pop	r12
    2038:	bf 90       	pop	r11
    203a:	af 90       	pop	r10
    203c:	9f 90       	pop	r9
    203e:	8f 90       	pop	r8
    2040:	7f 90       	pop	r7
    2042:	6f 90       	pop	r6
    2044:	5f 90       	pop	r5
    2046:	4f 90       	pop	r4
    2048:	08 95       	ret

0000204a <uxTaskPriorityGet>:
    204a:	0f b6       	in	r0, 0x3f	; 63
    204c:	f8 94       	cli
    204e:	0f 92       	push	r0
    2050:	00 97       	sbiw	r24, 0x00	; 0
    2052:	21 f4       	brne	.+8      	; 0x205c <uxTaskPriorityGet+0x12>
    2054:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <pxCurrentTCB>
    2058:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    205c:	0f 90       	pop	r0
    205e:	0f be       	out	0x3f, r0	; 63
    2060:	fc 01       	movw	r30, r24
    2062:	82 8d       	ldd	r24, Z+26	; 0x1a
    2064:	08 95       	ret

00002066 <vTaskStartScheduler>:
    2066:	af 92       	push	r10
    2068:	bf 92       	push	r11
    206a:	cf 92       	push	r12
    206c:	df 92       	push	r13
    206e:	ef 92       	push	r14
    2070:	ff 92       	push	r15
    2072:	0f 93       	push	r16
    2074:	a1 2c       	mov	r10, r1
    2076:	b1 2c       	mov	r11, r1
    2078:	c1 2c       	mov	r12, r1
    207a:	d1 2c       	mov	r13, r1
    207c:	0f 2e       	mov	r0, r31
    207e:	fb e0       	ldi	r31, 0x0B	; 11
    2080:	ef 2e       	mov	r14, r31
    2082:	f1 e3       	ldi	r31, 0x31	; 49
    2084:	ff 2e       	mov	r15, r31
    2086:	f0 2d       	mov	r31, r0
    2088:	00 e0       	ldi	r16, 0x00	; 0
    208a:	20 e0       	ldi	r18, 0x00	; 0
    208c:	30 e0       	ldi	r19, 0x00	; 0
    208e:	44 e6       	ldi	r20, 0x64	; 100
    2090:	50 e0       	ldi	r21, 0x00	; 0
    2092:	63 e5       	ldi	r22, 0x53	; 83
    2094:	70 e2       	ldi	r23, 0x20	; 32
    2096:	8d ec       	ldi	r24, 0xCD	; 205
    2098:	9e e0       	ldi	r25, 0x0E	; 14
    209a:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <xTaskGenericCreate>
    209e:	81 30       	cpi	r24, 0x01	; 1
    20a0:	69 f4       	brne	.+26     	; 0x20bc <vTaskStartScheduler+0x56>
    20a2:	f8 94       	cli
    20a4:	80 93 03 31 	sts	0x3103, r24	; 0x803103 <xSchedulerRunning>
    20a8:	10 92 06 31 	sts	0x3106, r1	; 0x803106 <xTickCount>
    20ac:	10 92 07 31 	sts	0x3107, r1	; 0x803107 <xTickCount+0x1>
    20b0:	10 92 08 31 	sts	0x3108, r1	; 0x803108 <xTickCount+0x2>
    20b4:	10 92 09 31 	sts	0x3109, r1	; 0x803109 <xTickCount+0x3>
    20b8:	0e 94 47 0b 	call	0x168e	; 0x168e <xPortStartScheduler>
    20bc:	0f 91       	pop	r16
    20be:	ff 90       	pop	r15
    20c0:	ef 90       	pop	r14
    20c2:	df 90       	pop	r13
    20c4:	cf 90       	pop	r12
    20c6:	bf 90       	pop	r11
    20c8:	af 90       	pop	r10
    20ca:	08 95       	ret

000020cc <vTaskSuspendAll>:
    20cc:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <uxSchedulerSuspended>
    20d0:	8f 5f       	subi	r24, 0xFF	; 255
    20d2:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxSchedulerSuspended>
    20d6:	08 95       	ret

000020d8 <xTaskGetTickCount>:
    20d8:	0f b6       	in	r0, 0x3f	; 63
    20da:	f8 94       	cli
    20dc:	0f 92       	push	r0
    20de:	60 91 06 31 	lds	r22, 0x3106	; 0x803106 <xTickCount>
    20e2:	70 91 07 31 	lds	r23, 0x3107	; 0x803107 <xTickCount+0x1>
    20e6:	80 91 08 31 	lds	r24, 0x3108	; 0x803108 <xTickCount+0x2>
    20ea:	90 91 09 31 	lds	r25, 0x3109	; 0x803109 <xTickCount+0x3>
    20ee:	0f 90       	pop	r0
    20f0:	0f be       	out	0x3f, r0	; 63
    20f2:	08 95       	ret

000020f4 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20f4:	00 97       	sbiw	r24, 0x00	; 0
    20f6:	21 f4       	brne	.+8      	; 0x2100 <pcTaskGetTaskName+0xc>
    20f8:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <pxCurrentTCB>
    20fc:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    2100:	4d 96       	adiw	r24, 0x1d	; 29
    2102:	08 95       	ret

00002104 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2104:	80 91 0b 31 	lds	r24, 0x310B	; 0x80310b <xIdleTaskHandle>
    2108:	90 91 0c 31 	lds	r25, 0x310C	; 0x80310c <xIdleTaskHandle+0x1>
    210c:	08 95       	ret

0000210e <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    210e:	ff 92       	push	r15
    2110:	0f 93       	push	r16
    2112:	1f 93       	push	r17
    2114:	cf 93       	push	r28
    2116:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2118:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <uxSchedulerSuspended>
    211c:	81 11       	cpse	r24, r1
    211e:	ed c0       	rjmp	.+474    	; 0x22fa <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    2120:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    2124:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    2128:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    212c:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
    2130:	01 96       	adiw	r24, 0x01	; 1
    2132:	a1 1d       	adc	r26, r1
    2134:	b1 1d       	adc	r27, r1
    2136:	80 93 06 31 	sts	0x3106, r24	; 0x803106 <xTickCount>
    213a:	90 93 07 31 	sts	0x3107, r25	; 0x803107 <xTickCount+0x1>
    213e:	a0 93 08 31 	sts	0x3108, r26	; 0x803108 <xTickCount+0x2>
    2142:	b0 93 09 31 	sts	0x3109, r27	; 0x803109 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2146:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    214a:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    214e:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    2152:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
    2156:	89 2b       	or	r24, r25
    2158:	8a 2b       	or	r24, r26
    215a:	8b 2b       	or	r24, r27
    215c:	f1 f5       	brne	.+124    	; 0x21da <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    215e:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <pxDelayedTaskList>
    2162:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2166:	20 91 18 31 	lds	r18, 0x3118	; 0x803118 <pxOverflowDelayedTaskList>
    216a:	30 91 19 31 	lds	r19, 0x3119	; 0x803119 <pxOverflowDelayedTaskList+0x1>
    216e:	20 93 1a 31 	sts	0x311A, r18	; 0x80311a <pxDelayedTaskList>
    2172:	30 93 1b 31 	sts	0x311B, r19	; 0x80311b <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2176:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <pxOverflowDelayedTaskList>
    217a:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    217e:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <xNumOfOverflows>
    2182:	8f 5f       	subi	r24, 0xFF	; 255
    2184:	80 93 ff 30 	sts	0x30FF, r24	; 0x8030ff <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2188:	e0 91 1a 31 	lds	r30, 0x311A	; 0x80311a <pxDelayedTaskList>
    218c:	f0 91 1b 31 	lds	r31, 0x311B	; 0x80311b <pxDelayedTaskList+0x1>
    2190:	80 81       	ld	r24, Z
    2192:	81 11       	cpse	r24, r1
    2194:	0c c0       	rjmp	.+24     	; 0x21ae <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2196:	8f ef       	ldi	r24, 0xFF	; 255
    2198:	9f ef       	ldi	r25, 0xFF	; 255
    219a:	dc 01       	movw	r26, r24
    219c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21a0:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21a4:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21a8:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    21ac:	16 c0       	rjmp	.+44     	; 0x21da <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    21ae:	e0 91 1a 31 	lds	r30, 0x311A	; 0x80311a <pxDelayedTaskList>
    21b2:	f0 91 1b 31 	lds	r31, 0x311B	; 0x80311b <pxDelayedTaskList+0x1>
    21b6:	07 80       	ldd	r0, Z+7	; 0x07
    21b8:	f0 85       	ldd	r31, Z+8	; 0x08
    21ba:	e0 2d       	mov	r30, r0
    21bc:	00 84       	ldd	r0, Z+8	; 0x08
    21be:	f1 85       	ldd	r31, Z+9	; 0x09
    21c0:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    21c2:	82 81       	ldd	r24, Z+2	; 0x02
    21c4:	93 81       	ldd	r25, Z+3	; 0x03
    21c6:	a4 81       	ldd	r26, Z+4	; 0x04
    21c8:	b5 81       	ldd	r27, Z+5	; 0x05
    21ca:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21ce:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21d2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21d6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    21da:	40 91 06 31 	lds	r20, 0x3106	; 0x803106 <xTickCount>
    21de:	50 91 07 31 	lds	r21, 0x3107	; 0x803107 <xTickCount+0x1>
    21e2:	60 91 08 31 	lds	r22, 0x3108	; 0x803108 <xTickCount+0x2>
    21e6:	70 91 09 31 	lds	r23, 0x3109	; 0x803109 <xTickCount+0x3>
    21ea:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    21ee:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21f2:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21f6:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21fa:	48 17       	cp	r20, r24
    21fc:	59 07       	cpc	r21, r25
    21fe:	6a 07       	cpc	r22, r26
    2200:	7b 07       	cpc	r23, r27
    2202:	08 f4       	brcc	.+2      	; 0x2206 <vTaskIncrementTick+0xf8>
    2204:	7f c0       	rjmp	.+254    	; 0x2304 <vTaskIncrementTick+0x1f6>
    2206:	e0 91 1a 31 	lds	r30, 0x311A	; 0x80311a <pxDelayedTaskList>
    220a:	f0 91 1b 31 	lds	r31, 0x311B	; 0x80311b <pxDelayedTaskList+0x1>
    220e:	80 81       	ld	r24, Z
    2210:	88 23       	and	r24, r24
    2212:	f9 f0       	breq	.+62     	; 0x2252 <vTaskIncrementTick+0x144>
    2214:	e0 91 1a 31 	lds	r30, 0x311A	; 0x80311a <pxDelayedTaskList>
    2218:	f0 91 1b 31 	lds	r31, 0x311B	; 0x80311b <pxDelayedTaskList+0x1>
    221c:	07 80       	ldd	r0, Z+7	; 0x07
    221e:	f0 85       	ldd	r31, Z+8	; 0x08
    2220:	e0 2d       	mov	r30, r0
    2222:	c0 85       	ldd	r28, Z+8	; 0x08
    2224:	d1 85       	ldd	r29, Z+9	; 0x09
    2226:	8a 81       	ldd	r24, Y+2	; 0x02
    2228:	9b 81       	ldd	r25, Y+3	; 0x03
    222a:	ac 81       	ldd	r26, Y+4	; 0x04
    222c:	bd 81       	ldd	r27, Y+5	; 0x05
    222e:	40 91 06 31 	lds	r20, 0x3106	; 0x803106 <xTickCount>
    2232:	50 91 07 31 	lds	r21, 0x3107	; 0x803107 <xTickCount+0x1>
    2236:	60 91 08 31 	lds	r22, 0x3108	; 0x803108 <xTickCount+0x2>
    223a:	70 91 09 31 	lds	r23, 0x3109	; 0x803109 <xTickCount+0x3>
    223e:	48 17       	cp	r20, r24
    2240:	59 07       	cpc	r21, r25
    2242:	6a 07       	cpc	r22, r26
    2244:	7b 07       	cpc	r23, r27
    2246:	58 f1       	brcs	.+86     	; 0x229e <vTaskIncrementTick+0x190>
    2248:	0f 2e       	mov	r0, r31
    224a:	fb e0       	ldi	r31, 0x0B	; 11
    224c:	ff 2e       	mov	r15, r31
    224e:	f0 2d       	mov	r31, r0
    2250:	2f c0       	rjmp	.+94     	; 0x22b0 <vTaskIncrementTick+0x1a2>
    2252:	8f ef       	ldi	r24, 0xFF	; 255
    2254:	9f ef       	ldi	r25, 0xFF	; 255
    2256:	dc 01       	movw	r26, r24
    2258:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    225c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2260:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2264:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2268:	4d c0       	rjmp	.+154    	; 0x2304 <vTaskIncrementTick+0x1f6>
    226a:	e0 91 1a 31 	lds	r30, 0x311A	; 0x80311a <pxDelayedTaskList>
    226e:	f0 91 1b 31 	lds	r31, 0x311B	; 0x80311b <pxDelayedTaskList+0x1>
    2272:	07 80       	ldd	r0, Z+7	; 0x07
    2274:	f0 85       	ldd	r31, Z+8	; 0x08
    2276:	e0 2d       	mov	r30, r0
    2278:	c0 85       	ldd	r28, Z+8	; 0x08
    227a:	d1 85       	ldd	r29, Z+9	; 0x09
    227c:	8a 81       	ldd	r24, Y+2	; 0x02
    227e:	9b 81       	ldd	r25, Y+3	; 0x03
    2280:	ac 81       	ldd	r26, Y+4	; 0x04
    2282:	bd 81       	ldd	r27, Y+5	; 0x05
    2284:	40 91 06 31 	lds	r20, 0x3106	; 0x803106 <xTickCount>
    2288:	50 91 07 31 	lds	r21, 0x3107	; 0x803107 <xTickCount+0x1>
    228c:	60 91 08 31 	lds	r22, 0x3108	; 0x803108 <xTickCount+0x2>
    2290:	70 91 09 31 	lds	r23, 0x3109	; 0x803109 <xTickCount+0x3>
    2294:	48 17       	cp	r20, r24
    2296:	59 07       	cpc	r21, r25
    2298:	6a 07       	cpc	r22, r26
    229a:	7b 07       	cpc	r23, r27
    229c:	48 f4       	brcc	.+18     	; 0x22b0 <vTaskIncrementTick+0x1a2>
    229e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22a2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22a6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22aa:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    22ae:	2a c0       	rjmp	.+84     	; 0x2304 <vTaskIncrementTick+0x1f6>
    22b0:	8e 01       	movw	r16, r28
    22b2:	0e 5f       	subi	r16, 0xFE	; 254
    22b4:	1f 4f       	sbci	r17, 0xFF	; 255
    22b6:	c8 01       	movw	r24, r16
    22b8:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>
    22bc:	88 8d       	ldd	r24, Y+24	; 0x18
    22be:	99 8d       	ldd	r25, Y+25	; 0x19
    22c0:	89 2b       	or	r24, r25
    22c2:	21 f0       	breq	.+8      	; 0x22cc <vTaskIncrementTick+0x1be>
    22c4:	ce 01       	movw	r24, r28
    22c6:	0e 96       	adiw	r24, 0x0e	; 14
    22c8:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>
    22cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22ce:	90 91 04 31 	lds	r25, 0x3104	; 0x803104 <uxTopReadyPriority>
    22d2:	98 17       	cp	r25, r24
    22d4:	10 f4       	brcc	.+4      	; 0x22da <vTaskIncrementTick+0x1cc>
    22d6:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <uxTopReadyPriority>
    22da:	f8 9e       	mul	r15, r24
    22dc:	c0 01       	movw	r24, r0
    22de:	11 24       	eor	r1, r1
    22e0:	b8 01       	movw	r22, r16
    22e2:	8e 5c       	subi	r24, 0xCE	; 206
    22e4:	9e 4c       	sbci	r25, 0xCE	; 206
    22e6:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInsertEnd>
    22ea:	e0 91 1a 31 	lds	r30, 0x311A	; 0x80311a <pxDelayedTaskList>
    22ee:	f0 91 1b 31 	lds	r31, 0x311B	; 0x80311b <pxDelayedTaskList+0x1>
    22f2:	80 81       	ld	r24, Z
    22f4:	81 11       	cpse	r24, r1
    22f6:	b9 cf       	rjmp	.-142    	; 0x226a <vTaskIncrementTick+0x15c>
    22f8:	ac cf       	rjmp	.-168    	; 0x2252 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22fa:	80 91 01 31 	lds	r24, 0x3101	; 0x803101 <uxMissedTicks>
    22fe:	8f 5f       	subi	r24, 0xFF	; 255
    2300:	80 93 01 31 	sts	0x3101, r24	; 0x803101 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2304:	df 91       	pop	r29
    2306:	cf 91       	pop	r28
    2308:	1f 91       	pop	r17
    230a:	0f 91       	pop	r16
    230c:	ff 90       	pop	r15
    230e:	08 95       	ret

00002310 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2310:	cf 92       	push	r12
    2312:	df 92       	push	r13
    2314:	ef 92       	push	r14
    2316:	ff 92       	push	r15
    2318:	0f 93       	push	r16
    231a:	1f 93       	push	r17
    231c:	cf 93       	push	r28
    231e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2320:	0f b6       	in	r0, 0x3f	; 63
    2322:	f8 94       	cli
    2324:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2326:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <uxSchedulerSuspended>
    232a:	81 50       	subi	r24, 0x01	; 1
    232c:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2330:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <uxSchedulerSuspended>
    2334:	81 11       	cpse	r24, r1
    2336:	60 c0       	rjmp	.+192    	; 0x23f8 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2338:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <uxCurrentNumberOfTasks>
    233c:	81 11       	cpse	r24, r1
    233e:	2c c0       	rjmp	.+88     	; 0x2398 <xTaskResumeAll+0x88>
    2340:	5e c0       	rjmp	.+188    	; 0x23fe <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2342:	d7 01       	movw	r26, r14
    2344:	17 96       	adiw	r26, 0x07	; 7
    2346:	ed 91       	ld	r30, X+
    2348:	fc 91       	ld	r31, X
    234a:	18 97       	sbiw	r26, 0x08	; 8
    234c:	c0 85       	ldd	r28, Z+8	; 0x08
    234e:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2350:	ce 01       	movw	r24, r28
    2352:	0e 96       	adiw	r24, 0x0e	; 14
    2354:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2358:	8e 01       	movw	r16, r28
    235a:	0e 5f       	subi	r16, 0xFE	; 254
    235c:	1f 4f       	sbci	r17, 0xFF	; 255
    235e:	c8 01       	movw	r24, r16
    2360:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2364:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2366:	90 91 04 31 	lds	r25, 0x3104	; 0x803104 <uxTopReadyPriority>
    236a:	98 17       	cp	r25, r24
    236c:	10 f4       	brcc	.+4      	; 0x2372 <xTaskResumeAll+0x62>
    236e:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <uxTopReadyPriority>
    2372:	d8 9e       	mul	r13, r24
    2374:	c0 01       	movw	r24, r0
    2376:	11 24       	eor	r1, r1
    2378:	b8 01       	movw	r22, r16
    237a:	8e 5c       	subi	r24, 0xCE	; 206
    237c:	9e 4c       	sbci	r25, 0xCE	; 206
    237e:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2382:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <pxCurrentTCB>
    2386:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    238a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    238c:	82 8d       	ldd	r24, Z+26	; 0x1a
    238e:	98 17       	cp	r25, r24
    2390:	70 f0       	brcs	.+28     	; 0x23ae <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2392:	cc 24       	eor	r12, r12
    2394:	c3 94       	inc	r12
    2396:	0b c0       	rjmp	.+22     	; 0x23ae <xTaskResumeAll+0x9e>
    2398:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    239a:	0f 2e       	mov	r0, r31
    239c:	fd e0       	ldi	r31, 0x0D	; 13
    239e:	ef 2e       	mov	r14, r31
    23a0:	f1 e3       	ldi	r31, 0x31	; 49
    23a2:	ff 2e       	mov	r15, r31
    23a4:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    23a6:	0f 2e       	mov	r0, r31
    23a8:	fb e0       	ldi	r31, 0x0B	; 11
    23aa:	df 2e       	mov	r13, r31
    23ac:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    23ae:	f7 01       	movw	r30, r14
    23b0:	80 81       	ld	r24, Z
    23b2:	81 11       	cpse	r24, r1
    23b4:	c6 cf       	rjmp	.-116    	; 0x2342 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23b6:	80 91 01 31 	lds	r24, 0x3101	; 0x803101 <uxMissedTicks>
    23ba:	88 23       	and	r24, r24
    23bc:	81 f0       	breq	.+32     	; 0x23de <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23be:	80 91 01 31 	lds	r24, 0x3101	; 0x803101 <uxMissedTicks>
    23c2:	88 23       	and	r24, r24
    23c4:	99 f0       	breq	.+38     	; 0x23ec <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    23c6:	0e 94 87 10 	call	0x210e	; 0x210e <vTaskIncrementTick>
						--uxMissedTicks;
    23ca:	80 91 01 31 	lds	r24, 0x3101	; 0x803101 <uxMissedTicks>
    23ce:	81 50       	subi	r24, 0x01	; 1
    23d0:	80 93 01 31 	sts	0x3101, r24	; 0x803101 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23d4:	80 91 01 31 	lds	r24, 0x3101	; 0x803101 <uxMissedTicks>
    23d8:	81 11       	cpse	r24, r1
    23da:	f5 cf       	rjmp	.-22     	; 0x23c6 <xTaskResumeAll+0xb6>
    23dc:	07 c0       	rjmp	.+14     	; 0x23ec <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    23de:	f1 e0       	ldi	r31, 0x01	; 1
    23e0:	cf 16       	cp	r12, r31
    23e2:	21 f0       	breq	.+8      	; 0x23ec <xTaskResumeAll+0xdc>
    23e4:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <xMissedYield>
    23e8:	81 30       	cpi	r24, 0x01	; 1
    23ea:	41 f4       	brne	.+16     	; 0x23fc <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23ec:	10 92 00 31 	sts	0x3100, r1	; 0x803100 <xMissedYield>
					portYIELD_WITHIN_API();
    23f0:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23f4:	81 e0       	ldi	r24, 0x01	; 1
    23f6:	03 c0       	rjmp	.+6      	; 0x23fe <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23f8:	80 e0       	ldi	r24, 0x00	; 0
    23fa:	01 c0       	rjmp	.+2      	; 0x23fe <xTaskResumeAll+0xee>
    23fc:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23fe:	0f 90       	pop	r0
    2400:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2402:	df 91       	pop	r29
    2404:	cf 91       	pop	r28
    2406:	1f 91       	pop	r17
    2408:	0f 91       	pop	r16
    240a:	ff 90       	pop	r15
    240c:	ef 90       	pop	r14
    240e:	df 90       	pop	r13
    2410:	cf 90       	pop	r12
    2412:	08 95       	ret

00002414 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2414:	cf 92       	push	r12
    2416:	df 92       	push	r13
    2418:	ef 92       	push	r14
    241a:	ff 92       	push	r15
    241c:	cf 93       	push	r28
    241e:	df 93       	push	r29
    2420:	ec 01       	movw	r28, r24
    2422:	6a 01       	movw	r12, r20
    2424:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2426:	0e 94 66 10 	call	0x20cc	; 0x20cc <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    242a:	88 81       	ld	r24, Y
    242c:	99 81       	ldd	r25, Y+1	; 0x01
    242e:	aa 81       	ldd	r26, Y+2	; 0x02
    2430:	bb 81       	ldd	r27, Y+3	; 0x03
    2432:	c8 0e       	add	r12, r24
    2434:	d9 1e       	adc	r13, r25
    2436:	ea 1e       	adc	r14, r26
    2438:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    243a:	40 91 06 31 	lds	r20, 0x3106	; 0x803106 <xTickCount>
    243e:	50 91 07 31 	lds	r21, 0x3107	; 0x803107 <xTickCount+0x1>
    2442:	60 91 08 31 	lds	r22, 0x3108	; 0x803108 <xTickCount+0x2>
    2446:	70 91 09 31 	lds	r23, 0x3109	; 0x803109 <xTickCount+0x3>
    244a:	48 17       	cp	r20, r24
    244c:	59 07       	cpc	r21, r25
    244e:	6a 07       	cpc	r22, r26
    2450:	7b 07       	cpc	r23, r27
    2452:	b8 f4       	brcc	.+46     	; 0x2482 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2454:	c8 16       	cp	r12, r24
    2456:	d9 06       	cpc	r13, r25
    2458:	ea 06       	cpc	r14, r26
    245a:	fb 06       	cpc	r15, r27
    245c:	e0 f5       	brcc	.+120    	; 0x24d6 <vTaskDelayUntil+0xc2>
    245e:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    2462:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    2466:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    246a:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    246e:	c8 82       	st	Y, r12
    2470:	d9 82       	std	Y+1, r13	; 0x01
    2472:	ea 82       	std	Y+2, r14	; 0x02
    2474:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2476:	8c 15       	cp	r24, r12
    2478:	9d 05       	cpc	r25, r13
    247a:	ae 05       	cpc	r26, r14
    247c:	bf 05       	cpc	r27, r15
    247e:	f8 f4       	brcc	.+62     	; 0x24be <vTaskDelayUntil+0xaa>
    2480:	13 c0       	rjmp	.+38     	; 0x24a8 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2482:	c8 16       	cp	r12, r24
    2484:	d9 06       	cpc	r13, r25
    2486:	ea 06       	cpc	r14, r26
    2488:	fb 06       	cpc	r15, r27
    248a:	00 f1       	brcs	.+64     	; 0x24cc <vTaskDelayUntil+0xb8>
    248c:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    2490:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    2494:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    2498:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
    249c:	8c 15       	cp	r24, r12
    249e:	9d 05       	cpc	r25, r13
    24a0:	ae 05       	cpc	r26, r14
    24a2:	bf 05       	cpc	r27, r15
    24a4:	98 f0       	brcs	.+38     	; 0x24cc <vTaskDelayUntil+0xb8>
    24a6:	17 c0       	rjmp	.+46     	; 0x24d6 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24a8:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <pxCurrentTCB>
    24ac:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    24b0:	02 96       	adiw	r24, 0x02	; 2
    24b2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24b6:	c7 01       	movw	r24, r14
    24b8:	b6 01       	movw	r22, r12
    24ba:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    24be:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24c2:	81 11       	cpse	r24, r1
    24c4:	0d c0       	rjmp	.+26     	; 0x24e0 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    24c6:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
		}
	}
    24ca:	0a c0       	rjmp	.+20     	; 0x24e0 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24cc:	c8 82       	st	Y, r12
    24ce:	d9 82       	std	Y+1, r13	; 0x01
    24d0:	ea 82       	std	Y+2, r14	; 0x02
    24d2:	fb 82       	std	Y+3, r15	; 0x03
    24d4:	e9 cf       	rjmp	.-46     	; 0x24a8 <vTaskDelayUntil+0x94>
    24d6:	c8 82       	st	Y, r12
    24d8:	d9 82       	std	Y+1, r13	; 0x01
    24da:	ea 82       	std	Y+2, r14	; 0x02
    24dc:	fb 82       	std	Y+3, r15	; 0x03
    24de:	ef cf       	rjmp	.-34     	; 0x24be <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    24e0:	df 91       	pop	r29
    24e2:	cf 91       	pop	r28
    24e4:	ff 90       	pop	r15
    24e6:	ef 90       	pop	r14
    24e8:	df 90       	pop	r13
    24ea:	cf 90       	pop	r12
    24ec:	08 95       	ret

000024ee <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    24ee:	cf 92       	push	r12
    24f0:	df 92       	push	r13
    24f2:	ef 92       	push	r14
    24f4:	ff 92       	push	r15
    24f6:	6b 01       	movw	r12, r22
    24f8:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24fa:	67 2b       	or	r22, r23
    24fc:	68 2b       	or	r22, r24
    24fe:	69 2b       	or	r22, r25
    2500:	e9 f0       	breq	.+58     	; 0x253c <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2502:	0e 94 66 10 	call	0x20cc	; 0x20cc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2506:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    250a:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    250e:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    2512:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
    2516:	c8 0e       	add	r12, r24
    2518:	d9 1e       	adc	r13, r25
    251a:	ea 1e       	adc	r14, r26
    251c:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    251e:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <pxCurrentTCB>
    2522:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    2526:	02 96       	adiw	r24, 0x02	; 2
    2528:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    252c:	c7 01       	movw	r24, r14
    252e:	b6 01       	movw	r22, r12
    2530:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2534:	0e 94 88 11 	call	0x2310	; 0x2310 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2538:	81 11       	cpse	r24, r1
    253a:	02 c0       	rjmp	.+4      	; 0x2540 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    253c:	0e 94 85 0b 	call	0x170a	; 0x170a <vPortYield>
		}
	}
    2540:	ff 90       	pop	r15
    2542:	ef 90       	pop	r14
    2544:	df 90       	pop	r13
    2546:	cf 90       	pop	r12
    2548:	08 95       	ret

0000254a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    254a:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <uxSchedulerSuspended>
    254e:	81 11       	cpse	r24, r1
    2550:	0c c0       	rjmp	.+24     	; 0x256a <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2552:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <uxTopReadyPriority>
    2556:	4b e0       	ldi	r20, 0x0B	; 11
    2558:	e4 9f       	mul	r30, r20
    255a:	f0 01       	movw	r30, r0
    255c:	11 24       	eor	r1, r1
    255e:	ee 5c       	subi	r30, 0xCE	; 206
    2560:	fe 4c       	sbci	r31, 0xCE	; 206
    2562:	80 81       	ld	r24, Z
    2564:	88 23       	and	r24, r24
    2566:	29 f0       	breq	.+10     	; 0x2572 <vTaskSwitchContext+0x28>
    2568:	14 c0       	rjmp	.+40     	; 0x2592 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    256a:	81 e0       	ldi	r24, 0x01	; 1
    256c:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <xMissedYield>
    2570:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2572:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2574:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <uxTopReadyPriority>
    2578:	81 50       	subi	r24, 0x01	; 1
    257a:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    257e:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <uxTopReadyPriority>
    2582:	9e 9f       	mul	r25, r30
    2584:	f0 01       	movw	r30, r0
    2586:	11 24       	eor	r1, r1
    2588:	ee 5c       	subi	r30, 0xCE	; 206
    258a:	fe 4c       	sbci	r31, 0xCE	; 206
    258c:	80 81       	ld	r24, Z
    258e:	88 23       	and	r24, r24
    2590:	89 f3       	breq	.-30     	; 0x2574 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2592:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <uxTopReadyPriority>
    2596:	28 2f       	mov	r18, r24
    2598:	30 e0       	ldi	r19, 0x00	; 0
    259a:	4b e0       	ldi	r20, 0x0B	; 11
    259c:	84 9f       	mul	r24, r20
    259e:	c0 01       	movw	r24, r0
    25a0:	11 24       	eor	r1, r1
    25a2:	dc 01       	movw	r26, r24
    25a4:	ae 5c       	subi	r26, 0xCE	; 206
    25a6:	be 4c       	sbci	r27, 0xCE	; 206
    25a8:	11 96       	adiw	r26, 0x01	; 1
    25aa:	ed 91       	ld	r30, X+
    25ac:	fc 91       	ld	r31, X
    25ae:	12 97       	sbiw	r26, 0x02	; 2
    25b0:	04 80       	ldd	r0, Z+4	; 0x04
    25b2:	f5 81       	ldd	r31, Z+5	; 0x05
    25b4:	e0 2d       	mov	r30, r0
    25b6:	11 96       	adiw	r26, 0x01	; 1
    25b8:	ed 93       	st	X+, r30
    25ba:	fc 93       	st	X, r31
    25bc:	12 97       	sbiw	r26, 0x02	; 2
    25be:	8b 5c       	subi	r24, 0xCB	; 203
    25c0:	9e 4c       	sbci	r25, 0xCE	; 206
    25c2:	e8 17       	cp	r30, r24
    25c4:	f9 07       	cpc	r31, r25
    25c6:	61 f4       	brne	.+24     	; 0x25e0 <vTaskSwitchContext+0x96>
    25c8:	84 81       	ldd	r24, Z+4	; 0x04
    25ca:	95 81       	ldd	r25, Z+5	; 0x05
    25cc:	4b e0       	ldi	r20, 0x0B	; 11
    25ce:	42 9f       	mul	r20, r18
    25d0:	f0 01       	movw	r30, r0
    25d2:	43 9f       	mul	r20, r19
    25d4:	f0 0d       	add	r31, r0
    25d6:	11 24       	eor	r1, r1
    25d8:	ee 5c       	subi	r30, 0xCE	; 206
    25da:	fe 4c       	sbci	r31, 0xCE	; 206
    25dc:	81 83       	std	Z+1, r24	; 0x01
    25de:	92 83       	std	Z+2, r25	; 0x02
    25e0:	8b e0       	ldi	r24, 0x0B	; 11
    25e2:	82 9f       	mul	r24, r18
    25e4:	f0 01       	movw	r30, r0
    25e6:	83 9f       	mul	r24, r19
    25e8:	f0 0d       	add	r31, r0
    25ea:	11 24       	eor	r1, r1
    25ec:	ee 5c       	subi	r30, 0xCE	; 206
    25ee:	fe 4c       	sbci	r31, 0xCE	; 206
    25f0:	01 80       	ldd	r0, Z+1	; 0x01
    25f2:	f2 81       	ldd	r31, Z+2	; 0x02
    25f4:	e0 2d       	mov	r30, r0
    25f6:	80 85       	ldd	r24, Z+8	; 0x08
    25f8:	91 85       	ldd	r25, Z+9	; 0x09
    25fa:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <pxCurrentTCB>
    25fe:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <pxCurrentTCB+0x1>
    2602:	08 95       	ret

00002604 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2604:	cf 92       	push	r12
    2606:	df 92       	push	r13
    2608:	ef 92       	push	r14
    260a:	ff 92       	push	r15
    260c:	6a 01       	movw	r12, r20
    260e:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2610:	60 91 5e 31 	lds	r22, 0x315E	; 0x80315e <pxCurrentTCB>
    2614:	70 91 5f 31 	lds	r23, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    2618:	62 5f       	subi	r22, 0xF2	; 242
    261a:	7f 4f       	sbci	r23, 0xFF	; 255
    261c:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2620:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <pxCurrentTCB>
    2624:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    2628:	02 96       	adiw	r24, 0x02	; 2
    262a:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    262e:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    2632:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    2636:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    263a:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    263e:	bc 01       	movw	r22, r24
    2640:	cd 01       	movw	r24, r26
    2642:	6c 0d       	add	r22, r12
    2644:	7d 1d       	adc	r23, r13
    2646:	8e 1d       	adc	r24, r14
    2648:	9f 1d       	adc	r25, r15
    264a:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    264e:	ff 90       	pop	r15
    2650:	ef 90       	pop	r14
    2652:	df 90       	pop	r13
    2654:	cf 90       	pop	r12
    2656:	08 95       	ret

00002658 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2658:	0f 93       	push	r16
    265a:	1f 93       	push	r17
    265c:	cf 93       	push	r28
    265e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2660:	dc 01       	movw	r26, r24
    2662:	17 96       	adiw	r26, 0x07	; 7
    2664:	ed 91       	ld	r30, X+
    2666:	fc 91       	ld	r31, X
    2668:	18 97       	sbiw	r26, 0x08	; 8
    266a:	c0 85       	ldd	r28, Z+8	; 0x08
    266c:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    266e:	8e 01       	movw	r16, r28
    2670:	02 5f       	subi	r16, 0xF2	; 242
    2672:	1f 4f       	sbci	r17, 0xFF	; 255
    2674:	c8 01       	movw	r24, r16
    2676:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    267a:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <uxSchedulerSuspended>
    267e:	81 11       	cpse	r24, r1
    2680:	16 c0       	rjmp	.+44     	; 0x26ae <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2682:	0c 50       	subi	r16, 0x0C	; 12
    2684:	11 09       	sbc	r17, r1
    2686:	c8 01       	movw	r24, r16
    2688:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    268c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    268e:	90 91 04 31 	lds	r25, 0x3104	; 0x803104 <uxTopReadyPriority>
    2692:	98 17       	cp	r25, r24
    2694:	10 f4       	brcc	.+4      	; 0x269a <xTaskRemoveFromEventList+0x42>
    2696:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <uxTopReadyPriority>
    269a:	bb e0       	ldi	r27, 0x0B	; 11
    269c:	8b 9f       	mul	r24, r27
    269e:	c0 01       	movw	r24, r0
    26a0:	11 24       	eor	r1, r1
    26a2:	b8 01       	movw	r22, r16
    26a4:	8e 5c       	subi	r24, 0xCE	; 206
    26a6:	9e 4c       	sbci	r25, 0xCE	; 206
    26a8:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInsertEnd>
    26ac:	05 c0       	rjmp	.+10     	; 0x26b8 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    26ae:	b8 01       	movw	r22, r16
    26b0:	8d e0       	ldi	r24, 0x0D	; 13
    26b2:	91 e3       	ldi	r25, 0x31	; 49
    26b4:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    26b8:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <pxCurrentTCB>
    26bc:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    26c0:	81 e0       	ldi	r24, 0x01	; 1
    26c2:	2a 8d       	ldd	r18, Y+26	; 0x1a
    26c4:	92 8d       	ldd	r25, Z+26	; 0x1a
    26c6:	29 17       	cp	r18, r25
    26c8:	08 f4       	brcc	.+2      	; 0x26cc <xTaskRemoveFromEventList+0x74>
    26ca:	80 e0       	ldi	r24, 0x00	; 0
}
    26cc:	df 91       	pop	r29
    26ce:	cf 91       	pop	r28
    26d0:	1f 91       	pop	r17
    26d2:	0f 91       	pop	r16
    26d4:	08 95       	ret

000026d6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    26d6:	20 91 ff 30 	lds	r18, 0x30FF	; 0x8030ff <xNumOfOverflows>
    26da:	fc 01       	movw	r30, r24
    26dc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    26de:	40 91 06 31 	lds	r20, 0x3106	; 0x803106 <xTickCount>
    26e2:	50 91 07 31 	lds	r21, 0x3107	; 0x803107 <xTickCount+0x1>
    26e6:	60 91 08 31 	lds	r22, 0x3108	; 0x803108 <xTickCount+0x2>
    26ea:	70 91 09 31 	lds	r23, 0x3109	; 0x803109 <xTickCount+0x3>
    26ee:	41 83       	std	Z+1, r20	; 0x01
    26f0:	52 83       	std	Z+2, r21	; 0x02
    26f2:	63 83       	std	Z+3, r22	; 0x03
    26f4:	74 83       	std	Z+4, r23	; 0x04
    26f6:	08 95       	ret

000026f8 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26f8:	8f 92       	push	r8
    26fa:	9f 92       	push	r9
    26fc:	af 92       	push	r10
    26fe:	bf 92       	push	r11
    2700:	cf 92       	push	r12
    2702:	df 92       	push	r13
    2704:	ef 92       	push	r14
    2706:	ff 92       	push	r15
    2708:	0f 93       	push	r16
    270a:	1f 93       	push	r17
    270c:	cf 93       	push	r28
    270e:	df 93       	push	r29
    2710:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2712:	0f b6       	in	r0, 0x3f	; 63
    2714:	f8 94       	cli
    2716:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2718:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <xNumOfOverflows>
    271c:	90 81       	ld	r25, Z
    271e:	98 17       	cp	r25, r24
    2720:	89 f0       	breq	.+34     	; 0x2744 <xTaskCheckForTimeOut+0x4c>
    2722:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    2726:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    272a:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    272e:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
    2732:	01 81       	ldd	r16, Z+1	; 0x01
    2734:	12 81       	ldd	r17, Z+2	; 0x02
    2736:	23 81       	ldd	r18, Z+3	; 0x03
    2738:	34 81       	ldd	r19, Z+4	; 0x04
    273a:	80 17       	cp	r24, r16
    273c:	91 07       	cpc	r25, r17
    273e:	a2 07       	cpc	r26, r18
    2740:	b3 07       	cpc	r27, r19
    2742:	a8 f5       	brcc	.+106    	; 0x27ae <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2744:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <xTickCount>
    2748:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <xTickCount+0x1>
    274c:	a0 91 08 31 	lds	r26, 0x3108	; 0x803108 <xTickCount+0x2>
    2750:	b0 91 09 31 	lds	r27, 0x3109	; 0x803109 <xTickCount+0x3>
    2754:	c1 80       	ldd	r12, Z+1	; 0x01
    2756:	d2 80       	ldd	r13, Z+2	; 0x02
    2758:	e3 80       	ldd	r14, Z+3	; 0x03
    275a:	f4 80       	ldd	r15, Z+4	; 0x04
    275c:	eb 01       	movw	r28, r22
    275e:	08 81       	ld	r16, Y
    2760:	19 81       	ldd	r17, Y+1	; 0x01
    2762:	2a 81       	ldd	r18, Y+2	; 0x02
    2764:	3b 81       	ldd	r19, Y+3	; 0x03
    2766:	8c 19       	sub	r24, r12
    2768:	9d 09       	sbc	r25, r13
    276a:	ae 09       	sbc	r26, r14
    276c:	bf 09       	sbc	r27, r15
    276e:	80 17       	cp	r24, r16
    2770:	91 07       	cpc	r25, r17
    2772:	a2 07       	cpc	r26, r18
    2774:	b3 07       	cpc	r27, r19
    2776:	e8 f4       	brcc	.+58     	; 0x27b2 <xTaskCheckForTimeOut+0xba>
    2778:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    277a:	80 90 06 31 	lds	r8, 0x3106	; 0x803106 <xTickCount>
    277e:	90 90 07 31 	lds	r9, 0x3107	; 0x803107 <xTickCount+0x1>
    2782:	a0 90 08 31 	lds	r10, 0x3108	; 0x803108 <xTickCount+0x2>
    2786:	b0 90 09 31 	lds	r11, 0x3109	; 0x803109 <xTickCount+0x3>
    278a:	b5 01       	movw	r22, r10
    278c:	a4 01       	movw	r20, r8
    278e:	4c 19       	sub	r20, r12
    2790:	5d 09       	sbc	r21, r13
    2792:	6e 09       	sbc	r22, r14
    2794:	7f 09       	sbc	r23, r15
    2796:	04 1b       	sub	r16, r20
    2798:	15 0b       	sbc	r17, r21
    279a:	26 0b       	sbc	r18, r22
    279c:	37 0b       	sbc	r19, r23
    279e:	08 83       	st	Y, r16
    27a0:	19 83       	std	Y+1, r17	; 0x01
    27a2:	2a 83       	std	Y+2, r18	; 0x02
    27a4:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    27a6:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    27aa:	80 e0       	ldi	r24, 0x00	; 0
    27ac:	03 c0       	rjmp	.+6      	; 0x27b4 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    27ae:	81 e0       	ldi	r24, 0x01	; 1
    27b0:	01 c0       	rjmp	.+2      	; 0x27b4 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    27b2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    27b4:	0f 90       	pop	r0
    27b6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    27b8:	df 91       	pop	r29
    27ba:	cf 91       	pop	r28
    27bc:	1f 91       	pop	r17
    27be:	0f 91       	pop	r16
    27c0:	ff 90       	pop	r15
    27c2:	ef 90       	pop	r14
    27c4:	df 90       	pop	r13
    27c6:	cf 90       	pop	r12
    27c8:	bf 90       	pop	r11
    27ca:	af 90       	pop	r10
    27cc:	9f 90       	pop	r9
    27ce:	8f 90       	pop	r8
    27d0:	08 95       	ret

000027d2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    27d2:	81 e0       	ldi	r24, 0x01	; 1
    27d4:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <xMissedYield>
    27d8:	08 95       	ret

000027da <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27da:	00 97       	sbiw	r24, 0x00	; 0
    27dc:	21 f4       	brne	.+8      	; 0x27e6 <uxTaskGetStackHighWaterMark+0xc>
    27de:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <pxCurrentTCB>
    27e2:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    27e6:	dc 01       	movw	r26, r24
    27e8:	5b 96       	adiw	r26, 0x1b	; 27
    27ea:	ed 91       	ld	r30, X+
    27ec:	fc 91       	ld	r31, X
    27ee:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27f0:	80 81       	ld	r24, Z
    27f2:	81 31       	cpi	r24, 0x11	; 17
    27f4:	41 f4       	brne	.+16     	; 0x2806 <uxTaskGetStackHighWaterMark+0x2c>
    27f6:	31 96       	adiw	r30, 0x01	; 1
    27f8:	80 e0       	ldi	r24, 0x00	; 0
    27fa:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27fc:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27fe:	21 91       	ld	r18, Z+
    2800:	21 31       	cpi	r18, 0x11	; 17
    2802:	e1 f3       	breq	.-8      	; 0x27fc <uxTaskGetStackHighWaterMark+0x22>
    2804:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2806:	80 e0       	ldi	r24, 0x00	; 0
    2808:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    280a:	08 95       	ret

0000280c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    280c:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <pxCurrentTCB>
    2810:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <pxCurrentTCB+0x1>

		return xReturn;
	}
    2814:	08 95       	ret

00002816 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2816:	0f 93       	push	r16
    2818:	1f 93       	push	r17
    281a:	cf 93       	push	r28
    281c:	df 93       	push	r29
    281e:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2820:	22 8d       	ldd	r18, Z+26	; 0x1a
    2822:	a0 91 5e 31 	lds	r26, 0x315E	; 0x80315e <pxCurrentTCB>
    2826:	b0 91 5f 31 	lds	r27, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    282a:	5a 96       	adiw	r26, 0x1a	; 26
    282c:	8c 91       	ld	r24, X
    282e:	28 17       	cp	r18, r24
    2830:	08 f0       	brcs	.+2      	; 0x2834 <vTaskPriorityInherit+0x1e>
    2832:	41 c0       	rjmp	.+130    	; 0x28b6 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2834:	a0 91 5e 31 	lds	r26, 0x315E	; 0x80315e <pxCurrentTCB>
    2838:	b0 91 5f 31 	lds	r27, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    283c:	5a 96       	adiw	r26, 0x1a	; 26
    283e:	3c 91       	ld	r19, X
    2840:	84 e0       	ldi	r24, 0x04	; 4
    2842:	90 e0       	ldi	r25, 0x00	; 0
    2844:	a0 e0       	ldi	r26, 0x00	; 0
    2846:	b0 e0       	ldi	r27, 0x00	; 0
    2848:	83 1b       	sub	r24, r19
    284a:	91 09       	sbc	r25, r1
    284c:	a1 09       	sbc	r26, r1
    284e:	b1 09       	sbc	r27, r1
    2850:	86 87       	std	Z+14, r24	; 0x0e
    2852:	97 87       	std	Z+15, r25	; 0x0f
    2854:	a0 8b       	std	Z+16, r26	; 0x10
    2856:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2858:	8b e0       	ldi	r24, 0x0B	; 11
    285a:	28 9f       	mul	r18, r24
    285c:	90 01       	movw	r18, r0
    285e:	11 24       	eor	r1, r1
    2860:	2e 5c       	subi	r18, 0xCE	; 206
    2862:	3e 4c       	sbci	r19, 0xCE	; 206
    2864:	84 85       	ldd	r24, Z+12	; 0x0c
    2866:	95 85       	ldd	r25, Z+13	; 0x0d
    2868:	82 17       	cp	r24, r18
    286a:	93 07       	cpc	r25, r19
    286c:	e9 f4       	brne	.+58     	; 0x28a8 <vTaskPriorityInherit+0x92>
    286e:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2870:	ef 01       	movw	r28, r30
    2872:	22 96       	adiw	r28, 0x02	; 2
    2874:	ce 01       	movw	r24, r28
    2876:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    287a:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <pxCurrentTCB>
    287e:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    2882:	82 8d       	ldd	r24, Z+26	; 0x1a
    2884:	f8 01       	movw	r30, r16
    2886:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2888:	90 91 04 31 	lds	r25, 0x3104	; 0x803104 <uxTopReadyPriority>
    288c:	98 17       	cp	r25, r24
    288e:	10 f4       	brcc	.+4      	; 0x2894 <vTaskPriorityInherit+0x7e>
    2890:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <uxTopReadyPriority>
    2894:	fb e0       	ldi	r31, 0x0B	; 11
    2896:	8f 9f       	mul	r24, r31
    2898:	c0 01       	movw	r24, r0
    289a:	11 24       	eor	r1, r1
    289c:	be 01       	movw	r22, r28
    289e:	8e 5c       	subi	r24, 0xCE	; 206
    28a0:	9e 4c       	sbci	r25, 0xCE	; 206
    28a2:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInsertEnd>
    28a6:	07 c0       	rjmp	.+14     	; 0x28b6 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    28a8:	a0 91 5e 31 	lds	r26, 0x315E	; 0x80315e <pxCurrentTCB>
    28ac:	b0 91 5f 31 	lds	r27, 0x315F	; 0x80315f <pxCurrentTCB+0x1>
    28b0:	5a 96       	adiw	r26, 0x1a	; 26
    28b2:	8c 91       	ld	r24, X
    28b4:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    28b6:	df 91       	pop	r29
    28b8:	cf 91       	pop	r28
    28ba:	1f 91       	pop	r17
    28bc:	0f 91       	pop	r16
    28be:	08 95       	ret

000028c0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    28c0:	0f 93       	push	r16
    28c2:	1f 93       	push	r17
    28c4:	cf 93       	push	r28
    28c6:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    28c8:	00 97       	sbiw	r24, 0x00	; 0
    28ca:	49 f1       	breq	.+82     	; 0x291e <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    28cc:	fc 01       	movw	r30, r24
    28ce:	32 8d       	ldd	r19, Z+26	; 0x1a
    28d0:	27 a1       	ldd	r18, Z+39	; 0x27
    28d2:	32 17       	cp	r19, r18
    28d4:	21 f1       	breq	.+72     	; 0x291e <vTaskPriorityDisinherit+0x5e>
    28d6:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    28d8:	8c 01       	movw	r16, r24
    28da:	0e 5f       	subi	r16, 0xFE	; 254
    28dc:	1f 4f       	sbci	r17, 0xFF	; 255
    28de:	c8 01       	movw	r24, r16
    28e0:	0e 94 ab 0a 	call	0x1556	; 0x1556 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28e4:	8f a1       	ldd	r24, Y+39	; 0x27
    28e6:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28e8:	44 e0       	ldi	r20, 0x04	; 4
    28ea:	50 e0       	ldi	r21, 0x00	; 0
    28ec:	60 e0       	ldi	r22, 0x00	; 0
    28ee:	70 e0       	ldi	r23, 0x00	; 0
    28f0:	48 1b       	sub	r20, r24
    28f2:	51 09       	sbc	r21, r1
    28f4:	61 09       	sbc	r22, r1
    28f6:	71 09       	sbc	r23, r1
    28f8:	4e 87       	std	Y+14, r20	; 0x0e
    28fa:	5f 87       	std	Y+15, r21	; 0x0f
    28fc:	68 8b       	std	Y+16, r22	; 0x10
    28fe:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2900:	90 91 04 31 	lds	r25, 0x3104	; 0x803104 <uxTopReadyPriority>
    2904:	98 17       	cp	r25, r24
    2906:	10 f4       	brcc	.+4      	; 0x290c <vTaskPriorityDisinherit+0x4c>
    2908:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <uxTopReadyPriority>
    290c:	fb e0       	ldi	r31, 0x0B	; 11
    290e:	8f 9f       	mul	r24, r31
    2910:	c0 01       	movw	r24, r0
    2912:	11 24       	eor	r1, r1
    2914:	b8 01       	movw	r22, r16
    2916:	8e 5c       	subi	r24, 0xCE	; 206
    2918:	9e 4c       	sbci	r25, 0xCE	; 206
    291a:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInsertEnd>
			}
		}
	}
    291e:	df 91       	pop	r29
    2920:	cf 91       	pop	r28
    2922:	1f 91       	pop	r17
    2924:	0f 91       	pop	r16
    2926:	08 95       	ret

00002928 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2928:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    292a:	e8 81       	ld	r30, Y
    292c:	f9 81       	ldd	r31, Y+1	; 0x01
    292e:	01 90       	ld	r0, Z+
    2930:	f0 81       	ld	r31, Z
    2932:	e0 2d       	mov	r30, r0
    2934:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2936:	1a 82       	std	Y+2, r1	; 0x02
    2938:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    293a:	6f ef       	ldi	r22, 0xFF	; 255
    293c:	7f ef       	ldi	r23, 0xFF	; 255
    293e:	cb 01       	movw	r24, r22
    2940:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskDelay>
    2944:	fa cf       	rjmp	.-12     	; 0x293a <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002946 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2946:	fc 01       	movw	r30, r24
    2948:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    294a:	65 87       	std	Z+13, r22	; 0x0d
    294c:	08 95       	ret

0000294e <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    294e:	4f 92       	push	r4
    2950:	5f 92       	push	r5
    2952:	6f 92       	push	r6
    2954:	7f 92       	push	r7
    2956:	8f 92       	push	r8
    2958:	9f 92       	push	r9
    295a:	af 92       	push	r10
    295c:	bf 92       	push	r11
    295e:	cf 92       	push	r12
    2960:	df 92       	push	r13
    2962:	ef 92       	push	r14
    2964:	ff 92       	push	r15
    2966:	0f 93       	push	r16
    2968:	1f 93       	push	r17
    296a:	cf 93       	push	r28
    296c:	df 93       	push	r29
    296e:	cd b7       	in	r28, 0x3d	; 61
    2970:	de b7       	in	r29, 0x3e	; 62
    2972:	2a 97       	sbiw	r28, 0x0a	; 10
    2974:	cd bf       	out	0x3d, r28	; 61
    2976:	de bf       	out	0x3e, r29	; 62
    2978:	4c 01       	movw	r8, r24
    297a:	29 01       	movw	r4, r18
    297c:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    297e:	8c e5       	ldi	r24, 0x5C	; 92
    2980:	90 e2       	ldi	r25, 0x20	; 32
    2982:	f4 01       	movw	r30, r8
    2984:	80 83       	st	Z, r24
    2986:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2988:	fb 01       	movw	r30, r22
    298a:	80 81       	ld	r24, Z
    298c:	88 23       	and	r24, r24
    298e:	69 f0       	breq	.+26     	; 0x29aa <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2990:	de 01       	movw	r26, r28
    2992:	11 96       	adiw	r26, 0x01	; 1
    2994:	31 96       	adiw	r30, 0x01	; 1
    2996:	90 e0       	ldi	r25, 0x00	; 0
    2998:	02 c0       	rjmp	.+4      	; 0x299e <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    299a:	99 30       	cpi	r25, 0x09	; 9
    299c:	39 f0       	breq	.+14     	; 0x29ac <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    299e:	9f 5f       	subi	r25, 0xFF	; 255
    29a0:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    29a2:	81 91       	ld	r24, Z+
    29a4:	81 11       	cpse	r24, r1
    29a6:	f9 cf       	rjmp	.-14     	; 0x299a <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    29a8:	01 c0       	rjmp	.+2      	; 0x29ac <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    29aa:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    29ac:	e1 e0       	ldi	r30, 0x01	; 1
    29ae:	f0 e0       	ldi	r31, 0x00	; 0
    29b0:	ec 0f       	add	r30, r28
    29b2:	fd 1f       	adc	r31, r29
    29b4:	e9 0f       	add	r30, r25
    29b6:	f1 1d       	adc	r31, r1
    29b8:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    29ba:	74 01       	movw	r14, r8
    29bc:	f2 e0       	ldi	r31, 0x02	; 2
    29be:	ef 0e       	add	r14, r31
    29c0:	f1 1c       	adc	r15, r1
    29c2:	a1 2c       	mov	r10, r1
    29c4:	b1 2c       	mov	r11, r1
    29c6:	c1 2c       	mov	r12, r1
    29c8:	d1 2c       	mov	r13, r1
    29ca:	04 2f       	mov	r16, r20
    29cc:	94 01       	movw	r18, r8
    29ce:	a2 01       	movw	r20, r4
    29d0:	be 01       	movw	r22, r28
    29d2:	6f 5f       	subi	r22, 0xFF	; 255
    29d4:	7f 4f       	sbci	r23, 0xFF	; 255
    29d6:	8a ea       	ldi	r24, 0xAA	; 170
    29d8:	92 e0       	ldi	r25, 0x02	; 2
    29da:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    29de:	f4 01       	movw	r30, r8
    29e0:	66 82       	std	Z+6, r6	; 0x06
    29e2:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    29e4:	40 86       	std	Z+8, r4	; 0x08
    29e6:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    29e8:	20 91 60 31 	lds	r18, 0x3160	; 0x803160 <last_created_task_pointer>
    29ec:	30 91 61 31 	lds	r19, 0x3161	; 0x803161 <last_created_task_pointer+0x1>
    29f0:	24 83       	std	Z+4, r18	; 0x04
    29f2:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29f4:	80 92 60 31 	sts	0x3160, r8	; 0x803160 <last_created_task_pointer>
    29f8:	90 92 61 31 	sts	0x3161, r9	; 0x803161 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29fc:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29fe:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2a00:	40 90 9a 31 	lds	r4, 0x319A	; 0x80319a <portStackTopForTask>
    2a04:	50 90 9b 31 	lds	r5, 0x319B	; 0x80319b <portStackTopForTask+0x1>
    2a08:	ff ef       	ldi	r31, 0xFF	; 255
    2a0a:	4f 1a       	sub	r4, r31
    2a0c:	5f 0a       	sbc	r5, r31
    2a0e:	40 92 9a 31 	sts	0x319A, r4	; 0x80319a <portStackTopForTask>
    2a12:	50 92 9b 31 	sts	0x319B, r5	; 0x80319b <portStackTopForTask+0x1>
    2a16:	f4 01       	movw	r30, r8
    2a18:	42 86       	std	Z+10, r4	; 0x0a
    2a1a:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2a1c:	16 86       	std	Z+14, r1	; 0x0e
    2a1e:	17 86       	std	Z+15, r1	; 0x0f
    2a20:	10 8a       	std	Z+16, r1	; 0x10
    2a22:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2a24:	61 14       	cp	r6, r1
    2a26:	71 04       	cpc	r7, r1
    2a28:	09 f4       	brne	.+2      	; 0x2a2c <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a2a:	44 c0       	rjmp	.+136    	; 0x2ab4 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a2c:	81 30       	cpi	r24, 0x01	; 1
    2a2e:	79 f5       	brne	.+94     	; 0x2a8e <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a30:	6a e0       	ldi	r22, 0x0A	; 10
    2a32:	c3 01       	movw	r24, r6
    2a34:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2a38:	7c 01       	movw	r14, r24
    2a3a:	61 ea       	ldi	r22, 0xA1	; 161
    2a3c:	74 e0       	ldi	r23, 0x04	; 4
    2a3e:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2a42:	be 01       	movw	r22, r28
    2a44:	6f 5f       	subi	r22, 0xFF	; 255
    2a46:	7f 4f       	sbci	r23, 0xFF	; 255
    2a48:	c7 01       	movw	r24, r14
    2a4a:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2a4e:	6a e0       	ldi	r22, 0x0A	; 10
    2a50:	c7 01       	movw	r24, r14
    2a52:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2a56:	7c 01       	movw	r14, r24
    2a58:	68 e9       	ldi	r22, 0x98	; 152
    2a5a:	74 e0       	ldi	r23, 0x04	; 4
    2a5c:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a60:	6a e0       	ldi	r22, 0x0A	; 10
    2a62:	c7 01       	movw	r24, r14
    2a64:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2a68:	7c 01       	movw	r14, r24
    2a6a:	6a e8       	ldi	r22, 0x8A	; 138
    2a6c:	74 e0       	ldi	r23, 0x04	; 4
    2a6e:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2a72:	63 e0       	ldi	r22, 0x03	; 3
    2a74:	c7 01       	movw	r24, r14
    2a76:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2a7a:	b2 01       	movw	r22, r4
    2a7c:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEj>
    2a80:	62 e0       	ldi	r22, 0x02	; 2
    2a82:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2a86:	66 e0       	ldi	r22, 0x06	; 6
    2a88:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2a8c:	13 c0       	rjmp	.+38     	; 0x2ab4 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a8e:	6a e0       	ldi	r22, 0x0A	; 10
    2a90:	c3 01       	movw	r24, r6
    2a92:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2a96:	4c 01       	movw	r8, r24
    2a98:	65 e7       	ldi	r22, 0x75	; 117
    2a9a:	74 e0       	ldi	r23, 0x04	; 4
    2a9c:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2aa0:	be 01       	movw	r22, r28
    2aa2:	6f 5f       	subi	r22, 0xFF	; 255
    2aa4:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa6:	c4 01       	movw	r24, r8
    2aa8:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2aac:	66 e0       	ldi	r22, 0x06	; 6
    2aae:	c4 01       	movw	r24, r8
    2ab0:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2ab4:	2a 96       	adiw	r28, 0x0a	; 10
    2ab6:	cd bf       	out	0x3d, r28	; 61
    2ab8:	de bf       	out	0x3e, r29	; 62
    2aba:	df 91       	pop	r29
    2abc:	cf 91       	pop	r28
    2abe:	1f 91       	pop	r17
    2ac0:	0f 91       	pop	r16
    2ac2:	ff 90       	pop	r15
    2ac4:	ef 90       	pop	r14
    2ac6:	df 90       	pop	r13
    2ac8:	cf 90       	pop	r12
    2aca:	bf 90       	pop	r11
    2acc:	af 90       	pop	r10
    2ace:	9f 90       	pop	r9
    2ad0:	8f 90       	pop	r8
    2ad2:	7f 90       	pop	r7
    2ad4:	6f 90       	pop	r6
    2ad6:	5f 90       	pop	r5
    2ad8:	4f 90       	pop	r4
    2ada:	08 95       	ret

00002adc <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2adc:	cf 92       	push	r12
    2ade:	df 92       	push	r13
    2ae0:	ef 92       	push	r14
    2ae2:	ff 92       	push	r15
    2ae4:	0f 93       	push	r16
    2ae6:	1f 93       	push	r17
    2ae8:	cf 93       	push	r28
    2aea:	df 93       	push	r29
    2aec:	ec 01       	movw	r28, r24
    2aee:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2af0:	8a 81       	ldd	r24, Y+2	; 0x02
    2af2:	9b 81       	ldd	r25, Y+3	; 0x03
    2af4:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <pcTaskGetTaskName>
    2af8:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2afa:	6a e0       	ldi	r22, 0x0A	; 10
    2afc:	c7 01       	movw	r24, r14
    2afe:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2b02:	8c 01       	movw	r16, r24
    2b04:	64 eb       	ldi	r22, 0xB4	; 180
    2b06:	74 e0       	ldi	r23, 0x04	; 4
    2b08:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2b0c:	6a e0       	ldi	r22, 0x0A	; 10
    2b0e:	c8 01       	movw	r24, r16
    2b10:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2b14:	8c 01       	movw	r16, r24
    2b16:	6d ea       	ldi	r22, 0xAD	; 173
    2b18:	74 e0       	ldi	r23, 0x04	; 4
    2b1a:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2b1e:	b6 01       	movw	r22, r12
    2b20:	c8 01       	movw	r24, r16
    2b22:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2b26:	6a e0       	ldi	r22, 0x0A	; 10
    2b28:	c8 01       	movw	r24, r16
    2b2a:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2b2e:	8c 01       	movw	r16, r24
    2b30:	67 ea       	ldi	r22, 0xA7	; 167
    2b32:	74 e0       	ldi	r23, 0x04	; 4
    2b34:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2b38:	66 e0       	ldi	r22, 0x06	; 6
    2b3a:	c8 01       	movw	r24, r16
    2b3c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b40:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b42:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b44:	e8 85       	ldd	r30, Y+8	; 0x08
    2b46:	f9 85       	ldd	r31, Y+9	; 0x09
    2b48:	01 e1       	ldi	r16, 0x11	; 17
    2b4a:	21 e0       	ldi	r18, 0x01	; 1
    2b4c:	a7 01       	movw	r20, r14
    2b4e:	bc 01       	movw	r22, r24
    2b50:	8e 1b       	sub	r24, r30
    2b52:	9f 0b       	sbc	r25, r31
    2b54:	0e 94 70 18 	call	0x30e0	; 0x30e0 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b58:	8c 81       	ldd	r24, Y+4	; 0x04
    2b5a:	9d 81       	ldd	r25, Y+5	; 0x05
    2b5c:	00 97       	sbiw	r24, 0x00	; 0
    2b5e:	19 f0       	breq	.+6      	; 0x2b66 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b60:	b7 01       	movw	r22, r14
    2b62:	0e 94 6e 15 	call	0x2adc	; 0x2adc <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	1f 91       	pop	r17
    2b6c:	0f 91       	pop	r16
    2b6e:	ff 90       	pop	r15
    2b70:	ef 90       	pop	r14
    2b72:	df 90       	pop	r13
    2b74:	cf 90       	pop	r12
    2b76:	08 95       	ret

00002b78 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b78:	0f 93       	push	r16
    2b7a:	1f 93       	push	r17
    2b7c:	cf 93       	push	r28
    2b7e:	df 93       	push	r29
    2b80:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b82:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <last_created_task_pointer>
    2b86:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <last_created_task_pointer+0x1>
    2b8a:	00 97       	sbiw	r24, 0x00	; 0
    2b8c:	19 f0       	breq	.+6      	; 0x2b94 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b8e:	be 01       	movw	r22, r28
    2b90:	0e 94 6e 15 	call	0x2adc	; 0x2adc <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b94:	6a e0       	ldi	r22, 0x0A	; 10
    2b96:	ce 01       	movw	r24, r28
    2b98:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2b9c:	8c 01       	movw	r16, r24
    2b9e:	6a ec       	ldi	r22, 0xCA	; 202
    2ba0:	74 e0       	ldi	r23, 0x04	; 4
    2ba2:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2ba6:	6a e0       	ldi	r22, 0x0A	; 10
    2ba8:	c8 01       	movw	r24, r16
    2baa:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2bae:	8c 01       	movw	r16, r24
    2bb0:	6f eb       	ldi	r22, 0xBF	; 191
    2bb2:	74 e0       	ldi	r23, 0x04	; 4
    2bb4:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2bb8:	6a e0       	ldi	r22, 0x0A	; 10
    2bba:	c8 01       	movw	r24, r16
    2bbc:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2bc0:	8c 01       	movw	r16, r24
    2bc2:	69 eb       	ldi	r22, 0xB9	; 185
    2bc4:	74 e0       	ldi	r23, 0x04	; 4
    2bc6:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2bca:	66 e0       	ldi	r22, 0x06	; 6
    2bcc:	c8 01       	movw	r24, r16
    2bce:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2bd2:	80 91 9a 31 	lds	r24, 0x319A	; 0x80319a <portStackTopForTask>
    2bd6:	90 91 9b 31 	lds	r25, 0x319B	; 0x80319b <portStackTopForTask+0x1>
    2bda:	bc 01       	movw	r22, r24
    2bdc:	6f 5f       	subi	r22, 0xFF	; 255
    2bde:	7f 4f       	sbci	r23, 0xFF	; 255
    2be0:	01 e1       	ldi	r16, 0x11	; 17
    2be2:	21 e0       	ldi	r18, 0x01	; 1
    2be4:	ae 01       	movw	r20, r28
    2be6:	83 56       	subi	r24, 0x63	; 99
    2be8:	91 09       	sbc	r25, r1
    2bea:	0e 94 70 18 	call	0x30e0	; 0x30e0 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2bee:	df 91       	pop	r29
    2bf0:	cf 91       	pop	r28
    2bf2:	1f 91       	pop	r17
    2bf4:	0f 91       	pop	r16
    2bf6:	08 95       	ret

00002bf8 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2bf8:	8f 92       	push	r8
    2bfa:	9f 92       	push	r9
    2bfc:	af 92       	push	r10
    2bfe:	bf 92       	push	r11
    2c00:	cf 92       	push	r12
    2c02:	df 92       	push	r13
    2c04:	ef 92       	push	r14
    2c06:	ff 92       	push	r15
    2c08:	0f 93       	push	r16
    2c0a:	1f 93       	push	r17
    2c0c:	cf 93       	push	r28
    2c0e:	df 93       	push	r29
    2c10:	ec 01       	movw	r28, r24
    2c12:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2c14:	8a 81       	ldd	r24, Y+2	; 0x02
    2c16:	9b 81       	ldd	r25, Y+3	; 0x03
    2c18:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <pcTaskGetTaskName>
    2c1c:	bc 01       	movw	r22, r24
    2c1e:	c8 01       	movw	r24, r16
    2c20:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2c24:	d8 01       	movw	r26, r16
    2c26:	ed 91       	ld	r30, X+
    2c28:	fc 91       	ld	r31, X
    2c2a:	02 80       	ldd	r0, Z+2	; 0x02
    2c2c:	f3 81       	ldd	r31, Z+3	; 0x03
    2c2e:	e0 2d       	mov	r30, r0
    2c30:	69 e0       	ldi	r22, 0x09	; 9
    2c32:	c8 01       	movw	r24, r16
    2c34:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c36:	8a 81       	ldd	r24, Y+2	; 0x02
    2c38:	9b 81       	ldd	r25, Y+3	; 0x03
    2c3a:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <pcTaskGetTaskName>
    2c3e:	fc 01       	movw	r30, r24
    2c40:	01 90       	ld	r0, Z+
    2c42:	00 20       	and	r0, r0
    2c44:	e9 f7       	brne	.-6      	; 0x2c40 <_ZN8frt_task12print_statusER8emstream+0x48>
    2c46:	31 97       	sbiw	r30, 0x01	; 1
    2c48:	e8 1b       	sub	r30, r24
    2c4a:	f9 0b       	sbc	r31, r25
    2c4c:	38 97       	sbiw	r30, 0x08	; 8
    2c4e:	48 f4       	brcc	.+18     	; 0x2c62 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2c50:	d8 01       	movw	r26, r16
    2c52:	ed 91       	ld	r30, X+
    2c54:	fc 91       	ld	r31, X
    2c56:	02 80       	ldd	r0, Z+2	; 0x02
    2c58:	f3 81       	ldd	r31, Z+3	; 0x03
    2c5a:	e0 2d       	mov	r30, r0
    2c5c:	69 e0       	ldi	r22, 0x09	; 9
    2c5e:	c8 01       	movw	r24, r16
    2c60:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c62:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c64:	df 84       	ldd	r13, Y+15	; 0x0f
    2c66:	e8 88       	ldd	r14, Y+16	; 0x10
    2c68:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c6a:	a8 84       	ldd	r10, Y+8	; 0x08
    2c6c:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c70:	9b 81       	ldd	r25, Y+3	; 0x03
    2c72:	0e 94 ed 13 	call	0x27da	; 0x27da <uxTaskGetStackHighWaterMark>
    2c76:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c78:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c7e:	0e 94 25 10 	call	0x204a	; 0x204a <uxTaskPriorityGet>
    2c82:	68 2f       	mov	r22, r24
    2c84:	c8 01       	movw	r24, r16
    2c86:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
    2c8a:	6a e0       	ldi	r22, 0x0A	; 10
    2c8c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2c90:	ec 01       	movw	r28, r24
    2c92:	6f e3       	ldi	r22, 0x3F	; 63
    2c94:	75 e0       	ldi	r23, 0x05	; 5
    2c96:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c9a:	68 2d       	mov	r22, r8
    2c9c:	ce 01       	movw	r24, r28
    2c9e:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2ca2:	6a e0       	ldi	r22, 0x0A	; 10
    2ca4:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2ca8:	ec 01       	movw	r28, r24
    2caa:	6d e3       	ldi	r22, 0x3D	; 61
    2cac:	75 e0       	ldi	r23, 0x05	; 5
    2cae:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2cb2:	69 2d       	mov	r22, r9
    2cb4:	ce 01       	movw	r24, r28
    2cb6:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
    2cba:	6a e0       	ldi	r22, 0x0A	; 10
    2cbc:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2cc0:	ec 01       	movw	r28, r24
    2cc2:	6b e3       	ldi	r22, 0x3B	; 59
    2cc4:	75 e0       	ldi	r23, 0x05	; 5
    2cc6:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2cca:	b5 01       	movw	r22, r10
    2ccc:	ce 01       	movw	r24, r28
    2cce:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEj>
    2cd2:	6a e0       	ldi	r22, 0x0A	; 10
    2cd4:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2cd8:	ec 01       	movw	r28, r24
    2cda:	69 e3       	ldi	r22, 0x39	; 57
    2cdc:	75 e0       	ldi	r23, 0x05	; 5
    2cde:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2ce2:	6a e0       	ldi	r22, 0x0A	; 10
    2ce4:	ce 01       	movw	r24, r28
    2ce6:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2cea:	ec 01       	movw	r28, r24
    2cec:	67 e3       	ldi	r22, 0x37	; 55
    2cee:	75 e0       	ldi	r23, 0x05	; 5
    2cf0:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2cf4:	b7 01       	movw	r22, r14
    2cf6:	a6 01       	movw	r20, r12
    2cf8:	ce 01       	movw	r24, r28
    2cfa:	0e 94 b0 1a 	call	0x3560	; 0x3560 <_ZN8emstreamlsEm>
}
    2cfe:	df 91       	pop	r29
    2d00:	cf 91       	pop	r28
    2d02:	1f 91       	pop	r17
    2d04:	0f 91       	pop	r16
    2d06:	ff 90       	pop	r15
    2d08:	ef 90       	pop	r14
    2d0a:	df 90       	pop	r13
    2d0c:	cf 90       	pop	r12
    2d0e:	bf 90       	pop	r11
    2d10:	af 90       	pop	r10
    2d12:	9f 90       	pop	r9
    2d14:	8f 90       	pop	r8
    2d16:	08 95       	ret

00002d18 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2d18:	cf 93       	push	r28
    2d1a:	df 93       	push	r29
    2d1c:	ec 01       	movw	r28, r24
    2d1e:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2d20:	db 01       	movw	r26, r22
    2d22:	ed 91       	ld	r30, X+
    2d24:	fc 91       	ld	r31, X
    2d26:	02 80       	ldd	r0, Z+2	; 0x02
    2d28:	f3 81       	ldd	r31, Z+3	; 0x03
    2d2a:	e0 2d       	mov	r30, r0
    2d2c:	be 01       	movw	r22, r28
    2d2e:	19 95       	eicall
	return (ser_dev);
}
    2d30:	ce 01       	movw	r24, r28
    2d32:	df 91       	pop	r29
    2d34:	cf 91       	pop	r28
    2d36:	08 95       	ret

00002d38 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2d38:	0f 93       	push	r16
    2d3a:	1f 93       	push	r17
    2d3c:	cf 93       	push	r28
    2d3e:	df 93       	push	r29
    2d40:	ec 01       	movw	r28, r24
    2d42:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d44:	bc 01       	movw	r22, r24
    2d46:	c8 01       	movw	r24, r16
    2d48:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZlsR8emstreamR8frt_task>
    2d4c:	66 e0       	ldi	r22, 0x06	; 6
    2d4e:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d52:	8c 81       	ldd	r24, Y+4	; 0x04
    2d54:	9d 81       	ldd	r25, Y+5	; 0x05
    2d56:	00 97       	sbiw	r24, 0x00	; 0
    2d58:	19 f0       	breq	.+6      	; 0x2d60 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d5a:	b8 01       	movw	r22, r16
    2d5c:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d60:	df 91       	pop	r29
    2d62:	cf 91       	pop	r28
    2d64:	1f 91       	pop	r17
    2d66:	0f 91       	pop	r16
    2d68:	08 95       	ret

00002d6a <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d6a:	0f 93       	push	r16
    2d6c:	1f 93       	push	r17
    2d6e:	cf 93       	push	r28
    2d70:	df 93       	push	r29
    2d72:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d74:	6a e0       	ldi	r22, 0x0A	; 10
    2d76:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2d7a:	8c 01       	movw	r16, r24
    2d7c:	6c e2       	ldi	r22, 0x2C	; 44
    2d7e:	75 e0       	ldi	r23, 0x05	; 5
    2d80:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d84:	6a e0       	ldi	r22, 0x0A	; 10
    2d86:	c8 01       	movw	r24, r16
    2d88:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2d8c:	8c 01       	movw	r16, r24
    2d8e:	65 e2       	ldi	r22, 0x25	; 37
    2d90:	75 e0       	ldi	r23, 0x05	; 5
    2d92:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d96:	66 e0       	ldi	r22, 0x06	; 6
    2d98:	c8 01       	movw	r24, r16
    2d9a:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d9e:	6a e0       	ldi	r22, 0x0A	; 10
    2da0:	ce 01       	movw	r24, r28
    2da2:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2da6:	8c 01       	movw	r16, r24
    2da8:	64 e1       	ldi	r22, 0x14	; 20
    2daa:	75 e0       	ldi	r23, 0x05	; 5
    2dac:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2db0:	6a e0       	ldi	r22, 0x0A	; 10
    2db2:	c8 01       	movw	r24, r16
    2db4:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2db8:	8c 01       	movw	r16, r24
    2dba:	68 e0       	ldi	r22, 0x08	; 8
    2dbc:	75 e0       	ldi	r23, 0x05	; 5
    2dbe:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2dc2:	6a e0       	ldi	r22, 0x0A	; 10
    2dc4:	c8 01       	movw	r24, r16
    2dc6:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2dca:	8c 01       	movw	r16, r24
    2dcc:	62 e0       	ldi	r22, 0x02	; 2
    2dce:	75 e0       	ldi	r23, 0x05	; 5
    2dd0:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2dd4:	66 e0       	ldi	r22, 0x06	; 6
    2dd6:	c8 01       	movw	r24, r16
    2dd8:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2ddc:	6a e0       	ldi	r22, 0x0A	; 10
    2dde:	ce 01       	movw	r24, r28
    2de0:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2de4:	8c 01       	movw	r16, r24
    2de6:	61 ef       	ldi	r22, 0xF1	; 241
    2de8:	74 e0       	ldi	r23, 0x04	; 4
    2dea:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2dee:	6a e0       	ldi	r22, 0x0A	; 10
    2df0:	c8 01       	movw	r24, r16
    2df2:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2df6:	8c 01       	movw	r16, r24
    2df8:	65 ee       	ldi	r22, 0xE5	; 229
    2dfa:	74 e0       	ldi	r23, 0x04	; 4
    2dfc:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2e00:	6a e0       	ldi	r22, 0x0A	; 10
    2e02:	c8 01       	movw	r24, r16
    2e04:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2e08:	8c 01       	movw	r16, r24
    2e0a:	6f ed       	ldi	r22, 0xDF	; 223
    2e0c:	74 e0       	ldi	r23, 0x04	; 4
    2e0e:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2e12:	66 e0       	ldi	r22, 0x06	; 6
    2e14:	c8 01       	movw	r24, r16
    2e16:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2e1a:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <last_created_task_pointer>
    2e1e:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <last_created_task_pointer+0x1>
    2e22:	00 97       	sbiw	r24, 0x00	; 0
    2e24:	19 f0       	breq	.+6      	; 0x2e2c <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2e26:	be 01       	movw	r22, r28
    2e28:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e2c:	0e 94 82 10 	call	0x2104	; 0x2104 <xTaskGetIdleTaskHandle>
    2e30:	0e 94 ed 13 	call	0x27da	; 0x27da <uxTaskGetStackHighWaterMark>
    2e34:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2e36:	6a e0       	ldi	r22, 0x0A	; 10
    2e38:	ce 01       	movw	r24, r28
    2e3a:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2e3e:	ec 01       	movw	r28, r24
    2e40:	64 ed       	ldi	r22, 0xD4	; 212
    2e42:	74 e0       	ldi	r23, 0x04	; 4
    2e44:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e48:	61 2f       	mov	r22, r17
    2e4a:	ce 01       	movw	r24, r28
    2e4c:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2e50:	6a e0       	ldi	r22, 0x0A	; 10
    2e52:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2e56:	ec 01       	movw	r28, r24
    2e58:	62 ed       	ldi	r22, 0xD2	; 210
    2e5a:	74 e0       	ldi	r23, 0x04	; 4
    2e5c:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    2e60:	64 e6       	ldi	r22, 0x64	; 100
    2e62:	70 e0       	ldi	r23, 0x00	; 0
    2e64:	ce 01       	movw	r24, r28
    2e66:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEj>
    2e6a:	6a e0       	ldi	r22, 0x0A	; 10
    2e6c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    2e70:	ec 01       	movw	r28, r24
    2e72:	6f ec       	ldi	r22, 0xCF	; 207
    2e74:	74 e0       	ldi	r23, 0x04	; 4
    2e76:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e7a:	66 e0       	ldi	r22, 0x06	; 6
    2e7c:	ce 01       	movw	r24, r28
    2e7e:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
}
    2e82:	df 91       	pop	r29
    2e84:	cf 91       	pop	r28
    2e86:	1f 91       	pop	r17
    2e88:	0f 91       	pop	r16
    2e8a:	08 95       	ret

00002e8c <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e8c:	0f 93       	push	r16
    2e8e:	cf 93       	push	r28
    2e90:	df 93       	push	r29
    2e92:	1f 92       	push	r1
    2e94:	cd b7       	in	r28, 0x3d	; 61
    2e96:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e98:	00 e0       	ldi	r16, 0x00	; 0
    2e9a:	2f ef       	ldi	r18, 0xFF	; 255
    2e9c:	3f ef       	ldi	r19, 0xFF	; 255
    2e9e:	a9 01       	movw	r20, r18
    2ea0:	be 01       	movw	r22, r28
    2ea2:	6f 5f       	subi	r22, 0xFF	; 255
    2ea4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ea6:	fc 01       	movw	r30, r24
    2ea8:	80 85       	ldd	r24, Z+8	; 0x08
    2eaa:	91 85       	ldd	r25, Z+9	; 0x09
    2eac:	0e 94 01 0e 	call	0x1c02	; 0x1c02 <xQueueGenericReceive>
    2eb0:	81 30       	cpi	r24, 0x01	; 1
    2eb2:	19 f4       	brne	.+6      	; 0x2eba <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2eb4:	89 81       	ldd	r24, Y+1	; 0x01
    2eb6:	90 e0       	ldi	r25, 0x00	; 0
    2eb8:	02 c0       	rjmp	.+4      	; 0x2ebe <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2eba:	8f ef       	ldi	r24, 0xFF	; 255
    2ebc:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2ebe:	0f 90       	pop	r0
    2ec0:	df 91       	pop	r29
    2ec2:	cf 91       	pop	r28
    2ec4:	0f 91       	pop	r16
    2ec6:	08 95       	ret

00002ec8 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2ec8:	fc 01       	movw	r30, r24
    2eca:	80 85       	ldd	r24, Z+8	; 0x08
    2ecc:	91 85       	ldd	r25, Z+9	; 0x09
    2ece:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <uxQueueMessagesWaiting>
    2ed2:	91 e0       	ldi	r25, 0x01	; 1
    2ed4:	81 11       	cpse	r24, r1
    2ed6:	01 c0       	rjmp	.+2      	; 0x2eda <_ZN14frt_text_queue14check_for_charEv+0x12>
    2ed8:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2eda:	89 2f       	mov	r24, r25
    2edc:	08 95       	ret

00002ede <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2ede:	0f 93       	push	r16
    2ee0:	cf 93       	push	r28
    2ee2:	df 93       	push	r29
    2ee4:	1f 92       	push	r1
    2ee6:	cd b7       	in	r28, 0x3d	; 61
    2ee8:	de b7       	in	r29, 0x3e	; 62
    2eea:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2eec:	fc 01       	movw	r30, r24
    2eee:	22 85       	ldd	r18, Z+10	; 0x0a
    2ef0:	33 85       	ldd	r19, Z+11	; 0x0b
    2ef2:	44 85       	ldd	r20, Z+12	; 0x0c
    2ef4:	55 85       	ldd	r21, Z+13	; 0x0d
    2ef6:	00 e0       	ldi	r16, 0x00	; 0
    2ef8:	be 01       	movw	r22, r28
    2efa:	6f 5f       	subi	r22, 0xFF	; 255
    2efc:	7f 4f       	sbci	r23, 0xFF	; 255
    2efe:	80 85       	ldd	r24, Z+8	; 0x08
    2f00:	91 85       	ldd	r25, Z+9	; 0x09
    2f02:	0e 94 66 0d 	call	0x1acc	; 0x1acc <xQueueGenericSend>
    2f06:	91 e0       	ldi	r25, 0x01	; 1
    2f08:	81 11       	cpse	r24, r1
    2f0a:	01 c0       	rjmp	.+2      	; 0x2f0e <_ZN14frt_text_queue7putcharEc+0x30>
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2f0e:	89 2f       	mov	r24, r25
    2f10:	0f 90       	pop	r0
    2f12:	df 91       	pop	r29
    2f14:	cf 91       	pop	r28
    2f16:	0f 91       	pop	r16
    2f18:	08 95       	ret

00002f1a <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2f1a:	8f 92       	push	r8
    2f1c:	9f 92       	push	r9
    2f1e:	bf 92       	push	r11
    2f20:	cf 92       	push	r12
    2f22:	df 92       	push	r13
    2f24:	ef 92       	push	r14
    2f26:	ff 92       	push	r15
    2f28:	0f 93       	push	r16
    2f2a:	1f 93       	push	r17
    2f2c:	cf 93       	push	r28
    2f2e:	df 93       	push	r29
    2f30:	ec 01       	movw	r28, r24
    2f32:	b6 2e       	mov	r11, r22
    2f34:	4a 01       	movw	r8, r20
    2f36:	68 01       	movw	r12, r16
    2f38:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f3a:	0e 94 c7 19 	call	0x338e	; 0x338e <_ZN8emstreamC1Ev>
    2f3e:	84 e6       	ldi	r24, 0x64	; 100
    2f40:	90 e2       	ldi	r25, 0x20	; 32
    2f42:	88 83       	st	Y, r24
    2f44:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f46:	8e 86       	std	Y+14, r8	; 0x0e
    2f48:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f4a:	40 e0       	ldi	r20, 0x00	; 0
    2f4c:	61 e0       	ldi	r22, 0x01	; 1
    2f4e:	8b 2d       	mov	r24, r11
    2f50:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <xQueueGenericCreate>
    2f54:	88 87       	std	Y+8, r24	; 0x08
    2f56:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f58:	ca 86       	std	Y+10, r12	; 0x0a
    2f5a:	db 86       	std	Y+11, r13	; 0x0b
    2f5c:	ec 86       	std	Y+12, r14	; 0x0c
    2f5e:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f60:	df 91       	pop	r29
    2f62:	cf 91       	pop	r28
    2f64:	1f 91       	pop	r17
    2f66:	0f 91       	pop	r16
    2f68:	ff 90       	pop	r15
    2f6a:	ef 90       	pop	r14
    2f6c:	df 90       	pop	r13
    2f6e:	cf 90       	pop	r12
    2f70:	bf 90       	pop	r11
    2f72:	9f 90       	pop	r9
    2f74:	8f 90       	pop	r8
    2f76:	08 95       	ret

00002f78 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f78:	cf 92       	push	r12
    2f7a:	df 92       	push	r13
    2f7c:	ef 92       	push	r14
    2f7e:	ff 92       	push	r15
    2f80:	cf 93       	push	r28
    2f82:	df 93       	push	r29
    2f84:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f86:	68 81       	ld	r22, Y
    2f88:	79 81       	ldd	r23, Y+1	; 0x01
    2f8a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f8c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f8e:	0f 2e       	mov	r0, r31
    2f90:	f8 ee       	ldi	r31, 0xE8	; 232
    2f92:	cf 2e       	mov	r12, r31
    2f94:	f3 e0       	ldi	r31, 0x03	; 3
    2f96:	df 2e       	mov	r13, r31
    2f98:	e1 2c       	mov	r14, r1
    2f9a:	f1 2c       	mov	r15, r1
    2f9c:	f0 2d       	mov	r31, r0
    2f9e:	a7 01       	movw	r20, r14
    2fa0:	96 01       	movw	r18, r12
    2fa2:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__udivmodsi4>
    2fa6:	9b 01       	movw	r18, r22
    2fa8:	ac 01       	movw	r20, r24
    2faa:	60 e4       	ldi	r22, 0x40	; 64
    2fac:	72 e4       	ldi	r23, 0x42	; 66
    2fae:	8f e0       	ldi	r24, 0x0F	; 15
    2fb0:	90 e0       	ldi	r25, 0x00	; 0
    2fb2:	0e 94 6f 1f 	call	0x3ede	; 0x3ede <__mulsi3>
    2fb6:	a7 01       	movw	r20, r14
    2fb8:	96 01       	movw	r18, r12
    2fba:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__udivmodsi4>
    2fbe:	69 01       	movw	r12, r18
    2fc0:	7a 01       	movw	r14, r20
    2fc2:	ac 81       	ldd	r26, Y+4	; 0x04
    2fc4:	bd 81       	ldd	r27, Y+5	; 0x05
    2fc6:	20 e4       	ldi	r18, 0x40	; 64
    2fc8:	32 e4       	ldi	r19, 0x42	; 66
    2fca:	4f e0       	ldi	r20, 0x0F	; 15
    2fcc:	50 e0       	ldi	r21, 0x00	; 0
    2fce:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <__muluhisi3>
    2fd2:	20 e0       	ldi	r18, 0x00	; 0
    2fd4:	38 e4       	ldi	r19, 0x48	; 72
    2fd6:	48 ee       	ldi	r20, 0xE8	; 232
    2fd8:	51 e0       	ldi	r21, 0x01	; 1
    2fda:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__udivmodsi4>
    2fde:	c7 01       	movw	r24, r14
    2fe0:	b6 01       	movw	r22, r12
    2fe2:	62 0f       	add	r22, r18
    2fe4:	73 1f       	adc	r23, r19
    2fe6:	84 1f       	adc	r24, r20
    2fe8:	95 1f       	adc	r25, r21
}
    2fea:	df 91       	pop	r29
    2fec:	cf 91       	pop	r28
    2fee:	ff 90       	pop	r15
    2ff0:	ef 90       	pop	r14
    2ff2:	df 90       	pop	r13
    2ff4:	cf 90       	pop	r12
    2ff6:	08 95       	ret

00002ff8 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2ff8:	cf 92       	push	r12
    2ffa:	df 92       	push	r13
    2ffc:	ef 92       	push	r14
    2ffe:	ff 92       	push	r15
    3000:	0f 93       	push	r16
    3002:	1f 93       	push	r17
    3004:	cf 93       	push	r28
    3006:	df 93       	push	r29
    3008:	cd b7       	in	r28, 0x3d	; 61
    300a:	de b7       	in	r29, 0x3e	; 62
    300c:	2f 97       	sbiw	r28, 0x0f	; 15
    300e:	cd bf       	out	0x3d, r28	; 61
    3010:	de bf       	out	0x3e, r29	; 62
    3012:	6c 01       	movw	r12, r24
    3014:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3016:	db 01       	movw	r26, r22
    3018:	6d 91       	ld	r22, X+
    301a:	7d 91       	ld	r23, X+
    301c:	8d 91       	ld	r24, X+
    301e:	9c 91       	ld	r25, X
    3020:	28 ee       	ldi	r18, 0xE8	; 232
    3022:	33 e0       	ldi	r19, 0x03	; 3
    3024:	40 e0       	ldi	r20, 0x00	; 0
    3026:	50 e0       	ldi	r21, 0x00	; 0
    3028:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__udivmodsi4>
    302c:	ba 01       	movw	r22, r20
    302e:	a9 01       	movw	r20, r18
    3030:	c6 01       	movw	r24, r12
    3032:	0e 94 b0 1a 	call	0x3560	; 0x3560 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3036:	d6 01       	movw	r26, r12
    3038:	ed 91       	ld	r30, X+
    303a:	fc 91       	ld	r31, X
    303c:	02 80       	ldd	r0, Z+2	; 0x02
    303e:	f3 81       	ldd	r31, Z+3	; 0x03
    3040:	e0 2d       	mov	r30, r0
    3042:	6e e2       	ldi	r22, 0x2E	; 46
    3044:	c6 01       	movw	r24, r12
    3046:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3048:	c8 01       	movw	r24, r16
    304a:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN10time_stamp12get_microsecEv>
    304e:	8e 01       	movw	r16, r28
    3050:	09 5f       	subi	r16, 0xF9	; 249
    3052:	1f 4f       	sbci	r17, 0xFF	; 255
    3054:	fe 01       	movw	r30, r28
    3056:	31 96       	adiw	r30, 0x01	; 1
    3058:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    305a:	2a e0       	ldi	r18, 0x0A	; 10
    305c:	30 e0       	ldi	r19, 0x00	; 0
    305e:	40 e0       	ldi	r20, 0x00	; 0
    3060:	50 e0       	ldi	r21, 0x00	; 0
    3062:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <__divmodsi4>
    3066:	e6 2f       	mov	r30, r22
    3068:	28 87       	std	Y+8, r18	; 0x08
    306a:	39 87       	std	Y+9, r19	; 0x09
    306c:	4a 87       	std	Y+10, r20	; 0x0a
    306e:	5b 87       	std	Y+11, r21	; 0x0b
    3070:	68 85       	ldd	r22, Y+8	; 0x08
    3072:	79 85       	ldd	r23, Y+9	; 0x09
    3074:	8a 85       	ldd	r24, Y+10	; 0x0a
    3076:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3078:	20 e3       	ldi	r18, 0x30	; 48
    307a:	2e 0f       	add	r18, r30
    307c:	d8 01       	movw	r26, r16
    307e:	2e 93       	st	-X, r18
    3080:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3082:	ae 15       	cp	r26, r14
    3084:	bf 05       	cpc	r27, r15
    3086:	49 f7       	brne	.-46     	; 0x305a <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3088:	1f 82       	std	Y+7, r1	; 0x07
    308a:	be 01       	movw	r22, r28
    308c:	6f 5f       	subi	r22, 0xFF	; 255
    308e:	7f 4f       	sbci	r23, 0xFF	; 255
    3090:	c6 01       	movw	r24, r12
    3092:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3096:	c6 01       	movw	r24, r12
    3098:	2f 96       	adiw	r28, 0x0f	; 15
    309a:	cd bf       	out	0x3d, r28	; 61
    309c:	de bf       	out	0x3e, r29	; 62
    309e:	df 91       	pop	r29
    30a0:	cf 91       	pop	r28
    30a2:	1f 91       	pop	r17
    30a4:	0f 91       	pop	r16
    30a6:	ff 90       	pop	r15
    30a8:	ef 90       	pop	r14
    30aa:	df 90       	pop	r13
    30ac:	cf 90       	pop	r12
    30ae:	08 95       	ret

000030b0 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    30b0:	cf 93       	push	r28
    30b2:	df 93       	push	r29
    30b4:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    30b6:	0f b6       	in	r0, 0x3f	; 63
    30b8:	f8 94       	cli
    30ba:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    30bc:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    30c0:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    30c4:	8c 83       	std	Y+4, r24	; 0x04
    30c6:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    30c8:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <xTaskGetTickCount>
    30cc:	68 83       	st	Y, r22
    30ce:	79 83       	std	Y+1, r23	; 0x01
    30d0:	8a 83       	std	Y+2, r24	; 0x02
    30d2:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    30d4:	0f 90       	pop	r0
    30d6:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    30d8:	ce 01       	movw	r24, r28
    30da:	df 91       	pop	r29
    30dc:	cf 91       	pop	r28
    30de:	08 95       	ret

000030e0 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    30e0:	5f 92       	push	r5
    30e2:	6f 92       	push	r6
    30e4:	7f 92       	push	r7
    30e6:	8f 92       	push	r8
    30e8:	9f 92       	push	r9
    30ea:	af 92       	push	r10
    30ec:	bf 92       	push	r11
    30ee:	cf 92       	push	r12
    30f0:	df 92       	push	r13
    30f2:	ef 92       	push	r14
    30f4:	ff 92       	push	r15
    30f6:	0f 93       	push	r16
    30f8:	1f 93       	push	r17
    30fa:	cf 93       	push	r28
    30fc:	df 93       	push	r29
    30fe:	5c 01       	movw	r10, r24
    3100:	4b 01       	movw	r8, r22
    3102:	7a 01       	movw	r14, r20
    3104:	12 2f       	mov	r17, r18
    3106:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3108:	63 e0       	ldi	r22, 0x03	; 3
    310a:	ca 01       	movw	r24, r20
    310c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3110:	a8 14       	cp	r10, r8
    3112:	b9 04       	cpc	r11, r9
    3114:	08 f0       	brcs	.+2      	; 0x3118 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3116:	7d c0       	rjmp	.+250    	; 0x3212 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3118:	65 01       	movw	r12, r10
    311a:	84 e1       	ldi	r24, 0x14	; 20
    311c:	c8 0e       	add	r12, r24
    311e:	d1 1c       	adc	r13, r1
    3120:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3122:	6a 2c       	mov	r6, r10
    3124:	5b 2c       	mov	r5, r11
    3126:	b5 01       	movw	r22, r10
    3128:	c7 01       	movw	r24, r14
    312a:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEj>
    312e:	6a e0       	ldi	r22, 0x0A	; 10
    3130:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    3134:	61 e5       	ldi	r22, 0x51	; 81
    3136:	75 e0       	ldi	r23, 0x05	; 5
    3138:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    313c:	11 23       	and	r17, r17
    313e:	09 f4       	brne	.+2      	; 0x3142 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3140:	6d c0       	rjmp	.+218    	; 0x321c <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3142:	00 23       	and	r16, r16
    3144:	09 f4       	brne	.+2      	; 0x3148 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3146:	6a c0       	rjmp	.+212    	; 0x321c <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3148:	6a e0       	ldi	r22, 0x0A	; 10
    314a:	c7 01       	movw	r24, r14
    314c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    3150:	6c e4       	ldi	r22, 0x4C	; 76
    3152:	75 e0       	ldi	r23, 0x05	; 5
    3154:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    3158:	61 c0       	rjmp	.+194    	; 0x321c <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    315a:	11 23       	and	r17, r17
    315c:	71 f0       	breq	.+28     	; 0x317a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    315e:	01 11       	cpse	r16, r1
    3160:	0c c0       	rjmp	.+24     	; 0x317a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3162:	88 81       	ld	r24, Y
    3164:	87 15       	cp	r24, r7
    3166:	49 f0       	breq	.+18     	; 0x317a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3168:	6a e0       	ldi	r22, 0x0A	; 10
    316a:	c7 01       	movw	r24, r14
    316c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    3170:	67 e4       	ldi	r22, 0x47	; 71
    3172:	75 e0       	ldi	r23, 0x05	; 5
    3174:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3178:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    317a:	69 91       	ld	r22, Y+
    317c:	c7 01       	movw	r24, r14
    317e:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3182:	dc 01       	movw	r26, r24
    3184:	ed 91       	ld	r30, X+
    3186:	fc 91       	ld	r31, X
    3188:	02 80       	ldd	r0, Z+2	; 0x02
    318a:	f3 81       	ldd	r31, Z+3	; 0x03
    318c:	e0 2d       	mov	r30, r0
    318e:	60 e2       	ldi	r22, 0x20	; 32
    3190:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3192:	cc 16       	cp	r12, r28
    3194:	dd 06       	cpc	r13, r29
    3196:	09 f7       	brne	.-62     	; 0x315a <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3198:	11 23       	and	r17, r17
    319a:	89 f0       	breq	.+34     	; 0x31be <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    319c:	6a e0       	ldi	r22, 0x0A	; 10
    319e:	c7 01       	movw	r24, r14
    31a0:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    31a4:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    31a6:	61 e4       	ldi	r22, 0x41	; 65
    31a8:	75 e0       	ldi	r23, 0x05	; 5
    31aa:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    31ae:	e8 81       	ld	r30, Y
    31b0:	f9 81       	ldd	r31, Y+1	; 0x01
    31b2:	02 80       	ldd	r0, Z+2	; 0x02
    31b4:	f3 81       	ldd	r31, Z+3	; 0x03
    31b6:	e0 2d       	mov	r30, r0
    31b8:	60 e2       	ldi	r22, 0x20	; 32
    31ba:	ce 01       	movw	r24, r28
    31bc:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    31be:	c6 2d       	mov	r28, r6
    31c0:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    31c2:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    31c4:	80 ee       	ldi	r24, 0xE0	; 224
    31c6:	86 0f       	add	r24, r22
    31c8:	8f 35       	cpi	r24, 0x5F	; 95
    31ca:	48 f4       	brcc	.+18     	; 0x31de <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    31cc:	d7 01       	movw	r26, r14
    31ce:	ed 91       	ld	r30, X+
    31d0:	fc 91       	ld	r31, X
    31d2:	02 80       	ldd	r0, Z+2	; 0x02
    31d4:	f3 81       	ldd	r31, Z+3	; 0x03
    31d6:	e0 2d       	mov	r30, r0
    31d8:	c7 01       	movw	r24, r14
    31da:	19 95       	eicall
    31dc:	09 c0       	rjmp	.+18     	; 0x31f0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    31de:	d7 01       	movw	r26, r14
    31e0:	ed 91       	ld	r30, X+
    31e2:	fc 91       	ld	r31, X
    31e4:	02 80       	ldd	r0, Z+2	; 0x02
    31e6:	f3 81       	ldd	r31, Z+3	; 0x03
    31e8:	e0 2d       	mov	r30, r0
    31ea:	6e e2       	ldi	r22, 0x2E	; 46
    31ec:	c7 01       	movw	r24, r14
    31ee:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    31f0:	cc 16       	cp	r12, r28
    31f2:	dd 06       	cpc	r13, r29
    31f4:	31 f7       	brne	.-52     	; 0x31c2 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31f6:	b4 e1       	ldi	r27, 0x14	; 20
    31f8:	ab 0e       	add	r10, r27
    31fa:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31fc:	66 e0       	ldi	r22, 0x06	; 6
    31fe:	c7 01       	movw	r24, r14
    3200:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    3204:	84 e1       	ldi	r24, 0x14	; 20
    3206:	c8 0e       	add	r12, r24
    3208:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    320a:	a8 14       	cp	r10, r8
    320c:	b9 04       	cpc	r11, r9
    320e:	08 f4       	brcc	.+2      	; 0x3212 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3210:	88 cf       	rjmp	.-240    	; 0x3122 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3212:	62 e0       	ldi	r22, 0x02	; 2
    3214:	c7 01       	movw	r24, r14
    3216:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
}
    321a:	03 c0       	rjmp	.+6      	; 0x3222 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    321c:	c6 2d       	mov	r28, r6
    321e:	d5 2d       	mov	r29, r5
    3220:	9c cf       	rjmp	.-200    	; 0x315a <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3222:	df 91       	pop	r29
    3224:	cf 91       	pop	r28
    3226:	1f 91       	pop	r17
    3228:	0f 91       	pop	r16
    322a:	ff 90       	pop	r15
    322c:	ef 90       	pop	r14
    322e:	df 90       	pop	r13
    3230:	cf 90       	pop	r12
    3232:	bf 90       	pop	r11
    3234:	af 90       	pop	r10
    3236:	9f 90       	pop	r9
    3238:	8f 90       	pop	r8
    323a:	7f 90       	pop	r7
    323c:	6f 90       	pop	r6
    323e:	5f 90       	pop	r5
    3240:	08 95       	ret

00003242 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3242:	0e 94 52 09 	call	0x12a4	; 0x12a4 <pvPortMalloc>
    3246:	08 95       	ret

00003248 <_Znaj>:
    3248:	0e 94 52 09 	call	0x12a4	; 0x12a4 <pvPortMalloc>
    324c:	08 95       	ret

0000324e <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    324e:	08 95       	ret

00003250 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3250:	cf 93       	push	r28
    3252:	df 93       	push	r29
    3254:	fc 01       	movw	r30, r24
    3256:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3258:	40 3a       	cpi	r20, 0xA0	; 160
    325a:	68 e0       	ldi	r22, 0x08	; 8
    325c:	56 07       	cpc	r21, r22
    325e:	49 f4       	brne	.+18     	; 0x3272 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3260:	80 e4       	ldi	r24, 0x40	; 64
    3262:	96 e0       	ldi	r25, 0x06	; 6
    3264:	82 83       	std	Z+2, r24	; 0x02
    3266:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3268:	82 e0       	ldi	r24, 0x02	; 2
    326a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    326c:	83 e0       	ldi	r24, 0x03	; 3
    326e:	85 83       	std	Z+5, r24	; 0x05
    3270:	32 c0       	rjmp	.+100    	; 0x32d6 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3272:	40 3b       	cpi	r20, 0xB0	; 176
    3274:	78 e0       	ldi	r23, 0x08	; 8
    3276:	57 07       	cpc	r21, r23
    3278:	49 f4       	brne	.+18     	; 0x328c <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    327a:	80 e4       	ldi	r24, 0x40	; 64
    327c:	96 e0       	ldi	r25, 0x06	; 6
    327e:	82 83       	std	Z+2, r24	; 0x02
    3280:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3282:	86 e0       	ldi	r24, 0x06	; 6
    3284:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3286:	87 e0       	ldi	r24, 0x07	; 7
    3288:	85 83       	std	Z+5, r24	; 0x05
    328a:	25 c0       	rjmp	.+74     	; 0x32d6 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    328c:	40 3a       	cpi	r20, 0xA0	; 160
    328e:	89 e0       	ldi	r24, 0x09	; 9
    3290:	58 07       	cpc	r21, r24
    3292:	49 f4       	brne	.+18     	; 0x32a6 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3294:	80 e6       	ldi	r24, 0x60	; 96
    3296:	96 e0       	ldi	r25, 0x06	; 6
    3298:	82 83       	std	Z+2, r24	; 0x02
    329a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    329c:	82 e0       	ldi	r24, 0x02	; 2
    329e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32a0:	83 e0       	ldi	r24, 0x03	; 3
    32a2:	85 83       	std	Z+5, r24	; 0x05
    32a4:	18 c0       	rjmp	.+48     	; 0x32d6 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    32a6:	40 3b       	cpi	r20, 0xB0	; 176
    32a8:	69 e0       	ldi	r22, 0x09	; 9
    32aa:	56 07       	cpc	r21, r22
    32ac:	49 f4       	brne	.+18     	; 0x32c0 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    32ae:	80 e6       	ldi	r24, 0x60	; 96
    32b0:	96 e0       	ldi	r25, 0x06	; 6
    32b2:	82 83       	std	Z+2, r24	; 0x02
    32b4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    32b6:	86 e0       	ldi	r24, 0x06	; 6
    32b8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32ba:	87 e0       	ldi	r24, 0x07	; 7
    32bc:	85 83       	std	Z+5, r24	; 0x05
    32be:	0b c0       	rjmp	.+22     	; 0x32d6 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    32c0:	40 3a       	cpi	r20, 0xA0	; 160
    32c2:	5a 40       	sbci	r21, 0x0A	; 10
    32c4:	41 f4       	brne	.+16     	; 0x32d6 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    32c6:	80 e8       	ldi	r24, 0x80	; 128
    32c8:	96 e0       	ldi	r25, 0x06	; 6
    32ca:	82 83       	std	Z+2, r24	; 0x02
    32cc:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32ce:	82 e0       	ldi	r24, 0x02	; 2
    32d0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32d2:	83 e0       	ldi	r24, 0x03	; 3
    32d4:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    32d6:	a6 83       	std	Z+6, r26	; 0x06
    32d8:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    32da:	cd 01       	movw	r24, r26
    32dc:	01 96       	adiw	r24, 0x01	; 1
    32de:	80 87       	std	Z+8, r24	; 0x08
    32e0:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    32e2:	03 96       	adiw	r24, 0x03	; 3
    32e4:	82 87       	std	Z+10, r24	; 0x0a
    32e6:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    32e8:	25 81       	ldd	r18, Z+5	; 0x05
    32ea:	c2 81       	ldd	r28, Z+2	; 0x02
    32ec:	d3 81       	ldd	r29, Z+3	; 0x03
    32ee:	4c 81       	ldd	r20, Y+4	; 0x04
    32f0:	81 e0       	ldi	r24, 0x01	; 1
    32f2:	90 e0       	ldi	r25, 0x00	; 0
    32f4:	bc 01       	movw	r22, r24
    32f6:	02 c0       	rjmp	.+4      	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xac>
    32f8:	66 0f       	add	r22, r22
    32fa:	77 1f       	adc	r23, r23
    32fc:	2a 95       	dec	r18
    32fe:	e2 f7       	brpl	.-8      	; 0x32f8 <_ZN7base232C1EjP12USART_struct+0xa8>
    3300:	9b 01       	movw	r18, r22
    3302:	24 2b       	or	r18, r20
    3304:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3306:	25 81       	ldd	r18, Z+5	; 0x05
    3308:	c2 81       	ldd	r28, Z+2	; 0x02
    330a:	d3 81       	ldd	r29, Z+3	; 0x03
    330c:	48 81       	ld	r20, Y
    330e:	bc 01       	movw	r22, r24
    3310:	02 c0       	rjmp	.+4      	; 0x3316 <_ZN7base232C1EjP12USART_struct+0xc6>
    3312:	66 0f       	add	r22, r22
    3314:	77 1f       	adc	r23, r23
    3316:	2a 95       	dec	r18
    3318:	e2 f7       	brpl	.-8      	; 0x3312 <_ZN7base232C1EjP12USART_struct+0xc2>
    331a:	9b 01       	movw	r18, r22
    331c:	24 2b       	or	r18, r20
    331e:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3320:	34 81       	ldd	r19, Z+4	; 0x04
    3322:	c2 81       	ldd	r28, Z+2	; 0x02
    3324:	d3 81       	ldd	r29, Z+3	; 0x03
    3326:	28 81       	ld	r18, Y
    3328:	02 c0       	rjmp	.+4      	; 0x332e <_ZN7base232C1EjP12USART_struct+0xde>
    332a:	88 0f       	add	r24, r24
    332c:	99 1f       	adc	r25, r25
    332e:	3a 95       	dec	r19
    3330:	e2 f7       	brpl	.-8      	; 0x332a <_ZN7base232C1EjP12USART_struct+0xda>
    3332:	80 95       	com	r24
    3334:	90 95       	com	r25
    3336:	82 23       	and	r24, r18
    3338:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    333a:	80 e1       	ldi	r24, 0x10	; 16
    333c:	13 96       	adiw	r26, 0x03	; 3
    333e:	8c 93       	st	X, r24
    3340:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3342:	83 e0       	ldi	r24, 0x03	; 3
    3344:	15 96       	adiw	r26, 0x05	; 5
    3346:	8c 93       	st	X, r24
    3348:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    334a:	80 ef       	ldi	r24, 0xF0	; 240
    334c:	17 96       	adiw	r26, 0x07	; 7
    334e:	8c 93       	st	X, r24
    3350:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3352:	81 e2       	ldi	r24, 0x21	; 33
    3354:	16 96       	adiw	r26, 0x06	; 6
    3356:	8c 93       	st	X, r24
    3358:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    335a:	88 e1       	ldi	r24, 0x18	; 24
    335c:	14 96       	adiw	r26, 0x04	; 4
    335e:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3360:	80 e8       	ldi	r24, 0x80	; 128
    3362:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3364:	80 e4       	ldi	r24, 0x40	; 64
    3366:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3368:	80 e2       	ldi	r24, 0x20	; 32
    336a:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    336c:	06 80       	ldd	r0, Z+6	; 0x06
    336e:	f7 81       	ldd	r31, Z+7	; 0x07
    3370:	e0 2d       	mov	r30, r0
    3372:	80 81       	ld	r24, Z
    3374:	80 81       	ld	r24, Z
}
    3376:	df 91       	pop	r29
    3378:	cf 91       	pop	r28
    337a:	08 95       	ret

0000337c <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    337c:	81 e0       	ldi	r24, 0x01	; 1
    337e:	08 95       	ret

00003380 <_ZN8emstream7getcharEv>:
    3380:	80 e0       	ldi	r24, 0x00	; 0
    3382:	90 e0       	ldi	r25, 0x00	; 0
    3384:	08 95       	ret

00003386 <_ZN8emstream14check_for_charEv>:
    3386:	80 e0       	ldi	r24, 0x00	; 0
    3388:	08 95       	ret

0000338a <_ZN8emstream12transmit_nowEv>:
    338a:	08 95       	ret

0000338c <_ZN8emstream12clear_screenEv>:
    338c:	08 95       	ret

0000338e <_ZN8emstreamC1Ev>:
    338e:	fc 01       	movw	r30, r24
    3390:	84 e7       	ldi	r24, 0x74	; 116
    3392:	90 e2       	ldi	r25, 0x20	; 32
    3394:	80 83       	st	Z, r24
    3396:	91 83       	std	Z+1, r25	; 0x01
    3398:	8a e0       	ldi	r24, 0x0A	; 10
    339a:	82 83       	std	Z+2, r24	; 0x02
    339c:	13 82       	std	Z+3, r1	; 0x03
    339e:	83 e0       	ldi	r24, 0x03	; 3
    33a0:	85 83       	std	Z+5, r24	; 0x05
    33a2:	14 82       	std	Z+4, r1	; 0x04
    33a4:	16 82       	std	Z+6, r1	; 0x06
    33a6:	17 82       	std	Z+7, r1	; 0x07
    33a8:	08 95       	ret

000033aa <_ZN8emstream4putsEPKc>:
    33aa:	0f 93       	push	r16
    33ac:	1f 93       	push	r17
    33ae:	cf 93       	push	r28
    33b0:	df 93       	push	r29
    33b2:	8c 01       	movw	r16, r24
    33b4:	fb 01       	movw	r30, r22
    33b6:	dc 01       	movw	r26, r24
    33b8:	14 96       	adiw	r26, 0x04	; 4
    33ba:	8c 91       	ld	r24, X
    33bc:	81 11       	cpse	r24, r1
    33be:	04 c0       	rjmp	.+8      	; 0x33c8 <_ZN8emstream4putsEPKc+0x1e>
    33c0:	60 81       	ld	r22, Z
    33c2:	61 11       	cpse	r22, r1
    33c4:	17 c0       	rjmp	.+46     	; 0x33f4 <_ZN8emstream4putsEPKc+0x4a>
    33c6:	23 c0       	rjmp	.+70     	; 0x340e <_ZN8emstream4putsEPKc+0x64>
    33c8:	d8 01       	movw	r26, r16
    33ca:	14 96       	adiw	r26, 0x04	; 4
    33cc:	1c 92       	st	X, r1
    33ce:	eb 01       	movw	r28, r22
    33d0:	21 96       	adiw	r28, 0x01	; 1
    33d2:	64 91       	lpm	r22, Z
    33d4:	66 23       	and	r22, r22
    33d6:	d9 f0       	breq	.+54     	; 0x340e <_ZN8emstream4putsEPKc+0x64>
    33d8:	d8 01       	movw	r26, r16
    33da:	ed 91       	ld	r30, X+
    33dc:	fc 91       	ld	r31, X
    33de:	02 80       	ldd	r0, Z+2	; 0x02
    33e0:	f3 81       	ldd	r31, Z+3	; 0x03
    33e2:	e0 2d       	mov	r30, r0
    33e4:	c8 01       	movw	r24, r16
    33e6:	19 95       	eicall
    33e8:	fe 01       	movw	r30, r28
    33ea:	64 91       	lpm	r22, Z
    33ec:	21 96       	adiw	r28, 0x01	; 1
    33ee:	61 11       	cpse	r22, r1
    33f0:	f3 cf       	rjmp	.-26     	; 0x33d8 <_ZN8emstream4putsEPKc+0x2e>
    33f2:	0d c0       	rjmp	.+26     	; 0x340e <_ZN8emstream4putsEPKc+0x64>
    33f4:	ef 01       	movw	r28, r30
    33f6:	21 96       	adiw	r28, 0x01	; 1
    33f8:	d8 01       	movw	r26, r16
    33fa:	ed 91       	ld	r30, X+
    33fc:	fc 91       	ld	r31, X
    33fe:	02 80       	ldd	r0, Z+2	; 0x02
    3400:	f3 81       	ldd	r31, Z+3	; 0x03
    3402:	e0 2d       	mov	r30, r0
    3404:	c8 01       	movw	r24, r16
    3406:	19 95       	eicall
    3408:	69 91       	ld	r22, Y+
    340a:	61 11       	cpse	r22, r1
    340c:	f5 cf       	rjmp	.-22     	; 0x33f8 <_ZN8emstream4putsEPKc+0x4e>
    340e:	df 91       	pop	r29
    3410:	cf 91       	pop	r28
    3412:	1f 91       	pop	r17
    3414:	0f 91       	pop	r16
    3416:	08 95       	ret

00003418 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3418:	cf 93       	push	r28
    341a:	df 93       	push	r29
    341c:	ec 01       	movw	r28, r24
	switch (new_manip)
    341e:	86 2f       	mov	r24, r22
    3420:	90 e0       	ldi	r25, 0x00	; 0
    3422:	8b 30       	cpi	r24, 0x0B	; 11
    3424:	91 05       	cpc	r25, r1
    3426:	d8 f5       	brcc	.+118    	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
    3428:	fc 01       	movw	r30, r24
    342a:	88 27       	eor	r24, r24
    342c:	e2 50       	subi	r30, 0x02	; 2
    342e:	ff 4f       	sbci	r31, 0xFF	; 255
    3430:	8f 4f       	sbci	r24, 0xFF	; 255
    3432:	0c 94 d4 1f 	jmp	0x3fa8	; 0x3fa8 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3436:	82 e0       	ldi	r24, 0x02	; 2
    3438:	8a 83       	std	Y+2, r24	; 0x02
			break;
    343a:	31 c0       	rjmp	.+98     	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    343c:	88 e0       	ldi	r24, 0x08	; 8
    343e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3440:	2e c0       	rjmp	.+92     	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3442:	8a e0       	ldi	r24, 0x0A	; 10
    3444:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3446:	2b c0       	rjmp	.+86     	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3448:	80 e1       	ldi	r24, 0x10	; 16
    344a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    344c:	28 c0       	rjmp	.+80     	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    344e:	81 e0       	ldi	r24, 0x01	; 1
    3450:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3452:	25 c0       	rjmp	.+74     	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3454:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3456:	23 c0       	rjmp	.+70     	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3458:	e8 81       	ld	r30, Y
    345a:	f9 81       	ldd	r31, Y+1	; 0x01
    345c:	02 80       	ldd	r0, Z+2	; 0x02
    345e:	f3 81       	ldd	r31, Z+3	; 0x03
    3460:	e0 2d       	mov	r30, r0
    3462:	6d e0       	ldi	r22, 0x0D	; 13
    3464:	ce 01       	movw	r24, r28
    3466:	19 95       	eicall
    3468:	e8 81       	ld	r30, Y
    346a:	f9 81       	ldd	r31, Y+1	; 0x01
    346c:	02 80       	ldd	r0, Z+2	; 0x02
    346e:	f3 81       	ldd	r31, Z+3	; 0x03
    3470:	e0 2d       	mov	r30, r0
    3472:	6a e0       	ldi	r22, 0x0A	; 10
    3474:	ce 01       	movw	r24, r28
    3476:	19 95       	eicall
			break;
    3478:	12 c0       	rjmp	.+36     	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    347a:	e8 81       	ld	r30, Y
    347c:	f9 81       	ldd	r31, Y+1	; 0x01
    347e:	02 84       	ldd	r0, Z+10	; 0x0a
    3480:	f3 85       	ldd	r31, Z+11	; 0x0b
    3482:	e0 2d       	mov	r30, r0
    3484:	ce 01       	movw	r24, r28
    3486:	19 95       	eicall
			break;
    3488:	0a c0       	rjmp	.+20     	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    348a:	e8 81       	ld	r30, Y
    348c:	f9 81       	ldd	r31, Y+1	; 0x01
    348e:	00 84       	ldd	r0, Z+8	; 0x08
    3490:	f1 85       	ldd	r31, Z+9	; 0x09
    3492:	e0 2d       	mov	r30, r0
    3494:	ce 01       	movw	r24, r28
    3496:	19 95       	eicall
			break;
    3498:	02 c0       	rjmp	.+4      	; 0x349e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    349a:	81 e0       	ldi	r24, 0x01	; 1
    349c:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    349e:	ce 01       	movw	r24, r28
    34a0:	df 91       	pop	r29
    34a2:	cf 91       	pop	r28
    34a4:	08 95       	ret

000034a6 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    34a6:	0f 93       	push	r16
    34a8:	1f 93       	push	r17
    34aa:	cf 93       	push	r28
    34ac:	df 93       	push	r29
    34ae:	cd b7       	in	r28, 0x3d	; 61
    34b0:	de b7       	in	r29, 0x3e	; 62
    34b2:	61 97       	sbiw	r28, 0x11	; 17
    34b4:	cd bf       	out	0x3d, r28	; 61
    34b6:	de bf       	out	0x3e, r29	; 62
    34b8:	8c 01       	movw	r16, r24
    34ba:	9b 01       	movw	r18, r22
	if (base != 10)
    34bc:	fc 01       	movw	r30, r24
    34be:	92 81       	ldd	r25, Z+2	; 0x02
    34c0:	9a 30       	cpi	r25, 0x0A	; 10
    34c2:	21 f0       	breq	.+8      	; 0x34cc <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    34c4:	c8 01       	movw	r24, r16
    34c6:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEj>
    34ca:	0d c0       	rjmp	.+26     	; 0x34e6 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    34cc:	4a e0       	ldi	r20, 0x0A	; 10
    34ce:	be 01       	movw	r22, r28
    34d0:	6f 5f       	subi	r22, 0xFF	; 255
    34d2:	7f 4f       	sbci	r23, 0xFF	; 255
    34d4:	c9 01       	movw	r24, r18
    34d6:	0e 94 41 20 	call	0x4082	; 0x4082 <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    34da:	be 01       	movw	r22, r28
    34dc:	6f 5f       	subi	r22, 0xFF	; 255
    34de:	7f 4f       	sbci	r23, 0xFF	; 255
    34e0:	c8 01       	movw	r24, r16
    34e2:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    34e6:	c8 01       	movw	r24, r16
    34e8:	61 96       	adiw	r28, 0x11	; 17
    34ea:	cd bf       	out	0x3d, r28	; 61
    34ec:	de bf       	out	0x3e, r29	; 62
    34ee:	df 91       	pop	r29
    34f0:	cf 91       	pop	r28
    34f2:	1f 91       	pop	r17
    34f4:	0f 91       	pop	r16
    34f6:	08 95       	ret

000034f8 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    34f8:	ff 92       	push	r15
    34fa:	0f 93       	push	r16
    34fc:	1f 93       	push	r17
    34fe:	cf 93       	push	r28
    3500:	df 93       	push	r29
    3502:	cd b7       	in	r28, 0x3d	; 61
    3504:	de b7       	in	r29, 0x3e	; 62
    3506:	61 97       	sbiw	r28, 0x11	; 17
    3508:	cd bf       	out	0x3d, r28	; 61
    350a:	de bf       	out	0x3e, r29	; 62
    350c:	8c 01       	movw	r16, r24
    350e:	f6 2e       	mov	r15, r22
    3510:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3512:	f8 01       	movw	r30, r16
    3514:	42 81       	ldd	r20, Z+2	; 0x02
    3516:	40 31       	cpi	r20, 0x10	; 16
    3518:	21 f0       	breq	.+8      	; 0x3522 <_ZN8emstreamlsEj+0x2a>
    351a:	48 30       	cpi	r20, 0x08	; 8
    351c:	11 f0       	breq	.+4      	; 0x3522 <_ZN8emstreamlsEj+0x2a>
    351e:	42 30       	cpi	r20, 0x02	; 2
    3520:	41 f4       	brne	.+16     	; 0x3532 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3522:	69 2f       	mov	r22, r25
    3524:	c8 01       	movw	r24, r16
    3526:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
    352a:	6f 2d       	mov	r22, r15
    352c:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
    3530:	0d c0       	rjmp	.+26     	; 0x354c <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3532:	50 e0       	ldi	r21, 0x00	; 0
    3534:	be 01       	movw	r22, r28
    3536:	6f 5f       	subi	r22, 0xFF	; 255
    3538:	7f 4f       	sbci	r23, 0xFF	; 255
    353a:	8f 2d       	mov	r24, r15
    353c:	0e 94 79 20 	call	0x40f2	; 0x40f2 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3540:	be 01       	movw	r22, r28
    3542:	6f 5f       	subi	r22, 0xFF	; 255
    3544:	7f 4f       	sbci	r23, 0xFF	; 255
    3546:	c8 01       	movw	r24, r16
    3548:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    354c:	c8 01       	movw	r24, r16
    354e:	61 96       	adiw	r28, 0x11	; 17
    3550:	cd bf       	out	0x3d, r28	; 61
    3552:	de bf       	out	0x3e, r29	; 62
    3554:	df 91       	pop	r29
    3556:	cf 91       	pop	r28
    3558:	1f 91       	pop	r17
    355a:	0f 91       	pop	r16
    355c:	ff 90       	pop	r15
    355e:	08 95       	ret

00003560 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3560:	df 92       	push	r13
    3562:	ef 92       	push	r14
    3564:	ff 92       	push	r15
    3566:	0f 93       	push	r16
    3568:	1f 93       	push	r17
    356a:	cf 93       	push	r28
    356c:	df 93       	push	r29
    356e:	cd b7       	in	r28, 0x3d	; 61
    3570:	de b7       	in	r29, 0x3e	; 62
    3572:	a1 97       	sbiw	r28, 0x21	; 33
    3574:	cd bf       	out	0x3d, r28	; 61
    3576:	de bf       	out	0x3e, r29	; 62
    3578:	8c 01       	movw	r16, r24
    357a:	d4 2e       	mov	r13, r20
    357c:	e5 2e       	mov	r14, r21
    357e:	f6 2e       	mov	r15, r22
    3580:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3582:	f8 01       	movw	r30, r16
    3584:	22 81       	ldd	r18, Z+2	; 0x02
    3586:	20 31       	cpi	r18, 0x10	; 16
    3588:	21 f0       	breq	.+8      	; 0x3592 <_ZN8emstreamlsEm+0x32>
    358a:	28 30       	cpi	r18, 0x08	; 8
    358c:	11 f0       	breq	.+4      	; 0x3592 <_ZN8emstreamlsEm+0x32>
    358e:	22 30       	cpi	r18, 0x02	; 2
    3590:	71 f4       	brne	.+28     	; 0x35ae <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3592:	69 2f       	mov	r22, r25
    3594:	c8 01       	movw	r24, r16
    3596:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
    359a:	6f 2d       	mov	r22, r15
    359c:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
    35a0:	6e 2d       	mov	r22, r14
    35a2:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
    35a6:	6d 2d       	mov	r22, r13
    35a8:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <_ZN8emstreamlsEh>
    35ac:	0f c0       	rjmp	.+30     	; 0x35cc <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    35ae:	30 e0       	ldi	r19, 0x00	; 0
    35b0:	ae 01       	movw	r20, r28
    35b2:	4f 5f       	subi	r20, 0xFF	; 255
    35b4:	5f 4f       	sbci	r21, 0xFF	; 255
    35b6:	6d 2d       	mov	r22, r13
    35b8:	7e 2d       	mov	r23, r14
    35ba:	8f 2d       	mov	r24, r15
    35bc:	0e 94 4c 20 	call	0x4098	; 0x4098 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    35c0:	be 01       	movw	r22, r28
    35c2:	6f 5f       	subi	r22, 0xFF	; 255
    35c4:	7f 4f       	sbci	r23, 0xFF	; 255
    35c6:	c8 01       	movw	r24, r16
    35c8:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35cc:	c8 01       	movw	r24, r16
    35ce:	a1 96       	adiw	r28, 0x21	; 33
    35d0:	cd bf       	out	0x3d, r28	; 61
    35d2:	de bf       	out	0x3e, r29	; 62
    35d4:	df 91       	pop	r29
    35d6:	cf 91       	pop	r28
    35d8:	1f 91       	pop	r17
    35da:	0f 91       	pop	r16
    35dc:	ff 90       	pop	r15
    35de:	ef 90       	pop	r14
    35e0:	df 90       	pop	r13
    35e2:	08 95       	ret

000035e4 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    35e4:	cf 92       	push	r12
    35e6:	df 92       	push	r13
    35e8:	ef 92       	push	r14
    35ea:	ff 92       	push	r15
    35ec:	0f 93       	push	r16
    35ee:	1f 93       	push	r17
    35f0:	cf 93       	push	r28
    35f2:	df 93       	push	r29
    35f4:	cd b7       	in	r28, 0x3d	; 61
    35f6:	de b7       	in	r29, 0x3e	; 62
    35f8:	29 97       	sbiw	r28, 0x09	; 9
    35fa:	cd bf       	out	0x3d, r28	; 61
    35fc:	de bf       	out	0x3e, r29	; 62
    35fe:	8c 01       	movw	r16, r24
    3600:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3602:	dc 01       	movw	r26, r24
    3604:	13 96       	adiw	r26, 0x03	; 3
    3606:	8c 91       	ld	r24, X
    3608:	13 97       	sbiw	r26, 0x03	; 3
    360a:	88 23       	and	r24, r24
    360c:	41 f0       	breq	.+16     	; 0x361e <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    360e:	ed 91       	ld	r30, X+
    3610:	fc 91       	ld	r31, X
    3612:	02 80       	ldd	r0, Z+2	; 0x02
    3614:	f3 81       	ldd	r31, Z+3	; 0x03
    3616:	e0 2d       	mov	r30, r0
    3618:	c8 01       	movw	r24, r16
    361a:	19 95       	eicall
    361c:	56 c0       	rjmp	.+172    	; 0x36ca <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    361e:	f8 01       	movw	r30, r16
    3620:	42 81       	ldd	r20, Z+2	; 0x02
    3622:	42 30       	cpi	r20, 0x02	; 2
    3624:	19 f5       	brne	.+70     	; 0x366c <_ZN8emstreamlsEh+0x88>
    3626:	68 94       	set
    3628:	cc 24       	eor	r12, r12
    362a:	c3 f8       	bld	r12, 3
    362c:	d1 2c       	mov	r13, r1
    362e:	68 94       	set
    3630:	ff 24       	eor	r15, r15
    3632:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3634:	8e 2d       	mov	r24, r14
    3636:	8f 21       	and	r24, r15
    3638:	51 f0       	breq	.+20     	; 0x364e <_ZN8emstreamlsEh+0x6a>
    363a:	d8 01       	movw	r26, r16
    363c:	ed 91       	ld	r30, X+
    363e:	fc 91       	ld	r31, X
    3640:	02 80       	ldd	r0, Z+2	; 0x02
    3642:	f3 81       	ldd	r31, Z+3	; 0x03
    3644:	e0 2d       	mov	r30, r0
    3646:	61 e3       	ldi	r22, 0x31	; 49
    3648:	c8 01       	movw	r24, r16
    364a:	19 95       	eicall
    364c:	09 c0       	rjmp	.+18     	; 0x3660 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    364e:	d8 01       	movw	r26, r16
    3650:	ed 91       	ld	r30, X+
    3652:	fc 91       	ld	r31, X
    3654:	02 80       	ldd	r0, Z+2	; 0x02
    3656:	f3 81       	ldd	r31, Z+3	; 0x03
    3658:	e0 2d       	mov	r30, r0
    365a:	60 e3       	ldi	r22, 0x30	; 48
    365c:	c8 01       	movw	r24, r16
    365e:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3660:	f6 94       	lsr	r15
    3662:	b1 e0       	ldi	r27, 0x01	; 1
    3664:	cb 1a       	sub	r12, r27
    3666:	d1 08       	sbc	r13, r1
    3668:	29 f7       	brne	.-54     	; 0x3634 <_ZN8emstreamlsEh+0x50>
    366a:	2f c0       	rjmp	.+94     	; 0x36ca <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    366c:	40 31       	cpi	r20, 0x10	; 16
    366e:	f9 f4       	brne	.+62     	; 0x36ae <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3670:	62 95       	swap	r22
    3672:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3674:	01 90       	ld	r0, Z+
    3676:	f0 81       	ld	r31, Z
    3678:	e0 2d       	mov	r30, r0
    367a:	02 80       	ldd	r0, Z+2	; 0x02
    367c:	f3 81       	ldd	r31, Z+3	; 0x03
    367e:	e0 2d       	mov	r30, r0
    3680:	6a 30       	cpi	r22, 0x0A	; 10
    3682:	10 f0       	brcs	.+4      	; 0x3688 <_ZN8emstreamlsEh+0xa4>
    3684:	69 5c       	subi	r22, 0xC9	; 201
    3686:	01 c0       	rjmp	.+2      	; 0x368a <_ZN8emstreamlsEh+0xa6>
    3688:	60 5d       	subi	r22, 0xD0	; 208
    368a:	c8 01       	movw	r24, r16
    368c:	19 95       	eicall
		temp_char = num & 0x0F;
    368e:	6e 2d       	mov	r22, r14
    3690:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3692:	d8 01       	movw	r26, r16
    3694:	ed 91       	ld	r30, X+
    3696:	fc 91       	ld	r31, X
    3698:	02 80       	ldd	r0, Z+2	; 0x02
    369a:	f3 81       	ldd	r31, Z+3	; 0x03
    369c:	e0 2d       	mov	r30, r0
    369e:	6a 30       	cpi	r22, 0x0A	; 10
    36a0:	10 f0       	brcs	.+4      	; 0x36a6 <_ZN8emstreamlsEh+0xc2>
    36a2:	69 5c       	subi	r22, 0xC9	; 201
    36a4:	01 c0       	rjmp	.+2      	; 0x36a8 <_ZN8emstreamlsEh+0xc4>
    36a6:	60 5d       	subi	r22, 0xD0	; 208
    36a8:	c8 01       	movw	r24, r16
    36aa:	19 95       	eicall
    36ac:	0e c0       	rjmp	.+28     	; 0x36ca <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    36ae:	50 e0       	ldi	r21, 0x00	; 0
    36b0:	be 01       	movw	r22, r28
    36b2:	6f 5f       	subi	r22, 0xFF	; 255
    36b4:	7f 4f       	sbci	r23, 0xFF	; 255
    36b6:	8e 2d       	mov	r24, r14
    36b8:	90 e0       	ldi	r25, 0x00	; 0
    36ba:	0e 94 79 20 	call	0x40f2	; 0x40f2 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    36be:	be 01       	movw	r22, r28
    36c0:	6f 5f       	subi	r22, 0xFF	; 255
    36c2:	7f 4f       	sbci	r23, 0xFF	; 255
    36c4:	c8 01       	movw	r24, r16
    36c6:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    36ca:	c8 01       	movw	r24, r16
    36cc:	29 96       	adiw	r28, 0x09	; 9
    36ce:	cd bf       	out	0x3d, r28	; 61
    36d0:	de bf       	out	0x3e, r29	; 62
    36d2:	df 91       	pop	r29
    36d4:	cf 91       	pop	r28
    36d6:	1f 91       	pop	r17
    36d8:	0f 91       	pop	r16
    36da:	ff 90       	pop	r15
    36dc:	ef 90       	pop	r14
    36de:	df 90       	pop	r13
    36e0:	cf 90       	pop	r12
    36e2:	08 95       	ret

000036e4 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    36e4:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36e6:	50 96       	adiw	r26, 0x10	; 16
    36e8:	ed 91       	ld	r30, X+
    36ea:	fc 91       	ld	r31, X
    36ec:	51 97       	sbiw	r26, 0x11	; 17
    36ee:	80 81       	ld	r24, Z
    36f0:	54 96       	adiw	r26, 0x14	; 20
    36f2:	4c 91       	ld	r20, X
    36f4:	54 97       	sbiw	r26, 0x14	; 20
    36f6:	84 23       	and	r24, r20
    36f8:	29 f0       	breq	.+10     	; 0x3704 <_ZN5rs2327putcharEc+0x20>
    36fa:	09 c0       	rjmp	.+18     	; 0x370e <_ZN5rs2327putcharEc+0x2a>
    36fc:	21 50       	subi	r18, 0x01	; 1
    36fe:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3700:	19 f4       	brne	.+6      	; 0x3708 <_ZN5rs2327putcharEc+0x24>
    3702:	12 c0       	rjmp	.+36     	; 0x3728 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3704:	21 e2       	ldi	r18, 0x21	; 33
    3706:	3e e4       	ldi	r19, 0x4E	; 78
    3708:	90 81       	ld	r25, Z
    370a:	94 23       	and	r25, r20
    370c:	b9 f3       	breq	.-18     	; 0x36fc <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    370e:	90 81       	ld	r25, Z
    3710:	56 96       	adiw	r26, 0x16	; 22
    3712:	8c 91       	ld	r24, X
    3714:	56 97       	sbiw	r26, 0x16	; 22
    3716:	89 2b       	or	r24, r25
    3718:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    371a:	1e 96       	adiw	r26, 0x0e	; 14
    371c:	ed 91       	ld	r30, X+
    371e:	fc 91       	ld	r31, X
    3720:	1f 97       	sbiw	r26, 0x0f	; 15
    3722:	60 83       	st	Z, r22
	return (true);
    3724:	81 e0       	ldi	r24, 0x01	; 1
    3726:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3728:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    372a:	08 95       	ret

0000372c <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    372c:	cf 93       	push	r28
    372e:	df 93       	push	r29
    3730:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3732:	c1 8d       	ldd	r28, Z+25	; 0x19
    3734:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3736:	28 81       	ld	r18, Y
    3738:	39 81       	ldd	r19, Y+1	; 0x01
    373a:	a3 8d       	ldd	r26, Z+27	; 0x1b
    373c:	b4 8d       	ldd	r27, Z+28	; 0x1c
    373e:	4d 91       	ld	r20, X+
    3740:	5c 91       	ld	r21, X
    3742:	24 17       	cp	r18, r20
    3744:	35 07       	cpc	r19, r21
    3746:	e9 f3       	breq	.-6      	; 0x3742 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3748:	a7 89       	ldd	r26, Z+23	; 0x17
    374a:	b0 8d       	ldd	r27, Z+24	; 0x18
    374c:	0d 90       	ld	r0, X+
    374e:	bc 91       	ld	r27, X
    3750:	a0 2d       	mov	r26, r0
    3752:	a2 0f       	add	r26, r18
    3754:	b3 1f       	adc	r27, r19
    3756:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3758:	2f 5f       	subi	r18, 0xFF	; 255
    375a:	3f 4f       	sbci	r19, 0xFF	; 255
    375c:	28 83       	st	Y, r18
    375e:	39 83       	std	Y+1, r19	; 0x01
    3760:	24 36       	cpi	r18, 0x64	; 100
    3762:	31 05       	cpc	r19, r1
    3764:	28 f0       	brcs	.+10     	; 0x3770 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3766:	01 8c       	ldd	r0, Z+25	; 0x19
    3768:	f2 8d       	ldd	r31, Z+26	; 0x1a
    376a:	e0 2d       	mov	r30, r0
    376c:	10 82       	st	Z, r1
    376e:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3770:	90 e0       	ldi	r25, 0x00	; 0
    3772:	df 91       	pop	r29
    3774:	cf 91       	pop	r28
    3776:	08 95       	ret

00003778 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3778:	cf 93       	push	r28
    377a:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    377c:	ec 01       	movw	r28, r24
    377e:	a9 8d       	ldd	r26, Y+25	; 0x19
    3780:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3782:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3784:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3786:	81 e0       	ldi	r24, 0x01	; 1
    3788:	4d 91       	ld	r20, X+
    378a:	5c 91       	ld	r21, X
    378c:	20 81       	ld	r18, Z
    378e:	31 81       	ldd	r19, Z+1	; 0x01
    3790:	42 17       	cp	r20, r18
    3792:	53 07       	cpc	r21, r19
    3794:	09 f4       	brne	.+2      	; 0x3798 <_ZN5rs23214check_for_charEv+0x20>
    3796:	80 e0       	ldi	r24, 0x00	; 0
}
    3798:	df 91       	pop	r29
    379a:	cf 91       	pop	r28
    379c:	08 95       	ret

0000379e <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    379e:	dc 01       	movw	r26, r24
    37a0:	ed 91       	ld	r30, X+
    37a2:	fc 91       	ld	r31, X
    37a4:	02 80       	ldd	r0, Z+2	; 0x02
    37a6:	f3 81       	ldd	r31, Z+3	; 0x03
    37a8:	e0 2d       	mov	r30, r0
    37aa:	6c e0       	ldi	r22, 0x0C	; 12
    37ac:	19 95       	eicall
    37ae:	08 95       	ret

000037b0 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    37b0:	ef 92       	push	r14
    37b2:	ff 92       	push	r15
    37b4:	0f 93       	push	r16
    37b6:	1f 93       	push	r17
    37b8:	cf 93       	push	r28
    37ba:	df 93       	push	r29
    37bc:	ec 01       	movw	r28, r24
    37be:	7b 01       	movw	r14, r22
    37c0:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    37c2:	0e 94 c7 19 	call	0x338e	; 0x338e <_ZN8emstreamC1Ev>
    37c6:	a8 01       	movw	r20, r16
    37c8:	b7 01       	movw	r22, r14
    37ca:	ce 01       	movw	r24, r28
    37cc:	08 96       	adiw	r24, 0x08	; 8
    37ce:	0e 94 28 19 	call	0x3250	; 0x3250 <_ZN7base232C1EjP12USART_struct>
    37d2:	84 e8       	ldi	r24, 0x84	; 132
    37d4:	90 e2       	ldi	r25, 0x20	; 32
    37d6:	88 83       	st	Y, r24
    37d8:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    37da:	00 3a       	cpi	r16, 0xA0	; 160
    37dc:	88 e0       	ldi	r24, 0x08	; 8
    37de:	18 07       	cpc	r17, r24
    37e0:	69 f4       	brne	.+26     	; 0x37fc <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    37e2:	8e e7       	ldi	r24, 0x7E	; 126
    37e4:	91 e3       	ldi	r25, 0x31	; 49
    37e6:	8f 8b       	std	Y+23, r24	; 0x17
    37e8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    37ea:	84 e7       	ldi	r24, 0x74	; 116
    37ec:	91 e3       	ldi	r25, 0x31	; 49
    37ee:	89 8f       	std	Y+25, r24	; 0x19
    37f0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    37f2:	8a e6       	ldi	r24, 0x6A	; 106
    37f4:	91 e3       	ldi	r25, 0x31	; 49
    37f6:	8b 8f       	std	Y+27, r24	; 0x1b
    37f8:	9c 8f       	std	Y+28, r25	; 0x1c
    37fa:	42 c0       	rjmp	.+132    	; 0x3880 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    37fc:	00 3b       	cpi	r16, 0xB0	; 176
    37fe:	e8 e0       	ldi	r30, 0x08	; 8
    3800:	1e 07       	cpc	r17, r30
    3802:	69 f4       	brne	.+26     	; 0x381e <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3804:	8c e7       	ldi	r24, 0x7C	; 124
    3806:	91 e3       	ldi	r25, 0x31	; 49
    3808:	8f 8b       	std	Y+23, r24	; 0x17
    380a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    380c:	82 e7       	ldi	r24, 0x72	; 114
    380e:	91 e3       	ldi	r25, 0x31	; 49
    3810:	89 8f       	std	Y+25, r24	; 0x19
    3812:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3814:	88 e6       	ldi	r24, 0x68	; 104
    3816:	91 e3       	ldi	r25, 0x31	; 49
    3818:	8b 8f       	std	Y+27, r24	; 0x1b
    381a:	9c 8f       	std	Y+28, r25	; 0x1c
    381c:	31 c0       	rjmp	.+98     	; 0x3880 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    381e:	00 3a       	cpi	r16, 0xA0	; 160
    3820:	f9 e0       	ldi	r31, 0x09	; 9
    3822:	1f 07       	cpc	r17, r31
    3824:	69 f4       	brne	.+26     	; 0x3840 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3826:	8a e7       	ldi	r24, 0x7A	; 122
    3828:	91 e3       	ldi	r25, 0x31	; 49
    382a:	8f 8b       	std	Y+23, r24	; 0x17
    382c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    382e:	80 e7       	ldi	r24, 0x70	; 112
    3830:	91 e3       	ldi	r25, 0x31	; 49
    3832:	89 8f       	std	Y+25, r24	; 0x19
    3834:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3836:	86 e6       	ldi	r24, 0x66	; 102
    3838:	91 e3       	ldi	r25, 0x31	; 49
    383a:	8b 8f       	std	Y+27, r24	; 0x1b
    383c:	9c 8f       	std	Y+28, r25	; 0x1c
    383e:	20 c0       	rjmp	.+64     	; 0x3880 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3840:	00 3b       	cpi	r16, 0xB0	; 176
    3842:	89 e0       	ldi	r24, 0x09	; 9
    3844:	18 07       	cpc	r17, r24
    3846:	69 f4       	brne	.+26     	; 0x3862 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3848:	88 e7       	ldi	r24, 0x78	; 120
    384a:	91 e3       	ldi	r25, 0x31	; 49
    384c:	8f 8b       	std	Y+23, r24	; 0x17
    384e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3850:	8e e6       	ldi	r24, 0x6E	; 110
    3852:	91 e3       	ldi	r25, 0x31	; 49
    3854:	89 8f       	std	Y+25, r24	; 0x19
    3856:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3858:	84 e6       	ldi	r24, 0x64	; 100
    385a:	91 e3       	ldi	r25, 0x31	; 49
    385c:	8b 8f       	std	Y+27, r24	; 0x1b
    385e:	9c 8f       	std	Y+28, r25	; 0x1c
    3860:	0f c0       	rjmp	.+30     	; 0x3880 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3862:	00 3a       	cpi	r16, 0xA0	; 160
    3864:	1a 40       	sbci	r17, 0x0A	; 10
    3866:	61 f4       	brne	.+24     	; 0x3880 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3868:	86 e7       	ldi	r24, 0x76	; 118
    386a:	91 e3       	ldi	r25, 0x31	; 49
    386c:	8f 8b       	std	Y+23, r24	; 0x17
    386e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3870:	8c e6       	ldi	r24, 0x6C	; 108
    3872:	91 e3       	ldi	r25, 0x31	; 49
    3874:	89 8f       	std	Y+25, r24	; 0x19
    3876:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3878:	82 e6       	ldi	r24, 0x62	; 98
    387a:	91 e3       	ldi	r25, 0x31	; 49
    387c:	8b 8f       	std	Y+27, r24	; 0x1b
    387e:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3880:	0f 89       	ldd	r16, Y+23	; 0x17
    3882:	18 8d       	ldd	r17, Y+24	; 0x18
    3884:	84 e6       	ldi	r24, 0x64	; 100
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	0e 94 24 19 	call	0x3248	; 0x3248 <_Znaj>
    388c:	f8 01       	movw	r30, r16
    388e:	80 83       	st	Z, r24
    3890:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3892:	e9 8d       	ldd	r30, Y+25	; 0x19
    3894:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3896:	10 82       	st	Z, r1
    3898:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    389a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    389c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    389e:	10 82       	st	Z, r1
    38a0:	11 82       	std	Z+1, r1	; 0x01
}
    38a2:	df 91       	pop	r29
    38a4:	cf 91       	pop	r28
    38a6:	1f 91       	pop	r17
    38a8:	0f 91       	pop	r16
    38aa:	ff 90       	pop	r15
    38ac:	ef 90       	pop	r14
    38ae:	08 95       	ret

000038b0 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    38b0:	1f 92       	push	r1
    38b2:	0f 92       	push	r0
    38b4:	0f b6       	in	r0, 0x3f	; 63
    38b6:	0f 92       	push	r0
    38b8:	11 24       	eor	r1, r1
    38ba:	08 b6       	in	r0, 0x38	; 56
    38bc:	0f 92       	push	r0
    38be:	18 be       	out	0x38, r1	; 56
    38c0:	0b b6       	in	r0, 0x3b	; 59
    38c2:	0f 92       	push	r0
    38c4:	1b be       	out	0x3b, r1	; 59
    38c6:	2f 93       	push	r18
    38c8:	3f 93       	push	r19
    38ca:	8f 93       	push	r24
    38cc:	9f 93       	push	r25
    38ce:	ef 93       	push	r30
    38d0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    38d2:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    38d6:	e0 91 7e 31 	lds	r30, 0x317E	; 0x80317e <rcvC0_buffer>
    38da:	f0 91 7f 31 	lds	r31, 0x317F	; 0x80317f <rcvC0_buffer+0x1>
    38de:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <rcvC0_write_index>
    38e2:	90 91 6b 31 	lds	r25, 0x316B	; 0x80316b <rcvC0_write_index+0x1>
    38e6:	e8 0f       	add	r30, r24
    38e8:	f9 1f       	adc	r31, r25
    38ea:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    38ec:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <rcvC0_write_index>
    38f0:	90 91 6b 31 	lds	r25, 0x316B	; 0x80316b <rcvC0_write_index+0x1>
    38f4:	01 96       	adiw	r24, 0x01	; 1
    38f6:	84 36       	cpi	r24, 0x64	; 100
    38f8:	91 05       	cpc	r25, r1
    38fa:	60 f4       	brcc	.+24     	; 0x3914 <__vector_25+0x64>
    38fc:	80 93 6a 31 	sts	0x316A, r24	; 0x80316a <rcvC0_write_index>
    3900:	90 93 6b 31 	sts	0x316B, r25	; 0x80316b <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3904:	20 91 74 31 	lds	r18, 0x3174	; 0x803174 <rcvC0_read_index>
    3908:	30 91 75 31 	lds	r19, 0x3175	; 0x803175 <rcvC0_read_index+0x1>
    390c:	82 17       	cp	r24, r18
    390e:	93 07       	cpc	r25, r19
    3910:	f1 f4       	brne	.+60     	; 0x394e <__vector_25+0x9e>
    3912:	0c c0       	rjmp	.+24     	; 0x392c <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3914:	10 92 6a 31 	sts	0x316A, r1	; 0x80316a <rcvC0_write_index>
    3918:	10 92 6b 31 	sts	0x316B, r1	; 0x80316b <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    391c:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <rcvC0_read_index>
    3920:	90 91 75 31 	lds	r25, 0x3175	; 0x803175 <rcvC0_read_index+0x1>
    3924:	18 16       	cp	r1, r24
    3926:	19 06       	cpc	r1, r25
    3928:	91 f4       	brne	.+36     	; 0x394e <__vector_25+0x9e>
    392a:	0e c0       	rjmp	.+28     	; 0x3948 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    392c:	01 96       	adiw	r24, 0x01	; 1
    392e:	84 36       	cpi	r24, 0x64	; 100
    3930:	91 05       	cpc	r25, r1
    3932:	28 f4       	brcc	.+10     	; 0x393e <__vector_25+0x8e>
    3934:	80 93 74 31 	sts	0x3174, r24	; 0x803174 <rcvC0_read_index>
    3938:	90 93 75 31 	sts	0x3175, r25	; 0x803175 <rcvC0_read_index+0x1>
    393c:	08 c0       	rjmp	.+16     	; 0x394e <__vector_25+0x9e>
			rcvC0_read_index = 0;
    393e:	10 92 74 31 	sts	0x3174, r1	; 0x803174 <rcvC0_read_index>
    3942:	10 92 75 31 	sts	0x3175, r1	; 0x803175 <rcvC0_read_index+0x1>
}
    3946:	03 c0       	rjmp	.+6      	; 0x394e <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3948:	81 e0       	ldi	r24, 0x01	; 1
    394a:	90 e0       	ldi	r25, 0x00	; 0
    394c:	f3 cf       	rjmp	.-26     	; 0x3934 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    394e:	ff 91       	pop	r31
    3950:	ef 91       	pop	r30
    3952:	9f 91       	pop	r25
    3954:	8f 91       	pop	r24
    3956:	3f 91       	pop	r19
    3958:	2f 91       	pop	r18
    395a:	0f 90       	pop	r0
    395c:	0b be       	out	0x3b, r0	; 59
    395e:	0f 90       	pop	r0
    3960:	08 be       	out	0x38, r0	; 56
    3962:	0f 90       	pop	r0
    3964:	0f be       	out	0x3f, r0	; 63
    3966:	0f 90       	pop	r0
    3968:	1f 90       	pop	r1
    396a:	18 95       	reti

0000396c <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    396c:	1f 92       	push	r1
    396e:	0f 92       	push	r0
    3970:	0f b6       	in	r0, 0x3f	; 63
    3972:	0f 92       	push	r0
    3974:	11 24       	eor	r1, r1
    3976:	08 b6       	in	r0, 0x38	; 56
    3978:	0f 92       	push	r0
    397a:	18 be       	out	0x38, r1	; 56
    397c:	0b b6       	in	r0, 0x3b	; 59
    397e:	0f 92       	push	r0
    3980:	1b be       	out	0x3b, r1	; 59
    3982:	2f 93       	push	r18
    3984:	3f 93       	push	r19
    3986:	8f 93       	push	r24
    3988:	9f 93       	push	r25
    398a:	ef 93       	push	r30
    398c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    398e:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3992:	e0 91 7c 31 	lds	r30, 0x317C	; 0x80317c <rcvC1_buffer>
    3996:	f0 91 7d 31 	lds	r31, 0x317D	; 0x80317d <rcvC1_buffer+0x1>
    399a:	80 91 68 31 	lds	r24, 0x3168	; 0x803168 <rcvC1_write_index>
    399e:	90 91 69 31 	lds	r25, 0x3169	; 0x803169 <rcvC1_write_index+0x1>
    39a2:	e8 0f       	add	r30, r24
    39a4:	f9 1f       	adc	r31, r25
    39a6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    39a8:	80 91 68 31 	lds	r24, 0x3168	; 0x803168 <rcvC1_write_index>
    39ac:	90 91 69 31 	lds	r25, 0x3169	; 0x803169 <rcvC1_write_index+0x1>
    39b0:	01 96       	adiw	r24, 0x01	; 1
    39b2:	84 36       	cpi	r24, 0x64	; 100
    39b4:	91 05       	cpc	r25, r1
    39b6:	60 f4       	brcc	.+24     	; 0x39d0 <__vector_28+0x64>
    39b8:	80 93 68 31 	sts	0x3168, r24	; 0x803168 <rcvC1_write_index>
    39bc:	90 93 69 31 	sts	0x3169, r25	; 0x803169 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39c0:	20 91 72 31 	lds	r18, 0x3172	; 0x803172 <rcvC1_read_index>
    39c4:	30 91 73 31 	lds	r19, 0x3173	; 0x803173 <rcvC1_read_index+0x1>
    39c8:	82 17       	cp	r24, r18
    39ca:	93 07       	cpc	r25, r19
    39cc:	f1 f4       	brne	.+60     	; 0x3a0a <__vector_28+0x9e>
    39ce:	0c c0       	rjmp	.+24     	; 0x39e8 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    39d0:	10 92 68 31 	sts	0x3168, r1	; 0x803168 <rcvC1_write_index>
    39d4:	10 92 69 31 	sts	0x3169, r1	; 0x803169 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39d8:	80 91 72 31 	lds	r24, 0x3172	; 0x803172 <rcvC1_read_index>
    39dc:	90 91 73 31 	lds	r25, 0x3173	; 0x803173 <rcvC1_read_index+0x1>
    39e0:	18 16       	cp	r1, r24
    39e2:	19 06       	cpc	r1, r25
    39e4:	91 f4       	brne	.+36     	; 0x3a0a <__vector_28+0x9e>
    39e6:	0e c0       	rjmp	.+28     	; 0x3a04 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    39e8:	01 96       	adiw	r24, 0x01	; 1
    39ea:	84 36       	cpi	r24, 0x64	; 100
    39ec:	91 05       	cpc	r25, r1
    39ee:	28 f4       	brcc	.+10     	; 0x39fa <__vector_28+0x8e>
    39f0:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <rcvC1_read_index>
    39f4:	90 93 73 31 	sts	0x3173, r25	; 0x803173 <rcvC1_read_index+0x1>
    39f8:	08 c0       	rjmp	.+16     	; 0x3a0a <__vector_28+0x9e>
	rcvC1_read_index = 0;
    39fa:	10 92 72 31 	sts	0x3172, r1	; 0x803172 <rcvC1_read_index>
    39fe:	10 92 73 31 	sts	0x3173, r1	; 0x803173 <rcvC1_read_index+0x1>
}
    3a02:	03 c0       	rjmp	.+6      	; 0x3a0a <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a04:	81 e0       	ldi	r24, 0x01	; 1
    3a06:	90 e0       	ldi	r25, 0x00	; 0
    3a08:	f3 cf       	rjmp	.-26     	; 0x39f0 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3a0a:	ff 91       	pop	r31
    3a0c:	ef 91       	pop	r30
    3a0e:	9f 91       	pop	r25
    3a10:	8f 91       	pop	r24
    3a12:	3f 91       	pop	r19
    3a14:	2f 91       	pop	r18
    3a16:	0f 90       	pop	r0
    3a18:	0b be       	out	0x3b, r0	; 59
    3a1a:	0f 90       	pop	r0
    3a1c:	08 be       	out	0x38, r0	; 56
    3a1e:	0f 90       	pop	r0
    3a20:	0f be       	out	0x3f, r0	; 63
    3a22:	0f 90       	pop	r0
    3a24:	1f 90       	pop	r1
    3a26:	18 95       	reti

00003a28 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3a28:	1f 92       	push	r1
    3a2a:	0f 92       	push	r0
    3a2c:	0f b6       	in	r0, 0x3f	; 63
    3a2e:	0f 92       	push	r0
    3a30:	11 24       	eor	r1, r1
    3a32:	08 b6       	in	r0, 0x38	; 56
    3a34:	0f 92       	push	r0
    3a36:	18 be       	out	0x38, r1	; 56
    3a38:	0b b6       	in	r0, 0x3b	; 59
    3a3a:	0f 92       	push	r0
    3a3c:	1b be       	out	0x3b, r1	; 59
    3a3e:	2f 93       	push	r18
    3a40:	3f 93       	push	r19
    3a42:	8f 93       	push	r24
    3a44:	9f 93       	push	r25
    3a46:	ef 93       	push	r30
    3a48:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3a4a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3a4e:	e0 91 7a 31 	lds	r30, 0x317A	; 0x80317a <rcvD0_buffer>
    3a52:	f0 91 7b 31 	lds	r31, 0x317B	; 0x80317b <rcvD0_buffer+0x1>
    3a56:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <rcvC0_write_index>
    3a5a:	90 91 6b 31 	lds	r25, 0x316B	; 0x80316b <rcvC0_write_index+0x1>
    3a5e:	e8 0f       	add	r30, r24
    3a60:	f9 1f       	adc	r31, r25
    3a62:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3a64:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <rcvD0_write_index>
    3a68:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <rcvD0_write_index+0x1>
    3a6c:	01 96       	adiw	r24, 0x01	; 1
    3a6e:	84 36       	cpi	r24, 0x64	; 100
    3a70:	91 05       	cpc	r25, r1
    3a72:	60 f4       	brcc	.+24     	; 0x3a8c <__vector_88+0x64>
    3a74:	80 93 66 31 	sts	0x3166, r24	; 0x803166 <rcvD0_write_index>
    3a78:	90 93 67 31 	sts	0x3167, r25	; 0x803167 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a7c:	20 91 70 31 	lds	r18, 0x3170	; 0x803170 <rcvD0_read_index>
    3a80:	30 91 71 31 	lds	r19, 0x3171	; 0x803171 <rcvD0_read_index+0x1>
    3a84:	82 17       	cp	r24, r18
    3a86:	93 07       	cpc	r25, r19
    3a88:	f1 f4       	brne	.+60     	; 0x3ac6 <__vector_88+0x9e>
    3a8a:	0c c0       	rjmp	.+24     	; 0x3aa4 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3a8c:	10 92 66 31 	sts	0x3166, r1	; 0x803166 <rcvD0_write_index>
    3a90:	10 92 67 31 	sts	0x3167, r1	; 0x803167 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a94:	80 91 70 31 	lds	r24, 0x3170	; 0x803170 <rcvD0_read_index>
    3a98:	90 91 71 31 	lds	r25, 0x3171	; 0x803171 <rcvD0_read_index+0x1>
    3a9c:	18 16       	cp	r1, r24
    3a9e:	19 06       	cpc	r1, r25
    3aa0:	91 f4       	brne	.+36     	; 0x3ac6 <__vector_88+0x9e>
    3aa2:	0e c0       	rjmp	.+28     	; 0x3ac0 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3aa4:	01 96       	adiw	r24, 0x01	; 1
    3aa6:	84 36       	cpi	r24, 0x64	; 100
    3aa8:	91 05       	cpc	r25, r1
    3aaa:	28 f4       	brcc	.+10     	; 0x3ab6 <__vector_88+0x8e>
    3aac:	80 93 70 31 	sts	0x3170, r24	; 0x803170 <rcvD0_read_index>
    3ab0:	90 93 71 31 	sts	0x3171, r25	; 0x803171 <rcvD0_read_index+0x1>
    3ab4:	08 c0       	rjmp	.+16     	; 0x3ac6 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3ab6:	10 92 70 31 	sts	0x3170, r1	; 0x803170 <rcvD0_read_index>
    3aba:	10 92 71 31 	sts	0x3171, r1	; 0x803171 <rcvD0_read_index+0x1>
}
    3abe:	03 c0       	rjmp	.+6      	; 0x3ac6 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3ac0:	81 e0       	ldi	r24, 0x01	; 1
    3ac2:	90 e0       	ldi	r25, 0x00	; 0
    3ac4:	f3 cf       	rjmp	.-26     	; 0x3aac <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3ac6:	ff 91       	pop	r31
    3ac8:	ef 91       	pop	r30
    3aca:	9f 91       	pop	r25
    3acc:	8f 91       	pop	r24
    3ace:	3f 91       	pop	r19
    3ad0:	2f 91       	pop	r18
    3ad2:	0f 90       	pop	r0
    3ad4:	0b be       	out	0x3b, r0	; 59
    3ad6:	0f 90       	pop	r0
    3ad8:	08 be       	out	0x38, r0	; 56
    3ada:	0f 90       	pop	r0
    3adc:	0f be       	out	0x3f, r0	; 63
    3ade:	0f 90       	pop	r0
    3ae0:	1f 90       	pop	r1
    3ae2:	18 95       	reti

00003ae4 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3ae4:	1f 92       	push	r1
    3ae6:	0f 92       	push	r0
    3ae8:	0f b6       	in	r0, 0x3f	; 63
    3aea:	0f 92       	push	r0
    3aec:	11 24       	eor	r1, r1
    3aee:	08 b6       	in	r0, 0x38	; 56
    3af0:	0f 92       	push	r0
    3af2:	18 be       	out	0x38, r1	; 56
    3af4:	0b b6       	in	r0, 0x3b	; 59
    3af6:	0f 92       	push	r0
    3af8:	1b be       	out	0x3b, r1	; 59
    3afa:	2f 93       	push	r18
    3afc:	3f 93       	push	r19
    3afe:	8f 93       	push	r24
    3b00:	9f 93       	push	r25
    3b02:	ef 93       	push	r30
    3b04:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3b06:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3b0a:	e0 91 78 31 	lds	r30, 0x3178	; 0x803178 <rcvD1_buffer>
    3b0e:	f0 91 79 31 	lds	r31, 0x3179	; 0x803179 <rcvD1_buffer+0x1>
    3b12:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <rcvD1_write_index>
    3b16:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <rcvD1_write_index+0x1>
    3b1a:	e8 0f       	add	r30, r24
    3b1c:	f9 1f       	adc	r31, r25
    3b1e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3b20:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <rcvD1_write_index>
    3b24:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <rcvD1_write_index+0x1>
    3b28:	01 96       	adiw	r24, 0x01	; 1
    3b2a:	84 36       	cpi	r24, 0x64	; 100
    3b2c:	91 05       	cpc	r25, r1
    3b2e:	60 f4       	brcc	.+24     	; 0x3b48 <__vector_91+0x64>
    3b30:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <rcvD1_write_index>
    3b34:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b38:	20 91 6e 31 	lds	r18, 0x316E	; 0x80316e <rcvD1_read_index>
    3b3c:	30 91 6f 31 	lds	r19, 0x316F	; 0x80316f <rcvD1_read_index+0x1>
    3b40:	82 17       	cp	r24, r18
    3b42:	93 07       	cpc	r25, r19
    3b44:	f1 f4       	brne	.+60     	; 0x3b82 <__vector_91+0x9e>
    3b46:	0c c0       	rjmp	.+24     	; 0x3b60 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3b48:	10 92 64 31 	sts	0x3164, r1	; 0x803164 <rcvD1_write_index>
    3b4c:	10 92 65 31 	sts	0x3165, r1	; 0x803165 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b50:	80 91 6e 31 	lds	r24, 0x316E	; 0x80316e <rcvD1_read_index>
    3b54:	90 91 6f 31 	lds	r25, 0x316F	; 0x80316f <rcvD1_read_index+0x1>
    3b58:	18 16       	cp	r1, r24
    3b5a:	19 06       	cpc	r1, r25
    3b5c:	91 f4       	brne	.+36     	; 0x3b82 <__vector_91+0x9e>
    3b5e:	0e c0       	rjmp	.+28     	; 0x3b7c <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b60:	01 96       	adiw	r24, 0x01	; 1
    3b62:	84 36       	cpi	r24, 0x64	; 100
    3b64:	91 05       	cpc	r25, r1
    3b66:	28 f4       	brcc	.+10     	; 0x3b72 <__vector_91+0x8e>
    3b68:	80 93 6e 31 	sts	0x316E, r24	; 0x80316e <rcvD1_read_index>
    3b6c:	90 93 6f 31 	sts	0x316F, r25	; 0x80316f <rcvD1_read_index+0x1>
    3b70:	08 c0       	rjmp	.+16     	; 0x3b82 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3b72:	10 92 6e 31 	sts	0x316E, r1	; 0x80316e <rcvD1_read_index>
    3b76:	10 92 6f 31 	sts	0x316F, r1	; 0x80316f <rcvD1_read_index+0x1>
}
    3b7a:	03 c0       	rjmp	.+6      	; 0x3b82 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b7c:	81 e0       	ldi	r24, 0x01	; 1
    3b7e:	90 e0       	ldi	r25, 0x00	; 0
    3b80:	f3 cf       	rjmp	.-26     	; 0x3b68 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3b82:	ff 91       	pop	r31
    3b84:	ef 91       	pop	r30
    3b86:	9f 91       	pop	r25
    3b88:	8f 91       	pop	r24
    3b8a:	3f 91       	pop	r19
    3b8c:	2f 91       	pop	r18
    3b8e:	0f 90       	pop	r0
    3b90:	0b be       	out	0x3b, r0	; 59
    3b92:	0f 90       	pop	r0
    3b94:	08 be       	out	0x38, r0	; 56
    3b96:	0f 90       	pop	r0
    3b98:	0f be       	out	0x3f, r0	; 63
    3b9a:	0f 90       	pop	r0
    3b9c:	1f 90       	pop	r1
    3b9e:	18 95       	reti

00003ba0 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3ba0:	1f 92       	push	r1
    3ba2:	0f 92       	push	r0
    3ba4:	0f b6       	in	r0, 0x3f	; 63
    3ba6:	0f 92       	push	r0
    3ba8:	11 24       	eor	r1, r1
    3baa:	08 b6       	in	r0, 0x38	; 56
    3bac:	0f 92       	push	r0
    3bae:	18 be       	out	0x38, r1	; 56
    3bb0:	0b b6       	in	r0, 0x3b	; 59
    3bb2:	0f 92       	push	r0
    3bb4:	1b be       	out	0x3b, r1	; 59
    3bb6:	2f 93       	push	r18
    3bb8:	3f 93       	push	r19
    3bba:	8f 93       	push	r24
    3bbc:	9f 93       	push	r25
    3bbe:	ef 93       	push	r30
    3bc0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3bc2:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3bc6:	e0 91 76 31 	lds	r30, 0x3176	; 0x803176 <rcvE0_buffer>
    3bca:	f0 91 77 31 	lds	r31, 0x3177	; 0x803177 <rcvE0_buffer+0x1>
    3bce:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <rcvE0_write_index>
    3bd2:	90 91 63 31 	lds	r25, 0x3163	; 0x803163 <rcvE0_write_index+0x1>
    3bd6:	e8 0f       	add	r30, r24
    3bd8:	f9 1f       	adc	r31, r25
    3bda:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3bdc:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <rcvE0_write_index>
    3be0:	90 91 63 31 	lds	r25, 0x3163	; 0x803163 <rcvE0_write_index+0x1>
    3be4:	01 96       	adiw	r24, 0x01	; 1
    3be6:	84 36       	cpi	r24, 0x64	; 100
    3be8:	91 05       	cpc	r25, r1
    3bea:	60 f4       	brcc	.+24     	; 0x3c04 <__vector_58+0x64>
    3bec:	80 93 62 31 	sts	0x3162, r24	; 0x803162 <rcvE0_write_index>
    3bf0:	90 93 63 31 	sts	0x3163, r25	; 0x803163 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3bf4:	20 91 6c 31 	lds	r18, 0x316C	; 0x80316c <rcvE0_read_index>
    3bf8:	30 91 6d 31 	lds	r19, 0x316D	; 0x80316d <rcvE0_read_index+0x1>
    3bfc:	82 17       	cp	r24, r18
    3bfe:	93 07       	cpc	r25, r19
    3c00:	f1 f4       	brne	.+60     	; 0x3c3e <__vector_58+0x9e>
    3c02:	0c c0       	rjmp	.+24     	; 0x3c1c <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3c04:	10 92 62 31 	sts	0x3162, r1	; 0x803162 <rcvE0_write_index>
    3c08:	10 92 63 31 	sts	0x3163, r1	; 0x803163 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c0c:	80 91 6c 31 	lds	r24, 0x316C	; 0x80316c <rcvE0_read_index>
    3c10:	90 91 6d 31 	lds	r25, 0x316D	; 0x80316d <rcvE0_read_index+0x1>
    3c14:	18 16       	cp	r1, r24
    3c16:	19 06       	cpc	r1, r25
    3c18:	91 f4       	brne	.+36     	; 0x3c3e <__vector_58+0x9e>
    3c1a:	0e c0       	rjmp	.+28     	; 0x3c38 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c1c:	01 96       	adiw	r24, 0x01	; 1
    3c1e:	84 36       	cpi	r24, 0x64	; 100
    3c20:	91 05       	cpc	r25, r1
    3c22:	28 f4       	brcc	.+10     	; 0x3c2e <__vector_58+0x8e>
    3c24:	80 93 6c 31 	sts	0x316C, r24	; 0x80316c <rcvE0_read_index>
    3c28:	90 93 6d 31 	sts	0x316D, r25	; 0x80316d <rcvE0_read_index+0x1>
    3c2c:	08 c0       	rjmp	.+16     	; 0x3c3e <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3c2e:	10 92 6c 31 	sts	0x316C, r1	; 0x80316c <rcvE0_read_index>
    3c32:	10 92 6d 31 	sts	0x316D, r1	; 0x80316d <rcvE0_read_index+0x1>
}
    3c36:	03 c0       	rjmp	.+6      	; 0x3c3e <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c38:	81 e0       	ldi	r24, 0x01	; 1
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	f3 cf       	rjmp	.-26     	; 0x3c24 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3c3e:	ff 91       	pop	r31
    3c40:	ef 91       	pop	r30
    3c42:	9f 91       	pop	r25
    3c44:	8f 91       	pop	r24
    3c46:	3f 91       	pop	r19
    3c48:	2f 91       	pop	r18
    3c4a:	0f 90       	pop	r0
    3c4c:	0b be       	out	0x3b, r0	; 59
    3c4e:	0f 90       	pop	r0
    3c50:	08 be       	out	0x38, r0	; 56
    3c52:	0f 90       	pop	r0
    3c54:	0f be       	out	0x3f, r0	; 63
    3c56:	0f 90       	pop	r0
    3c58:	1f 90       	pop	r1
    3c5a:	18 95       	reti

00003c5c <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3c5c:	0f 93       	push	r16
    3c5e:	cf 93       	push	r28
    3c60:	df 93       	push	r29
    3c62:	1f 92       	push	r1
    3c64:	cd b7       	in	r28, 0x3d	; 61
    3c66:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3c68:	2f b7       	in	r18, 0x3f	; 63
    3c6a:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3c6c:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3c6e:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3c70:	fc 01       	movw	r30, r24
    3c72:	08 ed       	ldi	r16, 0xD8	; 216
    3c74:	04 bf       	out	0x34, r16	; 52
    3c76:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3c78:	89 81       	ldd	r24, Y+1	; 0x01
    3c7a:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3c7c:	0f 90       	pop	r0
    3c7e:	df 91       	pop	r29
    3c80:	cf 91       	pop	r28
    3c82:	0f 91       	pop	r16
    3c84:	08 95       	ret

00003c86 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3c86:	0f 93       	push	r16
    3c88:	1f 93       	push	r17
    3c8a:	cf 93       	push	r28
    3c8c:	df 93       	push	r29
    3c8e:	cd b7       	in	r28, 0x3d	; 61
    3c90:	de b7       	in	r29, 0x3e	; 62
    3c92:	6d 97       	sbiw	r28, 0x1d	; 29
    3c94:	cd bf       	out	0x3d, r28	; 61
    3c96:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3c98:	e0 e6       	ldi	r30, 0x60	; 96
    3c9a:	f6 e0       	ldi	r31, 0x06	; 6
    3c9c:	80 e4       	ldi	r24, 0x40	; 64
    3c9e:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3ca0:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3ca2:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3ca4:	e0 e5       	ldi	r30, 0x50	; 80
    3ca6:	f0 e0       	ldi	r31, 0x00	; 0
    3ca8:	80 81       	ld	r24, Z
    3caa:	82 60       	ori	r24, 0x02	; 2
    3cac:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3cae:	81 81       	ldd	r24, Z+1	; 0x01
    3cb0:	81 ff       	sbrs	r24, 1
    3cb2:	fd cf       	rjmp	.-6      	; 0x3cae <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3cb4:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3cb8:	68 7f       	andi	r22, 0xF8	; 248
    3cba:	61 60       	ori	r22, 0x01	; 1
    3cbc:	80 e4       	ldi	r24, 0x40	; 64
    3cbe:	90 e0       	ldi	r25, 0x00	; 0
    3cc0:	0e 94 2e 1e 	call	0x3c5c	; 0x3c5c <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3cc4:	e0 e5       	ldi	r30, 0x50	; 80
    3cc6:	f0 e0       	ldi	r31, 0x00	; 0
    3cc8:	80 81       	ld	r24, Z
    3cca:	8e 7f       	andi	r24, 0xFE	; 254
    3ccc:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3cce:	9d ef       	ldi	r25, 0xFD	; 253
    3cd0:	88 ed       	ldi	r24, 0xD8	; 216
    3cd2:	08 b6       	in	r0, 0x38	; 56
    3cd4:	18 be       	out	0x38, r1	; 56
    3cd6:	84 bf       	out	0x34, r24	; 52
    3cd8:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3cdc:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3cde:	40 eb       	ldi	r20, 0xB0	; 176
    3ce0:	58 e0       	ldi	r21, 0x08	; 8
    3ce2:	60 e0       	ldi	r22, 0x00	; 0
    3ce4:	70 e0       	ldi	r23, 0x00	; 0
    3ce6:	ce 01       	movw	r24, r28
    3ce8:	01 96       	adiw	r24, 0x01	; 1
    3cea:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3cee:	67 e0       	ldi	r22, 0x07	; 7
    3cf0:	ce 01       	movw	r24, r28
    3cf2:	01 96       	adiw	r24, 0x01	; 1
    3cf4:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    3cf8:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3cfa:	60 e9       	ldi	r22, 0x90	; 144
    3cfc:	70 e2       	ldi	r23, 0x20	; 32
    3cfe:	0e 94 d5 19 	call	0x33aa	; 0x33aa <_ZN8emstream4putsEPKc>
    3d02:	66 e0       	ldi	r22, 0x06	; 6
    3d04:	c8 01       	movw	r24, r16
    3d06:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
    3d0a:	66 e0       	ldi	r22, 0x06	; 6
    3d0c:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3d10:	82 e1       	ldi	r24, 0x12	; 18
    3d12:	90 e0       	ldi	r25, 0x00	; 0
    3d14:	0e 94 21 19 	call	0x3242	; 0x3242 <_Znwj>
    3d18:	8e 01       	movw	r16, r28
    3d1a:	0f 5f       	subi	r16, 0xFF	; 255
    3d1c:	1f 4f       	sbci	r17, 0xFF	; 255
    3d1e:	24 e0       	ldi	r18, 0x04	; 4
    3d20:	31 e0       	ldi	r19, 0x01	; 1
    3d22:	40 e0       	ldi	r20, 0x00	; 0
    3d24:	6f ea       	ldi	r22, 0xAF	; 175
    3d26:	70 e2       	ldi	r23, 0x20	; 32
    3d28:	0e 94 bd 06 	call	0xd7a	; 0xd7a <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new task_EncoderMotor ("EncMtr", task_priority(7), 260, &ser_dev);
    3d2c:	82 e1       	ldi	r24, 0x12	; 18
    3d2e:	90 e0       	ldi	r25, 0x00	; 0
    3d30:	0e 94 21 19 	call	0x3242	; 0x3242 <_Znwj>
    3d34:	24 e0       	ldi	r18, 0x04	; 4
    3d36:	31 e0       	ldi	r19, 0x01	; 1
    3d38:	44 e0       	ldi	r20, 0x04	; 4
    3d3a:	67 eb       	ldi	r22, 0xB7	; 183
    3d3c:	70 e2       	ldi	r23, 0x20	; 32
    3d3e:	0e 94 ab 03 	call	0x756	; 0x756 <_ZN17task_EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new task_EncoderPendulum ("EncPen", task_priority(6), 260, &ser_dev);
    3d42:	82 e1       	ldi	r24, 0x12	; 18
    3d44:	90 e0       	ldi	r25, 0x00	; 0
    3d46:	0e 94 21 19 	call	0x3242	; 0x3242 <_Znwj>
    3d4a:	24 e0       	ldi	r18, 0x04	; 4
    3d4c:	31 e0       	ldi	r19, 0x01	; 1
    3d4e:	44 e0       	ldi	r20, 0x04	; 4
    3d50:	6e eb       	ldi	r22, 0xBE	; 190
    3d52:	70 e2       	ldi	r23, 0x20	; 32
    3d54:	0e 94 1b 04 	call	0x836	; 0x836 <_ZN20task_EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new task_LimitSwitches ("LimSwtch", task_priority(5), 260, &ser_dev);
    3d58:	82 e1       	ldi	r24, 0x12	; 18
    3d5a:	90 e0       	ldi	r25, 0x00	; 0
    3d5c:	0e 94 21 19 	call	0x3242	; 0x3242 <_Znwj>
    3d60:	24 e0       	ldi	r18, 0x04	; 4
    3d62:	31 e0       	ldi	r19, 0x01	; 1
    3d64:	44 e0       	ldi	r20, 0x04	; 4
    3d66:	65 ec       	ldi	r22, 0xC5	; 197
    3d68:	70 e2       	ldi	r23, 0x20	; 32
    3d6a:	0e 94 80 04 	call	0x900	; 0x900 <_ZN18task_LimitSwitchesC1EPKchjP8emstream>

	// The Motor task receives actuator signal and outputs PWM to the motor
	new task_Motor ("Motor", task_priority(4), 260, &ser_dev);
    3d6e:	8c e6       	ldi	r24, 0x6C	; 108
    3d70:	90 e0       	ldi	r25, 0x00	; 0
    3d72:	0e 94 21 19 	call	0x3242	; 0x3242 <_Znwj>
    3d76:	24 e0       	ldi	r18, 0x04	; 4
    3d78:	31 e0       	ldi	r19, 0x01	; 1
    3d7a:	44 e0       	ldi	r20, 0x04	; 4
    3d7c:	6e ec       	ldi	r22, 0xCE	; 206
    3d7e:	70 e2       	ldi	r23, 0x20	; 32
    3d80:	0e 94 88 06 	call	0xd10	; 0xd10 <_ZN10task_MotorC1EPKchjP8emstream>
	
	// The Velocity task handles the inner control loop
	new task_Velocity ("WLoopCtrl", task_priority(1), 260, &ser_dev);
    3d84:	82 e1       	ldi	r24, 0x12	; 18
    3d86:	90 e0       	ldi	r25, 0x00	; 0
    3d88:	0e 94 21 19 	call	0x3242	; 0x3242 <_Znwj>
    3d8c:	24 e0       	ldi	r18, 0x04	; 4
    3d8e:	31 e0       	ldi	r19, 0x01	; 1
    3d90:	41 e0       	ldi	r20, 0x01	; 1
    3d92:	64 ed       	ldi	r22, 0xD4	; 212
    3d94:	70 e2       	ldi	r23, 0x20	; 32
    3d96:	0e 94 42 09 	call	0x1284	; 0x1284 <_ZN13task_VelocityC1EPKchjP8emstream>
	
	// The Position task handles the middle control loop wrapped around velocity
	new task_Position ("PosLoopCtrl", task_priority(2), 260, &ser_dev);
    3d9a:	82 e1       	ldi	r24, 0x12	; 18
    3d9c:	90 e0       	ldi	r25, 0x00	; 0
    3d9e:	0e 94 21 19 	call	0x3242	; 0x3242 <_Znwj>
    3da2:	24 e0       	ldi	r18, 0x04	; 4
    3da4:	31 e0       	ldi	r19, 0x01	; 1
    3da6:	42 e0       	ldi	r20, 0x02	; 2
    3da8:	6e ed       	ldi	r22, 0xDE	; 222
    3daa:	70 e2       	ldi	r23, 0x20	; 32
    3dac:	0e 94 ad 06 	call	0xd5a	; 0xd5a <_ZN13task_PositionC1EPKchjP8emstream>
	
	// The Angle task is the outer control loop. It takes in angle error and outputs a position command
	new task_Angle ("AngLoopCtrl", task_priority(3), 260, &ser_dev);
    3db0:	82 e1       	ldi	r24, 0x12	; 18
    3db2:	90 e0       	ldi	r25, 0x00	; 0
    3db4:	0e 94 21 19 	call	0x3242	; 0x3242 <_Znwj>
    3db8:	24 e0       	ldi	r18, 0x04	; 4
    3dba:	31 e0       	ldi	r19, 0x01	; 1
    3dbc:	43 e0       	ldi	r20, 0x03	; 3
    3dbe:	6a ee       	ldi	r22, 0xEA	; 234
    3dc0:	70 e2       	ldi	r23, 0x20	; 32
    3dc2:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10task_AngleC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3dc6:	87 e0       	ldi	r24, 0x07	; 7
    3dc8:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3dcc:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3dce:	0e 94 33 10 	call	0x2066	; 0x2066 <vTaskStartScheduler>
	
	
	return 0;
    3dd2:	80 e0       	ldi	r24, 0x00	; 0
    3dd4:	90 e0       	ldi	r25, 0x00	; 0
    3dd6:	6d 96       	adiw	r28, 0x1d	; 29
    3dd8:	cd bf       	out	0x3d, r28	; 61
    3dda:	de bf       	out	0x3e, r29	; 62
    3ddc:	df 91       	pop	r29
    3dde:	cf 91       	pop	r28
    3de0:	1f 91       	pop	r17
    3de2:	0f 91       	pop	r16
    3de4:	08 95       	ret

00003de6 <_GLOBAL__sub_I_counter>:
    3de6:	0f 93       	push	r16
    3de8:	1f 93       	push	r17
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3dea:	0a e0       	ldi	r16, 0x0A	; 10
    3dec:	10 e0       	ldi	r17, 0x00	; 0
    3dee:	20 e0       	ldi	r18, 0x00	; 0
    3df0:	30 e0       	ldi	r19, 0x00	; 0
    3df2:	40 e0       	ldi	r20, 0x00	; 0
    3df4:	50 e0       	ldi	r21, 0x00	; 0
    3df6:	60 e2       	ldi	r22, 0x20	; 32
    3df8:	70 e0       	ldi	r23, 0x00	; 0
    3dfa:	8a e8       	ldi	r24, 0x8A	; 138
    3dfc:	91 e3       	ldi	r25, 0x31	; 49
    3dfe:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3e02:	1f 91       	pop	r17
    3e04:	0f 91       	pop	r16
    3e06:	08 95       	ret

00003e08 <__cmpsf2>:
    3e08:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <__fp_cmp>
    3e0c:	08 f4       	brcc	.+2      	; 0x3e10 <__cmpsf2+0x8>
    3e0e:	81 e0       	ldi	r24, 0x01	; 1
    3e10:	08 95       	ret

00003e12 <__floatunsisf>:
    3e12:	e8 94       	clt
    3e14:	09 c0       	rjmp	.+18     	; 0x3e28 <__floatsisf+0x12>

00003e16 <__floatsisf>:
    3e16:	97 fb       	bst	r25, 7
    3e18:	3e f4       	brtc	.+14     	; 0x3e28 <__floatsisf+0x12>
    3e1a:	90 95       	com	r25
    3e1c:	80 95       	com	r24
    3e1e:	70 95       	com	r23
    3e20:	61 95       	neg	r22
    3e22:	7f 4f       	sbci	r23, 0xFF	; 255
    3e24:	8f 4f       	sbci	r24, 0xFF	; 255
    3e26:	9f 4f       	sbci	r25, 0xFF	; 255
    3e28:	99 23       	and	r25, r25
    3e2a:	a9 f0       	breq	.+42     	; 0x3e56 <__floatsisf+0x40>
    3e2c:	f9 2f       	mov	r31, r25
    3e2e:	96 e9       	ldi	r25, 0x96	; 150
    3e30:	bb 27       	eor	r27, r27
    3e32:	93 95       	inc	r25
    3e34:	f6 95       	lsr	r31
    3e36:	87 95       	ror	r24
    3e38:	77 95       	ror	r23
    3e3a:	67 95       	ror	r22
    3e3c:	b7 95       	ror	r27
    3e3e:	f1 11       	cpse	r31, r1
    3e40:	f8 cf       	rjmp	.-16     	; 0x3e32 <__floatsisf+0x1c>
    3e42:	fa f4       	brpl	.+62     	; 0x3e82 <__floatsisf+0x6c>
    3e44:	bb 0f       	add	r27, r27
    3e46:	11 f4       	brne	.+4      	; 0x3e4c <__floatsisf+0x36>
    3e48:	60 ff       	sbrs	r22, 0
    3e4a:	1b c0       	rjmp	.+54     	; 0x3e82 <__floatsisf+0x6c>
    3e4c:	6f 5f       	subi	r22, 0xFF	; 255
    3e4e:	7f 4f       	sbci	r23, 0xFF	; 255
    3e50:	8f 4f       	sbci	r24, 0xFF	; 255
    3e52:	9f 4f       	sbci	r25, 0xFF	; 255
    3e54:	16 c0       	rjmp	.+44     	; 0x3e82 <__floatsisf+0x6c>
    3e56:	88 23       	and	r24, r24
    3e58:	11 f0       	breq	.+4      	; 0x3e5e <__floatsisf+0x48>
    3e5a:	96 e9       	ldi	r25, 0x96	; 150
    3e5c:	11 c0       	rjmp	.+34     	; 0x3e80 <__floatsisf+0x6a>
    3e5e:	77 23       	and	r23, r23
    3e60:	21 f0       	breq	.+8      	; 0x3e6a <__floatsisf+0x54>
    3e62:	9e e8       	ldi	r25, 0x8E	; 142
    3e64:	87 2f       	mov	r24, r23
    3e66:	76 2f       	mov	r23, r22
    3e68:	05 c0       	rjmp	.+10     	; 0x3e74 <__floatsisf+0x5e>
    3e6a:	66 23       	and	r22, r22
    3e6c:	71 f0       	breq	.+28     	; 0x3e8a <__floatsisf+0x74>
    3e6e:	96 e8       	ldi	r25, 0x86	; 134
    3e70:	86 2f       	mov	r24, r22
    3e72:	70 e0       	ldi	r23, 0x00	; 0
    3e74:	60 e0       	ldi	r22, 0x00	; 0
    3e76:	2a f0       	brmi	.+10     	; 0x3e82 <__floatsisf+0x6c>
    3e78:	9a 95       	dec	r25
    3e7a:	66 0f       	add	r22, r22
    3e7c:	77 1f       	adc	r23, r23
    3e7e:	88 1f       	adc	r24, r24
    3e80:	da f7       	brpl	.-10     	; 0x3e78 <__floatsisf+0x62>
    3e82:	88 0f       	add	r24, r24
    3e84:	96 95       	lsr	r25
    3e86:	87 95       	ror	r24
    3e88:	97 f9       	bld	r25, 7
    3e8a:	08 95       	ret

00003e8c <__fp_cmp>:
    3e8c:	99 0f       	add	r25, r25
    3e8e:	00 08       	sbc	r0, r0
    3e90:	55 0f       	add	r21, r21
    3e92:	aa 0b       	sbc	r26, r26
    3e94:	e0 e8       	ldi	r30, 0x80	; 128
    3e96:	fe ef       	ldi	r31, 0xFE	; 254
    3e98:	16 16       	cp	r1, r22
    3e9a:	17 06       	cpc	r1, r23
    3e9c:	e8 07       	cpc	r30, r24
    3e9e:	f9 07       	cpc	r31, r25
    3ea0:	c0 f0       	brcs	.+48     	; 0x3ed2 <__fp_cmp+0x46>
    3ea2:	12 16       	cp	r1, r18
    3ea4:	13 06       	cpc	r1, r19
    3ea6:	e4 07       	cpc	r30, r20
    3ea8:	f5 07       	cpc	r31, r21
    3eaa:	98 f0       	brcs	.+38     	; 0x3ed2 <__fp_cmp+0x46>
    3eac:	62 1b       	sub	r22, r18
    3eae:	73 0b       	sbc	r23, r19
    3eb0:	84 0b       	sbc	r24, r20
    3eb2:	95 0b       	sbc	r25, r21
    3eb4:	39 f4       	brne	.+14     	; 0x3ec4 <__fp_cmp+0x38>
    3eb6:	0a 26       	eor	r0, r26
    3eb8:	61 f0       	breq	.+24     	; 0x3ed2 <__fp_cmp+0x46>
    3eba:	23 2b       	or	r18, r19
    3ebc:	24 2b       	or	r18, r20
    3ebe:	25 2b       	or	r18, r21
    3ec0:	21 f4       	brne	.+8      	; 0x3eca <__fp_cmp+0x3e>
    3ec2:	08 95       	ret
    3ec4:	0a 26       	eor	r0, r26
    3ec6:	09 f4       	brne	.+2      	; 0x3eca <__fp_cmp+0x3e>
    3ec8:	a1 40       	sbci	r26, 0x01	; 1
    3eca:	a6 95       	lsr	r26
    3ecc:	8f ef       	ldi	r24, 0xFF	; 255
    3ece:	81 1d       	adc	r24, r1
    3ed0:	81 1d       	adc	r24, r1
    3ed2:	08 95       	ret

00003ed4 <__gesf2>:
    3ed4:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <__fp_cmp>
    3ed8:	08 f4       	brcc	.+2      	; 0x3edc <__gesf2+0x8>
    3eda:	8f ef       	ldi	r24, 0xFF	; 255
    3edc:	08 95       	ret

00003ede <__mulsi3>:
    3ede:	db 01       	movw	r26, r22
    3ee0:	8f 93       	push	r24
    3ee2:	9f 93       	push	r25
    3ee4:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <__muluhisi3>
    3ee8:	bf 91       	pop	r27
    3eea:	af 91       	pop	r26
    3eec:	a2 9f       	mul	r26, r18
    3eee:	80 0d       	add	r24, r0
    3ef0:	91 1d       	adc	r25, r1
    3ef2:	a3 9f       	mul	r26, r19
    3ef4:	90 0d       	add	r25, r0
    3ef6:	b2 9f       	mul	r27, r18
    3ef8:	90 0d       	add	r25, r0
    3efa:	11 24       	eor	r1, r1
    3efc:	08 95       	ret

00003efe <__divmodhi4>:
    3efe:	97 fb       	bst	r25, 7
    3f00:	07 2e       	mov	r0, r23
    3f02:	16 f4       	brtc	.+4      	; 0x3f08 <__divmodhi4+0xa>
    3f04:	00 94       	com	r0
    3f06:	07 d0       	rcall	.+14     	; 0x3f16 <__divmodhi4_neg1>
    3f08:	77 fd       	sbrc	r23, 7
    3f0a:	09 d0       	rcall	.+18     	; 0x3f1e <__divmodhi4_neg2>
    3f0c:	0e 94 0e 20 	call	0x401c	; 0x401c <__udivmodhi4>
    3f10:	07 fc       	sbrc	r0, 7
    3f12:	05 d0       	rcall	.+10     	; 0x3f1e <__divmodhi4_neg2>
    3f14:	3e f4       	brtc	.+14     	; 0x3f24 <__divmodhi4_exit>

00003f16 <__divmodhi4_neg1>:
    3f16:	90 95       	com	r25
    3f18:	81 95       	neg	r24
    3f1a:	9f 4f       	sbci	r25, 0xFF	; 255
    3f1c:	08 95       	ret

00003f1e <__divmodhi4_neg2>:
    3f1e:	70 95       	com	r23
    3f20:	61 95       	neg	r22
    3f22:	7f 4f       	sbci	r23, 0xFF	; 255

00003f24 <__divmodhi4_exit>:
    3f24:	08 95       	ret

00003f26 <__udivmodsi4>:
    3f26:	a1 e2       	ldi	r26, 0x21	; 33
    3f28:	1a 2e       	mov	r1, r26
    3f2a:	aa 1b       	sub	r26, r26
    3f2c:	bb 1b       	sub	r27, r27
    3f2e:	fd 01       	movw	r30, r26
    3f30:	0d c0       	rjmp	.+26     	; 0x3f4c <__udivmodsi4_ep>

00003f32 <__udivmodsi4_loop>:
    3f32:	aa 1f       	adc	r26, r26
    3f34:	bb 1f       	adc	r27, r27
    3f36:	ee 1f       	adc	r30, r30
    3f38:	ff 1f       	adc	r31, r31
    3f3a:	a2 17       	cp	r26, r18
    3f3c:	b3 07       	cpc	r27, r19
    3f3e:	e4 07       	cpc	r30, r20
    3f40:	f5 07       	cpc	r31, r21
    3f42:	20 f0       	brcs	.+8      	; 0x3f4c <__udivmodsi4_ep>
    3f44:	a2 1b       	sub	r26, r18
    3f46:	b3 0b       	sbc	r27, r19
    3f48:	e4 0b       	sbc	r30, r20
    3f4a:	f5 0b       	sbc	r31, r21

00003f4c <__udivmodsi4_ep>:
    3f4c:	66 1f       	adc	r22, r22
    3f4e:	77 1f       	adc	r23, r23
    3f50:	88 1f       	adc	r24, r24
    3f52:	99 1f       	adc	r25, r25
    3f54:	1a 94       	dec	r1
    3f56:	69 f7       	brne	.-38     	; 0x3f32 <__udivmodsi4_loop>
    3f58:	60 95       	com	r22
    3f5a:	70 95       	com	r23
    3f5c:	80 95       	com	r24
    3f5e:	90 95       	com	r25
    3f60:	9b 01       	movw	r18, r22
    3f62:	ac 01       	movw	r20, r24
    3f64:	bd 01       	movw	r22, r26
    3f66:	cf 01       	movw	r24, r30
    3f68:	08 95       	ret

00003f6a <__divmodsi4>:
    3f6a:	05 2e       	mov	r0, r21
    3f6c:	97 fb       	bst	r25, 7
    3f6e:	1e f4       	brtc	.+6      	; 0x3f76 <__divmodsi4+0xc>
    3f70:	00 94       	com	r0
    3f72:	0e 94 cc 1f 	call	0x3f98	; 0x3f98 <__negsi2>
    3f76:	57 fd       	sbrc	r21, 7
    3f78:	07 d0       	rcall	.+14     	; 0x3f88 <__divmodsi4_neg2>
    3f7a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__udivmodsi4>
    3f7e:	07 fc       	sbrc	r0, 7
    3f80:	03 d0       	rcall	.+6      	; 0x3f88 <__divmodsi4_neg2>
    3f82:	4e f4       	brtc	.+18     	; 0x3f96 <__divmodsi4_exit>
    3f84:	0c 94 cc 1f 	jmp	0x3f98	; 0x3f98 <__negsi2>

00003f88 <__divmodsi4_neg2>:
    3f88:	50 95       	com	r21
    3f8a:	40 95       	com	r20
    3f8c:	30 95       	com	r19
    3f8e:	21 95       	neg	r18
    3f90:	3f 4f       	sbci	r19, 0xFF	; 255
    3f92:	4f 4f       	sbci	r20, 0xFF	; 255
    3f94:	5f 4f       	sbci	r21, 0xFF	; 255

00003f96 <__divmodsi4_exit>:
    3f96:	08 95       	ret

00003f98 <__negsi2>:
    3f98:	90 95       	com	r25
    3f9a:	80 95       	com	r24
    3f9c:	70 95       	com	r23
    3f9e:	61 95       	neg	r22
    3fa0:	7f 4f       	sbci	r23, 0xFF	; 255
    3fa2:	8f 4f       	sbci	r24, 0xFF	; 255
    3fa4:	9f 4f       	sbci	r25, 0xFF	; 255
    3fa6:	08 95       	ret

00003fa8 <__tablejump2__>:
    3fa8:	ee 0f       	add	r30, r30
    3faa:	ff 1f       	adc	r31, r31
    3fac:	88 1f       	adc	r24, r24
    3fae:	8b bf       	out	0x3b, r24	; 59
    3fb0:	07 90       	elpm	r0, Z+
    3fb2:	f6 91       	elpm	r31, Z
    3fb4:	e0 2d       	mov	r30, r0
    3fb6:	1b be       	out	0x3b, r1	; 59
    3fb8:	19 94       	eijmp

00003fba <__mulhisi3>:
    3fba:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <__umulhisi3>
    3fbe:	33 23       	and	r19, r19
    3fc0:	12 f4       	brpl	.+4      	; 0x3fc6 <__mulhisi3+0xc>
    3fc2:	8a 1b       	sub	r24, r26
    3fc4:	9b 0b       	sbc	r25, r27
    3fc6:	0c 94 f6 1f 	jmp	0x3fec	; 0x3fec <__usmulhisi3_tail>

00003fca <__umulhisi3>:
    3fca:	a2 9f       	mul	r26, r18
    3fcc:	b0 01       	movw	r22, r0
    3fce:	b3 9f       	mul	r27, r19
    3fd0:	c0 01       	movw	r24, r0
    3fd2:	a3 9f       	mul	r26, r19
    3fd4:	70 0d       	add	r23, r0
    3fd6:	81 1d       	adc	r24, r1
    3fd8:	11 24       	eor	r1, r1
    3fda:	91 1d       	adc	r25, r1
    3fdc:	b2 9f       	mul	r27, r18
    3fde:	70 0d       	add	r23, r0
    3fe0:	81 1d       	adc	r24, r1
    3fe2:	11 24       	eor	r1, r1
    3fe4:	91 1d       	adc	r25, r1
    3fe6:	08 95       	ret

00003fe8 <__usmulhisi3>:
    3fe8:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <__umulhisi3>

00003fec <__usmulhisi3_tail>:
    3fec:	b7 ff       	sbrs	r27, 7
    3fee:	08 95       	ret
    3ff0:	82 1b       	sub	r24, r18
    3ff2:	93 0b       	sbc	r25, r19
    3ff4:	08 95       	ret

00003ff6 <__muluhisi3>:
    3ff6:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <__umulhisi3>
    3ffa:	a5 9f       	mul	r26, r21
    3ffc:	90 0d       	add	r25, r0
    3ffe:	b4 9f       	mul	r27, r20
    4000:	90 0d       	add	r25, r0
    4002:	a4 9f       	mul	r26, r20
    4004:	80 0d       	add	r24, r0
    4006:	91 1d       	adc	r25, r1
    4008:	11 24       	eor	r1, r1
    400a:	08 95       	ret

0000400c <__mulshisi3>:
    400c:	b7 ff       	sbrs	r27, 7
    400e:	0c 94 fb 1f 	jmp	0x3ff6	; 0x3ff6 <__muluhisi3>

00004012 <__mulohisi3>:
    4012:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <__muluhisi3>
    4016:	82 1b       	sub	r24, r18
    4018:	93 0b       	sbc	r25, r19
    401a:	08 95       	ret

0000401c <__udivmodhi4>:
    401c:	aa 1b       	sub	r26, r26
    401e:	bb 1b       	sub	r27, r27
    4020:	51 e1       	ldi	r21, 0x11	; 17
    4022:	07 c0       	rjmp	.+14     	; 0x4032 <__udivmodhi4_ep>

00004024 <__udivmodhi4_loop>:
    4024:	aa 1f       	adc	r26, r26
    4026:	bb 1f       	adc	r27, r27
    4028:	a6 17       	cp	r26, r22
    402a:	b7 07       	cpc	r27, r23
    402c:	10 f0       	brcs	.+4      	; 0x4032 <__udivmodhi4_ep>
    402e:	a6 1b       	sub	r26, r22
    4030:	b7 0b       	sbc	r27, r23

00004032 <__udivmodhi4_ep>:
    4032:	88 1f       	adc	r24, r24
    4034:	99 1f       	adc	r25, r25
    4036:	5a 95       	dec	r21
    4038:	a9 f7       	brne	.-22     	; 0x4024 <__udivmodhi4_loop>
    403a:	80 95       	com	r24
    403c:	90 95       	com	r25
    403e:	bc 01       	movw	r22, r24
    4040:	cd 01       	movw	r24, r26
    4042:	08 95       	ret

00004044 <memcpy>:
    4044:	fb 01       	movw	r30, r22
    4046:	dc 01       	movw	r26, r24
    4048:	02 c0       	rjmp	.+4      	; 0x404e <memcpy+0xa>
    404a:	01 90       	ld	r0, Z+
    404c:	0d 92       	st	X+, r0
    404e:	41 50       	subi	r20, 0x01	; 1
    4050:	50 40       	sbci	r21, 0x00	; 0
    4052:	d8 f7       	brcc	.-10     	; 0x404a <memcpy+0x6>
    4054:	08 95       	ret

00004056 <memset>:
    4056:	dc 01       	movw	r26, r24
    4058:	01 c0       	rjmp	.+2      	; 0x405c <memset+0x6>
    405a:	6d 93       	st	X+, r22
    405c:	41 50       	subi	r20, 0x01	; 1
    405e:	50 40       	sbci	r21, 0x00	; 0
    4060:	e0 f7       	brcc	.-8      	; 0x405a <memset+0x4>
    4062:	08 95       	ret

00004064 <strncpy>:
    4064:	fb 01       	movw	r30, r22
    4066:	dc 01       	movw	r26, r24
    4068:	41 50       	subi	r20, 0x01	; 1
    406a:	50 40       	sbci	r21, 0x00	; 0
    406c:	48 f0       	brcs	.+18     	; 0x4080 <strncpy+0x1c>
    406e:	01 90       	ld	r0, Z+
    4070:	0d 92       	st	X+, r0
    4072:	00 20       	and	r0, r0
    4074:	c9 f7       	brne	.-14     	; 0x4068 <strncpy+0x4>
    4076:	01 c0       	rjmp	.+2      	; 0x407a <strncpy+0x16>
    4078:	1d 92       	st	X+, r1
    407a:	41 50       	subi	r20, 0x01	; 1
    407c:	50 40       	sbci	r21, 0x00	; 0
    407e:	e0 f7       	brcc	.-8      	; 0x4078 <strncpy+0x14>
    4080:	08 95       	ret

00004082 <__itoa_ncheck>:
    4082:	bb 27       	eor	r27, r27
    4084:	4a 30       	cpi	r20, 0x0A	; 10
    4086:	31 f4       	brne	.+12     	; 0x4094 <__itoa_ncheck+0x12>
    4088:	99 23       	and	r25, r25
    408a:	22 f4       	brpl	.+8      	; 0x4094 <__itoa_ncheck+0x12>
    408c:	bd e2       	ldi	r27, 0x2D	; 45
    408e:	90 95       	com	r25
    4090:	81 95       	neg	r24
    4092:	9f 4f       	sbci	r25, 0xFF	; 255
    4094:	0c 94 85 20 	jmp	0x410a	; 0x410a <__utoa_common>

00004098 <ultoa>:
    4098:	25 32       	cpi	r18, 0x25	; 37
    409a:	31 05       	cpc	r19, r1
    409c:	20 f4       	brcc	.+8      	; 0x40a6 <ultoa+0xe>
    409e:	22 30       	cpi	r18, 0x02	; 2
    40a0:	10 f0       	brcs	.+4      	; 0x40a6 <ultoa+0xe>
    40a2:	0c 94 57 20 	jmp	0x40ae	; 0x40ae <__ultoa_ncheck>
    40a6:	fa 01       	movw	r30, r20
    40a8:	10 82       	st	Z, r1
    40aa:	ca 01       	movw	r24, r20
    40ac:	08 95       	ret

000040ae <__ultoa_ncheck>:
    40ae:	bb 27       	eor	r27, r27

000040b0 <__ultoa_common>:
    40b0:	fa 01       	movw	r30, r20
    40b2:	a6 2f       	mov	r26, r22
    40b4:	62 17       	cp	r22, r18
    40b6:	71 05       	cpc	r23, r1
    40b8:	81 05       	cpc	r24, r1
    40ba:	91 05       	cpc	r25, r1
    40bc:	33 0b       	sbc	r19, r19
    40be:	30 fb       	bst	r19, 0
    40c0:	66 f0       	brts	.+24     	; 0x40da <__ultoa_common+0x2a>
    40c2:	aa 27       	eor	r26, r26
    40c4:	66 0f       	add	r22, r22
    40c6:	77 1f       	adc	r23, r23
    40c8:	88 1f       	adc	r24, r24
    40ca:	99 1f       	adc	r25, r25
    40cc:	aa 1f       	adc	r26, r26
    40ce:	a2 17       	cp	r26, r18
    40d0:	10 f0       	brcs	.+4      	; 0x40d6 <__ultoa_common+0x26>
    40d2:	a2 1b       	sub	r26, r18
    40d4:	63 95       	inc	r22
    40d6:	38 50       	subi	r19, 0x08	; 8
    40d8:	a9 f7       	brne	.-22     	; 0x40c4 <__ultoa_common+0x14>
    40da:	a0 5d       	subi	r26, 0xD0	; 208
    40dc:	aa 33       	cpi	r26, 0x3A	; 58
    40de:	08 f0       	brcs	.+2      	; 0x40e2 <__ultoa_common+0x32>
    40e0:	a9 5d       	subi	r26, 0xD9	; 217
    40e2:	a1 93       	st	Z+, r26
    40e4:	36 f7       	brtc	.-52     	; 0x40b2 <__ultoa_common+0x2>
    40e6:	b1 11       	cpse	r27, r1
    40e8:	b1 93       	st	Z+, r27
    40ea:	10 82       	st	Z, r1
    40ec:	ca 01       	movw	r24, r20
    40ee:	0c 94 9e 20 	jmp	0x413c	; 0x413c <strrev>

000040f2 <utoa>:
    40f2:	45 32       	cpi	r20, 0x25	; 37
    40f4:	51 05       	cpc	r21, r1
    40f6:	20 f4       	brcc	.+8      	; 0x4100 <utoa+0xe>
    40f8:	42 30       	cpi	r20, 0x02	; 2
    40fa:	10 f0       	brcs	.+4      	; 0x4100 <utoa+0xe>
    40fc:	0c 94 84 20 	jmp	0x4108	; 0x4108 <__utoa_ncheck>
    4100:	fb 01       	movw	r30, r22
    4102:	10 82       	st	Z, r1
    4104:	cb 01       	movw	r24, r22
    4106:	08 95       	ret

00004108 <__utoa_ncheck>:
    4108:	bb 27       	eor	r27, r27

0000410a <__utoa_common>:
    410a:	fb 01       	movw	r30, r22
    410c:	55 27       	eor	r21, r21
    410e:	aa 27       	eor	r26, r26
    4110:	88 0f       	add	r24, r24
    4112:	99 1f       	adc	r25, r25
    4114:	aa 1f       	adc	r26, r26
    4116:	a4 17       	cp	r26, r20
    4118:	10 f0       	brcs	.+4      	; 0x411e <__utoa_common+0x14>
    411a:	a4 1b       	sub	r26, r20
    411c:	83 95       	inc	r24
    411e:	50 51       	subi	r21, 0x10	; 16
    4120:	b9 f7       	brne	.-18     	; 0x4110 <__utoa_common+0x6>
    4122:	a0 5d       	subi	r26, 0xD0	; 208
    4124:	aa 33       	cpi	r26, 0x3A	; 58
    4126:	08 f0       	brcs	.+2      	; 0x412a <__utoa_common+0x20>
    4128:	a9 5d       	subi	r26, 0xD9	; 217
    412a:	a1 93       	st	Z+, r26
    412c:	00 97       	sbiw	r24, 0x00	; 0
    412e:	79 f7       	brne	.-34     	; 0x410e <__utoa_common+0x4>
    4130:	b1 11       	cpse	r27, r1
    4132:	b1 93       	st	Z+, r27
    4134:	11 92       	st	Z+, r1
    4136:	cb 01       	movw	r24, r22
    4138:	0c 94 9e 20 	jmp	0x413c	; 0x413c <strrev>

0000413c <strrev>:
    413c:	dc 01       	movw	r26, r24
    413e:	fc 01       	movw	r30, r24
    4140:	67 2f       	mov	r22, r23
    4142:	71 91       	ld	r23, Z+
    4144:	77 23       	and	r23, r23
    4146:	e1 f7       	brne	.-8      	; 0x4140 <strrev+0x4>
    4148:	32 97       	sbiw	r30, 0x02	; 2
    414a:	04 c0       	rjmp	.+8      	; 0x4154 <strrev+0x18>
    414c:	7c 91       	ld	r23, X
    414e:	6d 93       	st	X+, r22
    4150:	70 83       	st	Z, r23
    4152:	62 91       	ld	r22, -Z
    4154:	ae 17       	cp	r26, r30
    4156:	bf 07       	cpc	r27, r31
    4158:	c8 f3       	brcs	.-14     	; 0x414c <strrev+0x10>
    415a:	08 95       	ret

0000415c <_exit>:
    415c:	f8 94       	cli

0000415e <__stop_program>:
    415e:	ff cf       	rjmp	.-2      	; 0x415e <__stop_program>
