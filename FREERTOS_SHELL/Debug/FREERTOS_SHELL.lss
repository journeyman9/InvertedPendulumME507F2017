
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000041fa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e2  00802000  000041fa  0000428e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020e2  008020e2  00004370  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004370  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000043a0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000708  00000000  00000000  000043e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012825  00000000  00000000  00004ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006815  00000000  00000000  0001730d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005587  00000000  00000000  0001db22  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000131c  00000000  00000000  000230ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000061e7  00000000  00000000  000243c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006024  00000000  00000000  0002a5af  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005a0  00000000  00000000  000305d3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a9 02 	jmp	0x552	; 0x552 <__ctors_end>
       4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      10:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      14:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      18:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      1c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      20:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      24:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      28:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      2c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      30:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      34:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      38:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      3c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      40:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      44:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      48:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      4c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      50:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      54:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      58:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      5c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      60:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      64:	0c 94 ac 1c 	jmp	0x3958	; 0x3958 <__vector_25>
      68:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      6c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      70:	0c 94 0a 1d 	jmp	0x3a14	; 0x3a14 <__vector_28>
      74:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      78:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      7c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      80:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      84:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      88:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      8c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      90:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      94:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      98:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      9c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c4:	0c 94 72 0c 	jmp	0x18e4	; 0x18e4 <__vector_49>
      c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e8:	0c 94 24 1e 	jmp	0x3c48	; 0x3c48 <__vector_58>
      ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      fc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     100:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     104:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     108:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     10c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     110:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     114:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     118:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     11c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     120:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     124:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     128:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     12c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     130:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     134:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     138:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     13c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     140:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     144:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     148:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     14c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     150:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     154:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     158:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     15c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     160:	0c 94 68 1d 	jmp	0x3ad0	; 0x3ad0 <__vector_88>
     164:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     168:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     16c:	0c 94 c6 1d 	jmp	0x3b8c	; 0x3b8c <__vector_91>
     170:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     174:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     178:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     17c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     180:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     184:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     188:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     18c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     190:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     194:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     198:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     19c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1fc:	44 1a       	sub	r4, r20
     1fe:	47 1a       	sub	r4, r23
     200:	4a 1a       	sub	r4, r26
     202:	4d 1a       	sub	r4, r29
     204:	50 1a       	sub	r5, r16
     206:	53 1a       	sub	r5, r19
     208:	55 1a       	sub	r5, r21
     20a:	66 1a       	sub	r6, r22
     20c:	6e 1a       	sub	r6, r30
     20e:	78 1a       	sub	r7, r24
     210:	76 1a       	sub	r7, r22

00000212 <__trampolines_start>:
     212:	0c 94 ea 1b 	jmp	0x37d4	; 0x37d4 <_ZN5rs2327getcharEv>
     216:	0c 94 53 1a 	jmp	0x34a6	; 0x34a6 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     21a:	0c 94 25 16 	jmp	0x2c4a	; 0x2c4a <_ZN8frt_task12print_statusER8emstream>
     21e:	0c 94 4a 1a 	jmp	0x3494	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     222:	0c 94 ee 19 	jmp	0x33dc	; 0x33dc <_ZN8emstream12transmit_nowEv>
     226:	0c 94 50 1a 	jmp	0x34a0	; 0x34a0 <_ZN8emstreamlsE15ser_manipulator+0x36>
     22a:	0c 94 e7 19 	jmp	0x33ce	; 0x33ce <_ZN8emstream13ready_to_sendEv>
     22e:	0c 94 e9 19 	jmp	0x33d2	; 0x33d2 <_ZN8emstream7getcharEv>
     232:	0c 94 ec 19 	jmp	0x33d8	; 0x33d8 <_ZN8emstream14check_for_charEv>
     236:	0c 94 44 1a 	jmp	0x3488	; 0x3488 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     23a:	0c 94 4e 08 	jmp	0x109c	; 0x109c <_ZN9task_user3runEv>
     23e:	0c 94 78 1a 	jmp	0x34f0	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
     242:	0c 94 8d 17 	jmp	0x2f1a	; 0x2f1a <_ZN14frt_text_queue14check_for_charEv>
     246:	0c 94 55 1a 	jmp	0x34aa	; 0x34aa <_ZN8emstreamlsE15ser_manipulator+0x40>
     24a:	0c 94 ef 19 	jmp	0x33de	; 0x33de <_ZN8emstream12clear_screenEv>
     24e:	0c 94 d4 03 	jmp	0x7a8	; 0x7a8 <_ZN13LimitSwitches3runEv>
     252:	0c 94 67 06 	jmp	0xcce	; 0xcce <_ZN9PWMdriver3runEv>
     256:	0c 94 4d 1a 	jmp	0x349a	; 0x349a <_ZN8emstreamlsE15ser_manipulator+0x30>
     25a:	0c 94 64 03 	jmp	0x6c8	; 0x6c8 <_ZN15EncoderPendulum3runEv>
     25e:	0c 94 6e 1a 	jmp	0x34dc	; 0x34dc <_ZN8emstreamlsE15ser_manipulator+0x72>
     262:	0c 94 66 1a 	jmp	0x34cc	; 0x34cc <_ZN8emstreamlsE15ser_manipulator+0x62>
     266:	0c 94 50 19 	jmp	0x32a0	; 0x32a0 <__cxa_pure_virtual>
     26a:	0c 94 a6 02 	jmp	0x54c	; 0x54c <_call_static_run_method>
     26e:	0c 94 6f 17 	jmp	0x2ede	; 0x2ede <_ZN14frt_text_queue7getcharEv>
     272:	0c 94 23 1c 	jmp	0x3846	; 0x3846 <_ZN5rs23212clear_screenEv>
     276:	0c 94 47 1a 	jmp	0x348e	; 0x348e <_ZN8emstreamlsE15ser_manipulator+0x24>
     27a:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_ZN12EncoderMotor3runEv>
     27e:	0c 94 f6 0e 	jmp	0x1dec	; 0x1dec <prvIdleTask>
     282:	0c 94 31 1f 	jmp	0x3e62	; 0x3e62 <_GLOBAL__sub_I_counter>
     286:	0c 94 39 04 	jmp	0x872	; 0x872 <_ZN5Motor3runEv>
     28a:	0c 94 10 1c 	jmp	0x3820	; 0x3820 <_ZN5rs23214check_for_charEv>
     28e:	0c 94 98 17 	jmp	0x2f30	; 0x2f30 <_ZN14frt_text_queue7putcharEc>
     292:	0c 94 76 1a 	jmp	0x34ec	; 0x34ec <_ZN8emstreamlsE15ser_manipulator+0x82>
     296:	0c 94 c6 1b 	jmp	0x378c	; 0x378c <_ZN5rs2327putcharEc>

0000029a <__trampolines_end>:
     29a:	2c 20       	and	r2, r12
     29c:	54 43       	sbci	r21, 0x34	; 52
     29e:	43 30       	cpi	r20, 0x03	; 3
     2a0:	43 43       	sbci	r20, 0x33	; 51
     2a2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a5 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a5:	2f 00                                               /.

000002a7 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b5:	54 69 6d 65 3a 20 00                                Time: .

000002bc <_ZZN9task_user11show_statusEvE3__c_0>:
     2bc:	44 65 63 20 20 35 20 32 30 31 37 00                 Dec  5 2017.

000002c8 <_ZZN9task_user11show_statusEvE3__c>:
     2c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     306:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000311 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     311:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     321:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34f:	6d 61 74 69 6f 6e 00                                mation.

00000356 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     356:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     366:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000377 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     377:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     387:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003ab <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3ab:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bb:	68 65 20 41 56 52 00                                he AVR.

000003c2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c2:	20 68 65 6c 70 00                                    help.

000003c8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e7 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e7:	1b 5b 33 30 6d 00                                   .[30m.

000003ed <_ZZN9task_user18print_help_messageEvE3__c>:
     3ed:	1b 5b 34 36 6d 00                                   .[46m.

000003f3 <_ZZN9task_user3runEvE3__c_3>:
     3f3:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     403:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000410 <_ZZN9task_user3runEvE3__c_2>:
     410:	3a 57 54 46 3f 00                                   :WTF?.

00000416 <_ZZN9task_user3runEvE3__c_1>:
     416:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     426:	65 00                                               e.

00000428 <_ZZN9task_user3runEvE3__c_0>:
     428:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000436 <_ZZN9task_user3runEvE3__c>:
     436:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     446:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000454 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     454:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045e <_ZZN8frt_task15emergency_resetEvE3__c>:
     45e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000046d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     46d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     47d:	61 73 6b 20 00                                      ask .

00000482 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     482:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000490 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     490:	20 63 72 65 61 74 65 64 00                           created.

00000499 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     499:	54 61 73 6b 20 00                                   Task .

0000049f <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49f:	1b 5b 32 32 6d 00                                   .[22m.

000004a5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a5:	54 61 73 6b 3a 20 00                                Task: .

000004ac <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4ac:	1b 5b 31 6d 00                                      .[1m.

000004b1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b1:	1b 5b 32 32 6d 00                                   .[22m.

000004b7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c2:	1b 5b 31 6d 00                                      .[1m.

000004c7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c7:	09 09 00                                            ...

000004ca <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ca:	2f 00                                               /.

000004cc <_ZZ15print_task_listP8emstreamE3__c_7>:
     4cc:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d7:	09 2d 2d 2d 2d 00                                   .----.

000004dd <_ZZ15print_task_listP8emstreamE3__c_5>:
     4dd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e9 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e9:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fa <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fa:	09 52 75 6e 73 00                                   .Runs.

00000500 <_ZZ15print_task_listP8emstreamE3__c_2>:
     500:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000050c <_ZZ15print_task_listP8emstreamE3__c_1>:
     50c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000051d <_ZZ15print_task_listP8emstreamE3__c_0>:
     51d:	09 53 74 61 63 6b 00                                .Stack.

00000524 <_ZZ15print_task_listP8emstreamE3__c>:
     524:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52f:	09 00                                               ..

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     533:	2f 00                                               /.

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     537:	09 00                                               ..

00000539 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53f:	1b 5b 31 6d 00                                      .[1m.

00000544 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     544:	1b 5b 31 6d 00                                      .[1m.

00000549 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     549:	20 20 00                                              .

0000054c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     54c:	0e 94 bd 14 	call	0x297a	; 0x297a <_ZN8frt_task22_call_users_run_methodEPS_>

00000550 <__ctors_start>:
     550:	31 1f       	adc	r19, r17

00000552 <__ctors_end>:
     552:	11 24       	eor	r1, r1
     554:	1f be       	out	0x3f, r1	; 63
     556:	cf ef       	ldi	r28, 0xFF	; 255
     558:	cd bf       	out	0x3d, r28	; 61
     55a:	df e3       	ldi	r29, 0x3F	; 63
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	00 e0       	ldi	r16, 0x00	; 0
     560:	0c bf       	out	0x3c, r16	; 60
     562:	18 be       	out	0x38, r1	; 56
     564:	19 be       	out	0x39, r1	; 57
     566:	1a be       	out	0x3a, r1	; 58
     568:	1b be       	out	0x3b, r1	; 59

0000056a <__do_copy_data>:
     56a:	10 e2       	ldi	r17, 0x20	; 32
     56c:	a0 e0       	ldi	r26, 0x00	; 0
     56e:	b0 e2       	ldi	r27, 0x20	; 32
     570:	ea ef       	ldi	r30, 0xFA	; 250
     572:	f1 e4       	ldi	r31, 0x41	; 65
     574:	00 e0       	ldi	r16, 0x00	; 0
     576:	0b bf       	out	0x3b, r16	; 59
     578:	02 c0       	rjmp	.+4      	; 0x57e <__do_copy_data+0x14>
     57a:	07 90       	elpm	r0, Z+
     57c:	0d 92       	st	X+, r0
     57e:	a2 3e       	cpi	r26, 0xE2	; 226
     580:	b1 07       	cpc	r27, r17
     582:	d9 f7       	brne	.-10     	; 0x57a <__do_copy_data+0x10>
     584:	1b be       	out	0x3b, r1	; 59

00000586 <__do_clear_bss>:
     586:	21 e3       	ldi	r18, 0x31	; 49
     588:	a2 ee       	ldi	r26, 0xE2	; 226
     58a:	b0 e2       	ldi	r27, 0x20	; 32
     58c:	01 c0       	rjmp	.+2      	; 0x590 <.do_clear_bss_start>

0000058e <.do_clear_bss_loop>:
     58e:	1d 92       	st	X+, r1

00000590 <.do_clear_bss_start>:
     590:	a8 38       	cpi	r26, 0x88	; 136
     592:	b2 07       	cpc	r27, r18
     594:	e1 f7       	brne	.-8      	; 0x58e <.do_clear_bss_loop>

00000596 <__do_global_ctors>:
     596:	12 e0       	ldi	r17, 0x02	; 2
     598:	c9 ea       	ldi	r28, 0xA9	; 169
     59a:	d2 e0       	ldi	r29, 0x02	; 2
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	06 c0       	rjmp	.+12     	; 0x5ac <__do_global_ctors+0x16>
     5a0:	21 97       	sbiw	r28, 0x01	; 1
     5a2:	01 09       	sbc	r16, r1
     5a4:	80 2f       	mov	r24, r16
     5a6:	fe 01       	movw	r30, r28
     5a8:	0e 94 12 20 	call	0x4024	; 0x4024 <__tablejump2__>
     5ac:	c8 3a       	cpi	r28, 0xA8	; 168
     5ae:	d1 07       	cpc	r29, r17
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	08 07       	cpc	r16, r24
     5b4:	a9 f7       	brne	.-22     	; 0x5a0 <__do_global_ctors+0xa>
     5b6:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <main>
     5ba:	0c 94 fb 20 	jmp	0x41f6	; 0x41f6 <_exit>

000005be <__bad_interrupt>:
     5be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c2 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	00 d0       	rcall	.+0      	; 0x5c8 <_ZN12EncoderMotor3runEv+0x6>
     5c8:	1f 92       	push	r1
     5ca:	cd b7       	in	r28, 0x3d	; 61
     5cc:	de b7       	in	r29, 0x3e	; 62
     5ce:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d0:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     5d4:	69 83       	std	Y+1, r22	; 0x01
     5d6:	7a 83       	std	Y+2, r23	; 0x02
     5d8:	8b 83       	std	Y+3, r24	; 0x03
     5da:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5dc:	e0 e8       	ldi	r30, 0x80	; 128
     5de:	f6 e0       	ldi	r31, 0x06	; 6
     5e0:	8c e0       	ldi	r24, 0x0C	; 12
     5e2:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e4:	82 89       	ldd	r24, Z+18	; 0x12
     5e6:	83 60       	ori	r24, 0x03	; 3
     5e8:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ea:	83 89       	ldd	r24, Z+19	; 0x13
     5ec:	83 60       	ori	r24, 0x03	; 3
     5ee:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5f0:	e0 e8       	ldi	r30, 0x80	; 128
     5f2:	f1 e0       	ldi	r31, 0x01	; 1
     5f4:	82 e7       	ldi	r24, 0x72	; 114
     5f6:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f8:	89 e0       	ldi	r24, 0x09	; 9
     5fa:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5fc:	e0 e0       	ldi	r30, 0x00	; 0
     5fe:	f9 e0       	ldi	r31, 0x09	; 9
     600:	88 e6       	ldi	r24, 0x68	; 104
     602:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     604:	8f ef       	ldi	r24, 0xFF	; 255
     606:	9f ef       	ldi	r25, 0xFF	; 255
     608:	86 a3       	std	Z+38, r24	; 0x26
     60a:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     60c:	81 e0       	ldi	r24, 0x01	; 1
     60e:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     610:	0f 2e       	mov	r0, r31
     612:	a1 2c       	mov	r10, r1
     614:	f9 e0       	ldi	r31, 0x09	; 9
     616:	bf 2e       	mov	r11, r31
     618:	f0 2d       	mov	r31, r0
     61a:	f5 01       	movw	r30, r10
     61c:	00 a1       	ldd	r16, Z+32	; 0x20
     61e:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     620:	0f b6       	in	r0, 0x3f	; 63
     622:	f8 94       	cli
     624:	0f 92       	push	r0
			the_data = new_data;
     626:	c8 01       	movw	r24, r16
     628:	01 2e       	mov	r0, r17
     62a:	00 0c       	add	r0, r0
     62c:	aa 0b       	sbc	r26, r26
     62e:	bb 0b       	sbc	r27, r27
     630:	ac 01       	movw	r20, r24
     632:	bd 01       	movw	r22, r26
     634:	44 0f       	add	r20, r20
     636:	55 1f       	adc	r21, r21
     638:	66 1f       	adc	r22, r22
     63a:	77 1f       	adc	r23, r23
     63c:	3a 01       	movw	r6, r20
     63e:	4b 01       	movw	r8, r22
     640:	68 0e       	add	r6, r24
     642:	79 1e       	adc	r7, r25
     644:	8a 1e       	adc	r8, r26
     646:	9b 1e       	adc	r9, r27
     648:	c4 01       	movw	r24, r8
     64a:	b3 01       	movw	r22, r6
     64c:	24 e6       	ldi	r18, 0x64	; 100
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	40 e0       	ldi	r20, 0x00	; 0
     652:	50 e0       	ldi	r21, 0x00	; 0
     654:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <__divmodsi4>
     658:	20 93 74 31 	sts	0x3174, r18	; 0x803174 <linear_position>
     65c:	30 93 75 31 	sts	0x3175, r19	; 0x803175 <linear_position+0x1>
			portEXIT_CRITICAL ();
     660:	0f 90       	pop	r0
     662:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     664:	0f b6       	in	r0, 0x3f	; 63
     666:	f8 94       	cli
     668:	0f 92       	push	r0
			the_data = new_data;
     66a:	c8 01       	movw	r24, r16
     66c:	8c 19       	sub	r24, r12
     66e:	9d 09       	sbc	r25, r13
     670:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <thdMotor>
     674:	90 93 73 31 	sts	0x3173, r25	; 0x803173 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     678:	0f 90       	pop	r0
     67a:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     67c:	f7 01       	movw	r30, r14
     67e:	86 85       	ldd	r24, Z+14	; 0x0e
     680:	97 85       	ldd	r25, Z+15	; 0x0f
     682:	a0 89       	ldd	r26, Z+16	; 0x10
     684:	b1 89       	ldd	r27, Z+17	; 0x11
     686:	01 96       	adiw	r24, 0x01	; 1
     688:	a1 1d       	adc	r26, r1
     68a:	b1 1d       	adc	r27, r1
     68c:	86 87       	std	Z+14, r24	; 0x0e
     68e:	97 87       	std	Z+15, r25	; 0x0f
     690:	a0 8b       	std	Z+16, r26	; 0x10
     692:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     694:	41 e0       	ldi	r20, 0x01	; 1
     696:	50 e0       	ldi	r21, 0x00	; 0
     698:	60 e0       	ldi	r22, 0x00	; 0
     69a:	70 e0       	ldi	r23, 0x00	; 0
     69c:	ce 01       	movw	r24, r28
     69e:	01 96       	adiw	r24, 0x01	; 1
     6a0:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6a4:	68 01       	movw	r12, r16
     6a6:	b9 cf       	rjmp	.-142    	; 0x61a <_ZN12EncoderMotor3runEv+0x58>

000006a8 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     6a8:	0f 93       	push	r16
     6aa:	1f 93       	push	r17
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
     6b0:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6b2:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     6b6:	8a e0       	ldi	r24, 0x0A	; 10
     6b8:	90 e2       	ldi	r25, 0x20	; 32
     6ba:	88 83       	st	Y, r24
     6bc:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	1f 91       	pop	r17
     6c4:	0f 91       	pop	r16
     6c6:	08 95       	ret

000006c8 <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	00 d0       	rcall	.+0      	; 0x6ce <_ZN15EncoderPendulum3runEv+0x6>
     6ce:	1f 92       	push	r1
     6d0:	cd b7       	in	r28, 0x3d	; 61
     6d2:	de b7       	in	r29, 0x3e	; 62
     6d4:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6d6:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     6da:	69 83       	std	Y+1, r22	; 0x01
     6dc:	7a 83       	std	Y+2, r23	; 0x02
     6de:	8b 83       	std	Y+3, r24	; 0x03
     6e0:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     6e2:	e0 e8       	ldi	r30, 0x80	; 128
     6e4:	f6 e0       	ldi	r31, 0x06	; 6
     6e6:	83 e0       	ldi	r24, 0x03	; 3
     6e8:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     6ea:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     6ec:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     6ee:	e0 e8       	ldi	r30, 0x80	; 128
     6f0:	f1 e0       	ldi	r31, 0x01	; 1
     6f2:	80 e7       	ldi	r24, 0x70	; 112
     6f4:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     6f6:	89 e0       	ldi	r24, 0x09	; 9
     6f8:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     6fa:	e0 e4       	ldi	r30, 0x40	; 64
     6fc:	f8 e0       	ldi	r31, 0x08	; 8
     6fe:	8a e6       	ldi	r24, 0x6A	; 106
     700:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     702:	80 ea       	ldi	r24, 0xA0	; 160
     704:	95 e0       	ldi	r25, 0x05	; 5
     706:	86 a3       	std	Z+38, r24	; 0x26
     708:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     70e:	68 94       	set
     710:	ee 24       	eor	r14, r14
     712:	e6 f8       	bld	r14, 6
     714:	ff 24       	eor	r15, r15
     716:	f3 f8       	bld	r15, 3
     718:	f7 01       	movw	r30, r14
     71a:	a0 a1       	ldd	r26, Z+32	; 0x20
     71c:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     71e:	0f b6       	in	r0, 0x3f	; 63
     720:	f8 94       	cli
     722:	0f 92       	push	r0
			the_data = new_data;
     724:	24 e6       	ldi	r18, 0x64	; 100
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	0e 94 32 20 	call	0x4064	; 0x4064 <__usmulhisi3>
     72c:	4b 01       	movw	r8, r22
     72e:	5c 01       	movw	r10, r24
     730:	99 23       	and	r25, r25
     732:	2c f4       	brge	.+10     	; 0x73e <_ZN15EncoderPendulum3runEv+0x76>
     734:	f3 e0       	ldi	r31, 0x03	; 3
     736:	8f 0e       	add	r8, r31
     738:	91 1c       	adc	r9, r1
     73a:	a1 1c       	adc	r10, r1
     73c:	b1 1c       	adc	r11, r1
     73e:	d5 01       	movw	r26, r10
     740:	c4 01       	movw	r24, r8
     742:	b5 95       	asr	r27
     744:	a7 95       	ror	r26
     746:	97 95       	ror	r25
     748:	87 95       	ror	r24
     74a:	b5 95       	asr	r27
     74c:	a7 95       	ror	r26
     74e:	97 95       	ror	r25
     750:	87 95       	ror	r24
     752:	80 93 70 31 	sts	0x3170, r24	; 0x803170 <thPendulum>
     756:	90 93 71 31 	sts	0x3171, r25	; 0x803171 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     75a:	0f 90       	pop	r0
     75c:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     75e:	f8 01       	movw	r30, r16
     760:	86 85       	ldd	r24, Z+14	; 0x0e
     762:	97 85       	ldd	r25, Z+15	; 0x0f
     764:	a0 89       	ldd	r26, Z+16	; 0x10
     766:	b1 89       	ldd	r27, Z+17	; 0x11
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	a1 1d       	adc	r26, r1
     76c:	b1 1d       	adc	r27, r1
     76e:	86 87       	std	Z+14, r24	; 0x0e
     770:	97 87       	std	Z+15, r25	; 0x0f
     772:	a0 8b       	std	Z+16, r26	; 0x10
     774:	b1 8b       	std	Z+17, r27	; 0x11
     776:	45 e0       	ldi	r20, 0x05	; 5
     778:	50 e0       	ldi	r21, 0x00	; 0
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	70 e0       	ldi	r23, 0x00	; 0
     77e:	ce 01       	movw	r24, r28
     780:	01 96       	adiw	r24, 0x01	; 1
     782:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
     786:	c8 cf       	rjmp	.-112    	; 0x718 <_ZN15EncoderPendulum3runEv+0x50>

00000788 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     788:	0f 93       	push	r16
     78a:	1f 93       	push	r17
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     792:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     796:	82 e1       	ldi	r24, 0x12	; 18
     798:	90 e2       	ldi	r25, 0x20	; 32
     79a:	88 83       	st	Y, r24
     79c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	1f 91       	pop	r17
     7a4:	0f 91       	pop	r16
     7a6:	08 95       	ret

000007a8 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	00 d0       	rcall	.+0      	; 0x7ae <_ZN13LimitSwitches3runEv+0x6>
     7ae:	1f 92       	push	r1
     7b0:	cd b7       	in	r28, 0x3d	; 61
     7b2:	de b7       	in	r29, 0x3e	; 62
     7b4:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7b6:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     7ba:	69 83       	std	Y+1, r22	; 0x01
     7bc:	7a 83       	std	Y+2, r23	; 0x02
     7be:	8b 83       	std	Y+3, r24	; 0x03
     7c0:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     7c2:	e0 e6       	ldi	r30, 0x60	; 96
     7c4:	f6 e0       	ldi	r31, 0x06	; 6
     7c6:	81 e0       	ldi	r24, 0x01	; 1
     7c8:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     7ca:	84 e0       	ldi	r24, 0x04	; 4
     7cc:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     7ce:	88 e1       	ldi	r24, 0x18	; 24
     7d0:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     7d2:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     7d4:	08 e6       	ldi	r16, 0x68	; 104
     7d6:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     7d8:	dd 24       	eor	r13, r13
     7da:	d3 94       	inc	r13
     7dc:	f8 01       	movw	r30, r16
     7de:	80 81       	ld	r24, Z
     7e0:	80 fd       	sbrc	r24, 0
     7e2:	08 c0       	rjmp	.+16     	; 0x7f4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	f8 94       	cli
     7e8:	0f 92       	push	r0
			the_data = new_data;
     7ea:	d0 92 6f 31 	sts	0x316F, r13	; 0x80316f <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7ee:	0f 90       	pop	r0
     7f0:	0f be       	out	0x3f, r0	; 63
     7f2:	07 c0       	rjmp	.+14     	; 0x802 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7f4:	0f b6       	in	r0, 0x3f	; 63
     7f6:	f8 94       	cli
     7f8:	0f 92       	push	r0
			the_data = new_data;
     7fa:	10 92 6f 31 	sts	0x316F, r1	; 0x80316f <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
			*/

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     802:	f8 01       	movw	r30, r16
     804:	80 81       	ld	r24, Z
     806:	82 fd       	sbrc	r24, 2
     808:	08 c0       	rjmp	.+16     	; 0x81a <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	0f 92       	push	r0
			the_data = new_data;
     810:	d0 92 6e 31 	sts	0x316E, r13	; 0x80316e <rightLimitSwitch>
			portEXIT_CRITICAL ();
     814:	0f 90       	pop	r0
     816:	0f be       	out	0x3f, r0	; 63
     818:	07 c0       	rjmp	.+14     	; 0x828 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     81a:	0f b6       	in	r0, 0x3f	; 63
     81c:	f8 94       	cli
     81e:	0f 92       	push	r0
			the_data = new_data;
     820:	10 92 6e 31 	sts	0x316E, r1	; 0x80316e <rightLimitSwitch>
			portEXIT_CRITICAL ();
     824:	0f 90       	pop	r0
     826:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     828:	f7 01       	movw	r30, r14
     82a:	86 85       	ldd	r24, Z+14	; 0x0e
     82c:	97 85       	ldd	r25, Z+15	; 0x0f
     82e:	a0 89       	ldd	r26, Z+16	; 0x10
     830:	b1 89       	ldd	r27, Z+17	; 0x11
     832:	01 96       	adiw	r24, 0x01	; 1
     834:	a1 1d       	adc	r26, r1
     836:	b1 1d       	adc	r27, r1
     838:	86 87       	std	Z+14, r24	; 0x0e
     83a:	97 87       	std	Z+15, r25	; 0x0f
     83c:	a0 8b       	std	Z+16, r26	; 0x10
     83e:	b1 8b       	std	Z+17, r27	; 0x11
     840:	45 e0       	ldi	r20, 0x05	; 5
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	70 e0       	ldi	r23, 0x00	; 0
     848:	ce 01       	movw	r24, r28
     84a:	01 96       	adiw	r24, 0x01	; 1
     84c:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
     850:	c5 cf       	rjmp	.-118    	; 0x7dc <_ZN13LimitSwitches3runEv+0x34>

00000852 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     852:	0f 93       	push	r16
     854:	1f 93       	push	r17
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     85c:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     860:	8a e1       	ldi	r24, 0x1A	; 26
     862:	90 e2       	ldi	r25, 0x20	; 32
     864:	88 83       	st	Y, r24
     866:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	1f 91       	pop	r17
     86e:	0f 91       	pop	r16
     870:	08 95       	ret

00000872 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	6c 97       	sbiw	r28, 0x1c	; 28
     87c:	cd bf       	out	0x3d, r28	; 61
     87e:	de bf       	out	0x3e, r29	; 62
     880:	1c 01       	movw	r2, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     882:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     886:	69 83       	std	Y+1, r22	; 0x01
     888:	7a 83       	std	Y+2, r23	; 0x02
     88a:	8b 83       	std	Y+3, r24	; 0x03
     88c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 5; // [ms]
     88e:	f1 01       	movw	r30, r2
     890:	fe 96       	adiw	r30, 0x3e	; 62
     892:	85 e0       	ldi	r24, 0x05	; 5
     894:	90 e0       	ldi	r25, 0x00	; 0
     896:	a0 e0       	ldi	r26, 0x00	; 0
     898:	b0 e0       	ldi	r27, 0x00	; 0
     89a:	80 83       	st	Z, r24
     89c:	91 83       	std	Z+1, r25	; 0x01
     89e:	a2 83       	std	Z+2, r26	; 0x02
     8a0:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     8a2:	81 e0       	ldi	r24, 0x01	; 1
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	d1 01       	movw	r26, r2
     8a8:	dc 96       	adiw	r26, 0x3c	; 60
     8aa:	8d 93       	st	X+, r24
     8ac:	9c 93       	st	X, r25
     8ae:	dd 97       	sbiw	r26, 0x3d	; 61
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
		omegam_set = 200; // [ticks/ms]
     8b0:	0f 2e       	mov	r0, r31
     8b2:	f8 ec       	ldi	r31, 0xC8	; 200
     8b4:	cf 2e       	mov	r12, r31
     8b6:	d1 2c       	mov	r13, r1
     8b8:	f0 2d       	mov	r31, r0
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     8ba:	71 01       	movw	r14, r2
     8bc:	b0 e5       	ldi	r27, 0x50	; 80
     8be:	eb 0e       	add	r14, r27
     8c0:	f1 1c       	adc	r15, r1
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 22;
     8c2:	3a 96       	adiw	r30, 0x0a	; 10
     8c4:	ed 83       	std	Y+5, r30	; 0x05
     8c6:	fe 83       	std	Y+6, r31	; 0x06
     8c8:	f6 e1       	ldi	r31, 0x16	; 22
     8ca:	ff 8b       	std	Y+23, r31	; 0x17
     8cc:	18 8e       	std	Y+24, r1	; 0x18
		_Ki = 0.5*256;
     8ce:	91 01       	movw	r18, r2
     8d0:	24 5b       	subi	r18, 0xB4	; 180
     8d2:	3f 4f       	sbci	r19, 0xFF	; 255
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	38 87       	std	Y+8, r19	; 0x08
		_Kd = 0;
     8d8:	c1 01       	movw	r24, r2
     8da:	86 5b       	subi	r24, 0xB6	; 182
     8dc:	9f 4f       	sbci	r25, 0xFF	; 255
     8de:	8b 8b       	std	Y+19, r24	; 0x13
     8e0:	9c 8b       	std	Y+20, r25	; 0x14
		_max = 1600;
     8e2:	d1 01       	movw	r26, r2
     8e4:	ac 5b       	subi	r26, 0xBC	; 188
     8e6:	bf 4f       	sbci	r27, 0xFF	; 255
     8e8:	a9 87       	std	Y+9, r26	; 0x09
     8ea:	ba 87       	std	Y+10, r27	; 0x0a
		_min = -1600;
     8ec:	f1 01       	movw	r30, r2
     8ee:	ea 5b       	subi	r30, 0xBA	; 186
     8f0:	ff 4f       	sbci	r31, 0xFF	; 255
     8f2:	ed 87       	std	Y+13, r30	; 0x0d
     8f4:	fe 87       	std	Y+14, r31	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     8f6:	20 5f       	subi	r18, 0xF0	; 240
     8f8:	3f 4f       	sbci	r19, 0xFF	; 255
     8fa:	2f 87       	std	Y+15, r18	; 0x0f
     8fc:	38 8b       	std	Y+16, r19	; 0x10

		// Integral term
		_integral += error * dt;
     8fe:	0c 97       	sbiw	r24, 0x0c	; 12
     900:	8b 87       	std	Y+11, r24	; 0x0b
     902:	9c 87       	std	Y+12, r25	; 0x0c
		_integral = arbitraryNumber;
		else if( _integral < arbitraryNumber )
		_integral = arbitraryNumber;
		*/
		
		Iout = (_Ki * _integral)/256;
     904:	54 96       	adiw	r26, 0x14	; 20
     906:	a9 8b       	std	Y+17, r26	; 0x11
     908:	ba 8b       	std	Y+18, r27	; 0x12
		output = _max;
		else if( output < _min )
		output = _min;

		// Save error to previous error
		_pre_error = error;
     90a:	38 96       	adiw	r30, 0x08	; 8
     90c:	ed 8b       	std	Y+21, r30	; 0x15
     90e:	fe 8b       	std	Y+22, r31	; 0x16
	dt = 5; // [ms]
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     910:	f1 01       	movw	r30, r2
     912:	86 85       	ldd	r24, Z+14	; 0x0e
     914:	97 85       	ldd	r25, Z+15	; 0x0f
     916:	a0 89       	ldd	r26, Z+16	; 0x10
     918:	b1 89       	ldd	r27, Z+17	; 0x11
     91a:	01 96       	adiw	r24, 0x01	; 1
     91c:	a1 1d       	adc	r26, r1
     91e:	b1 1d       	adc	r27, r1
     920:	86 87       	std	Z+14, r24	; 0x0e
     922:	97 87       	std	Z+15, r25	; 0x0f
     924:	a0 8b       	std	Z+16, r26	; 0x10
     926:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
		omegam_set = 200; // [ticks/ms]
     928:	c2 8e       	std	Z+26, r12	; 0x1a
     92a:	d3 8e       	std	Z+27, r13	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     932:	0f 90       	pop	r0
     934:	0f be       	out	0x3f, r0	; 63
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     936:	80 91 6f 31 	lds	r24, 0x316F	; 0x80316f <leftLimitSwitch>
     93a:	81 11       	cpse	r24, r1
     93c:	09 c0       	rjmp	.+18     	; 0x950 <_ZN5Motor3runEv+0xde>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     93e:	0f b6       	in	r0, 0x3f	; 63
     940:	f8 94       	cli
     942:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     944:	0f 90       	pop	r0
     946:	0f be       	out	0x3f, r0	; 63
     948:	80 91 6e 31 	lds	r24, 0x316E	; 0x80316e <rightLimitSwitch>
     94c:	88 23       	and	r24, r24
     94e:	31 f0       	breq	.+12     	; 0x95c <_ZN5Motor3runEv+0xea>
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     950:	d7 01       	movw	r26, r14
     952:	1d 92       	st	X+, r1
     954:	1d 92       	st	X+, r1
     956:	1d 92       	st	X+, r1
     958:	1c 92       	st	X, r1
     95a:	13 97       	sbiw	r26, 0x03	; 3
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     95c:	0f b6       	in	r0, 0x3f	; 63
     95e:	f8 94       	cli
     960:	0f 92       	push	r0
			temporary_copy = the_data;
     962:	80 91 72 31 	lds	r24, 0x3172	; 0x803172 <thdMotor>
     966:	90 91 73 31 	lds	r25, 0x3173	; 0x803173 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     96a:	0f 90       	pop	r0
     96c:	0f be       	out	0x3f, r0	; 63
		{
		omegam_set = 200; // [ticks/ms]
		}

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     96e:	f1 01       	movw	r30, r2
     970:	86 8f       	std	Z+30, r24	; 0x1e
     972:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 22;
     974:	ef 89       	ldd	r30, Y+23	; 0x17
     976:	ad 81       	ldd	r26, Y+5	; 0x05
     978:	be 81       	ldd	r27, Y+6	; 0x06
     97a:	ec 93       	st	X, r30
     97c:	f8 8d       	ldd	r31, Y+24	; 0x18
     97e:	11 96       	adiw	r26, 0x01	; 1
     980:	fc 93       	st	X, r31
		_Ki = 0.5*256;
     982:	e0 e8       	ldi	r30, 0x80	; 128
     984:	f0 e0       	ldi	r31, 0x00	; 0
     986:	af 81       	ldd	r26, Y+7	; 0x07
     988:	b8 85       	ldd	r27, Y+8	; 0x08
     98a:	ed 93       	st	X+, r30
     98c:	fc 93       	st	X, r31
		_Kd = 0;
     98e:	ab 89       	ldd	r26, Y+19	; 0x13
     990:	bc 89       	ldd	r27, Y+20	; 0x14
     992:	1d 92       	st	X+, r1
     994:	1c 92       	st	X, r1
		_max = 1600;
     996:	20 e4       	ldi	r18, 0x40	; 64
     998:	36 e0       	ldi	r19, 0x06	; 6
     99a:	e9 85       	ldd	r30, Y+9	; 0x09
     99c:	fa 85       	ldd	r31, Y+10	; 0x0a
     99e:	20 83       	st	Z, r18
     9a0:	31 83       	std	Z+1, r19	; 0x01
		_min = -1600;
     9a2:	e0 ec       	ldi	r30, 0xC0	; 192
     9a4:	f9 ef       	ldi	r31, 0xF9	; 249
     9a6:	ad 85       	ldd	r26, Y+13	; 0x0d
     9a8:	be 85       	ldd	r27, Y+14	; 0x0e
     9aa:	ed 93       	st	X+, r30
     9ac:	fc 93       	st	X, r31
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     9ae:	86 01       	movw	r16, r12
     9b0:	08 1b       	sub	r16, r24
     9b2:	19 0b       	sbc	r17, r25
     9b4:	48 01       	movw	r8, r16
     9b6:	01 2e       	mov	r0, r17
     9b8:	00 0c       	add	r0, r0
     9ba:	aa 08       	sbc	r10, r10
     9bc:	bb 08       	sbc	r11, r11
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     9be:	b8 01       	movw	r22, r16
     9c0:	86 e1       	ldi	r24, 0x16	; 22
     9c2:	90 e0       	ldi	r25, 0x00	; 0
     9c4:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <_ZN7satmath20signed_saturated_mulEii>
     9c8:	2b 01       	movw	r4, r22
     9ca:	3c 01       	movw	r6, r24
     9cc:	af 85       	ldd	r26, Y+15	; 0x0f
     9ce:	b8 89       	ldd	r27, Y+16	; 0x10
     9d0:	6d 93       	st	X+, r22
     9d2:	7c 93       	st	X, r23

		// Integral term
		_integral += error * dt;
     9d4:	eb 85       	ldd	r30, Y+11	; 0x0b
     9d6:	fc 85       	ldd	r31, Y+12	; 0x0c
     9d8:	60 81       	ld	r22, Z
     9da:	71 81       	ldd	r23, Z+1	; 0x01
     9dc:	82 81       	ldd	r24, Z+2	; 0x02
     9de:	93 81       	ldd	r25, Z+3	; 0x03
     9e0:	a5 01       	movw	r20, r10
     9e2:	94 01       	movw	r18, r8
     9e4:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <__mulsi3>
     9e8:	d7 01       	movw	r26, r14
     9ea:	2d 91       	ld	r18, X+
     9ec:	3d 91       	ld	r19, X+
     9ee:	4d 91       	ld	r20, X+
     9f0:	5c 91       	ld	r21, X
     9f2:	dc 01       	movw	r26, r24
     9f4:	cb 01       	movw	r24, r22
     9f6:	82 0f       	add	r24, r18
     9f8:	93 1f       	adc	r25, r19
     9fa:	a4 1f       	adc	r26, r20
     9fc:	b5 1f       	adc	r27, r21
		if(_integral < 1000000000)
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
     9fe:	81 30       	cpi	r24, 0x01	; 1
     a00:	ea ec       	ldi	r30, 0xCA	; 202
     a02:	9e 07       	cpc	r25, r30
     a04:	ea e9       	ldi	r30, 0x9A	; 154
     a06:	ae 07       	cpc	r26, r30
     a08:	eb e3       	ldi	r30, 0x3B	; 59
     a0a:	be 07       	cpc	r27, r30
     a0c:	34 f4       	brge	.+12     	; 0xa1a <_ZN5Motor3runEv+0x1a8>
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);

		// Integral term
		_integral += error * dt;
     a0e:	f7 01       	movw	r30, r14
     a10:	80 83       	st	Z, r24
     a12:	91 83       	std	Z+1, r25	; 0x01
     a14:	a2 83       	std	Z+2, r26	; 0x02
     a16:	b3 83       	std	Z+3, r27	; 0x03
     a18:	09 c0       	rjmp	.+18     	; 0xa2c <_ZN5Motor3runEv+0x1ba>
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
		{
			_integral = 1000000000;
     a1a:	80 e0       	ldi	r24, 0x00	; 0
     a1c:	9a ec       	ldi	r25, 0xCA	; 202
     a1e:	aa e9       	ldi	r26, 0x9A	; 154
     a20:	bb e3       	ldi	r27, 0x3B	; 59
     a22:	f7 01       	movw	r30, r14
     a24:	80 83       	st	Z, r24
     a26:	91 83       	std	Z+1, r25	; 0x01
     a28:	a2 83       	std	Z+2, r26	; 0x02
     a2a:	b3 83       	std	Z+3, r27	; 0x03
		_integral = arbitraryNumber;
		else if( _integral < arbitraryNumber )
		_integral = arbitraryNumber;
		*/
		
		Iout = (_Ki * _integral)/256;
     a2c:	ef 81       	ldd	r30, Y+7	; 0x07
     a2e:	f8 85       	ldd	r31, Y+8	; 0x08
     a30:	a0 81       	ld	r26, Z
     a32:	b1 81       	ldd	r27, Z+1	; 0x01
     a34:	f7 01       	movw	r30, r14
     a36:	20 81       	ld	r18, Z
     a38:	31 81       	ldd	r19, Z+1	; 0x01
     a3a:	42 81       	ldd	r20, Z+2	; 0x02
     a3c:	53 81       	ldd	r21, Z+3	; 0x03
     a3e:	0e 94 44 20 	call	0x4088	; 0x4088 <__mulshisi3>
     a42:	9b 01       	movw	r18, r22
     a44:	ac 01       	movw	r20, r24
     a46:	99 23       	and	r25, r25
     a48:	24 f4       	brge	.+8      	; 0xa52 <_ZN5Motor3runEv+0x1e0>
     a4a:	21 50       	subi	r18, 0x01	; 1
     a4c:	3f 4f       	sbci	r19, 0xFF	; 255
     a4e:	4f 4f       	sbci	r20, 0xFF	; 255
     a50:	5f 4f       	sbci	r21, 0xFF	; 255
     a52:	99 27       	eor	r25, r25
     a54:	57 fd       	sbrc	r21, 7
     a56:	9a 95       	dec	r25
     a58:	85 2f       	mov	r24, r21
     a5a:	74 2f       	mov	r23, r20
     a5c:	63 2f       	mov	r22, r19
     a5e:	a9 89       	ldd	r26, Y+17	; 0x11
     a60:	ba 89       	ldd	r27, Y+18	; 0x12
     a62:	6d 93       	st	X+, r22
     a64:	7d 93       	st	X+, r23
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	13 97       	sbiw	r26, 0x03	; 3
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output
		// int16_t output = Pout + Iout + Dout;
		int16_t output = ssadd(Pout, Iout);
     a6c:	c2 01       	movw	r24, r4
     a6e:	0e 94 dd 06 	call	0xdba	; 0xdba <_ZN7satmath20signed_saturated_addEii>

		// Restrict to max/min
		if( output > _max )
     a72:	e9 85       	ldd	r30, Y+9	; 0x09
     a74:	fa 85       	ldd	r31, Y+10	; 0x0a
     a76:	60 80       	ld	r6, Z
     a78:	71 80       	ldd	r7, Z+1	; 0x01
     a7a:	68 16       	cp	r6, r24
     a7c:	79 06       	cpc	r7, r25
     a7e:	4c f0       	brlt	.+18     	; 0xa92 <_ZN5Motor3runEv+0x220>
		output = _max;
		else if( output < _min )
     a80:	ad 85       	ldd	r26, Y+13	; 0x0d
     a82:	be 85       	ldd	r27, Y+14	; 0x0e
     a84:	2d 91       	ld	r18, X+
     a86:	3c 91       	ld	r19, X
     a88:	3c 01       	movw	r6, r24
     a8a:	82 17       	cp	r24, r18
     a8c:	93 07       	cpc	r25, r19
     a8e:	0c f4       	brge	.+2      	; 0xa92 <_ZN5Motor3runEv+0x220>
     a90:	39 01       	movw	r6, r18
		output = _min;

		// Save error to previous error
		_pre_error = error;
     a92:	ed 89       	ldd	r30, Y+21	; 0x15
     a94:	fe 89       	ldd	r31, Y+22	; 0x16
     a96:	00 83       	st	Z, r16
     a98:	11 83       	std	Z+1, r17	; 0x01
		
		
			if(runs%5==0){
     a9a:	d1 01       	movw	r26, r2
     a9c:	1e 96       	adiw	r26, 0x0e	; 14
     a9e:	6d 91       	ld	r22, X+
     aa0:	7d 91       	ld	r23, X+
     aa2:	8d 91       	ld	r24, X+
     aa4:	9c 91       	ld	r25, X
     aa6:	51 97       	sbiw	r26, 0x11	; 17
     aa8:	25 e0       	ldi	r18, 0x05	; 5
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
     ab4:	67 2b       	or	r22, r23
     ab6:	68 2b       	or	r22, r24
     ab8:	69 2b       	or	r22, r25
     aba:	09 f0       	breq	.+2      	; 0xabe <_ZN5Motor3runEv+0x24c>
     abc:	6a c0       	rjmp	.+212    	; 0xb92 <_ZN5Motor3runEv+0x320>
				*p_serial << "Ierror: " << Iout << endl;
     abe:	a9 89       	ldd	r26, Y+17	; 0x11
     ac0:	ba 89       	ldd	r27, Y+18	; 0x12
     ac2:	8d 91       	ld	r24, X+
     ac4:	9d 91       	ld	r25, X+
     ac6:	0d 90       	ld	r0, X+
     ac8:	bc 91       	ld	r27, X
     aca:	a0 2d       	mov	r26, r0
     acc:	89 8f       	std	Y+25, r24	; 0x19
     ace:	9a 8f       	std	Y+26, r25	; 0x1a
     ad0:	ab 8f       	std	Y+27, r26	; 0x1b
     ad2:	bc 8f       	std	Y+28, r27	; 0x1c
     ad4:	f1 01       	movw	r30, r2
     ad6:	06 81       	ldd	r16, Z+6	; 0x06
     ad8:	17 81       	ldd	r17, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     ada:	6e e1       	ldi	r22, 0x1E	; 30
     adc:	70 e2       	ldi	r23, 0x20	; 32
     ade:	c8 01       	movw	r24, r16
     ae0:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     ae4:	49 8d       	ldd	r20, Y+25	; 0x19
     ae6:	5a 8d       	ldd	r21, Y+26	; 0x1a
     ae8:	6b 8d       	ldd	r22, Y+27	; 0x1b
     aea:	7c 8d       	ldd	r23, Y+28	; 0x1c
     aec:	c8 01       	movw	r24, r16
     aee:	0e 94 a5 1a 	call	0x354a	; 0x354a <_ZN8emstreamlsEl>
     af2:	66 e0       	ldi	r22, 0x06	; 6
     af4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "Pout: " << Pout << endl;
     af8:	af 85       	ldd	r26, Y+15	; 0x0f
     afa:	b8 89       	ldd	r27, Y+16	; 0x10
     afc:	4d 90       	ld	r4, X+
     afe:	5c 90       	ld	r5, X
     b00:	f1 01       	movw	r30, r2
     b02:	06 81       	ldd	r16, Z+6	; 0x06
     b04:	17 81       	ldd	r17, Z+7	; 0x07
     b06:	67 e2       	ldi	r22, 0x27	; 39
     b08:	70 e2       	ldi	r23, 0x20	; 32
     b0a:	c8 01       	movw	r24, r16
     b0c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     b10:	b2 01       	movw	r22, r4
     b12:	c8 01       	movw	r24, r16
     b14:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEi>
     b18:	66 e0       	ldi	r22, 0x06	; 6
     b1a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "error: " << error << endl;
     b1e:	d1 01       	movw	r26, r2
     b20:	16 96       	adiw	r26, 0x06	; 6
     b22:	0d 91       	ld	r16, X+
     b24:	1c 91       	ld	r17, X
     b26:	17 97       	sbiw	r26, 0x07	; 7
     b28:	6f e1       	ldi	r22, 0x1F	; 31
     b2a:	70 e2       	ldi	r23, 0x20	; 32
     b2c:	c8 01       	movw	r24, r16
     b2e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     b32:	b5 01       	movw	r22, r10
     b34:	a4 01       	movw	r20, r8
     b36:	c8 01       	movw	r24, r16
     b38:	0e 94 a5 1a 	call	0x354a	; 0x354a <_ZN8emstreamlsEl>
     b3c:	66 e0       	ldi	r22, 0x06	; 6
     b3e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "Integral: " << _integral << endl;
     b42:	f7 01       	movw	r30, r14
     b44:	80 80       	ld	r8, Z
     b46:	91 80       	ldd	r9, Z+1	; 0x01
     b48:	a2 80       	ldd	r10, Z+2	; 0x02
     b4a:	b3 80       	ldd	r11, Z+3	; 0x03
     b4c:	d1 01       	movw	r26, r2
     b4e:	16 96       	adiw	r26, 0x06	; 6
     b50:	0d 91       	ld	r16, X+
     b52:	1c 91       	ld	r17, X
     b54:	17 97       	sbiw	r26, 0x07	; 7
     b56:	6e e2       	ldi	r22, 0x2E	; 46
     b58:	70 e2       	ldi	r23, 0x20	; 32
     b5a:	c8 01       	movw	r24, r16
     b5c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     b60:	b5 01       	movw	r22, r10
     b62:	a4 01       	movw	r20, r8
     b64:	c8 01       	movw	r24, r16
     b66:	0e 94 a5 1a 	call	0x354a	; 0x354a <_ZN8emstreamlsEl>
     b6a:	66 e0       	ldi	r22, 0x06	; 6
     b6c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "Measured: " << omegam_measured << endl;
     b70:	f1 01       	movw	r30, r2
     b72:	a6 8c       	ldd	r10, Z+30	; 0x1e
     b74:	b7 8c       	ldd	r11, Z+31	; 0x1f
     b76:	06 81       	ldd	r16, Z+6	; 0x06
     b78:	17 81       	ldd	r17, Z+7	; 0x07
     b7a:	69 e3       	ldi	r22, 0x39	; 57
     b7c:	70 e2       	ldi	r23, 0x20	; 32
     b7e:	c8 01       	movw	r24, r16
     b80:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     b84:	b5 01       	movw	r22, r10
     b86:	c8 01       	movw	r24, r16
     b88:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEi>
     b8c:	66 e0       	ldi	r22, 0x06	; 6
     b8e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b92:	0f b6       	in	r0, 0x3f	; 63
     b94:	f8 94       	cli
     b96:	0f 92       	push	r0
			the_data = new_data;
     b98:	60 92 6c 31 	sts	0x316C, r6	; 0x80316c <PWMvalue>
     b9c:	70 92 6d 31 	sts	0x316D, r7	; 0x80316d <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     ba0:	0f 90       	pop	r0
     ba2:	0f be       	out	0x3f, r0	; 63
			}
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     ba4:	d1 01       	movw	r26, r2
     ba6:	98 96       	adiw	r26, 0x28	; 40
     ba8:	1d 92       	st	X+, r1
     baa:	1c 92       	st	X, r1
     bac:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
     bae:	92 96       	adiw	r26, 0x22	; 34
     bb0:	8d 91       	ld	r24, X+
     bb2:	9c 91       	ld	r25, X
     bb4:	93 97       	sbiw	r26, 0x23	; 35
     bb6:	60 e0       	ldi	r22, 0x00	; 0
     bb8:	70 e0       	ldi	r23, 0x00	; 0
     bba:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <__divmodhi4>
     bbe:	8b 01       	movw	r16, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     bc0:	07 2e       	mov	r0, r23
     bc2:	00 0c       	add	r0, r0
     bc4:	88 0b       	sbc	r24, r24
     bc6:	99 0b       	sbc	r25, r25
     bc8:	0e 94 49 1f 	call	0x3e92	; 0x3e92 <__floatsisf>
     bcc:	4b 01       	movw	r8, r22
     bce:	5c 01       	movw	r10, r24
     bd0:	23 e3       	ldi	r18, 0x33	; 51
     bd2:	33 e3       	ldi	r19, 0x33	; 51
     bd4:	4b e8       	ldi	r20, 0x8B	; 139
     bd6:	51 e4       	ldi	r21, 0x41	; 65
     bd8:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <__gesf2>
     bdc:	18 16       	cp	r1, r24
     bde:	34 f4       	brge	.+12     	; 0xbec <_ZN5Motor3runEv+0x37a>
			Im_set = 17.4;
     be0:	81 e1       	ldi	r24, 0x11	; 17
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	f1 01       	movw	r30, r2
     be6:	84 a3       	std	Z+36, r24	; 0x24
     be8:	95 a3       	std	Z+37, r25	; 0x25
     bea:	15 c0       	rjmp	.+42     	; 0xc16 <_ZN5Motor3runEv+0x3a4>
		} else if(Im_set < -17.4) {
     bec:	23 e3       	ldi	r18, 0x33	; 51
     bee:	33 e3       	ldi	r19, 0x33	; 51
     bf0:	4b e8       	ldi	r20, 0x8B	; 139
     bf2:	51 ec       	ldi	r21, 0xC1	; 193
     bf4:	c5 01       	movw	r24, r10
     bf6:	b4 01       	movw	r22, r8
     bf8:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <__cmpsf2>
     bfc:	88 23       	and	r24, r24
     bfe:	34 f0       	brlt	.+12     	; 0xc0c <_ZN5Motor3runEv+0x39a>
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     c00:	d1 01       	movw	r26, r2
     c02:	94 96       	adiw	r26, 0x24	; 36
     c04:	0d 93       	st	X+, r16
     c06:	1c 93       	st	X, r17
     c08:	95 97       	sbiw	r26, 0x25	; 37
     c0a:	05 c0       	rjmp	.+10     	; 0xc16 <_ZN5Motor3runEv+0x3a4>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     c0c:	8f ee       	ldi	r24, 0xEF	; 239
     c0e:	9f ef       	ldi	r25, 0xFF	; 255
     c10:	f1 01       	movw	r30, r2
     c12:	84 a3       	std	Z+36, r24	; 0x24
     c14:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     c16:	d1 01       	movw	r26, r2
     c18:	d6 96       	adiw	r26, 0x36	; 54
     c1a:	1d 92       	st	X+, r1
     c1c:	1c 92       	st	X, r1
     c1e:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     c20:	d2 96       	adiw	r26, 0x32	; 50
     c22:	1d 92       	st	X+, r1
     c24:	1c 92       	st	X, r1
     c26:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     c28:	d4 96       	adiw	r26, 0x34	; 52
     c2a:	1d 92       	st	X+, r1
     c2c:	1c 92       	st	X, r1
     c2e:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
     c30:	d0 96       	adiw	r26, 0x30	; 48
     c32:	8d 91       	ld	r24, X+
     c34:	9c 91       	ld	r25, X
     c36:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
     c38:	89 31       	cpi	r24, 0x19	; 25
     c3a:	91 05       	cpc	r25, r1
     c3c:	3c f0       	brlt	.+14     	; 0xc4c <_ZN5Motor3runEv+0x3da>
			V_m = 24;
     c3e:	88 e1       	ldi	r24, 0x18	; 24
     c40:	90 e0       	ldi	r25, 0x00	; 0
     c42:	d8 96       	adiw	r26, 0x38	; 56
     c44:	8d 93       	st	X+, r24
     c46:	9c 93       	st	X, r25
     c48:	d9 97       	sbiw	r26, 0x39	; 57
     c4a:	0f c0       	rjmp	.+30     	; 0xc6a <_ZN5Motor3runEv+0x3f8>
		} else if(V_m < -24) {
     c4c:	88 3e       	cpi	r24, 0xE8	; 232
     c4e:	bf ef       	ldi	r27, 0xFF	; 255
     c50:	9b 07       	cpc	r25, r27
     c52:	24 f0       	brlt	.+8      	; 0xc5c <_ZN5Motor3runEv+0x3ea>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     c54:	f1 01       	movw	r30, r2
     c56:	80 af       	std	Z+56, r24	; 0x38
     c58:	91 af       	std	Z+57, r25	; 0x39
     c5a:	07 c0       	rjmp	.+14     	; 0xc6a <_ZN5Motor3runEv+0x3f8>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     c5c:	88 ee       	ldi	r24, 0xE8	; 232
     c5e:	9f ef       	ldi	r25, 0xFF	; 255
     c60:	d1 01       	movw	r26, r2
     c62:	d8 96       	adiw	r26, 0x38	; 56
     c64:	8d 93       	st	X+, r24
     c66:	9c 93       	st	X, r25
     c68:	d9 97       	sbiw	r26, 0x39	; 57

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
     c6a:	eb 85       	ldd	r30, Y+11	; 0x0b
     c6c:	fc 85       	ldd	r31, Y+12	; 0x0c
     c6e:	20 81       	ld	r18, Z
     c70:	31 81       	ldd	r19, Z+1	; 0x01
     c72:	42 81       	ldd	r20, Z+2	; 0x02
     c74:	53 81       	ldd	r21, Z+3	; 0x03
     c76:	a8 ee       	ldi	r26, 0xE8	; 232
     c78:	b3 e0       	ldi	r27, 0x03	; 3
     c7a:	0e 94 39 20 	call	0x4072	; 0x4072 <__muluhisi3>
     c7e:	68 3e       	cpi	r22, 0xE8	; 232
     c80:	f3 e0       	ldi	r31, 0x03	; 3
     c82:	7f 07       	cpc	r23, r31
     c84:	81 05       	cpc	r24, r1
     c86:	91 05       	cpc	r25, r1
     c88:	48 f0       	brcs	.+18     	; 0xc9c <_ZN5Motor3runEv+0x42a>
     c8a:	28 ee       	ldi	r18, 0xE8	; 232
     c8c:	33 e0       	ldi	r19, 0x03	; 3
     c8e:	40 e0       	ldi	r20, 0x00	; 0
     c90:	50 e0       	ldi	r21, 0x00	; 0
     c92:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
     c96:	ba 01       	movw	r22, r20
     c98:	a9 01       	movw	r20, r18
     c9a:	04 c0       	rjmp	.+8      	; 0xca4 <_ZN5Motor3runEv+0x432>
     c9c:	41 e0       	ldi	r20, 0x01	; 1
     c9e:	50 e0       	ldi	r21, 0x00	; 0
     ca0:	60 e0       	ldi	r22, 0x00	; 0
     ca2:	70 e0       	ldi	r23, 0x00	; 0
     ca4:	ce 01       	movw	r24, r28
     ca6:	01 96       	adiw	r24, 0x01	; 1
     ca8:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
     cac:	31 ce       	rjmp	.-926    	; 0x910 <_ZN5Motor3runEv+0x9e>

00000cae <_ZN5MotorC1EPKchjP8emstream>:
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
     cae:	0f 93       	push	r16
     cb0:	1f 93       	push	r17
     cb2:	cf 93       	push	r28
     cb4:	df 93       	push	r29
     cb6:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     cb8:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     cbc:	88 e4       	ldi	r24, 0x48	; 72
     cbe:	90 e2       	ldi	r25, 0x20	; 32
     cc0:	88 83       	st	Y, r24
     cc2:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     cc4:	df 91       	pop	r29
     cc6:	cf 91       	pop	r28
     cc8:	1f 91       	pop	r17
     cca:	0f 91       	pop	r16
     ccc:	08 95       	ret

00000cce <_ZN9PWMdriver3runEv>:
		// Nothing to do in this constructor other than call the parent constructor
	}



void PWMdriver::run(void){
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	00 d0       	rcall	.+0      	; 0xcd4 <_ZN9PWMdriver3runEv+0x6>
     cd4:	1f 92       	push	r1
     cd6:	cd b7       	in	r28, 0x3d	; 61
     cd8:	de b7       	in	r29, 0x3e	; 62
     cda:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     cdc:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     ce0:	69 83       	std	Y+1, r22	; 0x01
     ce2:	7a 83       	std	Y+2, r23	; 0x02
     ce4:	8b 83       	std	Y+3, r24	; 0x03
     ce6:	9c 83       	std	Y+4, r25	; 0x04
	//PC0 - MD0
	//PC1 - MD1
	
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     ce8:	a0 e4       	ldi	r26, 0x40	; 64
     cea:	b6 e0       	ldi	r27, 0x06	; 6
     cec:	87 e0       	ldi	r24, 0x07	; 7
     cee:	11 96       	adiw	r26, 0x01	; 1
     cf0:	8c 93       	st	X, r24
     cf2:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     cf4:	84 e0       	ldi	r24, 0x04	; 4
     cf6:	15 96       	adiw	r26, 0x05	; 5
     cf8:	8c 93       	st	X, r24
     cfa:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     cfc:	e0 e0       	ldi	r30, 0x00	; 0
     cfe:	f8 e0       	ldi	r31, 0x08	; 8
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     d04:	83 e0       	ldi	r24, 0x03	; 3
     d06:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     d08:	a6 a3       	std	Z+38, r26	; 0x26
     d0a:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     d0c:	10 a6       	std	Z+40, r1	; 0x28
     d0e:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     d10:	12 a6       	std	Z+42, r1	; 0x2a
     d12:	13 a6       	std	Z+43, r1	; 0x2b
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     d14:	81 81       	ldd	r24, Z+1	; 0x01
     d16:	80 63       	ori	r24, 0x30	; 48
     d18:	81 83       	std	Z+1, r24	; 0x01
	
	while(1){
		// Increment counter for debugging
		runs++;
		
		TCC0.CCA = PWMvalue.get();
     d1a:	00 e0       	ldi	r16, 0x00	; 0
     d1c:	18 e0       	ldi	r17, 0x08	; 8
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
	
	while(1){
		// Increment counter for debugging
		runs++;
     d1e:	f7 01       	movw	r30, r14
     d20:	86 85       	ldd	r24, Z+14	; 0x0e
     d22:	97 85       	ldd	r25, Z+15	; 0x0f
     d24:	a0 89       	ldd	r26, Z+16	; 0x10
     d26:	b1 89       	ldd	r27, Z+17	; 0x11
     d28:	01 96       	adiw	r24, 0x01	; 1
     d2a:	a1 1d       	adc	r26, r1
     d2c:	b1 1d       	adc	r27, r1
     d2e:	86 87       	std	Z+14, r24	; 0x0e
     d30:	97 87       	std	Z+15, r25	; 0x0f
     d32:	a0 8b       	std	Z+16, r26	; 0x10
     d34:	b1 8b       	std	Z+17, r27	; 0x11
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d36:	0f b6       	in	r0, 0x3f	; 63
     d38:	f8 94       	cli
     d3a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d3c:	0f 90       	pop	r0
     d3e:	0f be       	out	0x3f, r0	; 63
		
		TCC0.CCA = PWMvalue.get();
     d40:	80 91 6c 31 	lds	r24, 0x316C	; 0x80316c <PWMvalue>
     d44:	90 91 6d 31 	lds	r25, 0x316D	; 0x80316d <PWMvalue+0x1>
     d48:	f8 01       	movw	r30, r16
     d4a:	80 a7       	std	Z+40, r24	; 0x28
     d4c:	91 a7       	std	Z+41, r25	; 0x29
		TCC0.CCB = 0;
     d4e:	12 a6       	std	Z+42, r1	; 0x2a
     d50:	13 a6       	std	Z+43, r1	; 0x2b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d52:	0f b6       	in	r0, 0x3f	; 63
     d54:	f8 94       	cli
     d56:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63
		if(runs%100==0){
			*p_serial << PWMvalue.get() << endl;
		}	
		*/
		
		if (!leftLimitSwitch.get() && !rightLimitSwitch.get())
     d5c:	20 91 6f 31 	lds	r18, 0x316F	; 0x80316f <leftLimitSwitch>
     d60:	21 11       	cpse	r18, r1
     d62:	12 c0       	rjmp	.+36     	; 0xd88 <_ZN9PWMdriver3runEv+0xba>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d64:	0f b6       	in	r0, 0x3f	; 63
     d66:	f8 94       	cli
     d68:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d6a:	0f 90       	pop	r0
     d6c:	0f be       	out	0x3f, r0	; 63
     d6e:	20 91 6e 31 	lds	r18, 0x316E	; 0x80316e <rightLimitSwitch>
     d72:	21 11       	cpse	r18, r1
     d74:	09 c0       	rjmp	.+18     	; 0xd88 <_ZN9PWMdriver3runEv+0xba>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d76:	0f b6       	in	r0, 0x3f	; 63
     d78:	f8 94       	cli
     d7a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d7c:	0f 90       	pop	r0
     d7e:	0f be       	out	0x3f, r0	; 63
		{
			TCC0.CCA = PWMvalue.get();
     d80:	80 a7       	std	Z+40, r24	; 0x28
     d82:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
     d84:	12 a6       	std	Z+42, r1	; 0x2a
     d86:	13 a6       	std	Z+43, r1	; 0x2b
     d88:	44 e1       	ldi	r20, 0x14	; 20
     d8a:	50 e0       	ldi	r21, 0x00	; 0
     d8c:	60 e0       	ldi	r22, 0x00	; 0
     d8e:	70 e0       	ldi	r23, 0x00	; 0
     d90:	ce 01       	movw	r24, r28
     d92:	01 96       	adiw	r24, 0x01	; 1
     d94:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
     d98:	c2 cf       	rjmp	.-124    	; 0xd1e <_ZN9PWMdriver3runEv+0x50>

00000d9a <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

PWMdriver::PWMdriver(const char* a_name,
     d9a:	0f 93       	push	r16
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     da4:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     da8:	80 e5       	ldi	r24, 0x50	; 80
     daa:	90 e2       	ldi	r25, 0x20	; 32
     dac:	88 83       	st	Y, r24
     dae:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	1f 91       	pop	r17
     db6:	0f 91       	pop	r16
     db8:	08 95       	ret

00000dba <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
     dba:	9c 01       	movw	r18, r24
     dbc:	93 2f       	mov	r25, r19
     dbe:	99 1f       	adc	r25, r25
     dc0:	99 27       	eor	r25, r25
     dc2:	99 1f       	adc	r25, r25
     dc4:	89 2f       	mov	r24, r25
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	81 50       	subi	r24, 0x01	; 1
     dca:	90 48       	sbci	r25, 0x80	; 128
     dcc:	43 2f       	mov	r20, r19
     dce:	40 95       	com	r20
     dd0:	44 1f       	adc	r20, r20
     dd2:	44 27       	eor	r20, r20
     dd4:	44 1f       	adc	r20, r20
     dd6:	fc 01       	movw	r30, r24
     dd8:	e2 1b       	sub	r30, r18
     dda:	f3 0b       	sbc	r31, r19
     ddc:	51 e0       	ldi	r21, 0x01	; 1
     dde:	e6 17       	cp	r30, r22
     de0:	f7 07       	cpc	r31, r23
     de2:	0c f0       	brlt	.+2      	; 0xde6 <_ZN7satmath20signed_saturated_addEii+0x2c>
     de4:	50 e0       	ldi	r21, 0x00	; 0
     de6:	45 17       	cp	r20, r21
     de8:	19 f0       	breq	.+6      	; 0xdf0 <_ZN7satmath20signed_saturated_addEii+0x36>
     dea:	c9 01       	movw	r24, r18
     dec:	86 0f       	add	r24, r22
     dee:	97 1f       	adc	r25, r23
     df0:	08 95       	ret

00000df2 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     df2:	81 15       	cp	r24, r1
     df4:	20 e8       	ldi	r18, 0x80	; 128
     df6:	92 07       	cpc	r25, r18
     df8:	21 f4       	brne	.+8      	; 0xe02 <_ZN7satmath20signed_saturated_mulEii+0x10>
     dfa:	61 15       	cp	r22, r1
     dfc:	20 e8       	ldi	r18, 0x80	; 128
     dfe:	72 07       	cpc	r23, r18
     e00:	29 f0       	breq	.+10     	; 0xe0c <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     e02:	9c 01       	movw	r18, r24
     e04:	db 01       	movw	r26, r22
     e06:	0e 94 1b 20 	call	0x4036	; 0x4036 <__mulhisi3>
     e0a:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     e0c:	6f ef       	ldi	r22, 0xFF	; 255
     e0e:	7f ef       	ldi	r23, 0xFF	; 255
     e10:	8f ef       	ldi	r24, 0xFF	; 255
     e12:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     e14:	08 95       	ret

00000e16 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     e16:	0f 93       	push	r16
     e18:	1f 93       	push	r17
     e1a:	cf 93       	push	r28
     e1c:	df 93       	push	r29
     e1e:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     e20:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     e24:	88 e5       	ldi	r24, 0x58	; 88
     e26:	90 e2       	ldi	r25, 0x20	; 32
     e28:	88 83       	st	Y, r24
     e2a:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     e36:	0f 93       	push	r16
     e38:	1f 93       	push	r17
     e3a:	cf 93       	push	r28
     e3c:	df 93       	push	r29
     e3e:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     e40:	6a e0       	ldi	r22, 0x0A	; 10
     e42:	8e 81       	ldd	r24, Y+6	; 0x06
     e44:	9f 81       	ldd	r25, Y+7	; 0x07
     e46:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     e4a:	8c 01       	movw	r16, r24
     e4c:	6d ee       	ldi	r22, 0xED	; 237
     e4e:	73 e0       	ldi	r23, 0x03	; 3
     e50:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     e54:	6a e0       	ldi	r22, 0x0A	; 10
     e56:	c8 01       	movw	r24, r16
     e58:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     e5c:	8c 01       	movw	r16, r24
     e5e:	67 ee       	ldi	r22, 0xE7	; 231
     e60:	73 e0       	ldi	r23, 0x03	; 3
     e62:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     e66:	67 e0       	ldi	r22, 0x07	; 7
     e68:	c8 01       	movw	r24, r16
     e6a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     e6e:	6a e0       	ldi	r22, 0x0A	; 10
     e70:	8e 81       	ldd	r24, Y+6	; 0x06
     e72:	9f 81       	ldd	r25, Y+7	; 0x07
     e74:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     e78:	8c 01       	movw	r16, r24
     e7a:	68 ec       	ldi	r22, 0xC8	; 200
     e7c:	73 e0       	ldi	r23, 0x03	; 3
     e7e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     e82:	6a e0       	ldi	r22, 0x0A	; 10
     e84:	c8 01       	movw	r24, r16
     e86:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     e8a:	8c 01       	movw	r16, r24
     e8c:	62 ec       	ldi	r22, 0xC2	; 194
     e8e:	73 e0       	ldi	r23, 0x03	; 3
     e90:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     e94:	66 e0       	ldi	r22, 0x06	; 6
     e96:	c8 01       	movw	r24, r16
     e98:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e9c:	6a e0       	ldi	r22, 0x0A	; 10
     e9e:	8e 81       	ldd	r24, Y+6	; 0x06
     ea0:	9f 81       	ldd	r25, Y+7	; 0x07
     ea2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     ea6:	8c 01       	movw	r16, r24
     ea8:	6b ea       	ldi	r22, 0xAB	; 171
     eaa:	73 e0       	ldi	r23, 0x03	; 3
     eac:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     eb0:	66 e0       	ldi	r22, 0x06	; 6
     eb2:	c8 01       	movw	r24, r16
     eb4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     eb8:	6a e0       	ldi	r22, 0x0A	; 10
     eba:	8e 81       	ldd	r24, Y+6	; 0x06
     ebc:	9f 81       	ldd	r25, Y+7	; 0x07
     ebe:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     ec2:	8c 01       	movw	r16, r24
     ec4:	6f e8       	ldi	r22, 0x8F	; 143
     ec6:	73 e0       	ldi	r23, 0x03	; 3
     ec8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     ecc:	66 e0       	ldi	r22, 0x06	; 6
     ece:	c8 01       	movw	r24, r16
     ed0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     ed4:	6a e0       	ldi	r22, 0x0A	; 10
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	9f 81       	ldd	r25, Y+7	; 0x07
     eda:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     ede:	8c 01       	movw	r16, r24
     ee0:	67 e7       	ldi	r22, 0x77	; 119
     ee2:	73 e0       	ldi	r23, 0x03	; 3
     ee4:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     ee8:	66 e0       	ldi	r22, 0x06	; 6
     eea:	c8 01       	movw	r24, r16
     eec:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     ef0:	6a e0       	ldi	r22, 0x0A	; 10
     ef2:	8e 81       	ldd	r24, Y+6	; 0x06
     ef4:	9f 81       	ldd	r25, Y+7	; 0x07
     ef6:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     efa:	8c 01       	movw	r16, r24
     efc:	66 e5       	ldi	r22, 0x56	; 86
     efe:	73 e0       	ldi	r23, 0x03	; 3
     f00:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f04:	66 e0       	ldi	r22, 0x06	; 6
     f06:	c8 01       	movw	r24, r16
     f08:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     f0c:	6a e0       	ldi	r22, 0x0A	; 10
     f0e:	8e 81       	ldd	r24, Y+6	; 0x06
     f10:	9f 81       	ldd	r25, Y+7	; 0x07
     f12:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     f16:	8c 01       	movw	r16, r24
     f18:	6f e2       	ldi	r22, 0x2F	; 47
     f1a:	73 e0       	ldi	r23, 0x03	; 3
     f1c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f20:	66 e0       	ldi	r22, 0x06	; 6
     f22:	c8 01       	movw	r24, r16
     f24:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     f28:	6a e0       	ldi	r22, 0x0A	; 10
     f2a:	8e 81       	ldd	r24, Y+6	; 0x06
     f2c:	9f 81       	ldd	r25, Y+7	; 0x07
     f2e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     f32:	8c 01       	movw	r16, r24
     f34:	61 e1       	ldi	r22, 0x11	; 17
     f36:	73 e0       	ldi	r23, 0x03	; 3
     f38:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f3c:	66 e0       	ldi	r22, 0x06	; 6
     f3e:	c8 01       	movw	r24, r16
     f40:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     f44:	6a e0       	ldi	r22, 0x0A	; 10
     f46:	8e 81       	ldd	r24, Y+6	; 0x06
     f48:	9f 81       	ldd	r25, Y+7	; 0x07
     f4a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     f4e:	8c 01       	movw	r16, r24
     f50:	66 ef       	ldi	r22, 0xF6	; 246
     f52:	72 e0       	ldi	r23, 0x02	; 2
     f54:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f58:	66 e0       	ldi	r22, 0x06	; 6
     f5a:	c8 01       	movw	r24, r16
     f5c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     f60:	6a e0       	ldi	r22, 0x0A	; 10
     f62:	8e 81       	ldd	r24, Y+6	; 0x06
     f64:	9f 81       	ldd	r25, Y+7	; 0x07
     f66:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     f6a:	ec 01       	movw	r28, r24
     f6c:	67 ee       	ldi	r22, 0xE7	; 231
     f6e:	72 e0       	ldi	r23, 0x02	; 2
     f70:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f74:	66 e0       	ldi	r22, 0x06	; 6
     f76:	ce 01       	movw	r24, r28
     f78:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
}
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	1f 91       	pop	r17
     f82:	0f 91       	pop	r16
     f84:	08 95       	ret

00000f86 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     f86:	af 92       	push	r10
     f88:	bf 92       	push	r11
     f8a:	cf 92       	push	r12
     f8c:	df 92       	push	r13
     f8e:	ef 92       	push	r14
     f90:	ff 92       	push	r15
     f92:	0f 93       	push	r16
     f94:	1f 93       	push	r17
     f96:	cf 93       	push	r28
     f98:	df 93       	push	r29
     f9a:	00 d0       	rcall	.+0      	; 0xf9c <_ZN9task_user11show_statusEv+0x16>
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <_ZN9task_user11show_statusEv+0x18>
     f9e:	cd b7       	in	r28, 0x3d	; 61
     fa0:	de b7       	in	r29, 0x3e	; 62
     fa2:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     fa4:	19 82       	std	Y+1, r1	; 0x01
     fa6:	1a 82       	std	Y+2, r1	; 0x02
     fa8:	1b 82       	std	Y+3, r1	; 0x03
     faa:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     fac:	1d 82       	std	Y+5, r1	; 0x05
     fae:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     fb0:	0e 94 48 0a 	call	0x1490	; 0x1490 <xPortGetFreeHeapSize>
     fb4:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     fb6:	ce 01       	movw	r24, r28
     fb8:	01 96       	adiw	r24, 0x01	; 1
     fba:	0e 94 81 18 	call	0x3102	; 0x3102 <_ZN10time_stamp10set_to_nowEv>
     fbe:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     fc0:	66 e0       	ldi	r22, 0x06	; 6
     fc2:	f8 01       	movw	r30, r16
     fc4:	86 81       	ldd	r24, Z+6	; 0x06
     fc6:	97 81       	ldd	r25, Z+7	; 0x07
     fc8:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     fcc:	6a e0       	ldi	r22, 0x0A	; 10
     fce:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     fd2:	7c 01       	movw	r14, r24
     fd4:	68 ec       	ldi	r22, 0xC8	; 200
     fd6:	72 e0       	ldi	r23, 0x02	; 2
     fd8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     fdc:	6a e0       	ldi	r22, 0x0A	; 10
     fde:	c7 01       	movw	r24, r14
     fe0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     fe4:	7c 01       	movw	r14, r24
     fe6:	6c eb       	ldi	r22, 0xBC	; 188
     fe8:	72 e0       	ldi	r23, 0x02	; 2
     fea:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     fee:	66 e0       	ldi	r22, 0x06	; 6
     ff0:	c7 01       	movw	r24, r14
     ff2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     ff6:	6a e0       	ldi	r22, 0x0A	; 10
     ff8:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     ffc:	7c 01       	movw	r14, r24
     ffe:	65 eb       	ldi	r22, 0xB5	; 181
    1000:	72 e0       	ldi	r23, 0x02	; 2
    1002:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    1006:	b5 01       	movw	r22, r10
    1008:	c7 01       	movw	r24, r14
    100a:	0e 94 25 18 	call	0x304a	; 0x304a <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    100e:	6a e0       	ldi	r22, 0x0A	; 10
    1010:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1014:	7c 01       	movw	r14, r24
    1016:	67 ea       	ldi	r22, 0xA7	; 167
    1018:	72 e0       	ldi	r23, 0x02	; 2
    101a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    101e:	b6 01       	movw	r22, r12
    1020:	c7 01       	movw	r24, r14
    1022:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    1026:	6a e0       	ldi	r22, 0x0A	; 10
    1028:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    102c:	7c 01       	movw	r14, r24
    102e:	65 ea       	ldi	r22, 0xA5	; 165
    1030:	72 e0       	ldi	r23, 0x02	; 2
    1032:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1036:	4f ef       	ldi	r20, 0xFF	; 255
    1038:	5f e0       	ldi	r21, 0x0F	; 15
    103a:	60 e0       	ldi	r22, 0x00	; 0
    103c:	70 e0       	ldi	r23, 0x00	; 0
    103e:	c7 01       	movw	r24, r14
    1040:	0e 94 04 1b 	call	0x3608	; 0x3608 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1044:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1048:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    104c:	6a e0       	ldi	r22, 0x0A	; 10
    104e:	f8 01       	movw	r30, r16
    1050:	86 81       	ldd	r24, Z+6	; 0x06
    1052:	97 81       	ldd	r25, Z+7	; 0x07
    1054:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1058:	7c 01       	movw	r14, r24
    105a:	6a e9       	ldi	r22, 0x9A	; 154
    105c:	72 e0       	ldi	r23, 0x02	; 2
    105e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    1062:	b6 01       	movw	r22, r12
    1064:	c7 01       	movw	r24, r14
    1066:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    106a:	66 e0       	ldi	r22, 0x06	; 6
    106c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1070:	66 e0       	ldi	r22, 0x06	; 6
    1072:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1076:	f8 01       	movw	r30, r16
    1078:	86 81       	ldd	r24, Z+6	; 0x06
    107a:	97 81       	ldd	r25, Z+7	; 0x07
    107c:	0e 94 de 16 	call	0x2dbc	; 0x2dbc <_Z15print_task_listP8emstream>
}
    1080:	26 96       	adiw	r28, 0x06	; 6
    1082:	cd bf       	out	0x3d, r28	; 61
    1084:	de bf       	out	0x3e, r29	; 62
    1086:	df 91       	pop	r29
    1088:	cf 91       	pop	r28
    108a:	1f 91       	pop	r17
    108c:	0f 91       	pop	r16
    108e:	ff 90       	pop	r15
    1090:	ef 90       	pop	r14
    1092:	df 90       	pop	r13
    1094:	cf 90       	pop	r12
    1096:	bf 90       	pop	r11
    1098:	af 90       	pop	r10
    109a:	08 95       	ret

0000109c <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    109c:	cf 93       	push	r28
    109e:	df 93       	push	r29
    10a0:	00 d0       	rcall	.+0      	; 0x10a2 <_ZN9task_user3runEv+0x6>
    10a2:	00 d0       	rcall	.+0      	; 0x10a4 <_ZN9task_user3runEv+0x8>
    10a4:	cd b7       	in	r28, 0x3d	; 61
    10a6:	de b7       	in	r29, 0x3e	; 62
    10a8:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    10aa:	19 82       	std	Y+1, r1	; 0x01
    10ac:	1a 82       	std	Y+2, r1	; 0x02
    10ae:	1b 82       	std	Y+3, r1	; 0x03
    10b0:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    10b2:	1d 82       	std	Y+5, r1	; 0x05
    10b4:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    10b6:	6a e0       	ldi	r22, 0x0A	; 10
    10b8:	dc 01       	movw	r26, r24
    10ba:	16 96       	adiw	r26, 0x06	; 6
    10bc:	8d 91       	ld	r24, X+
    10be:	9c 91       	ld	r25, X
    10c0:	17 97       	sbiw	r26, 0x07	; 7
    10c2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    10c6:	7c 01       	movw	r14, r24
    10c8:	66 e3       	ldi	r22, 0x36	; 54
    10ca:	74 e0       	ldi	r23, 0x04	; 4
    10cc:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    10d0:	66 e0       	ldi	r22, 0x06	; 6
    10d2:	c7 01       	movw	r24, r14
    10d4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    10d8:	f8 01       	movw	r30, r16
    10da:	84 85       	ldd	r24, Z+12	; 0x0c
    10dc:	88 23       	and	r24, r24
    10de:	21 f0       	breq	.+8      	; 0x10e8 <_ZN9task_user3runEv+0x4c>
    10e0:	81 30       	cpi	r24, 0x01	; 1
    10e2:	09 f4       	brne	.+2      	; 0x10e6 <_ZN9task_user3runEv+0x4a>
    10e4:	5d c0       	rjmp	.+186    	; 0x11a0 <_ZN9task_user3runEv+0x104>
    10e6:	d8 c0       	rjmp	.+432    	; 0x1298 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    10e8:	86 81       	ldd	r24, Z+6	; 0x06
    10ea:	97 81       	ldd	r25, Z+7	; 0x07
    10ec:	dc 01       	movw	r26, r24
    10ee:	ed 91       	ld	r30, X+
    10f0:	fc 91       	ld	r31, X
    10f2:	04 80       	ldd	r0, Z+4	; 0x04
    10f4:	f5 81       	ldd	r31, Z+5	; 0x05
    10f6:	e0 2d       	mov	r30, r0
    10f8:	19 95       	eicall
    10fa:	88 23       	and	r24, r24
    10fc:	a9 f1       	breq	.+106    	; 0x1168 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    10fe:	f8 01       	movw	r30, r16
    1100:	86 81       	ldd	r24, Z+6	; 0x06
    1102:	97 81       	ldd	r25, Z+7	; 0x07
    1104:	dc 01       	movw	r26, r24
    1106:	ed 91       	ld	r30, X+
    1108:	fc 91       	ld	r31, X
    110a:	06 80       	ldd	r0, Z+6	; 0x06
    110c:	f7 81       	ldd	r31, Z+7	; 0x07
    110e:	e0 2d       	mov	r30, r0
    1110:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1112:	99 27       	eor	r25, r25
    1114:	81 30       	cpi	r24, 0x01	; 1
    1116:	91 05       	cpc	r25, r1
    1118:	f9 f0       	breq	.+62     	; 0x1158 <_ZN9task_user3runEv+0xbc>
    111a:	03 97       	sbiw	r24, 0x03	; 3
    111c:	09 f0       	breq	.+2      	; 0x1120 <_ZN9task_user3runEv+0x84>
    111e:	d8 c0       	rjmp	.+432    	; 0x12d0 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1120:	6a e0       	ldi	r22, 0x0A	; 10
    1122:	f8 01       	movw	r30, r16
    1124:	86 81       	ldd	r24, Z+6	; 0x06
    1126:	97 81       	ldd	r25, Z+7	; 0x07
    1128:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    112c:	8c 01       	movw	r16, r24
    112e:	68 e2       	ldi	r22, 0x28	; 40
    1130:	74 e0       	ldi	r23, 0x04	; 4
    1132:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    1136:	66 e0       	ldi	r22, 0x06	; 6
    1138:	c8 01       	movw	r24, r16
    113a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    113e:	93 e0       	ldi	r25, 0x03	; 3
    1140:	88 ed       	ldi	r24, 0xD8	; 216
    1142:	08 b6       	in	r0, 0x38	; 56
    1144:	18 be       	out	0x38, r1	; 56
    1146:	84 bf       	out	0x34, r24	; 52
    1148:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    114c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1150:	81 fd       	sbrc	r24, 1
    1152:	fc cf       	rjmp	.-8      	; 0x114c <_ZN9task_user3runEv+0xb0>
    1154:	08 be       	out	0x38, r0	; 56
    1156:	ff cf       	rjmp	.-2      	; 0x1156 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1158:	c8 01       	movw	r24, r16
    115a:	0e 94 1b 07 	call	0xe36	; 0xe36 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    115e:	61 e0       	ldi	r22, 0x01	; 1
    1160:	c8 01       	movw	r24, r16
    1162:	0e 94 cc 14 	call	0x2998	; 0x2998 <_ZN8frt_task13transition_toEh>
							break;
    1166:	b4 c0       	rjmp	.+360    	; 0x12d0 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1168:	86 e7       	ldi	r24, 0x76	; 118
    116a:	91 e3       	ldi	r25, 0x31	; 49
    116c:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <_ZN14frt_text_queue14check_for_charEv>
    1170:	88 23       	and	r24, r24
    1172:	09 f4       	brne	.+2      	; 0x1176 <_ZN9task_user3runEv+0xda>
    1174:	ad c0       	rjmp	.+346    	; 0x12d0 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1176:	d8 01       	movw	r26, r16
    1178:	16 96       	adiw	r26, 0x06	; 6
    117a:	ed 91       	ld	r30, X+
    117c:	fc 91       	ld	r31, X
    117e:	17 97       	sbiw	r26, 0x07	; 7
    1180:	01 90       	ld	r0, Z+
    1182:	f0 81       	ld	r31, Z
    1184:	e0 2d       	mov	r30, r0
    1186:	e2 80       	ldd	r14, Z+2	; 0x02
    1188:	f3 80       	ldd	r15, Z+3	; 0x03
    118a:	86 e7       	ldi	r24, 0x76	; 118
    118c:	91 e3       	ldi	r25, 0x31	; 49
    118e:	0e 94 6f 17 	call	0x2ede	; 0x2ede <_ZN14frt_text_queue7getcharEv>
    1192:	68 2f       	mov	r22, r24
    1194:	f8 01       	movw	r30, r16
    1196:	86 81       	ldd	r24, Z+6	; 0x06
    1198:	97 81       	ldd	r25, Z+7	; 0x07
    119a:	f7 01       	movw	r30, r14
    119c:	19 95       	eicall
    119e:	98 c0       	rjmp	.+304    	; 0x12d0 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    11a0:	86 81       	ldd	r24, Z+6	; 0x06
    11a2:	97 81       	ldd	r25, Z+7	; 0x07
    11a4:	dc 01       	movw	r26, r24
    11a6:	ed 91       	ld	r30, X+
    11a8:	fc 91       	ld	r31, X
    11aa:	04 80       	ldd	r0, Z+4	; 0x04
    11ac:	f5 81       	ldd	r31, Z+5	; 0x05
    11ae:	e0 2d       	mov	r30, r0
    11b0:	19 95       	eicall
    11b2:	88 23       	and	r24, r24
    11b4:	09 f4       	brne	.+2      	; 0x11b8 <_ZN9task_user3runEv+0x11c>
    11b6:	8c c0       	rjmp	.+280    	; 0x12d0 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    11b8:	f8 01       	movw	r30, r16
    11ba:	86 81       	ldd	r24, Z+6	; 0x06
    11bc:	97 81       	ldd	r25, Z+7	; 0x07
    11be:	dc 01       	movw	r26, r24
    11c0:	ed 91       	ld	r30, X+
    11c2:	fc 91       	ld	r31, X
    11c4:	06 80       	ldd	r0, Z+6	; 0x06
    11c6:	f7 81       	ldd	r31, Z+7	; 0x07
    11c8:	e0 2d       	mov	r30, r0
    11ca:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    11cc:	9c 01       	movw	r18, r24
    11ce:	33 27       	eor	r19, r19
    11d0:	28 36       	cpi	r18, 0x68	; 104
    11d2:	31 05       	cpc	r19, r1
    11d4:	59 f1       	breq	.+86     	; 0x122c <_ZN9task_user3runEv+0x190>
    11d6:	3c f4       	brge	.+14     	; 0x11e6 <_ZN9task_user3runEv+0x14a>
    11d8:	2b 31       	cpi	r18, 0x1B	; 27
    11da:	31 05       	cpc	r19, r1
    11dc:	59 f1       	breq	.+86     	; 0x1234 <_ZN9task_user3runEv+0x198>
    11de:	25 36       	cpi	r18, 0x65	; 101
    11e0:	31 05       	cpc	r19, r1
    11e2:	41 f1       	breq	.+80     	; 0x1234 <_ZN9task_user3runEv+0x198>
    11e4:	3b c0       	rjmp	.+118    	; 0x125c <_ZN9task_user3runEv+0x1c0>
    11e6:	23 37       	cpi	r18, 0x73	; 115
    11e8:	31 05       	cpc	r19, r1
    11ea:	c1 f0       	breq	.+48     	; 0x121c <_ZN9task_user3runEv+0x180>
    11ec:	26 37       	cpi	r18, 0x76	; 118
    11ee:	31 05       	cpc	r19, r1
    11f0:	89 f0       	breq	.+34     	; 0x1214 <_ZN9task_user3runEv+0x178>
    11f2:	2e 36       	cpi	r18, 0x6E	; 110
    11f4:	31 05       	cpc	r19, r1
    11f6:	91 f5       	brne	.+100    	; 0x125c <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    11f8:	ce 01       	movw	r24, r28
    11fa:	01 96       	adiw	r24, 0x01	; 1
    11fc:	0e 94 81 18 	call	0x3102	; 0x3102 <_ZN10time_stamp10set_to_nowEv>
    1200:	bc 01       	movw	r22, r24
    1202:	f8 01       	movw	r30, r16
    1204:	86 81       	ldd	r24, Z+6	; 0x06
    1206:	97 81       	ldd	r25, Z+7	; 0x07
    1208:	0e 94 25 18 	call	0x304a	; 0x304a <_ZlsR8emstreamR10time_stamp>
    120c:	66 e0       	ldi	r22, 0x06	; 6
    120e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
							break;
    1212:	5e c0       	rjmp	.+188    	; 0x12d0 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1214:	c8 01       	movw	r24, r16
    1216:	0e 94 c3 07 	call	0xf86	; 0xf86 <_ZN9task_user11show_statusEv>
							break;
    121a:	5a c0       	rjmp	.+180    	; 0x12d0 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    121c:	d8 01       	movw	r26, r16
    121e:	16 96       	adiw	r26, 0x06	; 6
    1220:	8d 91       	ld	r24, X+
    1222:	9c 91       	ld	r25, X
    1224:	17 97       	sbiw	r26, 0x07	; 7
    1226:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_Z17print_task_stacksP8emstream>
							break;
    122a:	52 c0       	rjmp	.+164    	; 0x12d0 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    122c:	c8 01       	movw	r24, r16
    122e:	0e 94 1b 07 	call	0xe36	; 0xe36 <_ZN9task_user18print_help_messageEv>
							break;
    1232:	4e c0       	rjmp	.+156    	; 0x12d0 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1234:	6a e0       	ldi	r22, 0x0A	; 10
    1236:	f8 01       	movw	r30, r16
    1238:	86 81       	ldd	r24, Z+6	; 0x06
    123a:	97 81       	ldd	r25, Z+7	; 0x07
    123c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1240:	7c 01       	movw	r14, r24
    1242:	66 e1       	ldi	r22, 0x16	; 22
    1244:	74 e0       	ldi	r23, 0x04	; 4
    1246:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    124a:	66 e0       	ldi	r22, 0x06	; 6
    124c:	c7 01       	movw	r24, r14
    124e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1252:	60 e0       	ldi	r22, 0x00	; 0
    1254:	c8 01       	movw	r24, r16
    1256:	0e 94 cc 14 	call	0x2998	; 0x2998 <_ZN8frt_task13transition_toEh>
							break;
    125a:	3a c0       	rjmp	.+116    	; 0x12d0 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    125c:	f8 01       	movw	r30, r16
    125e:	a6 81       	ldd	r26, Z+6	; 0x06
    1260:	b7 81       	ldd	r27, Z+7	; 0x07
    1262:	ed 91       	ld	r30, X+
    1264:	fc 91       	ld	r31, X
    1266:	11 97       	sbiw	r26, 0x01	; 1
    1268:	02 80       	ldd	r0, Z+2	; 0x02
    126a:	f3 81       	ldd	r31, Z+3	; 0x03
    126c:	e0 2d       	mov	r30, r0
    126e:	68 2f       	mov	r22, r24
    1270:	cd 01       	movw	r24, r26
    1272:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1274:	6a e0       	ldi	r22, 0x0A	; 10
    1276:	d8 01       	movw	r26, r16
    1278:	16 96       	adiw	r26, 0x06	; 6
    127a:	8d 91       	ld	r24, X+
    127c:	9c 91       	ld	r25, X
    127e:	17 97       	sbiw	r26, 0x07	; 7
    1280:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1284:	7c 01       	movw	r14, r24
    1286:	60 e1       	ldi	r22, 0x10	; 16
    1288:	74 e0       	ldi	r23, 0x04	; 4
    128a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    128e:	66 e0       	ldi	r22, 0x06	; 6
    1290:	c7 01       	movw	r24, r14
    1292:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
							break;
    1296:	1c c0       	rjmp	.+56     	; 0x12d0 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1298:	6a e0       	ldi	r22, 0x0A	; 10
    129a:	f8 01       	movw	r30, r16
    129c:	86 81       	ldd	r24, Z+6	; 0x06
    129e:	97 81       	ldd	r25, Z+7	; 0x07
    12a0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    12a4:	8c 01       	movw	r16, r24
    12a6:	63 ef       	ldi	r22, 0xF3	; 243
    12a8:	73 e0       	ldi	r23, 0x03	; 3
    12aa:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    12ae:	66 e0       	ldi	r22, 0x06	; 6
    12b0:	c8 01       	movw	r24, r16
    12b2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    12b6:	93 e0       	ldi	r25, 0x03	; 3
    12b8:	88 ed       	ldi	r24, 0xD8	; 216
    12ba:	08 b6       	in	r0, 0x38	; 56
    12bc:	18 be       	out	0x38, r1	; 56
    12be:	84 bf       	out	0x34, r24	; 52
    12c0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    12c4:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    12c8:	81 fd       	sbrc	r24, 1
    12ca:	fc cf       	rjmp	.-8      	; 0x12c4 <_ZN9task_user3runEv+0x228>
    12cc:	08 be       	out	0x38, r0	; 56
    12ce:	ff cf       	rjmp	.-2      	; 0x12ce <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    12d0:	f8 01       	movw	r30, r16
    12d2:	86 85       	ldd	r24, Z+14	; 0x0e
    12d4:	97 85       	ldd	r25, Z+15	; 0x0f
    12d6:	a0 89       	ldd	r26, Z+16	; 0x10
    12d8:	b1 89       	ldd	r27, Z+17	; 0x11
    12da:	01 96       	adiw	r24, 0x01	; 1
    12dc:	a1 1d       	adc	r26, r1
    12de:	b1 1d       	adc	r27, r1
    12e0:	86 87       	std	Z+14, r24	; 0x0e
    12e2:	97 87       	std	Z+15, r25	; 0x0f
    12e4:	a0 8b       	std	Z+16, r26	; 0x10
    12e6:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    12e8:	61 e0       	ldi	r22, 0x01	; 1
    12ea:	70 e0       	ldi	r23, 0x00	; 0
    12ec:	80 e0       	ldi	r24, 0x00	; 0
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	0e 94 a0 12 	call	0x2540	; 0x2540 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    12f4:	f1 ce       	rjmp	.-542    	; 0x10d8 <_ZN9task_user3runEv+0x3c>

000012f6 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    12f6:	0f 93       	push	r16
    12f8:	1f 93       	push	r17
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1300:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1304:	80 91 e2 20 	lds	r24, 0x20E2	; 0x8020e2 <__data_end>
    1308:	81 11       	cpse	r24, r1
    130a:	1d c0       	rjmp	.+58     	; 0x1346 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    130c:	a7 ee       	ldi	r26, 0xE7	; 231
    130e:	b0 e2       	ldi	r27, 0x20	; 32
    1310:	eb ee       	ldi	r30, 0xEB	; 235
    1312:	f0 e2       	ldi	r31, 0x20	; 32
    1314:	ed 93       	st	X+, r30
    1316:	fc 93       	st	X, r31
    1318:	11 97       	sbiw	r26, 0x01	; 1
    131a:	12 96       	adiw	r26, 0x02	; 2
    131c:	1d 92       	st	X+, r1
    131e:	1c 92       	st	X, r1
    1320:	13 97       	sbiw	r26, 0x03	; 3
    1322:	a3 ee       	ldi	r26, 0xE3	; 227
    1324:	b0 e2       	ldi	r27, 0x20	; 32
    1326:	8f ef       	ldi	r24, 0xFF	; 255
    1328:	9f e0       	ldi	r25, 0x0F	; 15
    132a:	12 96       	adiw	r26, 0x02	; 2
    132c:	8d 93       	st	X+, r24
    132e:	9c 93       	st	X, r25
    1330:	13 97       	sbiw	r26, 0x03	; 3
    1332:	1d 92       	st	X+, r1
    1334:	1c 92       	st	X, r1
    1336:	11 97       	sbiw	r26, 0x01	; 1
    1338:	82 83       	std	Z+2, r24	; 0x02
    133a:	93 83       	std	Z+3, r25	; 0x03
    133c:	a0 83       	st	Z, r26
    133e:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	80 93 e2 20 	sts	0x20E2, r24	; 0x8020e2 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1346:	20 97       	sbiw	r28, 0x00	; 0
    1348:	09 f4       	brne	.+2      	; 0x134c <pvPortMalloc+0x56>
    134a:	5f c0       	rjmp	.+190    	; 0x140a <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    134c:	9e 01       	movw	r18, r28
    134e:	2b 5f       	subi	r18, 0xFB	; 251
    1350:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1352:	24 96       	adiw	r28, 0x04	; 4
    1354:	ce 3f       	cpi	r28, 0xFE	; 254
    1356:	df 40       	sbci	r29, 0x0F	; 15
    1358:	08 f0       	brcs	.+2      	; 0x135c <pvPortMalloc+0x66>
    135a:	5a c0       	rjmp	.+180    	; 0x1410 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    135c:	e0 91 e7 20 	lds	r30, 0x20E7	; 0x8020e7 <xStart>
    1360:	f0 91 e8 20 	lds	r31, 0x20E8	; 0x8020e8 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1364:	a7 ee       	ldi	r26, 0xE7	; 231
    1366:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1368:	02 c0       	rjmp	.+4      	; 0x136e <pvPortMalloc+0x78>
    136a:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    136c:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    136e:	82 81       	ldd	r24, Z+2	; 0x02
    1370:	93 81       	ldd	r25, Z+3	; 0x03
    1372:	82 17       	cp	r24, r18
    1374:	93 07       	cpc	r25, r19
    1376:	20 f4       	brcc	.+8      	; 0x1380 <pvPortMalloc+0x8a>
    1378:	80 81       	ld	r24, Z
    137a:	91 81       	ldd	r25, Z+1	; 0x01
    137c:	00 97       	sbiw	r24, 0x00	; 0
    137e:	a9 f7       	brne	.-22     	; 0x136a <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1380:	c0 e2       	ldi	r28, 0x20	; 32
    1382:	e3 3e       	cpi	r30, 0xE3	; 227
    1384:	fc 07       	cpc	r31, r28
    1386:	09 f4       	brne	.+2      	; 0x138a <pvPortMalloc+0x94>
    1388:	46 c0       	rjmp	.+140    	; 0x1416 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    138a:	cd 91       	ld	r28, X+
    138c:	dc 91       	ld	r29, X
    138e:	11 97       	sbiw	r26, 0x01	; 1
    1390:	8e 01       	movw	r16, r28
    1392:	0b 5f       	subi	r16, 0xFB	; 251
    1394:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1396:	80 81       	ld	r24, Z
    1398:	91 81       	ldd	r25, Z+1	; 0x01
    139a:	8d 93       	st	X+, r24
    139c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    139e:	82 81       	ldd	r24, Z+2	; 0x02
    13a0:	93 81       	ldd	r25, Z+3	; 0x03
    13a2:	82 1b       	sub	r24, r18
    13a4:	93 0b       	sbc	r25, r19
    13a6:	8b 30       	cpi	r24, 0x0B	; 11
    13a8:	91 05       	cpc	r25, r1
    13aa:	10 f1       	brcs	.+68     	; 0x13f0 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    13ac:	bf 01       	movw	r22, r30
    13ae:	62 0f       	add	r22, r18
    13b0:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    13b2:	db 01       	movw	r26, r22
    13b4:	12 96       	adiw	r26, 0x02	; 2
    13b6:	8d 93       	st	X+, r24
    13b8:	9c 93       	st	X, r25
    13ba:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    13bc:	22 83       	std	Z+2, r18	; 0x02
    13be:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    13c0:	12 96       	adiw	r26, 0x02	; 2
    13c2:	4d 91       	ld	r20, X+
    13c4:	5c 91       	ld	r21, X
    13c6:	13 97       	sbiw	r26, 0x03	; 3
    13c8:	87 ee       	ldi	r24, 0xE7	; 231
    13ca:	90 e2       	ldi	r25, 0x20	; 32
    13cc:	01 c0       	rjmp	.+2      	; 0x13d0 <pvPortMalloc+0xda>
    13ce:	cd 01       	movw	r24, r26
    13d0:	ec 01       	movw	r28, r24
    13d2:	a8 81       	ld	r26, Y
    13d4:	b9 81       	ldd	r27, Y+1	; 0x01
    13d6:	12 96       	adiw	r26, 0x02	; 2
    13d8:	2d 91       	ld	r18, X+
    13da:	3c 91       	ld	r19, X
    13dc:	13 97       	sbiw	r26, 0x03	; 3
    13de:	24 17       	cp	r18, r20
    13e0:	35 07       	cpc	r19, r21
    13e2:	a8 f3       	brcs	.-22     	; 0x13ce <pvPortMalloc+0xd8>
    13e4:	eb 01       	movw	r28, r22
    13e6:	a8 83       	st	Y, r26
    13e8:	b9 83       	std	Y+1, r27	; 0x01
    13ea:	dc 01       	movw	r26, r24
    13ec:	6d 93       	st	X+, r22
    13ee:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    13f0:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    13f4:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    13f8:	22 81       	ldd	r18, Z+2	; 0x02
    13fa:	33 81       	ldd	r19, Z+3	; 0x03
    13fc:	82 1b       	sub	r24, r18
    13fe:	93 0b       	sbc	r25, r19
    1400:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1404:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1408:	08 c0       	rjmp	.+16     	; 0x141a <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    140a:	00 e0       	ldi	r16, 0x00	; 0
    140c:	10 e0       	ldi	r17, 0x00	; 0
    140e:	05 c0       	rjmp	.+10     	; 0x141a <pvPortMalloc+0x124>
    1410:	00 e0       	ldi	r16, 0x00	; 0
    1412:	10 e0       	ldi	r17, 0x00	; 0
    1414:	02 c0       	rjmp	.+4      	; 0x141a <pvPortMalloc+0x124>
    1416:	00 e0       	ldi	r16, 0x00	; 0
    1418:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    141a:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    141e:	c8 01       	movw	r24, r16
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	1f 91       	pop	r17
    1426:	0f 91       	pop	r16
    1428:	08 95       	ret

0000142a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    142a:	0f 93       	push	r16
    142c:	1f 93       	push	r17
    142e:	cf 93       	push	r28
    1430:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1432:	00 97       	sbiw	r24, 0x00	; 0
    1434:	41 f1       	breq	.+80     	; 0x1486 <vPortFree+0x5c>
    1436:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1438:	8c 01       	movw	r16, r24
    143a:	05 50       	subi	r16, 0x05	; 5
    143c:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    143e:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1442:	f8 01       	movw	r30, r16
    1444:	42 81       	ldd	r20, Z+2	; 0x02
    1446:	53 81       	ldd	r21, Z+3	; 0x03
    1448:	a7 ee       	ldi	r26, 0xE7	; 231
    144a:	b0 e2       	ldi	r27, 0x20	; 32
    144c:	01 c0       	rjmp	.+2      	; 0x1450 <vPortFree+0x26>
    144e:	df 01       	movw	r26, r30
    1450:	ed 91       	ld	r30, X+
    1452:	fc 91       	ld	r31, X
    1454:	11 97       	sbiw	r26, 0x01	; 1
    1456:	22 81       	ldd	r18, Z+2	; 0x02
    1458:	33 81       	ldd	r19, Z+3	; 0x03
    145a:	24 17       	cp	r18, r20
    145c:	35 07       	cpc	r19, r21
    145e:	b8 f3       	brcs	.-18     	; 0x144e <vPortFree+0x24>
    1460:	25 97       	sbiw	r28, 0x05	; 5
    1462:	e8 83       	st	Y, r30
    1464:	f9 83       	std	Y+1, r31	; 0x01
    1466:	0d 93       	st	X+, r16
    1468:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    146a:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    146e:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1472:	8a 81       	ldd	r24, Y+2	; 0x02
    1474:	9b 81       	ldd	r25, Y+3	; 0x03
    1476:	82 0f       	add	r24, r18
    1478:	93 1f       	adc	r25, r19
    147a:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    147e:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1482:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
	}
}
    1486:	df 91       	pop	r29
    1488:	cf 91       	pop	r28
    148a:	1f 91       	pop	r17
    148c:	0f 91       	pop	r16
    148e:	08 95       	ret

00001490 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1490:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1494:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1498:	08 95       	ret

0000149a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    149a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    149c:	03 96       	adiw	r24, 0x03	; 3
    149e:	81 83       	std	Z+1, r24	; 0x01
    14a0:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    14a2:	4f ef       	ldi	r20, 0xFF	; 255
    14a4:	5f ef       	ldi	r21, 0xFF	; 255
    14a6:	ba 01       	movw	r22, r20
    14a8:	43 83       	std	Z+3, r20	; 0x03
    14aa:	54 83       	std	Z+4, r21	; 0x04
    14ac:	65 83       	std	Z+5, r22	; 0x05
    14ae:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    14b0:	87 83       	std	Z+7, r24	; 0x07
    14b2:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    14b4:	81 87       	std	Z+9, r24	; 0x09
    14b6:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    14b8:	10 82       	st	Z, r1
    14ba:	08 95       	ret

000014bc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    14bc:	fc 01       	movw	r30, r24
    14be:	12 86       	std	Z+10, r1	; 0x0a
    14c0:	13 86       	std	Z+11, r1	; 0x0b
    14c2:	08 95       	ret

000014c4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    14c4:	cf 93       	push	r28
    14c6:	df 93       	push	r29
    14c8:	fc 01       	movw	r30, r24
    14ca:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    14cc:	21 81       	ldd	r18, Z+1	; 0x01
    14ce:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    14d0:	e9 01       	movw	r28, r18
    14d2:	8c 81       	ldd	r24, Y+4	; 0x04
    14d4:	9d 81       	ldd	r25, Y+5	; 0x05
    14d6:	14 96       	adiw	r26, 0x04	; 4
    14d8:	8d 93       	st	X+, r24
    14da:	9c 93       	st	X, r25
    14dc:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    14de:	81 81       	ldd	r24, Z+1	; 0x01
    14e0:	92 81       	ldd	r25, Z+2	; 0x02
    14e2:	16 96       	adiw	r26, 0x06	; 6
    14e4:	8d 93       	st	X+, r24
    14e6:	9c 93       	st	X, r25
    14e8:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    14ea:	8c 81       	ldd	r24, Y+4	; 0x04
    14ec:	9d 81       	ldd	r25, Y+5	; 0x05
    14ee:	ec 01       	movw	r28, r24
    14f0:	6e 83       	std	Y+6, r22	; 0x06
    14f2:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    14f4:	e9 01       	movw	r28, r18
    14f6:	6c 83       	std	Y+4, r22	; 0x04
    14f8:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    14fa:	61 83       	std	Z+1, r22	; 0x01
    14fc:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14fe:	1a 96       	adiw	r26, 0x0a	; 10
    1500:	ed 93       	st	X+, r30
    1502:	fc 93       	st	X, r31
    1504:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1506:	80 81       	ld	r24, Z
    1508:	8f 5f       	subi	r24, 0xFF	; 255
    150a:	80 83       	st	Z, r24
}
    150c:	df 91       	pop	r29
    150e:	cf 91       	pop	r28
    1510:	08 95       	ret

00001512 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1512:	0f 93       	push	r16
    1514:	1f 93       	push	r17
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
    151a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    151c:	08 81       	ld	r16, Y
    151e:	19 81       	ldd	r17, Y+1	; 0x01
    1520:	2a 81       	ldd	r18, Y+2	; 0x02
    1522:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1524:	0f 3f       	cpi	r16, 0xFF	; 255
    1526:	4f ef       	ldi	r20, 0xFF	; 255
    1528:	14 07       	cpc	r17, r20
    152a:	24 07       	cpc	r18, r20
    152c:	34 07       	cpc	r19, r20
    152e:	31 f4       	brne	.+12     	; 0x153c <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1530:	dc 01       	movw	r26, r24
    1532:	19 96       	adiw	r26, 0x09	; 9
    1534:	ed 91       	ld	r30, X+
    1536:	fc 91       	ld	r31, X
    1538:	1a 97       	sbiw	r26, 0x0a	; 10
    153a:	1f c0       	rjmp	.+62     	; 0x157a <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    153c:	fc 01       	movw	r30, r24
    153e:	33 96       	adiw	r30, 0x03	; 3
    1540:	dc 01       	movw	r26, r24
    1542:	17 96       	adiw	r26, 0x07	; 7
    1544:	4d 91       	ld	r20, X+
    1546:	5c 91       	ld	r21, X
    1548:	18 97       	sbiw	r26, 0x08	; 8
    154a:	da 01       	movw	r26, r20
    154c:	4d 91       	ld	r20, X+
    154e:	5d 91       	ld	r21, X+
    1550:	6d 91       	ld	r22, X+
    1552:	7c 91       	ld	r23, X
    1554:	04 17       	cp	r16, r20
    1556:	15 07       	cpc	r17, r21
    1558:	26 07       	cpc	r18, r22
    155a:	37 07       	cpc	r19, r23
    155c:	70 f0       	brcs	.+28     	; 0x157a <vListInsert+0x68>
    155e:	04 80       	ldd	r0, Z+4	; 0x04
    1560:	f5 81       	ldd	r31, Z+5	; 0x05
    1562:	e0 2d       	mov	r30, r0
    1564:	a4 81       	ldd	r26, Z+4	; 0x04
    1566:	b5 81       	ldd	r27, Z+5	; 0x05
    1568:	4d 91       	ld	r20, X+
    156a:	5d 91       	ld	r21, X+
    156c:	6d 91       	ld	r22, X+
    156e:	7c 91       	ld	r23, X
    1570:	04 17       	cp	r16, r20
    1572:	15 07       	cpc	r17, r21
    1574:	26 07       	cpc	r18, r22
    1576:	37 07       	cpc	r19, r23
    1578:	90 f7       	brcc	.-28     	; 0x155e <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    157a:	a4 81       	ldd	r26, Z+4	; 0x04
    157c:	b5 81       	ldd	r27, Z+5	; 0x05
    157e:	ac 83       	std	Y+4, r26	; 0x04
    1580:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1582:	16 96       	adiw	r26, 0x06	; 6
    1584:	cd 93       	st	X+, r28
    1586:	dc 93       	st	X, r29
    1588:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    158a:	ee 83       	std	Y+6, r30	; 0x06
    158c:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    158e:	c4 83       	std	Z+4, r28	; 0x04
    1590:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1592:	8a 87       	std	Y+10, r24	; 0x0a
    1594:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1596:	fc 01       	movw	r30, r24
    1598:	20 81       	ld	r18, Z
    159a:	2f 5f       	subi	r18, 0xFF	; 255
    159c:	20 83       	st	Z, r18
}
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	1f 91       	pop	r17
    15a4:	0f 91       	pop	r16
    15a6:	08 95       	ret

000015a8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    15a8:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    15aa:	a4 81       	ldd	r26, Z+4	; 0x04
    15ac:	b5 81       	ldd	r27, Z+5	; 0x05
    15ae:	86 81       	ldd	r24, Z+6	; 0x06
    15b0:	97 81       	ldd	r25, Z+7	; 0x07
    15b2:	16 96       	adiw	r26, 0x06	; 6
    15b4:	8d 93       	st	X+, r24
    15b6:	9c 93       	st	X, r25
    15b8:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    15ba:	a6 81       	ldd	r26, Z+6	; 0x06
    15bc:	b7 81       	ldd	r27, Z+7	; 0x07
    15be:	84 81       	ldd	r24, Z+4	; 0x04
    15c0:	95 81       	ldd	r25, Z+5	; 0x05
    15c2:	14 96       	adiw	r26, 0x04	; 4
    15c4:	8d 93       	st	X+, r24
    15c6:	9c 93       	st	X, r25
    15c8:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    15ca:	a2 85       	ldd	r26, Z+10	; 0x0a
    15cc:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    15ce:	11 96       	adiw	r26, 0x01	; 1
    15d0:	8d 91       	ld	r24, X+
    15d2:	9c 91       	ld	r25, X
    15d4:	12 97       	sbiw	r26, 0x02	; 2
    15d6:	e8 17       	cp	r30, r24
    15d8:	f9 07       	cpc	r31, r25
    15da:	31 f4       	brne	.+12     	; 0x15e8 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    15dc:	86 81       	ldd	r24, Z+6	; 0x06
    15de:	97 81       	ldd	r25, Z+7	; 0x07
    15e0:	11 96       	adiw	r26, 0x01	; 1
    15e2:	8d 93       	st	X+, r24
    15e4:	9c 93       	st	X, r25
    15e6:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    15e8:	12 86       	std	Z+10, r1	; 0x0a
    15ea:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    15ec:	8c 91       	ld	r24, X
    15ee:	81 50       	subi	r24, 0x01	; 1
    15f0:	8c 93       	st	X, r24
    15f2:	08 95       	ret

000015f4 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    15f4:	80 93 86 31 	sts	0x3186, r24	; 0x803186 <portStackTopForTask>
    15f8:	90 93 87 31 	sts	0x3187, r25	; 0x803187 <portStackTopForTask+0x1>
    15fc:	31 e1       	ldi	r19, 0x11	; 17
    15fe:	fc 01       	movw	r30, r24
    1600:	30 83       	st	Z, r19
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	22 e2       	ldi	r18, 0x22	; 34
    1606:	20 83       	st	Z, r18
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	a3 e3       	ldi	r26, 0x33	; 51
    160c:	a0 83       	st	Z, r26
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	60 83       	st	Z, r22
    1612:	31 97       	sbiw	r30, 0x01	; 1
    1614:	70 83       	st	Z, r23
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	10 82       	st	Z, r1
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	10 82       	st	Z, r1
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	60 e8       	ldi	r22, 0x80	; 128
    1622:	60 83       	st	Z, r22
    1624:	31 97       	sbiw	r30, 0x01	; 1
    1626:	10 82       	st	Z, r1
    1628:	31 97       	sbiw	r30, 0x01	; 1
    162a:	10 82       	st	Z, r1
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	10 82       	st	Z, r1
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	62 e0       	ldi	r22, 0x02	; 2
    1634:	60 83       	st	Z, r22
    1636:	31 97       	sbiw	r30, 0x01	; 1
    1638:	63 e0       	ldi	r22, 0x03	; 3
    163a:	60 83       	st	Z, r22
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	64 e0       	ldi	r22, 0x04	; 4
    1640:	60 83       	st	Z, r22
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	65 e0       	ldi	r22, 0x05	; 5
    1646:	60 83       	st	Z, r22
    1648:	31 97       	sbiw	r30, 0x01	; 1
    164a:	66 e0       	ldi	r22, 0x06	; 6
    164c:	60 83       	st	Z, r22
    164e:	31 97       	sbiw	r30, 0x01	; 1
    1650:	67 e0       	ldi	r22, 0x07	; 7
    1652:	60 83       	st	Z, r22
    1654:	31 97       	sbiw	r30, 0x01	; 1
    1656:	68 e0       	ldi	r22, 0x08	; 8
    1658:	60 83       	st	Z, r22
    165a:	31 97       	sbiw	r30, 0x01	; 1
    165c:	69 e0       	ldi	r22, 0x09	; 9
    165e:	60 83       	st	Z, r22
    1660:	31 97       	sbiw	r30, 0x01	; 1
    1662:	60 e1       	ldi	r22, 0x10	; 16
    1664:	60 83       	st	Z, r22
    1666:	31 97       	sbiw	r30, 0x01	; 1
    1668:	30 83       	st	Z, r19
    166a:	31 97       	sbiw	r30, 0x01	; 1
    166c:	32 e1       	ldi	r19, 0x12	; 18
    166e:	30 83       	st	Z, r19
    1670:	31 97       	sbiw	r30, 0x01	; 1
    1672:	33 e1       	ldi	r19, 0x13	; 19
    1674:	30 83       	st	Z, r19
    1676:	31 97       	sbiw	r30, 0x01	; 1
    1678:	34 e1       	ldi	r19, 0x14	; 20
    167a:	30 83       	st	Z, r19
    167c:	31 97       	sbiw	r30, 0x01	; 1
    167e:	35 e1       	ldi	r19, 0x15	; 21
    1680:	30 83       	st	Z, r19
    1682:	31 97       	sbiw	r30, 0x01	; 1
    1684:	36 e1       	ldi	r19, 0x16	; 22
    1686:	30 83       	st	Z, r19
    1688:	31 97       	sbiw	r30, 0x01	; 1
    168a:	37 e1       	ldi	r19, 0x17	; 23
    168c:	30 83       	st	Z, r19
    168e:	31 97       	sbiw	r30, 0x01	; 1
    1690:	38 e1       	ldi	r19, 0x18	; 24
    1692:	30 83       	st	Z, r19
    1694:	31 97       	sbiw	r30, 0x01	; 1
    1696:	39 e1       	ldi	r19, 0x19	; 25
    1698:	30 83       	st	Z, r19
    169a:	31 97       	sbiw	r30, 0x01	; 1
    169c:	30 e2       	ldi	r19, 0x20	; 32
    169e:	30 83       	st	Z, r19
    16a0:	31 97       	sbiw	r30, 0x01	; 1
    16a2:	31 e2       	ldi	r19, 0x21	; 33
    16a4:	30 83       	st	Z, r19
    16a6:	31 97       	sbiw	r30, 0x01	; 1
    16a8:	20 83       	st	Z, r18
    16aa:	31 97       	sbiw	r30, 0x01	; 1
    16ac:	23 e2       	ldi	r18, 0x23	; 35
    16ae:	20 83       	st	Z, r18
    16b0:	31 97       	sbiw	r30, 0x01	; 1
    16b2:	40 83       	st	Z, r20
    16b4:	31 97       	sbiw	r30, 0x01	; 1
    16b6:	50 83       	st	Z, r21
    16b8:	31 97       	sbiw	r30, 0x01	; 1
    16ba:	26 e2       	ldi	r18, 0x26	; 38
    16bc:	20 83       	st	Z, r18
    16be:	31 97       	sbiw	r30, 0x01	; 1
    16c0:	27 e2       	ldi	r18, 0x27	; 39
    16c2:	20 83       	st	Z, r18
    16c4:	31 97       	sbiw	r30, 0x01	; 1
    16c6:	28 e2       	ldi	r18, 0x28	; 40
    16c8:	20 83       	st	Z, r18
    16ca:	31 97       	sbiw	r30, 0x01	; 1
    16cc:	29 e2       	ldi	r18, 0x29	; 41
    16ce:	20 83       	st	Z, r18
    16d0:	31 97       	sbiw	r30, 0x01	; 1
    16d2:	20 e3       	ldi	r18, 0x30	; 48
    16d4:	20 83       	st	Z, r18
    16d6:	31 97       	sbiw	r30, 0x01	; 1
    16d8:	21 e3       	ldi	r18, 0x31	; 49
    16da:	20 83       	st	Z, r18
    16dc:	89 97       	sbiw	r24, 0x29	; 41
    16de:	08 95       	ret

000016e0 <xPortStartScheduler>:
    16e0:	8c e7       	ldi	r24, 0x7C	; 124
    16e2:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    16e6:	8f ef       	ldi	r24, 0xFF	; 255
    16e8:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    16ec:	81 e0       	ldi	r24, 0x01	; 1
    16ee:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    16f2:	91 e1       	ldi	r25, 0x11	; 17
    16f4:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    16f8:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    16fc:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    1700:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1704:	cd 91       	ld	r28, X+
    1706:	cd bf       	out	0x3d, r28	; 61
    1708:	dd 91       	ld	r29, X+
    170a:	de bf       	out	0x3e, r29	; 62
    170c:	ff 91       	pop	r31
    170e:	ef 91       	pop	r30
    1710:	df 91       	pop	r29
    1712:	cf 91       	pop	r28
    1714:	bf 91       	pop	r27
    1716:	af 91       	pop	r26
    1718:	9f 91       	pop	r25
    171a:	8f 91       	pop	r24
    171c:	7f 91       	pop	r23
    171e:	6f 91       	pop	r22
    1720:	5f 91       	pop	r21
    1722:	4f 91       	pop	r20
    1724:	3f 91       	pop	r19
    1726:	2f 91       	pop	r18
    1728:	1f 91       	pop	r17
    172a:	0f 91       	pop	r16
    172c:	ff 90       	pop	r15
    172e:	ef 90       	pop	r14
    1730:	df 90       	pop	r13
    1732:	cf 90       	pop	r12
    1734:	bf 90       	pop	r11
    1736:	af 90       	pop	r10
    1738:	9f 90       	pop	r9
    173a:	8f 90       	pop	r8
    173c:	7f 90       	pop	r7
    173e:	6f 90       	pop	r6
    1740:	5f 90       	pop	r5
    1742:	4f 90       	pop	r4
    1744:	3f 90       	pop	r3
    1746:	2f 90       	pop	r2
    1748:	1f 90       	pop	r1
    174a:	0f 90       	pop	r0
    174c:	0c be       	out	0x3c, r0	; 60
    174e:	0f 90       	pop	r0
    1750:	0b be       	out	0x3b, r0	; 59
    1752:	0f 90       	pop	r0
    1754:	0f be       	out	0x3f, r0	; 63
    1756:	0f 90       	pop	r0
    1758:	08 95       	ret
    175a:	08 95       	ret

0000175c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    175c:	0f 92       	push	r0
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	0f 92       	push	r0
    1764:	0b b6       	in	r0, 0x3b	; 59
    1766:	0f 92       	push	r0
    1768:	0c b6       	in	r0, 0x3c	; 60
    176a:	0f 92       	push	r0
    176c:	1f 92       	push	r1
    176e:	11 24       	eor	r1, r1
    1770:	2f 92       	push	r2
    1772:	3f 92       	push	r3
    1774:	4f 92       	push	r4
    1776:	5f 92       	push	r5
    1778:	6f 92       	push	r6
    177a:	7f 92       	push	r7
    177c:	8f 92       	push	r8
    177e:	9f 92       	push	r9
    1780:	af 92       	push	r10
    1782:	bf 92       	push	r11
    1784:	cf 92       	push	r12
    1786:	df 92       	push	r13
    1788:	ef 92       	push	r14
    178a:	ff 92       	push	r15
    178c:	0f 93       	push	r16
    178e:	1f 93       	push	r17
    1790:	2f 93       	push	r18
    1792:	3f 93       	push	r19
    1794:	4f 93       	push	r20
    1796:	5f 93       	push	r21
    1798:	6f 93       	push	r22
    179a:	7f 93       	push	r23
    179c:	8f 93       	push	r24
    179e:	9f 93       	push	r25
    17a0:	af 93       	push	r26
    17a2:	bf 93       	push	r27
    17a4:	cf 93       	push	r28
    17a6:	df 93       	push	r29
    17a8:	ef 93       	push	r30
    17aa:	ff 93       	push	r31
    17ac:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    17b0:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    17b4:	0d b6       	in	r0, 0x3d	; 61
    17b6:	0d 92       	st	X+, r0
    17b8:	0e b6       	in	r0, 0x3e	; 62
    17ba:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    17bc:	0e 94 ce 12 	call	0x259c	; 0x259c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17c0:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    17c4:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    17c8:	cd 91       	ld	r28, X+
    17ca:	cd bf       	out	0x3d, r28	; 61
    17cc:	dd 91       	ld	r29, X+
    17ce:	de bf       	out	0x3e, r29	; 62
    17d0:	ff 91       	pop	r31
    17d2:	ef 91       	pop	r30
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	bf 91       	pop	r27
    17da:	af 91       	pop	r26
    17dc:	9f 91       	pop	r25
    17de:	8f 91       	pop	r24
    17e0:	7f 91       	pop	r23
    17e2:	6f 91       	pop	r22
    17e4:	5f 91       	pop	r21
    17e6:	4f 91       	pop	r20
    17e8:	3f 91       	pop	r19
    17ea:	2f 91       	pop	r18
    17ec:	1f 91       	pop	r17
    17ee:	0f 91       	pop	r16
    17f0:	ff 90       	pop	r15
    17f2:	ef 90       	pop	r14
    17f4:	df 90       	pop	r13
    17f6:	cf 90       	pop	r12
    17f8:	bf 90       	pop	r11
    17fa:	af 90       	pop	r10
    17fc:	9f 90       	pop	r9
    17fe:	8f 90       	pop	r8
    1800:	7f 90       	pop	r7
    1802:	6f 90       	pop	r6
    1804:	5f 90       	pop	r5
    1806:	4f 90       	pop	r4
    1808:	3f 90       	pop	r3
    180a:	2f 90       	pop	r2
    180c:	1f 90       	pop	r1
    180e:	0f 90       	pop	r0
    1810:	0c be       	out	0x3c, r0	; 60
    1812:	0f 90       	pop	r0
    1814:	0b be       	out	0x3b, r0	; 59
    1816:	0f 90       	pop	r0
    1818:	0f be       	out	0x3f, r0	; 63
    181a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    181c:	08 95       	ret

0000181e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    181e:	0f 92       	push	r0
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	f8 94       	cli
    1824:	0f 92       	push	r0
    1826:	0b b6       	in	r0, 0x3b	; 59
    1828:	0f 92       	push	r0
    182a:	0c b6       	in	r0, 0x3c	; 60
    182c:	0f 92       	push	r0
    182e:	1f 92       	push	r1
    1830:	11 24       	eor	r1, r1
    1832:	2f 92       	push	r2
    1834:	3f 92       	push	r3
    1836:	4f 92       	push	r4
    1838:	5f 92       	push	r5
    183a:	6f 92       	push	r6
    183c:	7f 92       	push	r7
    183e:	8f 92       	push	r8
    1840:	9f 92       	push	r9
    1842:	af 92       	push	r10
    1844:	bf 92       	push	r11
    1846:	cf 92       	push	r12
    1848:	df 92       	push	r13
    184a:	ef 92       	push	r14
    184c:	ff 92       	push	r15
    184e:	0f 93       	push	r16
    1850:	1f 93       	push	r17
    1852:	2f 93       	push	r18
    1854:	3f 93       	push	r19
    1856:	4f 93       	push	r20
    1858:	5f 93       	push	r21
    185a:	6f 93       	push	r22
    185c:	7f 93       	push	r23
    185e:	8f 93       	push	r24
    1860:	9f 93       	push	r25
    1862:	af 93       	push	r26
    1864:	bf 93       	push	r27
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	ef 93       	push	r30
    186c:	ff 93       	push	r31
    186e:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    1872:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1876:	0d b6       	in	r0, 0x3d	; 61
    1878:	0d 92       	st	X+, r0
    187a:	0e b6       	in	r0, 0x3e	; 62
    187c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    187e:	0e 94 b0 10 	call	0x2160	; 0x2160 <vTaskIncrementTick>
	vTaskSwitchContext();
    1882:	0e 94 ce 12 	call	0x259c	; 0x259c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1886:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    188a:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    188e:	cd 91       	ld	r28, X+
    1890:	cd bf       	out	0x3d, r28	; 61
    1892:	dd 91       	ld	r29, X+
    1894:	de bf       	out	0x3e, r29	; 62
    1896:	ff 91       	pop	r31
    1898:	ef 91       	pop	r30
    189a:	df 91       	pop	r29
    189c:	cf 91       	pop	r28
    189e:	bf 91       	pop	r27
    18a0:	af 91       	pop	r26
    18a2:	9f 91       	pop	r25
    18a4:	8f 91       	pop	r24
    18a6:	7f 91       	pop	r23
    18a8:	6f 91       	pop	r22
    18aa:	5f 91       	pop	r21
    18ac:	4f 91       	pop	r20
    18ae:	3f 91       	pop	r19
    18b0:	2f 91       	pop	r18
    18b2:	1f 91       	pop	r17
    18b4:	0f 91       	pop	r16
    18b6:	ff 90       	pop	r15
    18b8:	ef 90       	pop	r14
    18ba:	df 90       	pop	r13
    18bc:	cf 90       	pop	r12
    18be:	bf 90       	pop	r11
    18c0:	af 90       	pop	r10
    18c2:	9f 90       	pop	r9
    18c4:	8f 90       	pop	r8
    18c6:	7f 90       	pop	r7
    18c8:	6f 90       	pop	r6
    18ca:	5f 90       	pop	r5
    18cc:	4f 90       	pop	r4
    18ce:	3f 90       	pop	r3
    18d0:	2f 90       	pop	r2
    18d2:	1f 90       	pop	r1
    18d4:	0f 90       	pop	r0
    18d6:	0c be       	out	0x3c, r0	; 60
    18d8:	0f 90       	pop	r0
    18da:	0b be       	out	0x3b, r0	; 59
    18dc:	0f 90       	pop	r0
    18de:	0f be       	out	0x3f, r0	; 63
    18e0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18e2:	08 95       	ret

000018e4 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    18e4:	0e 94 0f 0c 	call	0x181e	; 0x181e <vPortYieldFromTick>
		asm volatile ( "reti" );
    18e8:	18 95       	reti

000018ea <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18ea:	cf 93       	push	r28
    18ec:	df 93       	push	r29
    18ee:	ec 01       	movw	r28, r24
    18f0:	88 a1       	ldd	r24, Y+32	; 0x20
    18f2:	81 11       	cpse	r24, r1
    18f4:	0b c0       	rjmp	.+22     	; 0x190c <prvCopyDataToQueue+0x22>
    18f6:	88 81       	ld	r24, Y
    18f8:	99 81       	ldd	r25, Y+1	; 0x01
    18fa:	89 2b       	or	r24, r25
    18fc:	e1 f5       	brne	.+120    	; 0x1976 <prvCopyDataToQueue+0x8c>
    18fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1900:	9b 81       	ldd	r25, Y+3	; 0x03
    1902:	0e 94 89 14 	call	0x2912	; 0x2912 <vTaskPriorityDisinherit>
    1906:	1a 82       	std	Y+2, r1	; 0x02
    1908:	1b 82       	std	Y+3, r1	; 0x03
    190a:	35 c0       	rjmp	.+106    	; 0x1976 <prvCopyDataToQueue+0x8c>
    190c:	41 11       	cpse	r20, r1
    190e:	17 c0       	rjmp	.+46     	; 0x193e <prvCopyDataToQueue+0x54>
    1910:	48 2f       	mov	r20, r24
    1912:	50 e0       	ldi	r21, 0x00	; 0
    1914:	8c 81       	ldd	r24, Y+4	; 0x04
    1916:	9d 81       	ldd	r25, Y+5	; 0x05
    1918:	0e 94 60 20 	call	0x40c0	; 0x40c0 <memcpy>
    191c:	28 a1       	ldd	r18, Y+32	; 0x20
    191e:	8c 81       	ldd	r24, Y+4	; 0x04
    1920:	9d 81       	ldd	r25, Y+5	; 0x05
    1922:	82 0f       	add	r24, r18
    1924:	91 1d       	adc	r25, r1
    1926:	8c 83       	std	Y+4, r24	; 0x04
    1928:	9d 83       	std	Y+5, r25	; 0x05
    192a:	2a 81       	ldd	r18, Y+2	; 0x02
    192c:	3b 81       	ldd	r19, Y+3	; 0x03
    192e:	82 17       	cp	r24, r18
    1930:	93 07       	cpc	r25, r19
    1932:	08 f1       	brcs	.+66     	; 0x1976 <prvCopyDataToQueue+0x8c>
    1934:	88 81       	ld	r24, Y
    1936:	99 81       	ldd	r25, Y+1	; 0x01
    1938:	8c 83       	std	Y+4, r24	; 0x04
    193a:	9d 83       	std	Y+5, r25	; 0x05
    193c:	1c c0       	rjmp	.+56     	; 0x1976 <prvCopyDataToQueue+0x8c>
    193e:	48 2f       	mov	r20, r24
    1940:	50 e0       	ldi	r21, 0x00	; 0
    1942:	8e 81       	ldd	r24, Y+6	; 0x06
    1944:	9f 81       	ldd	r25, Y+7	; 0x07
    1946:	0e 94 60 20 	call	0x40c0	; 0x40c0 <memcpy>
    194a:	88 a1       	ldd	r24, Y+32	; 0x20
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	91 95       	neg	r25
    1950:	81 95       	neg	r24
    1952:	91 09       	sbc	r25, r1
    1954:	2e 81       	ldd	r18, Y+6	; 0x06
    1956:	3f 81       	ldd	r19, Y+7	; 0x07
    1958:	28 0f       	add	r18, r24
    195a:	39 1f       	adc	r19, r25
    195c:	2e 83       	std	Y+6, r18	; 0x06
    195e:	3f 83       	std	Y+7, r19	; 0x07
    1960:	48 81       	ld	r20, Y
    1962:	59 81       	ldd	r21, Y+1	; 0x01
    1964:	24 17       	cp	r18, r20
    1966:	35 07       	cpc	r19, r21
    1968:	30 f4       	brcc	.+12     	; 0x1976 <prvCopyDataToQueue+0x8c>
    196a:	2a 81       	ldd	r18, Y+2	; 0x02
    196c:	3b 81       	ldd	r19, Y+3	; 0x03
    196e:	82 0f       	add	r24, r18
    1970:	93 1f       	adc	r25, r19
    1972:	8e 83       	std	Y+6, r24	; 0x06
    1974:	9f 83       	std	Y+7, r25	; 0x07
    1976:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1978:	8f 5f       	subi	r24, 0xFF	; 255
    197a:	8e 8f       	std	Y+30, r24	; 0x1e
    197c:	df 91       	pop	r29
    197e:	cf 91       	pop	r28
    1980:	08 95       	ret

00001982 <prvCopyDataFromQueue>:
    1982:	fc 01       	movw	r30, r24
    1984:	80 81       	ld	r24, Z
    1986:	91 81       	ldd	r25, Z+1	; 0x01
    1988:	00 97       	sbiw	r24, 0x00	; 0
    198a:	a1 f0       	breq	.+40     	; 0x19b4 <prvCopyDataFromQueue+0x32>
    198c:	40 a1       	ldd	r20, Z+32	; 0x20
    198e:	50 e0       	ldi	r21, 0x00	; 0
    1990:	26 81       	ldd	r18, Z+6	; 0x06
    1992:	37 81       	ldd	r19, Z+7	; 0x07
    1994:	24 0f       	add	r18, r20
    1996:	35 1f       	adc	r19, r21
    1998:	26 83       	std	Z+6, r18	; 0x06
    199a:	37 83       	std	Z+7, r19	; 0x07
    199c:	a2 81       	ldd	r26, Z+2	; 0x02
    199e:	b3 81       	ldd	r27, Z+3	; 0x03
    19a0:	2a 17       	cp	r18, r26
    19a2:	3b 07       	cpc	r19, r27
    19a4:	10 f0       	brcs	.+4      	; 0x19aa <prvCopyDataFromQueue+0x28>
    19a6:	86 83       	std	Z+6, r24	; 0x06
    19a8:	97 83       	std	Z+7, r25	; 0x07
    19aa:	cb 01       	movw	r24, r22
    19ac:	66 81       	ldd	r22, Z+6	; 0x06
    19ae:	77 81       	ldd	r23, Z+7	; 0x07
    19b0:	0e 94 60 20 	call	0x40c0	; 0x40c0 <memcpy>
    19b4:	08 95       	ret

000019b6 <prvUnlockQueue>:
    19b6:	0f 93       	push	r16
    19b8:	1f 93       	push	r17
    19ba:	cf 93       	push	r28
    19bc:	df 93       	push	r29
    19be:	ec 01       	movw	r28, r24
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
    19c6:	8a a1       	ldd	r24, Y+34	; 0x22
    19c8:	18 16       	cp	r1, r24
    19ca:	b4 f4       	brge	.+44     	; 0x19f8 <prvUnlockQueue+0x42>
    19cc:	8b 89       	ldd	r24, Y+19	; 0x13
    19ce:	81 11       	cpse	r24, r1
    19d0:	05 c0       	rjmp	.+10     	; 0x19dc <prvUnlockQueue+0x26>
    19d2:	12 c0       	rjmp	.+36     	; 0x19f8 <prvUnlockQueue+0x42>
    19d4:	8b 89       	ldd	r24, Y+19	; 0x13
    19d6:	81 11       	cpse	r24, r1
    19d8:	04 c0       	rjmp	.+8      	; 0x19e2 <prvUnlockQueue+0x2c>
    19da:	0e c0       	rjmp	.+28     	; 0x19f8 <prvUnlockQueue+0x42>
    19dc:	8e 01       	movw	r16, r28
    19de:	0d 5e       	subi	r16, 0xED	; 237
    19e0:	1f 4f       	sbci	r17, 0xFF	; 255
    19e2:	c8 01       	movw	r24, r16
    19e4:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    19e8:	81 11       	cpse	r24, r1
    19ea:	0e 94 12 14 	call	0x2824	; 0x2824 <vTaskMissedYield>
    19ee:	8a a1       	ldd	r24, Y+34	; 0x22
    19f0:	81 50       	subi	r24, 0x01	; 1
    19f2:	8a a3       	std	Y+34, r24	; 0x22
    19f4:	18 16       	cp	r1, r24
    19f6:	74 f3       	brlt	.-36     	; 0x19d4 <prvUnlockQueue+0x1e>
    19f8:	8f ef       	ldi	r24, 0xFF	; 255
    19fa:	8a a3       	std	Y+34, r24	; 0x22
    19fc:	0f 90       	pop	r0
    19fe:	0f be       	out	0x3f, r0	; 63
    1a00:	0f b6       	in	r0, 0x3f	; 63
    1a02:	f8 94       	cli
    1a04:	0f 92       	push	r0
    1a06:	89 a1       	ldd	r24, Y+33	; 0x21
    1a08:	18 16       	cp	r1, r24
    1a0a:	b4 f4       	brge	.+44     	; 0x1a38 <prvUnlockQueue+0x82>
    1a0c:	88 85       	ldd	r24, Y+8	; 0x08
    1a0e:	81 11       	cpse	r24, r1
    1a10:	05 c0       	rjmp	.+10     	; 0x1a1c <prvUnlockQueue+0x66>
    1a12:	12 c0       	rjmp	.+36     	; 0x1a38 <prvUnlockQueue+0x82>
    1a14:	88 85       	ldd	r24, Y+8	; 0x08
    1a16:	81 11       	cpse	r24, r1
    1a18:	04 c0       	rjmp	.+8      	; 0x1a22 <prvUnlockQueue+0x6c>
    1a1a:	0e c0       	rjmp	.+28     	; 0x1a38 <prvUnlockQueue+0x82>
    1a1c:	8e 01       	movw	r16, r28
    1a1e:	08 5f       	subi	r16, 0xF8	; 248
    1a20:	1f 4f       	sbci	r17, 0xFF	; 255
    1a22:	c8 01       	movw	r24, r16
    1a24:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    1a28:	81 11       	cpse	r24, r1
    1a2a:	0e 94 12 14 	call	0x2824	; 0x2824 <vTaskMissedYield>
    1a2e:	89 a1       	ldd	r24, Y+33	; 0x21
    1a30:	81 50       	subi	r24, 0x01	; 1
    1a32:	89 a3       	std	Y+33, r24	; 0x21
    1a34:	18 16       	cp	r1, r24
    1a36:	74 f3       	brlt	.-36     	; 0x1a14 <prvUnlockQueue+0x5e>
    1a38:	8f ef       	ldi	r24, 0xFF	; 255
    1a3a:	89 a3       	std	Y+33, r24	; 0x21
    1a3c:	0f 90       	pop	r0
    1a3e:	0f be       	out	0x3f, r0	; 63
    1a40:	df 91       	pop	r29
    1a42:	cf 91       	pop	r28
    1a44:	1f 91       	pop	r17
    1a46:	0f 91       	pop	r16
    1a48:	08 95       	ret

00001a4a <xQueueGenericReset>:
    1a4a:	1f 93       	push	r17
    1a4c:	cf 93       	push	r28
    1a4e:	df 93       	push	r29
    1a50:	61 30       	cpi	r22, 0x01	; 1
    1a52:	59 f0       	breq	.+22     	; 0x1a6a <xQueueGenericReset+0x20>
    1a54:	fc 01       	movw	r30, r24
    1a56:	23 89       	ldd	r18, Z+19	; 0x13
    1a58:	30 85       	ldd	r19, Z+8	; 0x08
    1a5a:	31 11       	cpse	r19, r1
    1a5c:	2c c0       	rjmp	.+88     	; 0x1ab6 <xQueueGenericReset+0x6c>
    1a5e:	11 e0       	ldi	r17, 0x01	; 1
    1a60:	21 11       	cpse	r18, r1
    1a62:	10 e0       	ldi	r17, 0x00	; 0
    1a64:	21 11       	cpse	r18, r1
    1a66:	28 c0       	rjmp	.+80     	; 0x1ab8 <xQueueGenericReset+0x6e>
    1a68:	01 c0       	rjmp	.+2      	; 0x1a6c <xQueueGenericReset+0x22>
    1a6a:	11 e0       	ldi	r17, 0x01	; 1
    1a6c:	ec 01       	movw	r28, r24
    1a6e:	48 81       	ld	r20, Y
    1a70:	59 81       	ldd	r21, Y+1	; 0x01
    1a72:	28 a1       	ldd	r18, Y+32	; 0x20
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a78:	62 9f       	mul	r22, r18
    1a7a:	c0 01       	movw	r24, r0
    1a7c:	63 9f       	mul	r22, r19
    1a7e:	90 0d       	add	r25, r0
    1a80:	11 24       	eor	r1, r1
    1a82:	ba 01       	movw	r22, r20
    1a84:	68 0f       	add	r22, r24
    1a86:	79 1f       	adc	r23, r25
    1a88:	6a 83       	std	Y+2, r22	; 0x02
    1a8a:	7b 83       	std	Y+3, r23	; 0x03
    1a8c:	1e 8e       	std	Y+30, r1	; 0x1e
    1a8e:	4c 83       	std	Y+4, r20	; 0x04
    1a90:	5d 83       	std	Y+5, r21	; 0x05
    1a92:	82 1b       	sub	r24, r18
    1a94:	93 0b       	sbc	r25, r19
    1a96:	84 0f       	add	r24, r20
    1a98:	95 1f       	adc	r25, r21
    1a9a:	8e 83       	std	Y+6, r24	; 0x06
    1a9c:	9f 83       	std	Y+7, r25	; 0x07
    1a9e:	8f ef       	ldi	r24, 0xFF	; 255
    1aa0:	89 a3       	std	Y+33, r24	; 0x21
    1aa2:	8a a3       	std	Y+34, r24	; 0x22
    1aa4:	ce 01       	movw	r24, r28
    1aa6:	08 96       	adiw	r24, 0x08	; 8
    1aa8:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1aac:	ce 01       	movw	r24, r28
    1aae:	43 96       	adiw	r24, 0x13	; 19
    1ab0:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1ab4:	01 c0       	rjmp	.+2      	; 0x1ab8 <xQueueGenericReset+0x6e>
    1ab6:	10 e0       	ldi	r17, 0x00	; 0
    1ab8:	81 2f       	mov	r24, r17
    1aba:	df 91       	pop	r29
    1abc:	cf 91       	pop	r28
    1abe:	1f 91       	pop	r17
    1ac0:	08 95       	ret

00001ac2 <xQueueGenericCreate>:
    1ac2:	0f 93       	push	r16
    1ac4:	1f 93       	push	r17
    1ac6:	cf 93       	push	r28
    1ac8:	df 93       	push	r29
    1aca:	88 23       	and	r24, r24
    1acc:	01 f1       	breq	.+64     	; 0x1b0e <xQueueGenericCreate+0x4c>
    1ace:	06 2f       	mov	r16, r22
    1ad0:	18 2f       	mov	r17, r24
    1ad2:	83 e2       	ldi	r24, 0x23	; 35
    1ad4:	90 e0       	ldi	r25, 0x00	; 0
    1ad6:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    1ada:	ec 01       	movw	r28, r24
    1adc:	89 2b       	or	r24, r25
    1ade:	c9 f0       	breq	.+50     	; 0x1b12 <xQueueGenericCreate+0x50>
    1ae0:	10 9f       	mul	r17, r16
    1ae2:	c0 01       	movw	r24, r0
    1ae4:	11 24       	eor	r1, r1
    1ae6:	01 96       	adiw	r24, 0x01	; 1
    1ae8:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    1aec:	88 83       	st	Y, r24
    1aee:	99 83       	std	Y+1, r25	; 0x01
    1af0:	89 2b       	or	r24, r25
    1af2:	39 f0       	breq	.+14     	; 0x1b02 <xQueueGenericCreate+0x40>
    1af4:	1f 8f       	std	Y+31, r17	; 0x1f
    1af6:	08 a3       	std	Y+32, r16	; 0x20
    1af8:	61 e0       	ldi	r22, 0x01	; 1
    1afa:	ce 01       	movw	r24, r28
    1afc:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <xQueueGenericReset>
    1b00:	08 c0       	rjmp	.+16     	; 0x1b12 <xQueueGenericCreate+0x50>
    1b02:	ce 01       	movw	r24, r28
    1b04:	0e 94 15 0a 	call	0x142a	; 0x142a <vPortFree>
    1b08:	c0 e0       	ldi	r28, 0x00	; 0
    1b0a:	d0 e0       	ldi	r29, 0x00	; 0
    1b0c:	02 c0       	rjmp	.+4      	; 0x1b12 <xQueueGenericCreate+0x50>
    1b0e:	c0 e0       	ldi	r28, 0x00	; 0
    1b10:	d0 e0       	ldi	r29, 0x00	; 0
    1b12:	ce 01       	movw	r24, r28
    1b14:	df 91       	pop	r29
    1b16:	cf 91       	pop	r28
    1b18:	1f 91       	pop	r17
    1b1a:	0f 91       	pop	r16
    1b1c:	08 95       	ret

00001b1e <xQueueGenericSend>:
    1b1e:	af 92       	push	r10
    1b20:	bf 92       	push	r11
    1b22:	cf 92       	push	r12
    1b24:	df 92       	push	r13
    1b26:	ef 92       	push	r14
    1b28:	ff 92       	push	r15
    1b2a:	0f 93       	push	r16
    1b2c:	1f 93       	push	r17
    1b2e:	cf 93       	push	r28
    1b30:	df 93       	push	r29
    1b32:	cd b7       	in	r28, 0x3d	; 61
    1b34:	de b7       	in	r29, 0x3e	; 62
    1b36:	29 97       	sbiw	r28, 0x09	; 9
    1b38:	cd bf       	out	0x3d, r28	; 61
    1b3a:	de bf       	out	0x3e, r29	; 62
    1b3c:	7c 01       	movw	r14, r24
    1b3e:	5b 01       	movw	r10, r22
    1b40:	2e 83       	std	Y+6, r18	; 0x06
    1b42:	3f 83       	std	Y+7, r19	; 0x07
    1b44:	48 87       	std	Y+8, r20	; 0x08
    1b46:	59 87       	std	Y+9, r21	; 0x09
    1b48:	10 e0       	ldi	r17, 0x00	; 0
    1b4a:	6c 01       	movw	r12, r24
    1b4c:	88 e0       	ldi	r24, 0x08	; 8
    1b4e:	c8 0e       	add	r12, r24
    1b50:	d1 1c       	adc	r13, r1
    1b52:	0f b6       	in	r0, 0x3f	; 63
    1b54:	f8 94       	cli
    1b56:	0f 92       	push	r0
    1b58:	f7 01       	movw	r30, r14
    1b5a:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b5c:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b5e:	98 17       	cp	r25, r24
    1b60:	a8 f4       	brcc	.+42     	; 0x1b8c <xQueueGenericSend+0x6e>
    1b62:	40 2f       	mov	r20, r16
    1b64:	b5 01       	movw	r22, r10
    1b66:	c7 01       	movw	r24, r14
    1b68:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvCopyDataToQueue>
    1b6c:	f7 01       	movw	r30, r14
    1b6e:	83 89       	ldd	r24, Z+19	; 0x13
    1b70:	88 23       	and	r24, r24
    1b72:	41 f0       	breq	.+16     	; 0x1b84 <xQueueGenericSend+0x66>
    1b74:	c7 01       	movw	r24, r14
    1b76:	43 96       	adiw	r24, 0x13	; 19
    1b78:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    1b7c:	81 30       	cpi	r24, 0x01	; 1
    1b7e:	11 f4       	brne	.+4      	; 0x1b84 <xQueueGenericSend+0x66>
    1b80:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1b84:	0f 90       	pop	r0
    1b86:	0f be       	out	0x3f, r0	; 63
    1b88:	81 e0       	ldi	r24, 0x01	; 1
    1b8a:	56 c0       	rjmp	.+172    	; 0x1c38 <xQueueGenericSend+0x11a>
    1b8c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b8e:	9f 81       	ldd	r25, Y+7	; 0x07
    1b90:	a8 85       	ldd	r26, Y+8	; 0x08
    1b92:	b9 85       	ldd	r27, Y+9	; 0x09
    1b94:	89 2b       	or	r24, r25
    1b96:	8a 2b       	or	r24, r26
    1b98:	8b 2b       	or	r24, r27
    1b9a:	21 f4       	brne	.+8      	; 0x1ba4 <xQueueGenericSend+0x86>
    1b9c:	0f 90       	pop	r0
    1b9e:	0f be       	out	0x3f, r0	; 63
    1ba0:	80 e0       	ldi	r24, 0x00	; 0
    1ba2:	4a c0       	rjmp	.+148    	; 0x1c38 <xQueueGenericSend+0x11a>
    1ba4:	11 11       	cpse	r17, r1
    1ba6:	05 c0       	rjmp	.+10     	; 0x1bb2 <xQueueGenericSend+0x94>
    1ba8:	ce 01       	movw	r24, r28
    1baa:	01 96       	adiw	r24, 0x01	; 1
    1bac:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSetTimeOutState>
    1bb0:	11 e0       	ldi	r17, 0x01	; 1
    1bb2:	0f 90       	pop	r0
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	0f 92       	push	r0
    1bc0:	f7 01       	movw	r30, r14
    1bc2:	81 a1       	ldd	r24, Z+33	; 0x21
    1bc4:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc6:	09 f4       	brne	.+2      	; 0x1bca <xQueueGenericSend+0xac>
    1bc8:	11 a2       	std	Z+33, r1	; 0x21
    1bca:	f7 01       	movw	r30, r14
    1bcc:	82 a1       	ldd	r24, Z+34	; 0x22
    1bce:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd0:	09 f4       	brne	.+2      	; 0x1bd4 <xQueueGenericSend+0xb6>
    1bd2:	12 a2       	std	Z+34, r1	; 0x22
    1bd4:	0f 90       	pop	r0
    1bd6:	0f be       	out	0x3f, r0	; 63
    1bd8:	be 01       	movw	r22, r28
    1bda:	6a 5f       	subi	r22, 0xFA	; 250
    1bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bde:	ce 01       	movw	r24, r28
    1be0:	01 96       	adiw	r24, 0x01	; 1
    1be2:	0e 94 a5 13 	call	0x274a	; 0x274a <xTaskCheckForTimeOut>
    1be6:	81 11       	cpse	r24, r1
    1be8:	21 c0       	rjmp	.+66     	; 0x1c2c <xQueueGenericSend+0x10e>
    1bea:	0f b6       	in	r0, 0x3f	; 63
    1bec:	f8 94       	cli
    1bee:	0f 92       	push	r0
    1bf0:	f7 01       	movw	r30, r14
    1bf2:	96 8d       	ldd	r25, Z+30	; 0x1e
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63
    1bf8:	87 8d       	ldd	r24, Z+31	; 0x1f
    1bfa:	98 13       	cpse	r25, r24
    1bfc:	11 c0       	rjmp	.+34     	; 0x1c20 <xQueueGenericSend+0x102>
    1bfe:	4e 81       	ldd	r20, Y+6	; 0x06
    1c00:	5f 81       	ldd	r21, Y+7	; 0x07
    1c02:	68 85       	ldd	r22, Y+8	; 0x08
    1c04:	79 85       	ldd	r23, Y+9	; 0x09
    1c06:	c6 01       	movw	r24, r12
    1c08:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskPlaceOnEventList>
    1c0c:	c7 01       	movw	r24, r14
    1c0e:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1c12:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1c16:	81 11       	cpse	r24, r1
    1c18:	9c cf       	rjmp	.-200    	; 0x1b52 <xQueueGenericSend+0x34>
    1c1a:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1c1e:	99 cf       	rjmp	.-206    	; 0x1b52 <xQueueGenericSend+0x34>
    1c20:	c7 01       	movw	r24, r14
    1c22:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1c26:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1c2a:	93 cf       	rjmp	.-218    	; 0x1b52 <xQueueGenericSend+0x34>
    1c2c:	c7 01       	movw	r24, r14
    1c2e:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1c32:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1c36:	80 e0       	ldi	r24, 0x00	; 0
    1c38:	29 96       	adiw	r28, 0x09	; 9
    1c3a:	cd bf       	out	0x3d, r28	; 61
    1c3c:	de bf       	out	0x3e, r29	; 62
    1c3e:	df 91       	pop	r29
    1c40:	cf 91       	pop	r28
    1c42:	1f 91       	pop	r17
    1c44:	0f 91       	pop	r16
    1c46:	ff 90       	pop	r15
    1c48:	ef 90       	pop	r14
    1c4a:	df 90       	pop	r13
    1c4c:	cf 90       	pop	r12
    1c4e:	bf 90       	pop	r11
    1c50:	af 90       	pop	r10
    1c52:	08 95       	ret

00001c54 <xQueueGenericReceive>:
    1c54:	af 92       	push	r10
    1c56:	bf 92       	push	r11
    1c58:	cf 92       	push	r12
    1c5a:	df 92       	push	r13
    1c5c:	ef 92       	push	r14
    1c5e:	ff 92       	push	r15
    1c60:	0f 93       	push	r16
    1c62:	1f 93       	push	r17
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	cd b7       	in	r28, 0x3d	; 61
    1c6a:	de b7       	in	r29, 0x3e	; 62
    1c6c:	29 97       	sbiw	r28, 0x09	; 9
    1c6e:	cd bf       	out	0x3d, r28	; 61
    1c70:	de bf       	out	0x3e, r29	; 62
    1c72:	7c 01       	movw	r14, r24
    1c74:	5b 01       	movw	r10, r22
    1c76:	2e 83       	std	Y+6, r18	; 0x06
    1c78:	3f 83       	std	Y+7, r19	; 0x07
    1c7a:	48 87       	std	Y+8, r20	; 0x08
    1c7c:	59 87       	std	Y+9, r21	; 0x09
    1c7e:	10 e0       	ldi	r17, 0x00	; 0
    1c80:	6c 01       	movw	r12, r24
    1c82:	83 e1       	ldi	r24, 0x13	; 19
    1c84:	c8 0e       	add	r12, r24
    1c86:	d1 1c       	adc	r13, r1
    1c88:	0f b6       	in	r0, 0x3f	; 63
    1c8a:	f8 94       	cli
    1c8c:	0f 92       	push	r0
    1c8e:	f7 01       	movw	r30, r14
    1c90:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c92:	88 23       	and	r24, r24
    1c94:	99 f1       	breq	.+102    	; 0x1cfc <xQueueGenericReceive+0xa8>
    1c96:	c6 80       	ldd	r12, Z+6	; 0x06
    1c98:	d7 80       	ldd	r13, Z+7	; 0x07
    1c9a:	b5 01       	movw	r22, r10
    1c9c:	c7 01       	movw	r24, r14
    1c9e:	0e 94 c1 0c 	call	0x1982	; 0x1982 <prvCopyDataFromQueue>
    1ca2:	01 11       	cpse	r16, r1
    1ca4:	1a c0       	rjmp	.+52     	; 0x1cda <xQueueGenericReceive+0x86>
    1ca6:	f7 01       	movw	r30, r14
    1ca8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1caa:	81 50       	subi	r24, 0x01	; 1
    1cac:	86 8f       	std	Z+30, r24	; 0x1e
    1cae:	80 81       	ld	r24, Z
    1cb0:	91 81       	ldd	r25, Z+1	; 0x01
    1cb2:	89 2b       	or	r24, r25
    1cb4:	29 f4       	brne	.+10     	; 0x1cc0 <xQueueGenericReceive+0x6c>
    1cb6:	0e 94 2f 14 	call	0x285e	; 0x285e <xTaskGetCurrentTaskHandle>
    1cba:	f7 01       	movw	r30, r14
    1cbc:	82 83       	std	Z+2, r24	; 0x02
    1cbe:	93 83       	std	Z+3, r25	; 0x03
    1cc0:	f7 01       	movw	r30, r14
    1cc2:	80 85       	ldd	r24, Z+8	; 0x08
    1cc4:	88 23       	and	r24, r24
    1cc6:	b1 f0       	breq	.+44     	; 0x1cf4 <xQueueGenericReceive+0xa0>
    1cc8:	c7 01       	movw	r24, r14
    1cca:	08 96       	adiw	r24, 0x08	; 8
    1ccc:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    1cd0:	81 30       	cpi	r24, 0x01	; 1
    1cd2:	81 f4       	brne	.+32     	; 0x1cf4 <xQueueGenericReceive+0xa0>
    1cd4:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1cd8:	0d c0       	rjmp	.+26     	; 0x1cf4 <xQueueGenericReceive+0xa0>
    1cda:	f7 01       	movw	r30, r14
    1cdc:	c6 82       	std	Z+6, r12	; 0x06
    1cde:	d7 82       	std	Z+7, r13	; 0x07
    1ce0:	83 89       	ldd	r24, Z+19	; 0x13
    1ce2:	88 23       	and	r24, r24
    1ce4:	39 f0       	breq	.+14     	; 0x1cf4 <xQueueGenericReceive+0xa0>
    1ce6:	c7 01       	movw	r24, r14
    1ce8:	43 96       	adiw	r24, 0x13	; 19
    1cea:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    1cee:	81 11       	cpse	r24, r1
    1cf0:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1cf4:	0f 90       	pop	r0
    1cf6:	0f be       	out	0x3f, r0	; 63
    1cf8:	81 e0       	ldi	r24, 0x01	; 1
    1cfa:	62 c0       	rjmp	.+196    	; 0x1dc0 <xQueueGenericReceive+0x16c>
    1cfc:	8e 81       	ldd	r24, Y+6	; 0x06
    1cfe:	9f 81       	ldd	r25, Y+7	; 0x07
    1d00:	a8 85       	ldd	r26, Y+8	; 0x08
    1d02:	b9 85       	ldd	r27, Y+9	; 0x09
    1d04:	89 2b       	or	r24, r25
    1d06:	8a 2b       	or	r24, r26
    1d08:	8b 2b       	or	r24, r27
    1d0a:	21 f4       	brne	.+8      	; 0x1d14 <xQueueGenericReceive+0xc0>
    1d0c:	0f 90       	pop	r0
    1d0e:	0f be       	out	0x3f, r0	; 63
    1d10:	80 e0       	ldi	r24, 0x00	; 0
    1d12:	56 c0       	rjmp	.+172    	; 0x1dc0 <xQueueGenericReceive+0x16c>
    1d14:	11 11       	cpse	r17, r1
    1d16:	05 c0       	rjmp	.+10     	; 0x1d22 <xQueueGenericReceive+0xce>
    1d18:	ce 01       	movw	r24, r28
    1d1a:	01 96       	adiw	r24, 0x01	; 1
    1d1c:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSetTimeOutState>
    1d20:	11 e0       	ldi	r17, 0x01	; 1
    1d22:	0f 90       	pop	r0
    1d24:	0f be       	out	0x3f, r0	; 63
    1d26:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	f8 94       	cli
    1d2e:	0f 92       	push	r0
    1d30:	f7 01       	movw	r30, r14
    1d32:	81 a1       	ldd	r24, Z+33	; 0x21
    1d34:	8f 3f       	cpi	r24, 0xFF	; 255
    1d36:	09 f4       	brne	.+2      	; 0x1d3a <xQueueGenericReceive+0xe6>
    1d38:	11 a2       	std	Z+33, r1	; 0x21
    1d3a:	f7 01       	movw	r30, r14
    1d3c:	82 a1       	ldd	r24, Z+34	; 0x22
    1d3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d40:	09 f4       	brne	.+2      	; 0x1d44 <xQueueGenericReceive+0xf0>
    1d42:	12 a2       	std	Z+34, r1	; 0x22
    1d44:	0f 90       	pop	r0
    1d46:	0f be       	out	0x3f, r0	; 63
    1d48:	be 01       	movw	r22, r28
    1d4a:	6a 5f       	subi	r22, 0xFA	; 250
    1d4c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d4e:	ce 01       	movw	r24, r28
    1d50:	01 96       	adiw	r24, 0x01	; 1
    1d52:	0e 94 a5 13 	call	0x274a	; 0x274a <xTaskCheckForTimeOut>
    1d56:	81 11       	cpse	r24, r1
    1d58:	2d c0       	rjmp	.+90     	; 0x1db4 <xQueueGenericReceive+0x160>
    1d5a:	0f b6       	in	r0, 0x3f	; 63
    1d5c:	f8 94       	cli
    1d5e:	0f 92       	push	r0
    1d60:	f7 01       	movw	r30, r14
    1d62:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d64:	0f 90       	pop	r0
    1d66:	0f be       	out	0x3f, r0	; 63
    1d68:	81 11       	cpse	r24, r1
    1d6a:	1e c0       	rjmp	.+60     	; 0x1da8 <xQueueGenericReceive+0x154>
    1d6c:	80 81       	ld	r24, Z
    1d6e:	91 81       	ldd	r25, Z+1	; 0x01
    1d70:	89 2b       	or	r24, r25
    1d72:	49 f4       	brne	.+18     	; 0x1d86 <xQueueGenericReceive+0x132>
    1d74:	0f b6       	in	r0, 0x3f	; 63
    1d76:	f8 94       	cli
    1d78:	0f 92       	push	r0
    1d7a:	82 81       	ldd	r24, Z+2	; 0x02
    1d7c:	93 81       	ldd	r25, Z+3	; 0x03
    1d7e:	0e 94 34 14 	call	0x2868	; 0x2868 <vTaskPriorityInherit>
    1d82:	0f 90       	pop	r0
    1d84:	0f be       	out	0x3f, r0	; 63
    1d86:	4e 81       	ldd	r20, Y+6	; 0x06
    1d88:	5f 81       	ldd	r21, Y+7	; 0x07
    1d8a:	68 85       	ldd	r22, Y+8	; 0x08
    1d8c:	79 85       	ldd	r23, Y+9	; 0x09
    1d8e:	c6 01       	movw	r24, r12
    1d90:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskPlaceOnEventList>
    1d94:	c7 01       	movw	r24, r14
    1d96:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1d9a:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1d9e:	81 11       	cpse	r24, r1
    1da0:	73 cf       	rjmp	.-282    	; 0x1c88 <xQueueGenericReceive+0x34>
    1da2:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1da6:	70 cf       	rjmp	.-288    	; 0x1c88 <xQueueGenericReceive+0x34>
    1da8:	c7 01       	movw	r24, r14
    1daa:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1dae:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1db2:	6a cf       	rjmp	.-300    	; 0x1c88 <xQueueGenericReceive+0x34>
    1db4:	c7 01       	movw	r24, r14
    1db6:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1dba:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1dbe:	80 e0       	ldi	r24, 0x00	; 0
    1dc0:	29 96       	adiw	r28, 0x09	; 9
    1dc2:	cd bf       	out	0x3d, r28	; 61
    1dc4:	de bf       	out	0x3e, r29	; 62
    1dc6:	df 91       	pop	r29
    1dc8:	cf 91       	pop	r28
    1dca:	1f 91       	pop	r17
    1dcc:	0f 91       	pop	r16
    1dce:	ff 90       	pop	r15
    1dd0:	ef 90       	pop	r14
    1dd2:	df 90       	pop	r13
    1dd4:	cf 90       	pop	r12
    1dd6:	bf 90       	pop	r11
    1dd8:	af 90       	pop	r10
    1dda:	08 95       	ret

00001ddc <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1ddc:	0f b6       	in	r0, 0x3f	; 63
    1dde:	f8 94       	cli
    1de0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1de2:	fc 01       	movw	r30, r24
    1de4:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1de6:	0f 90       	pop	r0
    1de8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1dea:	08 95       	ret

00001dec <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1dec:	ce e1       	ldi	r28, 0x1E	; 30
    1dee:	d1 e3       	ldi	r29, 0x31	; 49
    1df0:	88 81       	ld	r24, Y
    1df2:	82 30       	cpi	r24, 0x02	; 2
    1df4:	e8 f3       	brcs	.-6      	; 0x1df0 <prvIdleTask+0x4>
    1df6:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1dfa:	fa cf       	rjmp	.-12     	; 0x1df0 <prvIdleTask+0x4>

00001dfc <prvAddCurrentTaskToDelayedList>:
    1dfc:	cf 92       	push	r12
    1dfe:	df 92       	push	r13
    1e00:	ef 92       	push	r14
    1e02:	ff 92       	push	r15
    1e04:	6b 01       	movw	r12, r22
    1e06:	7c 01       	movw	r14, r24
    1e08:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    1e0c:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1e10:	62 83       	std	Z+2, r22	; 0x02
    1e12:	73 83       	std	Z+3, r23	; 0x03
    1e14:	84 83       	std	Z+4, r24	; 0x04
    1e16:	95 83       	std	Z+5, r25	; 0x05
    1e18:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    1e1c:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    1e20:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    1e24:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    1e28:	c8 16       	cp	r12, r24
    1e2a:	d9 06       	cpc	r13, r25
    1e2c:	ea 06       	cpc	r14, r26
    1e2e:	fb 06       	cpc	r15, r27
    1e30:	68 f4       	brcc	.+26     	; 0x1e4c <prvAddCurrentTaskToDelayedList+0x50>
    1e32:	60 91 4a 31 	lds	r22, 0x314A	; 0x80314a <pxCurrentTCB>
    1e36:	70 91 4b 31 	lds	r23, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1e3a:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <pxOverflowDelayedTaskList>
    1e3e:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <pxOverflowDelayedTaskList+0x1>
    1e42:	6e 5f       	subi	r22, 0xFE	; 254
    1e44:	7f 4f       	sbci	r23, 0xFF	; 255
    1e46:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInsert>
    1e4a:	21 c0       	rjmp	.+66     	; 0x1e8e <prvAddCurrentTaskToDelayedList+0x92>
    1e4c:	60 91 4a 31 	lds	r22, 0x314A	; 0x80314a <pxCurrentTCB>
    1e50:	70 91 4b 31 	lds	r23, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1e54:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <pxDelayedTaskList>
    1e58:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    1e5c:	6e 5f       	subi	r22, 0xFE	; 254
    1e5e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e60:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInsert>
    1e64:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e68:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e6c:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e70:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e74:	c8 16       	cp	r12, r24
    1e76:	d9 06       	cpc	r13, r25
    1e78:	ea 06       	cpc	r14, r26
    1e7a:	fb 06       	cpc	r15, r27
    1e7c:	40 f4       	brcc	.+16     	; 0x1e8e <prvAddCurrentTaskToDelayedList+0x92>
    1e7e:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e82:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e86:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e8a:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e8e:	ff 90       	pop	r15
    1e90:	ef 90       	pop	r14
    1e92:	df 90       	pop	r13
    1e94:	cf 90       	pop	r12
    1e96:	08 95       	ret

00001e98 <xTaskGenericCreate>:
    1e98:	4f 92       	push	r4
    1e9a:	5f 92       	push	r5
    1e9c:	6f 92       	push	r6
    1e9e:	7f 92       	push	r7
    1ea0:	8f 92       	push	r8
    1ea2:	9f 92       	push	r9
    1ea4:	af 92       	push	r10
    1ea6:	bf 92       	push	r11
    1ea8:	cf 92       	push	r12
    1eaa:	df 92       	push	r13
    1eac:	ef 92       	push	r14
    1eae:	ff 92       	push	r15
    1eb0:	0f 93       	push	r16
    1eb2:	1f 93       	push	r17
    1eb4:	cf 93       	push	r28
    1eb6:	df 93       	push	r29
    1eb8:	5c 01       	movw	r10, r24
    1eba:	4b 01       	movw	r8, r22
    1ebc:	3a 01       	movw	r6, r20
    1ebe:	29 01       	movw	r4, r18
    1ec0:	88 e2       	ldi	r24, 0x28	; 40
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    1ec8:	ec 01       	movw	r28, r24
    1eca:	89 2b       	or	r24, r25
    1ecc:	09 f4       	brne	.+2      	; 0x1ed0 <xTaskGenericCreate+0x38>
    1ece:	d4 c0       	rjmp	.+424    	; 0x2078 <xTaskGenericCreate+0x1e0>
    1ed0:	c1 14       	cp	r12, r1
    1ed2:	d1 04       	cpc	r13, r1
    1ed4:	09 f0       	breq	.+2      	; 0x1ed8 <xTaskGenericCreate+0x40>
    1ed6:	cc c0       	rjmp	.+408    	; 0x2070 <xTaskGenericCreate+0x1d8>
    1ed8:	c3 01       	movw	r24, r6
    1eda:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    1ede:	8b 8f       	std	Y+27, r24	; 0x1b
    1ee0:	9c 8f       	std	Y+28, r25	; 0x1c
    1ee2:	00 97       	sbiw	r24, 0x00	; 0
    1ee4:	21 f4       	brne	.+8      	; 0x1eee <xTaskGenericCreate+0x56>
    1ee6:	ce 01       	movw	r24, r28
    1ee8:	0e 94 15 0a 	call	0x142a	; 0x142a <vPortFree>
    1eec:	c5 c0       	rjmp	.+394    	; 0x2078 <xTaskGenericCreate+0x1e0>
    1eee:	a3 01       	movw	r20, r6
    1ef0:	61 e1       	ldi	r22, 0x11	; 17
    1ef2:	70 e0       	ldi	r23, 0x00	; 0
    1ef4:	0e 94 69 20 	call	0x40d2	; 0x40d2 <memset>
    1ef8:	93 01       	movw	r18, r6
    1efa:	21 50       	subi	r18, 0x01	; 1
    1efc:	31 09       	sbc	r19, r1
    1efe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f00:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1f02:	3c 01       	movw	r6, r24
    1f04:	62 0e       	add	r6, r18
    1f06:	73 1e       	adc	r7, r19
    1f08:	4a e0       	ldi	r20, 0x0A	; 10
    1f0a:	50 e0       	ldi	r21, 0x00	; 0
    1f0c:	b4 01       	movw	r22, r8
    1f0e:	ce 01       	movw	r24, r28
    1f10:	4d 96       	adiw	r24, 0x1d	; 29
    1f12:	0e 94 70 20 	call	0x40e0	; 0x40e0 <strncpy>
    1f16:	1e a2       	std	Y+38, r1	; 0x26
    1f18:	10 2f       	mov	r17, r16
    1f1a:	04 30       	cpi	r16, 0x04	; 4
    1f1c:	08 f0       	brcs	.+2      	; 0x1f20 <xTaskGenericCreate+0x88>
    1f1e:	13 e0       	ldi	r17, 0x03	; 3
    1f20:	1a 8f       	std	Y+26, r17	; 0x1a
    1f22:	1f a3       	std	Y+39, r17	; 0x27
    1f24:	6e 01       	movw	r12, r28
    1f26:	22 e0       	ldi	r18, 0x02	; 2
    1f28:	c2 0e       	add	r12, r18
    1f2a:	d1 1c       	adc	r13, r1
    1f2c:	c6 01       	movw	r24, r12
    1f2e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <vListInitialiseItem>
    1f32:	ce 01       	movw	r24, r28
    1f34:	0e 96       	adiw	r24, 0x0e	; 14
    1f36:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <vListInitialiseItem>
    1f3a:	ca 87       	std	Y+10, r28	; 0x0a
    1f3c:	db 87       	std	Y+11, r29	; 0x0b
    1f3e:	84 e0       	ldi	r24, 0x04	; 4
    1f40:	90 e0       	ldi	r25, 0x00	; 0
    1f42:	a0 e0       	ldi	r26, 0x00	; 0
    1f44:	b0 e0       	ldi	r27, 0x00	; 0
    1f46:	81 1b       	sub	r24, r17
    1f48:	91 09       	sbc	r25, r1
    1f4a:	a1 09       	sbc	r26, r1
    1f4c:	b1 09       	sbc	r27, r1
    1f4e:	8e 87       	std	Y+14, r24	; 0x0e
    1f50:	9f 87       	std	Y+15, r25	; 0x0f
    1f52:	a8 8b       	std	Y+16, r26	; 0x10
    1f54:	b9 8b       	std	Y+17, r27	; 0x11
    1f56:	ce 8b       	std	Y+22, r28	; 0x16
    1f58:	df 8b       	std	Y+23, r29	; 0x17
    1f5a:	a2 01       	movw	r20, r4
    1f5c:	b5 01       	movw	r22, r10
    1f5e:	c3 01       	movw	r24, r6
    1f60:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <pxPortInitialiseStack>
    1f64:	88 83       	st	Y, r24
    1f66:	99 83       	std	Y+1, r25	; 0x01
    1f68:	e1 14       	cp	r14, r1
    1f6a:	f1 04       	cpc	r15, r1
    1f6c:	19 f0       	breq	.+6      	; 0x1f74 <xTaskGenericCreate+0xdc>
    1f6e:	f7 01       	movw	r30, r14
    1f70:	c0 83       	st	Z, r28
    1f72:	d1 83       	std	Z+1, r29	; 0x01
    1f74:	0f b6       	in	r0, 0x3f	; 63
    1f76:	f8 94       	cli
    1f78:	0f 92       	push	r0
    1f7a:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxCurrentNumberOfTasks>
    1f7e:	8f 5f       	subi	r24, 0xFF	; 255
    1f80:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxCurrentNumberOfTasks>
    1f84:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    1f88:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1f8c:	89 2b       	or	r24, r25
    1f8e:	89 f5       	brne	.+98     	; 0x1ff2 <xTaskGenericCreate+0x15a>
    1f90:	c0 93 4a 31 	sts	0x314A, r28	; 0x80314a <pxCurrentTCB>
    1f94:	d0 93 4b 31 	sts	0x314B, r29	; 0x80314b <pxCurrentTCB+0x1>
    1f98:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxCurrentNumberOfTasks>
    1f9c:	81 30       	cpi	r24, 0x01	; 1
    1f9e:	c1 f5       	brne	.+112    	; 0x2010 <xTaskGenericCreate+0x178>
    1fa0:	8e e1       	ldi	r24, 0x1E	; 30
    1fa2:	91 e3       	ldi	r25, 0x31	; 49
    1fa4:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fa8:	89 e2       	ldi	r24, 0x29	; 41
    1faa:	91 e3       	ldi	r25, 0x31	; 49
    1fac:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fb0:	84 e3       	ldi	r24, 0x34	; 52
    1fb2:	91 e3       	ldi	r25, 0x31	; 49
    1fb4:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fb8:	8f e3       	ldi	r24, 0x3F	; 63
    1fba:	91 e3       	ldi	r25, 0x31	; 49
    1fbc:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fc0:	83 e1       	ldi	r24, 0x13	; 19
    1fc2:	91 e3       	ldi	r25, 0x31	; 49
    1fc4:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fc8:	88 e0       	ldi	r24, 0x08	; 8
    1fca:	91 e3       	ldi	r25, 0x31	; 49
    1fcc:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fd0:	89 ef       	ldi	r24, 0xF9	; 249
    1fd2:	90 e3       	ldi	r25, 0x30	; 48
    1fd4:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fd8:	83 e1       	ldi	r24, 0x13	; 19
    1fda:	91 e3       	ldi	r25, 0x31	; 49
    1fdc:	80 93 06 31 	sts	0x3106, r24	; 0x803106 <pxDelayedTaskList>
    1fe0:	90 93 07 31 	sts	0x3107, r25	; 0x803107 <pxDelayedTaskList+0x1>
    1fe4:	88 e0       	ldi	r24, 0x08	; 8
    1fe6:	91 e3       	ldi	r25, 0x31	; 49
    1fe8:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <pxOverflowDelayedTaskList>
    1fec:	90 93 05 31 	sts	0x3105, r25	; 0x803105 <pxOverflowDelayedTaskList+0x1>
    1ff0:	0f c0       	rjmp	.+30     	; 0x2010 <xTaskGenericCreate+0x178>
    1ff2:	80 91 ef 30 	lds	r24, 0x30EF	; 0x8030ef <xSchedulerRunning>
    1ff6:	81 11       	cpse	r24, r1
    1ff8:	0b c0       	rjmp	.+22     	; 0x2010 <xTaskGenericCreate+0x178>
    1ffa:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    1ffe:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    2002:	82 8d       	ldd	r24, Z+26	; 0x1a
    2004:	08 17       	cp	r16, r24
    2006:	20 f0       	brcs	.+8      	; 0x2010 <xTaskGenericCreate+0x178>
    2008:	c0 93 4a 31 	sts	0x314A, r28	; 0x80314a <pxCurrentTCB>
    200c:	d0 93 4b 31 	sts	0x314B, r29	; 0x80314b <pxCurrentTCB+0x1>
    2010:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2012:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <uxTopUsedPriority>
    2016:	98 17       	cp	r25, r24
    2018:	10 f4       	brcc	.+4      	; 0x201e <xTaskGenericCreate+0x186>
    201a:	80 93 f1 30 	sts	0x30F1, r24	; 0x8030f1 <uxTopUsedPriority>
    201e:	90 91 ea 30 	lds	r25, 0x30EA	; 0x8030ea <uxTaskNumber>
    2022:	9f 5f       	subi	r25, 0xFF	; 255
    2024:	90 93 ea 30 	sts	0x30EA, r25	; 0x8030ea <uxTaskNumber>
    2028:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    202c:	98 17       	cp	r25, r24
    202e:	10 f4       	brcc	.+4      	; 0x2034 <xTaskGenericCreate+0x19c>
    2030:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    2034:	fb e0       	ldi	r31, 0x0B	; 11
    2036:	8f 9f       	mul	r24, r31
    2038:	c0 01       	movw	r24, r0
    203a:	11 24       	eor	r1, r1
    203c:	b6 01       	movw	r22, r12
    203e:	82 5e       	subi	r24, 0xE2	; 226
    2040:	9e 4c       	sbci	r25, 0xCE	; 206
    2042:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63
    204a:	80 91 ef 30 	lds	r24, 0x30EF	; 0x8030ef <xSchedulerRunning>
    204e:	88 23       	and	r24, r24
    2050:	59 f0       	breq	.+22     	; 0x2068 <xTaskGenericCreate+0x1d0>
    2052:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    2056:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    205a:	82 8d       	ldd	r24, Z+26	; 0x1a
    205c:	80 17       	cp	r24, r16
    205e:	30 f4       	brcc	.+12     	; 0x206c <xTaskGenericCreate+0x1d4>
    2060:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    2064:	81 e0       	ldi	r24, 0x01	; 1
    2066:	09 c0       	rjmp	.+18     	; 0x207a <xTaskGenericCreate+0x1e2>
    2068:	81 e0       	ldi	r24, 0x01	; 1
    206a:	07 c0       	rjmp	.+14     	; 0x207a <xTaskGenericCreate+0x1e2>
    206c:	81 e0       	ldi	r24, 0x01	; 1
    206e:	05 c0       	rjmp	.+10     	; 0x207a <xTaskGenericCreate+0x1e2>
    2070:	cb 8e       	std	Y+27, r12	; 0x1b
    2072:	dc 8e       	std	Y+28, r13	; 0x1c
    2074:	c6 01       	movw	r24, r12
    2076:	3b cf       	rjmp	.-394    	; 0x1eee <xTaskGenericCreate+0x56>
    2078:	8f ef       	ldi	r24, 0xFF	; 255
    207a:	df 91       	pop	r29
    207c:	cf 91       	pop	r28
    207e:	1f 91       	pop	r17
    2080:	0f 91       	pop	r16
    2082:	ff 90       	pop	r15
    2084:	ef 90       	pop	r14
    2086:	df 90       	pop	r13
    2088:	cf 90       	pop	r12
    208a:	bf 90       	pop	r11
    208c:	af 90       	pop	r10
    208e:	9f 90       	pop	r9
    2090:	8f 90       	pop	r8
    2092:	7f 90       	pop	r7
    2094:	6f 90       	pop	r6
    2096:	5f 90       	pop	r5
    2098:	4f 90       	pop	r4
    209a:	08 95       	ret

0000209c <uxTaskPriorityGet>:
    209c:	0f b6       	in	r0, 0x3f	; 63
    209e:	f8 94       	cli
    20a0:	0f 92       	push	r0
    20a2:	00 97       	sbiw	r24, 0x00	; 0
    20a4:	21 f4       	brne	.+8      	; 0x20ae <uxTaskPriorityGet+0x12>
    20a6:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    20aa:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    20ae:	0f 90       	pop	r0
    20b0:	0f be       	out	0x3f, r0	; 63
    20b2:	fc 01       	movw	r30, r24
    20b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    20b6:	08 95       	ret

000020b8 <vTaskStartScheduler>:
    20b8:	af 92       	push	r10
    20ba:	bf 92       	push	r11
    20bc:	cf 92       	push	r12
    20be:	df 92       	push	r13
    20c0:	ef 92       	push	r14
    20c2:	ff 92       	push	r15
    20c4:	0f 93       	push	r16
    20c6:	a1 2c       	mov	r10, r1
    20c8:	b1 2c       	mov	r11, r1
    20ca:	c1 2c       	mov	r12, r1
    20cc:	d1 2c       	mov	r13, r1
    20ce:	0f 2e       	mov	r0, r31
    20d0:	f7 ef       	ldi	r31, 0xF7	; 247
    20d2:	ef 2e       	mov	r14, r31
    20d4:	f0 e3       	ldi	r31, 0x30	; 48
    20d6:	ff 2e       	mov	r15, r31
    20d8:	f0 2d       	mov	r31, r0
    20da:	00 e0       	ldi	r16, 0x00	; 0
    20dc:	20 e0       	ldi	r18, 0x00	; 0
    20de:	30 e0       	ldi	r19, 0x00	; 0
    20e0:	44 e6       	ldi	r20, 0x64	; 100
    20e2:	50 e0       	ldi	r21, 0x00	; 0
    20e4:	6c e5       	ldi	r22, 0x5C	; 92
    20e6:	70 e2       	ldi	r23, 0x20	; 32
    20e8:	86 ef       	ldi	r24, 0xF6	; 246
    20ea:	9e e0       	ldi	r25, 0x0E	; 14
    20ec:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <xTaskGenericCreate>
    20f0:	81 30       	cpi	r24, 0x01	; 1
    20f2:	69 f4       	brne	.+26     	; 0x210e <vTaskStartScheduler+0x56>
    20f4:	f8 94       	cli
    20f6:	80 93 ef 30 	sts	0x30EF, r24	; 0x8030ef <xSchedulerRunning>
    20fa:	10 92 f2 30 	sts	0x30F2, r1	; 0x8030f2 <xTickCount>
    20fe:	10 92 f3 30 	sts	0x30F3, r1	; 0x8030f3 <xTickCount+0x1>
    2102:	10 92 f4 30 	sts	0x30F4, r1	; 0x8030f4 <xTickCount+0x2>
    2106:	10 92 f5 30 	sts	0x30F5, r1	; 0x8030f5 <xTickCount+0x3>
    210a:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <xPortStartScheduler>
    210e:	0f 91       	pop	r16
    2110:	ff 90       	pop	r15
    2112:	ef 90       	pop	r14
    2114:	df 90       	pop	r13
    2116:	cf 90       	pop	r12
    2118:	bf 90       	pop	r11
    211a:	af 90       	pop	r10
    211c:	08 95       	ret

0000211e <vTaskSuspendAll>:
    211e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    2122:	8f 5f       	subi	r24, 0xFF	; 255
    2124:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxSchedulerSuspended>
    2128:	08 95       	ret

0000212a <xTaskGetTickCount>:
    212a:	0f b6       	in	r0, 0x3f	; 63
    212c:	f8 94       	cli
    212e:	0f 92       	push	r0
    2130:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount>
    2134:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2138:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    213c:	90 91 f5 30 	lds	r25, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2140:	0f 90       	pop	r0
    2142:	0f be       	out	0x3f, r0	; 63
    2144:	08 95       	ret

00002146 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2146:	00 97       	sbiw	r24, 0x00	; 0
    2148:	21 f4       	brne	.+8      	; 0x2152 <pcTaskGetTaskName+0xc>
    214a:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    214e:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    2152:	4d 96       	adiw	r24, 0x1d	; 29
    2154:	08 95       	ret

00002156 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2156:	80 91 f7 30 	lds	r24, 0x30F7	; 0x8030f7 <xIdleTaskHandle>
    215a:	90 91 f8 30 	lds	r25, 0x30F8	; 0x8030f8 <xIdleTaskHandle+0x1>
    215e:	08 95       	ret

00002160 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2160:	ff 92       	push	r15
    2162:	0f 93       	push	r16
    2164:	1f 93       	push	r17
    2166:	cf 93       	push	r28
    2168:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    216a:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    216e:	81 11       	cpse	r24, r1
    2170:	ed c0       	rjmp	.+474    	; 0x234c <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    2172:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    2176:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    217a:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    217e:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2182:	01 96       	adiw	r24, 0x01	; 1
    2184:	a1 1d       	adc	r26, r1
    2186:	b1 1d       	adc	r27, r1
    2188:	80 93 f2 30 	sts	0x30F2, r24	; 0x8030f2 <xTickCount>
    218c:	90 93 f3 30 	sts	0x30F3, r25	; 0x8030f3 <xTickCount+0x1>
    2190:	a0 93 f4 30 	sts	0x30F4, r26	; 0x8030f4 <xTickCount+0x2>
    2194:	b0 93 f5 30 	sts	0x30F5, r27	; 0x8030f5 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2198:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    219c:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    21a0:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    21a4:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    21a8:	89 2b       	or	r24, r25
    21aa:	8a 2b       	or	r24, r26
    21ac:	8b 2b       	or	r24, r27
    21ae:	f1 f5       	brne	.+124    	; 0x222c <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    21b0:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <pxDelayedTaskList>
    21b4:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    21b8:	20 91 04 31 	lds	r18, 0x3104	; 0x803104 <pxOverflowDelayedTaskList>
    21bc:	30 91 05 31 	lds	r19, 0x3105	; 0x803105 <pxOverflowDelayedTaskList+0x1>
    21c0:	20 93 06 31 	sts	0x3106, r18	; 0x803106 <pxDelayedTaskList>
    21c4:	30 93 07 31 	sts	0x3107, r19	; 0x803107 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    21c8:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <pxOverflowDelayedTaskList>
    21cc:	90 93 05 31 	sts	0x3105, r25	; 0x803105 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    21d0:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <xNumOfOverflows>
    21d4:	8f 5f       	subi	r24, 0xFF	; 255
    21d6:	80 93 eb 30 	sts	0x30EB, r24	; 0x8030eb <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    21da:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    21de:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    21e2:	80 81       	ld	r24, Z
    21e4:	81 11       	cpse	r24, r1
    21e6:	0c c0       	rjmp	.+24     	; 0x2200 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    21e8:	8f ef       	ldi	r24, 0xFF	; 255
    21ea:	9f ef       	ldi	r25, 0xFF	; 255
    21ec:	dc 01       	movw	r26, r24
    21ee:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21f2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21f6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21fa:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    21fe:	16 c0       	rjmp	.+44     	; 0x222c <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2200:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    2204:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    2208:	07 80       	ldd	r0, Z+7	; 0x07
    220a:	f0 85       	ldd	r31, Z+8	; 0x08
    220c:	e0 2d       	mov	r30, r0
    220e:	00 84       	ldd	r0, Z+8	; 0x08
    2210:	f1 85       	ldd	r31, Z+9	; 0x09
    2212:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2214:	82 81       	ldd	r24, Z+2	; 0x02
    2216:	93 81       	ldd	r25, Z+3	; 0x03
    2218:	a4 81       	ldd	r26, Z+4	; 0x04
    221a:	b5 81       	ldd	r27, Z+5	; 0x05
    221c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2220:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2224:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2228:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    222c:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    2230:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2234:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    2238:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    223c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2240:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2244:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2248:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    224c:	48 17       	cp	r20, r24
    224e:	59 07       	cpc	r21, r25
    2250:	6a 07       	cpc	r22, r26
    2252:	7b 07       	cpc	r23, r27
    2254:	08 f4       	brcc	.+2      	; 0x2258 <vTaskIncrementTick+0xf8>
    2256:	7f c0       	rjmp	.+254    	; 0x2356 <vTaskIncrementTick+0x1f6>
    2258:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    225c:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    2260:	80 81       	ld	r24, Z
    2262:	88 23       	and	r24, r24
    2264:	f9 f0       	breq	.+62     	; 0x22a4 <vTaskIncrementTick+0x144>
    2266:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    226a:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    226e:	07 80       	ldd	r0, Z+7	; 0x07
    2270:	f0 85       	ldd	r31, Z+8	; 0x08
    2272:	e0 2d       	mov	r30, r0
    2274:	c0 85       	ldd	r28, Z+8	; 0x08
    2276:	d1 85       	ldd	r29, Z+9	; 0x09
    2278:	8a 81       	ldd	r24, Y+2	; 0x02
    227a:	9b 81       	ldd	r25, Y+3	; 0x03
    227c:	ac 81       	ldd	r26, Y+4	; 0x04
    227e:	bd 81       	ldd	r27, Y+5	; 0x05
    2280:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    2284:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2288:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    228c:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2290:	48 17       	cp	r20, r24
    2292:	59 07       	cpc	r21, r25
    2294:	6a 07       	cpc	r22, r26
    2296:	7b 07       	cpc	r23, r27
    2298:	58 f1       	brcs	.+86     	; 0x22f0 <vTaskIncrementTick+0x190>
    229a:	0f 2e       	mov	r0, r31
    229c:	fb e0       	ldi	r31, 0x0B	; 11
    229e:	ff 2e       	mov	r15, r31
    22a0:	f0 2d       	mov	r31, r0
    22a2:	2f c0       	rjmp	.+94     	; 0x2302 <vTaskIncrementTick+0x1a2>
    22a4:	8f ef       	ldi	r24, 0xFF	; 255
    22a6:	9f ef       	ldi	r25, 0xFF	; 255
    22a8:	dc 01       	movw	r26, r24
    22aa:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22ae:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22b2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22b6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    22ba:	4d c0       	rjmp	.+154    	; 0x2356 <vTaskIncrementTick+0x1f6>
    22bc:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    22c0:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    22c4:	07 80       	ldd	r0, Z+7	; 0x07
    22c6:	f0 85       	ldd	r31, Z+8	; 0x08
    22c8:	e0 2d       	mov	r30, r0
    22ca:	c0 85       	ldd	r28, Z+8	; 0x08
    22cc:	d1 85       	ldd	r29, Z+9	; 0x09
    22ce:	8a 81       	ldd	r24, Y+2	; 0x02
    22d0:	9b 81       	ldd	r25, Y+3	; 0x03
    22d2:	ac 81       	ldd	r26, Y+4	; 0x04
    22d4:	bd 81       	ldd	r27, Y+5	; 0x05
    22d6:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    22da:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    22de:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    22e2:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    22e6:	48 17       	cp	r20, r24
    22e8:	59 07       	cpc	r21, r25
    22ea:	6a 07       	cpc	r22, r26
    22ec:	7b 07       	cpc	r23, r27
    22ee:	48 f4       	brcc	.+18     	; 0x2302 <vTaskIncrementTick+0x1a2>
    22f0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22f4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22f8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22fc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2300:	2a c0       	rjmp	.+84     	; 0x2356 <vTaskIncrementTick+0x1f6>
    2302:	8e 01       	movw	r16, r28
    2304:	0e 5f       	subi	r16, 0xFE	; 254
    2306:	1f 4f       	sbci	r17, 0xFF	; 255
    2308:	c8 01       	movw	r24, r16
    230a:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
    230e:	88 8d       	ldd	r24, Y+24	; 0x18
    2310:	99 8d       	ldd	r25, Y+25	; 0x19
    2312:	89 2b       	or	r24, r25
    2314:	21 f0       	breq	.+8      	; 0x231e <vTaskIncrementTick+0x1be>
    2316:	ce 01       	movw	r24, r28
    2318:	0e 96       	adiw	r24, 0x0e	; 14
    231a:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
    231e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2320:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    2324:	98 17       	cp	r25, r24
    2326:	10 f4       	brcc	.+4      	; 0x232c <vTaskIncrementTick+0x1cc>
    2328:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    232c:	f8 9e       	mul	r15, r24
    232e:	c0 01       	movw	r24, r0
    2330:	11 24       	eor	r1, r1
    2332:	b8 01       	movw	r22, r16
    2334:	82 5e       	subi	r24, 0xE2	; 226
    2336:	9e 4c       	sbci	r25, 0xCE	; 206
    2338:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
    233c:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    2340:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    2344:	80 81       	ld	r24, Z
    2346:	81 11       	cpse	r24, r1
    2348:	b9 cf       	rjmp	.-142    	; 0x22bc <vTaskIncrementTick+0x15c>
    234a:	ac cf       	rjmp	.-168    	; 0x22a4 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    234c:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    2350:	8f 5f       	subi	r24, 0xFF	; 255
    2352:	80 93 ed 30 	sts	0x30ED, r24	; 0x8030ed <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2356:	df 91       	pop	r29
    2358:	cf 91       	pop	r28
    235a:	1f 91       	pop	r17
    235c:	0f 91       	pop	r16
    235e:	ff 90       	pop	r15
    2360:	08 95       	ret

00002362 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2362:	cf 92       	push	r12
    2364:	df 92       	push	r13
    2366:	ef 92       	push	r14
    2368:	ff 92       	push	r15
    236a:	0f 93       	push	r16
    236c:	1f 93       	push	r17
    236e:	cf 93       	push	r28
    2370:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2372:	0f b6       	in	r0, 0x3f	; 63
    2374:	f8 94       	cli
    2376:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2378:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    237c:	81 50       	subi	r24, 0x01	; 1
    237e:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2382:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    2386:	81 11       	cpse	r24, r1
    2388:	60 c0       	rjmp	.+192    	; 0x244a <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    238a:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxCurrentNumberOfTasks>
    238e:	81 11       	cpse	r24, r1
    2390:	2c c0       	rjmp	.+88     	; 0x23ea <xTaskResumeAll+0x88>
    2392:	5e c0       	rjmp	.+188    	; 0x2450 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2394:	d7 01       	movw	r26, r14
    2396:	17 96       	adiw	r26, 0x07	; 7
    2398:	ed 91       	ld	r30, X+
    239a:	fc 91       	ld	r31, X
    239c:	18 97       	sbiw	r26, 0x08	; 8
    239e:	c0 85       	ldd	r28, Z+8	; 0x08
    23a0:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    23a2:	ce 01       	movw	r24, r28
    23a4:	0e 96       	adiw	r24, 0x0e	; 14
    23a6:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    23aa:	8e 01       	movw	r16, r28
    23ac:	0e 5f       	subi	r16, 0xFE	; 254
    23ae:	1f 4f       	sbci	r17, 0xFF	; 255
    23b0:	c8 01       	movw	r24, r16
    23b2:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    23b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23b8:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    23bc:	98 17       	cp	r25, r24
    23be:	10 f4       	brcc	.+4      	; 0x23c4 <xTaskResumeAll+0x62>
    23c0:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    23c4:	d8 9e       	mul	r13, r24
    23c6:	c0 01       	movw	r24, r0
    23c8:	11 24       	eor	r1, r1
    23ca:	b8 01       	movw	r22, r16
    23cc:	82 5e       	subi	r24, 0xE2	; 226
    23ce:	9e 4c       	sbci	r25, 0xCE	; 206
    23d0:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    23d4:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    23d8:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    23dc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    23de:	82 8d       	ldd	r24, Z+26	; 0x1a
    23e0:	98 17       	cp	r25, r24
    23e2:	70 f0       	brcs	.+28     	; 0x2400 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    23e4:	cc 24       	eor	r12, r12
    23e6:	c3 94       	inc	r12
    23e8:	0b c0       	rjmp	.+22     	; 0x2400 <xTaskResumeAll+0x9e>
    23ea:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    23ec:	0f 2e       	mov	r0, r31
    23ee:	f9 ef       	ldi	r31, 0xF9	; 249
    23f0:	ef 2e       	mov	r14, r31
    23f2:	f0 e3       	ldi	r31, 0x30	; 48
    23f4:	ff 2e       	mov	r15, r31
    23f6:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    23f8:	0f 2e       	mov	r0, r31
    23fa:	fb e0       	ldi	r31, 0x0B	; 11
    23fc:	df 2e       	mov	r13, r31
    23fe:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2400:	f7 01       	movw	r30, r14
    2402:	80 81       	ld	r24, Z
    2404:	81 11       	cpse	r24, r1
    2406:	c6 cf       	rjmp	.-116    	; 0x2394 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2408:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    240c:	88 23       	and	r24, r24
    240e:	81 f0       	breq	.+32     	; 0x2430 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2410:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    2414:	88 23       	and	r24, r24
    2416:	99 f0       	breq	.+38     	; 0x243e <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2418:	0e 94 b0 10 	call	0x2160	; 0x2160 <vTaskIncrementTick>
						--uxMissedTicks;
    241c:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    2420:	81 50       	subi	r24, 0x01	; 1
    2422:	80 93 ed 30 	sts	0x30ED, r24	; 0x8030ed <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2426:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    242a:	81 11       	cpse	r24, r1
    242c:	f5 cf       	rjmp	.-22     	; 0x2418 <xTaskResumeAll+0xb6>
    242e:	07 c0       	rjmp	.+14     	; 0x243e <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2430:	f1 e0       	ldi	r31, 0x01	; 1
    2432:	cf 16       	cp	r12, r31
    2434:	21 f0       	breq	.+8      	; 0x243e <xTaskResumeAll+0xdc>
    2436:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <xMissedYield>
    243a:	81 30       	cpi	r24, 0x01	; 1
    243c:	41 f4       	brne	.+16     	; 0x244e <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    243e:	10 92 ec 30 	sts	0x30EC, r1	; 0x8030ec <xMissedYield>
					portYIELD_WITHIN_API();
    2442:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2446:	81 e0       	ldi	r24, 0x01	; 1
    2448:	03 c0       	rjmp	.+6      	; 0x2450 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    244a:	80 e0       	ldi	r24, 0x00	; 0
    244c:	01 c0       	rjmp	.+2      	; 0x2450 <xTaskResumeAll+0xee>
    244e:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2450:	0f 90       	pop	r0
    2452:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2454:	df 91       	pop	r29
    2456:	cf 91       	pop	r28
    2458:	1f 91       	pop	r17
    245a:	0f 91       	pop	r16
    245c:	ff 90       	pop	r15
    245e:	ef 90       	pop	r14
    2460:	df 90       	pop	r13
    2462:	cf 90       	pop	r12
    2464:	08 95       	ret

00002466 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2466:	cf 92       	push	r12
    2468:	df 92       	push	r13
    246a:	ef 92       	push	r14
    246c:	ff 92       	push	r15
    246e:	cf 93       	push	r28
    2470:	df 93       	push	r29
    2472:	ec 01       	movw	r28, r24
    2474:	6a 01       	movw	r12, r20
    2476:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2478:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    247c:	88 81       	ld	r24, Y
    247e:	99 81       	ldd	r25, Y+1	; 0x01
    2480:	aa 81       	ldd	r26, Y+2	; 0x02
    2482:	bb 81       	ldd	r27, Y+3	; 0x03
    2484:	c8 0e       	add	r12, r24
    2486:	d9 1e       	adc	r13, r25
    2488:	ea 1e       	adc	r14, r26
    248a:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    248c:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    2490:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2494:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    2498:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    249c:	48 17       	cp	r20, r24
    249e:	59 07       	cpc	r21, r25
    24a0:	6a 07       	cpc	r22, r26
    24a2:	7b 07       	cpc	r23, r27
    24a4:	b8 f4       	brcc	.+46     	; 0x24d4 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    24a6:	c8 16       	cp	r12, r24
    24a8:	d9 06       	cpc	r13, r25
    24aa:	ea 06       	cpc	r14, r26
    24ac:	fb 06       	cpc	r15, r27
    24ae:	e0 f5       	brcc	.+120    	; 0x2528 <vTaskDelayUntil+0xc2>
    24b0:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    24b4:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    24b8:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    24bc:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24c0:	c8 82       	st	Y, r12
    24c2:	d9 82       	std	Y+1, r13	; 0x01
    24c4:	ea 82       	std	Y+2, r14	; 0x02
    24c6:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    24c8:	8c 15       	cp	r24, r12
    24ca:	9d 05       	cpc	r25, r13
    24cc:	ae 05       	cpc	r26, r14
    24ce:	bf 05       	cpc	r27, r15
    24d0:	f8 f4       	brcc	.+62     	; 0x2510 <vTaskDelayUntil+0xaa>
    24d2:	13 c0       	rjmp	.+38     	; 0x24fa <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    24d4:	c8 16       	cp	r12, r24
    24d6:	d9 06       	cpc	r13, r25
    24d8:	ea 06       	cpc	r14, r26
    24da:	fb 06       	cpc	r15, r27
    24dc:	00 f1       	brcs	.+64     	; 0x251e <vTaskDelayUntil+0xb8>
    24de:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    24e2:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    24e6:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    24ea:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    24ee:	8c 15       	cp	r24, r12
    24f0:	9d 05       	cpc	r25, r13
    24f2:	ae 05       	cpc	r26, r14
    24f4:	bf 05       	cpc	r27, r15
    24f6:	98 f0       	brcs	.+38     	; 0x251e <vTaskDelayUntil+0xb8>
    24f8:	17 c0       	rjmp	.+46     	; 0x2528 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24fa:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    24fe:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    2502:	02 96       	adiw	r24, 0x02	; 2
    2504:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2508:	c7 01       	movw	r24, r14
    250a:	b6 01       	movw	r22, r12
    250c:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2510:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2514:	81 11       	cpse	r24, r1
    2516:	0d c0       	rjmp	.+26     	; 0x2532 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2518:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
		}
	}
    251c:	0a c0       	rjmp	.+20     	; 0x2532 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    251e:	c8 82       	st	Y, r12
    2520:	d9 82       	std	Y+1, r13	; 0x01
    2522:	ea 82       	std	Y+2, r14	; 0x02
    2524:	fb 82       	std	Y+3, r15	; 0x03
    2526:	e9 cf       	rjmp	.-46     	; 0x24fa <vTaskDelayUntil+0x94>
    2528:	c8 82       	st	Y, r12
    252a:	d9 82       	std	Y+1, r13	; 0x01
    252c:	ea 82       	std	Y+2, r14	; 0x02
    252e:	fb 82       	std	Y+3, r15	; 0x03
    2530:	ef cf       	rjmp	.-34     	; 0x2510 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2532:	df 91       	pop	r29
    2534:	cf 91       	pop	r28
    2536:	ff 90       	pop	r15
    2538:	ef 90       	pop	r14
    253a:	df 90       	pop	r13
    253c:	cf 90       	pop	r12
    253e:	08 95       	ret

00002540 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2540:	cf 92       	push	r12
    2542:	df 92       	push	r13
    2544:	ef 92       	push	r14
    2546:	ff 92       	push	r15
    2548:	6b 01       	movw	r12, r22
    254a:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    254c:	67 2b       	or	r22, r23
    254e:	68 2b       	or	r22, r24
    2550:	69 2b       	or	r22, r25
    2552:	e9 f0       	breq	.+58     	; 0x258e <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2554:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2558:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    255c:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2560:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    2564:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2568:	c8 0e       	add	r12, r24
    256a:	d9 1e       	adc	r13, r25
    256c:	ea 1e       	adc	r14, r26
    256e:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2570:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    2574:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    2578:	02 96       	adiw	r24, 0x02	; 2
    257a:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    257e:	c7 01       	movw	r24, r14
    2580:	b6 01       	movw	r22, r12
    2582:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2586:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    258a:	81 11       	cpse	r24, r1
    258c:	02 c0       	rjmp	.+4      	; 0x2592 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    258e:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
		}
	}
    2592:	ff 90       	pop	r15
    2594:	ef 90       	pop	r14
    2596:	df 90       	pop	r13
    2598:	cf 90       	pop	r12
    259a:	08 95       	ret

0000259c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    259c:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    25a0:	81 11       	cpse	r24, r1
    25a2:	0c c0       	rjmp	.+24     	; 0x25bc <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    25a4:	e0 91 f0 30 	lds	r30, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    25a8:	4b e0       	ldi	r20, 0x0B	; 11
    25aa:	e4 9f       	mul	r30, r20
    25ac:	f0 01       	movw	r30, r0
    25ae:	11 24       	eor	r1, r1
    25b0:	e2 5e       	subi	r30, 0xE2	; 226
    25b2:	fe 4c       	sbci	r31, 0xCE	; 206
    25b4:	80 81       	ld	r24, Z
    25b6:	88 23       	and	r24, r24
    25b8:	29 f0       	breq	.+10     	; 0x25c4 <vTaskSwitchContext+0x28>
    25ba:	14 c0       	rjmp	.+40     	; 0x25e4 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    25bc:	81 e0       	ldi	r24, 0x01	; 1
    25be:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <xMissedYield>
    25c2:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    25c4:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    25c6:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    25ca:	81 50       	subi	r24, 0x01	; 1
    25cc:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    25d0:	e0 91 f0 30 	lds	r30, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    25d4:	9e 9f       	mul	r25, r30
    25d6:	f0 01       	movw	r30, r0
    25d8:	11 24       	eor	r1, r1
    25da:	e2 5e       	subi	r30, 0xE2	; 226
    25dc:	fe 4c       	sbci	r31, 0xCE	; 206
    25de:	80 81       	ld	r24, Z
    25e0:	88 23       	and	r24, r24
    25e2:	89 f3       	breq	.-30     	; 0x25c6 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    25e4:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    25e8:	28 2f       	mov	r18, r24
    25ea:	30 e0       	ldi	r19, 0x00	; 0
    25ec:	4b e0       	ldi	r20, 0x0B	; 11
    25ee:	84 9f       	mul	r24, r20
    25f0:	c0 01       	movw	r24, r0
    25f2:	11 24       	eor	r1, r1
    25f4:	dc 01       	movw	r26, r24
    25f6:	a2 5e       	subi	r26, 0xE2	; 226
    25f8:	be 4c       	sbci	r27, 0xCE	; 206
    25fa:	11 96       	adiw	r26, 0x01	; 1
    25fc:	ed 91       	ld	r30, X+
    25fe:	fc 91       	ld	r31, X
    2600:	12 97       	sbiw	r26, 0x02	; 2
    2602:	04 80       	ldd	r0, Z+4	; 0x04
    2604:	f5 81       	ldd	r31, Z+5	; 0x05
    2606:	e0 2d       	mov	r30, r0
    2608:	11 96       	adiw	r26, 0x01	; 1
    260a:	ed 93       	st	X+, r30
    260c:	fc 93       	st	X, r31
    260e:	12 97       	sbiw	r26, 0x02	; 2
    2610:	8f 5d       	subi	r24, 0xDF	; 223
    2612:	9e 4c       	sbci	r25, 0xCE	; 206
    2614:	e8 17       	cp	r30, r24
    2616:	f9 07       	cpc	r31, r25
    2618:	61 f4       	brne	.+24     	; 0x2632 <vTaskSwitchContext+0x96>
    261a:	84 81       	ldd	r24, Z+4	; 0x04
    261c:	95 81       	ldd	r25, Z+5	; 0x05
    261e:	4b e0       	ldi	r20, 0x0B	; 11
    2620:	42 9f       	mul	r20, r18
    2622:	f0 01       	movw	r30, r0
    2624:	43 9f       	mul	r20, r19
    2626:	f0 0d       	add	r31, r0
    2628:	11 24       	eor	r1, r1
    262a:	e2 5e       	subi	r30, 0xE2	; 226
    262c:	fe 4c       	sbci	r31, 0xCE	; 206
    262e:	81 83       	std	Z+1, r24	; 0x01
    2630:	92 83       	std	Z+2, r25	; 0x02
    2632:	8b e0       	ldi	r24, 0x0B	; 11
    2634:	82 9f       	mul	r24, r18
    2636:	f0 01       	movw	r30, r0
    2638:	83 9f       	mul	r24, r19
    263a:	f0 0d       	add	r31, r0
    263c:	11 24       	eor	r1, r1
    263e:	e2 5e       	subi	r30, 0xE2	; 226
    2640:	fe 4c       	sbci	r31, 0xCE	; 206
    2642:	01 80       	ldd	r0, Z+1	; 0x01
    2644:	f2 81       	ldd	r31, Z+2	; 0x02
    2646:	e0 2d       	mov	r30, r0
    2648:	80 85       	ldd	r24, Z+8	; 0x08
    264a:	91 85       	ldd	r25, Z+9	; 0x09
    264c:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <pxCurrentTCB>
    2650:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <pxCurrentTCB+0x1>
    2654:	08 95       	ret

00002656 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2656:	cf 92       	push	r12
    2658:	df 92       	push	r13
    265a:	ef 92       	push	r14
    265c:	ff 92       	push	r15
    265e:	6a 01       	movw	r12, r20
    2660:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2662:	60 91 4a 31 	lds	r22, 0x314A	; 0x80314a <pxCurrentTCB>
    2666:	70 91 4b 31 	lds	r23, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    266a:	62 5f       	subi	r22, 0xF2	; 242
    266c:	7f 4f       	sbci	r23, 0xFF	; 255
    266e:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2672:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    2676:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    267a:	02 96       	adiw	r24, 0x02	; 2
    267c:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2680:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    2684:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2688:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    268c:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2690:	bc 01       	movw	r22, r24
    2692:	cd 01       	movw	r24, r26
    2694:	6c 0d       	add	r22, r12
    2696:	7d 1d       	adc	r23, r13
    2698:	8e 1d       	adc	r24, r14
    269a:	9f 1d       	adc	r25, r15
    269c:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    26a0:	ff 90       	pop	r15
    26a2:	ef 90       	pop	r14
    26a4:	df 90       	pop	r13
    26a6:	cf 90       	pop	r12
    26a8:	08 95       	ret

000026aa <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    26aa:	0f 93       	push	r16
    26ac:	1f 93       	push	r17
    26ae:	cf 93       	push	r28
    26b0:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    26b2:	dc 01       	movw	r26, r24
    26b4:	17 96       	adiw	r26, 0x07	; 7
    26b6:	ed 91       	ld	r30, X+
    26b8:	fc 91       	ld	r31, X
    26ba:	18 97       	sbiw	r26, 0x08	; 8
    26bc:	c0 85       	ldd	r28, Z+8	; 0x08
    26be:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    26c0:	8e 01       	movw	r16, r28
    26c2:	02 5f       	subi	r16, 0xF2	; 242
    26c4:	1f 4f       	sbci	r17, 0xFF	; 255
    26c6:	c8 01       	movw	r24, r16
    26c8:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    26cc:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    26d0:	81 11       	cpse	r24, r1
    26d2:	16 c0       	rjmp	.+44     	; 0x2700 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    26d4:	0c 50       	subi	r16, 0x0C	; 12
    26d6:	11 09       	sbc	r17, r1
    26d8:	c8 01       	movw	r24, r16
    26da:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    26de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    26e0:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    26e4:	98 17       	cp	r25, r24
    26e6:	10 f4       	brcc	.+4      	; 0x26ec <xTaskRemoveFromEventList+0x42>
    26e8:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    26ec:	bb e0       	ldi	r27, 0x0B	; 11
    26ee:	8b 9f       	mul	r24, r27
    26f0:	c0 01       	movw	r24, r0
    26f2:	11 24       	eor	r1, r1
    26f4:	b8 01       	movw	r22, r16
    26f6:	82 5e       	subi	r24, 0xE2	; 226
    26f8:	9e 4c       	sbci	r25, 0xCE	; 206
    26fa:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
    26fe:	05 c0       	rjmp	.+10     	; 0x270a <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2700:	b8 01       	movw	r22, r16
    2702:	89 ef       	ldi	r24, 0xF9	; 249
    2704:	90 e3       	ldi	r25, 0x30	; 48
    2706:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    270a:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    270e:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2712:	81 e0       	ldi	r24, 0x01	; 1
    2714:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2716:	92 8d       	ldd	r25, Z+26	; 0x1a
    2718:	29 17       	cp	r18, r25
    271a:	08 f4       	brcc	.+2      	; 0x271e <xTaskRemoveFromEventList+0x74>
    271c:	80 e0       	ldi	r24, 0x00	; 0
}
    271e:	df 91       	pop	r29
    2720:	cf 91       	pop	r28
    2722:	1f 91       	pop	r17
    2724:	0f 91       	pop	r16
    2726:	08 95       	ret

00002728 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2728:	20 91 eb 30 	lds	r18, 0x30EB	; 0x8030eb <xNumOfOverflows>
    272c:	fc 01       	movw	r30, r24
    272e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2730:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    2734:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2738:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    273c:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2740:	41 83       	std	Z+1, r20	; 0x01
    2742:	52 83       	std	Z+2, r21	; 0x02
    2744:	63 83       	std	Z+3, r22	; 0x03
    2746:	74 83       	std	Z+4, r23	; 0x04
    2748:	08 95       	ret

0000274a <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    274a:	8f 92       	push	r8
    274c:	9f 92       	push	r9
    274e:	af 92       	push	r10
    2750:	bf 92       	push	r11
    2752:	cf 92       	push	r12
    2754:	df 92       	push	r13
    2756:	ef 92       	push	r14
    2758:	ff 92       	push	r15
    275a:	0f 93       	push	r16
    275c:	1f 93       	push	r17
    275e:	cf 93       	push	r28
    2760:	df 93       	push	r29
    2762:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2764:	0f b6       	in	r0, 0x3f	; 63
    2766:	f8 94       	cli
    2768:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    276a:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <xNumOfOverflows>
    276e:	90 81       	ld	r25, Z
    2770:	98 17       	cp	r25, r24
    2772:	89 f0       	breq	.+34     	; 0x2796 <xTaskCheckForTimeOut+0x4c>
    2774:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    2778:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    277c:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    2780:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2784:	01 81       	ldd	r16, Z+1	; 0x01
    2786:	12 81       	ldd	r17, Z+2	; 0x02
    2788:	23 81       	ldd	r18, Z+3	; 0x03
    278a:	34 81       	ldd	r19, Z+4	; 0x04
    278c:	80 17       	cp	r24, r16
    278e:	91 07       	cpc	r25, r17
    2790:	a2 07       	cpc	r26, r18
    2792:	b3 07       	cpc	r27, r19
    2794:	a8 f5       	brcc	.+106    	; 0x2800 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2796:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    279a:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    279e:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    27a2:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    27a6:	c1 80       	ldd	r12, Z+1	; 0x01
    27a8:	d2 80       	ldd	r13, Z+2	; 0x02
    27aa:	e3 80       	ldd	r14, Z+3	; 0x03
    27ac:	f4 80       	ldd	r15, Z+4	; 0x04
    27ae:	eb 01       	movw	r28, r22
    27b0:	08 81       	ld	r16, Y
    27b2:	19 81       	ldd	r17, Y+1	; 0x01
    27b4:	2a 81       	ldd	r18, Y+2	; 0x02
    27b6:	3b 81       	ldd	r19, Y+3	; 0x03
    27b8:	8c 19       	sub	r24, r12
    27ba:	9d 09       	sbc	r25, r13
    27bc:	ae 09       	sbc	r26, r14
    27be:	bf 09       	sbc	r27, r15
    27c0:	80 17       	cp	r24, r16
    27c2:	91 07       	cpc	r25, r17
    27c4:	a2 07       	cpc	r26, r18
    27c6:	b3 07       	cpc	r27, r19
    27c8:	e8 f4       	brcc	.+58     	; 0x2804 <xTaskCheckForTimeOut+0xba>
    27ca:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    27cc:	80 90 f2 30 	lds	r8, 0x30F2	; 0x8030f2 <xTickCount>
    27d0:	90 90 f3 30 	lds	r9, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    27d4:	a0 90 f4 30 	lds	r10, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    27d8:	b0 90 f5 30 	lds	r11, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    27dc:	b5 01       	movw	r22, r10
    27de:	a4 01       	movw	r20, r8
    27e0:	4c 19       	sub	r20, r12
    27e2:	5d 09       	sbc	r21, r13
    27e4:	6e 09       	sbc	r22, r14
    27e6:	7f 09       	sbc	r23, r15
    27e8:	04 1b       	sub	r16, r20
    27ea:	15 0b       	sbc	r17, r21
    27ec:	26 0b       	sbc	r18, r22
    27ee:	37 0b       	sbc	r19, r23
    27f0:	08 83       	st	Y, r16
    27f2:	19 83       	std	Y+1, r17	; 0x01
    27f4:	2a 83       	std	Y+2, r18	; 0x02
    27f6:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    27f8:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    27fc:	80 e0       	ldi	r24, 0x00	; 0
    27fe:	03 c0       	rjmp	.+6      	; 0x2806 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	01 c0       	rjmp	.+2      	; 0x2806 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2804:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2806:	0f 90       	pop	r0
    2808:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    280a:	df 91       	pop	r29
    280c:	cf 91       	pop	r28
    280e:	1f 91       	pop	r17
    2810:	0f 91       	pop	r16
    2812:	ff 90       	pop	r15
    2814:	ef 90       	pop	r14
    2816:	df 90       	pop	r13
    2818:	cf 90       	pop	r12
    281a:	bf 90       	pop	r11
    281c:	af 90       	pop	r10
    281e:	9f 90       	pop	r9
    2820:	8f 90       	pop	r8
    2822:	08 95       	ret

00002824 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2824:	81 e0       	ldi	r24, 0x01	; 1
    2826:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <xMissedYield>
    282a:	08 95       	ret

0000282c <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    282c:	00 97       	sbiw	r24, 0x00	; 0
    282e:	21 f4       	brne	.+8      	; 0x2838 <uxTaskGetStackHighWaterMark+0xc>
    2830:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    2834:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2838:	dc 01       	movw	r26, r24
    283a:	5b 96       	adiw	r26, 0x1b	; 27
    283c:	ed 91       	ld	r30, X+
    283e:	fc 91       	ld	r31, X
    2840:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2842:	80 81       	ld	r24, Z
    2844:	81 31       	cpi	r24, 0x11	; 17
    2846:	41 f4       	brne	.+16     	; 0x2858 <uxTaskGetStackHighWaterMark+0x2c>
    2848:	31 96       	adiw	r30, 0x01	; 1
    284a:	80 e0       	ldi	r24, 0x00	; 0
    284c:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    284e:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2850:	21 91       	ld	r18, Z+
    2852:	21 31       	cpi	r18, 0x11	; 17
    2854:	e1 f3       	breq	.-8      	; 0x284e <uxTaskGetStackHighWaterMark+0x22>
    2856:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2858:	80 e0       	ldi	r24, 0x00	; 0
    285a:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    285c:	08 95       	ret

0000285e <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    285e:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    2862:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>

		return xReturn;
	}
    2866:	08 95       	ret

00002868 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2868:	0f 93       	push	r16
    286a:	1f 93       	push	r17
    286c:	cf 93       	push	r28
    286e:	df 93       	push	r29
    2870:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2872:	22 8d       	ldd	r18, Z+26	; 0x1a
    2874:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    2878:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    287c:	5a 96       	adiw	r26, 0x1a	; 26
    287e:	8c 91       	ld	r24, X
    2880:	28 17       	cp	r18, r24
    2882:	08 f0       	brcs	.+2      	; 0x2886 <vTaskPriorityInherit+0x1e>
    2884:	41 c0       	rjmp	.+130    	; 0x2908 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2886:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    288a:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    288e:	5a 96       	adiw	r26, 0x1a	; 26
    2890:	3c 91       	ld	r19, X
    2892:	84 e0       	ldi	r24, 0x04	; 4
    2894:	90 e0       	ldi	r25, 0x00	; 0
    2896:	a0 e0       	ldi	r26, 0x00	; 0
    2898:	b0 e0       	ldi	r27, 0x00	; 0
    289a:	83 1b       	sub	r24, r19
    289c:	91 09       	sbc	r25, r1
    289e:	a1 09       	sbc	r26, r1
    28a0:	b1 09       	sbc	r27, r1
    28a2:	86 87       	std	Z+14, r24	; 0x0e
    28a4:	97 87       	std	Z+15, r25	; 0x0f
    28a6:	a0 8b       	std	Z+16, r26	; 0x10
    28a8:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    28aa:	8b e0       	ldi	r24, 0x0B	; 11
    28ac:	28 9f       	mul	r18, r24
    28ae:	90 01       	movw	r18, r0
    28b0:	11 24       	eor	r1, r1
    28b2:	22 5e       	subi	r18, 0xE2	; 226
    28b4:	3e 4c       	sbci	r19, 0xCE	; 206
    28b6:	84 85       	ldd	r24, Z+12	; 0x0c
    28b8:	95 85       	ldd	r25, Z+13	; 0x0d
    28ba:	82 17       	cp	r24, r18
    28bc:	93 07       	cpc	r25, r19
    28be:	e9 f4       	brne	.+58     	; 0x28fa <vTaskPriorityInherit+0x92>
    28c0:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    28c2:	ef 01       	movw	r28, r30
    28c4:	22 96       	adiw	r28, 0x02	; 2
    28c6:	ce 01       	movw	r24, r28
    28c8:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    28cc:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    28d0:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    28d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    28d6:	f8 01       	movw	r30, r16
    28d8:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    28da:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    28de:	98 17       	cp	r25, r24
    28e0:	10 f4       	brcc	.+4      	; 0x28e6 <vTaskPriorityInherit+0x7e>
    28e2:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    28e6:	fb e0       	ldi	r31, 0x0B	; 11
    28e8:	8f 9f       	mul	r24, r31
    28ea:	c0 01       	movw	r24, r0
    28ec:	11 24       	eor	r1, r1
    28ee:	be 01       	movw	r22, r28
    28f0:	82 5e       	subi	r24, 0xE2	; 226
    28f2:	9e 4c       	sbci	r25, 0xCE	; 206
    28f4:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
    28f8:	07 c0       	rjmp	.+14     	; 0x2908 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    28fa:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    28fe:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    2902:	5a 96       	adiw	r26, 0x1a	; 26
    2904:	8c 91       	ld	r24, X
    2906:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2908:	df 91       	pop	r29
    290a:	cf 91       	pop	r28
    290c:	1f 91       	pop	r17
    290e:	0f 91       	pop	r16
    2910:	08 95       	ret

00002912 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2912:	0f 93       	push	r16
    2914:	1f 93       	push	r17
    2916:	cf 93       	push	r28
    2918:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    291a:	00 97       	sbiw	r24, 0x00	; 0
    291c:	49 f1       	breq	.+82     	; 0x2970 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    291e:	fc 01       	movw	r30, r24
    2920:	32 8d       	ldd	r19, Z+26	; 0x1a
    2922:	27 a1       	ldd	r18, Z+39	; 0x27
    2924:	32 17       	cp	r19, r18
    2926:	21 f1       	breq	.+72     	; 0x2970 <vTaskPriorityDisinherit+0x5e>
    2928:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    292a:	8c 01       	movw	r16, r24
    292c:	0e 5f       	subi	r16, 0xFE	; 254
    292e:	1f 4f       	sbci	r17, 0xFF	; 255
    2930:	c8 01       	movw	r24, r16
    2932:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2936:	8f a1       	ldd	r24, Y+39	; 0x27
    2938:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    293a:	44 e0       	ldi	r20, 0x04	; 4
    293c:	50 e0       	ldi	r21, 0x00	; 0
    293e:	60 e0       	ldi	r22, 0x00	; 0
    2940:	70 e0       	ldi	r23, 0x00	; 0
    2942:	48 1b       	sub	r20, r24
    2944:	51 09       	sbc	r21, r1
    2946:	61 09       	sbc	r22, r1
    2948:	71 09       	sbc	r23, r1
    294a:	4e 87       	std	Y+14, r20	; 0x0e
    294c:	5f 87       	std	Y+15, r21	; 0x0f
    294e:	68 8b       	std	Y+16, r22	; 0x10
    2950:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2952:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    2956:	98 17       	cp	r25, r24
    2958:	10 f4       	brcc	.+4      	; 0x295e <vTaskPriorityDisinherit+0x4c>
    295a:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    295e:	fb e0       	ldi	r31, 0x0B	; 11
    2960:	8f 9f       	mul	r24, r31
    2962:	c0 01       	movw	r24, r0
    2964:	11 24       	eor	r1, r1
    2966:	b8 01       	movw	r22, r16
    2968:	82 5e       	subi	r24, 0xE2	; 226
    296a:	9e 4c       	sbci	r25, 0xCE	; 206
    296c:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
			}
		}
	}
    2970:	df 91       	pop	r29
    2972:	cf 91       	pop	r28
    2974:	1f 91       	pop	r17
    2976:	0f 91       	pop	r16
    2978:	08 95       	ret

0000297a <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    297a:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    297c:	e8 81       	ld	r30, Y
    297e:	f9 81       	ldd	r31, Y+1	; 0x01
    2980:	01 90       	ld	r0, Z+
    2982:	f0 81       	ld	r31, Z
    2984:	e0 2d       	mov	r30, r0
    2986:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2988:	1a 82       	std	Y+2, r1	; 0x02
    298a:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    298c:	6f ef       	ldi	r22, 0xFF	; 255
    298e:	7f ef       	ldi	r23, 0xFF	; 255
    2990:	cb 01       	movw	r24, r22
    2992:	0e 94 a0 12 	call	0x2540	; 0x2540 <vTaskDelay>
    2996:	fa cf       	rjmp	.-12     	; 0x298c <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002998 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2998:	fc 01       	movw	r30, r24
    299a:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    299c:	65 87       	std	Z+13, r22	; 0x0d
    299e:	08 95       	ret

000029a0 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    29a0:	4f 92       	push	r4
    29a2:	5f 92       	push	r5
    29a4:	6f 92       	push	r6
    29a6:	7f 92       	push	r7
    29a8:	8f 92       	push	r8
    29aa:	9f 92       	push	r9
    29ac:	af 92       	push	r10
    29ae:	bf 92       	push	r11
    29b0:	cf 92       	push	r12
    29b2:	df 92       	push	r13
    29b4:	ef 92       	push	r14
    29b6:	ff 92       	push	r15
    29b8:	0f 93       	push	r16
    29ba:	1f 93       	push	r17
    29bc:	cf 93       	push	r28
    29be:	df 93       	push	r29
    29c0:	cd b7       	in	r28, 0x3d	; 61
    29c2:	de b7       	in	r29, 0x3e	; 62
    29c4:	2a 97       	sbiw	r28, 0x0a	; 10
    29c6:	cd bf       	out	0x3d, r28	; 61
    29c8:	de bf       	out	0x3e, r29	; 62
    29ca:	4c 01       	movw	r8, r24
    29cc:	29 01       	movw	r4, r18
    29ce:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    29d0:	85 e6       	ldi	r24, 0x65	; 101
    29d2:	90 e2       	ldi	r25, 0x20	; 32
    29d4:	f4 01       	movw	r30, r8
    29d6:	80 83       	st	Z, r24
    29d8:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    29da:	fb 01       	movw	r30, r22
    29dc:	80 81       	ld	r24, Z
    29de:	88 23       	and	r24, r24
    29e0:	69 f0       	breq	.+26     	; 0x29fc <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    29e2:	de 01       	movw	r26, r28
    29e4:	11 96       	adiw	r26, 0x01	; 1
    29e6:	31 96       	adiw	r30, 0x01	; 1
    29e8:	90 e0       	ldi	r25, 0x00	; 0
    29ea:	02 c0       	rjmp	.+4      	; 0x29f0 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    29ec:	99 30       	cpi	r25, 0x09	; 9
    29ee:	39 f0       	breq	.+14     	; 0x29fe <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    29f0:	9f 5f       	subi	r25, 0xFF	; 255
    29f2:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    29f4:	81 91       	ld	r24, Z+
    29f6:	81 11       	cpse	r24, r1
    29f8:	f9 cf       	rjmp	.-14     	; 0x29ec <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    29fa:	01 c0       	rjmp	.+2      	; 0x29fe <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    29fc:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    29fe:	e1 e0       	ldi	r30, 0x01	; 1
    2a00:	f0 e0       	ldi	r31, 0x00	; 0
    2a02:	ec 0f       	add	r30, r28
    2a04:	fd 1f       	adc	r31, r29
    2a06:	e9 0f       	add	r30, r25
    2a08:	f1 1d       	adc	r31, r1
    2a0a:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2a0c:	74 01       	movw	r14, r8
    2a0e:	f2 e0       	ldi	r31, 0x02	; 2
    2a10:	ef 0e       	add	r14, r31
    2a12:	f1 1c       	adc	r15, r1
    2a14:	a1 2c       	mov	r10, r1
    2a16:	b1 2c       	mov	r11, r1
    2a18:	c1 2c       	mov	r12, r1
    2a1a:	d1 2c       	mov	r13, r1
    2a1c:	04 2f       	mov	r16, r20
    2a1e:	94 01       	movw	r18, r8
    2a20:	a2 01       	movw	r20, r4
    2a22:	be 01       	movw	r22, r28
    2a24:	6f 5f       	subi	r22, 0xFF	; 255
    2a26:	7f 4f       	sbci	r23, 0xFF	; 255
    2a28:	86 ea       	ldi	r24, 0xA6	; 166
    2a2a:	92 e0       	ldi	r25, 0x02	; 2
    2a2c:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2a30:	f4 01       	movw	r30, r8
    2a32:	66 82       	std	Z+6, r6	; 0x06
    2a34:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2a36:	40 86       	std	Z+8, r4	; 0x08
    2a38:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2a3a:	20 91 4c 31 	lds	r18, 0x314C	; 0x80314c <last_created_task_pointer>
    2a3e:	30 91 4d 31 	lds	r19, 0x314D	; 0x80314d <last_created_task_pointer+0x1>
    2a42:	24 83       	std	Z+4, r18	; 0x04
    2a44:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2a46:	80 92 4c 31 	sts	0x314C, r8	; 0x80314c <last_created_task_pointer>
    2a4a:	90 92 4d 31 	sts	0x314D, r9	; 0x80314d <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2a4e:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2a50:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2a52:	40 90 86 31 	lds	r4, 0x3186	; 0x803186 <portStackTopForTask>
    2a56:	50 90 87 31 	lds	r5, 0x3187	; 0x803187 <portStackTopForTask+0x1>
    2a5a:	ff ef       	ldi	r31, 0xFF	; 255
    2a5c:	4f 1a       	sub	r4, r31
    2a5e:	5f 0a       	sbc	r5, r31
    2a60:	40 92 86 31 	sts	0x3186, r4	; 0x803186 <portStackTopForTask>
    2a64:	50 92 87 31 	sts	0x3187, r5	; 0x803187 <portStackTopForTask+0x1>
    2a68:	f4 01       	movw	r30, r8
    2a6a:	42 86       	std	Z+10, r4	; 0x0a
    2a6c:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2a6e:	16 86       	std	Z+14, r1	; 0x0e
    2a70:	17 86       	std	Z+15, r1	; 0x0f
    2a72:	10 8a       	std	Z+16, r1	; 0x10
    2a74:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2a76:	61 14       	cp	r6, r1
    2a78:	71 04       	cpc	r7, r1
    2a7a:	09 f4       	brne	.+2      	; 0x2a7e <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a7c:	44 c0       	rjmp	.+136    	; 0x2b06 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a7e:	81 30       	cpi	r24, 0x01	; 1
    2a80:	79 f5       	brne	.+94     	; 0x2ae0 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a82:	6a e0       	ldi	r22, 0x0A	; 10
    2a84:	c3 01       	movw	r24, r6
    2a86:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2a8a:	7c 01       	movw	r14, r24
    2a8c:	69 e9       	ldi	r22, 0x99	; 153
    2a8e:	74 e0       	ldi	r23, 0x04	; 4
    2a90:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2a94:	be 01       	movw	r22, r28
    2a96:	6f 5f       	subi	r22, 0xFF	; 255
    2a98:	7f 4f       	sbci	r23, 0xFF	; 255
    2a9a:	c7 01       	movw	r24, r14
    2a9c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2aa0:	6a e0       	ldi	r22, 0x0A	; 10
    2aa2:	c7 01       	movw	r24, r14
    2aa4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2aa8:	7c 01       	movw	r14, r24
    2aaa:	60 e9       	ldi	r22, 0x90	; 144
    2aac:	74 e0       	ldi	r23, 0x04	; 4
    2aae:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2ab2:	6a e0       	ldi	r22, 0x0A	; 10
    2ab4:	c7 01       	movw	r24, r14
    2ab6:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2aba:	7c 01       	movw	r14, r24
    2abc:	62 e8       	ldi	r22, 0x82	; 130
    2abe:	74 e0       	ldi	r23, 0x04	; 4
    2ac0:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2ac4:	63 e0       	ldi	r22, 0x03	; 3
    2ac6:	c7 01       	movw	r24, r14
    2ac8:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2acc:	b2 01       	movw	r22, r4
    2ace:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    2ad2:	62 e0       	ldi	r22, 0x02	; 2
    2ad4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ad8:	66 e0       	ldi	r22, 0x06	; 6
    2ada:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ade:	13 c0       	rjmp	.+38     	; 0x2b06 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2ae0:	6a e0       	ldi	r22, 0x0A	; 10
    2ae2:	c3 01       	movw	r24, r6
    2ae4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ae8:	4c 01       	movw	r8, r24
    2aea:	6d e6       	ldi	r22, 0x6D	; 109
    2aec:	74 e0       	ldi	r23, 0x04	; 4
    2aee:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2af2:	be 01       	movw	r22, r28
    2af4:	6f 5f       	subi	r22, 0xFF	; 255
    2af6:	7f 4f       	sbci	r23, 0xFF	; 255
    2af8:	c4 01       	movw	r24, r8
    2afa:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2afe:	66 e0       	ldi	r22, 0x06	; 6
    2b00:	c4 01       	movw	r24, r8
    2b02:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2b06:	2a 96       	adiw	r28, 0x0a	; 10
    2b08:	cd bf       	out	0x3d, r28	; 61
    2b0a:	de bf       	out	0x3e, r29	; 62
    2b0c:	df 91       	pop	r29
    2b0e:	cf 91       	pop	r28
    2b10:	1f 91       	pop	r17
    2b12:	0f 91       	pop	r16
    2b14:	ff 90       	pop	r15
    2b16:	ef 90       	pop	r14
    2b18:	df 90       	pop	r13
    2b1a:	cf 90       	pop	r12
    2b1c:	bf 90       	pop	r11
    2b1e:	af 90       	pop	r10
    2b20:	9f 90       	pop	r9
    2b22:	8f 90       	pop	r8
    2b24:	7f 90       	pop	r7
    2b26:	6f 90       	pop	r6
    2b28:	5f 90       	pop	r5
    2b2a:	4f 90       	pop	r4
    2b2c:	08 95       	ret

00002b2e <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2b2e:	cf 92       	push	r12
    2b30:	df 92       	push	r13
    2b32:	ef 92       	push	r14
    2b34:	ff 92       	push	r15
    2b36:	0f 93       	push	r16
    2b38:	1f 93       	push	r17
    2b3a:	cf 93       	push	r28
    2b3c:	df 93       	push	r29
    2b3e:	ec 01       	movw	r28, r24
    2b40:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2b42:	8a 81       	ldd	r24, Y+2	; 0x02
    2b44:	9b 81       	ldd	r25, Y+3	; 0x03
    2b46:	0e 94 a3 10 	call	0x2146	; 0x2146 <pcTaskGetTaskName>
    2b4a:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2b4c:	6a e0       	ldi	r22, 0x0A	; 10
    2b4e:	c7 01       	movw	r24, r14
    2b50:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2b54:	8c 01       	movw	r16, r24
    2b56:	6c ea       	ldi	r22, 0xAC	; 172
    2b58:	74 e0       	ldi	r23, 0x04	; 4
    2b5a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2b5e:	6a e0       	ldi	r22, 0x0A	; 10
    2b60:	c8 01       	movw	r24, r16
    2b62:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2b66:	8c 01       	movw	r16, r24
    2b68:	65 ea       	ldi	r22, 0xA5	; 165
    2b6a:	74 e0       	ldi	r23, 0x04	; 4
    2b6c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2b70:	b6 01       	movw	r22, r12
    2b72:	c8 01       	movw	r24, r16
    2b74:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2b78:	6a e0       	ldi	r22, 0x0A	; 10
    2b7a:	c8 01       	movw	r24, r16
    2b7c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2b80:	8c 01       	movw	r16, r24
    2b82:	6f e9       	ldi	r22, 0x9F	; 159
    2b84:	74 e0       	ldi	r23, 0x04	; 4
    2b86:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2b8a:	66 e0       	ldi	r22, 0x06	; 6
    2b8c:	c8 01       	movw	r24, r16
    2b8e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b92:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b94:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b96:	e8 85       	ldd	r30, Y+8	; 0x08
    2b98:	f9 85       	ldd	r31, Y+9	; 0x09
    2b9a:	01 e1       	ldi	r16, 0x11	; 17
    2b9c:	21 e0       	ldi	r18, 0x01	; 1
    2b9e:	a7 01       	movw	r20, r14
    2ba0:	bc 01       	movw	r22, r24
    2ba2:	8e 1b       	sub	r24, r30
    2ba4:	9f 0b       	sbc	r25, r31
    2ba6:	0e 94 99 18 	call	0x3132	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2baa:	8c 81       	ldd	r24, Y+4	; 0x04
    2bac:	9d 81       	ldd	r25, Y+5	; 0x05
    2bae:	00 97       	sbiw	r24, 0x00	; 0
    2bb0:	19 f0       	breq	.+6      	; 0x2bb8 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2bb2:	b7 01       	movw	r22, r14
    2bb4:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2bb8:	df 91       	pop	r29
    2bba:	cf 91       	pop	r28
    2bbc:	1f 91       	pop	r17
    2bbe:	0f 91       	pop	r16
    2bc0:	ff 90       	pop	r15
    2bc2:	ef 90       	pop	r14
    2bc4:	df 90       	pop	r13
    2bc6:	cf 90       	pop	r12
    2bc8:	08 95       	ret

00002bca <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2bca:	0f 93       	push	r16
    2bcc:	1f 93       	push	r17
    2bce:	cf 93       	push	r28
    2bd0:	df 93       	push	r29
    2bd2:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2bd4:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <last_created_task_pointer>
    2bd8:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <last_created_task_pointer+0x1>
    2bdc:	00 97       	sbiw	r24, 0x00	; 0
    2bde:	19 f0       	breq	.+6      	; 0x2be6 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2be0:	be 01       	movw	r22, r28
    2be2:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2be6:	6a e0       	ldi	r22, 0x0A	; 10
    2be8:	ce 01       	movw	r24, r28
    2bea:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2bee:	8c 01       	movw	r16, r24
    2bf0:	62 ec       	ldi	r22, 0xC2	; 194
    2bf2:	74 e0       	ldi	r23, 0x04	; 4
    2bf4:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2bf8:	6a e0       	ldi	r22, 0x0A	; 10
    2bfa:	c8 01       	movw	r24, r16
    2bfc:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2c00:	8c 01       	movw	r16, r24
    2c02:	67 eb       	ldi	r22, 0xB7	; 183
    2c04:	74 e0       	ldi	r23, 0x04	; 4
    2c06:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2c0a:	6a e0       	ldi	r22, 0x0A	; 10
    2c0c:	c8 01       	movw	r24, r16
    2c0e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2c12:	8c 01       	movw	r16, r24
    2c14:	61 eb       	ldi	r22, 0xB1	; 177
    2c16:	74 e0       	ldi	r23, 0x04	; 4
    2c18:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2c1c:	66 e0       	ldi	r22, 0x06	; 6
    2c1e:	c8 01       	movw	r24, r16
    2c20:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2c24:	80 91 86 31 	lds	r24, 0x3186	; 0x803186 <portStackTopForTask>
    2c28:	90 91 87 31 	lds	r25, 0x3187	; 0x803187 <portStackTopForTask+0x1>
    2c2c:	bc 01       	movw	r22, r24
    2c2e:	6f 5f       	subi	r22, 0xFF	; 255
    2c30:	7f 4f       	sbci	r23, 0xFF	; 255
    2c32:	01 e1       	ldi	r16, 0x11	; 17
    2c34:	21 e0       	ldi	r18, 0x01	; 1
    2c36:	ae 01       	movw	r20, r28
    2c38:	83 56       	subi	r24, 0x63	; 99
    2c3a:	91 09       	sbc	r25, r1
    2c3c:	0e 94 99 18 	call	0x3132	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2c40:	df 91       	pop	r29
    2c42:	cf 91       	pop	r28
    2c44:	1f 91       	pop	r17
    2c46:	0f 91       	pop	r16
    2c48:	08 95       	ret

00002c4a <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2c4a:	8f 92       	push	r8
    2c4c:	9f 92       	push	r9
    2c4e:	af 92       	push	r10
    2c50:	bf 92       	push	r11
    2c52:	cf 92       	push	r12
    2c54:	df 92       	push	r13
    2c56:	ef 92       	push	r14
    2c58:	ff 92       	push	r15
    2c5a:	0f 93       	push	r16
    2c5c:	1f 93       	push	r17
    2c5e:	cf 93       	push	r28
    2c60:	df 93       	push	r29
    2c62:	ec 01       	movw	r28, r24
    2c64:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2c66:	8a 81       	ldd	r24, Y+2	; 0x02
    2c68:	9b 81       	ldd	r25, Y+3	; 0x03
    2c6a:	0e 94 a3 10 	call	0x2146	; 0x2146 <pcTaskGetTaskName>
    2c6e:	bc 01       	movw	r22, r24
    2c70:	c8 01       	movw	r24, r16
    2c72:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2c76:	d8 01       	movw	r26, r16
    2c78:	ed 91       	ld	r30, X+
    2c7a:	fc 91       	ld	r31, X
    2c7c:	02 80       	ldd	r0, Z+2	; 0x02
    2c7e:	f3 81       	ldd	r31, Z+3	; 0x03
    2c80:	e0 2d       	mov	r30, r0
    2c82:	69 e0       	ldi	r22, 0x09	; 9
    2c84:	c8 01       	movw	r24, r16
    2c86:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c88:	8a 81       	ldd	r24, Y+2	; 0x02
    2c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c8c:	0e 94 a3 10 	call	0x2146	; 0x2146 <pcTaskGetTaskName>
    2c90:	fc 01       	movw	r30, r24
    2c92:	01 90       	ld	r0, Z+
    2c94:	00 20       	and	r0, r0
    2c96:	e9 f7       	brne	.-6      	; 0x2c92 <_ZN8frt_task12print_statusER8emstream+0x48>
    2c98:	31 97       	sbiw	r30, 0x01	; 1
    2c9a:	e8 1b       	sub	r30, r24
    2c9c:	f9 0b       	sbc	r31, r25
    2c9e:	38 97       	sbiw	r30, 0x08	; 8
    2ca0:	48 f4       	brcc	.+18     	; 0x2cb4 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2ca2:	d8 01       	movw	r26, r16
    2ca4:	ed 91       	ld	r30, X+
    2ca6:	fc 91       	ld	r31, X
    2ca8:	02 80       	ldd	r0, Z+2	; 0x02
    2caa:	f3 81       	ldd	r31, Z+3	; 0x03
    2cac:	e0 2d       	mov	r30, r0
    2cae:	69 e0       	ldi	r22, 0x09	; 9
    2cb0:	c8 01       	movw	r24, r16
    2cb2:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2cb4:	ce 84       	ldd	r12, Y+14	; 0x0e
    2cb6:	df 84       	ldd	r13, Y+15	; 0x0f
    2cb8:	e8 88       	ldd	r14, Y+16	; 0x10
    2cba:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2cbc:	a8 84       	ldd	r10, Y+8	; 0x08
    2cbe:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    2cc4:	0e 94 16 14 	call	0x282c	; 0x282c <uxTaskGetStackHighWaterMark>
    2cc8:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2cca:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    2cce:	9b 81       	ldd	r25, Y+3	; 0x03
    2cd0:	0e 94 4e 10 	call	0x209c	; 0x209c <uxTaskPriorityGet>
    2cd4:	68 2f       	mov	r22, r24
    2cd6:	c8 01       	movw	r24, r16
    2cd8:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    2cdc:	6a e0       	ldi	r22, 0x0A	; 10
    2cde:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ce2:	ec 01       	movw	r28, r24
    2ce4:	67 e3       	ldi	r22, 0x37	; 55
    2ce6:	75 e0       	ldi	r23, 0x05	; 5
    2ce8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
			<< get_state ()
    2cec:	68 2d       	mov	r22, r8
    2cee:	ce 01       	movw	r24, r28
    2cf0:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2cf4:	6a e0       	ldi	r22, 0x0A	; 10
    2cf6:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2cfa:	ec 01       	movw	r28, r24
    2cfc:	65 e3       	ldi	r22, 0x35	; 53
    2cfe:	75 e0       	ldi	r23, 0x05	; 5
    2d00:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2d04:	69 2d       	mov	r22, r9
    2d06:	ce 01       	movw	r24, r28
    2d08:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    2d0c:	6a e0       	ldi	r22, 0x0A	; 10
    2d0e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2d12:	ec 01       	movw	r28, r24
    2d14:	63 e3       	ldi	r22, 0x33	; 51
    2d16:	75 e0       	ldi	r23, 0x05	; 5
    2d18:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2d1c:	b5 01       	movw	r22, r10
    2d1e:	ce 01       	movw	r24, r28
    2d20:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    2d24:	6a e0       	ldi	r22, 0x0A	; 10
    2d26:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2d2a:	ec 01       	movw	r28, r24
    2d2c:	61 e3       	ldi	r22, 0x31	; 49
    2d2e:	75 e0       	ldi	r23, 0x05	; 5
    2d30:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2d34:	6a e0       	ldi	r22, 0x0A	; 10
    2d36:	ce 01       	movw	r24, r28
    2d38:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2d3c:	ec 01       	movw	r28, r24
    2d3e:	6f e2       	ldi	r22, 0x2F	; 47
    2d40:	75 e0       	ldi	r23, 0x05	; 5
    2d42:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2d46:	b7 01       	movw	r22, r14
    2d48:	a6 01       	movw	r20, r12
    2d4a:	ce 01       	movw	r24, r28
    2d4c:	0e 94 04 1b 	call	0x3608	; 0x3608 <_ZN8emstreamlsEm>
}
    2d50:	df 91       	pop	r29
    2d52:	cf 91       	pop	r28
    2d54:	1f 91       	pop	r17
    2d56:	0f 91       	pop	r16
    2d58:	ff 90       	pop	r15
    2d5a:	ef 90       	pop	r14
    2d5c:	df 90       	pop	r13
    2d5e:	cf 90       	pop	r12
    2d60:	bf 90       	pop	r11
    2d62:	af 90       	pop	r10
    2d64:	9f 90       	pop	r9
    2d66:	8f 90       	pop	r8
    2d68:	08 95       	ret

00002d6a <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2d6a:	cf 93       	push	r28
    2d6c:	df 93       	push	r29
    2d6e:	ec 01       	movw	r28, r24
    2d70:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2d72:	db 01       	movw	r26, r22
    2d74:	ed 91       	ld	r30, X+
    2d76:	fc 91       	ld	r31, X
    2d78:	02 80       	ldd	r0, Z+2	; 0x02
    2d7a:	f3 81       	ldd	r31, Z+3	; 0x03
    2d7c:	e0 2d       	mov	r30, r0
    2d7e:	be 01       	movw	r22, r28
    2d80:	19 95       	eicall
	return (ser_dev);
}
    2d82:	ce 01       	movw	r24, r28
    2d84:	df 91       	pop	r29
    2d86:	cf 91       	pop	r28
    2d88:	08 95       	ret

00002d8a <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2d8a:	0f 93       	push	r16
    2d8c:	1f 93       	push	r17
    2d8e:	cf 93       	push	r28
    2d90:	df 93       	push	r29
    2d92:	ec 01       	movw	r28, r24
    2d94:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d96:	bc 01       	movw	r22, r24
    2d98:	c8 01       	movw	r24, r16
    2d9a:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <_ZlsR8emstreamR8frt_task>
    2d9e:	66 e0       	ldi	r22, 0x06	; 6
    2da0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2da4:	8c 81       	ldd	r24, Y+4	; 0x04
    2da6:	9d 81       	ldd	r25, Y+5	; 0x05
    2da8:	00 97       	sbiw	r24, 0x00	; 0
    2daa:	19 f0       	breq	.+6      	; 0x2db2 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2dac:	b8 01       	movw	r22, r16
    2dae:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2db2:	df 91       	pop	r29
    2db4:	cf 91       	pop	r28
    2db6:	1f 91       	pop	r17
    2db8:	0f 91       	pop	r16
    2dba:	08 95       	ret

00002dbc <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2dbc:	0f 93       	push	r16
    2dbe:	1f 93       	push	r17
    2dc0:	cf 93       	push	r28
    2dc2:	df 93       	push	r29
    2dc4:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2dc6:	6a e0       	ldi	r22, 0x0A	; 10
    2dc8:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2dcc:	8c 01       	movw	r16, r24
    2dce:	64 e2       	ldi	r22, 0x24	; 36
    2dd0:	75 e0       	ldi	r23, 0x05	; 5
    2dd2:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2dd6:	6a e0       	ldi	r22, 0x0A	; 10
    2dd8:	c8 01       	movw	r24, r16
    2dda:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2dde:	8c 01       	movw	r16, r24
    2de0:	6d e1       	ldi	r22, 0x1D	; 29
    2de2:	75 e0       	ldi	r23, 0x05	; 5
    2de4:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2de8:	66 e0       	ldi	r22, 0x06	; 6
    2dea:	c8 01       	movw	r24, r16
    2dec:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2df0:	6a e0       	ldi	r22, 0x0A	; 10
    2df2:	ce 01       	movw	r24, r28
    2df4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2df8:	8c 01       	movw	r16, r24
    2dfa:	6c e0       	ldi	r22, 0x0C	; 12
    2dfc:	75 e0       	ldi	r23, 0x05	; 5
    2dfe:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2e02:	6a e0       	ldi	r22, 0x0A	; 10
    2e04:	c8 01       	movw	r24, r16
    2e06:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e0a:	8c 01       	movw	r16, r24
    2e0c:	60 e0       	ldi	r22, 0x00	; 0
    2e0e:	75 e0       	ldi	r23, 0x05	; 5
    2e10:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2e14:	6a e0       	ldi	r22, 0x0A	; 10
    2e16:	c8 01       	movw	r24, r16
    2e18:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e1c:	8c 01       	movw	r16, r24
    2e1e:	6a ef       	ldi	r22, 0xFA	; 250
    2e20:	74 e0       	ldi	r23, 0x04	; 4
    2e22:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2e26:	66 e0       	ldi	r22, 0x06	; 6
    2e28:	c8 01       	movw	r24, r16
    2e2a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2e2e:	6a e0       	ldi	r22, 0x0A	; 10
    2e30:	ce 01       	movw	r24, r28
    2e32:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e36:	8c 01       	movw	r16, r24
    2e38:	69 ee       	ldi	r22, 0xE9	; 233
    2e3a:	74 e0       	ldi	r23, 0x04	; 4
    2e3c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2e40:	6a e0       	ldi	r22, 0x0A	; 10
    2e42:	c8 01       	movw	r24, r16
    2e44:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e48:	8c 01       	movw	r16, r24
    2e4a:	6d ed       	ldi	r22, 0xDD	; 221
    2e4c:	74 e0       	ldi	r23, 0x04	; 4
    2e4e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2e52:	6a e0       	ldi	r22, 0x0A	; 10
    2e54:	c8 01       	movw	r24, r16
    2e56:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e5a:	8c 01       	movw	r16, r24
    2e5c:	67 ed       	ldi	r22, 0xD7	; 215
    2e5e:	74 e0       	ldi	r23, 0x04	; 4
    2e60:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2e64:	66 e0       	ldi	r22, 0x06	; 6
    2e66:	c8 01       	movw	r24, r16
    2e68:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2e6c:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <last_created_task_pointer>
    2e70:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <last_created_task_pointer+0x1>
    2e74:	00 97       	sbiw	r24, 0x00	; 0
    2e76:	19 f0       	breq	.+6      	; 0x2e7e <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2e78:	be 01       	movw	r22, r28
    2e7a:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e7e:	0e 94 ab 10 	call	0x2156	; 0x2156 <xTaskGetIdleTaskHandle>
    2e82:	0e 94 16 14 	call	0x282c	; 0x282c <uxTaskGetStackHighWaterMark>
    2e86:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2e88:	6a e0       	ldi	r22, 0x0A	; 10
    2e8a:	ce 01       	movw	r24, r28
    2e8c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e90:	ec 01       	movw	r28, r24
    2e92:	6c ec       	ldi	r22, 0xCC	; 204
    2e94:	74 e0       	ldi	r23, 0x04	; 4
    2e96:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e9a:	61 2f       	mov	r22, r17
    2e9c:	ce 01       	movw	r24, r28
    2e9e:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2ea2:	6a e0       	ldi	r22, 0x0A	; 10
    2ea4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ea8:	ec 01       	movw	r28, r24
    2eaa:	6a ec       	ldi	r22, 0xCA	; 202
    2eac:	74 e0       	ldi	r23, 0x04	; 4
    2eae:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2eb2:	64 e6       	ldi	r22, 0x64	; 100
    2eb4:	70 e0       	ldi	r23, 0x00	; 0
    2eb6:	ce 01       	movw	r24, r28
    2eb8:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    2ebc:	6a e0       	ldi	r22, 0x0A	; 10
    2ebe:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ec2:	ec 01       	movw	r28, r24
    2ec4:	67 ec       	ldi	r22, 0xC7	; 199
    2ec6:	74 e0       	ldi	r23, 0x04	; 4
    2ec8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2ecc:	66 e0       	ldi	r22, 0x06	; 6
    2ece:	ce 01       	movw	r24, r28
    2ed0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
}
    2ed4:	df 91       	pop	r29
    2ed6:	cf 91       	pop	r28
    2ed8:	1f 91       	pop	r17
    2eda:	0f 91       	pop	r16
    2edc:	08 95       	ret

00002ede <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2ede:	0f 93       	push	r16
    2ee0:	cf 93       	push	r28
    2ee2:	df 93       	push	r29
    2ee4:	1f 92       	push	r1
    2ee6:	cd b7       	in	r28, 0x3d	; 61
    2ee8:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2eea:	00 e0       	ldi	r16, 0x00	; 0
    2eec:	2f ef       	ldi	r18, 0xFF	; 255
    2eee:	3f ef       	ldi	r19, 0xFF	; 255
    2ef0:	a9 01       	movw	r20, r18
    2ef2:	be 01       	movw	r22, r28
    2ef4:	6f 5f       	subi	r22, 0xFF	; 255
    2ef6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ef8:	fc 01       	movw	r30, r24
    2efa:	80 85       	ldd	r24, Z+8	; 0x08
    2efc:	91 85       	ldd	r25, Z+9	; 0x09
    2efe:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xQueueGenericReceive>
    2f02:	81 30       	cpi	r24, 0x01	; 1
    2f04:	19 f4       	brne	.+6      	; 0x2f0c <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2f06:	89 81       	ldd	r24, Y+1	; 0x01
    2f08:	90 e0       	ldi	r25, 0x00	; 0
    2f0a:	02 c0       	rjmp	.+4      	; 0x2f10 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2f0c:	8f ef       	ldi	r24, 0xFF	; 255
    2f0e:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2f10:	0f 90       	pop	r0
    2f12:	df 91       	pop	r29
    2f14:	cf 91       	pop	r28
    2f16:	0f 91       	pop	r16
    2f18:	08 95       	ret

00002f1a <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2f1a:	fc 01       	movw	r30, r24
    2f1c:	80 85       	ldd	r24, Z+8	; 0x08
    2f1e:	91 85       	ldd	r25, Z+9	; 0x09
    2f20:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <uxQueueMessagesWaiting>
    2f24:	91 e0       	ldi	r25, 0x01	; 1
    2f26:	81 11       	cpse	r24, r1
    2f28:	01 c0       	rjmp	.+2      	; 0x2f2c <_ZN14frt_text_queue14check_for_charEv+0x12>
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2f2c:	89 2f       	mov	r24, r25
    2f2e:	08 95       	ret

00002f30 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2f30:	0f 93       	push	r16
    2f32:	cf 93       	push	r28
    2f34:	df 93       	push	r29
    2f36:	1f 92       	push	r1
    2f38:	cd b7       	in	r28, 0x3d	; 61
    2f3a:	de b7       	in	r29, 0x3e	; 62
    2f3c:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2f3e:	fc 01       	movw	r30, r24
    2f40:	22 85       	ldd	r18, Z+10	; 0x0a
    2f42:	33 85       	ldd	r19, Z+11	; 0x0b
    2f44:	44 85       	ldd	r20, Z+12	; 0x0c
    2f46:	55 85       	ldd	r21, Z+13	; 0x0d
    2f48:	00 e0       	ldi	r16, 0x00	; 0
    2f4a:	be 01       	movw	r22, r28
    2f4c:	6f 5f       	subi	r22, 0xFF	; 255
    2f4e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f50:	80 85       	ldd	r24, Z+8	; 0x08
    2f52:	91 85       	ldd	r25, Z+9	; 0x09
    2f54:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <xQueueGenericSend>
    2f58:	91 e0       	ldi	r25, 0x01	; 1
    2f5a:	81 11       	cpse	r24, r1
    2f5c:	01 c0       	rjmp	.+2      	; 0x2f60 <_ZN14frt_text_queue7putcharEc+0x30>
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2f60:	89 2f       	mov	r24, r25
    2f62:	0f 90       	pop	r0
    2f64:	df 91       	pop	r29
    2f66:	cf 91       	pop	r28
    2f68:	0f 91       	pop	r16
    2f6a:	08 95       	ret

00002f6c <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2f6c:	8f 92       	push	r8
    2f6e:	9f 92       	push	r9
    2f70:	bf 92       	push	r11
    2f72:	cf 92       	push	r12
    2f74:	df 92       	push	r13
    2f76:	ef 92       	push	r14
    2f78:	ff 92       	push	r15
    2f7a:	0f 93       	push	r16
    2f7c:	1f 93       	push	r17
    2f7e:	cf 93       	push	r28
    2f80:	df 93       	push	r29
    2f82:	ec 01       	movw	r28, r24
    2f84:	b6 2e       	mov	r11, r22
    2f86:	4a 01       	movw	r8, r20
    2f88:	68 01       	movw	r12, r16
    2f8a:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f8c:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <_ZN8emstreamC1Ev>
    2f90:	8d e6       	ldi	r24, 0x6D	; 109
    2f92:	90 e2       	ldi	r25, 0x20	; 32
    2f94:	88 83       	st	Y, r24
    2f96:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f98:	8e 86       	std	Y+14, r8	; 0x0e
    2f9a:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f9c:	40 e0       	ldi	r20, 0x00	; 0
    2f9e:	61 e0       	ldi	r22, 0x01	; 1
    2fa0:	8b 2d       	mov	r24, r11
    2fa2:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <xQueueGenericCreate>
    2fa6:	88 87       	std	Y+8, r24	; 0x08
    2fa8:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2faa:	ca 86       	std	Y+10, r12	; 0x0a
    2fac:	db 86       	std	Y+11, r13	; 0x0b
    2fae:	ec 86       	std	Y+12, r14	; 0x0c
    2fb0:	fd 86       	std	Y+13, r15	; 0x0d
}
    2fb2:	df 91       	pop	r29
    2fb4:	cf 91       	pop	r28
    2fb6:	1f 91       	pop	r17
    2fb8:	0f 91       	pop	r16
    2fba:	ff 90       	pop	r15
    2fbc:	ef 90       	pop	r14
    2fbe:	df 90       	pop	r13
    2fc0:	cf 90       	pop	r12
    2fc2:	bf 90       	pop	r11
    2fc4:	9f 90       	pop	r9
    2fc6:	8f 90       	pop	r8
    2fc8:	08 95       	ret

00002fca <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2fca:	cf 92       	push	r12
    2fcc:	df 92       	push	r13
    2fce:	ef 92       	push	r14
    2fd0:	ff 92       	push	r15
    2fd2:	cf 93       	push	r28
    2fd4:	df 93       	push	r29
    2fd6:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2fd8:	68 81       	ld	r22, Y
    2fda:	79 81       	ldd	r23, Y+1	; 0x01
    2fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    2fde:	9b 81       	ldd	r25, Y+3	; 0x03
    2fe0:	0f 2e       	mov	r0, r31
    2fe2:	f8 ee       	ldi	r31, 0xE8	; 232
    2fe4:	cf 2e       	mov	r12, r31
    2fe6:	f3 e0       	ldi	r31, 0x03	; 3
    2fe8:	df 2e       	mov	r13, r31
    2fea:	e1 2c       	mov	r14, r1
    2fec:	f1 2c       	mov	r15, r1
    2fee:	f0 2d       	mov	r31, r0
    2ff0:	a7 01       	movw	r20, r14
    2ff2:	96 01       	movw	r18, r12
    2ff4:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    2ff8:	9b 01       	movw	r18, r22
    2ffa:	ac 01       	movw	r20, r24
    2ffc:	60 e4       	ldi	r22, 0x40	; 64
    2ffe:	72 e4       	ldi	r23, 0x42	; 66
    3000:	8f e0       	ldi	r24, 0x0F	; 15
    3002:	90 e0       	ldi	r25, 0x00	; 0
    3004:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <__mulsi3>
    3008:	a7 01       	movw	r20, r14
    300a:	96 01       	movw	r18, r12
    300c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    3010:	69 01       	movw	r12, r18
    3012:	7a 01       	movw	r14, r20
    3014:	ac 81       	ldd	r26, Y+4	; 0x04
    3016:	bd 81       	ldd	r27, Y+5	; 0x05
    3018:	20 e4       	ldi	r18, 0x40	; 64
    301a:	32 e4       	ldi	r19, 0x42	; 66
    301c:	4f e0       	ldi	r20, 0x0F	; 15
    301e:	50 e0       	ldi	r21, 0x00	; 0
    3020:	0e 94 39 20 	call	0x4072	; 0x4072 <__muluhisi3>
    3024:	20 e0       	ldi	r18, 0x00	; 0
    3026:	38 e4       	ldi	r19, 0x48	; 72
    3028:	48 ee       	ldi	r20, 0xE8	; 232
    302a:	51 e0       	ldi	r21, 0x01	; 1
    302c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    3030:	c7 01       	movw	r24, r14
    3032:	b6 01       	movw	r22, r12
    3034:	62 0f       	add	r22, r18
    3036:	73 1f       	adc	r23, r19
    3038:	84 1f       	adc	r24, r20
    303a:	95 1f       	adc	r25, r21
}
    303c:	df 91       	pop	r29
    303e:	cf 91       	pop	r28
    3040:	ff 90       	pop	r15
    3042:	ef 90       	pop	r14
    3044:	df 90       	pop	r13
    3046:	cf 90       	pop	r12
    3048:	08 95       	ret

0000304a <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    304a:	cf 92       	push	r12
    304c:	df 92       	push	r13
    304e:	ef 92       	push	r14
    3050:	ff 92       	push	r15
    3052:	0f 93       	push	r16
    3054:	1f 93       	push	r17
    3056:	cf 93       	push	r28
    3058:	df 93       	push	r29
    305a:	cd b7       	in	r28, 0x3d	; 61
    305c:	de b7       	in	r29, 0x3e	; 62
    305e:	2f 97       	sbiw	r28, 0x0f	; 15
    3060:	cd bf       	out	0x3d, r28	; 61
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	6c 01       	movw	r12, r24
    3066:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3068:	db 01       	movw	r26, r22
    306a:	6d 91       	ld	r22, X+
    306c:	7d 91       	ld	r23, X+
    306e:	8d 91       	ld	r24, X+
    3070:	9c 91       	ld	r25, X
    3072:	28 ee       	ldi	r18, 0xE8	; 232
    3074:	33 e0       	ldi	r19, 0x03	; 3
    3076:	40 e0       	ldi	r20, 0x00	; 0
    3078:	50 e0       	ldi	r21, 0x00	; 0
    307a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    307e:	ba 01       	movw	r22, r20
    3080:	a9 01       	movw	r20, r18
    3082:	c6 01       	movw	r24, r12
    3084:	0e 94 04 1b 	call	0x3608	; 0x3608 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3088:	d6 01       	movw	r26, r12
    308a:	ed 91       	ld	r30, X+
    308c:	fc 91       	ld	r31, X
    308e:	02 80       	ldd	r0, Z+2	; 0x02
    3090:	f3 81       	ldd	r31, Z+3	; 0x03
    3092:	e0 2d       	mov	r30, r0
    3094:	6e e2       	ldi	r22, 0x2E	; 46
    3096:	c6 01       	movw	r24, r12
    3098:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    309a:	c8 01       	movw	r24, r16
    309c:	0e 94 e5 17 	call	0x2fca	; 0x2fca <_ZN10time_stamp12get_microsecEv>
    30a0:	8e 01       	movw	r16, r28
    30a2:	09 5f       	subi	r16, 0xF9	; 249
    30a4:	1f 4f       	sbci	r17, 0xFF	; 255
    30a6:	fe 01       	movw	r30, r28
    30a8:	31 96       	adiw	r30, 0x01	; 1
    30aa:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    30ac:	2a e0       	ldi	r18, 0x0A	; 10
    30ae:	30 e0       	ldi	r19, 0x00	; 0
    30b0:	40 e0       	ldi	r20, 0x00	; 0
    30b2:	50 e0       	ldi	r21, 0x00	; 0
    30b4:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <__divmodsi4>
    30b8:	e6 2f       	mov	r30, r22
    30ba:	28 87       	std	Y+8, r18	; 0x08
    30bc:	39 87       	std	Y+9, r19	; 0x09
    30be:	4a 87       	std	Y+10, r20	; 0x0a
    30c0:	5b 87       	std	Y+11, r21	; 0x0b
    30c2:	68 85       	ldd	r22, Y+8	; 0x08
    30c4:	79 85       	ldd	r23, Y+9	; 0x09
    30c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    30c8:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    30ca:	20 e3       	ldi	r18, 0x30	; 48
    30cc:	2e 0f       	add	r18, r30
    30ce:	d8 01       	movw	r26, r16
    30d0:	2e 93       	st	-X, r18
    30d2:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    30d4:	ae 15       	cp	r26, r14
    30d6:	bf 05       	cpc	r27, r15
    30d8:	49 f7       	brne	.-46     	; 0x30ac <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    30da:	1f 82       	std	Y+7, r1	; 0x07
    30dc:	be 01       	movw	r22, r28
    30de:	6f 5f       	subi	r22, 0xFF	; 255
    30e0:	7f 4f       	sbci	r23, 0xFF	; 255
    30e2:	c6 01       	movw	r24, r12
    30e4:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    30e8:	c6 01       	movw	r24, r12
    30ea:	2f 96       	adiw	r28, 0x0f	; 15
    30ec:	cd bf       	out	0x3d, r28	; 61
    30ee:	de bf       	out	0x3e, r29	; 62
    30f0:	df 91       	pop	r29
    30f2:	cf 91       	pop	r28
    30f4:	1f 91       	pop	r17
    30f6:	0f 91       	pop	r16
    30f8:	ff 90       	pop	r15
    30fa:	ef 90       	pop	r14
    30fc:	df 90       	pop	r13
    30fe:	cf 90       	pop	r12
    3100:	08 95       	ret

00003102 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3102:	cf 93       	push	r28
    3104:	df 93       	push	r29
    3106:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3108:	0f b6       	in	r0, 0x3f	; 63
    310a:	f8 94       	cli
    310c:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    310e:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3112:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3116:	8c 83       	std	Y+4, r24	; 0x04
    3118:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    311a:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
    311e:	68 83       	st	Y, r22
    3120:	79 83       	std	Y+1, r23	; 0x01
    3122:	8a 83       	std	Y+2, r24	; 0x02
    3124:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3126:	0f 90       	pop	r0
    3128:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    312a:	ce 01       	movw	r24, r28
    312c:	df 91       	pop	r29
    312e:	cf 91       	pop	r28
    3130:	08 95       	ret

00003132 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3132:	5f 92       	push	r5
    3134:	6f 92       	push	r6
    3136:	7f 92       	push	r7
    3138:	8f 92       	push	r8
    313a:	9f 92       	push	r9
    313c:	af 92       	push	r10
    313e:	bf 92       	push	r11
    3140:	cf 92       	push	r12
    3142:	df 92       	push	r13
    3144:	ef 92       	push	r14
    3146:	ff 92       	push	r15
    3148:	0f 93       	push	r16
    314a:	1f 93       	push	r17
    314c:	cf 93       	push	r28
    314e:	df 93       	push	r29
    3150:	5c 01       	movw	r10, r24
    3152:	4b 01       	movw	r8, r22
    3154:	7a 01       	movw	r14, r20
    3156:	12 2f       	mov	r17, r18
    3158:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    315a:	63 e0       	ldi	r22, 0x03	; 3
    315c:	ca 01       	movw	r24, r20
    315e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3162:	a8 14       	cp	r10, r8
    3164:	b9 04       	cpc	r11, r9
    3166:	08 f0       	brcs	.+2      	; 0x316a <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3168:	7d c0       	rjmp	.+250    	; 0x3264 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    316a:	65 01       	movw	r12, r10
    316c:	84 e1       	ldi	r24, 0x14	; 20
    316e:	c8 0e       	add	r12, r24
    3170:	d1 1c       	adc	r13, r1
    3172:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3174:	6a 2c       	mov	r6, r10
    3176:	5b 2c       	mov	r5, r11
    3178:	b5 01       	movw	r22, r10
    317a:	c7 01       	movw	r24, r14
    317c:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    3180:	6a e0       	ldi	r22, 0x0A	; 10
    3182:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    3186:	69 e4       	ldi	r22, 0x49	; 73
    3188:	75 e0       	ldi	r23, 0x05	; 5
    318a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    318e:	11 23       	and	r17, r17
    3190:	09 f4       	brne	.+2      	; 0x3194 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3192:	6d c0       	rjmp	.+218    	; 0x326e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3194:	00 23       	and	r16, r16
    3196:	09 f4       	brne	.+2      	; 0x319a <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3198:	6a c0       	rjmp	.+212    	; 0x326e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    319a:	6a e0       	ldi	r22, 0x0A	; 10
    319c:	c7 01       	movw	r24, r14
    319e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    31a2:	64 e4       	ldi	r22, 0x44	; 68
    31a4:	75 e0       	ldi	r23, 0x05	; 5
    31a6:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    31aa:	61 c0       	rjmp	.+194    	; 0x326e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    31ac:	11 23       	and	r17, r17
    31ae:	71 f0       	breq	.+28     	; 0x31cc <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    31b0:	01 11       	cpse	r16, r1
    31b2:	0c c0       	rjmp	.+24     	; 0x31cc <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    31b4:	88 81       	ld	r24, Y
    31b6:	87 15       	cp	r24, r7
    31b8:	49 f0       	breq	.+18     	; 0x31cc <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    31ba:	6a e0       	ldi	r22, 0x0A	; 10
    31bc:	c7 01       	movw	r24, r14
    31be:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    31c2:	6f e3       	ldi	r22, 0x3F	; 63
    31c4:	75 e0       	ldi	r23, 0x05	; 5
    31c6:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    31ca:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    31cc:	69 91       	ld	r22, Y+
    31ce:	c7 01       	movw	r24, r14
    31d0:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    31d4:	dc 01       	movw	r26, r24
    31d6:	ed 91       	ld	r30, X+
    31d8:	fc 91       	ld	r31, X
    31da:	02 80       	ldd	r0, Z+2	; 0x02
    31dc:	f3 81       	ldd	r31, Z+3	; 0x03
    31de:	e0 2d       	mov	r30, r0
    31e0:	60 e2       	ldi	r22, 0x20	; 32
    31e2:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    31e4:	cc 16       	cp	r12, r28
    31e6:	dd 06       	cpc	r13, r29
    31e8:	09 f7       	brne	.-62     	; 0x31ac <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    31ea:	11 23       	and	r17, r17
    31ec:	89 f0       	breq	.+34     	; 0x3210 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    31ee:	6a e0       	ldi	r22, 0x0A	; 10
    31f0:	c7 01       	movw	r24, r14
    31f2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    31f6:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    31f8:	69 e3       	ldi	r22, 0x39	; 57
    31fa:	75 e0       	ldi	r23, 0x05	; 5
    31fc:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3200:	e8 81       	ld	r30, Y
    3202:	f9 81       	ldd	r31, Y+1	; 0x01
    3204:	02 80       	ldd	r0, Z+2	; 0x02
    3206:	f3 81       	ldd	r31, Z+3	; 0x03
    3208:	e0 2d       	mov	r30, r0
    320a:	60 e2       	ldi	r22, 0x20	; 32
    320c:	ce 01       	movw	r24, r28
    320e:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3210:	c6 2d       	mov	r28, r6
    3212:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3214:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3216:	80 ee       	ldi	r24, 0xE0	; 224
    3218:	86 0f       	add	r24, r22
    321a:	8f 35       	cpi	r24, 0x5F	; 95
    321c:	48 f4       	brcc	.+18     	; 0x3230 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    321e:	d7 01       	movw	r26, r14
    3220:	ed 91       	ld	r30, X+
    3222:	fc 91       	ld	r31, X
    3224:	02 80       	ldd	r0, Z+2	; 0x02
    3226:	f3 81       	ldd	r31, Z+3	; 0x03
    3228:	e0 2d       	mov	r30, r0
    322a:	c7 01       	movw	r24, r14
    322c:	19 95       	eicall
    322e:	09 c0       	rjmp	.+18     	; 0x3242 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3230:	d7 01       	movw	r26, r14
    3232:	ed 91       	ld	r30, X+
    3234:	fc 91       	ld	r31, X
    3236:	02 80       	ldd	r0, Z+2	; 0x02
    3238:	f3 81       	ldd	r31, Z+3	; 0x03
    323a:	e0 2d       	mov	r30, r0
    323c:	6e e2       	ldi	r22, 0x2E	; 46
    323e:	c7 01       	movw	r24, r14
    3240:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3242:	cc 16       	cp	r12, r28
    3244:	dd 06       	cpc	r13, r29
    3246:	31 f7       	brne	.-52     	; 0x3214 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3248:	b4 e1       	ldi	r27, 0x14	; 20
    324a:	ab 0e       	add	r10, r27
    324c:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    324e:	66 e0       	ldi	r22, 0x06	; 6
    3250:	c7 01       	movw	r24, r14
    3252:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    3256:	84 e1       	ldi	r24, 0x14	; 20
    3258:	c8 0e       	add	r12, r24
    325a:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    325c:	a8 14       	cp	r10, r8
    325e:	b9 04       	cpc	r11, r9
    3260:	08 f4       	brcc	.+2      	; 0x3264 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3262:	88 cf       	rjmp	.-240    	; 0x3174 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3264:	62 e0       	ldi	r22, 0x02	; 2
    3266:	c7 01       	movw	r24, r14
    3268:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
}
    326c:	03 c0       	rjmp	.+6      	; 0x3274 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    326e:	c6 2d       	mov	r28, r6
    3270:	d5 2d       	mov	r29, r5
    3272:	9c cf       	rjmp	.-200    	; 0x31ac <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3274:	df 91       	pop	r29
    3276:	cf 91       	pop	r28
    3278:	1f 91       	pop	r17
    327a:	0f 91       	pop	r16
    327c:	ff 90       	pop	r15
    327e:	ef 90       	pop	r14
    3280:	df 90       	pop	r13
    3282:	cf 90       	pop	r12
    3284:	bf 90       	pop	r11
    3286:	af 90       	pop	r10
    3288:	9f 90       	pop	r9
    328a:	8f 90       	pop	r8
    328c:	7f 90       	pop	r7
    328e:	6f 90       	pop	r6
    3290:	5f 90       	pop	r5
    3292:	08 95       	ret

00003294 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3294:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    3298:	08 95       	ret

0000329a <_Znaj>:
    329a:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    329e:	08 95       	ret

000032a0 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    32a0:	08 95       	ret

000032a2 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    32a2:	cf 93       	push	r28
    32a4:	df 93       	push	r29
    32a6:	fc 01       	movw	r30, r24
    32a8:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    32aa:	40 3a       	cpi	r20, 0xA0	; 160
    32ac:	68 e0       	ldi	r22, 0x08	; 8
    32ae:	56 07       	cpc	r21, r22
    32b0:	49 f4       	brne	.+18     	; 0x32c4 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    32b2:	80 e4       	ldi	r24, 0x40	; 64
    32b4:	96 e0       	ldi	r25, 0x06	; 6
    32b6:	82 83       	std	Z+2, r24	; 0x02
    32b8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32ba:	82 e0       	ldi	r24, 0x02	; 2
    32bc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32be:	83 e0       	ldi	r24, 0x03	; 3
    32c0:	85 83       	std	Z+5, r24	; 0x05
    32c2:	32 c0       	rjmp	.+100    	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    32c4:	40 3b       	cpi	r20, 0xB0	; 176
    32c6:	78 e0       	ldi	r23, 0x08	; 8
    32c8:	57 07       	cpc	r21, r23
    32ca:	49 f4       	brne	.+18     	; 0x32de <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    32cc:	80 e4       	ldi	r24, 0x40	; 64
    32ce:	96 e0       	ldi	r25, 0x06	; 6
    32d0:	82 83       	std	Z+2, r24	; 0x02
    32d2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    32d4:	86 e0       	ldi	r24, 0x06	; 6
    32d6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32d8:	87 e0       	ldi	r24, 0x07	; 7
    32da:	85 83       	std	Z+5, r24	; 0x05
    32dc:	25 c0       	rjmp	.+74     	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    32de:	40 3a       	cpi	r20, 0xA0	; 160
    32e0:	89 e0       	ldi	r24, 0x09	; 9
    32e2:	58 07       	cpc	r21, r24
    32e4:	49 f4       	brne	.+18     	; 0x32f8 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    32e6:	80 e6       	ldi	r24, 0x60	; 96
    32e8:	96 e0       	ldi	r25, 0x06	; 6
    32ea:	82 83       	std	Z+2, r24	; 0x02
    32ec:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32ee:	82 e0       	ldi	r24, 0x02	; 2
    32f0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32f2:	83 e0       	ldi	r24, 0x03	; 3
    32f4:	85 83       	std	Z+5, r24	; 0x05
    32f6:	18 c0       	rjmp	.+48     	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    32f8:	40 3b       	cpi	r20, 0xB0	; 176
    32fa:	69 e0       	ldi	r22, 0x09	; 9
    32fc:	56 07       	cpc	r21, r22
    32fe:	49 f4       	brne	.+18     	; 0x3312 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3300:	80 e6       	ldi	r24, 0x60	; 96
    3302:	96 e0       	ldi	r25, 0x06	; 6
    3304:	82 83       	std	Z+2, r24	; 0x02
    3306:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3308:	86 e0       	ldi	r24, 0x06	; 6
    330a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    330c:	87 e0       	ldi	r24, 0x07	; 7
    330e:	85 83       	std	Z+5, r24	; 0x05
    3310:	0b c0       	rjmp	.+22     	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3312:	40 3a       	cpi	r20, 0xA0	; 160
    3314:	5a 40       	sbci	r21, 0x0A	; 10
    3316:	41 f4       	brne	.+16     	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3318:	80 e8       	ldi	r24, 0x80	; 128
    331a:	96 e0       	ldi	r25, 0x06	; 6
    331c:	82 83       	std	Z+2, r24	; 0x02
    331e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3320:	82 e0       	ldi	r24, 0x02	; 2
    3322:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3324:	83 e0       	ldi	r24, 0x03	; 3
    3326:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3328:	a6 83       	std	Z+6, r26	; 0x06
    332a:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    332c:	cd 01       	movw	r24, r26
    332e:	01 96       	adiw	r24, 0x01	; 1
    3330:	80 87       	std	Z+8, r24	; 0x08
    3332:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3334:	03 96       	adiw	r24, 0x03	; 3
    3336:	82 87       	std	Z+10, r24	; 0x0a
    3338:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    333a:	25 81       	ldd	r18, Z+5	; 0x05
    333c:	c2 81       	ldd	r28, Z+2	; 0x02
    333e:	d3 81       	ldd	r29, Z+3	; 0x03
    3340:	4c 81       	ldd	r20, Y+4	; 0x04
    3342:	81 e0       	ldi	r24, 0x01	; 1
    3344:	90 e0       	ldi	r25, 0x00	; 0
    3346:	bc 01       	movw	r22, r24
    3348:	02 c0       	rjmp	.+4      	; 0x334e <_ZN7base232C1EjP12USART_struct+0xac>
    334a:	66 0f       	add	r22, r22
    334c:	77 1f       	adc	r23, r23
    334e:	2a 95       	dec	r18
    3350:	e2 f7       	brpl	.-8      	; 0x334a <_ZN7base232C1EjP12USART_struct+0xa8>
    3352:	9b 01       	movw	r18, r22
    3354:	24 2b       	or	r18, r20
    3356:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3358:	25 81       	ldd	r18, Z+5	; 0x05
    335a:	c2 81       	ldd	r28, Z+2	; 0x02
    335c:	d3 81       	ldd	r29, Z+3	; 0x03
    335e:	48 81       	ld	r20, Y
    3360:	bc 01       	movw	r22, r24
    3362:	02 c0       	rjmp	.+4      	; 0x3368 <_ZN7base232C1EjP12USART_struct+0xc6>
    3364:	66 0f       	add	r22, r22
    3366:	77 1f       	adc	r23, r23
    3368:	2a 95       	dec	r18
    336a:	e2 f7       	brpl	.-8      	; 0x3364 <_ZN7base232C1EjP12USART_struct+0xc2>
    336c:	9b 01       	movw	r18, r22
    336e:	24 2b       	or	r18, r20
    3370:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3372:	34 81       	ldd	r19, Z+4	; 0x04
    3374:	c2 81       	ldd	r28, Z+2	; 0x02
    3376:	d3 81       	ldd	r29, Z+3	; 0x03
    3378:	28 81       	ld	r18, Y
    337a:	02 c0       	rjmp	.+4      	; 0x3380 <_ZN7base232C1EjP12USART_struct+0xde>
    337c:	88 0f       	add	r24, r24
    337e:	99 1f       	adc	r25, r25
    3380:	3a 95       	dec	r19
    3382:	e2 f7       	brpl	.-8      	; 0x337c <_ZN7base232C1EjP12USART_struct+0xda>
    3384:	80 95       	com	r24
    3386:	90 95       	com	r25
    3388:	82 23       	and	r24, r18
    338a:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    338c:	80 e1       	ldi	r24, 0x10	; 16
    338e:	13 96       	adiw	r26, 0x03	; 3
    3390:	8c 93       	st	X, r24
    3392:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3394:	83 e0       	ldi	r24, 0x03	; 3
    3396:	15 96       	adiw	r26, 0x05	; 5
    3398:	8c 93       	st	X, r24
    339a:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    339c:	80 ef       	ldi	r24, 0xF0	; 240
    339e:	17 96       	adiw	r26, 0x07	; 7
    33a0:	8c 93       	st	X, r24
    33a2:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    33a4:	81 e2       	ldi	r24, 0x21	; 33
    33a6:	16 96       	adiw	r26, 0x06	; 6
    33a8:	8c 93       	st	X, r24
    33aa:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    33ac:	88 e1       	ldi	r24, 0x18	; 24
    33ae:	14 96       	adiw	r26, 0x04	; 4
    33b0:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    33b2:	80 e8       	ldi	r24, 0x80	; 128
    33b4:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    33b6:	80 e4       	ldi	r24, 0x40	; 64
    33b8:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    33ba:	80 e2       	ldi	r24, 0x20	; 32
    33bc:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    33be:	06 80       	ldd	r0, Z+6	; 0x06
    33c0:	f7 81       	ldd	r31, Z+7	; 0x07
    33c2:	e0 2d       	mov	r30, r0
    33c4:	80 81       	ld	r24, Z
    33c6:	80 81       	ld	r24, Z
}
    33c8:	df 91       	pop	r29
    33ca:	cf 91       	pop	r28
    33cc:	08 95       	ret

000033ce <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    33ce:	81 e0       	ldi	r24, 0x01	; 1
    33d0:	08 95       	ret

000033d2 <_ZN8emstream7getcharEv>:
    33d2:	80 e0       	ldi	r24, 0x00	; 0
    33d4:	90 e0       	ldi	r25, 0x00	; 0
    33d6:	08 95       	ret

000033d8 <_ZN8emstream14check_for_charEv>:
    33d8:	80 e0       	ldi	r24, 0x00	; 0
    33da:	08 95       	ret

000033dc <_ZN8emstream12transmit_nowEv>:
    33dc:	08 95       	ret

000033de <_ZN8emstream12clear_screenEv>:
    33de:	08 95       	ret

000033e0 <_ZN8emstreamC1Ev>:
    33e0:	fc 01       	movw	r30, r24
    33e2:	8d e7       	ldi	r24, 0x7D	; 125
    33e4:	90 e2       	ldi	r25, 0x20	; 32
    33e6:	80 83       	st	Z, r24
    33e8:	91 83       	std	Z+1, r25	; 0x01
    33ea:	8a e0       	ldi	r24, 0x0A	; 10
    33ec:	82 83       	std	Z+2, r24	; 0x02
    33ee:	13 82       	std	Z+3, r1	; 0x03
    33f0:	83 e0       	ldi	r24, 0x03	; 3
    33f2:	85 83       	std	Z+5, r24	; 0x05
    33f4:	14 82       	std	Z+4, r1	; 0x04
    33f6:	16 82       	std	Z+6, r1	; 0x06
    33f8:	17 82       	std	Z+7, r1	; 0x07
    33fa:	08 95       	ret

000033fc <_ZN8emstream4putsEPKc>:
    33fc:	0f 93       	push	r16
    33fe:	1f 93       	push	r17
    3400:	cf 93       	push	r28
    3402:	df 93       	push	r29
    3404:	8c 01       	movw	r16, r24
    3406:	fb 01       	movw	r30, r22
    3408:	dc 01       	movw	r26, r24
    340a:	14 96       	adiw	r26, 0x04	; 4
    340c:	8c 91       	ld	r24, X
    340e:	81 11       	cpse	r24, r1
    3410:	04 c0       	rjmp	.+8      	; 0x341a <_ZN8emstream4putsEPKc+0x1e>
    3412:	60 81       	ld	r22, Z
    3414:	61 11       	cpse	r22, r1
    3416:	17 c0       	rjmp	.+46     	; 0x3446 <_ZN8emstream4putsEPKc+0x4a>
    3418:	23 c0       	rjmp	.+70     	; 0x3460 <_ZN8emstream4putsEPKc+0x64>
    341a:	d8 01       	movw	r26, r16
    341c:	14 96       	adiw	r26, 0x04	; 4
    341e:	1c 92       	st	X, r1
    3420:	eb 01       	movw	r28, r22
    3422:	21 96       	adiw	r28, 0x01	; 1
    3424:	64 91       	lpm	r22, Z
    3426:	66 23       	and	r22, r22
    3428:	d9 f0       	breq	.+54     	; 0x3460 <_ZN8emstream4putsEPKc+0x64>
    342a:	d8 01       	movw	r26, r16
    342c:	ed 91       	ld	r30, X+
    342e:	fc 91       	ld	r31, X
    3430:	02 80       	ldd	r0, Z+2	; 0x02
    3432:	f3 81       	ldd	r31, Z+3	; 0x03
    3434:	e0 2d       	mov	r30, r0
    3436:	c8 01       	movw	r24, r16
    3438:	19 95       	eicall
    343a:	fe 01       	movw	r30, r28
    343c:	64 91       	lpm	r22, Z
    343e:	21 96       	adiw	r28, 0x01	; 1
    3440:	61 11       	cpse	r22, r1
    3442:	f3 cf       	rjmp	.-26     	; 0x342a <_ZN8emstream4putsEPKc+0x2e>
    3444:	0d c0       	rjmp	.+26     	; 0x3460 <_ZN8emstream4putsEPKc+0x64>
    3446:	ef 01       	movw	r28, r30
    3448:	21 96       	adiw	r28, 0x01	; 1
    344a:	d8 01       	movw	r26, r16
    344c:	ed 91       	ld	r30, X+
    344e:	fc 91       	ld	r31, X
    3450:	02 80       	ldd	r0, Z+2	; 0x02
    3452:	f3 81       	ldd	r31, Z+3	; 0x03
    3454:	e0 2d       	mov	r30, r0
    3456:	c8 01       	movw	r24, r16
    3458:	19 95       	eicall
    345a:	69 91       	ld	r22, Y+
    345c:	61 11       	cpse	r22, r1
    345e:	f5 cf       	rjmp	.-22     	; 0x344a <_ZN8emstream4putsEPKc+0x4e>
    3460:	df 91       	pop	r29
    3462:	cf 91       	pop	r28
    3464:	1f 91       	pop	r17
    3466:	0f 91       	pop	r16
    3468:	08 95       	ret

0000346a <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    346a:	cf 93       	push	r28
    346c:	df 93       	push	r29
    346e:	ec 01       	movw	r28, r24
	switch (new_manip)
    3470:	86 2f       	mov	r24, r22
    3472:	90 e0       	ldi	r25, 0x00	; 0
    3474:	8b 30       	cpi	r24, 0x0B	; 11
    3476:	91 05       	cpc	r25, r1
    3478:	d8 f5       	brcc	.+118    	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
    347a:	fc 01       	movw	r30, r24
    347c:	88 27       	eor	r24, r24
    347e:	e2 50       	subi	r30, 0x02	; 2
    3480:	ff 4f       	sbci	r31, 0xFF	; 255
    3482:	8f 4f       	sbci	r24, 0xFF	; 255
    3484:	0c 94 12 20 	jmp	0x4024	; 0x4024 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3488:	82 e0       	ldi	r24, 0x02	; 2
    348a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    348c:	31 c0       	rjmp	.+98     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    348e:	88 e0       	ldi	r24, 0x08	; 8
    3490:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3492:	2e c0       	rjmp	.+92     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3494:	8a e0       	ldi	r24, 0x0A	; 10
    3496:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3498:	2b c0       	rjmp	.+86     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    349a:	80 e1       	ldi	r24, 0x10	; 16
    349c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    349e:	28 c0       	rjmp	.+80     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    34a0:	81 e0       	ldi	r24, 0x01	; 1
    34a2:	8b 83       	std	Y+3, r24	; 0x03
			break;
    34a4:	25 c0       	rjmp	.+74     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    34a6:	1b 82       	std	Y+3, r1	; 0x03
			break;
    34a8:	23 c0       	rjmp	.+70     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    34aa:	e8 81       	ld	r30, Y
    34ac:	f9 81       	ldd	r31, Y+1	; 0x01
    34ae:	02 80       	ldd	r0, Z+2	; 0x02
    34b0:	f3 81       	ldd	r31, Z+3	; 0x03
    34b2:	e0 2d       	mov	r30, r0
    34b4:	6d e0       	ldi	r22, 0x0D	; 13
    34b6:	ce 01       	movw	r24, r28
    34b8:	19 95       	eicall
    34ba:	e8 81       	ld	r30, Y
    34bc:	f9 81       	ldd	r31, Y+1	; 0x01
    34be:	02 80       	ldd	r0, Z+2	; 0x02
    34c0:	f3 81       	ldd	r31, Z+3	; 0x03
    34c2:	e0 2d       	mov	r30, r0
    34c4:	6a e0       	ldi	r22, 0x0A	; 10
    34c6:	ce 01       	movw	r24, r28
    34c8:	19 95       	eicall
			break;
    34ca:	12 c0       	rjmp	.+36     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    34cc:	e8 81       	ld	r30, Y
    34ce:	f9 81       	ldd	r31, Y+1	; 0x01
    34d0:	02 84       	ldd	r0, Z+10	; 0x0a
    34d2:	f3 85       	ldd	r31, Z+11	; 0x0b
    34d4:	e0 2d       	mov	r30, r0
    34d6:	ce 01       	movw	r24, r28
    34d8:	19 95       	eicall
			break;
    34da:	0a c0       	rjmp	.+20     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    34dc:	e8 81       	ld	r30, Y
    34de:	f9 81       	ldd	r31, Y+1	; 0x01
    34e0:	00 84       	ldd	r0, Z+8	; 0x08
    34e2:	f1 85       	ldd	r31, Z+9	; 0x09
    34e4:	e0 2d       	mov	r30, r0
    34e6:	ce 01       	movw	r24, r28
    34e8:	19 95       	eicall
			break;
    34ea:	02 c0       	rjmp	.+4      	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    34ec:	81 e0       	ldi	r24, 0x01	; 1
    34ee:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    34f0:	ce 01       	movw	r24, r28
    34f2:	df 91       	pop	r29
    34f4:	cf 91       	pop	r28
    34f6:	08 95       	ret

000034f8 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    34f8:	0f 93       	push	r16
    34fa:	1f 93       	push	r17
    34fc:	cf 93       	push	r28
    34fe:	df 93       	push	r29
    3500:	cd b7       	in	r28, 0x3d	; 61
    3502:	de b7       	in	r29, 0x3e	; 62
    3504:	61 97       	sbiw	r28, 0x11	; 17
    3506:	cd bf       	out	0x3d, r28	; 61
    3508:	de bf       	out	0x3e, r29	; 62
    350a:	8c 01       	movw	r16, r24
    350c:	9b 01       	movw	r18, r22
	if (base != 10)
    350e:	fc 01       	movw	r30, r24
    3510:	92 81       	ldd	r25, Z+2	; 0x02
    3512:	9a 30       	cpi	r25, 0x0A	; 10
    3514:	21 f0       	breq	.+8      	; 0x351e <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    3516:	c8 01       	movw	r24, r16
    3518:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    351c:	0d c0       	rjmp	.+26     	; 0x3538 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    351e:	4a e0       	ldi	r20, 0x0A	; 10
    3520:	be 01       	movw	r22, r28
    3522:	6f 5f       	subi	r22, 0xFF	; 255
    3524:	7f 4f       	sbci	r23, 0xFF	; 255
    3526:	c9 01       	movw	r24, r18
    3528:	0e 94 7f 20 	call	0x40fe	; 0x40fe <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    352c:	be 01       	movw	r22, r28
    352e:	6f 5f       	subi	r22, 0xFF	; 255
    3530:	7f 4f       	sbci	r23, 0xFF	; 255
    3532:	c8 01       	movw	r24, r16
    3534:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3538:	c8 01       	movw	r24, r16
    353a:	61 96       	adiw	r28, 0x11	; 17
    353c:	cd bf       	out	0x3d, r28	; 61
    353e:	de bf       	out	0x3e, r29	; 62
    3540:	df 91       	pop	r29
    3542:	cf 91       	pop	r28
    3544:	1f 91       	pop	r17
    3546:	0f 91       	pop	r16
    3548:	08 95       	ret

0000354a <_ZN8emstreamlsEl>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (int32_t num)
{
    354a:	0f 93       	push	r16
    354c:	1f 93       	push	r17
    354e:	cf 93       	push	r28
    3550:	df 93       	push	r29
    3552:	cd b7       	in	r28, 0x3d	; 61
    3554:	de b7       	in	r29, 0x3e	; 62
    3556:	a2 97       	sbiw	r28, 0x22	; 34
    3558:	cd bf       	out	0x3d, r28	; 61
    355a:	de bf       	out	0x3e, r29	; 62
    355c:	8c 01       	movw	r16, r24
    355e:	cb 01       	movw	r24, r22
    3560:	ba 01       	movw	r22, r20
	if (base != 10)
    3562:	f8 01       	movw	r30, r16
    3564:	22 81       	ldd	r18, Z+2	; 0x02
    3566:	2a 30       	cpi	r18, 0x0A	; 10
    3568:	31 f0       	breq	.+12     	; 0x3576 <_ZN8emstreamlsEl+0x2c>
	{
		*this << (uint32_t)num;
    356a:	ab 01       	movw	r20, r22
    356c:	bc 01       	movw	r22, r24
    356e:	c8 01       	movw	r24, r16
    3570:	0e 94 04 1b 	call	0x3608	; 0x3608 <_ZN8emstreamlsEm>
    3574:	0c c0       	rjmp	.+24     	; 0x358e <_ZN8emstreamlsEl+0x44>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__ltoa_ncheck (long, char *, unsigned char);
	return __ltoa_ncheck (__val, __s, __radix);
    3576:	2a e0       	ldi	r18, 0x0A	; 10
    3578:	ae 01       	movw	r20, r28
    357a:	4f 5f       	subi	r20, 0xFF	; 255
    357c:	5f 4f       	sbci	r21, 0xFF	; 255
    357e:	0e 94 8a 20 	call	0x4114	; 0x4114 <__ltoa_ncheck>
	}
	else
	{
		char out_str[34];
		ltoa ((long)num, out_str, base);
		puts (out_str);
    3582:	be 01       	movw	r22, r28
    3584:	6f 5f       	subi	r22, 0xFF	; 255
    3586:	7f 4f       	sbci	r23, 0xFF	; 255
    3588:	c8 01       	movw	r24, r16
    358a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    358e:	c8 01       	movw	r24, r16
    3590:	a2 96       	adiw	r28, 0x22	; 34
    3592:	cd bf       	out	0x3d, r28	; 61
    3594:	de bf       	out	0x3e, r29	; 62
    3596:	df 91       	pop	r29
    3598:	cf 91       	pop	r28
    359a:	1f 91       	pop	r17
    359c:	0f 91       	pop	r16
    359e:	08 95       	ret

000035a0 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    35a0:	ff 92       	push	r15
    35a2:	0f 93       	push	r16
    35a4:	1f 93       	push	r17
    35a6:	cf 93       	push	r28
    35a8:	df 93       	push	r29
    35aa:	cd b7       	in	r28, 0x3d	; 61
    35ac:	de b7       	in	r29, 0x3e	; 62
    35ae:	61 97       	sbiw	r28, 0x11	; 17
    35b0:	cd bf       	out	0x3d, r28	; 61
    35b2:	de bf       	out	0x3e, r29	; 62
    35b4:	8c 01       	movw	r16, r24
    35b6:	f6 2e       	mov	r15, r22
    35b8:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    35ba:	f8 01       	movw	r30, r16
    35bc:	42 81       	ldd	r20, Z+2	; 0x02
    35be:	40 31       	cpi	r20, 0x10	; 16
    35c0:	21 f0       	breq	.+8      	; 0x35ca <_ZN8emstreamlsEj+0x2a>
    35c2:	48 30       	cpi	r20, 0x08	; 8
    35c4:	11 f0       	breq	.+4      	; 0x35ca <_ZN8emstreamlsEj+0x2a>
    35c6:	42 30       	cpi	r20, 0x02	; 2
    35c8:	41 f4       	brne	.+16     	; 0x35da <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    35ca:	69 2f       	mov	r22, r25
    35cc:	c8 01       	movw	r24, r16
    35ce:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    35d2:	6f 2d       	mov	r22, r15
    35d4:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    35d8:	0d c0       	rjmp	.+26     	; 0x35f4 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    35da:	50 e0       	ldi	r21, 0x00	; 0
    35dc:	be 01       	movw	r22, r28
    35de:	6f 5f       	subi	r22, 0xFF	; 255
    35e0:	7f 4f       	sbci	r23, 0xFF	; 255
    35e2:	8f 2d       	mov	r24, r15
    35e4:	0e 94 c6 20 	call	0x418c	; 0x418c <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    35e8:	be 01       	movw	r22, r28
    35ea:	6f 5f       	subi	r22, 0xFF	; 255
    35ec:	7f 4f       	sbci	r23, 0xFF	; 255
    35ee:	c8 01       	movw	r24, r16
    35f0:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35f4:	c8 01       	movw	r24, r16
    35f6:	61 96       	adiw	r28, 0x11	; 17
    35f8:	cd bf       	out	0x3d, r28	; 61
    35fa:	de bf       	out	0x3e, r29	; 62
    35fc:	df 91       	pop	r29
    35fe:	cf 91       	pop	r28
    3600:	1f 91       	pop	r17
    3602:	0f 91       	pop	r16
    3604:	ff 90       	pop	r15
    3606:	08 95       	ret

00003608 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3608:	df 92       	push	r13
    360a:	ef 92       	push	r14
    360c:	ff 92       	push	r15
    360e:	0f 93       	push	r16
    3610:	1f 93       	push	r17
    3612:	cf 93       	push	r28
    3614:	df 93       	push	r29
    3616:	cd b7       	in	r28, 0x3d	; 61
    3618:	de b7       	in	r29, 0x3e	; 62
    361a:	a1 97       	sbiw	r28, 0x21	; 33
    361c:	cd bf       	out	0x3d, r28	; 61
    361e:	de bf       	out	0x3e, r29	; 62
    3620:	8c 01       	movw	r16, r24
    3622:	d4 2e       	mov	r13, r20
    3624:	e5 2e       	mov	r14, r21
    3626:	f6 2e       	mov	r15, r22
    3628:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    362a:	f8 01       	movw	r30, r16
    362c:	22 81       	ldd	r18, Z+2	; 0x02
    362e:	20 31       	cpi	r18, 0x10	; 16
    3630:	21 f0       	breq	.+8      	; 0x363a <_ZN8emstreamlsEm+0x32>
    3632:	28 30       	cpi	r18, 0x08	; 8
    3634:	11 f0       	breq	.+4      	; 0x363a <_ZN8emstreamlsEm+0x32>
    3636:	22 30       	cpi	r18, 0x02	; 2
    3638:	71 f4       	brne	.+28     	; 0x3656 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    363a:	69 2f       	mov	r22, r25
    363c:	c8 01       	movw	r24, r16
    363e:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    3642:	6f 2d       	mov	r22, r15
    3644:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    3648:	6e 2d       	mov	r22, r14
    364a:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    364e:	6d 2d       	mov	r22, r13
    3650:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    3654:	0f c0       	rjmp	.+30     	; 0x3674 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3656:	30 e0       	ldi	r19, 0x00	; 0
    3658:	ae 01       	movw	r20, r28
    365a:	4f 5f       	subi	r20, 0xFF	; 255
    365c:	5f 4f       	sbci	r21, 0xFF	; 255
    365e:	6d 2d       	mov	r22, r13
    3660:	7e 2d       	mov	r23, r14
    3662:	8f 2d       	mov	r24, r15
    3664:	0e 94 99 20 	call	0x4132	; 0x4132 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3668:	be 01       	movw	r22, r28
    366a:	6f 5f       	subi	r22, 0xFF	; 255
    366c:	7f 4f       	sbci	r23, 0xFF	; 255
    366e:	c8 01       	movw	r24, r16
    3670:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3674:	c8 01       	movw	r24, r16
    3676:	a1 96       	adiw	r28, 0x21	; 33
    3678:	cd bf       	out	0x3d, r28	; 61
    367a:	de bf       	out	0x3e, r29	; 62
    367c:	df 91       	pop	r29
    367e:	cf 91       	pop	r28
    3680:	1f 91       	pop	r17
    3682:	0f 91       	pop	r16
    3684:	ff 90       	pop	r15
    3686:	ef 90       	pop	r14
    3688:	df 90       	pop	r13
    368a:	08 95       	ret

0000368c <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    368c:	cf 92       	push	r12
    368e:	df 92       	push	r13
    3690:	ef 92       	push	r14
    3692:	ff 92       	push	r15
    3694:	0f 93       	push	r16
    3696:	1f 93       	push	r17
    3698:	cf 93       	push	r28
    369a:	df 93       	push	r29
    369c:	cd b7       	in	r28, 0x3d	; 61
    369e:	de b7       	in	r29, 0x3e	; 62
    36a0:	29 97       	sbiw	r28, 0x09	; 9
    36a2:	cd bf       	out	0x3d, r28	; 61
    36a4:	de bf       	out	0x3e, r29	; 62
    36a6:	8c 01       	movw	r16, r24
    36a8:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    36aa:	dc 01       	movw	r26, r24
    36ac:	13 96       	adiw	r26, 0x03	; 3
    36ae:	8c 91       	ld	r24, X
    36b0:	13 97       	sbiw	r26, 0x03	; 3
    36b2:	88 23       	and	r24, r24
    36b4:	41 f0       	breq	.+16     	; 0x36c6 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    36b6:	ed 91       	ld	r30, X+
    36b8:	fc 91       	ld	r31, X
    36ba:	02 80       	ldd	r0, Z+2	; 0x02
    36bc:	f3 81       	ldd	r31, Z+3	; 0x03
    36be:	e0 2d       	mov	r30, r0
    36c0:	c8 01       	movw	r24, r16
    36c2:	19 95       	eicall
    36c4:	56 c0       	rjmp	.+172    	; 0x3772 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    36c6:	f8 01       	movw	r30, r16
    36c8:	42 81       	ldd	r20, Z+2	; 0x02
    36ca:	42 30       	cpi	r20, 0x02	; 2
    36cc:	19 f5       	brne	.+70     	; 0x3714 <_ZN8emstreamlsEh+0x88>
    36ce:	68 94       	set
    36d0:	cc 24       	eor	r12, r12
    36d2:	c3 f8       	bld	r12, 3
    36d4:	d1 2c       	mov	r13, r1
    36d6:	68 94       	set
    36d8:	ff 24       	eor	r15, r15
    36da:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    36dc:	8e 2d       	mov	r24, r14
    36de:	8f 21       	and	r24, r15
    36e0:	51 f0       	breq	.+20     	; 0x36f6 <_ZN8emstreamlsEh+0x6a>
    36e2:	d8 01       	movw	r26, r16
    36e4:	ed 91       	ld	r30, X+
    36e6:	fc 91       	ld	r31, X
    36e8:	02 80       	ldd	r0, Z+2	; 0x02
    36ea:	f3 81       	ldd	r31, Z+3	; 0x03
    36ec:	e0 2d       	mov	r30, r0
    36ee:	61 e3       	ldi	r22, 0x31	; 49
    36f0:	c8 01       	movw	r24, r16
    36f2:	19 95       	eicall
    36f4:	09 c0       	rjmp	.+18     	; 0x3708 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    36f6:	d8 01       	movw	r26, r16
    36f8:	ed 91       	ld	r30, X+
    36fa:	fc 91       	ld	r31, X
    36fc:	02 80       	ldd	r0, Z+2	; 0x02
    36fe:	f3 81       	ldd	r31, Z+3	; 0x03
    3700:	e0 2d       	mov	r30, r0
    3702:	60 e3       	ldi	r22, 0x30	; 48
    3704:	c8 01       	movw	r24, r16
    3706:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3708:	f6 94       	lsr	r15
    370a:	b1 e0       	ldi	r27, 0x01	; 1
    370c:	cb 1a       	sub	r12, r27
    370e:	d1 08       	sbc	r13, r1
    3710:	29 f7       	brne	.-54     	; 0x36dc <_ZN8emstreamlsEh+0x50>
    3712:	2f c0       	rjmp	.+94     	; 0x3772 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3714:	40 31       	cpi	r20, 0x10	; 16
    3716:	f9 f4       	brne	.+62     	; 0x3756 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3718:	62 95       	swap	r22
    371a:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    371c:	01 90       	ld	r0, Z+
    371e:	f0 81       	ld	r31, Z
    3720:	e0 2d       	mov	r30, r0
    3722:	02 80       	ldd	r0, Z+2	; 0x02
    3724:	f3 81       	ldd	r31, Z+3	; 0x03
    3726:	e0 2d       	mov	r30, r0
    3728:	6a 30       	cpi	r22, 0x0A	; 10
    372a:	10 f0       	brcs	.+4      	; 0x3730 <_ZN8emstreamlsEh+0xa4>
    372c:	69 5c       	subi	r22, 0xC9	; 201
    372e:	01 c0       	rjmp	.+2      	; 0x3732 <_ZN8emstreamlsEh+0xa6>
    3730:	60 5d       	subi	r22, 0xD0	; 208
    3732:	c8 01       	movw	r24, r16
    3734:	19 95       	eicall
		temp_char = num & 0x0F;
    3736:	6e 2d       	mov	r22, r14
    3738:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    373a:	d8 01       	movw	r26, r16
    373c:	ed 91       	ld	r30, X+
    373e:	fc 91       	ld	r31, X
    3740:	02 80       	ldd	r0, Z+2	; 0x02
    3742:	f3 81       	ldd	r31, Z+3	; 0x03
    3744:	e0 2d       	mov	r30, r0
    3746:	6a 30       	cpi	r22, 0x0A	; 10
    3748:	10 f0       	brcs	.+4      	; 0x374e <_ZN8emstreamlsEh+0xc2>
    374a:	69 5c       	subi	r22, 0xC9	; 201
    374c:	01 c0       	rjmp	.+2      	; 0x3750 <_ZN8emstreamlsEh+0xc4>
    374e:	60 5d       	subi	r22, 0xD0	; 208
    3750:	c8 01       	movw	r24, r16
    3752:	19 95       	eicall
    3754:	0e c0       	rjmp	.+28     	; 0x3772 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3756:	50 e0       	ldi	r21, 0x00	; 0
    3758:	be 01       	movw	r22, r28
    375a:	6f 5f       	subi	r22, 0xFF	; 255
    375c:	7f 4f       	sbci	r23, 0xFF	; 255
    375e:	8e 2d       	mov	r24, r14
    3760:	90 e0       	ldi	r25, 0x00	; 0
    3762:	0e 94 c6 20 	call	0x418c	; 0x418c <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3766:	be 01       	movw	r22, r28
    3768:	6f 5f       	subi	r22, 0xFF	; 255
    376a:	7f 4f       	sbci	r23, 0xFF	; 255
    376c:	c8 01       	movw	r24, r16
    376e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3772:	c8 01       	movw	r24, r16
    3774:	29 96       	adiw	r28, 0x09	; 9
    3776:	cd bf       	out	0x3d, r28	; 61
    3778:	de bf       	out	0x3e, r29	; 62
    377a:	df 91       	pop	r29
    377c:	cf 91       	pop	r28
    377e:	1f 91       	pop	r17
    3780:	0f 91       	pop	r16
    3782:	ff 90       	pop	r15
    3784:	ef 90       	pop	r14
    3786:	df 90       	pop	r13
    3788:	cf 90       	pop	r12
    378a:	08 95       	ret

0000378c <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    378c:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    378e:	50 96       	adiw	r26, 0x10	; 16
    3790:	ed 91       	ld	r30, X+
    3792:	fc 91       	ld	r31, X
    3794:	51 97       	sbiw	r26, 0x11	; 17
    3796:	80 81       	ld	r24, Z
    3798:	54 96       	adiw	r26, 0x14	; 20
    379a:	4c 91       	ld	r20, X
    379c:	54 97       	sbiw	r26, 0x14	; 20
    379e:	84 23       	and	r24, r20
    37a0:	29 f0       	breq	.+10     	; 0x37ac <_ZN5rs2327putcharEc+0x20>
    37a2:	09 c0       	rjmp	.+18     	; 0x37b6 <_ZN5rs2327putcharEc+0x2a>
    37a4:	21 50       	subi	r18, 0x01	; 1
    37a6:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    37a8:	19 f4       	brne	.+6      	; 0x37b0 <_ZN5rs2327putcharEc+0x24>
    37aa:	12 c0       	rjmp	.+36     	; 0x37d0 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    37ac:	21 e2       	ldi	r18, 0x21	; 33
    37ae:	3e e4       	ldi	r19, 0x4E	; 78
    37b0:	90 81       	ld	r25, Z
    37b2:	94 23       	and	r25, r20
    37b4:	b9 f3       	breq	.-18     	; 0x37a4 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    37b6:	90 81       	ld	r25, Z
    37b8:	56 96       	adiw	r26, 0x16	; 22
    37ba:	8c 91       	ld	r24, X
    37bc:	56 97       	sbiw	r26, 0x16	; 22
    37be:	89 2b       	or	r24, r25
    37c0:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    37c2:	1e 96       	adiw	r26, 0x0e	; 14
    37c4:	ed 91       	ld	r30, X+
    37c6:	fc 91       	ld	r31, X
    37c8:	1f 97       	sbiw	r26, 0x0f	; 15
    37ca:	60 83       	st	Z, r22
	return (true);
    37cc:	81 e0       	ldi	r24, 0x01	; 1
    37ce:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    37d0:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    37d2:	08 95       	ret

000037d4 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    37d4:	cf 93       	push	r28
    37d6:	df 93       	push	r29
    37d8:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    37da:	c1 8d       	ldd	r28, Z+25	; 0x19
    37dc:	d2 8d       	ldd	r29, Z+26	; 0x1a
    37de:	28 81       	ld	r18, Y
    37e0:	39 81       	ldd	r19, Y+1	; 0x01
    37e2:	a3 8d       	ldd	r26, Z+27	; 0x1b
    37e4:	b4 8d       	ldd	r27, Z+28	; 0x1c
    37e6:	4d 91       	ld	r20, X+
    37e8:	5c 91       	ld	r21, X
    37ea:	24 17       	cp	r18, r20
    37ec:	35 07       	cpc	r19, r21
    37ee:	e9 f3       	breq	.-6      	; 0x37ea <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    37f0:	a7 89       	ldd	r26, Z+23	; 0x17
    37f2:	b0 8d       	ldd	r27, Z+24	; 0x18
    37f4:	0d 90       	ld	r0, X+
    37f6:	bc 91       	ld	r27, X
    37f8:	a0 2d       	mov	r26, r0
    37fa:	a2 0f       	add	r26, r18
    37fc:	b3 1f       	adc	r27, r19
    37fe:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3800:	2f 5f       	subi	r18, 0xFF	; 255
    3802:	3f 4f       	sbci	r19, 0xFF	; 255
    3804:	28 83       	st	Y, r18
    3806:	39 83       	std	Y+1, r19	; 0x01
    3808:	24 36       	cpi	r18, 0x64	; 100
    380a:	31 05       	cpc	r19, r1
    380c:	28 f0       	brcs	.+10     	; 0x3818 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    380e:	01 8c       	ldd	r0, Z+25	; 0x19
    3810:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3812:	e0 2d       	mov	r30, r0
    3814:	10 82       	st	Z, r1
    3816:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3818:	90 e0       	ldi	r25, 0x00	; 0
    381a:	df 91       	pop	r29
    381c:	cf 91       	pop	r28
    381e:	08 95       	ret

00003820 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3820:	cf 93       	push	r28
    3822:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3824:	ec 01       	movw	r28, r24
    3826:	a9 8d       	ldd	r26, Y+25	; 0x19
    3828:	ba 8d       	ldd	r27, Y+26	; 0x1a
    382a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    382c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    382e:	81 e0       	ldi	r24, 0x01	; 1
    3830:	4d 91       	ld	r20, X+
    3832:	5c 91       	ld	r21, X
    3834:	20 81       	ld	r18, Z
    3836:	31 81       	ldd	r19, Z+1	; 0x01
    3838:	42 17       	cp	r20, r18
    383a:	53 07       	cpc	r21, r19
    383c:	09 f4       	brne	.+2      	; 0x3840 <_ZN5rs23214check_for_charEv+0x20>
    383e:	80 e0       	ldi	r24, 0x00	; 0
}
    3840:	df 91       	pop	r29
    3842:	cf 91       	pop	r28
    3844:	08 95       	ret

00003846 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3846:	dc 01       	movw	r26, r24
    3848:	ed 91       	ld	r30, X+
    384a:	fc 91       	ld	r31, X
    384c:	02 80       	ldd	r0, Z+2	; 0x02
    384e:	f3 81       	ldd	r31, Z+3	; 0x03
    3850:	e0 2d       	mov	r30, r0
    3852:	6c e0       	ldi	r22, 0x0C	; 12
    3854:	19 95       	eicall
    3856:	08 95       	ret

00003858 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3858:	ef 92       	push	r14
    385a:	ff 92       	push	r15
    385c:	0f 93       	push	r16
    385e:	1f 93       	push	r17
    3860:	cf 93       	push	r28
    3862:	df 93       	push	r29
    3864:	ec 01       	movw	r28, r24
    3866:	7b 01       	movw	r14, r22
    3868:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    386a:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <_ZN8emstreamC1Ev>
    386e:	a8 01       	movw	r20, r16
    3870:	b7 01       	movw	r22, r14
    3872:	ce 01       	movw	r24, r28
    3874:	08 96       	adiw	r24, 0x08	; 8
    3876:	0e 94 51 19 	call	0x32a2	; 0x32a2 <_ZN7base232C1EjP12USART_struct>
    387a:	8d e8       	ldi	r24, 0x8D	; 141
    387c:	90 e2       	ldi	r25, 0x20	; 32
    387e:	88 83       	st	Y, r24
    3880:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3882:	00 3a       	cpi	r16, 0xA0	; 160
    3884:	88 e0       	ldi	r24, 0x08	; 8
    3886:	18 07       	cpc	r17, r24
    3888:	69 f4       	brne	.+26     	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    388a:	8a e6       	ldi	r24, 0x6A	; 106
    388c:	91 e3       	ldi	r25, 0x31	; 49
    388e:	8f 8b       	std	Y+23, r24	; 0x17
    3890:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3892:	80 e6       	ldi	r24, 0x60	; 96
    3894:	91 e3       	ldi	r25, 0x31	; 49
    3896:	89 8f       	std	Y+25, r24	; 0x19
    3898:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    389a:	86 e5       	ldi	r24, 0x56	; 86
    389c:	91 e3       	ldi	r25, 0x31	; 49
    389e:	8b 8f       	std	Y+27, r24	; 0x1b
    38a0:	9c 8f       	std	Y+28, r25	; 0x1c
    38a2:	42 c0       	rjmp	.+132    	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    38a4:	00 3b       	cpi	r16, 0xB0	; 176
    38a6:	e8 e0       	ldi	r30, 0x08	; 8
    38a8:	1e 07       	cpc	r17, r30
    38aa:	69 f4       	brne	.+26     	; 0x38c6 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    38ac:	88 e6       	ldi	r24, 0x68	; 104
    38ae:	91 e3       	ldi	r25, 0x31	; 49
    38b0:	8f 8b       	std	Y+23, r24	; 0x17
    38b2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    38b4:	8e e5       	ldi	r24, 0x5E	; 94
    38b6:	91 e3       	ldi	r25, 0x31	; 49
    38b8:	89 8f       	std	Y+25, r24	; 0x19
    38ba:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    38bc:	84 e5       	ldi	r24, 0x54	; 84
    38be:	91 e3       	ldi	r25, 0x31	; 49
    38c0:	8b 8f       	std	Y+27, r24	; 0x1b
    38c2:	9c 8f       	std	Y+28, r25	; 0x1c
    38c4:	31 c0       	rjmp	.+98     	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    38c6:	00 3a       	cpi	r16, 0xA0	; 160
    38c8:	f9 e0       	ldi	r31, 0x09	; 9
    38ca:	1f 07       	cpc	r17, r31
    38cc:	69 f4       	brne	.+26     	; 0x38e8 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    38ce:	86 e6       	ldi	r24, 0x66	; 102
    38d0:	91 e3       	ldi	r25, 0x31	; 49
    38d2:	8f 8b       	std	Y+23, r24	; 0x17
    38d4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    38d6:	8c e5       	ldi	r24, 0x5C	; 92
    38d8:	91 e3       	ldi	r25, 0x31	; 49
    38da:	89 8f       	std	Y+25, r24	; 0x19
    38dc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    38de:	82 e5       	ldi	r24, 0x52	; 82
    38e0:	91 e3       	ldi	r25, 0x31	; 49
    38e2:	8b 8f       	std	Y+27, r24	; 0x1b
    38e4:	9c 8f       	std	Y+28, r25	; 0x1c
    38e6:	20 c0       	rjmp	.+64     	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    38e8:	00 3b       	cpi	r16, 0xB0	; 176
    38ea:	89 e0       	ldi	r24, 0x09	; 9
    38ec:	18 07       	cpc	r17, r24
    38ee:	69 f4       	brne	.+26     	; 0x390a <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    38f0:	84 e6       	ldi	r24, 0x64	; 100
    38f2:	91 e3       	ldi	r25, 0x31	; 49
    38f4:	8f 8b       	std	Y+23, r24	; 0x17
    38f6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    38f8:	8a e5       	ldi	r24, 0x5A	; 90
    38fa:	91 e3       	ldi	r25, 0x31	; 49
    38fc:	89 8f       	std	Y+25, r24	; 0x19
    38fe:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3900:	80 e5       	ldi	r24, 0x50	; 80
    3902:	91 e3       	ldi	r25, 0x31	; 49
    3904:	8b 8f       	std	Y+27, r24	; 0x1b
    3906:	9c 8f       	std	Y+28, r25	; 0x1c
    3908:	0f c0       	rjmp	.+30     	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    390a:	00 3a       	cpi	r16, 0xA0	; 160
    390c:	1a 40       	sbci	r17, 0x0A	; 10
    390e:	61 f4       	brne	.+24     	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3910:	82 e6       	ldi	r24, 0x62	; 98
    3912:	91 e3       	ldi	r25, 0x31	; 49
    3914:	8f 8b       	std	Y+23, r24	; 0x17
    3916:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3918:	88 e5       	ldi	r24, 0x58	; 88
    391a:	91 e3       	ldi	r25, 0x31	; 49
    391c:	89 8f       	std	Y+25, r24	; 0x19
    391e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3920:	8e e4       	ldi	r24, 0x4E	; 78
    3922:	91 e3       	ldi	r25, 0x31	; 49
    3924:	8b 8f       	std	Y+27, r24	; 0x1b
    3926:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3928:	0f 89       	ldd	r16, Y+23	; 0x17
    392a:	18 8d       	ldd	r17, Y+24	; 0x18
    392c:	84 e6       	ldi	r24, 0x64	; 100
    392e:	90 e0       	ldi	r25, 0x00	; 0
    3930:	0e 94 4d 19 	call	0x329a	; 0x329a <_Znaj>
    3934:	f8 01       	movw	r30, r16
    3936:	80 83       	st	Z, r24
    3938:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    393a:	e9 8d       	ldd	r30, Y+25	; 0x19
    393c:	fa 8d       	ldd	r31, Y+26	; 0x1a
    393e:	10 82       	st	Z, r1
    3940:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3942:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3944:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3946:	10 82       	st	Z, r1
    3948:	11 82       	std	Z+1, r1	; 0x01
}
    394a:	df 91       	pop	r29
    394c:	cf 91       	pop	r28
    394e:	1f 91       	pop	r17
    3950:	0f 91       	pop	r16
    3952:	ff 90       	pop	r15
    3954:	ef 90       	pop	r14
    3956:	08 95       	ret

00003958 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3958:	1f 92       	push	r1
    395a:	0f 92       	push	r0
    395c:	0f b6       	in	r0, 0x3f	; 63
    395e:	0f 92       	push	r0
    3960:	11 24       	eor	r1, r1
    3962:	08 b6       	in	r0, 0x38	; 56
    3964:	0f 92       	push	r0
    3966:	18 be       	out	0x38, r1	; 56
    3968:	0b b6       	in	r0, 0x3b	; 59
    396a:	0f 92       	push	r0
    396c:	1b be       	out	0x3b, r1	; 59
    396e:	2f 93       	push	r18
    3970:	3f 93       	push	r19
    3972:	8f 93       	push	r24
    3974:	9f 93       	push	r25
    3976:	ef 93       	push	r30
    3978:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    397a:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    397e:	e0 91 6a 31 	lds	r30, 0x316A	; 0x80316a <rcvC0_buffer>
    3982:	f0 91 6b 31 	lds	r31, 0x316B	; 0x80316b <rcvC0_buffer+0x1>
    3986:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvC0_write_index>
    398a:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvC0_write_index+0x1>
    398e:	e8 0f       	add	r30, r24
    3990:	f9 1f       	adc	r31, r25
    3992:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3994:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvC0_write_index>
    3998:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvC0_write_index+0x1>
    399c:	01 96       	adiw	r24, 0x01	; 1
    399e:	84 36       	cpi	r24, 0x64	; 100
    39a0:	91 05       	cpc	r25, r1
    39a2:	60 f4       	brcc	.+24     	; 0x39bc <__vector_25+0x64>
    39a4:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvC0_write_index>
    39a8:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    39ac:	20 91 60 31 	lds	r18, 0x3160	; 0x803160 <rcvC0_read_index>
    39b0:	30 91 61 31 	lds	r19, 0x3161	; 0x803161 <rcvC0_read_index+0x1>
    39b4:	82 17       	cp	r24, r18
    39b6:	93 07       	cpc	r25, r19
    39b8:	f1 f4       	brne	.+60     	; 0x39f6 <__vector_25+0x9e>
    39ba:	0c c0       	rjmp	.+24     	; 0x39d4 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    39bc:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvC0_write_index>
    39c0:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    39c4:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvC0_read_index>
    39c8:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvC0_read_index+0x1>
    39cc:	18 16       	cp	r1, r24
    39ce:	19 06       	cpc	r1, r25
    39d0:	91 f4       	brne	.+36     	; 0x39f6 <__vector_25+0x9e>
    39d2:	0e c0       	rjmp	.+28     	; 0x39f0 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    39d4:	01 96       	adiw	r24, 0x01	; 1
    39d6:	84 36       	cpi	r24, 0x64	; 100
    39d8:	91 05       	cpc	r25, r1
    39da:	28 f4       	brcc	.+10     	; 0x39e6 <__vector_25+0x8e>
    39dc:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <rcvC0_read_index>
    39e0:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <rcvC0_read_index+0x1>
    39e4:	08 c0       	rjmp	.+16     	; 0x39f6 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    39e6:	10 92 60 31 	sts	0x3160, r1	; 0x803160 <rcvC0_read_index>
    39ea:	10 92 61 31 	sts	0x3161, r1	; 0x803161 <rcvC0_read_index+0x1>
}
    39ee:	03 c0       	rjmp	.+6      	; 0x39f6 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    39f0:	81 e0       	ldi	r24, 0x01	; 1
    39f2:	90 e0       	ldi	r25, 0x00	; 0
    39f4:	f3 cf       	rjmp	.-26     	; 0x39dc <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    39f6:	ff 91       	pop	r31
    39f8:	ef 91       	pop	r30
    39fa:	9f 91       	pop	r25
    39fc:	8f 91       	pop	r24
    39fe:	3f 91       	pop	r19
    3a00:	2f 91       	pop	r18
    3a02:	0f 90       	pop	r0
    3a04:	0b be       	out	0x3b, r0	; 59
    3a06:	0f 90       	pop	r0
    3a08:	08 be       	out	0x38, r0	; 56
    3a0a:	0f 90       	pop	r0
    3a0c:	0f be       	out	0x3f, r0	; 63
    3a0e:	0f 90       	pop	r0
    3a10:	1f 90       	pop	r1
    3a12:	18 95       	reti

00003a14 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3a14:	1f 92       	push	r1
    3a16:	0f 92       	push	r0
    3a18:	0f b6       	in	r0, 0x3f	; 63
    3a1a:	0f 92       	push	r0
    3a1c:	11 24       	eor	r1, r1
    3a1e:	08 b6       	in	r0, 0x38	; 56
    3a20:	0f 92       	push	r0
    3a22:	18 be       	out	0x38, r1	; 56
    3a24:	0b b6       	in	r0, 0x3b	; 59
    3a26:	0f 92       	push	r0
    3a28:	1b be       	out	0x3b, r1	; 59
    3a2a:	2f 93       	push	r18
    3a2c:	3f 93       	push	r19
    3a2e:	8f 93       	push	r24
    3a30:	9f 93       	push	r25
    3a32:	ef 93       	push	r30
    3a34:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3a36:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3a3a:	e0 91 68 31 	lds	r30, 0x3168	; 0x803168 <rcvC1_buffer>
    3a3e:	f0 91 69 31 	lds	r31, 0x3169	; 0x803169 <rcvC1_buffer+0x1>
    3a42:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC1_write_index>
    3a46:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC1_write_index+0x1>
    3a4a:	e8 0f       	add	r30, r24
    3a4c:	f9 1f       	adc	r31, r25
    3a4e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3a50:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC1_write_index>
    3a54:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC1_write_index+0x1>
    3a58:	01 96       	adiw	r24, 0x01	; 1
    3a5a:	84 36       	cpi	r24, 0x64	; 100
    3a5c:	91 05       	cpc	r25, r1
    3a5e:	60 f4       	brcc	.+24     	; 0x3a78 <__vector_28+0x64>
    3a60:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvC1_write_index>
    3a64:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3a68:	20 91 5e 31 	lds	r18, 0x315E	; 0x80315e <rcvC1_read_index>
    3a6c:	30 91 5f 31 	lds	r19, 0x315F	; 0x80315f <rcvC1_read_index+0x1>
    3a70:	82 17       	cp	r24, r18
    3a72:	93 07       	cpc	r25, r19
    3a74:	f1 f4       	brne	.+60     	; 0x3ab2 <__vector_28+0x9e>
    3a76:	0c c0       	rjmp	.+24     	; 0x3a90 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3a78:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvC1_write_index>
    3a7c:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3a80:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvC1_read_index>
    3a84:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvC1_read_index+0x1>
    3a88:	18 16       	cp	r1, r24
    3a8a:	19 06       	cpc	r1, r25
    3a8c:	91 f4       	brne	.+36     	; 0x3ab2 <__vector_28+0x9e>
    3a8e:	0e c0       	rjmp	.+28     	; 0x3aac <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a90:	01 96       	adiw	r24, 0x01	; 1
    3a92:	84 36       	cpi	r24, 0x64	; 100
    3a94:	91 05       	cpc	r25, r1
    3a96:	28 f4       	brcc	.+10     	; 0x3aa2 <__vector_28+0x8e>
    3a98:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <rcvC1_read_index>
    3a9c:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <rcvC1_read_index+0x1>
    3aa0:	08 c0       	rjmp	.+16     	; 0x3ab2 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3aa2:	10 92 5e 31 	sts	0x315E, r1	; 0x80315e <rcvC1_read_index>
    3aa6:	10 92 5f 31 	sts	0x315F, r1	; 0x80315f <rcvC1_read_index+0x1>
}
    3aaa:	03 c0       	rjmp	.+6      	; 0x3ab2 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3aac:	81 e0       	ldi	r24, 0x01	; 1
    3aae:	90 e0       	ldi	r25, 0x00	; 0
    3ab0:	f3 cf       	rjmp	.-26     	; 0x3a98 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3ab2:	ff 91       	pop	r31
    3ab4:	ef 91       	pop	r30
    3ab6:	9f 91       	pop	r25
    3ab8:	8f 91       	pop	r24
    3aba:	3f 91       	pop	r19
    3abc:	2f 91       	pop	r18
    3abe:	0f 90       	pop	r0
    3ac0:	0b be       	out	0x3b, r0	; 59
    3ac2:	0f 90       	pop	r0
    3ac4:	08 be       	out	0x38, r0	; 56
    3ac6:	0f 90       	pop	r0
    3ac8:	0f be       	out	0x3f, r0	; 63
    3aca:	0f 90       	pop	r0
    3acc:	1f 90       	pop	r1
    3ace:	18 95       	reti

00003ad0 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3ad0:	1f 92       	push	r1
    3ad2:	0f 92       	push	r0
    3ad4:	0f b6       	in	r0, 0x3f	; 63
    3ad6:	0f 92       	push	r0
    3ad8:	11 24       	eor	r1, r1
    3ada:	08 b6       	in	r0, 0x38	; 56
    3adc:	0f 92       	push	r0
    3ade:	18 be       	out	0x38, r1	; 56
    3ae0:	0b b6       	in	r0, 0x3b	; 59
    3ae2:	0f 92       	push	r0
    3ae4:	1b be       	out	0x3b, r1	; 59
    3ae6:	2f 93       	push	r18
    3ae8:	3f 93       	push	r19
    3aea:	8f 93       	push	r24
    3aec:	9f 93       	push	r25
    3aee:	ef 93       	push	r30
    3af0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3af2:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3af6:	e0 91 66 31 	lds	r30, 0x3166	; 0x803166 <rcvD0_buffer>
    3afa:	f0 91 67 31 	lds	r31, 0x3167	; 0x803167 <rcvD0_buffer+0x1>
    3afe:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvC0_write_index>
    3b02:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvC0_write_index+0x1>
    3b06:	e8 0f       	add	r30, r24
    3b08:	f9 1f       	adc	r31, r25
    3b0a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3b0c:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvD0_write_index>
    3b10:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvD0_write_index+0x1>
    3b14:	01 96       	adiw	r24, 0x01	; 1
    3b16:	84 36       	cpi	r24, 0x64	; 100
    3b18:	91 05       	cpc	r25, r1
    3b1a:	60 f4       	brcc	.+24     	; 0x3b34 <__vector_88+0x64>
    3b1c:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <rcvD0_write_index>
    3b20:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3b24:	20 91 5c 31 	lds	r18, 0x315C	; 0x80315c <rcvD0_read_index>
    3b28:	30 91 5d 31 	lds	r19, 0x315D	; 0x80315d <rcvD0_read_index+0x1>
    3b2c:	82 17       	cp	r24, r18
    3b2e:	93 07       	cpc	r25, r19
    3b30:	f1 f4       	brne	.+60     	; 0x3b6e <__vector_88+0x9e>
    3b32:	0c c0       	rjmp	.+24     	; 0x3b4c <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3b34:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <rcvD0_write_index>
    3b38:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3b3c:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvD0_read_index>
    3b40:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvD0_read_index+0x1>
    3b44:	18 16       	cp	r1, r24
    3b46:	19 06       	cpc	r1, r25
    3b48:	91 f4       	brne	.+36     	; 0x3b6e <__vector_88+0x9e>
    3b4a:	0e c0       	rjmp	.+28     	; 0x3b68 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3b4c:	01 96       	adiw	r24, 0x01	; 1
    3b4e:	84 36       	cpi	r24, 0x64	; 100
    3b50:	91 05       	cpc	r25, r1
    3b52:	28 f4       	brcc	.+10     	; 0x3b5e <__vector_88+0x8e>
    3b54:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvD0_read_index>
    3b58:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvD0_read_index+0x1>
    3b5c:	08 c0       	rjmp	.+16     	; 0x3b6e <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3b5e:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvD0_read_index>
    3b62:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvD0_read_index+0x1>
}
    3b66:	03 c0       	rjmp	.+6      	; 0x3b6e <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3b68:	81 e0       	ldi	r24, 0x01	; 1
    3b6a:	90 e0       	ldi	r25, 0x00	; 0
    3b6c:	f3 cf       	rjmp	.-26     	; 0x3b54 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3b6e:	ff 91       	pop	r31
    3b70:	ef 91       	pop	r30
    3b72:	9f 91       	pop	r25
    3b74:	8f 91       	pop	r24
    3b76:	3f 91       	pop	r19
    3b78:	2f 91       	pop	r18
    3b7a:	0f 90       	pop	r0
    3b7c:	0b be       	out	0x3b, r0	; 59
    3b7e:	0f 90       	pop	r0
    3b80:	08 be       	out	0x38, r0	; 56
    3b82:	0f 90       	pop	r0
    3b84:	0f be       	out	0x3f, r0	; 63
    3b86:	0f 90       	pop	r0
    3b88:	1f 90       	pop	r1
    3b8a:	18 95       	reti

00003b8c <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3b8c:	1f 92       	push	r1
    3b8e:	0f 92       	push	r0
    3b90:	0f b6       	in	r0, 0x3f	; 63
    3b92:	0f 92       	push	r0
    3b94:	11 24       	eor	r1, r1
    3b96:	08 b6       	in	r0, 0x38	; 56
    3b98:	0f 92       	push	r0
    3b9a:	18 be       	out	0x38, r1	; 56
    3b9c:	0b b6       	in	r0, 0x3b	; 59
    3b9e:	0f 92       	push	r0
    3ba0:	1b be       	out	0x3b, r1	; 59
    3ba2:	2f 93       	push	r18
    3ba4:	3f 93       	push	r19
    3ba6:	8f 93       	push	r24
    3ba8:	9f 93       	push	r25
    3baa:	ef 93       	push	r30
    3bac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3bae:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3bb2:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <rcvD1_buffer>
    3bb6:	f0 91 65 31 	lds	r31, 0x3165	; 0x803165 <rcvD1_buffer+0x1>
    3bba:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvD1_write_index>
    3bbe:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvD1_write_index+0x1>
    3bc2:	e8 0f       	add	r30, r24
    3bc4:	f9 1f       	adc	r31, r25
    3bc6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3bc8:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvD1_write_index>
    3bcc:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvD1_write_index+0x1>
    3bd0:	01 96       	adiw	r24, 0x01	; 1
    3bd2:	84 36       	cpi	r24, 0x64	; 100
    3bd4:	91 05       	cpc	r25, r1
    3bd6:	60 f4       	brcc	.+24     	; 0x3bf0 <__vector_91+0x64>
    3bd8:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvD1_write_index>
    3bdc:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3be0:	20 91 5a 31 	lds	r18, 0x315A	; 0x80315a <rcvD1_read_index>
    3be4:	30 91 5b 31 	lds	r19, 0x315B	; 0x80315b <rcvD1_read_index+0x1>
    3be8:	82 17       	cp	r24, r18
    3bea:	93 07       	cpc	r25, r19
    3bec:	f1 f4       	brne	.+60     	; 0x3c2a <__vector_91+0x9e>
    3bee:	0c c0       	rjmp	.+24     	; 0x3c08 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3bf0:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvD1_write_index>
    3bf4:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3bf8:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvD1_read_index>
    3bfc:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvD1_read_index+0x1>
    3c00:	18 16       	cp	r1, r24
    3c02:	19 06       	cpc	r1, r25
    3c04:	91 f4       	brne	.+36     	; 0x3c2a <__vector_91+0x9e>
    3c06:	0e c0       	rjmp	.+28     	; 0x3c24 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3c08:	01 96       	adiw	r24, 0x01	; 1
    3c0a:	84 36       	cpi	r24, 0x64	; 100
    3c0c:	91 05       	cpc	r25, r1
    3c0e:	28 f4       	brcc	.+10     	; 0x3c1a <__vector_91+0x8e>
    3c10:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvD1_read_index>
    3c14:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvD1_read_index+0x1>
    3c18:	08 c0       	rjmp	.+16     	; 0x3c2a <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3c1a:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvD1_read_index>
    3c1e:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvD1_read_index+0x1>
}
    3c22:	03 c0       	rjmp	.+6      	; 0x3c2a <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3c24:	81 e0       	ldi	r24, 0x01	; 1
    3c26:	90 e0       	ldi	r25, 0x00	; 0
    3c28:	f3 cf       	rjmp	.-26     	; 0x3c10 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3c2a:	ff 91       	pop	r31
    3c2c:	ef 91       	pop	r30
    3c2e:	9f 91       	pop	r25
    3c30:	8f 91       	pop	r24
    3c32:	3f 91       	pop	r19
    3c34:	2f 91       	pop	r18
    3c36:	0f 90       	pop	r0
    3c38:	0b be       	out	0x3b, r0	; 59
    3c3a:	0f 90       	pop	r0
    3c3c:	08 be       	out	0x38, r0	; 56
    3c3e:	0f 90       	pop	r0
    3c40:	0f be       	out	0x3f, r0	; 63
    3c42:	0f 90       	pop	r0
    3c44:	1f 90       	pop	r1
    3c46:	18 95       	reti

00003c48 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3c48:	1f 92       	push	r1
    3c4a:	0f 92       	push	r0
    3c4c:	0f b6       	in	r0, 0x3f	; 63
    3c4e:	0f 92       	push	r0
    3c50:	11 24       	eor	r1, r1
    3c52:	08 b6       	in	r0, 0x38	; 56
    3c54:	0f 92       	push	r0
    3c56:	18 be       	out	0x38, r1	; 56
    3c58:	0b b6       	in	r0, 0x3b	; 59
    3c5a:	0f 92       	push	r0
    3c5c:	1b be       	out	0x3b, r1	; 59
    3c5e:	2f 93       	push	r18
    3c60:	3f 93       	push	r19
    3c62:	8f 93       	push	r24
    3c64:	9f 93       	push	r25
    3c66:	ef 93       	push	r30
    3c68:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3c6a:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3c6e:	e0 91 62 31 	lds	r30, 0x3162	; 0x803162 <rcvE0_buffer>
    3c72:	f0 91 63 31 	lds	r31, 0x3163	; 0x803163 <rcvE0_buffer+0x1>
    3c76:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvE0_write_index>
    3c7a:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvE0_write_index+0x1>
    3c7e:	e8 0f       	add	r30, r24
    3c80:	f9 1f       	adc	r31, r25
    3c82:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3c84:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvE0_write_index>
    3c88:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvE0_write_index+0x1>
    3c8c:	01 96       	adiw	r24, 0x01	; 1
    3c8e:	84 36       	cpi	r24, 0x64	; 100
    3c90:	91 05       	cpc	r25, r1
    3c92:	60 f4       	brcc	.+24     	; 0x3cac <__vector_58+0x64>
    3c94:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvE0_write_index>
    3c98:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c9c:	20 91 58 31 	lds	r18, 0x3158	; 0x803158 <rcvE0_read_index>
    3ca0:	30 91 59 31 	lds	r19, 0x3159	; 0x803159 <rcvE0_read_index+0x1>
    3ca4:	82 17       	cp	r24, r18
    3ca6:	93 07       	cpc	r25, r19
    3ca8:	f1 f4       	brne	.+60     	; 0x3ce6 <__vector_58+0x9e>
    3caa:	0c c0       	rjmp	.+24     	; 0x3cc4 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3cac:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvE0_write_index>
    3cb0:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3cb4:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvE0_read_index>
    3cb8:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvE0_read_index+0x1>
    3cbc:	18 16       	cp	r1, r24
    3cbe:	19 06       	cpc	r1, r25
    3cc0:	91 f4       	brne	.+36     	; 0x3ce6 <__vector_58+0x9e>
    3cc2:	0e c0       	rjmp	.+28     	; 0x3ce0 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3cc4:	01 96       	adiw	r24, 0x01	; 1
    3cc6:	84 36       	cpi	r24, 0x64	; 100
    3cc8:	91 05       	cpc	r25, r1
    3cca:	28 f4       	brcc	.+10     	; 0x3cd6 <__vector_58+0x8e>
    3ccc:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvE0_read_index>
    3cd0:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvE0_read_index+0x1>
    3cd4:	08 c0       	rjmp	.+16     	; 0x3ce6 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3cd6:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvE0_read_index>
    3cda:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvE0_read_index+0x1>
}
    3cde:	03 c0       	rjmp	.+6      	; 0x3ce6 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3ce0:	81 e0       	ldi	r24, 0x01	; 1
    3ce2:	90 e0       	ldi	r25, 0x00	; 0
    3ce4:	f3 cf       	rjmp	.-26     	; 0x3ccc <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3ce6:	ff 91       	pop	r31
    3ce8:	ef 91       	pop	r30
    3cea:	9f 91       	pop	r25
    3cec:	8f 91       	pop	r24
    3cee:	3f 91       	pop	r19
    3cf0:	2f 91       	pop	r18
    3cf2:	0f 90       	pop	r0
    3cf4:	0b be       	out	0x3b, r0	; 59
    3cf6:	0f 90       	pop	r0
    3cf8:	08 be       	out	0x38, r0	; 56
    3cfa:	0f 90       	pop	r0
    3cfc:	0f be       	out	0x3f, r0	; 63
    3cfe:	0f 90       	pop	r0
    3d00:	1f 90       	pop	r1
    3d02:	18 95       	reti

00003d04 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3d04:	0f 93       	push	r16
    3d06:	cf 93       	push	r28
    3d08:	df 93       	push	r29
    3d0a:	1f 92       	push	r1
    3d0c:	cd b7       	in	r28, 0x3d	; 61
    3d0e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3d10:	2f b7       	in	r18, 0x3f	; 63
    3d12:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3d14:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3d16:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3d18:	fc 01       	movw	r30, r24
    3d1a:	08 ed       	ldi	r16, 0xD8	; 216
    3d1c:	04 bf       	out	0x34, r16	; 52
    3d1e:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3d20:	89 81       	ldd	r24, Y+1	; 0x01
    3d22:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3d24:	0f 90       	pop	r0
    3d26:	df 91       	pop	r29
    3d28:	cf 91       	pop	r28
    3d2a:	0f 91       	pop	r16
    3d2c:	08 95       	ret

00003d2e <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3d2e:	0f 93       	push	r16
    3d30:	1f 93       	push	r17
    3d32:	cf 93       	push	r28
    3d34:	df 93       	push	r29
    3d36:	cd b7       	in	r28, 0x3d	; 61
    3d38:	de b7       	in	r29, 0x3e	; 62
    3d3a:	6d 97       	sbiw	r28, 0x1d	; 29
    3d3c:	cd bf       	out	0x3d, r28	; 61
    3d3e:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3d40:	e0 e6       	ldi	r30, 0x60	; 96
    3d42:	f6 e0       	ldi	r31, 0x06	; 6
    3d44:	80 e4       	ldi	r24, 0x40	; 64
    3d46:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3d48:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3d4a:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3d4c:	e0 e5       	ldi	r30, 0x50	; 80
    3d4e:	f0 e0       	ldi	r31, 0x00	; 0
    3d50:	80 81       	ld	r24, Z
    3d52:	82 60       	ori	r24, 0x02	; 2
    3d54:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3d56:	81 81       	ldd	r24, Z+1	; 0x01
    3d58:	81 ff       	sbrs	r24, 1
    3d5a:	fd cf       	rjmp	.-6      	; 0x3d56 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3d5c:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3d60:	68 7f       	andi	r22, 0xF8	; 248
    3d62:	61 60       	ori	r22, 0x01	; 1
    3d64:	80 e4       	ldi	r24, 0x40	; 64
    3d66:	90 e0       	ldi	r25, 0x00	; 0
    3d68:	0e 94 82 1e 	call	0x3d04	; 0x3d04 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3d6c:	e0 e5       	ldi	r30, 0x50	; 80
    3d6e:	f0 e0       	ldi	r31, 0x00	; 0
    3d70:	80 81       	ld	r24, Z
    3d72:	8e 7f       	andi	r24, 0xFE	; 254
    3d74:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3d76:	9d ef       	ldi	r25, 0xFD	; 253
    3d78:	88 ed       	ldi	r24, 0xD8	; 216
    3d7a:	08 b6       	in	r0, 0x38	; 56
    3d7c:	18 be       	out	0x38, r1	; 56
    3d7e:	84 bf       	out	0x34, r24	; 52
    3d80:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3d84:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3d86:	40 eb       	ldi	r20, 0xB0	; 176
    3d88:	58 e0       	ldi	r21, 0x08	; 8
    3d8a:	60 e0       	ldi	r22, 0x00	; 0
    3d8c:	70 e0       	ldi	r23, 0x00	; 0
    3d8e:	ce 01       	movw	r24, r28
    3d90:	01 96       	adiw	r24, 0x01	; 1
    3d92:	0e 94 2c 1c 	call	0x3858	; 0x3858 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3d96:	67 e0       	ldi	r22, 0x07	; 7
    3d98:	ce 01       	movw	r24, r28
    3d9a:	01 96       	adiw	r24, 0x01	; 1
    3d9c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    3da0:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3da2:	69 e9       	ldi	r22, 0x99	; 153
    3da4:	70 e2       	ldi	r23, 0x20	; 32
    3da6:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    3daa:	66 e0       	ldi	r22, 0x06	; 6
    3dac:	c8 01       	movw	r24, r16
    3dae:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    3db2:	66 e0       	ldi	r22, 0x06	; 6
    3db4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3db8:	82 e1       	ldi	r24, 0x12	; 18
    3dba:	90 e0       	ldi	r25, 0x00	; 0
    3dbc:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3dc0:	8e 01       	movw	r16, r28
    3dc2:	0f 5f       	subi	r16, 0xFF	; 255
    3dc4:	1f 4f       	sbci	r17, 0xFF	; 255
    3dc6:	24 e0       	ldi	r18, 0x04	; 4
    3dc8:	31 e0       	ldi	r19, 0x01	; 1
    3dca:	40 e0       	ldi	r20, 0x00	; 0
    3dcc:	68 eb       	ldi	r22, 0xB8	; 184
    3dce:	70 e2       	ldi	r23, 0x20	; 32
    3dd0:	0e 94 0b 07 	call	0xe16	; 0xe16 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3dd4:	82 e1       	ldi	r24, 0x12	; 18
    3dd6:	90 e0       	ldi	r25, 0x00	; 0
    3dd8:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3ddc:	24 e0       	ldi	r18, 0x04	; 4
    3dde:	31 e0       	ldi	r19, 0x01	; 1
    3de0:	42 e0       	ldi	r20, 0x02	; 2
    3de2:	60 ec       	ldi	r22, 0xC0	; 192
    3de4:	70 e2       	ldi	r23, 0x20	; 32
    3de6:	0e 94 54 03 	call	0x6a8	; 0x6a8 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3dea:	82 e1       	ldi	r24, 0x12	; 18
    3dec:	90 e0       	ldi	r25, 0x00	; 0
    3dee:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3df2:	24 e0       	ldi	r18, 0x04	; 4
    3df4:	31 e0       	ldi	r19, 0x01	; 1
    3df6:	43 e0       	ldi	r20, 0x03	; 3
    3df8:	67 ec       	ldi	r22, 0xC7	; 199
    3dfa:	70 e2       	ldi	r23, 0x20	; 32
    3dfc:	0e 94 c4 03 	call	0x788	; 0x788 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3e00:	82 e1       	ldi	r24, 0x12	; 18
    3e02:	90 e0       	ldi	r25, 0x00	; 0
    3e04:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3e08:	24 e0       	ldi	r18, 0x04	; 4
    3e0a:	31 e0       	ldi	r19, 0x01	; 1
    3e0c:	44 e0       	ldi	r20, 0x04	; 4
    3e0e:	6e ec       	ldi	r22, 0xCE	; 206
    3e10:	70 e2       	ldi	r23, 0x20	; 32
    3e12:	0e 94 29 04 	call	0x852	; 0x852 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3e16:	8e e5       	ldi	r24, 0x5E	; 94
    3e18:	90 e0       	ldi	r25, 0x00	; 0
    3e1a:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3e1e:	24 e0       	ldi	r18, 0x04	; 4
    3e20:	31 e0       	ldi	r19, 0x01	; 1
    3e22:	43 e0       	ldi	r20, 0x03	; 3
    3e24:	67 ed       	ldi	r22, 0xD7	; 215
    3e26:	70 e2       	ldi	r23, 0x20	; 32
    3e28:	0e 94 57 06 	call	0xcae	; 0xcae <_ZN5MotorC1EPKchjP8emstream>
	
	new PWMdriver ("PWM", task_priority(5), 260, &ser_dev);
    3e2c:	82 e1       	ldi	r24, 0x12	; 18
    3e2e:	90 e0       	ldi	r25, 0x00	; 0
    3e30:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3e34:	24 e0       	ldi	r18, 0x04	; 4
    3e36:	31 e0       	ldi	r19, 0x01	; 1
    3e38:	44 e0       	ldi	r20, 0x04	; 4
    3e3a:	6d ed       	ldi	r22, 0xDD	; 221
    3e3c:	70 e2       	ldi	r23, 0x20	; 32
    3e3e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <_ZN9PWMdriverC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3e42:	87 e0       	ldi	r24, 0x07	; 7
    3e44:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3e48:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3e4a:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <vTaskStartScheduler>
	
	
	return 0;
    3e4e:	80 e0       	ldi	r24, 0x00	; 0
    3e50:	90 e0       	ldi	r25, 0x00	; 0
    3e52:	6d 96       	adiw	r28, 0x1d	; 29
    3e54:	cd bf       	out	0x3d, r28	; 61
    3e56:	de bf       	out	0x3e, r29	; 62
    3e58:	df 91       	pop	r29
    3e5a:	cf 91       	pop	r28
    3e5c:	1f 91       	pop	r17
    3e5e:	0f 91       	pop	r16
    3e60:	08 95       	ret

00003e62 <_GLOBAL__sub_I_counter>:
    3e62:	0f 93       	push	r16
    3e64:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3e66:	0a e0       	ldi	r16, 0x0A	; 10
    3e68:	10 e0       	ldi	r17, 0x00	; 0
    3e6a:	20 e0       	ldi	r18, 0x00	; 0
    3e6c:	30 e0       	ldi	r19, 0x00	; 0
    3e6e:	40 e0       	ldi	r20, 0x00	; 0
    3e70:	50 e0       	ldi	r21, 0x00	; 0
    3e72:	60 e2       	ldi	r22, 0x20	; 32
    3e74:	70 e0       	ldi	r23, 0x00	; 0
    3e76:	86 e7       	ldi	r24, 0x76	; 118
    3e78:	91 e3       	ldi	r25, 0x31	; 49
    3e7a:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3e7e:	1f 91       	pop	r17
    3e80:	0f 91       	pop	r16
    3e82:	08 95       	ret

00003e84 <__cmpsf2>:
    3e84:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <__fp_cmp>
    3e88:	08 f4       	brcc	.+2      	; 0x3e8c <__cmpsf2+0x8>
    3e8a:	81 e0       	ldi	r24, 0x01	; 1
    3e8c:	08 95       	ret

00003e8e <__floatunsisf>:
    3e8e:	e8 94       	clt
    3e90:	09 c0       	rjmp	.+18     	; 0x3ea4 <__floatsisf+0x12>

00003e92 <__floatsisf>:
    3e92:	97 fb       	bst	r25, 7
    3e94:	3e f4       	brtc	.+14     	; 0x3ea4 <__floatsisf+0x12>
    3e96:	90 95       	com	r25
    3e98:	80 95       	com	r24
    3e9a:	70 95       	com	r23
    3e9c:	61 95       	neg	r22
    3e9e:	7f 4f       	sbci	r23, 0xFF	; 255
    3ea0:	8f 4f       	sbci	r24, 0xFF	; 255
    3ea2:	9f 4f       	sbci	r25, 0xFF	; 255
    3ea4:	99 23       	and	r25, r25
    3ea6:	a9 f0       	breq	.+42     	; 0x3ed2 <__floatsisf+0x40>
    3ea8:	f9 2f       	mov	r31, r25
    3eaa:	96 e9       	ldi	r25, 0x96	; 150
    3eac:	bb 27       	eor	r27, r27
    3eae:	93 95       	inc	r25
    3eb0:	f6 95       	lsr	r31
    3eb2:	87 95       	ror	r24
    3eb4:	77 95       	ror	r23
    3eb6:	67 95       	ror	r22
    3eb8:	b7 95       	ror	r27
    3eba:	f1 11       	cpse	r31, r1
    3ebc:	f8 cf       	rjmp	.-16     	; 0x3eae <__floatsisf+0x1c>
    3ebe:	fa f4       	brpl	.+62     	; 0x3efe <__floatsisf+0x6c>
    3ec0:	bb 0f       	add	r27, r27
    3ec2:	11 f4       	brne	.+4      	; 0x3ec8 <__floatsisf+0x36>
    3ec4:	60 ff       	sbrs	r22, 0
    3ec6:	1b c0       	rjmp	.+54     	; 0x3efe <__floatsisf+0x6c>
    3ec8:	6f 5f       	subi	r22, 0xFF	; 255
    3eca:	7f 4f       	sbci	r23, 0xFF	; 255
    3ecc:	8f 4f       	sbci	r24, 0xFF	; 255
    3ece:	9f 4f       	sbci	r25, 0xFF	; 255
    3ed0:	16 c0       	rjmp	.+44     	; 0x3efe <__floatsisf+0x6c>
    3ed2:	88 23       	and	r24, r24
    3ed4:	11 f0       	breq	.+4      	; 0x3eda <__floatsisf+0x48>
    3ed6:	96 e9       	ldi	r25, 0x96	; 150
    3ed8:	11 c0       	rjmp	.+34     	; 0x3efc <__floatsisf+0x6a>
    3eda:	77 23       	and	r23, r23
    3edc:	21 f0       	breq	.+8      	; 0x3ee6 <__floatsisf+0x54>
    3ede:	9e e8       	ldi	r25, 0x8E	; 142
    3ee0:	87 2f       	mov	r24, r23
    3ee2:	76 2f       	mov	r23, r22
    3ee4:	05 c0       	rjmp	.+10     	; 0x3ef0 <__floatsisf+0x5e>
    3ee6:	66 23       	and	r22, r22
    3ee8:	71 f0       	breq	.+28     	; 0x3f06 <__floatsisf+0x74>
    3eea:	96 e8       	ldi	r25, 0x86	; 134
    3eec:	86 2f       	mov	r24, r22
    3eee:	70 e0       	ldi	r23, 0x00	; 0
    3ef0:	60 e0       	ldi	r22, 0x00	; 0
    3ef2:	2a f0       	brmi	.+10     	; 0x3efe <__floatsisf+0x6c>
    3ef4:	9a 95       	dec	r25
    3ef6:	66 0f       	add	r22, r22
    3ef8:	77 1f       	adc	r23, r23
    3efa:	88 1f       	adc	r24, r24
    3efc:	da f7       	brpl	.-10     	; 0x3ef4 <__floatsisf+0x62>
    3efe:	88 0f       	add	r24, r24
    3f00:	96 95       	lsr	r25
    3f02:	87 95       	ror	r24
    3f04:	97 f9       	bld	r25, 7
    3f06:	08 95       	ret

00003f08 <__fp_cmp>:
    3f08:	99 0f       	add	r25, r25
    3f0a:	00 08       	sbc	r0, r0
    3f0c:	55 0f       	add	r21, r21
    3f0e:	aa 0b       	sbc	r26, r26
    3f10:	e0 e8       	ldi	r30, 0x80	; 128
    3f12:	fe ef       	ldi	r31, 0xFE	; 254
    3f14:	16 16       	cp	r1, r22
    3f16:	17 06       	cpc	r1, r23
    3f18:	e8 07       	cpc	r30, r24
    3f1a:	f9 07       	cpc	r31, r25
    3f1c:	c0 f0       	brcs	.+48     	; 0x3f4e <__fp_cmp+0x46>
    3f1e:	12 16       	cp	r1, r18
    3f20:	13 06       	cpc	r1, r19
    3f22:	e4 07       	cpc	r30, r20
    3f24:	f5 07       	cpc	r31, r21
    3f26:	98 f0       	brcs	.+38     	; 0x3f4e <__fp_cmp+0x46>
    3f28:	62 1b       	sub	r22, r18
    3f2a:	73 0b       	sbc	r23, r19
    3f2c:	84 0b       	sbc	r24, r20
    3f2e:	95 0b       	sbc	r25, r21
    3f30:	39 f4       	brne	.+14     	; 0x3f40 <__fp_cmp+0x38>
    3f32:	0a 26       	eor	r0, r26
    3f34:	61 f0       	breq	.+24     	; 0x3f4e <__fp_cmp+0x46>
    3f36:	23 2b       	or	r18, r19
    3f38:	24 2b       	or	r18, r20
    3f3a:	25 2b       	or	r18, r21
    3f3c:	21 f4       	brne	.+8      	; 0x3f46 <__fp_cmp+0x3e>
    3f3e:	08 95       	ret
    3f40:	0a 26       	eor	r0, r26
    3f42:	09 f4       	brne	.+2      	; 0x3f46 <__fp_cmp+0x3e>
    3f44:	a1 40       	sbci	r26, 0x01	; 1
    3f46:	a6 95       	lsr	r26
    3f48:	8f ef       	ldi	r24, 0xFF	; 255
    3f4a:	81 1d       	adc	r24, r1
    3f4c:	81 1d       	adc	r24, r1
    3f4e:	08 95       	ret

00003f50 <__gesf2>:
    3f50:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <__fp_cmp>
    3f54:	08 f4       	brcc	.+2      	; 0x3f58 <__gesf2+0x8>
    3f56:	8f ef       	ldi	r24, 0xFF	; 255
    3f58:	08 95       	ret

00003f5a <__mulsi3>:
    3f5a:	db 01       	movw	r26, r22
    3f5c:	8f 93       	push	r24
    3f5e:	9f 93       	push	r25
    3f60:	0e 94 39 20 	call	0x4072	; 0x4072 <__muluhisi3>
    3f64:	bf 91       	pop	r27
    3f66:	af 91       	pop	r26
    3f68:	a2 9f       	mul	r26, r18
    3f6a:	80 0d       	add	r24, r0
    3f6c:	91 1d       	adc	r25, r1
    3f6e:	a3 9f       	mul	r26, r19
    3f70:	90 0d       	add	r25, r0
    3f72:	b2 9f       	mul	r27, r18
    3f74:	90 0d       	add	r25, r0
    3f76:	11 24       	eor	r1, r1
    3f78:	08 95       	ret

00003f7a <__divmodhi4>:
    3f7a:	97 fb       	bst	r25, 7
    3f7c:	07 2e       	mov	r0, r23
    3f7e:	16 f4       	brtc	.+4      	; 0x3f84 <__divmodhi4+0xa>
    3f80:	00 94       	com	r0
    3f82:	07 d0       	rcall	.+14     	; 0x3f92 <__divmodhi4_neg1>
    3f84:	77 fd       	sbrc	r23, 7
    3f86:	09 d0       	rcall	.+18     	; 0x3f9a <__divmodhi4_neg2>
    3f88:	0e 94 4c 20 	call	0x4098	; 0x4098 <__udivmodhi4>
    3f8c:	07 fc       	sbrc	r0, 7
    3f8e:	05 d0       	rcall	.+10     	; 0x3f9a <__divmodhi4_neg2>
    3f90:	3e f4       	brtc	.+14     	; 0x3fa0 <__divmodhi4_exit>

00003f92 <__divmodhi4_neg1>:
    3f92:	90 95       	com	r25
    3f94:	81 95       	neg	r24
    3f96:	9f 4f       	sbci	r25, 0xFF	; 255
    3f98:	08 95       	ret

00003f9a <__divmodhi4_neg2>:
    3f9a:	70 95       	com	r23
    3f9c:	61 95       	neg	r22
    3f9e:	7f 4f       	sbci	r23, 0xFF	; 255

00003fa0 <__divmodhi4_exit>:
    3fa0:	08 95       	ret

00003fa2 <__udivmodsi4>:
    3fa2:	a1 e2       	ldi	r26, 0x21	; 33
    3fa4:	1a 2e       	mov	r1, r26
    3fa6:	aa 1b       	sub	r26, r26
    3fa8:	bb 1b       	sub	r27, r27
    3faa:	fd 01       	movw	r30, r26
    3fac:	0d c0       	rjmp	.+26     	; 0x3fc8 <__udivmodsi4_ep>

00003fae <__udivmodsi4_loop>:
    3fae:	aa 1f       	adc	r26, r26
    3fb0:	bb 1f       	adc	r27, r27
    3fb2:	ee 1f       	adc	r30, r30
    3fb4:	ff 1f       	adc	r31, r31
    3fb6:	a2 17       	cp	r26, r18
    3fb8:	b3 07       	cpc	r27, r19
    3fba:	e4 07       	cpc	r30, r20
    3fbc:	f5 07       	cpc	r31, r21
    3fbe:	20 f0       	brcs	.+8      	; 0x3fc8 <__udivmodsi4_ep>
    3fc0:	a2 1b       	sub	r26, r18
    3fc2:	b3 0b       	sbc	r27, r19
    3fc4:	e4 0b       	sbc	r30, r20
    3fc6:	f5 0b       	sbc	r31, r21

00003fc8 <__udivmodsi4_ep>:
    3fc8:	66 1f       	adc	r22, r22
    3fca:	77 1f       	adc	r23, r23
    3fcc:	88 1f       	adc	r24, r24
    3fce:	99 1f       	adc	r25, r25
    3fd0:	1a 94       	dec	r1
    3fd2:	69 f7       	brne	.-38     	; 0x3fae <__udivmodsi4_loop>
    3fd4:	60 95       	com	r22
    3fd6:	70 95       	com	r23
    3fd8:	80 95       	com	r24
    3fda:	90 95       	com	r25
    3fdc:	9b 01       	movw	r18, r22
    3fde:	ac 01       	movw	r20, r24
    3fe0:	bd 01       	movw	r22, r26
    3fe2:	cf 01       	movw	r24, r30
    3fe4:	08 95       	ret

00003fe6 <__divmodsi4>:
    3fe6:	05 2e       	mov	r0, r21
    3fe8:	97 fb       	bst	r25, 7
    3fea:	1e f4       	brtc	.+6      	; 0x3ff2 <__divmodsi4+0xc>
    3fec:	00 94       	com	r0
    3fee:	0e 94 0a 20 	call	0x4014	; 0x4014 <__negsi2>
    3ff2:	57 fd       	sbrc	r21, 7
    3ff4:	07 d0       	rcall	.+14     	; 0x4004 <__divmodsi4_neg2>
    3ff6:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    3ffa:	07 fc       	sbrc	r0, 7
    3ffc:	03 d0       	rcall	.+6      	; 0x4004 <__divmodsi4_neg2>
    3ffe:	4e f4       	brtc	.+18     	; 0x4012 <__divmodsi4_exit>
    4000:	0c 94 0a 20 	jmp	0x4014	; 0x4014 <__negsi2>

00004004 <__divmodsi4_neg2>:
    4004:	50 95       	com	r21
    4006:	40 95       	com	r20
    4008:	30 95       	com	r19
    400a:	21 95       	neg	r18
    400c:	3f 4f       	sbci	r19, 0xFF	; 255
    400e:	4f 4f       	sbci	r20, 0xFF	; 255
    4010:	5f 4f       	sbci	r21, 0xFF	; 255

00004012 <__divmodsi4_exit>:
    4012:	08 95       	ret

00004014 <__negsi2>:
    4014:	90 95       	com	r25
    4016:	80 95       	com	r24
    4018:	70 95       	com	r23
    401a:	61 95       	neg	r22
    401c:	7f 4f       	sbci	r23, 0xFF	; 255
    401e:	8f 4f       	sbci	r24, 0xFF	; 255
    4020:	9f 4f       	sbci	r25, 0xFF	; 255
    4022:	08 95       	ret

00004024 <__tablejump2__>:
    4024:	ee 0f       	add	r30, r30
    4026:	ff 1f       	adc	r31, r31
    4028:	88 1f       	adc	r24, r24
    402a:	8b bf       	out	0x3b, r24	; 59
    402c:	07 90       	elpm	r0, Z+
    402e:	f6 91       	elpm	r31, Z
    4030:	e0 2d       	mov	r30, r0
    4032:	1b be       	out	0x3b, r1	; 59
    4034:	19 94       	eijmp

00004036 <__mulhisi3>:
    4036:	0e 94 23 20 	call	0x4046	; 0x4046 <__umulhisi3>
    403a:	33 23       	and	r19, r19
    403c:	12 f4       	brpl	.+4      	; 0x4042 <__mulhisi3+0xc>
    403e:	8a 1b       	sub	r24, r26
    4040:	9b 0b       	sbc	r25, r27
    4042:	0c 94 34 20 	jmp	0x4068	; 0x4068 <__usmulhisi3_tail>

00004046 <__umulhisi3>:
    4046:	a2 9f       	mul	r26, r18
    4048:	b0 01       	movw	r22, r0
    404a:	b3 9f       	mul	r27, r19
    404c:	c0 01       	movw	r24, r0
    404e:	a3 9f       	mul	r26, r19
    4050:	70 0d       	add	r23, r0
    4052:	81 1d       	adc	r24, r1
    4054:	11 24       	eor	r1, r1
    4056:	91 1d       	adc	r25, r1
    4058:	b2 9f       	mul	r27, r18
    405a:	70 0d       	add	r23, r0
    405c:	81 1d       	adc	r24, r1
    405e:	11 24       	eor	r1, r1
    4060:	91 1d       	adc	r25, r1
    4062:	08 95       	ret

00004064 <__usmulhisi3>:
    4064:	0e 94 23 20 	call	0x4046	; 0x4046 <__umulhisi3>

00004068 <__usmulhisi3_tail>:
    4068:	b7 ff       	sbrs	r27, 7
    406a:	08 95       	ret
    406c:	82 1b       	sub	r24, r18
    406e:	93 0b       	sbc	r25, r19
    4070:	08 95       	ret

00004072 <__muluhisi3>:
    4072:	0e 94 23 20 	call	0x4046	; 0x4046 <__umulhisi3>
    4076:	a5 9f       	mul	r26, r21
    4078:	90 0d       	add	r25, r0
    407a:	b4 9f       	mul	r27, r20
    407c:	90 0d       	add	r25, r0
    407e:	a4 9f       	mul	r26, r20
    4080:	80 0d       	add	r24, r0
    4082:	91 1d       	adc	r25, r1
    4084:	11 24       	eor	r1, r1
    4086:	08 95       	ret

00004088 <__mulshisi3>:
    4088:	b7 ff       	sbrs	r27, 7
    408a:	0c 94 39 20 	jmp	0x4072	; 0x4072 <__muluhisi3>

0000408e <__mulohisi3>:
    408e:	0e 94 39 20 	call	0x4072	; 0x4072 <__muluhisi3>
    4092:	82 1b       	sub	r24, r18
    4094:	93 0b       	sbc	r25, r19
    4096:	08 95       	ret

00004098 <__udivmodhi4>:
    4098:	aa 1b       	sub	r26, r26
    409a:	bb 1b       	sub	r27, r27
    409c:	51 e1       	ldi	r21, 0x11	; 17
    409e:	07 c0       	rjmp	.+14     	; 0x40ae <__udivmodhi4_ep>

000040a0 <__udivmodhi4_loop>:
    40a0:	aa 1f       	adc	r26, r26
    40a2:	bb 1f       	adc	r27, r27
    40a4:	a6 17       	cp	r26, r22
    40a6:	b7 07       	cpc	r27, r23
    40a8:	10 f0       	brcs	.+4      	; 0x40ae <__udivmodhi4_ep>
    40aa:	a6 1b       	sub	r26, r22
    40ac:	b7 0b       	sbc	r27, r23

000040ae <__udivmodhi4_ep>:
    40ae:	88 1f       	adc	r24, r24
    40b0:	99 1f       	adc	r25, r25
    40b2:	5a 95       	dec	r21
    40b4:	a9 f7       	brne	.-22     	; 0x40a0 <__udivmodhi4_loop>
    40b6:	80 95       	com	r24
    40b8:	90 95       	com	r25
    40ba:	bc 01       	movw	r22, r24
    40bc:	cd 01       	movw	r24, r26
    40be:	08 95       	ret

000040c0 <memcpy>:
    40c0:	fb 01       	movw	r30, r22
    40c2:	dc 01       	movw	r26, r24
    40c4:	02 c0       	rjmp	.+4      	; 0x40ca <memcpy+0xa>
    40c6:	01 90       	ld	r0, Z+
    40c8:	0d 92       	st	X+, r0
    40ca:	41 50       	subi	r20, 0x01	; 1
    40cc:	50 40       	sbci	r21, 0x00	; 0
    40ce:	d8 f7       	brcc	.-10     	; 0x40c6 <memcpy+0x6>
    40d0:	08 95       	ret

000040d2 <memset>:
    40d2:	dc 01       	movw	r26, r24
    40d4:	01 c0       	rjmp	.+2      	; 0x40d8 <memset+0x6>
    40d6:	6d 93       	st	X+, r22
    40d8:	41 50       	subi	r20, 0x01	; 1
    40da:	50 40       	sbci	r21, 0x00	; 0
    40dc:	e0 f7       	brcc	.-8      	; 0x40d6 <memset+0x4>
    40de:	08 95       	ret

000040e0 <strncpy>:
    40e0:	fb 01       	movw	r30, r22
    40e2:	dc 01       	movw	r26, r24
    40e4:	41 50       	subi	r20, 0x01	; 1
    40e6:	50 40       	sbci	r21, 0x00	; 0
    40e8:	48 f0       	brcs	.+18     	; 0x40fc <strncpy+0x1c>
    40ea:	01 90       	ld	r0, Z+
    40ec:	0d 92       	st	X+, r0
    40ee:	00 20       	and	r0, r0
    40f0:	c9 f7       	brne	.-14     	; 0x40e4 <strncpy+0x4>
    40f2:	01 c0       	rjmp	.+2      	; 0x40f6 <strncpy+0x16>
    40f4:	1d 92       	st	X+, r1
    40f6:	41 50       	subi	r20, 0x01	; 1
    40f8:	50 40       	sbci	r21, 0x00	; 0
    40fa:	e0 f7       	brcc	.-8      	; 0x40f4 <strncpy+0x14>
    40fc:	08 95       	ret

000040fe <__itoa_ncheck>:
    40fe:	bb 27       	eor	r27, r27
    4100:	4a 30       	cpi	r20, 0x0A	; 10
    4102:	31 f4       	brne	.+12     	; 0x4110 <__itoa_ncheck+0x12>
    4104:	99 23       	and	r25, r25
    4106:	22 f4       	brpl	.+8      	; 0x4110 <__itoa_ncheck+0x12>
    4108:	bd e2       	ldi	r27, 0x2D	; 45
    410a:	90 95       	com	r25
    410c:	81 95       	neg	r24
    410e:	9f 4f       	sbci	r25, 0xFF	; 255
    4110:	0c 94 d2 20 	jmp	0x41a4	; 0x41a4 <__utoa_common>

00004114 <__ltoa_ncheck>:
    4114:	bb 27       	eor	r27, r27
    4116:	2a 30       	cpi	r18, 0x0A	; 10
    4118:	51 f4       	brne	.+20     	; 0x412e <__ltoa_ncheck+0x1a>
    411a:	99 23       	and	r25, r25
    411c:	42 f4       	brpl	.+16     	; 0x412e <__ltoa_ncheck+0x1a>
    411e:	bd e2       	ldi	r27, 0x2D	; 45
    4120:	90 95       	com	r25
    4122:	80 95       	com	r24
    4124:	70 95       	com	r23
    4126:	61 95       	neg	r22
    4128:	7f 4f       	sbci	r23, 0xFF	; 255
    412a:	8f 4f       	sbci	r24, 0xFF	; 255
    412c:	9f 4f       	sbci	r25, 0xFF	; 255
    412e:	0c 94 a5 20 	jmp	0x414a	; 0x414a <__ultoa_common>

00004132 <ultoa>:
    4132:	25 32       	cpi	r18, 0x25	; 37
    4134:	31 05       	cpc	r19, r1
    4136:	20 f4       	brcc	.+8      	; 0x4140 <ultoa+0xe>
    4138:	22 30       	cpi	r18, 0x02	; 2
    413a:	10 f0       	brcs	.+4      	; 0x4140 <ultoa+0xe>
    413c:	0c 94 a4 20 	jmp	0x4148	; 0x4148 <__ultoa_ncheck>
    4140:	fa 01       	movw	r30, r20
    4142:	10 82       	st	Z, r1
    4144:	ca 01       	movw	r24, r20
    4146:	08 95       	ret

00004148 <__ultoa_ncheck>:
    4148:	bb 27       	eor	r27, r27

0000414a <__ultoa_common>:
    414a:	fa 01       	movw	r30, r20
    414c:	a6 2f       	mov	r26, r22
    414e:	62 17       	cp	r22, r18
    4150:	71 05       	cpc	r23, r1
    4152:	81 05       	cpc	r24, r1
    4154:	91 05       	cpc	r25, r1
    4156:	33 0b       	sbc	r19, r19
    4158:	30 fb       	bst	r19, 0
    415a:	66 f0       	brts	.+24     	; 0x4174 <__ultoa_common+0x2a>
    415c:	aa 27       	eor	r26, r26
    415e:	66 0f       	add	r22, r22
    4160:	77 1f       	adc	r23, r23
    4162:	88 1f       	adc	r24, r24
    4164:	99 1f       	adc	r25, r25
    4166:	aa 1f       	adc	r26, r26
    4168:	a2 17       	cp	r26, r18
    416a:	10 f0       	brcs	.+4      	; 0x4170 <__ultoa_common+0x26>
    416c:	a2 1b       	sub	r26, r18
    416e:	63 95       	inc	r22
    4170:	38 50       	subi	r19, 0x08	; 8
    4172:	a9 f7       	brne	.-22     	; 0x415e <__ultoa_common+0x14>
    4174:	a0 5d       	subi	r26, 0xD0	; 208
    4176:	aa 33       	cpi	r26, 0x3A	; 58
    4178:	08 f0       	brcs	.+2      	; 0x417c <__ultoa_common+0x32>
    417a:	a9 5d       	subi	r26, 0xD9	; 217
    417c:	a1 93       	st	Z+, r26
    417e:	36 f7       	brtc	.-52     	; 0x414c <__ultoa_common+0x2>
    4180:	b1 11       	cpse	r27, r1
    4182:	b1 93       	st	Z+, r27
    4184:	10 82       	st	Z, r1
    4186:	ca 01       	movw	r24, r20
    4188:	0c 94 eb 20 	jmp	0x41d6	; 0x41d6 <strrev>

0000418c <utoa>:
    418c:	45 32       	cpi	r20, 0x25	; 37
    418e:	51 05       	cpc	r21, r1
    4190:	20 f4       	brcc	.+8      	; 0x419a <utoa+0xe>
    4192:	42 30       	cpi	r20, 0x02	; 2
    4194:	10 f0       	brcs	.+4      	; 0x419a <utoa+0xe>
    4196:	0c 94 d1 20 	jmp	0x41a2	; 0x41a2 <__utoa_ncheck>
    419a:	fb 01       	movw	r30, r22
    419c:	10 82       	st	Z, r1
    419e:	cb 01       	movw	r24, r22
    41a0:	08 95       	ret

000041a2 <__utoa_ncheck>:
    41a2:	bb 27       	eor	r27, r27

000041a4 <__utoa_common>:
    41a4:	fb 01       	movw	r30, r22
    41a6:	55 27       	eor	r21, r21
    41a8:	aa 27       	eor	r26, r26
    41aa:	88 0f       	add	r24, r24
    41ac:	99 1f       	adc	r25, r25
    41ae:	aa 1f       	adc	r26, r26
    41b0:	a4 17       	cp	r26, r20
    41b2:	10 f0       	brcs	.+4      	; 0x41b8 <__utoa_common+0x14>
    41b4:	a4 1b       	sub	r26, r20
    41b6:	83 95       	inc	r24
    41b8:	50 51       	subi	r21, 0x10	; 16
    41ba:	b9 f7       	brne	.-18     	; 0x41aa <__utoa_common+0x6>
    41bc:	a0 5d       	subi	r26, 0xD0	; 208
    41be:	aa 33       	cpi	r26, 0x3A	; 58
    41c0:	08 f0       	brcs	.+2      	; 0x41c4 <__utoa_common+0x20>
    41c2:	a9 5d       	subi	r26, 0xD9	; 217
    41c4:	a1 93       	st	Z+, r26
    41c6:	00 97       	sbiw	r24, 0x00	; 0
    41c8:	79 f7       	brne	.-34     	; 0x41a8 <__utoa_common+0x4>
    41ca:	b1 11       	cpse	r27, r1
    41cc:	b1 93       	st	Z+, r27
    41ce:	11 92       	st	Z+, r1
    41d0:	cb 01       	movw	r24, r22
    41d2:	0c 94 eb 20 	jmp	0x41d6	; 0x41d6 <strrev>

000041d6 <strrev>:
    41d6:	dc 01       	movw	r26, r24
    41d8:	fc 01       	movw	r30, r24
    41da:	67 2f       	mov	r22, r23
    41dc:	71 91       	ld	r23, Z+
    41de:	77 23       	and	r23, r23
    41e0:	e1 f7       	brne	.-8      	; 0x41da <strrev+0x4>
    41e2:	32 97       	sbiw	r30, 0x02	; 2
    41e4:	04 c0       	rjmp	.+8      	; 0x41ee <strrev+0x18>
    41e6:	7c 91       	ld	r23, X
    41e8:	6d 93       	st	X+, r22
    41ea:	70 83       	st	Z, r23
    41ec:	62 91       	ld	r22, -Z
    41ee:	ae 17       	cp	r26, r30
    41f0:	bf 07       	cpc	r27, r31
    41f2:	c8 f3       	brcs	.-14     	; 0x41e6 <strrev+0x10>
    41f4:	08 95       	ret

000041f6 <_exit>:
    41f6:	f8 94       	cli

000041f8 <__stop_program>:
    41f8:	ff cf       	rjmp	.-2      	; 0x41f8 <__stop_program>
