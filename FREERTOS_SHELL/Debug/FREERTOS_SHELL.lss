
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003fde  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ca  00802000  00003fde  00004072  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020ca  008020ca  0000413c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000413c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000416c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006f0  00000000  00000000  000041ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012365  00000000  00000000  0000489c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000679d  00000000  00000000  00016c01  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000053a8  00000000  00000000  0001d39e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001368  00000000  00000000  00022748  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000608f  00000000  00000000  00023ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000061ee  00000000  00000000  00029b3f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005b0  00000000  00000000  0002fd2d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a9 02 	jmp	0x552	; 0x552 <__ctors_end>
       4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      10:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      14:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      18:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      1c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      20:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      24:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      28:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      2c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      30:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      34:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      38:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      3c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      40:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      44:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      48:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      4c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      50:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      54:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      58:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      5c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      60:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      64:	0c 94 bd 1b 	jmp	0x377a	; 0x377a <__vector_25>
      68:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      6c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      70:	0c 94 1b 1c 	jmp	0x3836	; 0x3836 <__vector_28>
      74:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      78:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      7c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      80:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      84:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      88:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      8c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      90:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      94:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      98:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      9c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c4:	0c 94 a9 0b 	jmp	0x1752	; 0x1752 <__vector_49>
      c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e8:	0c 94 35 1d 	jmp	0x3a6a	; 0x3a6a <__vector_58>
      ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      fc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     100:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     104:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     108:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     10c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     110:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     114:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     118:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     11c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     120:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     124:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     128:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     12c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     130:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     134:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     138:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     13c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     140:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     144:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     148:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     14c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     150:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     154:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     158:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     15c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     160:	0c 94 79 1c 	jmp	0x38f2	; 0x38f2 <__vector_88>
     164:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     168:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     16c:	0c 94 d7 1c 	jmp	0x39ae	; 0x39ae <__vector_91>
     170:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     174:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     178:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     17c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     180:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     184:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     188:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     18c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     190:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     194:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     198:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     19c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1fc:	80 19       	sub	r24, r0
     1fe:	83 19       	sub	r24, r3
     200:	86 19       	sub	r24, r6
     202:	89 19       	sub	r24, r9
     204:	8c 19       	sub	r24, r12
     206:	8f 19       	sub	r24, r15
     208:	91 19       	sub	r25, r1
     20a:	a2 19       	sub	r26, r2
     20c:	aa 19       	sub	r26, r10
     20e:	b4 19       	sub	r27, r4
     210:	b2 19       	sub	r27, r2

00000212 <__trampolines_start>:
     212:	0c 94 2b 19 	jmp	0x3256	; 0x3256 <_ZN8emstream12clear_screenEv>
     216:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <_ZN9task_user3runEv>
     21a:	0c 94 5c 15 	jmp	0x2ab8	; 0x2ab8 <_ZN8frt_task12print_statusER8emstream>
     21e:	0c 94 2a 19 	jmp	0x3254	; 0x3254 <_ZN8emstream12transmit_nowEv>
     222:	0c 94 25 19 	jmp	0x324a	; 0x324a <_ZN8emstream7getcharEv>
     226:	0c 94 aa 19 	jmp	0x3354	; 0x3354 <_ZN8emstreamlsE15ser_manipulator+0x72>
     22a:	0c 94 42 1e 	jmp	0x3c84	; 0x3c84 <_GLOBAL__sub_I_counter>
     22e:	0c 94 bd 05 	jmp	0xb7a	; 0xb7a <_ZN9PWMdriver3runEv>
     232:	0c 94 86 19 	jmp	0x330c	; 0x330c <_ZN8emstreamlsE15ser_manipulator+0x2a>
     236:	0c 94 f6 03 	jmp	0x7ec	; 0x7ec <_ZN13LimitSwitches3runEv>
     23a:	0c 94 a6 16 	jmp	0x2d4c	; 0x2d4c <_ZN14frt_text_queue7getcharEv>
     23e:	0c 94 83 19 	jmp	0x3306	; 0x3306 <_ZN8emstreamlsE15ser_manipulator+0x24>
     242:	0c 94 21 1b 	jmp	0x3642	; 0x3642 <_ZN5rs23214check_for_charEv>
     246:	0c 94 a6 02 	jmp	0x54c	; 0x54c <_call_static_run_method>
     24a:	0c 94 8c 18 	jmp	0x3118	; 0x3118 <__cxa_pure_virtual>
     24e:	0c 94 a2 19 	jmp	0x3344	; 0x3344 <_ZN8emstreamlsE15ser_manipulator+0x62>
     252:	0c 94 80 19 	jmp	0x3300	; 0x3300 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     256:	0c 94 c4 16 	jmp	0x2d88	; 0x2d88 <_ZN14frt_text_queue14check_for_charEv>
     25a:	0c 94 91 19 	jmp	0x3322	; 0x3322 <_ZN8emstreamlsE15ser_manipulator+0x40>
     25e:	0c 94 cf 16 	jmp	0x2d9e	; 0x2d9e <_ZN14frt_text_queue7putcharEc>
     262:	0c 94 2d 0e 	jmp	0x1c5a	; 0x1c5a <prvIdleTask>
     266:	0c 94 b4 19 	jmp	0x3368	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
     26a:	0c 94 34 1b 	jmp	0x3668	; 0x3668 <_ZN5rs23212clear_screenEv>
     26e:	0c 94 b2 19 	jmp	0x3364	; 0x3364 <_ZN8emstreamlsE15ser_manipulator+0x82>
     272:	0c 94 89 19 	jmp	0x3312	; 0x3312 <_ZN8emstreamlsE15ser_manipulator+0x30>
     276:	0c 94 86 03 	jmp	0x70c	; 0x70c <_ZN15EncoderPendulum3runEv>
     27a:	0c 94 8f 19 	jmp	0x331e	; 0x331e <_ZN8emstreamlsE15ser_manipulator+0x3c>
     27e:	0c 94 28 19 	jmp	0x3250	; 0x3250 <_ZN8emstream14check_for_charEv>
     282:	0c 94 d7 1a 	jmp	0x35ae	; 0x35ae <_ZN5rs2327putcharEc>
     286:	0c 94 23 19 	jmp	0x3246	; 0x3246 <_ZN8emstream13ready_to_sendEv>
     28a:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <_ZN5Motor3runEv>
     28e:	0c 94 8c 19 	jmp	0x3318	; 0x3318 <_ZN8emstreamlsE15ser_manipulator+0x36>
     292:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_ZN12EncoderMotor3runEv>
     296:	0c 94 fb 1a 	jmp	0x35f6	; 0x35f6 <_ZN5rs2327getcharEv>

0000029a <__trampolines_end>:
     29a:	2c 20       	and	r2, r12
     29c:	54 43       	sbci	r21, 0x34	; 52
     29e:	43 30       	cpi	r20, 0x03	; 3
     2a0:	43 43       	sbci	r20, 0x33	; 51
     2a2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a5 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a5:	2f 00                                               /.

000002a7 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b5:	54 69 6d 65 3a 20 00                                Time: .

000002bc <_ZZN9task_user11show_statusEvE3__c_0>:
     2bc:	44 65 63 20 20 34 20 32 30 31 37 00                 Dec  4 2017.

000002c8 <_ZZN9task_user11show_statusEvE3__c>:
     2c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     306:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000311 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     311:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     321:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34f:	6d 61 74 69 6f 6e 00                                mation.

00000356 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     356:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     366:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000377 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     377:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     387:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003ab <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3ab:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bb:	68 65 20 41 56 52 00                                he AVR.

000003c2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c2:	20 68 65 6c 70 00                                    help.

000003c8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e7 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e7:	1b 5b 33 30 6d 00                                   .[30m.

000003ed <_ZZN9task_user18print_help_messageEvE3__c>:
     3ed:	1b 5b 34 36 6d 00                                   .[46m.

000003f3 <_ZZN9task_user3runEvE3__c_3>:
     3f3:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     403:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000410 <_ZZN9task_user3runEvE3__c_2>:
     410:	3a 57 54 46 3f 00                                   :WTF?.

00000416 <_ZZN9task_user3runEvE3__c_1>:
     416:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     426:	65 00                                               e.

00000428 <_ZZN9task_user3runEvE3__c_0>:
     428:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000436 <_ZZN9task_user3runEvE3__c>:
     436:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     446:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000454 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     454:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045e <_ZZN8frt_task15emergency_resetEvE3__c>:
     45e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000046d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     46d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     47d:	61 73 6b 20 00                                      ask .

00000482 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     482:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000490 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     490:	20 63 72 65 61 74 65 64 00                           created.

00000499 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     499:	54 61 73 6b 20 00                                   Task .

0000049f <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49f:	1b 5b 32 32 6d 00                                   .[22m.

000004a5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a5:	54 61 73 6b 3a 20 00                                Task: .

000004ac <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4ac:	1b 5b 31 6d 00                                      .[1m.

000004b1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b1:	1b 5b 32 32 6d 00                                   .[22m.

000004b7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c2:	1b 5b 31 6d 00                                      .[1m.

000004c7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c7:	09 09 00                                            ...

000004ca <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ca:	2f 00                                               /.

000004cc <_ZZ15print_task_listP8emstreamE3__c_7>:
     4cc:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d7:	09 2d 2d 2d 2d 00                                   .----.

000004dd <_ZZ15print_task_listP8emstreamE3__c_5>:
     4dd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e9 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e9:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fa <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fa:	09 52 75 6e 73 00                                   .Runs.

00000500 <_ZZ15print_task_listP8emstreamE3__c_2>:
     500:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000050c <_ZZ15print_task_listP8emstreamE3__c_1>:
     50c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000051d <_ZZ15print_task_listP8emstreamE3__c_0>:
     51d:	09 53 74 61 63 6b 00                                .Stack.

00000524 <_ZZ15print_task_listP8emstreamE3__c>:
     524:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52f:	09 00                                               ..

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     533:	2f 00                                               /.

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     537:	09 00                                               ..

00000539 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53f:	1b 5b 31 6d 00                                      .[1m.

00000544 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     544:	1b 5b 31 6d 00                                      .[1m.

00000549 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     549:	20 20 00                                              .

0000054c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     54c:	0e 94 f4 13 	call	0x27e8	; 0x27e8 <_ZN8frt_task22_call_users_run_methodEPS_>

00000550 <__ctors_start>:
     550:	42 1e       	adc	r4, r18

00000552 <__ctors_end>:
     552:	11 24       	eor	r1, r1
     554:	1f be       	out	0x3f, r1	; 63
     556:	cf ef       	ldi	r28, 0xFF	; 255
     558:	cd bf       	out	0x3d, r28	; 61
     55a:	df e3       	ldi	r29, 0x3F	; 63
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	00 e0       	ldi	r16, 0x00	; 0
     560:	0c bf       	out	0x3c, r16	; 60
     562:	18 be       	out	0x38, r1	; 56
     564:	19 be       	out	0x39, r1	; 57
     566:	1a be       	out	0x3a, r1	; 58
     568:	1b be       	out	0x3b, r1	; 59

0000056a <__do_copy_data>:
     56a:	10 e2       	ldi	r17, 0x20	; 32
     56c:	a0 e0       	ldi	r26, 0x00	; 0
     56e:	b0 e2       	ldi	r27, 0x20	; 32
     570:	ee ed       	ldi	r30, 0xDE	; 222
     572:	ff e3       	ldi	r31, 0x3F	; 63
     574:	00 e0       	ldi	r16, 0x00	; 0
     576:	0b bf       	out	0x3b, r16	; 59
     578:	02 c0       	rjmp	.+4      	; 0x57e <__do_copy_data+0x14>
     57a:	07 90       	elpm	r0, Z+
     57c:	0d 92       	st	X+, r0
     57e:	aa 3c       	cpi	r26, 0xCA	; 202
     580:	b1 07       	cpc	r27, r17
     582:	d9 f7       	brne	.-10     	; 0x57a <__do_copy_data+0x10>
     584:	1b be       	out	0x3b, r1	; 59

00000586 <__do_clear_bss>:
     586:	21 e3       	ldi	r18, 0x31	; 49
     588:	aa ec       	ldi	r26, 0xCA	; 202
     58a:	b0 e2       	ldi	r27, 0x20	; 32
     58c:	01 c0       	rjmp	.+2      	; 0x590 <.do_clear_bss_start>

0000058e <.do_clear_bss_loop>:
     58e:	1d 92       	st	X+, r1

00000590 <.do_clear_bss_start>:
     590:	a0 37       	cpi	r26, 0x70	; 112
     592:	b2 07       	cpc	r27, r18
     594:	e1 f7       	brne	.-8      	; 0x58e <.do_clear_bss_loop>

00000596 <__do_global_ctors>:
     596:	12 e0       	ldi	r17, 0x02	; 2
     598:	c9 ea       	ldi	r28, 0xA9	; 169
     59a:	d2 e0       	ldi	r29, 0x02	; 2
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	06 c0       	rjmp	.+12     	; 0x5ac <__do_global_ctors+0x16>
     5a0:	21 97       	sbiw	r28, 0x01	; 1
     5a2:	01 09       	sbc	r16, r1
     5a4:	80 2f       	mov	r24, r16
     5a6:	fe 01       	movw	r30, r28
     5a8:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <__tablejump2__>
     5ac:	c8 3a       	cpi	r28, 0xA8	; 168
     5ae:	d1 07       	cpc	r29, r17
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	08 07       	cpc	r16, r24
     5b4:	a9 f7       	brne	.-22     	; 0x5a0 <__do_global_ctors+0xa>
     5b6:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <main>
     5ba:	0c 94 ed 1f 	jmp	0x3fda	; 0x3fda <_exit>

000005be <__bad_interrupt>:
     5be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c2 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	00 d0       	rcall	.+0      	; 0x5c8 <_ZN12EncoderMotor3runEv+0x6>
     5c8:	1f 92       	push	r1
     5ca:	cd b7       	in	r28, 0x3d	; 61
     5cc:	de b7       	in	r29, 0x3e	; 62
     5ce:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d0:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <xTaskGetTickCount>
     5d4:	69 83       	std	Y+1, r22	; 0x01
     5d6:	7a 83       	std	Y+2, r23	; 0x02
     5d8:	8b 83       	std	Y+3, r24	; 0x03
     5da:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5dc:	e0 e8       	ldi	r30, 0x80	; 128
     5de:	f6 e0       	ldi	r31, 0x06	; 6
     5e0:	8c e0       	ldi	r24, 0x0C	; 12
     5e2:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e4:	82 89       	ldd	r24, Z+18	; 0x12
     5e6:	83 60       	ori	r24, 0x03	; 3
     5e8:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ea:	83 89       	ldd	r24, Z+19	; 0x13
     5ec:	83 60       	ori	r24, 0x03	; 3
     5ee:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5f0:	e0 e8       	ldi	r30, 0x80	; 128
     5f2:	f1 e0       	ldi	r31, 0x01	; 1
     5f4:	82 e7       	ldi	r24, 0x72	; 114
     5f6:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f8:	89 e0       	ldi	r24, 0x09	; 9
     5fa:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5fc:	e0 e0       	ldi	r30, 0x00	; 0
     5fe:	f9 e0       	ldi	r31, 0x09	; 9
     600:	88 e6       	ldi	r24, 0x68	; 104
     602:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     604:	8f ef       	ldi	r24, 0xFF	; 255
     606:	9f ef       	ldi	r25, 0xFF	; 255
     608:	86 a3       	std	Z+38, r24	; 0x26
     60a:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     60c:	81 e0       	ldi	r24, 0x01	; 1
     60e:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     610:	0f 2e       	mov	r0, r31
     612:	21 2c       	mov	r2, r1
     614:	f9 e0       	ldi	r31, 0x09	; 9
     616:	3f 2e       	mov	r3, r31
     618:	f0 2d       	mov	r31, r0
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     61a:	0f 2e       	mov	r0, r31
     61c:	f4 e6       	ldi	r31, 0x64	; 100
     61e:	4f 2e       	mov	r4, r31
     620:	51 2c       	mov	r5, r1
     622:	61 2c       	mov	r6, r1
     624:	71 2c       	mov	r7, r1
     626:	f0 2d       	mov	r31, r0
     628:	f1 01       	movw	r30, r2
     62a:	00 a1       	ldd	r16, Z+32	; 0x20
     62c:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     62e:	0f b6       	in	r0, 0x3f	; 63
     630:	f8 94       	cli
     632:	0f 92       	push	r0
			the_data = new_data;
     634:	c8 01       	movw	r24, r16
     636:	01 2e       	mov	r0, r17
     638:	00 0c       	add	r0, r0
     63a:	aa 0b       	sbc	r26, r26
     63c:	bb 0b       	sbc	r27, r27
     63e:	ac 01       	movw	r20, r24
     640:	bd 01       	movw	r22, r26
     642:	44 0f       	add	r20, r20
     644:	55 1f       	adc	r21, r21
     646:	66 1f       	adc	r22, r22
     648:	77 1f       	adc	r23, r23
     64a:	4a 01       	movw	r8, r20
     64c:	5b 01       	movw	r10, r22
     64e:	88 0e       	add	r8, r24
     650:	99 1e       	adc	r9, r25
     652:	aa 1e       	adc	r10, r26
     654:	bb 1e       	adc	r11, r27
     656:	c5 01       	movw	r24, r10
     658:	b4 01       	movw	r22, r8
     65a:	a3 01       	movw	r20, r6
     65c:	92 01       	movw	r18, r4
     65e:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <__divmodsi4>
     662:	20 93 5c 31 	sts	0x315C, r18	; 0x80315c <linear_position>
     666:	30 93 5d 31 	sts	0x315D, r19	; 0x80315d <linear_position+0x1>
			portEXIT_CRITICAL ();
     66a:	0f 90       	pop	r0
     66c:	0f be       	out	0x3f, r0	; 63
		
		x = ( (int32_t) encoder_count*3)/100;								// PPMM = (4*1000)/(pi*38)
		//*p_serial << "linearPosition: " << x << " [mm]" << endl;			// x position in mm
		linear_position.put(x);
		
		int16_t ticks_per_ms = (encoder_count - last_encoder_count); // current angular velocity [ticks/ms]
     66e:	58 01       	movw	r10, r16
     670:	ac 18       	sub	r10, r12
     672:	bd 08       	sbc	r11, r13
     674:	65 01       	movw	r12, r10
		
		if(runs%100==0)
     676:	f7 01       	movw	r30, r14
     678:	66 85       	ldd	r22, Z+14	; 0x0e
     67a:	77 85       	ldd	r23, Z+15	; 0x0f
     67c:	80 89       	ldd	r24, Z+16	; 0x10
     67e:	91 89       	ldd	r25, Z+17	; 0x11
     680:	a3 01       	movw	r20, r6
     682:	92 01       	movw	r18, r4
     684:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <__udivmodsi4>
     688:	67 2b       	or	r22, r23
     68a:	68 2b       	or	r22, r24
     68c:	69 2b       	or	r22, r25
     68e:	79 f4       	brne	.+30     	; 0x6ae <_ZN12EncoderMotor3runEv+0xec>
		{
			*p_serial << "Ticks_per_ms: " << ticks_per_ms << endl;
     690:	f7 01       	movw	r30, r14
     692:	a6 80       	ldd	r10, Z+6	; 0x06
     694:	b7 80       	ldd	r11, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     696:	66 e0       	ldi	r22, 0x06	; 6
     698:	70 e2       	ldi	r23, 0x20	; 32
     69a:	c5 01       	movw	r24, r10
     69c:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     6a0:	b6 01       	movw	r22, r12
     6a2:	c5 01       	movw	r24, r10
     6a4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstreamlsEi>
     6a8:	66 e0       	ldi	r22, 0x06	; 6
     6aa:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     6ae:	0f b6       	in	r0, 0x3f	; 63
     6b0:	f8 94       	cli
     6b2:	0f 92       	push	r0
			the_data = new_data;
     6b4:	c0 92 5a 31 	sts	0x315A, r12	; 0x80315a <thdMotor>
     6b8:	d0 92 5b 31 	sts	0x315B, r13	; 0x80315b <thdMotor+0x1>
			portEXIT_CRITICAL ();
     6bc:	0f 90       	pop	r0
     6be:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     6c0:	f7 01       	movw	r30, r14
     6c2:	86 85       	ldd	r24, Z+14	; 0x0e
     6c4:	97 85       	ldd	r25, Z+15	; 0x0f
     6c6:	a0 89       	ldd	r26, Z+16	; 0x10
     6c8:	b1 89       	ldd	r27, Z+17	; 0x11
     6ca:	01 96       	adiw	r24, 0x01	; 1
     6cc:	a1 1d       	adc	r26, r1
     6ce:	b1 1d       	adc	r27, r1
     6d0:	86 87       	std	Z+14, r24	; 0x0e
     6d2:	97 87       	std	Z+15, r25	; 0x0f
     6d4:	a0 8b       	std	Z+16, r26	; 0x10
     6d6:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     6d8:	41 e0       	ldi	r20, 0x01	; 1
     6da:	50 e0       	ldi	r21, 0x00	; 0
     6dc:	60 e0       	ldi	r22, 0x00	; 0
     6de:	70 e0       	ldi	r23, 0x00	; 0
     6e0:	ce 01       	movw	r24, r28
     6e2:	01 96       	adiw	r24, 0x01	; 1
     6e4:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelayUntil>
		thdMotor.put(ticks_per_ms);
				
		angularVelocity = ((int32_t) (encoder_count-last_encoder_count)*15)/dt;	// d_ec*60/(4*1000)/dt where dt is in ms so * 1000
		//*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6e8:	68 01       	movw	r12, r16
     6ea:	9e cf       	rjmp	.-196    	; 0x628 <_ZN12EncoderMotor3runEv+0x66>

000006ec <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6f6:	0e 94 07 14 	call	0x280e	; 0x280e <_ZN8frt_taskC1EPKchjP8emstream>
     6fa:	89 e1       	ldi	r24, 0x19	; 25
     6fc:	90 e2       	ldi	r25, 0x20	; 32
     6fe:	88 83       	st	Y, r24
     700:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     702:	df 91       	pop	r29
     704:	cf 91       	pop	r28
     706:	1f 91       	pop	r17
     708:	0f 91       	pop	r16
     70a:	08 95       	ret

0000070c <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	00 d0       	rcall	.+0      	; 0x712 <_ZN15EncoderPendulum3runEv+0x6>
     712:	1f 92       	push	r1
     714:	cd b7       	in	r28, 0x3d	; 61
     716:	de b7       	in	r29, 0x3e	; 62
     718:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     71a:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <xTaskGetTickCount>
     71e:	69 83       	std	Y+1, r22	; 0x01
     720:	7a 83       	std	Y+2, r23	; 0x02
     722:	8b 83       	std	Y+3, r24	; 0x03
     724:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     726:	e0 e8       	ldi	r30, 0x80	; 128
     728:	f6 e0       	ldi	r31, 0x06	; 6
     72a:	83 e0       	ldi	r24, 0x03	; 3
     72c:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     72e:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     730:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     732:	e0 e8       	ldi	r30, 0x80	; 128
     734:	f1 e0       	ldi	r31, 0x01	; 1
     736:	80 e7       	ldi	r24, 0x70	; 112
     738:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     73a:	89 e0       	ldi	r24, 0x09	; 9
     73c:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     73e:	e0 e4       	ldi	r30, 0x40	; 64
     740:	f8 e0       	ldi	r31, 0x08	; 8
     742:	8a e6       	ldi	r24, 0x6A	; 106
     744:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     746:	80 ea       	ldi	r24, 0xA0	; 160
     748:	95 e0       	ldi	r25, 0x05	; 5
     74a:	86 a3       	std	Z+38, r24	; 0x26
     74c:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     74e:	81 e0       	ldi	r24, 0x01	; 1
     750:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     752:	68 94       	set
     754:	ee 24       	eor	r14, r14
     756:	e6 f8       	bld	r14, 6
     758:	ff 24       	eor	r15, r15
     75a:	f3 f8       	bld	r15, 3
     75c:	f7 01       	movw	r30, r14
     75e:	a0 a1       	ldd	r26, Z+32	; 0x20
     760:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     762:	0f b6       	in	r0, 0x3f	; 63
     764:	f8 94       	cli
     766:	0f 92       	push	r0
			the_data = new_data;
     768:	24 e6       	ldi	r18, 0x64	; 100
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__usmulhisi3>
     770:	4b 01       	movw	r8, r22
     772:	5c 01       	movw	r10, r24
     774:	99 23       	and	r25, r25
     776:	2c f4       	brge	.+10     	; 0x782 <_ZN15EncoderPendulum3runEv+0x76>
     778:	f3 e0       	ldi	r31, 0x03	; 3
     77a:	8f 0e       	add	r8, r31
     77c:	91 1c       	adc	r9, r1
     77e:	a1 1c       	adc	r10, r1
     780:	b1 1c       	adc	r11, r1
     782:	d5 01       	movw	r26, r10
     784:	c4 01       	movw	r24, r8
     786:	b5 95       	asr	r27
     788:	a7 95       	ror	r26
     78a:	97 95       	ror	r25
     78c:	87 95       	ror	r24
     78e:	b5 95       	asr	r27
     790:	a7 95       	ror	r26
     792:	97 95       	ror	r25
     794:	87 95       	ror	r24
     796:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <thPendulum>
     79a:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     79e:	0f 90       	pop	r0
     7a0:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     7a2:	f8 01       	movw	r30, r16
     7a4:	86 85       	ldd	r24, Z+14	; 0x0e
     7a6:	97 85       	ldd	r25, Z+15	; 0x0f
     7a8:	a0 89       	ldd	r26, Z+16	; 0x10
     7aa:	b1 89       	ldd	r27, Z+17	; 0x11
     7ac:	01 96       	adiw	r24, 0x01	; 1
     7ae:	a1 1d       	adc	r26, r1
     7b0:	b1 1d       	adc	r27, r1
     7b2:	86 87       	std	Z+14, r24	; 0x0e
     7b4:	97 87       	std	Z+15, r25	; 0x0f
     7b6:	a0 8b       	std	Z+16, r26	; 0x10
     7b8:	b1 8b       	std	Z+17, r27	; 0x11
     7ba:	45 e0       	ldi	r20, 0x05	; 5
     7bc:	50 e0       	ldi	r21, 0x00	; 0
     7be:	60 e0       	ldi	r22, 0x00	; 0
     7c0:	70 e0       	ldi	r23, 0x00	; 0
     7c2:	ce 01       	movw	r24, r28
     7c4:	01 96       	adiw	r24, 0x01	; 1
     7c6:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelayUntil>
     7ca:	c8 cf       	rjmp	.-112    	; 0x75c <_ZN15EncoderPendulum3runEv+0x50>

000007cc <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     7cc:	0f 93       	push	r16
     7ce:	1f 93       	push	r17
     7d0:	cf 93       	push	r28
     7d2:	df 93       	push	r29
     7d4:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7d6:	0e 94 07 14 	call	0x280e	; 0x280e <_ZN8frt_taskC1EPKchjP8emstream>
     7da:	81 e2       	ldi	r24, 0x21	; 33
     7dc:	90 e2       	ldi	r25, 0x20	; 32
     7de:	88 83       	st	Y, r24
     7e0:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     7e2:	df 91       	pop	r29
     7e4:	cf 91       	pop	r28
     7e6:	1f 91       	pop	r17
     7e8:	0f 91       	pop	r16
     7ea:	08 95       	ret

000007ec <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     7ec:	cf 93       	push	r28
     7ee:	df 93       	push	r29
     7f0:	00 d0       	rcall	.+0      	; 0x7f2 <_ZN13LimitSwitches3runEv+0x6>
     7f2:	1f 92       	push	r1
     7f4:	cd b7       	in	r28, 0x3d	; 61
     7f6:	de b7       	in	r29, 0x3e	; 62
     7f8:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7fa:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <xTaskGetTickCount>
     7fe:	69 83       	std	Y+1, r22	; 0x01
     800:	7a 83       	std	Y+2, r23	; 0x02
     802:	8b 83       	std	Y+3, r24	; 0x03
     804:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     806:	e0 e6       	ldi	r30, 0x60	; 96
     808:	f6 e0       	ldi	r31, 0x06	; 6
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     80e:	84 e0       	ldi	r24, 0x04	; 4
     810:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     812:	88 e1       	ldi	r24, 0x18	; 24
     814:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     816:	82 8b       	std	Z+18, r24	; 0x12
	bool rightLimit = false;
	bool leftLimit = false;
		
	while(1){
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     818:	08 e6       	ldi	r16, 0x68	; 104
     81a:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     81c:	dd 24       	eor	r13, r13
     81e:	d3 94       	inc	r13
     820:	f8 01       	movw	r30, r16
     822:	80 81       	ld	r24, Z
     824:	80 fd       	sbrc	r24, 0
     826:	08 c0       	rjmp	.+16     	; 0x838 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     828:	0f b6       	in	r0, 0x3f	; 63
     82a:	f8 94       	cli
     82c:	0f 92       	push	r0
			the_data = new_data;
     82e:	d0 92 57 31 	sts	0x3157, r13	; 0x803157 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     832:	0f 90       	pop	r0
     834:	0f be       	out	0x3f, r0	; 63
     836:	07 c0       	rjmp	.+14     	; 0x846 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     838:	0f b6       	in	r0, 0x3f	; 63
     83a:	f8 94       	cli
     83c:	0f 92       	push	r0
			the_data = new_data;
     83e:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     842:	0f 90       	pop	r0
     844:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);
			//*p_serial << "limits: " << rightLimit << leftLimit << endl;
		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     846:	f8 01       	movw	r30, r16
     848:	80 81       	ld	r24, Z
     84a:	82 fd       	sbrc	r24, 2
     84c:	08 c0       	rjmp	.+16     	; 0x85e <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     84e:	0f b6       	in	r0, 0x3f	; 63
     850:	f8 94       	cli
     852:	0f 92       	push	r0
			the_data = new_data;
     854:	d0 92 56 31 	sts	0x3156, r13	; 0x803156 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     858:	0f 90       	pop	r0
     85a:	0f be       	out	0x3f, r0	; 63
     85c:	07 c0       	rjmp	.+14     	; 0x86c <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	0f 92       	push	r0
			the_data = new_data;
     864:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     868:	0f 90       	pop	r0
     86a:	0f be       	out	0x3f, r0	; 63
		
		//*p_serial << "Left" << leftLimitSwitch.get() << "\t";
		//*p_serial << "Right" << rightLimitSwitch.get() << endl;
		
		// Increment counter for debugging
		runs++;
     86c:	f7 01       	movw	r30, r14
     86e:	86 85       	ldd	r24, Z+14	; 0x0e
     870:	97 85       	ldd	r25, Z+15	; 0x0f
     872:	a0 89       	ldd	r26, Z+16	; 0x10
     874:	b1 89       	ldd	r27, Z+17	; 0x11
     876:	01 96       	adiw	r24, 0x01	; 1
     878:	a1 1d       	adc	r26, r1
     87a:	b1 1d       	adc	r27, r1
     87c:	86 87       	std	Z+14, r24	; 0x0e
     87e:	97 87       	std	Z+15, r25	; 0x0f
     880:	a0 8b       	std	Z+16, r26	; 0x10
     882:	b1 8b       	std	Z+17, r27	; 0x11
     884:	45 e0       	ldi	r20, 0x05	; 5
     886:	50 e0       	ldi	r21, 0x00	; 0
     888:	60 e0       	ldi	r22, 0x00	; 0
     88a:	70 e0       	ldi	r23, 0x00	; 0
     88c:	ce 01       	movw	r24, r28
     88e:	01 96       	adiw	r24, 0x01	; 1
     890:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelayUntil>
     894:	c5 cf       	rjmp	.-118    	; 0x820 <_ZN13LimitSwitches3runEv+0x34>

00000896 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a0:	0e 94 07 14 	call	0x280e	; 0x280e <_ZN8frt_taskC1EPKchjP8emstream>
     8a4:	89 e2       	ldi	r24, 0x29	; 41
     8a6:	90 e2       	ldi	r25, 0x20	; 32
     8a8:	88 83       	st	Y, r24
     8aa:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN5Motor3runEv+0x6>
     8bc:	00 d0       	rcall	.+0      	; 0x8be <_ZN5Motor3runEv+0x8>
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	5c 01       	movw	r10, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <xTaskGetTickCount>
     8c8:	69 83       	std	Y+1, r22	; 0x01
     8ca:	7a 83       	std	Y+2, r23	; 0x02
     8cc:	8b 83       	std	Y+3, r24	; 0x03
     8ce:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     8d0:	81 e0       	ldi	r24, 0x01	; 1
     8d2:	90 e0       	ldi	r25, 0x00	; 0
     8d4:	f5 01       	movw	r30, r10
     8d6:	86 af       	std	Z+62, r24	; 0x3e
     8d8:	97 af       	std	Z+63, r25	; 0x3f
	inc = 1;
     8da:	84 af       	std	Z+60, r24	; 0x3c
     8dc:	95 af       	std	Z+61, r25	; 0x3d
		runs++;
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 200; // [ticks/ms]
     8de:	0f 2e       	mov	r0, r31
     8e0:	f8 ec       	ldi	r31, 0xC8	; 200
     8e2:	8f 2e       	mov	r8, r31
     8e4:	91 2c       	mov	r9, r1
     8e6:	f0 2d       	mov	r31, r0
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     8e8:	0f 2e       	mov	r0, r31
     8ea:	ff ee       	ldi	r31, 0xEF	; 239
     8ec:	2f 2e       	mov	r2, r31
     8ee:	33 24       	eor	r3, r3
     8f0:	3a 94       	dec	r3
     8f2:	f0 2d       	mov	r31, r0
		Im_set = Tset/K_T;

		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
     8f4:	0f 2e       	mov	r0, r31
     8f6:	f1 e1       	ldi	r31, 0x11	; 17
     8f8:	6f 2e       	mov	r6, r31
     8fa:	71 2c       	mov	r7, r1
     8fc:	f0 2d       	mov	r31, r0

		V_m = V_R + V_E;

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
     8fe:	0f 2e       	mov	r0, r31
     900:	f8 e1       	ldi	r31, 0x18	; 24
     902:	4f 2e       	mov	r4, r31
     904:	51 2c       	mov	r5, r1
     906:	f0 2d       	mov	r31, r0
	dt = 1; // [ms]
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     908:	f5 01       	movw	r30, r10
     90a:	86 85       	ldd	r24, Z+14	; 0x0e
     90c:	97 85       	ldd	r25, Z+15	; 0x0f
     90e:	a0 89       	ldd	r26, Z+16	; 0x10
     910:	b1 89       	ldd	r27, Z+17	; 0x11
     912:	01 96       	adiw	r24, 0x01	; 1
     914:	a1 1d       	adc	r26, r1
     916:	b1 1d       	adc	r27, r1
     918:	86 87       	std	Z+14, r24	; 0x0e
     91a:	97 87       	std	Z+15, r25	; 0x0f
     91c:	a0 8b       	std	Z+16, r26	; 0x10
     91e:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 200; // [ticks/ms]
     920:	82 8e       	std	Z+26, r8	; 0x1a
     922:	93 8e       	std	Z+27, r9	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     924:	0f b6       	in	r0, 0x3f	; 63
     926:	f8 94       	cli
     928:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     92a:	0f 90       	pop	r0
     92c:	0f be       	out	0x3f, r0	; 63

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     92e:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <thdMotor>
     932:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <thdMotor+0x1>
     936:	86 8f       	std	Z+30, r24	; 0x1e
     938:	97 8f       	std	Z+31, r25	; 0x1f
		//*p_serial << "Measured: " << omegam_measured << endl;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(1, 1600, -1600, 20, 0, 0); // PID output
     93a:	c1 2c       	mov	r12, r1
     93c:	d1 2c       	mov	r13, r1
     93e:	e1 2c       	mov	r14, r1
     940:	f1 2c       	mov	r15, r1
     942:	04 e1       	ldi	r16, 0x14	; 20
     944:	10 e0       	ldi	r17, 0x00	; 0
     946:	20 ec       	ldi	r18, 0xC0	; 192
     948:	39 ef       	ldi	r19, 0xF9	; 249
     94a:	40 e4       	ldi	r20, 0x40	; 64
     94c:	56 e0       	ldi	r21, 0x06	; 6
     94e:	61 e0       	ldi	r22, 0x01	; 1
     950:	70 e0       	ldi	r23, 0x00	; 0
     952:	ce 01       	movw	r24, r28
     954:	05 96       	adiw	r24, 0x05	; 5
     956:	0e 94 25 05 	call	0xa4a	; 0xa4a <_ZN3PIDC1Eiiiiii>
		int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
     95a:	f5 01       	movw	r30, r10
     95c:	46 8d       	ldd	r20, Z+30	; 0x1e
     95e:	57 8d       	ldd	r21, Z+31	; 0x1f
     960:	62 8d       	ldd	r22, Z+26	; 0x1a
     962:	73 8d       	ldd	r23, Z+27	; 0x1b
     964:	ce 01       	movw	r24, r28
     966:	05 96       	adiw	r24, 0x05	; 5
     968:	0e 94 b7 05 	call	0xb6e	; 0xb6e <_ZN3PID9calculateEii>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     96c:	0f b6       	in	r0, 0x3f	; 63
     96e:	f8 94       	cli
     970:	0f 92       	push	r0
			the_data = new_data;
     972:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <PWMvalue>
     976:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     97a:	0f 90       	pop	r0
     97c:	0f be       	out	0x3f, r0	; 63
		PWMvalue.put(Tset);
		
		//*p_serial << "CONTROLLER OUTPUT: " << Tset << endl;
		//*p_serial << omegam_measured << endl;
		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     97e:	f5 01       	movw	r30, r10
     980:	10 a6       	std	Z+40, r1	; 0x28
     982:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     984:	60 e0       	ldi	r22, 0x00	; 0
     986:	70 e0       	ldi	r23, 0x00	; 0
     988:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <__divmodhi4>
     98c:	8b 01       	movw	r16, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     98e:	07 2e       	mov	r0, r23
     990:	00 0c       	add	r0, r0
     992:	88 0b       	sbc	r24, r24
     994:	99 0b       	sbc	r25, r25
     996:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <__floatsisf>
     99a:	6b 01       	movw	r12, r22
     99c:	7c 01       	movw	r14, r24
     99e:	23 e3       	ldi	r18, 0x33	; 51
     9a0:	33 e3       	ldi	r19, 0x33	; 51
     9a2:	4b e8       	ldi	r20, 0x8B	; 139
     9a4:	51 e4       	ldi	r21, 0x41	; 65
     9a6:	0e 94 b9 1e 	call	0x3d72	; 0x3d72 <__gesf2>
     9aa:	18 16       	cp	r1, r24
     9ac:	24 f4       	brge	.+8      	; 0x9b6 <_ZN5Motor3runEv+0x100>
			Im_set = 17.4;
     9ae:	f5 01       	movw	r30, r10
     9b0:	64 a2       	std	Z+36, r6	; 0x24
     9b2:	75 a2       	std	Z+37, r7	; 0x25
     9b4:	11 c0       	rjmp	.+34     	; 0x9d8 <_ZN5Motor3runEv+0x122>
		} else if(Im_set < -17.4) {
     9b6:	23 e3       	ldi	r18, 0x33	; 51
     9b8:	33 e3       	ldi	r19, 0x33	; 51
     9ba:	4b e8       	ldi	r20, 0x8B	; 139
     9bc:	51 ec       	ldi	r21, 0xC1	; 193
     9be:	c7 01       	movw	r24, r14
     9c0:	b6 01       	movw	r22, r12
     9c2:	0e 94 53 1e 	call	0x3ca6	; 0x3ca6 <__cmpsf2>
     9c6:	88 23       	and	r24, r24
     9c8:	24 f0       	brlt	.+8      	; 0x9d2 <_ZN5Motor3runEv+0x11c>
		
		//*p_serial << "CONTROLLER OUTPUT: " << Tset << endl;
		//*p_serial << omegam_measured << endl;
		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     9ca:	f5 01       	movw	r30, r10
     9cc:	04 a3       	std	Z+36, r16	; 0x24
     9ce:	15 a3       	std	Z+37, r17	; 0x25
     9d0:	03 c0       	rjmp	.+6      	; 0x9d8 <_ZN5Motor3runEv+0x122>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     9d2:	f5 01       	movw	r30, r10
     9d4:	24 a2       	std	Z+36, r2	; 0x24
     9d6:	35 a2       	std	Z+37, r3	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     9d8:	f5 01       	movw	r30, r10
     9da:	16 aa       	std	Z+54, r1	; 0x36
     9dc:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     9de:	12 aa       	std	Z+50, r1	; 0x32
     9e0:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     9e2:	14 aa       	std	Z+52, r1	; 0x34
     9e4:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
     9e6:	80 a9       	ldd	r24, Z+48	; 0x30
     9e8:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
     9ea:	89 31       	cpi	r24, 0x19	; 25
     9ec:	91 05       	cpc	r25, r1
     9ee:	1c f0       	brlt	.+6      	; 0x9f6 <_ZN5Motor3runEv+0x140>
			V_m = 24;
     9f0:	40 ae       	std	Z+56, r4	; 0x38
     9f2:	51 ae       	std	Z+57, r5	; 0x39
     9f4:	0d c0       	rjmp	.+26     	; 0xa10 <_ZN5Motor3runEv+0x15a>
		} else if(V_m < -24) {
     9f6:	88 3e       	cpi	r24, 0xE8	; 232
     9f8:	ff ef       	ldi	r31, 0xFF	; 255
     9fa:	9f 07       	cpc	r25, r31
     9fc:	24 f0       	brlt	.+8      	; 0xa06 <_ZN5Motor3runEv+0x150>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     9fe:	f5 01       	movw	r30, r10
     a00:	80 af       	std	Z+56, r24	; 0x38
     a02:	91 af       	std	Z+57, r25	; 0x39
     a04:	05 c0       	rjmp	.+10     	; 0xa10 <_ZN5Motor3runEv+0x15a>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     a06:	88 ee       	ldi	r24, 0xE8	; 232
     a08:	9f ef       	ldi	r25, 0xFF	; 255
     a0a:	f5 01       	movw	r30, r10
     a0c:	80 af       	std	Z+56, r24	; 0x38
     a0e:	91 af       	std	Z+57, r25	; 0x39
     a10:	45 e0       	ldi	r20, 0x05	; 5
     a12:	50 e0       	ldi	r21, 0x00	; 0
     a14:	60 e0       	ldi	r22, 0x00	; 0
     a16:	70 e0       	ldi	r23, 0x00	; 0
     a18:	ce 01       	movw	r24, r28
     a1a:	01 96       	adiw	r24, 0x01	; 1
     a1c:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelayUntil>
		omegam_measured = thdMotor.get();
		//*p_serial << "Measured: " << omegam_measured << endl;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(1, 1600, -1600, 20, 0, 0); // PID output
     a20:	ce 01       	movw	r24, r28
     a22:	05 96       	adiw	r24, 0x05	; 5
     a24:	0e 94 5d 05 	call	0xaba	; 0xaba <_ZN3PIDD1Ev>
	portTickType previousTicks = xTaskGetTickCount ();

	dt = 1; // [ms]
	inc = 1;
	
	while(1){
     a28:	6f cf       	rjmp	.-290    	; 0x908 <_ZN5Motor3runEv+0x52>

00000a2a <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     a2a:	0f 93       	push	r16
     a2c:	1f 93       	push	r17
     a2e:	cf 93       	push	r28
     a30:	df 93       	push	r29
     a32:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a34:	0e 94 07 14 	call	0x280e	; 0x280e <_ZN8frt_taskC1EPKchjP8emstream>
     a38:	81 e3       	ldi	r24, 0x31	; 49
     a3a:	90 e2       	ldi	r25, 0x20	; 32
     a3c:	88 83       	st	Y, r24
     a3e:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     a40:	df 91       	pop	r29
     a42:	cf 91       	pop	r28
     a44:	1f 91       	pop	r17
     a46:	0f 91       	pop	r16
     a48:	08 95       	ret

00000a4a <_ZN3PIDC1Eiiiiii>:
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}
     a4a:	6f 92       	push	r6
     a4c:	7f 92       	push	r7
     a4e:	8f 92       	push	r8
     a50:	9f 92       	push	r9
     a52:	af 92       	push	r10
     a54:	bf 92       	push	r11
     a56:	cf 92       	push	r12
     a58:	df 92       	push	r13
     a5a:	ef 92       	push	r14
     a5c:	ff 92       	push	r15
     a5e:	0f 93       	push	r16
     a60:	1f 93       	push	r17
     a62:	cf 93       	push	r28
     a64:	df 93       	push	r29
     a66:	ec 01       	movw	r28, r24
     a68:	4b 01       	movw	r8, r22
     a6a:	5a 01       	movw	r10, r20
     a6c:	39 01       	movw	r6, r18
     a6e:	80 e1       	ldi	r24, 0x10	; 16
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	0e 94 81 18 	call	0x3102	; 0x3102 <_Znwj>
     a76:	fc 01       	movw	r30, r24
     a78:	80 82       	st	Z, r8
     a7a:	91 82       	std	Z+1, r9	; 0x01
     a7c:	a2 82       	std	Z+2, r10	; 0x02
     a7e:	b3 82       	std	Z+3, r11	; 0x03
     a80:	64 82       	std	Z+4, r6	; 0x04
     a82:	75 82       	std	Z+5, r7	; 0x05
     a84:	06 83       	std	Z+6, r16	; 0x06
     a86:	17 83       	std	Z+7, r17	; 0x07
     a88:	e0 86       	std	Z+8, r14	; 0x08
     a8a:	f1 86       	std	Z+9, r15	; 0x09
     a8c:	c2 86       	std	Z+10, r12	; 0x0a
     a8e:	d3 86       	std	Z+11, r13	; 0x0b
     a90:	14 86       	std	Z+12, r1	; 0x0c
     a92:	15 86       	std	Z+13, r1	; 0x0d
     a94:	16 86       	std	Z+14, r1	; 0x0e
     a96:	17 86       	std	Z+15, r1	; 0x0f
     a98:	88 83       	st	Y, r24
     a9a:	99 83       	std	Y+1, r25	; 0x01
     a9c:	df 91       	pop	r29
     a9e:	cf 91       	pop	r28
     aa0:	1f 91       	pop	r17
     aa2:	0f 91       	pop	r16
     aa4:	ff 90       	pop	r15
     aa6:	ef 90       	pop	r14
     aa8:	df 90       	pop	r13
     aaa:	cf 90       	pop	r12
     aac:	bf 90       	pop	r11
     aae:	af 90       	pop	r10
     ab0:	9f 90       	pop	r9
     ab2:	8f 90       	pop	r8
     ab4:	7f 90       	pop	r7
     ab6:	6f 90       	pop	r6
     ab8:	08 95       	ret

00000aba <_ZN3PIDD1Ev>:
     aba:	fc 01       	movw	r30, r24
     abc:	80 81       	ld	r24, Z
     abe:	91 81       	ldd	r25, Z+1	; 0x01
     ac0:	00 97       	sbiw	r24, 0x00	; 0
     ac2:	11 f0       	breq	.+4      	; 0xac8 <_ZN3PIDD1Ev+0xe>
     ac4:	0e 94 84 18 	call	0x3108	; 0x3108 <_ZdlPv>
     ac8:	08 95       	ret

00000aca <_ZN7PIDImpl9calculateEii>:

int16_t PIDImpl::calculate( int16_t setpoint, int16_t pv )
{
     aca:	0f 93       	push	r16
     acc:	1f 93       	push	r17
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
     ad2:	fc 01       	movw	r30, r24
    
    // Calculate error
    int16_t error = setpoint - pv;
     ad4:	9b 01       	movw	r18, r22
     ad6:	24 1b       	sub	r18, r20
     ad8:	35 0b       	sbc	r19, r21

    // Proportional term
    int16_t Pout = _Kp * error;
     ada:	86 81       	ldd	r24, Z+6	; 0x06
     adc:	97 81       	ldd	r25, Z+7	; 0x07
     ade:	28 9f       	mul	r18, r24
     ae0:	e0 01       	movw	r28, r0
     ae2:	29 9f       	mul	r18, r25
     ae4:	d0 0d       	add	r29, r0
     ae6:	38 9f       	mul	r19, r24
     ae8:	d0 0d       	add	r29, r0
     aea:	11 24       	eor	r1, r1

    // Integral term
    _integral += error * _dt;
     aec:	60 81       	ld	r22, Z
     aee:	71 81       	ldd	r23, Z+1	; 0x01
     af0:	26 9f       	mul	r18, r22
     af2:	80 01       	movw	r16, r0
     af4:	27 9f       	mul	r18, r23
     af6:	10 0d       	add	r17, r0
     af8:	36 9f       	mul	r19, r22
     afa:	10 0d       	add	r17, r0
     afc:	11 24       	eor	r1, r1
     afe:	86 85       	ldd	r24, Z+14	; 0x0e
     b00:	97 85       	ldd	r25, Z+15	; 0x0f
     b02:	08 0f       	add	r16, r24
     b04:	19 1f       	adc	r17, r25
     b06:	06 87       	std	Z+14, r16	; 0x0e
     b08:	17 87       	std	Z+15, r17	; 0x0f
    // Derivative term
    int16_t derivative = (error - _pre_error) / _dt;
    int16_t Dout = _Kd * derivative;

    // Calculate total output
    int16_t output = Pout + Iout + Dout;
     b0a:	84 85       	ldd	r24, Z+12	; 0x0c
     b0c:	95 85       	ldd	r25, Z+13	; 0x0d
     b0e:	a9 01       	movw	r20, r18
     b10:	48 1b       	sub	r20, r24
     b12:	59 0b       	sbc	r21, r25
     b14:	ca 01       	movw	r24, r20
     b16:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <__divmodhi4>
     b1a:	40 85       	ldd	r20, Z+8	; 0x08
     b1c:	51 85       	ldd	r21, Z+9	; 0x09
     b1e:	64 9f       	mul	r22, r20
     b20:	c0 01       	movw	r24, r0
     b22:	65 9f       	mul	r22, r21
     b24:	90 0d       	add	r25, r0
     b26:	74 9f       	mul	r23, r20
     b28:	90 0d       	add	r25, r0
     b2a:	11 24       	eor	r1, r1
     b2c:	62 85       	ldd	r22, Z+10	; 0x0a
     b2e:	73 85       	ldd	r23, Z+11	; 0x0b
     b30:	06 9f       	mul	r16, r22
     b32:	a0 01       	movw	r20, r0
     b34:	07 9f       	mul	r16, r23
     b36:	50 0d       	add	r21, r0
     b38:	16 9f       	mul	r17, r22
     b3a:	50 0d       	add	r21, r0
     b3c:	11 24       	eor	r1, r1
     b3e:	c4 0f       	add	r28, r20
     b40:	d5 1f       	adc	r29, r21
     b42:	ac 01       	movw	r20, r24
     b44:	4c 0f       	add	r20, r28
     b46:	5d 1f       	adc	r21, r29

    // Restrict to max/min
    if( output > _max )
     b48:	82 81       	ldd	r24, Z+2	; 0x02
     b4a:	93 81       	ldd	r25, Z+3	; 0x03
     b4c:	84 17       	cp	r24, r20
     b4e:	95 07       	cpc	r25, r21
     b50:	3c f0       	brlt	.+14     	; 0xb60 <_ZN7PIDImpl9calculateEii+0x96>
        output = _max;
    else if( output < _min )
     b52:	64 81       	ldd	r22, Z+4	; 0x04
     b54:	75 81       	ldd	r23, Z+5	; 0x05
     b56:	ca 01       	movw	r24, r20
     b58:	46 17       	cp	r20, r22
     b5a:	57 07       	cpc	r21, r23
     b5c:	0c f4       	brge	.+2      	; 0xb60 <_ZN7PIDImpl9calculateEii+0x96>
     b5e:	cb 01       	movw	r24, r22
        output = _min;

    // Save error to previous error
    _pre_error = error;
     b60:	24 87       	std	Z+12, r18	; 0x0c
     b62:	35 87       	std	Z+13, r19	; 0x0d

    return output;
}
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	1f 91       	pop	r17
     b6a:	0f 91       	pop	r16
     b6c:	08 95       	ret

00000b6e <_ZN3PID9calculateEii>:
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
int16_t PID::calculate( int16_t setpoint, int16_t pv )
{
    return pimpl->calculate(setpoint,pv);
     b6e:	fc 01       	movw	r30, r24
     b70:	80 81       	ld	r24, Z
     b72:	91 81       	ldd	r25, Z+1	; 0x01
     b74:	0e 94 65 05 	call	0xaca	; 0xaca <_ZN7PIDImpl9calculateEii>
}
     b78:	08 95       	ret

00000b7a <_ZN9PWMdriver3runEv>:
		// Nothing to do in this constructor other than call the parent constructor
	}



void PWMdriver::run(void){
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	00 d0       	rcall	.+0      	; 0xb80 <_ZN9PWMdriver3runEv+0x6>
     b80:	1f 92       	push	r1
     b82:	cd b7       	in	r28, 0x3d	; 61
     b84:	de b7       	in	r29, 0x3e	; 62
     b86:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     b88:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <xTaskGetTickCount>
     b8c:	69 83       	std	Y+1, r22	; 0x01
     b8e:	7a 83       	std	Y+2, r23	; 0x02
     b90:	8b 83       	std	Y+3, r24	; 0x03
     b92:	9c 83       	std	Y+4, r25	; 0x04
	//PC0 - MD0
	//PC1 - MD1
	
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     b94:	a0 e4       	ldi	r26, 0x40	; 64
     b96:	b6 e0       	ldi	r27, 0x06	; 6
     b98:	87 e0       	ldi	r24, 0x07	; 7
     b9a:	11 96       	adiw	r26, 0x01	; 1
     b9c:	8c 93       	st	X, r24
     b9e:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     ba0:	84 e0       	ldi	r24, 0x04	; 4
     ba2:	15 96       	adiw	r26, 0x05	; 5
     ba4:	8c 93       	st	X, r24
     ba6:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     ba8:	e0 e0       	ldi	r30, 0x00	; 0
     baa:	f8 e0       	ldi	r31, 0x08	; 8
     bac:	81 e0       	ldi	r24, 0x01	; 1
     bae:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     bb0:	83 e0       	ldi	r24, 0x03	; 3
     bb2:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     bb4:	a6 a3       	std	Z+38, r26	; 0x26
     bb6:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     bb8:	10 a6       	std	Z+40, r1	; 0x28
     bba:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     bbc:	12 a6       	std	Z+42, r1	; 0x2a
     bbe:	13 a6       	std	Z+43, r1	; 0x2b
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     bc0:	81 81       	ldd	r24, Z+1	; 0x01
     bc2:	80 63       	ori	r24, 0x30	; 48
     bc4:	81 83       	std	Z+1, r24	; 0x01
			//*p_serial << PWMvalue.get() << endl;
			TCC0.CCB = 0;
		}
		else if (leftLimitSwitch.get() || rightLimitSwitch.get())
		{
			TCC0.CCA = 0;
     bc6:	e1 2c       	mov	r14, r1
     bc8:	68 94       	set
     bca:	ff 24       	eor	r15, r15
     bcc:	f3 f8       	bld	r15, 3
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
	
	while(1){
		// Increment counter for debugging
		runs++;
     bce:	f8 01       	movw	r30, r16
     bd0:	86 85       	ldd	r24, Z+14	; 0x0e
     bd2:	97 85       	ldd	r25, Z+15	; 0x0f
     bd4:	a0 89       	ldd	r26, Z+16	; 0x10
     bd6:	b1 89       	ldd	r27, Z+17	; 0x11
     bd8:	01 96       	adiw	r24, 0x01	; 1
     bda:	a1 1d       	adc	r26, r1
     bdc:	b1 1d       	adc	r27, r1
     bde:	86 87       	std	Z+14, r24	; 0x0e
     be0:	97 87       	std	Z+15, r25	; 0x0f
     be2:	a0 8b       	std	Z+16, r26	; 0x10
     be4:	b1 8b       	std	Z+17, r27	; 0x11
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     be6:	0f b6       	in	r0, 0x3f	; 63
     be8:	f8 94       	cli
     bea:	0f 92       	push	r0
			temporary_copy = the_data;
     bec:	80 91 57 31 	lds	r24, 0x3157	; 0x803157 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     bf0:	0f 90       	pop	r0
     bf2:	0f be       	out	0x3f, r0	; 63
		
		if (!leftLimitSwitch.get() && !rightLimitSwitch.get())
     bf4:	81 11       	cpse	r24, r1
     bf6:	18 c0       	rjmp	.+48     	; 0xc28 <_ZN9PWMdriver3runEv+0xae>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bfe:	0f 90       	pop	r0
     c00:	0f be       	out	0x3f, r0	; 63
     c02:	90 91 56 31 	lds	r25, 0x3156	; 0x803156 <rightLimitSwitch>
     c06:	91 11       	cpse	r25, r1
     c08:	0f c0       	rjmp	.+30     	; 0xc28 <_ZN9PWMdriver3runEv+0xae>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c0a:	0f b6       	in	r0, 0x3f	; 63
     c0c:	f8 94       	cli
     c0e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c10:	0f 90       	pop	r0
     c12:	0f be       	out	0x3f, r0	; 63
		{
			TCC0.CCA = PWMvalue.get();
     c14:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <PWMvalue>
     c18:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <PWMvalue+0x1>
     c1c:	f7 01       	movw	r30, r14
     c1e:	80 a7       	std	Z+40, r24	; 0x28
     c20:	91 a7       	std	Z+41, r25	; 0x29
			//*p_serial << PWMvalue.get() << endl;
			TCC0.CCB = 0;
     c22:	12 a6       	std	Z+42, r1	; 0x2a
     c24:	13 a6       	std	Z+43, r1	; 0x2b
     c26:	15 c0       	rjmp	.+42     	; 0xc52 <_ZN9PWMdriver3runEv+0xd8>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c28:	0f b6       	in	r0, 0x3f	; 63
     c2a:	f8 94       	cli
     c2c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c2e:	0f 90       	pop	r0
     c30:	0f be       	out	0x3f, r0	; 63
		}
		else if (leftLimitSwitch.get() || rightLimitSwitch.get())
     c32:	81 11       	cpse	r24, r1
     c34:	09 c0       	rjmp	.+18     	; 0xc48 <_ZN9PWMdriver3runEv+0xce>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c36:	0f b6       	in	r0, 0x3f	; 63
     c38:	f8 94       	cli
     c3a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c3c:	0f 90       	pop	r0
     c3e:	0f be       	out	0x3f, r0	; 63
     c40:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rightLimitSwitch>
     c44:	88 23       	and	r24, r24
     c46:	29 f0       	breq	.+10     	; 0xc52 <_ZN9PWMdriver3runEv+0xd8>
		{
			TCC0.CCA = 0;
     c48:	f7 01       	movw	r30, r14
     c4a:	10 a6       	std	Z+40, r1	; 0x28
     c4c:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = 0;
     c4e:	12 a6       	std	Z+42, r1	; 0x2a
     c50:	13 a6       	std	Z+43, r1	; 0x2b
     c52:	44 e1       	ldi	r20, 0x14	; 20
     c54:	50 e0       	ldi	r21, 0x00	; 0
     c56:	60 e0       	ldi	r22, 0x00	; 0
     c58:	70 e0       	ldi	r23, 0x00	; 0
     c5a:	ce 01       	movw	r24, r28
     c5c:	01 96       	adiw	r24, 0x01	; 1
     c5e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelayUntil>
     c62:	b5 cf       	rjmp	.-150    	; 0xbce <_ZN9PWMdriver3runEv+0x54>

00000c64 <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

PWMdriver::PWMdriver(const char* a_name,
     c64:	0f 93       	push	r16
     c66:	1f 93       	push	r17
     c68:	cf 93       	push	r28
     c6a:	df 93       	push	r29
     c6c:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     c6e:	0e 94 07 14 	call	0x280e	; 0x280e <_ZN8frt_taskC1EPKchjP8emstream>
     c72:	89 e3       	ldi	r24, 0x39	; 57
     c74:	90 e2       	ldi	r25, 0x20	; 32
     c76:	88 83       	st	Y, r24
     c78:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     c7a:	df 91       	pop	r29
     c7c:	cf 91       	pop	r28
     c7e:	1f 91       	pop	r17
     c80:	0f 91       	pop	r16
     c82:	08 95       	ret

00000c84 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     c84:	0f 93       	push	r16
     c86:	1f 93       	push	r17
     c88:	cf 93       	push	r28
     c8a:	df 93       	push	r29
     c8c:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     c8e:	0e 94 07 14 	call	0x280e	; 0x280e <_ZN8frt_taskC1EPKchjP8emstream>
     c92:	81 e4       	ldi	r24, 0x41	; 65
     c94:	90 e2       	ldi	r25, 0x20	; 32
     c96:	88 83       	st	Y, r24
     c98:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     c9a:	df 91       	pop	r29
     c9c:	cf 91       	pop	r28
     c9e:	1f 91       	pop	r17
     ca0:	0f 91       	pop	r16
     ca2:	08 95       	ret

00000ca4 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     ca4:	0f 93       	push	r16
     ca6:	1f 93       	push	r17
     ca8:	cf 93       	push	r28
     caa:	df 93       	push	r29
     cac:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     cae:	6a e0       	ldi	r22, 0x0A	; 10
     cb0:	8e 81       	ldd	r24, Y+6	; 0x06
     cb2:	9f 81       	ldd	r25, Y+7	; 0x07
     cb4:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     cb8:	8c 01       	movw	r16, r24
     cba:	6d ee       	ldi	r22, 0xED	; 237
     cbc:	73 e0       	ldi	r23, 0x03	; 3
     cbe:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     cc2:	6a e0       	ldi	r22, 0x0A	; 10
     cc4:	c8 01       	movw	r24, r16
     cc6:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     cca:	8c 01       	movw	r16, r24
     ccc:	67 ee       	ldi	r22, 0xE7	; 231
     cce:	73 e0       	ldi	r23, 0x03	; 3
     cd0:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     cd4:	67 e0       	ldi	r22, 0x07	; 7
     cd6:	c8 01       	movw	r24, r16
     cd8:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     cdc:	6a e0       	ldi	r22, 0x0A	; 10
     cde:	8e 81       	ldd	r24, Y+6	; 0x06
     ce0:	9f 81       	ldd	r25, Y+7	; 0x07
     ce2:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     ce6:	8c 01       	movw	r16, r24
     ce8:	68 ec       	ldi	r22, 0xC8	; 200
     cea:	73 e0       	ldi	r23, 0x03	; 3
     cec:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     cf0:	6a e0       	ldi	r22, 0x0A	; 10
     cf2:	c8 01       	movw	r24, r16
     cf4:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     cf8:	8c 01       	movw	r16, r24
     cfa:	62 ec       	ldi	r22, 0xC2	; 194
     cfc:	73 e0       	ldi	r23, 0x03	; 3
     cfe:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     d02:	66 e0       	ldi	r22, 0x06	; 6
     d04:	c8 01       	movw	r24, r16
     d06:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     d0a:	6a e0       	ldi	r22, 0x0A	; 10
     d0c:	8e 81       	ldd	r24, Y+6	; 0x06
     d0e:	9f 81       	ldd	r25, Y+7	; 0x07
     d10:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     d14:	8c 01       	movw	r16, r24
     d16:	6b ea       	ldi	r22, 0xAB	; 171
     d18:	73 e0       	ldi	r23, 0x03	; 3
     d1a:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     d1e:	66 e0       	ldi	r22, 0x06	; 6
     d20:	c8 01       	movw	r24, r16
     d22:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     d26:	6a e0       	ldi	r22, 0x0A	; 10
     d28:	8e 81       	ldd	r24, Y+6	; 0x06
     d2a:	9f 81       	ldd	r25, Y+7	; 0x07
     d2c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     d30:	8c 01       	movw	r16, r24
     d32:	6f e8       	ldi	r22, 0x8F	; 143
     d34:	73 e0       	ldi	r23, 0x03	; 3
     d36:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     d3a:	66 e0       	ldi	r22, 0x06	; 6
     d3c:	c8 01       	movw	r24, r16
     d3e:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     d42:	6a e0       	ldi	r22, 0x0A	; 10
     d44:	8e 81       	ldd	r24, Y+6	; 0x06
     d46:	9f 81       	ldd	r25, Y+7	; 0x07
     d48:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     d4c:	8c 01       	movw	r16, r24
     d4e:	67 e7       	ldi	r22, 0x77	; 119
     d50:	73 e0       	ldi	r23, 0x03	; 3
     d52:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     d56:	66 e0       	ldi	r22, 0x06	; 6
     d58:	c8 01       	movw	r24, r16
     d5a:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     d5e:	6a e0       	ldi	r22, 0x0A	; 10
     d60:	8e 81       	ldd	r24, Y+6	; 0x06
     d62:	9f 81       	ldd	r25, Y+7	; 0x07
     d64:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     d68:	8c 01       	movw	r16, r24
     d6a:	66 e5       	ldi	r22, 0x56	; 86
     d6c:	73 e0       	ldi	r23, 0x03	; 3
     d6e:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     d72:	66 e0       	ldi	r22, 0x06	; 6
     d74:	c8 01       	movw	r24, r16
     d76:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     d7a:	6a e0       	ldi	r22, 0x0A	; 10
     d7c:	8e 81       	ldd	r24, Y+6	; 0x06
     d7e:	9f 81       	ldd	r25, Y+7	; 0x07
     d80:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     d84:	8c 01       	movw	r16, r24
     d86:	6f e2       	ldi	r22, 0x2F	; 47
     d88:	73 e0       	ldi	r23, 0x03	; 3
     d8a:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     d8e:	66 e0       	ldi	r22, 0x06	; 6
     d90:	c8 01       	movw	r24, r16
     d92:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     d96:	6a e0       	ldi	r22, 0x0A	; 10
     d98:	8e 81       	ldd	r24, Y+6	; 0x06
     d9a:	9f 81       	ldd	r25, Y+7	; 0x07
     d9c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     da0:	8c 01       	movw	r16, r24
     da2:	61 e1       	ldi	r22, 0x11	; 17
     da4:	73 e0       	ldi	r23, 0x03	; 3
     da6:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     daa:	66 e0       	ldi	r22, 0x06	; 6
     dac:	c8 01       	movw	r24, r16
     dae:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     db2:	6a e0       	ldi	r22, 0x0A	; 10
     db4:	8e 81       	ldd	r24, Y+6	; 0x06
     db6:	9f 81       	ldd	r25, Y+7	; 0x07
     db8:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     dbc:	8c 01       	movw	r16, r24
     dbe:	66 ef       	ldi	r22, 0xF6	; 246
     dc0:	72 e0       	ldi	r23, 0x02	; 2
     dc2:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     dc6:	66 e0       	ldi	r22, 0x06	; 6
     dc8:	c8 01       	movw	r24, r16
     dca:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     dce:	6a e0       	ldi	r22, 0x0A	; 10
     dd0:	8e 81       	ldd	r24, Y+6	; 0x06
     dd2:	9f 81       	ldd	r25, Y+7	; 0x07
     dd4:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     dd8:	ec 01       	movw	r28, r24
     dda:	67 ee       	ldi	r22, 0xE7	; 231
     ddc:	72 e0       	ldi	r23, 0x02	; 2
     dde:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     de2:	66 e0       	ldi	r22, 0x06	; 6
     de4:	ce 01       	movw	r24, r28
     de6:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
}
     dea:	df 91       	pop	r29
     dec:	cf 91       	pop	r28
     dee:	1f 91       	pop	r17
     df0:	0f 91       	pop	r16
     df2:	08 95       	ret

00000df4 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     df4:	af 92       	push	r10
     df6:	bf 92       	push	r11
     df8:	cf 92       	push	r12
     dfa:	df 92       	push	r13
     dfc:	ef 92       	push	r14
     dfe:	ff 92       	push	r15
     e00:	0f 93       	push	r16
     e02:	1f 93       	push	r17
     e04:	cf 93       	push	r28
     e06:	df 93       	push	r29
     e08:	00 d0       	rcall	.+0      	; 0xe0a <_ZN9task_user11show_statusEv+0x16>
     e0a:	00 d0       	rcall	.+0      	; 0xe0c <_ZN9task_user11show_statusEv+0x18>
     e0c:	cd b7       	in	r28, 0x3d	; 61
     e0e:	de b7       	in	r29, 0x3e	; 62
     e10:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     e12:	19 82       	std	Y+1, r1	; 0x01
     e14:	1a 82       	std	Y+2, r1	; 0x02
     e16:	1b 82       	std	Y+3, r1	; 0x03
     e18:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     e1a:	1d 82       	std	Y+5, r1	; 0x05
     e1c:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     e1e:	0e 94 7f 09 	call	0x12fe	; 0x12fe <xPortGetFreeHeapSize>
     e22:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     e24:	ce 01       	movw	r24, r28
     e26:	01 96       	adiw	r24, 0x01	; 1
     e28:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <_ZN10time_stamp10set_to_nowEv>
     e2c:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     e2e:	66 e0       	ldi	r22, 0x06	; 6
     e30:	f8 01       	movw	r30, r16
     e32:	86 81       	ldd	r24, Z+6	; 0x06
     e34:	97 81       	ldd	r25, Z+7	; 0x07
     e36:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     e3a:	6a e0       	ldi	r22, 0x0A	; 10
     e3c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     e40:	7c 01       	movw	r14, r24
     e42:	68 ec       	ldi	r22, 0xC8	; 200
     e44:	72 e0       	ldi	r23, 0x02	; 2
     e46:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     e4a:	6a e0       	ldi	r22, 0x0A	; 10
     e4c:	c7 01       	movw	r24, r14
     e4e:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     e52:	7c 01       	movw	r14, r24
     e54:	6c eb       	ldi	r22, 0xBC	; 188
     e56:	72 e0       	ldi	r23, 0x02	; 2
     e58:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     e5c:	66 e0       	ldi	r22, 0x06	; 6
     e5e:	c7 01       	movw	r24, r14
     e60:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     e64:	6a e0       	ldi	r22, 0x0A	; 10
     e66:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     e6a:	7c 01       	movw	r14, r24
     e6c:	65 eb       	ldi	r22, 0xB5	; 181
     e6e:	72 e0       	ldi	r23, 0x02	; 2
     e70:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     e74:	b5 01       	movw	r22, r10
     e76:	c7 01       	movw	r24, r14
     e78:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     e7c:	6a e0       	ldi	r22, 0x0A	; 10
     e7e:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     e82:	7c 01       	movw	r14, r24
     e84:	67 ea       	ldi	r22, 0xA7	; 167
     e86:	72 e0       	ldi	r23, 0x02	; 2
     e88:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     e8c:	b6 01       	movw	r22, r12
     e8e:	c7 01       	movw	r24, r14
     e90:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <_ZN8emstreamlsEj>
     e94:	6a e0       	ldi	r22, 0x0A	; 10
     e96:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     e9a:	7c 01       	movw	r14, r24
     e9c:	65 ea       	ldi	r22, 0xA5	; 165
     e9e:	72 e0       	ldi	r23, 0x02	; 2
     ea0:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     ea4:	4f ef       	ldi	r20, 0xFF	; 255
     ea6:	5f e0       	ldi	r21, 0x0F	; 15
     ea8:	60 e0       	ldi	r22, 0x00	; 0
     eaa:	70 e0       	ldi	r23, 0x00	; 0
     eac:	c7 01       	movw	r24, r14
     eae:	0e 94 15 1a 	call	0x342a	; 0x342a <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     eb2:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     eb6:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     eba:	6a e0       	ldi	r22, 0x0A	; 10
     ebc:	f8 01       	movw	r30, r16
     ebe:	86 81       	ldd	r24, Z+6	; 0x06
     ec0:	97 81       	ldd	r25, Z+7	; 0x07
     ec2:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     ec6:	7c 01       	movw	r14, r24
     ec8:	6a e9       	ldi	r22, 0x9A	; 154
     eca:	72 e0       	ldi	r23, 0x02	; 2
     ecc:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     ed0:	b6 01       	movw	r22, r12
     ed2:	c7 01       	movw	r24, r14
     ed4:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <_ZN8emstreamlsEj>
     ed8:	66 e0       	ldi	r22, 0x06	; 6
     eda:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     ede:	66 e0       	ldi	r22, 0x06	; 6
     ee0:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     ee4:	f8 01       	movw	r30, r16
     ee6:	86 81       	ldd	r24, Z+6	; 0x06
     ee8:	97 81       	ldd	r25, Z+7	; 0x07
     eea:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_Z15print_task_listP8emstream>
}
     eee:	26 96       	adiw	r28, 0x06	; 6
     ef0:	cd bf       	out	0x3d, r28	; 61
     ef2:	de bf       	out	0x3e, r29	; 62
     ef4:	df 91       	pop	r29
     ef6:	cf 91       	pop	r28
     ef8:	1f 91       	pop	r17
     efa:	0f 91       	pop	r16
     efc:	ff 90       	pop	r15
     efe:	ef 90       	pop	r14
     f00:	df 90       	pop	r13
     f02:	cf 90       	pop	r12
     f04:	bf 90       	pop	r11
     f06:	af 90       	pop	r10
     f08:	08 95       	ret

00000f0a <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     f0a:	cf 93       	push	r28
     f0c:	df 93       	push	r29
     f0e:	00 d0       	rcall	.+0      	; 0xf10 <_ZN9task_user3runEv+0x6>
     f10:	00 d0       	rcall	.+0      	; 0xf12 <_ZN9task_user3runEv+0x8>
     f12:	cd b7       	in	r28, 0x3d	; 61
     f14:	de b7       	in	r29, 0x3e	; 62
     f16:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f18:	19 82       	std	Y+1, r1	; 0x01
     f1a:	1a 82       	std	Y+2, r1	; 0x02
     f1c:	1b 82       	std	Y+3, r1	; 0x03
     f1e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f20:	1d 82       	std	Y+5, r1	; 0x05
     f22:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     f24:	6a e0       	ldi	r22, 0x0A	; 10
     f26:	dc 01       	movw	r26, r24
     f28:	16 96       	adiw	r26, 0x06	; 6
     f2a:	8d 91       	ld	r24, X+
     f2c:	9c 91       	ld	r25, X
     f2e:	17 97       	sbiw	r26, 0x07	; 7
     f30:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     f34:	7c 01       	movw	r14, r24
     f36:	66 e3       	ldi	r22, 0x36	; 54
     f38:	74 e0       	ldi	r23, 0x04	; 4
     f3a:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     f3e:	66 e0       	ldi	r22, 0x06	; 6
     f40:	c7 01       	movw	r24, r14
     f42:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     f46:	f8 01       	movw	r30, r16
     f48:	84 85       	ldd	r24, Z+12	; 0x0c
     f4a:	88 23       	and	r24, r24
     f4c:	21 f0       	breq	.+8      	; 0xf56 <_ZN9task_user3runEv+0x4c>
     f4e:	81 30       	cpi	r24, 0x01	; 1
     f50:	09 f4       	brne	.+2      	; 0xf54 <_ZN9task_user3runEv+0x4a>
     f52:	5d c0       	rjmp	.+186    	; 0x100e <_ZN9task_user3runEv+0x104>
     f54:	d8 c0       	rjmp	.+432    	; 0x1106 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     f56:	86 81       	ldd	r24, Z+6	; 0x06
     f58:	97 81       	ldd	r25, Z+7	; 0x07
     f5a:	dc 01       	movw	r26, r24
     f5c:	ed 91       	ld	r30, X+
     f5e:	fc 91       	ld	r31, X
     f60:	04 80       	ldd	r0, Z+4	; 0x04
     f62:	f5 81       	ldd	r31, Z+5	; 0x05
     f64:	e0 2d       	mov	r30, r0
     f66:	19 95       	eicall
     f68:	88 23       	and	r24, r24
     f6a:	a9 f1       	breq	.+106    	; 0xfd6 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     f6c:	f8 01       	movw	r30, r16
     f6e:	86 81       	ldd	r24, Z+6	; 0x06
     f70:	97 81       	ldd	r25, Z+7	; 0x07
     f72:	dc 01       	movw	r26, r24
     f74:	ed 91       	ld	r30, X+
     f76:	fc 91       	ld	r31, X
     f78:	06 80       	ldd	r0, Z+6	; 0x06
     f7a:	f7 81       	ldd	r31, Z+7	; 0x07
     f7c:	e0 2d       	mov	r30, r0
     f7e:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     f80:	99 27       	eor	r25, r25
     f82:	81 30       	cpi	r24, 0x01	; 1
     f84:	91 05       	cpc	r25, r1
     f86:	f9 f0       	breq	.+62     	; 0xfc6 <_ZN9task_user3runEv+0xbc>
     f88:	03 97       	sbiw	r24, 0x03	; 3
     f8a:	09 f0       	breq	.+2      	; 0xf8e <_ZN9task_user3runEv+0x84>
     f8c:	d8 c0       	rjmp	.+432    	; 0x113e <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     f8e:	6a e0       	ldi	r22, 0x0A	; 10
     f90:	f8 01       	movw	r30, r16
     f92:	86 81       	ldd	r24, Z+6	; 0x06
     f94:	97 81       	ldd	r25, Z+7	; 0x07
     f96:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
     f9a:	8c 01       	movw	r16, r24
     f9c:	68 e2       	ldi	r22, 0x28	; 40
     f9e:	74 e0       	ldi	r23, 0x04	; 4
     fa0:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
     fa4:	66 e0       	ldi	r22, 0x06	; 6
     fa6:	c8 01       	movw	r24, r16
     fa8:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     fac:	93 e0       	ldi	r25, 0x03	; 3
     fae:	88 ed       	ldi	r24, 0xD8	; 216
     fb0:	08 b6       	in	r0, 0x38	; 56
     fb2:	18 be       	out	0x38, r1	; 56
     fb4:	84 bf       	out	0x34, r24	; 52
     fb6:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     fba:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     fbe:	81 fd       	sbrc	r24, 1
     fc0:	fc cf       	rjmp	.-8      	; 0xfba <_ZN9task_user3runEv+0xb0>
     fc2:	08 be       	out	0x38, r0	; 56
     fc4:	ff cf       	rjmp	.-2      	; 0xfc4 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     fc6:	c8 01       	movw	r24, r16
     fc8:	0e 94 52 06 	call	0xca4	; 0xca4 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     fcc:	61 e0       	ldi	r22, 0x01	; 1
     fce:	c8 01       	movw	r24, r16
     fd0:	0e 94 03 14 	call	0x2806	; 0x2806 <_ZN8frt_task13transition_toEh>
							break;
     fd4:	b4 c0       	rjmp	.+360    	; 0x113e <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     fd6:	8e e5       	ldi	r24, 0x5E	; 94
     fd8:	91 e3       	ldi	r25, 0x31	; 49
     fda:	0e 94 c4 16 	call	0x2d88	; 0x2d88 <_ZN14frt_text_queue14check_for_charEv>
     fde:	88 23       	and	r24, r24
     fe0:	09 f4       	brne	.+2      	; 0xfe4 <_ZN9task_user3runEv+0xda>
     fe2:	ad c0       	rjmp	.+346    	; 0x113e <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     fe4:	d8 01       	movw	r26, r16
     fe6:	16 96       	adiw	r26, 0x06	; 6
     fe8:	ed 91       	ld	r30, X+
     fea:	fc 91       	ld	r31, X
     fec:	17 97       	sbiw	r26, 0x07	; 7
     fee:	01 90       	ld	r0, Z+
     ff0:	f0 81       	ld	r31, Z
     ff2:	e0 2d       	mov	r30, r0
     ff4:	e2 80       	ldd	r14, Z+2	; 0x02
     ff6:	f3 80       	ldd	r15, Z+3	; 0x03
     ff8:	8e e5       	ldi	r24, 0x5E	; 94
     ffa:	91 e3       	ldi	r25, 0x31	; 49
     ffc:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <_ZN14frt_text_queue7getcharEv>
    1000:	68 2f       	mov	r22, r24
    1002:	f8 01       	movw	r30, r16
    1004:	86 81       	ldd	r24, Z+6	; 0x06
    1006:	97 81       	ldd	r25, Z+7	; 0x07
    1008:	f7 01       	movw	r30, r14
    100a:	19 95       	eicall
    100c:	98 c0       	rjmp	.+304    	; 0x113e <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    100e:	86 81       	ldd	r24, Z+6	; 0x06
    1010:	97 81       	ldd	r25, Z+7	; 0x07
    1012:	dc 01       	movw	r26, r24
    1014:	ed 91       	ld	r30, X+
    1016:	fc 91       	ld	r31, X
    1018:	04 80       	ldd	r0, Z+4	; 0x04
    101a:	f5 81       	ldd	r31, Z+5	; 0x05
    101c:	e0 2d       	mov	r30, r0
    101e:	19 95       	eicall
    1020:	88 23       	and	r24, r24
    1022:	09 f4       	brne	.+2      	; 0x1026 <_ZN9task_user3runEv+0x11c>
    1024:	8c c0       	rjmp	.+280    	; 0x113e <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1026:	f8 01       	movw	r30, r16
    1028:	86 81       	ldd	r24, Z+6	; 0x06
    102a:	97 81       	ldd	r25, Z+7	; 0x07
    102c:	dc 01       	movw	r26, r24
    102e:	ed 91       	ld	r30, X+
    1030:	fc 91       	ld	r31, X
    1032:	06 80       	ldd	r0, Z+6	; 0x06
    1034:	f7 81       	ldd	r31, Z+7	; 0x07
    1036:	e0 2d       	mov	r30, r0
    1038:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    103a:	9c 01       	movw	r18, r24
    103c:	33 27       	eor	r19, r19
    103e:	28 36       	cpi	r18, 0x68	; 104
    1040:	31 05       	cpc	r19, r1
    1042:	59 f1       	breq	.+86     	; 0x109a <_ZN9task_user3runEv+0x190>
    1044:	3c f4       	brge	.+14     	; 0x1054 <_ZN9task_user3runEv+0x14a>
    1046:	2b 31       	cpi	r18, 0x1B	; 27
    1048:	31 05       	cpc	r19, r1
    104a:	59 f1       	breq	.+86     	; 0x10a2 <_ZN9task_user3runEv+0x198>
    104c:	25 36       	cpi	r18, 0x65	; 101
    104e:	31 05       	cpc	r19, r1
    1050:	41 f1       	breq	.+80     	; 0x10a2 <_ZN9task_user3runEv+0x198>
    1052:	3b c0       	rjmp	.+118    	; 0x10ca <_ZN9task_user3runEv+0x1c0>
    1054:	23 37       	cpi	r18, 0x73	; 115
    1056:	31 05       	cpc	r19, r1
    1058:	c1 f0       	breq	.+48     	; 0x108a <_ZN9task_user3runEv+0x180>
    105a:	26 37       	cpi	r18, 0x76	; 118
    105c:	31 05       	cpc	r19, r1
    105e:	89 f0       	breq	.+34     	; 0x1082 <_ZN9task_user3runEv+0x178>
    1060:	2e 36       	cpi	r18, 0x6E	; 110
    1062:	31 05       	cpc	r19, r1
    1064:	91 f5       	brne	.+100    	; 0x10ca <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1066:	ce 01       	movw	r24, r28
    1068:	01 96       	adiw	r24, 0x01	; 1
    106a:	0e 94 b8 17 	call	0x2f70	; 0x2f70 <_ZN10time_stamp10set_to_nowEv>
    106e:	bc 01       	movw	r22, r24
    1070:	f8 01       	movw	r30, r16
    1072:	86 81       	ldd	r24, Z+6	; 0x06
    1074:	97 81       	ldd	r25, Z+7	; 0x07
    1076:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <_ZlsR8emstreamR10time_stamp>
    107a:	66 e0       	ldi	r22, 0x06	; 6
    107c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1080:	5e c0       	rjmp	.+188    	; 0x113e <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1082:	c8 01       	movw	r24, r16
    1084:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN9task_user11show_statusEv>
							break;
    1088:	5a c0       	rjmp	.+180    	; 0x113e <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    108a:	d8 01       	movw	r26, r16
    108c:	16 96       	adiw	r26, 0x06	; 6
    108e:	8d 91       	ld	r24, X+
    1090:	9c 91       	ld	r25, X
    1092:	17 97       	sbiw	r26, 0x07	; 7
    1094:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <_Z17print_task_stacksP8emstream>
							break;
    1098:	52 c0       	rjmp	.+164    	; 0x113e <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    109a:	c8 01       	movw	r24, r16
    109c:	0e 94 52 06 	call	0xca4	; 0xca4 <_ZN9task_user18print_help_messageEv>
							break;
    10a0:	4e c0       	rjmp	.+156    	; 0x113e <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    10a2:	6a e0       	ldi	r22, 0x0A	; 10
    10a4:	f8 01       	movw	r30, r16
    10a6:	86 81       	ldd	r24, Z+6	; 0x06
    10a8:	97 81       	ldd	r25, Z+7	; 0x07
    10aa:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    10ae:	7c 01       	movw	r14, r24
    10b0:	66 e1       	ldi	r22, 0x16	; 22
    10b2:	74 e0       	ldi	r23, 0x04	; 4
    10b4:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    10b8:	66 e0       	ldi	r22, 0x06	; 6
    10ba:	c7 01       	movw	r24, r14
    10bc:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    10c0:	60 e0       	ldi	r22, 0x00	; 0
    10c2:	c8 01       	movw	r24, r16
    10c4:	0e 94 03 14 	call	0x2806	; 0x2806 <_ZN8frt_task13transition_toEh>
							break;
    10c8:	3a c0       	rjmp	.+116    	; 0x113e <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    10ca:	f8 01       	movw	r30, r16
    10cc:	a6 81       	ldd	r26, Z+6	; 0x06
    10ce:	b7 81       	ldd	r27, Z+7	; 0x07
    10d0:	ed 91       	ld	r30, X+
    10d2:	fc 91       	ld	r31, X
    10d4:	11 97       	sbiw	r26, 0x01	; 1
    10d6:	02 80       	ldd	r0, Z+2	; 0x02
    10d8:	f3 81       	ldd	r31, Z+3	; 0x03
    10da:	e0 2d       	mov	r30, r0
    10dc:	68 2f       	mov	r22, r24
    10de:	cd 01       	movw	r24, r26
    10e0:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    10e2:	6a e0       	ldi	r22, 0x0A	; 10
    10e4:	d8 01       	movw	r26, r16
    10e6:	16 96       	adiw	r26, 0x06	; 6
    10e8:	8d 91       	ld	r24, X+
    10ea:	9c 91       	ld	r25, X
    10ec:	17 97       	sbiw	r26, 0x07	; 7
    10ee:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    10f2:	7c 01       	movw	r14, r24
    10f4:	60 e1       	ldi	r22, 0x10	; 16
    10f6:	74 e0       	ldi	r23, 0x04	; 4
    10f8:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    10fc:	66 e0       	ldi	r22, 0x06	; 6
    10fe:	c7 01       	movw	r24, r14
    1100:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1104:	1c c0       	rjmp	.+56     	; 0x113e <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1106:	6a e0       	ldi	r22, 0x0A	; 10
    1108:	f8 01       	movw	r30, r16
    110a:	86 81       	ldd	r24, Z+6	; 0x06
    110c:	97 81       	ldd	r25, Z+7	; 0x07
    110e:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    1112:	8c 01       	movw	r16, r24
    1114:	63 ef       	ldi	r22, 0xF3	; 243
    1116:	73 e0       	ldi	r23, 0x03	; 3
    1118:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    111c:	66 e0       	ldi	r22, 0x06	; 6
    111e:	c8 01       	movw	r24, r16
    1120:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1124:	93 e0       	ldi	r25, 0x03	; 3
    1126:	88 ed       	ldi	r24, 0xD8	; 216
    1128:	08 b6       	in	r0, 0x38	; 56
    112a:	18 be       	out	0x38, r1	; 56
    112c:	84 bf       	out	0x34, r24	; 52
    112e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1132:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1136:	81 fd       	sbrc	r24, 1
    1138:	fc cf       	rjmp	.-8      	; 0x1132 <_ZN9task_user3runEv+0x228>
    113a:	08 be       	out	0x38, r0	; 56
    113c:	ff cf       	rjmp	.-2      	; 0x113c <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    113e:	f8 01       	movw	r30, r16
    1140:	86 85       	ldd	r24, Z+14	; 0x0e
    1142:	97 85       	ldd	r25, Z+15	; 0x0f
    1144:	a0 89       	ldd	r26, Z+16	; 0x10
    1146:	b1 89       	ldd	r27, Z+17	; 0x11
    1148:	01 96       	adiw	r24, 0x01	; 1
    114a:	a1 1d       	adc	r26, r1
    114c:	b1 1d       	adc	r27, r1
    114e:	86 87       	std	Z+14, r24	; 0x0e
    1150:	97 87       	std	Z+15, r25	; 0x0f
    1152:	a0 8b       	std	Z+16, r26	; 0x10
    1154:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1156:	61 e0       	ldi	r22, 0x01	; 1
    1158:	70 e0       	ldi	r23, 0x00	; 0
    115a:	80 e0       	ldi	r24, 0x00	; 0
    115c:	90 e0       	ldi	r25, 0x00	; 0
    115e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1162:	f1 ce       	rjmp	.-542    	; 0xf46 <_ZN9task_user3runEv+0x3c>

00001164 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1164:	0f 93       	push	r16
    1166:	1f 93       	push	r17
    1168:	cf 93       	push	r28
    116a:	df 93       	push	r29
    116c:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    116e:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1172:	80 91 ca 20 	lds	r24, 0x20CA	; 0x8020ca <__data_end>
    1176:	81 11       	cpse	r24, r1
    1178:	1d c0       	rjmp	.+58     	; 0x11b4 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    117a:	af ec       	ldi	r26, 0xCF	; 207
    117c:	b0 e2       	ldi	r27, 0x20	; 32
    117e:	e3 ed       	ldi	r30, 0xD3	; 211
    1180:	f0 e2       	ldi	r31, 0x20	; 32
    1182:	ed 93       	st	X+, r30
    1184:	fc 93       	st	X, r31
    1186:	11 97       	sbiw	r26, 0x01	; 1
    1188:	12 96       	adiw	r26, 0x02	; 2
    118a:	1d 92       	st	X+, r1
    118c:	1c 92       	st	X, r1
    118e:	13 97       	sbiw	r26, 0x03	; 3
    1190:	ab ec       	ldi	r26, 0xCB	; 203
    1192:	b0 e2       	ldi	r27, 0x20	; 32
    1194:	8f ef       	ldi	r24, 0xFF	; 255
    1196:	9f e0       	ldi	r25, 0x0F	; 15
    1198:	12 96       	adiw	r26, 0x02	; 2
    119a:	8d 93       	st	X+, r24
    119c:	9c 93       	st	X, r25
    119e:	13 97       	sbiw	r26, 0x03	; 3
    11a0:	1d 92       	st	X+, r1
    11a2:	1c 92       	st	X, r1
    11a4:	11 97       	sbiw	r26, 0x01	; 1
    11a6:	82 83       	std	Z+2, r24	; 0x02
    11a8:	93 83       	std	Z+3, r25	; 0x03
    11aa:	a0 83       	st	Z, r26
    11ac:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	80 93 ca 20 	sts	0x20CA, r24	; 0x8020ca <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    11b4:	20 97       	sbiw	r28, 0x00	; 0
    11b6:	09 f4       	brne	.+2      	; 0x11ba <pvPortMalloc+0x56>
    11b8:	5f c0       	rjmp	.+190    	; 0x1278 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    11ba:	9e 01       	movw	r18, r28
    11bc:	2b 5f       	subi	r18, 0xFB	; 251
    11be:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    11c0:	24 96       	adiw	r28, 0x04	; 4
    11c2:	ce 3f       	cpi	r28, 0xFE	; 254
    11c4:	df 40       	sbci	r29, 0x0F	; 15
    11c6:	08 f0       	brcs	.+2      	; 0x11ca <pvPortMalloc+0x66>
    11c8:	5a c0       	rjmp	.+180    	; 0x127e <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    11ca:	e0 91 cf 20 	lds	r30, 0x20CF	; 0x8020cf <xStart>
    11ce:	f0 91 d0 20 	lds	r31, 0x20D0	; 0x8020d0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    11d2:	af ec       	ldi	r26, 0xCF	; 207
    11d4:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    11d6:	02 c0       	rjmp	.+4      	; 0x11dc <pvPortMalloc+0x78>
    11d8:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    11da:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    11dc:	82 81       	ldd	r24, Z+2	; 0x02
    11de:	93 81       	ldd	r25, Z+3	; 0x03
    11e0:	82 17       	cp	r24, r18
    11e2:	93 07       	cpc	r25, r19
    11e4:	20 f4       	brcc	.+8      	; 0x11ee <pvPortMalloc+0x8a>
    11e6:	80 81       	ld	r24, Z
    11e8:	91 81       	ldd	r25, Z+1	; 0x01
    11ea:	00 97       	sbiw	r24, 0x00	; 0
    11ec:	a9 f7       	brne	.-22     	; 0x11d8 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    11ee:	c0 e2       	ldi	r28, 0x20	; 32
    11f0:	eb 3c       	cpi	r30, 0xCB	; 203
    11f2:	fc 07       	cpc	r31, r28
    11f4:	09 f4       	brne	.+2      	; 0x11f8 <pvPortMalloc+0x94>
    11f6:	46 c0       	rjmp	.+140    	; 0x1284 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    11f8:	cd 91       	ld	r28, X+
    11fa:	dc 91       	ld	r29, X
    11fc:	11 97       	sbiw	r26, 0x01	; 1
    11fe:	8e 01       	movw	r16, r28
    1200:	0b 5f       	subi	r16, 0xFB	; 251
    1202:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1204:	80 81       	ld	r24, Z
    1206:	91 81       	ldd	r25, Z+1	; 0x01
    1208:	8d 93       	st	X+, r24
    120a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    120c:	82 81       	ldd	r24, Z+2	; 0x02
    120e:	93 81       	ldd	r25, Z+3	; 0x03
    1210:	82 1b       	sub	r24, r18
    1212:	93 0b       	sbc	r25, r19
    1214:	8b 30       	cpi	r24, 0x0B	; 11
    1216:	91 05       	cpc	r25, r1
    1218:	10 f1       	brcs	.+68     	; 0x125e <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    121a:	bf 01       	movw	r22, r30
    121c:	62 0f       	add	r22, r18
    121e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1220:	db 01       	movw	r26, r22
    1222:	12 96       	adiw	r26, 0x02	; 2
    1224:	8d 93       	st	X+, r24
    1226:	9c 93       	st	X, r25
    1228:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    122a:	22 83       	std	Z+2, r18	; 0x02
    122c:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    122e:	12 96       	adiw	r26, 0x02	; 2
    1230:	4d 91       	ld	r20, X+
    1232:	5c 91       	ld	r21, X
    1234:	13 97       	sbiw	r26, 0x03	; 3
    1236:	8f ec       	ldi	r24, 0xCF	; 207
    1238:	90 e2       	ldi	r25, 0x20	; 32
    123a:	01 c0       	rjmp	.+2      	; 0x123e <pvPortMalloc+0xda>
    123c:	cd 01       	movw	r24, r26
    123e:	ec 01       	movw	r28, r24
    1240:	a8 81       	ld	r26, Y
    1242:	b9 81       	ldd	r27, Y+1	; 0x01
    1244:	12 96       	adiw	r26, 0x02	; 2
    1246:	2d 91       	ld	r18, X+
    1248:	3c 91       	ld	r19, X
    124a:	13 97       	sbiw	r26, 0x03	; 3
    124c:	24 17       	cp	r18, r20
    124e:	35 07       	cpc	r19, r21
    1250:	a8 f3       	brcs	.-22     	; 0x123c <pvPortMalloc+0xd8>
    1252:	eb 01       	movw	r28, r22
    1254:	a8 83       	st	Y, r26
    1256:	b9 83       	std	Y+1, r27	; 0x01
    1258:	dc 01       	movw	r26, r24
    125a:	6d 93       	st	X+, r22
    125c:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    125e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1262:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1266:	22 81       	ldd	r18, Z+2	; 0x02
    1268:	33 81       	ldd	r19, Z+3	; 0x03
    126a:	82 1b       	sub	r24, r18
    126c:	93 0b       	sbc	r25, r19
    126e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1272:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1276:	08 c0       	rjmp	.+16     	; 0x1288 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1278:	00 e0       	ldi	r16, 0x00	; 0
    127a:	10 e0       	ldi	r17, 0x00	; 0
    127c:	05 c0       	rjmp	.+10     	; 0x1288 <pvPortMalloc+0x124>
    127e:	00 e0       	ldi	r16, 0x00	; 0
    1280:	10 e0       	ldi	r17, 0x00	; 0
    1282:	02 c0       	rjmp	.+4      	; 0x1288 <pvPortMalloc+0x124>
    1284:	00 e0       	ldi	r16, 0x00	; 0
    1286:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1288:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    128c:	c8 01       	movw	r24, r16
    128e:	df 91       	pop	r29
    1290:	cf 91       	pop	r28
    1292:	1f 91       	pop	r17
    1294:	0f 91       	pop	r16
    1296:	08 95       	ret

00001298 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1298:	0f 93       	push	r16
    129a:	1f 93       	push	r17
    129c:	cf 93       	push	r28
    129e:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    12a0:	00 97       	sbiw	r24, 0x00	; 0
    12a2:	41 f1       	breq	.+80     	; 0x12f4 <vPortFree+0x5c>
    12a4:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    12a6:	8c 01       	movw	r16, r24
    12a8:	05 50       	subi	r16, 0x05	; 5
    12aa:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    12ac:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    12b0:	f8 01       	movw	r30, r16
    12b2:	42 81       	ldd	r20, Z+2	; 0x02
    12b4:	53 81       	ldd	r21, Z+3	; 0x03
    12b6:	af ec       	ldi	r26, 0xCF	; 207
    12b8:	b0 e2       	ldi	r27, 0x20	; 32
    12ba:	01 c0       	rjmp	.+2      	; 0x12be <vPortFree+0x26>
    12bc:	df 01       	movw	r26, r30
    12be:	ed 91       	ld	r30, X+
    12c0:	fc 91       	ld	r31, X
    12c2:	11 97       	sbiw	r26, 0x01	; 1
    12c4:	22 81       	ldd	r18, Z+2	; 0x02
    12c6:	33 81       	ldd	r19, Z+3	; 0x03
    12c8:	24 17       	cp	r18, r20
    12ca:	35 07       	cpc	r19, r21
    12cc:	b8 f3       	brcs	.-18     	; 0x12bc <vPortFree+0x24>
    12ce:	25 97       	sbiw	r28, 0x05	; 5
    12d0:	e8 83       	st	Y, r30
    12d2:	f9 83       	std	Y+1, r31	; 0x01
    12d4:	0d 93       	st	X+, r16
    12d6:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    12d8:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    12dc:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    12e0:	8a 81       	ldd	r24, Y+2	; 0x02
    12e2:	9b 81       	ldd	r25, Y+3	; 0x03
    12e4:	82 0f       	add	r24, r18
    12e6:	93 1f       	adc	r25, r19
    12e8:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    12ec:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    12f0:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
	}
}
    12f4:	df 91       	pop	r29
    12f6:	cf 91       	pop	r28
    12f8:	1f 91       	pop	r17
    12fa:	0f 91       	pop	r16
    12fc:	08 95       	ret

000012fe <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    12fe:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1302:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1306:	08 95       	ret

00001308 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1308:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    130a:	03 96       	adiw	r24, 0x03	; 3
    130c:	81 83       	std	Z+1, r24	; 0x01
    130e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1310:	4f ef       	ldi	r20, 0xFF	; 255
    1312:	5f ef       	ldi	r21, 0xFF	; 255
    1314:	ba 01       	movw	r22, r20
    1316:	43 83       	std	Z+3, r20	; 0x03
    1318:	54 83       	std	Z+4, r21	; 0x04
    131a:	65 83       	std	Z+5, r22	; 0x05
    131c:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    131e:	87 83       	std	Z+7, r24	; 0x07
    1320:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1322:	81 87       	std	Z+9, r24	; 0x09
    1324:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1326:	10 82       	st	Z, r1
    1328:	08 95       	ret

0000132a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    132a:	fc 01       	movw	r30, r24
    132c:	12 86       	std	Z+10, r1	; 0x0a
    132e:	13 86       	std	Z+11, r1	; 0x0b
    1330:	08 95       	ret

00001332 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1332:	cf 93       	push	r28
    1334:	df 93       	push	r29
    1336:	fc 01       	movw	r30, r24
    1338:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    133a:	21 81       	ldd	r18, Z+1	; 0x01
    133c:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    133e:	e9 01       	movw	r28, r18
    1340:	8c 81       	ldd	r24, Y+4	; 0x04
    1342:	9d 81       	ldd	r25, Y+5	; 0x05
    1344:	14 96       	adiw	r26, 0x04	; 4
    1346:	8d 93       	st	X+, r24
    1348:	9c 93       	st	X, r25
    134a:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    134c:	81 81       	ldd	r24, Z+1	; 0x01
    134e:	92 81       	ldd	r25, Z+2	; 0x02
    1350:	16 96       	adiw	r26, 0x06	; 6
    1352:	8d 93       	st	X+, r24
    1354:	9c 93       	st	X, r25
    1356:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1358:	8c 81       	ldd	r24, Y+4	; 0x04
    135a:	9d 81       	ldd	r25, Y+5	; 0x05
    135c:	ec 01       	movw	r28, r24
    135e:	6e 83       	std	Y+6, r22	; 0x06
    1360:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1362:	e9 01       	movw	r28, r18
    1364:	6c 83       	std	Y+4, r22	; 0x04
    1366:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1368:	61 83       	std	Z+1, r22	; 0x01
    136a:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    136c:	1a 96       	adiw	r26, 0x0a	; 10
    136e:	ed 93       	st	X+, r30
    1370:	fc 93       	st	X, r31
    1372:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1374:	80 81       	ld	r24, Z
    1376:	8f 5f       	subi	r24, 0xFF	; 255
    1378:	80 83       	st	Z, r24
}
    137a:	df 91       	pop	r29
    137c:	cf 91       	pop	r28
    137e:	08 95       	ret

00001380 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1380:	0f 93       	push	r16
    1382:	1f 93       	push	r17
    1384:	cf 93       	push	r28
    1386:	df 93       	push	r29
    1388:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    138a:	08 81       	ld	r16, Y
    138c:	19 81       	ldd	r17, Y+1	; 0x01
    138e:	2a 81       	ldd	r18, Y+2	; 0x02
    1390:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1392:	0f 3f       	cpi	r16, 0xFF	; 255
    1394:	4f ef       	ldi	r20, 0xFF	; 255
    1396:	14 07       	cpc	r17, r20
    1398:	24 07       	cpc	r18, r20
    139a:	34 07       	cpc	r19, r20
    139c:	31 f4       	brne	.+12     	; 0x13aa <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    139e:	dc 01       	movw	r26, r24
    13a0:	19 96       	adiw	r26, 0x09	; 9
    13a2:	ed 91       	ld	r30, X+
    13a4:	fc 91       	ld	r31, X
    13a6:	1a 97       	sbiw	r26, 0x0a	; 10
    13a8:	1f c0       	rjmp	.+62     	; 0x13e8 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    13aa:	fc 01       	movw	r30, r24
    13ac:	33 96       	adiw	r30, 0x03	; 3
    13ae:	dc 01       	movw	r26, r24
    13b0:	17 96       	adiw	r26, 0x07	; 7
    13b2:	4d 91       	ld	r20, X+
    13b4:	5c 91       	ld	r21, X
    13b6:	18 97       	sbiw	r26, 0x08	; 8
    13b8:	da 01       	movw	r26, r20
    13ba:	4d 91       	ld	r20, X+
    13bc:	5d 91       	ld	r21, X+
    13be:	6d 91       	ld	r22, X+
    13c0:	7c 91       	ld	r23, X
    13c2:	04 17       	cp	r16, r20
    13c4:	15 07       	cpc	r17, r21
    13c6:	26 07       	cpc	r18, r22
    13c8:	37 07       	cpc	r19, r23
    13ca:	70 f0       	brcs	.+28     	; 0x13e8 <vListInsert+0x68>
    13cc:	04 80       	ldd	r0, Z+4	; 0x04
    13ce:	f5 81       	ldd	r31, Z+5	; 0x05
    13d0:	e0 2d       	mov	r30, r0
    13d2:	a4 81       	ldd	r26, Z+4	; 0x04
    13d4:	b5 81       	ldd	r27, Z+5	; 0x05
    13d6:	4d 91       	ld	r20, X+
    13d8:	5d 91       	ld	r21, X+
    13da:	6d 91       	ld	r22, X+
    13dc:	7c 91       	ld	r23, X
    13de:	04 17       	cp	r16, r20
    13e0:	15 07       	cpc	r17, r21
    13e2:	26 07       	cpc	r18, r22
    13e4:	37 07       	cpc	r19, r23
    13e6:	90 f7       	brcc	.-28     	; 0x13cc <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    13e8:	a4 81       	ldd	r26, Z+4	; 0x04
    13ea:	b5 81       	ldd	r27, Z+5	; 0x05
    13ec:	ac 83       	std	Y+4, r26	; 0x04
    13ee:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    13f0:	16 96       	adiw	r26, 0x06	; 6
    13f2:	cd 93       	st	X+, r28
    13f4:	dc 93       	st	X, r29
    13f6:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    13f8:	ee 83       	std	Y+6, r30	; 0x06
    13fa:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    13fc:	c4 83       	std	Z+4, r28	; 0x04
    13fe:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1400:	8a 87       	std	Y+10, r24	; 0x0a
    1402:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1404:	fc 01       	movw	r30, r24
    1406:	20 81       	ld	r18, Z
    1408:	2f 5f       	subi	r18, 0xFF	; 255
    140a:	20 83       	st	Z, r18
}
    140c:	df 91       	pop	r29
    140e:	cf 91       	pop	r28
    1410:	1f 91       	pop	r17
    1412:	0f 91       	pop	r16
    1414:	08 95       	ret

00001416 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1416:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1418:	a4 81       	ldd	r26, Z+4	; 0x04
    141a:	b5 81       	ldd	r27, Z+5	; 0x05
    141c:	86 81       	ldd	r24, Z+6	; 0x06
    141e:	97 81       	ldd	r25, Z+7	; 0x07
    1420:	16 96       	adiw	r26, 0x06	; 6
    1422:	8d 93       	st	X+, r24
    1424:	9c 93       	st	X, r25
    1426:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1428:	a6 81       	ldd	r26, Z+6	; 0x06
    142a:	b7 81       	ldd	r27, Z+7	; 0x07
    142c:	84 81       	ldd	r24, Z+4	; 0x04
    142e:	95 81       	ldd	r25, Z+5	; 0x05
    1430:	14 96       	adiw	r26, 0x04	; 4
    1432:	8d 93       	st	X+, r24
    1434:	9c 93       	st	X, r25
    1436:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1438:	a2 85       	ldd	r26, Z+10	; 0x0a
    143a:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    143c:	11 96       	adiw	r26, 0x01	; 1
    143e:	8d 91       	ld	r24, X+
    1440:	9c 91       	ld	r25, X
    1442:	12 97       	sbiw	r26, 0x02	; 2
    1444:	e8 17       	cp	r30, r24
    1446:	f9 07       	cpc	r31, r25
    1448:	31 f4       	brne	.+12     	; 0x1456 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    144a:	86 81       	ldd	r24, Z+6	; 0x06
    144c:	97 81       	ldd	r25, Z+7	; 0x07
    144e:	11 96       	adiw	r26, 0x01	; 1
    1450:	8d 93       	st	X+, r24
    1452:	9c 93       	st	X, r25
    1454:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1456:	12 86       	std	Z+10, r1	; 0x0a
    1458:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    145a:	8c 91       	ld	r24, X
    145c:	81 50       	subi	r24, 0x01	; 1
    145e:	8c 93       	st	X, r24
    1460:	08 95       	ret

00001462 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1462:	80 93 6e 31 	sts	0x316E, r24	; 0x80316e <portStackTopForTask>
    1466:	90 93 6f 31 	sts	0x316F, r25	; 0x80316f <portStackTopForTask+0x1>
    146a:	31 e1       	ldi	r19, 0x11	; 17
    146c:	fc 01       	movw	r30, r24
    146e:	30 83       	st	Z, r19
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	22 e2       	ldi	r18, 0x22	; 34
    1474:	20 83       	st	Z, r18
    1476:	31 97       	sbiw	r30, 0x01	; 1
    1478:	a3 e3       	ldi	r26, 0x33	; 51
    147a:	a0 83       	st	Z, r26
    147c:	31 97       	sbiw	r30, 0x01	; 1
    147e:	60 83       	st	Z, r22
    1480:	31 97       	sbiw	r30, 0x01	; 1
    1482:	70 83       	st	Z, r23
    1484:	31 97       	sbiw	r30, 0x01	; 1
    1486:	10 82       	st	Z, r1
    1488:	31 97       	sbiw	r30, 0x01	; 1
    148a:	10 82       	st	Z, r1
    148c:	31 97       	sbiw	r30, 0x01	; 1
    148e:	60 e8       	ldi	r22, 0x80	; 128
    1490:	60 83       	st	Z, r22
    1492:	31 97       	sbiw	r30, 0x01	; 1
    1494:	10 82       	st	Z, r1
    1496:	31 97       	sbiw	r30, 0x01	; 1
    1498:	10 82       	st	Z, r1
    149a:	31 97       	sbiw	r30, 0x01	; 1
    149c:	10 82       	st	Z, r1
    149e:	31 97       	sbiw	r30, 0x01	; 1
    14a0:	62 e0       	ldi	r22, 0x02	; 2
    14a2:	60 83       	st	Z, r22
    14a4:	31 97       	sbiw	r30, 0x01	; 1
    14a6:	63 e0       	ldi	r22, 0x03	; 3
    14a8:	60 83       	st	Z, r22
    14aa:	31 97       	sbiw	r30, 0x01	; 1
    14ac:	64 e0       	ldi	r22, 0x04	; 4
    14ae:	60 83       	st	Z, r22
    14b0:	31 97       	sbiw	r30, 0x01	; 1
    14b2:	65 e0       	ldi	r22, 0x05	; 5
    14b4:	60 83       	st	Z, r22
    14b6:	31 97       	sbiw	r30, 0x01	; 1
    14b8:	66 e0       	ldi	r22, 0x06	; 6
    14ba:	60 83       	st	Z, r22
    14bc:	31 97       	sbiw	r30, 0x01	; 1
    14be:	67 e0       	ldi	r22, 0x07	; 7
    14c0:	60 83       	st	Z, r22
    14c2:	31 97       	sbiw	r30, 0x01	; 1
    14c4:	68 e0       	ldi	r22, 0x08	; 8
    14c6:	60 83       	st	Z, r22
    14c8:	31 97       	sbiw	r30, 0x01	; 1
    14ca:	69 e0       	ldi	r22, 0x09	; 9
    14cc:	60 83       	st	Z, r22
    14ce:	31 97       	sbiw	r30, 0x01	; 1
    14d0:	60 e1       	ldi	r22, 0x10	; 16
    14d2:	60 83       	st	Z, r22
    14d4:	31 97       	sbiw	r30, 0x01	; 1
    14d6:	30 83       	st	Z, r19
    14d8:	31 97       	sbiw	r30, 0x01	; 1
    14da:	32 e1       	ldi	r19, 0x12	; 18
    14dc:	30 83       	st	Z, r19
    14de:	31 97       	sbiw	r30, 0x01	; 1
    14e0:	33 e1       	ldi	r19, 0x13	; 19
    14e2:	30 83       	st	Z, r19
    14e4:	31 97       	sbiw	r30, 0x01	; 1
    14e6:	34 e1       	ldi	r19, 0x14	; 20
    14e8:	30 83       	st	Z, r19
    14ea:	31 97       	sbiw	r30, 0x01	; 1
    14ec:	35 e1       	ldi	r19, 0x15	; 21
    14ee:	30 83       	st	Z, r19
    14f0:	31 97       	sbiw	r30, 0x01	; 1
    14f2:	36 e1       	ldi	r19, 0x16	; 22
    14f4:	30 83       	st	Z, r19
    14f6:	31 97       	sbiw	r30, 0x01	; 1
    14f8:	37 e1       	ldi	r19, 0x17	; 23
    14fa:	30 83       	st	Z, r19
    14fc:	31 97       	sbiw	r30, 0x01	; 1
    14fe:	38 e1       	ldi	r19, 0x18	; 24
    1500:	30 83       	st	Z, r19
    1502:	31 97       	sbiw	r30, 0x01	; 1
    1504:	39 e1       	ldi	r19, 0x19	; 25
    1506:	30 83       	st	Z, r19
    1508:	31 97       	sbiw	r30, 0x01	; 1
    150a:	30 e2       	ldi	r19, 0x20	; 32
    150c:	30 83       	st	Z, r19
    150e:	31 97       	sbiw	r30, 0x01	; 1
    1510:	31 e2       	ldi	r19, 0x21	; 33
    1512:	30 83       	st	Z, r19
    1514:	31 97       	sbiw	r30, 0x01	; 1
    1516:	20 83       	st	Z, r18
    1518:	31 97       	sbiw	r30, 0x01	; 1
    151a:	23 e2       	ldi	r18, 0x23	; 35
    151c:	20 83       	st	Z, r18
    151e:	31 97       	sbiw	r30, 0x01	; 1
    1520:	40 83       	st	Z, r20
    1522:	31 97       	sbiw	r30, 0x01	; 1
    1524:	50 83       	st	Z, r21
    1526:	31 97       	sbiw	r30, 0x01	; 1
    1528:	26 e2       	ldi	r18, 0x26	; 38
    152a:	20 83       	st	Z, r18
    152c:	31 97       	sbiw	r30, 0x01	; 1
    152e:	27 e2       	ldi	r18, 0x27	; 39
    1530:	20 83       	st	Z, r18
    1532:	31 97       	sbiw	r30, 0x01	; 1
    1534:	28 e2       	ldi	r18, 0x28	; 40
    1536:	20 83       	st	Z, r18
    1538:	31 97       	sbiw	r30, 0x01	; 1
    153a:	29 e2       	ldi	r18, 0x29	; 41
    153c:	20 83       	st	Z, r18
    153e:	31 97       	sbiw	r30, 0x01	; 1
    1540:	20 e3       	ldi	r18, 0x30	; 48
    1542:	20 83       	st	Z, r18
    1544:	31 97       	sbiw	r30, 0x01	; 1
    1546:	21 e3       	ldi	r18, 0x31	; 49
    1548:	20 83       	st	Z, r18
    154a:	89 97       	sbiw	r24, 0x29	; 41
    154c:	08 95       	ret

0000154e <xPortStartScheduler>:
    154e:	8c e7       	ldi	r24, 0x7C	; 124
    1550:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1554:	8f ef       	ldi	r24, 0xFF	; 255
    1556:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    155a:	81 e0       	ldi	r24, 0x01	; 1
    155c:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1560:	91 e1       	ldi	r25, 0x11	; 17
    1562:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1566:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    156a:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    156e:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1572:	cd 91       	ld	r28, X+
    1574:	cd bf       	out	0x3d, r28	; 61
    1576:	dd 91       	ld	r29, X+
    1578:	de bf       	out	0x3e, r29	; 62
    157a:	ff 91       	pop	r31
    157c:	ef 91       	pop	r30
    157e:	df 91       	pop	r29
    1580:	cf 91       	pop	r28
    1582:	bf 91       	pop	r27
    1584:	af 91       	pop	r26
    1586:	9f 91       	pop	r25
    1588:	8f 91       	pop	r24
    158a:	7f 91       	pop	r23
    158c:	6f 91       	pop	r22
    158e:	5f 91       	pop	r21
    1590:	4f 91       	pop	r20
    1592:	3f 91       	pop	r19
    1594:	2f 91       	pop	r18
    1596:	1f 91       	pop	r17
    1598:	0f 91       	pop	r16
    159a:	ff 90       	pop	r15
    159c:	ef 90       	pop	r14
    159e:	df 90       	pop	r13
    15a0:	cf 90       	pop	r12
    15a2:	bf 90       	pop	r11
    15a4:	af 90       	pop	r10
    15a6:	9f 90       	pop	r9
    15a8:	8f 90       	pop	r8
    15aa:	7f 90       	pop	r7
    15ac:	6f 90       	pop	r6
    15ae:	5f 90       	pop	r5
    15b0:	4f 90       	pop	r4
    15b2:	3f 90       	pop	r3
    15b4:	2f 90       	pop	r2
    15b6:	1f 90       	pop	r1
    15b8:	0f 90       	pop	r0
    15ba:	0c be       	out	0x3c, r0	; 60
    15bc:	0f 90       	pop	r0
    15be:	0b be       	out	0x3b, r0	; 59
    15c0:	0f 90       	pop	r0
    15c2:	0f be       	out	0x3f, r0	; 63
    15c4:	0f 90       	pop	r0
    15c6:	08 95       	ret
    15c8:	08 95       	ret

000015ca <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    15ca:	0f 92       	push	r0
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	f8 94       	cli
    15d0:	0f 92       	push	r0
    15d2:	0b b6       	in	r0, 0x3b	; 59
    15d4:	0f 92       	push	r0
    15d6:	0c b6       	in	r0, 0x3c	; 60
    15d8:	0f 92       	push	r0
    15da:	1f 92       	push	r1
    15dc:	11 24       	eor	r1, r1
    15de:	2f 92       	push	r2
    15e0:	3f 92       	push	r3
    15e2:	4f 92       	push	r4
    15e4:	5f 92       	push	r5
    15e6:	6f 92       	push	r6
    15e8:	7f 92       	push	r7
    15ea:	8f 92       	push	r8
    15ec:	9f 92       	push	r9
    15ee:	af 92       	push	r10
    15f0:	bf 92       	push	r11
    15f2:	cf 92       	push	r12
    15f4:	df 92       	push	r13
    15f6:	ef 92       	push	r14
    15f8:	ff 92       	push	r15
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	2f 93       	push	r18
    1600:	3f 93       	push	r19
    1602:	4f 93       	push	r20
    1604:	5f 93       	push	r21
    1606:	6f 93       	push	r22
    1608:	7f 93       	push	r23
    160a:	8f 93       	push	r24
    160c:	9f 93       	push	r25
    160e:	af 93       	push	r26
    1610:	bf 93       	push	r27
    1612:	cf 93       	push	r28
    1614:	df 93       	push	r29
    1616:	ef 93       	push	r30
    1618:	ff 93       	push	r31
    161a:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    161e:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1622:	0d b6       	in	r0, 0x3d	; 61
    1624:	0d 92       	st	X+, r0
    1626:	0e b6       	in	r0, 0x3e	; 62
    1628:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    162a:	0e 94 05 12 	call	0x240a	; 0x240a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    162e:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    1632:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1636:	cd 91       	ld	r28, X+
    1638:	cd bf       	out	0x3d, r28	; 61
    163a:	dd 91       	ld	r29, X+
    163c:	de bf       	out	0x3e, r29	; 62
    163e:	ff 91       	pop	r31
    1640:	ef 91       	pop	r30
    1642:	df 91       	pop	r29
    1644:	cf 91       	pop	r28
    1646:	bf 91       	pop	r27
    1648:	af 91       	pop	r26
    164a:	9f 91       	pop	r25
    164c:	8f 91       	pop	r24
    164e:	7f 91       	pop	r23
    1650:	6f 91       	pop	r22
    1652:	5f 91       	pop	r21
    1654:	4f 91       	pop	r20
    1656:	3f 91       	pop	r19
    1658:	2f 91       	pop	r18
    165a:	1f 91       	pop	r17
    165c:	0f 91       	pop	r16
    165e:	ff 90       	pop	r15
    1660:	ef 90       	pop	r14
    1662:	df 90       	pop	r13
    1664:	cf 90       	pop	r12
    1666:	bf 90       	pop	r11
    1668:	af 90       	pop	r10
    166a:	9f 90       	pop	r9
    166c:	8f 90       	pop	r8
    166e:	7f 90       	pop	r7
    1670:	6f 90       	pop	r6
    1672:	5f 90       	pop	r5
    1674:	4f 90       	pop	r4
    1676:	3f 90       	pop	r3
    1678:	2f 90       	pop	r2
    167a:	1f 90       	pop	r1
    167c:	0f 90       	pop	r0
    167e:	0c be       	out	0x3c, r0	; 60
    1680:	0f 90       	pop	r0
    1682:	0b be       	out	0x3b, r0	; 59
    1684:	0f 90       	pop	r0
    1686:	0f be       	out	0x3f, r0	; 63
    1688:	0f 90       	pop	r0

	asm volatile ( "ret" );
    168a:	08 95       	ret

0000168c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    168c:	0f 92       	push	r0
    168e:	0f b6       	in	r0, 0x3f	; 63
    1690:	f8 94       	cli
    1692:	0f 92       	push	r0
    1694:	0b b6       	in	r0, 0x3b	; 59
    1696:	0f 92       	push	r0
    1698:	0c b6       	in	r0, 0x3c	; 60
    169a:	0f 92       	push	r0
    169c:	1f 92       	push	r1
    169e:	11 24       	eor	r1, r1
    16a0:	2f 92       	push	r2
    16a2:	3f 92       	push	r3
    16a4:	4f 92       	push	r4
    16a6:	5f 92       	push	r5
    16a8:	6f 92       	push	r6
    16aa:	7f 92       	push	r7
    16ac:	8f 92       	push	r8
    16ae:	9f 92       	push	r9
    16b0:	af 92       	push	r10
    16b2:	bf 92       	push	r11
    16b4:	cf 92       	push	r12
    16b6:	df 92       	push	r13
    16b8:	ef 92       	push	r14
    16ba:	ff 92       	push	r15
    16bc:	0f 93       	push	r16
    16be:	1f 93       	push	r17
    16c0:	2f 93       	push	r18
    16c2:	3f 93       	push	r19
    16c4:	4f 93       	push	r20
    16c6:	5f 93       	push	r21
    16c8:	6f 93       	push	r22
    16ca:	7f 93       	push	r23
    16cc:	8f 93       	push	r24
    16ce:	9f 93       	push	r25
    16d0:	af 93       	push	r26
    16d2:	bf 93       	push	r27
    16d4:	cf 93       	push	r28
    16d6:	df 93       	push	r29
    16d8:	ef 93       	push	r30
    16da:	ff 93       	push	r31
    16dc:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    16e0:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    16e4:	0d b6       	in	r0, 0x3d	; 61
    16e6:	0d 92       	st	X+, r0
    16e8:	0e b6       	in	r0, 0x3e	; 62
    16ea:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    16ec:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskIncrementTick>
	vTaskSwitchContext();
    16f0:	0e 94 05 12 	call	0x240a	; 0x240a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    16f4:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    16f8:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    16fc:	cd 91       	ld	r28, X+
    16fe:	cd bf       	out	0x3d, r28	; 61
    1700:	dd 91       	ld	r29, X+
    1702:	de bf       	out	0x3e, r29	; 62
    1704:	ff 91       	pop	r31
    1706:	ef 91       	pop	r30
    1708:	df 91       	pop	r29
    170a:	cf 91       	pop	r28
    170c:	bf 91       	pop	r27
    170e:	af 91       	pop	r26
    1710:	9f 91       	pop	r25
    1712:	8f 91       	pop	r24
    1714:	7f 91       	pop	r23
    1716:	6f 91       	pop	r22
    1718:	5f 91       	pop	r21
    171a:	4f 91       	pop	r20
    171c:	3f 91       	pop	r19
    171e:	2f 91       	pop	r18
    1720:	1f 91       	pop	r17
    1722:	0f 91       	pop	r16
    1724:	ff 90       	pop	r15
    1726:	ef 90       	pop	r14
    1728:	df 90       	pop	r13
    172a:	cf 90       	pop	r12
    172c:	bf 90       	pop	r11
    172e:	af 90       	pop	r10
    1730:	9f 90       	pop	r9
    1732:	8f 90       	pop	r8
    1734:	7f 90       	pop	r7
    1736:	6f 90       	pop	r6
    1738:	5f 90       	pop	r5
    173a:	4f 90       	pop	r4
    173c:	3f 90       	pop	r3
    173e:	2f 90       	pop	r2
    1740:	1f 90       	pop	r1
    1742:	0f 90       	pop	r0
    1744:	0c be       	out	0x3c, r0	; 60
    1746:	0f 90       	pop	r0
    1748:	0b be       	out	0x3b, r0	; 59
    174a:	0f 90       	pop	r0
    174c:	0f be       	out	0x3f, r0	; 63
    174e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1750:	08 95       	ret

00001752 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1752:	0e 94 46 0b 	call	0x168c	; 0x168c <vPortYieldFromTick>
		asm volatile ( "reti" );
    1756:	18 95       	reti

00001758 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1758:	cf 93       	push	r28
    175a:	df 93       	push	r29
    175c:	ec 01       	movw	r28, r24
    175e:	88 a1       	ldd	r24, Y+32	; 0x20
    1760:	81 11       	cpse	r24, r1
    1762:	0b c0       	rjmp	.+22     	; 0x177a <prvCopyDataToQueue+0x22>
    1764:	88 81       	ld	r24, Y
    1766:	99 81       	ldd	r25, Y+1	; 0x01
    1768:	89 2b       	or	r24, r25
    176a:	e1 f5       	brne	.+120    	; 0x17e4 <prvCopyDataToQueue+0x8c>
    176c:	8a 81       	ldd	r24, Y+2	; 0x02
    176e:	9b 81       	ldd	r25, Y+3	; 0x03
    1770:	0e 94 c0 13 	call	0x2780	; 0x2780 <vTaskPriorityDisinherit>
    1774:	1a 82       	std	Y+2, r1	; 0x02
    1776:	1b 82       	std	Y+3, r1	; 0x03
    1778:	35 c0       	rjmp	.+106    	; 0x17e4 <prvCopyDataToQueue+0x8c>
    177a:	41 11       	cpse	r20, r1
    177c:	17 c0       	rjmp	.+46     	; 0x17ac <prvCopyDataToQueue+0x54>
    177e:	48 2f       	mov	r20, r24
    1780:	50 e0       	ldi	r21, 0x00	; 0
    1782:	8c 81       	ldd	r24, Y+4	; 0x04
    1784:	9d 81       	ldd	r25, Y+5	; 0x05
    1786:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <memcpy>
    178a:	28 a1       	ldd	r18, Y+32	; 0x20
    178c:	8c 81       	ldd	r24, Y+4	; 0x04
    178e:	9d 81       	ldd	r25, Y+5	; 0x05
    1790:	82 0f       	add	r24, r18
    1792:	91 1d       	adc	r25, r1
    1794:	8c 83       	std	Y+4, r24	; 0x04
    1796:	9d 83       	std	Y+5, r25	; 0x05
    1798:	2a 81       	ldd	r18, Y+2	; 0x02
    179a:	3b 81       	ldd	r19, Y+3	; 0x03
    179c:	82 17       	cp	r24, r18
    179e:	93 07       	cpc	r25, r19
    17a0:	08 f1       	brcs	.+66     	; 0x17e4 <prvCopyDataToQueue+0x8c>
    17a2:	88 81       	ld	r24, Y
    17a4:	99 81       	ldd	r25, Y+1	; 0x01
    17a6:	8c 83       	std	Y+4, r24	; 0x04
    17a8:	9d 83       	std	Y+5, r25	; 0x05
    17aa:	1c c0       	rjmp	.+56     	; 0x17e4 <prvCopyDataToQueue+0x8c>
    17ac:	48 2f       	mov	r20, r24
    17ae:	50 e0       	ldi	r21, 0x00	; 0
    17b0:	8e 81       	ldd	r24, Y+6	; 0x06
    17b2:	9f 81       	ldd	r25, Y+7	; 0x07
    17b4:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <memcpy>
    17b8:	88 a1       	ldd	r24, Y+32	; 0x20
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	91 95       	neg	r25
    17be:	81 95       	neg	r24
    17c0:	91 09       	sbc	r25, r1
    17c2:	2e 81       	ldd	r18, Y+6	; 0x06
    17c4:	3f 81       	ldd	r19, Y+7	; 0x07
    17c6:	28 0f       	add	r18, r24
    17c8:	39 1f       	adc	r19, r25
    17ca:	2e 83       	std	Y+6, r18	; 0x06
    17cc:	3f 83       	std	Y+7, r19	; 0x07
    17ce:	48 81       	ld	r20, Y
    17d0:	59 81       	ldd	r21, Y+1	; 0x01
    17d2:	24 17       	cp	r18, r20
    17d4:	35 07       	cpc	r19, r21
    17d6:	30 f4       	brcc	.+12     	; 0x17e4 <prvCopyDataToQueue+0x8c>
    17d8:	2a 81       	ldd	r18, Y+2	; 0x02
    17da:	3b 81       	ldd	r19, Y+3	; 0x03
    17dc:	82 0f       	add	r24, r18
    17de:	93 1f       	adc	r25, r19
    17e0:	8e 83       	std	Y+6, r24	; 0x06
    17e2:	9f 83       	std	Y+7, r25	; 0x07
    17e4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17e6:	8f 5f       	subi	r24, 0xFF	; 255
    17e8:	8e 8f       	std	Y+30, r24	; 0x1e
    17ea:	df 91       	pop	r29
    17ec:	cf 91       	pop	r28
    17ee:	08 95       	ret

000017f0 <prvCopyDataFromQueue>:
    17f0:	fc 01       	movw	r30, r24
    17f2:	80 81       	ld	r24, Z
    17f4:	91 81       	ldd	r25, Z+1	; 0x01
    17f6:	00 97       	sbiw	r24, 0x00	; 0
    17f8:	a1 f0       	breq	.+40     	; 0x1822 <prvCopyDataFromQueue+0x32>
    17fa:	40 a1       	ldd	r20, Z+32	; 0x20
    17fc:	50 e0       	ldi	r21, 0x00	; 0
    17fe:	26 81       	ldd	r18, Z+6	; 0x06
    1800:	37 81       	ldd	r19, Z+7	; 0x07
    1802:	24 0f       	add	r18, r20
    1804:	35 1f       	adc	r19, r21
    1806:	26 83       	std	Z+6, r18	; 0x06
    1808:	37 83       	std	Z+7, r19	; 0x07
    180a:	a2 81       	ldd	r26, Z+2	; 0x02
    180c:	b3 81       	ldd	r27, Z+3	; 0x03
    180e:	2a 17       	cp	r18, r26
    1810:	3b 07       	cpc	r19, r27
    1812:	10 f0       	brcs	.+4      	; 0x1818 <prvCopyDataFromQueue+0x28>
    1814:	86 83       	std	Z+6, r24	; 0x06
    1816:	97 83       	std	Z+7, r25	; 0x07
    1818:	cb 01       	movw	r24, r22
    181a:	66 81       	ldd	r22, Z+6	; 0x06
    181c:	77 81       	ldd	r23, Z+7	; 0x07
    181e:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <memcpy>
    1822:	08 95       	ret

00001824 <prvUnlockQueue>:
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	ec 01       	movw	r28, r24
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	f8 94       	cli
    1832:	0f 92       	push	r0
    1834:	8a a1       	ldd	r24, Y+34	; 0x22
    1836:	18 16       	cp	r1, r24
    1838:	b4 f4       	brge	.+44     	; 0x1866 <prvUnlockQueue+0x42>
    183a:	8b 89       	ldd	r24, Y+19	; 0x13
    183c:	81 11       	cpse	r24, r1
    183e:	05 c0       	rjmp	.+10     	; 0x184a <prvUnlockQueue+0x26>
    1840:	12 c0       	rjmp	.+36     	; 0x1866 <prvUnlockQueue+0x42>
    1842:	8b 89       	ldd	r24, Y+19	; 0x13
    1844:	81 11       	cpse	r24, r1
    1846:	04 c0       	rjmp	.+8      	; 0x1850 <prvUnlockQueue+0x2c>
    1848:	0e c0       	rjmp	.+28     	; 0x1866 <prvUnlockQueue+0x42>
    184a:	8e 01       	movw	r16, r28
    184c:	0d 5e       	subi	r16, 0xED	; 237
    184e:	1f 4f       	sbci	r17, 0xFF	; 255
    1850:	c8 01       	movw	r24, r16
    1852:	0e 94 8c 12 	call	0x2518	; 0x2518 <xTaskRemoveFromEventList>
    1856:	81 11       	cpse	r24, r1
    1858:	0e 94 49 13 	call	0x2692	; 0x2692 <vTaskMissedYield>
    185c:	8a a1       	ldd	r24, Y+34	; 0x22
    185e:	81 50       	subi	r24, 0x01	; 1
    1860:	8a a3       	std	Y+34, r24	; 0x22
    1862:	18 16       	cp	r1, r24
    1864:	74 f3       	brlt	.-36     	; 0x1842 <prvUnlockQueue+0x1e>
    1866:	8f ef       	ldi	r24, 0xFF	; 255
    1868:	8a a3       	std	Y+34, r24	; 0x22
    186a:	0f 90       	pop	r0
    186c:	0f be       	out	0x3f, r0	; 63
    186e:	0f b6       	in	r0, 0x3f	; 63
    1870:	f8 94       	cli
    1872:	0f 92       	push	r0
    1874:	89 a1       	ldd	r24, Y+33	; 0x21
    1876:	18 16       	cp	r1, r24
    1878:	b4 f4       	brge	.+44     	; 0x18a6 <prvUnlockQueue+0x82>
    187a:	88 85       	ldd	r24, Y+8	; 0x08
    187c:	81 11       	cpse	r24, r1
    187e:	05 c0       	rjmp	.+10     	; 0x188a <prvUnlockQueue+0x66>
    1880:	12 c0       	rjmp	.+36     	; 0x18a6 <prvUnlockQueue+0x82>
    1882:	88 85       	ldd	r24, Y+8	; 0x08
    1884:	81 11       	cpse	r24, r1
    1886:	04 c0       	rjmp	.+8      	; 0x1890 <prvUnlockQueue+0x6c>
    1888:	0e c0       	rjmp	.+28     	; 0x18a6 <prvUnlockQueue+0x82>
    188a:	8e 01       	movw	r16, r28
    188c:	08 5f       	subi	r16, 0xF8	; 248
    188e:	1f 4f       	sbci	r17, 0xFF	; 255
    1890:	c8 01       	movw	r24, r16
    1892:	0e 94 8c 12 	call	0x2518	; 0x2518 <xTaskRemoveFromEventList>
    1896:	81 11       	cpse	r24, r1
    1898:	0e 94 49 13 	call	0x2692	; 0x2692 <vTaskMissedYield>
    189c:	89 a1       	ldd	r24, Y+33	; 0x21
    189e:	81 50       	subi	r24, 0x01	; 1
    18a0:	89 a3       	std	Y+33, r24	; 0x21
    18a2:	18 16       	cp	r1, r24
    18a4:	74 f3       	brlt	.-36     	; 0x1882 <prvUnlockQueue+0x5e>
    18a6:	8f ef       	ldi	r24, 0xFF	; 255
    18a8:	89 a3       	std	Y+33, r24	; 0x21
    18aa:	0f 90       	pop	r0
    18ac:	0f be       	out	0x3f, r0	; 63
    18ae:	df 91       	pop	r29
    18b0:	cf 91       	pop	r28
    18b2:	1f 91       	pop	r17
    18b4:	0f 91       	pop	r16
    18b6:	08 95       	ret

000018b8 <xQueueGenericReset>:
    18b8:	1f 93       	push	r17
    18ba:	cf 93       	push	r28
    18bc:	df 93       	push	r29
    18be:	61 30       	cpi	r22, 0x01	; 1
    18c0:	59 f0       	breq	.+22     	; 0x18d8 <xQueueGenericReset+0x20>
    18c2:	fc 01       	movw	r30, r24
    18c4:	23 89       	ldd	r18, Z+19	; 0x13
    18c6:	30 85       	ldd	r19, Z+8	; 0x08
    18c8:	31 11       	cpse	r19, r1
    18ca:	2c c0       	rjmp	.+88     	; 0x1924 <xQueueGenericReset+0x6c>
    18cc:	11 e0       	ldi	r17, 0x01	; 1
    18ce:	21 11       	cpse	r18, r1
    18d0:	10 e0       	ldi	r17, 0x00	; 0
    18d2:	21 11       	cpse	r18, r1
    18d4:	28 c0       	rjmp	.+80     	; 0x1926 <xQueueGenericReset+0x6e>
    18d6:	01 c0       	rjmp	.+2      	; 0x18da <xQueueGenericReset+0x22>
    18d8:	11 e0       	ldi	r17, 0x01	; 1
    18da:	ec 01       	movw	r28, r24
    18dc:	48 81       	ld	r20, Y
    18de:	59 81       	ldd	r21, Y+1	; 0x01
    18e0:	28 a1       	ldd	r18, Y+32	; 0x20
    18e2:	30 e0       	ldi	r19, 0x00	; 0
    18e4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    18e6:	62 9f       	mul	r22, r18
    18e8:	c0 01       	movw	r24, r0
    18ea:	63 9f       	mul	r22, r19
    18ec:	90 0d       	add	r25, r0
    18ee:	11 24       	eor	r1, r1
    18f0:	ba 01       	movw	r22, r20
    18f2:	68 0f       	add	r22, r24
    18f4:	79 1f       	adc	r23, r25
    18f6:	6a 83       	std	Y+2, r22	; 0x02
    18f8:	7b 83       	std	Y+3, r23	; 0x03
    18fa:	1e 8e       	std	Y+30, r1	; 0x1e
    18fc:	4c 83       	std	Y+4, r20	; 0x04
    18fe:	5d 83       	std	Y+5, r21	; 0x05
    1900:	82 1b       	sub	r24, r18
    1902:	93 0b       	sbc	r25, r19
    1904:	84 0f       	add	r24, r20
    1906:	95 1f       	adc	r25, r21
    1908:	8e 83       	std	Y+6, r24	; 0x06
    190a:	9f 83       	std	Y+7, r25	; 0x07
    190c:	8f ef       	ldi	r24, 0xFF	; 255
    190e:	89 a3       	std	Y+33, r24	; 0x21
    1910:	8a a3       	std	Y+34, r24	; 0x22
    1912:	ce 01       	movw	r24, r28
    1914:	08 96       	adiw	r24, 0x08	; 8
    1916:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    191a:	ce 01       	movw	r24, r28
    191c:	43 96       	adiw	r24, 0x13	; 19
    191e:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    1922:	01 c0       	rjmp	.+2      	; 0x1926 <xQueueGenericReset+0x6e>
    1924:	10 e0       	ldi	r17, 0x00	; 0
    1926:	81 2f       	mov	r24, r17
    1928:	df 91       	pop	r29
    192a:	cf 91       	pop	r28
    192c:	1f 91       	pop	r17
    192e:	08 95       	ret

00001930 <xQueueGenericCreate>:
    1930:	0f 93       	push	r16
    1932:	1f 93       	push	r17
    1934:	cf 93       	push	r28
    1936:	df 93       	push	r29
    1938:	88 23       	and	r24, r24
    193a:	01 f1       	breq	.+64     	; 0x197c <xQueueGenericCreate+0x4c>
    193c:	06 2f       	mov	r16, r22
    193e:	18 2f       	mov	r17, r24
    1940:	83 e2       	ldi	r24, 0x23	; 35
    1942:	90 e0       	ldi	r25, 0x00	; 0
    1944:	0e 94 b2 08 	call	0x1164	; 0x1164 <pvPortMalloc>
    1948:	ec 01       	movw	r28, r24
    194a:	89 2b       	or	r24, r25
    194c:	c9 f0       	breq	.+50     	; 0x1980 <xQueueGenericCreate+0x50>
    194e:	10 9f       	mul	r17, r16
    1950:	c0 01       	movw	r24, r0
    1952:	11 24       	eor	r1, r1
    1954:	01 96       	adiw	r24, 0x01	; 1
    1956:	0e 94 b2 08 	call	0x1164	; 0x1164 <pvPortMalloc>
    195a:	88 83       	st	Y, r24
    195c:	99 83       	std	Y+1, r25	; 0x01
    195e:	89 2b       	or	r24, r25
    1960:	39 f0       	breq	.+14     	; 0x1970 <xQueueGenericCreate+0x40>
    1962:	1f 8f       	std	Y+31, r17	; 0x1f
    1964:	08 a3       	std	Y+32, r16	; 0x20
    1966:	61 e0       	ldi	r22, 0x01	; 1
    1968:	ce 01       	movw	r24, r28
    196a:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <xQueueGenericReset>
    196e:	08 c0       	rjmp	.+16     	; 0x1980 <xQueueGenericCreate+0x50>
    1970:	ce 01       	movw	r24, r28
    1972:	0e 94 4c 09 	call	0x1298	; 0x1298 <vPortFree>
    1976:	c0 e0       	ldi	r28, 0x00	; 0
    1978:	d0 e0       	ldi	r29, 0x00	; 0
    197a:	02 c0       	rjmp	.+4      	; 0x1980 <xQueueGenericCreate+0x50>
    197c:	c0 e0       	ldi	r28, 0x00	; 0
    197e:	d0 e0       	ldi	r29, 0x00	; 0
    1980:	ce 01       	movw	r24, r28
    1982:	df 91       	pop	r29
    1984:	cf 91       	pop	r28
    1986:	1f 91       	pop	r17
    1988:	0f 91       	pop	r16
    198a:	08 95       	ret

0000198c <xQueueGenericSend>:
    198c:	af 92       	push	r10
    198e:	bf 92       	push	r11
    1990:	cf 92       	push	r12
    1992:	df 92       	push	r13
    1994:	ef 92       	push	r14
    1996:	ff 92       	push	r15
    1998:	0f 93       	push	r16
    199a:	1f 93       	push	r17
    199c:	cf 93       	push	r28
    199e:	df 93       	push	r29
    19a0:	cd b7       	in	r28, 0x3d	; 61
    19a2:	de b7       	in	r29, 0x3e	; 62
    19a4:	29 97       	sbiw	r28, 0x09	; 9
    19a6:	cd bf       	out	0x3d, r28	; 61
    19a8:	de bf       	out	0x3e, r29	; 62
    19aa:	7c 01       	movw	r14, r24
    19ac:	5b 01       	movw	r10, r22
    19ae:	2e 83       	std	Y+6, r18	; 0x06
    19b0:	3f 83       	std	Y+7, r19	; 0x07
    19b2:	48 87       	std	Y+8, r20	; 0x08
    19b4:	59 87       	std	Y+9, r21	; 0x09
    19b6:	10 e0       	ldi	r17, 0x00	; 0
    19b8:	6c 01       	movw	r12, r24
    19ba:	88 e0       	ldi	r24, 0x08	; 8
    19bc:	c8 0e       	add	r12, r24
    19be:	d1 1c       	adc	r13, r1
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
    19c6:	f7 01       	movw	r30, r14
    19c8:	96 8d       	ldd	r25, Z+30	; 0x1e
    19ca:	87 8d       	ldd	r24, Z+31	; 0x1f
    19cc:	98 17       	cp	r25, r24
    19ce:	a8 f4       	brcc	.+42     	; 0x19fa <xQueueGenericSend+0x6e>
    19d0:	40 2f       	mov	r20, r16
    19d2:	b5 01       	movw	r22, r10
    19d4:	c7 01       	movw	r24, r14
    19d6:	0e 94 ac 0b 	call	0x1758	; 0x1758 <prvCopyDataToQueue>
    19da:	f7 01       	movw	r30, r14
    19dc:	83 89       	ldd	r24, Z+19	; 0x13
    19de:	88 23       	and	r24, r24
    19e0:	41 f0       	breq	.+16     	; 0x19f2 <xQueueGenericSend+0x66>
    19e2:	c7 01       	movw	r24, r14
    19e4:	43 96       	adiw	r24, 0x13	; 19
    19e6:	0e 94 8c 12 	call	0x2518	; 0x2518 <xTaskRemoveFromEventList>
    19ea:	81 30       	cpi	r24, 0x01	; 1
    19ec:	11 f4       	brne	.+4      	; 0x19f2 <xQueueGenericSend+0x66>
    19ee:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
    19f2:	0f 90       	pop	r0
    19f4:	0f be       	out	0x3f, r0	; 63
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	56 c0       	rjmp	.+172    	; 0x1aa6 <xQueueGenericSend+0x11a>
    19fa:	8e 81       	ldd	r24, Y+6	; 0x06
    19fc:	9f 81       	ldd	r25, Y+7	; 0x07
    19fe:	a8 85       	ldd	r26, Y+8	; 0x08
    1a00:	b9 85       	ldd	r27, Y+9	; 0x09
    1a02:	89 2b       	or	r24, r25
    1a04:	8a 2b       	or	r24, r26
    1a06:	8b 2b       	or	r24, r27
    1a08:	21 f4       	brne	.+8      	; 0x1a12 <xQueueGenericSend+0x86>
    1a0a:	0f 90       	pop	r0
    1a0c:	0f be       	out	0x3f, r0	; 63
    1a0e:	80 e0       	ldi	r24, 0x00	; 0
    1a10:	4a c0       	rjmp	.+148    	; 0x1aa6 <xQueueGenericSend+0x11a>
    1a12:	11 11       	cpse	r17, r1
    1a14:	05 c0       	rjmp	.+10     	; 0x1a20 <xQueueGenericSend+0x94>
    1a16:	ce 01       	movw	r24, r28
    1a18:	01 96       	adiw	r24, 0x01	; 1
    1a1a:	0e 94 cb 12 	call	0x2596	; 0x2596 <vTaskSetTimeOutState>
    1a1e:	11 e0       	ldi	r17, 0x01	; 1
    1a20:	0f 90       	pop	r0
    1a22:	0f be       	out	0x3f, r0	; 63
    1a24:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <vTaskSuspendAll>
    1a28:	0f b6       	in	r0, 0x3f	; 63
    1a2a:	f8 94       	cli
    1a2c:	0f 92       	push	r0
    1a2e:	f7 01       	movw	r30, r14
    1a30:	81 a1       	ldd	r24, Z+33	; 0x21
    1a32:	8f 3f       	cpi	r24, 0xFF	; 255
    1a34:	09 f4       	brne	.+2      	; 0x1a38 <xQueueGenericSend+0xac>
    1a36:	11 a2       	std	Z+33, r1	; 0x21
    1a38:	f7 01       	movw	r30, r14
    1a3a:	82 a1       	ldd	r24, Z+34	; 0x22
    1a3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a3e:	09 f4       	brne	.+2      	; 0x1a42 <xQueueGenericSend+0xb6>
    1a40:	12 a2       	std	Z+34, r1	; 0x22
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63
    1a46:	be 01       	movw	r22, r28
    1a48:	6a 5f       	subi	r22, 0xFA	; 250
    1a4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a4c:	ce 01       	movw	r24, r28
    1a4e:	01 96       	adiw	r24, 0x01	; 1
    1a50:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <xTaskCheckForTimeOut>
    1a54:	81 11       	cpse	r24, r1
    1a56:	21 c0       	rjmp	.+66     	; 0x1a9a <xQueueGenericSend+0x10e>
    1a58:	0f b6       	in	r0, 0x3f	; 63
    1a5a:	f8 94       	cli
    1a5c:	0f 92       	push	r0
    1a5e:	f7 01       	movw	r30, r14
    1a60:	96 8d       	ldd	r25, Z+30	; 0x1e
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	87 8d       	ldd	r24, Z+31	; 0x1f
    1a68:	98 13       	cpse	r25, r24
    1a6a:	11 c0       	rjmp	.+34     	; 0x1a8e <xQueueGenericSend+0x102>
    1a6c:	4e 81       	ldd	r20, Y+6	; 0x06
    1a6e:	5f 81       	ldd	r21, Y+7	; 0x07
    1a70:	68 85       	ldd	r22, Y+8	; 0x08
    1a72:	79 85       	ldd	r23, Y+9	; 0x09
    1a74:	c6 01       	movw	r24, r12
    1a76:	0e 94 62 12 	call	0x24c4	; 0x24c4 <vTaskPlaceOnEventList>
    1a7a:	c7 01       	movw	r24, r14
    1a7c:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvUnlockQueue>
    1a80:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
    1a84:	81 11       	cpse	r24, r1
    1a86:	9c cf       	rjmp	.-200    	; 0x19c0 <xQueueGenericSend+0x34>
    1a88:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
    1a8c:	99 cf       	rjmp	.-206    	; 0x19c0 <xQueueGenericSend+0x34>
    1a8e:	c7 01       	movw	r24, r14
    1a90:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvUnlockQueue>
    1a94:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
    1a98:	93 cf       	rjmp	.-218    	; 0x19c0 <xQueueGenericSend+0x34>
    1a9a:	c7 01       	movw	r24, r14
    1a9c:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvUnlockQueue>
    1aa0:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
    1aa4:	80 e0       	ldi	r24, 0x00	; 0
    1aa6:	29 96       	adiw	r28, 0x09	; 9
    1aa8:	cd bf       	out	0x3d, r28	; 61
    1aaa:	de bf       	out	0x3e, r29	; 62
    1aac:	df 91       	pop	r29
    1aae:	cf 91       	pop	r28
    1ab0:	1f 91       	pop	r17
    1ab2:	0f 91       	pop	r16
    1ab4:	ff 90       	pop	r15
    1ab6:	ef 90       	pop	r14
    1ab8:	df 90       	pop	r13
    1aba:	cf 90       	pop	r12
    1abc:	bf 90       	pop	r11
    1abe:	af 90       	pop	r10
    1ac0:	08 95       	ret

00001ac2 <xQueueGenericReceive>:
    1ac2:	af 92       	push	r10
    1ac4:	bf 92       	push	r11
    1ac6:	cf 92       	push	r12
    1ac8:	df 92       	push	r13
    1aca:	ef 92       	push	r14
    1acc:	ff 92       	push	r15
    1ace:	0f 93       	push	r16
    1ad0:	1f 93       	push	r17
    1ad2:	cf 93       	push	r28
    1ad4:	df 93       	push	r29
    1ad6:	cd b7       	in	r28, 0x3d	; 61
    1ad8:	de b7       	in	r29, 0x3e	; 62
    1ada:	29 97       	sbiw	r28, 0x09	; 9
    1adc:	cd bf       	out	0x3d, r28	; 61
    1ade:	de bf       	out	0x3e, r29	; 62
    1ae0:	7c 01       	movw	r14, r24
    1ae2:	5b 01       	movw	r10, r22
    1ae4:	2e 83       	std	Y+6, r18	; 0x06
    1ae6:	3f 83       	std	Y+7, r19	; 0x07
    1ae8:	48 87       	std	Y+8, r20	; 0x08
    1aea:	59 87       	std	Y+9, r21	; 0x09
    1aec:	10 e0       	ldi	r17, 0x00	; 0
    1aee:	6c 01       	movw	r12, r24
    1af0:	83 e1       	ldi	r24, 0x13	; 19
    1af2:	c8 0e       	add	r12, r24
    1af4:	d1 1c       	adc	r13, r1
    1af6:	0f b6       	in	r0, 0x3f	; 63
    1af8:	f8 94       	cli
    1afa:	0f 92       	push	r0
    1afc:	f7 01       	movw	r30, r14
    1afe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b00:	88 23       	and	r24, r24
    1b02:	99 f1       	breq	.+102    	; 0x1b6a <xQueueGenericReceive+0xa8>
    1b04:	c6 80       	ldd	r12, Z+6	; 0x06
    1b06:	d7 80       	ldd	r13, Z+7	; 0x07
    1b08:	b5 01       	movw	r22, r10
    1b0a:	c7 01       	movw	r24, r14
    1b0c:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <prvCopyDataFromQueue>
    1b10:	01 11       	cpse	r16, r1
    1b12:	1a c0       	rjmp	.+52     	; 0x1b48 <xQueueGenericReceive+0x86>
    1b14:	f7 01       	movw	r30, r14
    1b16:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b18:	81 50       	subi	r24, 0x01	; 1
    1b1a:	86 8f       	std	Z+30, r24	; 0x1e
    1b1c:	80 81       	ld	r24, Z
    1b1e:	91 81       	ldd	r25, Z+1	; 0x01
    1b20:	89 2b       	or	r24, r25
    1b22:	29 f4       	brne	.+10     	; 0x1b2e <xQueueGenericReceive+0x6c>
    1b24:	0e 94 66 13 	call	0x26cc	; 0x26cc <xTaskGetCurrentTaskHandle>
    1b28:	f7 01       	movw	r30, r14
    1b2a:	82 83       	std	Z+2, r24	; 0x02
    1b2c:	93 83       	std	Z+3, r25	; 0x03
    1b2e:	f7 01       	movw	r30, r14
    1b30:	80 85       	ldd	r24, Z+8	; 0x08
    1b32:	88 23       	and	r24, r24
    1b34:	b1 f0       	breq	.+44     	; 0x1b62 <xQueueGenericReceive+0xa0>
    1b36:	c7 01       	movw	r24, r14
    1b38:	08 96       	adiw	r24, 0x08	; 8
    1b3a:	0e 94 8c 12 	call	0x2518	; 0x2518 <xTaskRemoveFromEventList>
    1b3e:	81 30       	cpi	r24, 0x01	; 1
    1b40:	81 f4       	brne	.+32     	; 0x1b62 <xQueueGenericReceive+0xa0>
    1b42:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
    1b46:	0d c0       	rjmp	.+26     	; 0x1b62 <xQueueGenericReceive+0xa0>
    1b48:	f7 01       	movw	r30, r14
    1b4a:	c6 82       	std	Z+6, r12	; 0x06
    1b4c:	d7 82       	std	Z+7, r13	; 0x07
    1b4e:	83 89       	ldd	r24, Z+19	; 0x13
    1b50:	88 23       	and	r24, r24
    1b52:	39 f0       	breq	.+14     	; 0x1b62 <xQueueGenericReceive+0xa0>
    1b54:	c7 01       	movw	r24, r14
    1b56:	43 96       	adiw	r24, 0x13	; 19
    1b58:	0e 94 8c 12 	call	0x2518	; 0x2518 <xTaskRemoveFromEventList>
    1b5c:	81 11       	cpse	r24, r1
    1b5e:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
    1b62:	0f 90       	pop	r0
    1b64:	0f be       	out	0x3f, r0	; 63
    1b66:	81 e0       	ldi	r24, 0x01	; 1
    1b68:	62 c0       	rjmp	.+196    	; 0x1c2e <xQueueGenericReceive+0x16c>
    1b6a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b6c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b6e:	a8 85       	ldd	r26, Y+8	; 0x08
    1b70:	b9 85       	ldd	r27, Y+9	; 0x09
    1b72:	89 2b       	or	r24, r25
    1b74:	8a 2b       	or	r24, r26
    1b76:	8b 2b       	or	r24, r27
    1b78:	21 f4       	brne	.+8      	; 0x1b82 <xQueueGenericReceive+0xc0>
    1b7a:	0f 90       	pop	r0
    1b7c:	0f be       	out	0x3f, r0	; 63
    1b7e:	80 e0       	ldi	r24, 0x00	; 0
    1b80:	56 c0       	rjmp	.+172    	; 0x1c2e <xQueueGenericReceive+0x16c>
    1b82:	11 11       	cpse	r17, r1
    1b84:	05 c0       	rjmp	.+10     	; 0x1b90 <xQueueGenericReceive+0xce>
    1b86:	ce 01       	movw	r24, r28
    1b88:	01 96       	adiw	r24, 0x01	; 1
    1b8a:	0e 94 cb 12 	call	0x2596	; 0x2596 <vTaskSetTimeOutState>
    1b8e:	11 e0       	ldi	r17, 0x01	; 1
    1b90:	0f 90       	pop	r0
    1b92:	0f be       	out	0x3f, r0	; 63
    1b94:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <vTaskSuspendAll>
    1b98:	0f b6       	in	r0, 0x3f	; 63
    1b9a:	f8 94       	cli
    1b9c:	0f 92       	push	r0
    1b9e:	f7 01       	movw	r30, r14
    1ba0:	81 a1       	ldd	r24, Z+33	; 0x21
    1ba2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ba4:	09 f4       	brne	.+2      	; 0x1ba8 <xQueueGenericReceive+0xe6>
    1ba6:	11 a2       	std	Z+33, r1	; 0x21
    1ba8:	f7 01       	movw	r30, r14
    1baa:	82 a1       	ldd	r24, Z+34	; 0x22
    1bac:	8f 3f       	cpi	r24, 0xFF	; 255
    1bae:	09 f4       	brne	.+2      	; 0x1bb2 <xQueueGenericReceive+0xf0>
    1bb0:	12 a2       	std	Z+34, r1	; 0x22
    1bb2:	0f 90       	pop	r0
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	be 01       	movw	r22, r28
    1bb8:	6a 5f       	subi	r22, 0xFA	; 250
    1bba:	7f 4f       	sbci	r23, 0xFF	; 255
    1bbc:	ce 01       	movw	r24, r28
    1bbe:	01 96       	adiw	r24, 0x01	; 1
    1bc0:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <xTaskCheckForTimeOut>
    1bc4:	81 11       	cpse	r24, r1
    1bc6:	2d c0       	rjmp	.+90     	; 0x1c22 <xQueueGenericReceive+0x160>
    1bc8:	0f b6       	in	r0, 0x3f	; 63
    1bca:	f8 94       	cli
    1bcc:	0f 92       	push	r0
    1bce:	f7 01       	movw	r30, r14
    1bd0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bd2:	0f 90       	pop	r0
    1bd4:	0f be       	out	0x3f, r0	; 63
    1bd6:	81 11       	cpse	r24, r1
    1bd8:	1e c0       	rjmp	.+60     	; 0x1c16 <xQueueGenericReceive+0x154>
    1bda:	80 81       	ld	r24, Z
    1bdc:	91 81       	ldd	r25, Z+1	; 0x01
    1bde:	89 2b       	or	r24, r25
    1be0:	49 f4       	brne	.+18     	; 0x1bf4 <xQueueGenericReceive+0x132>
    1be2:	0f b6       	in	r0, 0x3f	; 63
    1be4:	f8 94       	cli
    1be6:	0f 92       	push	r0
    1be8:	82 81       	ldd	r24, Z+2	; 0x02
    1bea:	93 81       	ldd	r25, Z+3	; 0x03
    1bec:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <vTaskPriorityInherit>
    1bf0:	0f 90       	pop	r0
    1bf2:	0f be       	out	0x3f, r0	; 63
    1bf4:	4e 81       	ldd	r20, Y+6	; 0x06
    1bf6:	5f 81       	ldd	r21, Y+7	; 0x07
    1bf8:	68 85       	ldd	r22, Y+8	; 0x08
    1bfa:	79 85       	ldd	r23, Y+9	; 0x09
    1bfc:	c6 01       	movw	r24, r12
    1bfe:	0e 94 62 12 	call	0x24c4	; 0x24c4 <vTaskPlaceOnEventList>
    1c02:	c7 01       	movw	r24, r14
    1c04:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvUnlockQueue>
    1c08:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
    1c0c:	81 11       	cpse	r24, r1
    1c0e:	73 cf       	rjmp	.-282    	; 0x1af6 <xQueueGenericReceive+0x34>
    1c10:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
    1c14:	70 cf       	rjmp	.-288    	; 0x1af6 <xQueueGenericReceive+0x34>
    1c16:	c7 01       	movw	r24, r14
    1c18:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvUnlockQueue>
    1c1c:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
    1c20:	6a cf       	rjmp	.-300    	; 0x1af6 <xQueueGenericReceive+0x34>
    1c22:	c7 01       	movw	r24, r14
    1c24:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvUnlockQueue>
    1c28:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
    1c2c:	80 e0       	ldi	r24, 0x00	; 0
    1c2e:	29 96       	adiw	r28, 0x09	; 9
    1c30:	cd bf       	out	0x3d, r28	; 61
    1c32:	de bf       	out	0x3e, r29	; 62
    1c34:	df 91       	pop	r29
    1c36:	cf 91       	pop	r28
    1c38:	1f 91       	pop	r17
    1c3a:	0f 91       	pop	r16
    1c3c:	ff 90       	pop	r15
    1c3e:	ef 90       	pop	r14
    1c40:	df 90       	pop	r13
    1c42:	cf 90       	pop	r12
    1c44:	bf 90       	pop	r11
    1c46:	af 90       	pop	r10
    1c48:	08 95       	ret

00001c4a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1c4a:	0f b6       	in	r0, 0x3f	; 63
    1c4c:	f8 94       	cli
    1c4e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1c50:	fc 01       	movw	r30, r24
    1c52:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1c54:	0f 90       	pop	r0
    1c56:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1c58:	08 95       	ret

00001c5a <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1c5a:	c6 e0       	ldi	r28, 0x06	; 6
    1c5c:	d1 e3       	ldi	r29, 0x31	; 49
    1c5e:	88 81       	ld	r24, Y
    1c60:	82 30       	cpi	r24, 0x02	; 2
    1c62:	e8 f3       	brcs	.-6      	; 0x1c5e <prvIdleTask+0x4>
    1c64:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
    1c68:	fa cf       	rjmp	.-12     	; 0x1c5e <prvIdleTask+0x4>

00001c6a <prvAddCurrentTaskToDelayedList>:
    1c6a:	cf 92       	push	r12
    1c6c:	df 92       	push	r13
    1c6e:	ef 92       	push	r14
    1c70:	ff 92       	push	r15
    1c72:	6b 01       	movw	r12, r22
    1c74:	7c 01       	movw	r14, r24
    1c76:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1c7a:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1c7e:	62 83       	std	Z+2, r22	; 0x02
    1c80:	73 83       	std	Z+3, r23	; 0x03
    1c82:	84 83       	std	Z+4, r24	; 0x04
    1c84:	95 83       	std	Z+5, r25	; 0x05
    1c86:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1c8a:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1c8e:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1c92:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1c96:	c8 16       	cp	r12, r24
    1c98:	d9 06       	cpc	r13, r25
    1c9a:	ea 06       	cpc	r14, r26
    1c9c:	fb 06       	cpc	r15, r27
    1c9e:	68 f4       	brcc	.+26     	; 0x1cba <prvAddCurrentTaskToDelayedList+0x50>
    1ca0:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    1ca4:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1ca8:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxOverflowDelayedTaskList>
    1cac:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    1cb0:	6e 5f       	subi	r22, 0xFE	; 254
    1cb2:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb4:	0e 94 c0 09 	call	0x1380	; 0x1380 <vListInsert>
    1cb8:	21 c0       	rjmp	.+66     	; 0x1cfc <prvAddCurrentTaskToDelayedList+0x92>
    1cba:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    1cbe:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1cc2:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1cc6:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1cca:	6e 5f       	subi	r22, 0xFE	; 254
    1ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    1cce:	0e 94 c0 09 	call	0x1380	; 0x1380 <vListInsert>
    1cd2:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1cd6:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1cda:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1cde:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1ce2:	c8 16       	cp	r12, r24
    1ce4:	d9 06       	cpc	r13, r25
    1ce6:	ea 06       	cpc	r14, r26
    1ce8:	fb 06       	cpc	r15, r27
    1cea:	40 f4       	brcc	.+16     	; 0x1cfc <prvAddCurrentTaskToDelayedList+0x92>
    1cec:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1cf0:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1cf4:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1cf8:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1cfc:	ff 90       	pop	r15
    1cfe:	ef 90       	pop	r14
    1d00:	df 90       	pop	r13
    1d02:	cf 90       	pop	r12
    1d04:	08 95       	ret

00001d06 <xTaskGenericCreate>:
    1d06:	4f 92       	push	r4
    1d08:	5f 92       	push	r5
    1d0a:	6f 92       	push	r6
    1d0c:	7f 92       	push	r7
    1d0e:	8f 92       	push	r8
    1d10:	9f 92       	push	r9
    1d12:	af 92       	push	r10
    1d14:	bf 92       	push	r11
    1d16:	cf 92       	push	r12
    1d18:	df 92       	push	r13
    1d1a:	ef 92       	push	r14
    1d1c:	ff 92       	push	r15
    1d1e:	0f 93       	push	r16
    1d20:	1f 93       	push	r17
    1d22:	cf 93       	push	r28
    1d24:	df 93       	push	r29
    1d26:	5c 01       	movw	r10, r24
    1d28:	4b 01       	movw	r8, r22
    1d2a:	3a 01       	movw	r6, r20
    1d2c:	29 01       	movw	r4, r18
    1d2e:	88 e2       	ldi	r24, 0x28	; 40
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	0e 94 b2 08 	call	0x1164	; 0x1164 <pvPortMalloc>
    1d36:	ec 01       	movw	r28, r24
    1d38:	89 2b       	or	r24, r25
    1d3a:	09 f4       	brne	.+2      	; 0x1d3e <xTaskGenericCreate+0x38>
    1d3c:	d4 c0       	rjmp	.+424    	; 0x1ee6 <xTaskGenericCreate+0x1e0>
    1d3e:	c1 14       	cp	r12, r1
    1d40:	d1 04       	cpc	r13, r1
    1d42:	09 f0       	breq	.+2      	; 0x1d46 <xTaskGenericCreate+0x40>
    1d44:	cc c0       	rjmp	.+408    	; 0x1ede <xTaskGenericCreate+0x1d8>
    1d46:	c3 01       	movw	r24, r6
    1d48:	0e 94 b2 08 	call	0x1164	; 0x1164 <pvPortMalloc>
    1d4c:	8b 8f       	std	Y+27, r24	; 0x1b
    1d4e:	9c 8f       	std	Y+28, r25	; 0x1c
    1d50:	00 97       	sbiw	r24, 0x00	; 0
    1d52:	21 f4       	brne	.+8      	; 0x1d5c <xTaskGenericCreate+0x56>
    1d54:	ce 01       	movw	r24, r28
    1d56:	0e 94 4c 09 	call	0x1298	; 0x1298 <vPortFree>
    1d5a:	c5 c0       	rjmp	.+394    	; 0x1ee6 <xTaskGenericCreate+0x1e0>
    1d5c:	a3 01       	movw	r20, r6
    1d5e:	61 e1       	ldi	r22, 0x11	; 17
    1d60:	70 e0       	ldi	r23, 0x00	; 0
    1d62:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <memset>
    1d66:	93 01       	movw	r18, r6
    1d68:	21 50       	subi	r18, 0x01	; 1
    1d6a:	31 09       	sbc	r19, r1
    1d6c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d6e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d70:	3c 01       	movw	r6, r24
    1d72:	62 0e       	add	r6, r18
    1d74:	73 1e       	adc	r7, r19
    1d76:	4a e0       	ldi	r20, 0x0A	; 10
    1d78:	50 e0       	ldi	r21, 0x00	; 0
    1d7a:	b4 01       	movw	r22, r8
    1d7c:	ce 01       	movw	r24, r28
    1d7e:	4d 96       	adiw	r24, 0x1d	; 29
    1d80:	0e 94 71 1f 	call	0x3ee2	; 0x3ee2 <strncpy>
    1d84:	1e a2       	std	Y+38, r1	; 0x26
    1d86:	10 2f       	mov	r17, r16
    1d88:	04 30       	cpi	r16, 0x04	; 4
    1d8a:	08 f0       	brcs	.+2      	; 0x1d8e <xTaskGenericCreate+0x88>
    1d8c:	13 e0       	ldi	r17, 0x03	; 3
    1d8e:	1a 8f       	std	Y+26, r17	; 0x1a
    1d90:	1f a3       	std	Y+39, r17	; 0x27
    1d92:	6e 01       	movw	r12, r28
    1d94:	22 e0       	ldi	r18, 0x02	; 2
    1d96:	c2 0e       	add	r12, r18
    1d98:	d1 1c       	adc	r13, r1
    1d9a:	c6 01       	movw	r24, r12
    1d9c:	0e 94 95 09 	call	0x132a	; 0x132a <vListInitialiseItem>
    1da0:	ce 01       	movw	r24, r28
    1da2:	0e 96       	adiw	r24, 0x0e	; 14
    1da4:	0e 94 95 09 	call	0x132a	; 0x132a <vListInitialiseItem>
    1da8:	ca 87       	std	Y+10, r28	; 0x0a
    1daa:	db 87       	std	Y+11, r29	; 0x0b
    1dac:	84 e0       	ldi	r24, 0x04	; 4
    1dae:	90 e0       	ldi	r25, 0x00	; 0
    1db0:	a0 e0       	ldi	r26, 0x00	; 0
    1db2:	b0 e0       	ldi	r27, 0x00	; 0
    1db4:	81 1b       	sub	r24, r17
    1db6:	91 09       	sbc	r25, r1
    1db8:	a1 09       	sbc	r26, r1
    1dba:	b1 09       	sbc	r27, r1
    1dbc:	8e 87       	std	Y+14, r24	; 0x0e
    1dbe:	9f 87       	std	Y+15, r25	; 0x0f
    1dc0:	a8 8b       	std	Y+16, r26	; 0x10
    1dc2:	b9 8b       	std	Y+17, r27	; 0x11
    1dc4:	ce 8b       	std	Y+22, r28	; 0x16
    1dc6:	df 8b       	std	Y+23, r29	; 0x17
    1dc8:	a2 01       	movw	r20, r4
    1dca:	b5 01       	movw	r22, r10
    1dcc:	c3 01       	movw	r24, r6
    1dce:	0e 94 31 0a 	call	0x1462	; 0x1462 <pxPortInitialiseStack>
    1dd2:	88 83       	st	Y, r24
    1dd4:	99 83       	std	Y+1, r25	; 0x01
    1dd6:	e1 14       	cp	r14, r1
    1dd8:	f1 04       	cpc	r15, r1
    1dda:	19 f0       	breq	.+6      	; 0x1de2 <xTaskGenericCreate+0xdc>
    1ddc:	f7 01       	movw	r30, r14
    1dde:	c0 83       	st	Z, r28
    1de0:	d1 83       	std	Z+1, r29	; 0x01
    1de2:	0f b6       	in	r0, 0x3f	; 63
    1de4:	f8 94       	cli
    1de6:	0f 92       	push	r0
    1de8:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1dec:	8f 5f       	subi	r24, 0xFF	; 255
    1dee:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <uxCurrentNumberOfTasks>
    1df2:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1df6:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1dfa:	89 2b       	or	r24, r25
    1dfc:	89 f5       	brne	.+98     	; 0x1e60 <xTaskGenericCreate+0x15a>
    1dfe:	c0 93 32 31 	sts	0x3132, r28	; 0x803132 <pxCurrentTCB>
    1e02:	d0 93 33 31 	sts	0x3133, r29	; 0x803133 <pxCurrentTCB+0x1>
    1e06:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1e0a:	81 30       	cpi	r24, 0x01	; 1
    1e0c:	c1 f5       	brne	.+112    	; 0x1e7e <xTaskGenericCreate+0x178>
    1e0e:	86 e0       	ldi	r24, 0x06	; 6
    1e10:	91 e3       	ldi	r25, 0x31	; 49
    1e12:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    1e16:	81 e1       	ldi	r24, 0x11	; 17
    1e18:	91 e3       	ldi	r25, 0x31	; 49
    1e1a:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    1e1e:	8c e1       	ldi	r24, 0x1C	; 28
    1e20:	91 e3       	ldi	r25, 0x31	; 49
    1e22:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    1e26:	87 e2       	ldi	r24, 0x27	; 39
    1e28:	91 e3       	ldi	r25, 0x31	; 49
    1e2a:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    1e2e:	8b ef       	ldi	r24, 0xFB	; 251
    1e30:	90 e3       	ldi	r25, 0x30	; 48
    1e32:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    1e36:	80 ef       	ldi	r24, 0xF0	; 240
    1e38:	90 e3       	ldi	r25, 0x30	; 48
    1e3a:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    1e3e:	81 ee       	ldi	r24, 0xE1	; 225
    1e40:	90 e3       	ldi	r25, 0x30	; 48
    1e42:	0e 94 84 09 	call	0x1308	; 0x1308 <vListInitialise>
    1e46:	8b ef       	ldi	r24, 0xFB	; 251
    1e48:	90 e3       	ldi	r25, 0x30	; 48
    1e4a:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <pxDelayedTaskList>
    1e4e:	90 93 ef 30 	sts	0x30EF, r25	; 0x8030ef <pxDelayedTaskList+0x1>
    1e52:	80 ef       	ldi	r24, 0xF0	; 240
    1e54:	90 e3       	ldi	r25, 0x30	; 48
    1e56:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxOverflowDelayedTaskList>
    1e5a:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    1e5e:	0f c0       	rjmp	.+30     	; 0x1e7e <xTaskGenericCreate+0x178>
    1e60:	80 91 d7 30 	lds	r24, 0x30D7	; 0x8030d7 <xSchedulerRunning>
    1e64:	81 11       	cpse	r24, r1
    1e66:	0b c0       	rjmp	.+22     	; 0x1e7e <xTaskGenericCreate+0x178>
    1e68:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1e6c:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1e70:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e72:	08 17       	cp	r16, r24
    1e74:	20 f0       	brcs	.+8      	; 0x1e7e <xTaskGenericCreate+0x178>
    1e76:	c0 93 32 31 	sts	0x3132, r28	; 0x803132 <pxCurrentTCB>
    1e7a:	d0 93 33 31 	sts	0x3133, r29	; 0x803133 <pxCurrentTCB+0x1>
    1e7e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e80:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <uxTopUsedPriority>
    1e84:	98 17       	cp	r25, r24
    1e86:	10 f4       	brcc	.+4      	; 0x1e8c <xTaskGenericCreate+0x186>
    1e88:	80 93 d9 30 	sts	0x30D9, r24	; 0x8030d9 <uxTopUsedPriority>
    1e8c:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <uxTaskNumber>
    1e90:	9f 5f       	subi	r25, 0xFF	; 255
    1e92:	90 93 d2 30 	sts	0x30D2, r25	; 0x8030d2 <uxTaskNumber>
    1e96:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    1e9a:	98 17       	cp	r25, r24
    1e9c:	10 f4       	brcc	.+4      	; 0x1ea2 <xTaskGenericCreate+0x19c>
    1e9e:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    1ea2:	fb e0       	ldi	r31, 0x0B	; 11
    1ea4:	8f 9f       	mul	r24, r31
    1ea6:	c0 01       	movw	r24, r0
    1ea8:	11 24       	eor	r1, r1
    1eaa:	b6 01       	movw	r22, r12
    1eac:	8a 5f       	subi	r24, 0xFA	; 250
    1eae:	9e 4c       	sbci	r25, 0xCE	; 206
    1eb0:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
    1eb4:	0f 90       	pop	r0
    1eb6:	0f be       	out	0x3f, r0	; 63
    1eb8:	80 91 d7 30 	lds	r24, 0x30D7	; 0x8030d7 <xSchedulerRunning>
    1ebc:	88 23       	and	r24, r24
    1ebe:	59 f0       	breq	.+22     	; 0x1ed6 <xTaskGenericCreate+0x1d0>
    1ec0:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1ec4:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1ec8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eca:	80 17       	cp	r24, r16
    1ecc:	30 f4       	brcc	.+12     	; 0x1eda <xTaskGenericCreate+0x1d4>
    1ece:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
    1ed2:	81 e0       	ldi	r24, 0x01	; 1
    1ed4:	09 c0       	rjmp	.+18     	; 0x1ee8 <xTaskGenericCreate+0x1e2>
    1ed6:	81 e0       	ldi	r24, 0x01	; 1
    1ed8:	07 c0       	rjmp	.+14     	; 0x1ee8 <xTaskGenericCreate+0x1e2>
    1eda:	81 e0       	ldi	r24, 0x01	; 1
    1edc:	05 c0       	rjmp	.+10     	; 0x1ee8 <xTaskGenericCreate+0x1e2>
    1ede:	cb 8e       	std	Y+27, r12	; 0x1b
    1ee0:	dc 8e       	std	Y+28, r13	; 0x1c
    1ee2:	c6 01       	movw	r24, r12
    1ee4:	3b cf       	rjmp	.-394    	; 0x1d5c <xTaskGenericCreate+0x56>
    1ee6:	8f ef       	ldi	r24, 0xFF	; 255
    1ee8:	df 91       	pop	r29
    1eea:	cf 91       	pop	r28
    1eec:	1f 91       	pop	r17
    1eee:	0f 91       	pop	r16
    1ef0:	ff 90       	pop	r15
    1ef2:	ef 90       	pop	r14
    1ef4:	df 90       	pop	r13
    1ef6:	cf 90       	pop	r12
    1ef8:	bf 90       	pop	r11
    1efa:	af 90       	pop	r10
    1efc:	9f 90       	pop	r9
    1efe:	8f 90       	pop	r8
    1f00:	7f 90       	pop	r7
    1f02:	6f 90       	pop	r6
    1f04:	5f 90       	pop	r5
    1f06:	4f 90       	pop	r4
    1f08:	08 95       	ret

00001f0a <uxTaskPriorityGet>:
    1f0a:	0f b6       	in	r0, 0x3f	; 63
    1f0c:	f8 94       	cli
    1f0e:	0f 92       	push	r0
    1f10:	00 97       	sbiw	r24, 0x00	; 0
    1f12:	21 f4       	brne	.+8      	; 0x1f1c <uxTaskPriorityGet+0x12>
    1f14:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1f18:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1f1c:	0f 90       	pop	r0
    1f1e:	0f be       	out	0x3f, r0	; 63
    1f20:	fc 01       	movw	r30, r24
    1f22:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f24:	08 95       	ret

00001f26 <vTaskStartScheduler>:
    1f26:	af 92       	push	r10
    1f28:	bf 92       	push	r11
    1f2a:	cf 92       	push	r12
    1f2c:	df 92       	push	r13
    1f2e:	ef 92       	push	r14
    1f30:	ff 92       	push	r15
    1f32:	0f 93       	push	r16
    1f34:	a1 2c       	mov	r10, r1
    1f36:	b1 2c       	mov	r11, r1
    1f38:	c1 2c       	mov	r12, r1
    1f3a:	d1 2c       	mov	r13, r1
    1f3c:	0f 2e       	mov	r0, r31
    1f3e:	ff ed       	ldi	r31, 0xDF	; 223
    1f40:	ef 2e       	mov	r14, r31
    1f42:	f0 e3       	ldi	r31, 0x30	; 48
    1f44:	ff 2e       	mov	r15, r31
    1f46:	f0 2d       	mov	r31, r0
    1f48:	00 e0       	ldi	r16, 0x00	; 0
    1f4a:	20 e0       	ldi	r18, 0x00	; 0
    1f4c:	30 e0       	ldi	r19, 0x00	; 0
    1f4e:	44 e6       	ldi	r20, 0x64	; 100
    1f50:	50 e0       	ldi	r21, 0x00	; 0
    1f52:	65 e4       	ldi	r22, 0x45	; 69
    1f54:	70 e2       	ldi	r23, 0x20	; 32
    1f56:	8d e2       	ldi	r24, 0x2D	; 45
    1f58:	9e e0       	ldi	r25, 0x0E	; 14
    1f5a:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <xTaskGenericCreate>
    1f5e:	81 30       	cpi	r24, 0x01	; 1
    1f60:	69 f4       	brne	.+26     	; 0x1f7c <vTaskStartScheduler+0x56>
    1f62:	f8 94       	cli
    1f64:	80 93 d7 30 	sts	0x30D7, r24	; 0x8030d7 <xSchedulerRunning>
    1f68:	10 92 da 30 	sts	0x30DA, r1	; 0x8030da <xTickCount>
    1f6c:	10 92 db 30 	sts	0x30DB, r1	; 0x8030db <xTickCount+0x1>
    1f70:	10 92 dc 30 	sts	0x30DC, r1	; 0x8030dc <xTickCount+0x2>
    1f74:	10 92 dd 30 	sts	0x30DD, r1	; 0x8030dd <xTickCount+0x3>
    1f78:	0e 94 a7 0a 	call	0x154e	; 0x154e <xPortStartScheduler>
    1f7c:	0f 91       	pop	r16
    1f7e:	ff 90       	pop	r15
    1f80:	ef 90       	pop	r14
    1f82:	df 90       	pop	r13
    1f84:	cf 90       	pop	r12
    1f86:	bf 90       	pop	r11
    1f88:	af 90       	pop	r10
    1f8a:	08 95       	ret

00001f8c <vTaskSuspendAll>:
    1f8c:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1f90:	8f 5f       	subi	r24, 0xFF	; 255
    1f92:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxSchedulerSuspended>
    1f96:	08 95       	ret

00001f98 <xTaskGetTickCount>:
    1f98:	0f b6       	in	r0, 0x3f	; 63
    1f9a:	f8 94       	cli
    1f9c:	0f 92       	push	r0
    1f9e:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount>
    1fa2:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x1>
    1fa6:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1faa:	90 91 dd 30 	lds	r25, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1fae:	0f 90       	pop	r0
    1fb0:	0f be       	out	0x3f, r0	; 63
    1fb2:	08 95       	ret

00001fb4 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1fb4:	00 97       	sbiw	r24, 0x00	; 0
    1fb6:	21 f4       	brne	.+8      	; 0x1fc0 <pcTaskGetTaskName+0xc>
    1fb8:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1fbc:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1fc0:	4d 96       	adiw	r24, 0x1d	; 29
    1fc2:	08 95       	ret

00001fc4 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1fc4:	80 91 df 30 	lds	r24, 0x30DF	; 0x8030df <xIdleTaskHandle>
    1fc8:	90 91 e0 30 	lds	r25, 0x30E0	; 0x8030e0 <xIdleTaskHandle+0x1>
    1fcc:	08 95       	ret

00001fce <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1fce:	ff 92       	push	r15
    1fd0:	0f 93       	push	r16
    1fd2:	1f 93       	push	r17
    1fd4:	cf 93       	push	r28
    1fd6:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1fd8:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1fdc:	81 11       	cpse	r24, r1
    1fde:	ed c0       	rjmp	.+474    	; 0x21ba <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    1fe0:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1fe4:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1fe8:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1fec:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1ff0:	01 96       	adiw	r24, 0x01	; 1
    1ff2:	a1 1d       	adc	r26, r1
    1ff4:	b1 1d       	adc	r27, r1
    1ff6:	80 93 da 30 	sts	0x30DA, r24	; 0x8030da <xTickCount>
    1ffa:	90 93 db 30 	sts	0x30DB, r25	; 0x8030db <xTickCount+0x1>
    1ffe:	a0 93 dc 30 	sts	0x30DC, r26	; 0x8030dc <xTickCount+0x2>
    2002:	b0 93 dd 30 	sts	0x30DD, r27	; 0x8030dd <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2006:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    200a:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    200e:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2012:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2016:	89 2b       	or	r24, r25
    2018:	8a 2b       	or	r24, r26
    201a:	8b 2b       	or	r24, r27
    201c:	f1 f5       	brne	.+124    	; 0x209a <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    201e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    2022:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2026:	20 91 ec 30 	lds	r18, 0x30EC	; 0x8030ec <pxOverflowDelayedTaskList>
    202a:	30 91 ed 30 	lds	r19, 0x30ED	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    202e:	20 93 ee 30 	sts	0x30EE, r18	; 0x8030ee <pxDelayedTaskList>
    2032:	30 93 ef 30 	sts	0x30EF, r19	; 0x8030ef <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2036:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxOverflowDelayedTaskList>
    203a:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    203e:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    2042:	8f 5f       	subi	r24, 0xFF	; 255
    2044:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2048:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    204c:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    2050:	80 81       	ld	r24, Z
    2052:	81 11       	cpse	r24, r1
    2054:	0c c0       	rjmp	.+24     	; 0x206e <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2056:	8f ef       	ldi	r24, 0xFF	; 255
    2058:	9f ef       	ldi	r25, 0xFF	; 255
    205a:	dc 01       	movw	r26, r24
    205c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2060:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2064:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2068:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    206c:	16 c0       	rjmp	.+44     	; 0x209a <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    206e:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    2072:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    2076:	07 80       	ldd	r0, Z+7	; 0x07
    2078:	f0 85       	ldd	r31, Z+8	; 0x08
    207a:	e0 2d       	mov	r30, r0
    207c:	00 84       	ldd	r0, Z+8	; 0x08
    207e:	f1 85       	ldd	r31, Z+9	; 0x09
    2080:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2082:	82 81       	ldd	r24, Z+2	; 0x02
    2084:	93 81       	ldd	r25, Z+3	; 0x03
    2086:	a4 81       	ldd	r26, Z+4	; 0x04
    2088:	b5 81       	ldd	r27, Z+5	; 0x05
    208a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    208e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2092:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2096:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    209a:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    209e:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    20a2:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    20a6:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    20aa:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    20ae:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    20b2:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    20b6:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    20ba:	48 17       	cp	r20, r24
    20bc:	59 07       	cpc	r21, r25
    20be:	6a 07       	cpc	r22, r26
    20c0:	7b 07       	cpc	r23, r27
    20c2:	08 f4       	brcc	.+2      	; 0x20c6 <vTaskIncrementTick+0xf8>
    20c4:	7f c0       	rjmp	.+254    	; 0x21c4 <vTaskIncrementTick+0x1f6>
    20c6:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    20ca:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    20ce:	80 81       	ld	r24, Z
    20d0:	88 23       	and	r24, r24
    20d2:	f9 f0       	breq	.+62     	; 0x2112 <vTaskIncrementTick+0x144>
    20d4:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    20d8:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    20dc:	07 80       	ldd	r0, Z+7	; 0x07
    20de:	f0 85       	ldd	r31, Z+8	; 0x08
    20e0:	e0 2d       	mov	r30, r0
    20e2:	c0 85       	ldd	r28, Z+8	; 0x08
    20e4:	d1 85       	ldd	r29, Z+9	; 0x09
    20e6:	8a 81       	ldd	r24, Y+2	; 0x02
    20e8:	9b 81       	ldd	r25, Y+3	; 0x03
    20ea:	ac 81       	ldd	r26, Y+4	; 0x04
    20ec:	bd 81       	ldd	r27, Y+5	; 0x05
    20ee:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    20f2:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    20f6:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    20fa:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    20fe:	48 17       	cp	r20, r24
    2100:	59 07       	cpc	r21, r25
    2102:	6a 07       	cpc	r22, r26
    2104:	7b 07       	cpc	r23, r27
    2106:	58 f1       	brcs	.+86     	; 0x215e <vTaskIncrementTick+0x190>
    2108:	0f 2e       	mov	r0, r31
    210a:	fb e0       	ldi	r31, 0x0B	; 11
    210c:	ff 2e       	mov	r15, r31
    210e:	f0 2d       	mov	r31, r0
    2110:	2f c0       	rjmp	.+94     	; 0x2170 <vTaskIncrementTick+0x1a2>
    2112:	8f ef       	ldi	r24, 0xFF	; 255
    2114:	9f ef       	ldi	r25, 0xFF	; 255
    2116:	dc 01       	movw	r26, r24
    2118:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    211c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2120:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2124:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2128:	4d c0       	rjmp	.+154    	; 0x21c4 <vTaskIncrementTick+0x1f6>
    212a:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    212e:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    2132:	07 80       	ldd	r0, Z+7	; 0x07
    2134:	f0 85       	ldd	r31, Z+8	; 0x08
    2136:	e0 2d       	mov	r30, r0
    2138:	c0 85       	ldd	r28, Z+8	; 0x08
    213a:	d1 85       	ldd	r29, Z+9	; 0x09
    213c:	8a 81       	ldd	r24, Y+2	; 0x02
    213e:	9b 81       	ldd	r25, Y+3	; 0x03
    2140:	ac 81       	ldd	r26, Y+4	; 0x04
    2142:	bd 81       	ldd	r27, Y+5	; 0x05
    2144:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    2148:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    214c:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2150:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2154:	48 17       	cp	r20, r24
    2156:	59 07       	cpc	r21, r25
    2158:	6a 07       	cpc	r22, r26
    215a:	7b 07       	cpc	r23, r27
    215c:	48 f4       	brcc	.+18     	; 0x2170 <vTaskIncrementTick+0x1a2>
    215e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2162:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2166:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    216a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    216e:	2a c0       	rjmp	.+84     	; 0x21c4 <vTaskIncrementTick+0x1f6>
    2170:	8e 01       	movw	r16, r28
    2172:	0e 5f       	subi	r16, 0xFE	; 254
    2174:	1f 4f       	sbci	r17, 0xFF	; 255
    2176:	c8 01       	movw	r24, r16
    2178:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>
    217c:	88 8d       	ldd	r24, Y+24	; 0x18
    217e:	99 8d       	ldd	r25, Y+25	; 0x19
    2180:	89 2b       	or	r24, r25
    2182:	21 f0       	breq	.+8      	; 0x218c <vTaskIncrementTick+0x1be>
    2184:	ce 01       	movw	r24, r28
    2186:	0e 96       	adiw	r24, 0x0e	; 14
    2188:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>
    218c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    218e:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2192:	98 17       	cp	r25, r24
    2194:	10 f4       	brcc	.+4      	; 0x219a <vTaskIncrementTick+0x1cc>
    2196:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    219a:	f8 9e       	mul	r15, r24
    219c:	c0 01       	movw	r24, r0
    219e:	11 24       	eor	r1, r1
    21a0:	b8 01       	movw	r22, r16
    21a2:	8a 5f       	subi	r24, 0xFA	; 250
    21a4:	9e 4c       	sbci	r25, 0xCE	; 206
    21a6:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
    21aa:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    21ae:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    21b2:	80 81       	ld	r24, Z
    21b4:	81 11       	cpse	r24, r1
    21b6:	b9 cf       	rjmp	.-142    	; 0x212a <vTaskIncrementTick+0x15c>
    21b8:	ac cf       	rjmp	.-168    	; 0x2112 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    21ba:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    21be:	8f 5f       	subi	r24, 0xFF	; 255
    21c0:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    21c4:	df 91       	pop	r29
    21c6:	cf 91       	pop	r28
    21c8:	1f 91       	pop	r17
    21ca:	0f 91       	pop	r16
    21cc:	ff 90       	pop	r15
    21ce:	08 95       	ret

000021d0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    21d0:	cf 92       	push	r12
    21d2:	df 92       	push	r13
    21d4:	ef 92       	push	r14
    21d6:	ff 92       	push	r15
    21d8:	0f 93       	push	r16
    21da:	1f 93       	push	r17
    21dc:	cf 93       	push	r28
    21de:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	f8 94       	cli
    21e4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    21e6:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    21ea:	81 50       	subi	r24, 0x01	; 1
    21ec:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21f0:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    21f4:	81 11       	cpse	r24, r1
    21f6:	60 c0       	rjmp	.+192    	; 0x22b8 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    21f8:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    21fc:	81 11       	cpse	r24, r1
    21fe:	2c c0       	rjmp	.+88     	; 0x2258 <xTaskResumeAll+0x88>
    2200:	5e c0       	rjmp	.+188    	; 0x22be <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2202:	d7 01       	movw	r26, r14
    2204:	17 96       	adiw	r26, 0x07	; 7
    2206:	ed 91       	ld	r30, X+
    2208:	fc 91       	ld	r31, X
    220a:	18 97       	sbiw	r26, 0x08	; 8
    220c:	c0 85       	ldd	r28, Z+8	; 0x08
    220e:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2210:	ce 01       	movw	r24, r28
    2212:	0e 96       	adiw	r24, 0x0e	; 14
    2214:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2218:	8e 01       	movw	r16, r28
    221a:	0e 5f       	subi	r16, 0xFE	; 254
    221c:	1f 4f       	sbci	r17, 0xFF	; 255
    221e:	c8 01       	movw	r24, r16
    2220:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2224:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2226:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    222a:	98 17       	cp	r25, r24
    222c:	10 f4       	brcc	.+4      	; 0x2232 <xTaskResumeAll+0x62>
    222e:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    2232:	d8 9e       	mul	r13, r24
    2234:	c0 01       	movw	r24, r0
    2236:	11 24       	eor	r1, r1
    2238:	b8 01       	movw	r22, r16
    223a:	8a 5f       	subi	r24, 0xFA	; 250
    223c:	9e 4c       	sbci	r25, 0xCE	; 206
    223e:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2242:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    2246:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    224a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    224c:	82 8d       	ldd	r24, Z+26	; 0x1a
    224e:	98 17       	cp	r25, r24
    2250:	70 f0       	brcs	.+28     	; 0x226e <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2252:	cc 24       	eor	r12, r12
    2254:	c3 94       	inc	r12
    2256:	0b c0       	rjmp	.+22     	; 0x226e <xTaskResumeAll+0x9e>
    2258:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    225a:	0f 2e       	mov	r0, r31
    225c:	f1 ee       	ldi	r31, 0xE1	; 225
    225e:	ef 2e       	mov	r14, r31
    2260:	f0 e3       	ldi	r31, 0x30	; 48
    2262:	ff 2e       	mov	r15, r31
    2264:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2266:	0f 2e       	mov	r0, r31
    2268:	fb e0       	ldi	r31, 0x0B	; 11
    226a:	df 2e       	mov	r13, r31
    226c:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    226e:	f7 01       	movw	r30, r14
    2270:	80 81       	ld	r24, Z
    2272:	81 11       	cpse	r24, r1
    2274:	c6 cf       	rjmp	.-116    	; 0x2202 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2276:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    227a:	88 23       	and	r24, r24
    227c:	81 f0       	breq	.+32     	; 0x229e <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    227e:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    2282:	88 23       	and	r24, r24
    2284:	99 f0       	breq	.+38     	; 0x22ac <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2286:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskIncrementTick>
						--uxMissedTicks;
    228a:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    228e:	81 50       	subi	r24, 0x01	; 1
    2290:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2294:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    2298:	81 11       	cpse	r24, r1
    229a:	f5 cf       	rjmp	.-22     	; 0x2286 <xTaskResumeAll+0xb6>
    229c:	07 c0       	rjmp	.+14     	; 0x22ac <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    229e:	f1 e0       	ldi	r31, 0x01	; 1
    22a0:	cf 16       	cp	r12, r31
    22a2:	21 f0       	breq	.+8      	; 0x22ac <xTaskResumeAll+0xdc>
    22a4:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <xMissedYield>
    22a8:	81 30       	cpi	r24, 0x01	; 1
    22aa:	41 f4       	brne	.+16     	; 0x22bc <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    22ac:	10 92 d4 30 	sts	0x30D4, r1	; 0x8030d4 <xMissedYield>
					portYIELD_WITHIN_API();
    22b0:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    22b4:	81 e0       	ldi	r24, 0x01	; 1
    22b6:	03 c0       	rjmp	.+6      	; 0x22be <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    22b8:	80 e0       	ldi	r24, 0x00	; 0
    22ba:	01 c0       	rjmp	.+2      	; 0x22be <xTaskResumeAll+0xee>
    22bc:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    22be:	0f 90       	pop	r0
    22c0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	ff 90       	pop	r15
    22cc:	ef 90       	pop	r14
    22ce:	df 90       	pop	r13
    22d0:	cf 90       	pop	r12
    22d2:	08 95       	ret

000022d4 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    22d4:	cf 92       	push	r12
    22d6:	df 92       	push	r13
    22d8:	ef 92       	push	r14
    22da:	ff 92       	push	r15
    22dc:	cf 93       	push	r28
    22de:	df 93       	push	r29
    22e0:	ec 01       	movw	r28, r24
    22e2:	6a 01       	movw	r12, r20
    22e4:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    22e6:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    22ea:	88 81       	ld	r24, Y
    22ec:	99 81       	ldd	r25, Y+1	; 0x01
    22ee:	aa 81       	ldd	r26, Y+2	; 0x02
    22f0:	bb 81       	ldd	r27, Y+3	; 0x03
    22f2:	c8 0e       	add	r12, r24
    22f4:	d9 1e       	adc	r13, r25
    22f6:	ea 1e       	adc	r14, r26
    22f8:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    22fa:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    22fe:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    2302:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2306:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    230a:	48 17       	cp	r20, r24
    230c:	59 07       	cpc	r21, r25
    230e:	6a 07       	cpc	r22, r26
    2310:	7b 07       	cpc	r23, r27
    2312:	b8 f4       	brcc	.+46     	; 0x2342 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2314:	c8 16       	cp	r12, r24
    2316:	d9 06       	cpc	r13, r25
    2318:	ea 06       	cpc	r14, r26
    231a:	fb 06       	cpc	r15, r27
    231c:	e0 f5       	brcc	.+120    	; 0x2396 <vTaskDelayUntil+0xc2>
    231e:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    2322:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2326:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    232a:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    232e:	c8 82       	st	Y, r12
    2330:	d9 82       	std	Y+1, r13	; 0x01
    2332:	ea 82       	std	Y+2, r14	; 0x02
    2334:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2336:	8c 15       	cp	r24, r12
    2338:	9d 05       	cpc	r25, r13
    233a:	ae 05       	cpc	r26, r14
    233c:	bf 05       	cpc	r27, r15
    233e:	f8 f4       	brcc	.+62     	; 0x237e <vTaskDelayUntil+0xaa>
    2340:	13 c0       	rjmp	.+38     	; 0x2368 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2342:	c8 16       	cp	r12, r24
    2344:	d9 06       	cpc	r13, r25
    2346:	ea 06       	cpc	r14, r26
    2348:	fb 06       	cpc	r15, r27
    234a:	00 f1       	brcs	.+64     	; 0x238c <vTaskDelayUntil+0xb8>
    234c:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    2350:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2354:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2358:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    235c:	8c 15       	cp	r24, r12
    235e:	9d 05       	cpc	r25, r13
    2360:	ae 05       	cpc	r26, r14
    2362:	bf 05       	cpc	r27, r15
    2364:	98 f0       	brcs	.+38     	; 0x238c <vTaskDelayUntil+0xb8>
    2366:	17 c0       	rjmp	.+46     	; 0x2396 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2368:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    236c:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2370:	02 96       	adiw	r24, 0x02	; 2
    2372:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2376:	c7 01       	movw	r24, r14
    2378:	b6 01       	movw	r22, r12
    237a:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    237e:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2382:	81 11       	cpse	r24, r1
    2384:	0d c0       	rjmp	.+26     	; 0x23a0 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2386:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
		}
	}
    238a:	0a c0       	rjmp	.+20     	; 0x23a0 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    238c:	c8 82       	st	Y, r12
    238e:	d9 82       	std	Y+1, r13	; 0x01
    2390:	ea 82       	std	Y+2, r14	; 0x02
    2392:	fb 82       	std	Y+3, r15	; 0x03
    2394:	e9 cf       	rjmp	.-46     	; 0x2368 <vTaskDelayUntil+0x94>
    2396:	c8 82       	st	Y, r12
    2398:	d9 82       	std	Y+1, r13	; 0x01
    239a:	ea 82       	std	Y+2, r14	; 0x02
    239c:	fb 82       	std	Y+3, r15	; 0x03
    239e:	ef cf       	rjmp	.-34     	; 0x237e <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    23a0:	df 91       	pop	r29
    23a2:	cf 91       	pop	r28
    23a4:	ff 90       	pop	r15
    23a6:	ef 90       	pop	r14
    23a8:	df 90       	pop	r13
    23aa:	cf 90       	pop	r12
    23ac:	08 95       	ret

000023ae <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    23ae:	cf 92       	push	r12
    23b0:	df 92       	push	r13
    23b2:	ef 92       	push	r14
    23b4:	ff 92       	push	r15
    23b6:	6b 01       	movw	r12, r22
    23b8:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    23ba:	67 2b       	or	r22, r23
    23bc:	68 2b       	or	r22, r24
    23be:	69 2b       	or	r22, r25
    23c0:	e9 f0       	breq	.+58     	; 0x23fc <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    23c2:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    23c6:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    23ca:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    23ce:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    23d2:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    23d6:	c8 0e       	add	r12, r24
    23d8:	d9 1e       	adc	r13, r25
    23da:	ea 1e       	adc	r14, r26
    23dc:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    23de:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    23e2:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    23e6:	02 96       	adiw	r24, 0x02	; 2
    23e8:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    23ec:	c7 01       	movw	r24, r14
    23ee:	b6 01       	movw	r22, r12
    23f0:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    23f4:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    23f8:	81 11       	cpse	r24, r1
    23fa:	02 c0       	rjmp	.+4      	; 0x2400 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    23fc:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vPortYield>
		}
	}
    2400:	ff 90       	pop	r15
    2402:	ef 90       	pop	r14
    2404:	df 90       	pop	r13
    2406:	cf 90       	pop	r12
    2408:	08 95       	ret

0000240a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    240a:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    240e:	81 11       	cpse	r24, r1
    2410:	0c c0       	rjmp	.+24     	; 0x242a <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2412:	e0 91 d8 30 	lds	r30, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2416:	4b e0       	ldi	r20, 0x0B	; 11
    2418:	e4 9f       	mul	r30, r20
    241a:	f0 01       	movw	r30, r0
    241c:	11 24       	eor	r1, r1
    241e:	ea 5f       	subi	r30, 0xFA	; 250
    2420:	fe 4c       	sbci	r31, 0xCE	; 206
    2422:	80 81       	ld	r24, Z
    2424:	88 23       	and	r24, r24
    2426:	29 f0       	breq	.+10     	; 0x2432 <vTaskSwitchContext+0x28>
    2428:	14 c0       	rjmp	.+40     	; 0x2452 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    242a:	81 e0       	ldi	r24, 0x01	; 1
    242c:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <xMissedYield>
    2430:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2432:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2434:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2438:	81 50       	subi	r24, 0x01	; 1
    243a:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    243e:	e0 91 d8 30 	lds	r30, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2442:	9e 9f       	mul	r25, r30
    2444:	f0 01       	movw	r30, r0
    2446:	11 24       	eor	r1, r1
    2448:	ea 5f       	subi	r30, 0xFA	; 250
    244a:	fe 4c       	sbci	r31, 0xCE	; 206
    244c:	80 81       	ld	r24, Z
    244e:	88 23       	and	r24, r24
    2450:	89 f3       	breq	.-30     	; 0x2434 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2452:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2456:	28 2f       	mov	r18, r24
    2458:	30 e0       	ldi	r19, 0x00	; 0
    245a:	4b e0       	ldi	r20, 0x0B	; 11
    245c:	84 9f       	mul	r24, r20
    245e:	c0 01       	movw	r24, r0
    2460:	11 24       	eor	r1, r1
    2462:	dc 01       	movw	r26, r24
    2464:	aa 5f       	subi	r26, 0xFA	; 250
    2466:	be 4c       	sbci	r27, 0xCE	; 206
    2468:	11 96       	adiw	r26, 0x01	; 1
    246a:	ed 91       	ld	r30, X+
    246c:	fc 91       	ld	r31, X
    246e:	12 97       	sbiw	r26, 0x02	; 2
    2470:	04 80       	ldd	r0, Z+4	; 0x04
    2472:	f5 81       	ldd	r31, Z+5	; 0x05
    2474:	e0 2d       	mov	r30, r0
    2476:	11 96       	adiw	r26, 0x01	; 1
    2478:	ed 93       	st	X+, r30
    247a:	fc 93       	st	X, r31
    247c:	12 97       	sbiw	r26, 0x02	; 2
    247e:	87 5f       	subi	r24, 0xF7	; 247
    2480:	9e 4c       	sbci	r25, 0xCE	; 206
    2482:	e8 17       	cp	r30, r24
    2484:	f9 07       	cpc	r31, r25
    2486:	61 f4       	brne	.+24     	; 0x24a0 <vTaskSwitchContext+0x96>
    2488:	84 81       	ldd	r24, Z+4	; 0x04
    248a:	95 81       	ldd	r25, Z+5	; 0x05
    248c:	4b e0       	ldi	r20, 0x0B	; 11
    248e:	42 9f       	mul	r20, r18
    2490:	f0 01       	movw	r30, r0
    2492:	43 9f       	mul	r20, r19
    2494:	f0 0d       	add	r31, r0
    2496:	11 24       	eor	r1, r1
    2498:	ea 5f       	subi	r30, 0xFA	; 250
    249a:	fe 4c       	sbci	r31, 0xCE	; 206
    249c:	81 83       	std	Z+1, r24	; 0x01
    249e:	92 83       	std	Z+2, r25	; 0x02
    24a0:	8b e0       	ldi	r24, 0x0B	; 11
    24a2:	82 9f       	mul	r24, r18
    24a4:	f0 01       	movw	r30, r0
    24a6:	83 9f       	mul	r24, r19
    24a8:	f0 0d       	add	r31, r0
    24aa:	11 24       	eor	r1, r1
    24ac:	ea 5f       	subi	r30, 0xFA	; 250
    24ae:	fe 4c       	sbci	r31, 0xCE	; 206
    24b0:	01 80       	ldd	r0, Z+1	; 0x01
    24b2:	f2 81       	ldd	r31, Z+2	; 0x02
    24b4:	e0 2d       	mov	r30, r0
    24b6:	80 85       	ldd	r24, Z+8	; 0x08
    24b8:	91 85       	ldd	r25, Z+9	; 0x09
    24ba:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <pxCurrentTCB>
    24be:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <pxCurrentTCB+0x1>
    24c2:	08 95       	ret

000024c4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    24c4:	cf 92       	push	r12
    24c6:	df 92       	push	r13
    24c8:	ef 92       	push	r14
    24ca:	ff 92       	push	r15
    24cc:	6a 01       	movw	r12, r20
    24ce:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    24d0:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    24d4:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    24d8:	62 5f       	subi	r22, 0xF2	; 242
    24da:	7f 4f       	sbci	r23, 0xFF	; 255
    24dc:	0e 94 c0 09 	call	0x1380	; 0x1380 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24e0:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    24e4:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    24e8:	02 96       	adiw	r24, 0x02	; 2
    24ea:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    24ee:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    24f2:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    24f6:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    24fa:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    24fe:	bc 01       	movw	r22, r24
    2500:	cd 01       	movw	r24, r26
    2502:	6c 0d       	add	r22, r12
    2504:	7d 1d       	adc	r23, r13
    2506:	8e 1d       	adc	r24, r14
    2508:	9f 1d       	adc	r25, r15
    250a:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    250e:	ff 90       	pop	r15
    2510:	ef 90       	pop	r14
    2512:	df 90       	pop	r13
    2514:	cf 90       	pop	r12
    2516:	08 95       	ret

00002518 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2518:	0f 93       	push	r16
    251a:	1f 93       	push	r17
    251c:	cf 93       	push	r28
    251e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2520:	dc 01       	movw	r26, r24
    2522:	17 96       	adiw	r26, 0x07	; 7
    2524:	ed 91       	ld	r30, X+
    2526:	fc 91       	ld	r31, X
    2528:	18 97       	sbiw	r26, 0x08	; 8
    252a:	c0 85       	ldd	r28, Z+8	; 0x08
    252c:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    252e:	8e 01       	movw	r16, r28
    2530:	02 5f       	subi	r16, 0xF2	; 242
    2532:	1f 4f       	sbci	r17, 0xFF	; 255
    2534:	c8 01       	movw	r24, r16
    2536:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    253a:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    253e:	81 11       	cpse	r24, r1
    2540:	16 c0       	rjmp	.+44     	; 0x256e <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2542:	0c 50       	subi	r16, 0x0C	; 12
    2544:	11 09       	sbc	r17, r1
    2546:	c8 01       	movw	r24, r16
    2548:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    254c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    254e:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2552:	98 17       	cp	r25, r24
    2554:	10 f4       	brcc	.+4      	; 0x255a <xTaskRemoveFromEventList+0x42>
    2556:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    255a:	bb e0       	ldi	r27, 0x0B	; 11
    255c:	8b 9f       	mul	r24, r27
    255e:	c0 01       	movw	r24, r0
    2560:	11 24       	eor	r1, r1
    2562:	b8 01       	movw	r22, r16
    2564:	8a 5f       	subi	r24, 0xFA	; 250
    2566:	9e 4c       	sbci	r25, 0xCE	; 206
    2568:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
    256c:	05 c0       	rjmp	.+10     	; 0x2578 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    256e:	b8 01       	movw	r22, r16
    2570:	81 ee       	ldi	r24, 0xE1	; 225
    2572:	90 e3       	ldi	r25, 0x30	; 48
    2574:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2578:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    257c:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2580:	81 e0       	ldi	r24, 0x01	; 1
    2582:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2584:	92 8d       	ldd	r25, Z+26	; 0x1a
    2586:	29 17       	cp	r18, r25
    2588:	08 f4       	brcc	.+2      	; 0x258c <xTaskRemoveFromEventList+0x74>
    258a:	80 e0       	ldi	r24, 0x00	; 0
}
    258c:	df 91       	pop	r29
    258e:	cf 91       	pop	r28
    2590:	1f 91       	pop	r17
    2592:	0f 91       	pop	r16
    2594:	08 95       	ret

00002596 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2596:	20 91 d3 30 	lds	r18, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    259a:	fc 01       	movw	r30, r24
    259c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    259e:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    25a2:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    25a6:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    25aa:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    25ae:	41 83       	std	Z+1, r20	; 0x01
    25b0:	52 83       	std	Z+2, r21	; 0x02
    25b2:	63 83       	std	Z+3, r22	; 0x03
    25b4:	74 83       	std	Z+4, r23	; 0x04
    25b6:	08 95       	ret

000025b8 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    25b8:	8f 92       	push	r8
    25ba:	9f 92       	push	r9
    25bc:	af 92       	push	r10
    25be:	bf 92       	push	r11
    25c0:	cf 92       	push	r12
    25c2:	df 92       	push	r13
    25c4:	ef 92       	push	r14
    25c6:	ff 92       	push	r15
    25c8:	0f 93       	push	r16
    25ca:	1f 93       	push	r17
    25cc:	cf 93       	push	r28
    25ce:	df 93       	push	r29
    25d0:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    25d2:	0f b6       	in	r0, 0x3f	; 63
    25d4:	f8 94       	cli
    25d6:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    25d8:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    25dc:	90 81       	ld	r25, Z
    25de:	98 17       	cp	r25, r24
    25e0:	89 f0       	breq	.+34     	; 0x2604 <xTaskCheckForTimeOut+0x4c>
    25e2:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    25e6:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    25ea:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    25ee:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    25f2:	01 81       	ldd	r16, Z+1	; 0x01
    25f4:	12 81       	ldd	r17, Z+2	; 0x02
    25f6:	23 81       	ldd	r18, Z+3	; 0x03
    25f8:	34 81       	ldd	r19, Z+4	; 0x04
    25fa:	80 17       	cp	r24, r16
    25fc:	91 07       	cpc	r25, r17
    25fe:	a2 07       	cpc	r26, r18
    2600:	b3 07       	cpc	r27, r19
    2602:	a8 f5       	brcc	.+106    	; 0x266e <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2604:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    2608:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    260c:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2610:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2614:	c1 80       	ldd	r12, Z+1	; 0x01
    2616:	d2 80       	ldd	r13, Z+2	; 0x02
    2618:	e3 80       	ldd	r14, Z+3	; 0x03
    261a:	f4 80       	ldd	r15, Z+4	; 0x04
    261c:	eb 01       	movw	r28, r22
    261e:	08 81       	ld	r16, Y
    2620:	19 81       	ldd	r17, Y+1	; 0x01
    2622:	2a 81       	ldd	r18, Y+2	; 0x02
    2624:	3b 81       	ldd	r19, Y+3	; 0x03
    2626:	8c 19       	sub	r24, r12
    2628:	9d 09       	sbc	r25, r13
    262a:	ae 09       	sbc	r26, r14
    262c:	bf 09       	sbc	r27, r15
    262e:	80 17       	cp	r24, r16
    2630:	91 07       	cpc	r25, r17
    2632:	a2 07       	cpc	r26, r18
    2634:	b3 07       	cpc	r27, r19
    2636:	e8 f4       	brcc	.+58     	; 0x2672 <xTaskCheckForTimeOut+0xba>
    2638:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    263a:	80 90 da 30 	lds	r8, 0x30DA	; 0x8030da <xTickCount>
    263e:	90 90 db 30 	lds	r9, 0x30DB	; 0x8030db <xTickCount+0x1>
    2642:	a0 90 dc 30 	lds	r10, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2646:	b0 90 dd 30 	lds	r11, 0x30DD	; 0x8030dd <xTickCount+0x3>
    264a:	b5 01       	movw	r22, r10
    264c:	a4 01       	movw	r20, r8
    264e:	4c 19       	sub	r20, r12
    2650:	5d 09       	sbc	r21, r13
    2652:	6e 09       	sbc	r22, r14
    2654:	7f 09       	sbc	r23, r15
    2656:	04 1b       	sub	r16, r20
    2658:	15 0b       	sbc	r17, r21
    265a:	26 0b       	sbc	r18, r22
    265c:	37 0b       	sbc	r19, r23
    265e:	08 83       	st	Y, r16
    2660:	19 83       	std	Y+1, r17	; 0x01
    2662:	2a 83       	std	Y+2, r18	; 0x02
    2664:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2666:	0e 94 cb 12 	call	0x2596	; 0x2596 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    266a:	80 e0       	ldi	r24, 0x00	; 0
    266c:	03 c0       	rjmp	.+6      	; 0x2674 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    266e:	81 e0       	ldi	r24, 0x01	; 1
    2670:	01 c0       	rjmp	.+2      	; 0x2674 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2672:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2674:	0f 90       	pop	r0
    2676:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2678:	df 91       	pop	r29
    267a:	cf 91       	pop	r28
    267c:	1f 91       	pop	r17
    267e:	0f 91       	pop	r16
    2680:	ff 90       	pop	r15
    2682:	ef 90       	pop	r14
    2684:	df 90       	pop	r13
    2686:	cf 90       	pop	r12
    2688:	bf 90       	pop	r11
    268a:	af 90       	pop	r10
    268c:	9f 90       	pop	r9
    268e:	8f 90       	pop	r8
    2690:	08 95       	ret

00002692 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2692:	81 e0       	ldi	r24, 0x01	; 1
    2694:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <xMissedYield>
    2698:	08 95       	ret

0000269a <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    269a:	00 97       	sbiw	r24, 0x00	; 0
    269c:	21 f4       	brne	.+8      	; 0x26a6 <uxTaskGetStackHighWaterMark+0xc>
    269e:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    26a2:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    26a6:	dc 01       	movw	r26, r24
    26a8:	5b 96       	adiw	r26, 0x1b	; 27
    26aa:	ed 91       	ld	r30, X+
    26ac:	fc 91       	ld	r31, X
    26ae:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    26b0:	80 81       	ld	r24, Z
    26b2:	81 31       	cpi	r24, 0x11	; 17
    26b4:	41 f4       	brne	.+16     	; 0x26c6 <uxTaskGetStackHighWaterMark+0x2c>
    26b6:	31 96       	adiw	r30, 0x01	; 1
    26b8:	80 e0       	ldi	r24, 0x00	; 0
    26ba:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    26bc:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    26be:	21 91       	ld	r18, Z+
    26c0:	21 31       	cpi	r18, 0x11	; 17
    26c2:	e1 f3       	breq	.-8      	; 0x26bc <uxTaskGetStackHighWaterMark+0x22>
    26c4:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    26c6:	80 e0       	ldi	r24, 0x00	; 0
    26c8:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    26ca:	08 95       	ret

000026cc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    26cc:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    26d0:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>

		return xReturn;
	}
    26d4:	08 95       	ret

000026d6 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    26d6:	0f 93       	push	r16
    26d8:	1f 93       	push	r17
    26da:	cf 93       	push	r28
    26dc:	df 93       	push	r29
    26de:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    26e0:	22 8d       	ldd	r18, Z+26	; 0x1a
    26e2:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    26e6:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    26ea:	5a 96       	adiw	r26, 0x1a	; 26
    26ec:	8c 91       	ld	r24, X
    26ee:	28 17       	cp	r18, r24
    26f0:	08 f0       	brcs	.+2      	; 0x26f4 <vTaskPriorityInherit+0x1e>
    26f2:	41 c0       	rjmp	.+130    	; 0x2776 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    26f4:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    26f8:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    26fc:	5a 96       	adiw	r26, 0x1a	; 26
    26fe:	3c 91       	ld	r19, X
    2700:	84 e0       	ldi	r24, 0x04	; 4
    2702:	90 e0       	ldi	r25, 0x00	; 0
    2704:	a0 e0       	ldi	r26, 0x00	; 0
    2706:	b0 e0       	ldi	r27, 0x00	; 0
    2708:	83 1b       	sub	r24, r19
    270a:	91 09       	sbc	r25, r1
    270c:	a1 09       	sbc	r26, r1
    270e:	b1 09       	sbc	r27, r1
    2710:	86 87       	std	Z+14, r24	; 0x0e
    2712:	97 87       	std	Z+15, r25	; 0x0f
    2714:	a0 8b       	std	Z+16, r26	; 0x10
    2716:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2718:	8b e0       	ldi	r24, 0x0B	; 11
    271a:	28 9f       	mul	r18, r24
    271c:	90 01       	movw	r18, r0
    271e:	11 24       	eor	r1, r1
    2720:	2a 5f       	subi	r18, 0xFA	; 250
    2722:	3e 4c       	sbci	r19, 0xCE	; 206
    2724:	84 85       	ldd	r24, Z+12	; 0x0c
    2726:	95 85       	ldd	r25, Z+13	; 0x0d
    2728:	82 17       	cp	r24, r18
    272a:	93 07       	cpc	r25, r19
    272c:	e9 f4       	brne	.+58     	; 0x2768 <vTaskPriorityInherit+0x92>
    272e:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2730:	ef 01       	movw	r28, r30
    2732:	22 96       	adiw	r28, 0x02	; 2
    2734:	ce 01       	movw	r24, r28
    2736:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    273a:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    273e:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2742:	82 8d       	ldd	r24, Z+26	; 0x1a
    2744:	f8 01       	movw	r30, r16
    2746:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2748:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    274c:	98 17       	cp	r25, r24
    274e:	10 f4       	brcc	.+4      	; 0x2754 <vTaskPriorityInherit+0x7e>
    2750:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    2754:	fb e0       	ldi	r31, 0x0B	; 11
    2756:	8f 9f       	mul	r24, r31
    2758:	c0 01       	movw	r24, r0
    275a:	11 24       	eor	r1, r1
    275c:	be 01       	movw	r22, r28
    275e:	8a 5f       	subi	r24, 0xFA	; 250
    2760:	9e 4c       	sbci	r25, 0xCE	; 206
    2762:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
    2766:	07 c0       	rjmp	.+14     	; 0x2776 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2768:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    276c:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2770:	5a 96       	adiw	r26, 0x1a	; 26
    2772:	8c 91       	ld	r24, X
    2774:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2776:	df 91       	pop	r29
    2778:	cf 91       	pop	r28
    277a:	1f 91       	pop	r17
    277c:	0f 91       	pop	r16
    277e:	08 95       	ret

00002780 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2780:	0f 93       	push	r16
    2782:	1f 93       	push	r17
    2784:	cf 93       	push	r28
    2786:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2788:	00 97       	sbiw	r24, 0x00	; 0
    278a:	49 f1       	breq	.+82     	; 0x27de <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    278c:	fc 01       	movw	r30, r24
    278e:	32 8d       	ldd	r19, Z+26	; 0x1a
    2790:	27 a1       	ldd	r18, Z+39	; 0x27
    2792:	32 17       	cp	r19, r18
    2794:	21 f1       	breq	.+72     	; 0x27de <vTaskPriorityDisinherit+0x5e>
    2796:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2798:	8c 01       	movw	r16, r24
    279a:	0e 5f       	subi	r16, 0xFE	; 254
    279c:	1f 4f       	sbci	r17, 0xFF	; 255
    279e:	c8 01       	movw	r24, r16
    27a0:	0e 94 0b 0a 	call	0x1416	; 0x1416 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    27a4:	8f a1       	ldd	r24, Y+39	; 0x27
    27a6:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    27a8:	44 e0       	ldi	r20, 0x04	; 4
    27aa:	50 e0       	ldi	r21, 0x00	; 0
    27ac:	60 e0       	ldi	r22, 0x00	; 0
    27ae:	70 e0       	ldi	r23, 0x00	; 0
    27b0:	48 1b       	sub	r20, r24
    27b2:	51 09       	sbc	r21, r1
    27b4:	61 09       	sbc	r22, r1
    27b6:	71 09       	sbc	r23, r1
    27b8:	4e 87       	std	Y+14, r20	; 0x0e
    27ba:	5f 87       	std	Y+15, r21	; 0x0f
    27bc:	68 8b       	std	Y+16, r22	; 0x10
    27be:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    27c0:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    27c4:	98 17       	cp	r25, r24
    27c6:	10 f4       	brcc	.+4      	; 0x27cc <vTaskPriorityDisinherit+0x4c>
    27c8:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    27cc:	fb e0       	ldi	r31, 0x0B	; 11
    27ce:	8f 9f       	mul	r24, r31
    27d0:	c0 01       	movw	r24, r0
    27d2:	11 24       	eor	r1, r1
    27d4:	b8 01       	movw	r22, r16
    27d6:	8a 5f       	subi	r24, 0xFA	; 250
    27d8:	9e 4c       	sbci	r25, 0xCE	; 206
    27da:	0e 94 99 09 	call	0x1332	; 0x1332 <vListInsertEnd>
			}
		}
	}
    27de:	df 91       	pop	r29
    27e0:	cf 91       	pop	r28
    27e2:	1f 91       	pop	r17
    27e4:	0f 91       	pop	r16
    27e6:	08 95       	ret

000027e8 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    27e8:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    27ea:	e8 81       	ld	r30, Y
    27ec:	f9 81       	ldd	r31, Y+1	; 0x01
    27ee:	01 90       	ld	r0, Z+
    27f0:	f0 81       	ld	r31, Z
    27f2:	e0 2d       	mov	r30, r0
    27f4:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    27f6:	1a 82       	std	Y+2, r1	; 0x02
    27f8:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    27fa:	6f ef       	ldi	r22, 0xFF	; 255
    27fc:	7f ef       	ldi	r23, 0xFF	; 255
    27fe:	cb 01       	movw	r24, r22
    2800:	0e 94 d7 11 	call	0x23ae	; 0x23ae <vTaskDelay>
    2804:	fa cf       	rjmp	.-12     	; 0x27fa <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002806 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2806:	fc 01       	movw	r30, r24
    2808:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    280a:	65 87       	std	Z+13, r22	; 0x0d
    280c:	08 95       	ret

0000280e <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    280e:	4f 92       	push	r4
    2810:	5f 92       	push	r5
    2812:	6f 92       	push	r6
    2814:	7f 92       	push	r7
    2816:	8f 92       	push	r8
    2818:	9f 92       	push	r9
    281a:	af 92       	push	r10
    281c:	bf 92       	push	r11
    281e:	cf 92       	push	r12
    2820:	df 92       	push	r13
    2822:	ef 92       	push	r14
    2824:	ff 92       	push	r15
    2826:	0f 93       	push	r16
    2828:	1f 93       	push	r17
    282a:	cf 93       	push	r28
    282c:	df 93       	push	r29
    282e:	cd b7       	in	r28, 0x3d	; 61
    2830:	de b7       	in	r29, 0x3e	; 62
    2832:	2a 97       	sbiw	r28, 0x0a	; 10
    2834:	cd bf       	out	0x3d, r28	; 61
    2836:	de bf       	out	0x3e, r29	; 62
    2838:	4c 01       	movw	r8, r24
    283a:	29 01       	movw	r4, r18
    283c:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    283e:	8e e4       	ldi	r24, 0x4E	; 78
    2840:	90 e2       	ldi	r25, 0x20	; 32
    2842:	f4 01       	movw	r30, r8
    2844:	80 83       	st	Z, r24
    2846:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2848:	fb 01       	movw	r30, r22
    284a:	80 81       	ld	r24, Z
    284c:	88 23       	and	r24, r24
    284e:	69 f0       	breq	.+26     	; 0x286a <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2850:	de 01       	movw	r26, r28
    2852:	11 96       	adiw	r26, 0x01	; 1
    2854:	31 96       	adiw	r30, 0x01	; 1
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	02 c0       	rjmp	.+4      	; 0x285e <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    285a:	99 30       	cpi	r25, 0x09	; 9
    285c:	39 f0       	breq	.+14     	; 0x286c <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    285e:	9f 5f       	subi	r25, 0xFF	; 255
    2860:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2862:	81 91       	ld	r24, Z+
    2864:	81 11       	cpse	r24, r1
    2866:	f9 cf       	rjmp	.-14     	; 0x285a <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2868:	01 c0       	rjmp	.+2      	; 0x286c <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    286a:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    286c:	e1 e0       	ldi	r30, 0x01	; 1
    286e:	f0 e0       	ldi	r31, 0x00	; 0
    2870:	ec 0f       	add	r30, r28
    2872:	fd 1f       	adc	r31, r29
    2874:	e9 0f       	add	r30, r25
    2876:	f1 1d       	adc	r31, r1
    2878:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    287a:	74 01       	movw	r14, r8
    287c:	f2 e0       	ldi	r31, 0x02	; 2
    287e:	ef 0e       	add	r14, r31
    2880:	f1 1c       	adc	r15, r1
    2882:	a1 2c       	mov	r10, r1
    2884:	b1 2c       	mov	r11, r1
    2886:	c1 2c       	mov	r12, r1
    2888:	d1 2c       	mov	r13, r1
    288a:	04 2f       	mov	r16, r20
    288c:	94 01       	movw	r18, r8
    288e:	a2 01       	movw	r20, r4
    2890:	be 01       	movw	r22, r28
    2892:	6f 5f       	subi	r22, 0xFF	; 255
    2894:	7f 4f       	sbci	r23, 0xFF	; 255
    2896:	86 ea       	ldi	r24, 0xA6	; 166
    2898:	92 e0       	ldi	r25, 0x02	; 2
    289a:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    289e:	f4 01       	movw	r30, r8
    28a0:	66 82       	std	Z+6, r6	; 0x06
    28a2:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    28a4:	40 86       	std	Z+8, r4	; 0x08
    28a6:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    28a8:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <last_created_task_pointer>
    28ac:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    28b0:	24 83       	std	Z+4, r18	; 0x04
    28b2:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    28b4:	80 92 34 31 	sts	0x3134, r8	; 0x803134 <last_created_task_pointer>
    28b8:	90 92 35 31 	sts	0x3135, r9	; 0x803135 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    28bc:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    28be:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    28c0:	40 90 6e 31 	lds	r4, 0x316E	; 0x80316e <portStackTopForTask>
    28c4:	50 90 6f 31 	lds	r5, 0x316F	; 0x80316f <portStackTopForTask+0x1>
    28c8:	ff ef       	ldi	r31, 0xFF	; 255
    28ca:	4f 1a       	sub	r4, r31
    28cc:	5f 0a       	sbc	r5, r31
    28ce:	40 92 6e 31 	sts	0x316E, r4	; 0x80316e <portStackTopForTask>
    28d2:	50 92 6f 31 	sts	0x316F, r5	; 0x80316f <portStackTopForTask+0x1>
    28d6:	f4 01       	movw	r30, r8
    28d8:	42 86       	std	Z+10, r4	; 0x0a
    28da:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    28dc:	16 86       	std	Z+14, r1	; 0x0e
    28de:	17 86       	std	Z+15, r1	; 0x0f
    28e0:	10 8a       	std	Z+16, r1	; 0x10
    28e2:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    28e4:	61 14       	cp	r6, r1
    28e6:	71 04       	cpc	r7, r1
    28e8:	09 f4       	brne	.+2      	; 0x28ec <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    28ea:	44 c0       	rjmp	.+136    	; 0x2974 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    28ec:	81 30       	cpi	r24, 0x01	; 1
    28ee:	79 f5       	brne	.+94     	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    28f0:	6a e0       	ldi	r22, 0x0A	; 10
    28f2:	c3 01       	movw	r24, r6
    28f4:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    28f8:	7c 01       	movw	r14, r24
    28fa:	69 e9       	ldi	r22, 0x99	; 153
    28fc:	74 e0       	ldi	r23, 0x04	; 4
    28fe:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2902:	be 01       	movw	r22, r28
    2904:	6f 5f       	subi	r22, 0xFF	; 255
    2906:	7f 4f       	sbci	r23, 0xFF	; 255
    2908:	c7 01       	movw	r24, r14
    290a:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    290e:	6a e0       	ldi	r22, 0x0A	; 10
    2910:	c7 01       	movw	r24, r14
    2912:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2916:	7c 01       	movw	r14, r24
    2918:	60 e9       	ldi	r22, 0x90	; 144
    291a:	74 e0       	ldi	r23, 0x04	; 4
    291c:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2920:	6a e0       	ldi	r22, 0x0A	; 10
    2922:	c7 01       	movw	r24, r14
    2924:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2928:	7c 01       	movw	r14, r24
    292a:	62 e8       	ldi	r22, 0x82	; 130
    292c:	74 e0       	ldi	r23, 0x04	; 4
    292e:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2932:	63 e0       	ldi	r22, 0x03	; 3
    2934:	c7 01       	movw	r24, r14
    2936:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    293a:	b2 01       	movw	r22, r4
    293c:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <_ZN8emstreamlsEj>
    2940:	62 e0       	ldi	r22, 0x02	; 2
    2942:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2946:	66 e0       	ldi	r22, 0x06	; 6
    2948:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    294c:	13 c0       	rjmp	.+38     	; 0x2974 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    294e:	6a e0       	ldi	r22, 0x0A	; 10
    2950:	c3 01       	movw	r24, r6
    2952:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2956:	4c 01       	movw	r8, r24
    2958:	6d e6       	ldi	r22, 0x6D	; 109
    295a:	74 e0       	ldi	r23, 0x04	; 4
    295c:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2960:	be 01       	movw	r22, r28
    2962:	6f 5f       	subi	r22, 0xFF	; 255
    2964:	7f 4f       	sbci	r23, 0xFF	; 255
    2966:	c4 01       	movw	r24, r8
    2968:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    296c:	66 e0       	ldi	r22, 0x06	; 6
    296e:	c4 01       	movw	r24, r8
    2970:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2974:	2a 96       	adiw	r28, 0x0a	; 10
    2976:	cd bf       	out	0x3d, r28	; 61
    2978:	de bf       	out	0x3e, r29	; 62
    297a:	df 91       	pop	r29
    297c:	cf 91       	pop	r28
    297e:	1f 91       	pop	r17
    2980:	0f 91       	pop	r16
    2982:	ff 90       	pop	r15
    2984:	ef 90       	pop	r14
    2986:	df 90       	pop	r13
    2988:	cf 90       	pop	r12
    298a:	bf 90       	pop	r11
    298c:	af 90       	pop	r10
    298e:	9f 90       	pop	r9
    2990:	8f 90       	pop	r8
    2992:	7f 90       	pop	r7
    2994:	6f 90       	pop	r6
    2996:	5f 90       	pop	r5
    2998:	4f 90       	pop	r4
    299a:	08 95       	ret

0000299c <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    299c:	cf 92       	push	r12
    299e:	df 92       	push	r13
    29a0:	ef 92       	push	r14
    29a2:	ff 92       	push	r15
    29a4:	0f 93       	push	r16
    29a6:	1f 93       	push	r17
    29a8:	cf 93       	push	r28
    29aa:	df 93       	push	r29
    29ac:	ec 01       	movw	r28, r24
    29ae:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    29b0:	8a 81       	ldd	r24, Y+2	; 0x02
    29b2:	9b 81       	ldd	r25, Y+3	; 0x03
    29b4:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <pcTaskGetTaskName>
    29b8:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    29ba:	6a e0       	ldi	r22, 0x0A	; 10
    29bc:	c7 01       	movw	r24, r14
    29be:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    29c2:	8c 01       	movw	r16, r24
    29c4:	6c ea       	ldi	r22, 0xAC	; 172
    29c6:	74 e0       	ldi	r23, 0x04	; 4
    29c8:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    29cc:	6a e0       	ldi	r22, 0x0A	; 10
    29ce:	c8 01       	movw	r24, r16
    29d0:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    29d4:	8c 01       	movw	r16, r24
    29d6:	65 ea       	ldi	r22, 0xA5	; 165
    29d8:	74 e0       	ldi	r23, 0x04	; 4
    29da:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    29de:	b6 01       	movw	r22, r12
    29e0:	c8 01       	movw	r24, r16
    29e2:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    29e6:	6a e0       	ldi	r22, 0x0A	; 10
    29e8:	c8 01       	movw	r24, r16
    29ea:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    29ee:	8c 01       	movw	r16, r24
    29f0:	6f e9       	ldi	r22, 0x9F	; 159
    29f2:	74 e0       	ldi	r23, 0x04	; 4
    29f4:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    29f8:	66 e0       	ldi	r22, 0x06	; 6
    29fa:	c8 01       	movw	r24, r16
    29fc:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2a00:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a02:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a04:	e8 85       	ldd	r30, Y+8	; 0x08
    2a06:	f9 85       	ldd	r31, Y+9	; 0x09
    2a08:	01 e1       	ldi	r16, 0x11	; 17
    2a0a:	21 e0       	ldi	r18, 0x01	; 1
    2a0c:	a7 01       	movw	r20, r14
    2a0e:	bc 01       	movw	r22, r24
    2a10:	8e 1b       	sub	r24, r30
    2a12:	9f 0b       	sbc	r25, r31
    2a14:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2a18:	8c 81       	ldd	r24, Y+4	; 0x04
    2a1a:	9d 81       	ldd	r25, Y+5	; 0x05
    2a1c:	00 97       	sbiw	r24, 0x00	; 0
    2a1e:	19 f0       	breq	.+6      	; 0x2a26 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2a20:	b7 01       	movw	r22, r14
    2a22:	0e 94 ce 14 	call	0x299c	; 0x299c <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2a26:	df 91       	pop	r29
    2a28:	cf 91       	pop	r28
    2a2a:	1f 91       	pop	r17
    2a2c:	0f 91       	pop	r16
    2a2e:	ff 90       	pop	r15
    2a30:	ef 90       	pop	r14
    2a32:	df 90       	pop	r13
    2a34:	cf 90       	pop	r12
    2a36:	08 95       	ret

00002a38 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2a38:	0f 93       	push	r16
    2a3a:	1f 93       	push	r17
    2a3c:	cf 93       	push	r28
    2a3e:	df 93       	push	r29
    2a40:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2a42:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <last_created_task_pointer>
    2a46:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    2a4a:	00 97       	sbiw	r24, 0x00	; 0
    2a4c:	19 f0       	breq	.+6      	; 0x2a54 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2a4e:	be 01       	movw	r22, r28
    2a50:	0e 94 ce 14 	call	0x299c	; 0x299c <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2a54:	6a e0       	ldi	r22, 0x0A	; 10
    2a56:	ce 01       	movw	r24, r28
    2a58:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2a5c:	8c 01       	movw	r16, r24
    2a5e:	62 ec       	ldi	r22, 0xC2	; 194
    2a60:	74 e0       	ldi	r23, 0x04	; 4
    2a62:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2a66:	6a e0       	ldi	r22, 0x0A	; 10
    2a68:	c8 01       	movw	r24, r16
    2a6a:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2a6e:	8c 01       	movw	r16, r24
    2a70:	67 eb       	ldi	r22, 0xB7	; 183
    2a72:	74 e0       	ldi	r23, 0x04	; 4
    2a74:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2a78:	6a e0       	ldi	r22, 0x0A	; 10
    2a7a:	c8 01       	movw	r24, r16
    2a7c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2a80:	8c 01       	movw	r16, r24
    2a82:	61 eb       	ldi	r22, 0xB1	; 177
    2a84:	74 e0       	ldi	r23, 0x04	; 4
    2a86:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2a8a:	66 e0       	ldi	r22, 0x06	; 6
    2a8c:	c8 01       	movw	r24, r16
    2a8e:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2a92:	80 91 6e 31 	lds	r24, 0x316E	; 0x80316e <portStackTopForTask>
    2a96:	90 91 6f 31 	lds	r25, 0x316F	; 0x80316f <portStackTopForTask+0x1>
    2a9a:	bc 01       	movw	r22, r24
    2a9c:	6f 5f       	subi	r22, 0xFF	; 255
    2a9e:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa0:	01 e1       	ldi	r16, 0x11	; 17
    2aa2:	21 e0       	ldi	r18, 0x01	; 1
    2aa4:	ae 01       	movw	r20, r28
    2aa6:	83 56       	subi	r24, 0x63	; 99
    2aa8:	91 09       	sbc	r25, r1
    2aaa:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2aae:	df 91       	pop	r29
    2ab0:	cf 91       	pop	r28
    2ab2:	1f 91       	pop	r17
    2ab4:	0f 91       	pop	r16
    2ab6:	08 95       	ret

00002ab8 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2ab8:	8f 92       	push	r8
    2aba:	9f 92       	push	r9
    2abc:	af 92       	push	r10
    2abe:	bf 92       	push	r11
    2ac0:	cf 92       	push	r12
    2ac2:	df 92       	push	r13
    2ac4:	ef 92       	push	r14
    2ac6:	ff 92       	push	r15
    2ac8:	0f 93       	push	r16
    2aca:	1f 93       	push	r17
    2acc:	cf 93       	push	r28
    2ace:	df 93       	push	r29
    2ad0:	ec 01       	movw	r28, r24
    2ad2:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2ad4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad8:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <pcTaskGetTaskName>
    2adc:	bc 01       	movw	r22, r24
    2ade:	c8 01       	movw	r24, r16
    2ae0:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2ae4:	d8 01       	movw	r26, r16
    2ae6:	ed 91       	ld	r30, X+
    2ae8:	fc 91       	ld	r31, X
    2aea:	02 80       	ldd	r0, Z+2	; 0x02
    2aec:	f3 81       	ldd	r31, Z+3	; 0x03
    2aee:	e0 2d       	mov	r30, r0
    2af0:	69 e0       	ldi	r22, 0x09	; 9
    2af2:	c8 01       	movw	r24, r16
    2af4:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2af6:	8a 81       	ldd	r24, Y+2	; 0x02
    2af8:	9b 81       	ldd	r25, Y+3	; 0x03
    2afa:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <pcTaskGetTaskName>
    2afe:	fc 01       	movw	r30, r24
    2b00:	01 90       	ld	r0, Z+
    2b02:	00 20       	and	r0, r0
    2b04:	e9 f7       	brne	.-6      	; 0x2b00 <_ZN8frt_task12print_statusER8emstream+0x48>
    2b06:	31 97       	sbiw	r30, 0x01	; 1
    2b08:	e8 1b       	sub	r30, r24
    2b0a:	f9 0b       	sbc	r31, r25
    2b0c:	38 97       	sbiw	r30, 0x08	; 8
    2b0e:	48 f4       	brcc	.+18     	; 0x2b22 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2b10:	d8 01       	movw	r26, r16
    2b12:	ed 91       	ld	r30, X+
    2b14:	fc 91       	ld	r31, X
    2b16:	02 80       	ldd	r0, Z+2	; 0x02
    2b18:	f3 81       	ldd	r31, Z+3	; 0x03
    2b1a:	e0 2d       	mov	r30, r0
    2b1c:	69 e0       	ldi	r22, 0x09	; 9
    2b1e:	c8 01       	movw	r24, r16
    2b20:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2b22:	ce 84       	ldd	r12, Y+14	; 0x0e
    2b24:	df 84       	ldd	r13, Y+15	; 0x0f
    2b26:	e8 88       	ldd	r14, Y+16	; 0x10
    2b28:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2b2a:	a8 84       	ldd	r10, Y+8	; 0x08
    2b2c:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2b2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2b30:	9b 81       	ldd	r25, Y+3	; 0x03
    2b32:	0e 94 4d 13 	call	0x269a	; 0x269a <uxTaskGetStackHighWaterMark>
    2b36:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2b38:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2b3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b3c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b3e:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <uxTaskPriorityGet>
    2b42:	68 2f       	mov	r22, r24
    2b44:	c8 01       	movw	r24, r16
    2b46:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
    2b4a:	6a e0       	ldi	r22, 0x0A	; 10
    2b4c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2b50:	ec 01       	movw	r28, r24
    2b52:	67 e3       	ldi	r22, 0x37	; 55
    2b54:	75 e0       	ldi	r23, 0x05	; 5
    2b56:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2b5a:	68 2d       	mov	r22, r8
    2b5c:	ce 01       	movw	r24, r28
    2b5e:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2b62:	6a e0       	ldi	r22, 0x0A	; 10
    2b64:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2b68:	ec 01       	movw	r28, r24
    2b6a:	65 e3       	ldi	r22, 0x35	; 53
    2b6c:	75 e0       	ldi	r23, 0x05	; 5
    2b6e:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2b72:	69 2d       	mov	r22, r9
    2b74:	ce 01       	movw	r24, r28
    2b76:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
    2b7a:	6a e0       	ldi	r22, 0x0A	; 10
    2b7c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2b80:	ec 01       	movw	r28, r24
    2b82:	63 e3       	ldi	r22, 0x33	; 51
    2b84:	75 e0       	ldi	r23, 0x05	; 5
    2b86:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2b8a:	b5 01       	movw	r22, r10
    2b8c:	ce 01       	movw	r24, r28
    2b8e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <_ZN8emstreamlsEj>
    2b92:	6a e0       	ldi	r22, 0x0A	; 10
    2b94:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2b98:	ec 01       	movw	r28, r24
    2b9a:	61 e3       	ldi	r22, 0x31	; 49
    2b9c:	75 e0       	ldi	r23, 0x05	; 5
    2b9e:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2ba2:	6a e0       	ldi	r22, 0x0A	; 10
    2ba4:	ce 01       	movw	r24, r28
    2ba6:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2baa:	ec 01       	movw	r28, r24
    2bac:	6f e2       	ldi	r22, 0x2F	; 47
    2bae:	75 e0       	ldi	r23, 0x05	; 5
    2bb0:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2bb4:	b7 01       	movw	r22, r14
    2bb6:	a6 01       	movw	r20, r12
    2bb8:	ce 01       	movw	r24, r28
    2bba:	0e 94 15 1a 	call	0x342a	; 0x342a <_ZN8emstreamlsEm>
}
    2bbe:	df 91       	pop	r29
    2bc0:	cf 91       	pop	r28
    2bc2:	1f 91       	pop	r17
    2bc4:	0f 91       	pop	r16
    2bc6:	ff 90       	pop	r15
    2bc8:	ef 90       	pop	r14
    2bca:	df 90       	pop	r13
    2bcc:	cf 90       	pop	r12
    2bce:	bf 90       	pop	r11
    2bd0:	af 90       	pop	r10
    2bd2:	9f 90       	pop	r9
    2bd4:	8f 90       	pop	r8
    2bd6:	08 95       	ret

00002bd8 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2bd8:	cf 93       	push	r28
    2bda:	df 93       	push	r29
    2bdc:	ec 01       	movw	r28, r24
    2bde:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2be0:	db 01       	movw	r26, r22
    2be2:	ed 91       	ld	r30, X+
    2be4:	fc 91       	ld	r31, X
    2be6:	02 80       	ldd	r0, Z+2	; 0x02
    2be8:	f3 81       	ldd	r31, Z+3	; 0x03
    2bea:	e0 2d       	mov	r30, r0
    2bec:	be 01       	movw	r22, r28
    2bee:	19 95       	eicall
	return (ser_dev);
}
    2bf0:	ce 01       	movw	r24, r28
    2bf2:	df 91       	pop	r29
    2bf4:	cf 91       	pop	r28
    2bf6:	08 95       	ret

00002bf8 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2bf8:	0f 93       	push	r16
    2bfa:	1f 93       	push	r17
    2bfc:	cf 93       	push	r28
    2bfe:	df 93       	push	r29
    2c00:	ec 01       	movw	r28, r24
    2c02:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2c04:	bc 01       	movw	r22, r24
    2c06:	c8 01       	movw	r24, r16
    2c08:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <_ZlsR8emstreamR8frt_task>
    2c0c:	66 e0       	ldi	r22, 0x06	; 6
    2c0e:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2c12:	8c 81       	ldd	r24, Y+4	; 0x04
    2c14:	9d 81       	ldd	r25, Y+5	; 0x05
    2c16:	00 97       	sbiw	r24, 0x00	; 0
    2c18:	19 f0       	breq	.+6      	; 0x2c20 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2c1a:	b8 01       	movw	r22, r16
    2c1c:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2c20:	df 91       	pop	r29
    2c22:	cf 91       	pop	r28
    2c24:	1f 91       	pop	r17
    2c26:	0f 91       	pop	r16
    2c28:	08 95       	ret

00002c2a <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2c2a:	0f 93       	push	r16
    2c2c:	1f 93       	push	r17
    2c2e:	cf 93       	push	r28
    2c30:	df 93       	push	r29
    2c32:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2c34:	6a e0       	ldi	r22, 0x0A	; 10
    2c36:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2c3a:	8c 01       	movw	r16, r24
    2c3c:	64 e2       	ldi	r22, 0x24	; 36
    2c3e:	75 e0       	ldi	r23, 0x05	; 5
    2c40:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2c44:	6a e0       	ldi	r22, 0x0A	; 10
    2c46:	c8 01       	movw	r24, r16
    2c48:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2c4c:	8c 01       	movw	r16, r24
    2c4e:	6d e1       	ldi	r22, 0x1D	; 29
    2c50:	75 e0       	ldi	r23, 0x05	; 5
    2c52:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2c56:	66 e0       	ldi	r22, 0x06	; 6
    2c58:	c8 01       	movw	r24, r16
    2c5a:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2c5e:	6a e0       	ldi	r22, 0x0A	; 10
    2c60:	ce 01       	movw	r24, r28
    2c62:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2c66:	8c 01       	movw	r16, r24
    2c68:	6c e0       	ldi	r22, 0x0C	; 12
    2c6a:	75 e0       	ldi	r23, 0x05	; 5
    2c6c:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2c70:	6a e0       	ldi	r22, 0x0A	; 10
    2c72:	c8 01       	movw	r24, r16
    2c74:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2c78:	8c 01       	movw	r16, r24
    2c7a:	60 e0       	ldi	r22, 0x00	; 0
    2c7c:	75 e0       	ldi	r23, 0x05	; 5
    2c7e:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2c82:	6a e0       	ldi	r22, 0x0A	; 10
    2c84:	c8 01       	movw	r24, r16
    2c86:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2c8a:	8c 01       	movw	r16, r24
    2c8c:	6a ef       	ldi	r22, 0xFA	; 250
    2c8e:	74 e0       	ldi	r23, 0x04	; 4
    2c90:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2c94:	66 e0       	ldi	r22, 0x06	; 6
    2c96:	c8 01       	movw	r24, r16
    2c98:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2c9c:	6a e0       	ldi	r22, 0x0A	; 10
    2c9e:	ce 01       	movw	r24, r28
    2ca0:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2ca4:	8c 01       	movw	r16, r24
    2ca6:	69 ee       	ldi	r22, 0xE9	; 233
    2ca8:	74 e0       	ldi	r23, 0x04	; 4
    2caa:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2cae:	6a e0       	ldi	r22, 0x0A	; 10
    2cb0:	c8 01       	movw	r24, r16
    2cb2:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2cb6:	8c 01       	movw	r16, r24
    2cb8:	6d ed       	ldi	r22, 0xDD	; 221
    2cba:	74 e0       	ldi	r23, 0x04	; 4
    2cbc:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2cc0:	6a e0       	ldi	r22, 0x0A	; 10
    2cc2:	c8 01       	movw	r24, r16
    2cc4:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2cc8:	8c 01       	movw	r16, r24
    2cca:	67 ed       	ldi	r22, 0xD7	; 215
    2ccc:	74 e0       	ldi	r23, 0x04	; 4
    2cce:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2cd2:	66 e0       	ldi	r22, 0x06	; 6
    2cd4:	c8 01       	movw	r24, r16
    2cd6:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2cda:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <last_created_task_pointer>
    2cde:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    2ce2:	00 97       	sbiw	r24, 0x00	; 0
    2ce4:	19 f0       	breq	.+6      	; 0x2cec <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2ce6:	be 01       	movw	r22, r28
    2ce8:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2cec:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <xTaskGetIdleTaskHandle>
    2cf0:	0e 94 4d 13 	call	0x269a	; 0x269a <uxTaskGetStackHighWaterMark>
    2cf4:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2cf6:	6a e0       	ldi	r22, 0x0A	; 10
    2cf8:	ce 01       	movw	r24, r28
    2cfa:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2cfe:	ec 01       	movw	r28, r24
    2d00:	6c ec       	ldi	r22, 0xCC	; 204
    2d02:	74 e0       	ldi	r23, 0x04	; 4
    2d04:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2d08:	61 2f       	mov	r22, r17
    2d0a:	ce 01       	movw	r24, r28
    2d0c:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2d10:	6a e0       	ldi	r22, 0x0A	; 10
    2d12:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2d16:	ec 01       	movw	r28, r24
    2d18:	6a ec       	ldi	r22, 0xCA	; 202
    2d1a:	74 e0       	ldi	r23, 0x04	; 4
    2d1c:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    2d20:	64 e6       	ldi	r22, 0x64	; 100
    2d22:	70 e0       	ldi	r23, 0x00	; 0
    2d24:	ce 01       	movw	r24, r28
    2d26:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <_ZN8emstreamlsEj>
    2d2a:	6a e0       	ldi	r22, 0x0A	; 10
    2d2c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2d30:	ec 01       	movw	r28, r24
    2d32:	67 ec       	ldi	r22, 0xC7	; 199
    2d34:	74 e0       	ldi	r23, 0x04	; 4
    2d36:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2d3a:	66 e0       	ldi	r22, 0x06	; 6
    2d3c:	ce 01       	movw	r24, r28
    2d3e:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
}
    2d42:	df 91       	pop	r29
    2d44:	cf 91       	pop	r28
    2d46:	1f 91       	pop	r17
    2d48:	0f 91       	pop	r16
    2d4a:	08 95       	ret

00002d4c <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2d4c:	0f 93       	push	r16
    2d4e:	cf 93       	push	r28
    2d50:	df 93       	push	r29
    2d52:	1f 92       	push	r1
    2d54:	cd b7       	in	r28, 0x3d	; 61
    2d56:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2d58:	00 e0       	ldi	r16, 0x00	; 0
    2d5a:	2f ef       	ldi	r18, 0xFF	; 255
    2d5c:	3f ef       	ldi	r19, 0xFF	; 255
    2d5e:	a9 01       	movw	r20, r18
    2d60:	be 01       	movw	r22, r28
    2d62:	6f 5f       	subi	r22, 0xFF	; 255
    2d64:	7f 4f       	sbci	r23, 0xFF	; 255
    2d66:	fc 01       	movw	r30, r24
    2d68:	80 85       	ldd	r24, Z+8	; 0x08
    2d6a:	91 85       	ldd	r25, Z+9	; 0x09
    2d6c:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <xQueueGenericReceive>
    2d70:	81 30       	cpi	r24, 0x01	; 1
    2d72:	19 f4       	brne	.+6      	; 0x2d7a <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2d74:	89 81       	ldd	r24, Y+1	; 0x01
    2d76:	90 e0       	ldi	r25, 0x00	; 0
    2d78:	02 c0       	rjmp	.+4      	; 0x2d7e <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2d7a:	8f ef       	ldi	r24, 0xFF	; 255
    2d7c:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2d7e:	0f 90       	pop	r0
    2d80:	df 91       	pop	r29
    2d82:	cf 91       	pop	r28
    2d84:	0f 91       	pop	r16
    2d86:	08 95       	ret

00002d88 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2d88:	fc 01       	movw	r30, r24
    2d8a:	80 85       	ldd	r24, Z+8	; 0x08
    2d8c:	91 85       	ldd	r25, Z+9	; 0x09
    2d8e:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <uxQueueMessagesWaiting>
    2d92:	91 e0       	ldi	r25, 0x01	; 1
    2d94:	81 11       	cpse	r24, r1
    2d96:	01 c0       	rjmp	.+2      	; 0x2d9a <_ZN14frt_text_queue14check_for_charEv+0x12>
    2d98:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2d9a:	89 2f       	mov	r24, r25
    2d9c:	08 95       	ret

00002d9e <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2d9e:	0f 93       	push	r16
    2da0:	cf 93       	push	r28
    2da2:	df 93       	push	r29
    2da4:	1f 92       	push	r1
    2da6:	cd b7       	in	r28, 0x3d	; 61
    2da8:	de b7       	in	r29, 0x3e	; 62
    2daa:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2dac:	fc 01       	movw	r30, r24
    2dae:	22 85       	ldd	r18, Z+10	; 0x0a
    2db0:	33 85       	ldd	r19, Z+11	; 0x0b
    2db2:	44 85       	ldd	r20, Z+12	; 0x0c
    2db4:	55 85       	ldd	r21, Z+13	; 0x0d
    2db6:	00 e0       	ldi	r16, 0x00	; 0
    2db8:	be 01       	movw	r22, r28
    2dba:	6f 5f       	subi	r22, 0xFF	; 255
    2dbc:	7f 4f       	sbci	r23, 0xFF	; 255
    2dbe:	80 85       	ldd	r24, Z+8	; 0x08
    2dc0:	91 85       	ldd	r25, Z+9	; 0x09
    2dc2:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    2dc6:	91 e0       	ldi	r25, 0x01	; 1
    2dc8:	81 11       	cpse	r24, r1
    2dca:	01 c0       	rjmp	.+2      	; 0x2dce <_ZN14frt_text_queue7putcharEc+0x30>
    2dcc:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2dce:	89 2f       	mov	r24, r25
    2dd0:	0f 90       	pop	r0
    2dd2:	df 91       	pop	r29
    2dd4:	cf 91       	pop	r28
    2dd6:	0f 91       	pop	r16
    2dd8:	08 95       	ret

00002dda <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2dda:	8f 92       	push	r8
    2ddc:	9f 92       	push	r9
    2dde:	bf 92       	push	r11
    2de0:	cf 92       	push	r12
    2de2:	df 92       	push	r13
    2de4:	ef 92       	push	r14
    2de6:	ff 92       	push	r15
    2de8:	0f 93       	push	r16
    2dea:	1f 93       	push	r17
    2dec:	cf 93       	push	r28
    2dee:	df 93       	push	r29
    2df0:	ec 01       	movw	r28, r24
    2df2:	b6 2e       	mov	r11, r22
    2df4:	4a 01       	movw	r8, r20
    2df6:	68 01       	movw	r12, r16
    2df8:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2dfa:	0e 94 2c 19 	call	0x3258	; 0x3258 <_ZN8emstreamC1Ev>
    2dfe:	86 e5       	ldi	r24, 0x56	; 86
    2e00:	90 e2       	ldi	r25, 0x20	; 32
    2e02:	88 83       	st	Y, r24
    2e04:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2e06:	8e 86       	std	Y+14, r8	; 0x0e
    2e08:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2e0a:	40 e0       	ldi	r20, 0x00	; 0
    2e0c:	61 e0       	ldi	r22, 0x01	; 1
    2e0e:	8b 2d       	mov	r24, r11
    2e10:	0e 94 98 0c 	call	0x1930	; 0x1930 <xQueueGenericCreate>
    2e14:	88 87       	std	Y+8, r24	; 0x08
    2e16:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2e18:	ca 86       	std	Y+10, r12	; 0x0a
    2e1a:	db 86       	std	Y+11, r13	; 0x0b
    2e1c:	ec 86       	std	Y+12, r14	; 0x0c
    2e1e:	fd 86       	std	Y+13, r15	; 0x0d
}
    2e20:	df 91       	pop	r29
    2e22:	cf 91       	pop	r28
    2e24:	1f 91       	pop	r17
    2e26:	0f 91       	pop	r16
    2e28:	ff 90       	pop	r15
    2e2a:	ef 90       	pop	r14
    2e2c:	df 90       	pop	r13
    2e2e:	cf 90       	pop	r12
    2e30:	bf 90       	pop	r11
    2e32:	9f 90       	pop	r9
    2e34:	8f 90       	pop	r8
    2e36:	08 95       	ret

00002e38 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2e38:	cf 92       	push	r12
    2e3a:	df 92       	push	r13
    2e3c:	ef 92       	push	r14
    2e3e:	ff 92       	push	r15
    2e40:	cf 93       	push	r28
    2e42:	df 93       	push	r29
    2e44:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2e46:	68 81       	ld	r22, Y
    2e48:	79 81       	ldd	r23, Y+1	; 0x01
    2e4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2e4e:	0f 2e       	mov	r0, r31
    2e50:	f8 ee       	ldi	r31, 0xE8	; 232
    2e52:	cf 2e       	mov	r12, r31
    2e54:	f3 e0       	ldi	r31, 0x03	; 3
    2e56:	df 2e       	mov	r13, r31
    2e58:	e1 2c       	mov	r14, r1
    2e5a:	f1 2c       	mov	r15, r1
    2e5c:	f0 2d       	mov	r31, r0
    2e5e:	a7 01       	movw	r20, r14
    2e60:	96 01       	movw	r18, r12
    2e62:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <__udivmodsi4>
    2e66:	9b 01       	movw	r18, r22
    2e68:	ac 01       	movw	r20, r24
    2e6a:	60 e4       	ldi	r22, 0x40	; 64
    2e6c:	72 e4       	ldi	r23, 0x42	; 66
    2e6e:	8f e0       	ldi	r24, 0x0F	; 15
    2e70:	90 e0       	ldi	r25, 0x00	; 0
    2e72:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__mulsi3>
    2e76:	a7 01       	movw	r20, r14
    2e78:	96 01       	movw	r18, r12
    2e7a:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <__udivmodsi4>
    2e7e:	69 01       	movw	r12, r18
    2e80:	7a 01       	movw	r14, r20
    2e82:	ac 81       	ldd	r26, Y+4	; 0x04
    2e84:	bd 81       	ldd	r27, Y+5	; 0x05
    2e86:	20 e4       	ldi	r18, 0x40	; 64
    2e88:	32 e4       	ldi	r19, 0x42	; 66
    2e8a:	4f e0       	ldi	r20, 0x0F	; 15
    2e8c:	50 e0       	ldi	r21, 0x00	; 0
    2e8e:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <__muluhisi3>
    2e92:	20 e0       	ldi	r18, 0x00	; 0
    2e94:	38 e4       	ldi	r19, 0x48	; 72
    2e96:	48 ee       	ldi	r20, 0xE8	; 232
    2e98:	51 e0       	ldi	r21, 0x01	; 1
    2e9a:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <__udivmodsi4>
    2e9e:	c7 01       	movw	r24, r14
    2ea0:	b6 01       	movw	r22, r12
    2ea2:	62 0f       	add	r22, r18
    2ea4:	73 1f       	adc	r23, r19
    2ea6:	84 1f       	adc	r24, r20
    2ea8:	95 1f       	adc	r25, r21
}
    2eaa:	df 91       	pop	r29
    2eac:	cf 91       	pop	r28
    2eae:	ff 90       	pop	r15
    2eb0:	ef 90       	pop	r14
    2eb2:	df 90       	pop	r13
    2eb4:	cf 90       	pop	r12
    2eb6:	08 95       	ret

00002eb8 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2eb8:	cf 92       	push	r12
    2eba:	df 92       	push	r13
    2ebc:	ef 92       	push	r14
    2ebe:	ff 92       	push	r15
    2ec0:	0f 93       	push	r16
    2ec2:	1f 93       	push	r17
    2ec4:	cf 93       	push	r28
    2ec6:	df 93       	push	r29
    2ec8:	cd b7       	in	r28, 0x3d	; 61
    2eca:	de b7       	in	r29, 0x3e	; 62
    2ecc:	2f 97       	sbiw	r28, 0x0f	; 15
    2ece:	cd bf       	out	0x3d, r28	; 61
    2ed0:	de bf       	out	0x3e, r29	; 62
    2ed2:	6c 01       	movw	r12, r24
    2ed4:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2ed6:	db 01       	movw	r26, r22
    2ed8:	6d 91       	ld	r22, X+
    2eda:	7d 91       	ld	r23, X+
    2edc:	8d 91       	ld	r24, X+
    2ede:	9c 91       	ld	r25, X
    2ee0:	28 ee       	ldi	r18, 0xE8	; 232
    2ee2:	33 e0       	ldi	r19, 0x03	; 3
    2ee4:	40 e0       	ldi	r20, 0x00	; 0
    2ee6:	50 e0       	ldi	r21, 0x00	; 0
    2ee8:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <__udivmodsi4>
    2eec:	ba 01       	movw	r22, r20
    2eee:	a9 01       	movw	r20, r18
    2ef0:	c6 01       	movw	r24, r12
    2ef2:	0e 94 15 1a 	call	0x342a	; 0x342a <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2ef6:	d6 01       	movw	r26, r12
    2ef8:	ed 91       	ld	r30, X+
    2efa:	fc 91       	ld	r31, X
    2efc:	02 80       	ldd	r0, Z+2	; 0x02
    2efe:	f3 81       	ldd	r31, Z+3	; 0x03
    2f00:	e0 2d       	mov	r30, r0
    2f02:	6e e2       	ldi	r22, 0x2E	; 46
    2f04:	c6 01       	movw	r24, r12
    2f06:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2f08:	c8 01       	movw	r24, r16
    2f0a:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN10time_stamp12get_microsecEv>
    2f0e:	8e 01       	movw	r16, r28
    2f10:	09 5f       	subi	r16, 0xF9	; 249
    2f12:	1f 4f       	sbci	r17, 0xFF	; 255
    2f14:	fe 01       	movw	r30, r28
    2f16:	31 96       	adiw	r30, 0x01	; 1
    2f18:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2f1a:	2a e0       	ldi	r18, 0x0A	; 10
    2f1c:	30 e0       	ldi	r19, 0x00	; 0
    2f1e:	40 e0       	ldi	r20, 0x00	; 0
    2f20:	50 e0       	ldi	r21, 0x00	; 0
    2f22:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <__divmodsi4>
    2f26:	e6 2f       	mov	r30, r22
    2f28:	28 87       	std	Y+8, r18	; 0x08
    2f2a:	39 87       	std	Y+9, r19	; 0x09
    2f2c:	4a 87       	std	Y+10, r20	; 0x0a
    2f2e:	5b 87       	std	Y+11, r21	; 0x0b
    2f30:	68 85       	ldd	r22, Y+8	; 0x08
    2f32:	79 85       	ldd	r23, Y+9	; 0x09
    2f34:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f36:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2f38:	20 e3       	ldi	r18, 0x30	; 48
    2f3a:	2e 0f       	add	r18, r30
    2f3c:	d8 01       	movw	r26, r16
    2f3e:	2e 93       	st	-X, r18
    2f40:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2f42:	ae 15       	cp	r26, r14
    2f44:	bf 05       	cpc	r27, r15
    2f46:	49 f7       	brne	.-46     	; 0x2f1a <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2f48:	1f 82       	std	Y+7, r1	; 0x07
    2f4a:	be 01       	movw	r22, r28
    2f4c:	6f 5f       	subi	r22, 0xFF	; 255
    2f4e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f50:	c6 01       	movw	r24, r12
    2f52:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2f56:	c6 01       	movw	r24, r12
    2f58:	2f 96       	adiw	r28, 0x0f	; 15
    2f5a:	cd bf       	out	0x3d, r28	; 61
    2f5c:	de bf       	out	0x3e, r29	; 62
    2f5e:	df 91       	pop	r29
    2f60:	cf 91       	pop	r28
    2f62:	1f 91       	pop	r17
    2f64:	0f 91       	pop	r16
    2f66:	ff 90       	pop	r15
    2f68:	ef 90       	pop	r14
    2f6a:	df 90       	pop	r13
    2f6c:	cf 90       	pop	r12
    2f6e:	08 95       	ret

00002f70 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2f70:	cf 93       	push	r28
    2f72:	df 93       	push	r29
    2f74:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2f76:	0f b6       	in	r0, 0x3f	; 63
    2f78:	f8 94       	cli
    2f7a:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2f7c:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2f80:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2f84:	8c 83       	std	Y+4, r24	; 0x04
    2f86:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2f88:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <xTaskGetTickCount>
    2f8c:	68 83       	st	Y, r22
    2f8e:	79 83       	std	Y+1, r23	; 0x01
    2f90:	8a 83       	std	Y+2, r24	; 0x02
    2f92:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2f94:	0f 90       	pop	r0
    2f96:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2f98:	ce 01       	movw	r24, r28
    2f9a:	df 91       	pop	r29
    2f9c:	cf 91       	pop	r28
    2f9e:	08 95       	ret

00002fa0 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2fa0:	5f 92       	push	r5
    2fa2:	6f 92       	push	r6
    2fa4:	7f 92       	push	r7
    2fa6:	8f 92       	push	r8
    2fa8:	9f 92       	push	r9
    2faa:	af 92       	push	r10
    2fac:	bf 92       	push	r11
    2fae:	cf 92       	push	r12
    2fb0:	df 92       	push	r13
    2fb2:	ef 92       	push	r14
    2fb4:	ff 92       	push	r15
    2fb6:	0f 93       	push	r16
    2fb8:	1f 93       	push	r17
    2fba:	cf 93       	push	r28
    2fbc:	df 93       	push	r29
    2fbe:	5c 01       	movw	r10, r24
    2fc0:	4b 01       	movw	r8, r22
    2fc2:	7a 01       	movw	r14, r20
    2fc4:	12 2f       	mov	r17, r18
    2fc6:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2fc8:	63 e0       	ldi	r22, 0x03	; 3
    2fca:	ca 01       	movw	r24, r20
    2fcc:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2fd0:	a8 14       	cp	r10, r8
    2fd2:	b9 04       	cpc	r11, r9
    2fd4:	08 f0       	brcs	.+2      	; 0x2fd8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2fd6:	7d c0       	rjmp	.+250    	; 0x30d2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2fd8:	65 01       	movw	r12, r10
    2fda:	84 e1       	ldi	r24, 0x14	; 20
    2fdc:	c8 0e       	add	r12, r24
    2fde:	d1 1c       	adc	r13, r1
    2fe0:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2fe2:	6a 2c       	mov	r6, r10
    2fe4:	5b 2c       	mov	r5, r11
    2fe6:	b5 01       	movw	r22, r10
    2fe8:	c7 01       	movw	r24, r14
    2fea:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <_ZN8emstreamlsEj>
    2fee:	6a e0       	ldi	r22, 0x0A	; 10
    2ff0:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    2ff4:	69 e4       	ldi	r22, 0x49	; 73
    2ff6:	75 e0       	ldi	r23, 0x05	; 5
    2ff8:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2ffc:	11 23       	and	r17, r17
    2ffe:	09 f4       	brne	.+2      	; 0x3002 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3000:	6d c0       	rjmp	.+218    	; 0x30dc <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3002:	00 23       	and	r16, r16
    3004:	09 f4       	brne	.+2      	; 0x3008 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3006:	6a c0       	rjmp	.+212    	; 0x30dc <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3008:	6a e0       	ldi	r22, 0x0A	; 10
    300a:	c7 01       	movw	r24, r14
    300c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    3010:	64 e4       	ldi	r22, 0x44	; 68
    3012:	75 e0       	ldi	r23, 0x05	; 5
    3014:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    3018:	61 c0       	rjmp	.+194    	; 0x30dc <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    301a:	11 23       	and	r17, r17
    301c:	71 f0       	breq	.+28     	; 0x303a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    301e:	01 11       	cpse	r16, r1
    3020:	0c c0       	rjmp	.+24     	; 0x303a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3022:	88 81       	ld	r24, Y
    3024:	87 15       	cp	r24, r7
    3026:	49 f0       	breq	.+18     	; 0x303a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3028:	6a e0       	ldi	r22, 0x0A	; 10
    302a:	c7 01       	movw	r24, r14
    302c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    3030:	6f e3       	ldi	r22, 0x3F	; 63
    3032:	75 e0       	ldi	r23, 0x05	; 5
    3034:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3038:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    303a:	69 91       	ld	r22, Y+
    303c:	c7 01       	movw	r24, r14
    303e:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3042:	dc 01       	movw	r26, r24
    3044:	ed 91       	ld	r30, X+
    3046:	fc 91       	ld	r31, X
    3048:	02 80       	ldd	r0, Z+2	; 0x02
    304a:	f3 81       	ldd	r31, Z+3	; 0x03
    304c:	e0 2d       	mov	r30, r0
    304e:	60 e2       	ldi	r22, 0x20	; 32
    3050:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3052:	cc 16       	cp	r12, r28
    3054:	dd 06       	cpc	r13, r29
    3056:	09 f7       	brne	.-62     	; 0x301a <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3058:	11 23       	and	r17, r17
    305a:	89 f0       	breq	.+34     	; 0x307e <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    305c:	6a e0       	ldi	r22, 0x0A	; 10
    305e:	c7 01       	movw	r24, r14
    3060:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    3064:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3066:	69 e3       	ldi	r22, 0x39	; 57
    3068:	75 e0       	ldi	r23, 0x05	; 5
    306a:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    306e:	e8 81       	ld	r30, Y
    3070:	f9 81       	ldd	r31, Y+1	; 0x01
    3072:	02 80       	ldd	r0, Z+2	; 0x02
    3074:	f3 81       	ldd	r31, Z+3	; 0x03
    3076:	e0 2d       	mov	r30, r0
    3078:	60 e2       	ldi	r22, 0x20	; 32
    307a:	ce 01       	movw	r24, r28
    307c:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    307e:	c6 2d       	mov	r28, r6
    3080:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3082:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3084:	80 ee       	ldi	r24, 0xE0	; 224
    3086:	86 0f       	add	r24, r22
    3088:	8f 35       	cpi	r24, 0x5F	; 95
    308a:	48 f4       	brcc	.+18     	; 0x309e <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    308c:	d7 01       	movw	r26, r14
    308e:	ed 91       	ld	r30, X+
    3090:	fc 91       	ld	r31, X
    3092:	02 80       	ldd	r0, Z+2	; 0x02
    3094:	f3 81       	ldd	r31, Z+3	; 0x03
    3096:	e0 2d       	mov	r30, r0
    3098:	c7 01       	movw	r24, r14
    309a:	19 95       	eicall
    309c:	09 c0       	rjmp	.+18     	; 0x30b0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    309e:	d7 01       	movw	r26, r14
    30a0:	ed 91       	ld	r30, X+
    30a2:	fc 91       	ld	r31, X
    30a4:	02 80       	ldd	r0, Z+2	; 0x02
    30a6:	f3 81       	ldd	r31, Z+3	; 0x03
    30a8:	e0 2d       	mov	r30, r0
    30aa:	6e e2       	ldi	r22, 0x2E	; 46
    30ac:	c7 01       	movw	r24, r14
    30ae:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    30b0:	cc 16       	cp	r12, r28
    30b2:	dd 06       	cpc	r13, r29
    30b4:	31 f7       	brne	.-52     	; 0x3082 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    30b6:	b4 e1       	ldi	r27, 0x14	; 20
    30b8:	ab 0e       	add	r10, r27
    30ba:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    30bc:	66 e0       	ldi	r22, 0x06	; 6
    30be:	c7 01       	movw	r24, r14
    30c0:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    30c4:	84 e1       	ldi	r24, 0x14	; 20
    30c6:	c8 0e       	add	r12, r24
    30c8:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    30ca:	a8 14       	cp	r10, r8
    30cc:	b9 04       	cpc	r11, r9
    30ce:	08 f4       	brcc	.+2      	; 0x30d2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30d0:	88 cf       	rjmp	.-240    	; 0x2fe2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    30d2:	62 e0       	ldi	r22, 0x02	; 2
    30d4:	c7 01       	movw	r24, r14
    30d6:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
}
    30da:	03 c0       	rjmp	.+6      	; 0x30e2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    30dc:	c6 2d       	mov	r28, r6
    30de:	d5 2d       	mov	r29, r5
    30e0:	9c cf       	rjmp	.-200    	; 0x301a <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    30e2:	df 91       	pop	r29
    30e4:	cf 91       	pop	r28
    30e6:	1f 91       	pop	r17
    30e8:	0f 91       	pop	r16
    30ea:	ff 90       	pop	r15
    30ec:	ef 90       	pop	r14
    30ee:	df 90       	pop	r13
    30f0:	cf 90       	pop	r12
    30f2:	bf 90       	pop	r11
    30f4:	af 90       	pop	r10
    30f6:	9f 90       	pop	r9
    30f8:	8f 90       	pop	r8
    30fa:	7f 90       	pop	r7
    30fc:	6f 90       	pop	r6
    30fe:	5f 90       	pop	r5
    3100:	08 95       	ret

00003102 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3102:	0e 94 b2 08 	call	0x1164	; 0x1164 <pvPortMalloc>
    3106:	08 95       	ret

00003108 <_ZdlPv>:
    3108:	00 97       	sbiw	r24, 0x00	; 0
    310a:	11 f0       	breq	.+4      	; 0x3110 <_ZdlPv+0x8>
    310c:	0e 94 4c 09 	call	0x1298	; 0x1298 <vPortFree>
    3110:	08 95       	ret

00003112 <_Znaj>:
    3112:	0e 94 b2 08 	call	0x1164	; 0x1164 <pvPortMalloc>
    3116:	08 95       	ret

00003118 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3118:	08 95       	ret

0000311a <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    311a:	cf 93       	push	r28
    311c:	df 93       	push	r29
    311e:	fc 01       	movw	r30, r24
    3120:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3122:	40 3a       	cpi	r20, 0xA0	; 160
    3124:	68 e0       	ldi	r22, 0x08	; 8
    3126:	56 07       	cpc	r21, r22
    3128:	49 f4       	brne	.+18     	; 0x313c <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    312a:	80 e4       	ldi	r24, 0x40	; 64
    312c:	96 e0       	ldi	r25, 0x06	; 6
    312e:	82 83       	std	Z+2, r24	; 0x02
    3130:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3132:	82 e0       	ldi	r24, 0x02	; 2
    3134:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3136:	83 e0       	ldi	r24, 0x03	; 3
    3138:	85 83       	std	Z+5, r24	; 0x05
    313a:	32 c0       	rjmp	.+100    	; 0x31a0 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    313c:	40 3b       	cpi	r20, 0xB0	; 176
    313e:	78 e0       	ldi	r23, 0x08	; 8
    3140:	57 07       	cpc	r21, r23
    3142:	49 f4       	brne	.+18     	; 0x3156 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3144:	80 e4       	ldi	r24, 0x40	; 64
    3146:	96 e0       	ldi	r25, 0x06	; 6
    3148:	82 83       	std	Z+2, r24	; 0x02
    314a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    314c:	86 e0       	ldi	r24, 0x06	; 6
    314e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3150:	87 e0       	ldi	r24, 0x07	; 7
    3152:	85 83       	std	Z+5, r24	; 0x05
    3154:	25 c0       	rjmp	.+74     	; 0x31a0 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3156:	40 3a       	cpi	r20, 0xA0	; 160
    3158:	89 e0       	ldi	r24, 0x09	; 9
    315a:	58 07       	cpc	r21, r24
    315c:	49 f4       	brne	.+18     	; 0x3170 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    315e:	80 e6       	ldi	r24, 0x60	; 96
    3160:	96 e0       	ldi	r25, 0x06	; 6
    3162:	82 83       	std	Z+2, r24	; 0x02
    3164:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3166:	82 e0       	ldi	r24, 0x02	; 2
    3168:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    316a:	83 e0       	ldi	r24, 0x03	; 3
    316c:	85 83       	std	Z+5, r24	; 0x05
    316e:	18 c0       	rjmp	.+48     	; 0x31a0 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3170:	40 3b       	cpi	r20, 0xB0	; 176
    3172:	69 e0       	ldi	r22, 0x09	; 9
    3174:	56 07       	cpc	r21, r22
    3176:	49 f4       	brne	.+18     	; 0x318a <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3178:	80 e6       	ldi	r24, 0x60	; 96
    317a:	96 e0       	ldi	r25, 0x06	; 6
    317c:	82 83       	std	Z+2, r24	; 0x02
    317e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3180:	86 e0       	ldi	r24, 0x06	; 6
    3182:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3184:	87 e0       	ldi	r24, 0x07	; 7
    3186:	85 83       	std	Z+5, r24	; 0x05
    3188:	0b c0       	rjmp	.+22     	; 0x31a0 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    318a:	40 3a       	cpi	r20, 0xA0	; 160
    318c:	5a 40       	sbci	r21, 0x0A	; 10
    318e:	41 f4       	brne	.+16     	; 0x31a0 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3190:	80 e8       	ldi	r24, 0x80	; 128
    3192:	96 e0       	ldi	r25, 0x06	; 6
    3194:	82 83       	std	Z+2, r24	; 0x02
    3196:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3198:	82 e0       	ldi	r24, 0x02	; 2
    319a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    319c:	83 e0       	ldi	r24, 0x03	; 3
    319e:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    31a0:	a6 83       	std	Z+6, r26	; 0x06
    31a2:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    31a4:	cd 01       	movw	r24, r26
    31a6:	01 96       	adiw	r24, 0x01	; 1
    31a8:	80 87       	std	Z+8, r24	; 0x08
    31aa:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    31ac:	03 96       	adiw	r24, 0x03	; 3
    31ae:	82 87       	std	Z+10, r24	; 0x0a
    31b0:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    31b2:	25 81       	ldd	r18, Z+5	; 0x05
    31b4:	c2 81       	ldd	r28, Z+2	; 0x02
    31b6:	d3 81       	ldd	r29, Z+3	; 0x03
    31b8:	4c 81       	ldd	r20, Y+4	; 0x04
    31ba:	81 e0       	ldi	r24, 0x01	; 1
    31bc:	90 e0       	ldi	r25, 0x00	; 0
    31be:	bc 01       	movw	r22, r24
    31c0:	02 c0       	rjmp	.+4      	; 0x31c6 <_ZN7base232C1EjP12USART_struct+0xac>
    31c2:	66 0f       	add	r22, r22
    31c4:	77 1f       	adc	r23, r23
    31c6:	2a 95       	dec	r18
    31c8:	e2 f7       	brpl	.-8      	; 0x31c2 <_ZN7base232C1EjP12USART_struct+0xa8>
    31ca:	9b 01       	movw	r18, r22
    31cc:	24 2b       	or	r18, r20
    31ce:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    31d0:	25 81       	ldd	r18, Z+5	; 0x05
    31d2:	c2 81       	ldd	r28, Z+2	; 0x02
    31d4:	d3 81       	ldd	r29, Z+3	; 0x03
    31d6:	48 81       	ld	r20, Y
    31d8:	bc 01       	movw	r22, r24
    31da:	02 c0       	rjmp	.+4      	; 0x31e0 <_ZN7base232C1EjP12USART_struct+0xc6>
    31dc:	66 0f       	add	r22, r22
    31de:	77 1f       	adc	r23, r23
    31e0:	2a 95       	dec	r18
    31e2:	e2 f7       	brpl	.-8      	; 0x31dc <_ZN7base232C1EjP12USART_struct+0xc2>
    31e4:	9b 01       	movw	r18, r22
    31e6:	24 2b       	or	r18, r20
    31e8:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    31ea:	34 81       	ldd	r19, Z+4	; 0x04
    31ec:	c2 81       	ldd	r28, Z+2	; 0x02
    31ee:	d3 81       	ldd	r29, Z+3	; 0x03
    31f0:	28 81       	ld	r18, Y
    31f2:	02 c0       	rjmp	.+4      	; 0x31f8 <_ZN7base232C1EjP12USART_struct+0xde>
    31f4:	88 0f       	add	r24, r24
    31f6:	99 1f       	adc	r25, r25
    31f8:	3a 95       	dec	r19
    31fa:	e2 f7       	brpl	.-8      	; 0x31f4 <_ZN7base232C1EjP12USART_struct+0xda>
    31fc:	80 95       	com	r24
    31fe:	90 95       	com	r25
    3200:	82 23       	and	r24, r18
    3202:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3204:	80 e1       	ldi	r24, 0x10	; 16
    3206:	13 96       	adiw	r26, 0x03	; 3
    3208:	8c 93       	st	X, r24
    320a:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    320c:	83 e0       	ldi	r24, 0x03	; 3
    320e:	15 96       	adiw	r26, 0x05	; 5
    3210:	8c 93       	st	X, r24
    3212:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3214:	80 ef       	ldi	r24, 0xF0	; 240
    3216:	17 96       	adiw	r26, 0x07	; 7
    3218:	8c 93       	st	X, r24
    321a:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    321c:	81 e2       	ldi	r24, 0x21	; 33
    321e:	16 96       	adiw	r26, 0x06	; 6
    3220:	8c 93       	st	X, r24
    3222:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3224:	88 e1       	ldi	r24, 0x18	; 24
    3226:	14 96       	adiw	r26, 0x04	; 4
    3228:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    322a:	80 e8       	ldi	r24, 0x80	; 128
    322c:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    322e:	80 e4       	ldi	r24, 0x40	; 64
    3230:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3232:	80 e2       	ldi	r24, 0x20	; 32
    3234:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3236:	06 80       	ldd	r0, Z+6	; 0x06
    3238:	f7 81       	ldd	r31, Z+7	; 0x07
    323a:	e0 2d       	mov	r30, r0
    323c:	80 81       	ld	r24, Z
    323e:	80 81       	ld	r24, Z
}
    3240:	df 91       	pop	r29
    3242:	cf 91       	pop	r28
    3244:	08 95       	ret

00003246 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3246:	81 e0       	ldi	r24, 0x01	; 1
    3248:	08 95       	ret

0000324a <_ZN8emstream7getcharEv>:
    324a:	80 e0       	ldi	r24, 0x00	; 0
    324c:	90 e0       	ldi	r25, 0x00	; 0
    324e:	08 95       	ret

00003250 <_ZN8emstream14check_for_charEv>:
    3250:	80 e0       	ldi	r24, 0x00	; 0
    3252:	08 95       	ret

00003254 <_ZN8emstream12transmit_nowEv>:
    3254:	08 95       	ret

00003256 <_ZN8emstream12clear_screenEv>:
    3256:	08 95       	ret

00003258 <_ZN8emstreamC1Ev>:
    3258:	fc 01       	movw	r30, r24
    325a:	86 e6       	ldi	r24, 0x66	; 102
    325c:	90 e2       	ldi	r25, 0x20	; 32
    325e:	80 83       	st	Z, r24
    3260:	91 83       	std	Z+1, r25	; 0x01
    3262:	8a e0       	ldi	r24, 0x0A	; 10
    3264:	82 83       	std	Z+2, r24	; 0x02
    3266:	13 82       	std	Z+3, r1	; 0x03
    3268:	83 e0       	ldi	r24, 0x03	; 3
    326a:	85 83       	std	Z+5, r24	; 0x05
    326c:	14 82       	std	Z+4, r1	; 0x04
    326e:	16 82       	std	Z+6, r1	; 0x06
    3270:	17 82       	std	Z+7, r1	; 0x07
    3272:	08 95       	ret

00003274 <_ZN8emstream4putsEPKc>:
    3274:	0f 93       	push	r16
    3276:	1f 93       	push	r17
    3278:	cf 93       	push	r28
    327a:	df 93       	push	r29
    327c:	8c 01       	movw	r16, r24
    327e:	fb 01       	movw	r30, r22
    3280:	dc 01       	movw	r26, r24
    3282:	14 96       	adiw	r26, 0x04	; 4
    3284:	8c 91       	ld	r24, X
    3286:	81 11       	cpse	r24, r1
    3288:	04 c0       	rjmp	.+8      	; 0x3292 <_ZN8emstream4putsEPKc+0x1e>
    328a:	60 81       	ld	r22, Z
    328c:	61 11       	cpse	r22, r1
    328e:	17 c0       	rjmp	.+46     	; 0x32be <_ZN8emstream4putsEPKc+0x4a>
    3290:	23 c0       	rjmp	.+70     	; 0x32d8 <_ZN8emstream4putsEPKc+0x64>
    3292:	d8 01       	movw	r26, r16
    3294:	14 96       	adiw	r26, 0x04	; 4
    3296:	1c 92       	st	X, r1
    3298:	eb 01       	movw	r28, r22
    329a:	21 96       	adiw	r28, 0x01	; 1
    329c:	64 91       	lpm	r22, Z
    329e:	66 23       	and	r22, r22
    32a0:	d9 f0       	breq	.+54     	; 0x32d8 <_ZN8emstream4putsEPKc+0x64>
    32a2:	d8 01       	movw	r26, r16
    32a4:	ed 91       	ld	r30, X+
    32a6:	fc 91       	ld	r31, X
    32a8:	02 80       	ldd	r0, Z+2	; 0x02
    32aa:	f3 81       	ldd	r31, Z+3	; 0x03
    32ac:	e0 2d       	mov	r30, r0
    32ae:	c8 01       	movw	r24, r16
    32b0:	19 95       	eicall
    32b2:	fe 01       	movw	r30, r28
    32b4:	64 91       	lpm	r22, Z
    32b6:	21 96       	adiw	r28, 0x01	; 1
    32b8:	61 11       	cpse	r22, r1
    32ba:	f3 cf       	rjmp	.-26     	; 0x32a2 <_ZN8emstream4putsEPKc+0x2e>
    32bc:	0d c0       	rjmp	.+26     	; 0x32d8 <_ZN8emstream4putsEPKc+0x64>
    32be:	ef 01       	movw	r28, r30
    32c0:	21 96       	adiw	r28, 0x01	; 1
    32c2:	d8 01       	movw	r26, r16
    32c4:	ed 91       	ld	r30, X+
    32c6:	fc 91       	ld	r31, X
    32c8:	02 80       	ldd	r0, Z+2	; 0x02
    32ca:	f3 81       	ldd	r31, Z+3	; 0x03
    32cc:	e0 2d       	mov	r30, r0
    32ce:	c8 01       	movw	r24, r16
    32d0:	19 95       	eicall
    32d2:	69 91       	ld	r22, Y+
    32d4:	61 11       	cpse	r22, r1
    32d6:	f5 cf       	rjmp	.-22     	; 0x32c2 <_ZN8emstream4putsEPKc+0x4e>
    32d8:	df 91       	pop	r29
    32da:	cf 91       	pop	r28
    32dc:	1f 91       	pop	r17
    32de:	0f 91       	pop	r16
    32e0:	08 95       	ret

000032e2 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    32e2:	cf 93       	push	r28
    32e4:	df 93       	push	r29
    32e6:	ec 01       	movw	r28, r24
	switch (new_manip)
    32e8:	86 2f       	mov	r24, r22
    32ea:	90 e0       	ldi	r25, 0x00	; 0
    32ec:	8b 30       	cpi	r24, 0x0B	; 11
    32ee:	91 05       	cpc	r25, r1
    32f0:	d8 f5       	brcc	.+118    	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
    32f2:	fc 01       	movw	r30, r24
    32f4:	88 27       	eor	r24, r24
    32f6:	e2 50       	subi	r30, 0x02	; 2
    32f8:	ff 4f       	sbci	r31, 0xFF	; 255
    32fa:	8f 4f       	sbci	r24, 0xFF	; 255
    32fc:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3300:	82 e0       	ldi	r24, 0x02	; 2
    3302:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3304:	31 c0       	rjmp	.+98     	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3306:	88 e0       	ldi	r24, 0x08	; 8
    3308:	8a 83       	std	Y+2, r24	; 0x02
			break;
    330a:	2e c0       	rjmp	.+92     	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    330c:	8a e0       	ldi	r24, 0x0A	; 10
    330e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3310:	2b c0       	rjmp	.+86     	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3312:	80 e1       	ldi	r24, 0x10	; 16
    3314:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3316:	28 c0       	rjmp	.+80     	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3318:	81 e0       	ldi	r24, 0x01	; 1
    331a:	8b 83       	std	Y+3, r24	; 0x03
			break;
    331c:	25 c0       	rjmp	.+74     	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    331e:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3320:	23 c0       	rjmp	.+70     	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3322:	e8 81       	ld	r30, Y
    3324:	f9 81       	ldd	r31, Y+1	; 0x01
    3326:	02 80       	ldd	r0, Z+2	; 0x02
    3328:	f3 81       	ldd	r31, Z+3	; 0x03
    332a:	e0 2d       	mov	r30, r0
    332c:	6d e0       	ldi	r22, 0x0D	; 13
    332e:	ce 01       	movw	r24, r28
    3330:	19 95       	eicall
    3332:	e8 81       	ld	r30, Y
    3334:	f9 81       	ldd	r31, Y+1	; 0x01
    3336:	02 80       	ldd	r0, Z+2	; 0x02
    3338:	f3 81       	ldd	r31, Z+3	; 0x03
    333a:	e0 2d       	mov	r30, r0
    333c:	6a e0       	ldi	r22, 0x0A	; 10
    333e:	ce 01       	movw	r24, r28
    3340:	19 95       	eicall
			break;
    3342:	12 c0       	rjmp	.+36     	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3344:	e8 81       	ld	r30, Y
    3346:	f9 81       	ldd	r31, Y+1	; 0x01
    3348:	02 84       	ldd	r0, Z+10	; 0x0a
    334a:	f3 85       	ldd	r31, Z+11	; 0x0b
    334c:	e0 2d       	mov	r30, r0
    334e:	ce 01       	movw	r24, r28
    3350:	19 95       	eicall
			break;
    3352:	0a c0       	rjmp	.+20     	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3354:	e8 81       	ld	r30, Y
    3356:	f9 81       	ldd	r31, Y+1	; 0x01
    3358:	00 84       	ldd	r0, Z+8	; 0x08
    335a:	f1 85       	ldd	r31, Z+9	; 0x09
    335c:	e0 2d       	mov	r30, r0
    335e:	ce 01       	movw	r24, r28
    3360:	19 95       	eicall
			break;
    3362:	02 c0       	rjmp	.+4      	; 0x3368 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3364:	81 e0       	ldi	r24, 0x01	; 1
    3366:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3368:	ce 01       	movw	r24, r28
    336a:	df 91       	pop	r29
    336c:	cf 91       	pop	r28
    336e:	08 95       	ret

00003370 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    3370:	0f 93       	push	r16
    3372:	1f 93       	push	r17
    3374:	cf 93       	push	r28
    3376:	df 93       	push	r29
    3378:	cd b7       	in	r28, 0x3d	; 61
    337a:	de b7       	in	r29, 0x3e	; 62
    337c:	61 97       	sbiw	r28, 0x11	; 17
    337e:	cd bf       	out	0x3d, r28	; 61
    3380:	de bf       	out	0x3e, r29	; 62
    3382:	8c 01       	movw	r16, r24
    3384:	9b 01       	movw	r18, r22
	if (base != 10)
    3386:	fc 01       	movw	r30, r24
    3388:	92 81       	ldd	r25, Z+2	; 0x02
    338a:	9a 30       	cpi	r25, 0x0A	; 10
    338c:	21 f0       	breq	.+8      	; 0x3396 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    338e:	c8 01       	movw	r24, r16
    3390:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <_ZN8emstreamlsEj>
    3394:	0d c0       	rjmp	.+26     	; 0x33b0 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3396:	4a e0       	ldi	r20, 0x0A	; 10
    3398:	be 01       	movw	r22, r28
    339a:	6f 5f       	subi	r22, 0xFF	; 255
    339c:	7f 4f       	sbci	r23, 0xFF	; 255
    339e:	c9 01       	movw	r24, r18
    33a0:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    33a4:	be 01       	movw	r22, r28
    33a6:	6f 5f       	subi	r22, 0xFF	; 255
    33a8:	7f 4f       	sbci	r23, 0xFF	; 255
    33aa:	c8 01       	movw	r24, r16
    33ac:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    33b0:	c8 01       	movw	r24, r16
    33b2:	61 96       	adiw	r28, 0x11	; 17
    33b4:	cd bf       	out	0x3d, r28	; 61
    33b6:	de bf       	out	0x3e, r29	; 62
    33b8:	df 91       	pop	r29
    33ba:	cf 91       	pop	r28
    33bc:	1f 91       	pop	r17
    33be:	0f 91       	pop	r16
    33c0:	08 95       	ret

000033c2 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    33c2:	ff 92       	push	r15
    33c4:	0f 93       	push	r16
    33c6:	1f 93       	push	r17
    33c8:	cf 93       	push	r28
    33ca:	df 93       	push	r29
    33cc:	cd b7       	in	r28, 0x3d	; 61
    33ce:	de b7       	in	r29, 0x3e	; 62
    33d0:	61 97       	sbiw	r28, 0x11	; 17
    33d2:	cd bf       	out	0x3d, r28	; 61
    33d4:	de bf       	out	0x3e, r29	; 62
    33d6:	8c 01       	movw	r16, r24
    33d8:	f6 2e       	mov	r15, r22
    33da:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    33dc:	f8 01       	movw	r30, r16
    33de:	42 81       	ldd	r20, Z+2	; 0x02
    33e0:	40 31       	cpi	r20, 0x10	; 16
    33e2:	21 f0       	breq	.+8      	; 0x33ec <_ZN8emstreamlsEj+0x2a>
    33e4:	48 30       	cpi	r20, 0x08	; 8
    33e6:	11 f0       	breq	.+4      	; 0x33ec <_ZN8emstreamlsEj+0x2a>
    33e8:	42 30       	cpi	r20, 0x02	; 2
    33ea:	41 f4       	brne	.+16     	; 0x33fc <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    33ec:	69 2f       	mov	r22, r25
    33ee:	c8 01       	movw	r24, r16
    33f0:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
    33f4:	6f 2d       	mov	r22, r15
    33f6:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
    33fa:	0d c0       	rjmp	.+26     	; 0x3416 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    33fc:	50 e0       	ldi	r21, 0x00	; 0
    33fe:	be 01       	movw	r22, r28
    3400:	6f 5f       	subi	r22, 0xFF	; 255
    3402:	7f 4f       	sbci	r23, 0xFF	; 255
    3404:	8f 2d       	mov	r24, r15
    3406:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    340a:	be 01       	movw	r22, r28
    340c:	6f 5f       	subi	r22, 0xFF	; 255
    340e:	7f 4f       	sbci	r23, 0xFF	; 255
    3410:	c8 01       	movw	r24, r16
    3412:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3416:	c8 01       	movw	r24, r16
    3418:	61 96       	adiw	r28, 0x11	; 17
    341a:	cd bf       	out	0x3d, r28	; 61
    341c:	de bf       	out	0x3e, r29	; 62
    341e:	df 91       	pop	r29
    3420:	cf 91       	pop	r28
    3422:	1f 91       	pop	r17
    3424:	0f 91       	pop	r16
    3426:	ff 90       	pop	r15
    3428:	08 95       	ret

0000342a <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    342a:	df 92       	push	r13
    342c:	ef 92       	push	r14
    342e:	ff 92       	push	r15
    3430:	0f 93       	push	r16
    3432:	1f 93       	push	r17
    3434:	cf 93       	push	r28
    3436:	df 93       	push	r29
    3438:	cd b7       	in	r28, 0x3d	; 61
    343a:	de b7       	in	r29, 0x3e	; 62
    343c:	a1 97       	sbiw	r28, 0x21	; 33
    343e:	cd bf       	out	0x3d, r28	; 61
    3440:	de bf       	out	0x3e, r29	; 62
    3442:	8c 01       	movw	r16, r24
    3444:	d4 2e       	mov	r13, r20
    3446:	e5 2e       	mov	r14, r21
    3448:	f6 2e       	mov	r15, r22
    344a:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    344c:	f8 01       	movw	r30, r16
    344e:	22 81       	ldd	r18, Z+2	; 0x02
    3450:	20 31       	cpi	r18, 0x10	; 16
    3452:	21 f0       	breq	.+8      	; 0x345c <_ZN8emstreamlsEm+0x32>
    3454:	28 30       	cpi	r18, 0x08	; 8
    3456:	11 f0       	breq	.+4      	; 0x345c <_ZN8emstreamlsEm+0x32>
    3458:	22 30       	cpi	r18, 0x02	; 2
    345a:	71 f4       	brne	.+28     	; 0x3478 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    345c:	69 2f       	mov	r22, r25
    345e:	c8 01       	movw	r24, r16
    3460:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
    3464:	6f 2d       	mov	r22, r15
    3466:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
    346a:	6e 2d       	mov	r22, r14
    346c:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
    3470:	6d 2d       	mov	r22, r13
    3472:	0e 94 57 1a 	call	0x34ae	; 0x34ae <_ZN8emstreamlsEh>
    3476:	0f c0       	rjmp	.+30     	; 0x3496 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3478:	30 e0       	ldi	r19, 0x00	; 0
    347a:	ae 01       	movw	r20, r28
    347c:	4f 5f       	subi	r20, 0xFF	; 255
    347e:	5f 4f       	sbci	r21, 0xFF	; 255
    3480:	6d 2d       	mov	r22, r13
    3482:	7e 2d       	mov	r23, r14
    3484:	8f 2d       	mov	r24, r15
    3486:	0e 94 8b 1f 	call	0x3f16	; 0x3f16 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    348a:	be 01       	movw	r22, r28
    348c:	6f 5f       	subi	r22, 0xFF	; 255
    348e:	7f 4f       	sbci	r23, 0xFF	; 255
    3490:	c8 01       	movw	r24, r16
    3492:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3496:	c8 01       	movw	r24, r16
    3498:	a1 96       	adiw	r28, 0x21	; 33
    349a:	cd bf       	out	0x3d, r28	; 61
    349c:	de bf       	out	0x3e, r29	; 62
    349e:	df 91       	pop	r29
    34a0:	cf 91       	pop	r28
    34a2:	1f 91       	pop	r17
    34a4:	0f 91       	pop	r16
    34a6:	ff 90       	pop	r15
    34a8:	ef 90       	pop	r14
    34aa:	df 90       	pop	r13
    34ac:	08 95       	ret

000034ae <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    34ae:	cf 92       	push	r12
    34b0:	df 92       	push	r13
    34b2:	ef 92       	push	r14
    34b4:	ff 92       	push	r15
    34b6:	0f 93       	push	r16
    34b8:	1f 93       	push	r17
    34ba:	cf 93       	push	r28
    34bc:	df 93       	push	r29
    34be:	cd b7       	in	r28, 0x3d	; 61
    34c0:	de b7       	in	r29, 0x3e	; 62
    34c2:	29 97       	sbiw	r28, 0x09	; 9
    34c4:	cd bf       	out	0x3d, r28	; 61
    34c6:	de bf       	out	0x3e, r29	; 62
    34c8:	8c 01       	movw	r16, r24
    34ca:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    34cc:	dc 01       	movw	r26, r24
    34ce:	13 96       	adiw	r26, 0x03	; 3
    34d0:	8c 91       	ld	r24, X
    34d2:	13 97       	sbiw	r26, 0x03	; 3
    34d4:	88 23       	and	r24, r24
    34d6:	41 f0       	breq	.+16     	; 0x34e8 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    34d8:	ed 91       	ld	r30, X+
    34da:	fc 91       	ld	r31, X
    34dc:	02 80       	ldd	r0, Z+2	; 0x02
    34de:	f3 81       	ldd	r31, Z+3	; 0x03
    34e0:	e0 2d       	mov	r30, r0
    34e2:	c8 01       	movw	r24, r16
    34e4:	19 95       	eicall
    34e6:	56 c0       	rjmp	.+172    	; 0x3594 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    34e8:	f8 01       	movw	r30, r16
    34ea:	42 81       	ldd	r20, Z+2	; 0x02
    34ec:	42 30       	cpi	r20, 0x02	; 2
    34ee:	19 f5       	brne	.+70     	; 0x3536 <_ZN8emstreamlsEh+0x88>
    34f0:	68 94       	set
    34f2:	cc 24       	eor	r12, r12
    34f4:	c3 f8       	bld	r12, 3
    34f6:	d1 2c       	mov	r13, r1
    34f8:	68 94       	set
    34fa:	ff 24       	eor	r15, r15
    34fc:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    34fe:	8e 2d       	mov	r24, r14
    3500:	8f 21       	and	r24, r15
    3502:	51 f0       	breq	.+20     	; 0x3518 <_ZN8emstreamlsEh+0x6a>
    3504:	d8 01       	movw	r26, r16
    3506:	ed 91       	ld	r30, X+
    3508:	fc 91       	ld	r31, X
    350a:	02 80       	ldd	r0, Z+2	; 0x02
    350c:	f3 81       	ldd	r31, Z+3	; 0x03
    350e:	e0 2d       	mov	r30, r0
    3510:	61 e3       	ldi	r22, 0x31	; 49
    3512:	c8 01       	movw	r24, r16
    3514:	19 95       	eicall
    3516:	09 c0       	rjmp	.+18     	; 0x352a <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3518:	d8 01       	movw	r26, r16
    351a:	ed 91       	ld	r30, X+
    351c:	fc 91       	ld	r31, X
    351e:	02 80       	ldd	r0, Z+2	; 0x02
    3520:	f3 81       	ldd	r31, Z+3	; 0x03
    3522:	e0 2d       	mov	r30, r0
    3524:	60 e3       	ldi	r22, 0x30	; 48
    3526:	c8 01       	movw	r24, r16
    3528:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    352a:	f6 94       	lsr	r15
    352c:	b1 e0       	ldi	r27, 0x01	; 1
    352e:	cb 1a       	sub	r12, r27
    3530:	d1 08       	sbc	r13, r1
    3532:	29 f7       	brne	.-54     	; 0x34fe <_ZN8emstreamlsEh+0x50>
    3534:	2f c0       	rjmp	.+94     	; 0x3594 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3536:	40 31       	cpi	r20, 0x10	; 16
    3538:	f9 f4       	brne	.+62     	; 0x3578 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    353a:	62 95       	swap	r22
    353c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    353e:	01 90       	ld	r0, Z+
    3540:	f0 81       	ld	r31, Z
    3542:	e0 2d       	mov	r30, r0
    3544:	02 80       	ldd	r0, Z+2	; 0x02
    3546:	f3 81       	ldd	r31, Z+3	; 0x03
    3548:	e0 2d       	mov	r30, r0
    354a:	6a 30       	cpi	r22, 0x0A	; 10
    354c:	10 f0       	brcs	.+4      	; 0x3552 <_ZN8emstreamlsEh+0xa4>
    354e:	69 5c       	subi	r22, 0xC9	; 201
    3550:	01 c0       	rjmp	.+2      	; 0x3554 <_ZN8emstreamlsEh+0xa6>
    3552:	60 5d       	subi	r22, 0xD0	; 208
    3554:	c8 01       	movw	r24, r16
    3556:	19 95       	eicall
		temp_char = num & 0x0F;
    3558:	6e 2d       	mov	r22, r14
    355a:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    355c:	d8 01       	movw	r26, r16
    355e:	ed 91       	ld	r30, X+
    3560:	fc 91       	ld	r31, X
    3562:	02 80       	ldd	r0, Z+2	; 0x02
    3564:	f3 81       	ldd	r31, Z+3	; 0x03
    3566:	e0 2d       	mov	r30, r0
    3568:	6a 30       	cpi	r22, 0x0A	; 10
    356a:	10 f0       	brcs	.+4      	; 0x3570 <_ZN8emstreamlsEh+0xc2>
    356c:	69 5c       	subi	r22, 0xC9	; 201
    356e:	01 c0       	rjmp	.+2      	; 0x3572 <_ZN8emstreamlsEh+0xc4>
    3570:	60 5d       	subi	r22, 0xD0	; 208
    3572:	c8 01       	movw	r24, r16
    3574:	19 95       	eicall
    3576:	0e c0       	rjmp	.+28     	; 0x3594 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3578:	50 e0       	ldi	r21, 0x00	; 0
    357a:	be 01       	movw	r22, r28
    357c:	6f 5f       	subi	r22, 0xFF	; 255
    357e:	7f 4f       	sbci	r23, 0xFF	; 255
    3580:	8e 2d       	mov	r24, r14
    3582:	90 e0       	ldi	r25, 0x00	; 0
    3584:	0e 94 b8 1f 	call	0x3f70	; 0x3f70 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3588:	be 01       	movw	r22, r28
    358a:	6f 5f       	subi	r22, 0xFF	; 255
    358c:	7f 4f       	sbci	r23, 0xFF	; 255
    358e:	c8 01       	movw	r24, r16
    3590:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3594:	c8 01       	movw	r24, r16
    3596:	29 96       	adiw	r28, 0x09	; 9
    3598:	cd bf       	out	0x3d, r28	; 61
    359a:	de bf       	out	0x3e, r29	; 62
    359c:	df 91       	pop	r29
    359e:	cf 91       	pop	r28
    35a0:	1f 91       	pop	r17
    35a2:	0f 91       	pop	r16
    35a4:	ff 90       	pop	r15
    35a6:	ef 90       	pop	r14
    35a8:	df 90       	pop	r13
    35aa:	cf 90       	pop	r12
    35ac:	08 95       	ret

000035ae <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    35ae:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    35b0:	50 96       	adiw	r26, 0x10	; 16
    35b2:	ed 91       	ld	r30, X+
    35b4:	fc 91       	ld	r31, X
    35b6:	51 97       	sbiw	r26, 0x11	; 17
    35b8:	80 81       	ld	r24, Z
    35ba:	54 96       	adiw	r26, 0x14	; 20
    35bc:	4c 91       	ld	r20, X
    35be:	54 97       	sbiw	r26, 0x14	; 20
    35c0:	84 23       	and	r24, r20
    35c2:	29 f0       	breq	.+10     	; 0x35ce <_ZN5rs2327putcharEc+0x20>
    35c4:	09 c0       	rjmp	.+18     	; 0x35d8 <_ZN5rs2327putcharEc+0x2a>
    35c6:	21 50       	subi	r18, 0x01	; 1
    35c8:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    35ca:	19 f4       	brne	.+6      	; 0x35d2 <_ZN5rs2327putcharEc+0x24>
    35cc:	12 c0       	rjmp	.+36     	; 0x35f2 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    35ce:	21 e2       	ldi	r18, 0x21	; 33
    35d0:	3e e4       	ldi	r19, 0x4E	; 78
    35d2:	90 81       	ld	r25, Z
    35d4:	94 23       	and	r25, r20
    35d6:	b9 f3       	breq	.-18     	; 0x35c6 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    35d8:	90 81       	ld	r25, Z
    35da:	56 96       	adiw	r26, 0x16	; 22
    35dc:	8c 91       	ld	r24, X
    35de:	56 97       	sbiw	r26, 0x16	; 22
    35e0:	89 2b       	or	r24, r25
    35e2:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    35e4:	1e 96       	adiw	r26, 0x0e	; 14
    35e6:	ed 91       	ld	r30, X+
    35e8:	fc 91       	ld	r31, X
    35ea:	1f 97       	sbiw	r26, 0x0f	; 15
    35ec:	60 83       	st	Z, r22
	return (true);
    35ee:	81 e0       	ldi	r24, 0x01	; 1
    35f0:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    35f2:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    35f4:	08 95       	ret

000035f6 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    35f6:	cf 93       	push	r28
    35f8:	df 93       	push	r29
    35fa:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    35fc:	c1 8d       	ldd	r28, Z+25	; 0x19
    35fe:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3600:	28 81       	ld	r18, Y
    3602:	39 81       	ldd	r19, Y+1	; 0x01
    3604:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3606:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3608:	4d 91       	ld	r20, X+
    360a:	5c 91       	ld	r21, X
    360c:	24 17       	cp	r18, r20
    360e:	35 07       	cpc	r19, r21
    3610:	e9 f3       	breq	.-6      	; 0x360c <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3612:	a7 89       	ldd	r26, Z+23	; 0x17
    3614:	b0 8d       	ldd	r27, Z+24	; 0x18
    3616:	0d 90       	ld	r0, X+
    3618:	bc 91       	ld	r27, X
    361a:	a0 2d       	mov	r26, r0
    361c:	a2 0f       	add	r26, r18
    361e:	b3 1f       	adc	r27, r19
    3620:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3622:	2f 5f       	subi	r18, 0xFF	; 255
    3624:	3f 4f       	sbci	r19, 0xFF	; 255
    3626:	28 83       	st	Y, r18
    3628:	39 83       	std	Y+1, r19	; 0x01
    362a:	24 36       	cpi	r18, 0x64	; 100
    362c:	31 05       	cpc	r19, r1
    362e:	28 f0       	brcs	.+10     	; 0x363a <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3630:	01 8c       	ldd	r0, Z+25	; 0x19
    3632:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3634:	e0 2d       	mov	r30, r0
    3636:	10 82       	st	Z, r1
    3638:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    363a:	90 e0       	ldi	r25, 0x00	; 0
    363c:	df 91       	pop	r29
    363e:	cf 91       	pop	r28
    3640:	08 95       	ret

00003642 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3642:	cf 93       	push	r28
    3644:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3646:	ec 01       	movw	r28, r24
    3648:	a9 8d       	ldd	r26, Y+25	; 0x19
    364a:	ba 8d       	ldd	r27, Y+26	; 0x1a
    364c:	eb 8d       	ldd	r30, Y+27	; 0x1b
    364e:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3650:	81 e0       	ldi	r24, 0x01	; 1
    3652:	4d 91       	ld	r20, X+
    3654:	5c 91       	ld	r21, X
    3656:	20 81       	ld	r18, Z
    3658:	31 81       	ldd	r19, Z+1	; 0x01
    365a:	42 17       	cp	r20, r18
    365c:	53 07       	cpc	r21, r19
    365e:	09 f4       	brne	.+2      	; 0x3662 <_ZN5rs23214check_for_charEv+0x20>
    3660:	80 e0       	ldi	r24, 0x00	; 0
}
    3662:	df 91       	pop	r29
    3664:	cf 91       	pop	r28
    3666:	08 95       	ret

00003668 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3668:	dc 01       	movw	r26, r24
    366a:	ed 91       	ld	r30, X+
    366c:	fc 91       	ld	r31, X
    366e:	02 80       	ldd	r0, Z+2	; 0x02
    3670:	f3 81       	ldd	r31, Z+3	; 0x03
    3672:	e0 2d       	mov	r30, r0
    3674:	6c e0       	ldi	r22, 0x0C	; 12
    3676:	19 95       	eicall
    3678:	08 95       	ret

0000367a <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    367a:	ef 92       	push	r14
    367c:	ff 92       	push	r15
    367e:	0f 93       	push	r16
    3680:	1f 93       	push	r17
    3682:	cf 93       	push	r28
    3684:	df 93       	push	r29
    3686:	ec 01       	movw	r28, r24
    3688:	7b 01       	movw	r14, r22
    368a:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    368c:	0e 94 2c 19 	call	0x3258	; 0x3258 <_ZN8emstreamC1Ev>
    3690:	a8 01       	movw	r20, r16
    3692:	b7 01       	movw	r22, r14
    3694:	ce 01       	movw	r24, r28
    3696:	08 96       	adiw	r24, 0x08	; 8
    3698:	0e 94 8d 18 	call	0x311a	; 0x311a <_ZN7base232C1EjP12USART_struct>
    369c:	86 e7       	ldi	r24, 0x76	; 118
    369e:	90 e2       	ldi	r25, 0x20	; 32
    36a0:	88 83       	st	Y, r24
    36a2:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    36a4:	00 3a       	cpi	r16, 0xA0	; 160
    36a6:	88 e0       	ldi	r24, 0x08	; 8
    36a8:	18 07       	cpc	r17, r24
    36aa:	69 f4       	brne	.+26     	; 0x36c6 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    36ac:	82 e5       	ldi	r24, 0x52	; 82
    36ae:	91 e3       	ldi	r25, 0x31	; 49
    36b0:	8f 8b       	std	Y+23, r24	; 0x17
    36b2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    36b4:	88 e4       	ldi	r24, 0x48	; 72
    36b6:	91 e3       	ldi	r25, 0x31	; 49
    36b8:	89 8f       	std	Y+25, r24	; 0x19
    36ba:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    36bc:	8e e3       	ldi	r24, 0x3E	; 62
    36be:	91 e3       	ldi	r25, 0x31	; 49
    36c0:	8b 8f       	std	Y+27, r24	; 0x1b
    36c2:	9c 8f       	std	Y+28, r25	; 0x1c
    36c4:	42 c0       	rjmp	.+132    	; 0x374a <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    36c6:	00 3b       	cpi	r16, 0xB0	; 176
    36c8:	e8 e0       	ldi	r30, 0x08	; 8
    36ca:	1e 07       	cpc	r17, r30
    36cc:	69 f4       	brne	.+26     	; 0x36e8 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    36ce:	80 e5       	ldi	r24, 0x50	; 80
    36d0:	91 e3       	ldi	r25, 0x31	; 49
    36d2:	8f 8b       	std	Y+23, r24	; 0x17
    36d4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    36d6:	86 e4       	ldi	r24, 0x46	; 70
    36d8:	91 e3       	ldi	r25, 0x31	; 49
    36da:	89 8f       	std	Y+25, r24	; 0x19
    36dc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    36de:	8c e3       	ldi	r24, 0x3C	; 60
    36e0:	91 e3       	ldi	r25, 0x31	; 49
    36e2:	8b 8f       	std	Y+27, r24	; 0x1b
    36e4:	9c 8f       	std	Y+28, r25	; 0x1c
    36e6:	31 c0       	rjmp	.+98     	; 0x374a <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    36e8:	00 3a       	cpi	r16, 0xA0	; 160
    36ea:	f9 e0       	ldi	r31, 0x09	; 9
    36ec:	1f 07       	cpc	r17, r31
    36ee:	69 f4       	brne	.+26     	; 0x370a <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    36f0:	8e e4       	ldi	r24, 0x4E	; 78
    36f2:	91 e3       	ldi	r25, 0x31	; 49
    36f4:	8f 8b       	std	Y+23, r24	; 0x17
    36f6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    36f8:	84 e4       	ldi	r24, 0x44	; 68
    36fa:	91 e3       	ldi	r25, 0x31	; 49
    36fc:	89 8f       	std	Y+25, r24	; 0x19
    36fe:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3700:	8a e3       	ldi	r24, 0x3A	; 58
    3702:	91 e3       	ldi	r25, 0x31	; 49
    3704:	8b 8f       	std	Y+27, r24	; 0x1b
    3706:	9c 8f       	std	Y+28, r25	; 0x1c
    3708:	20 c0       	rjmp	.+64     	; 0x374a <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    370a:	00 3b       	cpi	r16, 0xB0	; 176
    370c:	89 e0       	ldi	r24, 0x09	; 9
    370e:	18 07       	cpc	r17, r24
    3710:	69 f4       	brne	.+26     	; 0x372c <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3712:	8c e4       	ldi	r24, 0x4C	; 76
    3714:	91 e3       	ldi	r25, 0x31	; 49
    3716:	8f 8b       	std	Y+23, r24	; 0x17
    3718:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    371a:	82 e4       	ldi	r24, 0x42	; 66
    371c:	91 e3       	ldi	r25, 0x31	; 49
    371e:	89 8f       	std	Y+25, r24	; 0x19
    3720:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3722:	88 e3       	ldi	r24, 0x38	; 56
    3724:	91 e3       	ldi	r25, 0x31	; 49
    3726:	8b 8f       	std	Y+27, r24	; 0x1b
    3728:	9c 8f       	std	Y+28, r25	; 0x1c
    372a:	0f c0       	rjmp	.+30     	; 0x374a <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    372c:	00 3a       	cpi	r16, 0xA0	; 160
    372e:	1a 40       	sbci	r17, 0x0A	; 10
    3730:	61 f4       	brne	.+24     	; 0x374a <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3732:	8a e4       	ldi	r24, 0x4A	; 74
    3734:	91 e3       	ldi	r25, 0x31	; 49
    3736:	8f 8b       	std	Y+23, r24	; 0x17
    3738:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    373a:	80 e4       	ldi	r24, 0x40	; 64
    373c:	91 e3       	ldi	r25, 0x31	; 49
    373e:	89 8f       	std	Y+25, r24	; 0x19
    3740:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3742:	86 e3       	ldi	r24, 0x36	; 54
    3744:	91 e3       	ldi	r25, 0x31	; 49
    3746:	8b 8f       	std	Y+27, r24	; 0x1b
    3748:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    374a:	0f 89       	ldd	r16, Y+23	; 0x17
    374c:	18 8d       	ldd	r17, Y+24	; 0x18
    374e:	84 e6       	ldi	r24, 0x64	; 100
    3750:	90 e0       	ldi	r25, 0x00	; 0
    3752:	0e 94 89 18 	call	0x3112	; 0x3112 <_Znaj>
    3756:	f8 01       	movw	r30, r16
    3758:	80 83       	st	Z, r24
    375a:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    375c:	e9 8d       	ldd	r30, Y+25	; 0x19
    375e:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3760:	10 82       	st	Z, r1
    3762:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3764:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3766:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3768:	10 82       	st	Z, r1
    376a:	11 82       	std	Z+1, r1	; 0x01
}
    376c:	df 91       	pop	r29
    376e:	cf 91       	pop	r28
    3770:	1f 91       	pop	r17
    3772:	0f 91       	pop	r16
    3774:	ff 90       	pop	r15
    3776:	ef 90       	pop	r14
    3778:	08 95       	ret

0000377a <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    377a:	1f 92       	push	r1
    377c:	0f 92       	push	r0
    377e:	0f b6       	in	r0, 0x3f	; 63
    3780:	0f 92       	push	r0
    3782:	11 24       	eor	r1, r1
    3784:	08 b6       	in	r0, 0x38	; 56
    3786:	0f 92       	push	r0
    3788:	18 be       	out	0x38, r1	; 56
    378a:	0b b6       	in	r0, 0x3b	; 59
    378c:	0f 92       	push	r0
    378e:	1b be       	out	0x3b, r1	; 59
    3790:	2f 93       	push	r18
    3792:	3f 93       	push	r19
    3794:	8f 93       	push	r24
    3796:	9f 93       	push	r25
    3798:	ef 93       	push	r30
    379a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    379c:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    37a0:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <rcvC0_buffer>
    37a4:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <rcvC0_buffer+0x1>
    37a8:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvC0_write_index>
    37ac:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvC0_write_index+0x1>
    37b0:	e8 0f       	add	r30, r24
    37b2:	f9 1f       	adc	r31, r25
    37b4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    37b6:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvC0_write_index>
    37ba:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvC0_write_index+0x1>
    37be:	01 96       	adiw	r24, 0x01	; 1
    37c0:	84 36       	cpi	r24, 0x64	; 100
    37c2:	91 05       	cpc	r25, r1
    37c4:	60 f4       	brcc	.+24     	; 0x37de <__vector_25+0x64>
    37c6:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <rcvC0_write_index>
    37ca:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    37ce:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <rcvC0_read_index>
    37d2:	30 91 49 31 	lds	r19, 0x3149	; 0x803149 <rcvC0_read_index+0x1>
    37d6:	82 17       	cp	r24, r18
    37d8:	93 07       	cpc	r25, r19
    37da:	f1 f4       	brne	.+60     	; 0x3818 <__vector_25+0x9e>
    37dc:	0c c0       	rjmp	.+24     	; 0x37f6 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    37de:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <rcvC0_write_index>
    37e2:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    37e6:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvC0_read_index>
    37ea:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvC0_read_index+0x1>
    37ee:	18 16       	cp	r1, r24
    37f0:	19 06       	cpc	r1, r25
    37f2:	91 f4       	brne	.+36     	; 0x3818 <__vector_25+0x9e>
    37f4:	0e c0       	rjmp	.+28     	; 0x3812 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    37f6:	01 96       	adiw	r24, 0x01	; 1
    37f8:	84 36       	cpi	r24, 0x64	; 100
    37fa:	91 05       	cpc	r25, r1
    37fc:	28 f4       	brcc	.+10     	; 0x3808 <__vector_25+0x8e>
    37fe:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <rcvC0_read_index>
    3802:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <rcvC0_read_index+0x1>
    3806:	08 c0       	rjmp	.+16     	; 0x3818 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3808:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rcvC0_read_index>
    380c:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <rcvC0_read_index+0x1>
}
    3810:	03 c0       	rjmp	.+6      	; 0x3818 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3812:	81 e0       	ldi	r24, 0x01	; 1
    3814:	90 e0       	ldi	r25, 0x00	; 0
    3816:	f3 cf       	rjmp	.-26     	; 0x37fe <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3818:	ff 91       	pop	r31
    381a:	ef 91       	pop	r30
    381c:	9f 91       	pop	r25
    381e:	8f 91       	pop	r24
    3820:	3f 91       	pop	r19
    3822:	2f 91       	pop	r18
    3824:	0f 90       	pop	r0
    3826:	0b be       	out	0x3b, r0	; 59
    3828:	0f 90       	pop	r0
    382a:	08 be       	out	0x38, r0	; 56
    382c:	0f 90       	pop	r0
    382e:	0f be       	out	0x3f, r0	; 63
    3830:	0f 90       	pop	r0
    3832:	1f 90       	pop	r1
    3834:	18 95       	reti

00003836 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3836:	1f 92       	push	r1
    3838:	0f 92       	push	r0
    383a:	0f b6       	in	r0, 0x3f	; 63
    383c:	0f 92       	push	r0
    383e:	11 24       	eor	r1, r1
    3840:	08 b6       	in	r0, 0x38	; 56
    3842:	0f 92       	push	r0
    3844:	18 be       	out	0x38, r1	; 56
    3846:	0b b6       	in	r0, 0x3b	; 59
    3848:	0f 92       	push	r0
    384a:	1b be       	out	0x3b, r1	; 59
    384c:	2f 93       	push	r18
    384e:	3f 93       	push	r19
    3850:	8f 93       	push	r24
    3852:	9f 93       	push	r25
    3854:	ef 93       	push	r30
    3856:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3858:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    385c:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <rcvC1_buffer>
    3860:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <rcvC1_buffer+0x1>
    3864:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC1_write_index>
    3868:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC1_write_index+0x1>
    386c:	e8 0f       	add	r30, r24
    386e:	f9 1f       	adc	r31, r25
    3870:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3872:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC1_write_index>
    3876:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC1_write_index+0x1>
    387a:	01 96       	adiw	r24, 0x01	; 1
    387c:	84 36       	cpi	r24, 0x64	; 100
    387e:	91 05       	cpc	r25, r1
    3880:	60 f4       	brcc	.+24     	; 0x389a <__vector_28+0x64>
    3882:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <rcvC1_write_index>
    3886:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    388a:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <rcvC1_read_index>
    388e:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <rcvC1_read_index+0x1>
    3892:	82 17       	cp	r24, r18
    3894:	93 07       	cpc	r25, r19
    3896:	f1 f4       	brne	.+60     	; 0x38d4 <__vector_28+0x9e>
    3898:	0c c0       	rjmp	.+24     	; 0x38b2 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    389a:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rcvC1_write_index>
    389e:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    38a2:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvC1_read_index>
    38a6:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvC1_read_index+0x1>
    38aa:	18 16       	cp	r1, r24
    38ac:	19 06       	cpc	r1, r25
    38ae:	91 f4       	brne	.+36     	; 0x38d4 <__vector_28+0x9e>
    38b0:	0e c0       	rjmp	.+28     	; 0x38ce <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    38b2:	01 96       	adiw	r24, 0x01	; 1
    38b4:	84 36       	cpi	r24, 0x64	; 100
    38b6:	91 05       	cpc	r25, r1
    38b8:	28 f4       	brcc	.+10     	; 0x38c4 <__vector_28+0x8e>
    38ba:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvC1_read_index>
    38be:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvC1_read_index+0x1>
    38c2:	08 c0       	rjmp	.+16     	; 0x38d4 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    38c4:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvC1_read_index>
    38c8:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvC1_read_index+0x1>
}
    38cc:	03 c0       	rjmp	.+6      	; 0x38d4 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    38ce:	81 e0       	ldi	r24, 0x01	; 1
    38d0:	90 e0       	ldi	r25, 0x00	; 0
    38d2:	f3 cf       	rjmp	.-26     	; 0x38ba <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    38d4:	ff 91       	pop	r31
    38d6:	ef 91       	pop	r30
    38d8:	9f 91       	pop	r25
    38da:	8f 91       	pop	r24
    38dc:	3f 91       	pop	r19
    38de:	2f 91       	pop	r18
    38e0:	0f 90       	pop	r0
    38e2:	0b be       	out	0x3b, r0	; 59
    38e4:	0f 90       	pop	r0
    38e6:	08 be       	out	0x38, r0	; 56
    38e8:	0f 90       	pop	r0
    38ea:	0f be       	out	0x3f, r0	; 63
    38ec:	0f 90       	pop	r0
    38ee:	1f 90       	pop	r1
    38f0:	18 95       	reti

000038f2 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    38f2:	1f 92       	push	r1
    38f4:	0f 92       	push	r0
    38f6:	0f b6       	in	r0, 0x3f	; 63
    38f8:	0f 92       	push	r0
    38fa:	11 24       	eor	r1, r1
    38fc:	08 b6       	in	r0, 0x38	; 56
    38fe:	0f 92       	push	r0
    3900:	18 be       	out	0x38, r1	; 56
    3902:	0b b6       	in	r0, 0x3b	; 59
    3904:	0f 92       	push	r0
    3906:	1b be       	out	0x3b, r1	; 59
    3908:	2f 93       	push	r18
    390a:	3f 93       	push	r19
    390c:	8f 93       	push	r24
    390e:	9f 93       	push	r25
    3910:	ef 93       	push	r30
    3912:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3914:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3918:	e0 91 4e 31 	lds	r30, 0x314E	; 0x80314e <rcvD0_buffer>
    391c:	f0 91 4f 31 	lds	r31, 0x314F	; 0x80314f <rcvD0_buffer+0x1>
    3920:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvC0_write_index>
    3924:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvC0_write_index+0x1>
    3928:	e8 0f       	add	r30, r24
    392a:	f9 1f       	adc	r31, r25
    392c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    392e:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvD0_write_index>
    3932:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvD0_write_index+0x1>
    3936:	01 96       	adiw	r24, 0x01	; 1
    3938:	84 36       	cpi	r24, 0x64	; 100
    393a:	91 05       	cpc	r25, r1
    393c:	60 f4       	brcc	.+24     	; 0x3956 <__vector_88+0x64>
    393e:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvD0_write_index>
    3942:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3946:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <rcvD0_read_index>
    394a:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <rcvD0_read_index+0x1>
    394e:	82 17       	cp	r24, r18
    3950:	93 07       	cpc	r25, r19
    3952:	f1 f4       	brne	.+60     	; 0x3990 <__vector_88+0x9e>
    3954:	0c c0       	rjmp	.+24     	; 0x396e <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3956:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvD0_write_index>
    395a:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    395e:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <rcvD0_read_index>
    3962:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <rcvD0_read_index+0x1>
    3966:	18 16       	cp	r1, r24
    3968:	19 06       	cpc	r1, r25
    396a:	91 f4       	brne	.+36     	; 0x3990 <__vector_88+0x9e>
    396c:	0e c0       	rjmp	.+28     	; 0x398a <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    396e:	01 96       	adiw	r24, 0x01	; 1
    3970:	84 36       	cpi	r24, 0x64	; 100
    3972:	91 05       	cpc	r25, r1
    3974:	28 f4       	brcc	.+10     	; 0x3980 <__vector_88+0x8e>
    3976:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <rcvD0_read_index>
    397a:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <rcvD0_read_index+0x1>
    397e:	08 c0       	rjmp	.+16     	; 0x3990 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3980:	10 92 44 31 	sts	0x3144, r1	; 0x803144 <rcvD0_read_index>
    3984:	10 92 45 31 	sts	0x3145, r1	; 0x803145 <rcvD0_read_index+0x1>
}
    3988:	03 c0       	rjmp	.+6      	; 0x3990 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    398a:	81 e0       	ldi	r24, 0x01	; 1
    398c:	90 e0       	ldi	r25, 0x00	; 0
    398e:	f3 cf       	rjmp	.-26     	; 0x3976 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3990:	ff 91       	pop	r31
    3992:	ef 91       	pop	r30
    3994:	9f 91       	pop	r25
    3996:	8f 91       	pop	r24
    3998:	3f 91       	pop	r19
    399a:	2f 91       	pop	r18
    399c:	0f 90       	pop	r0
    399e:	0b be       	out	0x3b, r0	; 59
    39a0:	0f 90       	pop	r0
    39a2:	08 be       	out	0x38, r0	; 56
    39a4:	0f 90       	pop	r0
    39a6:	0f be       	out	0x3f, r0	; 63
    39a8:	0f 90       	pop	r0
    39aa:	1f 90       	pop	r1
    39ac:	18 95       	reti

000039ae <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    39ae:	1f 92       	push	r1
    39b0:	0f 92       	push	r0
    39b2:	0f b6       	in	r0, 0x3f	; 63
    39b4:	0f 92       	push	r0
    39b6:	11 24       	eor	r1, r1
    39b8:	08 b6       	in	r0, 0x38	; 56
    39ba:	0f 92       	push	r0
    39bc:	18 be       	out	0x38, r1	; 56
    39be:	0b b6       	in	r0, 0x3b	; 59
    39c0:	0f 92       	push	r0
    39c2:	1b be       	out	0x3b, r1	; 59
    39c4:	2f 93       	push	r18
    39c6:	3f 93       	push	r19
    39c8:	8f 93       	push	r24
    39ca:	9f 93       	push	r25
    39cc:	ef 93       	push	r30
    39ce:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    39d0:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    39d4:	e0 91 4c 31 	lds	r30, 0x314C	; 0x80314c <rcvD1_buffer>
    39d8:	f0 91 4d 31 	lds	r31, 0x314D	; 0x80314d <rcvD1_buffer+0x1>
    39dc:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvD1_write_index>
    39e0:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvD1_write_index+0x1>
    39e4:	e8 0f       	add	r30, r24
    39e6:	f9 1f       	adc	r31, r25
    39e8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    39ea:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvD1_write_index>
    39ee:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvD1_write_index+0x1>
    39f2:	01 96       	adiw	r24, 0x01	; 1
    39f4:	84 36       	cpi	r24, 0x64	; 100
    39f6:	91 05       	cpc	r25, r1
    39f8:	60 f4       	brcc	.+24     	; 0x3a12 <__vector_91+0x64>
    39fa:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvD1_write_index>
    39fe:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3a02:	20 91 42 31 	lds	r18, 0x3142	; 0x803142 <rcvD1_read_index>
    3a06:	30 91 43 31 	lds	r19, 0x3143	; 0x803143 <rcvD1_read_index+0x1>
    3a0a:	82 17       	cp	r24, r18
    3a0c:	93 07       	cpc	r25, r19
    3a0e:	f1 f4       	brne	.+60     	; 0x3a4c <__vector_91+0x9e>
    3a10:	0c c0       	rjmp	.+24     	; 0x3a2a <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3a12:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvD1_write_index>
    3a16:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3a1a:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvD1_read_index>
    3a1e:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvD1_read_index+0x1>
    3a22:	18 16       	cp	r1, r24
    3a24:	19 06       	cpc	r1, r25
    3a26:	91 f4       	brne	.+36     	; 0x3a4c <__vector_91+0x9e>
    3a28:	0e c0       	rjmp	.+28     	; 0x3a46 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3a2a:	01 96       	adiw	r24, 0x01	; 1
    3a2c:	84 36       	cpi	r24, 0x64	; 100
    3a2e:	91 05       	cpc	r25, r1
    3a30:	28 f4       	brcc	.+10     	; 0x3a3c <__vector_91+0x8e>
    3a32:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <rcvD1_read_index>
    3a36:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <rcvD1_read_index+0x1>
    3a3a:	08 c0       	rjmp	.+16     	; 0x3a4c <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3a3c:	10 92 42 31 	sts	0x3142, r1	; 0x803142 <rcvD1_read_index>
    3a40:	10 92 43 31 	sts	0x3143, r1	; 0x803143 <rcvD1_read_index+0x1>
}
    3a44:	03 c0       	rjmp	.+6      	; 0x3a4c <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3a46:	81 e0       	ldi	r24, 0x01	; 1
    3a48:	90 e0       	ldi	r25, 0x00	; 0
    3a4a:	f3 cf       	rjmp	.-26     	; 0x3a32 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3a4c:	ff 91       	pop	r31
    3a4e:	ef 91       	pop	r30
    3a50:	9f 91       	pop	r25
    3a52:	8f 91       	pop	r24
    3a54:	3f 91       	pop	r19
    3a56:	2f 91       	pop	r18
    3a58:	0f 90       	pop	r0
    3a5a:	0b be       	out	0x3b, r0	; 59
    3a5c:	0f 90       	pop	r0
    3a5e:	08 be       	out	0x38, r0	; 56
    3a60:	0f 90       	pop	r0
    3a62:	0f be       	out	0x3f, r0	; 63
    3a64:	0f 90       	pop	r0
    3a66:	1f 90       	pop	r1
    3a68:	18 95       	reti

00003a6a <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3a6a:	1f 92       	push	r1
    3a6c:	0f 92       	push	r0
    3a6e:	0f b6       	in	r0, 0x3f	; 63
    3a70:	0f 92       	push	r0
    3a72:	11 24       	eor	r1, r1
    3a74:	08 b6       	in	r0, 0x38	; 56
    3a76:	0f 92       	push	r0
    3a78:	18 be       	out	0x38, r1	; 56
    3a7a:	0b b6       	in	r0, 0x3b	; 59
    3a7c:	0f 92       	push	r0
    3a7e:	1b be       	out	0x3b, r1	; 59
    3a80:	2f 93       	push	r18
    3a82:	3f 93       	push	r19
    3a84:	8f 93       	push	r24
    3a86:	9f 93       	push	r25
    3a88:	ef 93       	push	r30
    3a8a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3a8c:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3a90:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <rcvE0_buffer>
    3a94:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <rcvE0_buffer+0x1>
    3a98:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvE0_write_index>
    3a9c:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvE0_write_index+0x1>
    3aa0:	e8 0f       	add	r30, r24
    3aa2:	f9 1f       	adc	r31, r25
    3aa4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3aa6:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvE0_write_index>
    3aaa:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvE0_write_index+0x1>
    3aae:	01 96       	adiw	r24, 0x01	; 1
    3ab0:	84 36       	cpi	r24, 0x64	; 100
    3ab2:	91 05       	cpc	r25, r1
    3ab4:	60 f4       	brcc	.+24     	; 0x3ace <__vector_58+0x64>
    3ab6:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvE0_write_index>
    3aba:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3abe:	20 91 40 31 	lds	r18, 0x3140	; 0x803140 <rcvE0_read_index>
    3ac2:	30 91 41 31 	lds	r19, 0x3141	; 0x803141 <rcvE0_read_index+0x1>
    3ac6:	82 17       	cp	r24, r18
    3ac8:	93 07       	cpc	r25, r19
    3aca:	f1 f4       	brne	.+60     	; 0x3b08 <__vector_58+0x9e>
    3acc:	0c c0       	rjmp	.+24     	; 0x3ae6 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3ace:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvE0_write_index>
    3ad2:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3ad6:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvE0_read_index>
    3ada:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvE0_read_index+0x1>
    3ade:	18 16       	cp	r1, r24
    3ae0:	19 06       	cpc	r1, r25
    3ae2:	91 f4       	brne	.+36     	; 0x3b08 <__vector_58+0x9e>
    3ae4:	0e c0       	rjmp	.+28     	; 0x3b02 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3ae6:	01 96       	adiw	r24, 0x01	; 1
    3ae8:	84 36       	cpi	r24, 0x64	; 100
    3aea:	91 05       	cpc	r25, r1
    3aec:	28 f4       	brcc	.+10     	; 0x3af8 <__vector_58+0x8e>
    3aee:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <rcvE0_read_index>
    3af2:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <rcvE0_read_index+0x1>
    3af6:	08 c0       	rjmp	.+16     	; 0x3b08 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3af8:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rcvE0_read_index>
    3afc:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <rcvE0_read_index+0x1>
}
    3b00:	03 c0       	rjmp	.+6      	; 0x3b08 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3b02:	81 e0       	ldi	r24, 0x01	; 1
    3b04:	90 e0       	ldi	r25, 0x00	; 0
    3b06:	f3 cf       	rjmp	.-26     	; 0x3aee <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3b08:	ff 91       	pop	r31
    3b0a:	ef 91       	pop	r30
    3b0c:	9f 91       	pop	r25
    3b0e:	8f 91       	pop	r24
    3b10:	3f 91       	pop	r19
    3b12:	2f 91       	pop	r18
    3b14:	0f 90       	pop	r0
    3b16:	0b be       	out	0x3b, r0	; 59
    3b18:	0f 90       	pop	r0
    3b1a:	08 be       	out	0x38, r0	; 56
    3b1c:	0f 90       	pop	r0
    3b1e:	0f be       	out	0x3f, r0	; 63
    3b20:	0f 90       	pop	r0
    3b22:	1f 90       	pop	r1
    3b24:	18 95       	reti

00003b26 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3b26:	0f 93       	push	r16
    3b28:	cf 93       	push	r28
    3b2a:	df 93       	push	r29
    3b2c:	1f 92       	push	r1
    3b2e:	cd b7       	in	r28, 0x3d	; 61
    3b30:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3b32:	2f b7       	in	r18, 0x3f	; 63
    3b34:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3b36:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3b38:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3b3a:	fc 01       	movw	r30, r24
    3b3c:	08 ed       	ldi	r16, 0xD8	; 216
    3b3e:	04 bf       	out	0x34, r16	; 52
    3b40:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3b42:	89 81       	ldd	r24, Y+1	; 0x01
    3b44:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3b46:	0f 90       	pop	r0
    3b48:	df 91       	pop	r29
    3b4a:	cf 91       	pop	r28
    3b4c:	0f 91       	pop	r16
    3b4e:	08 95       	ret

00003b50 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3b50:	0f 93       	push	r16
    3b52:	1f 93       	push	r17
    3b54:	cf 93       	push	r28
    3b56:	df 93       	push	r29
    3b58:	cd b7       	in	r28, 0x3d	; 61
    3b5a:	de b7       	in	r29, 0x3e	; 62
    3b5c:	6d 97       	sbiw	r28, 0x1d	; 29
    3b5e:	cd bf       	out	0x3d, r28	; 61
    3b60:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3b62:	e0 e6       	ldi	r30, 0x60	; 96
    3b64:	f6 e0       	ldi	r31, 0x06	; 6
    3b66:	80 e4       	ldi	r24, 0x40	; 64
    3b68:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3b6a:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3b6c:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3b6e:	e0 e5       	ldi	r30, 0x50	; 80
    3b70:	f0 e0       	ldi	r31, 0x00	; 0
    3b72:	80 81       	ld	r24, Z
    3b74:	82 60       	ori	r24, 0x02	; 2
    3b76:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3b78:	81 81       	ldd	r24, Z+1	; 0x01
    3b7a:	81 ff       	sbrs	r24, 1
    3b7c:	fd cf       	rjmp	.-6      	; 0x3b78 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3b7e:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3b82:	68 7f       	andi	r22, 0xF8	; 248
    3b84:	61 60       	ori	r22, 0x01	; 1
    3b86:	80 e4       	ldi	r24, 0x40	; 64
    3b88:	90 e0       	ldi	r25, 0x00	; 0
    3b8a:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3b8e:	e0 e5       	ldi	r30, 0x50	; 80
    3b90:	f0 e0       	ldi	r31, 0x00	; 0
    3b92:	80 81       	ld	r24, Z
    3b94:	8e 7f       	andi	r24, 0xFE	; 254
    3b96:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3b98:	9d ef       	ldi	r25, 0xFD	; 253
    3b9a:	88 ed       	ldi	r24, 0xD8	; 216
    3b9c:	08 b6       	in	r0, 0x38	; 56
    3b9e:	18 be       	out	0x38, r1	; 56
    3ba0:	84 bf       	out	0x34, r24	; 52
    3ba2:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3ba6:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3ba8:	40 eb       	ldi	r20, 0xB0	; 176
    3baa:	58 e0       	ldi	r21, 0x08	; 8
    3bac:	60 e0       	ldi	r22, 0x00	; 0
    3bae:	70 e0       	ldi	r23, 0x00	; 0
    3bb0:	ce 01       	movw	r24, r28
    3bb2:	01 96       	adiw	r24, 0x01	; 1
    3bb4:	0e 94 3d 1b 	call	0x367a	; 0x367a <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3bb8:	67 e0       	ldi	r22, 0x07	; 7
    3bba:	ce 01       	movw	r24, r28
    3bbc:	01 96       	adiw	r24, 0x01	; 1
    3bbe:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    3bc2:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3bc4:	62 e8       	ldi	r22, 0x82	; 130
    3bc6:	70 e2       	ldi	r23, 0x20	; 32
    3bc8:	0e 94 3a 19 	call	0x3274	; 0x3274 <_ZN8emstream4putsEPKc>
    3bcc:	66 e0       	ldi	r22, 0x06	; 6
    3bce:	c8 01       	movw	r24, r16
    3bd0:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
    3bd4:	66 e0       	ldi	r22, 0x06	; 6
    3bd6:	0e 94 71 19 	call	0x32e2	; 0x32e2 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3bda:	82 e1       	ldi	r24, 0x12	; 18
    3bdc:	90 e0       	ldi	r25, 0x00	; 0
    3bde:	0e 94 81 18 	call	0x3102	; 0x3102 <_Znwj>
    3be2:	8e 01       	movw	r16, r28
    3be4:	0f 5f       	subi	r16, 0xFF	; 255
    3be6:	1f 4f       	sbci	r17, 0xFF	; 255
    3be8:	24 e0       	ldi	r18, 0x04	; 4
    3bea:	31 e0       	ldi	r19, 0x01	; 1
    3bec:	40 e0       	ldi	r20, 0x00	; 0
    3bee:	61 ea       	ldi	r22, 0xA1	; 161
    3bf0:	70 e2       	ldi	r23, 0x20	; 32
    3bf2:	0e 94 42 06 	call	0xc84	; 0xc84 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3bf6:	82 e1       	ldi	r24, 0x12	; 18
    3bf8:	90 e0       	ldi	r25, 0x00	; 0
    3bfa:	0e 94 81 18 	call	0x3102	; 0x3102 <_Znwj>
    3bfe:	24 e0       	ldi	r18, 0x04	; 4
    3c00:	31 e0       	ldi	r19, 0x01	; 1
    3c02:	42 e0       	ldi	r20, 0x02	; 2
    3c04:	69 ea       	ldi	r22, 0xA9	; 169
    3c06:	70 e2       	ldi	r23, 0x20	; 32
    3c08:	0e 94 76 03 	call	0x6ec	; 0x6ec <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3c0c:	82 e1       	ldi	r24, 0x12	; 18
    3c0e:	90 e0       	ldi	r25, 0x00	; 0
    3c10:	0e 94 81 18 	call	0x3102	; 0x3102 <_Znwj>
    3c14:	24 e0       	ldi	r18, 0x04	; 4
    3c16:	31 e0       	ldi	r19, 0x01	; 1
    3c18:	43 e0       	ldi	r20, 0x03	; 3
    3c1a:	60 eb       	ldi	r22, 0xB0	; 176
    3c1c:	70 e2       	ldi	r23, 0x20	; 32
    3c1e:	0e 94 e6 03 	call	0x7cc	; 0x7cc <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3c22:	82 e1       	ldi	r24, 0x12	; 18
    3c24:	90 e0       	ldi	r25, 0x00	; 0
    3c26:	0e 94 81 18 	call	0x3102	; 0x3102 <_Znwj>
    3c2a:	24 e0       	ldi	r18, 0x04	; 4
    3c2c:	31 e0       	ldi	r19, 0x01	; 1
    3c2e:	44 e0       	ldi	r20, 0x04	; 4
    3c30:	67 eb       	ldi	r22, 0xB7	; 183
    3c32:	70 e2       	ldi	r23, 0x20	; 32
    3c34:	0e 94 4b 04 	call	0x896	; 0x896 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3c38:	80 e4       	ldi	r24, 0x40	; 64
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	0e 94 81 18 	call	0x3102	; 0x3102 <_Znwj>
    3c40:	24 e0       	ldi	r18, 0x04	; 4
    3c42:	31 e0       	ldi	r19, 0x01	; 1
    3c44:	43 e0       	ldi	r20, 0x03	; 3
    3c46:	60 ec       	ldi	r22, 0xC0	; 192
    3c48:	70 e2       	ldi	r23, 0x20	; 32
    3c4a:	0e 94 15 05 	call	0xa2a	; 0xa2a <_ZN5MotorC1EPKchjP8emstream>
	
	new PWMdriver ("PWM", task_priority(5), 260, &ser_dev);
    3c4e:	82 e1       	ldi	r24, 0x12	; 18
    3c50:	90 e0       	ldi	r25, 0x00	; 0
    3c52:	0e 94 81 18 	call	0x3102	; 0x3102 <_Znwj>
    3c56:	24 e0       	ldi	r18, 0x04	; 4
    3c58:	31 e0       	ldi	r19, 0x01	; 1
    3c5a:	44 e0       	ldi	r20, 0x04	; 4
    3c5c:	66 ec       	ldi	r22, 0xC6	; 198
    3c5e:	70 e2       	ldi	r23, 0x20	; 32
    3c60:	0e 94 32 06 	call	0xc64	; 0xc64 <_ZN9PWMdriverC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3c64:	87 e0       	ldi	r24, 0x07	; 7
    3c66:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3c6a:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3c6c:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vTaskStartScheduler>
	
	
	return 0;
    3c70:	80 e0       	ldi	r24, 0x00	; 0
    3c72:	90 e0       	ldi	r25, 0x00	; 0
    3c74:	6d 96       	adiw	r28, 0x1d	; 29
    3c76:	cd bf       	out	0x3d, r28	; 61
    3c78:	de bf       	out	0x3e, r29	; 62
    3c7a:	df 91       	pop	r29
    3c7c:	cf 91       	pop	r28
    3c7e:	1f 91       	pop	r17
    3c80:	0f 91       	pop	r16
    3c82:	08 95       	ret

00003c84 <_GLOBAL__sub_I_counter>:
    3c84:	0f 93       	push	r16
    3c86:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3c88:	0a e0       	ldi	r16, 0x0A	; 10
    3c8a:	10 e0       	ldi	r17, 0x00	; 0
    3c8c:	20 e0       	ldi	r18, 0x00	; 0
    3c8e:	30 e0       	ldi	r19, 0x00	; 0
    3c90:	40 e0       	ldi	r20, 0x00	; 0
    3c92:	50 e0       	ldi	r21, 0x00	; 0
    3c94:	60 e2       	ldi	r22, 0x20	; 32
    3c96:	70 e0       	ldi	r23, 0x00	; 0
    3c98:	8e e5       	ldi	r24, 0x5E	; 94
    3c9a:	91 e3       	ldi	r25, 0x31	; 49
    3c9c:	0e 94 ed 16 	call	0x2dda	; 0x2dda <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3ca0:	1f 91       	pop	r17
    3ca2:	0f 91       	pop	r16
    3ca4:	08 95       	ret

00003ca6 <__cmpsf2>:
    3ca6:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <__fp_cmp>
    3caa:	08 f4       	brcc	.+2      	; 0x3cae <__cmpsf2+0x8>
    3cac:	81 e0       	ldi	r24, 0x01	; 1
    3cae:	08 95       	ret

00003cb0 <__floatunsisf>:
    3cb0:	e8 94       	clt
    3cb2:	09 c0       	rjmp	.+18     	; 0x3cc6 <__floatsisf+0x12>

00003cb4 <__floatsisf>:
    3cb4:	97 fb       	bst	r25, 7
    3cb6:	3e f4       	brtc	.+14     	; 0x3cc6 <__floatsisf+0x12>
    3cb8:	90 95       	com	r25
    3cba:	80 95       	com	r24
    3cbc:	70 95       	com	r23
    3cbe:	61 95       	neg	r22
    3cc0:	7f 4f       	sbci	r23, 0xFF	; 255
    3cc2:	8f 4f       	sbci	r24, 0xFF	; 255
    3cc4:	9f 4f       	sbci	r25, 0xFF	; 255
    3cc6:	99 23       	and	r25, r25
    3cc8:	a9 f0       	breq	.+42     	; 0x3cf4 <__floatsisf+0x40>
    3cca:	f9 2f       	mov	r31, r25
    3ccc:	96 e9       	ldi	r25, 0x96	; 150
    3cce:	bb 27       	eor	r27, r27
    3cd0:	93 95       	inc	r25
    3cd2:	f6 95       	lsr	r31
    3cd4:	87 95       	ror	r24
    3cd6:	77 95       	ror	r23
    3cd8:	67 95       	ror	r22
    3cda:	b7 95       	ror	r27
    3cdc:	f1 11       	cpse	r31, r1
    3cde:	f8 cf       	rjmp	.-16     	; 0x3cd0 <__floatsisf+0x1c>
    3ce0:	fa f4       	brpl	.+62     	; 0x3d20 <__floatsisf+0x6c>
    3ce2:	bb 0f       	add	r27, r27
    3ce4:	11 f4       	brne	.+4      	; 0x3cea <__floatsisf+0x36>
    3ce6:	60 ff       	sbrs	r22, 0
    3ce8:	1b c0       	rjmp	.+54     	; 0x3d20 <__floatsisf+0x6c>
    3cea:	6f 5f       	subi	r22, 0xFF	; 255
    3cec:	7f 4f       	sbci	r23, 0xFF	; 255
    3cee:	8f 4f       	sbci	r24, 0xFF	; 255
    3cf0:	9f 4f       	sbci	r25, 0xFF	; 255
    3cf2:	16 c0       	rjmp	.+44     	; 0x3d20 <__floatsisf+0x6c>
    3cf4:	88 23       	and	r24, r24
    3cf6:	11 f0       	breq	.+4      	; 0x3cfc <__floatsisf+0x48>
    3cf8:	96 e9       	ldi	r25, 0x96	; 150
    3cfa:	11 c0       	rjmp	.+34     	; 0x3d1e <__floatsisf+0x6a>
    3cfc:	77 23       	and	r23, r23
    3cfe:	21 f0       	breq	.+8      	; 0x3d08 <__floatsisf+0x54>
    3d00:	9e e8       	ldi	r25, 0x8E	; 142
    3d02:	87 2f       	mov	r24, r23
    3d04:	76 2f       	mov	r23, r22
    3d06:	05 c0       	rjmp	.+10     	; 0x3d12 <__floatsisf+0x5e>
    3d08:	66 23       	and	r22, r22
    3d0a:	71 f0       	breq	.+28     	; 0x3d28 <__floatsisf+0x74>
    3d0c:	96 e8       	ldi	r25, 0x86	; 134
    3d0e:	86 2f       	mov	r24, r22
    3d10:	70 e0       	ldi	r23, 0x00	; 0
    3d12:	60 e0       	ldi	r22, 0x00	; 0
    3d14:	2a f0       	brmi	.+10     	; 0x3d20 <__floatsisf+0x6c>
    3d16:	9a 95       	dec	r25
    3d18:	66 0f       	add	r22, r22
    3d1a:	77 1f       	adc	r23, r23
    3d1c:	88 1f       	adc	r24, r24
    3d1e:	da f7       	brpl	.-10     	; 0x3d16 <__floatsisf+0x62>
    3d20:	88 0f       	add	r24, r24
    3d22:	96 95       	lsr	r25
    3d24:	87 95       	ror	r24
    3d26:	97 f9       	bld	r25, 7
    3d28:	08 95       	ret

00003d2a <__fp_cmp>:
    3d2a:	99 0f       	add	r25, r25
    3d2c:	00 08       	sbc	r0, r0
    3d2e:	55 0f       	add	r21, r21
    3d30:	aa 0b       	sbc	r26, r26
    3d32:	e0 e8       	ldi	r30, 0x80	; 128
    3d34:	fe ef       	ldi	r31, 0xFE	; 254
    3d36:	16 16       	cp	r1, r22
    3d38:	17 06       	cpc	r1, r23
    3d3a:	e8 07       	cpc	r30, r24
    3d3c:	f9 07       	cpc	r31, r25
    3d3e:	c0 f0       	brcs	.+48     	; 0x3d70 <__fp_cmp+0x46>
    3d40:	12 16       	cp	r1, r18
    3d42:	13 06       	cpc	r1, r19
    3d44:	e4 07       	cpc	r30, r20
    3d46:	f5 07       	cpc	r31, r21
    3d48:	98 f0       	brcs	.+38     	; 0x3d70 <__fp_cmp+0x46>
    3d4a:	62 1b       	sub	r22, r18
    3d4c:	73 0b       	sbc	r23, r19
    3d4e:	84 0b       	sbc	r24, r20
    3d50:	95 0b       	sbc	r25, r21
    3d52:	39 f4       	brne	.+14     	; 0x3d62 <__fp_cmp+0x38>
    3d54:	0a 26       	eor	r0, r26
    3d56:	61 f0       	breq	.+24     	; 0x3d70 <__fp_cmp+0x46>
    3d58:	23 2b       	or	r18, r19
    3d5a:	24 2b       	or	r18, r20
    3d5c:	25 2b       	or	r18, r21
    3d5e:	21 f4       	brne	.+8      	; 0x3d68 <__fp_cmp+0x3e>
    3d60:	08 95       	ret
    3d62:	0a 26       	eor	r0, r26
    3d64:	09 f4       	brne	.+2      	; 0x3d68 <__fp_cmp+0x3e>
    3d66:	a1 40       	sbci	r26, 0x01	; 1
    3d68:	a6 95       	lsr	r26
    3d6a:	8f ef       	ldi	r24, 0xFF	; 255
    3d6c:	81 1d       	adc	r24, r1
    3d6e:	81 1d       	adc	r24, r1
    3d70:	08 95       	ret

00003d72 <__gesf2>:
    3d72:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <__fp_cmp>
    3d76:	08 f4       	brcc	.+2      	; 0x3d7a <__gesf2+0x8>
    3d78:	8f ef       	ldi	r24, 0xFF	; 255
    3d7a:	08 95       	ret

00003d7c <__mulsi3>:
    3d7c:	db 01       	movw	r26, r22
    3d7e:	8f 93       	push	r24
    3d80:	9f 93       	push	r25
    3d82:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <__muluhisi3>
    3d86:	bf 91       	pop	r27
    3d88:	af 91       	pop	r26
    3d8a:	a2 9f       	mul	r26, r18
    3d8c:	80 0d       	add	r24, r0
    3d8e:	91 1d       	adc	r25, r1
    3d90:	a3 9f       	mul	r26, r19
    3d92:	90 0d       	add	r25, r0
    3d94:	b2 9f       	mul	r27, r18
    3d96:	90 0d       	add	r25, r0
    3d98:	11 24       	eor	r1, r1
    3d9a:	08 95       	ret

00003d9c <__divmodhi4>:
    3d9c:	97 fb       	bst	r25, 7
    3d9e:	07 2e       	mov	r0, r23
    3da0:	16 f4       	brtc	.+4      	; 0x3da6 <__divmodhi4+0xa>
    3da2:	00 94       	com	r0
    3da4:	07 d0       	rcall	.+14     	; 0x3db4 <__divmodhi4_neg1>
    3da6:	77 fd       	sbrc	r23, 7
    3da8:	09 d0       	rcall	.+18     	; 0x3dbc <__divmodhi4_neg2>
    3daa:	0e 94 3e 1f 	call	0x3e7c	; 0x3e7c <__udivmodhi4>
    3dae:	07 fc       	sbrc	r0, 7
    3db0:	05 d0       	rcall	.+10     	; 0x3dbc <__divmodhi4_neg2>
    3db2:	3e f4       	brtc	.+14     	; 0x3dc2 <__divmodhi4_exit>

00003db4 <__divmodhi4_neg1>:
    3db4:	90 95       	com	r25
    3db6:	81 95       	neg	r24
    3db8:	9f 4f       	sbci	r25, 0xFF	; 255
    3dba:	08 95       	ret

00003dbc <__divmodhi4_neg2>:
    3dbc:	70 95       	com	r23
    3dbe:	61 95       	neg	r22
    3dc0:	7f 4f       	sbci	r23, 0xFF	; 255

00003dc2 <__divmodhi4_exit>:
    3dc2:	08 95       	ret

00003dc4 <__udivmodsi4>:
    3dc4:	a1 e2       	ldi	r26, 0x21	; 33
    3dc6:	1a 2e       	mov	r1, r26
    3dc8:	aa 1b       	sub	r26, r26
    3dca:	bb 1b       	sub	r27, r27
    3dcc:	fd 01       	movw	r30, r26
    3dce:	0d c0       	rjmp	.+26     	; 0x3dea <__udivmodsi4_ep>

00003dd0 <__udivmodsi4_loop>:
    3dd0:	aa 1f       	adc	r26, r26
    3dd2:	bb 1f       	adc	r27, r27
    3dd4:	ee 1f       	adc	r30, r30
    3dd6:	ff 1f       	adc	r31, r31
    3dd8:	a2 17       	cp	r26, r18
    3dda:	b3 07       	cpc	r27, r19
    3ddc:	e4 07       	cpc	r30, r20
    3dde:	f5 07       	cpc	r31, r21
    3de0:	20 f0       	brcs	.+8      	; 0x3dea <__udivmodsi4_ep>
    3de2:	a2 1b       	sub	r26, r18
    3de4:	b3 0b       	sbc	r27, r19
    3de6:	e4 0b       	sbc	r30, r20
    3de8:	f5 0b       	sbc	r31, r21

00003dea <__udivmodsi4_ep>:
    3dea:	66 1f       	adc	r22, r22
    3dec:	77 1f       	adc	r23, r23
    3dee:	88 1f       	adc	r24, r24
    3df0:	99 1f       	adc	r25, r25
    3df2:	1a 94       	dec	r1
    3df4:	69 f7       	brne	.-38     	; 0x3dd0 <__udivmodsi4_loop>
    3df6:	60 95       	com	r22
    3df8:	70 95       	com	r23
    3dfa:	80 95       	com	r24
    3dfc:	90 95       	com	r25
    3dfe:	9b 01       	movw	r18, r22
    3e00:	ac 01       	movw	r20, r24
    3e02:	bd 01       	movw	r22, r26
    3e04:	cf 01       	movw	r24, r30
    3e06:	08 95       	ret

00003e08 <__divmodsi4>:
    3e08:	05 2e       	mov	r0, r21
    3e0a:	97 fb       	bst	r25, 7
    3e0c:	1e f4       	brtc	.+6      	; 0x3e14 <__divmodsi4+0xc>
    3e0e:	00 94       	com	r0
    3e10:	0e 94 1b 1f 	call	0x3e36	; 0x3e36 <__negsi2>
    3e14:	57 fd       	sbrc	r21, 7
    3e16:	07 d0       	rcall	.+14     	; 0x3e26 <__divmodsi4_neg2>
    3e18:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <__udivmodsi4>
    3e1c:	07 fc       	sbrc	r0, 7
    3e1e:	03 d0       	rcall	.+6      	; 0x3e26 <__divmodsi4_neg2>
    3e20:	4e f4       	brtc	.+18     	; 0x3e34 <__divmodsi4_exit>
    3e22:	0c 94 1b 1f 	jmp	0x3e36	; 0x3e36 <__negsi2>

00003e26 <__divmodsi4_neg2>:
    3e26:	50 95       	com	r21
    3e28:	40 95       	com	r20
    3e2a:	30 95       	com	r19
    3e2c:	21 95       	neg	r18
    3e2e:	3f 4f       	sbci	r19, 0xFF	; 255
    3e30:	4f 4f       	sbci	r20, 0xFF	; 255
    3e32:	5f 4f       	sbci	r21, 0xFF	; 255

00003e34 <__divmodsi4_exit>:
    3e34:	08 95       	ret

00003e36 <__negsi2>:
    3e36:	90 95       	com	r25
    3e38:	80 95       	com	r24
    3e3a:	70 95       	com	r23
    3e3c:	61 95       	neg	r22
    3e3e:	7f 4f       	sbci	r23, 0xFF	; 255
    3e40:	8f 4f       	sbci	r24, 0xFF	; 255
    3e42:	9f 4f       	sbci	r25, 0xFF	; 255
    3e44:	08 95       	ret

00003e46 <__tablejump2__>:
    3e46:	ee 0f       	add	r30, r30
    3e48:	ff 1f       	adc	r31, r31
    3e4a:	88 1f       	adc	r24, r24
    3e4c:	8b bf       	out	0x3b, r24	; 59
    3e4e:	07 90       	elpm	r0, Z+
    3e50:	f6 91       	elpm	r31, Z
    3e52:	e0 2d       	mov	r30, r0
    3e54:	1b be       	out	0x3b, r1	; 59
    3e56:	19 94       	eijmp

00003e58 <__usmulhisi3>:
    3e58:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <__umulhisi3>

00003e5c <__usmulhisi3_tail>:
    3e5c:	b7 ff       	sbrs	r27, 7
    3e5e:	08 95       	ret
    3e60:	82 1b       	sub	r24, r18
    3e62:	93 0b       	sbc	r25, r19
    3e64:	08 95       	ret

00003e66 <__muluhisi3>:
    3e66:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <__umulhisi3>
    3e6a:	a5 9f       	mul	r26, r21
    3e6c:	90 0d       	add	r25, r0
    3e6e:	b4 9f       	mul	r27, r20
    3e70:	90 0d       	add	r25, r0
    3e72:	a4 9f       	mul	r26, r20
    3e74:	80 0d       	add	r24, r0
    3e76:	91 1d       	adc	r25, r1
    3e78:	11 24       	eor	r1, r1
    3e7a:	08 95       	ret

00003e7c <__udivmodhi4>:
    3e7c:	aa 1b       	sub	r26, r26
    3e7e:	bb 1b       	sub	r27, r27
    3e80:	51 e1       	ldi	r21, 0x11	; 17
    3e82:	07 c0       	rjmp	.+14     	; 0x3e92 <__udivmodhi4_ep>

00003e84 <__udivmodhi4_loop>:
    3e84:	aa 1f       	adc	r26, r26
    3e86:	bb 1f       	adc	r27, r27
    3e88:	a6 17       	cp	r26, r22
    3e8a:	b7 07       	cpc	r27, r23
    3e8c:	10 f0       	brcs	.+4      	; 0x3e92 <__udivmodhi4_ep>
    3e8e:	a6 1b       	sub	r26, r22
    3e90:	b7 0b       	sbc	r27, r23

00003e92 <__udivmodhi4_ep>:
    3e92:	88 1f       	adc	r24, r24
    3e94:	99 1f       	adc	r25, r25
    3e96:	5a 95       	dec	r21
    3e98:	a9 f7       	brne	.-22     	; 0x3e84 <__udivmodhi4_loop>
    3e9a:	80 95       	com	r24
    3e9c:	90 95       	com	r25
    3e9e:	bc 01       	movw	r22, r24
    3ea0:	cd 01       	movw	r24, r26
    3ea2:	08 95       	ret

00003ea4 <__umulhisi3>:
    3ea4:	a2 9f       	mul	r26, r18
    3ea6:	b0 01       	movw	r22, r0
    3ea8:	b3 9f       	mul	r27, r19
    3eaa:	c0 01       	movw	r24, r0
    3eac:	a3 9f       	mul	r26, r19
    3eae:	70 0d       	add	r23, r0
    3eb0:	81 1d       	adc	r24, r1
    3eb2:	11 24       	eor	r1, r1
    3eb4:	91 1d       	adc	r25, r1
    3eb6:	b2 9f       	mul	r27, r18
    3eb8:	70 0d       	add	r23, r0
    3eba:	81 1d       	adc	r24, r1
    3ebc:	11 24       	eor	r1, r1
    3ebe:	91 1d       	adc	r25, r1
    3ec0:	08 95       	ret

00003ec2 <memcpy>:
    3ec2:	fb 01       	movw	r30, r22
    3ec4:	dc 01       	movw	r26, r24
    3ec6:	02 c0       	rjmp	.+4      	; 0x3ecc <memcpy+0xa>
    3ec8:	01 90       	ld	r0, Z+
    3eca:	0d 92       	st	X+, r0
    3ecc:	41 50       	subi	r20, 0x01	; 1
    3ece:	50 40       	sbci	r21, 0x00	; 0
    3ed0:	d8 f7       	brcc	.-10     	; 0x3ec8 <memcpy+0x6>
    3ed2:	08 95       	ret

00003ed4 <memset>:
    3ed4:	dc 01       	movw	r26, r24
    3ed6:	01 c0       	rjmp	.+2      	; 0x3eda <memset+0x6>
    3ed8:	6d 93       	st	X+, r22
    3eda:	41 50       	subi	r20, 0x01	; 1
    3edc:	50 40       	sbci	r21, 0x00	; 0
    3ede:	e0 f7       	brcc	.-8      	; 0x3ed8 <memset+0x4>
    3ee0:	08 95       	ret

00003ee2 <strncpy>:
    3ee2:	fb 01       	movw	r30, r22
    3ee4:	dc 01       	movw	r26, r24
    3ee6:	41 50       	subi	r20, 0x01	; 1
    3ee8:	50 40       	sbci	r21, 0x00	; 0
    3eea:	48 f0       	brcs	.+18     	; 0x3efe <strncpy+0x1c>
    3eec:	01 90       	ld	r0, Z+
    3eee:	0d 92       	st	X+, r0
    3ef0:	00 20       	and	r0, r0
    3ef2:	c9 f7       	brne	.-14     	; 0x3ee6 <strncpy+0x4>
    3ef4:	01 c0       	rjmp	.+2      	; 0x3ef8 <strncpy+0x16>
    3ef6:	1d 92       	st	X+, r1
    3ef8:	41 50       	subi	r20, 0x01	; 1
    3efa:	50 40       	sbci	r21, 0x00	; 0
    3efc:	e0 f7       	brcc	.-8      	; 0x3ef6 <strncpy+0x14>
    3efe:	08 95       	ret

00003f00 <__itoa_ncheck>:
    3f00:	bb 27       	eor	r27, r27
    3f02:	4a 30       	cpi	r20, 0x0A	; 10
    3f04:	31 f4       	brne	.+12     	; 0x3f12 <__itoa_ncheck+0x12>
    3f06:	99 23       	and	r25, r25
    3f08:	22 f4       	brpl	.+8      	; 0x3f12 <__itoa_ncheck+0x12>
    3f0a:	bd e2       	ldi	r27, 0x2D	; 45
    3f0c:	90 95       	com	r25
    3f0e:	81 95       	neg	r24
    3f10:	9f 4f       	sbci	r25, 0xFF	; 255
    3f12:	0c 94 c4 1f 	jmp	0x3f88	; 0x3f88 <__utoa_common>

00003f16 <ultoa>:
    3f16:	25 32       	cpi	r18, 0x25	; 37
    3f18:	31 05       	cpc	r19, r1
    3f1a:	20 f4       	brcc	.+8      	; 0x3f24 <ultoa+0xe>
    3f1c:	22 30       	cpi	r18, 0x02	; 2
    3f1e:	10 f0       	brcs	.+4      	; 0x3f24 <ultoa+0xe>
    3f20:	0c 94 96 1f 	jmp	0x3f2c	; 0x3f2c <__ultoa_ncheck>
    3f24:	fa 01       	movw	r30, r20
    3f26:	10 82       	st	Z, r1
    3f28:	ca 01       	movw	r24, r20
    3f2a:	08 95       	ret

00003f2c <__ultoa_ncheck>:
    3f2c:	bb 27       	eor	r27, r27

00003f2e <__ultoa_common>:
    3f2e:	fa 01       	movw	r30, r20
    3f30:	a6 2f       	mov	r26, r22
    3f32:	62 17       	cp	r22, r18
    3f34:	71 05       	cpc	r23, r1
    3f36:	81 05       	cpc	r24, r1
    3f38:	91 05       	cpc	r25, r1
    3f3a:	33 0b       	sbc	r19, r19
    3f3c:	30 fb       	bst	r19, 0
    3f3e:	66 f0       	brts	.+24     	; 0x3f58 <__ultoa_common+0x2a>
    3f40:	aa 27       	eor	r26, r26
    3f42:	66 0f       	add	r22, r22
    3f44:	77 1f       	adc	r23, r23
    3f46:	88 1f       	adc	r24, r24
    3f48:	99 1f       	adc	r25, r25
    3f4a:	aa 1f       	adc	r26, r26
    3f4c:	a2 17       	cp	r26, r18
    3f4e:	10 f0       	brcs	.+4      	; 0x3f54 <__ultoa_common+0x26>
    3f50:	a2 1b       	sub	r26, r18
    3f52:	63 95       	inc	r22
    3f54:	38 50       	subi	r19, 0x08	; 8
    3f56:	a9 f7       	brne	.-22     	; 0x3f42 <__ultoa_common+0x14>
    3f58:	a0 5d       	subi	r26, 0xD0	; 208
    3f5a:	aa 33       	cpi	r26, 0x3A	; 58
    3f5c:	08 f0       	brcs	.+2      	; 0x3f60 <__ultoa_common+0x32>
    3f5e:	a9 5d       	subi	r26, 0xD9	; 217
    3f60:	a1 93       	st	Z+, r26
    3f62:	36 f7       	brtc	.-52     	; 0x3f30 <__ultoa_common+0x2>
    3f64:	b1 11       	cpse	r27, r1
    3f66:	b1 93       	st	Z+, r27
    3f68:	10 82       	st	Z, r1
    3f6a:	ca 01       	movw	r24, r20
    3f6c:	0c 94 dd 1f 	jmp	0x3fba	; 0x3fba <strrev>

00003f70 <utoa>:
    3f70:	45 32       	cpi	r20, 0x25	; 37
    3f72:	51 05       	cpc	r21, r1
    3f74:	20 f4       	brcc	.+8      	; 0x3f7e <utoa+0xe>
    3f76:	42 30       	cpi	r20, 0x02	; 2
    3f78:	10 f0       	brcs	.+4      	; 0x3f7e <utoa+0xe>
    3f7a:	0c 94 c3 1f 	jmp	0x3f86	; 0x3f86 <__utoa_ncheck>
    3f7e:	fb 01       	movw	r30, r22
    3f80:	10 82       	st	Z, r1
    3f82:	cb 01       	movw	r24, r22
    3f84:	08 95       	ret

00003f86 <__utoa_ncheck>:
    3f86:	bb 27       	eor	r27, r27

00003f88 <__utoa_common>:
    3f88:	fb 01       	movw	r30, r22
    3f8a:	55 27       	eor	r21, r21
    3f8c:	aa 27       	eor	r26, r26
    3f8e:	88 0f       	add	r24, r24
    3f90:	99 1f       	adc	r25, r25
    3f92:	aa 1f       	adc	r26, r26
    3f94:	a4 17       	cp	r26, r20
    3f96:	10 f0       	brcs	.+4      	; 0x3f9c <__utoa_common+0x14>
    3f98:	a4 1b       	sub	r26, r20
    3f9a:	83 95       	inc	r24
    3f9c:	50 51       	subi	r21, 0x10	; 16
    3f9e:	b9 f7       	brne	.-18     	; 0x3f8e <__utoa_common+0x6>
    3fa0:	a0 5d       	subi	r26, 0xD0	; 208
    3fa2:	aa 33       	cpi	r26, 0x3A	; 58
    3fa4:	08 f0       	brcs	.+2      	; 0x3fa8 <__utoa_common+0x20>
    3fa6:	a9 5d       	subi	r26, 0xD9	; 217
    3fa8:	a1 93       	st	Z+, r26
    3faa:	00 97       	sbiw	r24, 0x00	; 0
    3fac:	79 f7       	brne	.-34     	; 0x3f8c <__utoa_common+0x4>
    3fae:	b1 11       	cpse	r27, r1
    3fb0:	b1 93       	st	Z+, r27
    3fb2:	11 92       	st	Z+, r1
    3fb4:	cb 01       	movw	r24, r22
    3fb6:	0c 94 dd 1f 	jmp	0x3fba	; 0x3fba <strrev>

00003fba <strrev>:
    3fba:	dc 01       	movw	r26, r24
    3fbc:	fc 01       	movw	r30, r24
    3fbe:	67 2f       	mov	r22, r23
    3fc0:	71 91       	ld	r23, Z+
    3fc2:	77 23       	and	r23, r23
    3fc4:	e1 f7       	brne	.-8      	; 0x3fbe <strrev+0x4>
    3fc6:	32 97       	sbiw	r30, 0x02	; 2
    3fc8:	04 c0       	rjmp	.+8      	; 0x3fd2 <strrev+0x18>
    3fca:	7c 91       	ld	r23, X
    3fcc:	6d 93       	st	X+, r22
    3fce:	70 83       	st	Z, r23
    3fd0:	62 91       	ld	r22, -Z
    3fd2:	ae 17       	cp	r26, r30
    3fd4:	bf 07       	cpc	r27, r31
    3fd6:	c8 f3       	brcs	.-14     	; 0x3fca <strrev+0x10>
    3fd8:	08 95       	ret

00003fda <_exit>:
    3fda:	f8 94       	cli

00003fdc <__stop_program>:
    3fdc:	ff cf       	rjmp	.-2      	; 0x3fdc <__stop_program>
