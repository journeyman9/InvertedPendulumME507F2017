
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000045f4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  000045f4  00004688  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  008020bc  008020bc  00004744  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004744  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004774  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006a0  00000000  00000000  000047b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000126d8  00000000  00000000  00004e54  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006344  00000000  00000000  0001752c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005503  00000000  00000000  0001d870  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001244  00000000  00000000  00022d74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006253  00000000  00000000  00023fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005eb1  00000000  00000000  0002a20b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000568  00000000  00000000  000300bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 95 03 	jmp	0x72a	; 0x72a <__ctors_end>
       4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      10:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      14:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      18:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      1c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      20:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      24:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      28:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      2c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      30:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      34:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      38:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      3c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      40:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      44:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      48:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      4c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      50:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      54:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      58:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      5c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      60:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      64:	0c 94 ce 1e 	jmp	0x3d9c	; 0x3d9c <__vector_25>
      68:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      6c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      70:	0c 94 2c 1f 	jmp	0x3e58	; 0x3e58 <__vector_28>
      74:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      78:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      7c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      80:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      84:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      88:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      8c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      90:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      94:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      98:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      9c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c4:	0c 94 e8 0e 	jmp	0x1dd0	; 0x1dd0 <__vector_49>
      c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e8:	0c 94 46 20 	jmp	0x408c	; 0x408c <__vector_58>
      ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      fc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     100:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     104:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     108:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     10c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     110:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     114:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     118:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     11c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     120:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     124:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     128:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     12c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     130:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     134:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     138:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     13c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     140:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     144:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     148:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     14c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     150:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     154:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     158:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     15c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     160:	0c 94 8a 1f 	jmp	0x3f14	; 0x3f14 <__vector_88>
     164:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     168:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     16c:	0c 94 e8 1f 	jmp	0x3fd0	; 0x3fd0 <__vector_91>
     170:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     174:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     178:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     17c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     180:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     184:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     188:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     18c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     190:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     194:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     198:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     19c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1fc:	2f 0b       	sbc	r18, r31
     1fe:	a7 0b       	sbc	r26, r23
     200:	a7 0b       	sbc	r26, r23
     202:	a7 0b       	sbc	r26, r23
     204:	a7 0b       	sbc	r26, r23
     206:	a7 0b       	sbc	r26, r23
     208:	a7 0b       	sbc	r26, r23
     20a:	a7 0b       	sbc	r26, r23
     20c:	a7 0b       	sbc	r26, r23
     20e:	a7 0b       	sbc	r26, r23
     210:	a7 0b       	sbc	r26, r23
     212:	a7 0b       	sbc	r26, r23
     214:	a7 0b       	sbc	r26, r23
     216:	a7 0b       	sbc	r26, r23
     218:	a7 0b       	sbc	r26, r23
     21a:	a7 0b       	sbc	r26, r23
     21c:	a7 0b       	sbc	r26, r23
     21e:	a7 0b       	sbc	r26, r23
     220:	a7 0b       	sbc	r26, r23
     222:	a7 0b       	sbc	r26, r23
     224:	a7 0b       	sbc	r26, r23
     226:	a7 0b       	sbc	r26, r23
     228:	a7 0b       	sbc	r26, r23
     22a:	a7 0b       	sbc	r26, r23
     22c:	a7 0b       	sbc	r26, r23
     22e:	a7 0b       	sbc	r26, r23
     230:	a7 0b       	sbc	r26, r23
     232:	a7 0b       	sbc	r26, r23
     234:	a7 0b       	sbc	r26, r23
     236:	a7 0b       	sbc	r26, r23
     238:	a7 0b       	sbc	r26, r23
     23a:	a7 0b       	sbc	r26, r23
     23c:	a7 0b       	sbc	r26, r23
     23e:	a7 0b       	sbc	r26, r23
     240:	a7 0b       	sbc	r26, r23
     242:	a7 0b       	sbc	r26, r23
     244:	a7 0b       	sbc	r26, r23
     246:	a7 0b       	sbc	r26, r23
     248:	a7 0b       	sbc	r26, r23
     24a:	a7 0b       	sbc	r26, r23
     24c:	a7 0b       	sbc	r26, r23
     24e:	a7 0b       	sbc	r26, r23
     250:	a7 0b       	sbc	r26, r23
     252:	a7 0b       	sbc	r26, r23
     254:	a7 0b       	sbc	r26, r23
     256:	a7 0b       	sbc	r26, r23
     258:	a7 0b       	sbc	r26, r23
     25a:	a7 0b       	sbc	r26, r23
     25c:	a7 0b       	sbc	r26, r23
     25e:	a7 0b       	sbc	r26, r23
     260:	a7 0b       	sbc	r26, r23
     262:	a7 0b       	sbc	r26, r23
     264:	a7 0b       	sbc	r26, r23
     266:	a7 0b       	sbc	r26, r23
     268:	a7 0b       	sbc	r26, r23
     26a:	a7 0b       	sbc	r26, r23
     26c:	a7 0b       	sbc	r26, r23
     26e:	a7 0b       	sbc	r26, r23
     270:	a7 0b       	sbc	r26, r23
     272:	a7 0b       	sbc	r26, r23
     274:	a7 0b       	sbc	r26, r23
     276:	a7 0b       	sbc	r26, r23
     278:	a7 0b       	sbc	r26, r23
     27a:	a7 0b       	sbc	r26, r23
     27c:	a7 0b       	sbc	r26, r23
     27e:	a7 0b       	sbc	r26, r23
     280:	a7 0b       	sbc	r26, r23
     282:	a7 0b       	sbc	r26, r23
     284:	a7 0b       	sbc	r26, r23
     286:	a7 0b       	sbc	r26, r23
     288:	a7 0b       	sbc	r26, r23
     28a:	43 0b       	sbc	r20, r19
     28c:	a7 0b       	sbc	r26, r23
     28e:	75 0b       	sbc	r23, r21
     290:	2f 0b       	sbc	r18, r31
     292:	a7 0b       	sbc	r26, r23
     294:	5d 0b       	sbc	r21, r29
     296:	2b 0b       	sbc	r18, r27
     298:	a7 0b       	sbc	r26, r23
     29a:	a7 0b       	sbc	r26, r23
     29c:	a7 0b       	sbc	r26, r23
     29e:	a7 0b       	sbc	r26, r23
     2a0:	a7 0b       	sbc	r26, r23
     2a2:	11 0b       	sbc	r17, r17
     2a4:	a7 0b       	sbc	r26, r23
     2a6:	a7 0b       	sbc	r26, r23
     2a8:	a7 0b       	sbc	r26, r23
     2aa:	8f 0b       	sbc	r24, r31
     2ac:	23 0b       	sbc	r18, r19
     2ae:	a7 0b       	sbc	r26, r23
     2b0:	a7 0b       	sbc	r26, r23
     2b2:	1f 0b       	sbc	r17, r31
     2b4:	ba 1c       	adc	r11, r10
     2b6:	bd 1c       	adc	r11, r13
     2b8:	c0 1c       	adc	r12, r0
     2ba:	c3 1c       	adc	r12, r3
     2bc:	c6 1c       	adc	r12, r6
     2be:	c9 1c       	adc	r12, r9
     2c0:	cb 1c       	adc	r12, r11
     2c2:	dc 1c       	adc	r13, r12
     2c4:	e4 1c       	adc	r14, r4
     2c6:	ee 1c       	adc	r14, r14
     2c8:	ec 1c       	adc	r14, r12

000002ca <__trampolines_start>:
     2ca:	0c 94 62 1c 	jmp	0x38c4	; 0x38c4 <_ZN8emstream14check_for_charEv>
     2ce:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2d2:	0c 94 23 0b 	jmp	0x1646	; 0x1646 <_ZN9task_user3runEv+0x170>
     2d6:	0c 94 2b 0b 	jmp	0x1656	; 0x1656 <_ZN9task_user3runEv+0x180>
     2da:	0c 94 5f 1c 	jmp	0x38be	; 0x38be <_ZN8emstream7getcharEv>
     2de:	0c 94 c6 1b 	jmp	0x378c	; 0x378c <__cxa_pure_virtual>
     2e2:	0c 94 a7 0b 	jmp	0x174e	; 0x174e <_ZN9task_user3runEv+0x278>
     2e6:	0c 94 2f 0b 	jmp	0x165e	; 0x165e <_ZN9task_user3runEv+0x188>
     2ea:	0c 94 e4 1c 	jmp	0x39c8	; 0x39c8 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2ee:	0c 94 48 21 	jmp	0x4290	; 0x4290 <_GLOBAL__sub_I_counter>
     2f2:	0c 94 ba 1c 	jmp	0x3974	; 0x3974 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2f6:	0c 94 c9 1c 	jmp	0x3992	; 0x3992 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2fa:	0c 94 b4 04 	jmp	0x968	; 0x968 <_ZN13LimitSwitches3runEv>
     2fe:	0c 94 6c 11 	jmp	0x22d8	; 0x22d8 <prvIdleTask>
     302:	0c 94 c0 1c 	jmp	0x3980	; 0x3980 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     306:	0c 94 03 1a 	jmp	0x3406	; 0x3406 <_ZN14frt_text_queue14check_for_charEv>
     30a:	0c 94 9b 18 	jmp	0x3136	; 0x3136 <_ZN8frt_task12print_statusER8emstream>
     30e:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <_ZN9task_user3runEv+0x248>
     312:	0c 94 0e 1a 	jmp	0x341c	; 0x341c <_ZN14frt_text_queue7putcharEc>
     316:	0c 94 e8 1d 	jmp	0x3bd0	; 0x3bd0 <_ZN5rs2327putcharEc>
     31a:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <_ZN15EncoderPendulum3runEv>
     31e:	0c 94 11 0b 	jmp	0x1622	; 0x1622 <_ZN9task_user3runEv+0x14c>
     322:	0c 94 ec 1c 	jmp	0x39d8	; 0x39d8 <_ZN8emstreamlsE15ser_manipulator+0x82>
     326:	0c 94 1f 0b 	jmp	0x163e	; 0x163e <_ZN9task_user3runEv+0x168>
     32a:	0c 94 32 1e 	jmp	0x3c64	; 0x3c64 <_ZN5rs23214check_for_charEv>
     32e:	0c 94 bd 1c 	jmp	0x397a	; 0x397a <_ZN8emstreamlsE15ser_manipulator+0x24>
     332:	0c 94 45 1e 	jmp	0x3c8a	; 0x3c8a <_ZN5rs23212clear_screenEv>
     336:	0c 94 65 1c 	jmp	0x38ca	; 0x38ca <_ZN8emstream12clear_screenEv>
     33a:	0c 94 43 0b 	jmp	0x1686	; 0x1686 <_ZN9task_user3runEv+0x1b0>
     33e:	0c 94 6b 0a 	jmp	0x14d6	; 0x14d6 <_ZN9task_user3runEv>
     342:	0c 94 5d 0b 	jmp	0x16ba	; 0x16ba <_ZN9task_user3runEv+0x1e4>
     346:	0c 94 e5 19 	jmp	0x33ca	; 0x33ca <_ZN14frt_text_queue7getcharEv>
     34a:	0c 94 ee 1c 	jmp	0x39dc	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
     34e:	0c 94 cd 03 	jmp	0x79a	; 0x79a <_ZN12EncoderMotor3runEv>
     352:	0c 94 0c 1e 	jmp	0x3c18	; 0x3c18 <_ZN5rs2327getcharEv>
     356:	0c 94 c6 1c 	jmp	0x398c	; 0x398c <_ZN8emstreamlsE15ser_manipulator+0x36>
     35a:	0c 94 c3 1c 	jmp	0x3986	; 0x3986 <_ZN8emstreamlsE15ser_manipulator+0x30>
     35e:	0c 94 dc 1c 	jmp	0x39b8	; 0x39b8 <_ZN8emstreamlsE15ser_manipulator+0x62>
     362:	0c 94 5d 1c 	jmp	0x38ba	; 0x38ba <_ZN8emstream13ready_to_sendEv>
     366:	0c 94 19 05 	jmp	0xa32	; 0xa32 <_ZN5Motor3runEv>
     36a:	0c 94 75 0b 	jmp	0x16ea	; 0x16ea <_ZN9task_user3runEv+0x214>
     36e:	0c 94 64 1c 	jmp	0x38c8	; 0x38c8 <_ZN8emstream12transmit_nowEv>
     372:	0c 94 92 03 	jmp	0x724	; 0x724 <_call_static_run_method>

00000376 <__trampolines_end>:
     376:	2c 20       	and	r2, r12
     378:	54 43       	sbci	r21, 0x34	; 52
     37a:	43 30       	cpi	r20, 0x03	; 3
     37c:	43 43       	sbci	r20, 0x33	; 51
     37e:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000381 <_ZZN9task_user11show_statusEvE3__c_3>:
     381:	2f 00                                               /.

00000383 <_ZZN9task_user11show_statusEvE3__c_2>:
     383:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000391 <_ZZN9task_user11show_statusEvE3__c_1>:
     391:	54 69 6d 65 3a 20 00                                Time: .

00000398 <_ZZN9task_user11show_statusEvE3__c_0>:
     398:	44 65 63 20 20 37 20 32 30 31 37 00                 Dec  7 2017.

000003a4 <_ZZN9task_user11show_statusEvE3__c>:
     3a4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3b4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003c3 <_ZZN9task_user18print_help_messageEvE3__c_14>:
     3c3:	20 20 20 20 72 3a 20 20 20 52 65 73 65 74 20 74         r:   Reset t
     3d3:	6f 20 49 64 6c 65 00                                o Idle.

000003da <_ZZN9task_user18print_help_messageEvE3__c_13>:
     3da:	20 20 20 20 64 3a 20 20 20 45 6d 65 72 67 65 6e         d:   Emergen
     3ea:	63 79 20 53 74 6f 70 00                             cy Stop.

000003f2 <_ZZN9task_user18print_help_messageEvE3__c_12>:
     3f2:	20 20 20 20 67 3a 20 20 20 53 77 69 6e 67 20 50         g:   Swing P
     402:	65 6e 64 75 6c 75 6d 20 55 70 72 69 67 68 74 2c     endulum Upright,
     412:	20 74 68 65 6e 20 47 6f 2e 00                        then Go..

0000041c <_ZZN9task_user18print_help_messageEvE3__c_11>:
     41c:	20 20 20 20 62 3a 20 20 20 42 65 67 69 6e 20 43         b:   Begin C
     42c:	61 6c 69 62 72 61 74 69 6f 6e 20 6f 66 20 49 6e     alibration of In
     43c:	76 65 72 74 65 64 20 50 65 6e 64 75 6c 75 6d 3f     verted Pendulum?
	...

0000044d <_ZZN9task_user18print_help_messageEvE3__c_10>:
     44d:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000045c <_ZZN9task_user18print_help_messageEvE3__c_9>:
     45c:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     46c:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000477 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     477:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     487:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000495 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     495:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     4a5:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     4b5:	6d 61 74 69 6f 6e 00                                mation.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_6>:
     4bc:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     4cc:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000004dd <_ZZN9task_user18print_help_messageEvE3__c_5>:
     4dd:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4ed:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004f5 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4f5:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     505:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000511 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     511:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     521:	68 65 20 41 56 52 00                                he AVR.

00000528 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     528:	20 68 65 6c 70 00                                    help.

0000052e <_ZZN9task_user18print_help_messageEvE3__c_1>:
     52e:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     53e:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000054d <_ZZN9task_user18print_help_messageEvE3__c_0>:
     54d:	1b 5b 33 30 6d 00                                   .[30m.

00000553 <_ZZN9task_user18print_help_messageEvE3__c>:
     553:	1b 5b 34 36 6d 00                                   .[46m.

00000559 <_ZZN9task_user3runEvE3__c_7>:
     559:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     569:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000576 <_ZZN9task_user3runEvE3__c_6>:
     576:	3a 57 54 46 3f 00                                   :WTF?.

0000057c <_ZZN9task_user3runEvE3__c_5>:
     57c:	52 65 73 65 74 2c 20 74 72 79 20 48 6f 6d 69 6e     Reset, try Homin
     58c:	67 20 61 67 61 69 6e 20 62 79 20 70 72 65 73 73     g again by press
     59c:	69 6e 67 20 27 62 27 00                             ing 'b'.

000005a4 <_ZZN9task_user3runEvE3__c_4>:
     5a4:	45 4d 45 52 47 45 4e 43 59 20 53 54 4f 50 00        EMERGENCY STOP.

000005b3 <_ZZN9task_user3runEvE3__c_3>:
     5b3:	43 6f 6d 6d 65 6e 63 65 20 42 61 6c 61 6e 63 65     Commence Balance
	...

000005c4 <_ZZN9task_user3runEvE3__c_2>:
     5c4:	42 65 67 69 6e 20 48 6f 6d 69 6e 67 00              Begin Homing.

000005d1 <_ZZN9task_user3runEvE3__c_1>:
     5d1:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     5e1:	65 00                                               e.

000005e3 <_ZZN9task_user3runEvE3__c_0>:
     5e3:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000005f1 <_ZZN9task_user3runEvE3__c>:
     5f1:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 74 6f 20     Press Ctrl-A to 
     601:	67 65 74 20 74 6f 20 63 6f 6d 6d 61 6e 64 20 6d     get to command m
     611:	6f 64 65 20 66 6f 72 20 49 6e 76 65 72 74 65 64     ode for Inverted
     621:	20 50 65 6e 64 75 6c 75 6d 00                        Pendulum.

0000062b <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     62b:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000635 <_ZZN8frt_task15emergency_resetEvE3__c>:
     635:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000644 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     644:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     654:	61 73 6b 20 00                                      ask .

00000659 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     659:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000667 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     667:	20 63 72 65 61 74 65 64 00                           created.

00000670 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     670:	54 61 73 6b 20 00                                   Task .

00000676 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     676:	1b 5b 32 32 6d 00                                   .[22m.

0000067c <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     67c:	54 61 73 6b 3a 20 00                                Task: .

00000683 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     683:	1b 5b 31 6d 00                                      .[1m.

00000688 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     688:	1b 5b 32 32 6d 00                                   .[22m.

0000068e <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     68e:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000699 <_ZZ17print_task_stacksP8emstreamE3__c>:
     699:	1b 5b 31 6d 00                                      .[1m.

0000069e <_ZZ15print_task_listP8emstreamE3__c_9>:
     69e:	09 09 00                                            ...

000006a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     6a1:	2f 00                                               /.

000006a3 <_ZZ15print_task_listP8emstreamE3__c_7>:
     6a3:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000006ae <_ZZ15print_task_listP8emstreamE3__c_6>:
     6ae:	09 2d 2d 2d 2d 00                                   .----.

000006b4 <_ZZ15print_task_listP8emstreamE3__c_5>:
     6b4:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000006c0 <_ZZ15print_task_listP8emstreamE3__c_4>:
     6c0:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000006d1 <_ZZ15print_task_listP8emstreamE3__c_3>:
     6d1:	09 52 75 6e 73 00                                   .Runs.

000006d7 <_ZZ15print_task_listP8emstreamE3__c_2>:
     6d7:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000006e3 <_ZZ15print_task_listP8emstreamE3__c_1>:
     6e3:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000006f4 <_ZZ15print_task_listP8emstreamE3__c_0>:
     6f4:	09 53 74 61 63 6b 00                                .Stack.

000006fb <_ZZ15print_task_listP8emstreamE3__c>:
     6fb:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000706 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     706:	09 00                                               ..

00000708 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     708:	09 00                                               ..

0000070a <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     70a:	2f 00                                               /.

0000070c <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     70c:	09 00                                               ..

0000070e <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     70e:	09 00                                               ..

00000710 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     710:	1b 5b 32 32 6d 00                                   .[22m.

00000716 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     716:	1b 5b 31 6d 00                                      .[1m.

0000071b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     71b:	1b 5b 31 6d 00                                      .[1m.

00000720 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     720:	20 20 00 00                                           ..

00000724 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     724:	0e 94 33 17 	call	0x2e66	; 0x2e66 <_ZN8frt_task22_call_users_run_methodEPS_>

00000728 <__ctors_start>:
     728:	48 21       	and	r20, r8

0000072a <__ctors_end>:
     72a:	11 24       	eor	r1, r1
     72c:	1f be       	out	0x3f, r1	; 63
     72e:	cf ef       	ldi	r28, 0xFF	; 255
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df e3       	ldi	r29, 0x3F	; 63
     734:	de bf       	out	0x3e, r29	; 62
     736:	00 e0       	ldi	r16, 0x00	; 0
     738:	0c bf       	out	0x3c, r16	; 60
     73a:	18 be       	out	0x38, r1	; 56
     73c:	19 be       	out	0x39, r1	; 57
     73e:	1a be       	out	0x3a, r1	; 58
     740:	1b be       	out	0x3b, r1	; 59

00000742 <__do_copy_data>:
     742:	10 e2       	ldi	r17, 0x20	; 32
     744:	a0 e0       	ldi	r26, 0x00	; 0
     746:	b0 e2       	ldi	r27, 0x20	; 32
     748:	e4 ef       	ldi	r30, 0xF4	; 244
     74a:	f5 e4       	ldi	r31, 0x45	; 69
     74c:	00 e0       	ldi	r16, 0x00	; 0
     74e:	0b bf       	out	0x3b, r16	; 59
     750:	02 c0       	rjmp	.+4      	; 0x756 <__do_copy_data+0x14>
     752:	07 90       	elpm	r0, Z+
     754:	0d 92       	st	X+, r0
     756:	ac 3b       	cpi	r26, 0xBC	; 188
     758:	b1 07       	cpc	r27, r17
     75a:	d9 f7       	brne	.-10     	; 0x752 <__do_copy_data+0x10>
     75c:	1b be       	out	0x3b, r1	; 59

0000075e <__do_clear_bss>:
     75e:	21 e3       	ldi	r18, 0x31	; 49
     760:	ac eb       	ldi	r26, 0xBC	; 188
     762:	b0 e2       	ldi	r27, 0x20	; 32
     764:	01 c0       	rjmp	.+2      	; 0x768 <.do_clear_bss_start>

00000766 <.do_clear_bss_loop>:
     766:	1d 92       	st	X+, r1

00000768 <.do_clear_bss_start>:
     768:	a6 36       	cpi	r26, 0x66	; 102
     76a:	b2 07       	cpc	r27, r18
     76c:	e1 f7       	brne	.-8      	; 0x766 <.do_clear_bss_loop>

0000076e <__do_global_ctors>:
     76e:	13 e0       	ldi	r17, 0x03	; 3
     770:	c5 e9       	ldi	r28, 0x95	; 149
     772:	d3 e0       	ldi	r29, 0x03	; 3
     774:	00 e0       	ldi	r16, 0x00	; 0
     776:	06 c0       	rjmp	.+12     	; 0x784 <__do_global_ctors+0x16>
     778:	21 97       	sbiw	r28, 0x01	; 1
     77a:	01 09       	sbc	r16, r1
     77c:	80 2f       	mov	r24, r16
     77e:	fe 01       	movw	r30, r28
     780:	0e 94 29 22 	call	0x4452	; 0x4452 <__tablejump2__>
     784:	c4 39       	cpi	r28, 0x94	; 148
     786:	d1 07       	cpc	r29, r17
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	08 07       	cpc	r16, r24
     78c:	a9 f7       	brne	.-22     	; 0x778 <__do_global_ctors+0xa>
     78e:	0e 94 b9 20 	call	0x4172	; 0x4172 <main>
     792:	0c 94 f8 22 	jmp	0x45f0	; 0x45f0 <_exit>

00000796 <__bad_interrupt>:
     796:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000079a <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <_ZN12EncoderMotor3runEv+0x6>
     7a0:	1f 92       	push	r1
     7a2:	cd b7       	in	r28, 0x3d	; 61
     7a4:	de b7       	in	r29, 0x3e	; 62
     7a6:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7a8:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskGetTickCount>
     7ac:	69 83       	std	Y+1, r22	; 0x01
     7ae:	7a 83       	std	Y+2, r23	; 0x02
     7b0:	8b 83       	std	Y+3, r24	; 0x03
     7b2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     7b4:	e0 e8       	ldi	r30, 0x80	; 128
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	8c e0       	ldi	r24, 0x0C	; 12
     7ba:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     7bc:	82 89       	ldd	r24, Z+18	; 0x12
     7be:	83 60       	ori	r24, 0x03	; 3
     7c0:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     7c2:	83 89       	ldd	r24, Z+19	; 0x13
     7c4:	83 60       	ori	r24, 0x03	; 3
     7c6:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     7c8:	e0 e8       	ldi	r30, 0x80	; 128
     7ca:	f1 e0       	ldi	r31, 0x01	; 1
     7cc:	82 e7       	ldi	r24, 0x72	; 114
     7ce:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     7d0:	89 e0       	ldi	r24, 0x09	; 9
     7d2:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     7d4:	e0 e0       	ldi	r30, 0x00	; 0
     7d6:	f9 e0       	ldi	r31, 0x09	; 9
     7d8:	88 e6       	ldi	r24, 0x68	; 104
     7da:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	9f ef       	ldi	r25, 0xFF	; 255
     7e0:	86 a3       	std	Z+38, r24	; 0x26
     7e2:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     7e8:	0f 2e       	mov	r0, r31
     7ea:	a1 2c       	mov	r10, r1
     7ec:	f9 e0       	ldi	r31, 0x09	; 9
     7ee:	bf 2e       	mov	r11, r31
     7f0:	f0 2d       	mov	r31, r0
     7f2:	f5 01       	movw	r30, r10
     7f4:	00 a1       	ldd	r16, Z+32	; 0x20
     7f6:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     7f8:	0f b6       	in	r0, 0x3f	; 63
     7fa:	f8 94       	cli
     7fc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	0f 92       	push	r0
			the_data = new_data;
     808:	c8 01       	movw	r24, r16
     80a:	01 2e       	mov	r0, r17
     80c:	00 0c       	add	r0, r0
     80e:	aa 0b       	sbc	r26, r26
     810:	bb 0b       	sbc	r27, r27
     812:	ac 01       	movw	r20, r24
     814:	bd 01       	movw	r22, r26
     816:	44 0f       	add	r20, r20
     818:	55 1f       	adc	r21, r21
     81a:	66 1f       	adc	r22, r22
     81c:	77 1f       	adc	r23, r23
     81e:	3a 01       	movw	r6, r20
     820:	4b 01       	movw	r8, r22
     822:	68 0e       	add	r6, r24
     824:	79 1e       	adc	r7, r25
     826:	8a 1e       	adc	r8, r26
     828:	9b 1e       	adc	r9, r27
     82a:	c4 01       	movw	r24, r8
     82c:	b3 01       	movw	r22, r6
     82e:	24 e6       	ldi	r18, 0x64	; 100
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	0e 94 0a 22 	call	0x4414	; 0x4414 <__divmodsi4>
     83a:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <linear_offset>
     83e:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <linear_offset+0x1>
     842:	28 1b       	sub	r18, r24
     844:	39 0b       	sbc	r19, r25
     846:	20 93 52 31 	sts	0x3152, r18	; 0x803152 <linear_position>
     84a:	30 93 53 31 	sts	0x3153, r19	; 0x803153 <linear_position+0x1>
			portEXIT_CRITICAL ();
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
			the_data = new_data;
     858:	c8 01       	movw	r24, r16
     85a:	8c 19       	sub	r24, r12
     85c:	9d 09       	sbc	r25, r13
     85e:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <thdMotor>
     862:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     86a:	f7 01       	movw	r30, r14
     86c:	86 85       	ldd	r24, Z+14	; 0x0e
     86e:	97 85       	ldd	r25, Z+15	; 0x0f
     870:	a0 89       	ldd	r26, Z+16	; 0x10
     872:	b1 89       	ldd	r27, Z+17	; 0x11
     874:	01 96       	adiw	r24, 0x01	; 1
     876:	a1 1d       	adc	r26, r1
     878:	b1 1d       	adc	r27, r1
     87a:	86 87       	std	Z+14, r24	; 0x0e
     87c:	97 87       	std	Z+15, r25	; 0x0f
     87e:	a0 8b       	std	Z+16, r26	; 0x10
     880:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     882:	41 e0       	ldi	r20, 0x01	; 1
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	ce 01       	movw	r24, r28
     88c:	01 96       	adiw	r24, 0x01	; 1
     88e:	0e 94 a9 14 	call	0x2952	; 0x2952 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     892:	68 01       	movw	r12, r16
     894:	ae cf       	rjmp	.-164    	; 0x7f2 <_ZN12EncoderMotor3runEv+0x58>

00000896 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a0:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <_ZN8frt_taskC1EPKchjP8emstream>
     8a4:	8a e0       	ldi	r24, 0x0A	; 10
     8a6:	90 e2       	ldi	r25, 0x20	; 32
     8a8:	88 83       	st	Y, r24
     8aa:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN15EncoderPendulum3runEv+0x6>
     8bc:	1f 92       	push	r1
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskGetTickCount>
     8c8:	69 83       	std	Y+1, r22	; 0x01
     8ca:	7a 83       	std	Y+2, r23	; 0x02
     8cc:	8b 83       	std	Y+3, r24	; 0x03
     8ce:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     8d0:	e0 e8       	ldi	r30, 0x80	; 128
     8d2:	f6 e0       	ldi	r31, 0x06	; 6
     8d4:	83 e0       	ldi	r24, 0x03	; 3
     8d6:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     8d8:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     8da:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     8dc:	e0 e8       	ldi	r30, 0x80	; 128
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	80 e7       	ldi	r24, 0x70	; 112
     8e2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     8e4:	89 e0       	ldi	r24, 0x09	; 9
     8e6:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     8e8:	e0 e4       	ldi	r30, 0x40	; 64
     8ea:	f8 e0       	ldi	r31, 0x08	; 8
     8ec:	8a e6       	ldi	r24, 0x6A	; 106
     8ee:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     8f0:	80 ea       	ldi	r24, 0xA0	; 160
     8f2:	95 e0       	ldi	r25, 0x05	; 5
     8f4:	86 a3       	std	Z+38, r24	; 0x26
     8f6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     8fc:	68 94       	set
     8fe:	ee 24       	eor	r14, r14
     900:	e6 f8       	bld	r14, 6
     902:	ff 24       	eor	r15, r15
     904:	f3 f8       	bld	r15, 3
     906:	f7 01       	movw	r30, r14
     908:	80 a1       	ldd	r24, Z+32	; 0x20
     90a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
			the_data = new_data;
     912:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <thPendulum>
     916:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <thPendulum+0x1>
			portEXIT_CRITICAL ();
     91a:	0f 90       	pop	r0
     91c:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     91e:	f8 01       	movw	r30, r16
     920:	86 85       	ldd	r24, Z+14	; 0x0e
     922:	97 85       	ldd	r25, Z+15	; 0x0f
     924:	a0 89       	ldd	r26, Z+16	; 0x10
     926:	b1 89       	ldd	r27, Z+17	; 0x11
     928:	01 96       	adiw	r24, 0x01	; 1
     92a:	a1 1d       	adc	r26, r1
     92c:	b1 1d       	adc	r27, r1
     92e:	86 87       	std	Z+14, r24	; 0x0e
     930:	97 87       	std	Z+15, r25	; 0x0f
     932:	a0 8b       	std	Z+16, r26	; 0x10
     934:	b1 8b       	std	Z+17, r27	; 0x11
     936:	41 e0       	ldi	r20, 0x01	; 1
     938:	50 e0       	ldi	r21, 0x00	; 0
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	70 e0       	ldi	r23, 0x00	; 0
     93e:	ce 01       	movw	r24, r28
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	0e 94 a9 14 	call	0x2952	; 0x2952 <vTaskDelayUntil>
     946:	df cf       	rjmp	.-66     	; 0x906 <_ZN15EncoderPendulum3runEv+0x50>

00000948 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     952:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <_ZN8frt_taskC1EPKchjP8emstream>
     956:	82 e1       	ldi	r24, 0x12	; 18
     958:	90 e2       	ldi	r25, 0x20	; 32
     95a:	88 83       	st	Y, r24
     95c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	08 95       	ret

00000968 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	00 d0       	rcall	.+0      	; 0x96e <_ZN13LimitSwitches3runEv+0x6>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     976:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskGetTickCount>
     97a:	69 83       	std	Y+1, r22	; 0x01
     97c:	7a 83       	std	Y+2, r23	; 0x02
     97e:	8b 83       	std	Y+3, r24	; 0x03
     980:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     982:	e0 e6       	ldi	r30, 0x60	; 96
     984:	f6 e0       	ldi	r31, 0x06	; 6
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     98a:	84 e0       	ldi	r24, 0x04	; 4
     98c:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     98e:	88 e1       	ldi	r24, 0x18	; 24
     990:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     992:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     994:	08 e6       	ldi	r16, 0x68	; 104
     996:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     998:	dd 24       	eor	r13, r13
     99a:	d3 94       	inc	r13
     99c:	f8 01       	movw	r30, r16
     99e:	80 81       	ld	r24, Z
     9a0:	80 fd       	sbrc	r24, 0
     9a2:	08 c0       	rjmp	.+16     	; 0x9b4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
			the_data = new_data;
     9aa:	d0 92 4d 31 	sts	0x314D, r13	; 0x80314d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9ae:	0f 90       	pop	r0
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	07 c0       	rjmp	.+14     	; 0x9c2 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	0f 92       	push	r0
			the_data = new_data;
     9ba:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     9c2:	f8 01       	movw	r30, r16
     9c4:	80 81       	ld	r24, Z
     9c6:	82 fd       	sbrc	r24, 2
     9c8:	08 c0       	rjmp	.+16     	; 0x9da <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
			the_data = new_data;
     9d0:	d0 92 4c 31 	sts	0x314C, r13	; 0x80314c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	f8 94       	cli
     9de:	0f 92       	push	r0
			the_data = new_data;
     9e0:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     9e8:	f7 01       	movw	r30, r14
     9ea:	86 85       	ldd	r24, Z+14	; 0x0e
     9ec:	97 85       	ldd	r25, Z+15	; 0x0f
     9ee:	a0 89       	ldd	r26, Z+16	; 0x10
     9f0:	b1 89       	ldd	r27, Z+17	; 0x11
     9f2:	01 96       	adiw	r24, 0x01	; 1
     9f4:	a1 1d       	adc	r26, r1
     9f6:	b1 1d       	adc	r27, r1
     9f8:	86 87       	std	Z+14, r24	; 0x0e
     9fa:	97 87       	std	Z+15, r25	; 0x0f
     9fc:	a0 8b       	std	Z+16, r26	; 0x10
     9fe:	b1 8b       	std	Z+17, r27	; 0x11
     a00:	41 e0       	ldi	r20, 0x01	; 1
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	01 96       	adiw	r24, 0x01	; 1
     a0c:	0e 94 a9 14 	call	0x2952	; 0x2952 <vTaskDelayUntil>
     a10:	c5 cf       	rjmp	.-118    	; 0x99c <_ZN13LimitSwitches3runEv+0x34>

00000a12 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a1c:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <_ZN8frt_taskC1EPKchjP8emstream>
     a20:	8a e1       	ldi	r24, 0x1A	; 26
     a22:	90 e2       	ldi	r25, 0x20	; 32
     a24:	88 83       	st	Y, r24
     a26:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	08 95       	ret

00000a32 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	68 97       	sbiw	r28, 0x18	; 24
     a3c:	cd bf       	out	0x3d, r28	; 61
     a3e:	de bf       	out	0x3e, r29	; 62
     a40:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     a42:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskGetTickCount>
     a46:	69 83       	std	Y+1, r22	; 0x01
     a48:	7a 83       	std	Y+2, r23	; 0x02
     a4a:	8b 83       	std	Y+3, r24	; 0x03
     a4c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     a4e:	f8 01       	movw	r30, r16
     a50:	fe 96       	adiw	r30, 0x3e	; 62
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	a0 e0       	ldi	r26, 0x00	; 0
     a58:	b0 e0       	ldi	r27, 0x00	; 0
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
     a5e:	a2 83       	std	Z+2, r26	; 0x02
     a60:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     a62:	d8 01       	movw	r26, r16
     a64:	dc 96       	adiw	r26, 0x3c	; 60
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     a6c:	a0 e4       	ldi	r26, 0x40	; 64
     a6e:	b6 e0       	ldi	r27, 0x06	; 6
     a70:	87 e0       	ldi	r24, 0x07	; 7
     a72:	11 96       	adiw	r26, 0x01	; 1
     a74:	8c 93       	st	X, r24
     a76:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     a78:	84 e0       	ldi	r24, 0x04	; 4
     a7a:	15 96       	adiw	r26, 0x05	; 5
     a7c:	8c 93       	st	X, r24
     a7e:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     a80:	e0 e0       	ldi	r30, 0x00	; 0
     a82:	f8 e0       	ldi	r31, 0x08	; 8
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     a88:	83 e0       	ldi	r24, 0x03	; 3
     a8a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     a8c:	a6 a3       	std	Z+38, r26	; 0x26
     a8e:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     a90:	10 a6       	std	Z+40, r1	; 0x28
     a92:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     a94:	12 a6       	std	Z+42, r1	; 0x2a
     a96:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     a98:	81 81       	ldd	r24, Z+1	; 0x01
     a9a:	80 63       	ori	r24, 0x30	; 48
     a9c:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	0f 92       	push	r0
			the_data = new_data;
     aa4:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <linear_offset>
     aa8:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     aac:	0f 90       	pop	r0
     aae:	0f be       	out	0x3f, r0	; 63
	linear_offset.put(0);								// Initialize motor offset	
	int16_t left_home;									// Initialize left distance to calculate center
	int16_t position_set;								// Setpoint of cart's position
	int16_t KP_pos = 100;								// P gain for cart position				
	int16_t position_error = 0;							// positional error	
	int16_t position_midpoint = 0;						// midpoint calculated from homing sequence
     ab0:	1d 8a       	std	Y+21, r1	; 0x15
     ab2:	1e 8a       	std	Y+22, r1	; 0x16
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(200);
				_integral = 0;
     ab4:	58 01       	movw	r10, r16
     ab6:	b0 e5       	ldi	r27, 0x50	; 80
     ab8:	ab 0e       	add	r10, r27
     aba:	b1 1c       	adc	r11, r1
			case(0) :
				if (begin.get())											// If user begins Calibration Sequence
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     abc:	0f 2e       	mov	r0, r31
     abe:	fa e0       	ldi	r31, 0x0A	; 10
     ac0:	2f 2e       	mov	r2, r31
     ac2:	31 2c       	mov	r3, r1
     ac4:	f0 2d       	mov	r31, r0

					if (rightLimitSwitch.get())
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
						output_correct = 0;
     ac6:	68 01       	movw	r12, r16
     ac8:	ee e5       	ldi	r30, 0x5E	; 94
     aca:	ce 0e       	add	r12, r30
     acc:	d1 1c       	adc	r13, r1
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     ace:	98 01       	movw	r18, r16
     ad0:	28 5b       	subi	r18, 0xB8	; 184
     ad2:	3f 4f       	sbci	r19, 0xFF	; 255
     ad4:	2f 87       	std	Y+15, r18	; 0x0f
     ad6:	38 8b       	std	Y+16, r19	; 0x10
		_Ki = .7*256;
     ad8:	c8 01       	movw	r24, r16
     ada:	84 5b       	subi	r24, 0xB4	; 180
     adc:	9f 4f       	sbci	r25, 0xFF	; 255
     ade:	8d 83       	std	Y+5, r24	; 0x05
     ae0:	9e 83       	std	Y+6, r25	; 0x06
		_Kd = 0;
     ae2:	d8 01       	movw	r26, r16
     ae4:	a6 5b       	subi	r26, 0xB6	; 182
     ae6:	bf 4f       	sbci	r27, 0xFF	; 255
     ae8:	a9 8b       	std	Y+17, r26	; 0x11
     aea:	ba 8b       	std	Y+18, r27	; 0x12
		antiwind_gain = .75*256;
     aec:	f8 01       	movw	r30, r16
     aee:	ec 59       	subi	r30, 0x9C	; 156
     af0:	ff 4f       	sbci	r31, 0xFF	; 255
     af2:	ef 83       	std	Y+7, r30	; 0x07
     af4:	f8 87       	std	Y+8, r31	; 0x08
		
		_max = 1600;
     af6:	24 50       	subi	r18, 0x04	; 4
     af8:	31 09       	sbc	r19, r1
     afa:	29 87       	std	Y+9, r18	; 0x09
     afc:	3a 87       	std	Y+10, r19	; 0x0a
		_min = -1600;
     afe:	06 97       	sbiw	r24, 0x06	; 6
     b00:	8d 87       	std	Y+13, r24	; 0x0d
     b02:	9e 87       	std	Y+14, r25	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     b04:	52 96       	adiw	r26, 0x12	; 18
     b06:	ab 8b       	std	Y+19, r26	; 0x13
     b08:	bc 8b       	std	Y+20, r27	; 0x14

		// Integral term
		error_int = error - antiwind_correct;
     b0a:	48 01       	movw	r8, r16
     b0c:	b6 e6       	ldi	r27, 0x66	; 102
     b0e:	8b 0e       	add	r8, r27
     b10:	91 1c       	adc	r9, r1
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     b12:	b6 97       	sbiw	r30, 0x26	; 38
     b14:	eb 87       	std	Y+11, r30	; 0x0b
     b16:	fc 87       	std	Y+12, r31	; 0x0c
	int16_t switchcountleft;
	int16_t switchcountright;
	
	while(1){
		// Increment counter for debugging
		runs++;
     b18:	d8 01       	movw	r26, r16
     b1a:	1e 96       	adiw	r26, 0x0e	; 14
     b1c:	4d 91       	ld	r20, X+
     b1e:	5d 91       	ld	r21, X+
     b20:	6d 91       	ld	r22, X+
     b22:	7c 91       	ld	r23, X
     b24:	51 97       	sbiw	r26, 0x11	; 17
     b26:	4f 5f       	subi	r20, 0xFF	; 255
     b28:	5f 4f       	sbci	r21, 0xFF	; 255
     b2a:	6f 4f       	sbci	r22, 0xFF	; 255
     b2c:	7f 4f       	sbci	r23, 0xFF	; 255
     b2e:	f8 01       	movw	r30, r16
     b30:	46 87       	std	Z+14, r20	; 0x0e
     b32:	57 87       	std	Z+15, r21	; 0x0f
     b34:	60 8b       	std	Z+16, r22	; 0x10
     b36:	71 8b       	std	Z+17, r23	; 0x11
		
		switch (state)
     b38:	84 85       	ldd	r24, Z+12	; 0x0c
     b3a:	82 30       	cpi	r24, 0x02	; 2
     b3c:	09 f4       	brne	.+2      	; 0xb40 <_ZN5Motor3runEv+0x10e>
     b3e:	8f c0       	rjmp	.+286    	; 0xc5e <_ZN5Motor3runEv+0x22c>
     b40:	30 f4       	brcc	.+12     	; 0xb4e <_ZN5Motor3runEv+0x11c>
     b42:	88 23       	and	r24, r24
     b44:	69 f0       	breq	.+26     	; 0xb60 <_ZN5Motor3runEv+0x12e>
     b46:	81 30       	cpi	r24, 0x01	; 1
     b48:	09 f4       	brne	.+2      	; 0xb4c <_ZN5Motor3runEv+0x11a>
     b4a:	4d c0       	rjmp	.+154    	; 0xbe6 <_ZN5Motor3runEv+0x1b4>
     b4c:	67 c1       	rjmp	.+718    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
     b4e:	84 30       	cpi	r24, 0x04	; 4
     b50:	09 f4       	brne	.+2      	; 0xb54 <_ZN5Motor3runEv+0x122>
     b52:	e5 c0       	rjmp	.+458    	; 0xd1e <_ZN5Motor3runEv+0x2ec>
     b54:	08 f4       	brcc	.+2      	; 0xb58 <_ZN5Motor3runEv+0x126>
     b56:	97 c0       	rjmp	.+302    	; 0xc86 <_ZN5Motor3runEv+0x254>
     b58:	84 36       	cpi	r24, 0x64	; 100
     b5a:	09 f4       	brne	.+2      	; 0xb5e <_ZN5Motor3runEv+0x12c>
     b5c:	2e c1       	rjmp	.+604    	; 0xdba <_ZN5Motor3runEv+0x388>
     b5e:	5e c1       	rjmp	.+700    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b60:	0f b6       	in	r0, 0x3f	; 63
     b62:	f8 94       	cli
     b64:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b66:	0f 90       	pop	r0
     b68:	0f be       	out	0x3f, r0	; 63
		{
			// Home right
			case(0) :
				if (begin.get())											// If user begins Calibration Sequence
     b6a:	80 91 49 31 	lds	r24, 0x3149	; 0x803149 <begin>
     b6e:	88 23       	and	r24, r24
     b70:	09 f4       	brne	.+2      	; 0xb74 <_ZN5Motor3runEv+0x142>
     b72:	54 c1       	rjmp	.+680    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b74:	0f b6       	in	r0, 0x3f	; 63
     b76:	f8 94       	cli
     b78:	0f 92       	push	r0
			the_data = new_data;
     b7a:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     b7e:	0f 90       	pop	r0
     b80:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b82:	0f b6       	in	r0, 0x3f	; 63
     b84:	f8 94       	cli
     b86:	0f 92       	push	r0
			the_data = new_data;
     b88:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <stop>
			portEXIT_CRITICAL ();
     b8c:	0f 90       	pop	r0
     b8e:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     b90:	22 8e       	std	Z+26, r2	; 0x1a
     b92:	33 8e       	std	Z+27, r3	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b94:	0f b6       	in	r0, 0x3f	; 63
     b96:	f8 94       	cli
     b98:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63
					switchcountright = 0;

					if (rightLimitSwitch.get())
     b9e:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rightLimitSwitch>
     ba2:	88 23       	and	r24, r24
     ba4:	09 f4       	brne	.+2      	; 0xba8 <_ZN5Motor3runEv+0x176>
     ba6:	3a c1       	rjmp	.+628    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ba8:	0f b6       	in	r0, 0x3f	; 63
     baa:	f8 94       	cli
     bac:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bae:	0f 90       	pop	r0
     bb0:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bb2:	0f b6       	in	r0, 0x3f	; 63
     bb4:	f8 94       	cli
     bb6:	0f 92       	push	r0
			the_data = new_data;
     bb8:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     bbc:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     bc0:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <linear_offset>
     bc4:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     bc8:	0f 90       	pop	r0
     bca:	0f be       	out	0x3f, r0	; 63
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
     bcc:	f5 01       	movw	r30, r10
     bce:	10 82       	st	Z, r1
     bd0:	11 82       	std	Z+1, r1	; 0x01
     bd2:	12 82       	std	Z+2, r1	; 0x02
     bd4:	13 82       	std	Z+3, r1	; 0x03
						output_correct = 0;
     bd6:	d6 01       	movw	r26, r12
     bd8:	1d 92       	st	X+, r1
     bda:	1c 92       	st	X, r1
						transition_to(1);									// if right Limit Switch is triggered 
     bdc:	61 e0       	ldi	r22, 0x01	; 1
     bde:	c8 01       	movw	r24, r16
     be0:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
     be4:	1b c1       	rjmp	.+566    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     be6:	0f b6       	in	r0, 0x3f	; 63
     be8:	f8 94       	cli
     bea:	0f 92       	push	r0
			the_data = new_data;
     bec:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <begin>
			portEXIT_CRITICAL ();
     bf0:	0f 90       	pop	r0
     bf2:	0f be       	out	0x3f, r0	; 63
				break;
				
			// Home left
			case(1) :
				begin.put(0);		// turn off flag
				omegam_set = -10;	// [ticks/ms]
     bf4:	86 ef       	ldi	r24, 0xF6	; 246
     bf6:	9f ef       	ldi	r25, 0xFF	; 255
     bf8:	f8 01       	movw	r30, r16
     bfa:	82 8f       	std	Z+26, r24	; 0x1a
     bfc:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bfe:	0f b6       	in	r0, 0x3f	; 63
     c00:	f8 94       	cli
     c02:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c04:	0f 90       	pop	r0
     c06:	0f be       	out	0x3f, r0	; 63
				switchcountleft = 0;
				
				if (leftLimitSwitch.get())
     c08:	80 91 4d 31 	lds	r24, 0x314D	; 0x80314d <leftLimitSwitch>
     c0c:	88 23       	and	r24, r24
     c0e:	c1 f0       	breq	.+48     	; 0xc40 <_ZN5Motor3runEv+0x20e>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c10:	0f b6       	in	r0, 0x3f	; 63
     c12:	f8 94       	cli
     c14:	0f 92       	push	r0
			temporary_copy = the_data;
     c16:	20 91 52 31 	lds	r18, 0x3152	; 0x803152 <linear_position>
     c1a:	30 91 53 31 	lds	r19, 0x3153	; 0x803153 <linear_position+0x1>
     c1e:	2f 8b       	std	Y+23, r18	; 0x17
     c20:	38 8f       	std	Y+24, r19	; 0x18
			portEXIT_CRITICAL ();
     c22:	0f 90       	pop	r0
     c24:	0f be       	out	0x3f, r0	; 63
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     c26:	d5 01       	movw	r26, r10
     c28:	1d 92       	st	X+, r1
     c2a:	1d 92       	st	X+, r1
     c2c:	1d 92       	st	X+, r1
     c2e:	1c 92       	st	X, r1
     c30:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     c32:	f6 01       	movw	r30, r12
     c34:	10 82       	st	Z, r1
     c36:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     c38:	62 e0       	ldi	r22, 0x02	; 2
     c3a:	c8 01       	movw	r24, r16
     c3c:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c46:	0f 90       	pop	r0
     c48:	0f be       	out	0x3f, r0	; 63
				}
						
				if (reset.get() == 1)
     c4a:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     c4e:	88 23       	and	r24, r24
     c50:	09 f4       	brne	.+2      	; 0xc54 <_ZN5Motor3runEv+0x222>
     c52:	e4 c0       	rjmp	.+456    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				{
					transition_to(0);
     c54:	60 e0       	ldi	r22, 0x00	; 0
     c56:	c8 01       	movw	r24, r16
     c58:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
     c5c:	df c0       	rjmp	.+446    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     c5e:	68 ec       	ldi	r22, 0xC8	; 200
     c60:	70 e0       	ldi	r23, 0x00	; 0
     c62:	80 e0       	ldi	r24, 0x00	; 0
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vTaskDelay>
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(200);
				_integral = 0;
     c6a:	d5 01       	movw	r26, r10
     c6c:	1d 92       	st	X+, r1
     c6e:	1d 92       	st	X+, r1
     c70:	1d 92       	st	X+, r1
     c72:	1c 92       	st	X, r1
     c74:	13 97       	sbiw	r26, 0x03	; 3
				omegam_set = 0;
     c76:	f8 01       	movw	r30, r16
     c78:	12 8e       	std	Z+26, r1	; 0x1a
     c7a:	13 8e       	std	Z+27, r1	; 0x1b
				transition_to(3);
     c7c:	63 e0       	ldi	r22, 0x03	; 3
     c7e:	c8 01       	movw	r24, r16
     c80:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
				break;
     c84:	cb c0       	rjmp	.+406    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				
			
			// Center Cart - Position Loop included
			case(3) :
				position_midpoint = left_home/2;
     c86:	8f 89       	ldd	r24, Y+23	; 0x17
     c88:	98 8d       	ldd	r25, Y+24	; 0x18
     c8a:	99 23       	and	r25, r25
     c8c:	0c f4       	brge	.+2      	; 0xc90 <_ZN5Motor3runEv+0x25e>
     c8e:	01 96       	adiw	r24, 0x01	; 1
     c90:	9c 01       	movw	r18, r24
     c92:	35 95       	asr	r19
     c94:	27 95       	ror	r18
     c96:	2d 8b       	std	Y+21, r18	; 0x15
     c98:	3e 8b       	std	Y+22, r19	; 0x16
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c9a:	0f b6       	in	r0, 0x3f	; 63
     c9c:	f8 94       	cli
     c9e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     ca0:	0f 90       	pop	r0
     ca2:	0f be       	out	0x3f, r0	; 63
				
				position_windup = position_error - antiwind_correct;
				position_windup_Ki = (_Ki_position * position_windup);
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_Ki * dt)/256;
				omegam_set = ssadd(omegam_set_Kp, omegam_set_Ki);
     ca4:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     ca8:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     cac:	28 1b       	sub	r18, r24
     cae:	39 0b       	sbc	r19, r25
     cb0:	44 e6       	ldi	r20, 0x64	; 100
     cb2:	42 9f       	mul	r20, r18
     cb4:	c0 01       	movw	r24, r0
     cb6:	43 9f       	mul	r20, r19
     cb8:	90 0d       	add	r25, r0
     cba:	11 24       	eor	r1, r1
     cbc:	68 ee       	ldi	r22, 0xE8	; 232
     cbe:	73 e0       	ldi	r23, 0x03	; 3
     cc0:	0e 94 d4 21 	call	0x43a8	; 0x43a8 <__divmodhi4>
     cc4:	cb 01       	movw	r24, r22
     cc6:	60 e0       	ldi	r22, 0x00	; 0
     cc8:	70 e0       	ldi	r23, 0x00	; 0
     cca:	0e 94 c2 08 	call	0x1184	; 0x1184 <_ZN7satmath20signed_saturated_addEii>
     cce:	d8 01       	movw	r26, r16
     cd0:	5a 96       	adiw	r26, 0x1a	; 26
     cd2:	8d 93       	st	X+, r24
     cd4:	9c 93       	st	X, r25
     cd6:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cd8:	0f b6       	in	r0, 0x3f	; 63
     cda:	f8 94       	cli
     cdc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cde:	0f 90       	pop	r0
     ce0:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get() == 1)			// if user hits reset
     ce2:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     ce6:	88 23       	and	r24, r24
     ce8:	59 f0       	breq	.+22     	; 0xd00 <_ZN5Motor3runEv+0x2ce>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	0f 92       	push	r0
			the_data = new_data;
     cf0:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     cf4:	0f 90       	pop	r0
     cf6:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);				// turn off flag
					transition_to(0);
     cf8:	60 e0       	ldi	r22, 0x00	; 0
     cfa:	c8 01       	movw	r24, r16
     cfc:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d00:	0f b6       	in	r0, 0x3f	; 63
     d02:	f8 94       	cli
     d04:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d06:	0f 90       	pop	r0
     d08:	0f be       	out	0x3f, r0	; 63
					
				}
				
				if(go.get() == 1)				// If user says pendulum is upright or angle = 720;
     d0a:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <go>
     d0e:	88 23       	and	r24, r24
     d10:	09 f4       	brne	.+2      	; 0xd14 <_ZN5Motor3runEv+0x2e2>
     d12:	84 c0       	rjmp	.+264    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				{
					transition_to(4);
     d14:	64 e0       	ldi	r22, 0x04	; 4
     d16:	c8 01       	movw	r24, r16
     d18:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
     d1c:	7f c0       	rjmp	.+254    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d1e:	0f b6       	in	r0, 0x3f	; 63
     d20:	f8 94       	cli
     d22:	0f 92       	push	r0
			the_data = new_data;
     d24:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <go>
			portEXIT_CRITICAL ();
     d28:	0f 90       	pop	r0
     d2a:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d2c:	0f b6       	in	r0, 0x3f	; 63
     d2e:	f8 94       	cli
     d30:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d32:	0f 90       	pop	r0
     d34:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d36:	0f b6       	in	r0, 0x3f	; 63
     d38:	f8 94       	cli
     d3a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d3c:	0f 90       	pop	r0
     d3e:	0f be       	out	0x3f, r0	; 63
			case(4) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				position_set = position_midpoint + angle_error*KP_angle/1000;
				position_error = position_set - linear_position.get();  // 
				omegam_set = position_error*KP_pos/1000;
     d40:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <thPendulum>
     d44:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <thPendulum+0x1>
     d48:	20 ed       	ldi	r18, 0xD0	; 208
     d4a:	32 e0       	ldi	r19, 0x02	; 2
     d4c:	28 1b       	sub	r18, r24
     d4e:	39 0b       	sbc	r19, r25
     d50:	48 e1       	ldi	r20, 0x18	; 24
     d52:	5c ef       	ldi	r21, 0xFC	; 252
     d54:	24 9f       	mul	r18, r20
     d56:	c0 01       	movw	r24, r0
     d58:	25 9f       	mul	r18, r21
     d5a:	90 0d       	add	r25, r0
     d5c:	34 9f       	mul	r19, r20
     d5e:	90 0d       	add	r25, r0
     d60:	11 24       	eor	r1, r1
     d62:	28 ee       	ldi	r18, 0xE8	; 232
     d64:	33 e0       	ldi	r19, 0x03	; 3
     d66:	b9 01       	movw	r22, r18
     d68:	0e 94 d4 21 	call	0x43a8	; 0x43a8 <__divmodhi4>
     d6c:	ed 89       	ldd	r30, Y+21	; 0x15
     d6e:	fe 89       	ldd	r31, Y+22	; 0x16
     d70:	6e 0f       	add	r22, r30
     d72:	7f 1f       	adc	r23, r31
     d74:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     d78:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     d7c:	68 1b       	sub	r22, r24
     d7e:	79 0b       	sbc	r23, r25
     d80:	44 e6       	ldi	r20, 0x64	; 100
     d82:	46 9f       	mul	r20, r22
     d84:	c0 01       	movw	r24, r0
     d86:	47 9f       	mul	r20, r23
     d88:	90 0d       	add	r25, r0
     d8a:	11 24       	eor	r1, r1
     d8c:	b9 01       	movw	r22, r18
     d8e:	0e 94 d4 21 	call	0x43a8	; 0x43a8 <__divmodhi4>
     d92:	d8 01       	movw	r26, r16
     d94:	5a 96       	adiw	r26, 0x1a	; 26
     d96:	6d 93       	st	X+, r22
     d98:	7c 93       	st	X, r23
     d9a:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d9c:	0f b6       	in	r0, 0x3f	; 63
     d9e:	f8 94       	cli
     da0:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     da2:	0f 90       	pop	r0
     da4:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get())
     da6:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     daa:	88 23       	and	r24, r24
     dac:	09 f4       	brne	.+2      	; 0xdb0 <_ZN5Motor3runEv+0x37e>
     dae:	36 c0       	rjmp	.+108    	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				{
					transition_to(0);
     db0:	60 e0       	ldi	r22, 0x00	; 0
     db2:	c8 01       	movw	r24, r16
     db4:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
     db8:	31 c0       	rjmp	.+98     	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				}
					
			break;
			
			case(100) :
			omegam_set = 0;
     dba:	f8 01       	movw	r30, r16
     dbc:	12 8e       	std	Z+26, r1	; 0x1a
     dbe:	13 8e       	std	Z+27, r1	; 0x1b
			
			if (runs%300 == 0)
     dc0:	cb 01       	movw	r24, r22
     dc2:	ba 01       	movw	r22, r20
     dc4:	2c e2       	ldi	r18, 0x2C	; 44
     dc6:	31 e0       	ldi	r19, 0x01	; 1
     dc8:	40 e0       	ldi	r20, 0x00	; 0
     dca:	50 e0       	ldi	r21, 0x00	; 0
     dcc:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__udivmodsi4>
     dd0:	67 2b       	or	r22, r23
     dd2:	68 2b       	or	r22, r24
     dd4:	69 2b       	or	r22, r25
     dd6:	71 f4       	brne	.+28     	; 0xdf4 <_ZN5Motor3runEv+0x3c2>
			{
				*p_serial << "Error State" << endl;
     dd8:	d8 01       	movw	r26, r16
     dda:	16 96       	adiw	r26, 0x06	; 6
     ddc:	ed 90       	ld	r14, X+
     dde:	fc 90       	ld	r15, X
     de0:	17 97       	sbiw	r26, 0x07	; 7
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     de2:	6e e1       	ldi	r22, 0x1E	; 30
     de4:	70 e2       	ldi	r23, 0x20	; 32
     de6:	c7 01       	movw	r24, r14
     de8:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
     dec:	66 e0       	ldi	r22, 0x06	; 6
     dee:	c7 01       	movw	r24, r14
     df0:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     df4:	0f b6       	in	r0, 0x3f	; 63
     df6:	f8 94       	cli
     df8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     dfa:	0f 90       	pop	r0
     dfc:	0f be       	out	0x3f, r0	; 63
			}
			
				if (reset.get())										// if user hits reset
     dfe:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     e02:	88 23       	and	r24, r24
     e04:	59 f0       	breq	.+22     	; 0xe1c <_ZN5Motor3runEv+0x3ea>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     e06:	0f b6       	in	r0, 0x3f	; 63
     e08:	f8 94       	cli
     e0a:	0f 92       	push	r0
			the_data = new_data;
     e0c:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     e10:	0f 90       	pop	r0
     e12:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);
					transition_to(0);
     e14:	60 e0       	ldi	r22, 0x00	; 0
     e16:	c8 01       	movw	r24, r16
     e18:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	f8 94       	cli
     e20:	0f 92       	push	r0
			temporary_copy = the_data;
     e22:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <thdMotor>
     e26:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     e2a:	0f 90       	pop	r0
     e2c:	0f be       	out	0x3f, r0	; 63
		
		};

		
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     e2e:	f8 01       	movw	r30, r16
     e30:	86 8f       	std	Z+30, r24	; 0x1e
     e32:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     e34:	af 85       	ldd	r26, Y+15	; 0x0f
     e36:	b8 89       	ldd	r27, Y+16	; 0x10
     e38:	2d 92       	st	X+, r2
     e3a:	3c 92       	st	X, r3
		_Ki = .7*256;
     e3c:	23 eb       	ldi	r18, 0xB3	; 179
     e3e:	30 e0       	ldi	r19, 0x00	; 0
     e40:	ed 81       	ldd	r30, Y+5	; 0x05
     e42:	fe 81       	ldd	r31, Y+6	; 0x06
     e44:	20 83       	st	Z, r18
     e46:	31 83       	std	Z+1, r19	; 0x01
		_Kd = 0;
     e48:	a9 89       	ldd	r26, Y+17	; 0x11
     e4a:	ba 89       	ldd	r27, Y+18	; 0x12
     e4c:	1d 92       	st	X+, r1
     e4e:	1c 92       	st	X, r1
		antiwind_gain = .75*256;
     e50:	20 ec       	ldi	r18, 0xC0	; 192
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	ef 81       	ldd	r30, Y+7	; 0x07
     e56:	f8 85       	ldd	r31, Y+8	; 0x08
     e58:	20 83       	st	Z, r18
     e5a:	31 83       	std	Z+1, r19	; 0x01
		
		_max = 1600;
     e5c:	20 e4       	ldi	r18, 0x40	; 64
     e5e:	36 e0       	ldi	r19, 0x06	; 6
     e60:	a9 85       	ldd	r26, Y+9	; 0x09
     e62:	ba 85       	ldd	r27, Y+10	; 0x0a
     e64:	2d 93       	st	X+, r18
     e66:	3c 93       	st	X, r19
		_min = -1600;
     e68:	20 ec       	ldi	r18, 0xC0	; 192
     e6a:	39 ef       	ldi	r19, 0xF9	; 249
     e6c:	ed 85       	ldd	r30, Y+13	; 0x0d
     e6e:	fe 85       	ldd	r31, Y+14	; 0x0e
     e70:	20 83       	st	Z, r18
     e72:	31 83       	std	Z+1, r19	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     e74:	d8 01       	movw	r26, r16
     e76:	5a 96       	adiw	r26, 0x1a	; 26
     e78:	ed 90       	ld	r14, X+
     e7a:	fc 90       	ld	r15, X
     e7c:	5b 97       	sbiw	r26, 0x1b	; 27
     e7e:	e8 1a       	sub	r14, r24
     e80:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     e82:	b7 01       	movw	r22, r14
     e84:	c1 01       	movw	r24, r2
     e86:	0e 94 de 08 	call	0x11bc	; 0x11bc <_ZN7satmath20signed_saturated_mulEii>
     e8a:	2b 01       	movw	r4, r22
     e8c:	3c 01       	movw	r6, r24
     e8e:	eb 89       	ldd	r30, Y+19	; 0x13
     e90:	fc 89       	ldd	r31, Y+20	; 0x14
     e92:	60 83       	st	Z, r22
     e94:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     e96:	d4 01       	movw	r26, r8
     e98:	8d 91       	ld	r24, X+
     e9a:	9c 91       	ld	r25, X
     e9c:	f7 01       	movw	r30, r14
     e9e:	e8 1b       	sub	r30, r24
     ea0:	f9 0b       	sbc	r31, r25
     ea2:	cf 01       	movw	r24, r30
     ea4:	f8 01       	movw	r30, r16
     ea6:	e8 59       	subi	r30, 0x98	; 152
     ea8:	ff 4f       	sbci	r31, 0xFF	; 255
     eaa:	80 83       	st	Z, r24
     eac:	91 83       	std	Z+1, r25	; 0x01
		error_int_gain = (_Ki * error_int);
     eae:	ad 81       	ldd	r26, Y+5	; 0x05
     eb0:	be 81       	ldd	r27, Y+6	; 0x06
     eb2:	2d 91       	ld	r18, X+
     eb4:	3c 91       	ld	r19, X
     eb6:	82 9f       	mul	r24, r18
     eb8:	d0 01       	movw	r26, r0
     eba:	83 9f       	mul	r24, r19
     ebc:	b0 0d       	add	r27, r0
     ebe:	92 9f       	mul	r25, r18
     ec0:	b0 0d       	add	r27, r0
     ec2:	11 24       	eor	r1, r1
     ec4:	32 96       	adiw	r30, 0x02	; 2
     ec6:	a0 83       	st	Z, r26
     ec8:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     eca:	eb 85       	ldd	r30, Y+11	; 0x0b
     ecc:	fc 85       	ldd	r31, Y+12	; 0x0c
     ece:	20 81       	ld	r18, Z
     ed0:	31 81       	ldd	r19, Z+1	; 0x01
     ed2:	42 81       	ldd	r20, Z+2	; 0x02
     ed4:	53 81       	ldd	r21, Z+3	; 0x03
     ed6:	0e 94 5b 22 	call	0x44b6	; 0x44b6 <__mulshisi3>
     eda:	9b 01       	movw	r18, r22
     edc:	ac 01       	movw	r20, r24
     ede:	99 23       	and	r25, r25
     ee0:	24 f4       	brge	.+8      	; 0xeea <_ZN5Motor3runEv+0x4b8>
     ee2:	21 50       	subi	r18, 0x01	; 1
     ee4:	3f 4f       	sbci	r19, 0xFF	; 255
     ee6:	4f 4f       	sbci	r20, 0xFF	; 255
     ee8:	5f 4f       	sbci	r21, 0xFF	; 255
     eea:	bb 27       	eor	r27, r27
     eec:	57 fd       	sbrc	r21, 7
     eee:	ba 95       	dec	r27
     ef0:	a5 2f       	mov	r26, r21
     ef2:	94 2f       	mov	r25, r20
     ef4:	83 2f       	mov	r24, r19
     ef6:	f5 01       	movw	r30, r10
     ef8:	40 81       	ld	r20, Z
     efa:	51 81       	ldd	r21, Z+1	; 0x01
     efc:	62 81       	ldd	r22, Z+2	; 0x02
     efe:	73 81       	ldd	r23, Z+3	; 0x03
     f00:	84 0f       	add	r24, r20
     f02:	95 1f       	adc	r25, r21
     f04:	a6 1f       	adc	r26, r22
     f06:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     f08:	81 30       	cpi	r24, 0x01	; 1
     f0a:	fa ec       	ldi	r31, 0xCA	; 202
     f0c:	9f 07       	cpc	r25, r31
     f0e:	fa e9       	ldi	r31, 0x9A	; 154
     f10:	af 07       	cpc	r26, r31
     f12:	fb e3       	ldi	r31, 0x3B	; 59
     f14:	bf 07       	cpc	r27, r31
     f16:	54 f0       	brlt	.+20     	; 0xf2c <_ZN5Motor3runEv+0x4fa>
		{
			_integral = 1000000000;
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	9a ec       	ldi	r25, 0xCA	; 202
     f1c:	aa e9       	ldi	r26, 0x9A	; 154
     f1e:	bb e3       	ldi	r27, 0x3B	; 59
     f20:	f5 01       	movw	r30, r10
     f22:	80 83       	st	Z, r24
     f24:	91 83       	std	Z+1, r25	; 0x01
     f26:	a2 83       	std	Z+2, r26	; 0x02
     f28:	b3 83       	std	Z+3, r27	; 0x03
     f2a:	17 c0       	rjmp	.+46     	; 0xf5a <_ZN5Motor3runEv+0x528>
		}
		else if(_integral < -1000000000)
     f2c:	81 15       	cp	r24, r1
     f2e:	f6 e3       	ldi	r31, 0x36	; 54
     f30:	9f 07       	cpc	r25, r31
     f32:	f5 e6       	ldi	r31, 0x65	; 101
     f34:	af 07       	cpc	r26, r31
     f36:	f4 ec       	ldi	r31, 0xC4	; 196
     f38:	bf 07       	cpc	r27, r31
     f3a:	34 f0       	brlt	.+12     	; 0xf48 <_ZN5Motor3runEv+0x516>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     f3c:	f5 01       	movw	r30, r10
     f3e:	80 83       	st	Z, r24
     f40:	91 83       	std	Z+1, r25	; 0x01
     f42:	a2 83       	std	Z+2, r26	; 0x02
     f44:	b3 83       	std	Z+3, r27	; 0x03
     f46:	09 c0       	rjmp	.+18     	; 0xf5a <_ZN5Motor3runEv+0x528>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	96 e3       	ldi	r25, 0x36	; 54
     f4c:	a5 e6       	ldi	r26, 0x65	; 101
     f4e:	b4 ec       	ldi	r27, 0xC4	; 196
     f50:	f5 01       	movw	r30, r10
     f52:	80 83       	st	Z, r24
     f54:	91 83       	std	Z+1, r25	; 0x01
     f56:	a2 83       	std	Z+2, r26	; 0x02
     f58:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     f5a:	d5 01       	movw	r26, r10
     f5c:	6d 91       	ld	r22, X+
     f5e:	7c 91       	ld	r23, X
     f60:	c2 01       	movw	r24, r4
     f62:	0e 94 c2 08 	call	0x1184	; 0x1184 <_ZN7satmath20signed_saturated_addEii>
     f66:	f8 01       	movw	r30, r16
     f68:	e0 5a       	subi	r30, 0xA0	; 160
     f6a:	ff 4f       	sbci	r31, 0xFF	; 255
     f6c:	80 83       	st	Z, r24
     f6e:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     f70:	f6 01       	movw	r30, r12
     f72:	80 83       	st	Z, r24
     f74:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     f76:	a9 85       	ldd	r26, Y+9	; 0x09
     f78:	ba 85       	ldd	r27, Y+10	; 0x0a
     f7a:	2d 91       	ld	r18, X+
     f7c:	3c 91       	ld	r19, X
     f7e:	28 17       	cp	r18, r24
     f80:	39 07       	cpc	r19, r25
     f82:	1c f4       	brge	.+6      	; 0xf8a <_ZN5Motor3runEv+0x558>
		output_correct = _max;
     f84:	20 83       	st	Z, r18
     f86:	31 83       	std	Z+1, r19	; 0x01
     f88:	0a c0       	rjmp	.+20     	; 0xf9e <_ZN5Motor3runEv+0x56c>
		else if( output_correct < _min )
     f8a:	ed 85       	ldd	r30, Y+13	; 0x0d
     f8c:	fe 85       	ldd	r31, Y+14	; 0x0e
     f8e:	20 81       	ld	r18, Z
     f90:	31 81       	ldd	r19, Z+1	; 0x01
     f92:	82 17       	cp	r24, r18
     f94:	93 07       	cpc	r25, r19
     f96:	1c f4       	brge	.+6      	; 0xf9e <_ZN5Motor3runEv+0x56c>
		output_correct = _min;
     f98:	d6 01       	movw	r26, r12
     f9a:	2d 93       	st	X+, r18
     f9c:	3c 93       	st	X, r19

		// Save error to previous error
		_pre_error = error;
     f9e:	f8 01       	movw	r30, r16
     fa0:	e2 5b       	subi	r30, 0xB2	; 178
     fa2:	ff 4f       	sbci	r31, 0xFF	; 255
     fa4:	e0 82       	st	Z, r14
     fa6:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     fa8:	f6 01       	movw	r30, r12
     faa:	20 81       	ld	r18, Z
     fac:	31 81       	ldd	r19, Z+1	; 0x01
     fae:	82 1b       	sub	r24, r18
     fb0:	93 0b       	sbc	r25, r19
     fb2:	f8 01       	movw	r30, r16
     fb4:	ee 59       	subi	r30, 0x9E	; 158
     fb6:	ff 4f       	sbci	r31, 0xFF	; 255
     fb8:	80 83       	st	Z, r24
     fba:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     fbc:	af 81       	ldd	r26, Y+7	; 0x07
     fbe:	b8 85       	ldd	r27, Y+8	; 0x08
     fc0:	4d 91       	ld	r20, X+
     fc2:	5c 91       	ld	r21, X
     fc4:	84 9f       	mul	r24, r20
     fc6:	90 01       	movw	r18, r0
     fc8:	85 9f       	mul	r24, r21
     fca:	30 0d       	add	r19, r0
     fcc:	94 9f       	mul	r25, r20
     fce:	30 0d       	add	r19, r0
     fd0:	11 24       	eor	r1, r1
     fd2:	33 23       	and	r19, r19
     fd4:	14 f4       	brge	.+4      	; 0xfda <_ZN5Motor3runEv+0x5a8>
     fd6:	21 50       	subi	r18, 0x01	; 1
     fd8:	3f 4f       	sbci	r19, 0xFF	; 255
     fda:	83 2f       	mov	r24, r19
     fdc:	88 0f       	add	r24, r24
     fde:	88 0b       	sbc	r24, r24
     fe0:	f4 01       	movw	r30, r8
     fe2:	30 83       	st	Z, r19
     fe4:	81 83       	std	Z+1, r24	; 0x01
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     fe6:	0f b6       	in	r0, 0x3f	; 63
     fe8:	f8 94       	cli
     fea:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     fec:	0f 90       	pop	r0
     fee:	0f be       	out	0x3f, r0	; 63
				//*p_serial << "go flag " << go.get() << endl;
				//*p_serial << "stop flag" << stop.get() << endl;
				//*p_serial << "reset flag " << reset.get() << endl;
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get() || stop.get())		// If limit switch or If emergency stop button was hit
     ff0:	80 91 4d 31 	lds	r24, 0x314D	; 0x80314d <leftLimitSwitch>
     ff4:	81 11       	cpse	r24, r1
     ff6:	12 c0       	rjmp	.+36     	; 0x101c <_ZN5Motor3runEv+0x5ea>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ff8:	0f b6       	in	r0, 0x3f	; 63
     ffa:	f8 94       	cli
     ffc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     ffe:	0f 90       	pop	r0
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rightLimitSwitch>
    1006:	81 11       	cpse	r24, r1
    1008:	09 c0       	rjmp	.+18     	; 0x101c <_ZN5Motor3runEv+0x5ea>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    100a:	0f b6       	in	r0, 0x3f	; 63
    100c:	f8 94       	cli
    100e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    1010:	0f 90       	pop	r0
    1012:	0f be       	out	0x3f, r0	; 63
    1014:	80 91 47 31 	lds	r24, 0x3147	; 0x803147 <stop>
    1018:	88 23       	and	r24, r24
    101a:	99 f0       	breq	.+38     	; 0x1042 <_ZN5Motor3runEv+0x610>
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
    101c:	d5 01       	movw	r26, r10
    101e:	1d 92       	st	X+, r1
    1020:	1d 92       	st	X+, r1
    1022:	1d 92       	st	X+, r1
    1024:	1c 92       	st	X, r1
    1026:	13 97       	sbiw	r26, 0x03	; 3
			output_correct = 0;
    1028:	f6 01       	movw	r30, r12
    102a:	10 82       	st	Z, r1
    102c:	11 82       	std	Z+1, r1	; 0x01
			
			if (state == 4 || state == 3)
    102e:	d8 01       	movw	r26, r16
    1030:	1c 96       	adiw	r26, 0x0c	; 12
    1032:	8c 91       	ld	r24, X
    1034:	83 50       	subi	r24, 0x03	; 3
    1036:	82 30       	cpi	r24, 0x02	; 2
    1038:	20 f4       	brcc	.+8      	; 0x1042 <_ZN5Motor3runEv+0x610>
			{
				transition_to(100);
    103a:	64 e6       	ldi	r22, 0x64	; 100
    103c:	c8 01       	movw	r24, r16
    103e:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
    1042:	f8 01       	movw	r30, r16
    1044:	10 a6       	std	Z+40, r1	; 0x28
    1046:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
    1048:	82 a1       	ldd	r24, Z+34	; 0x22
    104a:	93 a1       	ldd	r25, Z+35	; 0x23
    104c:	60 e0       	ldi	r22, 0x00	; 0
    104e:	70 e0       	ldi	r23, 0x00	; 0
    1050:	0e 94 d4 21 	call	0x43a8	; 0x43a8 <__divmodhi4>
    1054:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
    1056:	07 2e       	mov	r0, r23
    1058:	00 0c       	add	r0, r0
    105a:	88 0b       	sbc	r24, r24
    105c:	99 0b       	sbc	r25, r25
    105e:	0e 94 60 21 	call	0x42c0	; 0x42c0 <__floatsisf>
    1062:	2b 01       	movw	r4, r22
    1064:	3c 01       	movw	r6, r24
    1066:	23 e3       	ldi	r18, 0x33	; 51
    1068:	33 e3       	ldi	r19, 0x33	; 51
    106a:	4b e8       	ldi	r20, 0x8B	; 139
    106c:	51 e4       	ldi	r21, 0x41	; 65
    106e:	0e 94 bf 21 	call	0x437e	; 0x437e <__gesf2>
    1072:	18 16       	cp	r1, r24
    1074:	44 f4       	brge	.+16     	; 0x1086 <_ZN5Motor3runEv+0x654>
			Im_set = 17.4;
    1076:	81 e1       	ldi	r24, 0x11	; 17
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	d8 01       	movw	r26, r16
    107c:	94 96       	adiw	r26, 0x24	; 36
    107e:	8d 93       	st	X+, r24
    1080:	9c 93       	st	X, r25
    1082:	95 97       	sbiw	r26, 0x25	; 37
    1084:	15 c0       	rjmp	.+42     	; 0x10b0 <_ZN5Motor3runEv+0x67e>
		} else if(Im_set < -17.4) {
    1086:	23 e3       	ldi	r18, 0x33	; 51
    1088:	33 e3       	ldi	r19, 0x33	; 51
    108a:	4b e8       	ldi	r20, 0x8B	; 139
    108c:	51 ec       	ldi	r21, 0xC1	; 193
    108e:	c3 01       	movw	r24, r6
    1090:	b2 01       	movw	r22, r4
    1092:	0e 94 59 21 	call	0x42b2	; 0x42b2 <__cmpsf2>
    1096:	88 23       	and	r24, r24
    1098:	24 f0       	brlt	.+8      	; 0x10a2 <_ZN5Motor3runEv+0x670>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
    109a:	f8 01       	movw	r30, r16
    109c:	e4 a2       	std	Z+36, r14	; 0x24
    109e:	f5 a2       	std	Z+37, r15	; 0x25
    10a0:	07 c0       	rjmp	.+14     	; 0x10b0 <_ZN5Motor3runEv+0x67e>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
    10a2:	8f ee       	ldi	r24, 0xEF	; 239
    10a4:	9f ef       	ldi	r25, 0xFF	; 255
    10a6:	d8 01       	movw	r26, r16
    10a8:	94 96       	adiw	r26, 0x24	; 36
    10aa:	8d 93       	st	X+, r24
    10ac:	9c 93       	st	X, r25
    10ae:	95 97       	sbiw	r26, 0x25	; 37
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
    10b0:	f8 01       	movw	r30, r16
    10b2:	16 aa       	std	Z+54, r1	; 0x36
    10b4:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
    10b6:	12 aa       	std	Z+50, r1	; 0x32
    10b8:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
    10ba:	14 aa       	std	Z+52, r1	; 0x34
    10bc:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
    10be:	80 a9       	ldd	r24, Z+48	; 0x30
    10c0:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
    10c2:	89 31       	cpi	r24, 0x19	; 25
    10c4:	91 05       	cpc	r25, r1
    10c6:	2c f0       	brlt	.+10     	; 0x10d2 <_ZN5Motor3runEv+0x6a0>
			V_m = 24;
    10c8:	88 e1       	ldi	r24, 0x18	; 24
    10ca:	90 e0       	ldi	r25, 0x00	; 0
    10cc:	80 af       	std	Z+56, r24	; 0x38
    10ce:	91 af       	std	Z+57, r25	; 0x39
    10d0:	0f c0       	rjmp	.+30     	; 0x10f0 <_ZN5Motor3runEv+0x6be>
		} else if(V_m < -24) {
    10d2:	88 3e       	cpi	r24, 0xE8	; 232
    10d4:	ff ef       	ldi	r31, 0xFF	; 255
    10d6:	9f 07       	cpc	r25, r31
    10d8:	34 f0       	brlt	.+12     	; 0x10e6 <_ZN5Motor3runEv+0x6b4>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
    10da:	d8 01       	movw	r26, r16
    10dc:	d8 96       	adiw	r26, 0x38	; 56
    10de:	8d 93       	st	X+, r24
    10e0:	9c 93       	st	X, r25
    10e2:	d9 97       	sbiw	r26, 0x39	; 57
    10e4:	05 c0       	rjmp	.+10     	; 0x10f0 <_ZN5Motor3runEv+0x6be>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
    10e6:	88 ee       	ldi	r24, 0xE8	; 232
    10e8:	9f ef       	ldi	r25, 0xFF	; 255
    10ea:	f8 01       	movw	r30, r16
    10ec:	80 af       	std	Z+56, r24	; 0x38
    10ee:	91 af       	std	Z+57, r25	; 0x39
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
    10f0:	d6 01       	movw	r26, r12
    10f2:	8d 91       	ld	r24, X+
    10f4:	9c 91       	ld	r25, X
    10f6:	99 23       	and	r25, r25
    10f8:	3c f0       	brlt	.+14     	; 0x1108 <_ZN5Motor3runEv+0x6d6>
		{
			TCC0.CCA = output_correct;
    10fa:	e0 e0       	ldi	r30, 0x00	; 0
    10fc:	f8 e0       	ldi	r31, 0x08	; 8
    10fe:	80 a7       	std	Z+40, r24	; 0x28
    1100:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
    1102:	12 a6       	std	Z+42, r1	; 0x2a
    1104:	13 a6       	std	Z+43, r1	; 0x2b
    1106:	0c c0       	rjmp	.+24     	; 0x1120 <_ZN5Motor3runEv+0x6ee>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
    1108:	e0 e0       	ldi	r30, 0x00	; 0
    110a:	f8 e0       	ldi	r31, 0x08	; 8
    110c:	10 a6       	std	Z+40, r1	; 0x28
    110e:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
    1110:	d6 01       	movw	r26, r12
    1112:	8d 91       	ld	r24, X+
    1114:	9c 91       	ld	r25, X
    1116:	91 95       	neg	r25
    1118:	81 95       	neg	r24
    111a:	91 09       	sbc	r25, r1
    111c:	82 a7       	std	Z+42, r24	; 0x2a
    111e:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
    1120:	eb 85       	ldd	r30, Y+11	; 0x0b
    1122:	fc 85       	ldd	r31, Y+12	; 0x0c
    1124:	20 81       	ld	r18, Z
    1126:	31 81       	ldd	r19, Z+1	; 0x01
    1128:	42 81       	ldd	r20, Z+2	; 0x02
    112a:	53 81       	ldd	r21, Z+3	; 0x03
    112c:	a8 ee       	ldi	r26, 0xE8	; 232
    112e:	b3 e0       	ldi	r27, 0x03	; 3
    1130:	0e 94 50 22 	call	0x44a0	; 0x44a0 <__muluhisi3>
    1134:	68 3e       	cpi	r22, 0xE8	; 232
    1136:	f3 e0       	ldi	r31, 0x03	; 3
    1138:	7f 07       	cpc	r23, r31
    113a:	81 05       	cpc	r24, r1
    113c:	91 05       	cpc	r25, r1
    113e:	48 f0       	brcs	.+18     	; 0x1152 <_ZN5Motor3runEv+0x720>
    1140:	28 ee       	ldi	r18, 0xE8	; 232
    1142:	33 e0       	ldi	r19, 0x03	; 3
    1144:	40 e0       	ldi	r20, 0x00	; 0
    1146:	50 e0       	ldi	r21, 0x00	; 0
    1148:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__udivmodsi4>
    114c:	ba 01       	movw	r22, r20
    114e:	a9 01       	movw	r20, r18
    1150:	04 c0       	rjmp	.+8      	; 0x115a <_ZN5Motor3runEv+0x728>
    1152:	41 e0       	ldi	r20, 0x01	; 1
    1154:	50 e0       	ldi	r21, 0x00	; 0
    1156:	60 e0       	ldi	r22, 0x00	; 0
    1158:	70 e0       	ldi	r23, 0x00	; 0
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
    115a:	ce 01       	movw	r24, r28
    115c:	01 96       	adiw	r24, 0x01	; 1
    115e:	0e 94 a9 14 	call	0x2952	; 0x2952 <vTaskDelayUntil>
    1162:	da cc       	rjmp	.-1612   	; 0xb18 <_ZN5Motor3runEv+0xe6>

00001164 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
    1164:	0f 93       	push	r16
    1166:	1f 93       	push	r17
    1168:	cf 93       	push	r28
    116a:	df 93       	push	r29
    116c:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    116e:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <_ZN8frt_taskC1EPKchjP8emstream>
    1172:	8e e2       	ldi	r24, 0x2E	; 46
    1174:	90 e2       	ldi	r25, 0x20	; 32
    1176:	88 83       	st	Y, r24
    1178:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	1f 91       	pop	r17
    1180:	0f 91       	pop	r16
    1182:	08 95       	ret

00001184 <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
    1184:	9c 01       	movw	r18, r24
    1186:	93 2f       	mov	r25, r19
    1188:	99 1f       	adc	r25, r25
    118a:	99 27       	eor	r25, r25
    118c:	99 1f       	adc	r25, r25
    118e:	89 2f       	mov	r24, r25
    1190:	90 e0       	ldi	r25, 0x00	; 0
    1192:	81 50       	subi	r24, 0x01	; 1
    1194:	90 48       	sbci	r25, 0x80	; 128
    1196:	43 2f       	mov	r20, r19
    1198:	40 95       	com	r20
    119a:	44 1f       	adc	r20, r20
    119c:	44 27       	eor	r20, r20
    119e:	44 1f       	adc	r20, r20
    11a0:	fc 01       	movw	r30, r24
    11a2:	e2 1b       	sub	r30, r18
    11a4:	f3 0b       	sbc	r31, r19
    11a6:	51 e0       	ldi	r21, 0x01	; 1
    11a8:	e6 17       	cp	r30, r22
    11aa:	f7 07       	cpc	r31, r23
    11ac:	0c f0       	brlt	.+2      	; 0x11b0 <_ZN7satmath20signed_saturated_addEii+0x2c>
    11ae:	50 e0       	ldi	r21, 0x00	; 0
    11b0:	45 17       	cp	r20, r21
    11b2:	19 f0       	breq	.+6      	; 0x11ba <_ZN7satmath20signed_saturated_addEii+0x36>
    11b4:	c9 01       	movw	r24, r18
    11b6:	86 0f       	add	r24, r22
    11b8:	97 1f       	adc	r25, r23
    11ba:	08 95       	ret

000011bc <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    11bc:	81 15       	cp	r24, r1
    11be:	20 e8       	ldi	r18, 0x80	; 128
    11c0:	92 07       	cpc	r25, r18
    11c2:	21 f4       	brne	.+8      	; 0x11cc <_ZN7satmath20signed_saturated_mulEii+0x10>
    11c4:	61 15       	cp	r22, r1
    11c6:	20 e8       	ldi	r18, 0x80	; 128
    11c8:	72 07       	cpc	r23, r18
    11ca:	29 f0       	breq	.+10     	; 0x11d6 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
    11cc:	9c 01       	movw	r18, r24
    11ce:	db 01       	movw	r26, r22
    11d0:	0e 94 32 22 	call	0x4464	; 0x4464 <__mulhisi3>
    11d4:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    11d6:	6f ef       	ldi	r22, 0xFF	; 255
    11d8:	7f ef       	ldi	r23, 0xFF	; 255
    11da:	8f ef       	ldi	r24, 0xFF	; 255
    11dc:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
    11de:	08 95       	ret

000011e0 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    11ea:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <_ZN8frt_taskC1EPKchjP8emstream>
    11ee:	86 e3       	ldi	r24, 0x36	; 54
    11f0:	90 e2       	ldi	r25, 0x20	; 32
    11f2:	88 83       	st	Y, r24
    11f4:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    11f6:	df 91       	pop	r29
    11f8:	cf 91       	pop	r28
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	08 95       	ret

00001200 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    1200:	0f 93       	push	r16
    1202:	1f 93       	push	r17
    1204:	cf 93       	push	r28
    1206:	df 93       	push	r29
    1208:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    120a:	6a e0       	ldi	r22, 0x0A	; 10
    120c:	8e 81       	ldd	r24, Y+6	; 0x06
    120e:	9f 81       	ldd	r25, Y+7	; 0x07
    1210:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1214:	8c 01       	movw	r16, r24
    1216:	63 e5       	ldi	r22, 0x53	; 83
    1218:	75 e0       	ldi	r23, 0x05	; 5
    121a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    121e:	6a e0       	ldi	r22, 0x0A	; 10
    1220:	c8 01       	movw	r24, r16
    1222:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1226:	8c 01       	movw	r16, r24
    1228:	6d e4       	ldi	r22, 0x4D	; 77
    122a:	75 e0       	ldi	r23, 0x05	; 5
    122c:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1230:	67 e0       	ldi	r22, 0x07	; 7
    1232:	c8 01       	movw	r24, r16
    1234:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    1238:	6a e0       	ldi	r22, 0x0A	; 10
    123a:	8e 81       	ldd	r24, Y+6	; 0x06
    123c:	9f 81       	ldd	r25, Y+7	; 0x07
    123e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1242:	8c 01       	movw	r16, r24
    1244:	6e e2       	ldi	r22, 0x2E	; 46
    1246:	75 e0       	ldi	r23, 0x05	; 5
    1248:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    124c:	6a e0       	ldi	r22, 0x0A	; 10
    124e:	c8 01       	movw	r24, r16
    1250:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1254:	8c 01       	movw	r16, r24
    1256:	68 e2       	ldi	r22, 0x28	; 40
    1258:	75 e0       	ldi	r23, 0x05	; 5
    125a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    125e:	66 e0       	ldi	r22, 0x06	; 6
    1260:	c8 01       	movw	r24, r16
    1262:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1266:	6a e0       	ldi	r22, 0x0A	; 10
    1268:	8e 81       	ldd	r24, Y+6	; 0x06
    126a:	9f 81       	ldd	r25, Y+7	; 0x07
    126c:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1270:	8c 01       	movw	r16, r24
    1272:	61 e1       	ldi	r22, 0x11	; 17
    1274:	75 e0       	ldi	r23, 0x05	; 5
    1276:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    127a:	66 e0       	ldi	r22, 0x06	; 6
    127c:	c8 01       	movw	r24, r16
    127e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1282:	6a e0       	ldi	r22, 0x0A	; 10
    1284:	8e 81       	ldd	r24, Y+6	; 0x06
    1286:	9f 81       	ldd	r25, Y+7	; 0x07
    1288:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    128c:	8c 01       	movw	r16, r24
    128e:	65 ef       	ldi	r22, 0xF5	; 245
    1290:	74 e0       	ldi	r23, 0x04	; 4
    1292:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1296:	66 e0       	ldi	r22, 0x06	; 6
    1298:	c8 01       	movw	r24, r16
    129a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    129e:	6a e0       	ldi	r22, 0x0A	; 10
    12a0:	8e 81       	ldd	r24, Y+6	; 0x06
    12a2:	9f 81       	ldd	r25, Y+7	; 0x07
    12a4:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    12a8:	8c 01       	movw	r16, r24
    12aa:	6d ed       	ldi	r22, 0xDD	; 221
    12ac:	74 e0       	ldi	r23, 0x04	; 4
    12ae:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    12b2:	66 e0       	ldi	r22, 0x06	; 6
    12b4:	c8 01       	movw	r24, r16
    12b6:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    12ba:	6a e0       	ldi	r22, 0x0A	; 10
    12bc:	8e 81       	ldd	r24, Y+6	; 0x06
    12be:	9f 81       	ldd	r25, Y+7	; 0x07
    12c0:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    12c4:	8c 01       	movw	r16, r24
    12c6:	6c eb       	ldi	r22, 0xBC	; 188
    12c8:	74 e0       	ldi	r23, 0x04	; 4
    12ca:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    12ce:	66 e0       	ldi	r22, 0x06	; 6
    12d0:	c8 01       	movw	r24, r16
    12d2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    12d6:	6a e0       	ldi	r22, 0x0A	; 10
    12d8:	8e 81       	ldd	r24, Y+6	; 0x06
    12da:	9f 81       	ldd	r25, Y+7	; 0x07
    12dc:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    12e0:	8c 01       	movw	r16, r24
    12e2:	65 e9       	ldi	r22, 0x95	; 149
    12e4:	74 e0       	ldi	r23, 0x04	; 4
    12e6:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    12ea:	66 e0       	ldi	r22, 0x06	; 6
    12ec:	c8 01       	movw	r24, r16
    12ee:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    12f2:	6a e0       	ldi	r22, 0x0A	; 10
    12f4:	8e 81       	ldd	r24, Y+6	; 0x06
    12f6:	9f 81       	ldd	r25, Y+7	; 0x07
    12f8:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    12fc:	8c 01       	movw	r16, r24
    12fe:	67 e7       	ldi	r22, 0x77	; 119
    1300:	74 e0       	ldi	r23, 0x04	; 4
    1302:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1306:	66 e0       	ldi	r22, 0x06	; 6
    1308:	c8 01       	movw	r24, r16
    130a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    130e:	6a e0       	ldi	r22, 0x0A	; 10
    1310:	8e 81       	ldd	r24, Y+6	; 0x06
    1312:	9f 81       	ldd	r25, Y+7	; 0x07
    1314:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1318:	8c 01       	movw	r16, r24
    131a:	6c e5       	ldi	r22, 0x5C	; 92
    131c:	74 e0       	ldi	r23, 0x04	; 4
    131e:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1322:	66 e0       	ldi	r22, 0x06	; 6
    1324:	c8 01       	movw	r24, r16
    1326:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    132a:	6a e0       	ldi	r22, 0x0A	; 10
    132c:	8e 81       	ldd	r24, Y+6	; 0x06
    132e:	9f 81       	ldd	r25, Y+7	; 0x07
    1330:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1334:	8c 01       	movw	r16, r24
    1336:	6d e4       	ldi	r22, 0x4D	; 77
    1338:	74 e0       	ldi	r23, 0x04	; 4
    133a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    133e:	66 e0       	ldi	r22, 0x06	; 6
    1340:	c8 01       	movw	r24, r16
    1342:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    b:   Begin Calibration of Inverted Pendulum?") << endl;
    1346:	6a e0       	ldi	r22, 0x0A	; 10
    1348:	8e 81       	ldd	r24, Y+6	; 0x06
    134a:	9f 81       	ldd	r25, Y+7	; 0x07
    134c:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1350:	8c 01       	movw	r16, r24
    1352:	6c e1       	ldi	r22, 0x1C	; 28
    1354:	74 e0       	ldi	r23, 0x04	; 4
    1356:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    135a:	66 e0       	ldi	r22, 0x06	; 6
    135c:	c8 01       	movw	r24, r16
    135e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    g:   Swing Pendulum Upright, then Go.") << endl;
    1362:	6a e0       	ldi	r22, 0x0A	; 10
    1364:	8e 81       	ldd	r24, Y+6	; 0x06
    1366:	9f 81       	ldd	r25, Y+7	; 0x07
    1368:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    136c:	8c 01       	movw	r16, r24
    136e:	62 ef       	ldi	r22, 0xF2	; 242
    1370:	73 e0       	ldi	r23, 0x03	; 3
    1372:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1376:	66 e0       	ldi	r22, 0x06	; 6
    1378:	c8 01       	movw	r24, r16
    137a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    d:   Emergency Stop") << endl;
    137e:	6a e0       	ldi	r22, 0x0A	; 10
    1380:	8e 81       	ldd	r24, Y+6	; 0x06
    1382:	9f 81       	ldd	r25, Y+7	; 0x07
    1384:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1388:	8c 01       	movw	r16, r24
    138a:	6a ed       	ldi	r22, 0xDA	; 218
    138c:	73 e0       	ldi	r23, 0x03	; 3
    138e:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1392:	66 e0       	ldi	r22, 0x06	; 6
    1394:	c8 01       	movw	r24, r16
    1396:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    r:   Reset to Idle") << endl;
    139a:	6a e0       	ldi	r22, 0x0A	; 10
    139c:	8e 81       	ldd	r24, Y+6	; 0x06
    139e:	9f 81       	ldd	r25, Y+7	; 0x07
    13a0:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    13a4:	ec 01       	movw	r28, r24
    13a6:	63 ec       	ldi	r22, 0xC3	; 195
    13a8:	73 e0       	ldi	r23, 0x03	; 3
    13aa:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    13ae:	66 e0       	ldi	r22, 0x06	; 6
    13b0:	ce 01       	movw	r24, r28
    13b2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
}
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	0f 91       	pop	r16
    13be:	08 95       	ret

000013c0 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    13c0:	af 92       	push	r10
    13c2:	bf 92       	push	r11
    13c4:	cf 92       	push	r12
    13c6:	df 92       	push	r13
    13c8:	ef 92       	push	r14
    13ca:	ff 92       	push	r15
    13cc:	0f 93       	push	r16
    13ce:	1f 93       	push	r17
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	00 d0       	rcall	.+0      	; 0x13d6 <_ZN9task_user11show_statusEv+0x16>
    13d6:	00 d0       	rcall	.+0      	; 0x13d8 <_ZN9task_user11show_statusEv+0x18>
    13d8:	cd b7       	in	r28, 0x3d	; 61
    13da:	de b7       	in	r29, 0x3e	; 62
    13dc:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    13de:	19 82       	std	Y+1, r1	; 0x01
    13e0:	1a 82       	std	Y+2, r1	; 0x02
    13e2:	1b 82       	std	Y+3, r1	; 0x03
    13e4:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    13e6:	1d 82       	std	Y+5, r1	; 0x05
    13e8:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    13ea:	0e 94 be 0c 	call	0x197c	; 0x197c <xPortGetFreeHeapSize>
    13ee:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    13f0:	ce 01       	movw	r24, r28
    13f2:	01 96       	adiw	r24, 0x01	; 1
    13f4:	0e 94 f7 1a 	call	0x35ee	; 0x35ee <_ZN10time_stamp10set_to_nowEv>
    13f8:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    13fa:	66 e0       	ldi	r22, 0x06	; 6
    13fc:	f8 01       	movw	r30, r16
    13fe:	86 81       	ldd	r24, Z+6	; 0x06
    1400:	97 81       	ldd	r25, Z+7	; 0x07
    1402:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1406:	6a e0       	ldi	r22, 0x0A	; 10
    1408:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    140c:	7c 01       	movw	r14, r24
    140e:	64 ea       	ldi	r22, 0xA4	; 164
    1410:	73 e0       	ldi	r23, 0x03	; 3
    1412:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1416:	6a e0       	ldi	r22, 0x0A	; 10
    1418:	c7 01       	movw	r24, r14
    141a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    141e:	7c 01       	movw	r14, r24
    1420:	68 e9       	ldi	r22, 0x98	; 152
    1422:	73 e0       	ldi	r23, 0x03	; 3
    1424:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1428:	66 e0       	ldi	r22, 0x06	; 6
    142a:	c7 01       	movw	r24, r14
    142c:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1430:	6a e0       	ldi	r22, 0x0A	; 10
    1432:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1436:	7c 01       	movw	r14, r24
    1438:	61 e9       	ldi	r22, 0x91	; 145
    143a:	73 e0       	ldi	r23, 0x03	; 3
    143c:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1440:	b5 01       	movw	r22, r10
    1442:	c7 01       	movw	r24, r14
    1444:	0e 94 9b 1a 	call	0x3536	; 0x3536 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1448:	6a e0       	ldi	r22, 0x0A	; 10
    144a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    144e:	7c 01       	movw	r14, r24
    1450:	63 e8       	ldi	r22, 0x83	; 131
    1452:	73 e0       	ldi	r23, 0x03	; 3
    1454:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1458:	b6 01       	movw	r22, r12
    145a:	c7 01       	movw	r24, r14
    145c:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <_ZN8emstreamlsEj>
    1460:	6a e0       	ldi	r22, 0x0A	; 10
    1462:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1466:	7c 01       	movw	r14, r24
    1468:	61 e8       	ldi	r22, 0x81	; 129
    146a:	73 e0       	ldi	r23, 0x03	; 3
    146c:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1470:	4f ef       	ldi	r20, 0xFF	; 255
    1472:	5f e0       	ldi	r21, 0x0F	; 15
    1474:	60 e0       	ldi	r22, 0x00	; 0
    1476:	70 e0       	ldi	r23, 0x00	; 0
    1478:	c7 01       	movw	r24, r14
    147a:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    147e:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1482:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1486:	6a e0       	ldi	r22, 0x0A	; 10
    1488:	f8 01       	movw	r30, r16
    148a:	86 81       	ldd	r24, Z+6	; 0x06
    148c:	97 81       	ldd	r25, Z+7	; 0x07
    148e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1492:	7c 01       	movw	r14, r24
    1494:	66 e7       	ldi	r22, 0x76	; 118
    1496:	73 e0       	ldi	r23, 0x03	; 3
    1498:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    149c:	b6 01       	movw	r22, r12
    149e:	c7 01       	movw	r24, r14
    14a0:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <_ZN8emstreamlsEj>
    14a4:	66 e0       	ldi	r22, 0x06	; 6
    14a6:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    14aa:	66 e0       	ldi	r22, 0x06	; 6
    14ac:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    14b0:	f8 01       	movw	r30, r16
    14b2:	86 81       	ldd	r24, Z+6	; 0x06
    14b4:	97 81       	ldd	r25, Z+7	; 0x07
    14b6:	0e 94 54 19 	call	0x32a8	; 0x32a8 <_Z15print_task_listP8emstream>
}
    14ba:	26 96       	adiw	r28, 0x06	; 6
    14bc:	cd bf       	out	0x3d, r28	; 61
    14be:	de bf       	out	0x3e, r29	; 62
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	1f 91       	pop	r17
    14c6:	0f 91       	pop	r16
    14c8:	ff 90       	pop	r15
    14ca:	ef 90       	pop	r14
    14cc:	df 90       	pop	r13
    14ce:	cf 90       	pop	r12
    14d0:	bf 90       	pop	r11
    14d2:	af 90       	pop	r10
    14d4:	08 95       	ret

000014d6 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    14d6:	cf 93       	push	r28
    14d8:	df 93       	push	r29
    14da:	00 d0       	rcall	.+0      	; 0x14dc <_ZN9task_user3runEv+0x6>
    14dc:	00 d0       	rcall	.+0      	; 0x14de <_ZN9task_user3runEv+0x8>
    14de:	cd b7       	in	r28, 0x3d	; 61
    14e0:	de b7       	in	r29, 0x3e	; 62
    14e2:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    14e4:	19 82       	std	Y+1, r1	; 0x01
    14e6:	1a 82       	std	Y+2, r1	; 0x02
    14e8:	1b 82       	std	Y+3, r1	; 0x03
    14ea:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    14ec:	1d 82       	std	Y+5, r1	; 0x05
    14ee:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;
    14f0:	6a e0       	ldi	r22, 0x0A	; 10
    14f2:	dc 01       	movw	r26, r24
    14f4:	16 96       	adiw	r26, 0x06	; 6
    14f6:	8d 91       	ld	r24, X+
    14f8:	9c 91       	ld	r25, X
    14fa:	17 97       	sbiw	r26, 0x07	; 7
    14fc:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1500:	7c 01       	movw	r14, r24
    1502:	61 ef       	ldi	r22, 0xF1	; 241
    1504:	75 e0       	ldi	r23, 0x05	; 5
    1506:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    150a:	66 e0       	ldi	r22, 0x06	; 6
    150c:	c7 01       	movw	r24, r14
    150e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1512:	f8 01       	movw	r30, r16
    1514:	84 85       	ldd	r24, Z+12	; 0x0c
    1516:	88 23       	and	r24, r24
    1518:	21 f0       	breq	.+8      	; 0x1522 <_ZN9task_user3runEv+0x4c>
    151a:	81 30       	cpi	r24, 0x01	; 1
    151c:	09 f4       	brne	.+2      	; 0x1520 <_ZN9task_user3runEv+0x4a>
    151e:	5d c0       	rjmp	.+186    	; 0x15da <_ZN9task_user3runEv+0x104>
    1520:	32 c1       	rjmp	.+612    	; 0x1786 <_ZN9task_user3runEv+0x2b0>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1522:	86 81       	ldd	r24, Z+6	; 0x06
    1524:	97 81       	ldd	r25, Z+7	; 0x07
    1526:	dc 01       	movw	r26, r24
    1528:	ed 91       	ld	r30, X+
    152a:	fc 91       	ld	r31, X
    152c:	04 80       	ldd	r0, Z+4	; 0x04
    152e:	f5 81       	ldd	r31, Z+5	; 0x05
    1530:	e0 2d       	mov	r30, r0
    1532:	19 95       	eicall
    1534:	88 23       	and	r24, r24
    1536:	a9 f1       	breq	.+106    	; 0x15a2 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1538:	f8 01       	movw	r30, r16
    153a:	86 81       	ldd	r24, Z+6	; 0x06
    153c:	97 81       	ldd	r25, Z+7	; 0x07
    153e:	dc 01       	movw	r26, r24
    1540:	ed 91       	ld	r30, X+
    1542:	fc 91       	ld	r31, X
    1544:	06 80       	ldd	r0, Z+6	; 0x06
    1546:	f7 81       	ldd	r31, Z+7	; 0x07
    1548:	e0 2d       	mov	r30, r0
    154a:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    154c:	99 27       	eor	r25, r25
    154e:	81 30       	cpi	r24, 0x01	; 1
    1550:	91 05       	cpc	r25, r1
    1552:	f9 f0       	breq	.+62     	; 0x1592 <_ZN9task_user3runEv+0xbc>
    1554:	03 97       	sbiw	r24, 0x03	; 3
    1556:	09 f0       	breq	.+2      	; 0x155a <_ZN9task_user3runEv+0x84>
    1558:	31 c1       	rjmp	.+610    	; 0x17bc <_ZN9task_user3runEv+0x2e6>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    155a:	6a e0       	ldi	r22, 0x0A	; 10
    155c:	f8 01       	movw	r30, r16
    155e:	86 81       	ldd	r24, Z+6	; 0x06
    1560:	97 81       	ldd	r25, Z+7	; 0x07
    1562:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1566:	8c 01       	movw	r16, r24
    1568:	63 ee       	ldi	r22, 0xE3	; 227
    156a:	75 e0       	ldi	r23, 0x05	; 5
    156c:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1570:	66 e0       	ldi	r22, 0x06	; 6
    1572:	c8 01       	movw	r24, r16
    1574:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1578:	93 e0       	ldi	r25, 0x03	; 3
    157a:	88 ed       	ldi	r24, 0xD8	; 216
    157c:	08 b6       	in	r0, 0x38	; 56
    157e:	18 be       	out	0x38, r1	; 56
    1580:	84 bf       	out	0x34, r24	; 52
    1582:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1586:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    158a:	81 fd       	sbrc	r24, 1
    158c:	fc cf       	rjmp	.-8      	; 0x1586 <_ZN9task_user3runEv+0xb0>
    158e:	08 be       	out	0x38, r0	; 56
    1590:	ff cf       	rjmp	.-2      	; 0x1590 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1592:	c8 01       	movw	r24, r16
    1594:	0e 94 00 09 	call	0x1200	; 0x1200 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1598:	61 e0       	ldi	r22, 0x01	; 1
    159a:	c8 01       	movw	r24, r16
    159c:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
							break;
    15a0:	0d c1       	rjmp	.+538    	; 0x17bc <_ZN9task_user3runEv+0x2e6>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    15a2:	84 e5       	ldi	r24, 0x54	; 84
    15a4:	91 e3       	ldi	r25, 0x31	; 49
    15a6:	0e 94 03 1a 	call	0x3406	; 0x3406 <_ZN14frt_text_queue14check_for_charEv>
    15aa:	88 23       	and	r24, r24
    15ac:	09 f4       	brne	.+2      	; 0x15b0 <_ZN9task_user3runEv+0xda>
    15ae:	06 c1       	rjmp	.+524    	; 0x17bc <_ZN9task_user3runEv+0x2e6>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    15b0:	d8 01       	movw	r26, r16
    15b2:	16 96       	adiw	r26, 0x06	; 6
    15b4:	ed 91       	ld	r30, X+
    15b6:	fc 91       	ld	r31, X
    15b8:	17 97       	sbiw	r26, 0x07	; 7
    15ba:	01 90       	ld	r0, Z+
    15bc:	f0 81       	ld	r31, Z
    15be:	e0 2d       	mov	r30, r0
    15c0:	e2 80       	ldd	r14, Z+2	; 0x02
    15c2:	f3 80       	ldd	r15, Z+3	; 0x03
    15c4:	84 e5       	ldi	r24, 0x54	; 84
    15c6:	91 e3       	ldi	r25, 0x31	; 49
    15c8:	0e 94 e5 19 	call	0x33ca	; 0x33ca <_ZN14frt_text_queue7getcharEv>
    15cc:	68 2f       	mov	r22, r24
    15ce:	f8 01       	movw	r30, r16
    15d0:	86 81       	ldd	r24, Z+6	; 0x06
    15d2:	97 81       	ldd	r25, Z+7	; 0x07
    15d4:	f7 01       	movw	r30, r14
    15d6:	19 95       	eicall
    15d8:	f1 c0       	rjmp	.+482    	; 0x17bc <_ZN9task_user3runEv+0x2e6>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    15da:	86 81       	ldd	r24, Z+6	; 0x06
    15dc:	97 81       	ldd	r25, Z+7	; 0x07
    15de:	dc 01       	movw	r26, r24
    15e0:	ed 91       	ld	r30, X+
    15e2:	fc 91       	ld	r31, X
    15e4:	04 80       	ldd	r0, Z+4	; 0x04
    15e6:	f5 81       	ldd	r31, Z+5	; 0x05
    15e8:	e0 2d       	mov	r30, r0
    15ea:	19 95       	eicall
    15ec:	88 23       	and	r24, r24
    15ee:	09 f4       	brne	.+2      	; 0x15f2 <_ZN9task_user3runEv+0x11c>
    15f0:	e5 c0       	rjmp	.+458    	; 0x17bc <_ZN9task_user3runEv+0x2e6>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    15f2:	f8 01       	movw	r30, r16
    15f4:	86 81       	ldd	r24, Z+6	; 0x06
    15f6:	97 81       	ldd	r25, Z+7	; 0x07
    15f8:	dc 01       	movw	r26, r24
    15fa:	ed 91       	ld	r30, X+
    15fc:	fc 91       	ld	r31, X
    15fe:	06 80       	ldd	r0, Z+6	; 0x06
    1600:	f7 81       	ldd	r31, Z+7	; 0x07
    1602:	e0 2d       	mov	r30, r0
    1604:	19 95       	eicall
    1606:	bc 01       	movw	r22, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1608:	fc 01       	movw	r30, r24
    160a:	ff 27       	eor	r31, r31
    160c:	7b 97       	sbiw	r30, 0x1b	; 27
    160e:	ec 35       	cpi	r30, 0x5C	; 92
    1610:	f1 05       	cpc	r31, r1
    1612:	08 f0       	brcs	.+2      	; 0x1616 <_ZN9task_user3runEv+0x140>
    1614:	9c c0       	rjmp	.+312    	; 0x174e <_ZN9task_user3runEv+0x278>
    1616:	88 27       	eor	r24, r24
    1618:	e2 50       	subi	r30, 0x02	; 2
    161a:	ff 4f       	sbci	r31, 0xFF	; 255
    161c:	8f 4f       	sbci	r24, 0xFF	; 255
    161e:	0c 94 29 22 	jmp	0x4452	; 0x4452 <__tablejump2__>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1622:	ce 01       	movw	r24, r28
    1624:	01 96       	adiw	r24, 0x01	; 1
    1626:	0e 94 f7 1a 	call	0x35ee	; 0x35ee <_ZN10time_stamp10set_to_nowEv>
    162a:	bc 01       	movw	r22, r24
    162c:	f8 01       	movw	r30, r16
    162e:	86 81       	ldd	r24, Z+6	; 0x06
    1630:	97 81       	ldd	r25, Z+7	; 0x07
    1632:	0e 94 9b 1a 	call	0x3536	; 0x3536 <_ZlsR8emstreamR10time_stamp>
    1636:	66 e0       	ldi	r22, 0x06	; 6
    1638:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
							break;
    163c:	bf c0       	rjmp	.+382    	; 0x17bc <_ZN9task_user3runEv+0x2e6>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    163e:	c8 01       	movw	r24, r16
    1640:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <_ZN9task_user11show_statusEv>
							break;
    1644:	bb c0       	rjmp	.+374    	; 0x17bc <_ZN9task_user3runEv+0x2e6>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1646:	d8 01       	movw	r26, r16
    1648:	16 96       	adiw	r26, 0x06	; 6
    164a:	8d 91       	ld	r24, X+
    164c:	9c 91       	ld	r25, X
    164e:	17 97       	sbiw	r26, 0x07	; 7
    1650:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <_Z17print_task_stacksP8emstream>
							break;
    1654:	b3 c0       	rjmp	.+358    	; 0x17bc <_ZN9task_user3runEv+0x2e6>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1656:	c8 01       	movw	r24, r16
    1658:	0e 94 00 09 	call	0x1200	; 0x1200 <_ZN9task_user18print_help_messageEv>
							break;
    165c:	af c0       	rjmp	.+350    	; 0x17bc <_ZN9task_user3runEv+0x2e6>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    165e:	6a e0       	ldi	r22, 0x0A	; 10
    1660:	f8 01       	movw	r30, r16
    1662:	86 81       	ldd	r24, Z+6	; 0x06
    1664:	97 81       	ldd	r25, Z+7	; 0x07
    1666:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    166a:	7c 01       	movw	r14, r24
    166c:	61 ed       	ldi	r22, 0xD1	; 209
    166e:	75 e0       	ldi	r23, 0x05	; 5
    1670:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1674:	66 e0       	ldi	r22, 0x06	; 6
    1676:	c7 01       	movw	r24, r14
    1678:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0); 
    167c:	60 e0       	ldi	r22, 0x00	; 0
    167e:	c8 01       	movw	r24, r16
    1680:	0e 94 42 17 	call	0x2e84	; 0x2e84 <_ZN8frt_task13transition_toEh>
							break;
    1684:	9b c0       	rjmp	.+310    	; 0x17bc <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1686:	0f b6       	in	r0, 0x3f	; 63
    1688:	f8 94       	cli
    168a:	0f 92       	push	r0
			the_data = new_data;
    168c:	81 e0       	ldi	r24, 0x01	; 1
    168e:	80 93 49 31 	sts	0x3149, r24	; 0x803149 <begin>
			portEXIT_CRITICAL ();
    1692:	0f 90       	pop	r0
    1694:	0f be       	out	0x3f, r0	; 63
							
						case ('b'):
							begin.put(true);
							*p_serial << PMS ("Begin Homing") << endl;
    1696:	6a e0       	ldi	r22, 0x0A	; 10
    1698:	d8 01       	movw	r26, r16
    169a:	16 96       	adiw	r26, 0x06	; 6
    169c:	8d 91       	ld	r24, X+
    169e:	9c 91       	ld	r25, X
    16a0:	17 97       	sbiw	r26, 0x07	; 7
    16a2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    16a6:	7c 01       	movw	r14, r24
    16a8:	64 ec       	ldi	r22, 0xC4	; 196
    16aa:	75 e0       	ldi	r23, 0x05	; 5
    16ac:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    16b0:	66 e0       	ldi	r22, 0x06	; 6
    16b2:	c7 01       	movw	r24, r14
    16b4:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
							break;
    16b8:	81 c0       	rjmp	.+258    	; 0x17bc <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    16ba:	0f b6       	in	r0, 0x3f	; 63
    16bc:	f8 94       	cli
    16be:	0f 92       	push	r0
			the_data = new_data;
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <go>
			portEXIT_CRITICAL ();
    16c6:	0f 90       	pop	r0
    16c8:	0f be       	out	0x3f, r0	; 63
						
						case ('g'):
							go.put(true);
							*p_serial << PMS ("Commence Balance") << endl;
    16ca:	6a e0       	ldi	r22, 0x0A	; 10
    16cc:	f8 01       	movw	r30, r16
    16ce:	86 81       	ldd	r24, Z+6	; 0x06
    16d0:	97 81       	ldd	r25, Z+7	; 0x07
    16d2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    16d6:	7c 01       	movw	r14, r24
    16d8:	63 eb       	ldi	r22, 0xB3	; 179
    16da:	75 e0       	ldi	r23, 0x05	; 5
    16dc:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    16e0:	66 e0       	ldi	r22, 0x06	; 6
    16e2:	c7 01       	movw	r24, r14
    16e4:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
							break;
    16e8:	69 c0       	rjmp	.+210    	; 0x17bc <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    16ea:	0f b6       	in	r0, 0x3f	; 63
    16ec:	f8 94       	cli
    16ee:	0f 92       	push	r0
			the_data = new_data;
    16f0:	81 e0       	ldi	r24, 0x01	; 1
    16f2:	80 93 47 31 	sts	0x3147, r24	; 0x803147 <stop>
			portEXIT_CRITICAL ();
    16f6:	0f 90       	pop	r0
    16f8:	0f be       	out	0x3f, r0	; 63
						
						case('d'):
							stop.put(true);
							*p_serial << PMS ("EMERGENCY STOP") << endl;
    16fa:	6a e0       	ldi	r22, 0x0A	; 10
    16fc:	d8 01       	movw	r26, r16
    16fe:	16 96       	adiw	r26, 0x06	; 6
    1700:	8d 91       	ld	r24, X+
    1702:	9c 91       	ld	r25, X
    1704:	17 97       	sbiw	r26, 0x07	; 7
    1706:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    170a:	7c 01       	movw	r14, r24
    170c:	64 ea       	ldi	r22, 0xA4	; 164
    170e:	75 e0       	ldi	r23, 0x05	; 5
    1710:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1714:	66 e0       	ldi	r22, 0x06	; 6
    1716:	c7 01       	movw	r24, r14
    1718:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
							break;
    171c:	4f c0       	rjmp	.+158    	; 0x17bc <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	0f 92       	push	r0
			the_data = new_data;
    1724:	81 e0       	ldi	r24, 0x01	; 1
    1726:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <reset>
			portEXIT_CRITICAL ();
    172a:	0f 90       	pop	r0
    172c:	0f be       	out	0x3f, r0	; 63
						
						case('r'):
							reset.put(true);
							*p_serial << PMS ("Reset, try Homing again by pressing 'b'") << endl;
    172e:	6a e0       	ldi	r22, 0x0A	; 10
    1730:	f8 01       	movw	r30, r16
    1732:	86 81       	ldd	r24, Z+6	; 0x06
    1734:	97 81       	ldd	r25, Z+7	; 0x07
    1736:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    173a:	7c 01       	movw	r14, r24
    173c:	6c e7       	ldi	r22, 0x7C	; 124
    173e:	75 e0       	ldi	r23, 0x05	; 5
    1740:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    1744:	66 e0       	ldi	r22, 0x06	; 6
    1746:	c7 01       	movw	r24, r14
    1748:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
							break;
    174c:	37 c0       	rjmp	.+110    	; 0x17bc <_ZN9task_user3runEv+0x2e6>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    174e:	d8 01       	movw	r26, r16
    1750:	16 96       	adiw	r26, 0x06	; 6
    1752:	8d 91       	ld	r24, X+
    1754:	9c 91       	ld	r25, X
    1756:	17 97       	sbiw	r26, 0x07	; 7
    1758:	dc 01       	movw	r26, r24
    175a:	ed 91       	ld	r30, X+
    175c:	fc 91       	ld	r31, X
    175e:	02 80       	ldd	r0, Z+2	; 0x02
    1760:	f3 81       	ldd	r31, Z+3	; 0x03
    1762:	e0 2d       	mov	r30, r0
    1764:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1766:	6a e0       	ldi	r22, 0x0A	; 10
    1768:	f8 01       	movw	r30, r16
    176a:	86 81       	ldd	r24, Z+6	; 0x06
    176c:	97 81       	ldd	r25, Z+7	; 0x07
    176e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1772:	7c 01       	movw	r14, r24
    1774:	66 e7       	ldi	r22, 0x76	; 118
    1776:	75 e0       	ldi	r23, 0x05	; 5
    1778:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    177c:	66 e0       	ldi	r22, 0x06	; 6
    177e:	c7 01       	movw	r24, r14
    1780:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1784:	1b c0       	rjmp	.+54     	; 0x17bc <_ZN9task_user3runEv+0x2e6>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1786:	6a e0       	ldi	r22, 0x0A	; 10
    1788:	86 81       	ldd	r24, Z+6	; 0x06
    178a:	97 81       	ldd	r25, Z+7	; 0x07
    178c:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    1790:	8c 01       	movw	r16, r24
    1792:	69 e5       	ldi	r22, 0x59	; 89
    1794:	75 e0       	ldi	r23, 0x05	; 5
    1796:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    179a:	66 e0       	ldi	r22, 0x06	; 6
    179c:	c8 01       	movw	r24, r16
    179e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    17a2:	93 e0       	ldi	r25, 0x03	; 3
    17a4:	88 ed       	ldi	r24, 0xD8	; 216
    17a6:	08 b6       	in	r0, 0x38	; 56
    17a8:	18 be       	out	0x38, r1	; 56
    17aa:	84 bf       	out	0x34, r24	; 52
    17ac:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    17b0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    17b4:	81 fd       	sbrc	r24, 1
    17b6:	fc cf       	rjmp	.-8      	; 0x17b0 <_ZN9task_user3runEv+0x2da>
    17b8:	08 be       	out	0x38, r0	; 56
    17ba:	ff cf       	rjmp	.-2      	; 0x17ba <_ZN9task_user3runEv+0x2e4>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    17bc:	f8 01       	movw	r30, r16
    17be:	86 85       	ldd	r24, Z+14	; 0x0e
    17c0:	97 85       	ldd	r25, Z+15	; 0x0f
    17c2:	a0 89       	ldd	r26, Z+16	; 0x10
    17c4:	b1 89       	ldd	r27, Z+17	; 0x11
    17c6:	01 96       	adiw	r24, 0x01	; 1
    17c8:	a1 1d       	adc	r26, r1
    17ca:	b1 1d       	adc	r27, r1
    17cc:	86 87       	std	Z+14, r24	; 0x0e
    17ce:	97 87       	std	Z+15, r25	; 0x0f
    17d0:	a0 8b       	std	Z+16, r26	; 0x10
    17d2:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    17d4:	61 e0       	ldi	r22, 0x01	; 1
    17d6:	70 e0       	ldi	r23, 0x00	; 0
    17d8:	80 e0       	ldi	r24, 0x00	; 0
    17da:	90 e0       	ldi	r25, 0x00	; 0
    17dc:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vTaskDelay>
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;

	
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    17e0:	98 ce       	rjmp	.-720    	; 0x1512 <_ZN9task_user3runEv+0x3c>

000017e2 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    17e2:	0f 93       	push	r16
    17e4:	1f 93       	push	r17
    17e6:	cf 93       	push	r28
    17e8:	df 93       	push	r29
    17ea:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    17ec:	0e 94 05 13 	call	0x260a	; 0x260a <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    17f0:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    17f4:	81 11       	cpse	r24, r1
    17f6:	1d c0       	rjmp	.+58     	; 0x1832 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    17f8:	a1 ec       	ldi	r26, 0xC1	; 193
    17fa:	b0 e2       	ldi	r27, 0x20	; 32
    17fc:	e5 ec       	ldi	r30, 0xC5	; 197
    17fe:	f0 e2       	ldi	r31, 0x20	; 32
    1800:	ed 93       	st	X+, r30
    1802:	fc 93       	st	X, r31
    1804:	11 97       	sbiw	r26, 0x01	; 1
    1806:	12 96       	adiw	r26, 0x02	; 2
    1808:	1d 92       	st	X+, r1
    180a:	1c 92       	st	X, r1
    180c:	13 97       	sbiw	r26, 0x03	; 3
    180e:	ad eb       	ldi	r26, 0xBD	; 189
    1810:	b0 e2       	ldi	r27, 0x20	; 32
    1812:	8f ef       	ldi	r24, 0xFF	; 255
    1814:	9f e0       	ldi	r25, 0x0F	; 15
    1816:	12 96       	adiw	r26, 0x02	; 2
    1818:	8d 93       	st	X+, r24
    181a:	9c 93       	st	X, r25
    181c:	13 97       	sbiw	r26, 0x03	; 3
    181e:	1d 92       	st	X+, r1
    1820:	1c 92       	st	X, r1
    1822:	11 97       	sbiw	r26, 0x01	; 1
    1824:	82 83       	std	Z+2, r24	; 0x02
    1826:	93 83       	std	Z+3, r25	; 0x03
    1828:	a0 83       	st	Z, r26
    182a:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    182c:	81 e0       	ldi	r24, 0x01	; 1
    182e:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1832:	20 97       	sbiw	r28, 0x00	; 0
    1834:	09 f4       	brne	.+2      	; 0x1838 <pvPortMalloc+0x56>
    1836:	5f c0       	rjmp	.+190    	; 0x18f6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1838:	9e 01       	movw	r18, r28
    183a:	2b 5f       	subi	r18, 0xFB	; 251
    183c:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    183e:	24 96       	adiw	r28, 0x04	; 4
    1840:	ce 3f       	cpi	r28, 0xFE	; 254
    1842:	df 40       	sbci	r29, 0x0F	; 15
    1844:	08 f0       	brcs	.+2      	; 0x1848 <pvPortMalloc+0x66>
    1846:	5a c0       	rjmp	.+180    	; 0x18fc <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1848:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    184c:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1850:	a1 ec       	ldi	r26, 0xC1	; 193
    1852:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1854:	02 c0       	rjmp	.+4      	; 0x185a <pvPortMalloc+0x78>
    1856:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1858:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    185a:	82 81       	ldd	r24, Z+2	; 0x02
    185c:	93 81       	ldd	r25, Z+3	; 0x03
    185e:	82 17       	cp	r24, r18
    1860:	93 07       	cpc	r25, r19
    1862:	20 f4       	brcc	.+8      	; 0x186c <pvPortMalloc+0x8a>
    1864:	80 81       	ld	r24, Z
    1866:	91 81       	ldd	r25, Z+1	; 0x01
    1868:	00 97       	sbiw	r24, 0x00	; 0
    186a:	a9 f7       	brne	.-22     	; 0x1856 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    186c:	c0 e2       	ldi	r28, 0x20	; 32
    186e:	ed 3b       	cpi	r30, 0xBD	; 189
    1870:	fc 07       	cpc	r31, r28
    1872:	09 f4       	brne	.+2      	; 0x1876 <pvPortMalloc+0x94>
    1874:	46 c0       	rjmp	.+140    	; 0x1902 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1876:	cd 91       	ld	r28, X+
    1878:	dc 91       	ld	r29, X
    187a:	11 97       	sbiw	r26, 0x01	; 1
    187c:	8e 01       	movw	r16, r28
    187e:	0b 5f       	subi	r16, 0xFB	; 251
    1880:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1882:	80 81       	ld	r24, Z
    1884:	91 81       	ldd	r25, Z+1	; 0x01
    1886:	8d 93       	st	X+, r24
    1888:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    188a:	82 81       	ldd	r24, Z+2	; 0x02
    188c:	93 81       	ldd	r25, Z+3	; 0x03
    188e:	82 1b       	sub	r24, r18
    1890:	93 0b       	sbc	r25, r19
    1892:	8b 30       	cpi	r24, 0x0B	; 11
    1894:	91 05       	cpc	r25, r1
    1896:	10 f1       	brcs	.+68     	; 0x18dc <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1898:	bf 01       	movw	r22, r30
    189a:	62 0f       	add	r22, r18
    189c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    189e:	db 01       	movw	r26, r22
    18a0:	12 96       	adiw	r26, 0x02	; 2
    18a2:	8d 93       	st	X+, r24
    18a4:	9c 93       	st	X, r25
    18a6:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    18a8:	22 83       	std	Z+2, r18	; 0x02
    18aa:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    18ac:	12 96       	adiw	r26, 0x02	; 2
    18ae:	4d 91       	ld	r20, X+
    18b0:	5c 91       	ld	r21, X
    18b2:	13 97       	sbiw	r26, 0x03	; 3
    18b4:	81 ec       	ldi	r24, 0xC1	; 193
    18b6:	90 e2       	ldi	r25, 0x20	; 32
    18b8:	01 c0       	rjmp	.+2      	; 0x18bc <pvPortMalloc+0xda>
    18ba:	cd 01       	movw	r24, r26
    18bc:	ec 01       	movw	r28, r24
    18be:	a8 81       	ld	r26, Y
    18c0:	b9 81       	ldd	r27, Y+1	; 0x01
    18c2:	12 96       	adiw	r26, 0x02	; 2
    18c4:	2d 91       	ld	r18, X+
    18c6:	3c 91       	ld	r19, X
    18c8:	13 97       	sbiw	r26, 0x03	; 3
    18ca:	24 17       	cp	r18, r20
    18cc:	35 07       	cpc	r19, r21
    18ce:	a8 f3       	brcs	.-22     	; 0x18ba <pvPortMalloc+0xd8>
    18d0:	eb 01       	movw	r28, r22
    18d2:	a8 83       	st	Y, r26
    18d4:	b9 83       	std	Y+1, r27	; 0x01
    18d6:	dc 01       	movw	r26, r24
    18d8:	6d 93       	st	X+, r22
    18da:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    18dc:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    18e0:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    18e4:	22 81       	ldd	r18, Z+2	; 0x02
    18e6:	33 81       	ldd	r19, Z+3	; 0x03
    18e8:	82 1b       	sub	r24, r18
    18ea:	93 0b       	sbc	r25, r19
    18ec:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    18f0:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    18f4:	08 c0       	rjmp	.+16     	; 0x1906 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    18f6:	00 e0       	ldi	r16, 0x00	; 0
    18f8:	10 e0       	ldi	r17, 0x00	; 0
    18fa:	05 c0       	rjmp	.+10     	; 0x1906 <pvPortMalloc+0x124>
    18fc:	00 e0       	ldi	r16, 0x00	; 0
    18fe:	10 e0       	ldi	r17, 0x00	; 0
    1900:	02 c0       	rjmp	.+4      	; 0x1906 <pvPortMalloc+0x124>
    1902:	00 e0       	ldi	r16, 0x00	; 0
    1904:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1906:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    190a:	c8 01       	movw	r24, r16
    190c:	df 91       	pop	r29
    190e:	cf 91       	pop	r28
    1910:	1f 91       	pop	r17
    1912:	0f 91       	pop	r16
    1914:	08 95       	ret

00001916 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1916:	0f 93       	push	r16
    1918:	1f 93       	push	r17
    191a:	cf 93       	push	r28
    191c:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    191e:	00 97       	sbiw	r24, 0x00	; 0
    1920:	41 f1       	breq	.+80     	; 0x1972 <vPortFree+0x5c>
    1922:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1924:	8c 01       	movw	r16, r24
    1926:	05 50       	subi	r16, 0x05	; 5
    1928:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    192a:	0e 94 05 13 	call	0x260a	; 0x260a <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    192e:	f8 01       	movw	r30, r16
    1930:	42 81       	ldd	r20, Z+2	; 0x02
    1932:	53 81       	ldd	r21, Z+3	; 0x03
    1934:	a1 ec       	ldi	r26, 0xC1	; 193
    1936:	b0 e2       	ldi	r27, 0x20	; 32
    1938:	01 c0       	rjmp	.+2      	; 0x193c <vPortFree+0x26>
    193a:	df 01       	movw	r26, r30
    193c:	ed 91       	ld	r30, X+
    193e:	fc 91       	ld	r31, X
    1940:	11 97       	sbiw	r26, 0x01	; 1
    1942:	22 81       	ldd	r18, Z+2	; 0x02
    1944:	33 81       	ldd	r19, Z+3	; 0x03
    1946:	24 17       	cp	r18, r20
    1948:	35 07       	cpc	r19, r21
    194a:	b8 f3       	brcs	.-18     	; 0x193a <vPortFree+0x24>
    194c:	25 97       	sbiw	r28, 0x05	; 5
    194e:	e8 83       	st	Y, r30
    1950:	f9 83       	std	Y+1, r31	; 0x01
    1952:	0d 93       	st	X+, r16
    1954:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1956:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    195a:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    195e:	8a 81       	ldd	r24, Y+2	; 0x02
    1960:	9b 81       	ldd	r25, Y+3	; 0x03
    1962:	82 0f       	add	r24, r18
    1964:	93 1f       	adc	r25, r19
    1966:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    196a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    196e:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
	}
}
    1972:	df 91       	pop	r29
    1974:	cf 91       	pop	r28
    1976:	1f 91       	pop	r17
    1978:	0f 91       	pop	r16
    197a:	08 95       	ret

0000197c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    197c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1980:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1984:	08 95       	ret

00001986 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1986:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1988:	03 96       	adiw	r24, 0x03	; 3
    198a:	81 83       	std	Z+1, r24	; 0x01
    198c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    198e:	4f ef       	ldi	r20, 0xFF	; 255
    1990:	5f ef       	ldi	r21, 0xFF	; 255
    1992:	ba 01       	movw	r22, r20
    1994:	43 83       	std	Z+3, r20	; 0x03
    1996:	54 83       	std	Z+4, r21	; 0x04
    1998:	65 83       	std	Z+5, r22	; 0x05
    199a:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    199c:	87 83       	std	Z+7, r24	; 0x07
    199e:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    19a0:	81 87       	std	Z+9, r24	; 0x09
    19a2:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    19a4:	10 82       	st	Z, r1
    19a6:	08 95       	ret

000019a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    19a8:	fc 01       	movw	r30, r24
    19aa:	12 86       	std	Z+10, r1	; 0x0a
    19ac:	13 86       	std	Z+11, r1	; 0x0b
    19ae:	08 95       	ret

000019b0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    19b0:	cf 93       	push	r28
    19b2:	df 93       	push	r29
    19b4:	fc 01       	movw	r30, r24
    19b6:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    19b8:	21 81       	ldd	r18, Z+1	; 0x01
    19ba:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    19bc:	e9 01       	movw	r28, r18
    19be:	8c 81       	ldd	r24, Y+4	; 0x04
    19c0:	9d 81       	ldd	r25, Y+5	; 0x05
    19c2:	14 96       	adiw	r26, 0x04	; 4
    19c4:	8d 93       	st	X+, r24
    19c6:	9c 93       	st	X, r25
    19c8:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    19ca:	81 81       	ldd	r24, Z+1	; 0x01
    19cc:	92 81       	ldd	r25, Z+2	; 0x02
    19ce:	16 96       	adiw	r26, 0x06	; 6
    19d0:	8d 93       	st	X+, r24
    19d2:	9c 93       	st	X, r25
    19d4:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19d6:	8c 81       	ldd	r24, Y+4	; 0x04
    19d8:	9d 81       	ldd	r25, Y+5	; 0x05
    19da:	ec 01       	movw	r28, r24
    19dc:	6e 83       	std	Y+6, r22	; 0x06
    19de:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    19e0:	e9 01       	movw	r28, r18
    19e2:	6c 83       	std	Y+4, r22	; 0x04
    19e4:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    19e6:	61 83       	std	Z+1, r22	; 0x01
    19e8:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19ea:	1a 96       	adiw	r26, 0x0a	; 10
    19ec:	ed 93       	st	X+, r30
    19ee:	fc 93       	st	X, r31
    19f0:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    19f2:	80 81       	ld	r24, Z
    19f4:	8f 5f       	subi	r24, 0xFF	; 255
    19f6:	80 83       	st	Z, r24
}
    19f8:	df 91       	pop	r29
    19fa:	cf 91       	pop	r28
    19fc:	08 95       	ret

000019fe <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    19fe:	0f 93       	push	r16
    1a00:	1f 93       	push	r17
    1a02:	cf 93       	push	r28
    1a04:	df 93       	push	r29
    1a06:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1a08:	08 81       	ld	r16, Y
    1a0a:	19 81       	ldd	r17, Y+1	; 0x01
    1a0c:	2a 81       	ldd	r18, Y+2	; 0x02
    1a0e:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1a10:	0f 3f       	cpi	r16, 0xFF	; 255
    1a12:	4f ef       	ldi	r20, 0xFF	; 255
    1a14:	14 07       	cpc	r17, r20
    1a16:	24 07       	cpc	r18, r20
    1a18:	34 07       	cpc	r19, r20
    1a1a:	31 f4       	brne	.+12     	; 0x1a28 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1a1c:	dc 01       	movw	r26, r24
    1a1e:	19 96       	adiw	r26, 0x09	; 9
    1a20:	ed 91       	ld	r30, X+
    1a22:	fc 91       	ld	r31, X
    1a24:	1a 97       	sbiw	r26, 0x0a	; 10
    1a26:	1f c0       	rjmp	.+62     	; 0x1a66 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1a28:	fc 01       	movw	r30, r24
    1a2a:	33 96       	adiw	r30, 0x03	; 3
    1a2c:	dc 01       	movw	r26, r24
    1a2e:	17 96       	adiw	r26, 0x07	; 7
    1a30:	4d 91       	ld	r20, X+
    1a32:	5c 91       	ld	r21, X
    1a34:	18 97       	sbiw	r26, 0x08	; 8
    1a36:	da 01       	movw	r26, r20
    1a38:	4d 91       	ld	r20, X+
    1a3a:	5d 91       	ld	r21, X+
    1a3c:	6d 91       	ld	r22, X+
    1a3e:	7c 91       	ld	r23, X
    1a40:	04 17       	cp	r16, r20
    1a42:	15 07       	cpc	r17, r21
    1a44:	26 07       	cpc	r18, r22
    1a46:	37 07       	cpc	r19, r23
    1a48:	70 f0       	brcs	.+28     	; 0x1a66 <vListInsert+0x68>
    1a4a:	04 80       	ldd	r0, Z+4	; 0x04
    1a4c:	f5 81       	ldd	r31, Z+5	; 0x05
    1a4e:	e0 2d       	mov	r30, r0
    1a50:	a4 81       	ldd	r26, Z+4	; 0x04
    1a52:	b5 81       	ldd	r27, Z+5	; 0x05
    1a54:	4d 91       	ld	r20, X+
    1a56:	5d 91       	ld	r21, X+
    1a58:	6d 91       	ld	r22, X+
    1a5a:	7c 91       	ld	r23, X
    1a5c:	04 17       	cp	r16, r20
    1a5e:	15 07       	cpc	r17, r21
    1a60:	26 07       	cpc	r18, r22
    1a62:	37 07       	cpc	r19, r23
    1a64:	90 f7       	brcc	.-28     	; 0x1a4a <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1a66:	a4 81       	ldd	r26, Z+4	; 0x04
    1a68:	b5 81       	ldd	r27, Z+5	; 0x05
    1a6a:	ac 83       	std	Y+4, r26	; 0x04
    1a6c:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1a6e:	16 96       	adiw	r26, 0x06	; 6
    1a70:	cd 93       	st	X+, r28
    1a72:	dc 93       	st	X, r29
    1a74:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1a76:	ee 83       	std	Y+6, r30	; 0x06
    1a78:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1a7a:	c4 83       	std	Z+4, r28	; 0x04
    1a7c:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1a7e:	8a 87       	std	Y+10, r24	; 0x0a
    1a80:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1a82:	fc 01       	movw	r30, r24
    1a84:	20 81       	ld	r18, Z
    1a86:	2f 5f       	subi	r18, 0xFF	; 255
    1a88:	20 83       	st	Z, r18
}
    1a8a:	df 91       	pop	r29
    1a8c:	cf 91       	pop	r28
    1a8e:	1f 91       	pop	r17
    1a90:	0f 91       	pop	r16
    1a92:	08 95       	ret

00001a94 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1a94:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1a96:	a4 81       	ldd	r26, Z+4	; 0x04
    1a98:	b5 81       	ldd	r27, Z+5	; 0x05
    1a9a:	86 81       	ldd	r24, Z+6	; 0x06
    1a9c:	97 81       	ldd	r25, Z+7	; 0x07
    1a9e:	16 96       	adiw	r26, 0x06	; 6
    1aa0:	8d 93       	st	X+, r24
    1aa2:	9c 93       	st	X, r25
    1aa4:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1aa6:	a6 81       	ldd	r26, Z+6	; 0x06
    1aa8:	b7 81       	ldd	r27, Z+7	; 0x07
    1aaa:	84 81       	ldd	r24, Z+4	; 0x04
    1aac:	95 81       	ldd	r25, Z+5	; 0x05
    1aae:	14 96       	adiw	r26, 0x04	; 4
    1ab0:	8d 93       	st	X+, r24
    1ab2:	9c 93       	st	X, r25
    1ab4:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1ab6:	a2 85       	ldd	r26, Z+10	; 0x0a
    1ab8:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1aba:	11 96       	adiw	r26, 0x01	; 1
    1abc:	8d 91       	ld	r24, X+
    1abe:	9c 91       	ld	r25, X
    1ac0:	12 97       	sbiw	r26, 0x02	; 2
    1ac2:	e8 17       	cp	r30, r24
    1ac4:	f9 07       	cpc	r31, r25
    1ac6:	31 f4       	brne	.+12     	; 0x1ad4 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1ac8:	86 81       	ldd	r24, Z+6	; 0x06
    1aca:	97 81       	ldd	r25, Z+7	; 0x07
    1acc:	11 96       	adiw	r26, 0x01	; 1
    1ace:	8d 93       	st	X+, r24
    1ad0:	9c 93       	st	X, r25
    1ad2:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1ad4:	12 86       	std	Z+10, r1	; 0x0a
    1ad6:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1ad8:	8c 91       	ld	r24, X
    1ada:	81 50       	subi	r24, 0x01	; 1
    1adc:	8c 93       	st	X, r24
    1ade:	08 95       	ret

00001ae0 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1ae0:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <portStackTopForTask>
    1ae4:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <portStackTopForTask+0x1>
    1ae8:	31 e1       	ldi	r19, 0x11	; 17
    1aea:	fc 01       	movw	r30, r24
    1aec:	30 83       	st	Z, r19
    1aee:	31 97       	sbiw	r30, 0x01	; 1
    1af0:	22 e2       	ldi	r18, 0x22	; 34
    1af2:	20 83       	st	Z, r18
    1af4:	31 97       	sbiw	r30, 0x01	; 1
    1af6:	a3 e3       	ldi	r26, 0x33	; 51
    1af8:	a0 83       	st	Z, r26
    1afa:	31 97       	sbiw	r30, 0x01	; 1
    1afc:	60 83       	st	Z, r22
    1afe:	31 97       	sbiw	r30, 0x01	; 1
    1b00:	70 83       	st	Z, r23
    1b02:	31 97       	sbiw	r30, 0x01	; 1
    1b04:	10 82       	st	Z, r1
    1b06:	31 97       	sbiw	r30, 0x01	; 1
    1b08:	10 82       	st	Z, r1
    1b0a:	31 97       	sbiw	r30, 0x01	; 1
    1b0c:	60 e8       	ldi	r22, 0x80	; 128
    1b0e:	60 83       	st	Z, r22
    1b10:	31 97       	sbiw	r30, 0x01	; 1
    1b12:	10 82       	st	Z, r1
    1b14:	31 97       	sbiw	r30, 0x01	; 1
    1b16:	10 82       	st	Z, r1
    1b18:	31 97       	sbiw	r30, 0x01	; 1
    1b1a:	10 82       	st	Z, r1
    1b1c:	31 97       	sbiw	r30, 0x01	; 1
    1b1e:	62 e0       	ldi	r22, 0x02	; 2
    1b20:	60 83       	st	Z, r22
    1b22:	31 97       	sbiw	r30, 0x01	; 1
    1b24:	63 e0       	ldi	r22, 0x03	; 3
    1b26:	60 83       	st	Z, r22
    1b28:	31 97       	sbiw	r30, 0x01	; 1
    1b2a:	64 e0       	ldi	r22, 0x04	; 4
    1b2c:	60 83       	st	Z, r22
    1b2e:	31 97       	sbiw	r30, 0x01	; 1
    1b30:	65 e0       	ldi	r22, 0x05	; 5
    1b32:	60 83       	st	Z, r22
    1b34:	31 97       	sbiw	r30, 0x01	; 1
    1b36:	66 e0       	ldi	r22, 0x06	; 6
    1b38:	60 83       	st	Z, r22
    1b3a:	31 97       	sbiw	r30, 0x01	; 1
    1b3c:	67 e0       	ldi	r22, 0x07	; 7
    1b3e:	60 83       	st	Z, r22
    1b40:	31 97       	sbiw	r30, 0x01	; 1
    1b42:	68 e0       	ldi	r22, 0x08	; 8
    1b44:	60 83       	st	Z, r22
    1b46:	31 97       	sbiw	r30, 0x01	; 1
    1b48:	69 e0       	ldi	r22, 0x09	; 9
    1b4a:	60 83       	st	Z, r22
    1b4c:	31 97       	sbiw	r30, 0x01	; 1
    1b4e:	60 e1       	ldi	r22, 0x10	; 16
    1b50:	60 83       	st	Z, r22
    1b52:	31 97       	sbiw	r30, 0x01	; 1
    1b54:	30 83       	st	Z, r19
    1b56:	31 97       	sbiw	r30, 0x01	; 1
    1b58:	32 e1       	ldi	r19, 0x12	; 18
    1b5a:	30 83       	st	Z, r19
    1b5c:	31 97       	sbiw	r30, 0x01	; 1
    1b5e:	33 e1       	ldi	r19, 0x13	; 19
    1b60:	30 83       	st	Z, r19
    1b62:	31 97       	sbiw	r30, 0x01	; 1
    1b64:	34 e1       	ldi	r19, 0x14	; 20
    1b66:	30 83       	st	Z, r19
    1b68:	31 97       	sbiw	r30, 0x01	; 1
    1b6a:	35 e1       	ldi	r19, 0x15	; 21
    1b6c:	30 83       	st	Z, r19
    1b6e:	31 97       	sbiw	r30, 0x01	; 1
    1b70:	36 e1       	ldi	r19, 0x16	; 22
    1b72:	30 83       	st	Z, r19
    1b74:	31 97       	sbiw	r30, 0x01	; 1
    1b76:	37 e1       	ldi	r19, 0x17	; 23
    1b78:	30 83       	st	Z, r19
    1b7a:	31 97       	sbiw	r30, 0x01	; 1
    1b7c:	38 e1       	ldi	r19, 0x18	; 24
    1b7e:	30 83       	st	Z, r19
    1b80:	31 97       	sbiw	r30, 0x01	; 1
    1b82:	39 e1       	ldi	r19, 0x19	; 25
    1b84:	30 83       	st	Z, r19
    1b86:	31 97       	sbiw	r30, 0x01	; 1
    1b88:	30 e2       	ldi	r19, 0x20	; 32
    1b8a:	30 83       	st	Z, r19
    1b8c:	31 97       	sbiw	r30, 0x01	; 1
    1b8e:	31 e2       	ldi	r19, 0x21	; 33
    1b90:	30 83       	st	Z, r19
    1b92:	31 97       	sbiw	r30, 0x01	; 1
    1b94:	20 83       	st	Z, r18
    1b96:	31 97       	sbiw	r30, 0x01	; 1
    1b98:	23 e2       	ldi	r18, 0x23	; 35
    1b9a:	20 83       	st	Z, r18
    1b9c:	31 97       	sbiw	r30, 0x01	; 1
    1b9e:	40 83       	st	Z, r20
    1ba0:	31 97       	sbiw	r30, 0x01	; 1
    1ba2:	50 83       	st	Z, r21
    1ba4:	31 97       	sbiw	r30, 0x01	; 1
    1ba6:	26 e2       	ldi	r18, 0x26	; 38
    1ba8:	20 83       	st	Z, r18
    1baa:	31 97       	sbiw	r30, 0x01	; 1
    1bac:	27 e2       	ldi	r18, 0x27	; 39
    1bae:	20 83       	st	Z, r18
    1bb0:	31 97       	sbiw	r30, 0x01	; 1
    1bb2:	28 e2       	ldi	r18, 0x28	; 40
    1bb4:	20 83       	st	Z, r18
    1bb6:	31 97       	sbiw	r30, 0x01	; 1
    1bb8:	29 e2       	ldi	r18, 0x29	; 41
    1bba:	20 83       	st	Z, r18
    1bbc:	31 97       	sbiw	r30, 0x01	; 1
    1bbe:	20 e3       	ldi	r18, 0x30	; 48
    1bc0:	20 83       	st	Z, r18
    1bc2:	31 97       	sbiw	r30, 0x01	; 1
    1bc4:	21 e3       	ldi	r18, 0x31	; 49
    1bc6:	20 83       	st	Z, r18
    1bc8:	89 97       	sbiw	r24, 0x29	; 41
    1bca:	08 95       	ret

00001bcc <xPortStartScheduler>:
    1bcc:	8c e7       	ldi	r24, 0x7C	; 124
    1bce:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1bd2:	8f ef       	ldi	r24, 0xFF	; 255
    1bd4:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1bd8:	81 e0       	ldi	r24, 0x01	; 1
    1bda:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1bde:	91 e1       	ldi	r25, 0x11	; 17
    1be0:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1be4:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1be8:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1bec:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1bf0:	cd 91       	ld	r28, X+
    1bf2:	cd bf       	out	0x3d, r28	; 61
    1bf4:	dd 91       	ld	r29, X+
    1bf6:	de bf       	out	0x3e, r29	; 62
    1bf8:	ff 91       	pop	r31
    1bfa:	ef 91       	pop	r30
    1bfc:	df 91       	pop	r29
    1bfe:	cf 91       	pop	r28
    1c00:	bf 91       	pop	r27
    1c02:	af 91       	pop	r26
    1c04:	9f 91       	pop	r25
    1c06:	8f 91       	pop	r24
    1c08:	7f 91       	pop	r23
    1c0a:	6f 91       	pop	r22
    1c0c:	5f 91       	pop	r21
    1c0e:	4f 91       	pop	r20
    1c10:	3f 91       	pop	r19
    1c12:	2f 91       	pop	r18
    1c14:	1f 91       	pop	r17
    1c16:	0f 91       	pop	r16
    1c18:	ff 90       	pop	r15
    1c1a:	ef 90       	pop	r14
    1c1c:	df 90       	pop	r13
    1c1e:	cf 90       	pop	r12
    1c20:	bf 90       	pop	r11
    1c22:	af 90       	pop	r10
    1c24:	9f 90       	pop	r9
    1c26:	8f 90       	pop	r8
    1c28:	7f 90       	pop	r7
    1c2a:	6f 90       	pop	r6
    1c2c:	5f 90       	pop	r5
    1c2e:	4f 90       	pop	r4
    1c30:	3f 90       	pop	r3
    1c32:	2f 90       	pop	r2
    1c34:	1f 90       	pop	r1
    1c36:	0f 90       	pop	r0
    1c38:	0c be       	out	0x3c, r0	; 60
    1c3a:	0f 90       	pop	r0
    1c3c:	0b be       	out	0x3b, r0	; 59
    1c3e:	0f 90       	pop	r0
    1c40:	0f be       	out	0x3f, r0	; 63
    1c42:	0f 90       	pop	r0
    1c44:	08 95       	ret
    1c46:	08 95       	ret

00001c48 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1c48:	0f 92       	push	r0
    1c4a:	0f b6       	in	r0, 0x3f	; 63
    1c4c:	f8 94       	cli
    1c4e:	0f 92       	push	r0
    1c50:	0b b6       	in	r0, 0x3b	; 59
    1c52:	0f 92       	push	r0
    1c54:	0c b6       	in	r0, 0x3c	; 60
    1c56:	0f 92       	push	r0
    1c58:	1f 92       	push	r1
    1c5a:	11 24       	eor	r1, r1
    1c5c:	2f 92       	push	r2
    1c5e:	3f 92       	push	r3
    1c60:	4f 92       	push	r4
    1c62:	5f 92       	push	r5
    1c64:	6f 92       	push	r6
    1c66:	7f 92       	push	r7
    1c68:	8f 92       	push	r8
    1c6a:	9f 92       	push	r9
    1c6c:	af 92       	push	r10
    1c6e:	bf 92       	push	r11
    1c70:	cf 92       	push	r12
    1c72:	df 92       	push	r13
    1c74:	ef 92       	push	r14
    1c76:	ff 92       	push	r15
    1c78:	0f 93       	push	r16
    1c7a:	1f 93       	push	r17
    1c7c:	2f 93       	push	r18
    1c7e:	3f 93       	push	r19
    1c80:	4f 93       	push	r20
    1c82:	5f 93       	push	r21
    1c84:	6f 93       	push	r22
    1c86:	7f 93       	push	r23
    1c88:	8f 93       	push	r24
    1c8a:	9f 93       	push	r25
    1c8c:	af 93       	push	r26
    1c8e:	bf 93       	push	r27
    1c90:	cf 93       	push	r28
    1c92:	df 93       	push	r29
    1c94:	ef 93       	push	r30
    1c96:	ff 93       	push	r31
    1c98:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1c9c:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1ca0:	0d b6       	in	r0, 0x3d	; 61
    1ca2:	0d 92       	st	X+, r0
    1ca4:	0e b6       	in	r0, 0x3e	; 62
    1ca6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1ca8:	0e 94 44 15 	call	0x2a88	; 0x2a88 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1cac:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1cb0:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1cb4:	cd 91       	ld	r28, X+
    1cb6:	cd bf       	out	0x3d, r28	; 61
    1cb8:	dd 91       	ld	r29, X+
    1cba:	de bf       	out	0x3e, r29	; 62
    1cbc:	ff 91       	pop	r31
    1cbe:	ef 91       	pop	r30
    1cc0:	df 91       	pop	r29
    1cc2:	cf 91       	pop	r28
    1cc4:	bf 91       	pop	r27
    1cc6:	af 91       	pop	r26
    1cc8:	9f 91       	pop	r25
    1cca:	8f 91       	pop	r24
    1ccc:	7f 91       	pop	r23
    1cce:	6f 91       	pop	r22
    1cd0:	5f 91       	pop	r21
    1cd2:	4f 91       	pop	r20
    1cd4:	3f 91       	pop	r19
    1cd6:	2f 91       	pop	r18
    1cd8:	1f 91       	pop	r17
    1cda:	0f 91       	pop	r16
    1cdc:	ff 90       	pop	r15
    1cde:	ef 90       	pop	r14
    1ce0:	df 90       	pop	r13
    1ce2:	cf 90       	pop	r12
    1ce4:	bf 90       	pop	r11
    1ce6:	af 90       	pop	r10
    1ce8:	9f 90       	pop	r9
    1cea:	8f 90       	pop	r8
    1cec:	7f 90       	pop	r7
    1cee:	6f 90       	pop	r6
    1cf0:	5f 90       	pop	r5
    1cf2:	4f 90       	pop	r4
    1cf4:	3f 90       	pop	r3
    1cf6:	2f 90       	pop	r2
    1cf8:	1f 90       	pop	r1
    1cfa:	0f 90       	pop	r0
    1cfc:	0c be       	out	0x3c, r0	; 60
    1cfe:	0f 90       	pop	r0
    1d00:	0b be       	out	0x3b, r0	; 59
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63
    1d06:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d08:	08 95       	ret

00001d0a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1d0a:	0f 92       	push	r0
    1d0c:	0f b6       	in	r0, 0x3f	; 63
    1d0e:	f8 94       	cli
    1d10:	0f 92       	push	r0
    1d12:	0b b6       	in	r0, 0x3b	; 59
    1d14:	0f 92       	push	r0
    1d16:	0c b6       	in	r0, 0x3c	; 60
    1d18:	0f 92       	push	r0
    1d1a:	1f 92       	push	r1
    1d1c:	11 24       	eor	r1, r1
    1d1e:	2f 92       	push	r2
    1d20:	3f 92       	push	r3
    1d22:	4f 92       	push	r4
    1d24:	5f 92       	push	r5
    1d26:	6f 92       	push	r6
    1d28:	7f 92       	push	r7
    1d2a:	8f 92       	push	r8
    1d2c:	9f 92       	push	r9
    1d2e:	af 92       	push	r10
    1d30:	bf 92       	push	r11
    1d32:	cf 92       	push	r12
    1d34:	df 92       	push	r13
    1d36:	ef 92       	push	r14
    1d38:	ff 92       	push	r15
    1d3a:	0f 93       	push	r16
    1d3c:	1f 93       	push	r17
    1d3e:	2f 93       	push	r18
    1d40:	3f 93       	push	r19
    1d42:	4f 93       	push	r20
    1d44:	5f 93       	push	r21
    1d46:	6f 93       	push	r22
    1d48:	7f 93       	push	r23
    1d4a:	8f 93       	push	r24
    1d4c:	9f 93       	push	r25
    1d4e:	af 93       	push	r26
    1d50:	bf 93       	push	r27
    1d52:	cf 93       	push	r28
    1d54:	df 93       	push	r29
    1d56:	ef 93       	push	r30
    1d58:	ff 93       	push	r31
    1d5a:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1d5e:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1d62:	0d b6       	in	r0, 0x3d	; 61
    1d64:	0d 92       	st	X+, r0
    1d66:	0e b6       	in	r0, 0x3e	; 62
    1d68:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1d6a:	0e 94 26 13 	call	0x264c	; 0x264c <vTaskIncrementTick>
	vTaskSwitchContext();
    1d6e:	0e 94 44 15 	call	0x2a88	; 0x2a88 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1d72:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1d76:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1d7a:	cd 91       	ld	r28, X+
    1d7c:	cd bf       	out	0x3d, r28	; 61
    1d7e:	dd 91       	ld	r29, X+
    1d80:	de bf       	out	0x3e, r29	; 62
    1d82:	ff 91       	pop	r31
    1d84:	ef 91       	pop	r30
    1d86:	df 91       	pop	r29
    1d88:	cf 91       	pop	r28
    1d8a:	bf 91       	pop	r27
    1d8c:	af 91       	pop	r26
    1d8e:	9f 91       	pop	r25
    1d90:	8f 91       	pop	r24
    1d92:	7f 91       	pop	r23
    1d94:	6f 91       	pop	r22
    1d96:	5f 91       	pop	r21
    1d98:	4f 91       	pop	r20
    1d9a:	3f 91       	pop	r19
    1d9c:	2f 91       	pop	r18
    1d9e:	1f 91       	pop	r17
    1da0:	0f 91       	pop	r16
    1da2:	ff 90       	pop	r15
    1da4:	ef 90       	pop	r14
    1da6:	df 90       	pop	r13
    1da8:	cf 90       	pop	r12
    1daa:	bf 90       	pop	r11
    1dac:	af 90       	pop	r10
    1dae:	9f 90       	pop	r9
    1db0:	8f 90       	pop	r8
    1db2:	7f 90       	pop	r7
    1db4:	6f 90       	pop	r6
    1db6:	5f 90       	pop	r5
    1db8:	4f 90       	pop	r4
    1dba:	3f 90       	pop	r3
    1dbc:	2f 90       	pop	r2
    1dbe:	1f 90       	pop	r1
    1dc0:	0f 90       	pop	r0
    1dc2:	0c be       	out	0x3c, r0	; 60
    1dc4:	0f 90       	pop	r0
    1dc6:	0b be       	out	0x3b, r0	; 59
    1dc8:	0f 90       	pop	r0
    1dca:	0f be       	out	0x3f, r0	; 63
    1dcc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1dce:	08 95       	ret

00001dd0 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1dd0:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <vPortYieldFromTick>
		asm volatile ( "reti" );
    1dd4:	18 95       	reti

00001dd6 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1dd6:	cf 93       	push	r28
    1dd8:	df 93       	push	r29
    1dda:	ec 01       	movw	r28, r24
    1ddc:	88 a1       	ldd	r24, Y+32	; 0x20
    1dde:	81 11       	cpse	r24, r1
    1de0:	0b c0       	rjmp	.+22     	; 0x1df8 <prvCopyDataToQueue+0x22>
    1de2:	88 81       	ld	r24, Y
    1de4:	99 81       	ldd	r25, Y+1	; 0x01
    1de6:	89 2b       	or	r24, r25
    1de8:	e1 f5       	brne	.+120    	; 0x1e62 <prvCopyDataToQueue+0x8c>
    1dea:	8a 81       	ldd	r24, Y+2	; 0x02
    1dec:	9b 81       	ldd	r25, Y+3	; 0x03
    1dee:	0e 94 ff 16 	call	0x2dfe	; 0x2dfe <vTaskPriorityDisinherit>
    1df2:	1a 82       	std	Y+2, r1	; 0x02
    1df4:	1b 82       	std	Y+3, r1	; 0x03
    1df6:	35 c0       	rjmp	.+106    	; 0x1e62 <prvCopyDataToQueue+0x8c>
    1df8:	41 11       	cpse	r20, r1
    1dfa:	17 c0       	rjmp	.+46     	; 0x1e2a <prvCopyDataToQueue+0x54>
    1dfc:	48 2f       	mov	r20, r24
    1dfe:	50 e0       	ldi	r21, 0x00	; 0
    1e00:	8c 81       	ldd	r24, Y+4	; 0x04
    1e02:	9d 81       	ldd	r25, Y+5	; 0x05
    1e04:	0e 94 77 22 	call	0x44ee	; 0x44ee <memcpy>
    1e08:	28 a1       	ldd	r18, Y+32	; 0x20
    1e0a:	8c 81       	ldd	r24, Y+4	; 0x04
    1e0c:	9d 81       	ldd	r25, Y+5	; 0x05
    1e0e:	82 0f       	add	r24, r18
    1e10:	91 1d       	adc	r25, r1
    1e12:	8c 83       	std	Y+4, r24	; 0x04
    1e14:	9d 83       	std	Y+5, r25	; 0x05
    1e16:	2a 81       	ldd	r18, Y+2	; 0x02
    1e18:	3b 81       	ldd	r19, Y+3	; 0x03
    1e1a:	82 17       	cp	r24, r18
    1e1c:	93 07       	cpc	r25, r19
    1e1e:	08 f1       	brcs	.+66     	; 0x1e62 <prvCopyDataToQueue+0x8c>
    1e20:	88 81       	ld	r24, Y
    1e22:	99 81       	ldd	r25, Y+1	; 0x01
    1e24:	8c 83       	std	Y+4, r24	; 0x04
    1e26:	9d 83       	std	Y+5, r25	; 0x05
    1e28:	1c c0       	rjmp	.+56     	; 0x1e62 <prvCopyDataToQueue+0x8c>
    1e2a:	48 2f       	mov	r20, r24
    1e2c:	50 e0       	ldi	r21, 0x00	; 0
    1e2e:	8e 81       	ldd	r24, Y+6	; 0x06
    1e30:	9f 81       	ldd	r25, Y+7	; 0x07
    1e32:	0e 94 77 22 	call	0x44ee	; 0x44ee <memcpy>
    1e36:	88 a1       	ldd	r24, Y+32	; 0x20
    1e38:	90 e0       	ldi	r25, 0x00	; 0
    1e3a:	91 95       	neg	r25
    1e3c:	81 95       	neg	r24
    1e3e:	91 09       	sbc	r25, r1
    1e40:	2e 81       	ldd	r18, Y+6	; 0x06
    1e42:	3f 81       	ldd	r19, Y+7	; 0x07
    1e44:	28 0f       	add	r18, r24
    1e46:	39 1f       	adc	r19, r25
    1e48:	2e 83       	std	Y+6, r18	; 0x06
    1e4a:	3f 83       	std	Y+7, r19	; 0x07
    1e4c:	48 81       	ld	r20, Y
    1e4e:	59 81       	ldd	r21, Y+1	; 0x01
    1e50:	24 17       	cp	r18, r20
    1e52:	35 07       	cpc	r19, r21
    1e54:	30 f4       	brcc	.+12     	; 0x1e62 <prvCopyDataToQueue+0x8c>
    1e56:	2a 81       	ldd	r18, Y+2	; 0x02
    1e58:	3b 81       	ldd	r19, Y+3	; 0x03
    1e5a:	82 0f       	add	r24, r18
    1e5c:	93 1f       	adc	r25, r19
    1e5e:	8e 83       	std	Y+6, r24	; 0x06
    1e60:	9f 83       	std	Y+7, r25	; 0x07
    1e62:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e64:	8f 5f       	subi	r24, 0xFF	; 255
    1e66:	8e 8f       	std	Y+30, r24	; 0x1e
    1e68:	df 91       	pop	r29
    1e6a:	cf 91       	pop	r28
    1e6c:	08 95       	ret

00001e6e <prvCopyDataFromQueue>:
    1e6e:	fc 01       	movw	r30, r24
    1e70:	80 81       	ld	r24, Z
    1e72:	91 81       	ldd	r25, Z+1	; 0x01
    1e74:	00 97       	sbiw	r24, 0x00	; 0
    1e76:	a1 f0       	breq	.+40     	; 0x1ea0 <prvCopyDataFromQueue+0x32>
    1e78:	40 a1       	ldd	r20, Z+32	; 0x20
    1e7a:	50 e0       	ldi	r21, 0x00	; 0
    1e7c:	26 81       	ldd	r18, Z+6	; 0x06
    1e7e:	37 81       	ldd	r19, Z+7	; 0x07
    1e80:	24 0f       	add	r18, r20
    1e82:	35 1f       	adc	r19, r21
    1e84:	26 83       	std	Z+6, r18	; 0x06
    1e86:	37 83       	std	Z+7, r19	; 0x07
    1e88:	a2 81       	ldd	r26, Z+2	; 0x02
    1e8a:	b3 81       	ldd	r27, Z+3	; 0x03
    1e8c:	2a 17       	cp	r18, r26
    1e8e:	3b 07       	cpc	r19, r27
    1e90:	10 f0       	brcs	.+4      	; 0x1e96 <prvCopyDataFromQueue+0x28>
    1e92:	86 83       	std	Z+6, r24	; 0x06
    1e94:	97 83       	std	Z+7, r25	; 0x07
    1e96:	cb 01       	movw	r24, r22
    1e98:	66 81       	ldd	r22, Z+6	; 0x06
    1e9a:	77 81       	ldd	r23, Z+7	; 0x07
    1e9c:	0e 94 77 22 	call	0x44ee	; 0x44ee <memcpy>
    1ea0:	08 95       	ret

00001ea2 <prvUnlockQueue>:
    1ea2:	0f 93       	push	r16
    1ea4:	1f 93       	push	r17
    1ea6:	cf 93       	push	r28
    1ea8:	df 93       	push	r29
    1eaa:	ec 01       	movw	r28, r24
    1eac:	0f b6       	in	r0, 0x3f	; 63
    1eae:	f8 94       	cli
    1eb0:	0f 92       	push	r0
    1eb2:	8a a1       	ldd	r24, Y+34	; 0x22
    1eb4:	18 16       	cp	r1, r24
    1eb6:	b4 f4       	brge	.+44     	; 0x1ee4 <prvUnlockQueue+0x42>
    1eb8:	8b 89       	ldd	r24, Y+19	; 0x13
    1eba:	81 11       	cpse	r24, r1
    1ebc:	05 c0       	rjmp	.+10     	; 0x1ec8 <prvUnlockQueue+0x26>
    1ebe:	12 c0       	rjmp	.+36     	; 0x1ee4 <prvUnlockQueue+0x42>
    1ec0:	8b 89       	ldd	r24, Y+19	; 0x13
    1ec2:	81 11       	cpse	r24, r1
    1ec4:	04 c0       	rjmp	.+8      	; 0x1ece <prvUnlockQueue+0x2c>
    1ec6:	0e c0       	rjmp	.+28     	; 0x1ee4 <prvUnlockQueue+0x42>
    1ec8:	8e 01       	movw	r16, r28
    1eca:	0d 5e       	subi	r16, 0xED	; 237
    1ecc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ece:	c8 01       	movw	r24, r16
    1ed0:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <xTaskRemoveFromEventList>
    1ed4:	81 11       	cpse	r24, r1
    1ed6:	0e 94 88 16 	call	0x2d10	; 0x2d10 <vTaskMissedYield>
    1eda:	8a a1       	ldd	r24, Y+34	; 0x22
    1edc:	81 50       	subi	r24, 0x01	; 1
    1ede:	8a a3       	std	Y+34, r24	; 0x22
    1ee0:	18 16       	cp	r1, r24
    1ee2:	74 f3       	brlt	.-36     	; 0x1ec0 <prvUnlockQueue+0x1e>
    1ee4:	8f ef       	ldi	r24, 0xFF	; 255
    1ee6:	8a a3       	std	Y+34, r24	; 0x22
    1ee8:	0f 90       	pop	r0
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	0f b6       	in	r0, 0x3f	; 63
    1eee:	f8 94       	cli
    1ef0:	0f 92       	push	r0
    1ef2:	89 a1       	ldd	r24, Y+33	; 0x21
    1ef4:	18 16       	cp	r1, r24
    1ef6:	b4 f4       	brge	.+44     	; 0x1f24 <prvUnlockQueue+0x82>
    1ef8:	88 85       	ldd	r24, Y+8	; 0x08
    1efa:	81 11       	cpse	r24, r1
    1efc:	05 c0       	rjmp	.+10     	; 0x1f08 <prvUnlockQueue+0x66>
    1efe:	12 c0       	rjmp	.+36     	; 0x1f24 <prvUnlockQueue+0x82>
    1f00:	88 85       	ldd	r24, Y+8	; 0x08
    1f02:	81 11       	cpse	r24, r1
    1f04:	04 c0       	rjmp	.+8      	; 0x1f0e <prvUnlockQueue+0x6c>
    1f06:	0e c0       	rjmp	.+28     	; 0x1f24 <prvUnlockQueue+0x82>
    1f08:	8e 01       	movw	r16, r28
    1f0a:	08 5f       	subi	r16, 0xF8	; 248
    1f0c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f0e:	c8 01       	movw	r24, r16
    1f10:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <xTaskRemoveFromEventList>
    1f14:	81 11       	cpse	r24, r1
    1f16:	0e 94 88 16 	call	0x2d10	; 0x2d10 <vTaskMissedYield>
    1f1a:	89 a1       	ldd	r24, Y+33	; 0x21
    1f1c:	81 50       	subi	r24, 0x01	; 1
    1f1e:	89 a3       	std	Y+33, r24	; 0x21
    1f20:	18 16       	cp	r1, r24
    1f22:	74 f3       	brlt	.-36     	; 0x1f00 <prvUnlockQueue+0x5e>
    1f24:	8f ef       	ldi	r24, 0xFF	; 255
    1f26:	89 a3       	std	Y+33, r24	; 0x21
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63
    1f2c:	df 91       	pop	r29
    1f2e:	cf 91       	pop	r28
    1f30:	1f 91       	pop	r17
    1f32:	0f 91       	pop	r16
    1f34:	08 95       	ret

00001f36 <xQueueGenericReset>:
    1f36:	1f 93       	push	r17
    1f38:	cf 93       	push	r28
    1f3a:	df 93       	push	r29
    1f3c:	61 30       	cpi	r22, 0x01	; 1
    1f3e:	59 f0       	breq	.+22     	; 0x1f56 <xQueueGenericReset+0x20>
    1f40:	fc 01       	movw	r30, r24
    1f42:	23 89       	ldd	r18, Z+19	; 0x13
    1f44:	30 85       	ldd	r19, Z+8	; 0x08
    1f46:	31 11       	cpse	r19, r1
    1f48:	2c c0       	rjmp	.+88     	; 0x1fa2 <xQueueGenericReset+0x6c>
    1f4a:	11 e0       	ldi	r17, 0x01	; 1
    1f4c:	21 11       	cpse	r18, r1
    1f4e:	10 e0       	ldi	r17, 0x00	; 0
    1f50:	21 11       	cpse	r18, r1
    1f52:	28 c0       	rjmp	.+80     	; 0x1fa4 <xQueueGenericReset+0x6e>
    1f54:	01 c0       	rjmp	.+2      	; 0x1f58 <xQueueGenericReset+0x22>
    1f56:	11 e0       	ldi	r17, 0x01	; 1
    1f58:	ec 01       	movw	r28, r24
    1f5a:	48 81       	ld	r20, Y
    1f5c:	59 81       	ldd	r21, Y+1	; 0x01
    1f5e:	28 a1       	ldd	r18, Y+32	; 0x20
    1f60:	30 e0       	ldi	r19, 0x00	; 0
    1f62:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1f64:	62 9f       	mul	r22, r18
    1f66:	c0 01       	movw	r24, r0
    1f68:	63 9f       	mul	r22, r19
    1f6a:	90 0d       	add	r25, r0
    1f6c:	11 24       	eor	r1, r1
    1f6e:	ba 01       	movw	r22, r20
    1f70:	68 0f       	add	r22, r24
    1f72:	79 1f       	adc	r23, r25
    1f74:	6a 83       	std	Y+2, r22	; 0x02
    1f76:	7b 83       	std	Y+3, r23	; 0x03
    1f78:	1e 8e       	std	Y+30, r1	; 0x1e
    1f7a:	4c 83       	std	Y+4, r20	; 0x04
    1f7c:	5d 83       	std	Y+5, r21	; 0x05
    1f7e:	82 1b       	sub	r24, r18
    1f80:	93 0b       	sbc	r25, r19
    1f82:	84 0f       	add	r24, r20
    1f84:	95 1f       	adc	r25, r21
    1f86:	8e 83       	std	Y+6, r24	; 0x06
    1f88:	9f 83       	std	Y+7, r25	; 0x07
    1f8a:	8f ef       	ldi	r24, 0xFF	; 255
    1f8c:	89 a3       	std	Y+33, r24	; 0x21
    1f8e:	8a a3       	std	Y+34, r24	; 0x22
    1f90:	ce 01       	movw	r24, r28
    1f92:	08 96       	adiw	r24, 0x08	; 8
    1f94:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    1f98:	ce 01       	movw	r24, r28
    1f9a:	43 96       	adiw	r24, 0x13	; 19
    1f9c:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    1fa0:	01 c0       	rjmp	.+2      	; 0x1fa4 <xQueueGenericReset+0x6e>
    1fa2:	10 e0       	ldi	r17, 0x00	; 0
    1fa4:	81 2f       	mov	r24, r17
    1fa6:	df 91       	pop	r29
    1fa8:	cf 91       	pop	r28
    1faa:	1f 91       	pop	r17
    1fac:	08 95       	ret

00001fae <xQueueGenericCreate>:
    1fae:	0f 93       	push	r16
    1fb0:	1f 93       	push	r17
    1fb2:	cf 93       	push	r28
    1fb4:	df 93       	push	r29
    1fb6:	88 23       	and	r24, r24
    1fb8:	01 f1       	breq	.+64     	; 0x1ffa <xQueueGenericCreate+0x4c>
    1fba:	06 2f       	mov	r16, r22
    1fbc:	18 2f       	mov	r17, r24
    1fbe:	83 e2       	ldi	r24, 0x23	; 35
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <pvPortMalloc>
    1fc6:	ec 01       	movw	r28, r24
    1fc8:	89 2b       	or	r24, r25
    1fca:	c9 f0       	breq	.+50     	; 0x1ffe <xQueueGenericCreate+0x50>
    1fcc:	10 9f       	mul	r17, r16
    1fce:	c0 01       	movw	r24, r0
    1fd0:	11 24       	eor	r1, r1
    1fd2:	01 96       	adiw	r24, 0x01	; 1
    1fd4:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <pvPortMalloc>
    1fd8:	88 83       	st	Y, r24
    1fda:	99 83       	std	Y+1, r25	; 0x01
    1fdc:	89 2b       	or	r24, r25
    1fde:	39 f0       	breq	.+14     	; 0x1fee <xQueueGenericCreate+0x40>
    1fe0:	1f 8f       	std	Y+31, r17	; 0x1f
    1fe2:	08 a3       	std	Y+32, r16	; 0x20
    1fe4:	61 e0       	ldi	r22, 0x01	; 1
    1fe6:	ce 01       	movw	r24, r28
    1fe8:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <xQueueGenericReset>
    1fec:	08 c0       	rjmp	.+16     	; 0x1ffe <xQueueGenericCreate+0x50>
    1fee:	ce 01       	movw	r24, r28
    1ff0:	0e 94 8b 0c 	call	0x1916	; 0x1916 <vPortFree>
    1ff4:	c0 e0       	ldi	r28, 0x00	; 0
    1ff6:	d0 e0       	ldi	r29, 0x00	; 0
    1ff8:	02 c0       	rjmp	.+4      	; 0x1ffe <xQueueGenericCreate+0x50>
    1ffa:	c0 e0       	ldi	r28, 0x00	; 0
    1ffc:	d0 e0       	ldi	r29, 0x00	; 0
    1ffe:	ce 01       	movw	r24, r28
    2000:	df 91       	pop	r29
    2002:	cf 91       	pop	r28
    2004:	1f 91       	pop	r17
    2006:	0f 91       	pop	r16
    2008:	08 95       	ret

0000200a <xQueueGenericSend>:
    200a:	af 92       	push	r10
    200c:	bf 92       	push	r11
    200e:	cf 92       	push	r12
    2010:	df 92       	push	r13
    2012:	ef 92       	push	r14
    2014:	ff 92       	push	r15
    2016:	0f 93       	push	r16
    2018:	1f 93       	push	r17
    201a:	cf 93       	push	r28
    201c:	df 93       	push	r29
    201e:	cd b7       	in	r28, 0x3d	; 61
    2020:	de b7       	in	r29, 0x3e	; 62
    2022:	29 97       	sbiw	r28, 0x09	; 9
    2024:	cd bf       	out	0x3d, r28	; 61
    2026:	de bf       	out	0x3e, r29	; 62
    2028:	7c 01       	movw	r14, r24
    202a:	5b 01       	movw	r10, r22
    202c:	2e 83       	std	Y+6, r18	; 0x06
    202e:	3f 83       	std	Y+7, r19	; 0x07
    2030:	48 87       	std	Y+8, r20	; 0x08
    2032:	59 87       	std	Y+9, r21	; 0x09
    2034:	10 e0       	ldi	r17, 0x00	; 0
    2036:	6c 01       	movw	r12, r24
    2038:	88 e0       	ldi	r24, 0x08	; 8
    203a:	c8 0e       	add	r12, r24
    203c:	d1 1c       	adc	r13, r1
    203e:	0f b6       	in	r0, 0x3f	; 63
    2040:	f8 94       	cli
    2042:	0f 92       	push	r0
    2044:	f7 01       	movw	r30, r14
    2046:	96 8d       	ldd	r25, Z+30	; 0x1e
    2048:	87 8d       	ldd	r24, Z+31	; 0x1f
    204a:	98 17       	cp	r25, r24
    204c:	a8 f4       	brcc	.+42     	; 0x2078 <xQueueGenericSend+0x6e>
    204e:	40 2f       	mov	r20, r16
    2050:	b5 01       	movw	r22, r10
    2052:	c7 01       	movw	r24, r14
    2054:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <prvCopyDataToQueue>
    2058:	f7 01       	movw	r30, r14
    205a:	83 89       	ldd	r24, Z+19	; 0x13
    205c:	88 23       	and	r24, r24
    205e:	41 f0       	breq	.+16     	; 0x2070 <xQueueGenericSend+0x66>
    2060:	c7 01       	movw	r24, r14
    2062:	43 96       	adiw	r24, 0x13	; 19
    2064:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <xTaskRemoveFromEventList>
    2068:	81 30       	cpi	r24, 0x01	; 1
    206a:	11 f4       	brne	.+4      	; 0x2070 <xQueueGenericSend+0x66>
    206c:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
    2070:	0f 90       	pop	r0
    2072:	0f be       	out	0x3f, r0	; 63
    2074:	81 e0       	ldi	r24, 0x01	; 1
    2076:	56 c0       	rjmp	.+172    	; 0x2124 <xQueueGenericSend+0x11a>
    2078:	8e 81       	ldd	r24, Y+6	; 0x06
    207a:	9f 81       	ldd	r25, Y+7	; 0x07
    207c:	a8 85       	ldd	r26, Y+8	; 0x08
    207e:	b9 85       	ldd	r27, Y+9	; 0x09
    2080:	89 2b       	or	r24, r25
    2082:	8a 2b       	or	r24, r26
    2084:	8b 2b       	or	r24, r27
    2086:	21 f4       	brne	.+8      	; 0x2090 <xQueueGenericSend+0x86>
    2088:	0f 90       	pop	r0
    208a:	0f be       	out	0x3f, r0	; 63
    208c:	80 e0       	ldi	r24, 0x00	; 0
    208e:	4a c0       	rjmp	.+148    	; 0x2124 <xQueueGenericSend+0x11a>
    2090:	11 11       	cpse	r17, r1
    2092:	05 c0       	rjmp	.+10     	; 0x209e <xQueueGenericSend+0x94>
    2094:	ce 01       	movw	r24, r28
    2096:	01 96       	adiw	r24, 0x01	; 1
    2098:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <vTaskSetTimeOutState>
    209c:	11 e0       	ldi	r17, 0x01	; 1
    209e:	0f 90       	pop	r0
    20a0:	0f be       	out	0x3f, r0	; 63
    20a2:	0e 94 05 13 	call	0x260a	; 0x260a <vTaskSuspendAll>
    20a6:	0f b6       	in	r0, 0x3f	; 63
    20a8:	f8 94       	cli
    20aa:	0f 92       	push	r0
    20ac:	f7 01       	movw	r30, r14
    20ae:	81 a1       	ldd	r24, Z+33	; 0x21
    20b0:	8f 3f       	cpi	r24, 0xFF	; 255
    20b2:	09 f4       	brne	.+2      	; 0x20b6 <xQueueGenericSend+0xac>
    20b4:	11 a2       	std	Z+33, r1	; 0x21
    20b6:	f7 01       	movw	r30, r14
    20b8:	82 a1       	ldd	r24, Z+34	; 0x22
    20ba:	8f 3f       	cpi	r24, 0xFF	; 255
    20bc:	09 f4       	brne	.+2      	; 0x20c0 <xQueueGenericSend+0xb6>
    20be:	12 a2       	std	Z+34, r1	; 0x22
    20c0:	0f 90       	pop	r0
    20c2:	0f be       	out	0x3f, r0	; 63
    20c4:	be 01       	movw	r22, r28
    20c6:	6a 5f       	subi	r22, 0xFA	; 250
    20c8:	7f 4f       	sbci	r23, 0xFF	; 255
    20ca:	ce 01       	movw	r24, r28
    20cc:	01 96       	adiw	r24, 0x01	; 1
    20ce:	0e 94 1b 16 	call	0x2c36	; 0x2c36 <xTaskCheckForTimeOut>
    20d2:	81 11       	cpse	r24, r1
    20d4:	21 c0       	rjmp	.+66     	; 0x2118 <xQueueGenericSend+0x10e>
    20d6:	0f b6       	in	r0, 0x3f	; 63
    20d8:	f8 94       	cli
    20da:	0f 92       	push	r0
    20dc:	f7 01       	movw	r30, r14
    20de:	96 8d       	ldd	r25, Z+30	; 0x1e
    20e0:	0f 90       	pop	r0
    20e2:	0f be       	out	0x3f, r0	; 63
    20e4:	87 8d       	ldd	r24, Z+31	; 0x1f
    20e6:	98 13       	cpse	r25, r24
    20e8:	11 c0       	rjmp	.+34     	; 0x210c <xQueueGenericSend+0x102>
    20ea:	4e 81       	ldd	r20, Y+6	; 0x06
    20ec:	5f 81       	ldd	r21, Y+7	; 0x07
    20ee:	68 85       	ldd	r22, Y+8	; 0x08
    20f0:	79 85       	ldd	r23, Y+9	; 0x09
    20f2:	c6 01       	movw	r24, r12
    20f4:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <vTaskPlaceOnEventList>
    20f8:	c7 01       	movw	r24, r14
    20fa:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <prvUnlockQueue>
    20fe:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
    2102:	81 11       	cpse	r24, r1
    2104:	9c cf       	rjmp	.-200    	; 0x203e <xQueueGenericSend+0x34>
    2106:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
    210a:	99 cf       	rjmp	.-206    	; 0x203e <xQueueGenericSend+0x34>
    210c:	c7 01       	movw	r24, r14
    210e:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <prvUnlockQueue>
    2112:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
    2116:	93 cf       	rjmp	.-218    	; 0x203e <xQueueGenericSend+0x34>
    2118:	c7 01       	movw	r24, r14
    211a:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <prvUnlockQueue>
    211e:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
    2122:	80 e0       	ldi	r24, 0x00	; 0
    2124:	29 96       	adiw	r28, 0x09	; 9
    2126:	cd bf       	out	0x3d, r28	; 61
    2128:	de bf       	out	0x3e, r29	; 62
    212a:	df 91       	pop	r29
    212c:	cf 91       	pop	r28
    212e:	1f 91       	pop	r17
    2130:	0f 91       	pop	r16
    2132:	ff 90       	pop	r15
    2134:	ef 90       	pop	r14
    2136:	df 90       	pop	r13
    2138:	cf 90       	pop	r12
    213a:	bf 90       	pop	r11
    213c:	af 90       	pop	r10
    213e:	08 95       	ret

00002140 <xQueueGenericReceive>:
    2140:	af 92       	push	r10
    2142:	bf 92       	push	r11
    2144:	cf 92       	push	r12
    2146:	df 92       	push	r13
    2148:	ef 92       	push	r14
    214a:	ff 92       	push	r15
    214c:	0f 93       	push	r16
    214e:	1f 93       	push	r17
    2150:	cf 93       	push	r28
    2152:	df 93       	push	r29
    2154:	cd b7       	in	r28, 0x3d	; 61
    2156:	de b7       	in	r29, 0x3e	; 62
    2158:	29 97       	sbiw	r28, 0x09	; 9
    215a:	cd bf       	out	0x3d, r28	; 61
    215c:	de bf       	out	0x3e, r29	; 62
    215e:	7c 01       	movw	r14, r24
    2160:	5b 01       	movw	r10, r22
    2162:	2e 83       	std	Y+6, r18	; 0x06
    2164:	3f 83       	std	Y+7, r19	; 0x07
    2166:	48 87       	std	Y+8, r20	; 0x08
    2168:	59 87       	std	Y+9, r21	; 0x09
    216a:	10 e0       	ldi	r17, 0x00	; 0
    216c:	6c 01       	movw	r12, r24
    216e:	83 e1       	ldi	r24, 0x13	; 19
    2170:	c8 0e       	add	r12, r24
    2172:	d1 1c       	adc	r13, r1
    2174:	0f b6       	in	r0, 0x3f	; 63
    2176:	f8 94       	cli
    2178:	0f 92       	push	r0
    217a:	f7 01       	movw	r30, r14
    217c:	86 8d       	ldd	r24, Z+30	; 0x1e
    217e:	88 23       	and	r24, r24
    2180:	99 f1       	breq	.+102    	; 0x21e8 <xQueueGenericReceive+0xa8>
    2182:	c6 80       	ldd	r12, Z+6	; 0x06
    2184:	d7 80       	ldd	r13, Z+7	; 0x07
    2186:	b5 01       	movw	r22, r10
    2188:	c7 01       	movw	r24, r14
    218a:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <prvCopyDataFromQueue>
    218e:	01 11       	cpse	r16, r1
    2190:	1a c0       	rjmp	.+52     	; 0x21c6 <xQueueGenericReceive+0x86>
    2192:	f7 01       	movw	r30, r14
    2194:	86 8d       	ldd	r24, Z+30	; 0x1e
    2196:	81 50       	subi	r24, 0x01	; 1
    2198:	86 8f       	std	Z+30, r24	; 0x1e
    219a:	80 81       	ld	r24, Z
    219c:	91 81       	ldd	r25, Z+1	; 0x01
    219e:	89 2b       	or	r24, r25
    21a0:	29 f4       	brne	.+10     	; 0x21ac <xQueueGenericReceive+0x6c>
    21a2:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <xTaskGetCurrentTaskHandle>
    21a6:	f7 01       	movw	r30, r14
    21a8:	82 83       	std	Z+2, r24	; 0x02
    21aa:	93 83       	std	Z+3, r25	; 0x03
    21ac:	f7 01       	movw	r30, r14
    21ae:	80 85       	ldd	r24, Z+8	; 0x08
    21b0:	88 23       	and	r24, r24
    21b2:	b1 f0       	breq	.+44     	; 0x21e0 <xQueueGenericReceive+0xa0>
    21b4:	c7 01       	movw	r24, r14
    21b6:	08 96       	adiw	r24, 0x08	; 8
    21b8:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <xTaskRemoveFromEventList>
    21bc:	81 30       	cpi	r24, 0x01	; 1
    21be:	81 f4       	brne	.+32     	; 0x21e0 <xQueueGenericReceive+0xa0>
    21c0:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
    21c4:	0d c0       	rjmp	.+26     	; 0x21e0 <xQueueGenericReceive+0xa0>
    21c6:	f7 01       	movw	r30, r14
    21c8:	c6 82       	std	Z+6, r12	; 0x06
    21ca:	d7 82       	std	Z+7, r13	; 0x07
    21cc:	83 89       	ldd	r24, Z+19	; 0x13
    21ce:	88 23       	and	r24, r24
    21d0:	39 f0       	breq	.+14     	; 0x21e0 <xQueueGenericReceive+0xa0>
    21d2:	c7 01       	movw	r24, r14
    21d4:	43 96       	adiw	r24, 0x13	; 19
    21d6:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <xTaskRemoveFromEventList>
    21da:	81 11       	cpse	r24, r1
    21dc:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
    21e0:	0f 90       	pop	r0
    21e2:	0f be       	out	0x3f, r0	; 63
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	62 c0       	rjmp	.+196    	; 0x22ac <xQueueGenericReceive+0x16c>
    21e8:	8e 81       	ldd	r24, Y+6	; 0x06
    21ea:	9f 81       	ldd	r25, Y+7	; 0x07
    21ec:	a8 85       	ldd	r26, Y+8	; 0x08
    21ee:	b9 85       	ldd	r27, Y+9	; 0x09
    21f0:	89 2b       	or	r24, r25
    21f2:	8a 2b       	or	r24, r26
    21f4:	8b 2b       	or	r24, r27
    21f6:	21 f4       	brne	.+8      	; 0x2200 <xQueueGenericReceive+0xc0>
    21f8:	0f 90       	pop	r0
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	80 e0       	ldi	r24, 0x00	; 0
    21fe:	56 c0       	rjmp	.+172    	; 0x22ac <xQueueGenericReceive+0x16c>
    2200:	11 11       	cpse	r17, r1
    2202:	05 c0       	rjmp	.+10     	; 0x220e <xQueueGenericReceive+0xce>
    2204:	ce 01       	movw	r24, r28
    2206:	01 96       	adiw	r24, 0x01	; 1
    2208:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <vTaskSetTimeOutState>
    220c:	11 e0       	ldi	r17, 0x01	; 1
    220e:	0f 90       	pop	r0
    2210:	0f be       	out	0x3f, r0	; 63
    2212:	0e 94 05 13 	call	0x260a	; 0x260a <vTaskSuspendAll>
    2216:	0f b6       	in	r0, 0x3f	; 63
    2218:	f8 94       	cli
    221a:	0f 92       	push	r0
    221c:	f7 01       	movw	r30, r14
    221e:	81 a1       	ldd	r24, Z+33	; 0x21
    2220:	8f 3f       	cpi	r24, 0xFF	; 255
    2222:	09 f4       	brne	.+2      	; 0x2226 <xQueueGenericReceive+0xe6>
    2224:	11 a2       	std	Z+33, r1	; 0x21
    2226:	f7 01       	movw	r30, r14
    2228:	82 a1       	ldd	r24, Z+34	; 0x22
    222a:	8f 3f       	cpi	r24, 0xFF	; 255
    222c:	09 f4       	brne	.+2      	; 0x2230 <xQueueGenericReceive+0xf0>
    222e:	12 a2       	std	Z+34, r1	; 0x22
    2230:	0f 90       	pop	r0
    2232:	0f be       	out	0x3f, r0	; 63
    2234:	be 01       	movw	r22, r28
    2236:	6a 5f       	subi	r22, 0xFA	; 250
    2238:	7f 4f       	sbci	r23, 0xFF	; 255
    223a:	ce 01       	movw	r24, r28
    223c:	01 96       	adiw	r24, 0x01	; 1
    223e:	0e 94 1b 16 	call	0x2c36	; 0x2c36 <xTaskCheckForTimeOut>
    2242:	81 11       	cpse	r24, r1
    2244:	2d c0       	rjmp	.+90     	; 0x22a0 <xQueueGenericReceive+0x160>
    2246:	0f b6       	in	r0, 0x3f	; 63
    2248:	f8 94       	cli
    224a:	0f 92       	push	r0
    224c:	f7 01       	movw	r30, r14
    224e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2250:	0f 90       	pop	r0
    2252:	0f be       	out	0x3f, r0	; 63
    2254:	81 11       	cpse	r24, r1
    2256:	1e c0       	rjmp	.+60     	; 0x2294 <xQueueGenericReceive+0x154>
    2258:	80 81       	ld	r24, Z
    225a:	91 81       	ldd	r25, Z+1	; 0x01
    225c:	89 2b       	or	r24, r25
    225e:	49 f4       	brne	.+18     	; 0x2272 <xQueueGenericReceive+0x132>
    2260:	0f b6       	in	r0, 0x3f	; 63
    2262:	f8 94       	cli
    2264:	0f 92       	push	r0
    2266:	82 81       	ldd	r24, Z+2	; 0x02
    2268:	93 81       	ldd	r25, Z+3	; 0x03
    226a:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <vTaskPriorityInherit>
    226e:	0f 90       	pop	r0
    2270:	0f be       	out	0x3f, r0	; 63
    2272:	4e 81       	ldd	r20, Y+6	; 0x06
    2274:	5f 81       	ldd	r21, Y+7	; 0x07
    2276:	68 85       	ldd	r22, Y+8	; 0x08
    2278:	79 85       	ldd	r23, Y+9	; 0x09
    227a:	c6 01       	movw	r24, r12
    227c:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <vTaskPlaceOnEventList>
    2280:	c7 01       	movw	r24, r14
    2282:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <prvUnlockQueue>
    2286:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
    228a:	81 11       	cpse	r24, r1
    228c:	73 cf       	rjmp	.-282    	; 0x2174 <xQueueGenericReceive+0x34>
    228e:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
    2292:	70 cf       	rjmp	.-288    	; 0x2174 <xQueueGenericReceive+0x34>
    2294:	c7 01       	movw	r24, r14
    2296:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <prvUnlockQueue>
    229a:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
    229e:	6a cf       	rjmp	.-300    	; 0x2174 <xQueueGenericReceive+0x34>
    22a0:	c7 01       	movw	r24, r14
    22a2:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <prvUnlockQueue>
    22a6:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
    22aa:	80 e0       	ldi	r24, 0x00	; 0
    22ac:	29 96       	adiw	r28, 0x09	; 9
    22ae:	cd bf       	out	0x3d, r28	; 61
    22b0:	de bf       	out	0x3e, r29	; 62
    22b2:	df 91       	pop	r29
    22b4:	cf 91       	pop	r28
    22b6:	1f 91       	pop	r17
    22b8:	0f 91       	pop	r16
    22ba:	ff 90       	pop	r15
    22bc:	ef 90       	pop	r14
    22be:	df 90       	pop	r13
    22c0:	cf 90       	pop	r12
    22c2:	bf 90       	pop	r11
    22c4:	af 90       	pop	r10
    22c6:	08 95       	ret

000022c8 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    22c8:	0f b6       	in	r0, 0x3f	; 63
    22ca:	f8 94       	cli
    22cc:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    22ce:	fc 01       	movw	r30, r24
    22d0:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    22d2:	0f 90       	pop	r0
    22d4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    22d6:	08 95       	ret

000022d8 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    22d8:	c8 ef       	ldi	r28, 0xF8	; 248
    22da:	d0 e3       	ldi	r29, 0x30	; 48
    22dc:	88 81       	ld	r24, Y
    22de:	82 30       	cpi	r24, 0x02	; 2
    22e0:	e8 f3       	brcs	.-6      	; 0x22dc <prvIdleTask+0x4>
    22e2:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
    22e6:	fa cf       	rjmp	.-12     	; 0x22dc <prvIdleTask+0x4>

000022e8 <prvAddCurrentTaskToDelayedList>:
    22e8:	cf 92       	push	r12
    22ea:	df 92       	push	r13
    22ec:	ef 92       	push	r14
    22ee:	ff 92       	push	r15
    22f0:	6b 01       	movw	r12, r22
    22f2:	7c 01       	movw	r14, r24
    22f4:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    22f8:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    22fc:	62 83       	std	Z+2, r22	; 0x02
    22fe:	73 83       	std	Z+3, r23	; 0x03
    2300:	84 83       	std	Z+4, r24	; 0x04
    2302:	95 83       	std	Z+5, r25	; 0x05
    2304:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2308:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    230c:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2310:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2314:	c8 16       	cp	r12, r24
    2316:	d9 06       	cpc	r13, r25
    2318:	ea 06       	cpc	r14, r26
    231a:	fb 06       	cpc	r15, r27
    231c:	68 f4       	brcc	.+26     	; 0x2338 <prvAddCurrentTaskToDelayedList+0x50>
    231e:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2322:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2326:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    232a:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    232e:	6e 5f       	subi	r22, 0xFE	; 254
    2330:	7f 4f       	sbci	r23, 0xFF	; 255
    2332:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListInsert>
    2336:	21 c0       	rjmp	.+66     	; 0x237a <prvAddCurrentTaskToDelayedList+0x92>
    2338:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    233c:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2340:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2344:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2348:	6e 5f       	subi	r22, 0xFE	; 254
    234a:	7f 4f       	sbci	r23, 0xFF	; 255
    234c:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListInsert>
    2350:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2354:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2358:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    235c:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2360:	c8 16       	cp	r12, r24
    2362:	d9 06       	cpc	r13, r25
    2364:	ea 06       	cpc	r14, r26
    2366:	fb 06       	cpc	r15, r27
    2368:	40 f4       	brcc	.+16     	; 0x237a <prvAddCurrentTaskToDelayedList+0x92>
    236a:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    236e:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    2372:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2376:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    237a:	ff 90       	pop	r15
    237c:	ef 90       	pop	r14
    237e:	df 90       	pop	r13
    2380:	cf 90       	pop	r12
    2382:	08 95       	ret

00002384 <xTaskGenericCreate>:
    2384:	4f 92       	push	r4
    2386:	5f 92       	push	r5
    2388:	6f 92       	push	r6
    238a:	7f 92       	push	r7
    238c:	8f 92       	push	r8
    238e:	9f 92       	push	r9
    2390:	af 92       	push	r10
    2392:	bf 92       	push	r11
    2394:	cf 92       	push	r12
    2396:	df 92       	push	r13
    2398:	ef 92       	push	r14
    239a:	ff 92       	push	r15
    239c:	0f 93       	push	r16
    239e:	1f 93       	push	r17
    23a0:	cf 93       	push	r28
    23a2:	df 93       	push	r29
    23a4:	5c 01       	movw	r10, r24
    23a6:	4b 01       	movw	r8, r22
    23a8:	3a 01       	movw	r6, r20
    23aa:	29 01       	movw	r4, r18
    23ac:	88 e2       	ldi	r24, 0x28	; 40
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <pvPortMalloc>
    23b4:	ec 01       	movw	r28, r24
    23b6:	89 2b       	or	r24, r25
    23b8:	09 f4       	brne	.+2      	; 0x23bc <xTaskGenericCreate+0x38>
    23ba:	d4 c0       	rjmp	.+424    	; 0x2564 <xTaskGenericCreate+0x1e0>
    23bc:	c1 14       	cp	r12, r1
    23be:	d1 04       	cpc	r13, r1
    23c0:	09 f0       	breq	.+2      	; 0x23c4 <xTaskGenericCreate+0x40>
    23c2:	cc c0       	rjmp	.+408    	; 0x255c <xTaskGenericCreate+0x1d8>
    23c4:	c3 01       	movw	r24, r6
    23c6:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <pvPortMalloc>
    23ca:	8b 8f       	std	Y+27, r24	; 0x1b
    23cc:	9c 8f       	std	Y+28, r25	; 0x1c
    23ce:	00 97       	sbiw	r24, 0x00	; 0
    23d0:	21 f4       	brne	.+8      	; 0x23da <xTaskGenericCreate+0x56>
    23d2:	ce 01       	movw	r24, r28
    23d4:	0e 94 8b 0c 	call	0x1916	; 0x1916 <vPortFree>
    23d8:	c5 c0       	rjmp	.+394    	; 0x2564 <xTaskGenericCreate+0x1e0>
    23da:	a3 01       	movw	r20, r6
    23dc:	61 e1       	ldi	r22, 0x11	; 17
    23de:	70 e0       	ldi	r23, 0x00	; 0
    23e0:	0e 94 80 22 	call	0x4500	; 0x4500 <memset>
    23e4:	93 01       	movw	r18, r6
    23e6:	21 50       	subi	r18, 0x01	; 1
    23e8:	31 09       	sbc	r19, r1
    23ea:	8b 8d       	ldd	r24, Y+27	; 0x1b
    23ec:	9c 8d       	ldd	r25, Y+28	; 0x1c
    23ee:	3c 01       	movw	r6, r24
    23f0:	62 0e       	add	r6, r18
    23f2:	73 1e       	adc	r7, r19
    23f4:	4a e0       	ldi	r20, 0x0A	; 10
    23f6:	50 e0       	ldi	r21, 0x00	; 0
    23f8:	b4 01       	movw	r22, r8
    23fa:	ce 01       	movw	r24, r28
    23fc:	4d 96       	adiw	r24, 0x1d	; 29
    23fe:	0e 94 87 22 	call	0x450e	; 0x450e <strncpy>
    2402:	1e a2       	std	Y+38, r1	; 0x26
    2404:	10 2f       	mov	r17, r16
    2406:	04 30       	cpi	r16, 0x04	; 4
    2408:	08 f0       	brcs	.+2      	; 0x240c <xTaskGenericCreate+0x88>
    240a:	13 e0       	ldi	r17, 0x03	; 3
    240c:	1a 8f       	std	Y+26, r17	; 0x1a
    240e:	1f a3       	std	Y+39, r17	; 0x27
    2410:	6e 01       	movw	r12, r28
    2412:	22 e0       	ldi	r18, 0x02	; 2
    2414:	c2 0e       	add	r12, r18
    2416:	d1 1c       	adc	r13, r1
    2418:	c6 01       	movw	r24, r12
    241a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <vListInitialiseItem>
    241e:	ce 01       	movw	r24, r28
    2420:	0e 96       	adiw	r24, 0x0e	; 14
    2422:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <vListInitialiseItem>
    2426:	ca 87       	std	Y+10, r28	; 0x0a
    2428:	db 87       	std	Y+11, r29	; 0x0b
    242a:	84 e0       	ldi	r24, 0x04	; 4
    242c:	90 e0       	ldi	r25, 0x00	; 0
    242e:	a0 e0       	ldi	r26, 0x00	; 0
    2430:	b0 e0       	ldi	r27, 0x00	; 0
    2432:	81 1b       	sub	r24, r17
    2434:	91 09       	sbc	r25, r1
    2436:	a1 09       	sbc	r26, r1
    2438:	b1 09       	sbc	r27, r1
    243a:	8e 87       	std	Y+14, r24	; 0x0e
    243c:	9f 87       	std	Y+15, r25	; 0x0f
    243e:	a8 8b       	std	Y+16, r26	; 0x10
    2440:	b9 8b       	std	Y+17, r27	; 0x11
    2442:	ce 8b       	std	Y+22, r28	; 0x16
    2444:	df 8b       	std	Y+23, r29	; 0x17
    2446:	a2 01       	movw	r20, r4
    2448:	b5 01       	movw	r22, r10
    244a:	c3 01       	movw	r24, r6
    244c:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <pxPortInitialiseStack>
    2450:	88 83       	st	Y, r24
    2452:	99 83       	std	Y+1, r25	; 0x01
    2454:	e1 14       	cp	r14, r1
    2456:	f1 04       	cpc	r15, r1
    2458:	19 f0       	breq	.+6      	; 0x2460 <xTaskGenericCreate+0xdc>
    245a:	f7 01       	movw	r30, r14
    245c:	c0 83       	st	Z, r28
    245e:	d1 83       	std	Z+1, r29	; 0x01
    2460:	0f b6       	in	r0, 0x3f	; 63
    2462:	f8 94       	cli
    2464:	0f 92       	push	r0
    2466:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    246a:	8f 5f       	subi	r24, 0xFF	; 255
    246c:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    2470:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2474:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2478:	89 2b       	or	r24, r25
    247a:	89 f5       	brne	.+98     	; 0x24de <xTaskGenericCreate+0x15a>
    247c:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    2480:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    2484:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2488:	81 30       	cpi	r24, 0x01	; 1
    248a:	c1 f5       	brne	.+112    	; 0x24fc <xTaskGenericCreate+0x178>
    248c:	88 ef       	ldi	r24, 0xF8	; 248
    248e:	90 e3       	ldi	r25, 0x30	; 48
    2490:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    2494:	83 e0       	ldi	r24, 0x03	; 3
    2496:	91 e3       	ldi	r25, 0x31	; 49
    2498:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    249c:	8e e0       	ldi	r24, 0x0E	; 14
    249e:	91 e3       	ldi	r25, 0x31	; 49
    24a0:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    24a4:	89 e1       	ldi	r24, 0x19	; 25
    24a6:	91 e3       	ldi	r25, 0x31	; 49
    24a8:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    24ac:	8d ee       	ldi	r24, 0xED	; 237
    24ae:	90 e3       	ldi	r25, 0x30	; 48
    24b0:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    24b4:	82 ee       	ldi	r24, 0xE2	; 226
    24b6:	90 e3       	ldi	r25, 0x30	; 48
    24b8:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    24bc:	83 ed       	ldi	r24, 0xD3	; 211
    24be:	90 e3       	ldi	r25, 0x30	; 48
    24c0:	0e 94 c3 0c 	call	0x1986	; 0x1986 <vListInitialise>
    24c4:	8d ee       	ldi	r24, 0xED	; 237
    24c6:	90 e3       	ldi	r25, 0x30	; 48
    24c8:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    24cc:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    24d0:	82 ee       	ldi	r24, 0xE2	; 226
    24d2:	90 e3       	ldi	r25, 0x30	; 48
    24d4:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    24d8:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    24dc:	0f c0       	rjmp	.+30     	; 0x24fc <xTaskGenericCreate+0x178>
    24de:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    24e2:	81 11       	cpse	r24, r1
    24e4:	0b c0       	rjmp	.+22     	; 0x24fc <xTaskGenericCreate+0x178>
    24e6:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    24ea:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    24ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    24f0:	08 17       	cp	r16, r24
    24f2:	20 f0       	brcs	.+8      	; 0x24fc <xTaskGenericCreate+0x178>
    24f4:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    24f8:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    24fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    24fe:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    2502:	98 17       	cp	r25, r24
    2504:	10 f4       	brcc	.+4      	; 0x250a <xTaskGenericCreate+0x186>
    2506:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    250a:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    250e:	9f 5f       	subi	r25, 0xFF	; 255
    2510:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    2514:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2518:	98 17       	cp	r25, r24
    251a:	10 f4       	brcc	.+4      	; 0x2520 <xTaskGenericCreate+0x19c>
    251c:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2520:	fb e0       	ldi	r31, 0x0B	; 11
    2522:	8f 9f       	mul	r24, r31
    2524:	c0 01       	movw	r24, r0
    2526:	11 24       	eor	r1, r1
    2528:	b6 01       	movw	r22, r12
    252a:	88 50       	subi	r24, 0x08	; 8
    252c:	9f 4c       	sbci	r25, 0xCF	; 207
    252e:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInsertEnd>
    2532:	0f 90       	pop	r0
    2534:	0f be       	out	0x3f, r0	; 63
    2536:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    253a:	88 23       	and	r24, r24
    253c:	59 f0       	breq	.+22     	; 0x2554 <xTaskGenericCreate+0x1d0>
    253e:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2542:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2546:	82 8d       	ldd	r24, Z+26	; 0x1a
    2548:	80 17       	cp	r24, r16
    254a:	30 f4       	brcc	.+12     	; 0x2558 <xTaskGenericCreate+0x1d4>
    254c:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
    2550:	81 e0       	ldi	r24, 0x01	; 1
    2552:	09 c0       	rjmp	.+18     	; 0x2566 <xTaskGenericCreate+0x1e2>
    2554:	81 e0       	ldi	r24, 0x01	; 1
    2556:	07 c0       	rjmp	.+14     	; 0x2566 <xTaskGenericCreate+0x1e2>
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	05 c0       	rjmp	.+10     	; 0x2566 <xTaskGenericCreate+0x1e2>
    255c:	cb 8e       	std	Y+27, r12	; 0x1b
    255e:	dc 8e       	std	Y+28, r13	; 0x1c
    2560:	c6 01       	movw	r24, r12
    2562:	3b cf       	rjmp	.-394    	; 0x23da <xTaskGenericCreate+0x56>
    2564:	8f ef       	ldi	r24, 0xFF	; 255
    2566:	df 91       	pop	r29
    2568:	cf 91       	pop	r28
    256a:	1f 91       	pop	r17
    256c:	0f 91       	pop	r16
    256e:	ff 90       	pop	r15
    2570:	ef 90       	pop	r14
    2572:	df 90       	pop	r13
    2574:	cf 90       	pop	r12
    2576:	bf 90       	pop	r11
    2578:	af 90       	pop	r10
    257a:	9f 90       	pop	r9
    257c:	8f 90       	pop	r8
    257e:	7f 90       	pop	r7
    2580:	6f 90       	pop	r6
    2582:	5f 90       	pop	r5
    2584:	4f 90       	pop	r4
    2586:	08 95       	ret

00002588 <uxTaskPriorityGet>:
    2588:	0f b6       	in	r0, 0x3f	; 63
    258a:	f8 94       	cli
    258c:	0f 92       	push	r0
    258e:	00 97       	sbiw	r24, 0x00	; 0
    2590:	21 f4       	brne	.+8      	; 0x259a <uxTaskPriorityGet+0x12>
    2592:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2596:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    259a:	0f 90       	pop	r0
    259c:	0f be       	out	0x3f, r0	; 63
    259e:	fc 01       	movw	r30, r24
    25a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    25a2:	08 95       	ret

000025a4 <vTaskStartScheduler>:
    25a4:	af 92       	push	r10
    25a6:	bf 92       	push	r11
    25a8:	cf 92       	push	r12
    25aa:	df 92       	push	r13
    25ac:	ef 92       	push	r14
    25ae:	ff 92       	push	r15
    25b0:	0f 93       	push	r16
    25b2:	a1 2c       	mov	r10, r1
    25b4:	b1 2c       	mov	r11, r1
    25b6:	c1 2c       	mov	r12, r1
    25b8:	d1 2c       	mov	r13, r1
    25ba:	0f 2e       	mov	r0, r31
    25bc:	f1 ed       	ldi	r31, 0xD1	; 209
    25be:	ef 2e       	mov	r14, r31
    25c0:	f0 e3       	ldi	r31, 0x30	; 48
    25c2:	ff 2e       	mov	r15, r31
    25c4:	f0 2d       	mov	r31, r0
    25c6:	00 e0       	ldi	r16, 0x00	; 0
    25c8:	20 e0       	ldi	r18, 0x00	; 0
    25ca:	30 e0       	ldi	r19, 0x00	; 0
    25cc:	44 e6       	ldi	r20, 0x64	; 100
    25ce:	50 e0       	ldi	r21, 0x00	; 0
    25d0:	6a e3       	ldi	r22, 0x3A	; 58
    25d2:	70 e2       	ldi	r23, 0x20	; 32
    25d4:	8c e6       	ldi	r24, 0x6C	; 108
    25d6:	91 e1       	ldi	r25, 0x11	; 17
    25d8:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskGenericCreate>
    25dc:	81 30       	cpi	r24, 0x01	; 1
    25de:	69 f4       	brne	.+26     	; 0x25fa <vTaskStartScheduler+0x56>
    25e0:	f8 94       	cli
    25e2:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    25e6:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    25ea:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    25ee:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    25f2:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    25f6:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <xPortStartScheduler>
    25fa:	0f 91       	pop	r16
    25fc:	ff 90       	pop	r15
    25fe:	ef 90       	pop	r14
    2600:	df 90       	pop	r13
    2602:	cf 90       	pop	r12
    2604:	bf 90       	pop	r11
    2606:	af 90       	pop	r10
    2608:	08 95       	ret

0000260a <vTaskSuspendAll>:
    260a:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    260e:	8f 5f       	subi	r24, 0xFF	; 255
    2610:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    2614:	08 95       	ret

00002616 <xTaskGetTickCount>:
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	f8 94       	cli
    261a:	0f 92       	push	r0
    261c:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    2620:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2624:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2628:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    262c:	0f 90       	pop	r0
    262e:	0f be       	out	0x3f, r0	; 63
    2630:	08 95       	ret

00002632 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2632:	00 97       	sbiw	r24, 0x00	; 0
    2634:	21 f4       	brne	.+8      	; 0x263e <pcTaskGetTaskName+0xc>
    2636:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    263a:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    263e:	4d 96       	adiw	r24, 0x1d	; 29
    2640:	08 95       	ret

00002642 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2642:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    2646:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    264a:	08 95       	ret

0000264c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    264c:	ff 92       	push	r15
    264e:	0f 93       	push	r16
    2650:	1f 93       	push	r17
    2652:	cf 93       	push	r28
    2654:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2656:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    265a:	81 11       	cpse	r24, r1
    265c:	ed c0       	rjmp	.+474    	; 0x2838 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    265e:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2662:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2666:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    266a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    266e:	01 96       	adiw	r24, 0x01	; 1
    2670:	a1 1d       	adc	r26, r1
    2672:	b1 1d       	adc	r27, r1
    2674:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2678:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    267c:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    2680:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2684:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2688:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    268c:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2690:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2694:	89 2b       	or	r24, r25
    2696:	8a 2b       	or	r24, r26
    2698:	8b 2b       	or	r24, r27
    269a:	f1 f5       	brne	.+124    	; 0x2718 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    269c:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    26a0:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    26a4:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    26a8:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    26ac:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    26b0:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    26b4:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    26b8:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    26bc:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    26c0:	8f 5f       	subi	r24, 0xFF	; 255
    26c2:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    26c6:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    26ca:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    26ce:	80 81       	ld	r24, Z
    26d0:	81 11       	cpse	r24, r1
    26d2:	0c c0       	rjmp	.+24     	; 0x26ec <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    26d4:	8f ef       	ldi	r24, 0xFF	; 255
    26d6:	9f ef       	ldi	r25, 0xFF	; 255
    26d8:	dc 01       	movw	r26, r24
    26da:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    26de:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    26e2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    26e6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    26ea:	16 c0       	rjmp	.+44     	; 0x2718 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    26ec:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    26f0:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    26f4:	07 80       	ldd	r0, Z+7	; 0x07
    26f6:	f0 85       	ldd	r31, Z+8	; 0x08
    26f8:	e0 2d       	mov	r30, r0
    26fa:	00 84       	ldd	r0, Z+8	; 0x08
    26fc:	f1 85       	ldd	r31, Z+9	; 0x09
    26fe:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2700:	82 81       	ldd	r24, Z+2	; 0x02
    2702:	93 81       	ldd	r25, Z+3	; 0x03
    2704:	a4 81       	ldd	r26, Z+4	; 0x04
    2706:	b5 81       	ldd	r27, Z+5	; 0x05
    2708:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    270c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2710:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2714:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2718:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    271c:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2720:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2724:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2728:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    272c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2730:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2734:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2738:	48 17       	cp	r20, r24
    273a:	59 07       	cpc	r21, r25
    273c:	6a 07       	cpc	r22, r26
    273e:	7b 07       	cpc	r23, r27
    2740:	08 f4       	brcc	.+2      	; 0x2744 <vTaskIncrementTick+0xf8>
    2742:	7f c0       	rjmp	.+254    	; 0x2842 <vTaskIncrementTick+0x1f6>
    2744:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2748:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    274c:	80 81       	ld	r24, Z
    274e:	88 23       	and	r24, r24
    2750:	f9 f0       	breq	.+62     	; 0x2790 <vTaskIncrementTick+0x144>
    2752:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2756:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    275a:	07 80       	ldd	r0, Z+7	; 0x07
    275c:	f0 85       	ldd	r31, Z+8	; 0x08
    275e:	e0 2d       	mov	r30, r0
    2760:	c0 85       	ldd	r28, Z+8	; 0x08
    2762:	d1 85       	ldd	r29, Z+9	; 0x09
    2764:	8a 81       	ldd	r24, Y+2	; 0x02
    2766:	9b 81       	ldd	r25, Y+3	; 0x03
    2768:	ac 81       	ldd	r26, Y+4	; 0x04
    276a:	bd 81       	ldd	r27, Y+5	; 0x05
    276c:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2770:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2774:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2778:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    277c:	48 17       	cp	r20, r24
    277e:	59 07       	cpc	r21, r25
    2780:	6a 07       	cpc	r22, r26
    2782:	7b 07       	cpc	r23, r27
    2784:	58 f1       	brcs	.+86     	; 0x27dc <vTaskIncrementTick+0x190>
    2786:	0f 2e       	mov	r0, r31
    2788:	fb e0       	ldi	r31, 0x0B	; 11
    278a:	ff 2e       	mov	r15, r31
    278c:	f0 2d       	mov	r31, r0
    278e:	2f c0       	rjmp	.+94     	; 0x27ee <vTaskIncrementTick+0x1a2>
    2790:	8f ef       	ldi	r24, 0xFF	; 255
    2792:	9f ef       	ldi	r25, 0xFF	; 255
    2794:	dc 01       	movw	r26, r24
    2796:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    279a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    279e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27a2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    27a6:	4d c0       	rjmp	.+154    	; 0x2842 <vTaskIncrementTick+0x1f6>
    27a8:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    27ac:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    27b0:	07 80       	ldd	r0, Z+7	; 0x07
    27b2:	f0 85       	ldd	r31, Z+8	; 0x08
    27b4:	e0 2d       	mov	r30, r0
    27b6:	c0 85       	ldd	r28, Z+8	; 0x08
    27b8:	d1 85       	ldd	r29, Z+9	; 0x09
    27ba:	8a 81       	ldd	r24, Y+2	; 0x02
    27bc:	9b 81       	ldd	r25, Y+3	; 0x03
    27be:	ac 81       	ldd	r26, Y+4	; 0x04
    27c0:	bd 81       	ldd	r27, Y+5	; 0x05
    27c2:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    27c6:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    27ca:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    27ce:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    27d2:	48 17       	cp	r20, r24
    27d4:	59 07       	cpc	r21, r25
    27d6:	6a 07       	cpc	r22, r26
    27d8:	7b 07       	cpc	r23, r27
    27da:	48 f4       	brcc	.+18     	; 0x27ee <vTaskIncrementTick+0x1a2>
    27dc:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27e0:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    27e4:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27e8:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    27ec:	2a c0       	rjmp	.+84     	; 0x2842 <vTaskIncrementTick+0x1f6>
    27ee:	8e 01       	movw	r16, r28
    27f0:	0e 5f       	subi	r16, 0xFE	; 254
    27f2:	1f 4f       	sbci	r17, 0xFF	; 255
    27f4:	c8 01       	movw	r24, r16
    27f6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>
    27fa:	88 8d       	ldd	r24, Y+24	; 0x18
    27fc:	99 8d       	ldd	r25, Y+25	; 0x19
    27fe:	89 2b       	or	r24, r25
    2800:	21 f0       	breq	.+8      	; 0x280a <vTaskIncrementTick+0x1be>
    2802:	ce 01       	movw	r24, r28
    2804:	0e 96       	adiw	r24, 0x0e	; 14
    2806:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>
    280a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    280c:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2810:	98 17       	cp	r25, r24
    2812:	10 f4       	brcc	.+4      	; 0x2818 <vTaskIncrementTick+0x1cc>
    2814:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2818:	f8 9e       	mul	r15, r24
    281a:	c0 01       	movw	r24, r0
    281c:	11 24       	eor	r1, r1
    281e:	b8 01       	movw	r22, r16
    2820:	88 50       	subi	r24, 0x08	; 8
    2822:	9f 4c       	sbci	r25, 0xCF	; 207
    2824:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInsertEnd>
    2828:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    282c:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2830:	80 81       	ld	r24, Z
    2832:	81 11       	cpse	r24, r1
    2834:	b9 cf       	rjmp	.-142    	; 0x27a8 <vTaskIncrementTick+0x15c>
    2836:	ac cf       	rjmp	.-168    	; 0x2790 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    2838:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    283c:	8f 5f       	subi	r24, 0xFF	; 255
    283e:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2842:	df 91       	pop	r29
    2844:	cf 91       	pop	r28
    2846:	1f 91       	pop	r17
    2848:	0f 91       	pop	r16
    284a:	ff 90       	pop	r15
    284c:	08 95       	ret

0000284e <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    284e:	cf 92       	push	r12
    2850:	df 92       	push	r13
    2852:	ef 92       	push	r14
    2854:	ff 92       	push	r15
    2856:	0f 93       	push	r16
    2858:	1f 93       	push	r17
    285a:	cf 93       	push	r28
    285c:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    285e:	0f b6       	in	r0, 0x3f	; 63
    2860:	f8 94       	cli
    2862:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2864:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2868:	81 50       	subi	r24, 0x01	; 1
    286a:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    286e:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2872:	81 11       	cpse	r24, r1
    2874:	60 c0       	rjmp	.+192    	; 0x2936 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2876:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    287a:	81 11       	cpse	r24, r1
    287c:	2c c0       	rjmp	.+88     	; 0x28d6 <xTaskResumeAll+0x88>
    287e:	5e c0       	rjmp	.+188    	; 0x293c <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2880:	d7 01       	movw	r26, r14
    2882:	17 96       	adiw	r26, 0x07	; 7
    2884:	ed 91       	ld	r30, X+
    2886:	fc 91       	ld	r31, X
    2888:	18 97       	sbiw	r26, 0x08	; 8
    288a:	c0 85       	ldd	r28, Z+8	; 0x08
    288c:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    288e:	ce 01       	movw	r24, r28
    2890:	0e 96       	adiw	r24, 0x0e	; 14
    2892:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2896:	8e 01       	movw	r16, r28
    2898:	0e 5f       	subi	r16, 0xFE	; 254
    289a:	1f 4f       	sbci	r17, 0xFF	; 255
    289c:	c8 01       	movw	r24, r16
    289e:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    28a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28a4:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    28a8:	98 17       	cp	r25, r24
    28aa:	10 f4       	brcc	.+4      	; 0x28b0 <xTaskResumeAll+0x62>
    28ac:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    28b0:	d8 9e       	mul	r13, r24
    28b2:	c0 01       	movw	r24, r0
    28b4:	11 24       	eor	r1, r1
    28b6:	b8 01       	movw	r22, r16
    28b8:	88 50       	subi	r24, 0x08	; 8
    28ba:	9f 4c       	sbci	r25, 0xCF	; 207
    28bc:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    28c0:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    28c4:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    28c8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    28ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    28cc:	98 17       	cp	r25, r24
    28ce:	70 f0       	brcs	.+28     	; 0x28ec <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    28d0:	cc 24       	eor	r12, r12
    28d2:	c3 94       	inc	r12
    28d4:	0b c0       	rjmp	.+22     	; 0x28ec <xTaskResumeAll+0x9e>
    28d6:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    28d8:	0f 2e       	mov	r0, r31
    28da:	f3 ed       	ldi	r31, 0xD3	; 211
    28dc:	ef 2e       	mov	r14, r31
    28de:	f0 e3       	ldi	r31, 0x30	; 48
    28e0:	ff 2e       	mov	r15, r31
    28e2:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    28e4:	0f 2e       	mov	r0, r31
    28e6:	fb e0       	ldi	r31, 0x0B	; 11
    28e8:	df 2e       	mov	r13, r31
    28ea:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    28ec:	f7 01       	movw	r30, r14
    28ee:	80 81       	ld	r24, Z
    28f0:	81 11       	cpse	r24, r1
    28f2:	c6 cf       	rjmp	.-116    	; 0x2880 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    28f4:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    28f8:	88 23       	and	r24, r24
    28fa:	81 f0       	breq	.+32     	; 0x291c <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    28fc:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2900:	88 23       	and	r24, r24
    2902:	99 f0       	breq	.+38     	; 0x292a <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2904:	0e 94 26 13 	call	0x264c	; 0x264c <vTaskIncrementTick>
						--uxMissedTicks;
    2908:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    290c:	81 50       	subi	r24, 0x01	; 1
    290e:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2912:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2916:	81 11       	cpse	r24, r1
    2918:	f5 cf       	rjmp	.-22     	; 0x2904 <xTaskResumeAll+0xb6>
    291a:	07 c0       	rjmp	.+14     	; 0x292a <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    291c:	f1 e0       	ldi	r31, 0x01	; 1
    291e:	cf 16       	cp	r12, r31
    2920:	21 f0       	breq	.+8      	; 0x292a <xTaskResumeAll+0xdc>
    2922:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    2926:	81 30       	cpi	r24, 0x01	; 1
    2928:	41 f4       	brne	.+16     	; 0x293a <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    292a:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    292e:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2932:	81 e0       	ldi	r24, 0x01	; 1
    2934:	03 c0       	rjmp	.+6      	; 0x293c <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2936:	80 e0       	ldi	r24, 0x00	; 0
    2938:	01 c0       	rjmp	.+2      	; 0x293c <xTaskResumeAll+0xee>
    293a:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    293c:	0f 90       	pop	r0
    293e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2940:	df 91       	pop	r29
    2942:	cf 91       	pop	r28
    2944:	1f 91       	pop	r17
    2946:	0f 91       	pop	r16
    2948:	ff 90       	pop	r15
    294a:	ef 90       	pop	r14
    294c:	df 90       	pop	r13
    294e:	cf 90       	pop	r12
    2950:	08 95       	ret

00002952 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2952:	cf 92       	push	r12
    2954:	df 92       	push	r13
    2956:	ef 92       	push	r14
    2958:	ff 92       	push	r15
    295a:	cf 93       	push	r28
    295c:	df 93       	push	r29
    295e:	ec 01       	movw	r28, r24
    2960:	6a 01       	movw	r12, r20
    2962:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2964:	0e 94 05 13 	call	0x260a	; 0x260a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2968:	88 81       	ld	r24, Y
    296a:	99 81       	ldd	r25, Y+1	; 0x01
    296c:	aa 81       	ldd	r26, Y+2	; 0x02
    296e:	bb 81       	ldd	r27, Y+3	; 0x03
    2970:	c8 0e       	add	r12, r24
    2972:	d9 1e       	adc	r13, r25
    2974:	ea 1e       	adc	r14, r26
    2976:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2978:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    297c:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2980:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2984:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2988:	48 17       	cp	r20, r24
    298a:	59 07       	cpc	r21, r25
    298c:	6a 07       	cpc	r22, r26
    298e:	7b 07       	cpc	r23, r27
    2990:	b8 f4       	brcc	.+46     	; 0x29c0 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2992:	c8 16       	cp	r12, r24
    2994:	d9 06       	cpc	r13, r25
    2996:	ea 06       	cpc	r14, r26
    2998:	fb 06       	cpc	r15, r27
    299a:	e0 f5       	brcc	.+120    	; 0x2a14 <vTaskDelayUntil+0xc2>
    299c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    29a0:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    29a4:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    29a8:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    29ac:	c8 82       	st	Y, r12
    29ae:	d9 82       	std	Y+1, r13	; 0x01
    29b0:	ea 82       	std	Y+2, r14	; 0x02
    29b2:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    29b4:	8c 15       	cp	r24, r12
    29b6:	9d 05       	cpc	r25, r13
    29b8:	ae 05       	cpc	r26, r14
    29ba:	bf 05       	cpc	r27, r15
    29bc:	f8 f4       	brcc	.+62     	; 0x29fc <vTaskDelayUntil+0xaa>
    29be:	13 c0       	rjmp	.+38     	; 0x29e6 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    29c0:	c8 16       	cp	r12, r24
    29c2:	d9 06       	cpc	r13, r25
    29c4:	ea 06       	cpc	r14, r26
    29c6:	fb 06       	cpc	r15, r27
    29c8:	00 f1       	brcs	.+64     	; 0x2a0a <vTaskDelayUntil+0xb8>
    29ca:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    29ce:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    29d2:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    29d6:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    29da:	8c 15       	cp	r24, r12
    29dc:	9d 05       	cpc	r25, r13
    29de:	ae 05       	cpc	r26, r14
    29e0:	bf 05       	cpc	r27, r15
    29e2:	98 f0       	brcs	.+38     	; 0x2a0a <vTaskDelayUntil+0xb8>
    29e4:	17 c0       	rjmp	.+46     	; 0x2a14 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    29e6:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    29ea:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    29ee:	02 96       	adiw	r24, 0x02	; 2
    29f0:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    29f4:	c7 01       	movw	r24, r14
    29f6:	b6 01       	movw	r22, r12
    29f8:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    29fc:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2a00:	81 11       	cpse	r24, r1
    2a02:	0d c0       	rjmp	.+26     	; 0x2a1e <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2a04:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
		}
	}
    2a08:	0a c0       	rjmp	.+20     	; 0x2a1e <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2a0a:	c8 82       	st	Y, r12
    2a0c:	d9 82       	std	Y+1, r13	; 0x01
    2a0e:	ea 82       	std	Y+2, r14	; 0x02
    2a10:	fb 82       	std	Y+3, r15	; 0x03
    2a12:	e9 cf       	rjmp	.-46     	; 0x29e6 <vTaskDelayUntil+0x94>
    2a14:	c8 82       	st	Y, r12
    2a16:	d9 82       	std	Y+1, r13	; 0x01
    2a18:	ea 82       	std	Y+2, r14	; 0x02
    2a1a:	fb 82       	std	Y+3, r15	; 0x03
    2a1c:	ef cf       	rjmp	.-34     	; 0x29fc <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2a1e:	df 91       	pop	r29
    2a20:	cf 91       	pop	r28
    2a22:	ff 90       	pop	r15
    2a24:	ef 90       	pop	r14
    2a26:	df 90       	pop	r13
    2a28:	cf 90       	pop	r12
    2a2a:	08 95       	ret

00002a2c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2a2c:	cf 92       	push	r12
    2a2e:	df 92       	push	r13
    2a30:	ef 92       	push	r14
    2a32:	ff 92       	push	r15
    2a34:	6b 01       	movw	r12, r22
    2a36:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2a38:	67 2b       	or	r22, r23
    2a3a:	68 2b       	or	r22, r24
    2a3c:	69 2b       	or	r22, r25
    2a3e:	e9 f0       	breq	.+58     	; 0x2a7a <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2a40:	0e 94 05 13 	call	0x260a	; 0x260a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2a44:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2a48:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2a4c:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2a50:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2a54:	c8 0e       	add	r12, r24
    2a56:	d9 1e       	adc	r13, r25
    2a58:	ea 1e       	adc	r14, r26
    2a5a:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a5c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2a60:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2a64:	02 96       	adiw	r24, 0x02	; 2
    2a66:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2a6a:	c7 01       	movw	r24, r14
    2a6c:	b6 01       	movw	r22, r12
    2a6e:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2a72:	0e 94 27 14 	call	0x284e	; 0x284e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2a76:	81 11       	cpse	r24, r1
    2a78:	02 c0       	rjmp	.+4      	; 0x2a7e <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2a7a:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <vPortYield>
		}
	}
    2a7e:	ff 90       	pop	r15
    2a80:	ef 90       	pop	r14
    2a82:	df 90       	pop	r13
    2a84:	cf 90       	pop	r12
    2a86:	08 95       	ret

00002a88 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2a88:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2a8c:	81 11       	cpse	r24, r1
    2a8e:	0c c0       	rjmp	.+24     	; 0x2aa8 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2a90:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2a94:	4b e0       	ldi	r20, 0x0B	; 11
    2a96:	e4 9f       	mul	r30, r20
    2a98:	f0 01       	movw	r30, r0
    2a9a:	11 24       	eor	r1, r1
    2a9c:	e8 50       	subi	r30, 0x08	; 8
    2a9e:	ff 4c       	sbci	r31, 0xCF	; 207
    2aa0:	80 81       	ld	r24, Z
    2aa2:	88 23       	and	r24, r24
    2aa4:	29 f0       	breq	.+10     	; 0x2ab0 <vTaskSwitchContext+0x28>
    2aa6:	14 c0       	rjmp	.+40     	; 0x2ad0 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2aa8:	81 e0       	ldi	r24, 0x01	; 1
    2aaa:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2aae:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2ab0:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2ab2:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2ab6:	81 50       	subi	r24, 0x01	; 1
    2ab8:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2abc:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2ac0:	9e 9f       	mul	r25, r30
    2ac2:	f0 01       	movw	r30, r0
    2ac4:	11 24       	eor	r1, r1
    2ac6:	e8 50       	subi	r30, 0x08	; 8
    2ac8:	ff 4c       	sbci	r31, 0xCF	; 207
    2aca:	80 81       	ld	r24, Z
    2acc:	88 23       	and	r24, r24
    2ace:	89 f3       	breq	.-30     	; 0x2ab2 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2ad0:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2ad4:	28 2f       	mov	r18, r24
    2ad6:	30 e0       	ldi	r19, 0x00	; 0
    2ad8:	4b e0       	ldi	r20, 0x0B	; 11
    2ada:	84 9f       	mul	r24, r20
    2adc:	c0 01       	movw	r24, r0
    2ade:	11 24       	eor	r1, r1
    2ae0:	dc 01       	movw	r26, r24
    2ae2:	a8 50       	subi	r26, 0x08	; 8
    2ae4:	bf 4c       	sbci	r27, 0xCF	; 207
    2ae6:	11 96       	adiw	r26, 0x01	; 1
    2ae8:	ed 91       	ld	r30, X+
    2aea:	fc 91       	ld	r31, X
    2aec:	12 97       	sbiw	r26, 0x02	; 2
    2aee:	04 80       	ldd	r0, Z+4	; 0x04
    2af0:	f5 81       	ldd	r31, Z+5	; 0x05
    2af2:	e0 2d       	mov	r30, r0
    2af4:	11 96       	adiw	r26, 0x01	; 1
    2af6:	ed 93       	st	X+, r30
    2af8:	fc 93       	st	X, r31
    2afa:	12 97       	sbiw	r26, 0x02	; 2
    2afc:	85 50       	subi	r24, 0x05	; 5
    2afe:	9f 4c       	sbci	r25, 0xCF	; 207
    2b00:	e8 17       	cp	r30, r24
    2b02:	f9 07       	cpc	r31, r25
    2b04:	61 f4       	brne	.+24     	; 0x2b1e <vTaskSwitchContext+0x96>
    2b06:	84 81       	ldd	r24, Z+4	; 0x04
    2b08:	95 81       	ldd	r25, Z+5	; 0x05
    2b0a:	4b e0       	ldi	r20, 0x0B	; 11
    2b0c:	42 9f       	mul	r20, r18
    2b0e:	f0 01       	movw	r30, r0
    2b10:	43 9f       	mul	r20, r19
    2b12:	f0 0d       	add	r31, r0
    2b14:	11 24       	eor	r1, r1
    2b16:	e8 50       	subi	r30, 0x08	; 8
    2b18:	ff 4c       	sbci	r31, 0xCF	; 207
    2b1a:	81 83       	std	Z+1, r24	; 0x01
    2b1c:	92 83       	std	Z+2, r25	; 0x02
    2b1e:	8b e0       	ldi	r24, 0x0B	; 11
    2b20:	82 9f       	mul	r24, r18
    2b22:	f0 01       	movw	r30, r0
    2b24:	83 9f       	mul	r24, r19
    2b26:	f0 0d       	add	r31, r0
    2b28:	11 24       	eor	r1, r1
    2b2a:	e8 50       	subi	r30, 0x08	; 8
    2b2c:	ff 4c       	sbci	r31, 0xCF	; 207
    2b2e:	01 80       	ldd	r0, Z+1	; 0x01
    2b30:	f2 81       	ldd	r31, Z+2	; 0x02
    2b32:	e0 2d       	mov	r30, r0
    2b34:	80 85       	ldd	r24, Z+8	; 0x08
    2b36:	91 85       	ldd	r25, Z+9	; 0x09
    2b38:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    2b3c:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    2b40:	08 95       	ret

00002b42 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2b42:	cf 92       	push	r12
    2b44:	df 92       	push	r13
    2b46:	ef 92       	push	r14
    2b48:	ff 92       	push	r15
    2b4a:	6a 01       	movw	r12, r20
    2b4c:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2b4e:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2b52:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2b56:	62 5f       	subi	r22, 0xF2	; 242
    2b58:	7f 4f       	sbci	r23, 0xFF	; 255
    2b5a:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b5e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2b62:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2b66:	02 96       	adiw	r24, 0x02	; 2
    2b68:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2b6c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2b70:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2b74:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2b78:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b7c:	bc 01       	movw	r22, r24
    2b7e:	cd 01       	movw	r24, r26
    2b80:	6c 0d       	add	r22, r12
    2b82:	7d 1d       	adc	r23, r13
    2b84:	8e 1d       	adc	r24, r14
    2b86:	9f 1d       	adc	r25, r15
    2b88:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2b8c:	ff 90       	pop	r15
    2b8e:	ef 90       	pop	r14
    2b90:	df 90       	pop	r13
    2b92:	cf 90       	pop	r12
    2b94:	08 95       	ret

00002b96 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2b96:	0f 93       	push	r16
    2b98:	1f 93       	push	r17
    2b9a:	cf 93       	push	r28
    2b9c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2b9e:	dc 01       	movw	r26, r24
    2ba0:	17 96       	adiw	r26, 0x07	; 7
    2ba2:	ed 91       	ld	r30, X+
    2ba4:	fc 91       	ld	r31, X
    2ba6:	18 97       	sbiw	r26, 0x08	; 8
    2ba8:	c0 85       	ldd	r28, Z+8	; 0x08
    2baa:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2bac:	8e 01       	movw	r16, r28
    2bae:	02 5f       	subi	r16, 0xF2	; 242
    2bb0:	1f 4f       	sbci	r17, 0xFF	; 255
    2bb2:	c8 01       	movw	r24, r16
    2bb4:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2bb8:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2bbc:	81 11       	cpse	r24, r1
    2bbe:	16 c0       	rjmp	.+44     	; 0x2bec <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2bc0:	0c 50       	subi	r16, 0x0C	; 12
    2bc2:	11 09       	sbc	r17, r1
    2bc4:	c8 01       	movw	r24, r16
    2bc6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2bca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2bcc:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2bd0:	98 17       	cp	r25, r24
    2bd2:	10 f4       	brcc	.+4      	; 0x2bd8 <xTaskRemoveFromEventList+0x42>
    2bd4:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2bd8:	bb e0       	ldi	r27, 0x0B	; 11
    2bda:	8b 9f       	mul	r24, r27
    2bdc:	c0 01       	movw	r24, r0
    2bde:	11 24       	eor	r1, r1
    2be0:	b8 01       	movw	r22, r16
    2be2:	88 50       	subi	r24, 0x08	; 8
    2be4:	9f 4c       	sbci	r25, 0xCF	; 207
    2be6:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInsertEnd>
    2bea:	05 c0       	rjmp	.+10     	; 0x2bf6 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2bec:	b8 01       	movw	r22, r16
    2bee:	83 ed       	ldi	r24, 0xD3	; 211
    2bf0:	90 e3       	ldi	r25, 0x30	; 48
    2bf2:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2bf6:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2bfa:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2bfe:	81 e0       	ldi	r24, 0x01	; 1
    2c00:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2c02:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c04:	29 17       	cp	r18, r25
    2c06:	08 f4       	brcc	.+2      	; 0x2c0a <xTaskRemoveFromEventList+0x74>
    2c08:	80 e0       	ldi	r24, 0x00	; 0
}
    2c0a:	df 91       	pop	r29
    2c0c:	cf 91       	pop	r28
    2c0e:	1f 91       	pop	r17
    2c10:	0f 91       	pop	r16
    2c12:	08 95       	ret

00002c14 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2c14:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2c18:	fc 01       	movw	r30, r24
    2c1a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2c1c:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2c20:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2c24:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2c28:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2c2c:	41 83       	std	Z+1, r20	; 0x01
    2c2e:	52 83       	std	Z+2, r21	; 0x02
    2c30:	63 83       	std	Z+3, r22	; 0x03
    2c32:	74 83       	std	Z+4, r23	; 0x04
    2c34:	08 95       	ret

00002c36 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2c36:	8f 92       	push	r8
    2c38:	9f 92       	push	r9
    2c3a:	af 92       	push	r10
    2c3c:	bf 92       	push	r11
    2c3e:	cf 92       	push	r12
    2c40:	df 92       	push	r13
    2c42:	ef 92       	push	r14
    2c44:	ff 92       	push	r15
    2c46:	0f 93       	push	r16
    2c48:	1f 93       	push	r17
    2c4a:	cf 93       	push	r28
    2c4c:	df 93       	push	r29
    2c4e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2c50:	0f b6       	in	r0, 0x3f	; 63
    2c52:	f8 94       	cli
    2c54:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2c56:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2c5a:	90 81       	ld	r25, Z
    2c5c:	98 17       	cp	r25, r24
    2c5e:	89 f0       	breq	.+34     	; 0x2c82 <xTaskCheckForTimeOut+0x4c>
    2c60:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2c64:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2c68:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2c6c:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2c70:	01 81       	ldd	r16, Z+1	; 0x01
    2c72:	12 81       	ldd	r17, Z+2	; 0x02
    2c74:	23 81       	ldd	r18, Z+3	; 0x03
    2c76:	34 81       	ldd	r19, Z+4	; 0x04
    2c78:	80 17       	cp	r24, r16
    2c7a:	91 07       	cpc	r25, r17
    2c7c:	a2 07       	cpc	r26, r18
    2c7e:	b3 07       	cpc	r27, r19
    2c80:	a8 f5       	brcc	.+106    	; 0x2cec <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2c82:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2c86:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2c8a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2c8e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2c92:	c1 80       	ldd	r12, Z+1	; 0x01
    2c94:	d2 80       	ldd	r13, Z+2	; 0x02
    2c96:	e3 80       	ldd	r14, Z+3	; 0x03
    2c98:	f4 80       	ldd	r15, Z+4	; 0x04
    2c9a:	eb 01       	movw	r28, r22
    2c9c:	08 81       	ld	r16, Y
    2c9e:	19 81       	ldd	r17, Y+1	; 0x01
    2ca0:	2a 81       	ldd	r18, Y+2	; 0x02
    2ca2:	3b 81       	ldd	r19, Y+3	; 0x03
    2ca4:	8c 19       	sub	r24, r12
    2ca6:	9d 09       	sbc	r25, r13
    2ca8:	ae 09       	sbc	r26, r14
    2caa:	bf 09       	sbc	r27, r15
    2cac:	80 17       	cp	r24, r16
    2cae:	91 07       	cpc	r25, r17
    2cb0:	a2 07       	cpc	r26, r18
    2cb2:	b3 07       	cpc	r27, r19
    2cb4:	e8 f4       	brcc	.+58     	; 0x2cf0 <xTaskCheckForTimeOut+0xba>
    2cb6:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2cb8:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    2cbc:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2cc0:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2cc4:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2cc8:	b5 01       	movw	r22, r10
    2cca:	a4 01       	movw	r20, r8
    2ccc:	4c 19       	sub	r20, r12
    2cce:	5d 09       	sbc	r21, r13
    2cd0:	6e 09       	sbc	r22, r14
    2cd2:	7f 09       	sbc	r23, r15
    2cd4:	04 1b       	sub	r16, r20
    2cd6:	15 0b       	sbc	r17, r21
    2cd8:	26 0b       	sbc	r18, r22
    2cda:	37 0b       	sbc	r19, r23
    2cdc:	08 83       	st	Y, r16
    2cde:	19 83       	std	Y+1, r17	; 0x01
    2ce0:	2a 83       	std	Y+2, r18	; 0x02
    2ce2:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2ce4:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2ce8:	80 e0       	ldi	r24, 0x00	; 0
    2cea:	03 c0       	rjmp	.+6      	; 0x2cf2 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2cec:	81 e0       	ldi	r24, 0x01	; 1
    2cee:	01 c0       	rjmp	.+2      	; 0x2cf2 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2cf0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2cf2:	0f 90       	pop	r0
    2cf4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2cf6:	df 91       	pop	r29
    2cf8:	cf 91       	pop	r28
    2cfa:	1f 91       	pop	r17
    2cfc:	0f 91       	pop	r16
    2cfe:	ff 90       	pop	r15
    2d00:	ef 90       	pop	r14
    2d02:	df 90       	pop	r13
    2d04:	cf 90       	pop	r12
    2d06:	bf 90       	pop	r11
    2d08:	af 90       	pop	r10
    2d0a:	9f 90       	pop	r9
    2d0c:	8f 90       	pop	r8
    2d0e:	08 95       	ret

00002d10 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2d10:	81 e0       	ldi	r24, 0x01	; 1
    2d12:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2d16:	08 95       	ret

00002d18 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2d18:	00 97       	sbiw	r24, 0x00	; 0
    2d1a:	21 f4       	brne	.+8      	; 0x2d24 <uxTaskGetStackHighWaterMark+0xc>
    2d1c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2d20:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2d24:	dc 01       	movw	r26, r24
    2d26:	5b 96       	adiw	r26, 0x1b	; 27
    2d28:	ed 91       	ld	r30, X+
    2d2a:	fc 91       	ld	r31, X
    2d2c:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2d2e:	80 81       	ld	r24, Z
    2d30:	81 31       	cpi	r24, 0x11	; 17
    2d32:	41 f4       	brne	.+16     	; 0x2d44 <uxTaskGetStackHighWaterMark+0x2c>
    2d34:	31 96       	adiw	r30, 0x01	; 1
    2d36:	80 e0       	ldi	r24, 0x00	; 0
    2d38:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2d3a:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2d3c:	21 91       	ld	r18, Z+
    2d3e:	21 31       	cpi	r18, 0x11	; 17
    2d40:	e1 f3       	breq	.-8      	; 0x2d3a <uxTaskGetStackHighWaterMark+0x22>
    2d42:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2d44:	80 e0       	ldi	r24, 0x00	; 0
    2d46:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2d48:	08 95       	ret

00002d4a <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2d4a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2d4e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2d52:	08 95       	ret

00002d54 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2d54:	0f 93       	push	r16
    2d56:	1f 93       	push	r17
    2d58:	cf 93       	push	r28
    2d5a:	df 93       	push	r29
    2d5c:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2d5e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2d60:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2d64:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2d68:	5a 96       	adiw	r26, 0x1a	; 26
    2d6a:	8c 91       	ld	r24, X
    2d6c:	28 17       	cp	r18, r24
    2d6e:	08 f0       	brcs	.+2      	; 0x2d72 <vTaskPriorityInherit+0x1e>
    2d70:	41 c0       	rjmp	.+130    	; 0x2df4 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2d72:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2d76:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2d7a:	5a 96       	adiw	r26, 0x1a	; 26
    2d7c:	3c 91       	ld	r19, X
    2d7e:	84 e0       	ldi	r24, 0x04	; 4
    2d80:	90 e0       	ldi	r25, 0x00	; 0
    2d82:	a0 e0       	ldi	r26, 0x00	; 0
    2d84:	b0 e0       	ldi	r27, 0x00	; 0
    2d86:	83 1b       	sub	r24, r19
    2d88:	91 09       	sbc	r25, r1
    2d8a:	a1 09       	sbc	r26, r1
    2d8c:	b1 09       	sbc	r27, r1
    2d8e:	86 87       	std	Z+14, r24	; 0x0e
    2d90:	97 87       	std	Z+15, r25	; 0x0f
    2d92:	a0 8b       	std	Z+16, r26	; 0x10
    2d94:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2d96:	8b e0       	ldi	r24, 0x0B	; 11
    2d98:	28 9f       	mul	r18, r24
    2d9a:	90 01       	movw	r18, r0
    2d9c:	11 24       	eor	r1, r1
    2d9e:	28 50       	subi	r18, 0x08	; 8
    2da0:	3f 4c       	sbci	r19, 0xCF	; 207
    2da2:	84 85       	ldd	r24, Z+12	; 0x0c
    2da4:	95 85       	ldd	r25, Z+13	; 0x0d
    2da6:	82 17       	cp	r24, r18
    2da8:	93 07       	cpc	r25, r19
    2daa:	e9 f4       	brne	.+58     	; 0x2de6 <vTaskPriorityInherit+0x92>
    2dac:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2dae:	ef 01       	movw	r28, r30
    2db0:	22 96       	adiw	r28, 0x02	; 2
    2db2:	ce 01       	movw	r24, r28
    2db4:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2db8:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2dbc:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2dc0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dc2:	f8 01       	movw	r30, r16
    2dc4:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2dc6:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2dca:	98 17       	cp	r25, r24
    2dcc:	10 f4       	brcc	.+4      	; 0x2dd2 <vTaskPriorityInherit+0x7e>
    2dce:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2dd2:	fb e0       	ldi	r31, 0x0B	; 11
    2dd4:	8f 9f       	mul	r24, r31
    2dd6:	c0 01       	movw	r24, r0
    2dd8:	11 24       	eor	r1, r1
    2dda:	be 01       	movw	r22, r28
    2ddc:	88 50       	subi	r24, 0x08	; 8
    2dde:	9f 4c       	sbci	r25, 0xCF	; 207
    2de0:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInsertEnd>
    2de4:	07 c0       	rjmp	.+14     	; 0x2df4 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2de6:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2dea:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2dee:	5a 96       	adiw	r26, 0x1a	; 26
    2df0:	8c 91       	ld	r24, X
    2df2:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2df4:	df 91       	pop	r29
    2df6:	cf 91       	pop	r28
    2df8:	1f 91       	pop	r17
    2dfa:	0f 91       	pop	r16
    2dfc:	08 95       	ret

00002dfe <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2dfe:	0f 93       	push	r16
    2e00:	1f 93       	push	r17
    2e02:	cf 93       	push	r28
    2e04:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2e06:	00 97       	sbiw	r24, 0x00	; 0
    2e08:	49 f1       	breq	.+82     	; 0x2e5c <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2e0a:	fc 01       	movw	r30, r24
    2e0c:	32 8d       	ldd	r19, Z+26	; 0x1a
    2e0e:	27 a1       	ldd	r18, Z+39	; 0x27
    2e10:	32 17       	cp	r19, r18
    2e12:	21 f1       	breq	.+72     	; 0x2e5c <vTaskPriorityDisinherit+0x5e>
    2e14:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2e16:	8c 01       	movw	r16, r24
    2e18:	0e 5f       	subi	r16, 0xFE	; 254
    2e1a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e1c:	c8 01       	movw	r24, r16
    2e1e:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2e22:	8f a1       	ldd	r24, Y+39	; 0x27
    2e24:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2e26:	44 e0       	ldi	r20, 0x04	; 4
    2e28:	50 e0       	ldi	r21, 0x00	; 0
    2e2a:	60 e0       	ldi	r22, 0x00	; 0
    2e2c:	70 e0       	ldi	r23, 0x00	; 0
    2e2e:	48 1b       	sub	r20, r24
    2e30:	51 09       	sbc	r21, r1
    2e32:	61 09       	sbc	r22, r1
    2e34:	71 09       	sbc	r23, r1
    2e36:	4e 87       	std	Y+14, r20	; 0x0e
    2e38:	5f 87       	std	Y+15, r21	; 0x0f
    2e3a:	68 8b       	std	Y+16, r22	; 0x10
    2e3c:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2e3e:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2e42:	98 17       	cp	r25, r24
    2e44:	10 f4       	brcc	.+4      	; 0x2e4a <vTaskPriorityDisinherit+0x4c>
    2e46:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2e4a:	fb e0       	ldi	r31, 0x0B	; 11
    2e4c:	8f 9f       	mul	r24, r31
    2e4e:	c0 01       	movw	r24, r0
    2e50:	11 24       	eor	r1, r1
    2e52:	b8 01       	movw	r22, r16
    2e54:	88 50       	subi	r24, 0x08	; 8
    2e56:	9f 4c       	sbci	r25, 0xCF	; 207
    2e58:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <vListInsertEnd>
			}
		}
	}
    2e5c:	df 91       	pop	r29
    2e5e:	cf 91       	pop	r28
    2e60:	1f 91       	pop	r17
    2e62:	0f 91       	pop	r16
    2e64:	08 95       	ret

00002e66 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2e66:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2e68:	e8 81       	ld	r30, Y
    2e6a:	f9 81       	ldd	r31, Y+1	; 0x01
    2e6c:	01 90       	ld	r0, Z+
    2e6e:	f0 81       	ld	r31, Z
    2e70:	e0 2d       	mov	r30, r0
    2e72:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2e74:	1a 82       	std	Y+2, r1	; 0x02
    2e76:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2e78:	6f ef       	ldi	r22, 0xFF	; 255
    2e7a:	7f ef       	ldi	r23, 0xFF	; 255
    2e7c:	cb 01       	movw	r24, r22
    2e7e:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vTaskDelay>
    2e82:	fa cf       	rjmp	.-12     	; 0x2e78 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002e84 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2e84:	fc 01       	movw	r30, r24
    2e86:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2e88:	65 87       	std	Z+13, r22	; 0x0d
    2e8a:	08 95       	ret

00002e8c <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2e8c:	4f 92       	push	r4
    2e8e:	5f 92       	push	r5
    2e90:	6f 92       	push	r6
    2e92:	7f 92       	push	r7
    2e94:	8f 92       	push	r8
    2e96:	9f 92       	push	r9
    2e98:	af 92       	push	r10
    2e9a:	bf 92       	push	r11
    2e9c:	cf 92       	push	r12
    2e9e:	df 92       	push	r13
    2ea0:	ef 92       	push	r14
    2ea2:	ff 92       	push	r15
    2ea4:	0f 93       	push	r16
    2ea6:	1f 93       	push	r17
    2ea8:	cf 93       	push	r28
    2eaa:	df 93       	push	r29
    2eac:	cd b7       	in	r28, 0x3d	; 61
    2eae:	de b7       	in	r29, 0x3e	; 62
    2eb0:	2a 97       	sbiw	r28, 0x0a	; 10
    2eb2:	cd bf       	out	0x3d, r28	; 61
    2eb4:	de bf       	out	0x3e, r29	; 62
    2eb6:	4c 01       	movw	r8, r24
    2eb8:	29 01       	movw	r4, r18
    2eba:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2ebc:	83 e4       	ldi	r24, 0x43	; 67
    2ebe:	90 e2       	ldi	r25, 0x20	; 32
    2ec0:	f4 01       	movw	r30, r8
    2ec2:	80 83       	st	Z, r24
    2ec4:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2ec6:	fb 01       	movw	r30, r22
    2ec8:	80 81       	ld	r24, Z
    2eca:	88 23       	and	r24, r24
    2ecc:	69 f0       	breq	.+26     	; 0x2ee8 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2ece:	de 01       	movw	r26, r28
    2ed0:	11 96       	adiw	r26, 0x01	; 1
    2ed2:	31 96       	adiw	r30, 0x01	; 1
    2ed4:	90 e0       	ldi	r25, 0x00	; 0
    2ed6:	02 c0       	rjmp	.+4      	; 0x2edc <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2ed8:	99 30       	cpi	r25, 0x09	; 9
    2eda:	39 f0       	breq	.+14     	; 0x2eea <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2edc:	9f 5f       	subi	r25, 0xFF	; 255
    2ede:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2ee0:	81 91       	ld	r24, Z+
    2ee2:	81 11       	cpse	r24, r1
    2ee4:	f9 cf       	rjmp	.-14     	; 0x2ed8 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2ee6:	01 c0       	rjmp	.+2      	; 0x2eea <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2ee8:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2eea:	e1 e0       	ldi	r30, 0x01	; 1
    2eec:	f0 e0       	ldi	r31, 0x00	; 0
    2eee:	ec 0f       	add	r30, r28
    2ef0:	fd 1f       	adc	r31, r29
    2ef2:	e9 0f       	add	r30, r25
    2ef4:	f1 1d       	adc	r31, r1
    2ef6:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2ef8:	74 01       	movw	r14, r8
    2efa:	f2 e0       	ldi	r31, 0x02	; 2
    2efc:	ef 0e       	add	r14, r31
    2efe:	f1 1c       	adc	r15, r1
    2f00:	a1 2c       	mov	r10, r1
    2f02:	b1 2c       	mov	r11, r1
    2f04:	c1 2c       	mov	r12, r1
    2f06:	d1 2c       	mov	r13, r1
    2f08:	04 2f       	mov	r16, r20
    2f0a:	94 01       	movw	r18, r8
    2f0c:	a2 01       	movw	r20, r4
    2f0e:	be 01       	movw	r22, r28
    2f10:	6f 5f       	subi	r22, 0xFF	; 255
    2f12:	7f 4f       	sbci	r23, 0xFF	; 255
    2f14:	82 e9       	ldi	r24, 0x92	; 146
    2f16:	93 e0       	ldi	r25, 0x03	; 3
    2f18:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2f1c:	f4 01       	movw	r30, r8
    2f1e:	66 82       	std	Z+6, r6	; 0x06
    2f20:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2f22:	40 86       	std	Z+8, r4	; 0x08
    2f24:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2f26:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    2f2a:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2f2e:	24 83       	std	Z+4, r18	; 0x04
    2f30:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2f32:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    2f36:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2f3a:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2f3c:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2f3e:	40 90 64 31 	lds	r4, 0x3164	; 0x803164 <portStackTopForTask>
    2f42:	50 90 65 31 	lds	r5, 0x3165	; 0x803165 <portStackTopForTask+0x1>
    2f46:	ff ef       	ldi	r31, 0xFF	; 255
    2f48:	4f 1a       	sub	r4, r31
    2f4a:	5f 0a       	sbc	r5, r31
    2f4c:	40 92 64 31 	sts	0x3164, r4	; 0x803164 <portStackTopForTask>
    2f50:	50 92 65 31 	sts	0x3165, r5	; 0x803165 <portStackTopForTask+0x1>
    2f54:	f4 01       	movw	r30, r8
    2f56:	42 86       	std	Z+10, r4	; 0x0a
    2f58:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2f5a:	16 86       	std	Z+14, r1	; 0x0e
    2f5c:	17 86       	std	Z+15, r1	; 0x0f
    2f5e:	10 8a       	std	Z+16, r1	; 0x10
    2f60:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2f62:	61 14       	cp	r6, r1
    2f64:	71 04       	cpc	r7, r1
    2f66:	09 f4       	brne	.+2      	; 0x2f6a <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2f68:	44 c0       	rjmp	.+136    	; 0x2ff2 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2f6a:	81 30       	cpi	r24, 0x01	; 1
    2f6c:	79 f5       	brne	.+94     	; 0x2fcc <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2f6e:	6a e0       	ldi	r22, 0x0A	; 10
    2f70:	c3 01       	movw	r24, r6
    2f72:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    2f76:	7c 01       	movw	r14, r24
    2f78:	60 e7       	ldi	r22, 0x70	; 112
    2f7a:	76 e0       	ldi	r23, 0x06	; 6
    2f7c:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    2f80:	be 01       	movw	r22, r28
    2f82:	6f 5f       	subi	r22, 0xFF	; 255
    2f84:	7f 4f       	sbci	r23, 0xFF	; 255
    2f86:	c7 01       	movw	r24, r14
    2f88:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    2f8c:	6a e0       	ldi	r22, 0x0A	; 10
    2f8e:	c7 01       	movw	r24, r14
    2f90:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    2f94:	7c 01       	movw	r14, r24
    2f96:	67 e6       	ldi	r22, 0x67	; 103
    2f98:	76 e0       	ldi	r23, 0x06	; 6
    2f9a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2f9e:	6a e0       	ldi	r22, 0x0A	; 10
    2fa0:	c7 01       	movw	r24, r14
    2fa2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    2fa6:	7c 01       	movw	r14, r24
    2fa8:	69 e5       	ldi	r22, 0x59	; 89
    2faa:	76 e0       	ldi	r23, 0x06	; 6
    2fac:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    2fb0:	63 e0       	ldi	r22, 0x03	; 3
    2fb2:	c7 01       	movw	r24, r14
    2fb4:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    2fb8:	b2 01       	movw	r22, r4
    2fba:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <_ZN8emstreamlsEj>
    2fbe:	62 e0       	ldi	r22, 0x02	; 2
    2fc0:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    2fc4:	66 e0       	ldi	r22, 0x06	; 6
    2fc6:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    2fca:	13 c0       	rjmp	.+38     	; 0x2ff2 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2fcc:	6a e0       	ldi	r22, 0x0A	; 10
    2fce:	c3 01       	movw	r24, r6
    2fd0:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    2fd4:	4c 01       	movw	r8, r24
    2fd6:	64 e4       	ldi	r22, 0x44	; 68
    2fd8:	76 e0       	ldi	r23, 0x06	; 6
    2fda:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    2fde:	be 01       	movw	r22, r28
    2fe0:	6f 5f       	subi	r22, 0xFF	; 255
    2fe2:	7f 4f       	sbci	r23, 0xFF	; 255
    2fe4:	c4 01       	movw	r24, r8
    2fe6:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    2fea:	66 e0       	ldi	r22, 0x06	; 6
    2fec:	c4 01       	movw	r24, r8
    2fee:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2ff2:	2a 96       	adiw	r28, 0x0a	; 10
    2ff4:	cd bf       	out	0x3d, r28	; 61
    2ff6:	de bf       	out	0x3e, r29	; 62
    2ff8:	df 91       	pop	r29
    2ffa:	cf 91       	pop	r28
    2ffc:	1f 91       	pop	r17
    2ffe:	0f 91       	pop	r16
    3000:	ff 90       	pop	r15
    3002:	ef 90       	pop	r14
    3004:	df 90       	pop	r13
    3006:	cf 90       	pop	r12
    3008:	bf 90       	pop	r11
    300a:	af 90       	pop	r10
    300c:	9f 90       	pop	r9
    300e:	8f 90       	pop	r8
    3010:	7f 90       	pop	r7
    3012:	6f 90       	pop	r6
    3014:	5f 90       	pop	r5
    3016:	4f 90       	pop	r4
    3018:	08 95       	ret

0000301a <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    301a:	cf 92       	push	r12
    301c:	df 92       	push	r13
    301e:	ef 92       	push	r14
    3020:	ff 92       	push	r15
    3022:	0f 93       	push	r16
    3024:	1f 93       	push	r17
    3026:	cf 93       	push	r28
    3028:	df 93       	push	r29
    302a:	ec 01       	movw	r28, r24
    302c:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    302e:	8a 81       	ldd	r24, Y+2	; 0x02
    3030:	9b 81       	ldd	r25, Y+3	; 0x03
    3032:	0e 94 19 13 	call	0x2632	; 0x2632 <pcTaskGetTaskName>
    3036:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3038:	6a e0       	ldi	r22, 0x0A	; 10
    303a:	c7 01       	movw	r24, r14
    303c:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3040:	8c 01       	movw	r16, r24
    3042:	63 e8       	ldi	r22, 0x83	; 131
    3044:	76 e0       	ldi	r23, 0x06	; 6
    3046:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    304a:	6a e0       	ldi	r22, 0x0A	; 10
    304c:	c8 01       	movw	r24, r16
    304e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3052:	8c 01       	movw	r16, r24
    3054:	6c e7       	ldi	r22, 0x7C	; 124
    3056:	76 e0       	ldi	r23, 0x06	; 6
    3058:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    305c:	b6 01       	movw	r22, r12
    305e:	c8 01       	movw	r24, r16
    3060:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    3064:	6a e0       	ldi	r22, 0x0A	; 10
    3066:	c8 01       	movw	r24, r16
    3068:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    306c:	8c 01       	movw	r16, r24
    306e:	66 e7       	ldi	r22, 0x76	; 118
    3070:	76 e0       	ldi	r23, 0x06	; 6
    3072:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    3076:	66 e0       	ldi	r22, 0x06	; 6
    3078:	c8 01       	movw	r24, r16
    307a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    307e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3080:	9b 85       	ldd	r25, Y+11	; 0x0b
    3082:	e8 85       	ldd	r30, Y+8	; 0x08
    3084:	f9 85       	ldd	r31, Y+9	; 0x09
    3086:	01 e1       	ldi	r16, 0x11	; 17
    3088:	21 e0       	ldi	r18, 0x01	; 1
    308a:	a7 01       	movw	r20, r14
    308c:	bc 01       	movw	r22, r24
    308e:	8e 1b       	sub	r24, r30
    3090:	9f 0b       	sbc	r25, r31
    3092:	0e 94 0f 1b 	call	0x361e	; 0x361e <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    3096:	8c 81       	ldd	r24, Y+4	; 0x04
    3098:	9d 81       	ldd	r25, Y+5	; 0x05
    309a:	00 97       	sbiw	r24, 0x00	; 0
    309c:	19 f0       	breq	.+6      	; 0x30a4 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    309e:	b7 01       	movw	r22, r14
    30a0:	0e 94 0d 18 	call	0x301a	; 0x301a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    30a4:	df 91       	pop	r29
    30a6:	cf 91       	pop	r28
    30a8:	1f 91       	pop	r17
    30aa:	0f 91       	pop	r16
    30ac:	ff 90       	pop	r15
    30ae:	ef 90       	pop	r14
    30b0:	df 90       	pop	r13
    30b2:	cf 90       	pop	r12
    30b4:	08 95       	ret

000030b6 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    30b6:	0f 93       	push	r16
    30b8:	1f 93       	push	r17
    30ba:	cf 93       	push	r28
    30bc:	df 93       	push	r29
    30be:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    30c0:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    30c4:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    30c8:	00 97       	sbiw	r24, 0x00	; 0
    30ca:	19 f0       	breq	.+6      	; 0x30d2 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    30cc:	be 01       	movw	r22, r28
    30ce:	0e 94 0d 18 	call	0x301a	; 0x301a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    30d2:	6a e0       	ldi	r22, 0x0A	; 10
    30d4:	ce 01       	movw	r24, r28
    30d6:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    30da:	8c 01       	movw	r16, r24
    30dc:	69 e9       	ldi	r22, 0x99	; 153
    30de:	76 e0       	ldi	r23, 0x06	; 6
    30e0:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    30e4:	6a e0       	ldi	r22, 0x0A	; 10
    30e6:	c8 01       	movw	r24, r16
    30e8:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    30ec:	8c 01       	movw	r16, r24
    30ee:	6e e8       	ldi	r22, 0x8E	; 142
    30f0:	76 e0       	ldi	r23, 0x06	; 6
    30f2:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    30f6:	6a e0       	ldi	r22, 0x0A	; 10
    30f8:	c8 01       	movw	r24, r16
    30fa:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    30fe:	8c 01       	movw	r16, r24
    3100:	68 e8       	ldi	r22, 0x88	; 136
    3102:	76 e0       	ldi	r23, 0x06	; 6
    3104:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    3108:	66 e0       	ldi	r22, 0x06	; 6
    310a:	c8 01       	movw	r24, r16
    310c:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    3110:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <portStackTopForTask>
    3114:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <portStackTopForTask+0x1>
    3118:	bc 01       	movw	r22, r24
    311a:	6f 5f       	subi	r22, 0xFF	; 255
    311c:	7f 4f       	sbci	r23, 0xFF	; 255
    311e:	01 e1       	ldi	r16, 0x11	; 17
    3120:	21 e0       	ldi	r18, 0x01	; 1
    3122:	ae 01       	movw	r20, r28
    3124:	83 56       	subi	r24, 0x63	; 99
    3126:	91 09       	sbc	r25, r1
    3128:	0e 94 0f 1b 	call	0x361e	; 0x361e <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    312c:	df 91       	pop	r29
    312e:	cf 91       	pop	r28
    3130:	1f 91       	pop	r17
    3132:	0f 91       	pop	r16
    3134:	08 95       	ret

00003136 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3136:	8f 92       	push	r8
    3138:	9f 92       	push	r9
    313a:	af 92       	push	r10
    313c:	bf 92       	push	r11
    313e:	cf 92       	push	r12
    3140:	df 92       	push	r13
    3142:	ef 92       	push	r14
    3144:	ff 92       	push	r15
    3146:	0f 93       	push	r16
    3148:	1f 93       	push	r17
    314a:	cf 93       	push	r28
    314c:	df 93       	push	r29
    314e:	ec 01       	movw	r28, r24
    3150:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    3152:	8a 81       	ldd	r24, Y+2	; 0x02
    3154:	9b 81       	ldd	r25, Y+3	; 0x03
    3156:	0e 94 19 13 	call	0x2632	; 0x2632 <pcTaskGetTaskName>
    315a:	bc 01       	movw	r22, r24
    315c:	c8 01       	movw	r24, r16
    315e:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    3162:	d8 01       	movw	r26, r16
    3164:	ed 91       	ld	r30, X+
    3166:	fc 91       	ld	r31, X
    3168:	02 80       	ldd	r0, Z+2	; 0x02
    316a:	f3 81       	ldd	r31, Z+3	; 0x03
    316c:	e0 2d       	mov	r30, r0
    316e:	69 e0       	ldi	r22, 0x09	; 9
    3170:	c8 01       	movw	r24, r16
    3172:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    3174:	8a 81       	ldd	r24, Y+2	; 0x02
    3176:	9b 81       	ldd	r25, Y+3	; 0x03
    3178:	0e 94 19 13 	call	0x2632	; 0x2632 <pcTaskGetTaskName>
    317c:	fc 01       	movw	r30, r24
    317e:	01 90       	ld	r0, Z+
    3180:	00 20       	and	r0, r0
    3182:	e9 f7       	brne	.-6      	; 0x317e <_ZN8frt_task12print_statusER8emstream+0x48>
    3184:	31 97       	sbiw	r30, 0x01	; 1
    3186:	e8 1b       	sub	r30, r24
    3188:	f9 0b       	sbc	r31, r25
    318a:	38 97       	sbiw	r30, 0x08	; 8
    318c:	48 f4       	brcc	.+18     	; 0x31a0 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    318e:	d8 01       	movw	r26, r16
    3190:	ed 91       	ld	r30, X+
    3192:	fc 91       	ld	r31, X
    3194:	02 80       	ldd	r0, Z+2	; 0x02
    3196:	f3 81       	ldd	r31, Z+3	; 0x03
    3198:	e0 2d       	mov	r30, r0
    319a:	69 e0       	ldi	r22, 0x09	; 9
    319c:	c8 01       	movw	r24, r16
    319e:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    31a0:	ce 84       	ldd	r12, Y+14	; 0x0e
    31a2:	df 84       	ldd	r13, Y+15	; 0x0f
    31a4:	e8 88       	ldd	r14, Y+16	; 0x10
    31a6:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    31a8:	a8 84       	ldd	r10, Y+8	; 0x08
    31aa:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    31ac:	8a 81       	ldd	r24, Y+2	; 0x02
    31ae:	9b 81       	ldd	r25, Y+3	; 0x03
    31b0:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <uxTaskGetStackHighWaterMark>
    31b4:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    31b6:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    31b8:	8a 81       	ldd	r24, Y+2	; 0x02
    31ba:	9b 81       	ldd	r25, Y+3	; 0x03
    31bc:	0e 94 c4 12 	call	0x2588	; 0x2588 <uxTaskPriorityGet>
    31c0:	68 2f       	mov	r22, r24
    31c2:	c8 01       	movw	r24, r16
    31c4:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
    31c8:	6a e0       	ldi	r22, 0x0A	; 10
    31ca:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    31ce:	ec 01       	movw	r28, r24
    31d0:	6e e0       	ldi	r22, 0x0E	; 14
    31d2:	77 e0       	ldi	r23, 0x07	; 7
    31d4:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
			<< get_state ()
    31d8:	68 2d       	mov	r22, r8
    31da:	ce 01       	movw	r24, r28
    31dc:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    31e0:	6a e0       	ldi	r22, 0x0A	; 10
    31e2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    31e6:	ec 01       	movw	r28, r24
    31e8:	6c e0       	ldi	r22, 0x0C	; 12
    31ea:	77 e0       	ldi	r23, 0x07	; 7
    31ec:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    31f0:	69 2d       	mov	r22, r9
    31f2:	ce 01       	movw	r24, r28
    31f4:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
    31f8:	6a e0       	ldi	r22, 0x0A	; 10
    31fa:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    31fe:	ec 01       	movw	r28, r24
    3200:	6a e0       	ldi	r22, 0x0A	; 10
    3202:	77 e0       	ldi	r23, 0x07	; 7
    3204:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3208:	b5 01       	movw	r22, r10
    320a:	ce 01       	movw	r24, r28
    320c:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <_ZN8emstreamlsEj>
    3210:	6a e0       	ldi	r22, 0x0A	; 10
    3212:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3216:	ec 01       	movw	r28, r24
    3218:	68 e0       	ldi	r22, 0x08	; 8
    321a:	77 e0       	ldi	r23, 0x07	; 7
    321c:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    3220:	6a e0       	ldi	r22, 0x0A	; 10
    3222:	ce 01       	movw	r24, r28
    3224:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3228:	ec 01       	movw	r28, r24
    322a:	66 e0       	ldi	r22, 0x06	; 6
    322c:	77 e0       	ldi	r23, 0x07	; 7
    322e:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    3232:	b7 01       	movw	r22, r14
    3234:	a6 01       	movw	r20, r12
    3236:	ce 01       	movw	r24, r28
    3238:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <_ZN8emstreamlsEm>
}
    323c:	df 91       	pop	r29
    323e:	cf 91       	pop	r28
    3240:	1f 91       	pop	r17
    3242:	0f 91       	pop	r16
    3244:	ff 90       	pop	r15
    3246:	ef 90       	pop	r14
    3248:	df 90       	pop	r13
    324a:	cf 90       	pop	r12
    324c:	bf 90       	pop	r11
    324e:	af 90       	pop	r10
    3250:	9f 90       	pop	r9
    3252:	8f 90       	pop	r8
    3254:	08 95       	ret

00003256 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3256:	cf 93       	push	r28
    3258:	df 93       	push	r29
    325a:	ec 01       	movw	r28, r24
    325c:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    325e:	db 01       	movw	r26, r22
    3260:	ed 91       	ld	r30, X+
    3262:	fc 91       	ld	r31, X
    3264:	02 80       	ldd	r0, Z+2	; 0x02
    3266:	f3 81       	ldd	r31, Z+3	; 0x03
    3268:	e0 2d       	mov	r30, r0
    326a:	be 01       	movw	r22, r28
    326c:	19 95       	eicall
	return (ser_dev);
}
    326e:	ce 01       	movw	r24, r28
    3270:	df 91       	pop	r29
    3272:	cf 91       	pop	r28
    3274:	08 95       	ret

00003276 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3276:	0f 93       	push	r16
    3278:	1f 93       	push	r17
    327a:	cf 93       	push	r28
    327c:	df 93       	push	r29
    327e:	ec 01       	movw	r28, r24
    3280:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    3282:	bc 01       	movw	r22, r24
    3284:	c8 01       	movw	r24, r16
    3286:	0e 94 2b 19 	call	0x3256	; 0x3256 <_ZlsR8emstreamR8frt_task>
    328a:	66 e0       	ldi	r22, 0x06	; 6
    328c:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    3290:	8c 81       	ldd	r24, Y+4	; 0x04
    3292:	9d 81       	ldd	r25, Y+5	; 0x05
    3294:	00 97       	sbiw	r24, 0x00	; 0
    3296:	19 f0       	breq	.+6      	; 0x329e <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3298:	b8 01       	movw	r22, r16
    329a:	0e 94 3b 19 	call	0x3276	; 0x3276 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    329e:	df 91       	pop	r29
    32a0:	cf 91       	pop	r28
    32a2:	1f 91       	pop	r17
    32a4:	0f 91       	pop	r16
    32a6:	08 95       	ret

000032a8 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    32a8:	0f 93       	push	r16
    32aa:	1f 93       	push	r17
    32ac:	cf 93       	push	r28
    32ae:	df 93       	push	r29
    32b0:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    32b2:	6a e0       	ldi	r22, 0x0A	; 10
    32b4:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    32b8:	8c 01       	movw	r16, r24
    32ba:	6b ef       	ldi	r22, 0xFB	; 251
    32bc:	76 e0       	ldi	r23, 0x06	; 6
    32be:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    32c2:	6a e0       	ldi	r22, 0x0A	; 10
    32c4:	c8 01       	movw	r24, r16
    32c6:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    32ca:	8c 01       	movw	r16, r24
    32cc:	64 ef       	ldi	r22, 0xF4	; 244
    32ce:	76 e0       	ldi	r23, 0x06	; 6
    32d0:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    32d4:	66 e0       	ldi	r22, 0x06	; 6
    32d6:	c8 01       	movw	r24, r16
    32d8:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    32dc:	6a e0       	ldi	r22, 0x0A	; 10
    32de:	ce 01       	movw	r24, r28
    32e0:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    32e4:	8c 01       	movw	r16, r24
    32e6:	63 ee       	ldi	r22, 0xE3	; 227
    32e8:	76 e0       	ldi	r23, 0x06	; 6
    32ea:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    32ee:	6a e0       	ldi	r22, 0x0A	; 10
    32f0:	c8 01       	movw	r24, r16
    32f2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    32f6:	8c 01       	movw	r16, r24
    32f8:	67 ed       	ldi	r22, 0xD7	; 215
    32fa:	76 e0       	ldi	r23, 0x06	; 6
    32fc:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    3300:	6a e0       	ldi	r22, 0x0A	; 10
    3302:	c8 01       	movw	r24, r16
    3304:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3308:	8c 01       	movw	r16, r24
    330a:	61 ed       	ldi	r22, 0xD1	; 209
    330c:	76 e0       	ldi	r23, 0x06	; 6
    330e:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    3312:	66 e0       	ldi	r22, 0x06	; 6
    3314:	c8 01       	movw	r24, r16
    3316:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    331a:	6a e0       	ldi	r22, 0x0A	; 10
    331c:	ce 01       	movw	r24, r28
    331e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3322:	8c 01       	movw	r16, r24
    3324:	60 ec       	ldi	r22, 0xC0	; 192
    3326:	76 e0       	ldi	r23, 0x06	; 6
    3328:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    332c:	6a e0       	ldi	r22, 0x0A	; 10
    332e:	c8 01       	movw	r24, r16
    3330:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3334:	8c 01       	movw	r16, r24
    3336:	64 eb       	ldi	r22, 0xB4	; 180
    3338:	76 e0       	ldi	r23, 0x06	; 6
    333a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    333e:	6a e0       	ldi	r22, 0x0A	; 10
    3340:	c8 01       	movw	r24, r16
    3342:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3346:	8c 01       	movw	r16, r24
    3348:	6e ea       	ldi	r22, 0xAE	; 174
    334a:	76 e0       	ldi	r23, 0x06	; 6
    334c:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    3350:	66 e0       	ldi	r22, 0x06	; 6
    3352:	c8 01       	movw	r24, r16
    3354:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3358:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    335c:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    3360:	00 97       	sbiw	r24, 0x00	; 0
    3362:	19 f0       	breq	.+6      	; 0x336a <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    3364:	be 01       	movw	r22, r28
    3366:	0e 94 3b 19 	call	0x3276	; 0x3276 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    336a:	0e 94 21 13 	call	0x2642	; 0x2642 <xTaskGetIdleTaskHandle>
    336e:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <uxTaskGetStackHighWaterMark>
    3372:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    3374:	6a e0       	ldi	r22, 0x0A	; 10
    3376:	ce 01       	movw	r24, r28
    3378:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    337c:	ec 01       	movw	r28, r24
    337e:	63 ea       	ldi	r22, 0xA3	; 163
    3380:	76 e0       	ldi	r23, 0x06	; 6
    3382:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3386:	61 2f       	mov	r22, r17
    3388:	ce 01       	movw	r24, r28
    338a:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    338e:	6a e0       	ldi	r22, 0x0A	; 10
    3390:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3394:	ec 01       	movw	r28, r24
    3396:	61 ea       	ldi	r22, 0xA1	; 161
    3398:	76 e0       	ldi	r23, 0x06	; 6
    339a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    339e:	64 e6       	ldi	r22, 0x64	; 100
    33a0:	70 e0       	ldi	r23, 0x00	; 0
    33a2:	ce 01       	movw	r24, r28
    33a4:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <_ZN8emstreamlsEj>
    33a8:	6a e0       	ldi	r22, 0x0A	; 10
    33aa:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    33ae:	ec 01       	movw	r28, r24
    33b0:	6e e9       	ldi	r22, 0x9E	; 158
    33b2:	76 e0       	ldi	r23, 0x06	; 6
    33b4:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    33b8:	66 e0       	ldi	r22, 0x06	; 6
    33ba:	ce 01       	movw	r24, r28
    33bc:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
}
    33c0:	df 91       	pop	r29
    33c2:	cf 91       	pop	r28
    33c4:	1f 91       	pop	r17
    33c6:	0f 91       	pop	r16
    33c8:	08 95       	ret

000033ca <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    33ca:	0f 93       	push	r16
    33cc:	cf 93       	push	r28
    33ce:	df 93       	push	r29
    33d0:	1f 92       	push	r1
    33d2:	cd b7       	in	r28, 0x3d	; 61
    33d4:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    33d6:	00 e0       	ldi	r16, 0x00	; 0
    33d8:	2f ef       	ldi	r18, 0xFF	; 255
    33da:	3f ef       	ldi	r19, 0xFF	; 255
    33dc:	a9 01       	movw	r20, r18
    33de:	be 01       	movw	r22, r28
    33e0:	6f 5f       	subi	r22, 0xFF	; 255
    33e2:	7f 4f       	sbci	r23, 0xFF	; 255
    33e4:	fc 01       	movw	r30, r24
    33e6:	80 85       	ldd	r24, Z+8	; 0x08
    33e8:	91 85       	ldd	r25, Z+9	; 0x09
    33ea:	0e 94 a0 10 	call	0x2140	; 0x2140 <xQueueGenericReceive>
    33ee:	81 30       	cpi	r24, 0x01	; 1
    33f0:	19 f4       	brne	.+6      	; 0x33f8 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    33f2:	89 81       	ldd	r24, Y+1	; 0x01
    33f4:	90 e0       	ldi	r25, 0x00	; 0
    33f6:	02 c0       	rjmp	.+4      	; 0x33fc <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    33f8:	8f ef       	ldi	r24, 0xFF	; 255
    33fa:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    33fc:	0f 90       	pop	r0
    33fe:	df 91       	pop	r29
    3400:	cf 91       	pop	r28
    3402:	0f 91       	pop	r16
    3404:	08 95       	ret

00003406 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3406:	fc 01       	movw	r30, r24
    3408:	80 85       	ldd	r24, Z+8	; 0x08
    340a:	91 85       	ldd	r25, Z+9	; 0x09
    340c:	0e 94 64 11 	call	0x22c8	; 0x22c8 <uxQueueMessagesWaiting>
    3410:	91 e0       	ldi	r25, 0x01	; 1
    3412:	81 11       	cpse	r24, r1
    3414:	01 c0       	rjmp	.+2      	; 0x3418 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3416:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3418:	89 2f       	mov	r24, r25
    341a:	08 95       	ret

0000341c <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    341c:	0f 93       	push	r16
    341e:	cf 93       	push	r28
    3420:	df 93       	push	r29
    3422:	1f 92       	push	r1
    3424:	cd b7       	in	r28, 0x3d	; 61
    3426:	de b7       	in	r29, 0x3e	; 62
    3428:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    342a:	fc 01       	movw	r30, r24
    342c:	22 85       	ldd	r18, Z+10	; 0x0a
    342e:	33 85       	ldd	r19, Z+11	; 0x0b
    3430:	44 85       	ldd	r20, Z+12	; 0x0c
    3432:	55 85       	ldd	r21, Z+13	; 0x0d
    3434:	00 e0       	ldi	r16, 0x00	; 0
    3436:	be 01       	movw	r22, r28
    3438:	6f 5f       	subi	r22, 0xFF	; 255
    343a:	7f 4f       	sbci	r23, 0xFF	; 255
    343c:	80 85       	ldd	r24, Z+8	; 0x08
    343e:	91 85       	ldd	r25, Z+9	; 0x09
    3440:	0e 94 05 10 	call	0x200a	; 0x200a <xQueueGenericSend>
    3444:	91 e0       	ldi	r25, 0x01	; 1
    3446:	81 11       	cpse	r24, r1
    3448:	01 c0       	rjmp	.+2      	; 0x344c <_ZN14frt_text_queue7putcharEc+0x30>
    344a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    344c:	89 2f       	mov	r24, r25
    344e:	0f 90       	pop	r0
    3450:	df 91       	pop	r29
    3452:	cf 91       	pop	r28
    3454:	0f 91       	pop	r16
    3456:	08 95       	ret

00003458 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3458:	8f 92       	push	r8
    345a:	9f 92       	push	r9
    345c:	bf 92       	push	r11
    345e:	cf 92       	push	r12
    3460:	df 92       	push	r13
    3462:	ef 92       	push	r14
    3464:	ff 92       	push	r15
    3466:	0f 93       	push	r16
    3468:	1f 93       	push	r17
    346a:	cf 93       	push	r28
    346c:	df 93       	push	r29
    346e:	ec 01       	movw	r28, r24
    3470:	b6 2e       	mov	r11, r22
    3472:	4a 01       	movw	r8, r20
    3474:	68 01       	movw	r12, r16
    3476:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3478:	0e 94 66 1c 	call	0x38cc	; 0x38cc <_ZN8emstreamC1Ev>
    347c:	8b e4       	ldi	r24, 0x4B	; 75
    347e:	90 e2       	ldi	r25, 0x20	; 32
    3480:	88 83       	st	Y, r24
    3482:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3484:	8e 86       	std	Y+14, r8	; 0x0e
    3486:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3488:	40 e0       	ldi	r20, 0x00	; 0
    348a:	61 e0       	ldi	r22, 0x01	; 1
    348c:	8b 2d       	mov	r24, r11
    348e:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <xQueueGenericCreate>
    3492:	88 87       	std	Y+8, r24	; 0x08
    3494:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3496:	ca 86       	std	Y+10, r12	; 0x0a
    3498:	db 86       	std	Y+11, r13	; 0x0b
    349a:	ec 86       	std	Y+12, r14	; 0x0c
    349c:	fd 86       	std	Y+13, r15	; 0x0d
}
    349e:	df 91       	pop	r29
    34a0:	cf 91       	pop	r28
    34a2:	1f 91       	pop	r17
    34a4:	0f 91       	pop	r16
    34a6:	ff 90       	pop	r15
    34a8:	ef 90       	pop	r14
    34aa:	df 90       	pop	r13
    34ac:	cf 90       	pop	r12
    34ae:	bf 90       	pop	r11
    34b0:	9f 90       	pop	r9
    34b2:	8f 90       	pop	r8
    34b4:	08 95       	ret

000034b6 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    34b6:	cf 92       	push	r12
    34b8:	df 92       	push	r13
    34ba:	ef 92       	push	r14
    34bc:	ff 92       	push	r15
    34be:	cf 93       	push	r28
    34c0:	df 93       	push	r29
    34c2:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    34c4:	68 81       	ld	r22, Y
    34c6:	79 81       	ldd	r23, Y+1	; 0x01
    34c8:	8a 81       	ldd	r24, Y+2	; 0x02
    34ca:	9b 81       	ldd	r25, Y+3	; 0x03
    34cc:	0f 2e       	mov	r0, r31
    34ce:	f8 ee       	ldi	r31, 0xE8	; 232
    34d0:	cf 2e       	mov	r12, r31
    34d2:	f3 e0       	ldi	r31, 0x03	; 3
    34d4:	df 2e       	mov	r13, r31
    34d6:	e1 2c       	mov	r14, r1
    34d8:	f1 2c       	mov	r15, r1
    34da:	f0 2d       	mov	r31, r0
    34dc:	a7 01       	movw	r20, r14
    34de:	96 01       	movw	r18, r12
    34e0:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__udivmodsi4>
    34e4:	9b 01       	movw	r18, r22
    34e6:	ac 01       	movw	r20, r24
    34e8:	60 e4       	ldi	r22, 0x40	; 64
    34ea:	72 e4       	ldi	r23, 0x42	; 66
    34ec:	8f e0       	ldi	r24, 0x0F	; 15
    34ee:	90 e0       	ldi	r25, 0x00	; 0
    34f0:	0e 94 c4 21 	call	0x4388	; 0x4388 <__mulsi3>
    34f4:	a7 01       	movw	r20, r14
    34f6:	96 01       	movw	r18, r12
    34f8:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__udivmodsi4>
    34fc:	69 01       	movw	r12, r18
    34fe:	7a 01       	movw	r14, r20
    3500:	ac 81       	ldd	r26, Y+4	; 0x04
    3502:	bd 81       	ldd	r27, Y+5	; 0x05
    3504:	20 e4       	ldi	r18, 0x40	; 64
    3506:	32 e4       	ldi	r19, 0x42	; 66
    3508:	4f e0       	ldi	r20, 0x0F	; 15
    350a:	50 e0       	ldi	r21, 0x00	; 0
    350c:	0e 94 50 22 	call	0x44a0	; 0x44a0 <__muluhisi3>
    3510:	20 e0       	ldi	r18, 0x00	; 0
    3512:	38 e4       	ldi	r19, 0x48	; 72
    3514:	48 ee       	ldi	r20, 0xE8	; 232
    3516:	51 e0       	ldi	r21, 0x01	; 1
    3518:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__udivmodsi4>
    351c:	c7 01       	movw	r24, r14
    351e:	b6 01       	movw	r22, r12
    3520:	62 0f       	add	r22, r18
    3522:	73 1f       	adc	r23, r19
    3524:	84 1f       	adc	r24, r20
    3526:	95 1f       	adc	r25, r21
}
    3528:	df 91       	pop	r29
    352a:	cf 91       	pop	r28
    352c:	ff 90       	pop	r15
    352e:	ef 90       	pop	r14
    3530:	df 90       	pop	r13
    3532:	cf 90       	pop	r12
    3534:	08 95       	ret

00003536 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3536:	cf 92       	push	r12
    3538:	df 92       	push	r13
    353a:	ef 92       	push	r14
    353c:	ff 92       	push	r15
    353e:	0f 93       	push	r16
    3540:	1f 93       	push	r17
    3542:	cf 93       	push	r28
    3544:	df 93       	push	r29
    3546:	cd b7       	in	r28, 0x3d	; 61
    3548:	de b7       	in	r29, 0x3e	; 62
    354a:	2f 97       	sbiw	r28, 0x0f	; 15
    354c:	cd bf       	out	0x3d, r28	; 61
    354e:	de bf       	out	0x3e, r29	; 62
    3550:	6c 01       	movw	r12, r24
    3552:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3554:	db 01       	movw	r26, r22
    3556:	6d 91       	ld	r22, X+
    3558:	7d 91       	ld	r23, X+
    355a:	8d 91       	ld	r24, X+
    355c:	9c 91       	ld	r25, X
    355e:	28 ee       	ldi	r18, 0xE8	; 232
    3560:	33 e0       	ldi	r19, 0x03	; 3
    3562:	40 e0       	ldi	r20, 0x00	; 0
    3564:	50 e0       	ldi	r21, 0x00	; 0
    3566:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__udivmodsi4>
    356a:	ba 01       	movw	r22, r20
    356c:	a9 01       	movw	r20, r18
    356e:	c6 01       	movw	r24, r12
    3570:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3574:	d6 01       	movw	r26, r12
    3576:	ed 91       	ld	r30, X+
    3578:	fc 91       	ld	r31, X
    357a:	02 80       	ldd	r0, Z+2	; 0x02
    357c:	f3 81       	ldd	r31, Z+3	; 0x03
    357e:	e0 2d       	mov	r30, r0
    3580:	6e e2       	ldi	r22, 0x2E	; 46
    3582:	c6 01       	movw	r24, r12
    3584:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3586:	c8 01       	movw	r24, r16
    3588:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN10time_stamp12get_microsecEv>
    358c:	8e 01       	movw	r16, r28
    358e:	09 5f       	subi	r16, 0xF9	; 249
    3590:	1f 4f       	sbci	r17, 0xFF	; 255
    3592:	fe 01       	movw	r30, r28
    3594:	31 96       	adiw	r30, 0x01	; 1
    3596:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3598:	2a e0       	ldi	r18, 0x0A	; 10
    359a:	30 e0       	ldi	r19, 0x00	; 0
    359c:	40 e0       	ldi	r20, 0x00	; 0
    359e:	50 e0       	ldi	r21, 0x00	; 0
    35a0:	0e 94 0a 22 	call	0x4414	; 0x4414 <__divmodsi4>
    35a4:	e6 2f       	mov	r30, r22
    35a6:	28 87       	std	Y+8, r18	; 0x08
    35a8:	39 87       	std	Y+9, r19	; 0x09
    35aa:	4a 87       	std	Y+10, r20	; 0x0a
    35ac:	5b 87       	std	Y+11, r21	; 0x0b
    35ae:	68 85       	ldd	r22, Y+8	; 0x08
    35b0:	79 85       	ldd	r23, Y+9	; 0x09
    35b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    35b4:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    35b6:	20 e3       	ldi	r18, 0x30	; 48
    35b8:	2e 0f       	add	r18, r30
    35ba:	d8 01       	movw	r26, r16
    35bc:	2e 93       	st	-X, r18
    35be:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    35c0:	ae 15       	cp	r26, r14
    35c2:	bf 05       	cpc	r27, r15
    35c4:	49 f7       	brne	.-46     	; 0x3598 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    35c6:	1f 82       	std	Y+7, r1	; 0x07
    35c8:	be 01       	movw	r22, r28
    35ca:	6f 5f       	subi	r22, 0xFF	; 255
    35cc:	7f 4f       	sbci	r23, 0xFF	; 255
    35ce:	c6 01       	movw	r24, r12
    35d0:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    35d4:	c6 01       	movw	r24, r12
    35d6:	2f 96       	adiw	r28, 0x0f	; 15
    35d8:	cd bf       	out	0x3d, r28	; 61
    35da:	de bf       	out	0x3e, r29	; 62
    35dc:	df 91       	pop	r29
    35de:	cf 91       	pop	r28
    35e0:	1f 91       	pop	r17
    35e2:	0f 91       	pop	r16
    35e4:	ff 90       	pop	r15
    35e6:	ef 90       	pop	r14
    35e8:	df 90       	pop	r13
    35ea:	cf 90       	pop	r12
    35ec:	08 95       	ret

000035ee <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    35ee:	cf 93       	push	r28
    35f0:	df 93       	push	r29
    35f2:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    35f4:	0f b6       	in	r0, 0x3f	; 63
    35f6:	f8 94       	cli
    35f8:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    35fa:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    35fe:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3602:	8c 83       	std	Y+4, r24	; 0x04
    3604:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3606:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskGetTickCount>
    360a:	68 83       	st	Y, r22
    360c:	79 83       	std	Y+1, r23	; 0x01
    360e:	8a 83       	std	Y+2, r24	; 0x02
    3610:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3612:	0f 90       	pop	r0
    3614:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3616:	ce 01       	movw	r24, r28
    3618:	df 91       	pop	r29
    361a:	cf 91       	pop	r28
    361c:	08 95       	ret

0000361e <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    361e:	5f 92       	push	r5
    3620:	6f 92       	push	r6
    3622:	7f 92       	push	r7
    3624:	8f 92       	push	r8
    3626:	9f 92       	push	r9
    3628:	af 92       	push	r10
    362a:	bf 92       	push	r11
    362c:	cf 92       	push	r12
    362e:	df 92       	push	r13
    3630:	ef 92       	push	r14
    3632:	ff 92       	push	r15
    3634:	0f 93       	push	r16
    3636:	1f 93       	push	r17
    3638:	cf 93       	push	r28
    363a:	df 93       	push	r29
    363c:	5c 01       	movw	r10, r24
    363e:	4b 01       	movw	r8, r22
    3640:	7a 01       	movw	r14, r20
    3642:	12 2f       	mov	r17, r18
    3644:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3646:	63 e0       	ldi	r22, 0x03	; 3
    3648:	ca 01       	movw	r24, r20
    364a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    364e:	a8 14       	cp	r10, r8
    3650:	b9 04       	cpc	r11, r9
    3652:	08 f0       	brcs	.+2      	; 0x3656 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3654:	7d c0       	rjmp	.+250    	; 0x3750 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3656:	65 01       	movw	r12, r10
    3658:	84 e1       	ldi	r24, 0x14	; 20
    365a:	c8 0e       	add	r12, r24
    365c:	d1 1c       	adc	r13, r1
    365e:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3660:	6a 2c       	mov	r6, r10
    3662:	5b 2c       	mov	r5, r11
    3664:	b5 01       	movw	r22, r10
    3666:	c7 01       	movw	r24, r14
    3668:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <_ZN8emstreamlsEj>
    366c:	6a e0       	ldi	r22, 0x0A	; 10
    366e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3672:	60 e2       	ldi	r22, 0x20	; 32
    3674:	77 e0       	ldi	r23, 0x07	; 7
    3676:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    367a:	11 23       	and	r17, r17
    367c:	09 f4       	brne	.+2      	; 0x3680 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    367e:	6d c0       	rjmp	.+218    	; 0x375a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3680:	00 23       	and	r16, r16
    3682:	09 f4       	brne	.+2      	; 0x3686 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3684:	6a c0       	rjmp	.+212    	; 0x375a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3686:	6a e0       	ldi	r22, 0x0A	; 10
    3688:	c7 01       	movw	r24, r14
    368a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    368e:	6b e1       	ldi	r22, 0x1B	; 27
    3690:	77 e0       	ldi	r23, 0x07	; 7
    3692:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    3696:	61 c0       	rjmp	.+194    	; 0x375a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3698:	11 23       	and	r17, r17
    369a:	71 f0       	breq	.+28     	; 0x36b8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    369c:	01 11       	cpse	r16, r1
    369e:	0c c0       	rjmp	.+24     	; 0x36b8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    36a0:	88 81       	ld	r24, Y
    36a2:	87 15       	cp	r24, r7
    36a4:	49 f0       	breq	.+18     	; 0x36b8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    36a6:	6a e0       	ldi	r22, 0x0A	; 10
    36a8:	c7 01       	movw	r24, r14
    36aa:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    36ae:	66 e1       	ldi	r22, 0x16	; 22
    36b0:	77 e0       	ldi	r23, 0x07	; 7
    36b2:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    36b6:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    36b8:	69 91       	ld	r22, Y+
    36ba:	c7 01       	movw	r24, r14
    36bc:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    36c0:	dc 01       	movw	r26, r24
    36c2:	ed 91       	ld	r30, X+
    36c4:	fc 91       	ld	r31, X
    36c6:	02 80       	ldd	r0, Z+2	; 0x02
    36c8:	f3 81       	ldd	r31, Z+3	; 0x03
    36ca:	e0 2d       	mov	r30, r0
    36cc:	60 e2       	ldi	r22, 0x20	; 32
    36ce:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    36d0:	cc 16       	cp	r12, r28
    36d2:	dd 06       	cpc	r13, r29
    36d4:	09 f7       	brne	.-62     	; 0x3698 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    36d6:	11 23       	and	r17, r17
    36d8:	89 f0       	breq	.+34     	; 0x36fc <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    36da:	6a e0       	ldi	r22, 0x0A	; 10
    36dc:	c7 01       	movw	r24, r14
    36de:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    36e2:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    36e4:	60 e1       	ldi	r22, 0x10	; 16
    36e6:	77 e0       	ldi	r23, 0x07	; 7
    36e8:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    36ec:	e8 81       	ld	r30, Y
    36ee:	f9 81       	ldd	r31, Y+1	; 0x01
    36f0:	02 80       	ldd	r0, Z+2	; 0x02
    36f2:	f3 81       	ldd	r31, Z+3	; 0x03
    36f4:	e0 2d       	mov	r30, r0
    36f6:	60 e2       	ldi	r22, 0x20	; 32
    36f8:	ce 01       	movw	r24, r28
    36fa:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    36fc:	c6 2d       	mov	r28, r6
    36fe:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3700:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3702:	80 ee       	ldi	r24, 0xE0	; 224
    3704:	86 0f       	add	r24, r22
    3706:	8f 35       	cpi	r24, 0x5F	; 95
    3708:	48 f4       	brcc	.+18     	; 0x371c <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    370a:	d7 01       	movw	r26, r14
    370c:	ed 91       	ld	r30, X+
    370e:	fc 91       	ld	r31, X
    3710:	02 80       	ldd	r0, Z+2	; 0x02
    3712:	f3 81       	ldd	r31, Z+3	; 0x03
    3714:	e0 2d       	mov	r30, r0
    3716:	c7 01       	movw	r24, r14
    3718:	19 95       	eicall
    371a:	09 c0       	rjmp	.+18     	; 0x372e <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    371c:	d7 01       	movw	r26, r14
    371e:	ed 91       	ld	r30, X+
    3720:	fc 91       	ld	r31, X
    3722:	02 80       	ldd	r0, Z+2	; 0x02
    3724:	f3 81       	ldd	r31, Z+3	; 0x03
    3726:	e0 2d       	mov	r30, r0
    3728:	6e e2       	ldi	r22, 0x2E	; 46
    372a:	c7 01       	movw	r24, r14
    372c:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    372e:	cc 16       	cp	r12, r28
    3730:	dd 06       	cpc	r13, r29
    3732:	31 f7       	brne	.-52     	; 0x3700 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3734:	b4 e1       	ldi	r27, 0x14	; 20
    3736:	ab 0e       	add	r10, r27
    3738:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    373a:	66 e0       	ldi	r22, 0x06	; 6
    373c:	c7 01       	movw	r24, r14
    373e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    3742:	84 e1       	ldi	r24, 0x14	; 20
    3744:	c8 0e       	add	r12, r24
    3746:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3748:	a8 14       	cp	r10, r8
    374a:	b9 04       	cpc	r11, r9
    374c:	08 f4       	brcc	.+2      	; 0x3750 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    374e:	88 cf       	rjmp	.-240    	; 0x3660 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3750:	62 e0       	ldi	r22, 0x02	; 2
    3752:	c7 01       	movw	r24, r14
    3754:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
}
    3758:	03 c0       	rjmp	.+6      	; 0x3760 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    375a:	c6 2d       	mov	r28, r6
    375c:	d5 2d       	mov	r29, r5
    375e:	9c cf       	rjmp	.-200    	; 0x3698 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3760:	df 91       	pop	r29
    3762:	cf 91       	pop	r28
    3764:	1f 91       	pop	r17
    3766:	0f 91       	pop	r16
    3768:	ff 90       	pop	r15
    376a:	ef 90       	pop	r14
    376c:	df 90       	pop	r13
    376e:	cf 90       	pop	r12
    3770:	bf 90       	pop	r11
    3772:	af 90       	pop	r10
    3774:	9f 90       	pop	r9
    3776:	8f 90       	pop	r8
    3778:	7f 90       	pop	r7
    377a:	6f 90       	pop	r6
    377c:	5f 90       	pop	r5
    377e:	08 95       	ret

00003780 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3780:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <pvPortMalloc>
    3784:	08 95       	ret

00003786 <_Znaj>:
    3786:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <pvPortMalloc>
    378a:	08 95       	ret

0000378c <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    378c:	08 95       	ret

0000378e <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    378e:	cf 93       	push	r28
    3790:	df 93       	push	r29
    3792:	fc 01       	movw	r30, r24
    3794:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3796:	40 3a       	cpi	r20, 0xA0	; 160
    3798:	68 e0       	ldi	r22, 0x08	; 8
    379a:	56 07       	cpc	r21, r22
    379c:	49 f4       	brne	.+18     	; 0x37b0 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    379e:	80 e4       	ldi	r24, 0x40	; 64
    37a0:	96 e0       	ldi	r25, 0x06	; 6
    37a2:	82 83       	std	Z+2, r24	; 0x02
    37a4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    37a6:	82 e0       	ldi	r24, 0x02	; 2
    37a8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    37aa:	83 e0       	ldi	r24, 0x03	; 3
    37ac:	85 83       	std	Z+5, r24	; 0x05
    37ae:	32 c0       	rjmp	.+100    	; 0x3814 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    37b0:	40 3b       	cpi	r20, 0xB0	; 176
    37b2:	78 e0       	ldi	r23, 0x08	; 8
    37b4:	57 07       	cpc	r21, r23
    37b6:	49 f4       	brne	.+18     	; 0x37ca <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    37b8:	80 e4       	ldi	r24, 0x40	; 64
    37ba:	96 e0       	ldi	r25, 0x06	; 6
    37bc:	82 83       	std	Z+2, r24	; 0x02
    37be:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    37c0:	86 e0       	ldi	r24, 0x06	; 6
    37c2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    37c4:	87 e0       	ldi	r24, 0x07	; 7
    37c6:	85 83       	std	Z+5, r24	; 0x05
    37c8:	25 c0       	rjmp	.+74     	; 0x3814 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    37ca:	40 3a       	cpi	r20, 0xA0	; 160
    37cc:	89 e0       	ldi	r24, 0x09	; 9
    37ce:	58 07       	cpc	r21, r24
    37d0:	49 f4       	brne	.+18     	; 0x37e4 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    37d2:	80 e6       	ldi	r24, 0x60	; 96
    37d4:	96 e0       	ldi	r25, 0x06	; 6
    37d6:	82 83       	std	Z+2, r24	; 0x02
    37d8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    37da:	82 e0       	ldi	r24, 0x02	; 2
    37dc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    37de:	83 e0       	ldi	r24, 0x03	; 3
    37e0:	85 83       	std	Z+5, r24	; 0x05
    37e2:	18 c0       	rjmp	.+48     	; 0x3814 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    37e4:	40 3b       	cpi	r20, 0xB0	; 176
    37e6:	69 e0       	ldi	r22, 0x09	; 9
    37e8:	56 07       	cpc	r21, r22
    37ea:	49 f4       	brne	.+18     	; 0x37fe <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    37ec:	80 e6       	ldi	r24, 0x60	; 96
    37ee:	96 e0       	ldi	r25, 0x06	; 6
    37f0:	82 83       	std	Z+2, r24	; 0x02
    37f2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    37f4:	86 e0       	ldi	r24, 0x06	; 6
    37f6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    37f8:	87 e0       	ldi	r24, 0x07	; 7
    37fa:	85 83       	std	Z+5, r24	; 0x05
    37fc:	0b c0       	rjmp	.+22     	; 0x3814 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    37fe:	40 3a       	cpi	r20, 0xA0	; 160
    3800:	5a 40       	sbci	r21, 0x0A	; 10
    3802:	41 f4       	brne	.+16     	; 0x3814 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3804:	80 e8       	ldi	r24, 0x80	; 128
    3806:	96 e0       	ldi	r25, 0x06	; 6
    3808:	82 83       	std	Z+2, r24	; 0x02
    380a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    380c:	82 e0       	ldi	r24, 0x02	; 2
    380e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3810:	83 e0       	ldi	r24, 0x03	; 3
    3812:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3814:	a6 83       	std	Z+6, r26	; 0x06
    3816:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3818:	cd 01       	movw	r24, r26
    381a:	01 96       	adiw	r24, 0x01	; 1
    381c:	80 87       	std	Z+8, r24	; 0x08
    381e:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3820:	03 96       	adiw	r24, 0x03	; 3
    3822:	82 87       	std	Z+10, r24	; 0x0a
    3824:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3826:	25 81       	ldd	r18, Z+5	; 0x05
    3828:	c2 81       	ldd	r28, Z+2	; 0x02
    382a:	d3 81       	ldd	r29, Z+3	; 0x03
    382c:	4c 81       	ldd	r20, Y+4	; 0x04
    382e:	81 e0       	ldi	r24, 0x01	; 1
    3830:	90 e0       	ldi	r25, 0x00	; 0
    3832:	bc 01       	movw	r22, r24
    3834:	02 c0       	rjmp	.+4      	; 0x383a <_ZN7base232C1EjP12USART_struct+0xac>
    3836:	66 0f       	add	r22, r22
    3838:	77 1f       	adc	r23, r23
    383a:	2a 95       	dec	r18
    383c:	e2 f7       	brpl	.-8      	; 0x3836 <_ZN7base232C1EjP12USART_struct+0xa8>
    383e:	9b 01       	movw	r18, r22
    3840:	24 2b       	or	r18, r20
    3842:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3844:	25 81       	ldd	r18, Z+5	; 0x05
    3846:	c2 81       	ldd	r28, Z+2	; 0x02
    3848:	d3 81       	ldd	r29, Z+3	; 0x03
    384a:	48 81       	ld	r20, Y
    384c:	bc 01       	movw	r22, r24
    384e:	02 c0       	rjmp	.+4      	; 0x3854 <_ZN7base232C1EjP12USART_struct+0xc6>
    3850:	66 0f       	add	r22, r22
    3852:	77 1f       	adc	r23, r23
    3854:	2a 95       	dec	r18
    3856:	e2 f7       	brpl	.-8      	; 0x3850 <_ZN7base232C1EjP12USART_struct+0xc2>
    3858:	9b 01       	movw	r18, r22
    385a:	24 2b       	or	r18, r20
    385c:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    385e:	34 81       	ldd	r19, Z+4	; 0x04
    3860:	c2 81       	ldd	r28, Z+2	; 0x02
    3862:	d3 81       	ldd	r29, Z+3	; 0x03
    3864:	28 81       	ld	r18, Y
    3866:	02 c0       	rjmp	.+4      	; 0x386c <_ZN7base232C1EjP12USART_struct+0xde>
    3868:	88 0f       	add	r24, r24
    386a:	99 1f       	adc	r25, r25
    386c:	3a 95       	dec	r19
    386e:	e2 f7       	brpl	.-8      	; 0x3868 <_ZN7base232C1EjP12USART_struct+0xda>
    3870:	80 95       	com	r24
    3872:	90 95       	com	r25
    3874:	82 23       	and	r24, r18
    3876:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3878:	80 e1       	ldi	r24, 0x10	; 16
    387a:	13 96       	adiw	r26, 0x03	; 3
    387c:	8c 93       	st	X, r24
    387e:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3880:	83 e0       	ldi	r24, 0x03	; 3
    3882:	15 96       	adiw	r26, 0x05	; 5
    3884:	8c 93       	st	X, r24
    3886:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3888:	80 ef       	ldi	r24, 0xF0	; 240
    388a:	17 96       	adiw	r26, 0x07	; 7
    388c:	8c 93       	st	X, r24
    388e:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3890:	81 e2       	ldi	r24, 0x21	; 33
    3892:	16 96       	adiw	r26, 0x06	; 6
    3894:	8c 93       	st	X, r24
    3896:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3898:	88 e1       	ldi	r24, 0x18	; 24
    389a:	14 96       	adiw	r26, 0x04	; 4
    389c:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    389e:	80 e8       	ldi	r24, 0x80	; 128
    38a0:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    38a2:	80 e4       	ldi	r24, 0x40	; 64
    38a4:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    38a6:	80 e2       	ldi	r24, 0x20	; 32
    38a8:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    38aa:	06 80       	ldd	r0, Z+6	; 0x06
    38ac:	f7 81       	ldd	r31, Z+7	; 0x07
    38ae:	e0 2d       	mov	r30, r0
    38b0:	80 81       	ld	r24, Z
    38b2:	80 81       	ld	r24, Z
}
    38b4:	df 91       	pop	r29
    38b6:	cf 91       	pop	r28
    38b8:	08 95       	ret

000038ba <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    38ba:	81 e0       	ldi	r24, 0x01	; 1
    38bc:	08 95       	ret

000038be <_ZN8emstream7getcharEv>:
    38be:	80 e0       	ldi	r24, 0x00	; 0
    38c0:	90 e0       	ldi	r25, 0x00	; 0
    38c2:	08 95       	ret

000038c4 <_ZN8emstream14check_for_charEv>:
    38c4:	80 e0       	ldi	r24, 0x00	; 0
    38c6:	08 95       	ret

000038c8 <_ZN8emstream12transmit_nowEv>:
    38c8:	08 95       	ret

000038ca <_ZN8emstream12clear_screenEv>:
    38ca:	08 95       	ret

000038cc <_ZN8emstreamC1Ev>:
    38cc:	fc 01       	movw	r30, r24
    38ce:	8b e5       	ldi	r24, 0x5B	; 91
    38d0:	90 e2       	ldi	r25, 0x20	; 32
    38d2:	80 83       	st	Z, r24
    38d4:	91 83       	std	Z+1, r25	; 0x01
    38d6:	8a e0       	ldi	r24, 0x0A	; 10
    38d8:	82 83       	std	Z+2, r24	; 0x02
    38da:	13 82       	std	Z+3, r1	; 0x03
    38dc:	83 e0       	ldi	r24, 0x03	; 3
    38de:	85 83       	std	Z+5, r24	; 0x05
    38e0:	14 82       	std	Z+4, r1	; 0x04
    38e2:	16 82       	std	Z+6, r1	; 0x06
    38e4:	17 82       	std	Z+7, r1	; 0x07
    38e6:	08 95       	ret

000038e8 <_ZN8emstream4putsEPKc>:
    38e8:	0f 93       	push	r16
    38ea:	1f 93       	push	r17
    38ec:	cf 93       	push	r28
    38ee:	df 93       	push	r29
    38f0:	8c 01       	movw	r16, r24
    38f2:	fb 01       	movw	r30, r22
    38f4:	dc 01       	movw	r26, r24
    38f6:	14 96       	adiw	r26, 0x04	; 4
    38f8:	8c 91       	ld	r24, X
    38fa:	81 11       	cpse	r24, r1
    38fc:	04 c0       	rjmp	.+8      	; 0x3906 <_ZN8emstream4putsEPKc+0x1e>
    38fe:	60 81       	ld	r22, Z
    3900:	61 11       	cpse	r22, r1
    3902:	17 c0       	rjmp	.+46     	; 0x3932 <_ZN8emstream4putsEPKc+0x4a>
    3904:	23 c0       	rjmp	.+70     	; 0x394c <_ZN8emstream4putsEPKc+0x64>
    3906:	d8 01       	movw	r26, r16
    3908:	14 96       	adiw	r26, 0x04	; 4
    390a:	1c 92       	st	X, r1
    390c:	eb 01       	movw	r28, r22
    390e:	21 96       	adiw	r28, 0x01	; 1
    3910:	64 91       	lpm	r22, Z
    3912:	66 23       	and	r22, r22
    3914:	d9 f0       	breq	.+54     	; 0x394c <_ZN8emstream4putsEPKc+0x64>
    3916:	d8 01       	movw	r26, r16
    3918:	ed 91       	ld	r30, X+
    391a:	fc 91       	ld	r31, X
    391c:	02 80       	ldd	r0, Z+2	; 0x02
    391e:	f3 81       	ldd	r31, Z+3	; 0x03
    3920:	e0 2d       	mov	r30, r0
    3922:	c8 01       	movw	r24, r16
    3924:	19 95       	eicall
    3926:	fe 01       	movw	r30, r28
    3928:	64 91       	lpm	r22, Z
    392a:	21 96       	adiw	r28, 0x01	; 1
    392c:	61 11       	cpse	r22, r1
    392e:	f3 cf       	rjmp	.-26     	; 0x3916 <_ZN8emstream4putsEPKc+0x2e>
    3930:	0d c0       	rjmp	.+26     	; 0x394c <_ZN8emstream4putsEPKc+0x64>
    3932:	ef 01       	movw	r28, r30
    3934:	21 96       	adiw	r28, 0x01	; 1
    3936:	d8 01       	movw	r26, r16
    3938:	ed 91       	ld	r30, X+
    393a:	fc 91       	ld	r31, X
    393c:	02 80       	ldd	r0, Z+2	; 0x02
    393e:	f3 81       	ldd	r31, Z+3	; 0x03
    3940:	e0 2d       	mov	r30, r0
    3942:	c8 01       	movw	r24, r16
    3944:	19 95       	eicall
    3946:	69 91       	ld	r22, Y+
    3948:	61 11       	cpse	r22, r1
    394a:	f5 cf       	rjmp	.-22     	; 0x3936 <_ZN8emstream4putsEPKc+0x4e>
    394c:	df 91       	pop	r29
    394e:	cf 91       	pop	r28
    3950:	1f 91       	pop	r17
    3952:	0f 91       	pop	r16
    3954:	08 95       	ret

00003956 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3956:	cf 93       	push	r28
    3958:	df 93       	push	r29
    395a:	ec 01       	movw	r28, r24
	switch (new_manip)
    395c:	86 2f       	mov	r24, r22
    395e:	90 e0       	ldi	r25, 0x00	; 0
    3960:	8b 30       	cpi	r24, 0x0B	; 11
    3962:	91 05       	cpc	r25, r1
    3964:	d8 f5       	brcc	.+118    	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
    3966:	fc 01       	movw	r30, r24
    3968:	88 27       	eor	r24, r24
    396a:	e6 5a       	subi	r30, 0xA6	; 166
    396c:	fe 4f       	sbci	r31, 0xFE	; 254
    396e:	8f 4f       	sbci	r24, 0xFF	; 255
    3970:	0c 94 29 22 	jmp	0x4452	; 0x4452 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3974:	82 e0       	ldi	r24, 0x02	; 2
    3976:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3978:	31 c0       	rjmp	.+98     	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    397a:	88 e0       	ldi	r24, 0x08	; 8
    397c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    397e:	2e c0       	rjmp	.+92     	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3980:	8a e0       	ldi	r24, 0x0A	; 10
    3982:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3984:	2b c0       	rjmp	.+86     	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3986:	80 e1       	ldi	r24, 0x10	; 16
    3988:	8a 83       	std	Y+2, r24	; 0x02
			break;
    398a:	28 c0       	rjmp	.+80     	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    398c:	81 e0       	ldi	r24, 0x01	; 1
    398e:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3990:	25 c0       	rjmp	.+74     	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3992:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3994:	23 c0       	rjmp	.+70     	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3996:	e8 81       	ld	r30, Y
    3998:	f9 81       	ldd	r31, Y+1	; 0x01
    399a:	02 80       	ldd	r0, Z+2	; 0x02
    399c:	f3 81       	ldd	r31, Z+3	; 0x03
    399e:	e0 2d       	mov	r30, r0
    39a0:	6d e0       	ldi	r22, 0x0D	; 13
    39a2:	ce 01       	movw	r24, r28
    39a4:	19 95       	eicall
    39a6:	e8 81       	ld	r30, Y
    39a8:	f9 81       	ldd	r31, Y+1	; 0x01
    39aa:	02 80       	ldd	r0, Z+2	; 0x02
    39ac:	f3 81       	ldd	r31, Z+3	; 0x03
    39ae:	e0 2d       	mov	r30, r0
    39b0:	6a e0       	ldi	r22, 0x0A	; 10
    39b2:	ce 01       	movw	r24, r28
    39b4:	19 95       	eicall
			break;
    39b6:	12 c0       	rjmp	.+36     	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    39b8:	e8 81       	ld	r30, Y
    39ba:	f9 81       	ldd	r31, Y+1	; 0x01
    39bc:	02 84       	ldd	r0, Z+10	; 0x0a
    39be:	f3 85       	ldd	r31, Z+11	; 0x0b
    39c0:	e0 2d       	mov	r30, r0
    39c2:	ce 01       	movw	r24, r28
    39c4:	19 95       	eicall
			break;
    39c6:	0a c0       	rjmp	.+20     	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    39c8:	e8 81       	ld	r30, Y
    39ca:	f9 81       	ldd	r31, Y+1	; 0x01
    39cc:	00 84       	ldd	r0, Z+8	; 0x08
    39ce:	f1 85       	ldd	r31, Z+9	; 0x09
    39d0:	e0 2d       	mov	r30, r0
    39d2:	ce 01       	movw	r24, r28
    39d4:	19 95       	eicall
			break;
    39d6:	02 c0       	rjmp	.+4      	; 0x39dc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    39d8:	81 e0       	ldi	r24, 0x01	; 1
    39da:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    39dc:	ce 01       	movw	r24, r28
    39de:	df 91       	pop	r29
    39e0:	cf 91       	pop	r28
    39e2:	08 95       	ret

000039e4 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    39e4:	ff 92       	push	r15
    39e6:	0f 93       	push	r16
    39e8:	1f 93       	push	r17
    39ea:	cf 93       	push	r28
    39ec:	df 93       	push	r29
    39ee:	cd b7       	in	r28, 0x3d	; 61
    39f0:	de b7       	in	r29, 0x3e	; 62
    39f2:	61 97       	sbiw	r28, 0x11	; 17
    39f4:	cd bf       	out	0x3d, r28	; 61
    39f6:	de bf       	out	0x3e, r29	; 62
    39f8:	8c 01       	movw	r16, r24
    39fa:	f6 2e       	mov	r15, r22
    39fc:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    39fe:	f8 01       	movw	r30, r16
    3a00:	42 81       	ldd	r20, Z+2	; 0x02
    3a02:	40 31       	cpi	r20, 0x10	; 16
    3a04:	21 f0       	breq	.+8      	; 0x3a0e <_ZN8emstreamlsEj+0x2a>
    3a06:	48 30       	cpi	r20, 0x08	; 8
    3a08:	11 f0       	breq	.+4      	; 0x3a0e <_ZN8emstreamlsEj+0x2a>
    3a0a:	42 30       	cpi	r20, 0x02	; 2
    3a0c:	41 f4       	brne	.+16     	; 0x3a1e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3a0e:	69 2f       	mov	r22, r25
    3a10:	c8 01       	movw	r24, r16
    3a12:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
    3a16:	6f 2d       	mov	r22, r15
    3a18:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
    3a1c:	0d c0       	rjmp	.+26     	; 0x3a38 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3a1e:	50 e0       	ldi	r21, 0x00	; 0
    3a20:	be 01       	movw	r22, r28
    3a22:	6f 5f       	subi	r22, 0xFF	; 255
    3a24:	7f 4f       	sbci	r23, 0xFF	; 255
    3a26:	8f 2d       	mov	r24, r15
    3a28:	0e 94 c3 22 	call	0x4586	; 0x4586 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3a2c:	be 01       	movw	r22, r28
    3a2e:	6f 5f       	subi	r22, 0xFF	; 255
    3a30:	7f 4f       	sbci	r23, 0xFF	; 255
    3a32:	c8 01       	movw	r24, r16
    3a34:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3a38:	c8 01       	movw	r24, r16
    3a3a:	61 96       	adiw	r28, 0x11	; 17
    3a3c:	cd bf       	out	0x3d, r28	; 61
    3a3e:	de bf       	out	0x3e, r29	; 62
    3a40:	df 91       	pop	r29
    3a42:	cf 91       	pop	r28
    3a44:	1f 91       	pop	r17
    3a46:	0f 91       	pop	r16
    3a48:	ff 90       	pop	r15
    3a4a:	08 95       	ret

00003a4c <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3a4c:	df 92       	push	r13
    3a4e:	ef 92       	push	r14
    3a50:	ff 92       	push	r15
    3a52:	0f 93       	push	r16
    3a54:	1f 93       	push	r17
    3a56:	cf 93       	push	r28
    3a58:	df 93       	push	r29
    3a5a:	cd b7       	in	r28, 0x3d	; 61
    3a5c:	de b7       	in	r29, 0x3e	; 62
    3a5e:	a1 97       	sbiw	r28, 0x21	; 33
    3a60:	cd bf       	out	0x3d, r28	; 61
    3a62:	de bf       	out	0x3e, r29	; 62
    3a64:	8c 01       	movw	r16, r24
    3a66:	d4 2e       	mov	r13, r20
    3a68:	e5 2e       	mov	r14, r21
    3a6a:	f6 2e       	mov	r15, r22
    3a6c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3a6e:	f8 01       	movw	r30, r16
    3a70:	22 81       	ldd	r18, Z+2	; 0x02
    3a72:	20 31       	cpi	r18, 0x10	; 16
    3a74:	21 f0       	breq	.+8      	; 0x3a7e <_ZN8emstreamlsEm+0x32>
    3a76:	28 30       	cpi	r18, 0x08	; 8
    3a78:	11 f0       	breq	.+4      	; 0x3a7e <_ZN8emstreamlsEm+0x32>
    3a7a:	22 30       	cpi	r18, 0x02	; 2
    3a7c:	71 f4       	brne	.+28     	; 0x3a9a <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3a7e:	69 2f       	mov	r22, r25
    3a80:	c8 01       	movw	r24, r16
    3a82:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
    3a86:	6f 2d       	mov	r22, r15
    3a88:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
    3a8c:	6e 2d       	mov	r22, r14
    3a8e:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
    3a92:	6d 2d       	mov	r22, r13
    3a94:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZN8emstreamlsEh>
    3a98:	0f c0       	rjmp	.+30     	; 0x3ab8 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3a9a:	30 e0       	ldi	r19, 0x00	; 0
    3a9c:	ae 01       	movw	r20, r28
    3a9e:	4f 5f       	subi	r20, 0xFF	; 255
    3aa0:	5f 4f       	sbci	r21, 0xFF	; 255
    3aa2:	6d 2d       	mov	r22, r13
    3aa4:	7e 2d       	mov	r23, r14
    3aa6:	8f 2d       	mov	r24, r15
    3aa8:	0e 94 96 22 	call	0x452c	; 0x452c <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3aac:	be 01       	movw	r22, r28
    3aae:	6f 5f       	subi	r22, 0xFF	; 255
    3ab0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ab2:	c8 01       	movw	r24, r16
    3ab4:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3ab8:	c8 01       	movw	r24, r16
    3aba:	a1 96       	adiw	r28, 0x21	; 33
    3abc:	cd bf       	out	0x3d, r28	; 61
    3abe:	de bf       	out	0x3e, r29	; 62
    3ac0:	df 91       	pop	r29
    3ac2:	cf 91       	pop	r28
    3ac4:	1f 91       	pop	r17
    3ac6:	0f 91       	pop	r16
    3ac8:	ff 90       	pop	r15
    3aca:	ef 90       	pop	r14
    3acc:	df 90       	pop	r13
    3ace:	08 95       	ret

00003ad0 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3ad0:	cf 92       	push	r12
    3ad2:	df 92       	push	r13
    3ad4:	ef 92       	push	r14
    3ad6:	ff 92       	push	r15
    3ad8:	0f 93       	push	r16
    3ada:	1f 93       	push	r17
    3adc:	cf 93       	push	r28
    3ade:	df 93       	push	r29
    3ae0:	cd b7       	in	r28, 0x3d	; 61
    3ae2:	de b7       	in	r29, 0x3e	; 62
    3ae4:	29 97       	sbiw	r28, 0x09	; 9
    3ae6:	cd bf       	out	0x3d, r28	; 61
    3ae8:	de bf       	out	0x3e, r29	; 62
    3aea:	8c 01       	movw	r16, r24
    3aec:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3aee:	dc 01       	movw	r26, r24
    3af0:	13 96       	adiw	r26, 0x03	; 3
    3af2:	8c 91       	ld	r24, X
    3af4:	13 97       	sbiw	r26, 0x03	; 3
    3af6:	88 23       	and	r24, r24
    3af8:	41 f0       	breq	.+16     	; 0x3b0a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3afa:	ed 91       	ld	r30, X+
    3afc:	fc 91       	ld	r31, X
    3afe:	02 80       	ldd	r0, Z+2	; 0x02
    3b00:	f3 81       	ldd	r31, Z+3	; 0x03
    3b02:	e0 2d       	mov	r30, r0
    3b04:	c8 01       	movw	r24, r16
    3b06:	19 95       	eicall
    3b08:	56 c0       	rjmp	.+172    	; 0x3bb6 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3b0a:	f8 01       	movw	r30, r16
    3b0c:	42 81       	ldd	r20, Z+2	; 0x02
    3b0e:	42 30       	cpi	r20, 0x02	; 2
    3b10:	19 f5       	brne	.+70     	; 0x3b58 <_ZN8emstreamlsEh+0x88>
    3b12:	68 94       	set
    3b14:	cc 24       	eor	r12, r12
    3b16:	c3 f8       	bld	r12, 3
    3b18:	d1 2c       	mov	r13, r1
    3b1a:	68 94       	set
    3b1c:	ff 24       	eor	r15, r15
    3b1e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3b20:	8e 2d       	mov	r24, r14
    3b22:	8f 21       	and	r24, r15
    3b24:	51 f0       	breq	.+20     	; 0x3b3a <_ZN8emstreamlsEh+0x6a>
    3b26:	d8 01       	movw	r26, r16
    3b28:	ed 91       	ld	r30, X+
    3b2a:	fc 91       	ld	r31, X
    3b2c:	02 80       	ldd	r0, Z+2	; 0x02
    3b2e:	f3 81       	ldd	r31, Z+3	; 0x03
    3b30:	e0 2d       	mov	r30, r0
    3b32:	61 e3       	ldi	r22, 0x31	; 49
    3b34:	c8 01       	movw	r24, r16
    3b36:	19 95       	eicall
    3b38:	09 c0       	rjmp	.+18     	; 0x3b4c <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3b3a:	d8 01       	movw	r26, r16
    3b3c:	ed 91       	ld	r30, X+
    3b3e:	fc 91       	ld	r31, X
    3b40:	02 80       	ldd	r0, Z+2	; 0x02
    3b42:	f3 81       	ldd	r31, Z+3	; 0x03
    3b44:	e0 2d       	mov	r30, r0
    3b46:	60 e3       	ldi	r22, 0x30	; 48
    3b48:	c8 01       	movw	r24, r16
    3b4a:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3b4c:	f6 94       	lsr	r15
    3b4e:	b1 e0       	ldi	r27, 0x01	; 1
    3b50:	cb 1a       	sub	r12, r27
    3b52:	d1 08       	sbc	r13, r1
    3b54:	29 f7       	brne	.-54     	; 0x3b20 <_ZN8emstreamlsEh+0x50>
    3b56:	2f c0       	rjmp	.+94     	; 0x3bb6 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3b58:	40 31       	cpi	r20, 0x10	; 16
    3b5a:	f9 f4       	brne	.+62     	; 0x3b9a <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3b5c:	62 95       	swap	r22
    3b5e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3b60:	01 90       	ld	r0, Z+
    3b62:	f0 81       	ld	r31, Z
    3b64:	e0 2d       	mov	r30, r0
    3b66:	02 80       	ldd	r0, Z+2	; 0x02
    3b68:	f3 81       	ldd	r31, Z+3	; 0x03
    3b6a:	e0 2d       	mov	r30, r0
    3b6c:	6a 30       	cpi	r22, 0x0A	; 10
    3b6e:	10 f0       	brcs	.+4      	; 0x3b74 <_ZN8emstreamlsEh+0xa4>
    3b70:	69 5c       	subi	r22, 0xC9	; 201
    3b72:	01 c0       	rjmp	.+2      	; 0x3b76 <_ZN8emstreamlsEh+0xa6>
    3b74:	60 5d       	subi	r22, 0xD0	; 208
    3b76:	c8 01       	movw	r24, r16
    3b78:	19 95       	eicall
		temp_char = num & 0x0F;
    3b7a:	6e 2d       	mov	r22, r14
    3b7c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3b7e:	d8 01       	movw	r26, r16
    3b80:	ed 91       	ld	r30, X+
    3b82:	fc 91       	ld	r31, X
    3b84:	02 80       	ldd	r0, Z+2	; 0x02
    3b86:	f3 81       	ldd	r31, Z+3	; 0x03
    3b88:	e0 2d       	mov	r30, r0
    3b8a:	6a 30       	cpi	r22, 0x0A	; 10
    3b8c:	10 f0       	brcs	.+4      	; 0x3b92 <_ZN8emstreamlsEh+0xc2>
    3b8e:	69 5c       	subi	r22, 0xC9	; 201
    3b90:	01 c0       	rjmp	.+2      	; 0x3b94 <_ZN8emstreamlsEh+0xc4>
    3b92:	60 5d       	subi	r22, 0xD0	; 208
    3b94:	c8 01       	movw	r24, r16
    3b96:	19 95       	eicall
    3b98:	0e c0       	rjmp	.+28     	; 0x3bb6 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3b9a:	50 e0       	ldi	r21, 0x00	; 0
    3b9c:	be 01       	movw	r22, r28
    3b9e:	6f 5f       	subi	r22, 0xFF	; 255
    3ba0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ba2:	8e 2d       	mov	r24, r14
    3ba4:	90 e0       	ldi	r25, 0x00	; 0
    3ba6:	0e 94 c3 22 	call	0x4586	; 0x4586 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3baa:	be 01       	movw	r22, r28
    3bac:	6f 5f       	subi	r22, 0xFF	; 255
    3bae:	7f 4f       	sbci	r23, 0xFF	; 255
    3bb0:	c8 01       	movw	r24, r16
    3bb2:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3bb6:	c8 01       	movw	r24, r16
    3bb8:	29 96       	adiw	r28, 0x09	; 9
    3bba:	cd bf       	out	0x3d, r28	; 61
    3bbc:	de bf       	out	0x3e, r29	; 62
    3bbe:	df 91       	pop	r29
    3bc0:	cf 91       	pop	r28
    3bc2:	1f 91       	pop	r17
    3bc4:	0f 91       	pop	r16
    3bc6:	ff 90       	pop	r15
    3bc8:	ef 90       	pop	r14
    3bca:	df 90       	pop	r13
    3bcc:	cf 90       	pop	r12
    3bce:	08 95       	ret

00003bd0 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3bd0:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3bd2:	50 96       	adiw	r26, 0x10	; 16
    3bd4:	ed 91       	ld	r30, X+
    3bd6:	fc 91       	ld	r31, X
    3bd8:	51 97       	sbiw	r26, 0x11	; 17
    3bda:	80 81       	ld	r24, Z
    3bdc:	54 96       	adiw	r26, 0x14	; 20
    3bde:	4c 91       	ld	r20, X
    3be0:	54 97       	sbiw	r26, 0x14	; 20
    3be2:	84 23       	and	r24, r20
    3be4:	29 f0       	breq	.+10     	; 0x3bf0 <_ZN5rs2327putcharEc+0x20>
    3be6:	09 c0       	rjmp	.+18     	; 0x3bfa <_ZN5rs2327putcharEc+0x2a>
    3be8:	21 50       	subi	r18, 0x01	; 1
    3bea:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3bec:	19 f4       	brne	.+6      	; 0x3bf4 <_ZN5rs2327putcharEc+0x24>
    3bee:	12 c0       	rjmp	.+36     	; 0x3c14 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3bf0:	21 e2       	ldi	r18, 0x21	; 33
    3bf2:	3e e4       	ldi	r19, 0x4E	; 78
    3bf4:	90 81       	ld	r25, Z
    3bf6:	94 23       	and	r25, r20
    3bf8:	b9 f3       	breq	.-18     	; 0x3be8 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3bfa:	90 81       	ld	r25, Z
    3bfc:	56 96       	adiw	r26, 0x16	; 22
    3bfe:	8c 91       	ld	r24, X
    3c00:	56 97       	sbiw	r26, 0x16	; 22
    3c02:	89 2b       	or	r24, r25
    3c04:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3c06:	1e 96       	adiw	r26, 0x0e	; 14
    3c08:	ed 91       	ld	r30, X+
    3c0a:	fc 91       	ld	r31, X
    3c0c:	1f 97       	sbiw	r26, 0x0f	; 15
    3c0e:	60 83       	st	Z, r22
	return (true);
    3c10:	81 e0       	ldi	r24, 0x01	; 1
    3c12:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3c14:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3c16:	08 95       	ret

00003c18 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3c18:	cf 93       	push	r28
    3c1a:	df 93       	push	r29
    3c1c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3c1e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3c20:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3c22:	28 81       	ld	r18, Y
    3c24:	39 81       	ldd	r19, Y+1	; 0x01
    3c26:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3c28:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3c2a:	4d 91       	ld	r20, X+
    3c2c:	5c 91       	ld	r21, X
    3c2e:	24 17       	cp	r18, r20
    3c30:	35 07       	cpc	r19, r21
    3c32:	e9 f3       	breq	.-6      	; 0x3c2e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3c34:	a7 89       	ldd	r26, Z+23	; 0x17
    3c36:	b0 8d       	ldd	r27, Z+24	; 0x18
    3c38:	0d 90       	ld	r0, X+
    3c3a:	bc 91       	ld	r27, X
    3c3c:	a0 2d       	mov	r26, r0
    3c3e:	a2 0f       	add	r26, r18
    3c40:	b3 1f       	adc	r27, r19
    3c42:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3c44:	2f 5f       	subi	r18, 0xFF	; 255
    3c46:	3f 4f       	sbci	r19, 0xFF	; 255
    3c48:	28 83       	st	Y, r18
    3c4a:	39 83       	std	Y+1, r19	; 0x01
    3c4c:	24 36       	cpi	r18, 0x64	; 100
    3c4e:	31 05       	cpc	r19, r1
    3c50:	28 f0       	brcs	.+10     	; 0x3c5c <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3c52:	01 8c       	ldd	r0, Z+25	; 0x19
    3c54:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3c56:	e0 2d       	mov	r30, r0
    3c58:	10 82       	st	Z, r1
    3c5a:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3c5c:	90 e0       	ldi	r25, 0x00	; 0
    3c5e:	df 91       	pop	r29
    3c60:	cf 91       	pop	r28
    3c62:	08 95       	ret

00003c64 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3c64:	cf 93       	push	r28
    3c66:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3c68:	ec 01       	movw	r28, r24
    3c6a:	a9 8d       	ldd	r26, Y+25	; 0x19
    3c6c:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3c6e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3c70:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3c72:	81 e0       	ldi	r24, 0x01	; 1
    3c74:	4d 91       	ld	r20, X+
    3c76:	5c 91       	ld	r21, X
    3c78:	20 81       	ld	r18, Z
    3c7a:	31 81       	ldd	r19, Z+1	; 0x01
    3c7c:	42 17       	cp	r20, r18
    3c7e:	53 07       	cpc	r21, r19
    3c80:	09 f4       	brne	.+2      	; 0x3c84 <_ZN5rs23214check_for_charEv+0x20>
    3c82:	80 e0       	ldi	r24, 0x00	; 0
}
    3c84:	df 91       	pop	r29
    3c86:	cf 91       	pop	r28
    3c88:	08 95       	ret

00003c8a <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3c8a:	dc 01       	movw	r26, r24
    3c8c:	ed 91       	ld	r30, X+
    3c8e:	fc 91       	ld	r31, X
    3c90:	02 80       	ldd	r0, Z+2	; 0x02
    3c92:	f3 81       	ldd	r31, Z+3	; 0x03
    3c94:	e0 2d       	mov	r30, r0
    3c96:	6c e0       	ldi	r22, 0x0C	; 12
    3c98:	19 95       	eicall
    3c9a:	08 95       	ret

00003c9c <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3c9c:	ef 92       	push	r14
    3c9e:	ff 92       	push	r15
    3ca0:	0f 93       	push	r16
    3ca2:	1f 93       	push	r17
    3ca4:	cf 93       	push	r28
    3ca6:	df 93       	push	r29
    3ca8:	ec 01       	movw	r28, r24
    3caa:	7b 01       	movw	r14, r22
    3cac:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3cae:	0e 94 66 1c 	call	0x38cc	; 0x38cc <_ZN8emstreamC1Ev>
    3cb2:	a8 01       	movw	r20, r16
    3cb4:	b7 01       	movw	r22, r14
    3cb6:	ce 01       	movw	r24, r28
    3cb8:	08 96       	adiw	r24, 0x08	; 8
    3cba:	0e 94 c7 1b 	call	0x378e	; 0x378e <_ZN7base232C1EjP12USART_struct>
    3cbe:	8b e6       	ldi	r24, 0x6B	; 107
    3cc0:	90 e2       	ldi	r25, 0x20	; 32
    3cc2:	88 83       	st	Y, r24
    3cc4:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3cc6:	00 3a       	cpi	r16, 0xA0	; 160
    3cc8:	88 e0       	ldi	r24, 0x08	; 8
    3cca:	18 07       	cpc	r17, r24
    3ccc:	69 f4       	brne	.+26     	; 0x3ce8 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3cce:	84 e4       	ldi	r24, 0x44	; 68
    3cd0:	91 e3       	ldi	r25, 0x31	; 49
    3cd2:	8f 8b       	std	Y+23, r24	; 0x17
    3cd4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3cd6:	8a e3       	ldi	r24, 0x3A	; 58
    3cd8:	91 e3       	ldi	r25, 0x31	; 49
    3cda:	89 8f       	std	Y+25, r24	; 0x19
    3cdc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3cde:	80 e3       	ldi	r24, 0x30	; 48
    3ce0:	91 e3       	ldi	r25, 0x31	; 49
    3ce2:	8b 8f       	std	Y+27, r24	; 0x1b
    3ce4:	9c 8f       	std	Y+28, r25	; 0x1c
    3ce6:	42 c0       	rjmp	.+132    	; 0x3d6c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3ce8:	00 3b       	cpi	r16, 0xB0	; 176
    3cea:	e8 e0       	ldi	r30, 0x08	; 8
    3cec:	1e 07       	cpc	r17, r30
    3cee:	69 f4       	brne	.+26     	; 0x3d0a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3cf0:	82 e4       	ldi	r24, 0x42	; 66
    3cf2:	91 e3       	ldi	r25, 0x31	; 49
    3cf4:	8f 8b       	std	Y+23, r24	; 0x17
    3cf6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3cf8:	88 e3       	ldi	r24, 0x38	; 56
    3cfa:	91 e3       	ldi	r25, 0x31	; 49
    3cfc:	89 8f       	std	Y+25, r24	; 0x19
    3cfe:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3d00:	8e e2       	ldi	r24, 0x2E	; 46
    3d02:	91 e3       	ldi	r25, 0x31	; 49
    3d04:	8b 8f       	std	Y+27, r24	; 0x1b
    3d06:	9c 8f       	std	Y+28, r25	; 0x1c
    3d08:	31 c0       	rjmp	.+98     	; 0x3d6c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3d0a:	00 3a       	cpi	r16, 0xA0	; 160
    3d0c:	f9 e0       	ldi	r31, 0x09	; 9
    3d0e:	1f 07       	cpc	r17, r31
    3d10:	69 f4       	brne	.+26     	; 0x3d2c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3d12:	80 e4       	ldi	r24, 0x40	; 64
    3d14:	91 e3       	ldi	r25, 0x31	; 49
    3d16:	8f 8b       	std	Y+23, r24	; 0x17
    3d18:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3d1a:	86 e3       	ldi	r24, 0x36	; 54
    3d1c:	91 e3       	ldi	r25, 0x31	; 49
    3d1e:	89 8f       	std	Y+25, r24	; 0x19
    3d20:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3d22:	8c e2       	ldi	r24, 0x2C	; 44
    3d24:	91 e3       	ldi	r25, 0x31	; 49
    3d26:	8b 8f       	std	Y+27, r24	; 0x1b
    3d28:	9c 8f       	std	Y+28, r25	; 0x1c
    3d2a:	20 c0       	rjmp	.+64     	; 0x3d6c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3d2c:	00 3b       	cpi	r16, 0xB0	; 176
    3d2e:	89 e0       	ldi	r24, 0x09	; 9
    3d30:	18 07       	cpc	r17, r24
    3d32:	69 f4       	brne	.+26     	; 0x3d4e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3d34:	8e e3       	ldi	r24, 0x3E	; 62
    3d36:	91 e3       	ldi	r25, 0x31	; 49
    3d38:	8f 8b       	std	Y+23, r24	; 0x17
    3d3a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3d3c:	84 e3       	ldi	r24, 0x34	; 52
    3d3e:	91 e3       	ldi	r25, 0x31	; 49
    3d40:	89 8f       	std	Y+25, r24	; 0x19
    3d42:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3d44:	8a e2       	ldi	r24, 0x2A	; 42
    3d46:	91 e3       	ldi	r25, 0x31	; 49
    3d48:	8b 8f       	std	Y+27, r24	; 0x1b
    3d4a:	9c 8f       	std	Y+28, r25	; 0x1c
    3d4c:	0f c0       	rjmp	.+30     	; 0x3d6c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3d4e:	00 3a       	cpi	r16, 0xA0	; 160
    3d50:	1a 40       	sbci	r17, 0x0A	; 10
    3d52:	61 f4       	brne	.+24     	; 0x3d6c <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3d54:	8c e3       	ldi	r24, 0x3C	; 60
    3d56:	91 e3       	ldi	r25, 0x31	; 49
    3d58:	8f 8b       	std	Y+23, r24	; 0x17
    3d5a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3d5c:	82 e3       	ldi	r24, 0x32	; 50
    3d5e:	91 e3       	ldi	r25, 0x31	; 49
    3d60:	89 8f       	std	Y+25, r24	; 0x19
    3d62:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3d64:	88 e2       	ldi	r24, 0x28	; 40
    3d66:	91 e3       	ldi	r25, 0x31	; 49
    3d68:	8b 8f       	std	Y+27, r24	; 0x1b
    3d6a:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3d6c:	0f 89       	ldd	r16, Y+23	; 0x17
    3d6e:	18 8d       	ldd	r17, Y+24	; 0x18
    3d70:	84 e6       	ldi	r24, 0x64	; 100
    3d72:	90 e0       	ldi	r25, 0x00	; 0
    3d74:	0e 94 c3 1b 	call	0x3786	; 0x3786 <_Znaj>
    3d78:	f8 01       	movw	r30, r16
    3d7a:	80 83       	st	Z, r24
    3d7c:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3d7e:	e9 8d       	ldd	r30, Y+25	; 0x19
    3d80:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3d82:	10 82       	st	Z, r1
    3d84:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3d86:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3d88:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3d8a:	10 82       	st	Z, r1
    3d8c:	11 82       	std	Z+1, r1	; 0x01
}
    3d8e:	df 91       	pop	r29
    3d90:	cf 91       	pop	r28
    3d92:	1f 91       	pop	r17
    3d94:	0f 91       	pop	r16
    3d96:	ff 90       	pop	r15
    3d98:	ef 90       	pop	r14
    3d9a:	08 95       	ret

00003d9c <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3d9c:	1f 92       	push	r1
    3d9e:	0f 92       	push	r0
    3da0:	0f b6       	in	r0, 0x3f	; 63
    3da2:	0f 92       	push	r0
    3da4:	11 24       	eor	r1, r1
    3da6:	08 b6       	in	r0, 0x38	; 56
    3da8:	0f 92       	push	r0
    3daa:	18 be       	out	0x38, r1	; 56
    3dac:	0b b6       	in	r0, 0x3b	; 59
    3dae:	0f 92       	push	r0
    3db0:	1b be       	out	0x3b, r1	; 59
    3db2:	2f 93       	push	r18
    3db4:	3f 93       	push	r19
    3db6:	8f 93       	push	r24
    3db8:	9f 93       	push	r25
    3dba:	ef 93       	push	r30
    3dbc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3dbe:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3dc2:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    3dc6:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    3dca:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3dce:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3dd2:	e8 0f       	add	r30, r24
    3dd4:	f9 1f       	adc	r31, r25
    3dd6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3dd8:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3ddc:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3de0:	01 96       	adiw	r24, 0x01	; 1
    3de2:	84 36       	cpi	r24, 0x64	; 100
    3de4:	91 05       	cpc	r25, r1
    3de6:	60 f4       	brcc	.+24     	; 0x3e00 <__vector_25+0x64>
    3de8:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    3dec:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3df0:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    3df4:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3df8:	82 17       	cp	r24, r18
    3dfa:	93 07       	cpc	r25, r19
    3dfc:	f1 f4       	brne	.+60     	; 0x3e3a <__vector_25+0x9e>
    3dfe:	0c c0       	rjmp	.+24     	; 0x3e18 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3e00:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    3e04:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3e08:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    3e0c:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3e10:	18 16       	cp	r1, r24
    3e12:	19 06       	cpc	r1, r25
    3e14:	91 f4       	brne	.+36     	; 0x3e3a <__vector_25+0x9e>
    3e16:	0e c0       	rjmp	.+28     	; 0x3e34 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3e18:	01 96       	adiw	r24, 0x01	; 1
    3e1a:	84 36       	cpi	r24, 0x64	; 100
    3e1c:	91 05       	cpc	r25, r1
    3e1e:	28 f4       	brcc	.+10     	; 0x3e2a <__vector_25+0x8e>
    3e20:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    3e24:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    3e28:	08 c0       	rjmp	.+16     	; 0x3e3a <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3e2a:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    3e2e:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    3e32:	03 c0       	rjmp	.+6      	; 0x3e3a <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3e34:	81 e0       	ldi	r24, 0x01	; 1
    3e36:	90 e0       	ldi	r25, 0x00	; 0
    3e38:	f3 cf       	rjmp	.-26     	; 0x3e20 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3e3a:	ff 91       	pop	r31
    3e3c:	ef 91       	pop	r30
    3e3e:	9f 91       	pop	r25
    3e40:	8f 91       	pop	r24
    3e42:	3f 91       	pop	r19
    3e44:	2f 91       	pop	r18
    3e46:	0f 90       	pop	r0
    3e48:	0b be       	out	0x3b, r0	; 59
    3e4a:	0f 90       	pop	r0
    3e4c:	08 be       	out	0x38, r0	; 56
    3e4e:	0f 90       	pop	r0
    3e50:	0f be       	out	0x3f, r0	; 63
    3e52:	0f 90       	pop	r0
    3e54:	1f 90       	pop	r1
    3e56:	18 95       	reti

00003e58 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3e58:	1f 92       	push	r1
    3e5a:	0f 92       	push	r0
    3e5c:	0f b6       	in	r0, 0x3f	; 63
    3e5e:	0f 92       	push	r0
    3e60:	11 24       	eor	r1, r1
    3e62:	08 b6       	in	r0, 0x38	; 56
    3e64:	0f 92       	push	r0
    3e66:	18 be       	out	0x38, r1	; 56
    3e68:	0b b6       	in	r0, 0x3b	; 59
    3e6a:	0f 92       	push	r0
    3e6c:	1b be       	out	0x3b, r1	; 59
    3e6e:	2f 93       	push	r18
    3e70:	3f 93       	push	r19
    3e72:	8f 93       	push	r24
    3e74:	9f 93       	push	r25
    3e76:	ef 93       	push	r30
    3e78:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3e7a:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3e7e:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    3e82:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3e86:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3e8a:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3e8e:	e8 0f       	add	r30, r24
    3e90:	f9 1f       	adc	r31, r25
    3e92:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3e94:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3e98:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3e9c:	01 96       	adiw	r24, 0x01	; 1
    3e9e:	84 36       	cpi	r24, 0x64	; 100
    3ea0:	91 05       	cpc	r25, r1
    3ea2:	60 f4       	brcc	.+24     	; 0x3ebc <__vector_28+0x64>
    3ea4:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    3ea8:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3eac:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    3eb0:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    3eb4:	82 17       	cp	r24, r18
    3eb6:	93 07       	cpc	r25, r19
    3eb8:	f1 f4       	brne	.+60     	; 0x3ef6 <__vector_28+0x9e>
    3eba:	0c c0       	rjmp	.+24     	; 0x3ed4 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3ebc:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    3ec0:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3ec4:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    3ec8:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    3ecc:	18 16       	cp	r1, r24
    3ece:	19 06       	cpc	r1, r25
    3ed0:	91 f4       	brne	.+36     	; 0x3ef6 <__vector_28+0x9e>
    3ed2:	0e c0       	rjmp	.+28     	; 0x3ef0 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3ed4:	01 96       	adiw	r24, 0x01	; 1
    3ed6:	84 36       	cpi	r24, 0x64	; 100
    3ed8:	91 05       	cpc	r25, r1
    3eda:	28 f4       	brcc	.+10     	; 0x3ee6 <__vector_28+0x8e>
    3edc:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    3ee0:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    3ee4:	08 c0       	rjmp	.+16     	; 0x3ef6 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3ee6:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    3eea:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    3eee:	03 c0       	rjmp	.+6      	; 0x3ef6 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3ef0:	81 e0       	ldi	r24, 0x01	; 1
    3ef2:	90 e0       	ldi	r25, 0x00	; 0
    3ef4:	f3 cf       	rjmp	.-26     	; 0x3edc <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3ef6:	ff 91       	pop	r31
    3ef8:	ef 91       	pop	r30
    3efa:	9f 91       	pop	r25
    3efc:	8f 91       	pop	r24
    3efe:	3f 91       	pop	r19
    3f00:	2f 91       	pop	r18
    3f02:	0f 90       	pop	r0
    3f04:	0b be       	out	0x3b, r0	; 59
    3f06:	0f 90       	pop	r0
    3f08:	08 be       	out	0x38, r0	; 56
    3f0a:	0f 90       	pop	r0
    3f0c:	0f be       	out	0x3f, r0	; 63
    3f0e:	0f 90       	pop	r0
    3f10:	1f 90       	pop	r1
    3f12:	18 95       	reti

00003f14 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3f14:	1f 92       	push	r1
    3f16:	0f 92       	push	r0
    3f18:	0f b6       	in	r0, 0x3f	; 63
    3f1a:	0f 92       	push	r0
    3f1c:	11 24       	eor	r1, r1
    3f1e:	08 b6       	in	r0, 0x38	; 56
    3f20:	0f 92       	push	r0
    3f22:	18 be       	out	0x38, r1	; 56
    3f24:	0b b6       	in	r0, 0x3b	; 59
    3f26:	0f 92       	push	r0
    3f28:	1b be       	out	0x3b, r1	; 59
    3f2a:	2f 93       	push	r18
    3f2c:	3f 93       	push	r19
    3f2e:	8f 93       	push	r24
    3f30:	9f 93       	push	r25
    3f32:	ef 93       	push	r30
    3f34:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3f36:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3f3a:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    3f3e:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    3f42:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3f46:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3f4a:	e8 0f       	add	r30, r24
    3f4c:	f9 1f       	adc	r31, r25
    3f4e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3f50:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    3f54:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    3f58:	01 96       	adiw	r24, 0x01	; 1
    3f5a:	84 36       	cpi	r24, 0x64	; 100
    3f5c:	91 05       	cpc	r25, r1
    3f5e:	60 f4       	brcc	.+24     	; 0x3f78 <__vector_88+0x64>
    3f60:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    3f64:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3f68:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    3f6c:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3f70:	82 17       	cp	r24, r18
    3f72:	93 07       	cpc	r25, r19
    3f74:	f1 f4       	brne	.+60     	; 0x3fb2 <__vector_88+0x9e>
    3f76:	0c c0       	rjmp	.+24     	; 0x3f90 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3f78:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    3f7c:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3f80:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    3f84:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3f88:	18 16       	cp	r1, r24
    3f8a:	19 06       	cpc	r1, r25
    3f8c:	91 f4       	brne	.+36     	; 0x3fb2 <__vector_88+0x9e>
    3f8e:	0e c0       	rjmp	.+28     	; 0x3fac <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3f90:	01 96       	adiw	r24, 0x01	; 1
    3f92:	84 36       	cpi	r24, 0x64	; 100
    3f94:	91 05       	cpc	r25, r1
    3f96:	28 f4       	brcc	.+10     	; 0x3fa2 <__vector_88+0x8e>
    3f98:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    3f9c:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    3fa0:	08 c0       	rjmp	.+16     	; 0x3fb2 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3fa2:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    3fa6:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    3faa:	03 c0       	rjmp	.+6      	; 0x3fb2 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3fac:	81 e0       	ldi	r24, 0x01	; 1
    3fae:	90 e0       	ldi	r25, 0x00	; 0
    3fb0:	f3 cf       	rjmp	.-26     	; 0x3f98 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3fb2:	ff 91       	pop	r31
    3fb4:	ef 91       	pop	r30
    3fb6:	9f 91       	pop	r25
    3fb8:	8f 91       	pop	r24
    3fba:	3f 91       	pop	r19
    3fbc:	2f 91       	pop	r18
    3fbe:	0f 90       	pop	r0
    3fc0:	0b be       	out	0x3b, r0	; 59
    3fc2:	0f 90       	pop	r0
    3fc4:	08 be       	out	0x38, r0	; 56
    3fc6:	0f 90       	pop	r0
    3fc8:	0f be       	out	0x3f, r0	; 63
    3fca:	0f 90       	pop	r0
    3fcc:	1f 90       	pop	r1
    3fce:	18 95       	reti

00003fd0 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3fd0:	1f 92       	push	r1
    3fd2:	0f 92       	push	r0
    3fd4:	0f b6       	in	r0, 0x3f	; 63
    3fd6:	0f 92       	push	r0
    3fd8:	11 24       	eor	r1, r1
    3fda:	08 b6       	in	r0, 0x38	; 56
    3fdc:	0f 92       	push	r0
    3fde:	18 be       	out	0x38, r1	; 56
    3fe0:	0b b6       	in	r0, 0x3b	; 59
    3fe2:	0f 92       	push	r0
    3fe4:	1b be       	out	0x3b, r1	; 59
    3fe6:	2f 93       	push	r18
    3fe8:	3f 93       	push	r19
    3fea:	8f 93       	push	r24
    3fec:	9f 93       	push	r25
    3fee:	ef 93       	push	r30
    3ff0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3ff2:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3ff6:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    3ffa:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    3ffe:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    4002:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    4006:	e8 0f       	add	r30, r24
    4008:	f9 1f       	adc	r31, r25
    400a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    400c:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    4010:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    4014:	01 96       	adiw	r24, 0x01	; 1
    4016:	84 36       	cpi	r24, 0x64	; 100
    4018:	91 05       	cpc	r25, r1
    401a:	60 f4       	brcc	.+24     	; 0x4034 <__stack+0x35>
    401c:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    4020:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4024:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    4028:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    402c:	82 17       	cp	r24, r18
    402e:	93 07       	cpc	r25, r19
    4030:	f1 f4       	brne	.+60     	; 0x406e <__stack+0x6f>
    4032:	0c c0       	rjmp	.+24     	; 0x404c <__stack+0x4d>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    4034:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    4038:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    403c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    4040:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    4044:	18 16       	cp	r1, r24
    4046:	19 06       	cpc	r1, r25
    4048:	91 f4       	brne	.+36     	; 0x406e <__stack+0x6f>
    404a:	0e c0       	rjmp	.+28     	; 0x4068 <__stack+0x69>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    404c:	01 96       	adiw	r24, 0x01	; 1
    404e:	84 36       	cpi	r24, 0x64	; 100
    4050:	91 05       	cpc	r25, r1
    4052:	28 f4       	brcc	.+10     	; 0x405e <__stack+0x5f>
    4054:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    4058:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    405c:	08 c0       	rjmp	.+16     	; 0x406e <__stack+0x6f>
	rcvD1_read_index = 0;
    405e:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    4062:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    4066:	03 c0       	rjmp	.+6      	; 0x406e <__stack+0x6f>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4068:	81 e0       	ldi	r24, 0x01	; 1
    406a:	90 e0       	ldi	r25, 0x00	; 0
    406c:	f3 cf       	rjmp	.-26     	; 0x4054 <__stack+0x55>
	rcvD1_read_index = 0;
}
    406e:	ff 91       	pop	r31
    4070:	ef 91       	pop	r30
    4072:	9f 91       	pop	r25
    4074:	8f 91       	pop	r24
    4076:	3f 91       	pop	r19
    4078:	2f 91       	pop	r18
    407a:	0f 90       	pop	r0
    407c:	0b be       	out	0x3b, r0	; 59
    407e:	0f 90       	pop	r0
    4080:	08 be       	out	0x38, r0	; 56
    4082:	0f 90       	pop	r0
    4084:	0f be       	out	0x3f, r0	; 63
    4086:	0f 90       	pop	r0
    4088:	1f 90       	pop	r1
    408a:	18 95       	reti

0000408c <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    408c:	1f 92       	push	r1
    408e:	0f 92       	push	r0
    4090:	0f b6       	in	r0, 0x3f	; 63
    4092:	0f 92       	push	r0
    4094:	11 24       	eor	r1, r1
    4096:	08 b6       	in	r0, 0x38	; 56
    4098:	0f 92       	push	r0
    409a:	18 be       	out	0x38, r1	; 56
    409c:	0b b6       	in	r0, 0x3b	; 59
    409e:	0f 92       	push	r0
    40a0:	1b be       	out	0x3b, r1	; 59
    40a2:	2f 93       	push	r18
    40a4:	3f 93       	push	r19
    40a6:	8f 93       	push	r24
    40a8:	9f 93       	push	r25
    40aa:	ef 93       	push	r30
    40ac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    40ae:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    40b2:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    40b6:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    40ba:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    40be:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    40c2:	e8 0f       	add	r30, r24
    40c4:	f9 1f       	adc	r31, r25
    40c6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    40c8:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    40cc:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    40d0:	01 96       	adiw	r24, 0x01	; 1
    40d2:	84 36       	cpi	r24, 0x64	; 100
    40d4:	91 05       	cpc	r25, r1
    40d6:	60 f4       	brcc	.+24     	; 0x40f0 <__vector_58+0x64>
    40d8:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    40dc:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    40e0:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    40e4:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    40e8:	82 17       	cp	r24, r18
    40ea:	93 07       	cpc	r25, r19
    40ec:	f1 f4       	brne	.+60     	; 0x412a <__vector_58+0x9e>
    40ee:	0c c0       	rjmp	.+24     	; 0x4108 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    40f0:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    40f4:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    40f8:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    40fc:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    4100:	18 16       	cp	r1, r24
    4102:	19 06       	cpc	r1, r25
    4104:	91 f4       	brne	.+36     	; 0x412a <__vector_58+0x9e>
    4106:	0e c0       	rjmp	.+28     	; 0x4124 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4108:	01 96       	adiw	r24, 0x01	; 1
    410a:	84 36       	cpi	r24, 0x64	; 100
    410c:	91 05       	cpc	r25, r1
    410e:	28 f4       	brcc	.+10     	; 0x411a <__vector_58+0x8e>
    4110:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    4114:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    4118:	08 c0       	rjmp	.+16     	; 0x412a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    411a:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    411e:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    4122:	03 c0       	rjmp	.+6      	; 0x412a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4124:	81 e0       	ldi	r24, 0x01	; 1
    4126:	90 e0       	ldi	r25, 0x00	; 0
    4128:	f3 cf       	rjmp	.-26     	; 0x4110 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    412a:	ff 91       	pop	r31
    412c:	ef 91       	pop	r30
    412e:	9f 91       	pop	r25
    4130:	8f 91       	pop	r24
    4132:	3f 91       	pop	r19
    4134:	2f 91       	pop	r18
    4136:	0f 90       	pop	r0
    4138:	0b be       	out	0x3b, r0	; 59
    413a:	0f 90       	pop	r0
    413c:	08 be       	out	0x38, r0	; 56
    413e:	0f 90       	pop	r0
    4140:	0f be       	out	0x3f, r0	; 63
    4142:	0f 90       	pop	r0
    4144:	1f 90       	pop	r1
    4146:	18 95       	reti

00004148 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4148:	0f 93       	push	r16
    414a:	cf 93       	push	r28
    414c:	df 93       	push	r29
    414e:	1f 92       	push	r1
    4150:	cd b7       	in	r28, 0x3d	; 61
    4152:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4154:	2f b7       	in	r18, 0x3f	; 63
    4156:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4158:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    415a:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    415c:	fc 01       	movw	r30, r24
    415e:	08 ed       	ldi	r16, 0xD8	; 216
    4160:	04 bf       	out	0x34, r16	; 52
    4162:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4164:	89 81       	ldd	r24, Y+1	; 0x01
    4166:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4168:	0f 90       	pop	r0
    416a:	df 91       	pop	r29
    416c:	cf 91       	pop	r28
    416e:	0f 91       	pop	r16
    4170:	08 95       	ret

00004172 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    4172:	0f 93       	push	r16
    4174:	1f 93       	push	r17
    4176:	cf 93       	push	r28
    4178:	df 93       	push	r29
    417a:	cd b7       	in	r28, 0x3d	; 61
    417c:	de b7       	in	r29, 0x3e	; 62
    417e:	6d 97       	sbiw	r28, 0x1d	; 29
    4180:	cd bf       	out	0x3d, r28	; 61
    4182:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    4184:	e0 e6       	ldi	r30, 0x60	; 96
    4186:	f6 e0       	ldi	r31, 0x06	; 6
    4188:	80 e4       	ldi	r24, 0x40	; 64
    418a:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    418c:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    418e:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    4190:	e0 e5       	ldi	r30, 0x50	; 80
    4192:	f0 e0       	ldi	r31, 0x00	; 0
    4194:	80 81       	ld	r24, Z
    4196:	82 60       	ori	r24, 0x02	; 2
    4198:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    419a:	81 81       	ldd	r24, Z+1	; 0x01
    419c:	81 ff       	sbrs	r24, 1
    419e:	fd cf       	rjmp	.-6      	; 0x419a <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    41a0:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    41a4:	68 7f       	andi	r22, 0xF8	; 248
    41a6:	61 60       	ori	r22, 0x01	; 1
    41a8:	80 e4       	ldi	r24, 0x40	; 64
    41aa:	90 e0       	ldi	r25, 0x00	; 0
    41ac:	0e 94 a4 20 	call	0x4148	; 0x4148 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    41b0:	e0 e5       	ldi	r30, 0x50	; 80
    41b2:	f0 e0       	ldi	r31, 0x00	; 0
    41b4:	80 81       	ld	r24, Z
    41b6:	8e 7f       	andi	r24, 0xFE	; 254
    41b8:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    41ba:	9d ef       	ldi	r25, 0xFD	; 253
    41bc:	88 ed       	ldi	r24, 0xD8	; 216
    41be:	08 b6       	in	r0, 0x38	; 56
    41c0:	18 be       	out	0x38, r1	; 56
    41c2:	84 bf       	out	0x34, r24	; 52
    41c4:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    41c8:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    41ca:	40 eb       	ldi	r20, 0xB0	; 176
    41cc:	58 e0       	ldi	r21, 0x08	; 8
    41ce:	60 e0       	ldi	r22, 0x00	; 0
    41d0:	70 e0       	ldi	r23, 0x00	; 0
    41d2:	ce 01       	movw	r24, r28
    41d4:	01 96       	adiw	r24, 0x01	; 1
    41d6:	0e 94 4e 1e 	call	0x3c9c	; 0x3c9c <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    41da:	67 e0       	ldi	r22, 0x07	; 7
    41dc:	ce 01       	movw	r24, r28
    41de:	01 96       	adiw	r24, 0x01	; 1
    41e0:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    41e4:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    41e6:	67 e7       	ldi	r22, 0x77	; 119
    41e8:	70 e2       	ldi	r23, 0x20	; 32
    41ea:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <_ZN8emstream4putsEPKc>
    41ee:	66 e0       	ldi	r22, 0x06	; 6
    41f0:	c8 01       	movw	r24, r16
    41f2:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
    41f6:	66 e0       	ldi	r22, 0x06	; 6
    41f8:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    41fc:	82 e1       	ldi	r24, 0x12	; 18
    41fe:	90 e0       	ldi	r25, 0x00	; 0
    4200:	0e 94 c0 1b 	call	0x3780	; 0x3780 <_Znwj>
    4204:	8e 01       	movw	r16, r28
    4206:	0f 5f       	subi	r16, 0xFF	; 255
    4208:	1f 4f       	sbci	r17, 0xFF	; 255
    420a:	24 e0       	ldi	r18, 0x04	; 4
    420c:	31 e0       	ldi	r19, 0x01	; 1
    420e:	40 e0       	ldi	r20, 0x00	; 0
    4210:	66 e9       	ldi	r22, 0x96	; 150
    4212:	70 e2       	ldi	r23, 0x20	; 32
    4214:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    4218:	82 e1       	ldi	r24, 0x12	; 18
    421a:	90 e0       	ldi	r25, 0x00	; 0
    421c:	0e 94 c0 1b 	call	0x3780	; 0x3780 <_Znwj>
    4220:	24 e0       	ldi	r18, 0x04	; 4
    4222:	31 e0       	ldi	r19, 0x01	; 1
    4224:	42 e0       	ldi	r20, 0x02	; 2
    4226:	6e e9       	ldi	r22, 0x9E	; 158
    4228:	70 e2       	ldi	r23, 0x20	; 32
    422a:	0e 94 4b 04 	call	0x896	; 0x896 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    422e:	82 e1       	ldi	r24, 0x12	; 18
    4230:	90 e0       	ldi	r25, 0x00	; 0
    4232:	0e 94 c0 1b 	call	0x3780	; 0x3780 <_Znwj>
    4236:	24 e0       	ldi	r18, 0x04	; 4
    4238:	31 e0       	ldi	r19, 0x01	; 1
    423a:	43 e0       	ldi	r20, 0x03	; 3
    423c:	65 ea       	ldi	r22, 0xA5	; 165
    423e:	70 e2       	ldi	r23, 0x20	; 32
    4240:	0e 94 a4 04 	call	0x948	; 0x948 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    4244:	82 e1       	ldi	r24, 0x12	; 18
    4246:	90 e0       	ldi	r25, 0x00	; 0
    4248:	0e 94 c0 1b 	call	0x3780	; 0x3780 <_Znwj>
    424c:	24 e0       	ldi	r18, 0x04	; 4
    424e:	31 e0       	ldi	r19, 0x01	; 1
    4250:	44 e0       	ldi	r20, 0x04	; 4
    4252:	6c ea       	ldi	r22, 0xAC	; 172
    4254:	70 e2       	ldi	r23, 0x20	; 32
    4256:	0e 94 09 05 	call	0xa12	; 0xa12 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    425a:	8c e6       	ldi	r24, 0x6C	; 108
    425c:	90 e0       	ldi	r25, 0x00	; 0
    425e:	0e 94 c0 1b 	call	0x3780	; 0x3780 <_Znwj>
    4262:	24 e0       	ldi	r18, 0x04	; 4
    4264:	31 e0       	ldi	r19, 0x01	; 1
    4266:	43 e0       	ldi	r20, 0x03	; 3
    4268:	65 eb       	ldi	r22, 0xB5	; 181
    426a:	70 e2       	ldi	r23, 0x20	; 32
    426c:	0e 94 b2 08 	call	0x1164	; 0x1164 <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4270:	87 e0       	ldi	r24, 0x07	; 7
    4272:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4276:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4278:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <vTaskStartScheduler>
	
	
	return 0;
    427c:	80 e0       	ldi	r24, 0x00	; 0
    427e:	90 e0       	ldi	r25, 0x00	; 0
    4280:	6d 96       	adiw	r28, 0x1d	; 29
    4282:	cd bf       	out	0x3d, r28	; 61
    4284:	de bf       	out	0x3e, r29	; 62
    4286:	df 91       	pop	r29
    4288:	cf 91       	pop	r28
    428a:	1f 91       	pop	r17
    428c:	0f 91       	pop	r16
    428e:	08 95       	ret

00004290 <_GLOBAL__sub_I_counter>:
    4290:	0f 93       	push	r16
    4292:	1f 93       	push	r17
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4294:	0a e0       	ldi	r16, 0x0A	; 10
    4296:	10 e0       	ldi	r17, 0x00	; 0
    4298:	20 e0       	ldi	r18, 0x00	; 0
    429a:	30 e0       	ldi	r19, 0x00	; 0
    429c:	40 e0       	ldi	r20, 0x00	; 0
    429e:	50 e0       	ldi	r21, 0x00	; 0
    42a0:	60 e2       	ldi	r22, 0x20	; 32
    42a2:	70 e0       	ldi	r23, 0x00	; 0
    42a4:	84 e5       	ldi	r24, 0x54	; 84
    42a6:	91 e3       	ldi	r25, 0x31	; 49
    42a8:	0e 94 2c 1a 	call	0x3458	; 0x3458 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    42ac:	1f 91       	pop	r17
    42ae:	0f 91       	pop	r16
    42b0:	08 95       	ret

000042b2 <__cmpsf2>:
    42b2:	0e 94 9b 21 	call	0x4336	; 0x4336 <__fp_cmp>
    42b6:	08 f4       	brcc	.+2      	; 0x42ba <__cmpsf2+0x8>
    42b8:	81 e0       	ldi	r24, 0x01	; 1
    42ba:	08 95       	ret

000042bc <__floatunsisf>:
    42bc:	e8 94       	clt
    42be:	09 c0       	rjmp	.+18     	; 0x42d2 <__floatsisf+0x12>

000042c0 <__floatsisf>:
    42c0:	97 fb       	bst	r25, 7
    42c2:	3e f4       	brtc	.+14     	; 0x42d2 <__floatsisf+0x12>
    42c4:	90 95       	com	r25
    42c6:	80 95       	com	r24
    42c8:	70 95       	com	r23
    42ca:	61 95       	neg	r22
    42cc:	7f 4f       	sbci	r23, 0xFF	; 255
    42ce:	8f 4f       	sbci	r24, 0xFF	; 255
    42d0:	9f 4f       	sbci	r25, 0xFF	; 255
    42d2:	99 23       	and	r25, r25
    42d4:	a9 f0       	breq	.+42     	; 0x4300 <__floatsisf+0x40>
    42d6:	f9 2f       	mov	r31, r25
    42d8:	96 e9       	ldi	r25, 0x96	; 150
    42da:	bb 27       	eor	r27, r27
    42dc:	93 95       	inc	r25
    42de:	f6 95       	lsr	r31
    42e0:	87 95       	ror	r24
    42e2:	77 95       	ror	r23
    42e4:	67 95       	ror	r22
    42e6:	b7 95       	ror	r27
    42e8:	f1 11       	cpse	r31, r1
    42ea:	f8 cf       	rjmp	.-16     	; 0x42dc <__floatsisf+0x1c>
    42ec:	fa f4       	brpl	.+62     	; 0x432c <__floatsisf+0x6c>
    42ee:	bb 0f       	add	r27, r27
    42f0:	11 f4       	brne	.+4      	; 0x42f6 <__floatsisf+0x36>
    42f2:	60 ff       	sbrs	r22, 0
    42f4:	1b c0       	rjmp	.+54     	; 0x432c <__floatsisf+0x6c>
    42f6:	6f 5f       	subi	r22, 0xFF	; 255
    42f8:	7f 4f       	sbci	r23, 0xFF	; 255
    42fa:	8f 4f       	sbci	r24, 0xFF	; 255
    42fc:	9f 4f       	sbci	r25, 0xFF	; 255
    42fe:	16 c0       	rjmp	.+44     	; 0x432c <__floatsisf+0x6c>
    4300:	88 23       	and	r24, r24
    4302:	11 f0       	breq	.+4      	; 0x4308 <__floatsisf+0x48>
    4304:	96 e9       	ldi	r25, 0x96	; 150
    4306:	11 c0       	rjmp	.+34     	; 0x432a <__floatsisf+0x6a>
    4308:	77 23       	and	r23, r23
    430a:	21 f0       	breq	.+8      	; 0x4314 <__floatsisf+0x54>
    430c:	9e e8       	ldi	r25, 0x8E	; 142
    430e:	87 2f       	mov	r24, r23
    4310:	76 2f       	mov	r23, r22
    4312:	05 c0       	rjmp	.+10     	; 0x431e <__floatsisf+0x5e>
    4314:	66 23       	and	r22, r22
    4316:	71 f0       	breq	.+28     	; 0x4334 <__floatsisf+0x74>
    4318:	96 e8       	ldi	r25, 0x86	; 134
    431a:	86 2f       	mov	r24, r22
    431c:	70 e0       	ldi	r23, 0x00	; 0
    431e:	60 e0       	ldi	r22, 0x00	; 0
    4320:	2a f0       	brmi	.+10     	; 0x432c <__floatsisf+0x6c>
    4322:	9a 95       	dec	r25
    4324:	66 0f       	add	r22, r22
    4326:	77 1f       	adc	r23, r23
    4328:	88 1f       	adc	r24, r24
    432a:	da f7       	brpl	.-10     	; 0x4322 <__floatsisf+0x62>
    432c:	88 0f       	add	r24, r24
    432e:	96 95       	lsr	r25
    4330:	87 95       	ror	r24
    4332:	97 f9       	bld	r25, 7
    4334:	08 95       	ret

00004336 <__fp_cmp>:
    4336:	99 0f       	add	r25, r25
    4338:	00 08       	sbc	r0, r0
    433a:	55 0f       	add	r21, r21
    433c:	aa 0b       	sbc	r26, r26
    433e:	e0 e8       	ldi	r30, 0x80	; 128
    4340:	fe ef       	ldi	r31, 0xFE	; 254
    4342:	16 16       	cp	r1, r22
    4344:	17 06       	cpc	r1, r23
    4346:	e8 07       	cpc	r30, r24
    4348:	f9 07       	cpc	r31, r25
    434a:	c0 f0       	brcs	.+48     	; 0x437c <__fp_cmp+0x46>
    434c:	12 16       	cp	r1, r18
    434e:	13 06       	cpc	r1, r19
    4350:	e4 07       	cpc	r30, r20
    4352:	f5 07       	cpc	r31, r21
    4354:	98 f0       	brcs	.+38     	; 0x437c <__fp_cmp+0x46>
    4356:	62 1b       	sub	r22, r18
    4358:	73 0b       	sbc	r23, r19
    435a:	84 0b       	sbc	r24, r20
    435c:	95 0b       	sbc	r25, r21
    435e:	39 f4       	brne	.+14     	; 0x436e <__fp_cmp+0x38>
    4360:	0a 26       	eor	r0, r26
    4362:	61 f0       	breq	.+24     	; 0x437c <__fp_cmp+0x46>
    4364:	23 2b       	or	r18, r19
    4366:	24 2b       	or	r18, r20
    4368:	25 2b       	or	r18, r21
    436a:	21 f4       	brne	.+8      	; 0x4374 <__fp_cmp+0x3e>
    436c:	08 95       	ret
    436e:	0a 26       	eor	r0, r26
    4370:	09 f4       	brne	.+2      	; 0x4374 <__fp_cmp+0x3e>
    4372:	a1 40       	sbci	r26, 0x01	; 1
    4374:	a6 95       	lsr	r26
    4376:	8f ef       	ldi	r24, 0xFF	; 255
    4378:	81 1d       	adc	r24, r1
    437a:	81 1d       	adc	r24, r1
    437c:	08 95       	ret

0000437e <__gesf2>:
    437e:	0e 94 9b 21 	call	0x4336	; 0x4336 <__fp_cmp>
    4382:	08 f4       	brcc	.+2      	; 0x4386 <__gesf2+0x8>
    4384:	8f ef       	ldi	r24, 0xFF	; 255
    4386:	08 95       	ret

00004388 <__mulsi3>:
    4388:	db 01       	movw	r26, r22
    438a:	8f 93       	push	r24
    438c:	9f 93       	push	r25
    438e:	0e 94 50 22 	call	0x44a0	; 0x44a0 <__muluhisi3>
    4392:	bf 91       	pop	r27
    4394:	af 91       	pop	r26
    4396:	a2 9f       	mul	r26, r18
    4398:	80 0d       	add	r24, r0
    439a:	91 1d       	adc	r25, r1
    439c:	a3 9f       	mul	r26, r19
    439e:	90 0d       	add	r25, r0
    43a0:	b2 9f       	mul	r27, r18
    43a2:	90 0d       	add	r25, r0
    43a4:	11 24       	eor	r1, r1
    43a6:	08 95       	ret

000043a8 <__divmodhi4>:
    43a8:	97 fb       	bst	r25, 7
    43aa:	07 2e       	mov	r0, r23
    43ac:	16 f4       	brtc	.+4      	; 0x43b2 <__divmodhi4+0xa>
    43ae:	00 94       	com	r0
    43b0:	07 d0       	rcall	.+14     	; 0x43c0 <__divmodhi4_neg1>
    43b2:	77 fd       	sbrc	r23, 7
    43b4:	09 d0       	rcall	.+18     	; 0x43c8 <__divmodhi4_neg2>
    43b6:	0e 94 63 22 	call	0x44c6	; 0x44c6 <__udivmodhi4>
    43ba:	07 fc       	sbrc	r0, 7
    43bc:	05 d0       	rcall	.+10     	; 0x43c8 <__divmodhi4_neg2>
    43be:	3e f4       	brtc	.+14     	; 0x43ce <__divmodhi4_exit>

000043c0 <__divmodhi4_neg1>:
    43c0:	90 95       	com	r25
    43c2:	81 95       	neg	r24
    43c4:	9f 4f       	sbci	r25, 0xFF	; 255
    43c6:	08 95       	ret

000043c8 <__divmodhi4_neg2>:
    43c8:	70 95       	com	r23
    43ca:	61 95       	neg	r22
    43cc:	7f 4f       	sbci	r23, 0xFF	; 255

000043ce <__divmodhi4_exit>:
    43ce:	08 95       	ret

000043d0 <__udivmodsi4>:
    43d0:	a1 e2       	ldi	r26, 0x21	; 33
    43d2:	1a 2e       	mov	r1, r26
    43d4:	aa 1b       	sub	r26, r26
    43d6:	bb 1b       	sub	r27, r27
    43d8:	fd 01       	movw	r30, r26
    43da:	0d c0       	rjmp	.+26     	; 0x43f6 <__udivmodsi4_ep>

000043dc <__udivmodsi4_loop>:
    43dc:	aa 1f       	adc	r26, r26
    43de:	bb 1f       	adc	r27, r27
    43e0:	ee 1f       	adc	r30, r30
    43e2:	ff 1f       	adc	r31, r31
    43e4:	a2 17       	cp	r26, r18
    43e6:	b3 07       	cpc	r27, r19
    43e8:	e4 07       	cpc	r30, r20
    43ea:	f5 07       	cpc	r31, r21
    43ec:	20 f0       	brcs	.+8      	; 0x43f6 <__udivmodsi4_ep>
    43ee:	a2 1b       	sub	r26, r18
    43f0:	b3 0b       	sbc	r27, r19
    43f2:	e4 0b       	sbc	r30, r20
    43f4:	f5 0b       	sbc	r31, r21

000043f6 <__udivmodsi4_ep>:
    43f6:	66 1f       	adc	r22, r22
    43f8:	77 1f       	adc	r23, r23
    43fa:	88 1f       	adc	r24, r24
    43fc:	99 1f       	adc	r25, r25
    43fe:	1a 94       	dec	r1
    4400:	69 f7       	brne	.-38     	; 0x43dc <__udivmodsi4_loop>
    4402:	60 95       	com	r22
    4404:	70 95       	com	r23
    4406:	80 95       	com	r24
    4408:	90 95       	com	r25
    440a:	9b 01       	movw	r18, r22
    440c:	ac 01       	movw	r20, r24
    440e:	bd 01       	movw	r22, r26
    4410:	cf 01       	movw	r24, r30
    4412:	08 95       	ret

00004414 <__divmodsi4>:
    4414:	05 2e       	mov	r0, r21
    4416:	97 fb       	bst	r25, 7
    4418:	1e f4       	brtc	.+6      	; 0x4420 <__divmodsi4+0xc>
    441a:	00 94       	com	r0
    441c:	0e 94 21 22 	call	0x4442	; 0x4442 <__negsi2>
    4420:	57 fd       	sbrc	r21, 7
    4422:	07 d0       	rcall	.+14     	; 0x4432 <__divmodsi4_neg2>
    4424:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__udivmodsi4>
    4428:	07 fc       	sbrc	r0, 7
    442a:	03 d0       	rcall	.+6      	; 0x4432 <__divmodsi4_neg2>
    442c:	4e f4       	brtc	.+18     	; 0x4440 <__divmodsi4_exit>
    442e:	0c 94 21 22 	jmp	0x4442	; 0x4442 <__negsi2>

00004432 <__divmodsi4_neg2>:
    4432:	50 95       	com	r21
    4434:	40 95       	com	r20
    4436:	30 95       	com	r19
    4438:	21 95       	neg	r18
    443a:	3f 4f       	sbci	r19, 0xFF	; 255
    443c:	4f 4f       	sbci	r20, 0xFF	; 255
    443e:	5f 4f       	sbci	r21, 0xFF	; 255

00004440 <__divmodsi4_exit>:
    4440:	08 95       	ret

00004442 <__negsi2>:
    4442:	90 95       	com	r25
    4444:	80 95       	com	r24
    4446:	70 95       	com	r23
    4448:	61 95       	neg	r22
    444a:	7f 4f       	sbci	r23, 0xFF	; 255
    444c:	8f 4f       	sbci	r24, 0xFF	; 255
    444e:	9f 4f       	sbci	r25, 0xFF	; 255
    4450:	08 95       	ret

00004452 <__tablejump2__>:
    4452:	ee 0f       	add	r30, r30
    4454:	ff 1f       	adc	r31, r31
    4456:	88 1f       	adc	r24, r24
    4458:	8b bf       	out	0x3b, r24	; 59
    445a:	07 90       	elpm	r0, Z+
    445c:	f6 91       	elpm	r31, Z
    445e:	e0 2d       	mov	r30, r0
    4460:	1b be       	out	0x3b, r1	; 59
    4462:	19 94       	eijmp

00004464 <__mulhisi3>:
    4464:	0e 94 3a 22 	call	0x4474	; 0x4474 <__umulhisi3>
    4468:	33 23       	and	r19, r19
    446a:	12 f4       	brpl	.+4      	; 0x4470 <__mulhisi3+0xc>
    446c:	8a 1b       	sub	r24, r26
    446e:	9b 0b       	sbc	r25, r27
    4470:	0c 94 4b 22 	jmp	0x4496	; 0x4496 <__usmulhisi3_tail>

00004474 <__umulhisi3>:
    4474:	a2 9f       	mul	r26, r18
    4476:	b0 01       	movw	r22, r0
    4478:	b3 9f       	mul	r27, r19
    447a:	c0 01       	movw	r24, r0
    447c:	a3 9f       	mul	r26, r19
    447e:	70 0d       	add	r23, r0
    4480:	81 1d       	adc	r24, r1
    4482:	11 24       	eor	r1, r1
    4484:	91 1d       	adc	r25, r1
    4486:	b2 9f       	mul	r27, r18
    4488:	70 0d       	add	r23, r0
    448a:	81 1d       	adc	r24, r1
    448c:	11 24       	eor	r1, r1
    448e:	91 1d       	adc	r25, r1
    4490:	08 95       	ret

00004492 <__usmulhisi3>:
    4492:	0e 94 3a 22 	call	0x4474	; 0x4474 <__umulhisi3>

00004496 <__usmulhisi3_tail>:
    4496:	b7 ff       	sbrs	r27, 7
    4498:	08 95       	ret
    449a:	82 1b       	sub	r24, r18
    449c:	93 0b       	sbc	r25, r19
    449e:	08 95       	ret

000044a0 <__muluhisi3>:
    44a0:	0e 94 3a 22 	call	0x4474	; 0x4474 <__umulhisi3>
    44a4:	a5 9f       	mul	r26, r21
    44a6:	90 0d       	add	r25, r0
    44a8:	b4 9f       	mul	r27, r20
    44aa:	90 0d       	add	r25, r0
    44ac:	a4 9f       	mul	r26, r20
    44ae:	80 0d       	add	r24, r0
    44b0:	91 1d       	adc	r25, r1
    44b2:	11 24       	eor	r1, r1
    44b4:	08 95       	ret

000044b6 <__mulshisi3>:
    44b6:	b7 ff       	sbrs	r27, 7
    44b8:	0c 94 50 22 	jmp	0x44a0	; 0x44a0 <__muluhisi3>

000044bc <__mulohisi3>:
    44bc:	0e 94 50 22 	call	0x44a0	; 0x44a0 <__muluhisi3>
    44c0:	82 1b       	sub	r24, r18
    44c2:	93 0b       	sbc	r25, r19
    44c4:	08 95       	ret

000044c6 <__udivmodhi4>:
    44c6:	aa 1b       	sub	r26, r26
    44c8:	bb 1b       	sub	r27, r27
    44ca:	51 e1       	ldi	r21, 0x11	; 17
    44cc:	07 c0       	rjmp	.+14     	; 0x44dc <__udivmodhi4_ep>

000044ce <__udivmodhi4_loop>:
    44ce:	aa 1f       	adc	r26, r26
    44d0:	bb 1f       	adc	r27, r27
    44d2:	a6 17       	cp	r26, r22
    44d4:	b7 07       	cpc	r27, r23
    44d6:	10 f0       	brcs	.+4      	; 0x44dc <__udivmodhi4_ep>
    44d8:	a6 1b       	sub	r26, r22
    44da:	b7 0b       	sbc	r27, r23

000044dc <__udivmodhi4_ep>:
    44dc:	88 1f       	adc	r24, r24
    44de:	99 1f       	adc	r25, r25
    44e0:	5a 95       	dec	r21
    44e2:	a9 f7       	brne	.-22     	; 0x44ce <__udivmodhi4_loop>
    44e4:	80 95       	com	r24
    44e6:	90 95       	com	r25
    44e8:	bc 01       	movw	r22, r24
    44ea:	cd 01       	movw	r24, r26
    44ec:	08 95       	ret

000044ee <memcpy>:
    44ee:	fb 01       	movw	r30, r22
    44f0:	dc 01       	movw	r26, r24
    44f2:	02 c0       	rjmp	.+4      	; 0x44f8 <memcpy+0xa>
    44f4:	01 90       	ld	r0, Z+
    44f6:	0d 92       	st	X+, r0
    44f8:	41 50       	subi	r20, 0x01	; 1
    44fa:	50 40       	sbci	r21, 0x00	; 0
    44fc:	d8 f7       	brcc	.-10     	; 0x44f4 <memcpy+0x6>
    44fe:	08 95       	ret

00004500 <memset>:
    4500:	dc 01       	movw	r26, r24
    4502:	01 c0       	rjmp	.+2      	; 0x4506 <memset+0x6>
    4504:	6d 93       	st	X+, r22
    4506:	41 50       	subi	r20, 0x01	; 1
    4508:	50 40       	sbci	r21, 0x00	; 0
    450a:	e0 f7       	brcc	.-8      	; 0x4504 <memset+0x4>
    450c:	08 95       	ret

0000450e <strncpy>:
    450e:	fb 01       	movw	r30, r22
    4510:	dc 01       	movw	r26, r24
    4512:	41 50       	subi	r20, 0x01	; 1
    4514:	50 40       	sbci	r21, 0x00	; 0
    4516:	48 f0       	brcs	.+18     	; 0x452a <strncpy+0x1c>
    4518:	01 90       	ld	r0, Z+
    451a:	0d 92       	st	X+, r0
    451c:	00 20       	and	r0, r0
    451e:	c9 f7       	brne	.-14     	; 0x4512 <strncpy+0x4>
    4520:	01 c0       	rjmp	.+2      	; 0x4524 <strncpy+0x16>
    4522:	1d 92       	st	X+, r1
    4524:	41 50       	subi	r20, 0x01	; 1
    4526:	50 40       	sbci	r21, 0x00	; 0
    4528:	e0 f7       	brcc	.-8      	; 0x4522 <strncpy+0x14>
    452a:	08 95       	ret

0000452c <ultoa>:
    452c:	25 32       	cpi	r18, 0x25	; 37
    452e:	31 05       	cpc	r19, r1
    4530:	20 f4       	brcc	.+8      	; 0x453a <ultoa+0xe>
    4532:	22 30       	cpi	r18, 0x02	; 2
    4534:	10 f0       	brcs	.+4      	; 0x453a <ultoa+0xe>
    4536:	0c 94 a1 22 	jmp	0x4542	; 0x4542 <__ultoa_ncheck>
    453a:	fa 01       	movw	r30, r20
    453c:	10 82       	st	Z, r1
    453e:	ca 01       	movw	r24, r20
    4540:	08 95       	ret

00004542 <__ultoa_ncheck>:
    4542:	bb 27       	eor	r27, r27

00004544 <__ultoa_common>:
    4544:	fa 01       	movw	r30, r20
    4546:	a6 2f       	mov	r26, r22
    4548:	62 17       	cp	r22, r18
    454a:	71 05       	cpc	r23, r1
    454c:	81 05       	cpc	r24, r1
    454e:	91 05       	cpc	r25, r1
    4550:	33 0b       	sbc	r19, r19
    4552:	30 fb       	bst	r19, 0
    4554:	66 f0       	brts	.+24     	; 0x456e <__ultoa_common+0x2a>
    4556:	aa 27       	eor	r26, r26
    4558:	66 0f       	add	r22, r22
    455a:	77 1f       	adc	r23, r23
    455c:	88 1f       	adc	r24, r24
    455e:	99 1f       	adc	r25, r25
    4560:	aa 1f       	adc	r26, r26
    4562:	a2 17       	cp	r26, r18
    4564:	10 f0       	brcs	.+4      	; 0x456a <__ultoa_common+0x26>
    4566:	a2 1b       	sub	r26, r18
    4568:	63 95       	inc	r22
    456a:	38 50       	subi	r19, 0x08	; 8
    456c:	a9 f7       	brne	.-22     	; 0x4558 <__ultoa_common+0x14>
    456e:	a0 5d       	subi	r26, 0xD0	; 208
    4570:	aa 33       	cpi	r26, 0x3A	; 58
    4572:	08 f0       	brcs	.+2      	; 0x4576 <__ultoa_common+0x32>
    4574:	a9 5d       	subi	r26, 0xD9	; 217
    4576:	a1 93       	st	Z+, r26
    4578:	36 f7       	brtc	.-52     	; 0x4546 <__ultoa_common+0x2>
    457a:	b1 11       	cpse	r27, r1
    457c:	b1 93       	st	Z+, r27
    457e:	10 82       	st	Z, r1
    4580:	ca 01       	movw	r24, r20
    4582:	0c 94 e8 22 	jmp	0x45d0	; 0x45d0 <strrev>

00004586 <utoa>:
    4586:	45 32       	cpi	r20, 0x25	; 37
    4588:	51 05       	cpc	r21, r1
    458a:	20 f4       	brcc	.+8      	; 0x4594 <utoa+0xe>
    458c:	42 30       	cpi	r20, 0x02	; 2
    458e:	10 f0       	brcs	.+4      	; 0x4594 <utoa+0xe>
    4590:	0c 94 ce 22 	jmp	0x459c	; 0x459c <__utoa_ncheck>
    4594:	fb 01       	movw	r30, r22
    4596:	10 82       	st	Z, r1
    4598:	cb 01       	movw	r24, r22
    459a:	08 95       	ret

0000459c <__utoa_ncheck>:
    459c:	bb 27       	eor	r27, r27

0000459e <__utoa_common>:
    459e:	fb 01       	movw	r30, r22
    45a0:	55 27       	eor	r21, r21
    45a2:	aa 27       	eor	r26, r26
    45a4:	88 0f       	add	r24, r24
    45a6:	99 1f       	adc	r25, r25
    45a8:	aa 1f       	adc	r26, r26
    45aa:	a4 17       	cp	r26, r20
    45ac:	10 f0       	brcs	.+4      	; 0x45b2 <__utoa_common+0x14>
    45ae:	a4 1b       	sub	r26, r20
    45b0:	83 95       	inc	r24
    45b2:	50 51       	subi	r21, 0x10	; 16
    45b4:	b9 f7       	brne	.-18     	; 0x45a4 <__utoa_common+0x6>
    45b6:	a0 5d       	subi	r26, 0xD0	; 208
    45b8:	aa 33       	cpi	r26, 0x3A	; 58
    45ba:	08 f0       	brcs	.+2      	; 0x45be <__utoa_common+0x20>
    45bc:	a9 5d       	subi	r26, 0xD9	; 217
    45be:	a1 93       	st	Z+, r26
    45c0:	00 97       	sbiw	r24, 0x00	; 0
    45c2:	79 f7       	brne	.-34     	; 0x45a2 <__utoa_common+0x4>
    45c4:	b1 11       	cpse	r27, r1
    45c6:	b1 93       	st	Z+, r27
    45c8:	11 92       	st	Z+, r1
    45ca:	cb 01       	movw	r24, r22
    45cc:	0c 94 e8 22 	jmp	0x45d0	; 0x45d0 <strrev>

000045d0 <strrev>:
    45d0:	dc 01       	movw	r26, r24
    45d2:	fc 01       	movw	r30, r24
    45d4:	67 2f       	mov	r22, r23
    45d6:	71 91       	ld	r23, Z+
    45d8:	77 23       	and	r23, r23
    45da:	e1 f7       	brne	.-8      	; 0x45d4 <strrev+0x4>
    45dc:	32 97       	sbiw	r30, 0x02	; 2
    45de:	04 c0       	rjmp	.+8      	; 0x45e8 <strrev+0x18>
    45e0:	7c 91       	ld	r23, X
    45e2:	6d 93       	st	X+, r22
    45e4:	70 83       	st	Z, r23
    45e6:	62 91       	ld	r22, -Z
    45e8:	ae 17       	cp	r26, r30
    45ea:	bf 07       	cpc	r27, r31
    45ec:	c8 f3       	brcs	.-14     	; 0x45e0 <strrev+0x10>
    45ee:	08 95       	ret

000045f0 <_exit>:
    45f0:	f8 94       	cli

000045f2 <__stop_program>:
    45f2:	ff cf       	rjmp	.-2      	; 0x45f2 <__stop_program>
