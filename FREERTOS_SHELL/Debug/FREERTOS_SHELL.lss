
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003994  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000009a  00802000  00003994  00003a28  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  0080209a  0080209a  00003ac2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003ac2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003af4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000618  00000000  00000000  00003b34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010017  00000000  00000000  0000414c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006d94  00000000  00000000  00014163  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000047ae  00000000  00000000  0001aef7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001188  00000000  00000000  0001f6a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000699e  00000000  00000000  00020830  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000054fd  00000000  00000000  000271ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004f8  00000000  00000000  0002c6cb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a1 02 	jmp	0x542	; 0x542 <__ctors_end>
       4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
       8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
       c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      10:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      14:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      18:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      1c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      20:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      24:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      28:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      2c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      30:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      34:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      38:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      3c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      40:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      44:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      48:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      4c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      50:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      54:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      58:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      5c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      60:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      64:	0c 94 8a 18 	jmp	0x3114	; 0x3114 <__vector_25>
      68:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      6c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      70:	0c 94 e8 18 	jmp	0x31d0	; 0x31d0 <__vector_28>
      74:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      78:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      7c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      80:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      84:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      88:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      8c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      90:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      94:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      98:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      9c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      a0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      a4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      a8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      ac:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      b0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      b4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      b8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      bc:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      c0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      c4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      c8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      cc:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      d0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      d4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      d8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      dc:	0c 94 ac 08 	jmp	0x1158	; 0x1158 <__vector_55>
      e0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      e4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      e8:	0c 94 02 1a 	jmp	0x3404	; 0x3404 <__vector_58>
      ec:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      f0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      f4:	0c 94 60 1a 	jmp	0x34c0	; 0x34c0 <__vector_61>
      f8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
      fc:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     100:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     104:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     108:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     10c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     110:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     114:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     118:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     11c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     120:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     124:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     128:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     12c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     130:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     134:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     138:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     13c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     140:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     144:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     148:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     14c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     150:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     154:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     158:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     15c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     160:	0c 94 46 19 	jmp	0x328c	; 0x328c <__vector_88>
     164:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     168:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     16c:	0c 94 a4 19 	jmp	0x3348	; 0x3348 <__vector_91>
     170:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     174:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     178:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     17c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     180:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     184:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     188:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     18c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     190:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     194:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     198:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     19c:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1a0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1a4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1a8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1ac:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1b0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1b4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1b8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1bc:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1c0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1c4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1c8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1cc:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1d0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1d4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1d8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1dc:	0c 94 be 1a 	jmp	0x357c	; 0x357c <__vector_119>
     1e0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1e4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1e8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1ec:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1f0:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1f4:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1f8:	0c 94 d7 02 	jmp	0x5ae	; 0x5ae <__bad_interrupt>
     1fc:	2b 16       	cp	r2, r27
     1fe:	2e 16       	cp	r2, r30
     200:	31 16       	cp	r3, r17
     202:	34 16       	cp	r3, r20
     204:	37 16       	cp	r3, r23
     206:	3a 16       	cp	r3, r26
     208:	3c 16       	cp	r3, r28
     20a:	4d 16       	cp	r4, r29
     20c:	55 16       	cp	r5, r21
     20e:	5f 16       	cp	r5, r31
     210:	5d 16       	cp	r5, r29

00000212 <__trampolines_start>:
     212:	0c 94 4d 16 	jmp	0x2c9a	; 0x2c9a <_ZN8emstreamlsE15ser_manipulator+0x62>
     216:	0c 94 3a 16 	jmp	0x2c74	; 0x2c74 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     21a:	0c 94 55 16 	jmp	0x2caa	; 0x2caa <_ZN8emstreamlsE15ser_manipulator+0x72>
     21e:	0c 94 d3 15 	jmp	0x2ba6	; 0x2ba6 <_ZN8emstream14check_for_charEv>
     222:	0c 94 2b 16 	jmp	0x2c56	; 0x2c56 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     226:	0c 94 d6 15 	jmp	0x2bac	; 0x2bac <_ZN8emstream12clear_screenEv>
     22a:	0c 94 f2 11 	jmp	0x23e4	; 0x23e4 <_ZN8frt_task12print_statusER8emstream>
     22e:	0c 94 34 16 	jmp	0x2c68	; 0x2c68 <_ZN8emstreamlsE15ser_manipulator+0x30>
     232:	0c 94 82 17 	jmp	0x2f04	; 0x2f04 <_ZN5rs2327putcharEc>
     236:	0c 94 1d 15 	jmp	0x2a3a	; 0x2a3a <__cxa_pure_virtual>
     23a:	0c 94 37 16 	jmp	0x2c6e	; 0x2c6e <_ZN8emstreamlsE15ser_manipulator+0x36>
     23e:	0c 94 86 04 	jmp	0x90c	; 0x90c <_ZN9task_user3runEv>
     242:	0c 94 3c 13 	jmp	0x2678	; 0x2678 <_ZN14frt_text_queue7getcharEv>
     246:	0c 94 ce 15 	jmp	0x2b9c	; 0x2b9c <_ZN8emstream13ready_to_sendEv>
     24a:	0c 94 9e 02 	jmp	0x53c	; 0x53c <_call_static_run_method>
     24e:	0c 94 5d 16 	jmp	0x2cba	; 0x2cba <_ZN8emstreamlsE15ser_manipulator+0x82>
     252:	0c 94 5f 16 	jmp	0x2cbe	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
     256:	0c 94 d5 15 	jmp	0x2baa	; 0x2baa <_ZN8emstream12transmit_nowEv>
     25a:	0c 94 cc 17 	jmp	0x2f98	; 0x2f98 <_ZN5rs23214check_for_charEv>
     25e:	0c 94 df 17 	jmp	0x2fbe	; 0x2fbe <_ZN5rs23212clear_screenEv>
     262:	0c 94 3c 16 	jmp	0x2c78	; 0x2c78 <_ZN8emstreamlsE15ser_manipulator+0x40>
     266:	0c 94 5a 13 	jmp	0x26b4	; 0x26b4 <_ZN14frt_text_queue14check_for_charEv>
     26a:	0c 94 65 13 	jmp	0x26ca	; 0x26ca <_ZN14frt_text_queue7putcharEc>
     26e:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <_ZN12EncoderMotor3runEv>
     272:	0c 94 31 16 	jmp	0x2c62	; 0x2c62 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     276:	0c 94 2e 16 	jmp	0x2c5c	; 0x2c5c <_ZN8emstreamlsE15ser_manipulator+0x24>
     27a:	0c 94 d0 15 	jmp	0x2ba0	; 0x2ba0 <_ZN8emstream7getcharEv>
     27e:	0c 94 a6 17 	jmp	0x2f4c	; 0x2f4c <_ZN5rs2327getcharEv>
     282:	0c 94 30 0b 	jmp	0x1660	; 0x1660 <prvIdleTask>
     286:	0c 94 b7 1b 	jmp	0x376e	; 0x376e <_GLOBAL__sub_I_counter>

0000028a <__trampolines_end>:
     28a:	2c 20       	and	r2, r12
     28c:	54 43       	sbci	r21, 0x34	; 52
     28e:	43 30       	cpi	r20, 0x03	; 3
     290:	43 43       	sbci	r20, 0x33	; 51
     292:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000295 <_ZZN9task_user11show_statusEvE3__c_3>:
     295:	2f 00                                               /.

00000297 <_ZZN9task_user11show_statusEvE3__c_2>:
     297:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002a5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2a5:	54 69 6d 65 3a 20 00                                Time: .

000002ac <_ZZN9task_user11show_statusEvE3__c_0>:
     2ac:	4e 6f 76 20 32 35 20 32 30 31 37 00                 Nov 25 2017.

000002b8 <_ZZN9task_user11show_statusEvE3__c>:
     2b8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2c8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002d7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2d7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002e6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2e6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     2f6:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000301 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     301:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     311:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000031f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     31f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     32f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     33f:	6d 61 74 69 6f 6e 00                                mation.

00000346 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     346:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     356:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000367 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     367:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     377:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000037f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     37f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     38f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000039b <_ZZN9task_user18print_help_messageEvE3__c_3>:
     39b:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3ab:	68 65 20 41 56 52 00                                he AVR.

000003b2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3b2:	20 68 65 6c 70 00                                    help.

000003b8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3b8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3c8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003d7 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3d7:	1b 5b 33 30 6d 00                                   .[30m.

000003dd <_ZZN9task_user18print_help_messageEvE3__c>:
     3dd:	1b 5b 34 36 6d 00                                   .[46m.

000003e3 <_ZZN9task_user3runEvE3__c_3>:
     3e3:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3f3:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000400 <_ZZN9task_user3runEvE3__c_2>:
     400:	3a 57 54 46 3f 00                                   :WTF?.

00000406 <_ZZN9task_user3runEvE3__c_1>:
     406:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     416:	65 00                                               e.

00000418 <_ZZN9task_user3runEvE3__c_0>:
     418:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000426 <_ZZN9task_user3runEvE3__c>:
     426:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     436:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000444 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     444:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000044e <_ZZN8frt_task15emergency_resetEvE3__c>:
     44e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000045d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     45d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     46d:	61 73 6b 20 00                                      ask .

00000472 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     472:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000480 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     480:	20 63 72 65 61 74 65 64 00                           created.

00000489 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     489:	54 61 73 6b 20 00                                   Task .

0000048f <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     48f:	1b 5b 32 32 6d 00                                   .[22m.

00000495 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     495:	54 61 73 6b 3a 20 00                                Task: .

0000049c <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     49c:	1b 5b 31 6d 00                                      .[1m.

000004a1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4a1:	1b 5b 32 32 6d 00                                   .[22m.

000004a7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4a7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004b2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4b2:	1b 5b 31 6d 00                                      .[1m.

000004b7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4b7:	09 09 00                                            ...

000004ba <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ba:	2f 00                                               /.

000004bc <_ZZ15print_task_listP8emstreamE3__c_7>:
     4bc:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004c7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4c7:	09 2d 2d 2d 2d 00                                   .----.

000004cd <_ZZ15print_task_listP8emstreamE3__c_5>:
     4cd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4d9:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004ea <_ZZ15print_task_listP8emstreamE3__c_3>:
     4ea:	09 52 75 6e 73 00                                   .Runs.

000004f0 <_ZZ15print_task_listP8emstreamE3__c_2>:
     4f0:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000004fc <_ZZ15print_task_listP8emstreamE3__c_1>:
     4fc:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000050d <_ZZ15print_task_listP8emstreamE3__c_0>:
     50d:	09 53 74 61 63 6b 00                                .Stack.

00000514 <_ZZ15print_task_listP8emstreamE3__c>:
     514:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000051f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     51f:	09 00                                               ..

00000521 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     521:	09 00                                               ..

00000523 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     523:	2f 00                                               /.

00000525 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     525:	09 00                                               ..

00000527 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     527:	09 00                                               ..

00000529 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     529:	1b 5b 32 32 6d 00                                   .[22m.

0000052f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     52f:	1b 5b 31 6d 00                                      .[1m.

00000534 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     534:	1b 5b 31 6d 00                                      .[1m.

00000539 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     539:	20 20 00                                              .

0000053c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     53c:	0e 94 8a 10 	call	0x2114	; 0x2114 <_ZN8frt_task22_call_users_run_methodEPS_>

00000540 <__ctors_start>:
     540:	b7 1b       	sub	r27, r23

00000542 <__ctors_end>:
     542:	11 24       	eor	r1, r1
     544:	1f be       	out	0x3f, r1	; 63
     546:	cf ef       	ldi	r28, 0xFF	; 255
     548:	cd bf       	out	0x3d, r28	; 61
     54a:	df e3       	ldi	r29, 0x3F	; 63
     54c:	de bf       	out	0x3e, r29	; 62
     54e:	00 e0       	ldi	r16, 0x00	; 0
     550:	0c bf       	out	0x3c, r16	; 60
     552:	18 be       	out	0x38, r1	; 56
     554:	19 be       	out	0x39, r1	; 57
     556:	1a be       	out	0x3a, r1	; 58
     558:	1b be       	out	0x3b, r1	; 59

0000055a <__do_copy_data>:
     55a:	10 e2       	ldi	r17, 0x20	; 32
     55c:	a0 e0       	ldi	r26, 0x00	; 0
     55e:	b0 e2       	ldi	r27, 0x20	; 32
     560:	e4 e9       	ldi	r30, 0x94	; 148
     562:	f9 e3       	ldi	r31, 0x39	; 57
     564:	00 e0       	ldi	r16, 0x00	; 0
     566:	0b bf       	out	0x3b, r16	; 59
     568:	02 c0       	rjmp	.+4      	; 0x56e <__do_copy_data+0x14>
     56a:	07 90       	elpm	r0, Z+
     56c:	0d 92       	st	X+, r0
     56e:	aa 39       	cpi	r26, 0x9A	; 154
     570:	b1 07       	cpc	r27, r17
     572:	d9 f7       	brne	.-10     	; 0x56a <__do_copy_data+0x10>
     574:	1b be       	out	0x3b, r1	; 59

00000576 <__do_clear_bss>:
     576:	21 e3       	ldi	r18, 0x31	; 49
     578:	aa e9       	ldi	r26, 0x9A	; 154
     57a:	b0 e2       	ldi	r27, 0x20	; 32
     57c:	01 c0       	rjmp	.+2      	; 0x580 <.do_clear_bss_start>

0000057e <.do_clear_bss_loop>:
     57e:	1d 92       	st	X+, r1

00000580 <.do_clear_bss_start>:
     580:	a4 34       	cpi	r26, 0x44	; 68
     582:	b2 07       	cpc	r27, r18
     584:	e1 f7       	brne	.-8      	; 0x57e <.do_clear_bss_loop>

00000586 <__do_global_ctors>:
     586:	12 e0       	ldi	r17, 0x02	; 2
     588:	c1 ea       	ldi	r28, 0xA1	; 161
     58a:	d2 e0       	ldi	r29, 0x02	; 2
     58c:	00 e0       	ldi	r16, 0x00	; 0
     58e:	06 c0       	rjmp	.+12     	; 0x59c <__do_global_ctors+0x16>
     590:	21 97       	sbiw	r28, 0x01	; 1
     592:	01 09       	sbc	r16, r1
     594:	80 2f       	mov	r24, r16
     596:	fe 01       	movw	r30, r28
     598:	0e 94 19 1c 	call	0x3832	; 0x3832 <__tablejump2__>
     59c:	c0 3a       	cpi	r28, 0xA0	; 160
     59e:	d1 07       	cpc	r29, r17
     5a0:	80 e0       	ldi	r24, 0x00	; 0
     5a2:	08 07       	cpc	r16, r24
     5a4:	a9 f7       	brne	.-22     	; 0x590 <__do_global_ctors+0xa>
     5a6:	0e 94 31 1b 	call	0x3662	; 0x3662 <main>
     5aa:	0c 94 c8 1c 	jmp	0x3990	; 0x3990 <_exit>

000005ae <__bad_interrupt>:
     5ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005b2 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	cd b7       	in	r28, 0x3d	; 61
     5b8:	de b7       	in	r29, 0x3e	; 62
     5ba:	6d 97       	sbiw	r28, 0x1d	; 29
     5bc:	cd bf       	out	0x3d, r28	; 61
     5be:	de bf       	out	0x3e, r29	; 62
     5c0:	8c 01       	movw	r16, r24
	PORTC.DIRCLR = PIN0_bm | PIN1_bm;										// Set both CHa and CHb for input
     5c2:	e0 e4       	ldi	r30, 0x40	; 64
     5c4:	f6 e0       	ldi	r31, 0x06	; 6
     5c6:	83 e0       	ldi	r24, 0x03	; 3
     5c8:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN0CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5ca:	80 89       	ldd	r24, Z+16	; 0x10
     5cc:	83 60       	ori	r24, 0x03	; 3
     5ce:	80 8b       	std	Z+16, r24	; 0x10
	PORTC.PIN1CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5d0:	81 89       	ldd	r24, Z+17	; 0x11
     5d2:	83 60       	ori	r24, 0x03	; 3
     5d4:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTC_PIN0_gc;								// Configure CHa as a multiplexer input for event channel 0
     5d6:	e0 e8       	ldi	r30, 0x80	; 128
     5d8:	f1 e0       	ldi	r31, 0x01	; 1
     5da:	80 e6       	ldi	r24, 0x60	; 96
     5dc:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5de:	89 e0       	ldi	r24, 0x09	; 9
     5e0:	80 87       	std	Z+8, r24	; 0x08
	
	TCC0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5e2:	e0 e0       	ldi	r30, 0x00	; 0
     5e4:	f8 e0       	ldi	r31, 0x08	; 8
     5e6:	88 e6       	ldi	r24, 0x68	; 104
     5e8:	83 83       	std	Z+3, r24	; 0x03
	TCC0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     5ea:	8f ef       	ldi	r24, 0xFF	; 255
     5ec:	9f ef       	ldi	r25, 0xFF	; 255
     5ee:	86 a3       	std	Z+38, r24	; 0x26
     5f0:	97 a3       	std	Z+39, r25	; 0x27
	TCC0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     5f2:	81 e0       	ldi	r24, 0x01	; 1
     5f4:	80 83       	st	Z, r24
	
	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
     5f6:	40 ea       	ldi	r20, 0xA0	; 160
     5f8:	58 e0       	ldi	r21, 0x08	; 8
     5fa:	60 e0       	ldi	r22, 0x00	; 0
     5fc:	70 e0       	ldi	r23, 0x00	; 0
     5fe:	ce 01       	movw	r24, r28
     600:	01 96       	adiw	r24, 0x01	; 1
     602:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <_ZN5rs232C1EjP12USART_struct>

	while(1){
		encoder_count = TCC0.CNT;											// get count
     606:	40 e0       	ldi	r20, 0x00	; 0
     608:	58 e0       	ldi	r21, 0x08	; 8
     60a:	fa 01       	movw	r30, r20
     60c:	20 a1       	ldd	r18, Z+32	; 0x20
     60e:	31 a1       	ldd	r19, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     610:	0f b6       	in	r0, 0x3f	; 63
     612:	f8 94       	cli
     614:	0f 92       	push	r0
			the_data = new_data;
     616:	c9 01       	movw	r24, r18
     618:	88 0f       	add	r24, r24
     61a:	99 1f       	adc	r25, r25
     61c:	28 0f       	add	r18, r24
     61e:	39 1f       	adc	r19, r25
     620:	36 95       	lsr	r19
     622:	27 95       	ror	r18
     624:	36 95       	lsr	r19
     626:	27 95       	ror	r18
     628:	ab e7       	ldi	r26, 0x7B	; 123
     62a:	b4 e1       	ldi	r27, 0x14	; 20
     62c:	0e 94 22 1c 	call	0x3844	; 0x3844 <__umulhisi3>
     630:	96 95       	lsr	r25
     632:	87 95       	ror	r24
     634:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <linear_position>
     638:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <linear_position+0x1>
			portEXIT_CRITICAL ();
     63c:	0f 90       	pop	r0
     63e:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     640:	f8 01       	movw	r30, r16
     642:	86 85       	ldd	r24, Z+14	; 0x0e
     644:	97 85       	ldd	r25, Z+15	; 0x0f
     646:	a0 89       	ldd	r26, Z+16	; 0x10
     648:	b1 89       	ldd	r27, Z+17	; 0x11
     64a:	01 96       	adiw	r24, 0x01	; 1
     64c:	a1 1d       	adc	r26, r1
     64e:	b1 1d       	adc	r27, r1
     650:	86 87       	std	Z+14, r24	; 0x0e
     652:	97 87       	std	Z+15, r25	; 0x0f
     654:	a0 8b       	std	Z+16, r26	; 0x10
     656:	b1 8b       	std	Z+17, r27	; 0x11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     658:	8f e3       	ldi	r24, 0x3F	; 63
     65a:	9f e1       	ldi	r25, 0x1F	; 31
     65c:	01 97       	sbiw	r24, 0x01	; 1
     65e:	f1 f7       	brne	.-4      	; 0x65c <_ZN12EncoderMotor3runEv+0xaa>
     660:	00 c0       	rjmp	.+0      	; 0x662 <_ZN12EncoderMotor3runEv+0xb0>
     662:	00 00       	nop
     664:	d2 cf       	rjmp	.-92     	; 0x60a <_ZN12EncoderMotor3runEv+0x58>

00000666 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "UserInterface.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
*/


EncoderMotor::EncoderMotor(const char* a_name,
     666:	0f 93       	push	r16
     668:	1f 93       	push	r17
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
     66e:	ec 01       	movw	r28, r24
							unsigned portBASE_TYPE a_priority,
							size_t a_stack_size,
							emstream* p_ser_dev
							)
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     670:	0e 94 9d 10 	call	0x213a	; 0x213a <_ZN8frt_taskC1EPKchjP8emstream>
     674:	8a e0       	ldi	r24, 0x0A	; 10
     676:	90 e2       	ldi	r25, 0x20	; 32
     678:	88 83       	st	Y, r24
     67a:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     67c:	df 91       	pop	r29
     67e:	cf 91       	pop	r28
     680:	1f 91       	pop	r17
     682:	0f 91       	pop	r16
     684:	08 95       	ret

00000686 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     686:	0f 93       	push	r16
     688:	1f 93       	push	r17
     68a:	cf 93       	push	r28
     68c:	df 93       	push	r29
     68e:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     690:	0e 94 9d 10 	call	0x213a	; 0x213a <_ZN8frt_taskC1EPKchjP8emstream>
     694:	82 e1       	ldi	r24, 0x12	; 18
     696:	90 e2       	ldi	r25, 0x20	; 32
     698:	88 83       	st	Y, r24
     69a:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	1f 91       	pop	r17
     6a2:	0f 91       	pop	r16
     6a4:	08 95       	ret

000006a6 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     6a6:	0f 93       	push	r16
     6a8:	1f 93       	push	r17
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     6b0:	6a e0       	ldi	r22, 0x0A	; 10
     6b2:	8e 81       	ldd	r24, Y+6	; 0x06
     6b4:	9f 81       	ldd	r25, Y+7	; 0x07
     6b6:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     6ba:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     6bc:	6d ed       	ldi	r22, 0xDD	; 221
     6be:	73 e0       	ldi	r23, 0x03	; 3
     6c0:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     6c4:	6a e0       	ldi	r22, 0x0A	; 10
     6c6:	c8 01       	movw	r24, r16
     6c8:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     6cc:	8c 01       	movw	r16, r24
     6ce:	67 ed       	ldi	r22, 0xD7	; 215
     6d0:	73 e0       	ldi	r23, 0x03	; 3
     6d2:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     6d6:	67 e0       	ldi	r22, 0x07	; 7
     6d8:	c8 01       	movw	r24, r16
     6da:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     6de:	6a e0       	ldi	r22, 0x0A	; 10
     6e0:	8e 81       	ldd	r24, Y+6	; 0x06
     6e2:	9f 81       	ldd	r25, Y+7	; 0x07
     6e4:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     6e8:	8c 01       	movw	r16, r24
     6ea:	68 eb       	ldi	r22, 0xB8	; 184
     6ec:	73 e0       	ldi	r23, 0x03	; 3
     6ee:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     6f2:	6a e0       	ldi	r22, 0x0A	; 10
     6f4:	c8 01       	movw	r24, r16
     6f6:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     6fa:	8c 01       	movw	r16, r24
     6fc:	62 eb       	ldi	r22, 0xB2	; 178
     6fe:	73 e0       	ldi	r23, 0x03	; 3
     700:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     704:	66 e0       	ldi	r22, 0x06	; 6
     706:	c8 01       	movw	r24, r16
     708:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     70c:	6a e0       	ldi	r22, 0x0A	; 10
     70e:	8e 81       	ldd	r24, Y+6	; 0x06
     710:	9f 81       	ldd	r25, Y+7	; 0x07
     712:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     716:	8c 01       	movw	r16, r24
     718:	6b e9       	ldi	r22, 0x9B	; 155
     71a:	73 e0       	ldi	r23, 0x03	; 3
     71c:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     720:	66 e0       	ldi	r22, 0x06	; 6
     722:	c8 01       	movw	r24, r16
     724:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     728:	6a e0       	ldi	r22, 0x0A	; 10
     72a:	8e 81       	ldd	r24, Y+6	; 0x06
     72c:	9f 81       	ldd	r25, Y+7	; 0x07
     72e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     732:	8c 01       	movw	r16, r24
     734:	6f e7       	ldi	r22, 0x7F	; 127
     736:	73 e0       	ldi	r23, 0x03	; 3
     738:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     73c:	66 e0       	ldi	r22, 0x06	; 6
     73e:	c8 01       	movw	r24, r16
     740:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     744:	6a e0       	ldi	r22, 0x0A	; 10
     746:	8e 81       	ldd	r24, Y+6	; 0x06
     748:	9f 81       	ldd	r25, Y+7	; 0x07
     74a:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     74e:	8c 01       	movw	r16, r24
     750:	67 e6       	ldi	r22, 0x67	; 103
     752:	73 e0       	ldi	r23, 0x03	; 3
     754:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     758:	66 e0       	ldi	r22, 0x06	; 6
     75a:	c8 01       	movw	r24, r16
     75c:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     760:	6a e0       	ldi	r22, 0x0A	; 10
     762:	8e 81       	ldd	r24, Y+6	; 0x06
     764:	9f 81       	ldd	r25, Y+7	; 0x07
     766:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     76a:	8c 01       	movw	r16, r24
     76c:	66 e4       	ldi	r22, 0x46	; 70
     76e:	73 e0       	ldi	r23, 0x03	; 3
     770:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     774:	66 e0       	ldi	r22, 0x06	; 6
     776:	c8 01       	movw	r24, r16
     778:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     77c:	6a e0       	ldi	r22, 0x0A	; 10
     77e:	8e 81       	ldd	r24, Y+6	; 0x06
     780:	9f 81       	ldd	r25, Y+7	; 0x07
     782:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     786:	8c 01       	movw	r16, r24
     788:	6f e1       	ldi	r22, 0x1F	; 31
     78a:	73 e0       	ldi	r23, 0x03	; 3
     78c:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     790:	66 e0       	ldi	r22, 0x06	; 6
     792:	c8 01       	movw	r24, r16
     794:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     798:	6a e0       	ldi	r22, 0x0A	; 10
     79a:	8e 81       	ldd	r24, Y+6	; 0x06
     79c:	9f 81       	ldd	r25, Y+7	; 0x07
     79e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     7a2:	8c 01       	movw	r16, r24
     7a4:	61 e0       	ldi	r22, 0x01	; 1
     7a6:	73 e0       	ldi	r23, 0x03	; 3
     7a8:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     7ac:	66 e0       	ldi	r22, 0x06	; 6
     7ae:	c8 01       	movw	r24, r16
     7b0:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     7b4:	6a e0       	ldi	r22, 0x0A	; 10
     7b6:	8e 81       	ldd	r24, Y+6	; 0x06
     7b8:	9f 81       	ldd	r25, Y+7	; 0x07
     7ba:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     7be:	8c 01       	movw	r16, r24
     7c0:	66 ee       	ldi	r22, 0xE6	; 230
     7c2:	72 e0       	ldi	r23, 0x02	; 2
     7c4:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     7c8:	66 e0       	ldi	r22, 0x06	; 6
     7ca:	c8 01       	movw	r24, r16
     7cc:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     7d0:	6a e0       	ldi	r22, 0x0A	; 10
     7d2:	8e 81       	ldd	r24, Y+6	; 0x06
     7d4:	9f 81       	ldd	r25, Y+7	; 0x07
     7d6:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     7da:	ec 01       	movw	r28, r24
     7dc:	67 ed       	ldi	r22, 0xD7	; 215
     7de:	72 e0       	ldi	r23, 0x02	; 2
     7e0:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     7e4:	66 e0       	ldi	r22, 0x06	; 6
     7e6:	ce 01       	movw	r24, r28
     7e8:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
}
     7ec:	df 91       	pop	r29
     7ee:	cf 91       	pop	r28
     7f0:	1f 91       	pop	r17
     7f2:	0f 91       	pop	r16
     7f4:	08 95       	ret

000007f6 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     7f6:	af 92       	push	r10
     7f8:	bf 92       	push	r11
     7fa:	cf 92       	push	r12
     7fc:	df 92       	push	r13
     7fe:	ef 92       	push	r14
     800:	ff 92       	push	r15
     802:	0f 93       	push	r16
     804:	1f 93       	push	r17
     806:	cf 93       	push	r28
     808:	df 93       	push	r29
     80a:	00 d0       	rcall	.+0      	; 0x80c <_ZN9task_user11show_statusEv+0x16>
     80c:	00 d0       	rcall	.+0      	; 0x80e <_ZN9task_user11show_statusEv+0x18>
     80e:	cd b7       	in	r28, 0x3d	; 61
     810:	de b7       	in	r29, 0x3e	; 62
     812:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     814:	19 82       	std	Y+1, r1	; 0x01
     816:	1a 82       	std	Y+2, r1	; 0x02
     818:	1b 82       	std	Y+3, r1	; 0x03
     81a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     81c:	1d 82       	std	Y+5, r1	; 0x05
     81e:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     820:	0e 94 80 06 	call	0xd00	; 0xd00 <xPortGetFreeHeapSize>
     824:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     826:	ce 01       	movw	r24, r28
     828:	01 96       	adiw	r24, 0x01	; 1
     82a:	0e 94 4e 14 	call	0x289c	; 0x289c <_ZN10time_stamp10set_to_nowEv>
     82e:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     830:	66 e0       	ldi	r22, 0x06	; 6
     832:	f8 01       	movw	r30, r16
     834:	86 81       	ldd	r24, Z+6	; 0x06
     836:	97 81       	ldd	r25, Z+7	; 0x07
     838:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     83c:	6a e0       	ldi	r22, 0x0A	; 10
     83e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     842:	7c 01       	movw	r14, r24
     844:	68 eb       	ldi	r22, 0xB8	; 184
     846:	72 e0       	ldi	r23, 0x02	; 2
     848:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     84c:	6a e0       	ldi	r22, 0x0A	; 10
     84e:	c7 01       	movw	r24, r14
     850:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     854:	7c 01       	movw	r14, r24
     856:	6c ea       	ldi	r22, 0xAC	; 172
     858:	72 e0       	ldi	r23, 0x02	; 2
     85a:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     85e:	66 e0       	ldi	r22, 0x06	; 6
     860:	c7 01       	movw	r24, r14
     862:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     866:	6a e0       	ldi	r22, 0x0A	; 10
     868:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     86c:	7c 01       	movw	r14, r24
     86e:	65 ea       	ldi	r22, 0xA5	; 165
     870:	72 e0       	ldi	r23, 0x02	; 2
     872:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     876:	b5 01       	movw	r22, r10
     878:	c7 01       	movw	r24, r14
     87a:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     87e:	6a e0       	ldi	r22, 0x0A	; 10
     880:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     884:	7c 01       	movw	r14, r24
     886:	67 e9       	ldi	r22, 0x97	; 151
     888:	72 e0       	ldi	r23, 0x02	; 2
     88a:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     88e:	b6 01       	movw	r22, r12
     890:	c7 01       	movw	r24, r14
     892:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZN8emstreamlsEj>
     896:	6a e0       	ldi	r22, 0x0A	; 10
     898:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     89c:	7c 01       	movw	r14, r24
     89e:	65 e9       	ldi	r22, 0x95	; 149
     8a0:	72 e0       	ldi	r23, 0x02	; 2
     8a2:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     8a6:	4f ef       	ldi	r20, 0xFF	; 255
     8a8:	5f e0       	ldi	r21, 0x0F	; 15
     8aa:	60 e0       	ldi	r22, 0x00	; 0
     8ac:	70 e0       	ldi	r23, 0x00	; 0
     8ae:	c7 01       	movw	r24, r14
     8b0:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     8b4:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     8b8:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     8bc:	6a e0       	ldi	r22, 0x0A	; 10
     8be:	f8 01       	movw	r30, r16
     8c0:	86 81       	ldd	r24, Z+6	; 0x06
     8c2:	97 81       	ldd	r25, Z+7	; 0x07
     8c4:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     8c8:	7c 01       	movw	r14, r24
     8ca:	6a e8       	ldi	r22, 0x8A	; 138
     8cc:	72 e0       	ldi	r23, 0x02	; 2
     8ce:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     8d2:	b6 01       	movw	r22, r12
     8d4:	c7 01       	movw	r24, r14
     8d6:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZN8emstreamlsEj>
     8da:	66 e0       	ldi	r22, 0x06	; 6
     8dc:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     8e0:	66 e0       	ldi	r22, 0x06	; 6
     8e2:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     8e6:	f8 01       	movw	r30, r16
     8e8:	86 81       	ldd	r24, Z+6	; 0x06
     8ea:	97 81       	ldd	r25, Z+7	; 0x07
     8ec:	0e 94 ab 12 	call	0x2556	; 0x2556 <_Z15print_task_listP8emstream>
}
     8f0:	26 96       	adiw	r28, 0x06	; 6
     8f2:	cd bf       	out	0x3d, r28	; 61
     8f4:	de bf       	out	0x3e, r29	; 62
     8f6:	df 91       	pop	r29
     8f8:	cf 91       	pop	r28
     8fa:	1f 91       	pop	r17
     8fc:	0f 91       	pop	r16
     8fe:	ff 90       	pop	r15
     900:	ef 90       	pop	r14
     902:	df 90       	pop	r13
     904:	cf 90       	pop	r12
     906:	bf 90       	pop	r11
     908:	af 90       	pop	r10
     90a:	08 95       	ret

0000090c <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     90c:	cf 93       	push	r28
     90e:	df 93       	push	r29
     910:	00 d0       	rcall	.+0      	; 0x912 <_ZN9task_user3runEv+0x6>
     912:	00 d0       	rcall	.+0      	; 0x914 <_ZN9task_user3runEv+0x8>
     914:	cd b7       	in	r28, 0x3d	; 61
     916:	de b7       	in	r29, 0x3e	; 62
     918:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     91a:	19 82       	std	Y+1, r1	; 0x01
     91c:	1a 82       	std	Y+2, r1	; 0x02
     91e:	1b 82       	std	Y+3, r1	; 0x03
     920:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     922:	1d 82       	std	Y+5, r1	; 0x05
     924:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     926:	6a e0       	ldi	r22, 0x0A	; 10
     928:	dc 01       	movw	r26, r24
     92a:	16 96       	adiw	r26, 0x06	; 6
     92c:	8d 91       	ld	r24, X+
     92e:	9c 91       	ld	r25, X
     930:	17 97       	sbiw	r26, 0x07	; 7
     932:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     936:	7c 01       	movw	r14, r24
     938:	66 e2       	ldi	r22, 0x26	; 38
     93a:	74 e0       	ldi	r23, 0x04	; 4
     93c:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     940:	66 e0       	ldi	r22, 0x06	; 6
     942:	c7 01       	movw	r24, r14
     944:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     948:	f8 01       	movw	r30, r16
     94a:	84 85       	ldd	r24, Z+12	; 0x0c
     94c:	88 23       	and	r24, r24
     94e:	21 f0       	breq	.+8      	; 0x958 <_ZN9task_user3runEv+0x4c>
     950:	81 30       	cpi	r24, 0x01	; 1
     952:	09 f4       	brne	.+2      	; 0x956 <_ZN9task_user3runEv+0x4a>
     954:	5d c0       	rjmp	.+186    	; 0xa10 <_ZN9task_user3runEv+0x104>
     956:	d8 c0       	rjmp	.+432    	; 0xb08 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     958:	86 81       	ldd	r24, Z+6	; 0x06
     95a:	97 81       	ldd	r25, Z+7	; 0x07
     95c:	dc 01       	movw	r26, r24
     95e:	ed 91       	ld	r30, X+
     960:	fc 91       	ld	r31, X
     962:	04 80       	ldd	r0, Z+4	; 0x04
     964:	f5 81       	ldd	r31, Z+5	; 0x05
     966:	e0 2d       	mov	r30, r0
     968:	19 95       	eicall
     96a:	88 23       	and	r24, r24
     96c:	a9 f1       	breq	.+106    	; 0x9d8 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     96e:	f8 01       	movw	r30, r16
     970:	86 81       	ldd	r24, Z+6	; 0x06
     972:	97 81       	ldd	r25, Z+7	; 0x07
     974:	dc 01       	movw	r26, r24
     976:	ed 91       	ld	r30, X+
     978:	fc 91       	ld	r31, X
     97a:	06 80       	ldd	r0, Z+6	; 0x06
     97c:	f7 81       	ldd	r31, Z+7	; 0x07
     97e:	e0 2d       	mov	r30, r0
     980:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     982:	99 27       	eor	r25, r25
     984:	81 30       	cpi	r24, 0x01	; 1
     986:	91 05       	cpc	r25, r1
     988:	f9 f0       	breq	.+62     	; 0x9c8 <_ZN9task_user3runEv+0xbc>
     98a:	03 97       	sbiw	r24, 0x03	; 3
     98c:	09 f0       	breq	.+2      	; 0x990 <_ZN9task_user3runEv+0x84>
     98e:	d8 c0       	rjmp	.+432    	; 0xb40 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     990:	6a e0       	ldi	r22, 0x0A	; 10
     992:	f8 01       	movw	r30, r16
     994:	86 81       	ldd	r24, Z+6	; 0x06
     996:	97 81       	ldd	r25, Z+7	; 0x07
     998:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     99c:	8c 01       	movw	r16, r24
     99e:	68 e1       	ldi	r22, 0x18	; 24
     9a0:	74 e0       	ldi	r23, 0x04	; 4
     9a2:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     9a6:	66 e0       	ldi	r22, 0x06	; 6
     9a8:	c8 01       	movw	r24, r16
     9aa:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     9ae:	93 e0       	ldi	r25, 0x03	; 3
     9b0:	88 ed       	ldi	r24, 0xD8	; 216
     9b2:	08 b6       	in	r0, 0x38	; 56
     9b4:	18 be       	out	0x38, r1	; 56
     9b6:	84 bf       	out	0x34, r24	; 52
     9b8:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     9bc:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     9c0:	81 fd       	sbrc	r24, 1
     9c2:	fc cf       	rjmp	.-8      	; 0x9bc <_ZN9task_user3runEv+0xb0>
     9c4:	08 be       	out	0x38, r0	; 56
     9c6:	ff cf       	rjmp	.-2      	; 0x9c6 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     9c8:	c8 01       	movw	r24, r16
     9ca:	0e 94 53 03 	call	0x6a6	; 0x6a6 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     9ce:	61 e0       	ldi	r22, 0x01	; 1
     9d0:	c8 01       	movw	r24, r16
     9d2:	0e 94 99 10 	call	0x2132	; 0x2132 <_ZN8frt_task13transition_toEh>
							break;
     9d6:	b4 c0       	rjmp	.+360    	; 0xb40 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     9d8:	82 e3       	ldi	r24, 0x32	; 50
     9da:	91 e3       	ldi	r25, 0x31	; 49
     9dc:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <_ZN14frt_text_queue14check_for_charEv>
     9e0:	88 23       	and	r24, r24
     9e2:	09 f4       	brne	.+2      	; 0x9e6 <_ZN9task_user3runEv+0xda>
     9e4:	ad c0       	rjmp	.+346    	; 0xb40 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     9e6:	d8 01       	movw	r26, r16
     9e8:	16 96       	adiw	r26, 0x06	; 6
     9ea:	ed 91       	ld	r30, X+
     9ec:	fc 91       	ld	r31, X
     9ee:	17 97       	sbiw	r26, 0x07	; 7
     9f0:	01 90       	ld	r0, Z+
     9f2:	f0 81       	ld	r31, Z
     9f4:	e0 2d       	mov	r30, r0
     9f6:	e2 80       	ldd	r14, Z+2	; 0x02
     9f8:	f3 80       	ldd	r15, Z+3	; 0x03
     9fa:	82 e3       	ldi	r24, 0x32	; 50
     9fc:	91 e3       	ldi	r25, 0x31	; 49
     9fe:	0e 94 3c 13 	call	0x2678	; 0x2678 <_ZN14frt_text_queue7getcharEv>
     a02:	68 2f       	mov	r22, r24
     a04:	f8 01       	movw	r30, r16
     a06:	86 81       	ldd	r24, Z+6	; 0x06
     a08:	97 81       	ldd	r25, Z+7	; 0x07
     a0a:	f7 01       	movw	r30, r14
     a0c:	19 95       	eicall
     a0e:	98 c0       	rjmp	.+304    	; 0xb40 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     a10:	86 81       	ldd	r24, Z+6	; 0x06
     a12:	97 81       	ldd	r25, Z+7	; 0x07
     a14:	dc 01       	movw	r26, r24
     a16:	ed 91       	ld	r30, X+
     a18:	fc 91       	ld	r31, X
     a1a:	04 80       	ldd	r0, Z+4	; 0x04
     a1c:	f5 81       	ldd	r31, Z+5	; 0x05
     a1e:	e0 2d       	mov	r30, r0
     a20:	19 95       	eicall
     a22:	88 23       	and	r24, r24
     a24:	09 f4       	brne	.+2      	; 0xa28 <_ZN9task_user3runEv+0x11c>
     a26:	8c c0       	rjmp	.+280    	; 0xb40 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     a28:	f8 01       	movw	r30, r16
     a2a:	86 81       	ldd	r24, Z+6	; 0x06
     a2c:	97 81       	ldd	r25, Z+7	; 0x07
     a2e:	dc 01       	movw	r26, r24
     a30:	ed 91       	ld	r30, X+
     a32:	fc 91       	ld	r31, X
     a34:	06 80       	ldd	r0, Z+6	; 0x06
     a36:	f7 81       	ldd	r31, Z+7	; 0x07
     a38:	e0 2d       	mov	r30, r0
     a3a:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     a3c:	9c 01       	movw	r18, r24
     a3e:	33 27       	eor	r19, r19
     a40:	28 36       	cpi	r18, 0x68	; 104
     a42:	31 05       	cpc	r19, r1
     a44:	59 f1       	breq	.+86     	; 0xa9c <_ZN9task_user3runEv+0x190>
     a46:	3c f4       	brge	.+14     	; 0xa56 <_ZN9task_user3runEv+0x14a>
     a48:	2b 31       	cpi	r18, 0x1B	; 27
     a4a:	31 05       	cpc	r19, r1
     a4c:	59 f1       	breq	.+86     	; 0xaa4 <_ZN9task_user3runEv+0x198>
     a4e:	25 36       	cpi	r18, 0x65	; 101
     a50:	31 05       	cpc	r19, r1
     a52:	41 f1       	breq	.+80     	; 0xaa4 <_ZN9task_user3runEv+0x198>
     a54:	3b c0       	rjmp	.+118    	; 0xacc <_ZN9task_user3runEv+0x1c0>
     a56:	23 37       	cpi	r18, 0x73	; 115
     a58:	31 05       	cpc	r19, r1
     a5a:	c1 f0       	breq	.+48     	; 0xa8c <_ZN9task_user3runEv+0x180>
     a5c:	26 37       	cpi	r18, 0x76	; 118
     a5e:	31 05       	cpc	r19, r1
     a60:	89 f0       	breq	.+34     	; 0xa84 <_ZN9task_user3runEv+0x178>
     a62:	2e 36       	cpi	r18, 0x6E	; 110
     a64:	31 05       	cpc	r19, r1
     a66:	91 f5       	brne	.+100    	; 0xacc <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     a68:	ce 01       	movw	r24, r28
     a6a:	01 96       	adiw	r24, 0x01	; 1
     a6c:	0e 94 4e 14 	call	0x289c	; 0x289c <_ZN10time_stamp10set_to_nowEv>
     a70:	bc 01       	movw	r22, r24
     a72:	f8 01       	movw	r30, r16
     a74:	86 81       	ldd	r24, Z+6	; 0x06
     a76:	97 81       	ldd	r25, Z+7	; 0x07
     a78:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <_ZlsR8emstreamR10time_stamp>
     a7c:	66 e0       	ldi	r22, 0x06	; 6
     a7e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
							break;
     a82:	5e c0       	rjmp	.+188    	; 0xb40 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     a84:	c8 01       	movw	r24, r16
     a86:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <_ZN9task_user11show_statusEv>
							break;
     a8a:	5a c0       	rjmp	.+180    	; 0xb40 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     a8c:	d8 01       	movw	r26, r16
     a8e:	16 96       	adiw	r26, 0x06	; 6
     a90:	8d 91       	ld	r24, X+
     a92:	9c 91       	ld	r25, X
     a94:	17 97       	sbiw	r26, 0x07	; 7
     a96:	0e 94 b2 11 	call	0x2364	; 0x2364 <_Z17print_task_stacksP8emstream>
							break;
     a9a:	52 c0       	rjmp	.+164    	; 0xb40 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     a9c:	c8 01       	movw	r24, r16
     a9e:	0e 94 53 03 	call	0x6a6	; 0x6a6 <_ZN9task_user18print_help_messageEv>
							break;
     aa2:	4e c0       	rjmp	.+156    	; 0xb40 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     aa4:	6a e0       	ldi	r22, 0x0A	; 10
     aa6:	f8 01       	movw	r30, r16
     aa8:	86 81       	ldd	r24, Z+6	; 0x06
     aaa:	97 81       	ldd	r25, Z+7	; 0x07
     aac:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     ab0:	7c 01       	movw	r14, r24
     ab2:	66 e0       	ldi	r22, 0x06	; 6
     ab4:	74 e0       	ldi	r23, 0x04	; 4
     ab6:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     aba:	66 e0       	ldi	r22, 0x06	; 6
     abc:	c7 01       	movw	r24, r14
     abe:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     ac2:	60 e0       	ldi	r22, 0x00	; 0
     ac4:	c8 01       	movw	r24, r16
     ac6:	0e 94 99 10 	call	0x2132	; 0x2132 <_ZN8frt_task13transition_toEh>
							break;
     aca:	3a c0       	rjmp	.+116    	; 0xb40 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     acc:	f8 01       	movw	r30, r16
     ace:	a6 81       	ldd	r26, Z+6	; 0x06
     ad0:	b7 81       	ldd	r27, Z+7	; 0x07
     ad2:	ed 91       	ld	r30, X+
     ad4:	fc 91       	ld	r31, X
     ad6:	11 97       	sbiw	r26, 0x01	; 1
     ad8:	02 80       	ldd	r0, Z+2	; 0x02
     ada:	f3 81       	ldd	r31, Z+3	; 0x03
     adc:	e0 2d       	mov	r30, r0
     ade:	68 2f       	mov	r22, r24
     ae0:	cd 01       	movw	r24, r26
     ae2:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     ae4:	6a e0       	ldi	r22, 0x0A	; 10
     ae6:	d8 01       	movw	r26, r16
     ae8:	16 96       	adiw	r26, 0x06	; 6
     aea:	8d 91       	ld	r24, X+
     aec:	9c 91       	ld	r25, X
     aee:	17 97       	sbiw	r26, 0x07	; 7
     af0:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     af4:	7c 01       	movw	r14, r24
     af6:	60 e0       	ldi	r22, 0x00	; 0
     af8:	74 e0       	ldi	r23, 0x04	; 4
     afa:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     afe:	66 e0       	ldi	r22, 0x06	; 6
     b00:	c7 01       	movw	r24, r14
     b02:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
							break;
     b06:	1c c0       	rjmp	.+56     	; 0xb40 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     b08:	6a e0       	ldi	r22, 0x0A	; 10
     b0a:	f8 01       	movw	r30, r16
     b0c:	86 81       	ldd	r24, Z+6	; 0x06
     b0e:	97 81       	ldd	r25, Z+7	; 0x07
     b10:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
     b14:	8c 01       	movw	r16, r24
     b16:	63 ee       	ldi	r22, 0xE3	; 227
     b18:	73 e0       	ldi	r23, 0x03	; 3
     b1a:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
     b1e:	66 e0       	ldi	r22, 0x06	; 6
     b20:	c8 01       	movw	r24, r16
     b22:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     b26:	93 e0       	ldi	r25, 0x03	; 3
     b28:	88 ed       	ldi	r24, 0xD8	; 216
     b2a:	08 b6       	in	r0, 0x38	; 56
     b2c:	18 be       	out	0x38, r1	; 56
     b2e:	84 bf       	out	0x34, r24	; 52
     b30:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     b34:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     b38:	81 fd       	sbrc	r24, 1
     b3a:	fc cf       	rjmp	.-8      	; 0xb34 <_ZN9task_user3runEv+0x228>
     b3c:	08 be       	out	0x38, r0	; 56
     b3e:	ff cf       	rjmp	.-2      	; 0xb3e <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     b40:	f8 01       	movw	r30, r16
     b42:	86 85       	ldd	r24, Z+14	; 0x0e
     b44:	97 85       	ldd	r25, Z+15	; 0x0f
     b46:	a0 89       	ldd	r26, Z+16	; 0x10
     b48:	b1 89       	ldd	r27, Z+17	; 0x11
     b4a:	01 96       	adiw	r24, 0x01	; 1
     b4c:	a1 1d       	adc	r26, r1
     b4e:	b1 1d       	adc	r27, r1
     b50:	86 87       	std	Z+14, r24	; 0x0e
     b52:	97 87       	std	Z+15, r25	; 0x0f
     b54:	a0 8b       	std	Z+16, r26	; 0x10
     b56:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     b58:	61 e0       	ldi	r22, 0x01	; 1
     b5a:	70 e0       	ldi	r23, 0x00	; 0
     b5c:	80 e0       	ldi	r24, 0x00	; 0
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     b64:	f1 ce       	rjmp	.-542    	; 0x948 <_ZN9task_user3runEv+0x3c>

00000b66 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     b66:	0f 93       	push	r16
     b68:	1f 93       	push	r17
     b6a:	cf 93       	push	r28
     b6c:	df 93       	push	r29
     b6e:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     b70:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     b74:	80 91 9a 20 	lds	r24, 0x209A	; 0x80209a <__data_end>
     b78:	81 11       	cpse	r24, r1
     b7a:	1d c0       	rjmp	.+58     	; 0xbb6 <pvPortMalloc+0x50>
		{
			prvHeapInit();
     b7c:	af e9       	ldi	r26, 0x9F	; 159
     b7e:	b0 e2       	ldi	r27, 0x20	; 32
     b80:	e3 ea       	ldi	r30, 0xA3	; 163
     b82:	f0 e2       	ldi	r31, 0x20	; 32
     b84:	ed 93       	st	X+, r30
     b86:	fc 93       	st	X, r31
     b88:	11 97       	sbiw	r26, 0x01	; 1
     b8a:	12 96       	adiw	r26, 0x02	; 2
     b8c:	1d 92       	st	X+, r1
     b8e:	1c 92       	st	X, r1
     b90:	13 97       	sbiw	r26, 0x03	; 3
     b92:	ab e9       	ldi	r26, 0x9B	; 155
     b94:	b0 e2       	ldi	r27, 0x20	; 32
     b96:	8f ef       	ldi	r24, 0xFF	; 255
     b98:	9f e0       	ldi	r25, 0x0F	; 15
     b9a:	12 96       	adiw	r26, 0x02	; 2
     b9c:	8d 93       	st	X+, r24
     b9e:	9c 93       	st	X, r25
     ba0:	13 97       	sbiw	r26, 0x03	; 3
     ba2:	1d 92       	st	X+, r1
     ba4:	1c 92       	st	X, r1
     ba6:	11 97       	sbiw	r26, 0x01	; 1
     ba8:	82 83       	std	Z+2, r24	; 0x02
     baa:	93 83       	std	Z+3, r25	; 0x03
     bac:	a0 83       	st	Z, r26
     bae:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     bb0:	81 e0       	ldi	r24, 0x01	; 1
     bb2:	80 93 9a 20 	sts	0x209A, r24	; 0x80209a <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     bb6:	20 97       	sbiw	r28, 0x00	; 0
     bb8:	09 f4       	brne	.+2      	; 0xbbc <pvPortMalloc+0x56>
     bba:	5f c0       	rjmp	.+190    	; 0xc7a <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     bbc:	9e 01       	movw	r18, r28
     bbe:	2b 5f       	subi	r18, 0xFB	; 251
     bc0:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     bc2:	24 96       	adiw	r28, 0x04	; 4
     bc4:	ce 3f       	cpi	r28, 0xFE	; 254
     bc6:	df 40       	sbci	r29, 0x0F	; 15
     bc8:	08 f0       	brcs	.+2      	; 0xbcc <pvPortMalloc+0x66>
     bca:	5a c0       	rjmp	.+180    	; 0xc80 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     bcc:	e0 91 9f 20 	lds	r30, 0x209F	; 0x80209f <xStart>
     bd0:	f0 91 a0 20 	lds	r31, 0x20A0	; 0x8020a0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     bd4:	af e9       	ldi	r26, 0x9F	; 159
     bd6:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     bd8:	02 c0       	rjmp	.+4      	; 0xbde <pvPortMalloc+0x78>
     bda:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     bdc:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     bde:	82 81       	ldd	r24, Z+2	; 0x02
     be0:	93 81       	ldd	r25, Z+3	; 0x03
     be2:	82 17       	cp	r24, r18
     be4:	93 07       	cpc	r25, r19
     be6:	20 f4       	brcc	.+8      	; 0xbf0 <pvPortMalloc+0x8a>
     be8:	80 81       	ld	r24, Z
     bea:	91 81       	ldd	r25, Z+1	; 0x01
     bec:	00 97       	sbiw	r24, 0x00	; 0
     bee:	a9 f7       	brne	.-22     	; 0xbda <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     bf0:	c0 e2       	ldi	r28, 0x20	; 32
     bf2:	eb 39       	cpi	r30, 0x9B	; 155
     bf4:	fc 07       	cpc	r31, r28
     bf6:	09 f4       	brne	.+2      	; 0xbfa <pvPortMalloc+0x94>
     bf8:	46 c0       	rjmp	.+140    	; 0xc86 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     bfa:	cd 91       	ld	r28, X+
     bfc:	dc 91       	ld	r29, X
     bfe:	11 97       	sbiw	r26, 0x01	; 1
     c00:	8e 01       	movw	r16, r28
     c02:	0b 5f       	subi	r16, 0xFB	; 251
     c04:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     c06:	80 81       	ld	r24, Z
     c08:	91 81       	ldd	r25, Z+1	; 0x01
     c0a:	8d 93       	st	X+, r24
     c0c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     c0e:	82 81       	ldd	r24, Z+2	; 0x02
     c10:	93 81       	ldd	r25, Z+3	; 0x03
     c12:	82 1b       	sub	r24, r18
     c14:	93 0b       	sbc	r25, r19
     c16:	8b 30       	cpi	r24, 0x0B	; 11
     c18:	91 05       	cpc	r25, r1
     c1a:	10 f1       	brcs	.+68     	; 0xc60 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     c1c:	bf 01       	movw	r22, r30
     c1e:	62 0f       	add	r22, r18
     c20:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     c22:	db 01       	movw	r26, r22
     c24:	12 96       	adiw	r26, 0x02	; 2
     c26:	8d 93       	st	X+, r24
     c28:	9c 93       	st	X, r25
     c2a:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     c2c:	22 83       	std	Z+2, r18	; 0x02
     c2e:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     c30:	12 96       	adiw	r26, 0x02	; 2
     c32:	4d 91       	ld	r20, X+
     c34:	5c 91       	ld	r21, X
     c36:	13 97       	sbiw	r26, 0x03	; 3
     c38:	8f e9       	ldi	r24, 0x9F	; 159
     c3a:	90 e2       	ldi	r25, 0x20	; 32
     c3c:	01 c0       	rjmp	.+2      	; 0xc40 <pvPortMalloc+0xda>
     c3e:	cd 01       	movw	r24, r26
     c40:	ec 01       	movw	r28, r24
     c42:	a8 81       	ld	r26, Y
     c44:	b9 81       	ldd	r27, Y+1	; 0x01
     c46:	12 96       	adiw	r26, 0x02	; 2
     c48:	2d 91       	ld	r18, X+
     c4a:	3c 91       	ld	r19, X
     c4c:	13 97       	sbiw	r26, 0x03	; 3
     c4e:	24 17       	cp	r18, r20
     c50:	35 07       	cpc	r19, r21
     c52:	a8 f3       	brcs	.-22     	; 0xc3e <pvPortMalloc+0xd8>
     c54:	eb 01       	movw	r28, r22
     c56:	a8 83       	st	Y, r26
     c58:	b9 83       	std	Y+1, r27	; 0x01
     c5a:	dc 01       	movw	r26, r24
     c5c:	6d 93       	st	X+, r22
     c5e:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     c60:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     c64:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     c68:	22 81       	ldd	r18, Z+2	; 0x02
     c6a:	33 81       	ldd	r19, Z+3	; 0x03
     c6c:	82 1b       	sub	r24, r18
     c6e:	93 0b       	sbc	r25, r19
     c70:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     c74:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     c78:	08 c0       	rjmp	.+16     	; 0xc8a <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     c7a:	00 e0       	ldi	r16, 0x00	; 0
     c7c:	10 e0       	ldi	r17, 0x00	; 0
     c7e:	05 c0       	rjmp	.+10     	; 0xc8a <pvPortMalloc+0x124>
     c80:	00 e0       	ldi	r16, 0x00	; 0
     c82:	10 e0       	ldi	r17, 0x00	; 0
     c84:	02 c0       	rjmp	.+4      	; 0xc8a <pvPortMalloc+0x124>
     c86:	00 e0       	ldi	r16, 0x00	; 0
     c88:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     c8a:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c8e:	c8 01       	movw	r24, r16
     c90:	df 91       	pop	r29
     c92:	cf 91       	pop	r28
     c94:	1f 91       	pop	r17
     c96:	0f 91       	pop	r16
     c98:	08 95       	ret

00000c9a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c9a:	0f 93       	push	r16
     c9c:	1f 93       	push	r17
     c9e:	cf 93       	push	r28
     ca0:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     ca2:	00 97       	sbiw	r24, 0x00	; 0
     ca4:	41 f1       	breq	.+80     	; 0xcf6 <vPortFree+0x5c>
     ca6:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     ca8:	8c 01       	movw	r16, r24
     caa:	05 50       	subi	r16, 0x05	; 5
     cac:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     cae:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     cb2:	f8 01       	movw	r30, r16
     cb4:	42 81       	ldd	r20, Z+2	; 0x02
     cb6:	53 81       	ldd	r21, Z+3	; 0x03
     cb8:	af e9       	ldi	r26, 0x9F	; 159
     cba:	b0 e2       	ldi	r27, 0x20	; 32
     cbc:	01 c0       	rjmp	.+2      	; 0xcc0 <vPortFree+0x26>
     cbe:	df 01       	movw	r26, r30
     cc0:	ed 91       	ld	r30, X+
     cc2:	fc 91       	ld	r31, X
     cc4:	11 97       	sbiw	r26, 0x01	; 1
     cc6:	22 81       	ldd	r18, Z+2	; 0x02
     cc8:	33 81       	ldd	r19, Z+3	; 0x03
     cca:	24 17       	cp	r18, r20
     ccc:	35 07       	cpc	r19, r21
     cce:	b8 f3       	brcs	.-18     	; 0xcbe <vPortFree+0x24>
     cd0:	25 97       	sbiw	r28, 0x05	; 5
     cd2:	e8 83       	st	Y, r30
     cd4:	f9 83       	std	Y+1, r31	; 0x01
     cd6:	0d 93       	st	X+, r16
     cd8:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     cda:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
     cde:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
     ce2:	8a 81       	ldd	r24, Y+2	; 0x02
     ce4:	9b 81       	ldd	r25, Y+3	; 0x03
     ce6:	82 0f       	add	r24, r18
     ce8:	93 1f       	adc	r25, r19
     cea:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     cee:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
     cf2:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
	}
}
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	1f 91       	pop	r17
     cfc:	0f 91       	pop	r16
     cfe:	08 95       	ret

00000d00 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     d00:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     d04:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     d08:	08 95       	ret

00000d0a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     d0a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     d0c:	03 96       	adiw	r24, 0x03	; 3
     d0e:	81 83       	std	Z+1, r24	; 0x01
     d10:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d12:	4f ef       	ldi	r20, 0xFF	; 255
     d14:	5f ef       	ldi	r21, 0xFF	; 255
     d16:	ba 01       	movw	r22, r20
     d18:	43 83       	std	Z+3, r20	; 0x03
     d1a:	54 83       	std	Z+4, r21	; 0x04
     d1c:	65 83       	std	Z+5, r22	; 0x05
     d1e:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     d20:	87 83       	std	Z+7, r24	; 0x07
     d22:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     d24:	81 87       	std	Z+9, r24	; 0x09
     d26:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     d28:	10 82       	st	Z, r1
     d2a:	08 95       	ret

00000d2c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     d2c:	fc 01       	movw	r30, r24
     d2e:	12 86       	std	Z+10, r1	; 0x0a
     d30:	13 86       	std	Z+11, r1	; 0x0b
     d32:	08 95       	ret

00000d34 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     d34:	cf 93       	push	r28
     d36:	df 93       	push	r29
     d38:	fc 01       	movw	r30, r24
     d3a:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     d3c:	21 81       	ldd	r18, Z+1	; 0x01
     d3e:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     d40:	e9 01       	movw	r28, r18
     d42:	8c 81       	ldd	r24, Y+4	; 0x04
     d44:	9d 81       	ldd	r25, Y+5	; 0x05
     d46:	14 96       	adiw	r26, 0x04	; 4
     d48:	8d 93       	st	X+, r24
     d4a:	9c 93       	st	X, r25
     d4c:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
     d4e:	81 81       	ldd	r24, Z+1	; 0x01
     d50:	92 81       	ldd	r25, Z+2	; 0x02
     d52:	16 96       	adiw	r26, 0x06	; 6
     d54:	8d 93       	st	X+, r24
     d56:	9c 93       	st	X, r25
     d58:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     d5a:	8c 81       	ldd	r24, Y+4	; 0x04
     d5c:	9d 81       	ldd	r25, Y+5	; 0x05
     d5e:	ec 01       	movw	r28, r24
     d60:	6e 83       	std	Y+6, r22	; 0x06
     d62:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     d64:	e9 01       	movw	r28, r18
     d66:	6c 83       	std	Y+4, r22	; 0x04
     d68:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     d6a:	61 83       	std	Z+1, r22	; 0x01
     d6c:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d6e:	1a 96       	adiw	r26, 0x0a	; 10
     d70:	ed 93       	st	X+, r30
     d72:	fc 93       	st	X, r31
     d74:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
     d76:	80 81       	ld	r24, Z
     d78:	8f 5f       	subi	r24, 0xFF	; 255
     d7a:	80 83       	st	Z, r24
}
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	08 95       	ret

00000d82 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     d82:	0f 93       	push	r16
     d84:	1f 93       	push	r17
     d86:	cf 93       	push	r28
     d88:	df 93       	push	r29
     d8a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     d8c:	08 81       	ld	r16, Y
     d8e:	19 81       	ldd	r17, Y+1	; 0x01
     d90:	2a 81       	ldd	r18, Y+2	; 0x02
     d92:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d94:	0f 3f       	cpi	r16, 0xFF	; 255
     d96:	4f ef       	ldi	r20, 0xFF	; 255
     d98:	14 07       	cpc	r17, r20
     d9a:	24 07       	cpc	r18, r20
     d9c:	34 07       	cpc	r19, r20
     d9e:	31 f4       	brne	.+12     	; 0xdac <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     da0:	dc 01       	movw	r26, r24
     da2:	19 96       	adiw	r26, 0x09	; 9
     da4:	ed 91       	ld	r30, X+
     da6:	fc 91       	ld	r31, X
     da8:	1a 97       	sbiw	r26, 0x0a	; 10
     daa:	1f c0       	rjmp	.+62     	; 0xdea <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     dac:	fc 01       	movw	r30, r24
     dae:	33 96       	adiw	r30, 0x03	; 3
     db0:	dc 01       	movw	r26, r24
     db2:	17 96       	adiw	r26, 0x07	; 7
     db4:	4d 91       	ld	r20, X+
     db6:	5c 91       	ld	r21, X
     db8:	18 97       	sbiw	r26, 0x08	; 8
     dba:	da 01       	movw	r26, r20
     dbc:	4d 91       	ld	r20, X+
     dbe:	5d 91       	ld	r21, X+
     dc0:	6d 91       	ld	r22, X+
     dc2:	7c 91       	ld	r23, X
     dc4:	04 17       	cp	r16, r20
     dc6:	15 07       	cpc	r17, r21
     dc8:	26 07       	cpc	r18, r22
     dca:	37 07       	cpc	r19, r23
     dcc:	70 f0       	brcs	.+28     	; 0xdea <vListInsert+0x68>
     dce:	04 80       	ldd	r0, Z+4	; 0x04
     dd0:	f5 81       	ldd	r31, Z+5	; 0x05
     dd2:	e0 2d       	mov	r30, r0
     dd4:	a4 81       	ldd	r26, Z+4	; 0x04
     dd6:	b5 81       	ldd	r27, Z+5	; 0x05
     dd8:	4d 91       	ld	r20, X+
     dda:	5d 91       	ld	r21, X+
     ddc:	6d 91       	ld	r22, X+
     dde:	7c 91       	ld	r23, X
     de0:	04 17       	cp	r16, r20
     de2:	15 07       	cpc	r17, r21
     de4:	26 07       	cpc	r18, r22
     de6:	37 07       	cpc	r19, r23
     de8:	90 f7       	brcc	.-28     	; 0xdce <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     dea:	a4 81       	ldd	r26, Z+4	; 0x04
     dec:	b5 81       	ldd	r27, Z+5	; 0x05
     dee:	ac 83       	std	Y+4, r26	; 0x04
     df0:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     df2:	16 96       	adiw	r26, 0x06	; 6
     df4:	cd 93       	st	X+, r28
     df6:	dc 93       	st	X, r29
     df8:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
     dfa:	ee 83       	std	Y+6, r30	; 0x06
     dfc:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     dfe:	c4 83       	std	Z+4, r28	; 0x04
     e00:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e02:	8a 87       	std	Y+10, r24	; 0x0a
     e04:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     e06:	fc 01       	movw	r30, r24
     e08:	20 81       	ld	r18, Z
     e0a:	2f 5f       	subi	r18, 0xFF	; 255
     e0c:	20 83       	st	Z, r18
}
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	1f 91       	pop	r17
     e14:	0f 91       	pop	r16
     e16:	08 95       	ret

00000e18 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     e18:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     e1a:	a4 81       	ldd	r26, Z+4	; 0x04
     e1c:	b5 81       	ldd	r27, Z+5	; 0x05
     e1e:	86 81       	ldd	r24, Z+6	; 0x06
     e20:	97 81       	ldd	r25, Z+7	; 0x07
     e22:	16 96       	adiw	r26, 0x06	; 6
     e24:	8d 93       	st	X+, r24
     e26:	9c 93       	st	X, r25
     e28:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e2a:	a6 81       	ldd	r26, Z+6	; 0x06
     e2c:	b7 81       	ldd	r27, Z+7	; 0x07
     e2e:	84 81       	ldd	r24, Z+4	; 0x04
     e30:	95 81       	ldd	r25, Z+5	; 0x05
     e32:	14 96       	adiw	r26, 0x04	; 4
     e34:	8d 93       	st	X+, r24
     e36:	9c 93       	st	X, r25
     e38:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     e3a:	a2 85       	ldd	r26, Z+10	; 0x0a
     e3c:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e3e:	11 96       	adiw	r26, 0x01	; 1
     e40:	8d 91       	ld	r24, X+
     e42:	9c 91       	ld	r25, X
     e44:	12 97       	sbiw	r26, 0x02	; 2
     e46:	e8 17       	cp	r30, r24
     e48:	f9 07       	cpc	r31, r25
     e4a:	31 f4       	brne	.+12     	; 0xe58 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e4c:	86 81       	ldd	r24, Z+6	; 0x06
     e4e:	97 81       	ldd	r25, Z+7	; 0x07
     e50:	11 96       	adiw	r26, 0x01	; 1
     e52:	8d 93       	st	X+, r24
     e54:	9c 93       	st	X, r25
     e56:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
     e58:	12 86       	std	Z+10, r1	; 0x0a
     e5a:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     e5c:	8c 91       	ld	r24, X
     e5e:	81 50       	subi	r24, 0x01	; 1
     e60:	8c 93       	st	X, r24
     e62:	08 95       	ret

00000e64 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     e64:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <portStackTopForTask>
     e68:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <portStackTopForTask+0x1>
     e6c:	31 e1       	ldi	r19, 0x11	; 17
     e6e:	fc 01       	movw	r30, r24
     e70:	30 83       	st	Z, r19
     e72:	31 97       	sbiw	r30, 0x01	; 1
     e74:	22 e2       	ldi	r18, 0x22	; 34
     e76:	20 83       	st	Z, r18
     e78:	31 97       	sbiw	r30, 0x01	; 1
     e7a:	a3 e3       	ldi	r26, 0x33	; 51
     e7c:	a0 83       	st	Z, r26
     e7e:	31 97       	sbiw	r30, 0x01	; 1
     e80:	60 83       	st	Z, r22
     e82:	31 97       	sbiw	r30, 0x01	; 1
     e84:	70 83       	st	Z, r23
     e86:	31 97       	sbiw	r30, 0x01	; 1
     e88:	10 82       	st	Z, r1
     e8a:	31 97       	sbiw	r30, 0x01	; 1
     e8c:	10 82       	st	Z, r1
     e8e:	31 97       	sbiw	r30, 0x01	; 1
     e90:	60 e8       	ldi	r22, 0x80	; 128
     e92:	60 83       	st	Z, r22
     e94:	31 97       	sbiw	r30, 0x01	; 1
     e96:	10 82       	st	Z, r1
     e98:	31 97       	sbiw	r30, 0x01	; 1
     e9a:	10 82       	st	Z, r1
     e9c:	31 97       	sbiw	r30, 0x01	; 1
     e9e:	10 82       	st	Z, r1
     ea0:	31 97       	sbiw	r30, 0x01	; 1
     ea2:	62 e0       	ldi	r22, 0x02	; 2
     ea4:	60 83       	st	Z, r22
     ea6:	31 97       	sbiw	r30, 0x01	; 1
     ea8:	63 e0       	ldi	r22, 0x03	; 3
     eaa:	60 83       	st	Z, r22
     eac:	31 97       	sbiw	r30, 0x01	; 1
     eae:	64 e0       	ldi	r22, 0x04	; 4
     eb0:	60 83       	st	Z, r22
     eb2:	31 97       	sbiw	r30, 0x01	; 1
     eb4:	65 e0       	ldi	r22, 0x05	; 5
     eb6:	60 83       	st	Z, r22
     eb8:	31 97       	sbiw	r30, 0x01	; 1
     eba:	66 e0       	ldi	r22, 0x06	; 6
     ebc:	60 83       	st	Z, r22
     ebe:	31 97       	sbiw	r30, 0x01	; 1
     ec0:	67 e0       	ldi	r22, 0x07	; 7
     ec2:	60 83       	st	Z, r22
     ec4:	31 97       	sbiw	r30, 0x01	; 1
     ec6:	68 e0       	ldi	r22, 0x08	; 8
     ec8:	60 83       	st	Z, r22
     eca:	31 97       	sbiw	r30, 0x01	; 1
     ecc:	69 e0       	ldi	r22, 0x09	; 9
     ece:	60 83       	st	Z, r22
     ed0:	31 97       	sbiw	r30, 0x01	; 1
     ed2:	60 e1       	ldi	r22, 0x10	; 16
     ed4:	60 83       	st	Z, r22
     ed6:	31 97       	sbiw	r30, 0x01	; 1
     ed8:	30 83       	st	Z, r19
     eda:	31 97       	sbiw	r30, 0x01	; 1
     edc:	32 e1       	ldi	r19, 0x12	; 18
     ede:	30 83       	st	Z, r19
     ee0:	31 97       	sbiw	r30, 0x01	; 1
     ee2:	33 e1       	ldi	r19, 0x13	; 19
     ee4:	30 83       	st	Z, r19
     ee6:	31 97       	sbiw	r30, 0x01	; 1
     ee8:	34 e1       	ldi	r19, 0x14	; 20
     eea:	30 83       	st	Z, r19
     eec:	31 97       	sbiw	r30, 0x01	; 1
     eee:	35 e1       	ldi	r19, 0x15	; 21
     ef0:	30 83       	st	Z, r19
     ef2:	31 97       	sbiw	r30, 0x01	; 1
     ef4:	36 e1       	ldi	r19, 0x16	; 22
     ef6:	30 83       	st	Z, r19
     ef8:	31 97       	sbiw	r30, 0x01	; 1
     efa:	37 e1       	ldi	r19, 0x17	; 23
     efc:	30 83       	st	Z, r19
     efe:	31 97       	sbiw	r30, 0x01	; 1
     f00:	38 e1       	ldi	r19, 0x18	; 24
     f02:	30 83       	st	Z, r19
     f04:	31 97       	sbiw	r30, 0x01	; 1
     f06:	39 e1       	ldi	r19, 0x19	; 25
     f08:	30 83       	st	Z, r19
     f0a:	31 97       	sbiw	r30, 0x01	; 1
     f0c:	30 e2       	ldi	r19, 0x20	; 32
     f0e:	30 83       	st	Z, r19
     f10:	31 97       	sbiw	r30, 0x01	; 1
     f12:	31 e2       	ldi	r19, 0x21	; 33
     f14:	30 83       	st	Z, r19
     f16:	31 97       	sbiw	r30, 0x01	; 1
     f18:	20 83       	st	Z, r18
     f1a:	31 97       	sbiw	r30, 0x01	; 1
     f1c:	23 e2       	ldi	r18, 0x23	; 35
     f1e:	20 83       	st	Z, r18
     f20:	31 97       	sbiw	r30, 0x01	; 1
     f22:	40 83       	st	Z, r20
     f24:	31 97       	sbiw	r30, 0x01	; 1
     f26:	50 83       	st	Z, r21
     f28:	31 97       	sbiw	r30, 0x01	; 1
     f2a:	26 e2       	ldi	r18, 0x26	; 38
     f2c:	20 83       	st	Z, r18
     f2e:	31 97       	sbiw	r30, 0x01	; 1
     f30:	27 e2       	ldi	r18, 0x27	; 39
     f32:	20 83       	st	Z, r18
     f34:	31 97       	sbiw	r30, 0x01	; 1
     f36:	28 e2       	ldi	r18, 0x28	; 40
     f38:	20 83       	st	Z, r18
     f3a:	31 97       	sbiw	r30, 0x01	; 1
     f3c:	29 e2       	ldi	r18, 0x29	; 41
     f3e:	20 83       	st	Z, r18
     f40:	31 97       	sbiw	r30, 0x01	; 1
     f42:	20 e3       	ldi	r18, 0x30	; 48
     f44:	20 83       	st	Z, r18
     f46:	31 97       	sbiw	r30, 0x01	; 1
     f48:	21 e3       	ldi	r18, 0x31	; 49
     f4a:	20 83       	st	Z, r18
     f4c:	89 97       	sbiw	r24, 0x29	; 41
     f4e:	08 95       	ret

00000f50 <xPortStartScheduler>:
     f50:	8c e7       	ldi	r24, 0x7C	; 124
     f52:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
     f56:	8f ef       	ldi	r24, 0xFF	; 255
     f58:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
     f5c:	81 e0       	ldi	r24, 0x01	; 1
     f5e:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
     f62:	81 e1       	ldi	r24, 0x11	; 17
     f64:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
     f68:	83 e0       	ldi	r24, 0x03	; 3
     f6a:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
     f6e:	a0 91 02 31 	lds	r26, 0x3102	; 0x803102 <pxCurrentTCB>
     f72:	b0 91 03 31 	lds	r27, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
     f76:	cd 91       	ld	r28, X+
     f78:	cd bf       	out	0x3d, r28	; 61
     f7a:	dd 91       	ld	r29, X+
     f7c:	de bf       	out	0x3e, r29	; 62
     f7e:	ff 91       	pop	r31
     f80:	ef 91       	pop	r30
     f82:	df 91       	pop	r29
     f84:	cf 91       	pop	r28
     f86:	bf 91       	pop	r27
     f88:	af 91       	pop	r26
     f8a:	9f 91       	pop	r25
     f8c:	8f 91       	pop	r24
     f8e:	7f 91       	pop	r23
     f90:	6f 91       	pop	r22
     f92:	5f 91       	pop	r21
     f94:	4f 91       	pop	r20
     f96:	3f 91       	pop	r19
     f98:	2f 91       	pop	r18
     f9a:	1f 91       	pop	r17
     f9c:	0f 91       	pop	r16
     f9e:	ff 90       	pop	r15
     fa0:	ef 90       	pop	r14
     fa2:	df 90       	pop	r13
     fa4:	cf 90       	pop	r12
     fa6:	bf 90       	pop	r11
     fa8:	af 90       	pop	r10
     faa:	9f 90       	pop	r9
     fac:	8f 90       	pop	r8
     fae:	7f 90       	pop	r7
     fb0:	6f 90       	pop	r6
     fb2:	5f 90       	pop	r5
     fb4:	4f 90       	pop	r4
     fb6:	3f 90       	pop	r3
     fb8:	2f 90       	pop	r2
     fba:	1f 90       	pop	r1
     fbc:	0f 90       	pop	r0
     fbe:	0c be       	out	0x3c, r0	; 60
     fc0:	0f 90       	pop	r0
     fc2:	0b be       	out	0x3b, r0	; 59
     fc4:	0f 90       	pop	r0
     fc6:	0f be       	out	0x3f, r0	; 63
     fc8:	0f 90       	pop	r0
     fca:	08 95       	ret
     fcc:	81 e0       	ldi	r24, 0x01	; 1
     fce:	08 95       	ret

00000fd0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     fd0:	0f 92       	push	r0
     fd2:	0f b6       	in	r0, 0x3f	; 63
     fd4:	f8 94       	cli
     fd6:	0f 92       	push	r0
     fd8:	0b b6       	in	r0, 0x3b	; 59
     fda:	0f 92       	push	r0
     fdc:	0c b6       	in	r0, 0x3c	; 60
     fde:	0f 92       	push	r0
     fe0:	1f 92       	push	r1
     fe2:	11 24       	eor	r1, r1
     fe4:	2f 92       	push	r2
     fe6:	3f 92       	push	r3
     fe8:	4f 92       	push	r4
     fea:	5f 92       	push	r5
     fec:	6f 92       	push	r6
     fee:	7f 92       	push	r7
     ff0:	8f 92       	push	r8
     ff2:	9f 92       	push	r9
     ff4:	af 92       	push	r10
     ff6:	bf 92       	push	r11
     ff8:	cf 92       	push	r12
     ffa:	df 92       	push	r13
     ffc:	ef 92       	push	r14
     ffe:	ff 92       	push	r15
    1000:	0f 93       	push	r16
    1002:	1f 93       	push	r17
    1004:	2f 93       	push	r18
    1006:	3f 93       	push	r19
    1008:	4f 93       	push	r20
    100a:	5f 93       	push	r21
    100c:	6f 93       	push	r22
    100e:	7f 93       	push	r23
    1010:	8f 93       	push	r24
    1012:	9f 93       	push	r25
    1014:	af 93       	push	r26
    1016:	bf 93       	push	r27
    1018:	cf 93       	push	r28
    101a:	df 93       	push	r29
    101c:	ef 93       	push	r30
    101e:	ff 93       	push	r31
    1020:	a0 91 02 31 	lds	r26, 0x3102	; 0x803102 <pxCurrentTCB>
    1024:	b0 91 03 31 	lds	r27, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1028:	0d b6       	in	r0, 0x3d	; 61
    102a:	0d 92       	st	X+, r0
    102c:	0e b6       	in	r0, 0x3e	; 62
    102e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1030:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1034:	a0 91 02 31 	lds	r26, 0x3102	; 0x803102 <pxCurrentTCB>
    1038:	b0 91 03 31 	lds	r27, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    103c:	cd 91       	ld	r28, X+
    103e:	cd bf       	out	0x3d, r28	; 61
    1040:	dd 91       	ld	r29, X+
    1042:	de bf       	out	0x3e, r29	; 62
    1044:	ff 91       	pop	r31
    1046:	ef 91       	pop	r30
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	bf 91       	pop	r27
    104e:	af 91       	pop	r26
    1050:	9f 91       	pop	r25
    1052:	8f 91       	pop	r24
    1054:	7f 91       	pop	r23
    1056:	6f 91       	pop	r22
    1058:	5f 91       	pop	r21
    105a:	4f 91       	pop	r20
    105c:	3f 91       	pop	r19
    105e:	2f 91       	pop	r18
    1060:	1f 91       	pop	r17
    1062:	0f 91       	pop	r16
    1064:	ff 90       	pop	r15
    1066:	ef 90       	pop	r14
    1068:	df 90       	pop	r13
    106a:	cf 90       	pop	r12
    106c:	bf 90       	pop	r11
    106e:	af 90       	pop	r10
    1070:	9f 90       	pop	r9
    1072:	8f 90       	pop	r8
    1074:	7f 90       	pop	r7
    1076:	6f 90       	pop	r6
    1078:	5f 90       	pop	r5
    107a:	4f 90       	pop	r4
    107c:	3f 90       	pop	r3
    107e:	2f 90       	pop	r2
    1080:	1f 90       	pop	r1
    1082:	0f 90       	pop	r0
    1084:	0c be       	out	0x3c, r0	; 60
    1086:	0f 90       	pop	r0
    1088:	0b be       	out	0x3b, r0	; 59
    108a:	0f 90       	pop	r0
    108c:	0f be       	out	0x3f, r0	; 63
    108e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1090:	08 95       	ret

00001092 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1092:	0f 92       	push	r0
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	0f 92       	push	r0
    109a:	0b b6       	in	r0, 0x3b	; 59
    109c:	0f 92       	push	r0
    109e:	0c b6       	in	r0, 0x3c	; 60
    10a0:	0f 92       	push	r0
    10a2:	1f 92       	push	r1
    10a4:	11 24       	eor	r1, r1
    10a6:	2f 92       	push	r2
    10a8:	3f 92       	push	r3
    10aa:	4f 92       	push	r4
    10ac:	5f 92       	push	r5
    10ae:	6f 92       	push	r6
    10b0:	7f 92       	push	r7
    10b2:	8f 92       	push	r8
    10b4:	9f 92       	push	r9
    10b6:	af 92       	push	r10
    10b8:	bf 92       	push	r11
    10ba:	cf 92       	push	r12
    10bc:	df 92       	push	r13
    10be:	ef 92       	push	r14
    10c0:	ff 92       	push	r15
    10c2:	0f 93       	push	r16
    10c4:	1f 93       	push	r17
    10c6:	2f 93       	push	r18
    10c8:	3f 93       	push	r19
    10ca:	4f 93       	push	r20
    10cc:	5f 93       	push	r21
    10ce:	6f 93       	push	r22
    10d0:	7f 93       	push	r23
    10d2:	8f 93       	push	r24
    10d4:	9f 93       	push	r25
    10d6:	af 93       	push	r26
    10d8:	bf 93       	push	r27
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
    10de:	ef 93       	push	r30
    10e0:	ff 93       	push	r31
    10e2:	a0 91 02 31 	lds	r26, 0x3102	; 0x803102 <pxCurrentTCB>
    10e6:	b0 91 03 31 	lds	r27, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    10ea:	0d b6       	in	r0, 0x3d	; 61
    10ec:	0d 92       	st	X+, r0
    10ee:	0e b6       	in	r0, 0x3e	; 62
    10f0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    10f2:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vTaskIncrementTick>
	vTaskSwitchContext();
    10f6:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    10fa:	a0 91 02 31 	lds	r26, 0x3102	; 0x803102 <pxCurrentTCB>
    10fe:	b0 91 03 31 	lds	r27, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1102:	cd 91       	ld	r28, X+
    1104:	cd bf       	out	0x3d, r28	; 61
    1106:	dd 91       	ld	r29, X+
    1108:	de bf       	out	0x3e, r29	; 62
    110a:	ff 91       	pop	r31
    110c:	ef 91       	pop	r30
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	bf 91       	pop	r27
    1114:	af 91       	pop	r26
    1116:	9f 91       	pop	r25
    1118:	8f 91       	pop	r24
    111a:	7f 91       	pop	r23
    111c:	6f 91       	pop	r22
    111e:	5f 91       	pop	r21
    1120:	4f 91       	pop	r20
    1122:	3f 91       	pop	r19
    1124:	2f 91       	pop	r18
    1126:	1f 91       	pop	r17
    1128:	0f 91       	pop	r16
    112a:	ff 90       	pop	r15
    112c:	ef 90       	pop	r14
    112e:	df 90       	pop	r13
    1130:	cf 90       	pop	r12
    1132:	bf 90       	pop	r11
    1134:	af 90       	pop	r10
    1136:	9f 90       	pop	r9
    1138:	8f 90       	pop	r8
    113a:	7f 90       	pop	r7
    113c:	6f 90       	pop	r6
    113e:	5f 90       	pop	r5
    1140:	4f 90       	pop	r4
    1142:	3f 90       	pop	r3
    1144:	2f 90       	pop	r2
    1146:	1f 90       	pop	r1
    1148:	0f 90       	pop	r0
    114a:	0c be       	out	0x3c, r0	; 60
    114c:	0f 90       	pop	r0
    114e:	0b be       	out	0x3b, r0	; 59
    1150:	0f 90       	pop	r0
    1152:	0f be       	out	0x3f, r0	; 63
    1154:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1156:	08 95       	ret

00001158 <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1158:	0e 94 49 08 	call	0x1092	; 0x1092 <vPortYieldFromTick>
		asm volatile ( "reti" );
    115c:	18 95       	reti

0000115e <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	ec 01       	movw	r28, r24
    1164:	88 a1       	ldd	r24, Y+32	; 0x20
    1166:	81 11       	cpse	r24, r1
    1168:	0b c0       	rjmp	.+22     	; 0x1180 <prvCopyDataToQueue+0x22>
    116a:	88 81       	ld	r24, Y
    116c:	99 81       	ldd	r25, Y+1	; 0x01
    116e:	89 2b       	or	r24, r25
    1170:	e1 f5       	brne	.+120    	; 0x11ea <prvCopyDataToQueue+0x8c>
    1172:	8a 81       	ldd	r24, Y+2	; 0x02
    1174:	9b 81       	ldd	r25, Y+3	; 0x03
    1176:	0e 94 56 10 	call	0x20ac	; 0x20ac <vTaskPriorityDisinherit>
    117a:	1a 82       	std	Y+2, r1	; 0x02
    117c:	1b 82       	std	Y+3, r1	; 0x03
    117e:	35 c0       	rjmp	.+106    	; 0x11ea <prvCopyDataToQueue+0x8c>
    1180:	41 11       	cpse	r20, r1
    1182:	17 c0       	rjmp	.+46     	; 0x11b2 <prvCopyDataToQueue+0x54>
    1184:	48 2f       	mov	r20, r24
    1186:	50 e0       	ldi	r21, 0x00	; 0
    1188:	8c 81       	ldd	r24, Y+4	; 0x04
    118a:	9d 81       	ldd	r25, Y+5	; 0x05
    118c:	0e 94 3c 1c 	call	0x3878	; 0x3878 <memcpy>
    1190:	28 a1       	ldd	r18, Y+32	; 0x20
    1192:	8c 81       	ldd	r24, Y+4	; 0x04
    1194:	9d 81       	ldd	r25, Y+5	; 0x05
    1196:	82 0f       	add	r24, r18
    1198:	91 1d       	adc	r25, r1
    119a:	8c 83       	std	Y+4, r24	; 0x04
    119c:	9d 83       	std	Y+5, r25	; 0x05
    119e:	2a 81       	ldd	r18, Y+2	; 0x02
    11a0:	3b 81       	ldd	r19, Y+3	; 0x03
    11a2:	82 17       	cp	r24, r18
    11a4:	93 07       	cpc	r25, r19
    11a6:	08 f1       	brcs	.+66     	; 0x11ea <prvCopyDataToQueue+0x8c>
    11a8:	88 81       	ld	r24, Y
    11aa:	99 81       	ldd	r25, Y+1	; 0x01
    11ac:	8c 83       	std	Y+4, r24	; 0x04
    11ae:	9d 83       	std	Y+5, r25	; 0x05
    11b0:	1c c0       	rjmp	.+56     	; 0x11ea <prvCopyDataToQueue+0x8c>
    11b2:	48 2f       	mov	r20, r24
    11b4:	50 e0       	ldi	r21, 0x00	; 0
    11b6:	8e 81       	ldd	r24, Y+6	; 0x06
    11b8:	9f 81       	ldd	r25, Y+7	; 0x07
    11ba:	0e 94 3c 1c 	call	0x3878	; 0x3878 <memcpy>
    11be:	88 a1       	ldd	r24, Y+32	; 0x20
    11c0:	90 e0       	ldi	r25, 0x00	; 0
    11c2:	91 95       	neg	r25
    11c4:	81 95       	neg	r24
    11c6:	91 09       	sbc	r25, r1
    11c8:	2e 81       	ldd	r18, Y+6	; 0x06
    11ca:	3f 81       	ldd	r19, Y+7	; 0x07
    11cc:	28 0f       	add	r18, r24
    11ce:	39 1f       	adc	r19, r25
    11d0:	2e 83       	std	Y+6, r18	; 0x06
    11d2:	3f 83       	std	Y+7, r19	; 0x07
    11d4:	48 81       	ld	r20, Y
    11d6:	59 81       	ldd	r21, Y+1	; 0x01
    11d8:	24 17       	cp	r18, r20
    11da:	35 07       	cpc	r19, r21
    11dc:	30 f4       	brcc	.+12     	; 0x11ea <prvCopyDataToQueue+0x8c>
    11de:	2a 81       	ldd	r18, Y+2	; 0x02
    11e0:	3b 81       	ldd	r19, Y+3	; 0x03
    11e2:	82 0f       	add	r24, r18
    11e4:	93 1f       	adc	r25, r19
    11e6:	8e 83       	std	Y+6, r24	; 0x06
    11e8:	9f 83       	std	Y+7, r25	; 0x07
    11ea:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11ec:	8f 5f       	subi	r24, 0xFF	; 255
    11ee:	8e 8f       	std	Y+30, r24	; 0x1e
    11f0:	df 91       	pop	r29
    11f2:	cf 91       	pop	r28
    11f4:	08 95       	ret

000011f6 <prvCopyDataFromQueue>:
    11f6:	fc 01       	movw	r30, r24
    11f8:	80 81       	ld	r24, Z
    11fa:	91 81       	ldd	r25, Z+1	; 0x01
    11fc:	00 97       	sbiw	r24, 0x00	; 0
    11fe:	a1 f0       	breq	.+40     	; 0x1228 <prvCopyDataFromQueue+0x32>
    1200:	40 a1       	ldd	r20, Z+32	; 0x20
    1202:	50 e0       	ldi	r21, 0x00	; 0
    1204:	26 81       	ldd	r18, Z+6	; 0x06
    1206:	37 81       	ldd	r19, Z+7	; 0x07
    1208:	24 0f       	add	r18, r20
    120a:	35 1f       	adc	r19, r21
    120c:	26 83       	std	Z+6, r18	; 0x06
    120e:	37 83       	std	Z+7, r19	; 0x07
    1210:	a2 81       	ldd	r26, Z+2	; 0x02
    1212:	b3 81       	ldd	r27, Z+3	; 0x03
    1214:	2a 17       	cp	r18, r26
    1216:	3b 07       	cpc	r19, r27
    1218:	10 f0       	brcs	.+4      	; 0x121e <prvCopyDataFromQueue+0x28>
    121a:	86 83       	std	Z+6, r24	; 0x06
    121c:	97 83       	std	Z+7, r25	; 0x07
    121e:	cb 01       	movw	r24, r22
    1220:	66 81       	ldd	r22, Z+6	; 0x06
    1222:	77 81       	ldd	r23, Z+7	; 0x07
    1224:	0e 94 3c 1c 	call	0x3878	; 0x3878 <memcpy>
    1228:	08 95       	ret

0000122a <prvUnlockQueue>:
    122a:	0f 93       	push	r16
    122c:	1f 93       	push	r17
    122e:	cf 93       	push	r28
    1230:	df 93       	push	r29
    1232:	ec 01       	movw	r28, r24
    1234:	0f b6       	in	r0, 0x3f	; 63
    1236:	f8 94       	cli
    1238:	0f 92       	push	r0
    123a:	8a a1       	ldd	r24, Y+34	; 0x22
    123c:	18 16       	cp	r1, r24
    123e:	b4 f4       	brge	.+44     	; 0x126c <prvUnlockQueue+0x42>
    1240:	8b 89       	ldd	r24, Y+19	; 0x13
    1242:	81 11       	cpse	r24, r1
    1244:	05 c0       	rjmp	.+10     	; 0x1250 <prvUnlockQueue+0x26>
    1246:	12 c0       	rjmp	.+36     	; 0x126c <prvUnlockQueue+0x42>
    1248:	8b 89       	ldd	r24, Y+19	; 0x13
    124a:	81 11       	cpse	r24, r1
    124c:	04 c0       	rjmp	.+8      	; 0x1256 <prvUnlockQueue+0x2c>
    124e:	0e c0       	rjmp	.+28     	; 0x126c <prvUnlockQueue+0x42>
    1250:	8e 01       	movw	r16, r28
    1252:	0d 5e       	subi	r16, 0xED	; 237
    1254:	1f 4f       	sbci	r17, 0xFF	; 255
    1256:	c8 01       	movw	r24, r16
    1258:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <xTaskRemoveFromEventList>
    125c:	81 11       	cpse	r24, r1
    125e:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <vTaskMissedYield>
    1262:	8a a1       	ldd	r24, Y+34	; 0x22
    1264:	81 50       	subi	r24, 0x01	; 1
    1266:	8a a3       	std	Y+34, r24	; 0x22
    1268:	18 16       	cp	r1, r24
    126a:	74 f3       	brlt	.-36     	; 0x1248 <prvUnlockQueue+0x1e>
    126c:	8f ef       	ldi	r24, 0xFF	; 255
    126e:	8a a3       	std	Y+34, r24	; 0x22
    1270:	0f 90       	pop	r0
    1272:	0f be       	out	0x3f, r0	; 63
    1274:	0f b6       	in	r0, 0x3f	; 63
    1276:	f8 94       	cli
    1278:	0f 92       	push	r0
    127a:	89 a1       	ldd	r24, Y+33	; 0x21
    127c:	18 16       	cp	r1, r24
    127e:	b4 f4       	brge	.+44     	; 0x12ac <prvUnlockQueue+0x82>
    1280:	88 85       	ldd	r24, Y+8	; 0x08
    1282:	81 11       	cpse	r24, r1
    1284:	05 c0       	rjmp	.+10     	; 0x1290 <prvUnlockQueue+0x66>
    1286:	12 c0       	rjmp	.+36     	; 0x12ac <prvUnlockQueue+0x82>
    1288:	88 85       	ldd	r24, Y+8	; 0x08
    128a:	81 11       	cpse	r24, r1
    128c:	04 c0       	rjmp	.+8      	; 0x1296 <prvUnlockQueue+0x6c>
    128e:	0e c0       	rjmp	.+28     	; 0x12ac <prvUnlockQueue+0x82>
    1290:	8e 01       	movw	r16, r28
    1292:	08 5f       	subi	r16, 0xF8	; 248
    1294:	1f 4f       	sbci	r17, 0xFF	; 255
    1296:	c8 01       	movw	r24, r16
    1298:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <xTaskRemoveFromEventList>
    129c:	81 11       	cpse	r24, r1
    129e:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <vTaskMissedYield>
    12a2:	89 a1       	ldd	r24, Y+33	; 0x21
    12a4:	81 50       	subi	r24, 0x01	; 1
    12a6:	89 a3       	std	Y+33, r24	; 0x21
    12a8:	18 16       	cp	r1, r24
    12aa:	74 f3       	brlt	.-36     	; 0x1288 <prvUnlockQueue+0x5e>
    12ac:	8f ef       	ldi	r24, 0xFF	; 255
    12ae:	89 a3       	std	Y+33, r24	; 0x21
    12b0:	0f 90       	pop	r0
    12b2:	0f be       	out	0x3f, r0	; 63
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	08 95       	ret

000012be <xQueueGenericReset>:
    12be:	1f 93       	push	r17
    12c0:	cf 93       	push	r28
    12c2:	df 93       	push	r29
    12c4:	61 30       	cpi	r22, 0x01	; 1
    12c6:	59 f0       	breq	.+22     	; 0x12de <xQueueGenericReset+0x20>
    12c8:	fc 01       	movw	r30, r24
    12ca:	23 89       	ldd	r18, Z+19	; 0x13
    12cc:	30 85       	ldd	r19, Z+8	; 0x08
    12ce:	31 11       	cpse	r19, r1
    12d0:	2c c0       	rjmp	.+88     	; 0x132a <xQueueGenericReset+0x6c>
    12d2:	11 e0       	ldi	r17, 0x01	; 1
    12d4:	21 11       	cpse	r18, r1
    12d6:	10 e0       	ldi	r17, 0x00	; 0
    12d8:	21 11       	cpse	r18, r1
    12da:	28 c0       	rjmp	.+80     	; 0x132c <xQueueGenericReset+0x6e>
    12dc:	01 c0       	rjmp	.+2      	; 0x12e0 <xQueueGenericReset+0x22>
    12de:	11 e0       	ldi	r17, 0x01	; 1
    12e0:	ec 01       	movw	r28, r24
    12e2:	48 81       	ld	r20, Y
    12e4:	59 81       	ldd	r21, Y+1	; 0x01
    12e6:	28 a1       	ldd	r18, Y+32	; 0x20
    12e8:	30 e0       	ldi	r19, 0x00	; 0
    12ea:	6f 8d       	ldd	r22, Y+31	; 0x1f
    12ec:	62 9f       	mul	r22, r18
    12ee:	c0 01       	movw	r24, r0
    12f0:	63 9f       	mul	r22, r19
    12f2:	90 0d       	add	r25, r0
    12f4:	11 24       	eor	r1, r1
    12f6:	ba 01       	movw	r22, r20
    12f8:	68 0f       	add	r22, r24
    12fa:	79 1f       	adc	r23, r25
    12fc:	6a 83       	std	Y+2, r22	; 0x02
    12fe:	7b 83       	std	Y+3, r23	; 0x03
    1300:	1e 8e       	std	Y+30, r1	; 0x1e
    1302:	4c 83       	std	Y+4, r20	; 0x04
    1304:	5d 83       	std	Y+5, r21	; 0x05
    1306:	82 1b       	sub	r24, r18
    1308:	93 0b       	sbc	r25, r19
    130a:	84 0f       	add	r24, r20
    130c:	95 1f       	adc	r25, r21
    130e:	8e 83       	std	Y+6, r24	; 0x06
    1310:	9f 83       	std	Y+7, r25	; 0x07
    1312:	8f ef       	ldi	r24, 0xFF	; 255
    1314:	89 a3       	std	Y+33, r24	; 0x21
    1316:	8a a3       	std	Y+34, r24	; 0x22
    1318:	ce 01       	movw	r24, r28
    131a:	08 96       	adiw	r24, 0x08	; 8
    131c:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    1320:	ce 01       	movw	r24, r28
    1322:	43 96       	adiw	r24, 0x13	; 19
    1324:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    1328:	01 c0       	rjmp	.+2      	; 0x132c <xQueueGenericReset+0x6e>
    132a:	10 e0       	ldi	r17, 0x00	; 0
    132c:	81 2f       	mov	r24, r17
    132e:	df 91       	pop	r29
    1330:	cf 91       	pop	r28
    1332:	1f 91       	pop	r17
    1334:	08 95       	ret

00001336 <xQueueGenericCreate>:
    1336:	0f 93       	push	r16
    1338:	1f 93       	push	r17
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	88 23       	and	r24, r24
    1340:	01 f1       	breq	.+64     	; 0x1382 <xQueueGenericCreate+0x4c>
    1342:	06 2f       	mov	r16, r22
    1344:	18 2f       	mov	r17, r24
    1346:	83 e2       	ldi	r24, 0x23	; 35
    1348:	90 e0       	ldi	r25, 0x00	; 0
    134a:	0e 94 b3 05 	call	0xb66	; 0xb66 <pvPortMalloc>
    134e:	ec 01       	movw	r28, r24
    1350:	89 2b       	or	r24, r25
    1352:	c9 f0       	breq	.+50     	; 0x1386 <xQueueGenericCreate+0x50>
    1354:	10 9f       	mul	r17, r16
    1356:	c0 01       	movw	r24, r0
    1358:	11 24       	eor	r1, r1
    135a:	01 96       	adiw	r24, 0x01	; 1
    135c:	0e 94 b3 05 	call	0xb66	; 0xb66 <pvPortMalloc>
    1360:	88 83       	st	Y, r24
    1362:	99 83       	std	Y+1, r25	; 0x01
    1364:	89 2b       	or	r24, r25
    1366:	39 f0       	breq	.+14     	; 0x1376 <xQueueGenericCreate+0x40>
    1368:	1f 8f       	std	Y+31, r17	; 0x1f
    136a:	08 a3       	std	Y+32, r16	; 0x20
    136c:	61 e0       	ldi	r22, 0x01	; 1
    136e:	ce 01       	movw	r24, r28
    1370:	0e 94 5f 09 	call	0x12be	; 0x12be <xQueueGenericReset>
    1374:	08 c0       	rjmp	.+16     	; 0x1386 <xQueueGenericCreate+0x50>
    1376:	ce 01       	movw	r24, r28
    1378:	0e 94 4d 06 	call	0xc9a	; 0xc9a <vPortFree>
    137c:	c0 e0       	ldi	r28, 0x00	; 0
    137e:	d0 e0       	ldi	r29, 0x00	; 0
    1380:	02 c0       	rjmp	.+4      	; 0x1386 <xQueueGenericCreate+0x50>
    1382:	c0 e0       	ldi	r28, 0x00	; 0
    1384:	d0 e0       	ldi	r29, 0x00	; 0
    1386:	ce 01       	movw	r24, r28
    1388:	df 91       	pop	r29
    138a:	cf 91       	pop	r28
    138c:	1f 91       	pop	r17
    138e:	0f 91       	pop	r16
    1390:	08 95       	ret

00001392 <xQueueGenericSend>:
    1392:	af 92       	push	r10
    1394:	bf 92       	push	r11
    1396:	cf 92       	push	r12
    1398:	df 92       	push	r13
    139a:	ef 92       	push	r14
    139c:	ff 92       	push	r15
    139e:	0f 93       	push	r16
    13a0:	1f 93       	push	r17
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
    13a6:	cd b7       	in	r28, 0x3d	; 61
    13a8:	de b7       	in	r29, 0x3e	; 62
    13aa:	29 97       	sbiw	r28, 0x09	; 9
    13ac:	cd bf       	out	0x3d, r28	; 61
    13ae:	de bf       	out	0x3e, r29	; 62
    13b0:	7c 01       	movw	r14, r24
    13b2:	5b 01       	movw	r10, r22
    13b4:	2e 83       	std	Y+6, r18	; 0x06
    13b6:	3f 83       	std	Y+7, r19	; 0x07
    13b8:	48 87       	std	Y+8, r20	; 0x08
    13ba:	59 87       	std	Y+9, r21	; 0x09
    13bc:	10 e0       	ldi	r17, 0x00	; 0
    13be:	6c 01       	movw	r12, r24
    13c0:	88 e0       	ldi	r24, 0x08	; 8
    13c2:	c8 0e       	add	r12, r24
    13c4:	d1 1c       	adc	r13, r1
    13c6:	0f b6       	in	r0, 0x3f	; 63
    13c8:	f8 94       	cli
    13ca:	0f 92       	push	r0
    13cc:	f7 01       	movw	r30, r14
    13ce:	96 8d       	ldd	r25, Z+30	; 0x1e
    13d0:	87 8d       	ldd	r24, Z+31	; 0x1f
    13d2:	98 17       	cp	r25, r24
    13d4:	a8 f4       	brcc	.+42     	; 0x1400 <xQueueGenericSend+0x6e>
    13d6:	40 2f       	mov	r20, r16
    13d8:	b5 01       	movw	r22, r10
    13da:	c7 01       	movw	r24, r14
    13dc:	0e 94 af 08 	call	0x115e	; 0x115e <prvCopyDataToQueue>
    13e0:	f7 01       	movw	r30, r14
    13e2:	83 89       	ldd	r24, Z+19	; 0x13
    13e4:	88 23       	and	r24, r24
    13e6:	41 f0       	breq	.+16     	; 0x13f8 <xQueueGenericSend+0x66>
    13e8:	c7 01       	movw	r24, r14
    13ea:	43 96       	adiw	r24, 0x13	; 19
    13ec:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <xTaskRemoveFromEventList>
    13f0:	81 30       	cpi	r24, 0x01	; 1
    13f2:	11 f4       	brne	.+4      	; 0x13f8 <xQueueGenericSend+0x66>
    13f4:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
    13f8:	0f 90       	pop	r0
    13fa:	0f be       	out	0x3f, r0	; 63
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	56 c0       	rjmp	.+172    	; 0x14ac <xQueueGenericSend+0x11a>
    1400:	8e 81       	ldd	r24, Y+6	; 0x06
    1402:	9f 81       	ldd	r25, Y+7	; 0x07
    1404:	a8 85       	ldd	r26, Y+8	; 0x08
    1406:	b9 85       	ldd	r27, Y+9	; 0x09
    1408:	89 2b       	or	r24, r25
    140a:	8a 2b       	or	r24, r26
    140c:	8b 2b       	or	r24, r27
    140e:	21 f4       	brne	.+8      	; 0x1418 <xQueueGenericSend+0x86>
    1410:	0f 90       	pop	r0
    1412:	0f be       	out	0x3f, r0	; 63
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	4a c0       	rjmp	.+148    	; 0x14ac <xQueueGenericSend+0x11a>
    1418:	11 11       	cpse	r17, r1
    141a:	05 c0       	rjmp	.+10     	; 0x1426 <xQueueGenericSend+0x94>
    141c:	ce 01       	movw	r24, r28
    141e:	01 96       	adiw	r24, 0x01	; 1
    1420:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vTaskSetTimeOutState>
    1424:	11 e0       	ldi	r17, 0x01	; 1
    1426:	0f 90       	pop	r0
    1428:	0f be       	out	0x3f, r0	; 63
    142a:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vTaskSuspendAll>
    142e:	0f b6       	in	r0, 0x3f	; 63
    1430:	f8 94       	cli
    1432:	0f 92       	push	r0
    1434:	f7 01       	movw	r30, r14
    1436:	81 a1       	ldd	r24, Z+33	; 0x21
    1438:	8f 3f       	cpi	r24, 0xFF	; 255
    143a:	09 f4       	brne	.+2      	; 0x143e <xQueueGenericSend+0xac>
    143c:	11 a2       	std	Z+33, r1	; 0x21
    143e:	f7 01       	movw	r30, r14
    1440:	82 a1       	ldd	r24, Z+34	; 0x22
    1442:	8f 3f       	cpi	r24, 0xFF	; 255
    1444:	09 f4       	brne	.+2      	; 0x1448 <xQueueGenericSend+0xb6>
    1446:	12 a2       	std	Z+34, r1	; 0x22
    1448:	0f 90       	pop	r0
    144a:	0f be       	out	0x3f, r0	; 63
    144c:	be 01       	movw	r22, r28
    144e:	6a 5f       	subi	r22, 0xFA	; 250
    1450:	7f 4f       	sbci	r23, 0xFF	; 255
    1452:	ce 01       	movw	r24, r28
    1454:	01 96       	adiw	r24, 0x01	; 1
    1456:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <xTaskCheckForTimeOut>
    145a:	81 11       	cpse	r24, r1
    145c:	21 c0       	rjmp	.+66     	; 0x14a0 <xQueueGenericSend+0x10e>
    145e:	0f b6       	in	r0, 0x3f	; 63
    1460:	f8 94       	cli
    1462:	0f 92       	push	r0
    1464:	f7 01       	movw	r30, r14
    1466:	96 8d       	ldd	r25, Z+30	; 0x1e
    1468:	0f 90       	pop	r0
    146a:	0f be       	out	0x3f, r0	; 63
    146c:	87 8d       	ldd	r24, Z+31	; 0x1f
    146e:	98 13       	cpse	r25, r24
    1470:	11 c0       	rjmp	.+34     	; 0x1494 <xQueueGenericSend+0x102>
    1472:	4e 81       	ldd	r20, Y+6	; 0x06
    1474:	5f 81       	ldd	r21, Y+7	; 0x07
    1476:	68 85       	ldd	r22, Y+8	; 0x08
    1478:	79 85       	ldd	r23, Y+9	; 0x09
    147a:	c6 01       	movw	r24, r12
    147c:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <vTaskPlaceOnEventList>
    1480:	c7 01       	movw	r24, r14
    1482:	0e 94 15 09 	call	0x122a	; 0x122a <prvUnlockQueue>
    1486:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
    148a:	81 11       	cpse	r24, r1
    148c:	9c cf       	rjmp	.-200    	; 0x13c6 <xQueueGenericSend+0x34>
    148e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
    1492:	99 cf       	rjmp	.-206    	; 0x13c6 <xQueueGenericSend+0x34>
    1494:	c7 01       	movw	r24, r14
    1496:	0e 94 15 09 	call	0x122a	; 0x122a <prvUnlockQueue>
    149a:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
    149e:	93 cf       	rjmp	.-218    	; 0x13c6 <xQueueGenericSend+0x34>
    14a0:	c7 01       	movw	r24, r14
    14a2:	0e 94 15 09 	call	0x122a	; 0x122a <prvUnlockQueue>
    14a6:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	29 96       	adiw	r28, 0x09	; 9
    14ae:	cd bf       	out	0x3d, r28	; 61
    14b0:	de bf       	out	0x3e, r29	; 62
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	ff 90       	pop	r15
    14bc:	ef 90       	pop	r14
    14be:	df 90       	pop	r13
    14c0:	cf 90       	pop	r12
    14c2:	bf 90       	pop	r11
    14c4:	af 90       	pop	r10
    14c6:	08 95       	ret

000014c8 <xQueueGenericReceive>:
    14c8:	af 92       	push	r10
    14ca:	bf 92       	push	r11
    14cc:	cf 92       	push	r12
    14ce:	df 92       	push	r13
    14d0:	ef 92       	push	r14
    14d2:	ff 92       	push	r15
    14d4:	0f 93       	push	r16
    14d6:	1f 93       	push	r17
    14d8:	cf 93       	push	r28
    14da:	df 93       	push	r29
    14dc:	cd b7       	in	r28, 0x3d	; 61
    14de:	de b7       	in	r29, 0x3e	; 62
    14e0:	29 97       	sbiw	r28, 0x09	; 9
    14e2:	cd bf       	out	0x3d, r28	; 61
    14e4:	de bf       	out	0x3e, r29	; 62
    14e6:	7c 01       	movw	r14, r24
    14e8:	5b 01       	movw	r10, r22
    14ea:	2e 83       	std	Y+6, r18	; 0x06
    14ec:	3f 83       	std	Y+7, r19	; 0x07
    14ee:	48 87       	std	Y+8, r20	; 0x08
    14f0:	59 87       	std	Y+9, r21	; 0x09
    14f2:	10 e0       	ldi	r17, 0x00	; 0
    14f4:	6c 01       	movw	r12, r24
    14f6:	83 e1       	ldi	r24, 0x13	; 19
    14f8:	c8 0e       	add	r12, r24
    14fa:	d1 1c       	adc	r13, r1
    14fc:	0f b6       	in	r0, 0x3f	; 63
    14fe:	f8 94       	cli
    1500:	0f 92       	push	r0
    1502:	f7 01       	movw	r30, r14
    1504:	86 8d       	ldd	r24, Z+30	; 0x1e
    1506:	88 23       	and	r24, r24
    1508:	99 f1       	breq	.+102    	; 0x1570 <xQueueGenericReceive+0xa8>
    150a:	c6 80       	ldd	r12, Z+6	; 0x06
    150c:	d7 80       	ldd	r13, Z+7	; 0x07
    150e:	b5 01       	movw	r22, r10
    1510:	c7 01       	movw	r24, r14
    1512:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <prvCopyDataFromQueue>
    1516:	01 11       	cpse	r16, r1
    1518:	1a c0       	rjmp	.+52     	; 0x154e <xQueueGenericReceive+0x86>
    151a:	f7 01       	movw	r30, r14
    151c:	86 8d       	ldd	r24, Z+30	; 0x1e
    151e:	81 50       	subi	r24, 0x01	; 1
    1520:	86 8f       	std	Z+30, r24	; 0x1e
    1522:	80 81       	ld	r24, Z
    1524:	91 81       	ldd	r25, Z+1	; 0x01
    1526:	89 2b       	or	r24, r25
    1528:	29 f4       	brne	.+10     	; 0x1534 <xQueueGenericReceive+0x6c>
    152a:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <xTaskGetCurrentTaskHandle>
    152e:	f7 01       	movw	r30, r14
    1530:	82 83       	std	Z+2, r24	; 0x02
    1532:	93 83       	std	Z+3, r25	; 0x03
    1534:	f7 01       	movw	r30, r14
    1536:	80 85       	ldd	r24, Z+8	; 0x08
    1538:	88 23       	and	r24, r24
    153a:	b1 f0       	breq	.+44     	; 0x1568 <xQueueGenericReceive+0xa0>
    153c:	c7 01       	movw	r24, r14
    153e:	08 96       	adiw	r24, 0x08	; 8
    1540:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <xTaskRemoveFromEventList>
    1544:	81 30       	cpi	r24, 0x01	; 1
    1546:	81 f4       	brne	.+32     	; 0x1568 <xQueueGenericReceive+0xa0>
    1548:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
    154c:	0d c0       	rjmp	.+26     	; 0x1568 <xQueueGenericReceive+0xa0>
    154e:	f7 01       	movw	r30, r14
    1550:	c6 82       	std	Z+6, r12	; 0x06
    1552:	d7 82       	std	Z+7, r13	; 0x07
    1554:	83 89       	ldd	r24, Z+19	; 0x13
    1556:	88 23       	and	r24, r24
    1558:	39 f0       	breq	.+14     	; 0x1568 <xQueueGenericReceive+0xa0>
    155a:	c7 01       	movw	r24, r14
    155c:	43 96       	adiw	r24, 0x13	; 19
    155e:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <xTaskRemoveFromEventList>
    1562:	81 11       	cpse	r24, r1
    1564:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
    1568:	0f 90       	pop	r0
    156a:	0f be       	out	0x3f, r0	; 63
    156c:	81 e0       	ldi	r24, 0x01	; 1
    156e:	62 c0       	rjmp	.+196    	; 0x1634 <xQueueGenericReceive+0x16c>
    1570:	8e 81       	ldd	r24, Y+6	; 0x06
    1572:	9f 81       	ldd	r25, Y+7	; 0x07
    1574:	a8 85       	ldd	r26, Y+8	; 0x08
    1576:	b9 85       	ldd	r27, Y+9	; 0x09
    1578:	89 2b       	or	r24, r25
    157a:	8a 2b       	or	r24, r26
    157c:	8b 2b       	or	r24, r27
    157e:	21 f4       	brne	.+8      	; 0x1588 <xQueueGenericReceive+0xc0>
    1580:	0f 90       	pop	r0
    1582:	0f be       	out	0x3f, r0	; 63
    1584:	80 e0       	ldi	r24, 0x00	; 0
    1586:	56 c0       	rjmp	.+172    	; 0x1634 <xQueueGenericReceive+0x16c>
    1588:	11 11       	cpse	r17, r1
    158a:	05 c0       	rjmp	.+10     	; 0x1596 <xQueueGenericReceive+0xce>
    158c:	ce 01       	movw	r24, r28
    158e:	01 96       	adiw	r24, 0x01	; 1
    1590:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vTaskSetTimeOutState>
    1594:	11 e0       	ldi	r17, 0x01	; 1
    1596:	0f 90       	pop	r0
    1598:	0f be       	out	0x3f, r0	; 63
    159a:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vTaskSuspendAll>
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	0f 92       	push	r0
    15a4:	f7 01       	movw	r30, r14
    15a6:	81 a1       	ldd	r24, Z+33	; 0x21
    15a8:	8f 3f       	cpi	r24, 0xFF	; 255
    15aa:	09 f4       	brne	.+2      	; 0x15ae <xQueueGenericReceive+0xe6>
    15ac:	11 a2       	std	Z+33, r1	; 0x21
    15ae:	f7 01       	movw	r30, r14
    15b0:	82 a1       	ldd	r24, Z+34	; 0x22
    15b2:	8f 3f       	cpi	r24, 0xFF	; 255
    15b4:	09 f4       	brne	.+2      	; 0x15b8 <xQueueGenericReceive+0xf0>
    15b6:	12 a2       	std	Z+34, r1	; 0x22
    15b8:	0f 90       	pop	r0
    15ba:	0f be       	out	0x3f, r0	; 63
    15bc:	be 01       	movw	r22, r28
    15be:	6a 5f       	subi	r22, 0xFA	; 250
    15c0:	7f 4f       	sbci	r23, 0xFF	; 255
    15c2:	ce 01       	movw	r24, r28
    15c4:	01 96       	adiw	r24, 0x01	; 1
    15c6:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <xTaskCheckForTimeOut>
    15ca:	81 11       	cpse	r24, r1
    15cc:	2d c0       	rjmp	.+90     	; 0x1628 <xQueueGenericReceive+0x160>
    15ce:	0f b6       	in	r0, 0x3f	; 63
    15d0:	f8 94       	cli
    15d2:	0f 92       	push	r0
    15d4:	f7 01       	movw	r30, r14
    15d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    15d8:	0f 90       	pop	r0
    15da:	0f be       	out	0x3f, r0	; 63
    15dc:	81 11       	cpse	r24, r1
    15de:	1e c0       	rjmp	.+60     	; 0x161c <xQueueGenericReceive+0x154>
    15e0:	80 81       	ld	r24, Z
    15e2:	91 81       	ldd	r25, Z+1	; 0x01
    15e4:	89 2b       	or	r24, r25
    15e6:	49 f4       	brne	.+18     	; 0x15fa <xQueueGenericReceive+0x132>
    15e8:	0f b6       	in	r0, 0x3f	; 63
    15ea:	f8 94       	cli
    15ec:	0f 92       	push	r0
    15ee:	82 81       	ldd	r24, Z+2	; 0x02
    15f0:	93 81       	ldd	r25, Z+3	; 0x03
    15f2:	0e 94 01 10 	call	0x2002	; 0x2002 <vTaskPriorityInherit>
    15f6:	0f 90       	pop	r0
    15f8:	0f be       	out	0x3f, r0	; 63
    15fa:	4e 81       	ldd	r20, Y+6	; 0x06
    15fc:	5f 81       	ldd	r21, Y+7	; 0x07
    15fe:	68 85       	ldd	r22, Y+8	; 0x08
    1600:	79 85       	ldd	r23, Y+9	; 0x09
    1602:	c6 01       	movw	r24, r12
    1604:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <vTaskPlaceOnEventList>
    1608:	c7 01       	movw	r24, r14
    160a:	0e 94 15 09 	call	0x122a	; 0x122a <prvUnlockQueue>
    160e:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
    1612:	81 11       	cpse	r24, r1
    1614:	73 cf       	rjmp	.-282    	; 0x14fc <xQueueGenericReceive+0x34>
    1616:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
    161a:	70 cf       	rjmp	.-288    	; 0x14fc <xQueueGenericReceive+0x34>
    161c:	c7 01       	movw	r24, r14
    161e:	0e 94 15 09 	call	0x122a	; 0x122a <prvUnlockQueue>
    1622:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
    1626:	6a cf       	rjmp	.-300    	; 0x14fc <xQueueGenericReceive+0x34>
    1628:	c7 01       	movw	r24, r14
    162a:	0e 94 15 09 	call	0x122a	; 0x122a <prvUnlockQueue>
    162e:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
    1632:	80 e0       	ldi	r24, 0x00	; 0
    1634:	29 96       	adiw	r28, 0x09	; 9
    1636:	cd bf       	out	0x3d, r28	; 61
    1638:	de bf       	out	0x3e, r29	; 62
    163a:	df 91       	pop	r29
    163c:	cf 91       	pop	r28
    163e:	1f 91       	pop	r17
    1640:	0f 91       	pop	r16
    1642:	ff 90       	pop	r15
    1644:	ef 90       	pop	r14
    1646:	df 90       	pop	r13
    1648:	cf 90       	pop	r12
    164a:	bf 90       	pop	r11
    164c:	af 90       	pop	r10
    164e:	08 95       	ret

00001650 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1650:	0f b6       	in	r0, 0x3f	; 63
    1652:	f8 94       	cli
    1654:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1656:	fc 01       	movw	r30, r24
    1658:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    165a:	0f 90       	pop	r0
    165c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    165e:	08 95       	ret

00001660 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1660:	c6 ed       	ldi	r28, 0xD6	; 214
    1662:	d0 e3       	ldi	r29, 0x30	; 48
    1664:	88 81       	ld	r24, Y
    1666:	82 30       	cpi	r24, 0x02	; 2
    1668:	e8 f3       	brcs	.-6      	; 0x1664 <prvIdleTask+0x4>
    166a:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
    166e:	fa cf       	rjmp	.-12     	; 0x1664 <prvIdleTask+0x4>

00001670 <prvAddCurrentTaskToDelayedList>:
    1670:	cf 92       	push	r12
    1672:	df 92       	push	r13
    1674:	ef 92       	push	r14
    1676:	ff 92       	push	r15
    1678:	6b 01       	movw	r12, r22
    167a:	7c 01       	movw	r14, r24
    167c:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxCurrentTCB>
    1680:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1684:	62 83       	std	Z+2, r22	; 0x02
    1686:	73 83       	std	Z+3, r23	; 0x03
    1688:	84 83       	std	Z+4, r24	; 0x04
    168a:	95 83       	std	Z+5, r25	; 0x05
    168c:	80 91 aa 30 	lds	r24, 0x30AA	; 0x8030aa <xTickCount>
    1690:	90 91 ab 30 	lds	r25, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1694:	a0 91 ac 30 	lds	r26, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1698:	b0 91 ad 30 	lds	r27, 0x30AD	; 0x8030ad <xTickCount+0x3>
    169c:	c8 16       	cp	r12, r24
    169e:	d9 06       	cpc	r13, r25
    16a0:	ea 06       	cpc	r14, r26
    16a2:	fb 06       	cpc	r15, r27
    16a4:	68 f4       	brcc	.+26     	; 0x16c0 <prvAddCurrentTaskToDelayedList+0x50>
    16a6:	60 91 02 31 	lds	r22, 0x3102	; 0x803102 <pxCurrentTCB>
    16aa:	70 91 03 31 	lds	r23, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    16ae:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <pxOverflowDelayedTaskList>
    16b2:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <pxOverflowDelayedTaskList+0x1>
    16b6:	6e 5f       	subi	r22, 0xFE	; 254
    16b8:	7f 4f       	sbci	r23, 0xFF	; 255
    16ba:	0e 94 c1 06 	call	0xd82	; 0xd82 <vListInsert>
    16be:	21 c0       	rjmp	.+66     	; 0x1702 <prvAddCurrentTaskToDelayedList+0x92>
    16c0:	60 91 02 31 	lds	r22, 0x3102	; 0x803102 <pxCurrentTCB>
    16c4:	70 91 03 31 	lds	r23, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    16c8:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <pxDelayedTaskList>
    16cc:	90 91 bf 30 	lds	r25, 0x30BF	; 0x8030bf <pxDelayedTaskList+0x1>
    16d0:	6e 5f       	subi	r22, 0xFE	; 254
    16d2:	7f 4f       	sbci	r23, 0xFF	; 255
    16d4:	0e 94 c1 06 	call	0xd82	; 0xd82 <vListInsert>
    16d8:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    16dc:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    16e0:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    16e4:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    16e8:	c8 16       	cp	r12, r24
    16ea:	d9 06       	cpc	r13, r25
    16ec:	ea 06       	cpc	r14, r26
    16ee:	fb 06       	cpc	r15, r27
    16f0:	40 f4       	brcc	.+16     	; 0x1702 <prvAddCurrentTaskToDelayedList+0x92>
    16f2:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    16f6:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    16fa:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    16fe:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1702:	ff 90       	pop	r15
    1704:	ef 90       	pop	r14
    1706:	df 90       	pop	r13
    1708:	cf 90       	pop	r12
    170a:	08 95       	ret

0000170c <xTaskGenericCreate>:
    170c:	4f 92       	push	r4
    170e:	5f 92       	push	r5
    1710:	6f 92       	push	r6
    1712:	7f 92       	push	r7
    1714:	8f 92       	push	r8
    1716:	9f 92       	push	r9
    1718:	af 92       	push	r10
    171a:	bf 92       	push	r11
    171c:	cf 92       	push	r12
    171e:	df 92       	push	r13
    1720:	ef 92       	push	r14
    1722:	ff 92       	push	r15
    1724:	0f 93       	push	r16
    1726:	1f 93       	push	r17
    1728:	cf 93       	push	r28
    172a:	df 93       	push	r29
    172c:	5c 01       	movw	r10, r24
    172e:	4b 01       	movw	r8, r22
    1730:	3a 01       	movw	r6, r20
    1732:	29 01       	movw	r4, r18
    1734:	88 e2       	ldi	r24, 0x28	; 40
    1736:	90 e0       	ldi	r25, 0x00	; 0
    1738:	0e 94 b3 05 	call	0xb66	; 0xb66 <pvPortMalloc>
    173c:	ec 01       	movw	r28, r24
    173e:	89 2b       	or	r24, r25
    1740:	09 f4       	brne	.+2      	; 0x1744 <xTaskGenericCreate+0x38>
    1742:	d4 c0       	rjmp	.+424    	; 0x18ec <xTaskGenericCreate+0x1e0>
    1744:	c1 14       	cp	r12, r1
    1746:	d1 04       	cpc	r13, r1
    1748:	09 f0       	breq	.+2      	; 0x174c <xTaskGenericCreate+0x40>
    174a:	cc c0       	rjmp	.+408    	; 0x18e4 <xTaskGenericCreate+0x1d8>
    174c:	c3 01       	movw	r24, r6
    174e:	0e 94 b3 05 	call	0xb66	; 0xb66 <pvPortMalloc>
    1752:	8b 8f       	std	Y+27, r24	; 0x1b
    1754:	9c 8f       	std	Y+28, r25	; 0x1c
    1756:	00 97       	sbiw	r24, 0x00	; 0
    1758:	21 f4       	brne	.+8      	; 0x1762 <xTaskGenericCreate+0x56>
    175a:	ce 01       	movw	r24, r28
    175c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <vPortFree>
    1760:	c5 c0       	rjmp	.+394    	; 0x18ec <xTaskGenericCreate+0x1e0>
    1762:	a3 01       	movw	r20, r6
    1764:	61 e1       	ldi	r22, 0x11	; 17
    1766:	70 e0       	ldi	r23, 0x00	; 0
    1768:	0e 94 45 1c 	call	0x388a	; 0x388a <memset>
    176c:	93 01       	movw	r18, r6
    176e:	21 50       	subi	r18, 0x01	; 1
    1770:	31 09       	sbc	r19, r1
    1772:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1774:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1776:	3c 01       	movw	r6, r24
    1778:	62 0e       	add	r6, r18
    177a:	73 1e       	adc	r7, r19
    177c:	4a e0       	ldi	r20, 0x0A	; 10
    177e:	50 e0       	ldi	r21, 0x00	; 0
    1780:	b4 01       	movw	r22, r8
    1782:	ce 01       	movw	r24, r28
    1784:	4d 96       	adiw	r24, 0x1d	; 29
    1786:	0e 94 4c 1c 	call	0x3898	; 0x3898 <strncpy>
    178a:	1e a2       	std	Y+38, r1	; 0x26
    178c:	10 2f       	mov	r17, r16
    178e:	04 30       	cpi	r16, 0x04	; 4
    1790:	08 f0       	brcs	.+2      	; 0x1794 <xTaskGenericCreate+0x88>
    1792:	13 e0       	ldi	r17, 0x03	; 3
    1794:	1a 8f       	std	Y+26, r17	; 0x1a
    1796:	1f a3       	std	Y+39, r17	; 0x27
    1798:	6e 01       	movw	r12, r28
    179a:	22 e0       	ldi	r18, 0x02	; 2
    179c:	c2 0e       	add	r12, r18
    179e:	d1 1c       	adc	r13, r1
    17a0:	c6 01       	movw	r24, r12
    17a2:	0e 94 96 06 	call	0xd2c	; 0xd2c <vListInitialiseItem>
    17a6:	ce 01       	movw	r24, r28
    17a8:	0e 96       	adiw	r24, 0x0e	; 14
    17aa:	0e 94 96 06 	call	0xd2c	; 0xd2c <vListInitialiseItem>
    17ae:	ca 87       	std	Y+10, r28	; 0x0a
    17b0:	db 87       	std	Y+11, r29	; 0x0b
    17b2:	84 e0       	ldi	r24, 0x04	; 4
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	a0 e0       	ldi	r26, 0x00	; 0
    17b8:	b0 e0       	ldi	r27, 0x00	; 0
    17ba:	81 1b       	sub	r24, r17
    17bc:	91 09       	sbc	r25, r1
    17be:	a1 09       	sbc	r26, r1
    17c0:	b1 09       	sbc	r27, r1
    17c2:	8e 87       	std	Y+14, r24	; 0x0e
    17c4:	9f 87       	std	Y+15, r25	; 0x0f
    17c6:	a8 8b       	std	Y+16, r26	; 0x10
    17c8:	b9 8b       	std	Y+17, r27	; 0x11
    17ca:	ce 8b       	std	Y+22, r28	; 0x16
    17cc:	df 8b       	std	Y+23, r29	; 0x17
    17ce:	a2 01       	movw	r20, r4
    17d0:	b5 01       	movw	r22, r10
    17d2:	c3 01       	movw	r24, r6
    17d4:	0e 94 32 07 	call	0xe64	; 0xe64 <pxPortInitialiseStack>
    17d8:	88 83       	st	Y, r24
    17da:	99 83       	std	Y+1, r25	; 0x01
    17dc:	e1 14       	cp	r14, r1
    17de:	f1 04       	cpc	r15, r1
    17e0:	19 f0       	breq	.+6      	; 0x17e8 <xTaskGenericCreate+0xdc>
    17e2:	f7 01       	movw	r30, r14
    17e4:	c0 83       	st	Z, r28
    17e6:	d1 83       	std	Z+1, r29	; 0x01
    17e8:	0f b6       	in	r0, 0x3f	; 63
    17ea:	f8 94       	cli
    17ec:	0f 92       	push	r0
    17ee:	80 91 ae 30 	lds	r24, 0x30AE	; 0x8030ae <uxCurrentNumberOfTasks>
    17f2:	8f 5f       	subi	r24, 0xFF	; 255
    17f4:	80 93 ae 30 	sts	0x30AE, r24	; 0x8030ae <uxCurrentNumberOfTasks>
    17f8:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxCurrentTCB>
    17fc:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1800:	89 2b       	or	r24, r25
    1802:	89 f5       	brne	.+98     	; 0x1866 <xTaskGenericCreate+0x15a>
    1804:	c0 93 02 31 	sts	0x3102, r28	; 0x803102 <pxCurrentTCB>
    1808:	d0 93 03 31 	sts	0x3103, r29	; 0x803103 <pxCurrentTCB+0x1>
    180c:	80 91 ae 30 	lds	r24, 0x30AE	; 0x8030ae <uxCurrentNumberOfTasks>
    1810:	81 30       	cpi	r24, 0x01	; 1
    1812:	c1 f5       	brne	.+112    	; 0x1884 <xTaskGenericCreate+0x178>
    1814:	86 ed       	ldi	r24, 0xD6	; 214
    1816:	90 e3       	ldi	r25, 0x30	; 48
    1818:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    181c:	81 ee       	ldi	r24, 0xE1	; 225
    181e:	90 e3       	ldi	r25, 0x30	; 48
    1820:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    1824:	8c ee       	ldi	r24, 0xEC	; 236
    1826:	90 e3       	ldi	r25, 0x30	; 48
    1828:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    182c:	87 ef       	ldi	r24, 0xF7	; 247
    182e:	90 e3       	ldi	r25, 0x30	; 48
    1830:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    1834:	8b ec       	ldi	r24, 0xCB	; 203
    1836:	90 e3       	ldi	r25, 0x30	; 48
    1838:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    183c:	80 ec       	ldi	r24, 0xC0	; 192
    183e:	90 e3       	ldi	r25, 0x30	; 48
    1840:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    1844:	81 eb       	ldi	r24, 0xB1	; 177
    1846:	90 e3       	ldi	r25, 0x30	; 48
    1848:	0e 94 85 06 	call	0xd0a	; 0xd0a <vListInitialise>
    184c:	8b ec       	ldi	r24, 0xCB	; 203
    184e:	90 e3       	ldi	r25, 0x30	; 48
    1850:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <pxDelayedTaskList>
    1854:	90 93 bf 30 	sts	0x30BF, r25	; 0x8030bf <pxDelayedTaskList+0x1>
    1858:	80 ec       	ldi	r24, 0xC0	; 192
    185a:	90 e3       	ldi	r25, 0x30	; 48
    185c:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <pxOverflowDelayedTaskList>
    1860:	90 93 bd 30 	sts	0x30BD, r25	; 0x8030bd <pxOverflowDelayedTaskList+0x1>
    1864:	0f c0       	rjmp	.+30     	; 0x1884 <xTaskGenericCreate+0x178>
    1866:	80 91 a7 30 	lds	r24, 0x30A7	; 0x8030a7 <xSchedulerRunning>
    186a:	81 11       	cpse	r24, r1
    186c:	0b c0       	rjmp	.+22     	; 0x1884 <xTaskGenericCreate+0x178>
    186e:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxCurrentTCB>
    1872:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1876:	82 8d       	ldd	r24, Z+26	; 0x1a
    1878:	08 17       	cp	r16, r24
    187a:	20 f0       	brcs	.+8      	; 0x1884 <xTaskGenericCreate+0x178>
    187c:	c0 93 02 31 	sts	0x3102, r28	; 0x803102 <pxCurrentTCB>
    1880:	d0 93 03 31 	sts	0x3103, r29	; 0x803103 <pxCurrentTCB+0x1>
    1884:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1886:	90 91 a9 30 	lds	r25, 0x30A9	; 0x8030a9 <uxTopUsedPriority>
    188a:	98 17       	cp	r25, r24
    188c:	10 f4       	brcc	.+4      	; 0x1892 <xTaskGenericCreate+0x186>
    188e:	80 93 a9 30 	sts	0x30A9, r24	; 0x8030a9 <uxTopUsedPriority>
    1892:	90 91 a2 30 	lds	r25, 0x30A2	; 0x8030a2 <uxTaskNumber>
    1896:	9f 5f       	subi	r25, 0xFF	; 255
    1898:	90 93 a2 30 	sts	0x30A2, r25	; 0x8030a2 <uxTaskNumber>
    189c:	90 91 a8 30 	lds	r25, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    18a0:	98 17       	cp	r25, r24
    18a2:	10 f4       	brcc	.+4      	; 0x18a8 <xTaskGenericCreate+0x19c>
    18a4:	80 93 a8 30 	sts	0x30A8, r24	; 0x8030a8 <uxTopReadyPriority>
    18a8:	fb e0       	ldi	r31, 0x0B	; 11
    18aa:	8f 9f       	mul	r24, r31
    18ac:	c0 01       	movw	r24, r0
    18ae:	11 24       	eor	r1, r1
    18b0:	b6 01       	movw	r22, r12
    18b2:	8a 52       	subi	r24, 0x2A	; 42
    18b4:	9f 4c       	sbci	r25, 0xCF	; 207
    18b6:	0e 94 9a 06 	call	0xd34	; 0xd34 <vListInsertEnd>
    18ba:	0f 90       	pop	r0
    18bc:	0f be       	out	0x3f, r0	; 63
    18be:	80 91 a7 30 	lds	r24, 0x30A7	; 0x8030a7 <xSchedulerRunning>
    18c2:	88 23       	and	r24, r24
    18c4:	59 f0       	breq	.+22     	; 0x18dc <xTaskGenericCreate+0x1d0>
    18c6:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxCurrentTCB>
    18ca:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    18ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    18d0:	80 17       	cp	r24, r16
    18d2:	30 f4       	brcc	.+12     	; 0x18e0 <xTaskGenericCreate+0x1d4>
    18d4:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
    18d8:	81 e0       	ldi	r24, 0x01	; 1
    18da:	09 c0       	rjmp	.+18     	; 0x18ee <xTaskGenericCreate+0x1e2>
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	07 c0       	rjmp	.+14     	; 0x18ee <xTaskGenericCreate+0x1e2>
    18e0:	81 e0       	ldi	r24, 0x01	; 1
    18e2:	05 c0       	rjmp	.+10     	; 0x18ee <xTaskGenericCreate+0x1e2>
    18e4:	cb 8e       	std	Y+27, r12	; 0x1b
    18e6:	dc 8e       	std	Y+28, r13	; 0x1c
    18e8:	c6 01       	movw	r24, r12
    18ea:	3b cf       	rjmp	.-394    	; 0x1762 <xTaskGenericCreate+0x56>
    18ec:	8f ef       	ldi	r24, 0xFF	; 255
    18ee:	df 91       	pop	r29
    18f0:	cf 91       	pop	r28
    18f2:	1f 91       	pop	r17
    18f4:	0f 91       	pop	r16
    18f6:	ff 90       	pop	r15
    18f8:	ef 90       	pop	r14
    18fa:	df 90       	pop	r13
    18fc:	cf 90       	pop	r12
    18fe:	bf 90       	pop	r11
    1900:	af 90       	pop	r10
    1902:	9f 90       	pop	r9
    1904:	8f 90       	pop	r8
    1906:	7f 90       	pop	r7
    1908:	6f 90       	pop	r6
    190a:	5f 90       	pop	r5
    190c:	4f 90       	pop	r4
    190e:	08 95       	ret

00001910 <uxTaskPriorityGet>:
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	0f 92       	push	r0
    1916:	00 97       	sbiw	r24, 0x00	; 0
    1918:	21 f4       	brne	.+8      	; 0x1922 <uxTaskPriorityGet+0x12>
    191a:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxCurrentTCB>
    191e:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
    1926:	fc 01       	movw	r30, r24
    1928:	82 8d       	ldd	r24, Z+26	; 0x1a
    192a:	08 95       	ret

0000192c <vTaskStartScheduler>:
    192c:	af 92       	push	r10
    192e:	bf 92       	push	r11
    1930:	cf 92       	push	r12
    1932:	df 92       	push	r13
    1934:	ef 92       	push	r14
    1936:	ff 92       	push	r15
    1938:	0f 93       	push	r16
    193a:	a1 2c       	mov	r10, r1
    193c:	b1 2c       	mov	r11, r1
    193e:	c1 2c       	mov	r12, r1
    1940:	d1 2c       	mov	r13, r1
    1942:	0f 2e       	mov	r0, r31
    1944:	ff ea       	ldi	r31, 0xAF	; 175
    1946:	ef 2e       	mov	r14, r31
    1948:	f0 e3       	ldi	r31, 0x30	; 48
    194a:	ff 2e       	mov	r15, r31
    194c:	f0 2d       	mov	r31, r0
    194e:	00 e0       	ldi	r16, 0x00	; 0
    1950:	20 e0       	ldi	r18, 0x00	; 0
    1952:	30 e0       	ldi	r19, 0x00	; 0
    1954:	44 e6       	ldi	r20, 0x64	; 100
    1956:	50 e0       	ldi	r21, 0x00	; 0
    1958:	66 e1       	ldi	r22, 0x16	; 22
    195a:	70 e2       	ldi	r23, 0x20	; 32
    195c:	80 e3       	ldi	r24, 0x30	; 48
    195e:	9b e0       	ldi	r25, 0x0B	; 11
    1960:	0e 94 86 0b 	call	0x170c	; 0x170c <xTaskGenericCreate>
    1964:	81 30       	cpi	r24, 0x01	; 1
    1966:	69 f4       	brne	.+26     	; 0x1982 <vTaskStartScheduler+0x56>
    1968:	f8 94       	cli
    196a:	80 93 a7 30 	sts	0x30A7, r24	; 0x8030a7 <xSchedulerRunning>
    196e:	10 92 aa 30 	sts	0x30AA, r1	; 0x8030aa <xTickCount>
    1972:	10 92 ab 30 	sts	0x30AB, r1	; 0x8030ab <xTickCount+0x1>
    1976:	10 92 ac 30 	sts	0x30AC, r1	; 0x8030ac <xTickCount+0x2>
    197a:	10 92 ad 30 	sts	0x30AD, r1	; 0x8030ad <xTickCount+0x3>
    197e:	0e 94 a8 07 	call	0xf50	; 0xf50 <xPortStartScheduler>
    1982:	0f 91       	pop	r16
    1984:	ff 90       	pop	r15
    1986:	ef 90       	pop	r14
    1988:	df 90       	pop	r13
    198a:	cf 90       	pop	r12
    198c:	bf 90       	pop	r11
    198e:	af 90       	pop	r10
    1990:	08 95       	ret

00001992 <vTaskSuspendAll>:
    1992:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxSchedulerSuspended>
    1996:	8f 5f       	subi	r24, 0xFF	; 255
    1998:	80 93 a6 30 	sts	0x30A6, r24	; 0x8030a6 <uxSchedulerSuspended>
    199c:	08 95       	ret

0000199e <xTaskGetTickCount>:
    199e:	0f b6       	in	r0, 0x3f	; 63
    19a0:	f8 94       	cli
    19a2:	0f 92       	push	r0
    19a4:	60 91 aa 30 	lds	r22, 0x30AA	; 0x8030aa <xTickCount>
    19a8:	70 91 ab 30 	lds	r23, 0x30AB	; 0x8030ab <xTickCount+0x1>
    19ac:	80 91 ac 30 	lds	r24, 0x30AC	; 0x8030ac <xTickCount+0x2>
    19b0:	90 91 ad 30 	lds	r25, 0x30AD	; 0x8030ad <xTickCount+0x3>
    19b4:	0f 90       	pop	r0
    19b6:	0f be       	out	0x3f, r0	; 63
    19b8:	08 95       	ret

000019ba <pcTaskGetTaskName>:
    19ba:	00 97       	sbiw	r24, 0x00	; 0
    19bc:	21 f4       	brne	.+8      	; 0x19c6 <pcTaskGetTaskName+0xc>
    19be:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxCurrentTCB>
    19c2:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    19c6:	4d 96       	adiw	r24, 0x1d	; 29
    19c8:	08 95       	ret

000019ca <xTaskGetIdleTaskHandle>:
    19ca:	80 91 af 30 	lds	r24, 0x30AF	; 0x8030af <xIdleTaskHandle>
    19ce:	90 91 b0 30 	lds	r25, 0x30B0	; 0x8030b0 <xIdleTaskHandle+0x1>
    19d2:	08 95       	ret

000019d4 <vTaskIncrementTick>:
    19d4:	ff 92       	push	r15
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	cf 93       	push	r28
    19dc:	df 93       	push	r29
    19de:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxSchedulerSuspended>
    19e2:	81 11       	cpse	r24, r1
    19e4:	ed c0       	rjmp	.+474    	; 0x1bc0 <vTaskIncrementTick+0x1ec>
    19e6:	80 91 aa 30 	lds	r24, 0x30AA	; 0x8030aa <xTickCount>
    19ea:	90 91 ab 30 	lds	r25, 0x30AB	; 0x8030ab <xTickCount+0x1>
    19ee:	a0 91 ac 30 	lds	r26, 0x30AC	; 0x8030ac <xTickCount+0x2>
    19f2:	b0 91 ad 30 	lds	r27, 0x30AD	; 0x8030ad <xTickCount+0x3>
    19f6:	01 96       	adiw	r24, 0x01	; 1
    19f8:	a1 1d       	adc	r26, r1
    19fa:	b1 1d       	adc	r27, r1
    19fc:	80 93 aa 30 	sts	0x30AA, r24	; 0x8030aa <xTickCount>
    1a00:	90 93 ab 30 	sts	0x30AB, r25	; 0x8030ab <xTickCount+0x1>
    1a04:	a0 93 ac 30 	sts	0x30AC, r26	; 0x8030ac <xTickCount+0x2>
    1a08:	b0 93 ad 30 	sts	0x30AD, r27	; 0x8030ad <xTickCount+0x3>
    1a0c:	80 91 aa 30 	lds	r24, 0x30AA	; 0x8030aa <xTickCount>
    1a10:	90 91 ab 30 	lds	r25, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1a14:	a0 91 ac 30 	lds	r26, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1a18:	b0 91 ad 30 	lds	r27, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1a1c:	89 2b       	or	r24, r25
    1a1e:	8a 2b       	or	r24, r26
    1a20:	8b 2b       	or	r24, r27
    1a22:	f1 f5       	brne	.+124    	; 0x1aa0 <vTaskIncrementTick+0xcc>
    1a24:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <pxDelayedTaskList>
    1a28:	90 91 bf 30 	lds	r25, 0x30BF	; 0x8030bf <pxDelayedTaskList+0x1>
    1a2c:	20 91 bc 30 	lds	r18, 0x30BC	; 0x8030bc <pxOverflowDelayedTaskList>
    1a30:	30 91 bd 30 	lds	r19, 0x30BD	; 0x8030bd <pxOverflowDelayedTaskList+0x1>
    1a34:	20 93 be 30 	sts	0x30BE, r18	; 0x8030be <pxDelayedTaskList>
    1a38:	30 93 bf 30 	sts	0x30BF, r19	; 0x8030bf <pxDelayedTaskList+0x1>
    1a3c:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <pxOverflowDelayedTaskList>
    1a40:	90 93 bd 30 	sts	0x30BD, r25	; 0x8030bd <pxOverflowDelayedTaskList+0x1>
    1a44:	80 91 a3 30 	lds	r24, 0x30A3	; 0x8030a3 <xNumOfOverflows>
    1a48:	8f 5f       	subi	r24, 0xFF	; 255
    1a4a:	80 93 a3 30 	sts	0x30A3, r24	; 0x8030a3 <xNumOfOverflows>
    1a4e:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <pxDelayedTaskList>
    1a52:	f0 91 bf 30 	lds	r31, 0x30BF	; 0x8030bf <pxDelayedTaskList+0x1>
    1a56:	80 81       	ld	r24, Z
    1a58:	81 11       	cpse	r24, r1
    1a5a:	0c c0       	rjmp	.+24     	; 0x1a74 <vTaskIncrementTick+0xa0>
    1a5c:	8f ef       	ldi	r24, 0xFF	; 255
    1a5e:	9f ef       	ldi	r25, 0xFF	; 255
    1a60:	dc 01       	movw	r26, r24
    1a62:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1a66:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1a6a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1a6e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1a72:	16 c0       	rjmp	.+44     	; 0x1aa0 <vTaskIncrementTick+0xcc>
    1a74:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <pxDelayedTaskList>
    1a78:	f0 91 bf 30 	lds	r31, 0x30BF	; 0x8030bf <pxDelayedTaskList+0x1>
    1a7c:	07 80       	ldd	r0, Z+7	; 0x07
    1a7e:	f0 85       	ldd	r31, Z+8	; 0x08
    1a80:	e0 2d       	mov	r30, r0
    1a82:	00 84       	ldd	r0, Z+8	; 0x08
    1a84:	f1 85       	ldd	r31, Z+9	; 0x09
    1a86:	e0 2d       	mov	r30, r0
    1a88:	82 81       	ldd	r24, Z+2	; 0x02
    1a8a:	93 81       	ldd	r25, Z+3	; 0x03
    1a8c:	a4 81       	ldd	r26, Z+4	; 0x04
    1a8e:	b5 81       	ldd	r27, Z+5	; 0x05
    1a90:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1a94:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1a98:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1a9c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1aa0:	40 91 aa 30 	lds	r20, 0x30AA	; 0x8030aa <xTickCount>
    1aa4:	50 91 ab 30 	lds	r21, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1aa8:	60 91 ac 30 	lds	r22, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1aac:	70 91 ad 30 	lds	r23, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1ab0:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1ab4:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ab8:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1abc:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1ac0:	48 17       	cp	r20, r24
    1ac2:	59 07       	cpc	r21, r25
    1ac4:	6a 07       	cpc	r22, r26
    1ac6:	7b 07       	cpc	r23, r27
    1ac8:	08 f4       	brcc	.+2      	; 0x1acc <vTaskIncrementTick+0xf8>
    1aca:	7f c0       	rjmp	.+254    	; 0x1bca <vTaskIncrementTick+0x1f6>
    1acc:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <pxDelayedTaskList>
    1ad0:	f0 91 bf 30 	lds	r31, 0x30BF	; 0x8030bf <pxDelayedTaskList+0x1>
    1ad4:	80 81       	ld	r24, Z
    1ad6:	88 23       	and	r24, r24
    1ad8:	f9 f0       	breq	.+62     	; 0x1b18 <vTaskIncrementTick+0x144>
    1ada:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <pxDelayedTaskList>
    1ade:	f0 91 bf 30 	lds	r31, 0x30BF	; 0x8030bf <pxDelayedTaskList+0x1>
    1ae2:	07 80       	ldd	r0, Z+7	; 0x07
    1ae4:	f0 85       	ldd	r31, Z+8	; 0x08
    1ae6:	e0 2d       	mov	r30, r0
    1ae8:	c0 85       	ldd	r28, Z+8	; 0x08
    1aea:	d1 85       	ldd	r29, Z+9	; 0x09
    1aec:	8a 81       	ldd	r24, Y+2	; 0x02
    1aee:	9b 81       	ldd	r25, Y+3	; 0x03
    1af0:	ac 81       	ldd	r26, Y+4	; 0x04
    1af2:	bd 81       	ldd	r27, Y+5	; 0x05
    1af4:	40 91 aa 30 	lds	r20, 0x30AA	; 0x8030aa <xTickCount>
    1af8:	50 91 ab 30 	lds	r21, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1afc:	60 91 ac 30 	lds	r22, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1b00:	70 91 ad 30 	lds	r23, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1b04:	48 17       	cp	r20, r24
    1b06:	59 07       	cpc	r21, r25
    1b08:	6a 07       	cpc	r22, r26
    1b0a:	7b 07       	cpc	r23, r27
    1b0c:	58 f1       	brcs	.+86     	; 0x1b64 <vTaskIncrementTick+0x190>
    1b0e:	0f 2e       	mov	r0, r31
    1b10:	fb e0       	ldi	r31, 0x0B	; 11
    1b12:	ff 2e       	mov	r15, r31
    1b14:	f0 2d       	mov	r31, r0
    1b16:	2f c0       	rjmp	.+94     	; 0x1b76 <vTaskIncrementTick+0x1a2>
    1b18:	8f ef       	ldi	r24, 0xFF	; 255
    1b1a:	9f ef       	ldi	r25, 0xFF	; 255
    1b1c:	dc 01       	movw	r26, r24
    1b1e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1b22:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1b26:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1b2a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1b2e:	4d c0       	rjmp	.+154    	; 0x1bca <vTaskIncrementTick+0x1f6>
    1b30:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <pxDelayedTaskList>
    1b34:	f0 91 bf 30 	lds	r31, 0x30BF	; 0x8030bf <pxDelayedTaskList+0x1>
    1b38:	07 80       	ldd	r0, Z+7	; 0x07
    1b3a:	f0 85       	ldd	r31, Z+8	; 0x08
    1b3c:	e0 2d       	mov	r30, r0
    1b3e:	c0 85       	ldd	r28, Z+8	; 0x08
    1b40:	d1 85       	ldd	r29, Z+9	; 0x09
    1b42:	8a 81       	ldd	r24, Y+2	; 0x02
    1b44:	9b 81       	ldd	r25, Y+3	; 0x03
    1b46:	ac 81       	ldd	r26, Y+4	; 0x04
    1b48:	bd 81       	ldd	r27, Y+5	; 0x05
    1b4a:	40 91 aa 30 	lds	r20, 0x30AA	; 0x8030aa <xTickCount>
    1b4e:	50 91 ab 30 	lds	r21, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1b52:	60 91 ac 30 	lds	r22, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1b56:	70 91 ad 30 	lds	r23, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1b5a:	48 17       	cp	r20, r24
    1b5c:	59 07       	cpc	r21, r25
    1b5e:	6a 07       	cpc	r22, r26
    1b60:	7b 07       	cpc	r23, r27
    1b62:	48 f4       	brcc	.+18     	; 0x1b76 <vTaskIncrementTick+0x1a2>
    1b64:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1b68:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1b6c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1b70:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1b74:	2a c0       	rjmp	.+84     	; 0x1bca <vTaskIncrementTick+0x1f6>
    1b76:	8e 01       	movw	r16, r28
    1b78:	0e 5f       	subi	r16, 0xFE	; 254
    1b7a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b7c:	c8 01       	movw	r24, r16
    1b7e:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>
    1b82:	88 8d       	ldd	r24, Y+24	; 0x18
    1b84:	99 8d       	ldd	r25, Y+25	; 0x19
    1b86:	89 2b       	or	r24, r25
    1b88:	21 f0       	breq	.+8      	; 0x1b92 <vTaskIncrementTick+0x1be>
    1b8a:	ce 01       	movw	r24, r28
    1b8c:	0e 96       	adiw	r24, 0x0e	; 14
    1b8e:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>
    1b92:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b94:	90 91 a8 30 	lds	r25, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    1b98:	98 17       	cp	r25, r24
    1b9a:	10 f4       	brcc	.+4      	; 0x1ba0 <vTaskIncrementTick+0x1cc>
    1b9c:	80 93 a8 30 	sts	0x30A8, r24	; 0x8030a8 <uxTopReadyPriority>
    1ba0:	f8 9e       	mul	r15, r24
    1ba2:	c0 01       	movw	r24, r0
    1ba4:	11 24       	eor	r1, r1
    1ba6:	b8 01       	movw	r22, r16
    1ba8:	8a 52       	subi	r24, 0x2A	; 42
    1baa:	9f 4c       	sbci	r25, 0xCF	; 207
    1bac:	0e 94 9a 06 	call	0xd34	; 0xd34 <vListInsertEnd>
    1bb0:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <pxDelayedTaskList>
    1bb4:	f0 91 bf 30 	lds	r31, 0x30BF	; 0x8030bf <pxDelayedTaskList+0x1>
    1bb8:	80 81       	ld	r24, Z
    1bba:	81 11       	cpse	r24, r1
    1bbc:	b9 cf       	rjmp	.-142    	; 0x1b30 <vTaskIncrementTick+0x15c>
    1bbe:	ac cf       	rjmp	.-168    	; 0x1b18 <vTaskIncrementTick+0x144>
    1bc0:	80 91 a5 30 	lds	r24, 0x30A5	; 0x8030a5 <uxMissedTicks>
    1bc4:	8f 5f       	subi	r24, 0xFF	; 255
    1bc6:	80 93 a5 30 	sts	0x30A5, r24	; 0x8030a5 <uxMissedTicks>
    1bca:	df 91       	pop	r29
    1bcc:	cf 91       	pop	r28
    1bce:	1f 91       	pop	r17
    1bd0:	0f 91       	pop	r16
    1bd2:	ff 90       	pop	r15
    1bd4:	08 95       	ret

00001bd6 <xTaskResumeAll>:
    1bd6:	cf 92       	push	r12
    1bd8:	df 92       	push	r13
    1bda:	ef 92       	push	r14
    1bdc:	ff 92       	push	r15
    1bde:	0f 93       	push	r16
    1be0:	1f 93       	push	r17
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	0f b6       	in	r0, 0x3f	; 63
    1be8:	f8 94       	cli
    1bea:	0f 92       	push	r0
    1bec:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxSchedulerSuspended>
    1bf0:	81 50       	subi	r24, 0x01	; 1
    1bf2:	80 93 a6 30 	sts	0x30A6, r24	; 0x8030a6 <uxSchedulerSuspended>
    1bf6:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxSchedulerSuspended>
    1bfa:	81 11       	cpse	r24, r1
    1bfc:	60 c0       	rjmp	.+192    	; 0x1cbe <xTaskResumeAll+0xe8>
    1bfe:	80 91 ae 30 	lds	r24, 0x30AE	; 0x8030ae <uxCurrentNumberOfTasks>
    1c02:	81 11       	cpse	r24, r1
    1c04:	2c c0       	rjmp	.+88     	; 0x1c5e <xTaskResumeAll+0x88>
    1c06:	5e c0       	rjmp	.+188    	; 0x1cc4 <xTaskResumeAll+0xee>
    1c08:	d7 01       	movw	r26, r14
    1c0a:	17 96       	adiw	r26, 0x07	; 7
    1c0c:	ed 91       	ld	r30, X+
    1c0e:	fc 91       	ld	r31, X
    1c10:	18 97       	sbiw	r26, 0x08	; 8
    1c12:	c0 85       	ldd	r28, Z+8	; 0x08
    1c14:	d1 85       	ldd	r29, Z+9	; 0x09
    1c16:	ce 01       	movw	r24, r28
    1c18:	0e 96       	adiw	r24, 0x0e	; 14
    1c1a:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>
    1c1e:	8e 01       	movw	r16, r28
    1c20:	0e 5f       	subi	r16, 0xFE	; 254
    1c22:	1f 4f       	sbci	r17, 0xFF	; 255
    1c24:	c8 01       	movw	r24, r16
    1c26:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>
    1c2a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c2c:	90 91 a8 30 	lds	r25, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    1c30:	98 17       	cp	r25, r24
    1c32:	10 f4       	brcc	.+4      	; 0x1c38 <xTaskResumeAll+0x62>
    1c34:	80 93 a8 30 	sts	0x30A8, r24	; 0x8030a8 <uxTopReadyPriority>
    1c38:	d8 9e       	mul	r13, r24
    1c3a:	c0 01       	movw	r24, r0
    1c3c:	11 24       	eor	r1, r1
    1c3e:	b8 01       	movw	r22, r16
    1c40:	8a 52       	subi	r24, 0x2A	; 42
    1c42:	9f 4c       	sbci	r25, 0xCF	; 207
    1c44:	0e 94 9a 06 	call	0xd34	; 0xd34 <vListInsertEnd>
    1c48:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxCurrentTCB>
    1c4c:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1c50:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c52:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c54:	98 17       	cp	r25, r24
    1c56:	70 f0       	brcs	.+28     	; 0x1c74 <xTaskResumeAll+0x9e>
    1c58:	cc 24       	eor	r12, r12
    1c5a:	c3 94       	inc	r12
    1c5c:	0b c0       	rjmp	.+22     	; 0x1c74 <xTaskResumeAll+0x9e>
    1c5e:	c1 2c       	mov	r12, r1
    1c60:	0f 2e       	mov	r0, r31
    1c62:	f1 eb       	ldi	r31, 0xB1	; 177
    1c64:	ef 2e       	mov	r14, r31
    1c66:	f0 e3       	ldi	r31, 0x30	; 48
    1c68:	ff 2e       	mov	r15, r31
    1c6a:	f0 2d       	mov	r31, r0
    1c6c:	0f 2e       	mov	r0, r31
    1c6e:	fb e0       	ldi	r31, 0x0B	; 11
    1c70:	df 2e       	mov	r13, r31
    1c72:	f0 2d       	mov	r31, r0
    1c74:	f7 01       	movw	r30, r14
    1c76:	80 81       	ld	r24, Z
    1c78:	81 11       	cpse	r24, r1
    1c7a:	c6 cf       	rjmp	.-116    	; 0x1c08 <xTaskResumeAll+0x32>
    1c7c:	80 91 a5 30 	lds	r24, 0x30A5	; 0x8030a5 <uxMissedTicks>
    1c80:	88 23       	and	r24, r24
    1c82:	81 f0       	breq	.+32     	; 0x1ca4 <xTaskResumeAll+0xce>
    1c84:	80 91 a5 30 	lds	r24, 0x30A5	; 0x8030a5 <uxMissedTicks>
    1c88:	88 23       	and	r24, r24
    1c8a:	99 f0       	breq	.+38     	; 0x1cb2 <xTaskResumeAll+0xdc>
    1c8c:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vTaskIncrementTick>
    1c90:	80 91 a5 30 	lds	r24, 0x30A5	; 0x8030a5 <uxMissedTicks>
    1c94:	81 50       	subi	r24, 0x01	; 1
    1c96:	80 93 a5 30 	sts	0x30A5, r24	; 0x8030a5 <uxMissedTicks>
    1c9a:	80 91 a5 30 	lds	r24, 0x30A5	; 0x8030a5 <uxMissedTicks>
    1c9e:	81 11       	cpse	r24, r1
    1ca0:	f5 cf       	rjmp	.-22     	; 0x1c8c <xTaskResumeAll+0xb6>
    1ca2:	07 c0       	rjmp	.+14     	; 0x1cb2 <xTaskResumeAll+0xdc>
    1ca4:	f1 e0       	ldi	r31, 0x01	; 1
    1ca6:	cf 16       	cp	r12, r31
    1ca8:	21 f0       	breq	.+8      	; 0x1cb2 <xTaskResumeAll+0xdc>
    1caa:	80 91 a4 30 	lds	r24, 0x30A4	; 0x8030a4 <xMissedYield>
    1cae:	81 30       	cpi	r24, 0x01	; 1
    1cb0:	41 f4       	brne	.+16     	; 0x1cc2 <xTaskResumeAll+0xec>
    1cb2:	10 92 a4 30 	sts	0x30A4, r1	; 0x8030a4 <xMissedYield>
    1cb6:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
    1cba:	81 e0       	ldi	r24, 0x01	; 1
    1cbc:	03 c0       	rjmp	.+6      	; 0x1cc4 <xTaskResumeAll+0xee>
    1cbe:	80 e0       	ldi	r24, 0x00	; 0
    1cc0:	01 c0       	rjmp	.+2      	; 0x1cc4 <xTaskResumeAll+0xee>
    1cc2:	80 e0       	ldi	r24, 0x00	; 0
    1cc4:	0f 90       	pop	r0
    1cc6:	0f be       	out	0x3f, r0	; 63
    1cc8:	df 91       	pop	r29
    1cca:	cf 91       	pop	r28
    1ccc:	1f 91       	pop	r17
    1cce:	0f 91       	pop	r16
    1cd0:	ff 90       	pop	r15
    1cd2:	ef 90       	pop	r14
    1cd4:	df 90       	pop	r13
    1cd6:	cf 90       	pop	r12
    1cd8:	08 95       	ret

00001cda <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1cda:	cf 92       	push	r12
    1cdc:	df 92       	push	r13
    1cde:	ef 92       	push	r14
    1ce0:	ff 92       	push	r15
    1ce2:	6b 01       	movw	r12, r22
    1ce4:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1ce6:	67 2b       	or	r22, r23
    1ce8:	68 2b       	or	r22, r24
    1cea:	69 2b       	or	r22, r25
    1cec:	e9 f0       	breq	.+58     	; 0x1d28 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    1cee:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1cf2:	80 91 aa 30 	lds	r24, 0x30AA	; 0x8030aa <xTickCount>
    1cf6:	90 91 ab 30 	lds	r25, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1cfa:	a0 91 ac 30 	lds	r26, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1cfe:	b0 91 ad 30 	lds	r27, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1d02:	c8 0e       	add	r12, r24
    1d04:	d9 1e       	adc	r13, r25
    1d06:	ea 1e       	adc	r14, r26
    1d08:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d0a:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxCurrentTCB>
    1d0e:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1d12:	02 96       	adiw	r24, 0x02	; 2
    1d14:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d18:	c7 01       	movw	r24, r14
    1d1a:	b6 01       	movw	r22, r12
    1d1c:	0e 94 38 0b 	call	0x1670	; 0x1670 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1d20:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d24:	81 11       	cpse	r24, r1
    1d26:	02 c0       	rjmp	.+4      	; 0x1d2c <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    1d28:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <vPortYield>
		}
	}
    1d2c:	ff 90       	pop	r15
    1d2e:	ef 90       	pop	r14
    1d30:	df 90       	pop	r13
    1d32:	cf 90       	pop	r12
    1d34:	08 95       	ret

00001d36 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1d36:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxSchedulerSuspended>
    1d3a:	81 11       	cpse	r24, r1
    1d3c:	0c c0       	rjmp	.+24     	; 0x1d56 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1d3e:	e0 91 a8 30 	lds	r30, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    1d42:	4b e0       	ldi	r20, 0x0B	; 11
    1d44:	e4 9f       	mul	r30, r20
    1d46:	f0 01       	movw	r30, r0
    1d48:	11 24       	eor	r1, r1
    1d4a:	ea 52       	subi	r30, 0x2A	; 42
    1d4c:	ff 4c       	sbci	r31, 0xCF	; 207
    1d4e:	80 81       	ld	r24, Z
    1d50:	88 23       	and	r24, r24
    1d52:	29 f0       	breq	.+10     	; 0x1d5e <vTaskSwitchContext+0x28>
    1d54:	14 c0       	rjmp	.+40     	; 0x1d7e <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1d56:	81 e0       	ldi	r24, 0x01	; 1
    1d58:	80 93 a4 30 	sts	0x30A4, r24	; 0x8030a4 <xMissedYield>
    1d5c:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1d5e:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1d60:	80 91 a8 30 	lds	r24, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    1d64:	81 50       	subi	r24, 0x01	; 1
    1d66:	80 93 a8 30 	sts	0x30A8, r24	; 0x8030a8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1d6a:	e0 91 a8 30 	lds	r30, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    1d6e:	9e 9f       	mul	r25, r30
    1d70:	f0 01       	movw	r30, r0
    1d72:	11 24       	eor	r1, r1
    1d74:	ea 52       	subi	r30, 0x2A	; 42
    1d76:	ff 4c       	sbci	r31, 0xCF	; 207
    1d78:	80 81       	ld	r24, Z
    1d7a:	88 23       	and	r24, r24
    1d7c:	89 f3       	breq	.-30     	; 0x1d60 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1d7e:	80 91 a8 30 	lds	r24, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    1d82:	28 2f       	mov	r18, r24
    1d84:	30 e0       	ldi	r19, 0x00	; 0
    1d86:	4b e0       	ldi	r20, 0x0B	; 11
    1d88:	84 9f       	mul	r24, r20
    1d8a:	c0 01       	movw	r24, r0
    1d8c:	11 24       	eor	r1, r1
    1d8e:	dc 01       	movw	r26, r24
    1d90:	aa 52       	subi	r26, 0x2A	; 42
    1d92:	bf 4c       	sbci	r27, 0xCF	; 207
    1d94:	11 96       	adiw	r26, 0x01	; 1
    1d96:	ed 91       	ld	r30, X+
    1d98:	fc 91       	ld	r31, X
    1d9a:	12 97       	sbiw	r26, 0x02	; 2
    1d9c:	04 80       	ldd	r0, Z+4	; 0x04
    1d9e:	f5 81       	ldd	r31, Z+5	; 0x05
    1da0:	e0 2d       	mov	r30, r0
    1da2:	11 96       	adiw	r26, 0x01	; 1
    1da4:	ed 93       	st	X+, r30
    1da6:	fc 93       	st	X, r31
    1da8:	12 97       	sbiw	r26, 0x02	; 2
    1daa:	87 52       	subi	r24, 0x27	; 39
    1dac:	9f 4c       	sbci	r25, 0xCF	; 207
    1dae:	e8 17       	cp	r30, r24
    1db0:	f9 07       	cpc	r31, r25
    1db2:	61 f4       	brne	.+24     	; 0x1dcc <vTaskSwitchContext+0x96>
    1db4:	84 81       	ldd	r24, Z+4	; 0x04
    1db6:	95 81       	ldd	r25, Z+5	; 0x05
    1db8:	4b e0       	ldi	r20, 0x0B	; 11
    1dba:	42 9f       	mul	r20, r18
    1dbc:	f0 01       	movw	r30, r0
    1dbe:	43 9f       	mul	r20, r19
    1dc0:	f0 0d       	add	r31, r0
    1dc2:	11 24       	eor	r1, r1
    1dc4:	ea 52       	subi	r30, 0x2A	; 42
    1dc6:	ff 4c       	sbci	r31, 0xCF	; 207
    1dc8:	81 83       	std	Z+1, r24	; 0x01
    1dca:	92 83       	std	Z+2, r25	; 0x02
    1dcc:	8b e0       	ldi	r24, 0x0B	; 11
    1dce:	82 9f       	mul	r24, r18
    1dd0:	f0 01       	movw	r30, r0
    1dd2:	83 9f       	mul	r24, r19
    1dd4:	f0 0d       	add	r31, r0
    1dd6:	11 24       	eor	r1, r1
    1dd8:	ea 52       	subi	r30, 0x2A	; 42
    1dda:	ff 4c       	sbci	r31, 0xCF	; 207
    1ddc:	01 80       	ldd	r0, Z+1	; 0x01
    1dde:	f2 81       	ldd	r31, Z+2	; 0x02
    1de0:	e0 2d       	mov	r30, r0
    1de2:	80 85       	ldd	r24, Z+8	; 0x08
    1de4:	91 85       	ldd	r25, Z+9	; 0x09
    1de6:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <pxCurrentTCB>
    1dea:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <pxCurrentTCB+0x1>
    1dee:	08 95       	ret

00001df0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1df0:	cf 92       	push	r12
    1df2:	df 92       	push	r13
    1df4:	ef 92       	push	r14
    1df6:	ff 92       	push	r15
    1df8:	6a 01       	movw	r12, r20
    1dfa:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1dfc:	60 91 02 31 	lds	r22, 0x3102	; 0x803102 <pxCurrentTCB>
    1e00:	70 91 03 31 	lds	r23, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1e04:	62 5f       	subi	r22, 0xF2	; 242
    1e06:	7f 4f       	sbci	r23, 0xFF	; 255
    1e08:	0e 94 c1 06 	call	0xd82	; 0xd82 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e0c:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxCurrentTCB>
    1e10:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    1e14:	02 96       	adiw	r24, 0x02	; 2
    1e16:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1e1a:	80 91 aa 30 	lds	r24, 0x30AA	; 0x8030aa <xTickCount>
    1e1e:	90 91 ab 30 	lds	r25, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1e22:	a0 91 ac 30 	lds	r26, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1e26:	b0 91 ad 30 	lds	r27, 0x30AD	; 0x8030ad <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e2a:	bc 01       	movw	r22, r24
    1e2c:	cd 01       	movw	r24, r26
    1e2e:	6c 0d       	add	r22, r12
    1e30:	7d 1d       	adc	r23, r13
    1e32:	8e 1d       	adc	r24, r14
    1e34:	9f 1d       	adc	r25, r15
    1e36:	0e 94 38 0b 	call	0x1670	; 0x1670 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1e3a:	ff 90       	pop	r15
    1e3c:	ef 90       	pop	r14
    1e3e:	df 90       	pop	r13
    1e40:	cf 90       	pop	r12
    1e42:	08 95       	ret

00001e44 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1e44:	0f 93       	push	r16
    1e46:	1f 93       	push	r17
    1e48:	cf 93       	push	r28
    1e4a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1e4c:	dc 01       	movw	r26, r24
    1e4e:	17 96       	adiw	r26, 0x07	; 7
    1e50:	ed 91       	ld	r30, X+
    1e52:	fc 91       	ld	r31, X
    1e54:	18 97       	sbiw	r26, 0x08	; 8
    1e56:	c0 85       	ldd	r28, Z+8	; 0x08
    1e58:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1e5a:	8e 01       	movw	r16, r28
    1e5c:	02 5f       	subi	r16, 0xF2	; 242
    1e5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e60:	c8 01       	movw	r24, r16
    1e62:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e66:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxSchedulerSuspended>
    1e6a:	81 11       	cpse	r24, r1
    1e6c:	16 c0       	rjmp	.+44     	; 0x1e9a <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1e6e:	0c 50       	subi	r16, 0x0C	; 12
    1e70:	11 09       	sbc	r17, r1
    1e72:	c8 01       	movw	r24, r16
    1e74:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1e78:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e7a:	90 91 a8 30 	lds	r25, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    1e7e:	98 17       	cp	r25, r24
    1e80:	10 f4       	brcc	.+4      	; 0x1e86 <xTaskRemoveFromEventList+0x42>
    1e82:	80 93 a8 30 	sts	0x30A8, r24	; 0x8030a8 <uxTopReadyPriority>
    1e86:	bb e0       	ldi	r27, 0x0B	; 11
    1e88:	8b 9f       	mul	r24, r27
    1e8a:	c0 01       	movw	r24, r0
    1e8c:	11 24       	eor	r1, r1
    1e8e:	b8 01       	movw	r22, r16
    1e90:	8a 52       	subi	r24, 0x2A	; 42
    1e92:	9f 4c       	sbci	r25, 0xCF	; 207
    1e94:	0e 94 9a 06 	call	0xd34	; 0xd34 <vListInsertEnd>
    1e98:	05 c0       	rjmp	.+10     	; 0x1ea4 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1e9a:	b8 01       	movw	r22, r16
    1e9c:	81 eb       	ldi	r24, 0xB1	; 177
    1e9e:	90 e3       	ldi	r25, 0x30	; 48
    1ea0:	0e 94 9a 06 	call	0xd34	; 0xd34 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1ea4:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxCurrentTCB>
    1ea8:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1eb0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1eb2:	29 17       	cp	r18, r25
    1eb4:	08 f4       	brcc	.+2      	; 0x1eb8 <xTaskRemoveFromEventList+0x74>
    1eb6:	80 e0       	ldi	r24, 0x00	; 0
}
    1eb8:	df 91       	pop	r29
    1eba:	cf 91       	pop	r28
    1ebc:	1f 91       	pop	r17
    1ebe:	0f 91       	pop	r16
    1ec0:	08 95       	ret

00001ec2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1ec2:	20 91 a3 30 	lds	r18, 0x30A3	; 0x8030a3 <xNumOfOverflows>
    1ec6:	fc 01       	movw	r30, r24
    1ec8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1eca:	40 91 aa 30 	lds	r20, 0x30AA	; 0x8030aa <xTickCount>
    1ece:	50 91 ab 30 	lds	r21, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1ed2:	60 91 ac 30 	lds	r22, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1ed6:	70 91 ad 30 	lds	r23, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1eda:	41 83       	std	Z+1, r20	; 0x01
    1edc:	52 83       	std	Z+2, r21	; 0x02
    1ede:	63 83       	std	Z+3, r22	; 0x03
    1ee0:	74 83       	std	Z+4, r23	; 0x04
    1ee2:	08 95       	ret

00001ee4 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1ee4:	8f 92       	push	r8
    1ee6:	9f 92       	push	r9
    1ee8:	af 92       	push	r10
    1eea:	bf 92       	push	r11
    1eec:	cf 92       	push	r12
    1eee:	df 92       	push	r13
    1ef0:	ef 92       	push	r14
    1ef2:	ff 92       	push	r15
    1ef4:	0f 93       	push	r16
    1ef6:	1f 93       	push	r17
    1ef8:	cf 93       	push	r28
    1efa:	df 93       	push	r29
    1efc:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1efe:	0f b6       	in	r0, 0x3f	; 63
    1f00:	f8 94       	cli
    1f02:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1f04:	80 91 a3 30 	lds	r24, 0x30A3	; 0x8030a3 <xNumOfOverflows>
    1f08:	90 81       	ld	r25, Z
    1f0a:	98 17       	cp	r25, r24
    1f0c:	89 f0       	breq	.+34     	; 0x1f30 <xTaskCheckForTimeOut+0x4c>
    1f0e:	80 91 aa 30 	lds	r24, 0x30AA	; 0x8030aa <xTickCount>
    1f12:	90 91 ab 30 	lds	r25, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1f16:	a0 91 ac 30 	lds	r26, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1f1a:	b0 91 ad 30 	lds	r27, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1f1e:	01 81       	ldd	r16, Z+1	; 0x01
    1f20:	12 81       	ldd	r17, Z+2	; 0x02
    1f22:	23 81       	ldd	r18, Z+3	; 0x03
    1f24:	34 81       	ldd	r19, Z+4	; 0x04
    1f26:	80 17       	cp	r24, r16
    1f28:	91 07       	cpc	r25, r17
    1f2a:	a2 07       	cpc	r26, r18
    1f2c:	b3 07       	cpc	r27, r19
    1f2e:	a8 f5       	brcc	.+106    	; 0x1f9a <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1f30:	80 91 aa 30 	lds	r24, 0x30AA	; 0x8030aa <xTickCount>
    1f34:	90 91 ab 30 	lds	r25, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1f38:	a0 91 ac 30 	lds	r26, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1f3c:	b0 91 ad 30 	lds	r27, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1f40:	c1 80       	ldd	r12, Z+1	; 0x01
    1f42:	d2 80       	ldd	r13, Z+2	; 0x02
    1f44:	e3 80       	ldd	r14, Z+3	; 0x03
    1f46:	f4 80       	ldd	r15, Z+4	; 0x04
    1f48:	eb 01       	movw	r28, r22
    1f4a:	08 81       	ld	r16, Y
    1f4c:	19 81       	ldd	r17, Y+1	; 0x01
    1f4e:	2a 81       	ldd	r18, Y+2	; 0x02
    1f50:	3b 81       	ldd	r19, Y+3	; 0x03
    1f52:	8c 19       	sub	r24, r12
    1f54:	9d 09       	sbc	r25, r13
    1f56:	ae 09       	sbc	r26, r14
    1f58:	bf 09       	sbc	r27, r15
    1f5a:	80 17       	cp	r24, r16
    1f5c:	91 07       	cpc	r25, r17
    1f5e:	a2 07       	cpc	r26, r18
    1f60:	b3 07       	cpc	r27, r19
    1f62:	e8 f4       	brcc	.+58     	; 0x1f9e <xTaskCheckForTimeOut+0xba>
    1f64:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1f66:	80 90 aa 30 	lds	r8, 0x30AA	; 0x8030aa <xTickCount>
    1f6a:	90 90 ab 30 	lds	r9, 0x30AB	; 0x8030ab <xTickCount+0x1>
    1f6e:	a0 90 ac 30 	lds	r10, 0x30AC	; 0x8030ac <xTickCount+0x2>
    1f72:	b0 90 ad 30 	lds	r11, 0x30AD	; 0x8030ad <xTickCount+0x3>
    1f76:	b5 01       	movw	r22, r10
    1f78:	a4 01       	movw	r20, r8
    1f7a:	4c 19       	sub	r20, r12
    1f7c:	5d 09       	sbc	r21, r13
    1f7e:	6e 09       	sbc	r22, r14
    1f80:	7f 09       	sbc	r23, r15
    1f82:	04 1b       	sub	r16, r20
    1f84:	15 0b       	sbc	r17, r21
    1f86:	26 0b       	sbc	r18, r22
    1f88:	37 0b       	sbc	r19, r23
    1f8a:	08 83       	st	Y, r16
    1f8c:	19 83       	std	Y+1, r17	; 0x01
    1f8e:	2a 83       	std	Y+2, r18	; 0x02
    1f90:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    1f92:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1f96:	80 e0       	ldi	r24, 0x00	; 0
    1f98:	03 c0       	rjmp	.+6      	; 0x1fa0 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1f9a:	81 e0       	ldi	r24, 0x01	; 1
    1f9c:	01 c0       	rjmp	.+2      	; 0x1fa0 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1f9e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1fa0:	0f 90       	pop	r0
    1fa2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1fa4:	df 91       	pop	r29
    1fa6:	cf 91       	pop	r28
    1fa8:	1f 91       	pop	r17
    1faa:	0f 91       	pop	r16
    1fac:	ff 90       	pop	r15
    1fae:	ef 90       	pop	r14
    1fb0:	df 90       	pop	r13
    1fb2:	cf 90       	pop	r12
    1fb4:	bf 90       	pop	r11
    1fb6:	af 90       	pop	r10
    1fb8:	9f 90       	pop	r9
    1fba:	8f 90       	pop	r8
    1fbc:	08 95       	ret

00001fbe <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1fbe:	81 e0       	ldi	r24, 0x01	; 1
    1fc0:	80 93 a4 30 	sts	0x30A4, r24	; 0x8030a4 <xMissedYield>
    1fc4:	08 95       	ret

00001fc6 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    1fc6:	00 97       	sbiw	r24, 0x00	; 0
    1fc8:	21 f4       	brne	.+8      	; 0x1fd2 <uxTaskGetStackHighWaterMark+0xc>
    1fca:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxCurrentTCB>
    1fce:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    1fd2:	dc 01       	movw	r26, r24
    1fd4:	5b 96       	adiw	r26, 0x1b	; 27
    1fd6:	ed 91       	ld	r30, X+
    1fd8:	fc 91       	ld	r31, X
    1fda:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1fdc:	80 81       	ld	r24, Z
    1fde:	81 31       	cpi	r24, 0x11	; 17
    1fe0:	41 f4       	brne	.+16     	; 0x1ff2 <uxTaskGetStackHighWaterMark+0x2c>
    1fe2:	31 96       	adiw	r30, 0x01	; 1
    1fe4:	80 e0       	ldi	r24, 0x00	; 0
    1fe6:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    1fe8:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    1fea:	21 91       	ld	r18, Z+
    1fec:	21 31       	cpi	r18, 0x11	; 17
    1fee:	e1 f3       	breq	.-8      	; 0x1fe8 <uxTaskGetStackHighWaterMark+0x22>
    1ff0:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    1ff2:	80 e0       	ldi	r24, 0x00	; 0
    1ff4:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    1ff6:	08 95       	ret

00001ff8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1ff8:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxCurrentTCB>
    1ffc:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2000:	08 95       	ret

00002002 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2002:	0f 93       	push	r16
    2004:	1f 93       	push	r17
    2006:	cf 93       	push	r28
    2008:	df 93       	push	r29
    200a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    200c:	22 8d       	ldd	r18, Z+26	; 0x1a
    200e:	a0 91 02 31 	lds	r26, 0x3102	; 0x803102 <pxCurrentTCB>
    2012:	b0 91 03 31 	lds	r27, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    2016:	5a 96       	adiw	r26, 0x1a	; 26
    2018:	8c 91       	ld	r24, X
    201a:	28 17       	cp	r18, r24
    201c:	08 f0       	brcs	.+2      	; 0x2020 <vTaskPriorityInherit+0x1e>
    201e:	41 c0       	rjmp	.+130    	; 0x20a2 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2020:	a0 91 02 31 	lds	r26, 0x3102	; 0x803102 <pxCurrentTCB>
    2024:	b0 91 03 31 	lds	r27, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    2028:	5a 96       	adiw	r26, 0x1a	; 26
    202a:	3c 91       	ld	r19, X
    202c:	84 e0       	ldi	r24, 0x04	; 4
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	a0 e0       	ldi	r26, 0x00	; 0
    2032:	b0 e0       	ldi	r27, 0x00	; 0
    2034:	83 1b       	sub	r24, r19
    2036:	91 09       	sbc	r25, r1
    2038:	a1 09       	sbc	r26, r1
    203a:	b1 09       	sbc	r27, r1
    203c:	86 87       	std	Z+14, r24	; 0x0e
    203e:	97 87       	std	Z+15, r25	; 0x0f
    2040:	a0 8b       	std	Z+16, r26	; 0x10
    2042:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2044:	8b e0       	ldi	r24, 0x0B	; 11
    2046:	28 9f       	mul	r18, r24
    2048:	90 01       	movw	r18, r0
    204a:	11 24       	eor	r1, r1
    204c:	2a 52       	subi	r18, 0x2A	; 42
    204e:	3f 4c       	sbci	r19, 0xCF	; 207
    2050:	84 85       	ldd	r24, Z+12	; 0x0c
    2052:	95 85       	ldd	r25, Z+13	; 0x0d
    2054:	82 17       	cp	r24, r18
    2056:	93 07       	cpc	r25, r19
    2058:	e9 f4       	brne	.+58     	; 0x2094 <vTaskPriorityInherit+0x92>
    205a:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    205c:	ef 01       	movw	r28, r30
    205e:	22 96       	adiw	r28, 0x02	; 2
    2060:	ce 01       	movw	r24, r28
    2062:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2066:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxCurrentTCB>
    206a:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    206e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2070:	f8 01       	movw	r30, r16
    2072:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2074:	90 91 a8 30 	lds	r25, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    2078:	98 17       	cp	r25, r24
    207a:	10 f4       	brcc	.+4      	; 0x2080 <vTaskPriorityInherit+0x7e>
    207c:	80 93 a8 30 	sts	0x30A8, r24	; 0x8030a8 <uxTopReadyPriority>
    2080:	fb e0       	ldi	r31, 0x0B	; 11
    2082:	8f 9f       	mul	r24, r31
    2084:	c0 01       	movw	r24, r0
    2086:	11 24       	eor	r1, r1
    2088:	be 01       	movw	r22, r28
    208a:	8a 52       	subi	r24, 0x2A	; 42
    208c:	9f 4c       	sbci	r25, 0xCF	; 207
    208e:	0e 94 9a 06 	call	0xd34	; 0xd34 <vListInsertEnd>
    2092:	07 c0       	rjmp	.+14     	; 0x20a2 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2094:	a0 91 02 31 	lds	r26, 0x3102	; 0x803102 <pxCurrentTCB>
    2098:	b0 91 03 31 	lds	r27, 0x3103	; 0x803103 <pxCurrentTCB+0x1>
    209c:	5a 96       	adiw	r26, 0x1a	; 26
    209e:	8c 91       	ld	r24, X
    20a0:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    20a2:	df 91       	pop	r29
    20a4:	cf 91       	pop	r28
    20a6:	1f 91       	pop	r17
    20a8:	0f 91       	pop	r16
    20aa:	08 95       	ret

000020ac <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    20ac:	0f 93       	push	r16
    20ae:	1f 93       	push	r17
    20b0:	cf 93       	push	r28
    20b2:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    20b4:	00 97       	sbiw	r24, 0x00	; 0
    20b6:	49 f1       	breq	.+82     	; 0x210a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    20b8:	fc 01       	movw	r30, r24
    20ba:	32 8d       	ldd	r19, Z+26	; 0x1a
    20bc:	27 a1       	ldd	r18, Z+39	; 0x27
    20be:	32 17       	cp	r19, r18
    20c0:	21 f1       	breq	.+72     	; 0x210a <vTaskPriorityDisinherit+0x5e>
    20c2:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    20c4:	8c 01       	movw	r16, r24
    20c6:	0e 5f       	subi	r16, 0xFE	; 254
    20c8:	1f 4f       	sbci	r17, 0xFF	; 255
    20ca:	c8 01       	movw	r24, r16
    20cc:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    20d0:	8f a1       	ldd	r24, Y+39	; 0x27
    20d2:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    20d4:	44 e0       	ldi	r20, 0x04	; 4
    20d6:	50 e0       	ldi	r21, 0x00	; 0
    20d8:	60 e0       	ldi	r22, 0x00	; 0
    20da:	70 e0       	ldi	r23, 0x00	; 0
    20dc:	48 1b       	sub	r20, r24
    20de:	51 09       	sbc	r21, r1
    20e0:	61 09       	sbc	r22, r1
    20e2:	71 09       	sbc	r23, r1
    20e4:	4e 87       	std	Y+14, r20	; 0x0e
    20e6:	5f 87       	std	Y+15, r21	; 0x0f
    20e8:	68 8b       	std	Y+16, r22	; 0x10
    20ea:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    20ec:	90 91 a8 30 	lds	r25, 0x30A8	; 0x8030a8 <uxTopReadyPriority>
    20f0:	98 17       	cp	r25, r24
    20f2:	10 f4       	brcc	.+4      	; 0x20f8 <vTaskPriorityDisinherit+0x4c>
    20f4:	80 93 a8 30 	sts	0x30A8, r24	; 0x8030a8 <uxTopReadyPriority>
    20f8:	fb e0       	ldi	r31, 0x0B	; 11
    20fa:	8f 9f       	mul	r24, r31
    20fc:	c0 01       	movw	r24, r0
    20fe:	11 24       	eor	r1, r1
    2100:	b8 01       	movw	r22, r16
    2102:	8a 52       	subi	r24, 0x2A	; 42
    2104:	9f 4c       	sbci	r25, 0xCF	; 207
    2106:	0e 94 9a 06 	call	0xd34	; 0xd34 <vListInsertEnd>
			}
		}
	}
    210a:	df 91       	pop	r29
    210c:	cf 91       	pop	r28
    210e:	1f 91       	pop	r17
    2110:	0f 91       	pop	r16
    2112:	08 95       	ret

00002114 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2114:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2116:	e8 81       	ld	r30, Y
    2118:	f9 81       	ldd	r31, Y+1	; 0x01
    211a:	01 90       	ld	r0, Z+
    211c:	f0 81       	ld	r31, Z
    211e:	e0 2d       	mov	r30, r0
    2120:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2122:	1a 82       	std	Y+2, r1	; 0x02
    2124:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2126:	6f ef       	ldi	r22, 0xFF	; 255
    2128:	7f ef       	ldi	r23, 0xFF	; 255
    212a:	cb 01       	movw	r24, r22
    212c:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <vTaskDelay>
    2130:	fa cf       	rjmp	.-12     	; 0x2126 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002132 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2132:	fc 01       	movw	r30, r24
    2134:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2136:	65 87       	std	Z+13, r22	; 0x0d
    2138:	08 95       	ret

0000213a <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    213a:	4f 92       	push	r4
    213c:	5f 92       	push	r5
    213e:	6f 92       	push	r6
    2140:	7f 92       	push	r7
    2142:	8f 92       	push	r8
    2144:	9f 92       	push	r9
    2146:	af 92       	push	r10
    2148:	bf 92       	push	r11
    214a:	cf 92       	push	r12
    214c:	df 92       	push	r13
    214e:	ef 92       	push	r14
    2150:	ff 92       	push	r15
    2152:	0f 93       	push	r16
    2154:	1f 93       	push	r17
    2156:	cf 93       	push	r28
    2158:	df 93       	push	r29
    215a:	cd b7       	in	r28, 0x3d	; 61
    215c:	de b7       	in	r29, 0x3e	; 62
    215e:	2a 97       	sbiw	r28, 0x0a	; 10
    2160:	cd bf       	out	0x3d, r28	; 61
    2162:	de bf       	out	0x3e, r29	; 62
    2164:	4c 01       	movw	r8, r24
    2166:	29 01       	movw	r4, r18
    2168:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    216a:	8f e1       	ldi	r24, 0x1F	; 31
    216c:	90 e2       	ldi	r25, 0x20	; 32
    216e:	f4 01       	movw	r30, r8
    2170:	80 83       	st	Z, r24
    2172:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2174:	fb 01       	movw	r30, r22
    2176:	80 81       	ld	r24, Z
    2178:	88 23       	and	r24, r24
    217a:	69 f0       	breq	.+26     	; 0x2196 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    217c:	de 01       	movw	r26, r28
    217e:	11 96       	adiw	r26, 0x01	; 1
    2180:	31 96       	adiw	r30, 0x01	; 1
    2182:	90 e0       	ldi	r25, 0x00	; 0
    2184:	02 c0       	rjmp	.+4      	; 0x218a <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2186:	99 30       	cpi	r25, 0x09	; 9
    2188:	39 f0       	breq	.+14     	; 0x2198 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    218a:	9f 5f       	subi	r25, 0xFF	; 255
    218c:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    218e:	81 91       	ld	r24, Z+
    2190:	81 11       	cpse	r24, r1
    2192:	f9 cf       	rjmp	.-14     	; 0x2186 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2194:	01 c0       	rjmp	.+2      	; 0x2198 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2196:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2198:	e1 e0       	ldi	r30, 0x01	; 1
    219a:	f0 e0       	ldi	r31, 0x00	; 0
    219c:	ec 0f       	add	r30, r28
    219e:	fd 1f       	adc	r31, r29
    21a0:	e9 0f       	add	r30, r25
    21a2:	f1 1d       	adc	r31, r1
    21a4:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    21a6:	74 01       	movw	r14, r8
    21a8:	f2 e0       	ldi	r31, 0x02	; 2
    21aa:	ef 0e       	add	r14, r31
    21ac:	f1 1c       	adc	r15, r1
    21ae:	a1 2c       	mov	r10, r1
    21b0:	b1 2c       	mov	r11, r1
    21b2:	c1 2c       	mov	r12, r1
    21b4:	d1 2c       	mov	r13, r1
    21b6:	04 2f       	mov	r16, r20
    21b8:	94 01       	movw	r18, r8
    21ba:	a2 01       	movw	r20, r4
    21bc:	be 01       	movw	r22, r28
    21be:	6f 5f       	subi	r22, 0xFF	; 255
    21c0:	7f 4f       	sbci	r23, 0xFF	; 255
    21c2:	8e e9       	ldi	r24, 0x9E	; 158
    21c4:	92 e0       	ldi	r25, 0x02	; 2
    21c6:	0e 94 86 0b 	call	0x170c	; 0x170c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    21ca:	f4 01       	movw	r30, r8
    21cc:	66 82       	std	Z+6, r6	; 0x06
    21ce:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    21d0:	40 86       	std	Z+8, r4	; 0x08
    21d2:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    21d4:	20 91 04 31 	lds	r18, 0x3104	; 0x803104 <last_created_task_pointer>
    21d8:	30 91 05 31 	lds	r19, 0x3105	; 0x803105 <last_created_task_pointer+0x1>
    21dc:	24 83       	std	Z+4, r18	; 0x04
    21de:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    21e0:	80 92 04 31 	sts	0x3104, r8	; 0x803104 <last_created_task_pointer>
    21e4:	90 92 05 31 	sts	0x3105, r9	; 0x803105 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    21e8:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    21ea:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    21ec:	40 90 42 31 	lds	r4, 0x3142	; 0x803142 <portStackTopForTask>
    21f0:	50 90 43 31 	lds	r5, 0x3143	; 0x803143 <portStackTopForTask+0x1>
    21f4:	ff ef       	ldi	r31, 0xFF	; 255
    21f6:	4f 1a       	sub	r4, r31
    21f8:	5f 0a       	sbc	r5, r31
    21fa:	40 92 42 31 	sts	0x3142, r4	; 0x803142 <portStackTopForTask>
    21fe:	50 92 43 31 	sts	0x3143, r5	; 0x803143 <portStackTopForTask+0x1>
    2202:	f4 01       	movw	r30, r8
    2204:	42 86       	std	Z+10, r4	; 0x0a
    2206:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2208:	16 86       	std	Z+14, r1	; 0x0e
    220a:	17 86       	std	Z+15, r1	; 0x0f
    220c:	10 8a       	std	Z+16, r1	; 0x10
    220e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2210:	61 14       	cp	r6, r1
    2212:	71 04       	cpc	r7, r1
    2214:	09 f4       	brne	.+2      	; 0x2218 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2216:	44 c0       	rjmp	.+136    	; 0x22a0 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2218:	81 30       	cpi	r24, 0x01	; 1
    221a:	79 f5       	brne	.+94     	; 0x227a <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    221c:	6a e0       	ldi	r22, 0x0A	; 10
    221e:	c3 01       	movw	r24, r6
    2220:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2224:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2226:	69 e8       	ldi	r22, 0x89	; 137
    2228:	74 e0       	ldi	r23, 0x04	; 4
    222a:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    222e:	be 01       	movw	r22, r28
    2230:	6f 5f       	subi	r22, 0xFF	; 255
    2232:	7f 4f       	sbci	r23, 0xFF	; 255
    2234:	c7 01       	movw	r24, r14
    2236:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    223a:	6a e0       	ldi	r22, 0x0A	; 10
    223c:	c7 01       	movw	r24, r14
    223e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2242:	7c 01       	movw	r14, r24
    2244:	60 e8       	ldi	r22, 0x80	; 128
    2246:	74 e0       	ldi	r23, 0x04	; 4
    2248:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    224c:	6a e0       	ldi	r22, 0x0A	; 10
    224e:	c7 01       	movw	r24, r14
    2250:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2254:	7c 01       	movw	r14, r24
    2256:	62 e7       	ldi	r22, 0x72	; 114
    2258:	74 e0       	ldi	r23, 0x04	; 4
    225a:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    225e:	63 e0       	ldi	r22, 0x03	; 3
    2260:	c7 01       	movw	r24, r14
    2262:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2266:	b2 01       	movw	r22, r4
    2268:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZN8emstreamlsEj>
    226c:	62 e0       	ldi	r22, 0x02	; 2
    226e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2272:	66 e0       	ldi	r22, 0x06	; 6
    2274:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2278:	13 c0       	rjmp	.+38     	; 0x22a0 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    227a:	6a e0       	ldi	r22, 0x0A	; 10
    227c:	c3 01       	movw	r24, r6
    227e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2282:	4c 01       	movw	r8, r24
    2284:	6d e5       	ldi	r22, 0x5D	; 93
    2286:	74 e0       	ldi	r23, 0x04	; 4
    2288:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    228c:	be 01       	movw	r22, r28
    228e:	6f 5f       	subi	r22, 0xFF	; 255
    2290:	7f 4f       	sbci	r23, 0xFF	; 255
    2292:	c4 01       	movw	r24, r8
    2294:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    2298:	66 e0       	ldi	r22, 0x06	; 6
    229a:	c4 01       	movw	r24, r8
    229c:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    22a0:	2a 96       	adiw	r28, 0x0a	; 10
    22a2:	cd bf       	out	0x3d, r28	; 61
    22a4:	de bf       	out	0x3e, r29	; 62
    22a6:	df 91       	pop	r29
    22a8:	cf 91       	pop	r28
    22aa:	1f 91       	pop	r17
    22ac:	0f 91       	pop	r16
    22ae:	ff 90       	pop	r15
    22b0:	ef 90       	pop	r14
    22b2:	df 90       	pop	r13
    22b4:	cf 90       	pop	r12
    22b6:	bf 90       	pop	r11
    22b8:	af 90       	pop	r10
    22ba:	9f 90       	pop	r9
    22bc:	8f 90       	pop	r8
    22be:	7f 90       	pop	r7
    22c0:	6f 90       	pop	r6
    22c2:	5f 90       	pop	r5
    22c4:	4f 90       	pop	r4
    22c6:	08 95       	ret

000022c8 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    22c8:	cf 92       	push	r12
    22ca:	df 92       	push	r13
    22cc:	ef 92       	push	r14
    22ce:	ff 92       	push	r15
    22d0:	0f 93       	push	r16
    22d2:	1f 93       	push	r17
    22d4:	cf 93       	push	r28
    22d6:	df 93       	push	r29
    22d8:	ec 01       	movw	r28, r24
    22da:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    22dc:	8a 81       	ldd	r24, Y+2	; 0x02
    22de:	9b 81       	ldd	r25, Y+3	; 0x03
    22e0:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <pcTaskGetTaskName>
    22e4:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    22e6:	6a e0       	ldi	r22, 0x0A	; 10
    22e8:	c7 01       	movw	r24, r14
    22ea:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    22ee:	8c 01       	movw	r16, r24
    22f0:	6c e9       	ldi	r22, 0x9C	; 156
    22f2:	74 e0       	ldi	r23, 0x04	; 4
    22f4:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    22f8:	6a e0       	ldi	r22, 0x0A	; 10
    22fa:	c8 01       	movw	r24, r16
    22fc:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2300:	8c 01       	movw	r16, r24
    2302:	65 e9       	ldi	r22, 0x95	; 149
    2304:	74 e0       	ldi	r23, 0x04	; 4
    2306:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    230a:	b6 01       	movw	r22, r12
    230c:	c8 01       	movw	r24, r16
    230e:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2312:	6a e0       	ldi	r22, 0x0A	; 10
    2314:	c8 01       	movw	r24, r16
    2316:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    231a:	8c 01       	movw	r16, r24
    231c:	6f e8       	ldi	r22, 0x8F	; 143
    231e:	74 e0       	ldi	r23, 0x04	; 4
    2320:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    2324:	66 e0       	ldi	r22, 0x06	; 6
    2326:	c8 01       	movw	r24, r16
    2328:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    232c:	8a 85       	ldd	r24, Y+10	; 0x0a
    232e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2330:	e8 85       	ldd	r30, Y+8	; 0x08
    2332:	f9 85       	ldd	r31, Y+9	; 0x09
    2334:	01 e1       	ldi	r16, 0x11	; 17
    2336:	21 e0       	ldi	r18, 0x01	; 1
    2338:	a7 01       	movw	r20, r14
    233a:	bc 01       	movw	r22, r24
    233c:	8e 1b       	sub	r24, r30
    233e:	9f 0b       	sbc	r25, r31
    2340:	0e 94 66 14 	call	0x28cc	; 0x28cc <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2344:	8c 81       	ldd	r24, Y+4	; 0x04
    2346:	9d 81       	ldd	r25, Y+5	; 0x05
    2348:	00 97       	sbiw	r24, 0x00	; 0
    234a:	19 f0       	breq	.+6      	; 0x2352 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    234c:	b7 01       	movw	r22, r14
    234e:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2352:	df 91       	pop	r29
    2354:	cf 91       	pop	r28
    2356:	1f 91       	pop	r17
    2358:	0f 91       	pop	r16
    235a:	ff 90       	pop	r15
    235c:	ef 90       	pop	r14
    235e:	df 90       	pop	r13
    2360:	cf 90       	pop	r12
    2362:	08 95       	ret

00002364 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2364:	0f 93       	push	r16
    2366:	1f 93       	push	r17
    2368:	cf 93       	push	r28
    236a:	df 93       	push	r29
    236c:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    236e:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <last_created_task_pointer>
    2372:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <last_created_task_pointer+0x1>
    2376:	00 97       	sbiw	r24, 0x00	; 0
    2378:	19 f0       	breq	.+6      	; 0x2380 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    237a:	be 01       	movw	r22, r28
    237c:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2380:	6a e0       	ldi	r22, 0x0A	; 10
    2382:	ce 01       	movw	r24, r28
    2384:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2388:	8c 01       	movw	r16, r24
    238a:	62 eb       	ldi	r22, 0xB2	; 178
    238c:	74 e0       	ldi	r23, 0x04	; 4
    238e:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    2392:	6a e0       	ldi	r22, 0x0A	; 10
    2394:	c8 01       	movw	r24, r16
    2396:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    239a:	8c 01       	movw	r16, r24
    239c:	67 ea       	ldi	r22, 0xA7	; 167
    239e:	74 e0       	ldi	r23, 0x04	; 4
    23a0:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    23a4:	6a e0       	ldi	r22, 0x0A	; 10
    23a6:	c8 01       	movw	r24, r16
    23a8:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    23ac:	8c 01       	movw	r16, r24
    23ae:	61 ea       	ldi	r22, 0xA1	; 161
    23b0:	74 e0       	ldi	r23, 0x04	; 4
    23b2:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    23b6:	66 e0       	ldi	r22, 0x06	; 6
    23b8:	c8 01       	movw	r24, r16
    23ba:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    23be:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <portStackTopForTask>
    23c2:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <portStackTopForTask+0x1>
    23c6:	bc 01       	movw	r22, r24
    23c8:	6f 5f       	subi	r22, 0xFF	; 255
    23ca:	7f 4f       	sbci	r23, 0xFF	; 255
    23cc:	01 e1       	ldi	r16, 0x11	; 17
    23ce:	21 e0       	ldi	r18, 0x01	; 1
    23d0:	ae 01       	movw	r20, r28
    23d2:	83 56       	subi	r24, 0x63	; 99
    23d4:	91 09       	sbc	r25, r1
    23d6:	0e 94 66 14 	call	0x28cc	; 0x28cc <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    23da:	df 91       	pop	r29
    23dc:	cf 91       	pop	r28
    23de:	1f 91       	pop	r17
    23e0:	0f 91       	pop	r16
    23e2:	08 95       	ret

000023e4 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    23e4:	8f 92       	push	r8
    23e6:	9f 92       	push	r9
    23e8:	af 92       	push	r10
    23ea:	bf 92       	push	r11
    23ec:	cf 92       	push	r12
    23ee:	df 92       	push	r13
    23f0:	ef 92       	push	r14
    23f2:	ff 92       	push	r15
    23f4:	0f 93       	push	r16
    23f6:	1f 93       	push	r17
    23f8:	cf 93       	push	r28
    23fa:	df 93       	push	r29
    23fc:	ec 01       	movw	r28, r24
    23fe:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2400:	8a 81       	ldd	r24, Y+2	; 0x02
    2402:	9b 81       	ldd	r25, Y+3	; 0x03
    2404:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <pcTaskGetTaskName>
    2408:	bc 01       	movw	r22, r24
    240a:	c8 01       	movw	r24, r16
    240c:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2410:	d8 01       	movw	r26, r16
    2412:	ed 91       	ld	r30, X+
    2414:	fc 91       	ld	r31, X
    2416:	02 80       	ldd	r0, Z+2	; 0x02
    2418:	f3 81       	ldd	r31, Z+3	; 0x03
    241a:	e0 2d       	mov	r30, r0
    241c:	69 e0       	ldi	r22, 0x09	; 9
    241e:	c8 01       	movw	r24, r16
    2420:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2422:	8a 81       	ldd	r24, Y+2	; 0x02
    2424:	9b 81       	ldd	r25, Y+3	; 0x03
    2426:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <pcTaskGetTaskName>
    242a:	fc 01       	movw	r30, r24
    242c:	01 90       	ld	r0, Z+
    242e:	00 20       	and	r0, r0
    2430:	e9 f7       	brne	.-6      	; 0x242c <_ZN8frt_task12print_statusER8emstream+0x48>
    2432:	31 97       	sbiw	r30, 0x01	; 1
    2434:	e8 1b       	sub	r30, r24
    2436:	f9 0b       	sbc	r31, r25
    2438:	38 97       	sbiw	r30, 0x08	; 8
    243a:	48 f4       	brcc	.+18     	; 0x244e <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    243c:	d8 01       	movw	r26, r16
    243e:	ed 91       	ld	r30, X+
    2440:	fc 91       	ld	r31, X
    2442:	02 80       	ldd	r0, Z+2	; 0x02
    2444:	f3 81       	ldd	r31, Z+3	; 0x03
    2446:	e0 2d       	mov	r30, r0
    2448:	69 e0       	ldi	r22, 0x09	; 9
    244a:	c8 01       	movw	r24, r16
    244c:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    244e:	ce 84       	ldd	r12, Y+14	; 0x0e
    2450:	df 84       	ldd	r13, Y+15	; 0x0f
    2452:	e8 88       	ldd	r14, Y+16	; 0x10
    2454:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2456:	a8 84       	ldd	r10, Y+8	; 0x08
    2458:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    245a:	8a 81       	ldd	r24, Y+2	; 0x02
    245c:	9b 81       	ldd	r25, Y+3	; 0x03
    245e:	0e 94 e3 0f 	call	0x1fc6	; 0x1fc6 <uxTaskGetStackHighWaterMark>
    2462:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2464:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2466:	8a 81       	ldd	r24, Y+2	; 0x02
    2468:	9b 81       	ldd	r25, Y+3	; 0x03
    246a:	0e 94 88 0c 	call	0x1910	; 0x1910 <uxTaskPriorityGet>
    246e:	68 2f       	mov	r22, r24
    2470:	c8 01       	movw	r24, r16
    2472:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
    2476:	6a e0       	ldi	r22, 0x0A	; 10
    2478:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    247c:	ec 01       	movw	r28, r24
    247e:	67 e2       	ldi	r22, 0x27	; 39
    2480:	75 e0       	ldi	r23, 0x05	; 5
    2482:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
			<< get_state ()
    2486:	68 2d       	mov	r22, r8
    2488:	ce 01       	movw	r24, r28
    248a:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    248e:	6a e0       	ldi	r22, 0x0A	; 10
    2490:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2494:	ec 01       	movw	r28, r24
    2496:	65 e2       	ldi	r22, 0x25	; 37
    2498:	75 e0       	ldi	r23, 0x05	; 5
    249a:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    249e:	69 2d       	mov	r22, r9
    24a0:	ce 01       	movw	r24, r28
    24a2:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
    24a6:	6a e0       	ldi	r22, 0x0A	; 10
    24a8:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    24ac:	ec 01       	movw	r28, r24
    24ae:	63 e2       	ldi	r22, 0x23	; 35
    24b0:	75 e0       	ldi	r23, 0x05	; 5
    24b2:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    24b6:	b5 01       	movw	r22, r10
    24b8:	ce 01       	movw	r24, r28
    24ba:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZN8emstreamlsEj>
    24be:	6a e0       	ldi	r22, 0x0A	; 10
    24c0:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    24c4:	ec 01       	movw	r28, r24
    24c6:	61 e2       	ldi	r22, 0x21	; 33
    24c8:	75 e0       	ldi	r23, 0x05	; 5
    24ca:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    24ce:	6a e0       	ldi	r22, 0x0A	; 10
    24d0:	ce 01       	movw	r24, r28
    24d2:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    24d6:	ec 01       	movw	r28, r24
    24d8:	6f e1       	ldi	r22, 0x1F	; 31
    24da:	75 e0       	ldi	r23, 0x05	; 5
    24dc:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    24e0:	b7 01       	movw	r22, r14
    24e2:	a6 01       	movw	r20, r12
    24e4:	ce 01       	movw	r24, r28
    24e6:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <_ZN8emstreamlsEm>
}
    24ea:	df 91       	pop	r29
    24ec:	cf 91       	pop	r28
    24ee:	1f 91       	pop	r17
    24f0:	0f 91       	pop	r16
    24f2:	ff 90       	pop	r15
    24f4:	ef 90       	pop	r14
    24f6:	df 90       	pop	r13
    24f8:	cf 90       	pop	r12
    24fa:	bf 90       	pop	r11
    24fc:	af 90       	pop	r10
    24fe:	9f 90       	pop	r9
    2500:	8f 90       	pop	r8
    2502:	08 95       	ret

00002504 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2504:	cf 93       	push	r28
    2506:	df 93       	push	r29
    2508:	ec 01       	movw	r28, r24
    250a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    250c:	db 01       	movw	r26, r22
    250e:	ed 91       	ld	r30, X+
    2510:	fc 91       	ld	r31, X
    2512:	02 80       	ldd	r0, Z+2	; 0x02
    2514:	f3 81       	ldd	r31, Z+3	; 0x03
    2516:	e0 2d       	mov	r30, r0
    2518:	be 01       	movw	r22, r28
    251a:	19 95       	eicall
	return (ser_dev);
}
    251c:	ce 01       	movw	r24, r28
    251e:	df 91       	pop	r29
    2520:	cf 91       	pop	r28
    2522:	08 95       	ret

00002524 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2524:	0f 93       	push	r16
    2526:	1f 93       	push	r17
    2528:	cf 93       	push	r28
    252a:	df 93       	push	r29
    252c:	ec 01       	movw	r28, r24
    252e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2530:	bc 01       	movw	r22, r24
    2532:	c8 01       	movw	r24, r16
    2534:	0e 94 82 12 	call	0x2504	; 0x2504 <_ZlsR8emstreamR8frt_task>
    2538:	66 e0       	ldi	r22, 0x06	; 6
    253a:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    253e:	8c 81       	ldd	r24, Y+4	; 0x04
    2540:	9d 81       	ldd	r25, Y+5	; 0x05
    2542:	00 97       	sbiw	r24, 0x00	; 0
    2544:	19 f0       	breq	.+6      	; 0x254c <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2546:	b8 01       	movw	r22, r16
    2548:	0e 94 92 12 	call	0x2524	; 0x2524 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	1f 91       	pop	r17
    2552:	0f 91       	pop	r16
    2554:	08 95       	ret

00002556 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2556:	0f 93       	push	r16
    2558:	1f 93       	push	r17
    255a:	cf 93       	push	r28
    255c:	df 93       	push	r29
    255e:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2560:	6a e0       	ldi	r22, 0x0A	; 10
    2562:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2566:	8c 01       	movw	r16, r24
    2568:	64 e1       	ldi	r22, 0x14	; 20
    256a:	75 e0       	ldi	r23, 0x05	; 5
    256c:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2570:	6a e0       	ldi	r22, 0x0A	; 10
    2572:	c8 01       	movw	r24, r16
    2574:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2578:	8c 01       	movw	r16, r24
    257a:	6d e0       	ldi	r22, 0x0D	; 13
    257c:	75 e0       	ldi	r23, 0x05	; 5
    257e:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2582:	66 e0       	ldi	r22, 0x06	; 6
    2584:	c8 01       	movw	r24, r16
    2586:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    258a:	6a e0       	ldi	r22, 0x0A	; 10
    258c:	ce 01       	movw	r24, r28
    258e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2592:	8c 01       	movw	r16, r24
    2594:	6c ef       	ldi	r22, 0xFC	; 252
    2596:	74 e0       	ldi	r23, 0x04	; 4
    2598:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    259c:	6a e0       	ldi	r22, 0x0A	; 10
    259e:	c8 01       	movw	r24, r16
    25a0:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    25a4:	8c 01       	movw	r16, r24
    25a6:	60 ef       	ldi	r22, 0xF0	; 240
    25a8:	74 e0       	ldi	r23, 0x04	; 4
    25aa:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    25ae:	6a e0       	ldi	r22, 0x0A	; 10
    25b0:	c8 01       	movw	r24, r16
    25b2:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    25b6:	8c 01       	movw	r16, r24
    25b8:	6a ee       	ldi	r22, 0xEA	; 234
    25ba:	74 e0       	ldi	r23, 0x04	; 4
    25bc:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    25c0:	66 e0       	ldi	r22, 0x06	; 6
    25c2:	c8 01       	movw	r24, r16
    25c4:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    25c8:	6a e0       	ldi	r22, 0x0A	; 10
    25ca:	ce 01       	movw	r24, r28
    25cc:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    25d0:	8c 01       	movw	r16, r24
    25d2:	69 ed       	ldi	r22, 0xD9	; 217
    25d4:	74 e0       	ldi	r23, 0x04	; 4
    25d6:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    25da:	6a e0       	ldi	r22, 0x0A	; 10
    25dc:	c8 01       	movw	r24, r16
    25de:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    25e2:	8c 01       	movw	r16, r24
    25e4:	6d ec       	ldi	r22, 0xCD	; 205
    25e6:	74 e0       	ldi	r23, 0x04	; 4
    25e8:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    25ec:	6a e0       	ldi	r22, 0x0A	; 10
    25ee:	c8 01       	movw	r24, r16
    25f0:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    25f4:	8c 01       	movw	r16, r24
    25f6:	67 ec       	ldi	r22, 0xC7	; 199
    25f8:	74 e0       	ldi	r23, 0x04	; 4
    25fa:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    25fe:	66 e0       	ldi	r22, 0x06	; 6
    2600:	c8 01       	movw	r24, r16
    2602:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2606:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <last_created_task_pointer>
    260a:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <last_created_task_pointer+0x1>
    260e:	00 97       	sbiw	r24, 0x00	; 0
    2610:	19 f0       	breq	.+6      	; 0x2618 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2612:	be 01       	movw	r22, r28
    2614:	0e 94 92 12 	call	0x2524	; 0x2524 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2618:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <xTaskGetIdleTaskHandle>
    261c:	0e 94 e3 0f 	call	0x1fc6	; 0x1fc6 <uxTaskGetStackHighWaterMark>
    2620:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2622:	6a e0       	ldi	r22, 0x0A	; 10
    2624:	ce 01       	movw	r24, r28
    2626:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    262a:	ec 01       	movw	r28, r24
    262c:	6c eb       	ldi	r22, 0xBC	; 188
    262e:	74 e0       	ldi	r23, 0x04	; 4
    2630:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2634:	61 2f       	mov	r22, r17
    2636:	ce 01       	movw	r24, r28
    2638:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    263c:	6a e0       	ldi	r22, 0x0A	; 10
    263e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2642:	ec 01       	movw	r28, r24
    2644:	6a eb       	ldi	r22, 0xBA	; 186
    2646:	74 e0       	ldi	r23, 0x04	; 4
    2648:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    264c:	64 e6       	ldi	r22, 0x64	; 100
    264e:	70 e0       	ldi	r23, 0x00	; 0
    2650:	ce 01       	movw	r24, r28
    2652:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZN8emstreamlsEj>
    2656:	6a e0       	ldi	r22, 0x0A	; 10
    2658:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    265c:	ec 01       	movw	r28, r24
    265e:	67 eb       	ldi	r22, 0xB7	; 183
    2660:	74 e0       	ldi	r23, 0x04	; 4
    2662:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2666:	66 e0       	ldi	r22, 0x06	; 6
    2668:	ce 01       	movw	r24, r28
    266a:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
}
    266e:	df 91       	pop	r29
    2670:	cf 91       	pop	r28
    2672:	1f 91       	pop	r17
    2674:	0f 91       	pop	r16
    2676:	08 95       	ret

00002678 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2678:	0f 93       	push	r16
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	1f 92       	push	r1
    2680:	cd b7       	in	r28, 0x3d	; 61
    2682:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2684:	00 e0       	ldi	r16, 0x00	; 0
    2686:	2f ef       	ldi	r18, 0xFF	; 255
    2688:	3f ef       	ldi	r19, 0xFF	; 255
    268a:	a9 01       	movw	r20, r18
    268c:	be 01       	movw	r22, r28
    268e:	6f 5f       	subi	r22, 0xFF	; 255
    2690:	7f 4f       	sbci	r23, 0xFF	; 255
    2692:	fc 01       	movw	r30, r24
    2694:	80 85       	ldd	r24, Z+8	; 0x08
    2696:	91 85       	ldd	r25, Z+9	; 0x09
    2698:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <xQueueGenericReceive>
    269c:	81 30       	cpi	r24, 0x01	; 1
    269e:	19 f4       	brne	.+6      	; 0x26a6 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    26a0:	89 81       	ldd	r24, Y+1	; 0x01
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	02 c0       	rjmp	.+4      	; 0x26aa <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    26a6:	8f ef       	ldi	r24, 0xFF	; 255
    26a8:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    26aa:	0f 90       	pop	r0
    26ac:	df 91       	pop	r29
    26ae:	cf 91       	pop	r28
    26b0:	0f 91       	pop	r16
    26b2:	08 95       	ret

000026b4 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    26b4:	fc 01       	movw	r30, r24
    26b6:	80 85       	ldd	r24, Z+8	; 0x08
    26b8:	91 85       	ldd	r25, Z+9	; 0x09
    26ba:	0e 94 28 0b 	call	0x1650	; 0x1650 <uxQueueMessagesWaiting>
    26be:	91 e0       	ldi	r25, 0x01	; 1
    26c0:	81 11       	cpse	r24, r1
    26c2:	01 c0       	rjmp	.+2      	; 0x26c6 <_ZN14frt_text_queue14check_for_charEv+0x12>
    26c4:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    26c6:	89 2f       	mov	r24, r25
    26c8:	08 95       	ret

000026ca <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    26ca:	0f 93       	push	r16
    26cc:	cf 93       	push	r28
    26ce:	df 93       	push	r29
    26d0:	1f 92       	push	r1
    26d2:	cd b7       	in	r28, 0x3d	; 61
    26d4:	de b7       	in	r29, 0x3e	; 62
    26d6:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    26d8:	fc 01       	movw	r30, r24
    26da:	22 85       	ldd	r18, Z+10	; 0x0a
    26dc:	33 85       	ldd	r19, Z+11	; 0x0b
    26de:	44 85       	ldd	r20, Z+12	; 0x0c
    26e0:	55 85       	ldd	r21, Z+13	; 0x0d
    26e2:	00 e0       	ldi	r16, 0x00	; 0
    26e4:	be 01       	movw	r22, r28
    26e6:	6f 5f       	subi	r22, 0xFF	; 255
    26e8:	7f 4f       	sbci	r23, 0xFF	; 255
    26ea:	80 85       	ldd	r24, Z+8	; 0x08
    26ec:	91 85       	ldd	r25, Z+9	; 0x09
    26ee:	0e 94 c9 09 	call	0x1392	; 0x1392 <xQueueGenericSend>
    26f2:	91 e0       	ldi	r25, 0x01	; 1
    26f4:	81 11       	cpse	r24, r1
    26f6:	01 c0       	rjmp	.+2      	; 0x26fa <_ZN14frt_text_queue7putcharEc+0x30>
    26f8:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    26fa:	89 2f       	mov	r24, r25
    26fc:	0f 90       	pop	r0
    26fe:	df 91       	pop	r29
    2700:	cf 91       	pop	r28
    2702:	0f 91       	pop	r16
    2704:	08 95       	ret

00002706 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2706:	8f 92       	push	r8
    2708:	9f 92       	push	r9
    270a:	bf 92       	push	r11
    270c:	cf 92       	push	r12
    270e:	df 92       	push	r13
    2710:	ef 92       	push	r14
    2712:	ff 92       	push	r15
    2714:	0f 93       	push	r16
    2716:	1f 93       	push	r17
    2718:	cf 93       	push	r28
    271a:	df 93       	push	r29
    271c:	ec 01       	movw	r28, r24
    271e:	b6 2e       	mov	r11, r22
    2720:	4a 01       	movw	r8, r20
    2722:	68 01       	movw	r12, r16
    2724:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2726:	0e 94 d7 15 	call	0x2bae	; 0x2bae <_ZN8emstreamC1Ev>
    272a:	87 e2       	ldi	r24, 0x27	; 39
    272c:	90 e2       	ldi	r25, 0x20	; 32
    272e:	88 83       	st	Y, r24
    2730:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2732:	8e 86       	std	Y+14, r8	; 0x0e
    2734:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2736:	40 e0       	ldi	r20, 0x00	; 0
    2738:	61 e0       	ldi	r22, 0x01	; 1
    273a:	8b 2d       	mov	r24, r11
    273c:	0e 94 9b 09 	call	0x1336	; 0x1336 <xQueueGenericCreate>
    2740:	88 87       	std	Y+8, r24	; 0x08
    2742:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2744:	ca 86       	std	Y+10, r12	; 0x0a
    2746:	db 86       	std	Y+11, r13	; 0x0b
    2748:	ec 86       	std	Y+12, r14	; 0x0c
    274a:	fd 86       	std	Y+13, r15	; 0x0d
}
    274c:	df 91       	pop	r29
    274e:	cf 91       	pop	r28
    2750:	1f 91       	pop	r17
    2752:	0f 91       	pop	r16
    2754:	ff 90       	pop	r15
    2756:	ef 90       	pop	r14
    2758:	df 90       	pop	r13
    275a:	cf 90       	pop	r12
    275c:	bf 90       	pop	r11
    275e:	9f 90       	pop	r9
    2760:	8f 90       	pop	r8
    2762:	08 95       	ret

00002764 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2764:	cf 92       	push	r12
    2766:	df 92       	push	r13
    2768:	ef 92       	push	r14
    276a:	ff 92       	push	r15
    276c:	cf 93       	push	r28
    276e:	df 93       	push	r29
    2770:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2772:	68 81       	ld	r22, Y
    2774:	79 81       	ldd	r23, Y+1	; 0x01
    2776:	8a 81       	ldd	r24, Y+2	; 0x02
    2778:	9b 81       	ldd	r25, Y+3	; 0x03
    277a:	0f 2e       	mov	r0, r31
    277c:	f8 ee       	ldi	r31, 0xE8	; 232
    277e:	cf 2e       	mov	r12, r31
    2780:	f3 e0       	ldi	r31, 0x03	; 3
    2782:	df 2e       	mov	r13, r31
    2784:	e1 2c       	mov	r14, r1
    2786:	f1 2c       	mov	r15, r1
    2788:	f0 2d       	mov	r31, r0
    278a:	a7 01       	movw	r20, r14
    278c:	96 01       	movw	r18, r12
    278e:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__udivmodsi4>
    2792:	9b 01       	movw	r18, r22
    2794:	ac 01       	movw	r20, r24
    2796:	60 e4       	ldi	r22, 0x40	; 64
    2798:	72 e4       	ldi	r23, 0x42	; 66
    279a:	8f e0       	ldi	r24, 0x0F	; 15
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	0e 94 c8 1b 	call	0x3790	; 0x3790 <__mulsi3>
    27a2:	a7 01       	movw	r20, r14
    27a4:	96 01       	movw	r18, r12
    27a6:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__udivmodsi4>
    27aa:	69 01       	movw	r12, r18
    27ac:	7a 01       	movw	r14, r20
    27ae:	ac 81       	ldd	r26, Y+4	; 0x04
    27b0:	bd 81       	ldd	r27, Y+5	; 0x05
    27b2:	20 e4       	ldi	r18, 0x40	; 64
    27b4:	32 e4       	ldi	r19, 0x42	; 66
    27b6:	4f e0       	ldi	r20, 0x0F	; 15
    27b8:	50 e0       	ldi	r21, 0x00	; 0
    27ba:	0e 94 31 1c 	call	0x3862	; 0x3862 <__muluhisi3>
    27be:	20 e0       	ldi	r18, 0x00	; 0
    27c0:	38 e4       	ldi	r19, 0x48	; 72
    27c2:	48 ee       	ldi	r20, 0xE8	; 232
    27c4:	51 e0       	ldi	r21, 0x01	; 1
    27c6:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__udivmodsi4>
    27ca:	c7 01       	movw	r24, r14
    27cc:	b6 01       	movw	r22, r12
    27ce:	62 0f       	add	r22, r18
    27d0:	73 1f       	adc	r23, r19
    27d2:	84 1f       	adc	r24, r20
    27d4:	95 1f       	adc	r25, r21
}
    27d6:	df 91       	pop	r29
    27d8:	cf 91       	pop	r28
    27da:	ff 90       	pop	r15
    27dc:	ef 90       	pop	r14
    27de:	df 90       	pop	r13
    27e0:	cf 90       	pop	r12
    27e2:	08 95       	ret

000027e4 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    27e4:	cf 92       	push	r12
    27e6:	df 92       	push	r13
    27e8:	ef 92       	push	r14
    27ea:	ff 92       	push	r15
    27ec:	0f 93       	push	r16
    27ee:	1f 93       	push	r17
    27f0:	cf 93       	push	r28
    27f2:	df 93       	push	r29
    27f4:	cd b7       	in	r28, 0x3d	; 61
    27f6:	de b7       	in	r29, 0x3e	; 62
    27f8:	2f 97       	sbiw	r28, 0x0f	; 15
    27fa:	cd bf       	out	0x3d, r28	; 61
    27fc:	de bf       	out	0x3e, r29	; 62
    27fe:	6c 01       	movw	r12, r24
    2800:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2802:	db 01       	movw	r26, r22
    2804:	6d 91       	ld	r22, X+
    2806:	7d 91       	ld	r23, X+
    2808:	8d 91       	ld	r24, X+
    280a:	9c 91       	ld	r25, X
    280c:	28 ee       	ldi	r18, 0xE8	; 232
    280e:	33 e0       	ldi	r19, 0x03	; 3
    2810:	40 e0       	ldi	r20, 0x00	; 0
    2812:	50 e0       	ldi	r21, 0x00	; 0
    2814:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__udivmodsi4>
    2818:	ba 01       	movw	r22, r20
    281a:	a9 01       	movw	r20, r18
    281c:	c6 01       	movw	r24, r12
    281e:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2822:	d6 01       	movw	r26, r12
    2824:	ed 91       	ld	r30, X+
    2826:	fc 91       	ld	r31, X
    2828:	02 80       	ldd	r0, Z+2	; 0x02
    282a:	f3 81       	ldd	r31, Z+3	; 0x03
    282c:	e0 2d       	mov	r30, r0
    282e:	6e e2       	ldi	r22, 0x2E	; 46
    2830:	c6 01       	movw	r24, r12
    2832:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2834:	c8 01       	movw	r24, r16
    2836:	0e 94 b2 13 	call	0x2764	; 0x2764 <_ZN10time_stamp12get_microsecEv>
    283a:	8e 01       	movw	r16, r28
    283c:	09 5f       	subi	r16, 0xF9	; 249
    283e:	1f 4f       	sbci	r17, 0xFF	; 255
    2840:	fe 01       	movw	r30, r28
    2842:	31 96       	adiw	r30, 0x01	; 1
    2844:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2846:	2a e0       	ldi	r18, 0x0A	; 10
    2848:	30 e0       	ldi	r19, 0x00	; 0
    284a:	40 e0       	ldi	r20, 0x00	; 0
    284c:	50 e0       	ldi	r21, 0x00	; 0
    284e:	0e 94 fa 1b 	call	0x37f4	; 0x37f4 <__divmodsi4>
    2852:	e6 2f       	mov	r30, r22
    2854:	28 87       	std	Y+8, r18	; 0x08
    2856:	39 87       	std	Y+9, r19	; 0x09
    2858:	4a 87       	std	Y+10, r20	; 0x0a
    285a:	5b 87       	std	Y+11, r21	; 0x0b
    285c:	68 85       	ldd	r22, Y+8	; 0x08
    285e:	79 85       	ldd	r23, Y+9	; 0x09
    2860:	8a 85       	ldd	r24, Y+10	; 0x0a
    2862:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2864:	20 e3       	ldi	r18, 0x30	; 48
    2866:	2e 0f       	add	r18, r30
    2868:	d8 01       	movw	r26, r16
    286a:	2e 93       	st	-X, r18
    286c:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    286e:	ae 15       	cp	r26, r14
    2870:	bf 05       	cpc	r27, r15
    2872:	49 f7       	brne	.-46     	; 0x2846 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2874:	1f 82       	std	Y+7, r1	; 0x07
    2876:	be 01       	movw	r22, r28
    2878:	6f 5f       	subi	r22, 0xFF	; 255
    287a:	7f 4f       	sbci	r23, 0xFF	; 255
    287c:	c6 01       	movw	r24, r12
    287e:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2882:	c6 01       	movw	r24, r12
    2884:	2f 96       	adiw	r28, 0x0f	; 15
    2886:	cd bf       	out	0x3d, r28	; 61
    2888:	de bf       	out	0x3e, r29	; 62
    288a:	df 91       	pop	r29
    288c:	cf 91       	pop	r28
    288e:	1f 91       	pop	r17
    2890:	0f 91       	pop	r16
    2892:	ff 90       	pop	r15
    2894:	ef 90       	pop	r14
    2896:	df 90       	pop	r13
    2898:	cf 90       	pop	r12
    289a:	08 95       	ret

0000289c <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    289c:	cf 93       	push	r28
    289e:	df 93       	push	r29
    28a0:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	f8 94       	cli
    28a6:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    28a8:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    28ac:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    28b0:	8c 83       	std	Y+4, r24	; 0x04
    28b2:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    28b4:	0e 94 cf 0c 	call	0x199e	; 0x199e <xTaskGetTickCount>
    28b8:	68 83       	st	Y, r22
    28ba:	79 83       	std	Y+1, r23	; 0x01
    28bc:	8a 83       	std	Y+2, r24	; 0x02
    28be:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    28c0:	0f 90       	pop	r0
    28c2:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    28c4:	ce 01       	movw	r24, r28
    28c6:	df 91       	pop	r29
    28c8:	cf 91       	pop	r28
    28ca:	08 95       	ret

000028cc <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    28cc:	5f 92       	push	r5
    28ce:	6f 92       	push	r6
    28d0:	7f 92       	push	r7
    28d2:	8f 92       	push	r8
    28d4:	9f 92       	push	r9
    28d6:	af 92       	push	r10
    28d8:	bf 92       	push	r11
    28da:	cf 92       	push	r12
    28dc:	df 92       	push	r13
    28de:	ef 92       	push	r14
    28e0:	ff 92       	push	r15
    28e2:	0f 93       	push	r16
    28e4:	1f 93       	push	r17
    28e6:	cf 93       	push	r28
    28e8:	df 93       	push	r29
    28ea:	5c 01       	movw	r10, r24
    28ec:	4b 01       	movw	r8, r22
    28ee:	7a 01       	movw	r14, r20
    28f0:	12 2f       	mov	r17, r18
    28f2:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    28f4:	63 e0       	ldi	r22, 0x03	; 3
    28f6:	ca 01       	movw	r24, r20
    28f8:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    28fc:	a8 14       	cp	r10, r8
    28fe:	b9 04       	cpc	r11, r9
    2900:	08 f0       	brcs	.+2      	; 0x2904 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2902:	7d c0       	rjmp	.+250    	; 0x29fe <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2904:	65 01       	movw	r12, r10
    2906:	84 e1       	ldi	r24, 0x14	; 20
    2908:	c8 0e       	add	r12, r24
    290a:	d1 1c       	adc	r13, r1
    290c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    290e:	6a 2c       	mov	r6, r10
    2910:	5b 2c       	mov	r5, r11
    2912:	b5 01       	movw	r22, r10
    2914:	c7 01       	movw	r24, r14
    2916:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZN8emstreamlsEj>
    291a:	6a e0       	ldi	r22, 0x0A	; 10
    291c:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2920:	69 e3       	ldi	r22, 0x39	; 57
    2922:	75 e0       	ldi	r23, 0x05	; 5
    2924:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2928:	11 23       	and	r17, r17
    292a:	09 f4       	brne	.+2      	; 0x292e <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    292c:	6d c0       	rjmp	.+218    	; 0x2a08 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    292e:	00 23       	and	r16, r16
    2930:	09 f4       	brne	.+2      	; 0x2934 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2932:	6a c0       	rjmp	.+212    	; 0x2a08 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2934:	6a e0       	ldi	r22, 0x0A	; 10
    2936:	c7 01       	movw	r24, r14
    2938:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    293c:	64 e3       	ldi	r22, 0x34	; 52
    293e:	75 e0       	ldi	r23, 0x05	; 5
    2940:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    2944:	61 c0       	rjmp	.+194    	; 0x2a08 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2946:	11 23       	and	r17, r17
    2948:	71 f0       	breq	.+28     	; 0x2966 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    294a:	01 11       	cpse	r16, r1
    294c:	0c c0       	rjmp	.+24     	; 0x2966 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    294e:	88 81       	ld	r24, Y
    2950:	87 15       	cp	r24, r7
    2952:	49 f0       	breq	.+18     	; 0x2966 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2954:	6a e0       	ldi	r22, 0x0A	; 10
    2956:	c7 01       	movw	r24, r14
    2958:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    295c:	6f e2       	ldi	r22, 0x2F	; 47
    295e:	75 e0       	ldi	r23, 0x05	; 5
    2960:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2964:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2966:	69 91       	ld	r22, Y+
    2968:	c7 01       	movw	r24, r14
    296a:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    296e:	dc 01       	movw	r26, r24
    2970:	ed 91       	ld	r30, X+
    2972:	fc 91       	ld	r31, X
    2974:	02 80       	ldd	r0, Z+2	; 0x02
    2976:	f3 81       	ldd	r31, Z+3	; 0x03
    2978:	e0 2d       	mov	r30, r0
    297a:	60 e2       	ldi	r22, 0x20	; 32
    297c:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    297e:	cc 16       	cp	r12, r28
    2980:	dd 06       	cpc	r13, r29
    2982:	09 f7       	brne	.-62     	; 0x2946 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2984:	11 23       	and	r17, r17
    2986:	89 f0       	breq	.+34     	; 0x29aa <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2988:	6a e0       	ldi	r22, 0x0A	; 10
    298a:	c7 01       	movw	r24, r14
    298c:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    2990:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2992:	69 e2       	ldi	r22, 0x29	; 41
    2994:	75 e0       	ldi	r23, 0x05	; 5
    2996:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    299a:	e8 81       	ld	r30, Y
    299c:	f9 81       	ldd	r31, Y+1	; 0x01
    299e:	02 80       	ldd	r0, Z+2	; 0x02
    29a0:	f3 81       	ldd	r31, Z+3	; 0x03
    29a2:	e0 2d       	mov	r30, r0
    29a4:	60 e2       	ldi	r22, 0x20	; 32
    29a6:	ce 01       	movw	r24, r28
    29a8:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    29aa:	c6 2d       	mov	r28, r6
    29ac:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    29ae:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    29b0:	80 ee       	ldi	r24, 0xE0	; 224
    29b2:	86 0f       	add	r24, r22
    29b4:	8f 35       	cpi	r24, 0x5F	; 95
    29b6:	48 f4       	brcc	.+18     	; 0x29ca <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    29b8:	d7 01       	movw	r26, r14
    29ba:	ed 91       	ld	r30, X+
    29bc:	fc 91       	ld	r31, X
    29be:	02 80       	ldd	r0, Z+2	; 0x02
    29c0:	f3 81       	ldd	r31, Z+3	; 0x03
    29c2:	e0 2d       	mov	r30, r0
    29c4:	c7 01       	movw	r24, r14
    29c6:	19 95       	eicall
    29c8:	09 c0       	rjmp	.+18     	; 0x29dc <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    29ca:	d7 01       	movw	r26, r14
    29cc:	ed 91       	ld	r30, X+
    29ce:	fc 91       	ld	r31, X
    29d0:	02 80       	ldd	r0, Z+2	; 0x02
    29d2:	f3 81       	ldd	r31, Z+3	; 0x03
    29d4:	e0 2d       	mov	r30, r0
    29d6:	6e e2       	ldi	r22, 0x2E	; 46
    29d8:	c7 01       	movw	r24, r14
    29da:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    29dc:	cc 16       	cp	r12, r28
    29de:	dd 06       	cpc	r13, r29
    29e0:	31 f7       	brne	.-52     	; 0x29ae <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    29e2:	b4 e1       	ldi	r27, 0x14	; 20
    29e4:	ab 0e       	add	r10, r27
    29e6:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    29e8:	66 e0       	ldi	r22, 0x06	; 6
    29ea:	c7 01       	movw	r24, r14
    29ec:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    29f0:	84 e1       	ldi	r24, 0x14	; 20
    29f2:	c8 0e       	add	r12, r24
    29f4:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    29f6:	a8 14       	cp	r10, r8
    29f8:	b9 04       	cpc	r11, r9
    29fa:	08 f4       	brcc	.+2      	; 0x29fe <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    29fc:	88 cf       	rjmp	.-240    	; 0x290e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    29fe:	62 e0       	ldi	r22, 0x02	; 2
    2a00:	c7 01       	movw	r24, r14
    2a02:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
}
    2a06:	03 c0       	rjmp	.+6      	; 0x2a0e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2a08:	c6 2d       	mov	r28, r6
    2a0a:	d5 2d       	mov	r29, r5
    2a0c:	9c cf       	rjmp	.-200    	; 0x2946 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2a0e:	df 91       	pop	r29
    2a10:	cf 91       	pop	r28
    2a12:	1f 91       	pop	r17
    2a14:	0f 91       	pop	r16
    2a16:	ff 90       	pop	r15
    2a18:	ef 90       	pop	r14
    2a1a:	df 90       	pop	r13
    2a1c:	cf 90       	pop	r12
    2a1e:	bf 90       	pop	r11
    2a20:	af 90       	pop	r10
    2a22:	9f 90       	pop	r9
    2a24:	8f 90       	pop	r8
    2a26:	7f 90       	pop	r7
    2a28:	6f 90       	pop	r6
    2a2a:	5f 90       	pop	r5
    2a2c:	08 95       	ret

00002a2e <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2a2e:	0e 94 b3 05 	call	0xb66	; 0xb66 <pvPortMalloc>
    2a32:	08 95       	ret

00002a34 <_Znaj>:
    2a34:	0e 94 b3 05 	call	0xb66	; 0xb66 <pvPortMalloc>
    2a38:	08 95       	ret

00002a3a <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2a3a:	08 95       	ret

00002a3c <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2a3c:	cf 93       	push	r28
    2a3e:	df 93       	push	r29
    2a40:	fc 01       	movw	r30, r24
    2a42:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2a44:	40 3a       	cpi	r20, 0xA0	; 160
    2a46:	68 e0       	ldi	r22, 0x08	; 8
    2a48:	56 07       	cpc	r21, r22
    2a4a:	49 f4       	brne	.+18     	; 0x2a5e <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2a4c:	80 e4       	ldi	r24, 0x40	; 64
    2a4e:	96 e0       	ldi	r25, 0x06	; 6
    2a50:	82 83       	std	Z+2, r24	; 0x02
    2a52:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2a54:	82 e0       	ldi	r24, 0x02	; 2
    2a56:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2a58:	83 e0       	ldi	r24, 0x03	; 3
    2a5a:	85 83       	std	Z+5, r24	; 0x05
    2a5c:	4c c0       	rjmp	.+152    	; 0x2af6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2a5e:	40 3b       	cpi	r20, 0xB0	; 176
    2a60:	78 e0       	ldi	r23, 0x08	; 8
    2a62:	57 07       	cpc	r21, r23
    2a64:	49 f4       	brne	.+18     	; 0x2a78 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2a66:	80 e4       	ldi	r24, 0x40	; 64
    2a68:	96 e0       	ldi	r25, 0x06	; 6
    2a6a:	82 83       	std	Z+2, r24	; 0x02
    2a6c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2a6e:	86 e0       	ldi	r24, 0x06	; 6
    2a70:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2a72:	87 e0       	ldi	r24, 0x07	; 7
    2a74:	85 83       	std	Z+5, r24	; 0x05
    2a76:	3f c0       	rjmp	.+126    	; 0x2af6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2a78:	40 3a       	cpi	r20, 0xA0	; 160
    2a7a:	89 e0       	ldi	r24, 0x09	; 9
    2a7c:	58 07       	cpc	r21, r24
    2a7e:	49 f4       	brne	.+18     	; 0x2a92 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2a80:	80 e6       	ldi	r24, 0x60	; 96
    2a82:	96 e0       	ldi	r25, 0x06	; 6
    2a84:	82 83       	std	Z+2, r24	; 0x02
    2a86:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2a88:	82 e0       	ldi	r24, 0x02	; 2
    2a8a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2a8c:	83 e0       	ldi	r24, 0x03	; 3
    2a8e:	85 83       	std	Z+5, r24	; 0x05
    2a90:	32 c0       	rjmp	.+100    	; 0x2af6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2a92:	40 3b       	cpi	r20, 0xB0	; 176
    2a94:	69 e0       	ldi	r22, 0x09	; 9
    2a96:	56 07       	cpc	r21, r22
    2a98:	49 f4       	brne	.+18     	; 0x2aac <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2a9a:	80 e6       	ldi	r24, 0x60	; 96
    2a9c:	96 e0       	ldi	r25, 0x06	; 6
    2a9e:	82 83       	std	Z+2, r24	; 0x02
    2aa0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2aa2:	86 e0       	ldi	r24, 0x06	; 6
    2aa4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2aa6:	87 e0       	ldi	r24, 0x07	; 7
    2aa8:	85 83       	std	Z+5, r24	; 0x05
    2aaa:	25 c0       	rjmp	.+74     	; 0x2af6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2aac:	40 3a       	cpi	r20, 0xA0	; 160
    2aae:	7a e0       	ldi	r23, 0x0A	; 10
    2ab0:	57 07       	cpc	r21, r23
    2ab2:	49 f4       	brne	.+18     	; 0x2ac6 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    2ab4:	80 e8       	ldi	r24, 0x80	; 128
    2ab6:	96 e0       	ldi	r25, 0x06	; 6
    2ab8:	82 83       	std	Z+2, r24	; 0x02
    2aba:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2abc:	82 e0       	ldi	r24, 0x02	; 2
    2abe:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2ac0:	83 e0       	ldi	r24, 0x03	; 3
    2ac2:	85 83       	std	Z+5, r24	; 0x05
    2ac4:	18 c0       	rjmp	.+48     	; 0x2af6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    2ac6:	40 3b       	cpi	r20, 0xB0	; 176
    2ac8:	8a e0       	ldi	r24, 0x0A	; 10
    2aca:	58 07       	cpc	r21, r24
    2acc:	49 f4       	brne	.+18     	; 0x2ae0 <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    2ace:	80 e8       	ldi	r24, 0x80	; 128
    2ad0:	96 e0       	ldi	r25, 0x06	; 6
    2ad2:	82 83       	std	Z+2, r24	; 0x02
    2ad4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2ad6:	86 e0       	ldi	r24, 0x06	; 6
    2ad8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2ada:	87 e0       	ldi	r24, 0x07	; 7
    2adc:	85 83       	std	Z+5, r24	; 0x05
    2ade:	0b c0       	rjmp	.+22     	; 0x2af6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    2ae0:	40 3a       	cpi	r20, 0xA0	; 160
    2ae2:	5b 40       	sbci	r21, 0x0B	; 11
    2ae4:	41 f4       	brne	.+16     	; 0x2af6 <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    2ae6:	80 ea       	ldi	r24, 0xA0	; 160
    2ae8:	96 e0       	ldi	r25, 0x06	; 6
    2aea:	82 83       	std	Z+2, r24	; 0x02
    2aec:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2aee:	82 e0       	ldi	r24, 0x02	; 2
    2af0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2af2:	83 e0       	ldi	r24, 0x03	; 3
    2af4:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2af6:	a6 83       	std	Z+6, r26	; 0x06
    2af8:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2afa:	cd 01       	movw	r24, r26
    2afc:	01 96       	adiw	r24, 0x01	; 1
    2afe:	80 87       	std	Z+8, r24	; 0x08
    2b00:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2b02:	03 96       	adiw	r24, 0x03	; 3
    2b04:	82 87       	std	Z+10, r24	; 0x0a
    2b06:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2b08:	25 81       	ldd	r18, Z+5	; 0x05
    2b0a:	c2 81       	ldd	r28, Z+2	; 0x02
    2b0c:	d3 81       	ldd	r29, Z+3	; 0x03
    2b0e:	4c 81       	ldd	r20, Y+4	; 0x04
    2b10:	81 e0       	ldi	r24, 0x01	; 1
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	bc 01       	movw	r22, r24
    2b16:	02 c0       	rjmp	.+4      	; 0x2b1c <_ZN7base232C1EjP12USART_struct+0xe0>
    2b18:	66 0f       	add	r22, r22
    2b1a:	77 1f       	adc	r23, r23
    2b1c:	2a 95       	dec	r18
    2b1e:	e2 f7       	brpl	.-8      	; 0x2b18 <_ZN7base232C1EjP12USART_struct+0xdc>
    2b20:	9b 01       	movw	r18, r22
    2b22:	24 2b       	or	r18, r20
    2b24:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2b26:	25 81       	ldd	r18, Z+5	; 0x05
    2b28:	c2 81       	ldd	r28, Z+2	; 0x02
    2b2a:	d3 81       	ldd	r29, Z+3	; 0x03
    2b2c:	48 81       	ld	r20, Y
    2b2e:	bc 01       	movw	r22, r24
    2b30:	02 c0       	rjmp	.+4      	; 0x2b36 <_ZN7base232C1EjP12USART_struct+0xfa>
    2b32:	66 0f       	add	r22, r22
    2b34:	77 1f       	adc	r23, r23
    2b36:	2a 95       	dec	r18
    2b38:	e2 f7       	brpl	.-8      	; 0x2b32 <_ZN7base232C1EjP12USART_struct+0xf6>
    2b3a:	9b 01       	movw	r18, r22
    2b3c:	24 2b       	or	r18, r20
    2b3e:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2b40:	34 81       	ldd	r19, Z+4	; 0x04
    2b42:	c2 81       	ldd	r28, Z+2	; 0x02
    2b44:	d3 81       	ldd	r29, Z+3	; 0x03
    2b46:	28 81       	ld	r18, Y
    2b48:	02 c0       	rjmp	.+4      	; 0x2b4e <_ZN7base232C1EjP12USART_struct+0x112>
    2b4a:	88 0f       	add	r24, r24
    2b4c:	99 1f       	adc	r25, r25
    2b4e:	3a 95       	dec	r19
    2b50:	e2 f7       	brpl	.-8      	; 0x2b4a <_ZN7base232C1EjP12USART_struct+0x10e>
    2b52:	80 95       	com	r24
    2b54:	90 95       	com	r25
    2b56:	82 23       	and	r24, r18
    2b58:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2b5a:	80 e1       	ldi	r24, 0x10	; 16
    2b5c:	13 96       	adiw	r26, 0x03	; 3
    2b5e:	8c 93       	st	X, r24
    2b60:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2b62:	83 e0       	ldi	r24, 0x03	; 3
    2b64:	15 96       	adiw	r26, 0x05	; 5
    2b66:	8c 93       	st	X, r24
    2b68:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2b6a:	80 ef       	ldi	r24, 0xF0	; 240
    2b6c:	17 96       	adiw	r26, 0x07	; 7
    2b6e:	8c 93       	st	X, r24
    2b70:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2b72:	81 e2       	ldi	r24, 0x21	; 33
    2b74:	16 96       	adiw	r26, 0x06	; 6
    2b76:	8c 93       	st	X, r24
    2b78:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2b7a:	88 e1       	ldi	r24, 0x18	; 24
    2b7c:	14 96       	adiw	r26, 0x04	; 4
    2b7e:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2b80:	80 e8       	ldi	r24, 0x80	; 128
    2b82:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2b84:	80 e4       	ldi	r24, 0x40	; 64
    2b86:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2b88:	80 e2       	ldi	r24, 0x20	; 32
    2b8a:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2b8c:	06 80       	ldd	r0, Z+6	; 0x06
    2b8e:	f7 81       	ldd	r31, Z+7	; 0x07
    2b90:	e0 2d       	mov	r30, r0
    2b92:	80 81       	ld	r24, Z
    2b94:	80 81       	ld	r24, Z
}
    2b96:	df 91       	pop	r29
    2b98:	cf 91       	pop	r28
    2b9a:	08 95       	ret

00002b9c <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
    2b9e:	08 95       	ret

00002ba0 <_ZN8emstream7getcharEv>:
    2ba0:	80 e0       	ldi	r24, 0x00	; 0
    2ba2:	90 e0       	ldi	r25, 0x00	; 0
    2ba4:	08 95       	ret

00002ba6 <_ZN8emstream14check_for_charEv>:
    2ba6:	80 e0       	ldi	r24, 0x00	; 0
    2ba8:	08 95       	ret

00002baa <_ZN8emstream12transmit_nowEv>:
    2baa:	08 95       	ret

00002bac <_ZN8emstream12clear_screenEv>:
    2bac:	08 95       	ret

00002bae <_ZN8emstreamC1Ev>:
    2bae:	fc 01       	movw	r30, r24
    2bb0:	87 e3       	ldi	r24, 0x37	; 55
    2bb2:	90 e2       	ldi	r25, 0x20	; 32
    2bb4:	80 83       	st	Z, r24
    2bb6:	91 83       	std	Z+1, r25	; 0x01
    2bb8:	8a e0       	ldi	r24, 0x0A	; 10
    2bba:	82 83       	std	Z+2, r24	; 0x02
    2bbc:	13 82       	std	Z+3, r1	; 0x03
    2bbe:	83 e0       	ldi	r24, 0x03	; 3
    2bc0:	85 83       	std	Z+5, r24	; 0x05
    2bc2:	14 82       	std	Z+4, r1	; 0x04
    2bc4:	16 82       	std	Z+6, r1	; 0x06
    2bc6:	17 82       	std	Z+7, r1	; 0x07
    2bc8:	08 95       	ret

00002bca <_ZN8emstream4putsEPKc>:
    2bca:	0f 93       	push	r16
    2bcc:	1f 93       	push	r17
    2bce:	cf 93       	push	r28
    2bd0:	df 93       	push	r29
    2bd2:	8c 01       	movw	r16, r24
    2bd4:	fb 01       	movw	r30, r22
    2bd6:	dc 01       	movw	r26, r24
    2bd8:	14 96       	adiw	r26, 0x04	; 4
    2bda:	8c 91       	ld	r24, X
    2bdc:	81 11       	cpse	r24, r1
    2bde:	04 c0       	rjmp	.+8      	; 0x2be8 <_ZN8emstream4putsEPKc+0x1e>
    2be0:	60 81       	ld	r22, Z
    2be2:	61 11       	cpse	r22, r1
    2be4:	17 c0       	rjmp	.+46     	; 0x2c14 <_ZN8emstream4putsEPKc+0x4a>
    2be6:	23 c0       	rjmp	.+70     	; 0x2c2e <_ZN8emstream4putsEPKc+0x64>
    2be8:	d8 01       	movw	r26, r16
    2bea:	14 96       	adiw	r26, 0x04	; 4
    2bec:	1c 92       	st	X, r1
    2bee:	eb 01       	movw	r28, r22
    2bf0:	21 96       	adiw	r28, 0x01	; 1
    2bf2:	64 91       	lpm	r22, Z
    2bf4:	66 23       	and	r22, r22
    2bf6:	d9 f0       	breq	.+54     	; 0x2c2e <_ZN8emstream4putsEPKc+0x64>
    2bf8:	d8 01       	movw	r26, r16
    2bfa:	ed 91       	ld	r30, X+
    2bfc:	fc 91       	ld	r31, X
    2bfe:	02 80       	ldd	r0, Z+2	; 0x02
    2c00:	f3 81       	ldd	r31, Z+3	; 0x03
    2c02:	e0 2d       	mov	r30, r0
    2c04:	c8 01       	movw	r24, r16
    2c06:	19 95       	eicall
    2c08:	fe 01       	movw	r30, r28
    2c0a:	64 91       	lpm	r22, Z
    2c0c:	21 96       	adiw	r28, 0x01	; 1
    2c0e:	61 11       	cpse	r22, r1
    2c10:	f3 cf       	rjmp	.-26     	; 0x2bf8 <_ZN8emstream4putsEPKc+0x2e>
    2c12:	0d c0       	rjmp	.+26     	; 0x2c2e <_ZN8emstream4putsEPKc+0x64>
    2c14:	ef 01       	movw	r28, r30
    2c16:	21 96       	adiw	r28, 0x01	; 1
    2c18:	d8 01       	movw	r26, r16
    2c1a:	ed 91       	ld	r30, X+
    2c1c:	fc 91       	ld	r31, X
    2c1e:	02 80       	ldd	r0, Z+2	; 0x02
    2c20:	f3 81       	ldd	r31, Z+3	; 0x03
    2c22:	e0 2d       	mov	r30, r0
    2c24:	c8 01       	movw	r24, r16
    2c26:	19 95       	eicall
    2c28:	69 91       	ld	r22, Y+
    2c2a:	61 11       	cpse	r22, r1
    2c2c:	f5 cf       	rjmp	.-22     	; 0x2c18 <_ZN8emstream4putsEPKc+0x4e>
    2c2e:	df 91       	pop	r29
    2c30:	cf 91       	pop	r28
    2c32:	1f 91       	pop	r17
    2c34:	0f 91       	pop	r16
    2c36:	08 95       	ret

00002c38 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2c38:	cf 93       	push	r28
    2c3a:	df 93       	push	r29
    2c3c:	ec 01       	movw	r28, r24
	switch (new_manip)
    2c3e:	86 2f       	mov	r24, r22
    2c40:	90 e0       	ldi	r25, 0x00	; 0
    2c42:	8b 30       	cpi	r24, 0x0B	; 11
    2c44:	91 05       	cpc	r25, r1
    2c46:	d8 f5       	brcc	.+118    	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
    2c48:	fc 01       	movw	r30, r24
    2c4a:	88 27       	eor	r24, r24
    2c4c:	e2 50       	subi	r30, 0x02	; 2
    2c4e:	ff 4f       	sbci	r31, 0xFF	; 255
    2c50:	8f 4f       	sbci	r24, 0xFF	; 255
    2c52:	0c 94 19 1c 	jmp	0x3832	; 0x3832 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    2c56:	82 e0       	ldi	r24, 0x02	; 2
    2c58:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2c5a:	31 c0       	rjmp	.+98     	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    2c5c:	88 e0       	ldi	r24, 0x08	; 8
    2c5e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2c60:	2e c0       	rjmp	.+92     	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    2c62:	8a e0       	ldi	r24, 0x0A	; 10
    2c64:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2c66:	2b c0       	rjmp	.+86     	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    2c68:	80 e1       	ldi	r24, 0x10	; 16
    2c6a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2c6c:	28 c0       	rjmp	.+80     	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    2c6e:	81 e0       	ldi	r24, 0x01	; 1
    2c70:	8b 83       	std	Y+3, r24	; 0x03
			break;
    2c72:	25 c0       	rjmp	.+74     	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    2c74:	1b 82       	std	Y+3, r1	; 0x03
			break;
    2c76:	23 c0       	rjmp	.+70     	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2c78:	e8 81       	ld	r30, Y
    2c7a:	f9 81       	ldd	r31, Y+1	; 0x01
    2c7c:	02 80       	ldd	r0, Z+2	; 0x02
    2c7e:	f3 81       	ldd	r31, Z+3	; 0x03
    2c80:	e0 2d       	mov	r30, r0
    2c82:	6d e0       	ldi	r22, 0x0D	; 13
    2c84:	ce 01       	movw	r24, r28
    2c86:	19 95       	eicall
    2c88:	e8 81       	ld	r30, Y
    2c8a:	f9 81       	ldd	r31, Y+1	; 0x01
    2c8c:	02 80       	ldd	r0, Z+2	; 0x02
    2c8e:	f3 81       	ldd	r31, Z+3	; 0x03
    2c90:	e0 2d       	mov	r30, r0
    2c92:	6a e0       	ldi	r22, 0x0A	; 10
    2c94:	ce 01       	movw	r24, r28
    2c96:	19 95       	eicall
			break;
    2c98:	12 c0       	rjmp	.+36     	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2c9a:	e8 81       	ld	r30, Y
    2c9c:	f9 81       	ldd	r31, Y+1	; 0x01
    2c9e:	02 84       	ldd	r0, Z+10	; 0x0a
    2ca0:	f3 85       	ldd	r31, Z+11	; 0x0b
    2ca2:	e0 2d       	mov	r30, r0
    2ca4:	ce 01       	movw	r24, r28
    2ca6:	19 95       	eicall
			break;
    2ca8:	0a c0       	rjmp	.+20     	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    2caa:	e8 81       	ld	r30, Y
    2cac:	f9 81       	ldd	r31, Y+1	; 0x01
    2cae:	00 84       	ldd	r0, Z+8	; 0x08
    2cb0:	f1 85       	ldd	r31, Z+9	; 0x09
    2cb2:	e0 2d       	mov	r30, r0
    2cb4:	ce 01       	movw	r24, r28
    2cb6:	19 95       	eicall
			break;
    2cb8:	02 c0       	rjmp	.+4      	; 0x2cbe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    2cba:	81 e0       	ldi	r24, 0x01	; 1
    2cbc:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    2cbe:	ce 01       	movw	r24, r28
    2cc0:	df 91       	pop	r29
    2cc2:	cf 91       	pop	r28
    2cc4:	08 95       	ret

00002cc6 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    2cc6:	0f 93       	push	r16
    2cc8:	1f 93       	push	r17
    2cca:	cf 93       	push	r28
    2ccc:	df 93       	push	r29
    2cce:	cd b7       	in	r28, 0x3d	; 61
    2cd0:	de b7       	in	r29, 0x3e	; 62
    2cd2:	61 97       	sbiw	r28, 0x11	; 17
    2cd4:	cd bf       	out	0x3d, r28	; 61
    2cd6:	de bf       	out	0x3e, r29	; 62
    2cd8:	8c 01       	movw	r16, r24
    2cda:	9b 01       	movw	r18, r22
	if (base != 10)
    2cdc:	fc 01       	movw	r30, r24
    2cde:	92 81       	ldd	r25, Z+2	; 0x02
    2ce0:	9a 30       	cpi	r25, 0x0A	; 10
    2ce2:	21 f0       	breq	.+8      	; 0x2cec <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    2ce4:	c8 01       	movw	r24, r16
    2ce6:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZN8emstreamlsEj>
    2cea:	0d c0       	rjmp	.+26     	; 0x2d06 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    2cec:	4a e0       	ldi	r20, 0x0A	; 10
    2cee:	be 01       	movw	r22, r28
    2cf0:	6f 5f       	subi	r22, 0xFF	; 255
    2cf2:	7f 4f       	sbci	r23, 0xFF	; 255
    2cf4:	c9 01       	movw	r24, r18
    2cf6:	0e 94 5b 1c 	call	0x38b6	; 0x38b6 <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    2cfa:	be 01       	movw	r22, r28
    2cfc:	6f 5f       	subi	r22, 0xFF	; 255
    2cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    2d00:	c8 01       	movw	r24, r16
    2d02:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    2d06:	c8 01       	movw	r24, r16
    2d08:	61 96       	adiw	r28, 0x11	; 17
    2d0a:	cd bf       	out	0x3d, r28	; 61
    2d0c:	de bf       	out	0x3e, r29	; 62
    2d0e:	df 91       	pop	r29
    2d10:	cf 91       	pop	r28
    2d12:	1f 91       	pop	r17
    2d14:	0f 91       	pop	r16
    2d16:	08 95       	ret

00002d18 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    2d18:	ff 92       	push	r15
    2d1a:	0f 93       	push	r16
    2d1c:	1f 93       	push	r17
    2d1e:	cf 93       	push	r28
    2d20:	df 93       	push	r29
    2d22:	cd b7       	in	r28, 0x3d	; 61
    2d24:	de b7       	in	r29, 0x3e	; 62
    2d26:	61 97       	sbiw	r28, 0x11	; 17
    2d28:	cd bf       	out	0x3d, r28	; 61
    2d2a:	de bf       	out	0x3e, r29	; 62
    2d2c:	8c 01       	movw	r16, r24
    2d2e:	f6 2e       	mov	r15, r22
    2d30:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2d32:	f8 01       	movw	r30, r16
    2d34:	42 81       	ldd	r20, Z+2	; 0x02
    2d36:	40 31       	cpi	r20, 0x10	; 16
    2d38:	21 f0       	breq	.+8      	; 0x2d42 <_ZN8emstreamlsEj+0x2a>
    2d3a:	48 30       	cpi	r20, 0x08	; 8
    2d3c:	11 f0       	breq	.+4      	; 0x2d42 <_ZN8emstreamlsEj+0x2a>
    2d3e:	42 30       	cpi	r20, 0x02	; 2
    2d40:	41 f4       	brne	.+16     	; 0x2d52 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    2d42:	69 2f       	mov	r22, r25
    2d44:	c8 01       	movw	r24, r16
    2d46:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
    2d4a:	6f 2d       	mov	r22, r15
    2d4c:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
    2d50:	0d c0       	rjmp	.+26     	; 0x2d6c <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    2d52:	50 e0       	ldi	r21, 0x00	; 0
    2d54:	be 01       	movw	r22, r28
    2d56:	6f 5f       	subi	r22, 0xFF	; 255
    2d58:	7f 4f       	sbci	r23, 0xFF	; 255
    2d5a:	8f 2d       	mov	r24, r15
    2d5c:	0e 94 93 1c 	call	0x3926	; 0x3926 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    2d60:	be 01       	movw	r22, r28
    2d62:	6f 5f       	subi	r22, 0xFF	; 255
    2d64:	7f 4f       	sbci	r23, 0xFF	; 255
    2d66:	c8 01       	movw	r24, r16
    2d68:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    2d6c:	c8 01       	movw	r24, r16
    2d6e:	61 96       	adiw	r28, 0x11	; 17
    2d70:	cd bf       	out	0x3d, r28	; 61
    2d72:	de bf       	out	0x3e, r29	; 62
    2d74:	df 91       	pop	r29
    2d76:	cf 91       	pop	r28
    2d78:	1f 91       	pop	r17
    2d7a:	0f 91       	pop	r16
    2d7c:	ff 90       	pop	r15
    2d7e:	08 95       	ret

00002d80 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    2d80:	df 92       	push	r13
    2d82:	ef 92       	push	r14
    2d84:	ff 92       	push	r15
    2d86:	0f 93       	push	r16
    2d88:	1f 93       	push	r17
    2d8a:	cf 93       	push	r28
    2d8c:	df 93       	push	r29
    2d8e:	cd b7       	in	r28, 0x3d	; 61
    2d90:	de b7       	in	r29, 0x3e	; 62
    2d92:	a1 97       	sbiw	r28, 0x21	; 33
    2d94:	cd bf       	out	0x3d, r28	; 61
    2d96:	de bf       	out	0x3e, r29	; 62
    2d98:	8c 01       	movw	r16, r24
    2d9a:	d4 2e       	mov	r13, r20
    2d9c:	e5 2e       	mov	r14, r21
    2d9e:	f6 2e       	mov	r15, r22
    2da0:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2da2:	f8 01       	movw	r30, r16
    2da4:	22 81       	ldd	r18, Z+2	; 0x02
    2da6:	20 31       	cpi	r18, 0x10	; 16
    2da8:	21 f0       	breq	.+8      	; 0x2db2 <_ZN8emstreamlsEm+0x32>
    2daa:	28 30       	cpi	r18, 0x08	; 8
    2dac:	11 f0       	breq	.+4      	; 0x2db2 <_ZN8emstreamlsEm+0x32>
    2dae:	22 30       	cpi	r18, 0x02	; 2
    2db0:	71 f4       	brne	.+28     	; 0x2dce <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    2db2:	69 2f       	mov	r22, r25
    2db4:	c8 01       	movw	r24, r16
    2db6:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
    2dba:	6f 2d       	mov	r22, r15
    2dbc:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
    2dc0:	6e 2d       	mov	r22, r14
    2dc2:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
    2dc6:	6d 2d       	mov	r22, r13
    2dc8:	0e 94 02 17 	call	0x2e04	; 0x2e04 <_ZN8emstreamlsEh>
    2dcc:	0f c0       	rjmp	.+30     	; 0x2dec <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    2dce:	30 e0       	ldi	r19, 0x00	; 0
    2dd0:	ae 01       	movw	r20, r28
    2dd2:	4f 5f       	subi	r20, 0xFF	; 255
    2dd4:	5f 4f       	sbci	r21, 0xFF	; 255
    2dd6:	6d 2d       	mov	r22, r13
    2dd8:	7e 2d       	mov	r23, r14
    2dda:	8f 2d       	mov	r24, r15
    2ddc:	0e 94 66 1c 	call	0x38cc	; 0x38cc <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    2de0:	be 01       	movw	r22, r28
    2de2:	6f 5f       	subi	r22, 0xFF	; 255
    2de4:	7f 4f       	sbci	r23, 0xFF	; 255
    2de6:	c8 01       	movw	r24, r16
    2de8:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    2dec:	c8 01       	movw	r24, r16
    2dee:	a1 96       	adiw	r28, 0x21	; 33
    2df0:	cd bf       	out	0x3d, r28	; 61
    2df2:	de bf       	out	0x3e, r29	; 62
    2df4:	df 91       	pop	r29
    2df6:	cf 91       	pop	r28
    2df8:	1f 91       	pop	r17
    2dfa:	0f 91       	pop	r16
    2dfc:	ff 90       	pop	r15
    2dfe:	ef 90       	pop	r14
    2e00:	df 90       	pop	r13
    2e02:	08 95       	ret

00002e04 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    2e04:	cf 92       	push	r12
    2e06:	df 92       	push	r13
    2e08:	ef 92       	push	r14
    2e0a:	ff 92       	push	r15
    2e0c:	0f 93       	push	r16
    2e0e:	1f 93       	push	r17
    2e10:	cf 93       	push	r28
    2e12:	df 93       	push	r29
    2e14:	cd b7       	in	r28, 0x3d	; 61
    2e16:	de b7       	in	r29, 0x3e	; 62
    2e18:	29 97       	sbiw	r28, 0x09	; 9
    2e1a:	cd bf       	out	0x3d, r28	; 61
    2e1c:	de bf       	out	0x3e, r29	; 62
    2e1e:	8c 01       	movw	r16, r24
    2e20:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    2e22:	dc 01       	movw	r26, r24
    2e24:	13 96       	adiw	r26, 0x03	; 3
    2e26:	8c 91       	ld	r24, X
    2e28:	13 97       	sbiw	r26, 0x03	; 3
    2e2a:	88 23       	and	r24, r24
    2e2c:	41 f0       	breq	.+16     	; 0x2e3e <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    2e2e:	ed 91       	ld	r30, X+
    2e30:	fc 91       	ld	r31, X
    2e32:	02 80       	ldd	r0, Z+2	; 0x02
    2e34:	f3 81       	ldd	r31, Z+3	; 0x03
    2e36:	e0 2d       	mov	r30, r0
    2e38:	c8 01       	movw	r24, r16
    2e3a:	19 95       	eicall
    2e3c:	56 c0       	rjmp	.+172    	; 0x2eea <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    2e3e:	f8 01       	movw	r30, r16
    2e40:	42 81       	ldd	r20, Z+2	; 0x02
    2e42:	42 30       	cpi	r20, 0x02	; 2
    2e44:	19 f5       	brne	.+70     	; 0x2e8c <_ZN8emstreamlsEh+0x88>
    2e46:	68 94       	set
    2e48:	cc 24       	eor	r12, r12
    2e4a:	c3 f8       	bld	r12, 3
    2e4c:	d1 2c       	mov	r13, r1
    2e4e:	68 94       	set
    2e50:	ff 24       	eor	r15, r15
    2e52:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    2e54:	8e 2d       	mov	r24, r14
    2e56:	8f 21       	and	r24, r15
    2e58:	51 f0       	breq	.+20     	; 0x2e6e <_ZN8emstreamlsEh+0x6a>
    2e5a:	d8 01       	movw	r26, r16
    2e5c:	ed 91       	ld	r30, X+
    2e5e:	fc 91       	ld	r31, X
    2e60:	02 80       	ldd	r0, Z+2	; 0x02
    2e62:	f3 81       	ldd	r31, Z+3	; 0x03
    2e64:	e0 2d       	mov	r30, r0
    2e66:	61 e3       	ldi	r22, 0x31	; 49
    2e68:	c8 01       	movw	r24, r16
    2e6a:	19 95       	eicall
    2e6c:	09 c0       	rjmp	.+18     	; 0x2e80 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    2e6e:	d8 01       	movw	r26, r16
    2e70:	ed 91       	ld	r30, X+
    2e72:	fc 91       	ld	r31, X
    2e74:	02 80       	ldd	r0, Z+2	; 0x02
    2e76:	f3 81       	ldd	r31, Z+3	; 0x03
    2e78:	e0 2d       	mov	r30, r0
    2e7a:	60 e3       	ldi	r22, 0x30	; 48
    2e7c:	c8 01       	movw	r24, r16
    2e7e:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    2e80:	f6 94       	lsr	r15
    2e82:	b1 e0       	ldi	r27, 0x01	; 1
    2e84:	cb 1a       	sub	r12, r27
    2e86:	d1 08       	sbc	r13, r1
    2e88:	29 f7       	brne	.-54     	; 0x2e54 <_ZN8emstreamlsEh+0x50>
    2e8a:	2f c0       	rjmp	.+94     	; 0x2eea <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    2e8c:	40 31       	cpi	r20, 0x10	; 16
    2e8e:	f9 f4       	brne	.+62     	; 0x2ece <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    2e90:	62 95       	swap	r22
    2e92:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    2e94:	01 90       	ld	r0, Z+
    2e96:	f0 81       	ld	r31, Z
    2e98:	e0 2d       	mov	r30, r0
    2e9a:	02 80       	ldd	r0, Z+2	; 0x02
    2e9c:	f3 81       	ldd	r31, Z+3	; 0x03
    2e9e:	e0 2d       	mov	r30, r0
    2ea0:	6a 30       	cpi	r22, 0x0A	; 10
    2ea2:	10 f0       	brcs	.+4      	; 0x2ea8 <_ZN8emstreamlsEh+0xa4>
    2ea4:	69 5c       	subi	r22, 0xC9	; 201
    2ea6:	01 c0       	rjmp	.+2      	; 0x2eaa <_ZN8emstreamlsEh+0xa6>
    2ea8:	60 5d       	subi	r22, 0xD0	; 208
    2eaa:	c8 01       	movw	r24, r16
    2eac:	19 95       	eicall
		temp_char = num & 0x0F;
    2eae:	6e 2d       	mov	r22, r14
    2eb0:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    2eb2:	d8 01       	movw	r26, r16
    2eb4:	ed 91       	ld	r30, X+
    2eb6:	fc 91       	ld	r31, X
    2eb8:	02 80       	ldd	r0, Z+2	; 0x02
    2eba:	f3 81       	ldd	r31, Z+3	; 0x03
    2ebc:	e0 2d       	mov	r30, r0
    2ebe:	6a 30       	cpi	r22, 0x0A	; 10
    2ec0:	10 f0       	brcs	.+4      	; 0x2ec6 <_ZN8emstreamlsEh+0xc2>
    2ec2:	69 5c       	subi	r22, 0xC9	; 201
    2ec4:	01 c0       	rjmp	.+2      	; 0x2ec8 <_ZN8emstreamlsEh+0xc4>
    2ec6:	60 5d       	subi	r22, 0xD0	; 208
    2ec8:	c8 01       	movw	r24, r16
    2eca:	19 95       	eicall
    2ecc:	0e c0       	rjmp	.+28     	; 0x2eea <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    2ece:	50 e0       	ldi	r21, 0x00	; 0
    2ed0:	be 01       	movw	r22, r28
    2ed2:	6f 5f       	subi	r22, 0xFF	; 255
    2ed4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed6:	8e 2d       	mov	r24, r14
    2ed8:	90 e0       	ldi	r25, 0x00	; 0
    2eda:	0e 94 93 1c 	call	0x3926	; 0x3926 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    2ede:	be 01       	movw	r22, r28
    2ee0:	6f 5f       	subi	r22, 0xFF	; 255
    2ee2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ee4:	c8 01       	movw	r24, r16
    2ee6:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    2eea:	c8 01       	movw	r24, r16
    2eec:	29 96       	adiw	r28, 0x09	; 9
    2eee:	cd bf       	out	0x3d, r28	; 61
    2ef0:	de bf       	out	0x3e, r29	; 62
    2ef2:	df 91       	pop	r29
    2ef4:	cf 91       	pop	r28
    2ef6:	1f 91       	pop	r17
    2ef8:	0f 91       	pop	r16
    2efa:	ff 90       	pop	r15
    2efc:	ef 90       	pop	r14
    2efe:	df 90       	pop	r13
    2f00:	cf 90       	pop	r12
    2f02:	08 95       	ret

00002f04 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    2f04:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    2f06:	50 96       	adiw	r26, 0x10	; 16
    2f08:	ed 91       	ld	r30, X+
    2f0a:	fc 91       	ld	r31, X
    2f0c:	51 97       	sbiw	r26, 0x11	; 17
    2f0e:	80 81       	ld	r24, Z
    2f10:	54 96       	adiw	r26, 0x14	; 20
    2f12:	4c 91       	ld	r20, X
    2f14:	54 97       	sbiw	r26, 0x14	; 20
    2f16:	84 23       	and	r24, r20
    2f18:	29 f0       	breq	.+10     	; 0x2f24 <_ZN5rs2327putcharEc+0x20>
    2f1a:	09 c0       	rjmp	.+18     	; 0x2f2e <_ZN5rs2327putcharEc+0x2a>
    2f1c:	21 50       	subi	r18, 0x01	; 1
    2f1e:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    2f20:	19 f4       	brne	.+6      	; 0x2f28 <_ZN5rs2327putcharEc+0x24>
    2f22:	12 c0       	rjmp	.+36     	; 0x2f48 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    2f24:	21 e2       	ldi	r18, 0x21	; 33
    2f26:	3e e4       	ldi	r19, 0x4E	; 78
    2f28:	90 81       	ld	r25, Z
    2f2a:	94 23       	and	r25, r20
    2f2c:	b9 f3       	breq	.-18     	; 0x2f1c <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    2f2e:	90 81       	ld	r25, Z
    2f30:	56 96       	adiw	r26, 0x16	; 22
    2f32:	8c 91       	ld	r24, X
    2f34:	56 97       	sbiw	r26, 0x16	; 22
    2f36:	89 2b       	or	r24, r25
    2f38:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    2f3a:	1e 96       	adiw	r26, 0x0e	; 14
    2f3c:	ed 91       	ld	r30, X+
    2f3e:	fc 91       	ld	r31, X
    2f40:	1f 97       	sbiw	r26, 0x0f	; 15
    2f42:	60 83       	st	Z, r22
	return (true);
    2f44:	81 e0       	ldi	r24, 0x01	; 1
    2f46:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    2f48:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    2f4a:	08 95       	ret

00002f4c <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    2f4c:	cf 93       	push	r28
    2f4e:	df 93       	push	r29
    2f50:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    2f52:	c1 8d       	ldd	r28, Z+25	; 0x19
    2f54:	d2 8d       	ldd	r29, Z+26	; 0x1a
    2f56:	28 81       	ld	r18, Y
    2f58:	39 81       	ldd	r19, Y+1	; 0x01
    2f5a:	a3 8d       	ldd	r26, Z+27	; 0x1b
    2f5c:	b4 8d       	ldd	r27, Z+28	; 0x1c
    2f5e:	4d 91       	ld	r20, X+
    2f60:	5c 91       	ld	r21, X
    2f62:	24 17       	cp	r18, r20
    2f64:	35 07       	cpc	r19, r21
    2f66:	e9 f3       	breq	.-6      	; 0x2f62 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    2f68:	a7 89       	ldd	r26, Z+23	; 0x17
    2f6a:	b0 8d       	ldd	r27, Z+24	; 0x18
    2f6c:	0d 90       	ld	r0, X+
    2f6e:	bc 91       	ld	r27, X
    2f70:	a0 2d       	mov	r26, r0
    2f72:	a2 0f       	add	r26, r18
    2f74:	b3 1f       	adc	r27, r19
    2f76:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    2f78:	2f 5f       	subi	r18, 0xFF	; 255
    2f7a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f7c:	28 83       	st	Y, r18
    2f7e:	39 83       	std	Y+1, r19	; 0x01
    2f80:	24 36       	cpi	r18, 0x64	; 100
    2f82:	31 05       	cpc	r19, r1
    2f84:	28 f0       	brcs	.+10     	; 0x2f90 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    2f86:	01 8c       	ldd	r0, Z+25	; 0x19
    2f88:	f2 8d       	ldd	r31, Z+26	; 0x1a
    2f8a:	e0 2d       	mov	r30, r0
    2f8c:	10 82       	st	Z, r1
    2f8e:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    2f90:	90 e0       	ldi	r25, 0x00	; 0
    2f92:	df 91       	pop	r29
    2f94:	cf 91       	pop	r28
    2f96:	08 95       	ret

00002f98 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    2f98:	cf 93       	push	r28
    2f9a:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    2f9c:	ec 01       	movw	r28, r24
    2f9e:	a9 8d       	ldd	r26, Y+25	; 0x19
    2fa0:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2fa2:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2fa4:	fc 8d       	ldd	r31, Y+28	; 0x1c
    2fa6:	81 e0       	ldi	r24, 0x01	; 1
    2fa8:	4d 91       	ld	r20, X+
    2faa:	5c 91       	ld	r21, X
    2fac:	20 81       	ld	r18, Z
    2fae:	31 81       	ldd	r19, Z+1	; 0x01
    2fb0:	42 17       	cp	r20, r18
    2fb2:	53 07       	cpc	r21, r19
    2fb4:	09 f4       	brne	.+2      	; 0x2fb8 <_ZN5rs23214check_for_charEv+0x20>
    2fb6:	80 e0       	ldi	r24, 0x00	; 0
}
    2fb8:	df 91       	pop	r29
    2fba:	cf 91       	pop	r28
    2fbc:	08 95       	ret

00002fbe <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    2fbe:	dc 01       	movw	r26, r24
    2fc0:	ed 91       	ld	r30, X+
    2fc2:	fc 91       	ld	r31, X
    2fc4:	02 80       	ldd	r0, Z+2	; 0x02
    2fc6:	f3 81       	ldd	r31, Z+3	; 0x03
    2fc8:	e0 2d       	mov	r30, r0
    2fca:	6c e0       	ldi	r22, 0x0C	; 12
    2fcc:	19 95       	eicall
    2fce:	08 95       	ret

00002fd0 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    2fd0:	ef 92       	push	r14
    2fd2:	ff 92       	push	r15
    2fd4:	0f 93       	push	r16
    2fd6:	1f 93       	push	r17
    2fd8:	cf 93       	push	r28
    2fda:	df 93       	push	r29
    2fdc:	ec 01       	movw	r28, r24
    2fde:	7b 01       	movw	r14, r22
    2fe0:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    2fe2:	0e 94 d7 15 	call	0x2bae	; 0x2bae <_ZN8emstreamC1Ev>
    2fe6:	a8 01       	movw	r20, r16
    2fe8:	b7 01       	movw	r22, r14
    2fea:	ce 01       	movw	r24, r28
    2fec:	08 96       	adiw	r24, 0x08	; 8
    2fee:	0e 94 1e 15 	call	0x2a3c	; 0x2a3c <_ZN7base232C1EjP12USART_struct>
    2ff2:	87 e4       	ldi	r24, 0x47	; 71
    2ff4:	90 e2       	ldi	r25, 0x20	; 32
    2ff6:	88 83       	st	Y, r24
    2ff8:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    2ffa:	00 3a       	cpi	r16, 0xA0	; 160
    2ffc:	88 e0       	ldi	r24, 0x08	; 8
    2ffe:	18 07       	cpc	r17, r24
    3000:	69 f4       	brne	.+26     	; 0x301c <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3002:	8e e2       	ldi	r24, 0x2E	; 46
    3004:	91 e3       	ldi	r25, 0x31	; 49
    3006:	8f 8b       	std	Y+23, r24	; 0x17
    3008:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    300a:	80 e2       	ldi	r24, 0x20	; 32
    300c:	91 e3       	ldi	r25, 0x31	; 49
    300e:	89 8f       	std	Y+25, r24	; 0x19
    3010:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3012:	82 e1       	ldi	r24, 0x12	; 18
    3014:	91 e3       	ldi	r25, 0x31	; 49
    3016:	8b 8f       	std	Y+27, r24	; 0x1b
    3018:	9c 8f       	std	Y+28, r25	; 0x1c
    301a:	64 c0       	rjmp	.+200    	; 0x30e4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    301c:	00 3b       	cpi	r16, 0xB0	; 176
    301e:	e8 e0       	ldi	r30, 0x08	; 8
    3020:	1e 07       	cpc	r17, r30
    3022:	69 f4       	brne	.+26     	; 0x303e <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3024:	8c e2       	ldi	r24, 0x2C	; 44
    3026:	91 e3       	ldi	r25, 0x31	; 49
    3028:	8f 8b       	std	Y+23, r24	; 0x17
    302a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    302c:	8e e1       	ldi	r24, 0x1E	; 30
    302e:	91 e3       	ldi	r25, 0x31	; 49
    3030:	89 8f       	std	Y+25, r24	; 0x19
    3032:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3034:	80 e1       	ldi	r24, 0x10	; 16
    3036:	91 e3       	ldi	r25, 0x31	; 49
    3038:	8b 8f       	std	Y+27, r24	; 0x1b
    303a:	9c 8f       	std	Y+28, r25	; 0x1c
    303c:	53 c0       	rjmp	.+166    	; 0x30e4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    303e:	00 3a       	cpi	r16, 0xA0	; 160
    3040:	f9 e0       	ldi	r31, 0x09	; 9
    3042:	1f 07       	cpc	r17, r31
    3044:	69 f4       	brne	.+26     	; 0x3060 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3046:	8a e2       	ldi	r24, 0x2A	; 42
    3048:	91 e3       	ldi	r25, 0x31	; 49
    304a:	8f 8b       	std	Y+23, r24	; 0x17
    304c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    304e:	8c e1       	ldi	r24, 0x1C	; 28
    3050:	91 e3       	ldi	r25, 0x31	; 49
    3052:	89 8f       	std	Y+25, r24	; 0x19
    3054:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3056:	8e e0       	ldi	r24, 0x0E	; 14
    3058:	91 e3       	ldi	r25, 0x31	; 49
    305a:	8b 8f       	std	Y+27, r24	; 0x1b
    305c:	9c 8f       	std	Y+28, r25	; 0x1c
    305e:	42 c0       	rjmp	.+132    	; 0x30e4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3060:	00 3b       	cpi	r16, 0xB0	; 176
    3062:	89 e0       	ldi	r24, 0x09	; 9
    3064:	18 07       	cpc	r17, r24
    3066:	69 f4       	brne	.+26     	; 0x3082 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3068:	88 e2       	ldi	r24, 0x28	; 40
    306a:	91 e3       	ldi	r25, 0x31	; 49
    306c:	8f 8b       	std	Y+23, r24	; 0x17
    306e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3070:	8a e1       	ldi	r24, 0x1A	; 26
    3072:	91 e3       	ldi	r25, 0x31	; 49
    3074:	89 8f       	std	Y+25, r24	; 0x19
    3076:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3078:	8c e0       	ldi	r24, 0x0C	; 12
    307a:	91 e3       	ldi	r25, 0x31	; 49
    307c:	8b 8f       	std	Y+27, r24	; 0x1b
    307e:	9c 8f       	std	Y+28, r25	; 0x1c
    3080:	31 c0       	rjmp	.+98     	; 0x30e4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3082:	00 3a       	cpi	r16, 0xA0	; 160
    3084:	ea e0       	ldi	r30, 0x0A	; 10
    3086:	1e 07       	cpc	r17, r30
    3088:	69 f4       	brne	.+26     	; 0x30a4 <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    308a:	86 e2       	ldi	r24, 0x26	; 38
    308c:	91 e3       	ldi	r25, 0x31	; 49
    308e:	8f 8b       	std	Y+23, r24	; 0x17
    3090:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3092:	88 e1       	ldi	r24, 0x18	; 24
    3094:	91 e3       	ldi	r25, 0x31	; 49
    3096:	89 8f       	std	Y+25, r24	; 0x19
    3098:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    309a:	8a e0       	ldi	r24, 0x0A	; 10
    309c:	91 e3       	ldi	r25, 0x31	; 49
    309e:	8b 8f       	std	Y+27, r24	; 0x1b
    30a0:	9c 8f       	std	Y+28, r25	; 0x1c
    30a2:	20 c0       	rjmp	.+64     	; 0x30e4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    30a4:	00 3b       	cpi	r16, 0xB0	; 176
    30a6:	fa e0       	ldi	r31, 0x0A	; 10
    30a8:	1f 07       	cpc	r17, r31
    30aa:	69 f4       	brne	.+26     	; 0x30c6 <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    30ac:	84 e2       	ldi	r24, 0x24	; 36
    30ae:	91 e3       	ldi	r25, 0x31	; 49
    30b0:	8f 8b       	std	Y+23, r24	; 0x17
    30b2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    30b4:	86 e1       	ldi	r24, 0x16	; 22
    30b6:	91 e3       	ldi	r25, 0x31	; 49
    30b8:	89 8f       	std	Y+25, r24	; 0x19
    30ba:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    30bc:	88 e0       	ldi	r24, 0x08	; 8
    30be:	91 e3       	ldi	r25, 0x31	; 49
    30c0:	8b 8f       	std	Y+27, r24	; 0x1b
    30c2:	9c 8f       	std	Y+28, r25	; 0x1c
    30c4:	0f c0       	rjmp	.+30     	; 0x30e4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    30c6:	00 3a       	cpi	r16, 0xA0	; 160
    30c8:	1b 40       	sbci	r17, 0x0B	; 11
    30ca:	61 f4       	brne	.+24     	; 0x30e4 <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    30cc:	82 e2       	ldi	r24, 0x22	; 34
    30ce:	91 e3       	ldi	r25, 0x31	; 49
    30d0:	8f 8b       	std	Y+23, r24	; 0x17
    30d2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    30d4:	84 e1       	ldi	r24, 0x14	; 20
    30d6:	91 e3       	ldi	r25, 0x31	; 49
    30d8:	89 8f       	std	Y+25, r24	; 0x19
    30da:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    30dc:	86 e0       	ldi	r24, 0x06	; 6
    30de:	91 e3       	ldi	r25, 0x31	; 49
    30e0:	8b 8f       	std	Y+27, r24	; 0x1b
    30e2:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    30e4:	0f 89       	ldd	r16, Y+23	; 0x17
    30e6:	18 8d       	ldd	r17, Y+24	; 0x18
    30e8:	84 e6       	ldi	r24, 0x64	; 100
    30ea:	90 e0       	ldi	r25, 0x00	; 0
    30ec:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <_Znaj>
    30f0:	f8 01       	movw	r30, r16
    30f2:	80 83       	st	Z, r24
    30f4:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    30f6:	e9 8d       	ldd	r30, Y+25	; 0x19
    30f8:	fa 8d       	ldd	r31, Y+26	; 0x1a
    30fa:	10 82       	st	Z, r1
    30fc:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    30fe:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3100:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3102:	10 82       	st	Z, r1
    3104:	11 82       	std	Z+1, r1	; 0x01
}
    3106:	df 91       	pop	r29
    3108:	cf 91       	pop	r28
    310a:	1f 91       	pop	r17
    310c:	0f 91       	pop	r16
    310e:	ff 90       	pop	r15
    3110:	ef 90       	pop	r14
    3112:	08 95       	ret

00003114 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3114:	1f 92       	push	r1
    3116:	0f 92       	push	r0
    3118:	0f b6       	in	r0, 0x3f	; 63
    311a:	0f 92       	push	r0
    311c:	11 24       	eor	r1, r1
    311e:	08 b6       	in	r0, 0x38	; 56
    3120:	0f 92       	push	r0
    3122:	18 be       	out	0x38, r1	; 56
    3124:	0b b6       	in	r0, 0x3b	; 59
    3126:	0f 92       	push	r0
    3128:	1b be       	out	0x3b, r1	; 59
    312a:	2f 93       	push	r18
    312c:	3f 93       	push	r19
    312e:	8f 93       	push	r24
    3130:	9f 93       	push	r25
    3132:	ef 93       	push	r30
    3134:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3136:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    313a:	e0 91 2e 31 	lds	r30, 0x312E	; 0x80312e <rcvC0_buffer>
    313e:	f0 91 2f 31 	lds	r31, 0x312F	; 0x80312f <rcvC0_buffer+0x1>
    3142:	80 91 12 31 	lds	r24, 0x3112	; 0x803112 <rcvC0_write_index>
    3146:	90 91 13 31 	lds	r25, 0x3113	; 0x803113 <rcvC0_write_index+0x1>
    314a:	e8 0f       	add	r30, r24
    314c:	f9 1f       	adc	r31, r25
    314e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3150:	80 91 12 31 	lds	r24, 0x3112	; 0x803112 <rcvC0_write_index>
    3154:	90 91 13 31 	lds	r25, 0x3113	; 0x803113 <rcvC0_write_index+0x1>
    3158:	01 96       	adiw	r24, 0x01	; 1
    315a:	84 36       	cpi	r24, 0x64	; 100
    315c:	91 05       	cpc	r25, r1
    315e:	60 f4       	brcc	.+24     	; 0x3178 <__vector_25+0x64>
    3160:	80 93 12 31 	sts	0x3112, r24	; 0x803112 <rcvC0_write_index>
    3164:	90 93 13 31 	sts	0x3113, r25	; 0x803113 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3168:	20 91 20 31 	lds	r18, 0x3120	; 0x803120 <rcvC0_read_index>
    316c:	30 91 21 31 	lds	r19, 0x3121	; 0x803121 <rcvC0_read_index+0x1>
    3170:	82 17       	cp	r24, r18
    3172:	93 07       	cpc	r25, r19
    3174:	f1 f4       	brne	.+60     	; 0x31b2 <__vector_25+0x9e>
    3176:	0c c0       	rjmp	.+24     	; 0x3190 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3178:	10 92 12 31 	sts	0x3112, r1	; 0x803112 <rcvC0_write_index>
    317c:	10 92 13 31 	sts	0x3113, r1	; 0x803113 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3180:	80 91 20 31 	lds	r24, 0x3120	; 0x803120 <rcvC0_read_index>
    3184:	90 91 21 31 	lds	r25, 0x3121	; 0x803121 <rcvC0_read_index+0x1>
    3188:	18 16       	cp	r1, r24
    318a:	19 06       	cpc	r1, r25
    318c:	91 f4       	brne	.+36     	; 0x31b2 <__vector_25+0x9e>
    318e:	0e c0       	rjmp	.+28     	; 0x31ac <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3190:	01 96       	adiw	r24, 0x01	; 1
    3192:	84 36       	cpi	r24, 0x64	; 100
    3194:	91 05       	cpc	r25, r1
    3196:	28 f4       	brcc	.+10     	; 0x31a2 <__vector_25+0x8e>
    3198:	80 93 20 31 	sts	0x3120, r24	; 0x803120 <rcvC0_read_index>
    319c:	90 93 21 31 	sts	0x3121, r25	; 0x803121 <rcvC0_read_index+0x1>
    31a0:	08 c0       	rjmp	.+16     	; 0x31b2 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    31a2:	10 92 20 31 	sts	0x3120, r1	; 0x803120 <rcvC0_read_index>
    31a6:	10 92 21 31 	sts	0x3121, r1	; 0x803121 <rcvC0_read_index+0x1>
}
    31aa:	03 c0       	rjmp	.+6      	; 0x31b2 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    31ac:	81 e0       	ldi	r24, 0x01	; 1
    31ae:	90 e0       	ldi	r25, 0x00	; 0
    31b0:	f3 cf       	rjmp	.-26     	; 0x3198 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    31b2:	ff 91       	pop	r31
    31b4:	ef 91       	pop	r30
    31b6:	9f 91       	pop	r25
    31b8:	8f 91       	pop	r24
    31ba:	3f 91       	pop	r19
    31bc:	2f 91       	pop	r18
    31be:	0f 90       	pop	r0
    31c0:	0b be       	out	0x3b, r0	; 59
    31c2:	0f 90       	pop	r0
    31c4:	08 be       	out	0x38, r0	; 56
    31c6:	0f 90       	pop	r0
    31c8:	0f be       	out	0x3f, r0	; 63
    31ca:	0f 90       	pop	r0
    31cc:	1f 90       	pop	r1
    31ce:	18 95       	reti

000031d0 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    31d0:	1f 92       	push	r1
    31d2:	0f 92       	push	r0
    31d4:	0f b6       	in	r0, 0x3f	; 63
    31d6:	0f 92       	push	r0
    31d8:	11 24       	eor	r1, r1
    31da:	08 b6       	in	r0, 0x38	; 56
    31dc:	0f 92       	push	r0
    31de:	18 be       	out	0x38, r1	; 56
    31e0:	0b b6       	in	r0, 0x3b	; 59
    31e2:	0f 92       	push	r0
    31e4:	1b be       	out	0x3b, r1	; 59
    31e6:	2f 93       	push	r18
    31e8:	3f 93       	push	r19
    31ea:	8f 93       	push	r24
    31ec:	9f 93       	push	r25
    31ee:	ef 93       	push	r30
    31f0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    31f2:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    31f6:	e0 91 2c 31 	lds	r30, 0x312C	; 0x80312c <rcvC1_buffer>
    31fa:	f0 91 2d 31 	lds	r31, 0x312D	; 0x80312d <rcvC1_buffer+0x1>
    31fe:	80 91 10 31 	lds	r24, 0x3110	; 0x803110 <rcvC1_write_index>
    3202:	90 91 11 31 	lds	r25, 0x3111	; 0x803111 <rcvC1_write_index+0x1>
    3206:	e8 0f       	add	r30, r24
    3208:	f9 1f       	adc	r31, r25
    320a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    320c:	80 91 10 31 	lds	r24, 0x3110	; 0x803110 <rcvC1_write_index>
    3210:	90 91 11 31 	lds	r25, 0x3111	; 0x803111 <rcvC1_write_index+0x1>
    3214:	01 96       	adiw	r24, 0x01	; 1
    3216:	84 36       	cpi	r24, 0x64	; 100
    3218:	91 05       	cpc	r25, r1
    321a:	60 f4       	brcc	.+24     	; 0x3234 <__vector_28+0x64>
    321c:	80 93 10 31 	sts	0x3110, r24	; 0x803110 <rcvC1_write_index>
    3220:	90 93 11 31 	sts	0x3111, r25	; 0x803111 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3224:	20 91 1e 31 	lds	r18, 0x311E	; 0x80311e <rcvC1_read_index>
    3228:	30 91 1f 31 	lds	r19, 0x311F	; 0x80311f <rcvC1_read_index+0x1>
    322c:	82 17       	cp	r24, r18
    322e:	93 07       	cpc	r25, r19
    3230:	f1 f4       	brne	.+60     	; 0x326e <__vector_28+0x9e>
    3232:	0c c0       	rjmp	.+24     	; 0x324c <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3234:	10 92 10 31 	sts	0x3110, r1	; 0x803110 <rcvC1_write_index>
    3238:	10 92 11 31 	sts	0x3111, r1	; 0x803111 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    323c:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvC1_read_index>
    3240:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvC1_read_index+0x1>
    3244:	18 16       	cp	r1, r24
    3246:	19 06       	cpc	r1, r25
    3248:	91 f4       	brne	.+36     	; 0x326e <__vector_28+0x9e>
    324a:	0e c0       	rjmp	.+28     	; 0x3268 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    324c:	01 96       	adiw	r24, 0x01	; 1
    324e:	84 36       	cpi	r24, 0x64	; 100
    3250:	91 05       	cpc	r25, r1
    3252:	28 f4       	brcc	.+10     	; 0x325e <__vector_28+0x8e>
    3254:	80 93 1e 31 	sts	0x311E, r24	; 0x80311e <rcvC1_read_index>
    3258:	90 93 1f 31 	sts	0x311F, r25	; 0x80311f <rcvC1_read_index+0x1>
    325c:	08 c0       	rjmp	.+16     	; 0x326e <__vector_28+0x9e>
	rcvC1_read_index = 0;
    325e:	10 92 1e 31 	sts	0x311E, r1	; 0x80311e <rcvC1_read_index>
    3262:	10 92 1f 31 	sts	0x311F, r1	; 0x80311f <rcvC1_read_index+0x1>
}
    3266:	03 c0       	rjmp	.+6      	; 0x326e <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3268:	81 e0       	ldi	r24, 0x01	; 1
    326a:	90 e0       	ldi	r25, 0x00	; 0
    326c:	f3 cf       	rjmp	.-26     	; 0x3254 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    326e:	ff 91       	pop	r31
    3270:	ef 91       	pop	r30
    3272:	9f 91       	pop	r25
    3274:	8f 91       	pop	r24
    3276:	3f 91       	pop	r19
    3278:	2f 91       	pop	r18
    327a:	0f 90       	pop	r0
    327c:	0b be       	out	0x3b, r0	; 59
    327e:	0f 90       	pop	r0
    3280:	08 be       	out	0x38, r0	; 56
    3282:	0f 90       	pop	r0
    3284:	0f be       	out	0x3f, r0	; 63
    3286:	0f 90       	pop	r0
    3288:	1f 90       	pop	r1
    328a:	18 95       	reti

0000328c <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    328c:	1f 92       	push	r1
    328e:	0f 92       	push	r0
    3290:	0f b6       	in	r0, 0x3f	; 63
    3292:	0f 92       	push	r0
    3294:	11 24       	eor	r1, r1
    3296:	08 b6       	in	r0, 0x38	; 56
    3298:	0f 92       	push	r0
    329a:	18 be       	out	0x38, r1	; 56
    329c:	0b b6       	in	r0, 0x3b	; 59
    329e:	0f 92       	push	r0
    32a0:	1b be       	out	0x3b, r1	; 59
    32a2:	2f 93       	push	r18
    32a4:	3f 93       	push	r19
    32a6:	8f 93       	push	r24
    32a8:	9f 93       	push	r25
    32aa:	ef 93       	push	r30
    32ac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    32ae:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    32b2:	e0 91 2a 31 	lds	r30, 0x312A	; 0x80312a <rcvD0_buffer>
    32b6:	f0 91 2b 31 	lds	r31, 0x312B	; 0x80312b <rcvD0_buffer+0x1>
    32ba:	80 91 12 31 	lds	r24, 0x3112	; 0x803112 <rcvC0_write_index>
    32be:	90 91 13 31 	lds	r25, 0x3113	; 0x803113 <rcvC0_write_index+0x1>
    32c2:	e8 0f       	add	r30, r24
    32c4:	f9 1f       	adc	r31, r25
    32c6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    32c8:	80 91 0e 31 	lds	r24, 0x310E	; 0x80310e <rcvD0_write_index>
    32cc:	90 91 0f 31 	lds	r25, 0x310F	; 0x80310f <rcvD0_write_index+0x1>
    32d0:	01 96       	adiw	r24, 0x01	; 1
    32d2:	84 36       	cpi	r24, 0x64	; 100
    32d4:	91 05       	cpc	r25, r1
    32d6:	60 f4       	brcc	.+24     	; 0x32f0 <__vector_88+0x64>
    32d8:	80 93 0e 31 	sts	0x310E, r24	; 0x80310e <rcvD0_write_index>
    32dc:	90 93 0f 31 	sts	0x310F, r25	; 0x80310f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    32e0:	20 91 1c 31 	lds	r18, 0x311C	; 0x80311c <rcvD0_read_index>
    32e4:	30 91 1d 31 	lds	r19, 0x311D	; 0x80311d <rcvD0_read_index+0x1>
    32e8:	82 17       	cp	r24, r18
    32ea:	93 07       	cpc	r25, r19
    32ec:	f1 f4       	brne	.+60     	; 0x332a <__vector_88+0x9e>
    32ee:	0c c0       	rjmp	.+24     	; 0x3308 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    32f0:	10 92 0e 31 	sts	0x310E, r1	; 0x80310e <rcvD0_write_index>
    32f4:	10 92 0f 31 	sts	0x310F, r1	; 0x80310f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    32f8:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvD0_read_index>
    32fc:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvD0_read_index+0x1>
    3300:	18 16       	cp	r1, r24
    3302:	19 06       	cpc	r1, r25
    3304:	91 f4       	brne	.+36     	; 0x332a <__vector_88+0x9e>
    3306:	0e c0       	rjmp	.+28     	; 0x3324 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3308:	01 96       	adiw	r24, 0x01	; 1
    330a:	84 36       	cpi	r24, 0x64	; 100
    330c:	91 05       	cpc	r25, r1
    330e:	28 f4       	brcc	.+10     	; 0x331a <__vector_88+0x8e>
    3310:	80 93 1c 31 	sts	0x311C, r24	; 0x80311c <rcvD0_read_index>
    3314:	90 93 1d 31 	sts	0x311D, r25	; 0x80311d <rcvD0_read_index+0x1>
    3318:	08 c0       	rjmp	.+16     	; 0x332a <__vector_88+0x9e>
	rcvD0_read_index = 0;
    331a:	10 92 1c 31 	sts	0x311C, r1	; 0x80311c <rcvD0_read_index>
    331e:	10 92 1d 31 	sts	0x311D, r1	; 0x80311d <rcvD0_read_index+0x1>
}
    3322:	03 c0       	rjmp	.+6      	; 0x332a <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3324:	81 e0       	ldi	r24, 0x01	; 1
    3326:	90 e0       	ldi	r25, 0x00	; 0
    3328:	f3 cf       	rjmp	.-26     	; 0x3310 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    332a:	ff 91       	pop	r31
    332c:	ef 91       	pop	r30
    332e:	9f 91       	pop	r25
    3330:	8f 91       	pop	r24
    3332:	3f 91       	pop	r19
    3334:	2f 91       	pop	r18
    3336:	0f 90       	pop	r0
    3338:	0b be       	out	0x3b, r0	; 59
    333a:	0f 90       	pop	r0
    333c:	08 be       	out	0x38, r0	; 56
    333e:	0f 90       	pop	r0
    3340:	0f be       	out	0x3f, r0	; 63
    3342:	0f 90       	pop	r0
    3344:	1f 90       	pop	r1
    3346:	18 95       	reti

00003348 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3348:	1f 92       	push	r1
    334a:	0f 92       	push	r0
    334c:	0f b6       	in	r0, 0x3f	; 63
    334e:	0f 92       	push	r0
    3350:	11 24       	eor	r1, r1
    3352:	08 b6       	in	r0, 0x38	; 56
    3354:	0f 92       	push	r0
    3356:	18 be       	out	0x38, r1	; 56
    3358:	0b b6       	in	r0, 0x3b	; 59
    335a:	0f 92       	push	r0
    335c:	1b be       	out	0x3b, r1	; 59
    335e:	2f 93       	push	r18
    3360:	3f 93       	push	r19
    3362:	8f 93       	push	r24
    3364:	9f 93       	push	r25
    3366:	ef 93       	push	r30
    3368:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    336a:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    336e:	e0 91 28 31 	lds	r30, 0x3128	; 0x803128 <rcvD1_buffer>
    3372:	f0 91 29 31 	lds	r31, 0x3129	; 0x803129 <rcvD1_buffer+0x1>
    3376:	80 91 0c 31 	lds	r24, 0x310C	; 0x80310c <rcvD1_write_index>
    337a:	90 91 0d 31 	lds	r25, 0x310D	; 0x80310d <rcvD1_write_index+0x1>
    337e:	e8 0f       	add	r30, r24
    3380:	f9 1f       	adc	r31, r25
    3382:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3384:	80 91 0c 31 	lds	r24, 0x310C	; 0x80310c <rcvD1_write_index>
    3388:	90 91 0d 31 	lds	r25, 0x310D	; 0x80310d <rcvD1_write_index+0x1>
    338c:	01 96       	adiw	r24, 0x01	; 1
    338e:	84 36       	cpi	r24, 0x64	; 100
    3390:	91 05       	cpc	r25, r1
    3392:	60 f4       	brcc	.+24     	; 0x33ac <__vector_91+0x64>
    3394:	80 93 0c 31 	sts	0x310C, r24	; 0x80310c <rcvD1_write_index>
    3398:	90 93 0d 31 	sts	0x310D, r25	; 0x80310d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    339c:	20 91 1a 31 	lds	r18, 0x311A	; 0x80311a <rcvD1_read_index>
    33a0:	30 91 1b 31 	lds	r19, 0x311B	; 0x80311b <rcvD1_read_index+0x1>
    33a4:	82 17       	cp	r24, r18
    33a6:	93 07       	cpc	r25, r19
    33a8:	f1 f4       	brne	.+60     	; 0x33e6 <__vector_91+0x9e>
    33aa:	0c c0       	rjmp	.+24     	; 0x33c4 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    33ac:	10 92 0c 31 	sts	0x310C, r1	; 0x80310c <rcvD1_write_index>
    33b0:	10 92 0d 31 	sts	0x310D, r1	; 0x80310d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    33b4:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <rcvD1_read_index>
    33b8:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <rcvD1_read_index+0x1>
    33bc:	18 16       	cp	r1, r24
    33be:	19 06       	cpc	r1, r25
    33c0:	91 f4       	brne	.+36     	; 0x33e6 <__vector_91+0x9e>
    33c2:	0e c0       	rjmp	.+28     	; 0x33e0 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    33c4:	01 96       	adiw	r24, 0x01	; 1
    33c6:	84 36       	cpi	r24, 0x64	; 100
    33c8:	91 05       	cpc	r25, r1
    33ca:	28 f4       	brcc	.+10     	; 0x33d6 <__vector_91+0x8e>
    33cc:	80 93 1a 31 	sts	0x311A, r24	; 0x80311a <rcvD1_read_index>
    33d0:	90 93 1b 31 	sts	0x311B, r25	; 0x80311b <rcvD1_read_index+0x1>
    33d4:	08 c0       	rjmp	.+16     	; 0x33e6 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    33d6:	10 92 1a 31 	sts	0x311A, r1	; 0x80311a <rcvD1_read_index>
    33da:	10 92 1b 31 	sts	0x311B, r1	; 0x80311b <rcvD1_read_index+0x1>
}
    33de:	03 c0       	rjmp	.+6      	; 0x33e6 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    33e0:	81 e0       	ldi	r24, 0x01	; 1
    33e2:	90 e0       	ldi	r25, 0x00	; 0
    33e4:	f3 cf       	rjmp	.-26     	; 0x33cc <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    33e6:	ff 91       	pop	r31
    33e8:	ef 91       	pop	r30
    33ea:	9f 91       	pop	r25
    33ec:	8f 91       	pop	r24
    33ee:	3f 91       	pop	r19
    33f0:	2f 91       	pop	r18
    33f2:	0f 90       	pop	r0
    33f4:	0b be       	out	0x3b, r0	; 59
    33f6:	0f 90       	pop	r0
    33f8:	08 be       	out	0x38, r0	; 56
    33fa:	0f 90       	pop	r0
    33fc:	0f be       	out	0x3f, r0	; 63
    33fe:	0f 90       	pop	r0
    3400:	1f 90       	pop	r1
    3402:	18 95       	reti

00003404 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3404:	1f 92       	push	r1
    3406:	0f 92       	push	r0
    3408:	0f b6       	in	r0, 0x3f	; 63
    340a:	0f 92       	push	r0
    340c:	11 24       	eor	r1, r1
    340e:	08 b6       	in	r0, 0x38	; 56
    3410:	0f 92       	push	r0
    3412:	18 be       	out	0x38, r1	; 56
    3414:	0b b6       	in	r0, 0x3b	; 59
    3416:	0f 92       	push	r0
    3418:	1b be       	out	0x3b, r1	; 59
    341a:	2f 93       	push	r18
    341c:	3f 93       	push	r19
    341e:	8f 93       	push	r24
    3420:	9f 93       	push	r25
    3422:	ef 93       	push	r30
    3424:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3426:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    342a:	e0 91 26 31 	lds	r30, 0x3126	; 0x803126 <rcvE0_buffer>
    342e:	f0 91 27 31 	lds	r31, 0x3127	; 0x803127 <rcvE0_buffer+0x1>
    3432:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <rcvE0_write_index>
    3436:	90 91 0b 31 	lds	r25, 0x310B	; 0x80310b <rcvE0_write_index+0x1>
    343a:	e8 0f       	add	r30, r24
    343c:	f9 1f       	adc	r31, r25
    343e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3440:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <rcvE0_write_index>
    3444:	90 91 0b 31 	lds	r25, 0x310B	; 0x80310b <rcvE0_write_index+0x1>
    3448:	01 96       	adiw	r24, 0x01	; 1
    344a:	84 36       	cpi	r24, 0x64	; 100
    344c:	91 05       	cpc	r25, r1
    344e:	60 f4       	brcc	.+24     	; 0x3468 <__vector_58+0x64>
    3450:	80 93 0a 31 	sts	0x310A, r24	; 0x80310a <rcvE0_write_index>
    3454:	90 93 0b 31 	sts	0x310B, r25	; 0x80310b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3458:	20 91 18 31 	lds	r18, 0x3118	; 0x803118 <rcvE0_read_index>
    345c:	30 91 19 31 	lds	r19, 0x3119	; 0x803119 <rcvE0_read_index+0x1>
    3460:	82 17       	cp	r24, r18
    3462:	93 07       	cpc	r25, r19
    3464:	f1 f4       	brne	.+60     	; 0x34a2 <__vector_58+0x9e>
    3466:	0c c0       	rjmp	.+24     	; 0x3480 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3468:	10 92 0a 31 	sts	0x310A, r1	; 0x80310a <rcvE0_write_index>
    346c:	10 92 0b 31 	sts	0x310B, r1	; 0x80310b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3470:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <rcvE0_read_index>
    3474:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <rcvE0_read_index+0x1>
    3478:	18 16       	cp	r1, r24
    347a:	19 06       	cpc	r1, r25
    347c:	91 f4       	brne	.+36     	; 0x34a2 <__vector_58+0x9e>
    347e:	0e c0       	rjmp	.+28     	; 0x349c <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3480:	01 96       	adiw	r24, 0x01	; 1
    3482:	84 36       	cpi	r24, 0x64	; 100
    3484:	91 05       	cpc	r25, r1
    3486:	28 f4       	brcc	.+10     	; 0x3492 <__vector_58+0x8e>
    3488:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <rcvE0_read_index>
    348c:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <rcvE0_read_index+0x1>
    3490:	08 c0       	rjmp	.+16     	; 0x34a2 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3492:	10 92 18 31 	sts	0x3118, r1	; 0x803118 <rcvE0_read_index>
    3496:	10 92 19 31 	sts	0x3119, r1	; 0x803119 <rcvE0_read_index+0x1>
}
    349a:	03 c0       	rjmp	.+6      	; 0x34a2 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    349c:	81 e0       	ldi	r24, 0x01	; 1
    349e:	90 e0       	ldi	r25, 0x00	; 0
    34a0:	f3 cf       	rjmp	.-26     	; 0x3488 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    34a2:	ff 91       	pop	r31
    34a4:	ef 91       	pop	r30
    34a6:	9f 91       	pop	r25
    34a8:	8f 91       	pop	r24
    34aa:	3f 91       	pop	r19
    34ac:	2f 91       	pop	r18
    34ae:	0f 90       	pop	r0
    34b0:	0b be       	out	0x3b, r0	; 59
    34b2:	0f 90       	pop	r0
    34b4:	08 be       	out	0x38, r0	; 56
    34b6:	0f 90       	pop	r0
    34b8:	0f be       	out	0x3f, r0	; 63
    34ba:	0f 90       	pop	r0
    34bc:	1f 90       	pop	r1
    34be:	18 95       	reti

000034c0 <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    34c0:	1f 92       	push	r1
    34c2:	0f 92       	push	r0
    34c4:	0f b6       	in	r0, 0x3f	; 63
    34c6:	0f 92       	push	r0
    34c8:	11 24       	eor	r1, r1
    34ca:	08 b6       	in	r0, 0x38	; 56
    34cc:	0f 92       	push	r0
    34ce:	18 be       	out	0x38, r1	; 56
    34d0:	0b b6       	in	r0, 0x3b	; 59
    34d2:	0f 92       	push	r0
    34d4:	1b be       	out	0x3b, r1	; 59
    34d6:	2f 93       	push	r18
    34d8:	3f 93       	push	r19
    34da:	8f 93       	push	r24
    34dc:	9f 93       	push	r25
    34de:	ef 93       	push	r30
    34e0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    34e2:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    34e6:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <rcvE1_buffer>
    34ea:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <rcvE1_buffer+0x1>
    34ee:	80 91 08 31 	lds	r24, 0x3108	; 0x803108 <rcvE1_write_index>
    34f2:	90 91 09 31 	lds	r25, 0x3109	; 0x803109 <rcvE1_write_index+0x1>
    34f6:	e8 0f       	add	r30, r24
    34f8:	f9 1f       	adc	r31, r25
    34fa:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    34fc:	80 91 08 31 	lds	r24, 0x3108	; 0x803108 <rcvE1_write_index>
    3500:	90 91 09 31 	lds	r25, 0x3109	; 0x803109 <rcvE1_write_index+0x1>
    3504:	01 96       	adiw	r24, 0x01	; 1
    3506:	84 36       	cpi	r24, 0x64	; 100
    3508:	91 05       	cpc	r25, r1
    350a:	60 f4       	brcc	.+24     	; 0x3524 <__vector_61+0x64>
    350c:	80 93 08 31 	sts	0x3108, r24	; 0x803108 <rcvE1_write_index>
    3510:	90 93 09 31 	sts	0x3109, r25	; 0x803109 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3514:	20 91 16 31 	lds	r18, 0x3116	; 0x803116 <rcvE1_read_index>
    3518:	30 91 17 31 	lds	r19, 0x3117	; 0x803117 <rcvE1_read_index+0x1>
    351c:	82 17       	cp	r24, r18
    351e:	93 07       	cpc	r25, r19
    3520:	f1 f4       	brne	.+60     	; 0x355e <__vector_61+0x9e>
    3522:	0c c0       	rjmp	.+24     	; 0x353c <__vector_61+0x7c>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    3524:	10 92 08 31 	sts	0x3108, r1	; 0x803108 <rcvE1_write_index>
    3528:	10 92 09 31 	sts	0x3109, r1	; 0x803109 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    352c:	80 91 16 31 	lds	r24, 0x3116	; 0x803116 <rcvE1_read_index>
    3530:	90 91 17 31 	lds	r25, 0x3117	; 0x803117 <rcvE1_read_index+0x1>
    3534:	18 16       	cp	r1, r24
    3536:	19 06       	cpc	r1, r25
    3538:	91 f4       	brne	.+36     	; 0x355e <__vector_61+0x9e>
    353a:	0e c0       	rjmp	.+28     	; 0x3558 <__vector_61+0x98>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    353c:	01 96       	adiw	r24, 0x01	; 1
    353e:	84 36       	cpi	r24, 0x64	; 100
    3540:	91 05       	cpc	r25, r1
    3542:	28 f4       	brcc	.+10     	; 0x354e <__vector_61+0x8e>
    3544:	80 93 16 31 	sts	0x3116, r24	; 0x803116 <rcvE1_read_index>
    3548:	90 93 17 31 	sts	0x3117, r25	; 0x803117 <rcvE1_read_index+0x1>
    354c:	08 c0       	rjmp	.+16     	; 0x355e <__vector_61+0x9e>
	rcvE1_read_index = 0;
    354e:	10 92 16 31 	sts	0x3116, r1	; 0x803116 <rcvE1_read_index>
    3552:	10 92 17 31 	sts	0x3117, r1	; 0x803117 <rcvE1_read_index+0x1>
}
    3556:	03 c0       	rjmp	.+6      	; 0x355e <__vector_61+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3558:	81 e0       	ldi	r24, 0x01	; 1
    355a:	90 e0       	ldi	r25, 0x00	; 0
    355c:	f3 cf       	rjmp	.-26     	; 0x3544 <__vector_61+0x84>
	rcvE1_read_index = 0;
}
    355e:	ff 91       	pop	r31
    3560:	ef 91       	pop	r30
    3562:	9f 91       	pop	r25
    3564:	8f 91       	pop	r24
    3566:	3f 91       	pop	r19
    3568:	2f 91       	pop	r18
    356a:	0f 90       	pop	r0
    356c:	0b be       	out	0x3b, r0	; 59
    356e:	0f 90       	pop	r0
    3570:	08 be       	out	0x38, r0	; 56
    3572:	0f 90       	pop	r0
    3574:	0f be       	out	0x3f, r0	; 63
    3576:	0f 90       	pop	r0
    3578:	1f 90       	pop	r1
    357a:	18 95       	reti

0000357c <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    357c:	1f 92       	push	r1
    357e:	0f 92       	push	r0
    3580:	0f b6       	in	r0, 0x3f	; 63
    3582:	0f 92       	push	r0
    3584:	11 24       	eor	r1, r1
    3586:	08 b6       	in	r0, 0x38	; 56
    3588:	0f 92       	push	r0
    358a:	18 be       	out	0x38, r1	; 56
    358c:	0b b6       	in	r0, 0x3b	; 59
    358e:	0f 92       	push	r0
    3590:	1b be       	out	0x3b, r1	; 59
    3592:	2f 93       	push	r18
    3594:	3f 93       	push	r19
    3596:	8f 93       	push	r24
    3598:	9f 93       	push	r25
    359a:	ef 93       	push	r30
    359c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    359e:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    35a2:	e0 91 22 31 	lds	r30, 0x3122	; 0x803122 <rcvF0_buffer>
    35a6:	f0 91 23 31 	lds	r31, 0x3123	; 0x803123 <rcvF0_buffer+0x1>
    35aa:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <rcvF0_write_index>
    35ae:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <rcvF0_write_index+0x1>
    35b2:	e8 0f       	add	r30, r24
    35b4:	f9 1f       	adc	r31, r25
    35b6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    35b8:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <rcvF0_write_index>
    35bc:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <rcvF0_write_index+0x1>
    35c0:	01 96       	adiw	r24, 0x01	; 1
    35c2:	84 36       	cpi	r24, 0x64	; 100
    35c4:	91 05       	cpc	r25, r1
    35c6:	60 f4       	brcc	.+24     	; 0x35e0 <__vector_119+0x64>
    35c8:	80 93 06 31 	sts	0x3106, r24	; 0x803106 <rcvF0_write_index>
    35cc:	90 93 07 31 	sts	0x3107, r25	; 0x803107 <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    35d0:	20 91 14 31 	lds	r18, 0x3114	; 0x803114 <rcvF0_read_index>
    35d4:	30 91 15 31 	lds	r19, 0x3115	; 0x803115 <rcvF0_read_index+0x1>
    35d8:	82 17       	cp	r24, r18
    35da:	93 07       	cpc	r25, r19
    35dc:	f1 f4       	brne	.+60     	; 0x361a <__vector_119+0x9e>
    35de:	0c c0       	rjmp	.+24     	; 0x35f8 <__vector_119+0x7c>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    35e0:	10 92 06 31 	sts	0x3106, r1	; 0x803106 <rcvF0_write_index>
    35e4:	10 92 07 31 	sts	0x3107, r1	; 0x803107 <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    35e8:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <rcvF0_read_index>
    35ec:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <rcvF0_read_index+0x1>
    35f0:	18 16       	cp	r1, r24
    35f2:	19 06       	cpc	r1, r25
    35f4:	91 f4       	brne	.+36     	; 0x361a <__vector_119+0x9e>
    35f6:	0e c0       	rjmp	.+28     	; 0x3614 <__vector_119+0x98>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    35f8:	01 96       	adiw	r24, 0x01	; 1
    35fa:	84 36       	cpi	r24, 0x64	; 100
    35fc:	91 05       	cpc	r25, r1
    35fe:	28 f4       	brcc	.+10     	; 0x360a <__vector_119+0x8e>
    3600:	80 93 14 31 	sts	0x3114, r24	; 0x803114 <rcvF0_read_index>
    3604:	90 93 15 31 	sts	0x3115, r25	; 0x803115 <rcvF0_read_index+0x1>
    3608:	08 c0       	rjmp	.+16     	; 0x361a <__vector_119+0x9e>
	rcvF0_read_index = 0;
    360a:	10 92 14 31 	sts	0x3114, r1	; 0x803114 <rcvF0_read_index>
    360e:	10 92 15 31 	sts	0x3115, r1	; 0x803115 <rcvF0_read_index+0x1>
}
    3612:	03 c0       	rjmp	.+6      	; 0x361a <__vector_119+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3614:	81 e0       	ldi	r24, 0x01	; 1
    3616:	90 e0       	ldi	r25, 0x00	; 0
    3618:	f3 cf       	rjmp	.-26     	; 0x3600 <__vector_119+0x84>
	rcvF0_read_index = 0;
}
    361a:	ff 91       	pop	r31
    361c:	ef 91       	pop	r30
    361e:	9f 91       	pop	r25
    3620:	8f 91       	pop	r24
    3622:	3f 91       	pop	r19
    3624:	2f 91       	pop	r18
    3626:	0f 90       	pop	r0
    3628:	0b be       	out	0x3b, r0	; 59
    362a:	0f 90       	pop	r0
    362c:	08 be       	out	0x38, r0	; 56
    362e:	0f 90       	pop	r0
    3630:	0f be       	out	0x3f, r0	; 63
    3632:	0f 90       	pop	r0
    3634:	1f 90       	pop	r1
    3636:	18 95       	reti

00003638 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3638:	0f 93       	push	r16
    363a:	cf 93       	push	r28
    363c:	df 93       	push	r29
    363e:	1f 92       	push	r1
    3640:	cd b7       	in	r28, 0x3d	; 61
    3642:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3644:	2f b7       	in	r18, 0x3f	; 63
    3646:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3648:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    364a:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    364c:	fc 01       	movw	r30, r24
    364e:	08 ed       	ldi	r16, 0xD8	; 216
    3650:	04 bf       	out	0x34, r16	; 52
    3652:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3654:	89 81       	ldd	r24, Y+1	; 0x01
    3656:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3658:	0f 90       	pop	r0
    365a:	df 91       	pop	r29
    365c:	cf 91       	pop	r28
    365e:	0f 91       	pop	r16
    3660:	08 95       	ret

00003662 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3662:	0f 93       	push	r16
    3664:	1f 93       	push	r17
    3666:	cf 93       	push	r28
    3668:	df 93       	push	r29
    366a:	cd b7       	in	r28, 0x3d	; 61
    366c:	de b7       	in	r29, 0x3e	; 62
    366e:	6d 97       	sbiw	r28, 0x1d	; 29
    3670:	cd bf       	out	0x3d, r28	; 61
    3672:	de bf       	out	0x3e, r29	; 62
	//Clear any interrupts
	cli();
    3674:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3676:	e0 e5       	ldi	r30, 0x50	; 80
    3678:	f0 e0       	ldi	r31, 0x00	; 0
    367a:	80 81       	ld	r24, Z
    367c:	82 60       	ori	r24, 0x02	; 2
    367e:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3680:	81 81       	ldd	r24, Z+1	; 0x01
    3682:	81 ff       	sbrs	r24, 1
    3684:	fd cf       	rjmp	.-6      	; 0x3680 <main+0x1e>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3686:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    368a:	68 7f       	andi	r22, 0xF8	; 248
    368c:	61 60       	ori	r22, 0x01	; 1
    368e:	80 e4       	ldi	r24, 0x40	; 64
    3690:	90 e0       	ldi	r25, 0x00	; 0
    3692:	0e 94 1c 1b 	call	0x3638	; 0x3638 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3696:	e0 e5       	ldi	r30, 0x50	; 80
    3698:	f0 e0       	ldi	r31, 0x00	; 0
    369a:	80 81       	ld	r24, Z
    369c:	8e 7f       	andi	r24, 0xFE	; 254
    369e:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    36a0:	9d ef       	ldi	r25, 0xFD	; 253
    36a2:	88 ed       	ldi	r24, 0xD8	; 216
    36a4:	08 b6       	in	r0, 0x38	; 56
    36a6:	18 be       	out	0x38, r1	; 56
    36a8:	84 bf       	out	0x34, r24	; 52
    36aa:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    36ae:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
    36b0:	40 ea       	ldi	r20, 0xA0	; 160
    36b2:	58 e0       	ldi	r21, 0x08	; 8
    36b4:	60 e0       	ldi	r22, 0x00	; 0
    36b6:	70 e0       	ldi	r23, 0x00	; 0
    36b8:	ce 01       	movw	r24, r28
    36ba:	01 96       	adiw	r24, 0x01	; 1
    36bc:	0e 94 e8 17 	call	0x2fd0	; 0x2fd0 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    36c0:	67 e0       	ldi	r22, 0x07	; 7
    36c2:	ce 01       	movw	r24, r28
    36c4:	01 96       	adiw	r24, 0x01	; 1
    36c6:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    36ca:	8c 01       	movw	r16, r24
    36cc:	63 e5       	ldi	r22, 0x53	; 83
    36ce:	70 e2       	ldi	r23, 0x20	; 32
    36d0:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    36d4:	66 e0       	ldi	r22, 0x06	; 6
    36d6:	c8 01       	movw	r24, r16
    36d8:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
    36dc:	66 e0       	ldi	r22, 0x06	; 6
    36de:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    36e2:	82 e1       	ldi	r24, 0x12	; 18
    36e4:	90 e0       	ldi	r25, 0x00	; 0
    36e6:	0e 94 17 15 	call	0x2a2e	; 0x2a2e <_Znwj>
    36ea:	8e 01       	movw	r16, r28
    36ec:	0f 5f       	subi	r16, 0xFF	; 255
    36ee:	1f 4f       	sbci	r17, 0xFF	; 255
    36f0:	24 e0       	ldi	r18, 0x04	; 4
    36f2:	31 e0       	ldi	r19, 0x01	; 1
    36f4:	40 e0       	ldi	r20, 0x00	; 0
    36f6:	62 e7       	ldi	r22, 0x72	; 114
    36f8:	70 e2       	ldi	r23, 0x20	; 32
    36fa:	0e 94 43 03 	call	0x686	; 0x686 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(1), 260, &ser_dev);
    36fe:	82 e1       	ldi	r24, 0x12	; 18
    3700:	90 e0       	ldi	r25, 0x00	; 0
    3702:	0e 94 17 15 	call	0x2a2e	; 0x2a2e <_Znwj>
    3706:	24 e0       	ldi	r18, 0x04	; 4
    3708:	31 e0       	ldi	r19, 0x01	; 1
    370a:	41 e0       	ldi	r20, 0x01	; 1
    370c:	6a e7       	ldi	r22, 0x7A	; 122
    370e:	70 e2       	ldi	r23, 0x20	; 32
    3710:	0e 94 33 03 	call	0x666	; 0x666 <_ZN12EncoderMotorC1EPKchjP8emstream>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    3714:	0f b6       	in	r0, 0x3f	; 63
    3716:	f8 94       	cli
    3718:	0f 92       	push	r0
			temporary_copy = the_data;
    371a:	00 91 30 31 	lds	r16, 0x3130	; 0x803130 <linear_position>
    371e:	10 91 31 31 	lds	r17, 0x3131	; 0x803131 <linear_position+0x1>
			portEXIT_CRITICAL ();
    3722:	0f 90       	pop	r0
    3724:	0f be       	out	0x3f, r0	; 63
    3726:	61 e8       	ldi	r22, 0x81	; 129
    3728:	70 e2       	ldi	r23, 0x20	; 32
    372a:	ce 01       	movw	r24, r28
    372c:	01 96       	adiw	r24, 0x01	; 1
    372e:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
	ser_dev << "Linear Position: " << linear_position.get() << " [mm]" << endl;
    3732:	b8 01       	movw	r22, r16
    3734:	ce 01       	movw	r24, r28
    3736:	01 96       	adiw	r24, 0x01	; 1
    3738:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <_ZN8emstreamlsEi>
    373c:	8c 01       	movw	r16, r24
    373e:	63 e9       	ldi	r22, 0x93	; 147
    3740:	70 e2       	ldi	r23, 0x20	; 32
    3742:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZN8emstream4putsEPKc>
    3746:	66 e0       	ldi	r22, 0x06	; 6
    3748:	c8 01       	movw	r24, r16
    374a:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <_ZN8emstreamlsE15ser_manipulator>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    374e:	87 e0       	ldi	r24, 0x07	; 7
    3750:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3754:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3756:	0e 94 96 0c 	call	0x192c	; 0x192c <vTaskStartScheduler>
	
	return 0;
    375a:	80 e0       	ldi	r24, 0x00	; 0
    375c:	90 e0       	ldi	r25, 0x00	; 0
    375e:	6d 96       	adiw	r28, 0x1d	; 29
    3760:	cd bf       	out	0x3d, r28	; 61
    3762:	de bf       	out	0x3e, r29	; 62
    3764:	df 91       	pop	r29
    3766:	cf 91       	pop	r28
    3768:	1f 91       	pop	r17
    376a:	0f 91       	pop	r16
    376c:	08 95       	ret

0000376e <_GLOBAL__sub_I_counter>:
    376e:	0f 93       	push	r16
    3770:	1f 93       	push	r17

#include "EncoderMotor.h"					// Header for Encoder of Motor
#include "util/delay.h"						// Header for delay

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3772:	0a e0       	ldi	r16, 0x0A	; 10
    3774:	10 e0       	ldi	r17, 0x00	; 0
    3776:	20 e0       	ldi	r18, 0x00	; 0
    3778:	30 e0       	ldi	r19, 0x00	; 0
    377a:	40 e0       	ldi	r20, 0x00	; 0
    377c:	50 e0       	ldi	r21, 0x00	; 0
    377e:	60 e2       	ldi	r22, 0x20	; 32
    3780:	70 e0       	ldi	r23, 0x00	; 0
    3782:	82 e3       	ldi	r24, 0x32	; 50
    3784:	91 e3       	ldi	r25, 0x31	; 49
    3786:	0e 94 83 13 	call	0x2706	; 0x2706 <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    378a:	1f 91       	pop	r17
    378c:	0f 91       	pop	r16
    378e:	08 95       	ret

00003790 <__mulsi3>:
    3790:	db 01       	movw	r26, r22
    3792:	8f 93       	push	r24
    3794:	9f 93       	push	r25
    3796:	0e 94 31 1c 	call	0x3862	; 0x3862 <__muluhisi3>
    379a:	bf 91       	pop	r27
    379c:	af 91       	pop	r26
    379e:	a2 9f       	mul	r26, r18
    37a0:	80 0d       	add	r24, r0
    37a2:	91 1d       	adc	r25, r1
    37a4:	a3 9f       	mul	r26, r19
    37a6:	90 0d       	add	r25, r0
    37a8:	b2 9f       	mul	r27, r18
    37aa:	90 0d       	add	r25, r0
    37ac:	11 24       	eor	r1, r1
    37ae:	08 95       	ret

000037b0 <__udivmodsi4>:
    37b0:	a1 e2       	ldi	r26, 0x21	; 33
    37b2:	1a 2e       	mov	r1, r26
    37b4:	aa 1b       	sub	r26, r26
    37b6:	bb 1b       	sub	r27, r27
    37b8:	fd 01       	movw	r30, r26
    37ba:	0d c0       	rjmp	.+26     	; 0x37d6 <__udivmodsi4_ep>

000037bc <__udivmodsi4_loop>:
    37bc:	aa 1f       	adc	r26, r26
    37be:	bb 1f       	adc	r27, r27
    37c0:	ee 1f       	adc	r30, r30
    37c2:	ff 1f       	adc	r31, r31
    37c4:	a2 17       	cp	r26, r18
    37c6:	b3 07       	cpc	r27, r19
    37c8:	e4 07       	cpc	r30, r20
    37ca:	f5 07       	cpc	r31, r21
    37cc:	20 f0       	brcs	.+8      	; 0x37d6 <__udivmodsi4_ep>
    37ce:	a2 1b       	sub	r26, r18
    37d0:	b3 0b       	sbc	r27, r19
    37d2:	e4 0b       	sbc	r30, r20
    37d4:	f5 0b       	sbc	r31, r21

000037d6 <__udivmodsi4_ep>:
    37d6:	66 1f       	adc	r22, r22
    37d8:	77 1f       	adc	r23, r23
    37da:	88 1f       	adc	r24, r24
    37dc:	99 1f       	adc	r25, r25
    37de:	1a 94       	dec	r1
    37e0:	69 f7       	brne	.-38     	; 0x37bc <__udivmodsi4_loop>
    37e2:	60 95       	com	r22
    37e4:	70 95       	com	r23
    37e6:	80 95       	com	r24
    37e8:	90 95       	com	r25
    37ea:	9b 01       	movw	r18, r22
    37ec:	ac 01       	movw	r20, r24
    37ee:	bd 01       	movw	r22, r26
    37f0:	cf 01       	movw	r24, r30
    37f2:	08 95       	ret

000037f4 <__divmodsi4>:
    37f4:	05 2e       	mov	r0, r21
    37f6:	97 fb       	bst	r25, 7
    37f8:	1e f4       	brtc	.+6      	; 0x3800 <__divmodsi4+0xc>
    37fa:	00 94       	com	r0
    37fc:	0e 94 11 1c 	call	0x3822	; 0x3822 <__negsi2>
    3800:	57 fd       	sbrc	r21, 7
    3802:	07 d0       	rcall	.+14     	; 0x3812 <__divmodsi4_neg2>
    3804:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__udivmodsi4>
    3808:	07 fc       	sbrc	r0, 7
    380a:	03 d0       	rcall	.+6      	; 0x3812 <__divmodsi4_neg2>
    380c:	4e f4       	brtc	.+18     	; 0x3820 <__divmodsi4_exit>
    380e:	0c 94 11 1c 	jmp	0x3822	; 0x3822 <__negsi2>

00003812 <__divmodsi4_neg2>:
    3812:	50 95       	com	r21
    3814:	40 95       	com	r20
    3816:	30 95       	com	r19
    3818:	21 95       	neg	r18
    381a:	3f 4f       	sbci	r19, 0xFF	; 255
    381c:	4f 4f       	sbci	r20, 0xFF	; 255
    381e:	5f 4f       	sbci	r21, 0xFF	; 255

00003820 <__divmodsi4_exit>:
    3820:	08 95       	ret

00003822 <__negsi2>:
    3822:	90 95       	com	r25
    3824:	80 95       	com	r24
    3826:	70 95       	com	r23
    3828:	61 95       	neg	r22
    382a:	7f 4f       	sbci	r23, 0xFF	; 255
    382c:	8f 4f       	sbci	r24, 0xFF	; 255
    382e:	9f 4f       	sbci	r25, 0xFF	; 255
    3830:	08 95       	ret

00003832 <__tablejump2__>:
    3832:	ee 0f       	add	r30, r30
    3834:	ff 1f       	adc	r31, r31
    3836:	88 1f       	adc	r24, r24
    3838:	8b bf       	out	0x3b, r24	; 59
    383a:	07 90       	elpm	r0, Z+
    383c:	f6 91       	elpm	r31, Z
    383e:	e0 2d       	mov	r30, r0
    3840:	1b be       	out	0x3b, r1	; 59
    3842:	19 94       	eijmp

00003844 <__umulhisi3>:
    3844:	a2 9f       	mul	r26, r18
    3846:	b0 01       	movw	r22, r0
    3848:	b3 9f       	mul	r27, r19
    384a:	c0 01       	movw	r24, r0
    384c:	a3 9f       	mul	r26, r19
    384e:	70 0d       	add	r23, r0
    3850:	81 1d       	adc	r24, r1
    3852:	11 24       	eor	r1, r1
    3854:	91 1d       	adc	r25, r1
    3856:	b2 9f       	mul	r27, r18
    3858:	70 0d       	add	r23, r0
    385a:	81 1d       	adc	r24, r1
    385c:	11 24       	eor	r1, r1
    385e:	91 1d       	adc	r25, r1
    3860:	08 95       	ret

00003862 <__muluhisi3>:
    3862:	0e 94 22 1c 	call	0x3844	; 0x3844 <__umulhisi3>
    3866:	a5 9f       	mul	r26, r21
    3868:	90 0d       	add	r25, r0
    386a:	b4 9f       	mul	r27, r20
    386c:	90 0d       	add	r25, r0
    386e:	a4 9f       	mul	r26, r20
    3870:	80 0d       	add	r24, r0
    3872:	91 1d       	adc	r25, r1
    3874:	11 24       	eor	r1, r1
    3876:	08 95       	ret

00003878 <memcpy>:
    3878:	fb 01       	movw	r30, r22
    387a:	dc 01       	movw	r26, r24
    387c:	02 c0       	rjmp	.+4      	; 0x3882 <memcpy+0xa>
    387e:	01 90       	ld	r0, Z+
    3880:	0d 92       	st	X+, r0
    3882:	41 50       	subi	r20, 0x01	; 1
    3884:	50 40       	sbci	r21, 0x00	; 0
    3886:	d8 f7       	brcc	.-10     	; 0x387e <memcpy+0x6>
    3888:	08 95       	ret

0000388a <memset>:
    388a:	dc 01       	movw	r26, r24
    388c:	01 c0       	rjmp	.+2      	; 0x3890 <memset+0x6>
    388e:	6d 93       	st	X+, r22
    3890:	41 50       	subi	r20, 0x01	; 1
    3892:	50 40       	sbci	r21, 0x00	; 0
    3894:	e0 f7       	brcc	.-8      	; 0x388e <memset+0x4>
    3896:	08 95       	ret

00003898 <strncpy>:
    3898:	fb 01       	movw	r30, r22
    389a:	dc 01       	movw	r26, r24
    389c:	41 50       	subi	r20, 0x01	; 1
    389e:	50 40       	sbci	r21, 0x00	; 0
    38a0:	48 f0       	brcs	.+18     	; 0x38b4 <strncpy+0x1c>
    38a2:	01 90       	ld	r0, Z+
    38a4:	0d 92       	st	X+, r0
    38a6:	00 20       	and	r0, r0
    38a8:	c9 f7       	brne	.-14     	; 0x389c <strncpy+0x4>
    38aa:	01 c0       	rjmp	.+2      	; 0x38ae <strncpy+0x16>
    38ac:	1d 92       	st	X+, r1
    38ae:	41 50       	subi	r20, 0x01	; 1
    38b0:	50 40       	sbci	r21, 0x00	; 0
    38b2:	e0 f7       	brcc	.-8      	; 0x38ac <strncpy+0x14>
    38b4:	08 95       	ret

000038b6 <__itoa_ncheck>:
    38b6:	bb 27       	eor	r27, r27
    38b8:	4a 30       	cpi	r20, 0x0A	; 10
    38ba:	31 f4       	brne	.+12     	; 0x38c8 <__itoa_ncheck+0x12>
    38bc:	99 23       	and	r25, r25
    38be:	22 f4       	brpl	.+8      	; 0x38c8 <__itoa_ncheck+0x12>
    38c0:	bd e2       	ldi	r27, 0x2D	; 45
    38c2:	90 95       	com	r25
    38c4:	81 95       	neg	r24
    38c6:	9f 4f       	sbci	r25, 0xFF	; 255
    38c8:	0c 94 9f 1c 	jmp	0x393e	; 0x393e <__utoa_common>

000038cc <ultoa>:
    38cc:	25 32       	cpi	r18, 0x25	; 37
    38ce:	31 05       	cpc	r19, r1
    38d0:	20 f4       	brcc	.+8      	; 0x38da <ultoa+0xe>
    38d2:	22 30       	cpi	r18, 0x02	; 2
    38d4:	10 f0       	brcs	.+4      	; 0x38da <ultoa+0xe>
    38d6:	0c 94 71 1c 	jmp	0x38e2	; 0x38e2 <__ultoa_ncheck>
    38da:	fa 01       	movw	r30, r20
    38dc:	10 82       	st	Z, r1
    38de:	ca 01       	movw	r24, r20
    38e0:	08 95       	ret

000038e2 <__ultoa_ncheck>:
    38e2:	bb 27       	eor	r27, r27

000038e4 <__ultoa_common>:
    38e4:	fa 01       	movw	r30, r20
    38e6:	a6 2f       	mov	r26, r22
    38e8:	62 17       	cp	r22, r18
    38ea:	71 05       	cpc	r23, r1
    38ec:	81 05       	cpc	r24, r1
    38ee:	91 05       	cpc	r25, r1
    38f0:	33 0b       	sbc	r19, r19
    38f2:	30 fb       	bst	r19, 0
    38f4:	66 f0       	brts	.+24     	; 0x390e <__ultoa_common+0x2a>
    38f6:	aa 27       	eor	r26, r26
    38f8:	66 0f       	add	r22, r22
    38fa:	77 1f       	adc	r23, r23
    38fc:	88 1f       	adc	r24, r24
    38fe:	99 1f       	adc	r25, r25
    3900:	aa 1f       	adc	r26, r26
    3902:	a2 17       	cp	r26, r18
    3904:	10 f0       	brcs	.+4      	; 0x390a <__ultoa_common+0x26>
    3906:	a2 1b       	sub	r26, r18
    3908:	63 95       	inc	r22
    390a:	38 50       	subi	r19, 0x08	; 8
    390c:	a9 f7       	brne	.-22     	; 0x38f8 <__ultoa_common+0x14>
    390e:	a0 5d       	subi	r26, 0xD0	; 208
    3910:	aa 33       	cpi	r26, 0x3A	; 58
    3912:	08 f0       	brcs	.+2      	; 0x3916 <__ultoa_common+0x32>
    3914:	a9 5d       	subi	r26, 0xD9	; 217
    3916:	a1 93       	st	Z+, r26
    3918:	36 f7       	brtc	.-52     	; 0x38e6 <__ultoa_common+0x2>
    391a:	b1 11       	cpse	r27, r1
    391c:	b1 93       	st	Z+, r27
    391e:	10 82       	st	Z, r1
    3920:	ca 01       	movw	r24, r20
    3922:	0c 94 b8 1c 	jmp	0x3970	; 0x3970 <strrev>

00003926 <utoa>:
    3926:	45 32       	cpi	r20, 0x25	; 37
    3928:	51 05       	cpc	r21, r1
    392a:	20 f4       	brcc	.+8      	; 0x3934 <utoa+0xe>
    392c:	42 30       	cpi	r20, 0x02	; 2
    392e:	10 f0       	brcs	.+4      	; 0x3934 <utoa+0xe>
    3930:	0c 94 9e 1c 	jmp	0x393c	; 0x393c <__utoa_ncheck>
    3934:	fb 01       	movw	r30, r22
    3936:	10 82       	st	Z, r1
    3938:	cb 01       	movw	r24, r22
    393a:	08 95       	ret

0000393c <__utoa_ncheck>:
    393c:	bb 27       	eor	r27, r27

0000393e <__utoa_common>:
    393e:	fb 01       	movw	r30, r22
    3940:	55 27       	eor	r21, r21
    3942:	aa 27       	eor	r26, r26
    3944:	88 0f       	add	r24, r24
    3946:	99 1f       	adc	r25, r25
    3948:	aa 1f       	adc	r26, r26
    394a:	a4 17       	cp	r26, r20
    394c:	10 f0       	brcs	.+4      	; 0x3952 <__utoa_common+0x14>
    394e:	a4 1b       	sub	r26, r20
    3950:	83 95       	inc	r24
    3952:	50 51       	subi	r21, 0x10	; 16
    3954:	b9 f7       	brne	.-18     	; 0x3944 <__utoa_common+0x6>
    3956:	a0 5d       	subi	r26, 0xD0	; 208
    3958:	aa 33       	cpi	r26, 0x3A	; 58
    395a:	08 f0       	brcs	.+2      	; 0x395e <__utoa_common+0x20>
    395c:	a9 5d       	subi	r26, 0xD9	; 217
    395e:	a1 93       	st	Z+, r26
    3960:	00 97       	sbiw	r24, 0x00	; 0
    3962:	79 f7       	brne	.-34     	; 0x3942 <__utoa_common+0x4>
    3964:	b1 11       	cpse	r27, r1
    3966:	b1 93       	st	Z+, r27
    3968:	11 92       	st	Z+, r1
    396a:	cb 01       	movw	r24, r22
    396c:	0c 94 b8 1c 	jmp	0x3970	; 0x3970 <strrev>

00003970 <strrev>:
    3970:	dc 01       	movw	r26, r24
    3972:	fc 01       	movw	r30, r24
    3974:	67 2f       	mov	r22, r23
    3976:	71 91       	ld	r23, Z+
    3978:	77 23       	and	r23, r23
    397a:	e1 f7       	brne	.-8      	; 0x3974 <strrev+0x4>
    397c:	32 97       	sbiw	r30, 0x02	; 2
    397e:	04 c0       	rjmp	.+8      	; 0x3988 <strrev+0x18>
    3980:	7c 91       	ld	r23, X
    3982:	6d 93       	st	X+, r22
    3984:	70 83       	st	Z, r23
    3986:	62 91       	ld	r22, -Z
    3988:	ae 17       	cp	r26, r30
    398a:	bf 07       	cpc	r27, r31
    398c:	c8 f3       	brcs	.-14     	; 0x3980 <strrev+0x10>
    398e:	08 95       	ret

00003990 <_exit>:
    3990:	f8 94       	cli

00003992 <__stop_program>:
    3992:	ff cf       	rjmp	.-2      	; 0x3992 <__stop_program>
