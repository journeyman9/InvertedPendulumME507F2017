
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000464e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000da  00802000  0000464e  000046e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ae  008020da  008020da  000047bc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000047bc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000047ec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006f8  00000000  00000000  0000482c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012712  00000000  00000000  00004f24  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00007931  00000000  00000000  00017636  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000051ae  00000000  00000000  0001ef67  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001438  00000000  00000000  00024118  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006e65  00000000  00000000  00025550  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000643e  00000000  00000000  0002c3b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005a0  00000000  00000000  000327f3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a7 02 	jmp	0x54e	; 0x54e <__ctors_end>
       4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      10:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      14:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      18:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      1c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      20:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      24:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      28:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      2c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      30:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      34:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      38:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      3c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      40:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      44:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      4c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      50:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      54:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      58:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      5c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      60:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      64:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__vector_25>
      68:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      6c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      70:	0c 94 03 1d 	jmp	0x3a06	; 0x3a06 <__vector_28>
      74:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      78:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      7c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      80:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      84:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      88:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      8c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      90:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      94:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      98:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      9c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      dc:	0c 94 3d 0c 	jmp	0x187a	; 0x187a <__vector_55>
      e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e8:	0c 94 1d 1e 	jmp	0x3c3a	; 0x3c3a <__vector_58>
      ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f4:	0c 94 7b 1e 	jmp	0x3cf6	; 0x3cf6 <__vector_61>
      f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      fc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     100:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     104:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     108:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     10c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     110:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     114:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     118:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     11c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     120:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     124:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     128:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     12c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     130:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     134:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     138:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     13c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     140:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     144:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     148:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     14c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     150:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     154:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     158:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     15c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     160:	0c 94 61 1d 	jmp	0x3ac2	; 0x3ac2 <__vector_88>
     164:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     168:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     16c:	0c 94 bf 1d 	jmp	0x3b7e	; 0x3b7e <__vector_91>
     170:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     174:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     178:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     17c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     180:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     184:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     188:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     18c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     190:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     194:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     198:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     19c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1dc:	0c 94 d9 1e 	jmp	0x3db2	; 0x3db2 <__vector_119>
     1e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1fc:	2e 1a       	sub	r2, r30
     1fe:	31 1a       	sub	r3, r17
     200:	34 1a       	sub	r3, r20
     202:	37 1a       	sub	r3, r23
     204:	3a 1a       	sub	r3, r26
     206:	3d 1a       	sub	r3, r29
     208:	3f 1a       	sub	r3, r31
     20a:	50 1a       	sub	r5, r16
     20c:	58 1a       	sub	r5, r24
     20e:	62 1a       	sub	r6, r18
     210:	60 1a       	sub	r6, r16

00000212 <__trampolines_start>:
     212:	0c 94 9d 1b 	jmp	0x373a	; 0x373a <_ZN5rs2327putcharEc>
     216:	0c 94 31 1a 	jmp	0x3462	; 0x3462 <_ZN8emstreamlsE15ser_manipulator+0x24>
     21a:	0c 94 a4 02 	jmp	0x548	; 0x548 <_call_static_run_method>
     21e:	0c 94 60 1a 	jmp	0x34c0	; 0x34c0 <_ZN8emstreamlsE15ser_manipulator+0x82>
     222:	0c 94 20 19 	jmp	0x3240	; 0x3240 <__cxa_pure_virtual>
     226:	0c 94 34 1a 	jmp	0x3468	; 0x3468 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     22a:	0c 94 d6 19 	jmp	0x33ac	; 0x33ac <_ZN8emstream14check_for_charEv>
     22e:	0c 94 d9 19 	jmp	0x33b2	; 0x33b2 <_ZN8emstream12clear_screenEv>
     232:	0c 94 fa 1b 	jmp	0x37f4	; 0x37f4 <_ZN5rs23212clear_screenEv>
     236:	0c 94 17 08 	jmp	0x102e	; 0x102e <_ZN9task_user3runEv>
     23a:	0c 94 f0 15 	jmp	0x2be0	; 0x2be0 <_ZN8frt_task12print_statusER8emstream>
     23e:	0c 94 d1 19 	jmp	0x33a2	; 0x33a2 <_ZN8emstream13ready_to_sendEv>
     242:	0c 94 6e 04 	jmp	0x8dc	; 0x8dc <_ZN5Motor3runEv>
     246:	0c 94 d3 19 	jmp	0x33a6	; 0x33a6 <_ZN8emstream7getcharEv>
     24a:	0c 94 3f 1a 	jmp	0x347e	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x40>
     24e:	0c 94 3d 1a 	jmp	0x347a	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x3c>
     252:	0c 94 3a 1a 	jmp	0x3474	; 0x3474 <_ZN8emstreamlsE15ser_manipulator+0x36>
     256:	0c 94 3a 17 	jmp	0x2e74	; 0x2e74 <_ZN14frt_text_queue7getcharEv>
     25a:	0c 94 63 17 	jmp	0x2ec6	; 0x2ec6 <_ZN14frt_text_queue7putcharEc>
     25e:	0c 94 d8 19 	jmp	0x33b0	; 0x33b0 <_ZN8emstream12transmit_nowEv>
     262:	0c 94 c1 0e 	jmp	0x1d82	; 0x1d82 <prvIdleTask>
     266:	0c 94 2e 1a 	jmp	0x345c	; 0x345c <_ZN8emstreamlsE15ser_manipulator+0x1e>
     26a:	0c 94 e7 1b 	jmp	0x37ce	; 0x37ce <_ZN5rs23214check_for_charEv>
     26e:	0c 94 37 1a 	jmp	0x346e	; 0x346e <_ZN8emstreamlsE15ser_manipulator+0x30>
     272:	0c 94 50 1a 	jmp	0x34a0	; 0x34a0 <_ZN8emstreamlsE15ser_manipulator+0x62>
     276:	0c 94 58 1a 	jmp	0x34b0	; 0x34b0 <_ZN8emstreamlsE15ser_manipulator+0x72>
     27a:	0c 94 62 1a 	jmp	0x34c4	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
     27e:	0c 94 ad 03 	jmp	0x75a	; 0x75a <_ZN15EncoderPendulum3runEv>
     282:	0c 94 06 04 	jmp	0x80c	; 0x80c <_ZN13LimitSwitches3runEv>
     286:	0c 94 d6 1f 	jmp	0x3fac	; 0x3fac <_GLOBAL__sub_I_counter>
     28a:	0c 94 c1 1b 	jmp	0x3782	; 0x3782 <_ZN5rs2327getcharEv>
     28e:	0c 94 df 02 	jmp	0x5be	; 0x5be <_ZN12EncoderMotor3runEv>
     292:	0c 94 58 17 	jmp	0x2eb0	; 0x2eb0 <_ZN14frt_text_queue14check_for_charEv>

00000296 <__trampolines_end>:
     296:	2c 20       	and	r2, r12
     298:	54 43       	sbci	r21, 0x34	; 52
     29a:	43 30       	cpi	r20, 0x03	; 3
     29c:	43 43       	sbci	r20, 0x33	; 51
     29e:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a1 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a1:	2f 00                                               /.

000002a3 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b1 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b1:	54 69 6d 65 3a 20 00                                Time: .

000002b8 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b8:	4e 6f 76 20 32 35 20 32 30 31 37 00                 Nov 25 2017.

000002c4 <_ZZN9task_user11show_statusEvE3__c>:
     2c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     302:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000030d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     30d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     31d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34b:	6d 61 74 69 6f 6e 00                                mation.

00000352 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     352:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     362:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000373 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     373:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     383:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3a7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3b7:	68 65 20 41 56 52 00                                he AVR.

000003be <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3be:	20 68 65 6c 70 00                                    help.

000003c4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e3:	1b 5b 33 30 6d 00                                   .[30m.

000003e9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e9:	1b 5b 34 36 6d 00                                   .[46m.

000003ef <_ZZN9task_user3runEvE3__c_3>:
     3ef:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ff:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000040c <_ZZN9task_user3runEvE3__c_2>:
     40c:	3a 57 54 46 3f 00                                   :WTF?.

00000412 <_ZZN9task_user3runEvE3__c_1>:
     412:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     422:	65 00                                               e.

00000424 <_ZZN9task_user3runEvE3__c_0>:
     424:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000432 <_ZZN9task_user3runEvE3__c>:
     432:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     442:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000450 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     450:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045a <_ZZN8frt_task15emergency_resetEvE3__c>:
     45a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000469 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     469:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     479:	61 73 6b 20 00                                      ask .

0000047e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     47e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000048c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     48c:	20 63 72 65 61 74 65 64 00                           created.

00000495 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     495:	54 61 73 6b 20 00                                   Task .

0000049b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49b:	1b 5b 32 32 6d 00                                   .[22m.

000004a1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a1:	54 61 73 6b 3a 20 00                                Task: .

000004a8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a8:	1b 5b 31 6d 00                                      .[1m.

000004ad <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4ad:	1b 5b 32 32 6d 00                                   .[22m.

000004b3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004be <_ZZ17print_task_stacksP8emstreamE3__c>:
     4be:	1b 5b 31 6d 00                                      .[1m.

000004c3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c3:	09 09 00                                            ...

000004c6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4c6:	2f 00                                               /.

000004c8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d3:	09 2d 2d 2d 2d 00                                   .----.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004f6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4f6:	09 52 75 6e 73 00                                   .Runs.

000004fc <_ZZ15print_task_listP8emstreamE3__c_2>:
     4fc:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000508 <_ZZ15print_task_listP8emstreamE3__c_1>:
     508:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000519 <_ZZ15print_task_listP8emstreamE3__c_0>:
     519:	09 53 74 61 63 6b 00                                .Stack.

00000520 <_ZZ15print_task_listP8emstreamE3__c>:
     520:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52b:	09 00                                               ..

0000052d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     52d:	09 00                                               ..

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     52f:	2f 00                                               /.

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     533:	09 00                                               ..

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53b:	1b 5b 31 6d 00                                      .[1m.

00000540 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     545:	20 20 00                                              .

00000548 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     548:	0e 94 88 14 	call	0x2910	; 0x2910 <_ZN8frt_task22_call_users_run_methodEPS_>

0000054c <__ctors_start>:
     54c:	d6 1f       	adc	r29, r22

0000054e <__ctors_end>:
     54e:	11 24       	eor	r1, r1
     550:	1f be       	out	0x3f, r1	; 63
     552:	cf ef       	ldi	r28, 0xFF	; 255
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df e3       	ldi	r29, 0x3F	; 63
     558:	de bf       	out	0x3e, r29	; 62
     55a:	00 e0       	ldi	r16, 0x00	; 0
     55c:	0c bf       	out	0x3c, r16	; 60
     55e:	18 be       	out	0x38, r1	; 56
     560:	19 be       	out	0x39, r1	; 57
     562:	1a be       	out	0x3a, r1	; 58
     564:	1b be       	out	0x3b, r1	; 59

00000566 <__do_copy_data>:
     566:	10 e2       	ldi	r17, 0x20	; 32
     568:	a0 e0       	ldi	r26, 0x00	; 0
     56a:	b0 e2       	ldi	r27, 0x20	; 32
     56c:	ee e4       	ldi	r30, 0x4E	; 78
     56e:	f6 e4       	ldi	r31, 0x46	; 70
     570:	00 e0       	ldi	r16, 0x00	; 0
     572:	0b bf       	out	0x3b, r16	; 59
     574:	02 c0       	rjmp	.+4      	; 0x57a <__do_copy_data+0x14>
     576:	07 90       	elpm	r0, Z+
     578:	0d 92       	st	X+, r0
     57a:	aa 3d       	cpi	r26, 0xDA	; 218
     57c:	b1 07       	cpc	r27, r17
     57e:	d9 f7       	brne	.-10     	; 0x576 <__do_copy_data+0x10>
     580:	1b be       	out	0x3b, r1	; 59

00000582 <__do_clear_bss>:
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	aa ed       	ldi	r26, 0xDA	; 218
     586:	b0 e2       	ldi	r27, 0x20	; 32
     588:	01 c0       	rjmp	.+2      	; 0x58c <.do_clear_bss_start>

0000058a <.do_clear_bss_loop>:
     58a:	1d 92       	st	X+, r1

0000058c <.do_clear_bss_start>:
     58c:	a8 38       	cpi	r26, 0x88	; 136
     58e:	b2 07       	cpc	r27, r18
     590:	e1 f7       	brne	.-8      	; 0x58a <.do_clear_bss_loop>

00000592 <__do_global_ctors>:
     592:	12 e0       	ldi	r17, 0x02	; 2
     594:	c7 ea       	ldi	r28, 0xA7	; 167
     596:	d2 e0       	ldi	r29, 0x02	; 2
     598:	00 e0       	ldi	r16, 0x00	; 0
     59a:	06 c0       	rjmp	.+12     	; 0x5a8 <__do_global_ctors+0x16>
     59c:	21 97       	sbiw	r28, 0x01	; 1
     59e:	01 09       	sbc	r16, r1
     5a0:	80 2f       	mov	r24, r16
     5a2:	fe 01       	movw	r30, r28
     5a4:	0e 94 76 22 	call	0x44ec	; 0x44ec <__tablejump2__>
     5a8:	c6 3a       	cpi	r28, 0xA6	; 166
     5aa:	d1 07       	cpc	r29, r17
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 07       	cpc	r16, r24
     5b0:	a9 f7       	brne	.-22     	; 0x59c <__do_global_ctors+0xa>
     5b2:	0e 94 4c 1f 	call	0x3e98	; 0x3e98 <main>
     5b6:	0c 94 25 23 	jmp	0x464a	; 0x464a <_exit>

000005ba <__bad_interrupt>:
     5ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005be <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN12EncoderMotor3runEv+0x6>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5cc:	0e 94 60 10 	call	0x20c0	; 0x20c0 <xTaskGetTickCount>
     5d0:	69 83       	std	Y+1, r22	; 0x01
     5d2:	7a 83       	std	Y+2, r23	; 0x02
     5d4:	8b 83       	std	Y+3, r24	; 0x03
     5d6:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN4_bm | PIN5_bm;										// Set both CHa and CHb for input
     5d8:	e0 e8       	ldi	r30, 0x80	; 128
     5da:	f6 e0       	ldi	r31, 0x06	; 6
     5dc:	80 e3       	ldi	r24, 0x30	; 48
     5de:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN4CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e0:	84 89       	ldd	r24, Z+20	; 0x14
     5e2:	83 60       	ori	r24, 0x03	; 3
     5e4:	84 8b       	std	Z+20, r24	; 0x14
	PORTE.PIN5CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5e6:	85 89       	ldd	r24, Z+21	; 0x15
     5e8:	83 60       	ori	r24, 0x03	; 3
     5ea:	85 8b       	std	Z+21, r24	; 0x15
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN4_gc;								// Configure CHa as a multiplexer input for event channel 1
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	84 e7       	ldi	r24, 0x74	; 116
     5f2:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f4:	89 e0       	ldi	r24, 0x09	; 9
     5f6:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f8:	e0 e0       	ldi	r30, 0x00	; 0
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	88 e6       	ldi	r24, 0x68	; 104
     5fe:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	86 a3       	std	Z+38, r24	; 0x26
     606:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	80 83       	st	Z, r24
	float x_calc;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     60c:	0f 2e       	mov	r0, r31
     60e:	a1 2c       	mov	r10, r1
     610:	f9 e0       	ldi	r31, 0x09	; 9
     612:	bf 2e       	mov	r11, r31
     614:	f0 2d       	mov	r31, r0
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     616:	0f 2e       	mov	r0, r31
     618:	fc e3       	ldi	r31, 0x3C	; 60
     61a:	9f 2e       	mov	r9, r31
     61c:	f0 2d       	mov	r31, r0
     61e:	f5 01       	movw	r30, r10
     620:	00 a1       	ldd	r16, Z+32	; 0x20
     622:	11 a1       	ldd	r17, Z+33	; 0x21
		*p_serial << "Encoder Pulses: " << encoder_count << endl;
     624:	f7 01       	movw	r30, r14
     626:	66 80       	ldd	r6, Z+6	; 0x06
     628:	77 80       	ldd	r7, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     62a:	66 e0       	ldi	r22, 0x06	; 6
     62c:	70 e2       	ldi	r23, 0x20	; 32
     62e:	c3 01       	movw	r24, r6
     630:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     634:	b8 01       	movw	r22, r16
     636:	c3 01       	movw	r24, r6
     638:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsEi>
     63c:	66 e0       	ldi	r22, 0x06	; 6
     63e:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     642:	0f b6       	in	r0, 0x3f	; 63
     644:	f8 94       	cli
     646:	0f 92       	push	r0
			the_data = new_data;
     648:	28 01       	movw	r4, r16
     64a:	01 2e       	mov	r0, r17
     64c:	00 0c       	add	r0, r0
     64e:	66 08       	sbc	r6, r6
     650:	77 08       	sbc	r7, r7
     652:	c3 01       	movw	r24, r6
     654:	b2 01       	movw	r22, r4
     656:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     65a:	20 e0       	ldi	r18, 0x00	; 0
     65c:	30 e0       	ldi	r19, 0x00	; 0
     65e:	4a e7       	ldi	r20, 0x7A	; 122
     660:	55 e4       	ldi	r21, 0x45	; 69
     662:	0e 94 59 20 	call	0x40b2	; 0x40b2 <__divsf3>
     666:	20 e0       	ldi	r18, 0x00	; 0
     668:	30 e0       	ldi	r19, 0x00	; 0
     66a:	44 eb       	ldi	r20, 0xB4	; 180
     66c:	53 e4       	ldi	r21, 0x43	; 67
     66e:	0e 94 b8 21 	call	0x4370	; 0x4370 <__mulsf3>
     672:	0e 94 cb 20 	call	0x4196	; 0x4196 <__fixsfsi>
     676:	60 93 72 31 	sts	0x3172, r22	; 0x803172 <thMotor>
     67a:	70 93 73 31 	sts	0x3173, r23	; 0x803173 <thMotor+0x1>
			portEXIT_CRITICAL ();
     67e:	0f 90       	pop	r0
     680:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     682:	0f b6       	in	r0, 0x3f	; 63
     684:	f8 94       	cli
     686:	0f 92       	push	r0
			the_data = new_data;
     688:	d3 01       	movw	r26, r6
     68a:	c2 01       	movw	r24, r4
     68c:	88 0f       	add	r24, r24
     68e:	99 1f       	adc	r25, r25
     690:	aa 1f       	adc	r26, r26
     692:	bb 1f       	adc	r27, r27
     694:	bc 01       	movw	r22, r24
     696:	cd 01       	movw	r24, r26
     698:	64 0d       	add	r22, r4
     69a:	75 1d       	adc	r23, r5
     69c:	86 1d       	adc	r24, r6
     69e:	97 1d       	adc	r25, r7
     6a0:	24 e6       	ldi	r18, 0x64	; 100
     6a2:	30 e0       	ldi	r19, 0x00	; 0
     6a4:	40 e0       	ldi	r20, 0x00	; 0
     6a6:	50 e0       	ldi	r21, 0x00	; 0
     6a8:	0e 94 57 22 	call	0x44ae	; 0x44ae <__divmodsi4>
     6ac:	ca 01       	movw	r24, r20
     6ae:	b9 01       	movw	r22, r18
     6b0:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     6b4:	0e 94 cb 20 	call	0x4196	; 0x4196 <__fixsfsi>
     6b8:	60 93 74 31 	sts	0x3174, r22	; 0x803174 <linear_position>
     6bc:	70 93 75 31 	sts	0x3175, r23	; 0x803175 <linear_position+0x1>
			portEXIT_CRITICAL ();
     6c0:	0f 90       	pop	r0
     6c2:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     6c4:	0f b6       	in	r0, 0x3f	; 63
     6c6:	f8 94       	cli
     6c8:	0f 92       	push	r0
			the_data = new_data;
     6ca:	c8 01       	movw	r24, r16
     6cc:	8c 19       	sub	r24, r12
     6ce:	9d 09       	sbc	r25, r13
     6d0:	98 9e       	mul	r9, r24
     6d2:	b0 01       	movw	r22, r0
     6d4:	99 9e       	mul	r9, r25
     6d6:	70 0d       	add	r23, r0
     6d8:	11 24       	eor	r1, r1
     6da:	07 2e       	mov	r0, r23
     6dc:	00 0c       	add	r0, r0
     6de:	88 0b       	sbc	r24, r24
     6e0:	99 0b       	sbc	r25, r25
     6e2:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     6e6:	20 e0       	ldi	r18, 0x00	; 0
     6e8:	30 e0       	ldi	r19, 0x00	; 0
     6ea:	4a e7       	ldi	r20, 0x7A	; 122
     6ec:	55 e4       	ldi	r21, 0x45	; 69
     6ee:	0e 94 59 20 	call	0x40b2	; 0x40b2 <__divsf3>
     6f2:	2a e0       	ldi	r18, 0x0A	; 10
     6f4:	37 ed       	ldi	r19, 0xD7	; 215
     6f6:	43 ea       	ldi	r20, 0xA3	; 163
     6f8:	5b e3       	ldi	r21, 0x3B	; 59
     6fa:	0e 94 59 20 	call	0x40b2	; 0x40b2 <__divsf3>
     6fe:	0e 94 cb 20 	call	0x4196	; 0x4196 <__fixsfsi>
     702:	60 93 70 31 	sts	0x3170, r22	; 0x803170 <thdMotor>
     706:	70 93 71 31 	sts	0x3171, r23	; 0x803171 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     70a:	0f 90       	pop	r0
     70c:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     70e:	f7 01       	movw	r30, r14
     710:	86 85       	ldd	r24, Z+14	; 0x0e
     712:	97 85       	ldd	r25, Z+15	; 0x0f
     714:	a0 89       	ldd	r26, Z+16	; 0x10
     716:	b1 89       	ldd	r27, Z+17	; 0x11
     718:	01 96       	adiw	r24, 0x01	; 1
     71a:	a1 1d       	adc	r26, r1
     71c:	b1 1d       	adc	r27, r1
     71e:	86 87       	std	Z+14, r24	; 0x0e
     720:	97 87       	std	Z+15, r25	; 0x0f
     722:	a0 8b       	std	Z+16, r26	; 0x10
     724:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     726:	45 e0       	ldi	r20, 0x05	; 5
     728:	50 e0       	ldi	r21, 0x00	; 0
     72a:	60 e0       	ldi	r22, 0x00	; 0
     72c:	70 e0       	ldi	r23, 0x00	; 0
     72e:	ce 01       	movw	r24, r28
     730:	01 96       	adiw	r24, 0x01	; 1
     732:	0e 94 fe 11 	call	0x23fc	; 0x23fc <vTaskDelayUntil>
		angularVelocityCalc = ((int16_t) (encoder_count-last_encoder_count))*60/(4.00000*1000.00000)/dt;	// convert to velocity [RPM]
		angularVelocity = angularVelocityCalc;
		//*p_serial << "Angular Velocity: " << angularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     736:	68 01       	movw	r12, r16
     738:	72 cf       	rjmp	.-284    	; 0x61e <_ZN12EncoderMotor3runEv+0x60>

0000073a <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     73a:	0f 93       	push	r16
     73c:	1f 93       	push	r17
     73e:	cf 93       	push	r28
     740:	df 93       	push	r29
     742:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     744:	0e 94 9b 14 	call	0x2936	; 0x2936 <_ZN8frt_taskC1EPKchjP8emstream>
     748:	8b e1       	ldi	r24, 0x1B	; 27
     74a:	90 e2       	ldi	r25, 0x20	; 32
     74c:	88 83       	st	Y, r24
     74e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	1f 91       	pop	r17
     756:	0f 91       	pop	r16
     758:	08 95       	ret

0000075a <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     75a:	cf 93       	push	r28
     75c:	df 93       	push	r29
     75e:	00 d0       	rcall	.+0      	; 0x760 <_ZN15EncoderPendulum3runEv+0x6>
     760:	1f 92       	push	r1
     762:	cd b7       	in	r28, 0x3d	; 61
     764:	de b7       	in	r29, 0x3e	; 62
     766:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     768:	0e 94 60 10 	call	0x20c0	; 0x20c0 <xTaskGetTickCount>
     76c:	69 83       	std	Y+1, r22	; 0x01
     76e:	7a 83       	std	Y+2, r23	; 0x02
     770:	8b 83       	std	Y+3, r24	; 0x03
     772:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTB.DIRCLR = (PIN4_bm | PIN5_bm);							// set C4 & C5 as inputs
     774:	e0 e2       	ldi	r30, 0x20	; 32
     776:	f6 e0       	ldi	r31, 0x06	; 6
     778:	80 e3       	ldi	r24, 0x30	; 48
     77a:	82 83       	std	Z+2, r24	; 0x02
	PORTB.PIN4CTRL = PORT_ISC_LEVEL_gc;							// set C4 for level sensing
     77c:	83 e0       	ldi	r24, 0x03	; 3
     77e:	84 8b       	std	Z+20, r24	; 0x14
	PORTB.PIN5CTRL = PORT_ISC_LEVEL_gc;							// set C5 for level sensing
     780:	85 8b       	std	Z+21, r24	; 0x15
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTB_PIN4_gc;					// set PC4 as Multiplexer for Event Chan 0
     782:	e0 e8       	ldi	r30, 0x80	; 128
     784:	f1 e0       	ldi	r31, 0x01	; 1
     786:	8c e5       	ldi	r24, 0x5C	; 92
     788:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     78a:	89 e0       	ldi	r24, 0x09	; 9
     78c:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     78e:	e0 e4       	ldi	r30, 0x40	; 64
     790:	f8 e0       	ldi	r31, 0x08	; 8
     792:	8a e6       	ldi	r24, 0x6A	; 106
     794:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0xFFFF;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     796:	8f ef       	ldi	r24, 0xFF	; 255
     798:	9f ef       	ldi	r25, 0xFF	; 255
     79a:	86 a3       	std	Z+38, r24	; 0x26
     79c:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     79e:	81 e0       	ldi	r24, 0x01	; 1
     7a0:	80 83       	st	Z, r24
	
	uint16_t count;												// contains the current encoder value
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     7a2:	68 94       	set
     7a4:	ee 24       	eor	r14, r14
     7a6:	e6 f8       	bld	r14, 6
     7a8:	ff 24       	eor	r15, r15
     7aa:	f3 f8       	bld	r15, 3
     7ac:	f7 01       	movw	r30, r14
     7ae:	60 a1       	ldd	r22, Z+32	; 0x20
     7b0:	71 a1       	ldd	r23, Z+33	; 0x21
		*p_serial << count << endl;
     7b2:	f8 01       	movw	r30, r16
     7b4:	86 81       	ldd	r24, Z+6	; 0x06
     7b6:	97 81       	ldd	r25, Z+7	; 0x07
     7b8:	0e 94 a7 1a 	call	0x354e	; 0x354e <_ZN8emstreamlsEj>
     7bc:	66 e0       	ldi	r22, 0x06	; 6
     7be:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     7c2:	f8 01       	movw	r30, r16
     7c4:	86 85       	ldd	r24, Z+14	; 0x0e
     7c6:	97 85       	ldd	r25, Z+15	; 0x0f
     7c8:	a0 89       	ldd	r26, Z+16	; 0x10
     7ca:	b1 89       	ldd	r27, Z+17	; 0x11
     7cc:	01 96       	adiw	r24, 0x01	; 1
     7ce:	a1 1d       	adc	r26, r1
     7d0:	b1 1d       	adc	r27, r1
     7d2:	86 87       	std	Z+14, r24	; 0x0e
     7d4:	97 87       	std	Z+15, r25	; 0x0f
     7d6:	a0 8b       	std	Z+16, r26	; 0x10
     7d8:	b1 8b       	std	Z+17, r27	; 0x11
     7da:	41 e0       	ldi	r20, 0x01	; 1
     7dc:	50 e0       	ldi	r21, 0x00	; 0
     7de:	60 e0       	ldi	r22, 0x00	; 0
     7e0:	70 e0       	ldi	r23, 0x00	; 0
     7e2:	ce 01       	movw	r24, r28
     7e4:	01 96       	adiw	r24, 0x01	; 1
     7e6:	0e 94 fe 11 	call	0x23fc	; 0x23fc <vTaskDelayUntil>
     7ea:	e0 cf       	rjmp	.-64     	; 0x7ac <_ZN15EncoderPendulum3runEv+0x52>

000007ec <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     7ec:	0f 93       	push	r16
     7ee:	1f 93       	push	r17
     7f0:	cf 93       	push	r28
     7f2:	df 93       	push	r29
     7f4:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7f6:	0e 94 9b 14 	call	0x2936	; 0x2936 <_ZN8frt_taskC1EPKchjP8emstream>
     7fa:	83 e2       	ldi	r24, 0x23	; 35
     7fc:	90 e2       	ldi	r25, 0x20	; 32
     7fe:	88 83       	st	Y, r24
     800:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     802:	df 91       	pop	r29
     804:	cf 91       	pop	r28
     806:	1f 91       	pop	r17
     808:	0f 91       	pop	r16
     80a:	08 95       	ret

0000080c <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     80c:	cf 93       	push	r28
     80e:	df 93       	push	r29
     810:	00 d0       	rcall	.+0      	; 0x812 <_ZN13LimitSwitches3runEv+0x6>
     812:	1f 92       	push	r1
     814:	cd b7       	in	r28, 0x3d	; 61
     816:	de b7       	in	r29, 0x3e	; 62
     818:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     81a:	0e 94 60 10 	call	0x20c0	; 0x20c0 <xTaskGetTickCount>
     81e:	69 83       	std	Y+1, r22	; 0x01
     820:	7a 83       	std	Y+2, r23	; 0x02
     822:	8b 83       	std	Y+3, r24	; 0x03
     824:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PK0 & PK2) and LED output
	PORTK.DIRCLR = PIN0_bm;									// set K0 as input
     826:	e0 e2       	ldi	r30, 0x20	; 32
     828:	f7 e0       	ldi	r31, 0x07	; 7
     82a:	81 e0       	ldi	r24, 0x01	; 1
     82c:	82 83       	std	Z+2, r24	; 0x02
	PORTK.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set K0 as pullup
     82e:	88 e1       	ldi	r24, 0x18	; 24
     830:	80 8b       	std	Z+16, r24	; 0x10
	PORTK.DIRCLR = PIN2_bm;									// set K2 as input
     832:	94 e0       	ldi	r25, 0x04	; 4
     834:	92 83       	std	Z+2, r25	; 0x02
	PORTK.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set K2 as pullup
     836:	82 8b       	std	Z+18, r24	; 0x12
	bool rightLimit;
	bool leftLimit;

	while(1){
		
		if(!(PORTK_IN & PIN0_bm))							// check whether limit is pressed (pin K0 is high)
     838:	0f 2e       	mov	r0, r31
     83a:	f8 e2       	ldi	r31, 0x28	; 40
     83c:	ef 2e       	mov	r14, r31
     83e:	f7 e0       	ldi	r31, 0x07	; 7
     840:	ff 2e       	mov	r15, r31
     842:	f0 2d       	mov	r31, r0
     844:	f7 01       	movw	r30, r14
     846:	80 81       	ld	r24, Z
     848:	80 fd       	sbrc	r24, 0
     84a:	10 c0       	rjmp	.+32     	; 0x86c <_ZN13LimitSwitches3runEv+0x60>
		{	
			rightLimit = 1;
			*p_serial << "rightLimit: " << rightLimit << endl;
     84c:	f8 01       	movw	r30, r16
     84e:	c6 80       	ldd	r12, Z+6	; 0x06
     850:	d7 80       	ldd	r13, Z+7	; 0x07
     852:	67 e2       	ldi	r22, 0x27	; 39
     854:	70 e2       	ldi	r23, 0x20	; 32
     856:	c6 01       	movw	r24, r12
     858:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     85c:	61 e0       	ldi	r22, 0x01	; 1
     85e:	c6 01       	movw	r24, r12
     860:	0e 94 66 1a 	call	0x34cc	; 0x34cc <_ZN8emstreamlsEb>
     864:	66 e0       	ldi	r22, 0x06	; 6
     866:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     86a:	13 c0       	rjmp	.+38     	; 0x892 <_ZN13LimitSwitches3runEv+0x86>
			
		}
		else if (!(PORTK_IN & PIN2_bm))						// check whether limit is pressed (pin K2 is high)
     86c:	f7 01       	movw	r30, r14
     86e:	80 81       	ld	r24, Z
     870:	82 fd       	sbrc	r24, 2
     872:	0f c0       	rjmp	.+30     	; 0x892 <_ZN13LimitSwitches3runEv+0x86>
		{
			leftLimit = 1;
			*p_serial << "leftLimit: " << leftLimit << endl;
     874:	f8 01       	movw	r30, r16
     876:	c6 80       	ldd	r12, Z+6	; 0x06
     878:	d7 80       	ldd	r13, Z+7	; 0x07
     87a:	64 e3       	ldi	r22, 0x34	; 52
     87c:	70 e2       	ldi	r23, 0x20	; 32
     87e:	c6 01       	movw	r24, r12
     880:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     884:	61 e0       	ldi	r22, 0x01	; 1
     886:	c6 01       	movw	r24, r12
     888:	0e 94 66 1a 	call	0x34cc	; 0x34cc <_ZN8emstreamlsEb>
     88c:	66 e0       	ldi	r22, 0x06	; 6
     88e:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
			leftLimit = 0;
			//*p_serial << "limits: " << rightLimit << leftLimit << endl;
		}
		
		// Increment counter for debugging
		runs++;
     892:	f8 01       	movw	r30, r16
     894:	86 85       	ldd	r24, Z+14	; 0x0e
     896:	97 85       	ldd	r25, Z+15	; 0x0f
     898:	a0 89       	ldd	r26, Z+16	; 0x10
     89a:	b1 89       	ldd	r27, Z+17	; 0x11
     89c:	01 96       	adiw	r24, 0x01	; 1
     89e:	a1 1d       	adc	r26, r1
     8a0:	b1 1d       	adc	r27, r1
     8a2:	86 87       	std	Z+14, r24	; 0x0e
     8a4:	97 87       	std	Z+15, r25	; 0x0f
     8a6:	a0 8b       	std	Z+16, r26	; 0x10
     8a8:	b1 8b       	std	Z+17, r27	; 0x11
     8aa:	41 e0       	ldi	r20, 0x01	; 1
     8ac:	50 e0       	ldi	r21, 0x00	; 0
     8ae:	60 e0       	ldi	r22, 0x00	; 0
     8b0:	70 e0       	ldi	r23, 0x00	; 0
     8b2:	ce 01       	movw	r24, r28
     8b4:	01 96       	adiw	r24, 0x01	; 1
     8b6:	0e 94 fe 11 	call	0x23fc	; 0x23fc <vTaskDelayUntil>
     8ba:	c4 cf       	rjmp	.-120    	; 0x844 <_ZN13LimitSwitches3runEv+0x38>

000008bc <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     8bc:	0f 93       	push	r16
     8be:	1f 93       	push	r17
     8c0:	cf 93       	push	r28
     8c2:	df 93       	push	r29
     8c4:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8c6:	0e 94 9b 14 	call	0x2936	; 0x2936 <_ZN8frt_taskC1EPKchjP8emstream>
     8ca:	84 e4       	ldi	r24, 0x44	; 68
     8cc:	90 e2       	ldi	r25, 0x20	; 32
     8ce:	88 83       	st	Y, r24
     8d0:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     8d2:	df 91       	pop	r29
     8d4:	cf 91       	pop	r28
     8d6:	1f 91       	pop	r17
     8d8:	0f 91       	pop	r16
     8da:	08 95       	ret

000008dc <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     8dc:	cf 93       	push	r28
     8de:	df 93       	push	r29
     8e0:	00 d0       	rcall	.+0      	; 0x8e2 <_ZN5Motor3runEv+0x6>
     8e2:	00 d0       	rcall	.+0      	; 0x8e4 <_ZN5Motor3runEv+0x8>
     8e4:	cd b7       	in	r28, 0x3d	; 61
     8e6:	de b7       	in	r29, 0x3e	; 62
     8e8:	3c 01       	movw	r6, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8ea:	0e 94 60 10 	call	0x20c0	; 0x20c0 <xTaskGetTickCount>
     8ee:	69 83       	std	Y+1, r22	; 0x01
     8f0:	7a 83       	std	Y+2, r23	; 0x02
     8f2:	8b 83       	std	Y+3, r24	; 0x03
     8f4:	9c 83       	std	Y+4, r25	; 0x04

	dt = .008;
     8f6:	f3 01       	movw	r30, r6
     8f8:	fe 96       	adiw	r30, 0x3e	; 62
     8fa:	8f e6       	ldi	r24, 0x6F	; 111
     8fc:	92 e1       	ldi	r25, 0x12	; 18
     8fe:	a3 e0       	ldi	r26, 0x03	; 3
     900:	bc e3       	ldi	r27, 0x3C	; 60
     902:	80 83       	st	Z, r24
     904:	91 83       	std	Z+1, r25	; 0x01
     906:	a2 83       	std	Z+2, r26	; 0x02
     908:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     90a:	81 e0       	ldi	r24, 0x01	; 1
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	f3 01       	movw	r30, r6
     910:	84 af       	std	Z+60, r24	; 0x3c
     912:	95 af       	std	Z+61, r25	; 0x3d
		runs++;
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     914:	68 94       	set
     916:	44 24       	eor	r4, r4
     918:	41 f8       	bld	r4, 1
     91a:	51 2c       	mov	r5, r1
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     91c:	0f 2e       	mov	r0, r31
     91e:	ff e3       	ldi	r31, 0x3F	; 63
     920:	2f 2e       	mov	r2, r31
     922:	f0 2d       	mov	r31, r0
     924:	0f 2e       	mov	r0, r31
     926:	fc e3       	ldi	r31, 0x3C	; 60
     928:	3f 2e       	mov	r3, r31
     92a:	f0 2d       	mov	r31, r0
	dt = .008;
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     92c:	f3 01       	movw	r30, r6
     92e:	86 85       	ldd	r24, Z+14	; 0x0e
     930:	97 85       	ldd	r25, Z+15	; 0x0f
     932:	a0 89       	ldd	r26, Z+16	; 0x10
     934:	b1 89       	ldd	r27, Z+17	; 0x11
     936:	01 96       	adiw	r24, 0x01	; 1
     938:	a1 1d       	adc	r26, r1
     93a:	b1 1d       	adc	r27, r1
     93c:	86 87       	std	Z+14, r24	; 0x0e
     93e:	97 87       	std	Z+15, r25	; 0x0f
     940:	a0 8b       	std	Z+16, r26	; 0x10
     942:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     944:	42 8e       	std	Z+26, r4	; 0x1a
     946:	53 8e       	std	Z+27, r5	; 0x1b

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
     948:	16 8e       	std	Z+30, r1	; 0x1e
     94a:	17 8e       	std	Z+31, r1	; 0x1f
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     94c:	2f 92       	push	r2
     94e:	1f 92       	push	r1
     950:	1f 92       	push	r1
     952:	1f 92       	push	r1
     954:	3f 92       	push	r3
     956:	f3 e2       	ldi	r31, 0x23	; 35
     958:	ff 93       	push	r31
     95a:	27 ed       	ldi	r18, 0xD7	; 215
     95c:	2f 93       	push	r18
     95e:	3a e0       	ldi	r19, 0x0A	; 10
     960:	3f 93       	push	r19
     962:	0f 2e       	mov	r0, r31
     964:	fd ec       	ldi	r31, 0xCD	; 205
     966:	8f 2e       	mov	r8, r31
     968:	fc ec       	ldi	r31, 0xCC	; 204
     96a:	9f 2e       	mov	r9, r31
     96c:	a9 2c       	mov	r10, r9
     96e:	fd e3       	ldi	r31, 0x3D	; 61
     970:	bf 2e       	mov	r11, r31
     972:	f0 2d       	mov	r31, r0
     974:	0f 2e       	mov	r0, r31
     976:	f4 e1       	ldi	r31, 0x14	; 20
     978:	cf 2e       	mov	r12, r31
     97a:	fe ea       	ldi	r31, 0xAE	; 174
     97c:	df 2e       	mov	r13, r31
     97e:	ff e8       	ldi	r31, 0x8F	; 143
     980:	ef 2e       	mov	r14, r31
     982:	ff eb       	ldi	r31, 0xBF	; 191
     984:	ff 2e       	mov	r15, r31
     986:	f0 2d       	mov	r31, r0
     988:	04 e1       	ldi	r16, 0x14	; 20
     98a:	1e ea       	ldi	r17, 0xAE	; 174
     98c:	2f e8       	ldi	r18, 0x8F	; 143
     98e:	3f e3       	ldi	r19, 0x3F	; 63
     990:	b5 01       	movw	r22, r10
     992:	a4 01       	movw	r20, r8
     994:	ce 01       	movw	r24, r28
     996:	05 96       	adiw	r24, 0x05	; 5
     998:	0e 94 a3 05 	call	0xb46	; 0xb46 <_ZN3PIDC1Edddddd>
		double Tset = pidTorque.calculate(omegam_set, omegam_measured);
     99c:	f3 01       	movw	r30, r6
     99e:	66 8d       	ldd	r22, Z+30	; 0x1e
     9a0:	77 8d       	ldd	r23, Z+31	; 0x1f
     9a2:	02 8d       	ldd	r16, Z+26	; 0x1a
     9a4:	13 8d       	ldd	r17, Z+27	; 0x1b
     9a6:	07 2e       	mov	r0, r23
     9a8:	00 0c       	add	r0, r0
     9aa:	88 0b       	sbc	r24, r24
     9ac:	99 0b       	sbc	r25, r25
     9ae:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     9b2:	6b 01       	movw	r12, r22
     9b4:	7c 01       	movw	r14, r24
     9b6:	b8 01       	movw	r22, r16
     9b8:	11 0f       	add	r17, r17
     9ba:	88 0b       	sbc	r24, r24
     9bc:	99 0b       	sbc	r25, r25
     9be:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     9c2:	ab 01       	movw	r20, r22
     9c4:	bc 01       	movw	r22, r24
     9c6:	97 01       	movw	r18, r14
     9c8:	86 01       	movw	r16, r12
     9ca:	ce 01       	movw	r24, r28
     9cc:	05 96       	adiw	r24, 0x05	; 5
     9ce:	0e 94 ca 06 	call	0xd94	; 0xd94 <_ZN3PID9calculateEdd>
     9d2:	6b 01       	movw	r12, r22
     9d4:	7c 01       	movw	r14, r24
		//printf("val:% 7.3f inc:% 7.3f\n", omegam_measured, inc);
		omegam_measured += inc;
     9d6:	f3 01       	movw	r30, r6
     9d8:	24 ad       	ldd	r18, Z+60	; 0x3c
     9da:	35 ad       	ldd	r19, Z+61	; 0x3d
     9dc:	86 8d       	ldd	r24, Z+30	; 0x1e
     9de:	97 8d       	ldd	r25, Z+31	; 0x1f
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	86 8f       	std	Z+30, r24	; 0x1e
     9e6:	97 8f       	std	Z+31, r25	; 0x1f

		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     9e8:	10 a6       	std	Z+40, r1	; 0x28
     9ea:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     9ec:	60 a5       	ldd	r22, Z+40	; 0x28
     9ee:	71 a5       	ldd	r23, Z+41	; 0x29
     9f0:	07 2e       	mov	r0, r23
     9f2:	00 0c       	add	r0, r0
     9f4:	88 0b       	sbc	r24, r24
     9f6:	99 0b       	sbc	r25, r25
     9f8:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     9fc:	9b 01       	movw	r18, r22
     9fe:	ac 01       	movw	r20, r24
     a00:	c7 01       	movw	r24, r14
     a02:	b6 01       	movw	r22, r12
     a04:	0e 94 59 20 	call	0x40b2	; 0x40b2 <__divsf3>
     a08:	0e 94 cb 20 	call	0x4196	; 0x4196 <__fixsfsi>
     a0c:	f3 01       	movw	r30, r6
     a0e:	64 a3       	std	Z+36, r22	; 0x24
     a10:	75 a3       	std	Z+37, r23	; 0x25

		// Saturater for current
		
		if(Im_set > 17.4) {
     a12:	64 a1       	ldd	r22, Z+36	; 0x24
     a14:	75 a1       	ldd	r23, Z+37	; 0x25
     a16:	07 2e       	mov	r0, r23
     a18:	00 0c       	add	r0, r0
     a1a:	88 0b       	sbc	r24, r24
     a1c:	99 0b       	sbc	r25, r25
     a1e:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     a22:	cd bf       	out	0x3d, r28	; 61
     a24:	de bf       	out	0x3e, r29	; 62
     a26:	23 e3       	ldi	r18, 0x33	; 51
     a28:	33 e3       	ldi	r19, 0x33	; 51
     a2a:	4b e8       	ldi	r20, 0x8B	; 139
     a2c:	51 e4       	ldi	r21, 0x41	; 65
     a2e:	0e 94 b3 21 	call	0x4366	; 0x4366 <__gesf2>
     a32:	18 16       	cp	r1, r24
     a34:	34 f4       	brge	.+12     	; 0xa42 <_ZN5Motor3runEv+0x166>
			Im_set = 17.4;
     a36:	21 e1       	ldi	r18, 0x11	; 17
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	f3 01       	movw	r30, r6
     a3c:	24 a3       	std	Z+36, r18	; 0x24
     a3e:	35 a3       	std	Z+37, r19	; 0x25
     a40:	16 c0       	rjmp	.+44     	; 0xa6e <_ZN5Motor3runEv+0x192>
		} else if(Im_set < -17.4) {
     a42:	f3 01       	movw	r30, r6
     a44:	64 a1       	ldd	r22, Z+36	; 0x24
     a46:	75 a1       	ldd	r23, Z+37	; 0x25
     a48:	07 2e       	mov	r0, r23
     a4a:	00 0c       	add	r0, r0
     a4c:	88 0b       	sbc	r24, r24
     a4e:	99 0b       	sbc	r25, r25
     a50:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     a54:	23 e3       	ldi	r18, 0x33	; 51
     a56:	33 e3       	ldi	r19, 0x33	; 51
     a58:	4b e8       	ldi	r20, 0x8B	; 139
     a5a:	51 ec       	ldi	r21, 0xC1	; 193
     a5c:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__cmpsf2>
     a60:	88 23       	and	r24, r24
     a62:	2c f4       	brge	.+10     	; 0xa6e <_ZN5Motor3runEv+0x192>
			Im_set = -17.4;
     a64:	2f ee       	ldi	r18, 0xEF	; 239
     a66:	3f ef       	ldi	r19, 0xFF	; 255
     a68:	f3 01       	movw	r30, r6
     a6a:	24 a3       	std	Z+36, r18	; 0x24
     a6c:	35 a3       	std	Z+37, r19	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     a6e:	f3 01       	movw	r30, r6
     a70:	16 aa       	std	Z+54, r1	; 0x36
     a72:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     a74:	60 a5       	ldd	r22, Z+40	; 0x28
     a76:	71 a5       	ldd	r23, Z+41	; 0x29
     a78:	06 a9       	ldd	r16, Z+54	; 0x36
     a7a:	17 a9       	ldd	r17, Z+55	; 0x37
     a7c:	07 2e       	mov	r0, r23
     a7e:	00 0c       	add	r0, r0
     a80:	88 0b       	sbc	r24, r24
     a82:	99 0b       	sbc	r25, r25
     a84:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     a88:	20 e5       	ldi	r18, 0x50	; 80
     a8a:	3a e6       	ldi	r19, 0x6A	; 106
     a8c:	41 ea       	ldi	r20, 0xA1	; 161
     a8e:	57 e4       	ldi	r21, 0x47	; 71
     a90:	0e 94 b8 21 	call	0x4370	; 0x4370 <__mulsf3>
     a94:	6b 01       	movw	r12, r22
     a96:	7c 01       	movw	r14, r24
     a98:	b8 01       	movw	r22, r16
     a9a:	11 0f       	add	r17, r17
     a9c:	88 0b       	sbc	r24, r24
     a9e:	99 0b       	sbc	r25, r25
     aa0:	0e 94 03 21 	call	0x4206	; 0x4206 <__floatsisf>
     aa4:	9b 01       	movw	r18, r22
     aa6:	ac 01       	movw	r20, r24
     aa8:	c7 01       	movw	r24, r14
     aaa:	b6 01       	movw	r22, r12
     aac:	0e 94 b8 21 	call	0x4370	; 0x4370 <__mulsf3>
     ab0:	0e 94 cb 20 	call	0x4196	; 0x4196 <__fixsfsi>
     ab4:	f3 01       	movw	r30, r6
     ab6:	62 ab       	std	Z+50, r22	; 0x32
     ab8:	73 ab       	std	Z+51, r23	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     aba:	46 a9       	ldd	r20, Z+54	; 0x36
     abc:	57 a9       	ldd	r21, Z+55	; 0x37
     abe:	26 8d       	ldd	r18, Z+30	; 0x1e
     ac0:	37 8d       	ldd	r19, Z+31	; 0x1f
     ac2:	42 9f       	mul	r20, r18
     ac4:	c0 01       	movw	r24, r0
     ac6:	43 9f       	mul	r20, r19
     ac8:	90 0d       	add	r25, r0
     aca:	52 9f       	mul	r21, r18
     acc:	90 0d       	add	r25, r0
     ace:	11 24       	eor	r1, r1
     ad0:	84 ab       	std	Z+52, r24	; 0x34
     ad2:	95 ab       	std	Z+53, r25	; 0x35

		V_m = V_R + V_E;
     ad4:	20 a9       	ldd	r18, Z+48	; 0x30
     ad6:	31 a9       	ldd	r19, Z+49	; 0x31
     ad8:	84 a9       	ldd	r24, Z+52	; 0x34
     ada:	95 a9       	ldd	r25, Z+53	; 0x35
     adc:	82 0f       	add	r24, r18
     ade:	93 1f       	adc	r25, r19
     ae0:	80 af       	std	Z+56, r24	; 0x38
     ae2:	91 af       	std	Z+57, r25	; 0x39

		// Saturater for voltage
		if (V_m > 24) {
     ae4:	80 ad       	ldd	r24, Z+56	; 0x38
     ae6:	91 ad       	ldd	r25, Z+57	; 0x39
     ae8:	49 97       	sbiw	r24, 0x19	; 25
     aea:	2c f0       	brlt	.+10     	; 0xaf6 <_ZN5Motor3runEv+0x21a>
			V_m = 24;
     aec:	28 e1       	ldi	r18, 0x18	; 24
     aee:	30 e0       	ldi	r19, 0x00	; 0
     af0:	20 af       	std	Z+56, r18	; 0x38
     af2:	31 af       	std	Z+57, r19	; 0x39
     af4:	0b c0       	rjmp	.+22     	; 0xb0c <_ZN5Motor3runEv+0x230>
		} else if(V_m < -24) {
     af6:	f3 01       	movw	r30, r6
     af8:	80 ad       	ldd	r24, Z+56	; 0x38
     afa:	91 ad       	ldd	r25, Z+57	; 0x39
     afc:	88 3e       	cpi	r24, 0xE8	; 232
     afe:	9f 4f       	sbci	r25, 0xFF	; 255
     b00:	2c f4       	brge	.+10     	; 0xb0c <_ZN5Motor3runEv+0x230>
			V_m = -24;
     b02:	28 ee       	ldi	r18, 0xE8	; 232
     b04:	3f ef       	ldi	r19, 0xFF	; 255
     b06:	f3 01       	movw	r30, r6
     b08:	20 af       	std	Z+56, r18	; 0x38
     b0a:	31 af       	std	Z+57, r19	; 0x39
     b0c:	41 e0       	ldi	r20, 0x01	; 1
     b0e:	50 e0       	ldi	r21, 0x00	; 0
     b10:	60 e0       	ldi	r22, 0x00	; 0
     b12:	70 e0       	ldi	r23, 0x00	; 0
     b14:	ce 01       	movw	r24, r28
     b16:	01 96       	adiw	r24, 0x01	; 1
     b18:	0e 94 fe 11 	call	0x23fc	; 0x23fc <vTaskDelayUntil>
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     b1c:	ce 01       	movw	r24, r28
     b1e:	05 96       	adiw	r24, 0x05	; 5
     b20:	0e 94 0a 06 	call	0xc14	; 0xc14 <_ZN3PIDD1Ev>
	portTickType previousTicks = xTaskGetTickCount ();

	dt = .008;
	inc = 1;
	
	while(1){
     b24:	03 cf       	rjmp	.-506    	; 0x92c <_ZN5Motor3runEv+0x50>

00000b26 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     b26:	0f 93       	push	r16
     b28:	1f 93       	push	r17
     b2a:	cf 93       	push	r28
     b2c:	df 93       	push	r29
     b2e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     b30:	0e 94 9b 14 	call	0x2936	; 0x2936 <_ZN8frt_taskC1EPKchjP8emstream>
     b34:	8c e4       	ldi	r24, 0x4C	; 76
     b36:	90 e2       	ldi	r25, 0x20	; 32
     b38:	88 83       	st	Y, r24
     b3a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     b3c:	df 91       	pop	r29
     b3e:	cf 91       	pop	r28
     b40:	1f 91       	pop	r17
     b42:	0f 91       	pop	r16
     b44:	08 95       	ret

00000b46 <_ZN3PIDC1Edddddd>:
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}
     b46:	2f 92       	push	r2
     b48:	3f 92       	push	r3
     b4a:	4f 92       	push	r4
     b4c:	5f 92       	push	r5
     b4e:	6f 92       	push	r6
     b50:	7f 92       	push	r7
     b52:	8f 92       	push	r8
     b54:	9f 92       	push	r9
     b56:	af 92       	push	r10
     b58:	bf 92       	push	r11
     b5a:	cf 92       	push	r12
     b5c:	df 92       	push	r13
     b5e:	ef 92       	push	r14
     b60:	ff 92       	push	r15
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	00 d0       	rcall	.+0      	; 0xb6c <_ZN3PIDC1Edddddd+0x26>
     b6c:	1f 92       	push	r1
     b6e:	cd b7       	in	r28, 0x3d	; 61
     b70:	de b7       	in	r29, 0x3e	; 62
     b72:	1c 01       	movw	r2, r24
     b74:	2a 01       	movw	r4, r20
     b76:	3b 01       	movw	r6, r22
     b78:	09 83       	std	Y+1, r16	; 0x01
     b7a:	1a 83       	std	Y+2, r17	; 0x02
     b7c:	2b 83       	std	Y+3, r18	; 0x03
     b7e:	3c 83       	std	Y+4, r19	; 0x04
     b80:	80 e2       	ldi	r24, 0x20	; 32
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	0e 94 15 19 	call	0x322a	; 0x322a <_Znwj>
     b88:	fc 01       	movw	r30, r24
     b8a:	40 82       	st	Z, r4
     b8c:	51 82       	std	Z+1, r5	; 0x01
     b8e:	62 82       	std	Z+2, r6	; 0x02
     b90:	73 82       	std	Z+3, r7	; 0x03
     b92:	89 81       	ldd	r24, Y+1	; 0x01
     b94:	9a 81       	ldd	r25, Y+2	; 0x02
     b96:	ab 81       	ldd	r26, Y+3	; 0x03
     b98:	bc 81       	ldd	r27, Y+4	; 0x04
     b9a:	84 83       	std	Z+4, r24	; 0x04
     b9c:	95 83       	std	Z+5, r25	; 0x05
     b9e:	a6 83       	std	Z+6, r26	; 0x06
     ba0:	b7 83       	std	Z+7, r27	; 0x07
     ba2:	c0 86       	std	Z+8, r12	; 0x08
     ba4:	d1 86       	std	Z+9, r13	; 0x09
     ba6:	e2 86       	std	Z+10, r14	; 0x0a
     ba8:	f3 86       	std	Z+11, r15	; 0x0b
     baa:	84 86       	std	Z+12, r8	; 0x0c
     bac:	95 86       	std	Z+13, r9	; 0x0d
     bae:	a6 86       	std	Z+14, r10	; 0x0e
     bb0:	b7 86       	std	Z+15, r11	; 0x0f
     bb2:	4a 8d       	ldd	r20, Y+26	; 0x1a
     bb4:	5b 8d       	ldd	r21, Y+27	; 0x1b
     bb6:	6c 8d       	ldd	r22, Y+28	; 0x1c
     bb8:	7d 8d       	ldd	r23, Y+29	; 0x1d
     bba:	40 8b       	std	Z+16, r20	; 0x10
     bbc:	51 8b       	std	Z+17, r21	; 0x11
     bbe:	62 8b       	std	Z+18, r22	; 0x12
     bc0:	73 8b       	std	Z+19, r23	; 0x13
     bc2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bc4:	9f 8d       	ldd	r25, Y+31	; 0x1f
     bc6:	a8 a1       	ldd	r26, Y+32	; 0x20
     bc8:	b9 a1       	ldd	r27, Y+33	; 0x21
     bca:	84 8b       	std	Z+20, r24	; 0x14
     bcc:	95 8b       	std	Z+21, r25	; 0x15
     bce:	a6 8b       	std	Z+22, r26	; 0x16
     bd0:	b7 8b       	std	Z+23, r27	; 0x17
     bd2:	10 8e       	std	Z+24, r1	; 0x18
     bd4:	11 8e       	std	Z+25, r1	; 0x19
     bd6:	12 8e       	std	Z+26, r1	; 0x1a
     bd8:	13 8e       	std	Z+27, r1	; 0x1b
     bda:	14 8e       	std	Z+28, r1	; 0x1c
     bdc:	15 8e       	std	Z+29, r1	; 0x1d
     bde:	16 8e       	std	Z+30, r1	; 0x1e
     be0:	17 8e       	std	Z+31, r1	; 0x1f
     be2:	d1 01       	movw	r26, r2
     be4:	ed 93       	st	X+, r30
     be6:	fc 93       	st	X, r31
     be8:	24 96       	adiw	r28, 0x04	; 4
     bea:	cd bf       	out	0x3d, r28	; 61
     bec:	de bf       	out	0x3e, r29	; 62
     bee:	df 91       	pop	r29
     bf0:	cf 91       	pop	r28
     bf2:	1f 91       	pop	r17
     bf4:	0f 91       	pop	r16
     bf6:	ff 90       	pop	r15
     bf8:	ef 90       	pop	r14
     bfa:	df 90       	pop	r13
     bfc:	cf 90       	pop	r12
     bfe:	bf 90       	pop	r11
     c00:	af 90       	pop	r10
     c02:	9f 90       	pop	r9
     c04:	8f 90       	pop	r8
     c06:	7f 90       	pop	r7
     c08:	6f 90       	pop	r6
     c0a:	5f 90       	pop	r5
     c0c:	4f 90       	pop	r4
     c0e:	3f 90       	pop	r3
     c10:	2f 90       	pop	r2
     c12:	08 95       	ret

00000c14 <_ZN3PIDD1Ev>:
     c14:	fc 01       	movw	r30, r24
     c16:	80 81       	ld	r24, Z
     c18:	91 81       	ldd	r25, Z+1	; 0x01
     c1a:	00 97       	sbiw	r24, 0x00	; 0
     c1c:	11 f0       	breq	.+4      	; 0xc22 <_ZN3PIDD1Ev+0xe>
     c1e:	0e 94 18 19 	call	0x3230	; 0x3230 <_ZdlPv>
     c22:	08 95       	ret

00000c24 <_ZN7PIDImpl9calculateEdd>:

double PIDImpl::calculate( double setpoint, double pv )
{
     c24:	4f 92       	push	r4
     c26:	5f 92       	push	r5
     c28:	6f 92       	push	r6
     c2a:	7f 92       	push	r7
     c2c:	8f 92       	push	r8
     c2e:	9f 92       	push	r9
     c30:	af 92       	push	r10
     c32:	bf 92       	push	r11
     c34:	cf 92       	push	r12
     c36:	df 92       	push	r13
     c38:	ef 92       	push	r14
     c3a:	ff 92       	push	r15
     c3c:	0f 93       	push	r16
     c3e:	1f 93       	push	r17
     c40:	cf 93       	push	r28
     c42:	df 93       	push	r29
     c44:	00 d0       	rcall	.+0      	; 0xc46 <_ZN7PIDImpl9calculateEdd+0x22>
     c46:	00 d0       	rcall	.+0      	; 0xc48 <_ZN7PIDImpl9calculateEdd+0x24>
     c48:	cd b7       	in	r28, 0x3d	; 61
     c4a:	de b7       	in	r29, 0x3e	; 62
     c4c:	8d 83       	std	Y+5, r24	; 0x05
     c4e:	9e 83       	std	Y+6, r25	; 0x06
     c50:	cb 01       	movw	r24, r22
     c52:	ba 01       	movw	r22, r20
    
    // Calculate error
    double error = setpoint - pv;
     c54:	a9 01       	movw	r20, r18
     c56:	98 01       	movw	r18, r16
     c58:	0e 94 e7 1f 	call	0x3fce	; 0x3fce <__subsf3>
     c5c:	6b 01       	movw	r12, r22
     c5e:	7c 01       	movw	r14, r24

    // Proportional term
    double Pout = _Kp * error;
     c60:	ed 81       	ldd	r30, Y+5	; 0x05
     c62:	fe 81       	ldd	r31, Y+6	; 0x06
     c64:	24 85       	ldd	r18, Z+12	; 0x0c
     c66:	35 85       	ldd	r19, Z+13	; 0x0d
     c68:	46 85       	ldd	r20, Z+14	; 0x0e
     c6a:	57 85       	ldd	r21, Z+15	; 0x0f
     c6c:	0e 94 b8 21 	call	0x4370	; 0x4370 <__mulsf3>
     c70:	69 83       	std	Y+1, r22	; 0x01
     c72:	7a 83       	std	Y+2, r23	; 0x02
     c74:	8b 83       	std	Y+3, r24	; 0x03
     c76:	9c 83       	std	Y+4, r25	; 0x04

    // Integral term
    _integral += error * _dt;
     c78:	ed 81       	ldd	r30, Y+5	; 0x05
     c7a:	fe 81       	ldd	r31, Y+6	; 0x06
     c7c:	40 80       	ld	r4, Z
     c7e:	51 80       	ldd	r5, Z+1	; 0x01
     c80:	62 80       	ldd	r6, Z+2	; 0x02
     c82:	73 80       	ldd	r7, Z+3	; 0x03
     c84:	a3 01       	movw	r20, r6
     c86:	92 01       	movw	r18, r4
     c88:	c7 01       	movw	r24, r14
     c8a:	b6 01       	movw	r22, r12
     c8c:	0e 94 b8 21 	call	0x4370	; 0x4370 <__mulsf3>
     c90:	ed 81       	ldd	r30, Y+5	; 0x05
     c92:	fe 81       	ldd	r31, Y+6	; 0x06
     c94:	24 8d       	ldd	r18, Z+28	; 0x1c
     c96:	35 8d       	ldd	r19, Z+29	; 0x1d
     c98:	46 8d       	ldd	r20, Z+30	; 0x1e
     c9a:	57 8d       	ldd	r21, Z+31	; 0x1f
     c9c:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <__addsf3>
     ca0:	4b 01       	movw	r8, r22
     ca2:	5c 01       	movw	r10, r24
     ca4:	ed 81       	ldd	r30, Y+5	; 0x05
     ca6:	fe 81       	ldd	r31, Y+6	; 0x06
     ca8:	64 8f       	std	Z+28, r22	; 0x1c
     caa:	75 8f       	std	Z+29, r23	; 0x1d
     cac:	86 8f       	std	Z+30, r24	; 0x1e
     cae:	97 8f       	std	Z+31, r25	; 0x1f
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     cb0:	20 8d       	ldd	r18, Z+24	; 0x18
     cb2:	31 8d       	ldd	r19, Z+25	; 0x19
     cb4:	42 8d       	ldd	r20, Z+26	; 0x1a
     cb6:	53 8d       	ldd	r21, Z+27	; 0x1b
     cb8:	c7 01       	movw	r24, r14
     cba:	b6 01       	movw	r22, r12
     cbc:	0e 94 e7 1f 	call	0x3fce	; 0x3fce <__subsf3>
     cc0:	a3 01       	movw	r20, r6
     cc2:	92 01       	movw	r18, r4
     cc4:	0e 94 59 20 	call	0x40b2	; 0x40b2 <__divsf3>
     cc8:	ed 81       	ldd	r30, Y+5	; 0x05
     cca:	fe 81       	ldd	r31, Y+6	; 0x06
     ccc:	20 89       	ldd	r18, Z+16	; 0x10
     cce:	31 89       	ldd	r19, Z+17	; 0x11
     cd0:	42 89       	ldd	r20, Z+18	; 0x12
     cd2:	53 89       	ldd	r21, Z+19	; 0x13
     cd4:	0e 94 b8 21 	call	0x4370	; 0x4370 <__mulsf3>
     cd8:	2b 01       	movw	r4, r22
     cda:	3c 01       	movw	r6, r24
     cdc:	ed 81       	ldd	r30, Y+5	; 0x05
     cde:	fe 81       	ldd	r31, Y+6	; 0x06
     ce0:	24 89       	ldd	r18, Z+20	; 0x14
     ce2:	35 89       	ldd	r19, Z+21	; 0x15
     ce4:	46 89       	ldd	r20, Z+22	; 0x16
     ce6:	57 89       	ldd	r21, Z+23	; 0x17
     ce8:	c5 01       	movw	r24, r10
     cea:	b4 01       	movw	r22, r8
     cec:	0e 94 b8 21 	call	0x4370	; 0x4370 <__mulsf3>
     cf0:	29 81       	ldd	r18, Y+1	; 0x01
     cf2:	3a 81       	ldd	r19, Y+2	; 0x02
     cf4:	4b 81       	ldd	r20, Y+3	; 0x03
     cf6:	5c 81       	ldd	r21, Y+4	; 0x04
     cf8:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <__addsf3>
     cfc:	9b 01       	movw	r18, r22
     cfe:	ac 01       	movw	r20, r24
     d00:	c3 01       	movw	r24, r6
     d02:	b2 01       	movw	r22, r4
     d04:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <__addsf3>
     d08:	b6 2e       	mov	r11, r22
     d0a:	a7 2e       	mov	r10, r23
     d0c:	98 2e       	mov	r9, r24
     d0e:	89 2e       	mov	r8, r25

    // Restrict to max/min
    if( output > _max )
     d10:	ed 81       	ldd	r30, Y+5	; 0x05
     d12:	fe 81       	ldd	r31, Y+6	; 0x06
     d14:	74 80       	ldd	r7, Z+4	; 0x04
     d16:	65 80       	ldd	r6, Z+5	; 0x05
     d18:	56 80       	ldd	r5, Z+6	; 0x06
     d1a:	47 80       	ldd	r4, Z+7	; 0x07
     d1c:	27 2d       	mov	r18, r7
     d1e:	36 2d       	mov	r19, r6
     d20:	45 2d       	mov	r20, r5
     d22:	54 2d       	mov	r21, r4
     d24:	0e 94 b3 21 	call	0x4366	; 0x4366 <__gesf2>
     d28:	18 16       	cp	r1, r24
     d2a:	b4 f0       	brlt	.+44     	; 0xd58 <_ZN7PIDImpl9calculateEdd+0x134>
        output = _max;
    else if( output < _min )
     d2c:	ed 81       	ldd	r30, Y+5	; 0x05
     d2e:	fe 81       	ldd	r31, Y+6	; 0x06
     d30:	70 84       	ldd	r7, Z+8	; 0x08
     d32:	61 84       	ldd	r6, Z+9	; 0x09
     d34:	52 84       	ldd	r5, Z+10	; 0x0a
     d36:	43 84       	ldd	r4, Z+11	; 0x0b
     d38:	27 2d       	mov	r18, r7
     d3a:	36 2d       	mov	r19, r6
     d3c:	45 2d       	mov	r20, r5
     d3e:	54 2d       	mov	r21, r4
     d40:	6b 2d       	mov	r22, r11
     d42:	7a 2d       	mov	r23, r10
     d44:	89 2d       	mov	r24, r9
     d46:	98 2d       	mov	r25, r8
     d48:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__cmpsf2>
     d4c:	88 23       	and	r24, r24
     d4e:	24 f0       	brlt	.+8      	; 0xd58 <_ZN7PIDImpl9calculateEdd+0x134>
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     d50:	7b 2c       	mov	r7, r11
     d52:	6a 2c       	mov	r6, r10
     d54:	59 2c       	mov	r5, r9
     d56:	48 2c       	mov	r4, r8
        output = _max;
    else if( output < _min )
        output = _min;

    // Save error to previous error
    _pre_error = error;
     d58:	ed 81       	ldd	r30, Y+5	; 0x05
     d5a:	fe 81       	ldd	r31, Y+6	; 0x06
     d5c:	c0 8e       	std	Z+24, r12	; 0x18
     d5e:	d1 8e       	std	Z+25, r13	; 0x19
     d60:	e2 8e       	std	Z+26, r14	; 0x1a
     d62:	f3 8e       	std	Z+27, r15	; 0x1b

    return output;
}
     d64:	67 2d       	mov	r22, r7
     d66:	76 2d       	mov	r23, r6
     d68:	85 2d       	mov	r24, r5
     d6a:	94 2d       	mov	r25, r4
     d6c:	26 96       	adiw	r28, 0x06	; 6
     d6e:	cd bf       	out	0x3d, r28	; 61
     d70:	de bf       	out	0x3e, r29	; 62
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	1f 91       	pop	r17
     d78:	0f 91       	pop	r16
     d7a:	ff 90       	pop	r15
     d7c:	ef 90       	pop	r14
     d7e:	df 90       	pop	r13
     d80:	cf 90       	pop	r12
     d82:	bf 90       	pop	r11
     d84:	af 90       	pop	r10
     d86:	9f 90       	pop	r9
     d88:	8f 90       	pop	r8
     d8a:	7f 90       	pop	r7
     d8c:	6f 90       	pop	r6
     d8e:	5f 90       	pop	r5
     d90:	4f 90       	pop	r4
     d92:	08 95       	ret

00000d94 <_ZN3PID9calculateEdd>:
PID::PID( double dt, double max, double min, double Kp, double Kd, double Ki )
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
double PID::calculate( double setpoint, double pv )
{
     d94:	0f 93       	push	r16
     d96:	1f 93       	push	r17
    return pimpl->calculate(setpoint,pv);
     d98:	fc 01       	movw	r30, r24
     d9a:	80 81       	ld	r24, Z
     d9c:	91 81       	ldd	r25, Z+1	; 0x01
     d9e:	0e 94 12 06 	call	0xc24	; 0xc24 <_ZN7PIDImpl9calculateEdd>
}
     da2:	1f 91       	pop	r17
     da4:	0f 91       	pop	r16
     da6:	08 95       	ret

00000da8 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     da8:	0f 93       	push	r16
     daa:	1f 93       	push	r17
     dac:	cf 93       	push	r28
     dae:	df 93       	push	r29
     db0:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     db2:	0e 94 9b 14 	call	0x2936	; 0x2936 <_ZN8frt_taskC1EPKchjP8emstream>
     db6:	84 e5       	ldi	r24, 0x54	; 84
     db8:	90 e2       	ldi	r25, 0x20	; 32
     dba:	88 83       	st	Y, r24
     dbc:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     dbe:	df 91       	pop	r29
     dc0:	cf 91       	pop	r28
     dc2:	1f 91       	pop	r17
     dc4:	0f 91       	pop	r16
     dc6:	08 95       	ret

00000dc8 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     dc8:	0f 93       	push	r16
     dca:	1f 93       	push	r17
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
     dd0:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     dd2:	6a e0       	ldi	r22, 0x0A	; 10
     dd4:	8e 81       	ldd	r24, Y+6	; 0x06
     dd6:	9f 81       	ldd	r25, Y+7	; 0x07
     dd8:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     ddc:	8c 01       	movw	r16, r24
     dde:	69 ee       	ldi	r22, 0xE9	; 233
     de0:	73 e0       	ldi	r23, 0x03	; 3
     de2:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     de6:	6a e0       	ldi	r22, 0x0A	; 10
     de8:	c8 01       	movw	r24, r16
     dea:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     dee:	8c 01       	movw	r16, r24
     df0:	63 ee       	ldi	r22, 0xE3	; 227
     df2:	73 e0       	ldi	r23, 0x03	; 3
     df4:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     df8:	67 e0       	ldi	r22, 0x07	; 7
     dfa:	c8 01       	movw	r24, r16
     dfc:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     e00:	6a e0       	ldi	r22, 0x0A	; 10
     e02:	8e 81       	ldd	r24, Y+6	; 0x06
     e04:	9f 81       	ldd	r25, Y+7	; 0x07
     e06:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     e0a:	8c 01       	movw	r16, r24
     e0c:	64 ec       	ldi	r22, 0xC4	; 196
     e0e:	73 e0       	ldi	r23, 0x03	; 3
     e10:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     e14:	6a e0       	ldi	r22, 0x0A	; 10
     e16:	c8 01       	movw	r24, r16
     e18:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     e1c:	8c 01       	movw	r16, r24
     e1e:	6e eb       	ldi	r22, 0xBE	; 190
     e20:	73 e0       	ldi	r23, 0x03	; 3
     e22:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     e26:	66 e0       	ldi	r22, 0x06	; 6
     e28:	c8 01       	movw	r24, r16
     e2a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e2e:	6a e0       	ldi	r22, 0x0A	; 10
     e30:	8e 81       	ldd	r24, Y+6	; 0x06
     e32:	9f 81       	ldd	r25, Y+7	; 0x07
     e34:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     e38:	8c 01       	movw	r16, r24
     e3a:	67 ea       	ldi	r22, 0xA7	; 167
     e3c:	73 e0       	ldi	r23, 0x03	; 3
     e3e:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     e42:	66 e0       	ldi	r22, 0x06	; 6
     e44:	c8 01       	movw	r24, r16
     e46:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e4a:	6a e0       	ldi	r22, 0x0A	; 10
     e4c:	8e 81       	ldd	r24, Y+6	; 0x06
     e4e:	9f 81       	ldd	r25, Y+7	; 0x07
     e50:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     e54:	8c 01       	movw	r16, r24
     e56:	6b e8       	ldi	r22, 0x8B	; 139
     e58:	73 e0       	ldi	r23, 0x03	; 3
     e5a:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     e5e:	66 e0       	ldi	r22, 0x06	; 6
     e60:	c8 01       	movw	r24, r16
     e62:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e66:	6a e0       	ldi	r22, 0x0A	; 10
     e68:	8e 81       	ldd	r24, Y+6	; 0x06
     e6a:	9f 81       	ldd	r25, Y+7	; 0x07
     e6c:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     e70:	8c 01       	movw	r16, r24
     e72:	63 e7       	ldi	r22, 0x73	; 115
     e74:	73 e0       	ldi	r23, 0x03	; 3
     e76:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     e7a:	66 e0       	ldi	r22, 0x06	; 6
     e7c:	c8 01       	movw	r24, r16
     e7e:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e82:	6a e0       	ldi	r22, 0x0A	; 10
     e84:	8e 81       	ldd	r24, Y+6	; 0x06
     e86:	9f 81       	ldd	r25, Y+7	; 0x07
     e88:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     e8c:	8c 01       	movw	r16, r24
     e8e:	62 e5       	ldi	r22, 0x52	; 82
     e90:	73 e0       	ldi	r23, 0x03	; 3
     e92:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     e96:	66 e0       	ldi	r22, 0x06	; 6
     e98:	c8 01       	movw	r24, r16
     e9a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e9e:	6a e0       	ldi	r22, 0x0A	; 10
     ea0:	8e 81       	ldd	r24, Y+6	; 0x06
     ea2:	9f 81       	ldd	r25, Y+7	; 0x07
     ea4:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     ea8:	8c 01       	movw	r16, r24
     eaa:	6b e2       	ldi	r22, 0x2B	; 43
     eac:	73 e0       	ldi	r23, 0x03	; 3
     eae:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     eb2:	66 e0       	ldi	r22, 0x06	; 6
     eb4:	c8 01       	movw	r24, r16
     eb6:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     eba:	6a e0       	ldi	r22, 0x0A	; 10
     ebc:	8e 81       	ldd	r24, Y+6	; 0x06
     ebe:	9f 81       	ldd	r25, Y+7	; 0x07
     ec0:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     ec4:	8c 01       	movw	r16, r24
     ec6:	6d e0       	ldi	r22, 0x0D	; 13
     ec8:	73 e0       	ldi	r23, 0x03	; 3
     eca:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     ece:	66 e0       	ldi	r22, 0x06	; 6
     ed0:	c8 01       	movw	r24, r16
     ed2:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     ed6:	6a e0       	ldi	r22, 0x0A	; 10
     ed8:	8e 81       	ldd	r24, Y+6	; 0x06
     eda:	9f 81       	ldd	r25, Y+7	; 0x07
     edc:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     ee0:	8c 01       	movw	r16, r24
     ee2:	62 ef       	ldi	r22, 0xF2	; 242
     ee4:	72 e0       	ldi	r23, 0x02	; 2
     ee6:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     eea:	66 e0       	ldi	r22, 0x06	; 6
     eec:	c8 01       	movw	r24, r16
     eee:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     ef2:	6a e0       	ldi	r22, 0x0A	; 10
     ef4:	8e 81       	ldd	r24, Y+6	; 0x06
     ef6:	9f 81       	ldd	r25, Y+7	; 0x07
     ef8:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     efc:	ec 01       	movw	r28, r24
     efe:	63 ee       	ldi	r22, 0xE3	; 227
     f00:	72 e0       	ldi	r23, 0x02	; 2
     f02:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     f06:	66 e0       	ldi	r22, 0x06	; 6
     f08:	ce 01       	movw	r24, r28
     f0a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
}
     f0e:	df 91       	pop	r29
     f10:	cf 91       	pop	r28
     f12:	1f 91       	pop	r17
     f14:	0f 91       	pop	r16
     f16:	08 95       	ret

00000f18 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     f18:	af 92       	push	r10
     f1a:	bf 92       	push	r11
     f1c:	cf 92       	push	r12
     f1e:	df 92       	push	r13
     f20:	ef 92       	push	r14
     f22:	ff 92       	push	r15
     f24:	0f 93       	push	r16
     f26:	1f 93       	push	r17
     f28:	cf 93       	push	r28
     f2a:	df 93       	push	r29
     f2c:	00 d0       	rcall	.+0      	; 0xf2e <_ZN9task_user11show_statusEv+0x16>
     f2e:	00 d0       	rcall	.+0      	; 0xf30 <_ZN9task_user11show_statusEv+0x18>
     f30:	cd b7       	in	r28, 0x3d	; 61
     f32:	de b7       	in	r29, 0x3e	; 62
     f34:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f36:	19 82       	std	Y+1, r1	; 0x01
     f38:	1a 82       	std	Y+2, r1	; 0x02
     f3a:	1b 82       	std	Y+3, r1	; 0x03
     f3c:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f3e:	1d 82       	std	Y+5, r1	; 0x05
     f40:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f42:	0e 94 11 0a 	call	0x1422	; 0x1422 <xPortGetFreeHeapSize>
     f46:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f48:	ce 01       	movw	r24, r28
     f4a:	01 96       	adiw	r24, 0x01	; 1
     f4c:	0e 94 4c 18 	call	0x3098	; 0x3098 <_ZN10time_stamp10set_to_nowEv>
     f50:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f52:	66 e0       	ldi	r22, 0x06	; 6
     f54:	f8 01       	movw	r30, r16
     f56:	86 81       	ldd	r24, Z+6	; 0x06
     f58:	97 81       	ldd	r25, Z+7	; 0x07
     f5a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     f5e:	6a e0       	ldi	r22, 0x0A	; 10
     f60:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     f64:	7c 01       	movw	r14, r24
     f66:	64 ec       	ldi	r22, 0xC4	; 196
     f68:	72 e0       	ldi	r23, 0x02	; 2
     f6a:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     f6e:	6a e0       	ldi	r22, 0x0A	; 10
     f70:	c7 01       	movw	r24, r14
     f72:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     f76:	7c 01       	movw	r14, r24
     f78:	68 eb       	ldi	r22, 0xB8	; 184
     f7a:	72 e0       	ldi	r23, 0x02	; 2
     f7c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     f80:	66 e0       	ldi	r22, 0x06	; 6
     f82:	c7 01       	movw	r24, r14
     f84:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f88:	6a e0       	ldi	r22, 0x0A	; 10
     f8a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     f8e:	7c 01       	movw	r14, r24
     f90:	61 eb       	ldi	r22, 0xB1	; 177
     f92:	72 e0       	ldi	r23, 0x02	; 2
     f94:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     f98:	b5 01       	movw	r22, r10
     f9a:	c7 01       	movw	r24, r14
     f9c:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     fa0:	6a e0       	ldi	r22, 0x0A	; 10
     fa2:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     fa6:	7c 01       	movw	r14, r24
     fa8:	63 ea       	ldi	r22, 0xA3	; 163
     faa:	72 e0       	ldi	r23, 0x02	; 2
     fac:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     fb0:	b6 01       	movw	r22, r12
     fb2:	c7 01       	movw	r24, r14
     fb4:	0e 94 a7 1a 	call	0x354e	; 0x354e <_ZN8emstreamlsEj>
     fb8:	6a e0       	ldi	r22, 0x0A	; 10
     fba:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     fbe:	7c 01       	movw	r14, r24
     fc0:	61 ea       	ldi	r22, 0xA1	; 161
     fc2:	72 e0       	ldi	r23, 0x02	; 2
     fc4:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     fc8:	4f ef       	ldi	r20, 0xFF	; 255
     fca:	5f e0       	ldi	r21, 0x0F	; 15
     fcc:	60 e0       	ldi	r22, 0x00	; 0
     fce:	70 e0       	ldi	r23, 0x00	; 0
     fd0:	c7 01       	movw	r24, r14
     fd2:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     fd6:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     fda:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     fde:	6a e0       	ldi	r22, 0x0A	; 10
     fe0:	f8 01       	movw	r30, r16
     fe2:	86 81       	ldd	r24, Z+6	; 0x06
     fe4:	97 81       	ldd	r25, Z+7	; 0x07
     fe6:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
     fea:	7c 01       	movw	r14, r24
     fec:	66 e9       	ldi	r22, 0x96	; 150
     fee:	72 e0       	ldi	r23, 0x02	; 2
     ff0:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
     ff4:	b6 01       	movw	r22, r12
     ff6:	c7 01       	movw	r24, r14
     ff8:	0e 94 a7 1a 	call	0x354e	; 0x354e <_ZN8emstreamlsEj>
     ffc:	66 e0       	ldi	r22, 0x06	; 6
     ffe:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    1002:	66 e0       	ldi	r22, 0x06	; 6
    1004:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1008:	f8 01       	movw	r30, r16
    100a:	86 81       	ldd	r24, Z+6	; 0x06
    100c:	97 81       	ldd	r25, Z+7	; 0x07
    100e:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <_Z15print_task_listP8emstream>
}
    1012:	26 96       	adiw	r28, 0x06	; 6
    1014:	cd bf       	out	0x3d, r28	; 61
    1016:	de bf       	out	0x3e, r29	; 62
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	1f 91       	pop	r17
    101e:	0f 91       	pop	r16
    1020:	ff 90       	pop	r15
    1022:	ef 90       	pop	r14
    1024:	df 90       	pop	r13
    1026:	cf 90       	pop	r12
    1028:	bf 90       	pop	r11
    102a:	af 90       	pop	r10
    102c:	08 95       	ret

0000102e <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    102e:	cf 93       	push	r28
    1030:	df 93       	push	r29
    1032:	00 d0       	rcall	.+0      	; 0x1034 <_ZN9task_user3runEv+0x6>
    1034:	00 d0       	rcall	.+0      	; 0x1036 <_ZN9task_user3runEv+0x8>
    1036:	cd b7       	in	r28, 0x3d	; 61
    1038:	de b7       	in	r29, 0x3e	; 62
    103a:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    103c:	19 82       	std	Y+1, r1	; 0x01
    103e:	1a 82       	std	Y+2, r1	; 0x02
    1040:	1b 82       	std	Y+3, r1	; 0x03
    1042:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1044:	1d 82       	std	Y+5, r1	; 0x05
    1046:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1048:	6a e0       	ldi	r22, 0x0A	; 10
    104a:	dc 01       	movw	r26, r24
    104c:	16 96       	adiw	r26, 0x06	; 6
    104e:	8d 91       	ld	r24, X+
    1050:	9c 91       	ld	r25, X
    1052:	17 97       	sbiw	r26, 0x07	; 7
    1054:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    1058:	7c 01       	movw	r14, r24
    105a:	62 e3       	ldi	r22, 0x32	; 50
    105c:	74 e0       	ldi	r23, 0x04	; 4
    105e:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    1062:	66 e0       	ldi	r22, 0x06	; 6
    1064:	c7 01       	movw	r24, r14
    1066:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    106a:	f8 01       	movw	r30, r16
    106c:	84 85       	ldd	r24, Z+12	; 0x0c
    106e:	88 23       	and	r24, r24
    1070:	21 f0       	breq	.+8      	; 0x107a <_ZN9task_user3runEv+0x4c>
    1072:	81 30       	cpi	r24, 0x01	; 1
    1074:	09 f4       	brne	.+2      	; 0x1078 <_ZN9task_user3runEv+0x4a>
    1076:	5d c0       	rjmp	.+186    	; 0x1132 <_ZN9task_user3runEv+0x104>
    1078:	d8 c0       	rjmp	.+432    	; 0x122a <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    107a:	86 81       	ldd	r24, Z+6	; 0x06
    107c:	97 81       	ldd	r25, Z+7	; 0x07
    107e:	dc 01       	movw	r26, r24
    1080:	ed 91       	ld	r30, X+
    1082:	fc 91       	ld	r31, X
    1084:	04 80       	ldd	r0, Z+4	; 0x04
    1086:	f5 81       	ldd	r31, Z+5	; 0x05
    1088:	e0 2d       	mov	r30, r0
    108a:	19 95       	eicall
    108c:	88 23       	and	r24, r24
    108e:	a9 f1       	breq	.+106    	; 0x10fa <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1090:	f8 01       	movw	r30, r16
    1092:	86 81       	ldd	r24, Z+6	; 0x06
    1094:	97 81       	ldd	r25, Z+7	; 0x07
    1096:	dc 01       	movw	r26, r24
    1098:	ed 91       	ld	r30, X+
    109a:	fc 91       	ld	r31, X
    109c:	06 80       	ldd	r0, Z+6	; 0x06
    109e:	f7 81       	ldd	r31, Z+7	; 0x07
    10a0:	e0 2d       	mov	r30, r0
    10a2:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    10a4:	99 27       	eor	r25, r25
    10a6:	81 30       	cpi	r24, 0x01	; 1
    10a8:	91 05       	cpc	r25, r1
    10aa:	f9 f0       	breq	.+62     	; 0x10ea <_ZN9task_user3runEv+0xbc>
    10ac:	03 97       	sbiw	r24, 0x03	; 3
    10ae:	09 f0       	breq	.+2      	; 0x10b2 <_ZN9task_user3runEv+0x84>
    10b0:	d8 c0       	rjmp	.+432    	; 0x1262 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    10b2:	6a e0       	ldi	r22, 0x0A	; 10
    10b4:	f8 01       	movw	r30, r16
    10b6:	86 81       	ldd	r24, Z+6	; 0x06
    10b8:	97 81       	ldd	r25, Z+7	; 0x07
    10ba:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    10be:	8c 01       	movw	r16, r24
    10c0:	64 e2       	ldi	r22, 0x24	; 36
    10c2:	74 e0       	ldi	r23, 0x04	; 4
    10c4:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    10c8:	66 e0       	ldi	r22, 0x06	; 6
    10ca:	c8 01       	movw	r24, r16
    10cc:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10d0:	93 e0       	ldi	r25, 0x03	; 3
    10d2:	88 ed       	ldi	r24, 0xD8	; 216
    10d4:	08 b6       	in	r0, 0x38	; 56
    10d6:	18 be       	out	0x38, r1	; 56
    10d8:	84 bf       	out	0x34, r24	; 52
    10da:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10de:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10e2:	81 fd       	sbrc	r24, 1
    10e4:	fc cf       	rjmp	.-8      	; 0x10de <_ZN9task_user3runEv+0xb0>
    10e6:	08 be       	out	0x38, r0	; 56
    10e8:	ff cf       	rjmp	.-2      	; 0x10e8 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10ea:	c8 01       	movw	r24, r16
    10ec:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10f0:	61 e0       	ldi	r22, 0x01	; 1
    10f2:	c8 01       	movw	r24, r16
    10f4:	0e 94 97 14 	call	0x292e	; 0x292e <_ZN8frt_task13transition_toEh>
							break;
    10f8:	b4 c0       	rjmp	.+360    	; 0x1262 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10fa:	86 e7       	ldi	r24, 0x76	; 118
    10fc:	91 e3       	ldi	r25, 0x31	; 49
    10fe:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <_ZN14frt_text_queue14check_for_charEv>
    1102:	88 23       	and	r24, r24
    1104:	09 f4       	brne	.+2      	; 0x1108 <_ZN9task_user3runEv+0xda>
    1106:	ad c0       	rjmp	.+346    	; 0x1262 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1108:	d8 01       	movw	r26, r16
    110a:	16 96       	adiw	r26, 0x06	; 6
    110c:	ed 91       	ld	r30, X+
    110e:	fc 91       	ld	r31, X
    1110:	17 97       	sbiw	r26, 0x07	; 7
    1112:	01 90       	ld	r0, Z+
    1114:	f0 81       	ld	r31, Z
    1116:	e0 2d       	mov	r30, r0
    1118:	e2 80       	ldd	r14, Z+2	; 0x02
    111a:	f3 80       	ldd	r15, Z+3	; 0x03
    111c:	86 e7       	ldi	r24, 0x76	; 118
    111e:	91 e3       	ldi	r25, 0x31	; 49
    1120:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <_ZN14frt_text_queue7getcharEv>
    1124:	68 2f       	mov	r22, r24
    1126:	f8 01       	movw	r30, r16
    1128:	86 81       	ldd	r24, Z+6	; 0x06
    112a:	97 81       	ldd	r25, Z+7	; 0x07
    112c:	f7 01       	movw	r30, r14
    112e:	19 95       	eicall
    1130:	98 c0       	rjmp	.+304    	; 0x1262 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1132:	86 81       	ldd	r24, Z+6	; 0x06
    1134:	97 81       	ldd	r25, Z+7	; 0x07
    1136:	dc 01       	movw	r26, r24
    1138:	ed 91       	ld	r30, X+
    113a:	fc 91       	ld	r31, X
    113c:	04 80       	ldd	r0, Z+4	; 0x04
    113e:	f5 81       	ldd	r31, Z+5	; 0x05
    1140:	e0 2d       	mov	r30, r0
    1142:	19 95       	eicall
    1144:	88 23       	and	r24, r24
    1146:	09 f4       	brne	.+2      	; 0x114a <_ZN9task_user3runEv+0x11c>
    1148:	8c c0       	rjmp	.+280    	; 0x1262 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    114a:	f8 01       	movw	r30, r16
    114c:	86 81       	ldd	r24, Z+6	; 0x06
    114e:	97 81       	ldd	r25, Z+7	; 0x07
    1150:	dc 01       	movw	r26, r24
    1152:	ed 91       	ld	r30, X+
    1154:	fc 91       	ld	r31, X
    1156:	06 80       	ldd	r0, Z+6	; 0x06
    1158:	f7 81       	ldd	r31, Z+7	; 0x07
    115a:	e0 2d       	mov	r30, r0
    115c:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    115e:	9c 01       	movw	r18, r24
    1160:	33 27       	eor	r19, r19
    1162:	28 36       	cpi	r18, 0x68	; 104
    1164:	31 05       	cpc	r19, r1
    1166:	59 f1       	breq	.+86     	; 0x11be <_ZN9task_user3runEv+0x190>
    1168:	3c f4       	brge	.+14     	; 0x1178 <_ZN9task_user3runEv+0x14a>
    116a:	2b 31       	cpi	r18, 0x1B	; 27
    116c:	31 05       	cpc	r19, r1
    116e:	59 f1       	breq	.+86     	; 0x11c6 <_ZN9task_user3runEv+0x198>
    1170:	25 36       	cpi	r18, 0x65	; 101
    1172:	31 05       	cpc	r19, r1
    1174:	41 f1       	breq	.+80     	; 0x11c6 <_ZN9task_user3runEv+0x198>
    1176:	3b c0       	rjmp	.+118    	; 0x11ee <_ZN9task_user3runEv+0x1c0>
    1178:	23 37       	cpi	r18, 0x73	; 115
    117a:	31 05       	cpc	r19, r1
    117c:	c1 f0       	breq	.+48     	; 0x11ae <_ZN9task_user3runEv+0x180>
    117e:	26 37       	cpi	r18, 0x76	; 118
    1180:	31 05       	cpc	r19, r1
    1182:	89 f0       	breq	.+34     	; 0x11a6 <_ZN9task_user3runEv+0x178>
    1184:	2e 36       	cpi	r18, 0x6E	; 110
    1186:	31 05       	cpc	r19, r1
    1188:	91 f5       	brne	.+100    	; 0x11ee <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    118a:	ce 01       	movw	r24, r28
    118c:	01 96       	adiw	r24, 0x01	; 1
    118e:	0e 94 4c 18 	call	0x3098	; 0x3098 <_ZN10time_stamp10set_to_nowEv>
    1192:	bc 01       	movw	r22, r24
    1194:	f8 01       	movw	r30, r16
    1196:	86 81       	ldd	r24, Z+6	; 0x06
    1198:	97 81       	ldd	r25, Z+7	; 0x07
    119a:	0e 94 f0 17 	call	0x2fe0	; 0x2fe0 <_ZlsR8emstreamR10time_stamp>
    119e:	66 e0       	ldi	r22, 0x06	; 6
    11a0:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
							break;
    11a4:	5e c0       	rjmp	.+188    	; 0x1262 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    11a6:	c8 01       	movw	r24, r16
    11a8:	0e 94 8c 07 	call	0xf18	; 0xf18 <_ZN9task_user11show_statusEv>
							break;
    11ac:	5a c0       	rjmp	.+180    	; 0x1262 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    11ae:	d8 01       	movw	r26, r16
    11b0:	16 96       	adiw	r26, 0x06	; 6
    11b2:	8d 91       	ld	r24, X+
    11b4:	9c 91       	ld	r25, X
    11b6:	17 97       	sbiw	r26, 0x07	; 7
    11b8:	0e 94 b0 15 	call	0x2b60	; 0x2b60 <_Z17print_task_stacksP8emstream>
							break;
    11bc:	52 c0       	rjmp	.+164    	; 0x1262 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    11be:	c8 01       	movw	r24, r16
    11c0:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <_ZN9task_user18print_help_messageEv>
							break;
    11c4:	4e c0       	rjmp	.+156    	; 0x1262 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    11c6:	6a e0       	ldi	r22, 0x0A	; 10
    11c8:	f8 01       	movw	r30, r16
    11ca:	86 81       	ldd	r24, Z+6	; 0x06
    11cc:	97 81       	ldd	r25, Z+7	; 0x07
    11ce:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    11d2:	7c 01       	movw	r14, r24
    11d4:	62 e1       	ldi	r22, 0x12	; 18
    11d6:	74 e0       	ldi	r23, 0x04	; 4
    11d8:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    11dc:	66 e0       	ldi	r22, 0x06	; 6
    11de:	c7 01       	movw	r24, r14
    11e0:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11e4:	60 e0       	ldi	r22, 0x00	; 0
    11e6:	c8 01       	movw	r24, r16
    11e8:	0e 94 97 14 	call	0x292e	; 0x292e <_ZN8frt_task13transition_toEh>
							break;
    11ec:	3a c0       	rjmp	.+116    	; 0x1262 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11ee:	f8 01       	movw	r30, r16
    11f0:	a6 81       	ldd	r26, Z+6	; 0x06
    11f2:	b7 81       	ldd	r27, Z+7	; 0x07
    11f4:	ed 91       	ld	r30, X+
    11f6:	fc 91       	ld	r31, X
    11f8:	11 97       	sbiw	r26, 0x01	; 1
    11fa:	02 80       	ldd	r0, Z+2	; 0x02
    11fc:	f3 81       	ldd	r31, Z+3	; 0x03
    11fe:	e0 2d       	mov	r30, r0
    1200:	68 2f       	mov	r22, r24
    1202:	cd 01       	movw	r24, r26
    1204:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1206:	6a e0       	ldi	r22, 0x0A	; 10
    1208:	d8 01       	movw	r26, r16
    120a:	16 96       	adiw	r26, 0x06	; 6
    120c:	8d 91       	ld	r24, X+
    120e:	9c 91       	ld	r25, X
    1210:	17 97       	sbiw	r26, 0x07	; 7
    1212:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    1216:	7c 01       	movw	r14, r24
    1218:	6c e0       	ldi	r22, 0x0C	; 12
    121a:	74 e0       	ldi	r23, 0x04	; 4
    121c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    1220:	66 e0       	ldi	r22, 0x06	; 6
    1222:	c7 01       	movw	r24, r14
    1224:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
							break;
    1228:	1c c0       	rjmp	.+56     	; 0x1262 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    122a:	6a e0       	ldi	r22, 0x0A	; 10
    122c:	f8 01       	movw	r30, r16
    122e:	86 81       	ldd	r24, Z+6	; 0x06
    1230:	97 81       	ldd	r25, Z+7	; 0x07
    1232:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    1236:	8c 01       	movw	r16, r24
    1238:	6f ee       	ldi	r22, 0xEF	; 239
    123a:	73 e0       	ldi	r23, 0x03	; 3
    123c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    1240:	66 e0       	ldi	r22, 0x06	; 6
    1242:	c8 01       	movw	r24, r16
    1244:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1248:	93 e0       	ldi	r25, 0x03	; 3
    124a:	88 ed       	ldi	r24, 0xD8	; 216
    124c:	08 b6       	in	r0, 0x38	; 56
    124e:	18 be       	out	0x38, r1	; 56
    1250:	84 bf       	out	0x34, r24	; 52
    1252:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1256:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    125a:	81 fd       	sbrc	r24, 1
    125c:	fc cf       	rjmp	.-8      	; 0x1256 <_ZN9task_user3runEv+0x228>
    125e:	08 be       	out	0x38, r0	; 56
    1260:	ff cf       	rjmp	.-2      	; 0x1260 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1262:	f8 01       	movw	r30, r16
    1264:	86 85       	ldd	r24, Z+14	; 0x0e
    1266:	97 85       	ldd	r25, Z+15	; 0x0f
    1268:	a0 89       	ldd	r26, Z+16	; 0x10
    126a:	b1 89       	ldd	r27, Z+17	; 0x11
    126c:	01 96       	adiw	r24, 0x01	; 1
    126e:	a1 1d       	adc	r26, r1
    1270:	b1 1d       	adc	r27, r1
    1272:	86 87       	std	Z+14, r24	; 0x0e
    1274:	97 87       	std	Z+15, r25	; 0x0f
    1276:	a0 8b       	std	Z+16, r26	; 0x10
    1278:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    127a:	61 e0       	ldi	r22, 0x01	; 1
    127c:	70 e0       	ldi	r23, 0x00	; 0
    127e:	80 e0       	ldi	r24, 0x00	; 0
    1280:	90 e0       	ldi	r25, 0x00	; 0
    1282:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1286:	f1 ce       	rjmp	.-542    	; 0x106a <_ZN9task_user3runEv+0x3c>

00001288 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1288:	0f 93       	push	r16
    128a:	1f 93       	push	r17
    128c:	cf 93       	push	r28
    128e:	df 93       	push	r29
    1290:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1292:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1296:	80 91 da 20 	lds	r24, 0x20DA	; 0x8020da <__data_end>
    129a:	81 11       	cpse	r24, r1
    129c:	1d c0       	rjmp	.+58     	; 0x12d8 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    129e:	af ed       	ldi	r26, 0xDF	; 223
    12a0:	b0 e2       	ldi	r27, 0x20	; 32
    12a2:	e3 ee       	ldi	r30, 0xE3	; 227
    12a4:	f0 e2       	ldi	r31, 0x20	; 32
    12a6:	ed 93       	st	X+, r30
    12a8:	fc 93       	st	X, r31
    12aa:	11 97       	sbiw	r26, 0x01	; 1
    12ac:	12 96       	adiw	r26, 0x02	; 2
    12ae:	1d 92       	st	X+, r1
    12b0:	1c 92       	st	X, r1
    12b2:	13 97       	sbiw	r26, 0x03	; 3
    12b4:	ab ed       	ldi	r26, 0xDB	; 219
    12b6:	b0 e2       	ldi	r27, 0x20	; 32
    12b8:	8f ef       	ldi	r24, 0xFF	; 255
    12ba:	9f e0       	ldi	r25, 0x0F	; 15
    12bc:	12 96       	adiw	r26, 0x02	; 2
    12be:	8d 93       	st	X+, r24
    12c0:	9c 93       	st	X, r25
    12c2:	13 97       	sbiw	r26, 0x03	; 3
    12c4:	1d 92       	st	X+, r1
    12c6:	1c 92       	st	X, r1
    12c8:	11 97       	sbiw	r26, 0x01	; 1
    12ca:	82 83       	std	Z+2, r24	; 0x02
    12cc:	93 83       	std	Z+3, r25	; 0x03
    12ce:	a0 83       	st	Z, r26
    12d0:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    12d2:	81 e0       	ldi	r24, 0x01	; 1
    12d4:	80 93 da 20 	sts	0x20DA, r24	; 0x8020da <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12d8:	20 97       	sbiw	r28, 0x00	; 0
    12da:	09 f4       	brne	.+2      	; 0x12de <pvPortMalloc+0x56>
    12dc:	5f c0       	rjmp	.+190    	; 0x139c <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12de:	9e 01       	movw	r18, r28
    12e0:	2b 5f       	subi	r18, 0xFB	; 251
    12e2:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    12e4:	24 96       	adiw	r28, 0x04	; 4
    12e6:	ce 3f       	cpi	r28, 0xFE	; 254
    12e8:	df 40       	sbci	r29, 0x0F	; 15
    12ea:	08 f0       	brcs	.+2      	; 0x12ee <pvPortMalloc+0x66>
    12ec:	5a c0       	rjmp	.+180    	; 0x13a2 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    12ee:	e0 91 df 20 	lds	r30, 0x20DF	; 0x8020df <xStart>
    12f2:	f0 91 e0 20 	lds	r31, 0x20E0	; 0x8020e0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    12f6:	af ed       	ldi	r26, 0xDF	; 223
    12f8:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12fa:	02 c0       	rjmp	.+4      	; 0x1300 <pvPortMalloc+0x78>
    12fc:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    12fe:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1300:	82 81       	ldd	r24, Z+2	; 0x02
    1302:	93 81       	ldd	r25, Z+3	; 0x03
    1304:	82 17       	cp	r24, r18
    1306:	93 07       	cpc	r25, r19
    1308:	20 f4       	brcc	.+8      	; 0x1312 <pvPortMalloc+0x8a>
    130a:	80 81       	ld	r24, Z
    130c:	91 81       	ldd	r25, Z+1	; 0x01
    130e:	00 97       	sbiw	r24, 0x00	; 0
    1310:	a9 f7       	brne	.-22     	; 0x12fc <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1312:	c0 e2       	ldi	r28, 0x20	; 32
    1314:	eb 3d       	cpi	r30, 0xDB	; 219
    1316:	fc 07       	cpc	r31, r28
    1318:	09 f4       	brne	.+2      	; 0x131c <pvPortMalloc+0x94>
    131a:	46 c0       	rjmp	.+140    	; 0x13a8 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    131c:	cd 91       	ld	r28, X+
    131e:	dc 91       	ld	r29, X
    1320:	11 97       	sbiw	r26, 0x01	; 1
    1322:	8e 01       	movw	r16, r28
    1324:	0b 5f       	subi	r16, 0xFB	; 251
    1326:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1328:	80 81       	ld	r24, Z
    132a:	91 81       	ldd	r25, Z+1	; 0x01
    132c:	8d 93       	st	X+, r24
    132e:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1330:	82 81       	ldd	r24, Z+2	; 0x02
    1332:	93 81       	ldd	r25, Z+3	; 0x03
    1334:	82 1b       	sub	r24, r18
    1336:	93 0b       	sbc	r25, r19
    1338:	8b 30       	cpi	r24, 0x0B	; 11
    133a:	91 05       	cpc	r25, r1
    133c:	10 f1       	brcs	.+68     	; 0x1382 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    133e:	bf 01       	movw	r22, r30
    1340:	62 0f       	add	r22, r18
    1342:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1344:	db 01       	movw	r26, r22
    1346:	12 96       	adiw	r26, 0x02	; 2
    1348:	8d 93       	st	X+, r24
    134a:	9c 93       	st	X, r25
    134c:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    134e:	22 83       	std	Z+2, r18	; 0x02
    1350:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1352:	12 96       	adiw	r26, 0x02	; 2
    1354:	4d 91       	ld	r20, X+
    1356:	5c 91       	ld	r21, X
    1358:	13 97       	sbiw	r26, 0x03	; 3
    135a:	8f ed       	ldi	r24, 0xDF	; 223
    135c:	90 e2       	ldi	r25, 0x20	; 32
    135e:	01 c0       	rjmp	.+2      	; 0x1362 <pvPortMalloc+0xda>
    1360:	cd 01       	movw	r24, r26
    1362:	ec 01       	movw	r28, r24
    1364:	a8 81       	ld	r26, Y
    1366:	b9 81       	ldd	r27, Y+1	; 0x01
    1368:	12 96       	adiw	r26, 0x02	; 2
    136a:	2d 91       	ld	r18, X+
    136c:	3c 91       	ld	r19, X
    136e:	13 97       	sbiw	r26, 0x03	; 3
    1370:	24 17       	cp	r18, r20
    1372:	35 07       	cpc	r19, r21
    1374:	a8 f3       	brcs	.-22     	; 0x1360 <pvPortMalloc+0xd8>
    1376:	eb 01       	movw	r28, r22
    1378:	a8 83       	st	Y, r26
    137a:	b9 83       	std	Y+1, r27	; 0x01
    137c:	dc 01       	movw	r26, r24
    137e:	6d 93       	st	X+, r22
    1380:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1382:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1386:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    138a:	22 81       	ldd	r18, Z+2	; 0x02
    138c:	33 81       	ldd	r19, Z+3	; 0x03
    138e:	82 1b       	sub	r24, r18
    1390:	93 0b       	sbc	r25, r19
    1392:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1396:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    139a:	08 c0       	rjmp	.+16     	; 0x13ac <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    139c:	00 e0       	ldi	r16, 0x00	; 0
    139e:	10 e0       	ldi	r17, 0x00	; 0
    13a0:	05 c0       	rjmp	.+10     	; 0x13ac <pvPortMalloc+0x124>
    13a2:	00 e0       	ldi	r16, 0x00	; 0
    13a4:	10 e0       	ldi	r17, 0x00	; 0
    13a6:	02 c0       	rjmp	.+4      	; 0x13ac <pvPortMalloc+0x124>
    13a8:	00 e0       	ldi	r16, 0x00	; 0
    13aa:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    13ac:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    13b0:	c8 01       	movw	r24, r16
    13b2:	df 91       	pop	r29
    13b4:	cf 91       	pop	r28
    13b6:	1f 91       	pop	r17
    13b8:	0f 91       	pop	r16
    13ba:	08 95       	ret

000013bc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    13bc:	0f 93       	push	r16
    13be:	1f 93       	push	r17
    13c0:	cf 93       	push	r28
    13c2:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    13c4:	00 97       	sbiw	r24, 0x00	; 0
    13c6:	41 f1       	breq	.+80     	; 0x1418 <vPortFree+0x5c>
    13c8:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    13ca:	8c 01       	movw	r16, r24
    13cc:	05 50       	subi	r16, 0x05	; 5
    13ce:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    13d0:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    13d4:	f8 01       	movw	r30, r16
    13d6:	42 81       	ldd	r20, Z+2	; 0x02
    13d8:	53 81       	ldd	r21, Z+3	; 0x03
    13da:	af ed       	ldi	r26, 0xDF	; 223
    13dc:	b0 e2       	ldi	r27, 0x20	; 32
    13de:	01 c0       	rjmp	.+2      	; 0x13e2 <vPortFree+0x26>
    13e0:	df 01       	movw	r26, r30
    13e2:	ed 91       	ld	r30, X+
    13e4:	fc 91       	ld	r31, X
    13e6:	11 97       	sbiw	r26, 0x01	; 1
    13e8:	22 81       	ldd	r18, Z+2	; 0x02
    13ea:	33 81       	ldd	r19, Z+3	; 0x03
    13ec:	24 17       	cp	r18, r20
    13ee:	35 07       	cpc	r19, r21
    13f0:	b8 f3       	brcs	.-18     	; 0x13e0 <vPortFree+0x24>
    13f2:	25 97       	sbiw	r28, 0x05	; 5
    13f4:	e8 83       	st	Y, r30
    13f6:	f9 83       	std	Y+1, r31	; 0x01
    13f8:	0d 93       	st	X+, r16
    13fa:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    13fc:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1400:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1404:	8a 81       	ldd	r24, Y+2	; 0x02
    1406:	9b 81       	ldd	r25, Y+3	; 0x03
    1408:	82 0f       	add	r24, r18
    140a:	93 1f       	adc	r25, r19
    140c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1410:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1414:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
	}
}
    1418:	df 91       	pop	r29
    141a:	cf 91       	pop	r28
    141c:	1f 91       	pop	r17
    141e:	0f 91       	pop	r16
    1420:	08 95       	ret

00001422 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1422:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1426:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    142a:	08 95       	ret

0000142c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    142c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    142e:	03 96       	adiw	r24, 0x03	; 3
    1430:	81 83       	std	Z+1, r24	; 0x01
    1432:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1434:	4f ef       	ldi	r20, 0xFF	; 255
    1436:	5f ef       	ldi	r21, 0xFF	; 255
    1438:	ba 01       	movw	r22, r20
    143a:	43 83       	std	Z+3, r20	; 0x03
    143c:	54 83       	std	Z+4, r21	; 0x04
    143e:	65 83       	std	Z+5, r22	; 0x05
    1440:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1442:	87 83       	std	Z+7, r24	; 0x07
    1444:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1446:	81 87       	std	Z+9, r24	; 0x09
    1448:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    144a:	10 82       	st	Z, r1
    144c:	08 95       	ret

0000144e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    144e:	fc 01       	movw	r30, r24
    1450:	12 86       	std	Z+10, r1	; 0x0a
    1452:	13 86       	std	Z+11, r1	; 0x0b
    1454:	08 95       	ret

00001456 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29
    145a:	fc 01       	movw	r30, r24
    145c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    145e:	21 81       	ldd	r18, Z+1	; 0x01
    1460:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1462:	e9 01       	movw	r28, r18
    1464:	8c 81       	ldd	r24, Y+4	; 0x04
    1466:	9d 81       	ldd	r25, Y+5	; 0x05
    1468:	14 96       	adiw	r26, 0x04	; 4
    146a:	8d 93       	st	X+, r24
    146c:	9c 93       	st	X, r25
    146e:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1470:	81 81       	ldd	r24, Z+1	; 0x01
    1472:	92 81       	ldd	r25, Z+2	; 0x02
    1474:	16 96       	adiw	r26, 0x06	; 6
    1476:	8d 93       	st	X+, r24
    1478:	9c 93       	st	X, r25
    147a:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    147c:	8c 81       	ldd	r24, Y+4	; 0x04
    147e:	9d 81       	ldd	r25, Y+5	; 0x05
    1480:	ec 01       	movw	r28, r24
    1482:	6e 83       	std	Y+6, r22	; 0x06
    1484:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1486:	e9 01       	movw	r28, r18
    1488:	6c 83       	std	Y+4, r22	; 0x04
    148a:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    148c:	61 83       	std	Z+1, r22	; 0x01
    148e:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1490:	1a 96       	adiw	r26, 0x0a	; 10
    1492:	ed 93       	st	X+, r30
    1494:	fc 93       	st	X, r31
    1496:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1498:	80 81       	ld	r24, Z
    149a:	8f 5f       	subi	r24, 0xFF	; 255
    149c:	80 83       	st	Z, r24
}
    149e:	df 91       	pop	r29
    14a0:	cf 91       	pop	r28
    14a2:	08 95       	ret

000014a4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    14a4:	0f 93       	push	r16
    14a6:	1f 93       	push	r17
    14a8:	cf 93       	push	r28
    14aa:	df 93       	push	r29
    14ac:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    14ae:	08 81       	ld	r16, Y
    14b0:	19 81       	ldd	r17, Y+1	; 0x01
    14b2:	2a 81       	ldd	r18, Y+2	; 0x02
    14b4:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14b6:	0f 3f       	cpi	r16, 0xFF	; 255
    14b8:	4f ef       	ldi	r20, 0xFF	; 255
    14ba:	14 07       	cpc	r17, r20
    14bc:	24 07       	cpc	r18, r20
    14be:	34 07       	cpc	r19, r20
    14c0:	31 f4       	brne	.+12     	; 0x14ce <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14c2:	dc 01       	movw	r26, r24
    14c4:	19 96       	adiw	r26, 0x09	; 9
    14c6:	ed 91       	ld	r30, X+
    14c8:	fc 91       	ld	r31, X
    14ca:	1a 97       	sbiw	r26, 0x0a	; 10
    14cc:	1f c0       	rjmp	.+62     	; 0x150c <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14ce:	fc 01       	movw	r30, r24
    14d0:	33 96       	adiw	r30, 0x03	; 3
    14d2:	dc 01       	movw	r26, r24
    14d4:	17 96       	adiw	r26, 0x07	; 7
    14d6:	4d 91       	ld	r20, X+
    14d8:	5c 91       	ld	r21, X
    14da:	18 97       	sbiw	r26, 0x08	; 8
    14dc:	da 01       	movw	r26, r20
    14de:	4d 91       	ld	r20, X+
    14e0:	5d 91       	ld	r21, X+
    14e2:	6d 91       	ld	r22, X+
    14e4:	7c 91       	ld	r23, X
    14e6:	04 17       	cp	r16, r20
    14e8:	15 07       	cpc	r17, r21
    14ea:	26 07       	cpc	r18, r22
    14ec:	37 07       	cpc	r19, r23
    14ee:	70 f0       	brcs	.+28     	; 0x150c <vListInsert+0x68>
    14f0:	04 80       	ldd	r0, Z+4	; 0x04
    14f2:	f5 81       	ldd	r31, Z+5	; 0x05
    14f4:	e0 2d       	mov	r30, r0
    14f6:	a4 81       	ldd	r26, Z+4	; 0x04
    14f8:	b5 81       	ldd	r27, Z+5	; 0x05
    14fa:	4d 91       	ld	r20, X+
    14fc:	5d 91       	ld	r21, X+
    14fe:	6d 91       	ld	r22, X+
    1500:	7c 91       	ld	r23, X
    1502:	04 17       	cp	r16, r20
    1504:	15 07       	cpc	r17, r21
    1506:	26 07       	cpc	r18, r22
    1508:	37 07       	cpc	r19, r23
    150a:	90 f7       	brcc	.-28     	; 0x14f0 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    150c:	a4 81       	ldd	r26, Z+4	; 0x04
    150e:	b5 81       	ldd	r27, Z+5	; 0x05
    1510:	ac 83       	std	Y+4, r26	; 0x04
    1512:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1514:	16 96       	adiw	r26, 0x06	; 6
    1516:	cd 93       	st	X+, r28
    1518:	dc 93       	st	X, r29
    151a:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    151c:	ee 83       	std	Y+6, r30	; 0x06
    151e:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1520:	c4 83       	std	Z+4, r28	; 0x04
    1522:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1524:	8a 87       	std	Y+10, r24	; 0x0a
    1526:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1528:	fc 01       	movw	r30, r24
    152a:	20 81       	ld	r18, Z
    152c:	2f 5f       	subi	r18, 0xFF	; 255
    152e:	20 83       	st	Z, r18
}
    1530:	df 91       	pop	r29
    1532:	cf 91       	pop	r28
    1534:	1f 91       	pop	r17
    1536:	0f 91       	pop	r16
    1538:	08 95       	ret

0000153a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    153a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    153c:	a4 81       	ldd	r26, Z+4	; 0x04
    153e:	b5 81       	ldd	r27, Z+5	; 0x05
    1540:	86 81       	ldd	r24, Z+6	; 0x06
    1542:	97 81       	ldd	r25, Z+7	; 0x07
    1544:	16 96       	adiw	r26, 0x06	; 6
    1546:	8d 93       	st	X+, r24
    1548:	9c 93       	st	X, r25
    154a:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    154c:	a6 81       	ldd	r26, Z+6	; 0x06
    154e:	b7 81       	ldd	r27, Z+7	; 0x07
    1550:	84 81       	ldd	r24, Z+4	; 0x04
    1552:	95 81       	ldd	r25, Z+5	; 0x05
    1554:	14 96       	adiw	r26, 0x04	; 4
    1556:	8d 93       	st	X+, r24
    1558:	9c 93       	st	X, r25
    155a:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    155c:	a2 85       	ldd	r26, Z+10	; 0x0a
    155e:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1560:	11 96       	adiw	r26, 0x01	; 1
    1562:	8d 91       	ld	r24, X+
    1564:	9c 91       	ld	r25, X
    1566:	12 97       	sbiw	r26, 0x02	; 2
    1568:	e8 17       	cp	r30, r24
    156a:	f9 07       	cpc	r31, r25
    156c:	31 f4       	brne	.+12     	; 0x157a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    156e:	86 81       	ldd	r24, Z+6	; 0x06
    1570:	97 81       	ldd	r25, Z+7	; 0x07
    1572:	11 96       	adiw	r26, 0x01	; 1
    1574:	8d 93       	st	X+, r24
    1576:	9c 93       	st	X, r25
    1578:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    157a:	12 86       	std	Z+10, r1	; 0x0a
    157c:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    157e:	8c 91       	ld	r24, X
    1580:	81 50       	subi	r24, 0x01	; 1
    1582:	8c 93       	st	X, r24
    1584:	08 95       	ret

00001586 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1586:	80 93 86 31 	sts	0x3186, r24	; 0x803186 <portStackTopForTask>
    158a:	90 93 87 31 	sts	0x3187, r25	; 0x803187 <portStackTopForTask+0x1>
    158e:	31 e1       	ldi	r19, 0x11	; 17
    1590:	fc 01       	movw	r30, r24
    1592:	30 83       	st	Z, r19
    1594:	31 97       	sbiw	r30, 0x01	; 1
    1596:	22 e2       	ldi	r18, 0x22	; 34
    1598:	20 83       	st	Z, r18
    159a:	31 97       	sbiw	r30, 0x01	; 1
    159c:	a3 e3       	ldi	r26, 0x33	; 51
    159e:	a0 83       	st	Z, r26
    15a0:	31 97       	sbiw	r30, 0x01	; 1
    15a2:	60 83       	st	Z, r22
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	70 83       	st	Z, r23
    15a8:	31 97       	sbiw	r30, 0x01	; 1
    15aa:	10 82       	st	Z, r1
    15ac:	31 97       	sbiw	r30, 0x01	; 1
    15ae:	10 82       	st	Z, r1
    15b0:	31 97       	sbiw	r30, 0x01	; 1
    15b2:	60 e8       	ldi	r22, 0x80	; 128
    15b4:	60 83       	st	Z, r22
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	10 82       	st	Z, r1
    15ba:	31 97       	sbiw	r30, 0x01	; 1
    15bc:	10 82       	st	Z, r1
    15be:	31 97       	sbiw	r30, 0x01	; 1
    15c0:	10 82       	st	Z, r1
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	62 e0       	ldi	r22, 0x02	; 2
    15c6:	60 83       	st	Z, r22
    15c8:	31 97       	sbiw	r30, 0x01	; 1
    15ca:	63 e0       	ldi	r22, 0x03	; 3
    15cc:	60 83       	st	Z, r22
    15ce:	31 97       	sbiw	r30, 0x01	; 1
    15d0:	64 e0       	ldi	r22, 0x04	; 4
    15d2:	60 83       	st	Z, r22
    15d4:	31 97       	sbiw	r30, 0x01	; 1
    15d6:	65 e0       	ldi	r22, 0x05	; 5
    15d8:	60 83       	st	Z, r22
    15da:	31 97       	sbiw	r30, 0x01	; 1
    15dc:	66 e0       	ldi	r22, 0x06	; 6
    15de:	60 83       	st	Z, r22
    15e0:	31 97       	sbiw	r30, 0x01	; 1
    15e2:	67 e0       	ldi	r22, 0x07	; 7
    15e4:	60 83       	st	Z, r22
    15e6:	31 97       	sbiw	r30, 0x01	; 1
    15e8:	68 e0       	ldi	r22, 0x08	; 8
    15ea:	60 83       	st	Z, r22
    15ec:	31 97       	sbiw	r30, 0x01	; 1
    15ee:	69 e0       	ldi	r22, 0x09	; 9
    15f0:	60 83       	st	Z, r22
    15f2:	31 97       	sbiw	r30, 0x01	; 1
    15f4:	60 e1       	ldi	r22, 0x10	; 16
    15f6:	60 83       	st	Z, r22
    15f8:	31 97       	sbiw	r30, 0x01	; 1
    15fa:	30 83       	st	Z, r19
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	32 e1       	ldi	r19, 0x12	; 18
    1600:	30 83       	st	Z, r19
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	33 e1       	ldi	r19, 0x13	; 19
    1606:	30 83       	st	Z, r19
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	34 e1       	ldi	r19, 0x14	; 20
    160c:	30 83       	st	Z, r19
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	35 e1       	ldi	r19, 0x15	; 21
    1612:	30 83       	st	Z, r19
    1614:	31 97       	sbiw	r30, 0x01	; 1
    1616:	36 e1       	ldi	r19, 0x16	; 22
    1618:	30 83       	st	Z, r19
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	37 e1       	ldi	r19, 0x17	; 23
    161e:	30 83       	st	Z, r19
    1620:	31 97       	sbiw	r30, 0x01	; 1
    1622:	38 e1       	ldi	r19, 0x18	; 24
    1624:	30 83       	st	Z, r19
    1626:	31 97       	sbiw	r30, 0x01	; 1
    1628:	39 e1       	ldi	r19, 0x19	; 25
    162a:	30 83       	st	Z, r19
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	30 e2       	ldi	r19, 0x20	; 32
    1630:	30 83       	st	Z, r19
    1632:	31 97       	sbiw	r30, 0x01	; 1
    1634:	31 e2       	ldi	r19, 0x21	; 33
    1636:	30 83       	st	Z, r19
    1638:	31 97       	sbiw	r30, 0x01	; 1
    163a:	20 83       	st	Z, r18
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	23 e2       	ldi	r18, 0x23	; 35
    1640:	20 83       	st	Z, r18
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	40 83       	st	Z, r20
    1646:	31 97       	sbiw	r30, 0x01	; 1
    1648:	50 83       	st	Z, r21
    164a:	31 97       	sbiw	r30, 0x01	; 1
    164c:	26 e2       	ldi	r18, 0x26	; 38
    164e:	20 83       	st	Z, r18
    1650:	31 97       	sbiw	r30, 0x01	; 1
    1652:	27 e2       	ldi	r18, 0x27	; 39
    1654:	20 83       	st	Z, r18
    1656:	31 97       	sbiw	r30, 0x01	; 1
    1658:	28 e2       	ldi	r18, 0x28	; 40
    165a:	20 83       	st	Z, r18
    165c:	31 97       	sbiw	r30, 0x01	; 1
    165e:	29 e2       	ldi	r18, 0x29	; 41
    1660:	20 83       	st	Z, r18
    1662:	31 97       	sbiw	r30, 0x01	; 1
    1664:	20 e3       	ldi	r18, 0x30	; 48
    1666:	20 83       	st	Z, r18
    1668:	31 97       	sbiw	r30, 0x01	; 1
    166a:	21 e3       	ldi	r18, 0x31	; 49
    166c:	20 83       	st	Z, r18
    166e:	89 97       	sbiw	r24, 0x29	; 41
    1670:	08 95       	ret

00001672 <xPortStartScheduler>:
    1672:	8c e7       	ldi	r24, 0x7C	; 124
    1674:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
    1678:	8f ef       	ldi	r24, 0xFF	; 255
    167a:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
    167e:	81 e0       	ldi	r24, 0x01	; 1
    1680:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    1684:	81 e1       	ldi	r24, 0x11	; 17
    1686:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    168a:	83 e0       	ldi	r24, 0x03	; 3
    168c:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
    1690:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    1694:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1698:	cd 91       	ld	r28, X+
    169a:	cd bf       	out	0x3d, r28	; 61
    169c:	dd 91       	ld	r29, X+
    169e:	de bf       	out	0x3e, r29	; 62
    16a0:	ff 91       	pop	r31
    16a2:	ef 91       	pop	r30
    16a4:	df 91       	pop	r29
    16a6:	cf 91       	pop	r28
    16a8:	bf 91       	pop	r27
    16aa:	af 91       	pop	r26
    16ac:	9f 91       	pop	r25
    16ae:	8f 91       	pop	r24
    16b0:	7f 91       	pop	r23
    16b2:	6f 91       	pop	r22
    16b4:	5f 91       	pop	r21
    16b6:	4f 91       	pop	r20
    16b8:	3f 91       	pop	r19
    16ba:	2f 91       	pop	r18
    16bc:	1f 91       	pop	r17
    16be:	0f 91       	pop	r16
    16c0:	ff 90       	pop	r15
    16c2:	ef 90       	pop	r14
    16c4:	df 90       	pop	r13
    16c6:	cf 90       	pop	r12
    16c8:	bf 90       	pop	r11
    16ca:	af 90       	pop	r10
    16cc:	9f 90       	pop	r9
    16ce:	8f 90       	pop	r8
    16d0:	7f 90       	pop	r7
    16d2:	6f 90       	pop	r6
    16d4:	5f 90       	pop	r5
    16d6:	4f 90       	pop	r4
    16d8:	3f 90       	pop	r3
    16da:	2f 90       	pop	r2
    16dc:	1f 90       	pop	r1
    16de:	0f 90       	pop	r0
    16e0:	0c be       	out	0x3c, r0	; 60
    16e2:	0f 90       	pop	r0
    16e4:	0b be       	out	0x3b, r0	; 59
    16e6:	0f 90       	pop	r0
    16e8:	0f be       	out	0x3f, r0	; 63
    16ea:	0f 90       	pop	r0
    16ec:	08 95       	ret
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	08 95       	ret

000016f2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16f2:	0f 92       	push	r0
    16f4:	0f b6       	in	r0, 0x3f	; 63
    16f6:	f8 94       	cli
    16f8:	0f 92       	push	r0
    16fa:	0b b6       	in	r0, 0x3b	; 59
    16fc:	0f 92       	push	r0
    16fe:	0c b6       	in	r0, 0x3c	; 60
    1700:	0f 92       	push	r0
    1702:	1f 92       	push	r1
    1704:	11 24       	eor	r1, r1
    1706:	2f 92       	push	r2
    1708:	3f 92       	push	r3
    170a:	4f 92       	push	r4
    170c:	5f 92       	push	r5
    170e:	6f 92       	push	r6
    1710:	7f 92       	push	r7
    1712:	8f 92       	push	r8
    1714:	9f 92       	push	r9
    1716:	af 92       	push	r10
    1718:	bf 92       	push	r11
    171a:	cf 92       	push	r12
    171c:	df 92       	push	r13
    171e:	ef 92       	push	r14
    1720:	ff 92       	push	r15
    1722:	0f 93       	push	r16
    1724:	1f 93       	push	r17
    1726:	2f 93       	push	r18
    1728:	3f 93       	push	r19
    172a:	4f 93       	push	r20
    172c:	5f 93       	push	r21
    172e:	6f 93       	push	r22
    1730:	7f 93       	push	r23
    1732:	8f 93       	push	r24
    1734:	9f 93       	push	r25
    1736:	af 93       	push	r26
    1738:	bf 93       	push	r27
    173a:	cf 93       	push	r28
    173c:	df 93       	push	r29
    173e:	ef 93       	push	r30
    1740:	ff 93       	push	r31
    1742:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    1746:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    174a:	0d b6       	in	r0, 0x3d	; 61
    174c:	0d 92       	st	X+, r0
    174e:	0e b6       	in	r0, 0x3e	; 62
    1750:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1752:	0e 94 99 12 	call	0x2532	; 0x2532 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1756:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    175a:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    175e:	cd 91       	ld	r28, X+
    1760:	cd bf       	out	0x3d, r28	; 61
    1762:	dd 91       	ld	r29, X+
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	ff 91       	pop	r31
    1768:	ef 91       	pop	r30
    176a:	df 91       	pop	r29
    176c:	cf 91       	pop	r28
    176e:	bf 91       	pop	r27
    1770:	af 91       	pop	r26
    1772:	9f 91       	pop	r25
    1774:	8f 91       	pop	r24
    1776:	7f 91       	pop	r23
    1778:	6f 91       	pop	r22
    177a:	5f 91       	pop	r21
    177c:	4f 91       	pop	r20
    177e:	3f 91       	pop	r19
    1780:	2f 91       	pop	r18
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	ff 90       	pop	r15
    1788:	ef 90       	pop	r14
    178a:	df 90       	pop	r13
    178c:	cf 90       	pop	r12
    178e:	bf 90       	pop	r11
    1790:	af 90       	pop	r10
    1792:	9f 90       	pop	r9
    1794:	8f 90       	pop	r8
    1796:	7f 90       	pop	r7
    1798:	6f 90       	pop	r6
    179a:	5f 90       	pop	r5
    179c:	4f 90       	pop	r4
    179e:	3f 90       	pop	r3
    17a0:	2f 90       	pop	r2
    17a2:	1f 90       	pop	r1
    17a4:	0f 90       	pop	r0
    17a6:	0c be       	out	0x3c, r0	; 60
    17a8:	0f 90       	pop	r0
    17aa:	0b be       	out	0x3b, r0	; 59
    17ac:	0f 90       	pop	r0
    17ae:	0f be       	out	0x3f, r0	; 63
    17b0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17b2:	08 95       	ret

000017b4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17b4:	0f 92       	push	r0
    17b6:	0f b6       	in	r0, 0x3f	; 63
    17b8:	f8 94       	cli
    17ba:	0f 92       	push	r0
    17bc:	0b b6       	in	r0, 0x3b	; 59
    17be:	0f 92       	push	r0
    17c0:	0c b6       	in	r0, 0x3c	; 60
    17c2:	0f 92       	push	r0
    17c4:	1f 92       	push	r1
    17c6:	11 24       	eor	r1, r1
    17c8:	2f 92       	push	r2
    17ca:	3f 92       	push	r3
    17cc:	4f 92       	push	r4
    17ce:	5f 92       	push	r5
    17d0:	6f 92       	push	r6
    17d2:	7f 92       	push	r7
    17d4:	8f 92       	push	r8
    17d6:	9f 92       	push	r9
    17d8:	af 92       	push	r10
    17da:	bf 92       	push	r11
    17dc:	cf 92       	push	r12
    17de:	df 92       	push	r13
    17e0:	ef 92       	push	r14
    17e2:	ff 92       	push	r15
    17e4:	0f 93       	push	r16
    17e6:	1f 93       	push	r17
    17e8:	2f 93       	push	r18
    17ea:	3f 93       	push	r19
    17ec:	4f 93       	push	r20
    17ee:	5f 93       	push	r21
    17f0:	6f 93       	push	r22
    17f2:	7f 93       	push	r23
    17f4:	8f 93       	push	r24
    17f6:	9f 93       	push	r25
    17f8:	af 93       	push	r26
    17fa:	bf 93       	push	r27
    17fc:	cf 93       	push	r28
    17fe:	df 93       	push	r29
    1800:	ef 93       	push	r30
    1802:	ff 93       	push	r31
    1804:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    1808:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    180c:	0d b6       	in	r0, 0x3d	; 61
    180e:	0d 92       	st	X+, r0
    1810:	0e b6       	in	r0, 0x3e	; 62
    1812:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1814:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <vTaskIncrementTick>
	vTaskSwitchContext();
    1818:	0e 94 99 12 	call	0x2532	; 0x2532 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    181c:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    1820:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1824:	cd 91       	ld	r28, X+
    1826:	cd bf       	out	0x3d, r28	; 61
    1828:	dd 91       	ld	r29, X+
    182a:	de bf       	out	0x3e, r29	; 62
    182c:	ff 91       	pop	r31
    182e:	ef 91       	pop	r30
    1830:	df 91       	pop	r29
    1832:	cf 91       	pop	r28
    1834:	bf 91       	pop	r27
    1836:	af 91       	pop	r26
    1838:	9f 91       	pop	r25
    183a:	8f 91       	pop	r24
    183c:	7f 91       	pop	r23
    183e:	6f 91       	pop	r22
    1840:	5f 91       	pop	r21
    1842:	4f 91       	pop	r20
    1844:	3f 91       	pop	r19
    1846:	2f 91       	pop	r18
    1848:	1f 91       	pop	r17
    184a:	0f 91       	pop	r16
    184c:	ff 90       	pop	r15
    184e:	ef 90       	pop	r14
    1850:	df 90       	pop	r13
    1852:	cf 90       	pop	r12
    1854:	bf 90       	pop	r11
    1856:	af 90       	pop	r10
    1858:	9f 90       	pop	r9
    185a:	8f 90       	pop	r8
    185c:	7f 90       	pop	r7
    185e:	6f 90       	pop	r6
    1860:	5f 90       	pop	r5
    1862:	4f 90       	pop	r4
    1864:	3f 90       	pop	r3
    1866:	2f 90       	pop	r2
    1868:	1f 90       	pop	r1
    186a:	0f 90       	pop	r0
    186c:	0c be       	out	0x3c, r0	; 60
    186e:	0f 90       	pop	r0
    1870:	0b be       	out	0x3b, r0	; 59
    1872:	0f 90       	pop	r0
    1874:	0f be       	out	0x3f, r0	; 63
    1876:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1878:	08 95       	ret

0000187a <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    187a:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    187e:	18 95       	reti

00001880 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1880:	cf 93       	push	r28
    1882:	df 93       	push	r29
    1884:	ec 01       	movw	r28, r24
    1886:	88 a1       	ldd	r24, Y+32	; 0x20
    1888:	81 11       	cpse	r24, r1
    188a:	0b c0       	rjmp	.+22     	; 0x18a2 <prvCopyDataToQueue+0x22>
    188c:	88 81       	ld	r24, Y
    188e:	99 81       	ldd	r25, Y+1	; 0x01
    1890:	89 2b       	or	r24, r25
    1892:	e1 f5       	brne	.+120    	; 0x190c <prvCopyDataToQueue+0x8c>
    1894:	8a 81       	ldd	r24, Y+2	; 0x02
    1896:	9b 81       	ldd	r25, Y+3	; 0x03
    1898:	0e 94 54 14 	call	0x28a8	; 0x28a8 <vTaskPriorityDisinherit>
    189c:	1a 82       	std	Y+2, r1	; 0x02
    189e:	1b 82       	std	Y+3, r1	; 0x03
    18a0:	35 c0       	rjmp	.+106    	; 0x190c <prvCopyDataToQueue+0x8c>
    18a2:	41 11       	cpse	r20, r1
    18a4:	17 c0       	rjmp	.+46     	; 0x18d4 <prvCopyDataToQueue+0x54>
    18a6:	48 2f       	mov	r20, r24
    18a8:	50 e0       	ldi	r21, 0x00	; 0
    18aa:	8c 81       	ldd	r24, Y+4	; 0x04
    18ac:	9d 81       	ldd	r25, Y+5	; 0x05
    18ae:	0e 94 99 22 	call	0x4532	; 0x4532 <memcpy>
    18b2:	28 a1       	ldd	r18, Y+32	; 0x20
    18b4:	8c 81       	ldd	r24, Y+4	; 0x04
    18b6:	9d 81       	ldd	r25, Y+5	; 0x05
    18b8:	82 0f       	add	r24, r18
    18ba:	91 1d       	adc	r25, r1
    18bc:	8c 83       	std	Y+4, r24	; 0x04
    18be:	9d 83       	std	Y+5, r25	; 0x05
    18c0:	2a 81       	ldd	r18, Y+2	; 0x02
    18c2:	3b 81       	ldd	r19, Y+3	; 0x03
    18c4:	82 17       	cp	r24, r18
    18c6:	93 07       	cpc	r25, r19
    18c8:	08 f1       	brcs	.+66     	; 0x190c <prvCopyDataToQueue+0x8c>
    18ca:	88 81       	ld	r24, Y
    18cc:	99 81       	ldd	r25, Y+1	; 0x01
    18ce:	8c 83       	std	Y+4, r24	; 0x04
    18d0:	9d 83       	std	Y+5, r25	; 0x05
    18d2:	1c c0       	rjmp	.+56     	; 0x190c <prvCopyDataToQueue+0x8c>
    18d4:	48 2f       	mov	r20, r24
    18d6:	50 e0       	ldi	r21, 0x00	; 0
    18d8:	8e 81       	ldd	r24, Y+6	; 0x06
    18da:	9f 81       	ldd	r25, Y+7	; 0x07
    18dc:	0e 94 99 22 	call	0x4532	; 0x4532 <memcpy>
    18e0:	88 a1       	ldd	r24, Y+32	; 0x20
    18e2:	90 e0       	ldi	r25, 0x00	; 0
    18e4:	91 95       	neg	r25
    18e6:	81 95       	neg	r24
    18e8:	91 09       	sbc	r25, r1
    18ea:	2e 81       	ldd	r18, Y+6	; 0x06
    18ec:	3f 81       	ldd	r19, Y+7	; 0x07
    18ee:	28 0f       	add	r18, r24
    18f0:	39 1f       	adc	r19, r25
    18f2:	2e 83       	std	Y+6, r18	; 0x06
    18f4:	3f 83       	std	Y+7, r19	; 0x07
    18f6:	48 81       	ld	r20, Y
    18f8:	59 81       	ldd	r21, Y+1	; 0x01
    18fa:	24 17       	cp	r18, r20
    18fc:	35 07       	cpc	r19, r21
    18fe:	30 f4       	brcc	.+12     	; 0x190c <prvCopyDataToQueue+0x8c>
    1900:	2a 81       	ldd	r18, Y+2	; 0x02
    1902:	3b 81       	ldd	r19, Y+3	; 0x03
    1904:	82 0f       	add	r24, r18
    1906:	93 1f       	adc	r25, r19
    1908:	8e 83       	std	Y+6, r24	; 0x06
    190a:	9f 83       	std	Y+7, r25	; 0x07
    190c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    190e:	8f 5f       	subi	r24, 0xFF	; 255
    1910:	8e 8f       	std	Y+30, r24	; 0x1e
    1912:	df 91       	pop	r29
    1914:	cf 91       	pop	r28
    1916:	08 95       	ret

00001918 <prvCopyDataFromQueue>:
    1918:	fc 01       	movw	r30, r24
    191a:	80 81       	ld	r24, Z
    191c:	91 81       	ldd	r25, Z+1	; 0x01
    191e:	00 97       	sbiw	r24, 0x00	; 0
    1920:	a1 f0       	breq	.+40     	; 0x194a <prvCopyDataFromQueue+0x32>
    1922:	40 a1       	ldd	r20, Z+32	; 0x20
    1924:	50 e0       	ldi	r21, 0x00	; 0
    1926:	26 81       	ldd	r18, Z+6	; 0x06
    1928:	37 81       	ldd	r19, Z+7	; 0x07
    192a:	24 0f       	add	r18, r20
    192c:	35 1f       	adc	r19, r21
    192e:	26 83       	std	Z+6, r18	; 0x06
    1930:	37 83       	std	Z+7, r19	; 0x07
    1932:	a2 81       	ldd	r26, Z+2	; 0x02
    1934:	b3 81       	ldd	r27, Z+3	; 0x03
    1936:	2a 17       	cp	r18, r26
    1938:	3b 07       	cpc	r19, r27
    193a:	10 f0       	brcs	.+4      	; 0x1940 <prvCopyDataFromQueue+0x28>
    193c:	86 83       	std	Z+6, r24	; 0x06
    193e:	97 83       	std	Z+7, r25	; 0x07
    1940:	cb 01       	movw	r24, r22
    1942:	66 81       	ldd	r22, Z+6	; 0x06
    1944:	77 81       	ldd	r23, Z+7	; 0x07
    1946:	0e 94 99 22 	call	0x4532	; 0x4532 <memcpy>
    194a:	08 95       	ret

0000194c <prvUnlockQueue>:
    194c:	0f 93       	push	r16
    194e:	1f 93       	push	r17
    1950:	cf 93       	push	r28
    1952:	df 93       	push	r29
    1954:	ec 01       	movw	r28, r24
    1956:	0f b6       	in	r0, 0x3f	; 63
    1958:	f8 94       	cli
    195a:	0f 92       	push	r0
    195c:	8a a1       	ldd	r24, Y+34	; 0x22
    195e:	18 16       	cp	r1, r24
    1960:	b4 f4       	brge	.+44     	; 0x198e <prvUnlockQueue+0x42>
    1962:	8b 89       	ldd	r24, Y+19	; 0x13
    1964:	81 11       	cpse	r24, r1
    1966:	05 c0       	rjmp	.+10     	; 0x1972 <prvUnlockQueue+0x26>
    1968:	12 c0       	rjmp	.+36     	; 0x198e <prvUnlockQueue+0x42>
    196a:	8b 89       	ldd	r24, Y+19	; 0x13
    196c:	81 11       	cpse	r24, r1
    196e:	04 c0       	rjmp	.+8      	; 0x1978 <prvUnlockQueue+0x2c>
    1970:	0e c0       	rjmp	.+28     	; 0x198e <prvUnlockQueue+0x42>
    1972:	8e 01       	movw	r16, r28
    1974:	0d 5e       	subi	r16, 0xED	; 237
    1976:	1f 4f       	sbci	r17, 0xFF	; 255
    1978:	c8 01       	movw	r24, r16
    197a:	0e 94 20 13 	call	0x2640	; 0x2640 <xTaskRemoveFromEventList>
    197e:	81 11       	cpse	r24, r1
    1980:	0e 94 dd 13 	call	0x27ba	; 0x27ba <vTaskMissedYield>
    1984:	8a a1       	ldd	r24, Y+34	; 0x22
    1986:	81 50       	subi	r24, 0x01	; 1
    1988:	8a a3       	std	Y+34, r24	; 0x22
    198a:	18 16       	cp	r1, r24
    198c:	74 f3       	brlt	.-36     	; 0x196a <prvUnlockQueue+0x1e>
    198e:	8f ef       	ldi	r24, 0xFF	; 255
    1990:	8a a3       	std	Y+34, r24	; 0x22
    1992:	0f 90       	pop	r0
    1994:	0f be       	out	0x3f, r0	; 63
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	0f 92       	push	r0
    199c:	89 a1       	ldd	r24, Y+33	; 0x21
    199e:	18 16       	cp	r1, r24
    19a0:	b4 f4       	brge	.+44     	; 0x19ce <prvUnlockQueue+0x82>
    19a2:	88 85       	ldd	r24, Y+8	; 0x08
    19a4:	81 11       	cpse	r24, r1
    19a6:	05 c0       	rjmp	.+10     	; 0x19b2 <prvUnlockQueue+0x66>
    19a8:	12 c0       	rjmp	.+36     	; 0x19ce <prvUnlockQueue+0x82>
    19aa:	88 85       	ldd	r24, Y+8	; 0x08
    19ac:	81 11       	cpse	r24, r1
    19ae:	04 c0       	rjmp	.+8      	; 0x19b8 <prvUnlockQueue+0x6c>
    19b0:	0e c0       	rjmp	.+28     	; 0x19ce <prvUnlockQueue+0x82>
    19b2:	8e 01       	movw	r16, r28
    19b4:	08 5f       	subi	r16, 0xF8	; 248
    19b6:	1f 4f       	sbci	r17, 0xFF	; 255
    19b8:	c8 01       	movw	r24, r16
    19ba:	0e 94 20 13 	call	0x2640	; 0x2640 <xTaskRemoveFromEventList>
    19be:	81 11       	cpse	r24, r1
    19c0:	0e 94 dd 13 	call	0x27ba	; 0x27ba <vTaskMissedYield>
    19c4:	89 a1       	ldd	r24, Y+33	; 0x21
    19c6:	81 50       	subi	r24, 0x01	; 1
    19c8:	89 a3       	std	Y+33, r24	; 0x21
    19ca:	18 16       	cp	r1, r24
    19cc:	74 f3       	brlt	.-36     	; 0x19aa <prvUnlockQueue+0x5e>
    19ce:	8f ef       	ldi	r24, 0xFF	; 255
    19d0:	89 a3       	std	Y+33, r24	; 0x21
    19d2:	0f 90       	pop	r0
    19d4:	0f be       	out	0x3f, r0	; 63
    19d6:	df 91       	pop	r29
    19d8:	cf 91       	pop	r28
    19da:	1f 91       	pop	r17
    19dc:	0f 91       	pop	r16
    19de:	08 95       	ret

000019e0 <xQueueGenericReset>:
    19e0:	1f 93       	push	r17
    19e2:	cf 93       	push	r28
    19e4:	df 93       	push	r29
    19e6:	61 30       	cpi	r22, 0x01	; 1
    19e8:	59 f0       	breq	.+22     	; 0x1a00 <xQueueGenericReset+0x20>
    19ea:	fc 01       	movw	r30, r24
    19ec:	23 89       	ldd	r18, Z+19	; 0x13
    19ee:	30 85       	ldd	r19, Z+8	; 0x08
    19f0:	31 11       	cpse	r19, r1
    19f2:	2c c0       	rjmp	.+88     	; 0x1a4c <xQueueGenericReset+0x6c>
    19f4:	11 e0       	ldi	r17, 0x01	; 1
    19f6:	21 11       	cpse	r18, r1
    19f8:	10 e0       	ldi	r17, 0x00	; 0
    19fa:	21 11       	cpse	r18, r1
    19fc:	28 c0       	rjmp	.+80     	; 0x1a4e <xQueueGenericReset+0x6e>
    19fe:	01 c0       	rjmp	.+2      	; 0x1a02 <xQueueGenericReset+0x22>
    1a00:	11 e0       	ldi	r17, 0x01	; 1
    1a02:	ec 01       	movw	r28, r24
    1a04:	48 81       	ld	r20, Y
    1a06:	59 81       	ldd	r21, Y+1	; 0x01
    1a08:	28 a1       	ldd	r18, Y+32	; 0x20
    1a0a:	30 e0       	ldi	r19, 0x00	; 0
    1a0c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a0e:	62 9f       	mul	r22, r18
    1a10:	c0 01       	movw	r24, r0
    1a12:	63 9f       	mul	r22, r19
    1a14:	90 0d       	add	r25, r0
    1a16:	11 24       	eor	r1, r1
    1a18:	ba 01       	movw	r22, r20
    1a1a:	68 0f       	add	r22, r24
    1a1c:	79 1f       	adc	r23, r25
    1a1e:	6a 83       	std	Y+2, r22	; 0x02
    1a20:	7b 83       	std	Y+3, r23	; 0x03
    1a22:	1e 8e       	std	Y+30, r1	; 0x1e
    1a24:	4c 83       	std	Y+4, r20	; 0x04
    1a26:	5d 83       	std	Y+5, r21	; 0x05
    1a28:	82 1b       	sub	r24, r18
    1a2a:	93 0b       	sbc	r25, r19
    1a2c:	84 0f       	add	r24, r20
    1a2e:	95 1f       	adc	r25, r21
    1a30:	8e 83       	std	Y+6, r24	; 0x06
    1a32:	9f 83       	std	Y+7, r25	; 0x07
    1a34:	8f ef       	ldi	r24, 0xFF	; 255
    1a36:	89 a3       	std	Y+33, r24	; 0x21
    1a38:	8a a3       	std	Y+34, r24	; 0x22
    1a3a:	ce 01       	movw	r24, r28
    1a3c:	08 96       	adiw	r24, 0x08	; 8
    1a3e:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1a42:	ce 01       	movw	r24, r28
    1a44:	43 96       	adiw	r24, 0x13	; 19
    1a46:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1a4a:	01 c0       	rjmp	.+2      	; 0x1a4e <xQueueGenericReset+0x6e>
    1a4c:	10 e0       	ldi	r17, 0x00	; 0
    1a4e:	81 2f       	mov	r24, r17
    1a50:	df 91       	pop	r29
    1a52:	cf 91       	pop	r28
    1a54:	1f 91       	pop	r17
    1a56:	08 95       	ret

00001a58 <xQueueGenericCreate>:
    1a58:	0f 93       	push	r16
    1a5a:	1f 93       	push	r17
    1a5c:	cf 93       	push	r28
    1a5e:	df 93       	push	r29
    1a60:	88 23       	and	r24, r24
    1a62:	01 f1       	breq	.+64     	; 0x1aa4 <xQueueGenericCreate+0x4c>
    1a64:	06 2f       	mov	r16, r22
    1a66:	18 2f       	mov	r17, r24
    1a68:	83 e2       	ldi	r24, 0x23	; 35
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	0e 94 44 09 	call	0x1288	; 0x1288 <pvPortMalloc>
    1a70:	ec 01       	movw	r28, r24
    1a72:	89 2b       	or	r24, r25
    1a74:	c9 f0       	breq	.+50     	; 0x1aa8 <xQueueGenericCreate+0x50>
    1a76:	10 9f       	mul	r17, r16
    1a78:	c0 01       	movw	r24, r0
    1a7a:	11 24       	eor	r1, r1
    1a7c:	01 96       	adiw	r24, 0x01	; 1
    1a7e:	0e 94 44 09 	call	0x1288	; 0x1288 <pvPortMalloc>
    1a82:	88 83       	st	Y, r24
    1a84:	99 83       	std	Y+1, r25	; 0x01
    1a86:	89 2b       	or	r24, r25
    1a88:	39 f0       	breq	.+14     	; 0x1a98 <xQueueGenericCreate+0x40>
    1a8a:	1f 8f       	std	Y+31, r17	; 0x1f
    1a8c:	08 a3       	std	Y+32, r16	; 0x20
    1a8e:	61 e0       	ldi	r22, 0x01	; 1
    1a90:	ce 01       	movw	r24, r28
    1a92:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <xQueueGenericReset>
    1a96:	08 c0       	rjmp	.+16     	; 0x1aa8 <xQueueGenericCreate+0x50>
    1a98:	ce 01       	movw	r24, r28
    1a9a:	0e 94 de 09 	call	0x13bc	; 0x13bc <vPortFree>
    1a9e:	c0 e0       	ldi	r28, 0x00	; 0
    1aa0:	d0 e0       	ldi	r29, 0x00	; 0
    1aa2:	02 c0       	rjmp	.+4      	; 0x1aa8 <xQueueGenericCreate+0x50>
    1aa4:	c0 e0       	ldi	r28, 0x00	; 0
    1aa6:	d0 e0       	ldi	r29, 0x00	; 0
    1aa8:	ce 01       	movw	r24, r28
    1aaa:	df 91       	pop	r29
    1aac:	cf 91       	pop	r28
    1aae:	1f 91       	pop	r17
    1ab0:	0f 91       	pop	r16
    1ab2:	08 95       	ret

00001ab4 <xQueueGenericSend>:
    1ab4:	af 92       	push	r10
    1ab6:	bf 92       	push	r11
    1ab8:	cf 92       	push	r12
    1aba:	df 92       	push	r13
    1abc:	ef 92       	push	r14
    1abe:	ff 92       	push	r15
    1ac0:	0f 93       	push	r16
    1ac2:	1f 93       	push	r17
    1ac4:	cf 93       	push	r28
    1ac6:	df 93       	push	r29
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	29 97       	sbiw	r28, 0x09	; 9
    1ace:	cd bf       	out	0x3d, r28	; 61
    1ad0:	de bf       	out	0x3e, r29	; 62
    1ad2:	7c 01       	movw	r14, r24
    1ad4:	5b 01       	movw	r10, r22
    1ad6:	2e 83       	std	Y+6, r18	; 0x06
    1ad8:	3f 83       	std	Y+7, r19	; 0x07
    1ada:	48 87       	std	Y+8, r20	; 0x08
    1adc:	59 87       	std	Y+9, r21	; 0x09
    1ade:	10 e0       	ldi	r17, 0x00	; 0
    1ae0:	6c 01       	movw	r12, r24
    1ae2:	88 e0       	ldi	r24, 0x08	; 8
    1ae4:	c8 0e       	add	r12, r24
    1ae6:	d1 1c       	adc	r13, r1
    1ae8:	0f b6       	in	r0, 0x3f	; 63
    1aea:	f8 94       	cli
    1aec:	0f 92       	push	r0
    1aee:	f7 01       	movw	r30, r14
    1af0:	96 8d       	ldd	r25, Z+30	; 0x1e
    1af2:	87 8d       	ldd	r24, Z+31	; 0x1f
    1af4:	98 17       	cp	r25, r24
    1af6:	a8 f4       	brcc	.+42     	; 0x1b22 <xQueueGenericSend+0x6e>
    1af8:	40 2f       	mov	r20, r16
    1afa:	b5 01       	movw	r22, r10
    1afc:	c7 01       	movw	r24, r14
    1afe:	0e 94 40 0c 	call	0x1880	; 0x1880 <prvCopyDataToQueue>
    1b02:	f7 01       	movw	r30, r14
    1b04:	83 89       	ldd	r24, Z+19	; 0x13
    1b06:	88 23       	and	r24, r24
    1b08:	41 f0       	breq	.+16     	; 0x1b1a <xQueueGenericSend+0x66>
    1b0a:	c7 01       	movw	r24, r14
    1b0c:	43 96       	adiw	r24, 0x13	; 19
    1b0e:	0e 94 20 13 	call	0x2640	; 0x2640 <xTaskRemoveFromEventList>
    1b12:	81 30       	cpi	r24, 0x01	; 1
    1b14:	11 f4       	brne	.+4      	; 0x1b1a <xQueueGenericSend+0x66>
    1b16:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
    1b1a:	0f 90       	pop	r0
    1b1c:	0f be       	out	0x3f, r0	; 63
    1b1e:	81 e0       	ldi	r24, 0x01	; 1
    1b20:	56 c0       	rjmp	.+172    	; 0x1bce <xQueueGenericSend+0x11a>
    1b22:	8e 81       	ldd	r24, Y+6	; 0x06
    1b24:	9f 81       	ldd	r25, Y+7	; 0x07
    1b26:	a8 85       	ldd	r26, Y+8	; 0x08
    1b28:	b9 85       	ldd	r27, Y+9	; 0x09
    1b2a:	89 2b       	or	r24, r25
    1b2c:	8a 2b       	or	r24, r26
    1b2e:	8b 2b       	or	r24, r27
    1b30:	21 f4       	brne	.+8      	; 0x1b3a <xQueueGenericSend+0x86>
    1b32:	0f 90       	pop	r0
    1b34:	0f be       	out	0x3f, r0	; 63
    1b36:	80 e0       	ldi	r24, 0x00	; 0
    1b38:	4a c0       	rjmp	.+148    	; 0x1bce <xQueueGenericSend+0x11a>
    1b3a:	11 11       	cpse	r17, r1
    1b3c:	05 c0       	rjmp	.+10     	; 0x1b48 <xQueueGenericSend+0x94>
    1b3e:	ce 01       	movw	r24, r28
    1b40:	01 96       	adiw	r24, 0x01	; 1
    1b42:	0e 94 5f 13 	call	0x26be	; 0x26be <vTaskSetTimeOutState>
    1b46:	11 e0       	ldi	r17, 0x01	; 1
    1b48:	0f 90       	pop	r0
    1b4a:	0f be       	out	0x3f, r0	; 63
    1b4c:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <vTaskSuspendAll>
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	f8 94       	cli
    1b54:	0f 92       	push	r0
    1b56:	f7 01       	movw	r30, r14
    1b58:	81 a1       	ldd	r24, Z+33	; 0x21
    1b5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b5c:	09 f4       	brne	.+2      	; 0x1b60 <xQueueGenericSend+0xac>
    1b5e:	11 a2       	std	Z+33, r1	; 0x21
    1b60:	f7 01       	movw	r30, r14
    1b62:	82 a1       	ldd	r24, Z+34	; 0x22
    1b64:	8f 3f       	cpi	r24, 0xFF	; 255
    1b66:	09 f4       	brne	.+2      	; 0x1b6a <xQueueGenericSend+0xb6>
    1b68:	12 a2       	std	Z+34, r1	; 0x22
    1b6a:	0f 90       	pop	r0
    1b6c:	0f be       	out	0x3f, r0	; 63
    1b6e:	be 01       	movw	r22, r28
    1b70:	6a 5f       	subi	r22, 0xFA	; 250
    1b72:	7f 4f       	sbci	r23, 0xFF	; 255
    1b74:	ce 01       	movw	r24, r28
    1b76:	01 96       	adiw	r24, 0x01	; 1
    1b78:	0e 94 70 13 	call	0x26e0	; 0x26e0 <xTaskCheckForTimeOut>
    1b7c:	81 11       	cpse	r24, r1
    1b7e:	21 c0       	rjmp	.+66     	; 0x1bc2 <xQueueGenericSend+0x10e>
    1b80:	0f b6       	in	r0, 0x3f	; 63
    1b82:	f8 94       	cli
    1b84:	0f 92       	push	r0
    1b86:	f7 01       	movw	r30, r14
    1b88:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b8a:	0f 90       	pop	r0
    1b8c:	0f be       	out	0x3f, r0	; 63
    1b8e:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b90:	98 13       	cpse	r25, r24
    1b92:	11 c0       	rjmp	.+34     	; 0x1bb6 <xQueueGenericSend+0x102>
    1b94:	4e 81       	ldd	r20, Y+6	; 0x06
    1b96:	5f 81       	ldd	r21, Y+7	; 0x07
    1b98:	68 85       	ldd	r22, Y+8	; 0x08
    1b9a:	79 85       	ldd	r23, Y+9	; 0x09
    1b9c:	c6 01       	movw	r24, r12
    1b9e:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vTaskPlaceOnEventList>
    1ba2:	c7 01       	movw	r24, r14
    1ba4:	0e 94 a6 0c 	call	0x194c	; 0x194c <prvUnlockQueue>
    1ba8:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
    1bac:	81 11       	cpse	r24, r1
    1bae:	9c cf       	rjmp	.-200    	; 0x1ae8 <xQueueGenericSend+0x34>
    1bb0:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
    1bb4:	99 cf       	rjmp	.-206    	; 0x1ae8 <xQueueGenericSend+0x34>
    1bb6:	c7 01       	movw	r24, r14
    1bb8:	0e 94 a6 0c 	call	0x194c	; 0x194c <prvUnlockQueue>
    1bbc:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
    1bc0:	93 cf       	rjmp	.-218    	; 0x1ae8 <xQueueGenericSend+0x34>
    1bc2:	c7 01       	movw	r24, r14
    1bc4:	0e 94 a6 0c 	call	0x194c	; 0x194c <prvUnlockQueue>
    1bc8:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
    1bcc:	80 e0       	ldi	r24, 0x00	; 0
    1bce:	29 96       	adiw	r28, 0x09	; 9
    1bd0:	cd bf       	out	0x3d, r28	; 61
    1bd2:	de bf       	out	0x3e, r29	; 62
    1bd4:	df 91       	pop	r29
    1bd6:	cf 91       	pop	r28
    1bd8:	1f 91       	pop	r17
    1bda:	0f 91       	pop	r16
    1bdc:	ff 90       	pop	r15
    1bde:	ef 90       	pop	r14
    1be0:	df 90       	pop	r13
    1be2:	cf 90       	pop	r12
    1be4:	bf 90       	pop	r11
    1be6:	af 90       	pop	r10
    1be8:	08 95       	ret

00001bea <xQueueGenericReceive>:
    1bea:	af 92       	push	r10
    1bec:	bf 92       	push	r11
    1bee:	cf 92       	push	r12
    1bf0:	df 92       	push	r13
    1bf2:	ef 92       	push	r14
    1bf4:	ff 92       	push	r15
    1bf6:	0f 93       	push	r16
    1bf8:	1f 93       	push	r17
    1bfa:	cf 93       	push	r28
    1bfc:	df 93       	push	r29
    1bfe:	cd b7       	in	r28, 0x3d	; 61
    1c00:	de b7       	in	r29, 0x3e	; 62
    1c02:	29 97       	sbiw	r28, 0x09	; 9
    1c04:	cd bf       	out	0x3d, r28	; 61
    1c06:	de bf       	out	0x3e, r29	; 62
    1c08:	7c 01       	movw	r14, r24
    1c0a:	5b 01       	movw	r10, r22
    1c0c:	2e 83       	std	Y+6, r18	; 0x06
    1c0e:	3f 83       	std	Y+7, r19	; 0x07
    1c10:	48 87       	std	Y+8, r20	; 0x08
    1c12:	59 87       	std	Y+9, r21	; 0x09
    1c14:	10 e0       	ldi	r17, 0x00	; 0
    1c16:	6c 01       	movw	r12, r24
    1c18:	83 e1       	ldi	r24, 0x13	; 19
    1c1a:	c8 0e       	add	r12, r24
    1c1c:	d1 1c       	adc	r13, r1
    1c1e:	0f b6       	in	r0, 0x3f	; 63
    1c20:	f8 94       	cli
    1c22:	0f 92       	push	r0
    1c24:	f7 01       	movw	r30, r14
    1c26:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c28:	88 23       	and	r24, r24
    1c2a:	99 f1       	breq	.+102    	; 0x1c92 <xQueueGenericReceive+0xa8>
    1c2c:	c6 80       	ldd	r12, Z+6	; 0x06
    1c2e:	d7 80       	ldd	r13, Z+7	; 0x07
    1c30:	b5 01       	movw	r22, r10
    1c32:	c7 01       	movw	r24, r14
    1c34:	0e 94 8c 0c 	call	0x1918	; 0x1918 <prvCopyDataFromQueue>
    1c38:	01 11       	cpse	r16, r1
    1c3a:	1a c0       	rjmp	.+52     	; 0x1c70 <xQueueGenericReceive+0x86>
    1c3c:	f7 01       	movw	r30, r14
    1c3e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c40:	81 50       	subi	r24, 0x01	; 1
    1c42:	86 8f       	std	Z+30, r24	; 0x1e
    1c44:	80 81       	ld	r24, Z
    1c46:	91 81       	ldd	r25, Z+1	; 0x01
    1c48:	89 2b       	or	r24, r25
    1c4a:	29 f4       	brne	.+10     	; 0x1c56 <xQueueGenericReceive+0x6c>
    1c4c:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <xTaskGetCurrentTaskHandle>
    1c50:	f7 01       	movw	r30, r14
    1c52:	82 83       	std	Z+2, r24	; 0x02
    1c54:	93 83       	std	Z+3, r25	; 0x03
    1c56:	f7 01       	movw	r30, r14
    1c58:	80 85       	ldd	r24, Z+8	; 0x08
    1c5a:	88 23       	and	r24, r24
    1c5c:	b1 f0       	breq	.+44     	; 0x1c8a <xQueueGenericReceive+0xa0>
    1c5e:	c7 01       	movw	r24, r14
    1c60:	08 96       	adiw	r24, 0x08	; 8
    1c62:	0e 94 20 13 	call	0x2640	; 0x2640 <xTaskRemoveFromEventList>
    1c66:	81 30       	cpi	r24, 0x01	; 1
    1c68:	81 f4       	brne	.+32     	; 0x1c8a <xQueueGenericReceive+0xa0>
    1c6a:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
    1c6e:	0d c0       	rjmp	.+26     	; 0x1c8a <xQueueGenericReceive+0xa0>
    1c70:	f7 01       	movw	r30, r14
    1c72:	c6 82       	std	Z+6, r12	; 0x06
    1c74:	d7 82       	std	Z+7, r13	; 0x07
    1c76:	83 89       	ldd	r24, Z+19	; 0x13
    1c78:	88 23       	and	r24, r24
    1c7a:	39 f0       	breq	.+14     	; 0x1c8a <xQueueGenericReceive+0xa0>
    1c7c:	c7 01       	movw	r24, r14
    1c7e:	43 96       	adiw	r24, 0x13	; 19
    1c80:	0e 94 20 13 	call	0x2640	; 0x2640 <xTaskRemoveFromEventList>
    1c84:	81 11       	cpse	r24, r1
    1c86:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
    1c8a:	0f 90       	pop	r0
    1c8c:	0f be       	out	0x3f, r0	; 63
    1c8e:	81 e0       	ldi	r24, 0x01	; 1
    1c90:	62 c0       	rjmp	.+196    	; 0x1d56 <xQueueGenericReceive+0x16c>
    1c92:	8e 81       	ldd	r24, Y+6	; 0x06
    1c94:	9f 81       	ldd	r25, Y+7	; 0x07
    1c96:	a8 85       	ldd	r26, Y+8	; 0x08
    1c98:	b9 85       	ldd	r27, Y+9	; 0x09
    1c9a:	89 2b       	or	r24, r25
    1c9c:	8a 2b       	or	r24, r26
    1c9e:	8b 2b       	or	r24, r27
    1ca0:	21 f4       	brne	.+8      	; 0x1caa <xQueueGenericReceive+0xc0>
    1ca2:	0f 90       	pop	r0
    1ca4:	0f be       	out	0x3f, r0	; 63
    1ca6:	80 e0       	ldi	r24, 0x00	; 0
    1ca8:	56 c0       	rjmp	.+172    	; 0x1d56 <xQueueGenericReceive+0x16c>
    1caa:	11 11       	cpse	r17, r1
    1cac:	05 c0       	rjmp	.+10     	; 0x1cb8 <xQueueGenericReceive+0xce>
    1cae:	ce 01       	movw	r24, r28
    1cb0:	01 96       	adiw	r24, 0x01	; 1
    1cb2:	0e 94 5f 13 	call	0x26be	; 0x26be <vTaskSetTimeOutState>
    1cb6:	11 e0       	ldi	r17, 0x01	; 1
    1cb8:	0f 90       	pop	r0
    1cba:	0f be       	out	0x3f, r0	; 63
    1cbc:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <vTaskSuspendAll>
    1cc0:	0f b6       	in	r0, 0x3f	; 63
    1cc2:	f8 94       	cli
    1cc4:	0f 92       	push	r0
    1cc6:	f7 01       	movw	r30, r14
    1cc8:	81 a1       	ldd	r24, Z+33	; 0x21
    1cca:	8f 3f       	cpi	r24, 0xFF	; 255
    1ccc:	09 f4       	brne	.+2      	; 0x1cd0 <xQueueGenericReceive+0xe6>
    1cce:	11 a2       	std	Z+33, r1	; 0x21
    1cd0:	f7 01       	movw	r30, r14
    1cd2:	82 a1       	ldd	r24, Z+34	; 0x22
    1cd4:	8f 3f       	cpi	r24, 0xFF	; 255
    1cd6:	09 f4       	brne	.+2      	; 0x1cda <xQueueGenericReceive+0xf0>
    1cd8:	12 a2       	std	Z+34, r1	; 0x22
    1cda:	0f 90       	pop	r0
    1cdc:	0f be       	out	0x3f, r0	; 63
    1cde:	be 01       	movw	r22, r28
    1ce0:	6a 5f       	subi	r22, 0xFA	; 250
    1ce2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce4:	ce 01       	movw	r24, r28
    1ce6:	01 96       	adiw	r24, 0x01	; 1
    1ce8:	0e 94 70 13 	call	0x26e0	; 0x26e0 <xTaskCheckForTimeOut>
    1cec:	81 11       	cpse	r24, r1
    1cee:	2d c0       	rjmp	.+90     	; 0x1d4a <xQueueGenericReceive+0x160>
    1cf0:	0f b6       	in	r0, 0x3f	; 63
    1cf2:	f8 94       	cli
    1cf4:	0f 92       	push	r0
    1cf6:	f7 01       	movw	r30, r14
    1cf8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cfa:	0f 90       	pop	r0
    1cfc:	0f be       	out	0x3f, r0	; 63
    1cfe:	81 11       	cpse	r24, r1
    1d00:	1e c0       	rjmp	.+60     	; 0x1d3e <xQueueGenericReceive+0x154>
    1d02:	80 81       	ld	r24, Z
    1d04:	91 81       	ldd	r25, Z+1	; 0x01
    1d06:	89 2b       	or	r24, r25
    1d08:	49 f4       	brne	.+18     	; 0x1d1c <xQueueGenericReceive+0x132>
    1d0a:	0f b6       	in	r0, 0x3f	; 63
    1d0c:	f8 94       	cli
    1d0e:	0f 92       	push	r0
    1d10:	82 81       	ldd	r24, Z+2	; 0x02
    1d12:	93 81       	ldd	r25, Z+3	; 0x03
    1d14:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vTaskPriorityInherit>
    1d18:	0f 90       	pop	r0
    1d1a:	0f be       	out	0x3f, r0	; 63
    1d1c:	4e 81       	ldd	r20, Y+6	; 0x06
    1d1e:	5f 81       	ldd	r21, Y+7	; 0x07
    1d20:	68 85       	ldd	r22, Y+8	; 0x08
    1d22:	79 85       	ldd	r23, Y+9	; 0x09
    1d24:	c6 01       	movw	r24, r12
    1d26:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vTaskPlaceOnEventList>
    1d2a:	c7 01       	movw	r24, r14
    1d2c:	0e 94 a6 0c 	call	0x194c	; 0x194c <prvUnlockQueue>
    1d30:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
    1d34:	81 11       	cpse	r24, r1
    1d36:	73 cf       	rjmp	.-282    	; 0x1c1e <xQueueGenericReceive+0x34>
    1d38:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
    1d3c:	70 cf       	rjmp	.-288    	; 0x1c1e <xQueueGenericReceive+0x34>
    1d3e:	c7 01       	movw	r24, r14
    1d40:	0e 94 a6 0c 	call	0x194c	; 0x194c <prvUnlockQueue>
    1d44:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
    1d48:	6a cf       	rjmp	.-300    	; 0x1c1e <xQueueGenericReceive+0x34>
    1d4a:	c7 01       	movw	r24, r14
    1d4c:	0e 94 a6 0c 	call	0x194c	; 0x194c <prvUnlockQueue>
    1d50:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
    1d54:	80 e0       	ldi	r24, 0x00	; 0
    1d56:	29 96       	adiw	r28, 0x09	; 9
    1d58:	cd bf       	out	0x3d, r28	; 61
    1d5a:	de bf       	out	0x3e, r29	; 62
    1d5c:	df 91       	pop	r29
    1d5e:	cf 91       	pop	r28
    1d60:	1f 91       	pop	r17
    1d62:	0f 91       	pop	r16
    1d64:	ff 90       	pop	r15
    1d66:	ef 90       	pop	r14
    1d68:	df 90       	pop	r13
    1d6a:	cf 90       	pop	r12
    1d6c:	bf 90       	pop	r11
    1d6e:	af 90       	pop	r10
    1d70:	08 95       	ret

00001d72 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d78:	fc 01       	movw	r30, r24
    1d7a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d7c:	0f 90       	pop	r0
    1d7e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d80:	08 95       	ret

00001d82 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d82:	c6 e1       	ldi	r28, 0x16	; 22
    1d84:	d1 e3       	ldi	r29, 0x31	; 49
    1d86:	88 81       	ld	r24, Y
    1d88:	82 30       	cpi	r24, 0x02	; 2
    1d8a:	e8 f3       	brcs	.-6      	; 0x1d86 <prvIdleTask+0x4>
    1d8c:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
    1d90:	fa cf       	rjmp	.-12     	; 0x1d86 <prvIdleTask+0x4>

00001d92 <prvAddCurrentTaskToDelayedList>:
    1d92:	cf 92       	push	r12
    1d94:	df 92       	push	r13
    1d96:	ef 92       	push	r14
    1d98:	ff 92       	push	r15
    1d9a:	6b 01       	movw	r12, r22
    1d9c:	7c 01       	movw	r14, r24
    1d9e:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    1da2:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1da6:	62 83       	std	Z+2, r22	; 0x02
    1da8:	73 83       	std	Z+3, r23	; 0x03
    1daa:	84 83       	std	Z+4, r24	; 0x04
    1dac:	95 83       	std	Z+5, r25	; 0x05
    1dae:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    1db2:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    1db6:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    1dba:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    1dbe:	c8 16       	cp	r12, r24
    1dc0:	d9 06       	cpc	r13, r25
    1dc2:	ea 06       	cpc	r14, r26
    1dc4:	fb 06       	cpc	r15, r27
    1dc6:	68 f4       	brcc	.+26     	; 0x1de2 <prvAddCurrentTaskToDelayedList+0x50>
    1dc8:	60 91 42 31 	lds	r22, 0x3142	; 0x803142 <pxCurrentTCB>
    1dcc:	70 91 43 31 	lds	r23, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1dd0:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <pxOverflowDelayedTaskList>
    1dd4:	90 91 fd 30 	lds	r25, 0x30FD	; 0x8030fd <pxOverflowDelayedTaskList+0x1>
    1dd8:	6e 5f       	subi	r22, 0xFE	; 254
    1dda:	7f 4f       	sbci	r23, 0xFF	; 255
    1ddc:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListInsert>
    1de0:	21 c0       	rjmp	.+66     	; 0x1e24 <prvAddCurrentTaskToDelayedList+0x92>
    1de2:	60 91 42 31 	lds	r22, 0x3142	; 0x803142 <pxCurrentTCB>
    1de6:	70 91 43 31 	lds	r23, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1dea:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    1dee:	90 91 ff 30 	lds	r25, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    1df2:	6e 5f       	subi	r22, 0xFE	; 254
    1df4:	7f 4f       	sbci	r23, 0xFF	; 255
    1df6:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListInsert>
    1dfa:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1dfe:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e02:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e06:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e0a:	c8 16       	cp	r12, r24
    1e0c:	d9 06       	cpc	r13, r25
    1e0e:	ea 06       	cpc	r14, r26
    1e10:	fb 06       	cpc	r15, r27
    1e12:	40 f4       	brcc	.+16     	; 0x1e24 <prvAddCurrentTaskToDelayedList+0x92>
    1e14:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e18:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e1c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e20:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e24:	ff 90       	pop	r15
    1e26:	ef 90       	pop	r14
    1e28:	df 90       	pop	r13
    1e2a:	cf 90       	pop	r12
    1e2c:	08 95       	ret

00001e2e <xTaskGenericCreate>:
    1e2e:	4f 92       	push	r4
    1e30:	5f 92       	push	r5
    1e32:	6f 92       	push	r6
    1e34:	7f 92       	push	r7
    1e36:	8f 92       	push	r8
    1e38:	9f 92       	push	r9
    1e3a:	af 92       	push	r10
    1e3c:	bf 92       	push	r11
    1e3e:	cf 92       	push	r12
    1e40:	df 92       	push	r13
    1e42:	ef 92       	push	r14
    1e44:	ff 92       	push	r15
    1e46:	0f 93       	push	r16
    1e48:	1f 93       	push	r17
    1e4a:	cf 93       	push	r28
    1e4c:	df 93       	push	r29
    1e4e:	5c 01       	movw	r10, r24
    1e50:	4b 01       	movw	r8, r22
    1e52:	3a 01       	movw	r6, r20
    1e54:	29 01       	movw	r4, r18
    1e56:	88 e2       	ldi	r24, 0x28	; 40
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	0e 94 44 09 	call	0x1288	; 0x1288 <pvPortMalloc>
    1e5e:	ec 01       	movw	r28, r24
    1e60:	89 2b       	or	r24, r25
    1e62:	09 f4       	brne	.+2      	; 0x1e66 <xTaskGenericCreate+0x38>
    1e64:	d4 c0       	rjmp	.+424    	; 0x200e <xTaskGenericCreate+0x1e0>
    1e66:	c1 14       	cp	r12, r1
    1e68:	d1 04       	cpc	r13, r1
    1e6a:	09 f0       	breq	.+2      	; 0x1e6e <xTaskGenericCreate+0x40>
    1e6c:	cc c0       	rjmp	.+408    	; 0x2006 <xTaskGenericCreate+0x1d8>
    1e6e:	c3 01       	movw	r24, r6
    1e70:	0e 94 44 09 	call	0x1288	; 0x1288 <pvPortMalloc>
    1e74:	8b 8f       	std	Y+27, r24	; 0x1b
    1e76:	9c 8f       	std	Y+28, r25	; 0x1c
    1e78:	00 97       	sbiw	r24, 0x00	; 0
    1e7a:	21 f4       	brne	.+8      	; 0x1e84 <xTaskGenericCreate+0x56>
    1e7c:	ce 01       	movw	r24, r28
    1e7e:	0e 94 de 09 	call	0x13bc	; 0x13bc <vPortFree>
    1e82:	c5 c0       	rjmp	.+394    	; 0x200e <xTaskGenericCreate+0x1e0>
    1e84:	a3 01       	movw	r20, r6
    1e86:	61 e1       	ldi	r22, 0x11	; 17
    1e88:	70 e0       	ldi	r23, 0x00	; 0
    1e8a:	0e 94 a2 22 	call	0x4544	; 0x4544 <memset>
    1e8e:	93 01       	movw	r18, r6
    1e90:	21 50       	subi	r18, 0x01	; 1
    1e92:	31 09       	sbc	r19, r1
    1e94:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e96:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e98:	3c 01       	movw	r6, r24
    1e9a:	62 0e       	add	r6, r18
    1e9c:	73 1e       	adc	r7, r19
    1e9e:	4a e0       	ldi	r20, 0x0A	; 10
    1ea0:	50 e0       	ldi	r21, 0x00	; 0
    1ea2:	b4 01       	movw	r22, r8
    1ea4:	ce 01       	movw	r24, r28
    1ea6:	4d 96       	adiw	r24, 0x1d	; 29
    1ea8:	0e 94 a9 22 	call	0x4552	; 0x4552 <strncpy>
    1eac:	1e a2       	std	Y+38, r1	; 0x26
    1eae:	10 2f       	mov	r17, r16
    1eb0:	04 30       	cpi	r16, 0x04	; 4
    1eb2:	08 f0       	brcs	.+2      	; 0x1eb6 <xTaskGenericCreate+0x88>
    1eb4:	13 e0       	ldi	r17, 0x03	; 3
    1eb6:	1a 8f       	std	Y+26, r17	; 0x1a
    1eb8:	1f a3       	std	Y+39, r17	; 0x27
    1eba:	6e 01       	movw	r12, r28
    1ebc:	22 e0       	ldi	r18, 0x02	; 2
    1ebe:	c2 0e       	add	r12, r18
    1ec0:	d1 1c       	adc	r13, r1
    1ec2:	c6 01       	movw	r24, r12
    1ec4:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInitialiseItem>
    1ec8:	ce 01       	movw	r24, r28
    1eca:	0e 96       	adiw	r24, 0x0e	; 14
    1ecc:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInitialiseItem>
    1ed0:	ca 87       	std	Y+10, r28	; 0x0a
    1ed2:	db 87       	std	Y+11, r29	; 0x0b
    1ed4:	84 e0       	ldi	r24, 0x04	; 4
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	a0 e0       	ldi	r26, 0x00	; 0
    1eda:	b0 e0       	ldi	r27, 0x00	; 0
    1edc:	81 1b       	sub	r24, r17
    1ede:	91 09       	sbc	r25, r1
    1ee0:	a1 09       	sbc	r26, r1
    1ee2:	b1 09       	sbc	r27, r1
    1ee4:	8e 87       	std	Y+14, r24	; 0x0e
    1ee6:	9f 87       	std	Y+15, r25	; 0x0f
    1ee8:	a8 8b       	std	Y+16, r26	; 0x10
    1eea:	b9 8b       	std	Y+17, r27	; 0x11
    1eec:	ce 8b       	std	Y+22, r28	; 0x16
    1eee:	df 8b       	std	Y+23, r29	; 0x17
    1ef0:	a2 01       	movw	r20, r4
    1ef2:	b5 01       	movw	r22, r10
    1ef4:	c3 01       	movw	r24, r6
    1ef6:	0e 94 c3 0a 	call	0x1586	; 0x1586 <pxPortInitialiseStack>
    1efa:	88 83       	st	Y, r24
    1efc:	99 83       	std	Y+1, r25	; 0x01
    1efe:	e1 14       	cp	r14, r1
    1f00:	f1 04       	cpc	r15, r1
    1f02:	19 f0       	breq	.+6      	; 0x1f0a <xTaskGenericCreate+0xdc>
    1f04:	f7 01       	movw	r30, r14
    1f06:	c0 83       	st	Z, r28
    1f08:	d1 83       	std	Z+1, r29	; 0x01
    1f0a:	0f b6       	in	r0, 0x3f	; 63
    1f0c:	f8 94       	cli
    1f0e:	0f 92       	push	r0
    1f10:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxCurrentNumberOfTasks>
    1f14:	8f 5f       	subi	r24, 0xFF	; 255
    1f16:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxCurrentNumberOfTasks>
    1f1a:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    1f1e:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1f22:	89 2b       	or	r24, r25
    1f24:	89 f5       	brne	.+98     	; 0x1f88 <xTaskGenericCreate+0x15a>
    1f26:	c0 93 42 31 	sts	0x3142, r28	; 0x803142 <pxCurrentTCB>
    1f2a:	d0 93 43 31 	sts	0x3143, r29	; 0x803143 <pxCurrentTCB+0x1>
    1f2e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxCurrentNumberOfTasks>
    1f32:	81 30       	cpi	r24, 0x01	; 1
    1f34:	c1 f5       	brne	.+112    	; 0x1fa6 <xTaskGenericCreate+0x178>
    1f36:	86 e1       	ldi	r24, 0x16	; 22
    1f38:	91 e3       	ldi	r25, 0x31	; 49
    1f3a:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1f3e:	81 e2       	ldi	r24, 0x21	; 33
    1f40:	91 e3       	ldi	r25, 0x31	; 49
    1f42:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1f46:	8c e2       	ldi	r24, 0x2C	; 44
    1f48:	91 e3       	ldi	r25, 0x31	; 49
    1f4a:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1f4e:	87 e3       	ldi	r24, 0x37	; 55
    1f50:	91 e3       	ldi	r25, 0x31	; 49
    1f52:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1f56:	8b e0       	ldi	r24, 0x0B	; 11
    1f58:	91 e3       	ldi	r25, 0x31	; 49
    1f5a:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1f5e:	80 e0       	ldi	r24, 0x00	; 0
    1f60:	91 e3       	ldi	r25, 0x31	; 49
    1f62:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1f66:	81 ef       	ldi	r24, 0xF1	; 241
    1f68:	90 e3       	ldi	r25, 0x30	; 48
    1f6a:	0e 94 16 0a 	call	0x142c	; 0x142c <vListInitialise>
    1f6e:	8b e0       	ldi	r24, 0x0B	; 11
    1f70:	91 e3       	ldi	r25, 0x31	; 49
    1f72:	80 93 fe 30 	sts	0x30FE, r24	; 0x8030fe <pxDelayedTaskList>
    1f76:	90 93 ff 30 	sts	0x30FF, r25	; 0x8030ff <pxDelayedTaskList+0x1>
    1f7a:	80 e0       	ldi	r24, 0x00	; 0
    1f7c:	91 e3       	ldi	r25, 0x31	; 49
    1f7e:	80 93 fc 30 	sts	0x30FC, r24	; 0x8030fc <pxOverflowDelayedTaskList>
    1f82:	90 93 fd 30 	sts	0x30FD, r25	; 0x8030fd <pxOverflowDelayedTaskList+0x1>
    1f86:	0f c0       	rjmp	.+30     	; 0x1fa6 <xTaskGenericCreate+0x178>
    1f88:	80 91 e7 30 	lds	r24, 0x30E7	; 0x8030e7 <xSchedulerRunning>
    1f8c:	81 11       	cpse	r24, r1
    1f8e:	0b c0       	rjmp	.+22     	; 0x1fa6 <xTaskGenericCreate+0x178>
    1f90:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    1f94:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1f98:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f9a:	08 17       	cp	r16, r24
    1f9c:	20 f0       	brcs	.+8      	; 0x1fa6 <xTaskGenericCreate+0x178>
    1f9e:	c0 93 42 31 	sts	0x3142, r28	; 0x803142 <pxCurrentTCB>
    1fa2:	d0 93 43 31 	sts	0x3143, r29	; 0x803143 <pxCurrentTCB+0x1>
    1fa6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fa8:	90 91 e9 30 	lds	r25, 0x30E9	; 0x8030e9 <uxTopUsedPriority>
    1fac:	98 17       	cp	r25, r24
    1fae:	10 f4       	brcc	.+4      	; 0x1fb4 <xTaskGenericCreate+0x186>
    1fb0:	80 93 e9 30 	sts	0x30E9, r24	; 0x8030e9 <uxTopUsedPriority>
    1fb4:	90 91 e2 30 	lds	r25, 0x30E2	; 0x8030e2 <uxTaskNumber>
    1fb8:	9f 5f       	subi	r25, 0xFF	; 255
    1fba:	90 93 e2 30 	sts	0x30E2, r25	; 0x8030e2 <uxTaskNumber>
    1fbe:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    1fc2:	98 17       	cp	r25, r24
    1fc4:	10 f4       	brcc	.+4      	; 0x1fca <xTaskGenericCreate+0x19c>
    1fc6:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    1fca:	fb e0       	ldi	r31, 0x0B	; 11
    1fcc:	8f 9f       	mul	r24, r31
    1fce:	c0 01       	movw	r24, r0
    1fd0:	11 24       	eor	r1, r1
    1fd2:	b6 01       	movw	r22, r12
    1fd4:	8a 5e       	subi	r24, 0xEA	; 234
    1fd6:	9e 4c       	sbci	r25, 0xCE	; 206
    1fd8:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vListInsertEnd>
    1fdc:	0f 90       	pop	r0
    1fde:	0f be       	out	0x3f, r0	; 63
    1fe0:	80 91 e7 30 	lds	r24, 0x30E7	; 0x8030e7 <xSchedulerRunning>
    1fe4:	88 23       	and	r24, r24
    1fe6:	59 f0       	breq	.+22     	; 0x1ffe <xTaskGenericCreate+0x1d0>
    1fe8:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    1fec:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1ff0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ff2:	80 17       	cp	r24, r16
    1ff4:	30 f4       	brcc	.+12     	; 0x2002 <xTaskGenericCreate+0x1d4>
    1ff6:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
    1ffa:	81 e0       	ldi	r24, 0x01	; 1
    1ffc:	09 c0       	rjmp	.+18     	; 0x2010 <xTaskGenericCreate+0x1e2>
    1ffe:	81 e0       	ldi	r24, 0x01	; 1
    2000:	07 c0       	rjmp	.+14     	; 0x2010 <xTaskGenericCreate+0x1e2>
    2002:	81 e0       	ldi	r24, 0x01	; 1
    2004:	05 c0       	rjmp	.+10     	; 0x2010 <xTaskGenericCreate+0x1e2>
    2006:	cb 8e       	std	Y+27, r12	; 0x1b
    2008:	dc 8e       	std	Y+28, r13	; 0x1c
    200a:	c6 01       	movw	r24, r12
    200c:	3b cf       	rjmp	.-394    	; 0x1e84 <xTaskGenericCreate+0x56>
    200e:	8f ef       	ldi	r24, 0xFF	; 255
    2010:	df 91       	pop	r29
    2012:	cf 91       	pop	r28
    2014:	1f 91       	pop	r17
    2016:	0f 91       	pop	r16
    2018:	ff 90       	pop	r15
    201a:	ef 90       	pop	r14
    201c:	df 90       	pop	r13
    201e:	cf 90       	pop	r12
    2020:	bf 90       	pop	r11
    2022:	af 90       	pop	r10
    2024:	9f 90       	pop	r9
    2026:	8f 90       	pop	r8
    2028:	7f 90       	pop	r7
    202a:	6f 90       	pop	r6
    202c:	5f 90       	pop	r5
    202e:	4f 90       	pop	r4
    2030:	08 95       	ret

00002032 <uxTaskPriorityGet>:
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	f8 94       	cli
    2036:	0f 92       	push	r0
    2038:	00 97       	sbiw	r24, 0x00	; 0
    203a:	21 f4       	brne	.+8      	; 0x2044 <uxTaskPriorityGet+0x12>
    203c:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    2040:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2044:	0f 90       	pop	r0
    2046:	0f be       	out	0x3f, r0	; 63
    2048:	fc 01       	movw	r30, r24
    204a:	82 8d       	ldd	r24, Z+26	; 0x1a
    204c:	08 95       	ret

0000204e <vTaskStartScheduler>:
    204e:	af 92       	push	r10
    2050:	bf 92       	push	r11
    2052:	cf 92       	push	r12
    2054:	df 92       	push	r13
    2056:	ef 92       	push	r14
    2058:	ff 92       	push	r15
    205a:	0f 93       	push	r16
    205c:	a1 2c       	mov	r10, r1
    205e:	b1 2c       	mov	r11, r1
    2060:	c1 2c       	mov	r12, r1
    2062:	d1 2c       	mov	r13, r1
    2064:	0f 2e       	mov	r0, r31
    2066:	ff ee       	ldi	r31, 0xEF	; 239
    2068:	ef 2e       	mov	r14, r31
    206a:	f0 e3       	ldi	r31, 0x30	; 48
    206c:	ff 2e       	mov	r15, r31
    206e:	f0 2d       	mov	r31, r0
    2070:	00 e0       	ldi	r16, 0x00	; 0
    2072:	20 e0       	ldi	r18, 0x00	; 0
    2074:	30 e0       	ldi	r19, 0x00	; 0
    2076:	44 e6       	ldi	r20, 0x64	; 100
    2078:	50 e0       	ldi	r21, 0x00	; 0
    207a:	68 e5       	ldi	r22, 0x58	; 88
    207c:	70 e2       	ldi	r23, 0x20	; 32
    207e:	81 ec       	ldi	r24, 0xC1	; 193
    2080:	9e e0       	ldi	r25, 0x0E	; 14
    2082:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <xTaskGenericCreate>
    2086:	81 30       	cpi	r24, 0x01	; 1
    2088:	69 f4       	brne	.+26     	; 0x20a4 <vTaskStartScheduler+0x56>
    208a:	f8 94       	cli
    208c:	80 93 e7 30 	sts	0x30E7, r24	; 0x8030e7 <xSchedulerRunning>
    2090:	10 92 ea 30 	sts	0x30EA, r1	; 0x8030ea <xTickCount>
    2094:	10 92 eb 30 	sts	0x30EB, r1	; 0x8030eb <xTickCount+0x1>
    2098:	10 92 ec 30 	sts	0x30EC, r1	; 0x8030ec <xTickCount+0x2>
    209c:	10 92 ed 30 	sts	0x30ED, r1	; 0x8030ed <xTickCount+0x3>
    20a0:	0e 94 39 0b 	call	0x1672	; 0x1672 <xPortStartScheduler>
    20a4:	0f 91       	pop	r16
    20a6:	ff 90       	pop	r15
    20a8:	ef 90       	pop	r14
    20aa:	df 90       	pop	r13
    20ac:	cf 90       	pop	r12
    20ae:	bf 90       	pop	r11
    20b0:	af 90       	pop	r10
    20b2:	08 95       	ret

000020b4 <vTaskSuspendAll>:
    20b4:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    20b8:	8f 5f       	subi	r24, 0xFF	; 255
    20ba:	80 93 e6 30 	sts	0x30E6, r24	; 0x8030e6 <uxSchedulerSuspended>
    20be:	08 95       	ret

000020c0 <xTaskGetTickCount>:
    20c0:	0f b6       	in	r0, 0x3f	; 63
    20c2:	f8 94       	cli
    20c4:	0f 92       	push	r0
    20c6:	60 91 ea 30 	lds	r22, 0x30EA	; 0x8030ea <xTickCount>
    20ca:	70 91 eb 30 	lds	r23, 0x30EB	; 0x8030eb <xTickCount+0x1>
    20ce:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <xTickCount+0x2>
    20d2:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <xTickCount+0x3>
    20d6:	0f 90       	pop	r0
    20d8:	0f be       	out	0x3f, r0	; 63
    20da:	08 95       	ret

000020dc <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20dc:	00 97       	sbiw	r24, 0x00	; 0
    20de:	21 f4       	brne	.+8      	; 0x20e8 <pcTaskGetTaskName+0xc>
    20e0:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    20e4:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20e8:	4d 96       	adiw	r24, 0x1d	; 29
    20ea:	08 95       	ret

000020ec <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20ec:	80 91 ef 30 	lds	r24, 0x30EF	; 0x8030ef <xIdleTaskHandle>
    20f0:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <xIdleTaskHandle+0x1>
    20f4:	08 95       	ret

000020f6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20f6:	ff 92       	push	r15
    20f8:	0f 93       	push	r16
    20fa:	1f 93       	push	r17
    20fc:	cf 93       	push	r28
    20fe:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2100:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    2104:	81 11       	cpse	r24, r1
    2106:	ed c0       	rjmp	.+474    	; 0x22e2 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    2108:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    210c:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2110:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2114:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    2118:	01 96       	adiw	r24, 0x01	; 1
    211a:	a1 1d       	adc	r26, r1
    211c:	b1 1d       	adc	r27, r1
    211e:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <xTickCount>
    2122:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <xTickCount+0x1>
    2126:	a0 93 ec 30 	sts	0x30EC, r26	; 0x8030ec <xTickCount+0x2>
    212a:	b0 93 ed 30 	sts	0x30ED, r27	; 0x8030ed <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    212e:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    2132:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2136:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    213a:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    213e:	89 2b       	or	r24, r25
    2140:	8a 2b       	or	r24, r26
    2142:	8b 2b       	or	r24, r27
    2144:	f1 f5       	brne	.+124    	; 0x21c2 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2146:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    214a:	90 91 ff 30 	lds	r25, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    214e:	20 91 fc 30 	lds	r18, 0x30FC	; 0x8030fc <pxOverflowDelayedTaskList>
    2152:	30 91 fd 30 	lds	r19, 0x30FD	; 0x8030fd <pxOverflowDelayedTaskList+0x1>
    2156:	20 93 fe 30 	sts	0x30FE, r18	; 0x8030fe <pxDelayedTaskList>
    215a:	30 93 ff 30 	sts	0x30FF, r19	; 0x8030ff <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    215e:	80 93 fc 30 	sts	0x30FC, r24	; 0x8030fc <pxOverflowDelayedTaskList>
    2162:	90 93 fd 30 	sts	0x30FD, r25	; 0x8030fd <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2166:	80 91 e3 30 	lds	r24, 0x30E3	; 0x8030e3 <xNumOfOverflows>
    216a:	8f 5f       	subi	r24, 0xFF	; 255
    216c:	80 93 e3 30 	sts	0x30E3, r24	; 0x8030e3 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2170:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    2174:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    2178:	80 81       	ld	r24, Z
    217a:	81 11       	cpse	r24, r1
    217c:	0c c0       	rjmp	.+24     	; 0x2196 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    217e:	8f ef       	ldi	r24, 0xFF	; 255
    2180:	9f ef       	ldi	r25, 0xFF	; 255
    2182:	dc 01       	movw	r26, r24
    2184:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2188:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    218c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2190:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2194:	16 c0       	rjmp	.+44     	; 0x21c2 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2196:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    219a:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    219e:	07 80       	ldd	r0, Z+7	; 0x07
    21a0:	f0 85       	ldd	r31, Z+8	; 0x08
    21a2:	e0 2d       	mov	r30, r0
    21a4:	00 84       	ldd	r0, Z+8	; 0x08
    21a6:	f1 85       	ldd	r31, Z+9	; 0x09
    21a8:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    21aa:	82 81       	ldd	r24, Z+2	; 0x02
    21ac:	93 81       	ldd	r25, Z+3	; 0x03
    21ae:	a4 81       	ldd	r26, Z+4	; 0x04
    21b0:	b5 81       	ldd	r27, Z+5	; 0x05
    21b2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21b6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21ba:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21be:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    21c2:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    21c6:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    21ca:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    21ce:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    21d2:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    21d6:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21da:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21de:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21e2:	48 17       	cp	r20, r24
    21e4:	59 07       	cpc	r21, r25
    21e6:	6a 07       	cpc	r22, r26
    21e8:	7b 07       	cpc	r23, r27
    21ea:	08 f4       	brcc	.+2      	; 0x21ee <vTaskIncrementTick+0xf8>
    21ec:	7f c0       	rjmp	.+254    	; 0x22ec <vTaskIncrementTick+0x1f6>
    21ee:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    21f2:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    21f6:	80 81       	ld	r24, Z
    21f8:	88 23       	and	r24, r24
    21fa:	f9 f0       	breq	.+62     	; 0x223a <vTaskIncrementTick+0x144>
    21fc:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    2200:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    2204:	07 80       	ldd	r0, Z+7	; 0x07
    2206:	f0 85       	ldd	r31, Z+8	; 0x08
    2208:	e0 2d       	mov	r30, r0
    220a:	c0 85       	ldd	r28, Z+8	; 0x08
    220c:	d1 85       	ldd	r29, Z+9	; 0x09
    220e:	8a 81       	ldd	r24, Y+2	; 0x02
    2210:	9b 81       	ldd	r25, Y+3	; 0x03
    2212:	ac 81       	ldd	r26, Y+4	; 0x04
    2214:	bd 81       	ldd	r27, Y+5	; 0x05
    2216:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    221a:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    221e:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2222:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    2226:	48 17       	cp	r20, r24
    2228:	59 07       	cpc	r21, r25
    222a:	6a 07       	cpc	r22, r26
    222c:	7b 07       	cpc	r23, r27
    222e:	58 f1       	brcs	.+86     	; 0x2286 <vTaskIncrementTick+0x190>
    2230:	0f 2e       	mov	r0, r31
    2232:	fb e0       	ldi	r31, 0x0B	; 11
    2234:	ff 2e       	mov	r15, r31
    2236:	f0 2d       	mov	r31, r0
    2238:	2f c0       	rjmp	.+94     	; 0x2298 <vTaskIncrementTick+0x1a2>
    223a:	8f ef       	ldi	r24, 0xFF	; 255
    223c:	9f ef       	ldi	r25, 0xFF	; 255
    223e:	dc 01       	movw	r26, r24
    2240:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2244:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2248:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    224c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2250:	4d c0       	rjmp	.+154    	; 0x22ec <vTaskIncrementTick+0x1f6>
    2252:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    2256:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    225a:	07 80       	ldd	r0, Z+7	; 0x07
    225c:	f0 85       	ldd	r31, Z+8	; 0x08
    225e:	e0 2d       	mov	r30, r0
    2260:	c0 85       	ldd	r28, Z+8	; 0x08
    2262:	d1 85       	ldd	r29, Z+9	; 0x09
    2264:	8a 81       	ldd	r24, Y+2	; 0x02
    2266:	9b 81       	ldd	r25, Y+3	; 0x03
    2268:	ac 81       	ldd	r26, Y+4	; 0x04
    226a:	bd 81       	ldd	r27, Y+5	; 0x05
    226c:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    2270:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2274:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2278:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    227c:	48 17       	cp	r20, r24
    227e:	59 07       	cpc	r21, r25
    2280:	6a 07       	cpc	r22, r26
    2282:	7b 07       	cpc	r23, r27
    2284:	48 f4       	brcc	.+18     	; 0x2298 <vTaskIncrementTick+0x1a2>
    2286:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    228a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    228e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2292:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2296:	2a c0       	rjmp	.+84     	; 0x22ec <vTaskIncrementTick+0x1f6>
    2298:	8e 01       	movw	r16, r28
    229a:	0e 5f       	subi	r16, 0xFE	; 254
    229c:	1f 4f       	sbci	r17, 0xFF	; 255
    229e:	c8 01       	movw	r24, r16
    22a0:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>
    22a4:	88 8d       	ldd	r24, Y+24	; 0x18
    22a6:	99 8d       	ldd	r25, Y+25	; 0x19
    22a8:	89 2b       	or	r24, r25
    22aa:	21 f0       	breq	.+8      	; 0x22b4 <vTaskIncrementTick+0x1be>
    22ac:	ce 01       	movw	r24, r28
    22ae:	0e 96       	adiw	r24, 0x0e	; 14
    22b0:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>
    22b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22b6:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    22ba:	98 17       	cp	r25, r24
    22bc:	10 f4       	brcc	.+4      	; 0x22c2 <vTaskIncrementTick+0x1cc>
    22be:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    22c2:	f8 9e       	mul	r15, r24
    22c4:	c0 01       	movw	r24, r0
    22c6:	11 24       	eor	r1, r1
    22c8:	b8 01       	movw	r22, r16
    22ca:	8a 5e       	subi	r24, 0xEA	; 234
    22cc:	9e 4c       	sbci	r25, 0xCE	; 206
    22ce:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vListInsertEnd>
    22d2:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    22d6:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    22da:	80 81       	ld	r24, Z
    22dc:	81 11       	cpse	r24, r1
    22de:	b9 cf       	rjmp	.-142    	; 0x2252 <vTaskIncrementTick+0x15c>
    22e0:	ac cf       	rjmp	.-168    	; 0x223a <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22e2:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    22e6:	8f 5f       	subi	r24, 0xFF	; 255
    22e8:	80 93 e5 30 	sts	0x30E5, r24	; 0x8030e5 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22ec:	df 91       	pop	r29
    22ee:	cf 91       	pop	r28
    22f0:	1f 91       	pop	r17
    22f2:	0f 91       	pop	r16
    22f4:	ff 90       	pop	r15
    22f6:	08 95       	ret

000022f8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22f8:	cf 92       	push	r12
    22fa:	df 92       	push	r13
    22fc:	ef 92       	push	r14
    22fe:	ff 92       	push	r15
    2300:	0f 93       	push	r16
    2302:	1f 93       	push	r17
    2304:	cf 93       	push	r28
    2306:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2308:	0f b6       	in	r0, 0x3f	; 63
    230a:	f8 94       	cli
    230c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    230e:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    2312:	81 50       	subi	r24, 0x01	; 1
    2314:	80 93 e6 30 	sts	0x30E6, r24	; 0x8030e6 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2318:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    231c:	81 11       	cpse	r24, r1
    231e:	60 c0       	rjmp	.+192    	; 0x23e0 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2320:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxCurrentNumberOfTasks>
    2324:	81 11       	cpse	r24, r1
    2326:	2c c0       	rjmp	.+88     	; 0x2380 <xTaskResumeAll+0x88>
    2328:	5e c0       	rjmp	.+188    	; 0x23e6 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    232a:	d7 01       	movw	r26, r14
    232c:	17 96       	adiw	r26, 0x07	; 7
    232e:	ed 91       	ld	r30, X+
    2330:	fc 91       	ld	r31, X
    2332:	18 97       	sbiw	r26, 0x08	; 8
    2334:	c0 85       	ldd	r28, Z+8	; 0x08
    2336:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2338:	ce 01       	movw	r24, r28
    233a:	0e 96       	adiw	r24, 0x0e	; 14
    233c:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2340:	8e 01       	movw	r16, r28
    2342:	0e 5f       	subi	r16, 0xFE	; 254
    2344:	1f 4f       	sbci	r17, 0xFF	; 255
    2346:	c8 01       	movw	r24, r16
    2348:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    234c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    234e:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    2352:	98 17       	cp	r25, r24
    2354:	10 f4       	brcc	.+4      	; 0x235a <xTaskResumeAll+0x62>
    2356:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    235a:	d8 9e       	mul	r13, r24
    235c:	c0 01       	movw	r24, r0
    235e:	11 24       	eor	r1, r1
    2360:	b8 01       	movw	r22, r16
    2362:	8a 5e       	subi	r24, 0xEA	; 234
    2364:	9e 4c       	sbci	r25, 0xCE	; 206
    2366:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    236a:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    236e:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2372:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2374:	82 8d       	ldd	r24, Z+26	; 0x1a
    2376:	98 17       	cp	r25, r24
    2378:	70 f0       	brcs	.+28     	; 0x2396 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    237a:	cc 24       	eor	r12, r12
    237c:	c3 94       	inc	r12
    237e:	0b c0       	rjmp	.+22     	; 0x2396 <xTaskResumeAll+0x9e>
    2380:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2382:	0f 2e       	mov	r0, r31
    2384:	f1 ef       	ldi	r31, 0xF1	; 241
    2386:	ef 2e       	mov	r14, r31
    2388:	f0 e3       	ldi	r31, 0x30	; 48
    238a:	ff 2e       	mov	r15, r31
    238c:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    238e:	0f 2e       	mov	r0, r31
    2390:	fb e0       	ldi	r31, 0x0B	; 11
    2392:	df 2e       	mov	r13, r31
    2394:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2396:	f7 01       	movw	r30, r14
    2398:	80 81       	ld	r24, Z
    239a:	81 11       	cpse	r24, r1
    239c:	c6 cf       	rjmp	.-116    	; 0x232a <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    239e:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    23a2:	88 23       	and	r24, r24
    23a4:	81 f0       	breq	.+32     	; 0x23c6 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23a6:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    23aa:	88 23       	and	r24, r24
    23ac:	99 f0       	breq	.+38     	; 0x23d4 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    23ae:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <vTaskIncrementTick>
						--uxMissedTicks;
    23b2:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    23b6:	81 50       	subi	r24, 0x01	; 1
    23b8:	80 93 e5 30 	sts	0x30E5, r24	; 0x8030e5 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23bc:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    23c0:	81 11       	cpse	r24, r1
    23c2:	f5 cf       	rjmp	.-22     	; 0x23ae <xTaskResumeAll+0xb6>
    23c4:	07 c0       	rjmp	.+14     	; 0x23d4 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    23c6:	f1 e0       	ldi	r31, 0x01	; 1
    23c8:	cf 16       	cp	r12, r31
    23ca:	21 f0       	breq	.+8      	; 0x23d4 <xTaskResumeAll+0xdc>
    23cc:	80 91 e4 30 	lds	r24, 0x30E4	; 0x8030e4 <xMissedYield>
    23d0:	81 30       	cpi	r24, 0x01	; 1
    23d2:	41 f4       	brne	.+16     	; 0x23e4 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23d4:	10 92 e4 30 	sts	0x30E4, r1	; 0x8030e4 <xMissedYield>
					portYIELD_WITHIN_API();
    23d8:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23dc:	81 e0       	ldi	r24, 0x01	; 1
    23de:	03 c0       	rjmp	.+6      	; 0x23e6 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23e0:	80 e0       	ldi	r24, 0x00	; 0
    23e2:	01 c0       	rjmp	.+2      	; 0x23e6 <xTaskResumeAll+0xee>
    23e4:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23e6:	0f 90       	pop	r0
    23e8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23ea:	df 91       	pop	r29
    23ec:	cf 91       	pop	r28
    23ee:	1f 91       	pop	r17
    23f0:	0f 91       	pop	r16
    23f2:	ff 90       	pop	r15
    23f4:	ef 90       	pop	r14
    23f6:	df 90       	pop	r13
    23f8:	cf 90       	pop	r12
    23fa:	08 95       	ret

000023fc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    23fc:	cf 92       	push	r12
    23fe:	df 92       	push	r13
    2400:	ef 92       	push	r14
    2402:	ff 92       	push	r15
    2404:	cf 93       	push	r28
    2406:	df 93       	push	r29
    2408:	ec 01       	movw	r28, r24
    240a:	6a 01       	movw	r12, r20
    240c:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    240e:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2412:	88 81       	ld	r24, Y
    2414:	99 81       	ldd	r25, Y+1	; 0x01
    2416:	aa 81       	ldd	r26, Y+2	; 0x02
    2418:	bb 81       	ldd	r27, Y+3	; 0x03
    241a:	c8 0e       	add	r12, r24
    241c:	d9 1e       	adc	r13, r25
    241e:	ea 1e       	adc	r14, r26
    2420:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2422:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    2426:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    242a:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    242e:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    2432:	48 17       	cp	r20, r24
    2434:	59 07       	cpc	r21, r25
    2436:	6a 07       	cpc	r22, r26
    2438:	7b 07       	cpc	r23, r27
    243a:	b8 f4       	brcc	.+46     	; 0x246a <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    243c:	c8 16       	cp	r12, r24
    243e:	d9 06       	cpc	r13, r25
    2440:	ea 06       	cpc	r14, r26
    2442:	fb 06       	cpc	r15, r27
    2444:	e0 f5       	brcc	.+120    	; 0x24be <vTaskDelayUntil+0xc2>
    2446:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    244a:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    244e:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2452:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2456:	c8 82       	st	Y, r12
    2458:	d9 82       	std	Y+1, r13	; 0x01
    245a:	ea 82       	std	Y+2, r14	; 0x02
    245c:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    245e:	8c 15       	cp	r24, r12
    2460:	9d 05       	cpc	r25, r13
    2462:	ae 05       	cpc	r26, r14
    2464:	bf 05       	cpc	r27, r15
    2466:	f8 f4       	brcc	.+62     	; 0x24a6 <vTaskDelayUntil+0xaa>
    2468:	13 c0       	rjmp	.+38     	; 0x2490 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    246a:	c8 16       	cp	r12, r24
    246c:	d9 06       	cpc	r13, r25
    246e:	ea 06       	cpc	r14, r26
    2470:	fb 06       	cpc	r15, r27
    2472:	00 f1       	brcs	.+64     	; 0x24b4 <vTaskDelayUntil+0xb8>
    2474:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    2478:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    247c:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2480:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    2484:	8c 15       	cp	r24, r12
    2486:	9d 05       	cpc	r25, r13
    2488:	ae 05       	cpc	r26, r14
    248a:	bf 05       	cpc	r27, r15
    248c:	98 f0       	brcs	.+38     	; 0x24b4 <vTaskDelayUntil+0xb8>
    248e:	17 c0       	rjmp	.+46     	; 0x24be <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2490:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    2494:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2498:	02 96       	adiw	r24, 0x02	; 2
    249a:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    249e:	c7 01       	movw	r24, r14
    24a0:	b6 01       	movw	r22, r12
    24a2:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    24a6:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24aa:	81 11       	cpse	r24, r1
    24ac:	0d c0       	rjmp	.+26     	; 0x24c8 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    24ae:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
		}
	}
    24b2:	0a c0       	rjmp	.+20     	; 0x24c8 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24b4:	c8 82       	st	Y, r12
    24b6:	d9 82       	std	Y+1, r13	; 0x01
    24b8:	ea 82       	std	Y+2, r14	; 0x02
    24ba:	fb 82       	std	Y+3, r15	; 0x03
    24bc:	e9 cf       	rjmp	.-46     	; 0x2490 <vTaskDelayUntil+0x94>
    24be:	c8 82       	st	Y, r12
    24c0:	d9 82       	std	Y+1, r13	; 0x01
    24c2:	ea 82       	std	Y+2, r14	; 0x02
    24c4:	fb 82       	std	Y+3, r15	; 0x03
    24c6:	ef cf       	rjmp	.-34     	; 0x24a6 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    24c8:	df 91       	pop	r29
    24ca:	cf 91       	pop	r28
    24cc:	ff 90       	pop	r15
    24ce:	ef 90       	pop	r14
    24d0:	df 90       	pop	r13
    24d2:	cf 90       	pop	r12
    24d4:	08 95       	ret

000024d6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    24d6:	cf 92       	push	r12
    24d8:	df 92       	push	r13
    24da:	ef 92       	push	r14
    24dc:	ff 92       	push	r15
    24de:	6b 01       	movw	r12, r22
    24e0:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24e2:	67 2b       	or	r22, r23
    24e4:	68 2b       	or	r22, r24
    24e6:	69 2b       	or	r22, r25
    24e8:	e9 f0       	breq	.+58     	; 0x2524 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    24ea:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24ee:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    24f2:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    24f6:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    24fa:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    24fe:	c8 0e       	add	r12, r24
    2500:	d9 1e       	adc	r13, r25
    2502:	ea 1e       	adc	r14, r26
    2504:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2506:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    250a:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    250e:	02 96       	adiw	r24, 0x02	; 2
    2510:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2514:	c7 01       	movw	r24, r14
    2516:	b6 01       	movw	r22, r12
    2518:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    251c:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2520:	81 11       	cpse	r24, r1
    2522:	02 c0       	rjmp	.+4      	; 0x2528 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2524:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <vPortYield>
		}
	}
    2528:	ff 90       	pop	r15
    252a:	ef 90       	pop	r14
    252c:	df 90       	pop	r13
    252e:	cf 90       	pop	r12
    2530:	08 95       	ret

00002532 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2532:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    2536:	81 11       	cpse	r24, r1
    2538:	0c c0       	rjmp	.+24     	; 0x2552 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    253a:	e0 91 e8 30 	lds	r30, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    253e:	4b e0       	ldi	r20, 0x0B	; 11
    2540:	e4 9f       	mul	r30, r20
    2542:	f0 01       	movw	r30, r0
    2544:	11 24       	eor	r1, r1
    2546:	ea 5e       	subi	r30, 0xEA	; 234
    2548:	fe 4c       	sbci	r31, 0xCE	; 206
    254a:	80 81       	ld	r24, Z
    254c:	88 23       	and	r24, r24
    254e:	29 f0       	breq	.+10     	; 0x255a <vTaskSwitchContext+0x28>
    2550:	14 c0       	rjmp	.+40     	; 0x257a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2552:	81 e0       	ldi	r24, 0x01	; 1
    2554:	80 93 e4 30 	sts	0x30E4, r24	; 0x8030e4 <xMissedYield>
    2558:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    255a:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    255c:	80 91 e8 30 	lds	r24, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    2560:	81 50       	subi	r24, 0x01	; 1
    2562:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2566:	e0 91 e8 30 	lds	r30, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    256a:	9e 9f       	mul	r25, r30
    256c:	f0 01       	movw	r30, r0
    256e:	11 24       	eor	r1, r1
    2570:	ea 5e       	subi	r30, 0xEA	; 234
    2572:	fe 4c       	sbci	r31, 0xCE	; 206
    2574:	80 81       	ld	r24, Z
    2576:	88 23       	and	r24, r24
    2578:	89 f3       	breq	.-30     	; 0x255c <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    257a:	80 91 e8 30 	lds	r24, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    257e:	28 2f       	mov	r18, r24
    2580:	30 e0       	ldi	r19, 0x00	; 0
    2582:	4b e0       	ldi	r20, 0x0B	; 11
    2584:	84 9f       	mul	r24, r20
    2586:	c0 01       	movw	r24, r0
    2588:	11 24       	eor	r1, r1
    258a:	dc 01       	movw	r26, r24
    258c:	aa 5e       	subi	r26, 0xEA	; 234
    258e:	be 4c       	sbci	r27, 0xCE	; 206
    2590:	11 96       	adiw	r26, 0x01	; 1
    2592:	ed 91       	ld	r30, X+
    2594:	fc 91       	ld	r31, X
    2596:	12 97       	sbiw	r26, 0x02	; 2
    2598:	04 80       	ldd	r0, Z+4	; 0x04
    259a:	f5 81       	ldd	r31, Z+5	; 0x05
    259c:	e0 2d       	mov	r30, r0
    259e:	11 96       	adiw	r26, 0x01	; 1
    25a0:	ed 93       	st	X+, r30
    25a2:	fc 93       	st	X, r31
    25a4:	12 97       	sbiw	r26, 0x02	; 2
    25a6:	87 5e       	subi	r24, 0xE7	; 231
    25a8:	9e 4c       	sbci	r25, 0xCE	; 206
    25aa:	e8 17       	cp	r30, r24
    25ac:	f9 07       	cpc	r31, r25
    25ae:	61 f4       	brne	.+24     	; 0x25c8 <vTaskSwitchContext+0x96>
    25b0:	84 81       	ldd	r24, Z+4	; 0x04
    25b2:	95 81       	ldd	r25, Z+5	; 0x05
    25b4:	4b e0       	ldi	r20, 0x0B	; 11
    25b6:	42 9f       	mul	r20, r18
    25b8:	f0 01       	movw	r30, r0
    25ba:	43 9f       	mul	r20, r19
    25bc:	f0 0d       	add	r31, r0
    25be:	11 24       	eor	r1, r1
    25c0:	ea 5e       	subi	r30, 0xEA	; 234
    25c2:	fe 4c       	sbci	r31, 0xCE	; 206
    25c4:	81 83       	std	Z+1, r24	; 0x01
    25c6:	92 83       	std	Z+2, r25	; 0x02
    25c8:	8b e0       	ldi	r24, 0x0B	; 11
    25ca:	82 9f       	mul	r24, r18
    25cc:	f0 01       	movw	r30, r0
    25ce:	83 9f       	mul	r24, r19
    25d0:	f0 0d       	add	r31, r0
    25d2:	11 24       	eor	r1, r1
    25d4:	ea 5e       	subi	r30, 0xEA	; 234
    25d6:	fe 4c       	sbci	r31, 0xCE	; 206
    25d8:	01 80       	ldd	r0, Z+1	; 0x01
    25da:	f2 81       	ldd	r31, Z+2	; 0x02
    25dc:	e0 2d       	mov	r30, r0
    25de:	80 85       	ldd	r24, Z+8	; 0x08
    25e0:	91 85       	ldd	r25, Z+9	; 0x09
    25e2:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <pxCurrentTCB>
    25e6:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <pxCurrentTCB+0x1>
    25ea:	08 95       	ret

000025ec <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25ec:	cf 92       	push	r12
    25ee:	df 92       	push	r13
    25f0:	ef 92       	push	r14
    25f2:	ff 92       	push	r15
    25f4:	6a 01       	movw	r12, r20
    25f6:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25f8:	60 91 42 31 	lds	r22, 0x3142	; 0x803142 <pxCurrentTCB>
    25fc:	70 91 43 31 	lds	r23, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2600:	62 5f       	subi	r22, 0xF2	; 242
    2602:	7f 4f       	sbci	r23, 0xFF	; 255
    2604:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2608:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    260c:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2610:	02 96       	adiw	r24, 0x02	; 2
    2612:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2616:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    261a:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    261e:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2622:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2626:	bc 01       	movw	r22, r24
    2628:	cd 01       	movw	r24, r26
    262a:	6c 0d       	add	r22, r12
    262c:	7d 1d       	adc	r23, r13
    262e:	8e 1d       	adc	r24, r14
    2630:	9f 1d       	adc	r25, r15
    2632:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2636:	ff 90       	pop	r15
    2638:	ef 90       	pop	r14
    263a:	df 90       	pop	r13
    263c:	cf 90       	pop	r12
    263e:	08 95       	ret

00002640 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2640:	0f 93       	push	r16
    2642:	1f 93       	push	r17
    2644:	cf 93       	push	r28
    2646:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2648:	dc 01       	movw	r26, r24
    264a:	17 96       	adiw	r26, 0x07	; 7
    264c:	ed 91       	ld	r30, X+
    264e:	fc 91       	ld	r31, X
    2650:	18 97       	sbiw	r26, 0x08	; 8
    2652:	c0 85       	ldd	r28, Z+8	; 0x08
    2654:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2656:	8e 01       	movw	r16, r28
    2658:	02 5f       	subi	r16, 0xF2	; 242
    265a:	1f 4f       	sbci	r17, 0xFF	; 255
    265c:	c8 01       	movw	r24, r16
    265e:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2662:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    2666:	81 11       	cpse	r24, r1
    2668:	16 c0       	rjmp	.+44     	; 0x2696 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    266a:	0c 50       	subi	r16, 0x0C	; 12
    266c:	11 09       	sbc	r17, r1
    266e:	c8 01       	movw	r24, r16
    2670:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2674:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2676:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    267a:	98 17       	cp	r25, r24
    267c:	10 f4       	brcc	.+4      	; 0x2682 <xTaskRemoveFromEventList+0x42>
    267e:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    2682:	bb e0       	ldi	r27, 0x0B	; 11
    2684:	8b 9f       	mul	r24, r27
    2686:	c0 01       	movw	r24, r0
    2688:	11 24       	eor	r1, r1
    268a:	b8 01       	movw	r22, r16
    268c:	8a 5e       	subi	r24, 0xEA	; 234
    268e:	9e 4c       	sbci	r25, 0xCE	; 206
    2690:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vListInsertEnd>
    2694:	05 c0       	rjmp	.+10     	; 0x26a0 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2696:	b8 01       	movw	r22, r16
    2698:	81 ef       	ldi	r24, 0xF1	; 241
    269a:	90 e3       	ldi	r25, 0x30	; 48
    269c:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    26a0:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    26a4:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    26a8:	81 e0       	ldi	r24, 0x01	; 1
    26aa:	2a 8d       	ldd	r18, Y+26	; 0x1a
    26ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    26ae:	29 17       	cp	r18, r25
    26b0:	08 f4       	brcc	.+2      	; 0x26b4 <xTaskRemoveFromEventList+0x74>
    26b2:	80 e0       	ldi	r24, 0x00	; 0
}
    26b4:	df 91       	pop	r29
    26b6:	cf 91       	pop	r28
    26b8:	1f 91       	pop	r17
    26ba:	0f 91       	pop	r16
    26bc:	08 95       	ret

000026be <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    26be:	20 91 e3 30 	lds	r18, 0x30E3	; 0x8030e3 <xNumOfOverflows>
    26c2:	fc 01       	movw	r30, r24
    26c4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    26c6:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    26ca:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    26ce:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    26d2:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    26d6:	41 83       	std	Z+1, r20	; 0x01
    26d8:	52 83       	std	Z+2, r21	; 0x02
    26da:	63 83       	std	Z+3, r22	; 0x03
    26dc:	74 83       	std	Z+4, r23	; 0x04
    26de:	08 95       	ret

000026e0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26e0:	8f 92       	push	r8
    26e2:	9f 92       	push	r9
    26e4:	af 92       	push	r10
    26e6:	bf 92       	push	r11
    26e8:	cf 92       	push	r12
    26ea:	df 92       	push	r13
    26ec:	ef 92       	push	r14
    26ee:	ff 92       	push	r15
    26f0:	0f 93       	push	r16
    26f2:	1f 93       	push	r17
    26f4:	cf 93       	push	r28
    26f6:	df 93       	push	r29
    26f8:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2700:	80 91 e3 30 	lds	r24, 0x30E3	; 0x8030e3 <xNumOfOverflows>
    2704:	90 81       	ld	r25, Z
    2706:	98 17       	cp	r25, r24
    2708:	89 f0       	breq	.+34     	; 0x272c <xTaskCheckForTimeOut+0x4c>
    270a:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    270e:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2712:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2716:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    271a:	01 81       	ldd	r16, Z+1	; 0x01
    271c:	12 81       	ldd	r17, Z+2	; 0x02
    271e:	23 81       	ldd	r18, Z+3	; 0x03
    2720:	34 81       	ldd	r19, Z+4	; 0x04
    2722:	80 17       	cp	r24, r16
    2724:	91 07       	cpc	r25, r17
    2726:	a2 07       	cpc	r26, r18
    2728:	b3 07       	cpc	r27, r19
    272a:	a8 f5       	brcc	.+106    	; 0x2796 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    272c:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    2730:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2734:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2738:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    273c:	c1 80       	ldd	r12, Z+1	; 0x01
    273e:	d2 80       	ldd	r13, Z+2	; 0x02
    2740:	e3 80       	ldd	r14, Z+3	; 0x03
    2742:	f4 80       	ldd	r15, Z+4	; 0x04
    2744:	eb 01       	movw	r28, r22
    2746:	08 81       	ld	r16, Y
    2748:	19 81       	ldd	r17, Y+1	; 0x01
    274a:	2a 81       	ldd	r18, Y+2	; 0x02
    274c:	3b 81       	ldd	r19, Y+3	; 0x03
    274e:	8c 19       	sub	r24, r12
    2750:	9d 09       	sbc	r25, r13
    2752:	ae 09       	sbc	r26, r14
    2754:	bf 09       	sbc	r27, r15
    2756:	80 17       	cp	r24, r16
    2758:	91 07       	cpc	r25, r17
    275a:	a2 07       	cpc	r26, r18
    275c:	b3 07       	cpc	r27, r19
    275e:	e8 f4       	brcc	.+58     	; 0x279a <xTaskCheckForTimeOut+0xba>
    2760:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2762:	80 90 ea 30 	lds	r8, 0x30EA	; 0x8030ea <xTickCount>
    2766:	90 90 eb 30 	lds	r9, 0x30EB	; 0x8030eb <xTickCount+0x1>
    276a:	a0 90 ec 30 	lds	r10, 0x30EC	; 0x8030ec <xTickCount+0x2>
    276e:	b0 90 ed 30 	lds	r11, 0x30ED	; 0x8030ed <xTickCount+0x3>
    2772:	b5 01       	movw	r22, r10
    2774:	a4 01       	movw	r20, r8
    2776:	4c 19       	sub	r20, r12
    2778:	5d 09       	sbc	r21, r13
    277a:	6e 09       	sbc	r22, r14
    277c:	7f 09       	sbc	r23, r15
    277e:	04 1b       	sub	r16, r20
    2780:	15 0b       	sbc	r17, r21
    2782:	26 0b       	sbc	r18, r22
    2784:	37 0b       	sbc	r19, r23
    2786:	08 83       	st	Y, r16
    2788:	19 83       	std	Y+1, r17	; 0x01
    278a:	2a 83       	std	Y+2, r18	; 0x02
    278c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    278e:	0e 94 5f 13 	call	0x26be	; 0x26be <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2792:	80 e0       	ldi	r24, 0x00	; 0
    2794:	03 c0       	rjmp	.+6      	; 0x279c <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	01 c0       	rjmp	.+2      	; 0x279c <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    279a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    279c:	0f 90       	pop	r0
    279e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    27a0:	df 91       	pop	r29
    27a2:	cf 91       	pop	r28
    27a4:	1f 91       	pop	r17
    27a6:	0f 91       	pop	r16
    27a8:	ff 90       	pop	r15
    27aa:	ef 90       	pop	r14
    27ac:	df 90       	pop	r13
    27ae:	cf 90       	pop	r12
    27b0:	bf 90       	pop	r11
    27b2:	af 90       	pop	r10
    27b4:	9f 90       	pop	r9
    27b6:	8f 90       	pop	r8
    27b8:	08 95       	ret

000027ba <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    27ba:	81 e0       	ldi	r24, 0x01	; 1
    27bc:	80 93 e4 30 	sts	0x30E4, r24	; 0x8030e4 <xMissedYield>
    27c0:	08 95       	ret

000027c2 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27c2:	00 97       	sbiw	r24, 0x00	; 0
    27c4:	21 f4       	brne	.+8      	; 0x27ce <uxTaskGetStackHighWaterMark+0xc>
    27c6:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    27ca:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    27ce:	dc 01       	movw	r26, r24
    27d0:	5b 96       	adiw	r26, 0x1b	; 27
    27d2:	ed 91       	ld	r30, X+
    27d4:	fc 91       	ld	r31, X
    27d6:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27d8:	80 81       	ld	r24, Z
    27da:	81 31       	cpi	r24, 0x11	; 17
    27dc:	41 f4       	brne	.+16     	; 0x27ee <uxTaskGetStackHighWaterMark+0x2c>
    27de:	31 96       	adiw	r30, 0x01	; 1
    27e0:	80 e0       	ldi	r24, 0x00	; 0
    27e2:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27e4:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27e6:	21 91       	ld	r18, Z+
    27e8:	21 31       	cpi	r18, 0x11	; 17
    27ea:	e1 f3       	breq	.-8      	; 0x27e4 <uxTaskGetStackHighWaterMark+0x22>
    27ec:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27ee:	80 e0       	ldi	r24, 0x00	; 0
    27f0:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27f2:	08 95       	ret

000027f4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27f4:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    27f8:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>

		return xReturn;
	}
    27fc:	08 95       	ret

000027fe <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27fe:	0f 93       	push	r16
    2800:	1f 93       	push	r17
    2802:	cf 93       	push	r28
    2804:	df 93       	push	r29
    2806:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2808:	22 8d       	ldd	r18, Z+26	; 0x1a
    280a:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    280e:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2812:	5a 96       	adiw	r26, 0x1a	; 26
    2814:	8c 91       	ld	r24, X
    2816:	28 17       	cp	r18, r24
    2818:	08 f0       	brcs	.+2      	; 0x281c <vTaskPriorityInherit+0x1e>
    281a:	41 c0       	rjmp	.+130    	; 0x289e <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    281c:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    2820:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2824:	5a 96       	adiw	r26, 0x1a	; 26
    2826:	3c 91       	ld	r19, X
    2828:	84 e0       	ldi	r24, 0x04	; 4
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	a0 e0       	ldi	r26, 0x00	; 0
    282e:	b0 e0       	ldi	r27, 0x00	; 0
    2830:	83 1b       	sub	r24, r19
    2832:	91 09       	sbc	r25, r1
    2834:	a1 09       	sbc	r26, r1
    2836:	b1 09       	sbc	r27, r1
    2838:	86 87       	std	Z+14, r24	; 0x0e
    283a:	97 87       	std	Z+15, r25	; 0x0f
    283c:	a0 8b       	std	Z+16, r26	; 0x10
    283e:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2840:	8b e0       	ldi	r24, 0x0B	; 11
    2842:	28 9f       	mul	r18, r24
    2844:	90 01       	movw	r18, r0
    2846:	11 24       	eor	r1, r1
    2848:	2a 5e       	subi	r18, 0xEA	; 234
    284a:	3e 4c       	sbci	r19, 0xCE	; 206
    284c:	84 85       	ldd	r24, Z+12	; 0x0c
    284e:	95 85       	ldd	r25, Z+13	; 0x0d
    2850:	82 17       	cp	r24, r18
    2852:	93 07       	cpc	r25, r19
    2854:	e9 f4       	brne	.+58     	; 0x2890 <vTaskPriorityInherit+0x92>
    2856:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2858:	ef 01       	movw	r28, r30
    285a:	22 96       	adiw	r28, 0x02	; 2
    285c:	ce 01       	movw	r24, r28
    285e:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2862:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    2866:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    286a:	82 8d       	ldd	r24, Z+26	; 0x1a
    286c:	f8 01       	movw	r30, r16
    286e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2870:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    2874:	98 17       	cp	r25, r24
    2876:	10 f4       	brcc	.+4      	; 0x287c <vTaskPriorityInherit+0x7e>
    2878:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    287c:	fb e0       	ldi	r31, 0x0B	; 11
    287e:	8f 9f       	mul	r24, r31
    2880:	c0 01       	movw	r24, r0
    2882:	11 24       	eor	r1, r1
    2884:	be 01       	movw	r22, r28
    2886:	8a 5e       	subi	r24, 0xEA	; 234
    2888:	9e 4c       	sbci	r25, 0xCE	; 206
    288a:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vListInsertEnd>
    288e:	07 c0       	rjmp	.+14     	; 0x289e <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2890:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    2894:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2898:	5a 96       	adiw	r26, 0x1a	; 26
    289a:	8c 91       	ld	r24, X
    289c:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    289e:	df 91       	pop	r29
    28a0:	cf 91       	pop	r28
    28a2:	1f 91       	pop	r17
    28a4:	0f 91       	pop	r16
    28a6:	08 95       	ret

000028a8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    28a8:	0f 93       	push	r16
    28aa:	1f 93       	push	r17
    28ac:	cf 93       	push	r28
    28ae:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    28b0:	00 97       	sbiw	r24, 0x00	; 0
    28b2:	49 f1       	breq	.+82     	; 0x2906 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    28b4:	fc 01       	movw	r30, r24
    28b6:	32 8d       	ldd	r19, Z+26	; 0x1a
    28b8:	27 a1       	ldd	r18, Z+39	; 0x27
    28ba:	32 17       	cp	r19, r18
    28bc:	21 f1       	breq	.+72     	; 0x2906 <vTaskPriorityDisinherit+0x5e>
    28be:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    28c0:	8c 01       	movw	r16, r24
    28c2:	0e 5f       	subi	r16, 0xFE	; 254
    28c4:	1f 4f       	sbci	r17, 0xFF	; 255
    28c6:	c8 01       	movw	r24, r16
    28c8:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28cc:	8f a1       	ldd	r24, Y+39	; 0x27
    28ce:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28d0:	44 e0       	ldi	r20, 0x04	; 4
    28d2:	50 e0       	ldi	r21, 0x00	; 0
    28d4:	60 e0       	ldi	r22, 0x00	; 0
    28d6:	70 e0       	ldi	r23, 0x00	; 0
    28d8:	48 1b       	sub	r20, r24
    28da:	51 09       	sbc	r21, r1
    28dc:	61 09       	sbc	r22, r1
    28de:	71 09       	sbc	r23, r1
    28e0:	4e 87       	std	Y+14, r20	; 0x0e
    28e2:	5f 87       	std	Y+15, r21	; 0x0f
    28e4:	68 8b       	std	Y+16, r22	; 0x10
    28e6:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28e8:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    28ec:	98 17       	cp	r25, r24
    28ee:	10 f4       	brcc	.+4      	; 0x28f4 <vTaskPriorityDisinherit+0x4c>
    28f0:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    28f4:	fb e0       	ldi	r31, 0x0B	; 11
    28f6:	8f 9f       	mul	r24, r31
    28f8:	c0 01       	movw	r24, r0
    28fa:	11 24       	eor	r1, r1
    28fc:	b8 01       	movw	r22, r16
    28fe:	8a 5e       	subi	r24, 0xEA	; 234
    2900:	9e 4c       	sbci	r25, 0xCE	; 206
    2902:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vListInsertEnd>
			}
		}
	}
    2906:	df 91       	pop	r29
    2908:	cf 91       	pop	r28
    290a:	1f 91       	pop	r17
    290c:	0f 91       	pop	r16
    290e:	08 95       	ret

00002910 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2910:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2912:	e8 81       	ld	r30, Y
    2914:	f9 81       	ldd	r31, Y+1	; 0x01
    2916:	01 90       	ld	r0, Z+
    2918:	f0 81       	ld	r31, Z
    291a:	e0 2d       	mov	r30, r0
    291c:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    291e:	1a 82       	std	Y+2, r1	; 0x02
    2920:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2922:	6f ef       	ldi	r22, 0xFF	; 255
    2924:	7f ef       	ldi	r23, 0xFF	; 255
    2926:	cb 01       	movw	r24, r22
    2928:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <vTaskDelay>
    292c:	fa cf       	rjmp	.-12     	; 0x2922 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000292e <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    292e:	fc 01       	movw	r30, r24
    2930:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2932:	65 87       	std	Z+13, r22	; 0x0d
    2934:	08 95       	ret

00002936 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2936:	4f 92       	push	r4
    2938:	5f 92       	push	r5
    293a:	6f 92       	push	r6
    293c:	7f 92       	push	r7
    293e:	8f 92       	push	r8
    2940:	9f 92       	push	r9
    2942:	af 92       	push	r10
    2944:	bf 92       	push	r11
    2946:	cf 92       	push	r12
    2948:	df 92       	push	r13
    294a:	ef 92       	push	r14
    294c:	ff 92       	push	r15
    294e:	0f 93       	push	r16
    2950:	1f 93       	push	r17
    2952:	cf 93       	push	r28
    2954:	df 93       	push	r29
    2956:	cd b7       	in	r28, 0x3d	; 61
    2958:	de b7       	in	r29, 0x3e	; 62
    295a:	2a 97       	sbiw	r28, 0x0a	; 10
    295c:	cd bf       	out	0x3d, r28	; 61
    295e:	de bf       	out	0x3e, r29	; 62
    2960:	4c 01       	movw	r8, r24
    2962:	29 01       	movw	r4, r18
    2964:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2966:	81 e6       	ldi	r24, 0x61	; 97
    2968:	90 e2       	ldi	r25, 0x20	; 32
    296a:	f4 01       	movw	r30, r8
    296c:	80 83       	st	Z, r24
    296e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2970:	fb 01       	movw	r30, r22
    2972:	80 81       	ld	r24, Z
    2974:	88 23       	and	r24, r24
    2976:	69 f0       	breq	.+26     	; 0x2992 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2978:	de 01       	movw	r26, r28
    297a:	11 96       	adiw	r26, 0x01	; 1
    297c:	31 96       	adiw	r30, 0x01	; 1
    297e:	90 e0       	ldi	r25, 0x00	; 0
    2980:	02 c0       	rjmp	.+4      	; 0x2986 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2982:	99 30       	cpi	r25, 0x09	; 9
    2984:	39 f0       	breq	.+14     	; 0x2994 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2986:	9f 5f       	subi	r25, 0xFF	; 255
    2988:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    298a:	81 91       	ld	r24, Z+
    298c:	81 11       	cpse	r24, r1
    298e:	f9 cf       	rjmp	.-14     	; 0x2982 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2990:	01 c0       	rjmp	.+2      	; 0x2994 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2992:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2994:	e1 e0       	ldi	r30, 0x01	; 1
    2996:	f0 e0       	ldi	r31, 0x00	; 0
    2998:	ec 0f       	add	r30, r28
    299a:	fd 1f       	adc	r31, r29
    299c:	e9 0f       	add	r30, r25
    299e:	f1 1d       	adc	r31, r1
    29a0:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    29a2:	74 01       	movw	r14, r8
    29a4:	f2 e0       	ldi	r31, 0x02	; 2
    29a6:	ef 0e       	add	r14, r31
    29a8:	f1 1c       	adc	r15, r1
    29aa:	a1 2c       	mov	r10, r1
    29ac:	b1 2c       	mov	r11, r1
    29ae:	c1 2c       	mov	r12, r1
    29b0:	d1 2c       	mov	r13, r1
    29b2:	04 2f       	mov	r16, r20
    29b4:	94 01       	movw	r18, r8
    29b6:	a2 01       	movw	r20, r4
    29b8:	be 01       	movw	r22, r28
    29ba:	6f 5f       	subi	r22, 0xFF	; 255
    29bc:	7f 4f       	sbci	r23, 0xFF	; 255
    29be:	84 ea       	ldi	r24, 0xA4	; 164
    29c0:	92 e0       	ldi	r25, 0x02	; 2
    29c2:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    29c6:	f4 01       	movw	r30, r8
    29c8:	66 82       	std	Z+6, r6	; 0x06
    29ca:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    29cc:	40 86       	std	Z+8, r4	; 0x08
    29ce:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    29d0:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <last_created_task_pointer>
    29d4:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <last_created_task_pointer+0x1>
    29d8:	24 83       	std	Z+4, r18	; 0x04
    29da:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29dc:	80 92 44 31 	sts	0x3144, r8	; 0x803144 <last_created_task_pointer>
    29e0:	90 92 45 31 	sts	0x3145, r9	; 0x803145 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29e4:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29e6:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29e8:	40 90 86 31 	lds	r4, 0x3186	; 0x803186 <portStackTopForTask>
    29ec:	50 90 87 31 	lds	r5, 0x3187	; 0x803187 <portStackTopForTask+0x1>
    29f0:	ff ef       	ldi	r31, 0xFF	; 255
    29f2:	4f 1a       	sub	r4, r31
    29f4:	5f 0a       	sbc	r5, r31
    29f6:	40 92 86 31 	sts	0x3186, r4	; 0x803186 <portStackTopForTask>
    29fa:	50 92 87 31 	sts	0x3187, r5	; 0x803187 <portStackTopForTask+0x1>
    29fe:	f4 01       	movw	r30, r8
    2a00:	42 86       	std	Z+10, r4	; 0x0a
    2a02:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2a04:	16 86       	std	Z+14, r1	; 0x0e
    2a06:	17 86       	std	Z+15, r1	; 0x0f
    2a08:	10 8a       	std	Z+16, r1	; 0x10
    2a0a:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2a0c:	61 14       	cp	r6, r1
    2a0e:	71 04       	cpc	r7, r1
    2a10:	09 f4       	brne	.+2      	; 0x2a14 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a12:	44 c0       	rjmp	.+136    	; 0x2a9c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a14:	81 30       	cpi	r24, 0x01	; 1
    2a16:	79 f5       	brne	.+94     	; 0x2a76 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a18:	6a e0       	ldi	r22, 0x0A	; 10
    2a1a:	c3 01       	movw	r24, r6
    2a1c:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2a20:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2a22:	65 e9       	ldi	r22, 0x95	; 149
    2a24:	74 e0       	ldi	r23, 0x04	; 4
    2a26:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2a2a:	be 01       	movw	r22, r28
    2a2c:	6f 5f       	subi	r22, 0xFF	; 255
    2a2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a30:	c7 01       	movw	r24, r14
    2a32:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2a36:	6a e0       	ldi	r22, 0x0A	; 10
    2a38:	c7 01       	movw	r24, r14
    2a3a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2a3e:	7c 01       	movw	r14, r24
    2a40:	6c e8       	ldi	r22, 0x8C	; 140
    2a42:	74 e0       	ldi	r23, 0x04	; 4
    2a44:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a48:	6a e0       	ldi	r22, 0x0A	; 10
    2a4a:	c7 01       	movw	r24, r14
    2a4c:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2a50:	7c 01       	movw	r14, r24
    2a52:	6e e7       	ldi	r22, 0x7E	; 126
    2a54:	74 e0       	ldi	r23, 0x04	; 4
    2a56:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2a5a:	63 e0       	ldi	r22, 0x03	; 3
    2a5c:	c7 01       	movw	r24, r14
    2a5e:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2a62:	b2 01       	movw	r22, r4
    2a64:	0e 94 a7 1a 	call	0x354e	; 0x354e <_ZN8emstreamlsEj>
    2a68:	62 e0       	ldi	r22, 0x02	; 2
    2a6a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2a6e:	66 e0       	ldi	r22, 0x06	; 6
    2a70:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2a74:	13 c0       	rjmp	.+38     	; 0x2a9c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a76:	6a e0       	ldi	r22, 0x0A	; 10
    2a78:	c3 01       	movw	r24, r6
    2a7a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2a7e:	4c 01       	movw	r8, r24
    2a80:	69 e6       	ldi	r22, 0x69	; 105
    2a82:	74 e0       	ldi	r23, 0x04	; 4
    2a84:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2a88:	be 01       	movw	r22, r28
    2a8a:	6f 5f       	subi	r22, 0xFF	; 255
    2a8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8e:	c4 01       	movw	r24, r8
    2a90:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2a94:	66 e0       	ldi	r22, 0x06	; 6
    2a96:	c4 01       	movw	r24, r8
    2a98:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a9c:	2a 96       	adiw	r28, 0x0a	; 10
    2a9e:	cd bf       	out	0x3d, r28	; 61
    2aa0:	de bf       	out	0x3e, r29	; 62
    2aa2:	df 91       	pop	r29
    2aa4:	cf 91       	pop	r28
    2aa6:	1f 91       	pop	r17
    2aa8:	0f 91       	pop	r16
    2aaa:	ff 90       	pop	r15
    2aac:	ef 90       	pop	r14
    2aae:	df 90       	pop	r13
    2ab0:	cf 90       	pop	r12
    2ab2:	bf 90       	pop	r11
    2ab4:	af 90       	pop	r10
    2ab6:	9f 90       	pop	r9
    2ab8:	8f 90       	pop	r8
    2aba:	7f 90       	pop	r7
    2abc:	6f 90       	pop	r6
    2abe:	5f 90       	pop	r5
    2ac0:	4f 90       	pop	r4
    2ac2:	08 95       	ret

00002ac4 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2ac4:	cf 92       	push	r12
    2ac6:	df 92       	push	r13
    2ac8:	ef 92       	push	r14
    2aca:	ff 92       	push	r15
    2acc:	0f 93       	push	r16
    2ace:	1f 93       	push	r17
    2ad0:	cf 93       	push	r28
    2ad2:	df 93       	push	r29
    2ad4:	ec 01       	movw	r28, r24
    2ad6:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2ad8:	8a 81       	ldd	r24, Y+2	; 0x02
    2ada:	9b 81       	ldd	r25, Y+3	; 0x03
    2adc:	0e 94 6e 10 	call	0x20dc	; 0x20dc <pcTaskGetTaskName>
    2ae0:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2ae2:	6a e0       	ldi	r22, 0x0A	; 10
    2ae4:	c7 01       	movw	r24, r14
    2ae6:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2aea:	8c 01       	movw	r16, r24
    2aec:	68 ea       	ldi	r22, 0xA8	; 168
    2aee:	74 e0       	ldi	r23, 0x04	; 4
    2af0:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2af4:	6a e0       	ldi	r22, 0x0A	; 10
    2af6:	c8 01       	movw	r24, r16
    2af8:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2afc:	8c 01       	movw	r16, r24
    2afe:	61 ea       	ldi	r22, 0xA1	; 161
    2b00:	74 e0       	ldi	r23, 0x04	; 4
    2b02:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2b06:	b6 01       	movw	r22, r12
    2b08:	c8 01       	movw	r24, r16
    2b0a:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2b0e:	6a e0       	ldi	r22, 0x0A	; 10
    2b10:	c8 01       	movw	r24, r16
    2b12:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2b16:	8c 01       	movw	r16, r24
    2b18:	6b e9       	ldi	r22, 0x9B	; 155
    2b1a:	74 e0       	ldi	r23, 0x04	; 4
    2b1c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2b20:	66 e0       	ldi	r22, 0x06	; 6
    2b22:	c8 01       	movw	r24, r16
    2b24:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b28:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b2a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b2c:	e8 85       	ldd	r30, Y+8	; 0x08
    2b2e:	f9 85       	ldd	r31, Y+9	; 0x09
    2b30:	01 e1       	ldi	r16, 0x11	; 17
    2b32:	21 e0       	ldi	r18, 0x01	; 1
    2b34:	a7 01       	movw	r20, r14
    2b36:	bc 01       	movw	r22, r24
    2b38:	8e 1b       	sub	r24, r30
    2b3a:	9f 0b       	sbc	r25, r31
    2b3c:	0e 94 64 18 	call	0x30c8	; 0x30c8 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b40:	8c 81       	ldd	r24, Y+4	; 0x04
    2b42:	9d 81       	ldd	r25, Y+5	; 0x05
    2b44:	00 97       	sbiw	r24, 0x00	; 0
    2b46:	19 f0       	breq	.+6      	; 0x2b4e <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b48:	b7 01       	movw	r22, r14
    2b4a:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b4e:	df 91       	pop	r29
    2b50:	cf 91       	pop	r28
    2b52:	1f 91       	pop	r17
    2b54:	0f 91       	pop	r16
    2b56:	ff 90       	pop	r15
    2b58:	ef 90       	pop	r14
    2b5a:	df 90       	pop	r13
    2b5c:	cf 90       	pop	r12
    2b5e:	08 95       	ret

00002b60 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b60:	0f 93       	push	r16
    2b62:	1f 93       	push	r17
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    2b68:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b6a:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <last_created_task_pointer>
    2b6e:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <last_created_task_pointer+0x1>
    2b72:	00 97       	sbiw	r24, 0x00	; 0
    2b74:	19 f0       	breq	.+6      	; 0x2b7c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b76:	be 01       	movw	r22, r28
    2b78:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b7c:	6a e0       	ldi	r22, 0x0A	; 10
    2b7e:	ce 01       	movw	r24, r28
    2b80:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2b84:	8c 01       	movw	r16, r24
    2b86:	6e eb       	ldi	r22, 0xBE	; 190
    2b88:	74 e0       	ldi	r23, 0x04	; 4
    2b8a:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2b8e:	6a e0       	ldi	r22, 0x0A	; 10
    2b90:	c8 01       	movw	r24, r16
    2b92:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2b96:	8c 01       	movw	r16, r24
    2b98:	63 eb       	ldi	r22, 0xB3	; 179
    2b9a:	74 e0       	ldi	r23, 0x04	; 4
    2b9c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2ba0:	6a e0       	ldi	r22, 0x0A	; 10
    2ba2:	c8 01       	movw	r24, r16
    2ba4:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2ba8:	8c 01       	movw	r16, r24
    2baa:	6d ea       	ldi	r22, 0xAD	; 173
    2bac:	74 e0       	ldi	r23, 0x04	; 4
    2bae:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2bb2:	66 e0       	ldi	r22, 0x06	; 6
    2bb4:	c8 01       	movw	r24, r16
    2bb6:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2bba:	80 91 86 31 	lds	r24, 0x3186	; 0x803186 <portStackTopForTask>
    2bbe:	90 91 87 31 	lds	r25, 0x3187	; 0x803187 <portStackTopForTask+0x1>
    2bc2:	bc 01       	movw	r22, r24
    2bc4:	6f 5f       	subi	r22, 0xFF	; 255
    2bc6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bc8:	01 e1       	ldi	r16, 0x11	; 17
    2bca:	21 e0       	ldi	r18, 0x01	; 1
    2bcc:	ae 01       	movw	r20, r28
    2bce:	83 56       	subi	r24, 0x63	; 99
    2bd0:	91 09       	sbc	r25, r1
    2bd2:	0e 94 64 18 	call	0x30c8	; 0x30c8 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2bd6:	df 91       	pop	r29
    2bd8:	cf 91       	pop	r28
    2bda:	1f 91       	pop	r17
    2bdc:	0f 91       	pop	r16
    2bde:	08 95       	ret

00002be0 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2be0:	8f 92       	push	r8
    2be2:	9f 92       	push	r9
    2be4:	af 92       	push	r10
    2be6:	bf 92       	push	r11
    2be8:	cf 92       	push	r12
    2bea:	df 92       	push	r13
    2bec:	ef 92       	push	r14
    2bee:	ff 92       	push	r15
    2bf0:	0f 93       	push	r16
    2bf2:	1f 93       	push	r17
    2bf4:	cf 93       	push	r28
    2bf6:	df 93       	push	r29
    2bf8:	ec 01       	movw	r28, r24
    2bfa:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    2c00:	0e 94 6e 10 	call	0x20dc	; 0x20dc <pcTaskGetTaskName>
    2c04:	bc 01       	movw	r22, r24
    2c06:	c8 01       	movw	r24, r16
    2c08:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2c0c:	d8 01       	movw	r26, r16
    2c0e:	ed 91       	ld	r30, X+
    2c10:	fc 91       	ld	r31, X
    2c12:	02 80       	ldd	r0, Z+2	; 0x02
    2c14:	f3 81       	ldd	r31, Z+3	; 0x03
    2c16:	e0 2d       	mov	r30, r0
    2c18:	69 e0       	ldi	r22, 0x09	; 9
    2c1a:	c8 01       	movw	r24, r16
    2c1c:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c1e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c20:	9b 81       	ldd	r25, Y+3	; 0x03
    2c22:	0e 94 6e 10 	call	0x20dc	; 0x20dc <pcTaskGetTaskName>
    2c26:	fc 01       	movw	r30, r24
    2c28:	01 90       	ld	r0, Z+
    2c2a:	00 20       	and	r0, r0
    2c2c:	e9 f7       	brne	.-6      	; 0x2c28 <_ZN8frt_task12print_statusER8emstream+0x48>
    2c2e:	31 97       	sbiw	r30, 0x01	; 1
    2c30:	e8 1b       	sub	r30, r24
    2c32:	f9 0b       	sbc	r31, r25
    2c34:	38 97       	sbiw	r30, 0x08	; 8
    2c36:	48 f4       	brcc	.+18     	; 0x2c4a <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2c38:	d8 01       	movw	r26, r16
    2c3a:	ed 91       	ld	r30, X+
    2c3c:	fc 91       	ld	r31, X
    2c3e:	02 80       	ldd	r0, Z+2	; 0x02
    2c40:	f3 81       	ldd	r31, Z+3	; 0x03
    2c42:	e0 2d       	mov	r30, r0
    2c44:	69 e0       	ldi	r22, 0x09	; 9
    2c46:	c8 01       	movw	r24, r16
    2c48:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c4a:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c4c:	df 84       	ldd	r13, Y+15	; 0x0f
    2c4e:	e8 88       	ldd	r14, Y+16	; 0x10
    2c50:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c52:	a8 84       	ldd	r10, Y+8	; 0x08
    2c54:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c56:	8a 81       	ldd	r24, Y+2	; 0x02
    2c58:	9b 81       	ldd	r25, Y+3	; 0x03
    2c5a:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <uxTaskGetStackHighWaterMark>
    2c5e:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c60:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c62:	8a 81       	ldd	r24, Y+2	; 0x02
    2c64:	9b 81       	ldd	r25, Y+3	; 0x03
    2c66:	0e 94 19 10 	call	0x2032	; 0x2032 <uxTaskPriorityGet>
    2c6a:	68 2f       	mov	r22, r24
    2c6c:	c8 01       	movw	r24, r16
    2c6e:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
    2c72:	6a e0       	ldi	r22, 0x0A	; 10
    2c74:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2c78:	ec 01       	movw	r28, r24
    2c7a:	63 e3       	ldi	r22, 0x33	; 51
    2c7c:	75 e0       	ldi	r23, 0x05	; 5
    2c7e:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c82:	68 2d       	mov	r22, r8
    2c84:	ce 01       	movw	r24, r28
    2c86:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c8a:	6a e0       	ldi	r22, 0x0A	; 10
    2c8c:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2c90:	ec 01       	movw	r28, r24
    2c92:	61 e3       	ldi	r22, 0x31	; 49
    2c94:	75 e0       	ldi	r23, 0x05	; 5
    2c96:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2c9a:	69 2d       	mov	r22, r9
    2c9c:	ce 01       	movw	r24, r28
    2c9e:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
    2ca2:	6a e0       	ldi	r22, 0x0A	; 10
    2ca4:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2ca8:	ec 01       	movw	r28, r24
    2caa:	6f e2       	ldi	r22, 0x2F	; 47
    2cac:	75 e0       	ldi	r23, 0x05	; 5
    2cae:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2cb2:	b5 01       	movw	r22, r10
    2cb4:	ce 01       	movw	r24, r28
    2cb6:	0e 94 a7 1a 	call	0x354e	; 0x354e <_ZN8emstreamlsEj>
    2cba:	6a e0       	ldi	r22, 0x0A	; 10
    2cbc:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2cc0:	ec 01       	movw	r28, r24
    2cc2:	6d e2       	ldi	r22, 0x2D	; 45
    2cc4:	75 e0       	ldi	r23, 0x05	; 5
    2cc6:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2cca:	6a e0       	ldi	r22, 0x0A	; 10
    2ccc:	ce 01       	movw	r24, r28
    2cce:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2cd2:	ec 01       	movw	r28, r24
    2cd4:	6b e2       	ldi	r22, 0x2B	; 43
    2cd6:	75 e0       	ldi	r23, 0x05	; 5
    2cd8:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2cdc:	b7 01       	movw	r22, r14
    2cde:	a6 01       	movw	r20, r12
    2ce0:	ce 01       	movw	r24, r28
    2ce2:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <_ZN8emstreamlsEm>
}
    2ce6:	df 91       	pop	r29
    2ce8:	cf 91       	pop	r28
    2cea:	1f 91       	pop	r17
    2cec:	0f 91       	pop	r16
    2cee:	ff 90       	pop	r15
    2cf0:	ef 90       	pop	r14
    2cf2:	df 90       	pop	r13
    2cf4:	cf 90       	pop	r12
    2cf6:	bf 90       	pop	r11
    2cf8:	af 90       	pop	r10
    2cfa:	9f 90       	pop	r9
    2cfc:	8f 90       	pop	r8
    2cfe:	08 95       	ret

00002d00 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2d00:	cf 93       	push	r28
    2d02:	df 93       	push	r29
    2d04:	ec 01       	movw	r28, r24
    2d06:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2d08:	db 01       	movw	r26, r22
    2d0a:	ed 91       	ld	r30, X+
    2d0c:	fc 91       	ld	r31, X
    2d0e:	02 80       	ldd	r0, Z+2	; 0x02
    2d10:	f3 81       	ldd	r31, Z+3	; 0x03
    2d12:	e0 2d       	mov	r30, r0
    2d14:	be 01       	movw	r22, r28
    2d16:	19 95       	eicall
	return (ser_dev);
}
    2d18:	ce 01       	movw	r24, r28
    2d1a:	df 91       	pop	r29
    2d1c:	cf 91       	pop	r28
    2d1e:	08 95       	ret

00002d20 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2d20:	0f 93       	push	r16
    2d22:	1f 93       	push	r17
    2d24:	cf 93       	push	r28
    2d26:	df 93       	push	r29
    2d28:	ec 01       	movw	r28, r24
    2d2a:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d2c:	bc 01       	movw	r22, r24
    2d2e:	c8 01       	movw	r24, r16
    2d30:	0e 94 80 16 	call	0x2d00	; 0x2d00 <_ZlsR8emstreamR8frt_task>
    2d34:	66 e0       	ldi	r22, 0x06	; 6
    2d36:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d3a:	8c 81       	ldd	r24, Y+4	; 0x04
    2d3c:	9d 81       	ldd	r25, Y+5	; 0x05
    2d3e:	00 97       	sbiw	r24, 0x00	; 0
    2d40:	19 f0       	breq	.+6      	; 0x2d48 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d42:	b8 01       	movw	r22, r16
    2d44:	0e 94 90 16 	call	0x2d20	; 0x2d20 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d48:	df 91       	pop	r29
    2d4a:	cf 91       	pop	r28
    2d4c:	1f 91       	pop	r17
    2d4e:	0f 91       	pop	r16
    2d50:	08 95       	ret

00002d52 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d52:	0f 93       	push	r16
    2d54:	1f 93       	push	r17
    2d56:	cf 93       	push	r28
    2d58:	df 93       	push	r29
    2d5a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d5c:	6a e0       	ldi	r22, 0x0A	; 10
    2d5e:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2d62:	8c 01       	movw	r16, r24
    2d64:	60 e2       	ldi	r22, 0x20	; 32
    2d66:	75 e0       	ldi	r23, 0x05	; 5
    2d68:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d6c:	6a e0       	ldi	r22, 0x0A	; 10
    2d6e:	c8 01       	movw	r24, r16
    2d70:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2d74:	8c 01       	movw	r16, r24
    2d76:	69 e1       	ldi	r22, 0x19	; 25
    2d78:	75 e0       	ldi	r23, 0x05	; 5
    2d7a:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d7e:	66 e0       	ldi	r22, 0x06	; 6
    2d80:	c8 01       	movw	r24, r16
    2d82:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d86:	6a e0       	ldi	r22, 0x0A	; 10
    2d88:	ce 01       	movw	r24, r28
    2d8a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2d8e:	8c 01       	movw	r16, r24
    2d90:	68 e0       	ldi	r22, 0x08	; 8
    2d92:	75 e0       	ldi	r23, 0x05	; 5
    2d94:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2d98:	6a e0       	ldi	r22, 0x0A	; 10
    2d9a:	c8 01       	movw	r24, r16
    2d9c:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2da0:	8c 01       	movw	r16, r24
    2da2:	6c ef       	ldi	r22, 0xFC	; 252
    2da4:	74 e0       	ldi	r23, 0x04	; 4
    2da6:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2daa:	6a e0       	ldi	r22, 0x0A	; 10
    2dac:	c8 01       	movw	r24, r16
    2dae:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2db2:	8c 01       	movw	r16, r24
    2db4:	66 ef       	ldi	r22, 0xF6	; 246
    2db6:	74 e0       	ldi	r23, 0x04	; 4
    2db8:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2dbc:	66 e0       	ldi	r22, 0x06	; 6
    2dbe:	c8 01       	movw	r24, r16
    2dc0:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2dc4:	6a e0       	ldi	r22, 0x0A	; 10
    2dc6:	ce 01       	movw	r24, r28
    2dc8:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2dcc:	8c 01       	movw	r16, r24
    2dce:	65 ee       	ldi	r22, 0xE5	; 229
    2dd0:	74 e0       	ldi	r23, 0x04	; 4
    2dd2:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2dd6:	6a e0       	ldi	r22, 0x0A	; 10
    2dd8:	c8 01       	movw	r24, r16
    2dda:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2dde:	8c 01       	movw	r16, r24
    2de0:	69 ed       	ldi	r22, 0xD9	; 217
    2de2:	74 e0       	ldi	r23, 0x04	; 4
    2de4:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2de8:	6a e0       	ldi	r22, 0x0A	; 10
    2dea:	c8 01       	movw	r24, r16
    2dec:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2df0:	8c 01       	movw	r16, r24
    2df2:	63 ed       	ldi	r22, 0xD3	; 211
    2df4:	74 e0       	ldi	r23, 0x04	; 4
    2df6:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2dfa:	66 e0       	ldi	r22, 0x06	; 6
    2dfc:	c8 01       	movw	r24, r16
    2dfe:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2e02:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <last_created_task_pointer>
    2e06:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <last_created_task_pointer+0x1>
    2e0a:	00 97       	sbiw	r24, 0x00	; 0
    2e0c:	19 f0       	breq	.+6      	; 0x2e14 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2e0e:	be 01       	movw	r22, r28
    2e10:	0e 94 90 16 	call	0x2d20	; 0x2d20 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e14:	0e 94 76 10 	call	0x20ec	; 0x20ec <xTaskGetIdleTaskHandle>
    2e18:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <uxTaskGetStackHighWaterMark>
    2e1c:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2e1e:	6a e0       	ldi	r22, 0x0A	; 10
    2e20:	ce 01       	movw	r24, r28
    2e22:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2e26:	ec 01       	movw	r28, r24
    2e28:	68 ec       	ldi	r22, 0xC8	; 200
    2e2a:	74 e0       	ldi	r23, 0x04	; 4
    2e2c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e30:	61 2f       	mov	r22, r17
    2e32:	ce 01       	movw	r24, r28
    2e34:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2e38:	6a e0       	ldi	r22, 0x0A	; 10
    2e3a:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2e3e:	ec 01       	movw	r28, r24
    2e40:	66 ec       	ldi	r22, 0xC6	; 198
    2e42:	74 e0       	ldi	r23, 0x04	; 4
    2e44:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    2e48:	64 e6       	ldi	r22, 0x64	; 100
    2e4a:	70 e0       	ldi	r23, 0x00	; 0
    2e4c:	ce 01       	movw	r24, r28
    2e4e:	0e 94 a7 1a 	call	0x354e	; 0x354e <_ZN8emstreamlsEj>
    2e52:	6a e0       	ldi	r22, 0x0A	; 10
    2e54:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    2e58:	ec 01       	movw	r28, r24
    2e5a:	63 ec       	ldi	r22, 0xC3	; 195
    2e5c:	74 e0       	ldi	r23, 0x04	; 4
    2e5e:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e62:	66 e0       	ldi	r22, 0x06	; 6
    2e64:	ce 01       	movw	r24, r28
    2e66:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
}
    2e6a:	df 91       	pop	r29
    2e6c:	cf 91       	pop	r28
    2e6e:	1f 91       	pop	r17
    2e70:	0f 91       	pop	r16
    2e72:	08 95       	ret

00002e74 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e74:	0f 93       	push	r16
    2e76:	cf 93       	push	r28
    2e78:	df 93       	push	r29
    2e7a:	1f 92       	push	r1
    2e7c:	cd b7       	in	r28, 0x3d	; 61
    2e7e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e80:	00 e0       	ldi	r16, 0x00	; 0
    2e82:	2f ef       	ldi	r18, 0xFF	; 255
    2e84:	3f ef       	ldi	r19, 0xFF	; 255
    2e86:	a9 01       	movw	r20, r18
    2e88:	be 01       	movw	r22, r28
    2e8a:	6f 5f       	subi	r22, 0xFF	; 255
    2e8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e8e:	fc 01       	movw	r30, r24
    2e90:	80 85       	ldd	r24, Z+8	; 0x08
    2e92:	91 85       	ldd	r25, Z+9	; 0x09
    2e94:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <xQueueGenericReceive>
    2e98:	81 30       	cpi	r24, 0x01	; 1
    2e9a:	19 f4       	brne	.+6      	; 0x2ea2 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e9c:	89 81       	ldd	r24, Y+1	; 0x01
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
    2ea0:	02 c0       	rjmp	.+4      	; 0x2ea6 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2ea2:	8f ef       	ldi	r24, 0xFF	; 255
    2ea4:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2ea6:	0f 90       	pop	r0
    2ea8:	df 91       	pop	r29
    2eaa:	cf 91       	pop	r28
    2eac:	0f 91       	pop	r16
    2eae:	08 95       	ret

00002eb0 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2eb0:	fc 01       	movw	r30, r24
    2eb2:	80 85       	ldd	r24, Z+8	; 0x08
    2eb4:	91 85       	ldd	r25, Z+9	; 0x09
    2eb6:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <uxQueueMessagesWaiting>
    2eba:	91 e0       	ldi	r25, 0x01	; 1
    2ebc:	81 11       	cpse	r24, r1
    2ebe:	01 c0       	rjmp	.+2      	; 0x2ec2 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2ec0:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2ec2:	89 2f       	mov	r24, r25
    2ec4:	08 95       	ret

00002ec6 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2ec6:	0f 93       	push	r16
    2ec8:	cf 93       	push	r28
    2eca:	df 93       	push	r29
    2ecc:	1f 92       	push	r1
    2ece:	cd b7       	in	r28, 0x3d	; 61
    2ed0:	de b7       	in	r29, 0x3e	; 62
    2ed2:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2ed4:	fc 01       	movw	r30, r24
    2ed6:	22 85       	ldd	r18, Z+10	; 0x0a
    2ed8:	33 85       	ldd	r19, Z+11	; 0x0b
    2eda:	44 85       	ldd	r20, Z+12	; 0x0c
    2edc:	55 85       	ldd	r21, Z+13	; 0x0d
    2ede:	00 e0       	ldi	r16, 0x00	; 0
    2ee0:	be 01       	movw	r22, r28
    2ee2:	6f 5f       	subi	r22, 0xFF	; 255
    2ee4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ee6:	80 85       	ldd	r24, Z+8	; 0x08
    2ee8:	91 85       	ldd	r25, Z+9	; 0x09
    2eea:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <xQueueGenericSend>
    2eee:	91 e0       	ldi	r25, 0x01	; 1
    2ef0:	81 11       	cpse	r24, r1
    2ef2:	01 c0       	rjmp	.+2      	; 0x2ef6 <_ZN14frt_text_queue7putcharEc+0x30>
    2ef4:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2ef6:	89 2f       	mov	r24, r25
    2ef8:	0f 90       	pop	r0
    2efa:	df 91       	pop	r29
    2efc:	cf 91       	pop	r28
    2efe:	0f 91       	pop	r16
    2f00:	08 95       	ret

00002f02 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2f02:	8f 92       	push	r8
    2f04:	9f 92       	push	r9
    2f06:	bf 92       	push	r11
    2f08:	cf 92       	push	r12
    2f0a:	df 92       	push	r13
    2f0c:	ef 92       	push	r14
    2f0e:	ff 92       	push	r15
    2f10:	0f 93       	push	r16
    2f12:	1f 93       	push	r17
    2f14:	cf 93       	push	r28
    2f16:	df 93       	push	r29
    2f18:	ec 01       	movw	r28, r24
    2f1a:	b6 2e       	mov	r11, r22
    2f1c:	4a 01       	movw	r8, r20
    2f1e:	68 01       	movw	r12, r16
    2f20:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f22:	0e 94 da 19 	call	0x33b4	; 0x33b4 <_ZN8emstreamC1Ev>
    2f26:	89 e6       	ldi	r24, 0x69	; 105
    2f28:	90 e2       	ldi	r25, 0x20	; 32
    2f2a:	88 83       	st	Y, r24
    2f2c:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f2e:	8e 86       	std	Y+14, r8	; 0x0e
    2f30:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f32:	40 e0       	ldi	r20, 0x00	; 0
    2f34:	61 e0       	ldi	r22, 0x01	; 1
    2f36:	8b 2d       	mov	r24, r11
    2f38:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <xQueueGenericCreate>
    2f3c:	88 87       	std	Y+8, r24	; 0x08
    2f3e:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f40:	ca 86       	std	Y+10, r12	; 0x0a
    2f42:	db 86       	std	Y+11, r13	; 0x0b
    2f44:	ec 86       	std	Y+12, r14	; 0x0c
    2f46:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f48:	df 91       	pop	r29
    2f4a:	cf 91       	pop	r28
    2f4c:	1f 91       	pop	r17
    2f4e:	0f 91       	pop	r16
    2f50:	ff 90       	pop	r15
    2f52:	ef 90       	pop	r14
    2f54:	df 90       	pop	r13
    2f56:	cf 90       	pop	r12
    2f58:	bf 90       	pop	r11
    2f5a:	9f 90       	pop	r9
    2f5c:	8f 90       	pop	r8
    2f5e:	08 95       	ret

00002f60 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f60:	cf 92       	push	r12
    2f62:	df 92       	push	r13
    2f64:	ef 92       	push	r14
    2f66:	ff 92       	push	r15
    2f68:	cf 93       	push	r28
    2f6a:	df 93       	push	r29
    2f6c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f6e:	68 81       	ld	r22, Y
    2f70:	79 81       	ldd	r23, Y+1	; 0x01
    2f72:	8a 81       	ldd	r24, Y+2	; 0x02
    2f74:	9b 81       	ldd	r25, Y+3	; 0x03
    2f76:	0f 2e       	mov	r0, r31
    2f78:	f8 ee       	ldi	r31, 0xE8	; 232
    2f7a:	cf 2e       	mov	r12, r31
    2f7c:	f3 e0       	ldi	r31, 0x03	; 3
    2f7e:	df 2e       	mov	r13, r31
    2f80:	e1 2c       	mov	r14, r1
    2f82:	f1 2c       	mov	r15, r1
    2f84:	f0 2d       	mov	r31, r0
    2f86:	a7 01       	movw	r20, r14
    2f88:	96 01       	movw	r18, r12
    2f8a:	0e 94 35 22 	call	0x446a	; 0x446a <__udivmodsi4>
    2f8e:	9b 01       	movw	r18, r22
    2f90:	ac 01       	movw	r20, r24
    2f92:	60 e4       	ldi	r22, 0x40	; 64
    2f94:	72 e4       	ldi	r23, 0x42	; 66
    2f96:	8f e0       	ldi	r24, 0x0F	; 15
    2f98:	90 e0       	ldi	r25, 0x00	; 0
    2f9a:	0e 94 25 22 	call	0x444a	; 0x444a <__mulsi3>
    2f9e:	a7 01       	movw	r20, r14
    2fa0:	96 01       	movw	r18, r12
    2fa2:	0e 94 35 22 	call	0x446a	; 0x446a <__udivmodsi4>
    2fa6:	69 01       	movw	r12, r18
    2fa8:	7a 01       	movw	r14, r20
    2faa:	ac 81       	ldd	r26, Y+4	; 0x04
    2fac:	bd 81       	ldd	r27, Y+5	; 0x05
    2fae:	20 e4       	ldi	r18, 0x40	; 64
    2fb0:	32 e4       	ldi	r19, 0x42	; 66
    2fb2:	4f e0       	ldi	r20, 0x0F	; 15
    2fb4:	50 e0       	ldi	r21, 0x00	; 0
    2fb6:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__muluhisi3>
    2fba:	20 e0       	ldi	r18, 0x00	; 0
    2fbc:	38 e4       	ldi	r19, 0x48	; 72
    2fbe:	48 ee       	ldi	r20, 0xE8	; 232
    2fc0:	51 e0       	ldi	r21, 0x01	; 1
    2fc2:	0e 94 35 22 	call	0x446a	; 0x446a <__udivmodsi4>
    2fc6:	c7 01       	movw	r24, r14
    2fc8:	b6 01       	movw	r22, r12
    2fca:	62 0f       	add	r22, r18
    2fcc:	73 1f       	adc	r23, r19
    2fce:	84 1f       	adc	r24, r20
    2fd0:	95 1f       	adc	r25, r21
}
    2fd2:	df 91       	pop	r29
    2fd4:	cf 91       	pop	r28
    2fd6:	ff 90       	pop	r15
    2fd8:	ef 90       	pop	r14
    2fda:	df 90       	pop	r13
    2fdc:	cf 90       	pop	r12
    2fde:	08 95       	ret

00002fe0 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2fe0:	cf 92       	push	r12
    2fe2:	df 92       	push	r13
    2fe4:	ef 92       	push	r14
    2fe6:	ff 92       	push	r15
    2fe8:	0f 93       	push	r16
    2fea:	1f 93       	push	r17
    2fec:	cf 93       	push	r28
    2fee:	df 93       	push	r29
    2ff0:	cd b7       	in	r28, 0x3d	; 61
    2ff2:	de b7       	in	r29, 0x3e	; 62
    2ff4:	2f 97       	sbiw	r28, 0x0f	; 15
    2ff6:	cd bf       	out	0x3d, r28	; 61
    2ff8:	de bf       	out	0x3e, r29	; 62
    2ffa:	6c 01       	movw	r12, r24
    2ffc:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2ffe:	db 01       	movw	r26, r22
    3000:	6d 91       	ld	r22, X+
    3002:	7d 91       	ld	r23, X+
    3004:	8d 91       	ld	r24, X+
    3006:	9c 91       	ld	r25, X
    3008:	28 ee       	ldi	r18, 0xE8	; 232
    300a:	33 e0       	ldi	r19, 0x03	; 3
    300c:	40 e0       	ldi	r20, 0x00	; 0
    300e:	50 e0       	ldi	r21, 0x00	; 0
    3010:	0e 94 35 22 	call	0x446a	; 0x446a <__udivmodsi4>
    3014:	ba 01       	movw	r22, r20
    3016:	a9 01       	movw	r20, r18
    3018:	c6 01       	movw	r24, r12
    301a:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    301e:	d6 01       	movw	r26, r12
    3020:	ed 91       	ld	r30, X+
    3022:	fc 91       	ld	r31, X
    3024:	02 80       	ldd	r0, Z+2	; 0x02
    3026:	f3 81       	ldd	r31, Z+3	; 0x03
    3028:	e0 2d       	mov	r30, r0
    302a:	6e e2       	ldi	r22, 0x2E	; 46
    302c:	c6 01       	movw	r24, r12
    302e:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3030:	c8 01       	movw	r24, r16
    3032:	0e 94 b0 17 	call	0x2f60	; 0x2f60 <_ZN10time_stamp12get_microsecEv>
    3036:	8e 01       	movw	r16, r28
    3038:	09 5f       	subi	r16, 0xF9	; 249
    303a:	1f 4f       	sbci	r17, 0xFF	; 255
    303c:	fe 01       	movw	r30, r28
    303e:	31 96       	adiw	r30, 0x01	; 1
    3040:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3042:	2a e0       	ldi	r18, 0x0A	; 10
    3044:	30 e0       	ldi	r19, 0x00	; 0
    3046:	40 e0       	ldi	r20, 0x00	; 0
    3048:	50 e0       	ldi	r21, 0x00	; 0
    304a:	0e 94 57 22 	call	0x44ae	; 0x44ae <__divmodsi4>
    304e:	e6 2f       	mov	r30, r22
    3050:	28 87       	std	Y+8, r18	; 0x08
    3052:	39 87       	std	Y+9, r19	; 0x09
    3054:	4a 87       	std	Y+10, r20	; 0x0a
    3056:	5b 87       	std	Y+11, r21	; 0x0b
    3058:	68 85       	ldd	r22, Y+8	; 0x08
    305a:	79 85       	ldd	r23, Y+9	; 0x09
    305c:	8a 85       	ldd	r24, Y+10	; 0x0a
    305e:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3060:	20 e3       	ldi	r18, 0x30	; 48
    3062:	2e 0f       	add	r18, r30
    3064:	d8 01       	movw	r26, r16
    3066:	2e 93       	st	-X, r18
    3068:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    306a:	ae 15       	cp	r26, r14
    306c:	bf 05       	cpc	r27, r15
    306e:	49 f7       	brne	.-46     	; 0x3042 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3070:	1f 82       	std	Y+7, r1	; 0x07
    3072:	be 01       	movw	r22, r28
    3074:	6f 5f       	subi	r22, 0xFF	; 255
    3076:	7f 4f       	sbci	r23, 0xFF	; 255
    3078:	c6 01       	movw	r24, r12
    307a:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    307e:	c6 01       	movw	r24, r12
    3080:	2f 96       	adiw	r28, 0x0f	; 15
    3082:	cd bf       	out	0x3d, r28	; 61
    3084:	de bf       	out	0x3e, r29	; 62
    3086:	df 91       	pop	r29
    3088:	cf 91       	pop	r28
    308a:	1f 91       	pop	r17
    308c:	0f 91       	pop	r16
    308e:	ff 90       	pop	r15
    3090:	ef 90       	pop	r14
    3092:	df 90       	pop	r13
    3094:	cf 90       	pop	r12
    3096:	08 95       	ret

00003098 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3098:	cf 93       	push	r28
    309a:	df 93       	push	r29
    309c:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    309e:	0f b6       	in	r0, 0x3f	; 63
    30a0:	f8 94       	cli
    30a2:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    30a4:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    30a8:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    30ac:	8c 83       	std	Y+4, r24	; 0x04
    30ae:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    30b0:	0e 94 60 10 	call	0x20c0	; 0x20c0 <xTaskGetTickCount>
    30b4:	68 83       	st	Y, r22
    30b6:	79 83       	std	Y+1, r23	; 0x01
    30b8:	8a 83       	std	Y+2, r24	; 0x02
    30ba:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    30bc:	0f 90       	pop	r0
    30be:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    30c0:	ce 01       	movw	r24, r28
    30c2:	df 91       	pop	r29
    30c4:	cf 91       	pop	r28
    30c6:	08 95       	ret

000030c8 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    30c8:	5f 92       	push	r5
    30ca:	6f 92       	push	r6
    30cc:	7f 92       	push	r7
    30ce:	8f 92       	push	r8
    30d0:	9f 92       	push	r9
    30d2:	af 92       	push	r10
    30d4:	bf 92       	push	r11
    30d6:	cf 92       	push	r12
    30d8:	df 92       	push	r13
    30da:	ef 92       	push	r14
    30dc:	ff 92       	push	r15
    30de:	0f 93       	push	r16
    30e0:	1f 93       	push	r17
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	5c 01       	movw	r10, r24
    30e8:	4b 01       	movw	r8, r22
    30ea:	7a 01       	movw	r14, r20
    30ec:	12 2f       	mov	r17, r18
    30ee:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    30f0:	63 e0       	ldi	r22, 0x03	; 3
    30f2:	ca 01       	movw	r24, r20
    30f4:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    30f8:	a8 14       	cp	r10, r8
    30fa:	b9 04       	cpc	r11, r9
    30fc:	08 f0       	brcs	.+2      	; 0x3100 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    30fe:	7d c0       	rjmp	.+250    	; 0x31fa <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3100:	65 01       	movw	r12, r10
    3102:	84 e1       	ldi	r24, 0x14	; 20
    3104:	c8 0e       	add	r12, r24
    3106:	d1 1c       	adc	r13, r1
    3108:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    310a:	6a 2c       	mov	r6, r10
    310c:	5b 2c       	mov	r5, r11
    310e:	b5 01       	movw	r22, r10
    3110:	c7 01       	movw	r24, r14
    3112:	0e 94 a7 1a 	call	0x354e	; 0x354e <_ZN8emstreamlsEj>
    3116:	6a e0       	ldi	r22, 0x0A	; 10
    3118:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    311c:	65 e4       	ldi	r22, 0x45	; 69
    311e:	75 e0       	ldi	r23, 0x05	; 5
    3120:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3124:	11 23       	and	r17, r17
    3126:	09 f4       	brne	.+2      	; 0x312a <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3128:	6d c0       	rjmp	.+218    	; 0x3204 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    312a:	00 23       	and	r16, r16
    312c:	09 f4       	brne	.+2      	; 0x3130 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    312e:	6a c0       	rjmp	.+212    	; 0x3204 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3130:	6a e0       	ldi	r22, 0x0A	; 10
    3132:	c7 01       	movw	r24, r14
    3134:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    3138:	60 e4       	ldi	r22, 0x40	; 64
    313a:	75 e0       	ldi	r23, 0x05	; 5
    313c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    3140:	61 c0       	rjmp	.+194    	; 0x3204 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3142:	11 23       	and	r17, r17
    3144:	71 f0       	breq	.+28     	; 0x3162 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3146:	01 11       	cpse	r16, r1
    3148:	0c c0       	rjmp	.+24     	; 0x3162 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    314a:	88 81       	ld	r24, Y
    314c:	87 15       	cp	r24, r7
    314e:	49 f0       	breq	.+18     	; 0x3162 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3150:	6a e0       	ldi	r22, 0x0A	; 10
    3152:	c7 01       	movw	r24, r14
    3154:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    3158:	6b e3       	ldi	r22, 0x3B	; 59
    315a:	75 e0       	ldi	r23, 0x05	; 5
    315c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3160:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3162:	69 91       	ld	r22, Y+
    3164:	c7 01       	movw	r24, r14
    3166:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    316a:	dc 01       	movw	r26, r24
    316c:	ed 91       	ld	r30, X+
    316e:	fc 91       	ld	r31, X
    3170:	02 80       	ldd	r0, Z+2	; 0x02
    3172:	f3 81       	ldd	r31, Z+3	; 0x03
    3174:	e0 2d       	mov	r30, r0
    3176:	60 e2       	ldi	r22, 0x20	; 32
    3178:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    317a:	cc 16       	cp	r12, r28
    317c:	dd 06       	cpc	r13, r29
    317e:	09 f7       	brne	.-62     	; 0x3142 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3180:	11 23       	and	r17, r17
    3182:	89 f0       	breq	.+34     	; 0x31a6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3184:	6a e0       	ldi	r22, 0x0A	; 10
    3186:	c7 01       	movw	r24, r14
    3188:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    318c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    318e:	65 e3       	ldi	r22, 0x35	; 53
    3190:	75 e0       	ldi	r23, 0x05	; 5
    3192:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3196:	e8 81       	ld	r30, Y
    3198:	f9 81       	ldd	r31, Y+1	; 0x01
    319a:	02 80       	ldd	r0, Z+2	; 0x02
    319c:	f3 81       	ldd	r31, Z+3	; 0x03
    319e:	e0 2d       	mov	r30, r0
    31a0:	60 e2       	ldi	r22, 0x20	; 32
    31a2:	ce 01       	movw	r24, r28
    31a4:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    31a6:	c6 2d       	mov	r28, r6
    31a8:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    31aa:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    31ac:	80 ee       	ldi	r24, 0xE0	; 224
    31ae:	86 0f       	add	r24, r22
    31b0:	8f 35       	cpi	r24, 0x5F	; 95
    31b2:	48 f4       	brcc	.+18     	; 0x31c6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    31b4:	d7 01       	movw	r26, r14
    31b6:	ed 91       	ld	r30, X+
    31b8:	fc 91       	ld	r31, X
    31ba:	02 80       	ldd	r0, Z+2	; 0x02
    31bc:	f3 81       	ldd	r31, Z+3	; 0x03
    31be:	e0 2d       	mov	r30, r0
    31c0:	c7 01       	movw	r24, r14
    31c2:	19 95       	eicall
    31c4:	09 c0       	rjmp	.+18     	; 0x31d8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    31c6:	d7 01       	movw	r26, r14
    31c8:	ed 91       	ld	r30, X+
    31ca:	fc 91       	ld	r31, X
    31cc:	02 80       	ldd	r0, Z+2	; 0x02
    31ce:	f3 81       	ldd	r31, Z+3	; 0x03
    31d0:	e0 2d       	mov	r30, r0
    31d2:	6e e2       	ldi	r22, 0x2E	; 46
    31d4:	c7 01       	movw	r24, r14
    31d6:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    31d8:	cc 16       	cp	r12, r28
    31da:	dd 06       	cpc	r13, r29
    31dc:	31 f7       	brne	.-52     	; 0x31aa <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31de:	b4 e1       	ldi	r27, 0x14	; 20
    31e0:	ab 0e       	add	r10, r27
    31e2:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31e4:	66 e0       	ldi	r22, 0x06	; 6
    31e6:	c7 01       	movw	r24, r14
    31e8:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    31ec:	84 e1       	ldi	r24, 0x14	; 20
    31ee:	c8 0e       	add	r12, r24
    31f0:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31f2:	a8 14       	cp	r10, r8
    31f4:	b9 04       	cpc	r11, r9
    31f6:	08 f4       	brcc	.+2      	; 0x31fa <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31f8:	88 cf       	rjmp	.-240    	; 0x310a <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    31fa:	62 e0       	ldi	r22, 0x02	; 2
    31fc:	c7 01       	movw	r24, r14
    31fe:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
}
    3202:	03 c0       	rjmp	.+6      	; 0x320a <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3204:	c6 2d       	mov	r28, r6
    3206:	d5 2d       	mov	r29, r5
    3208:	9c cf       	rjmp	.-200    	; 0x3142 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    320a:	df 91       	pop	r29
    320c:	cf 91       	pop	r28
    320e:	1f 91       	pop	r17
    3210:	0f 91       	pop	r16
    3212:	ff 90       	pop	r15
    3214:	ef 90       	pop	r14
    3216:	df 90       	pop	r13
    3218:	cf 90       	pop	r12
    321a:	bf 90       	pop	r11
    321c:	af 90       	pop	r10
    321e:	9f 90       	pop	r9
    3220:	8f 90       	pop	r8
    3222:	7f 90       	pop	r7
    3224:	6f 90       	pop	r6
    3226:	5f 90       	pop	r5
    3228:	08 95       	ret

0000322a <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    322a:	0e 94 44 09 	call	0x1288	; 0x1288 <pvPortMalloc>
    322e:	08 95       	ret

00003230 <_ZdlPv>:
    3230:	00 97       	sbiw	r24, 0x00	; 0
    3232:	11 f0       	breq	.+4      	; 0x3238 <_ZdlPv+0x8>
    3234:	0e 94 de 09 	call	0x13bc	; 0x13bc <vPortFree>
    3238:	08 95       	ret

0000323a <_Znaj>:
    323a:	0e 94 44 09 	call	0x1288	; 0x1288 <pvPortMalloc>
    323e:	08 95       	ret

00003240 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3240:	08 95       	ret

00003242 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3242:	cf 93       	push	r28
    3244:	df 93       	push	r29
    3246:	fc 01       	movw	r30, r24
    3248:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    324a:	40 3a       	cpi	r20, 0xA0	; 160
    324c:	68 e0       	ldi	r22, 0x08	; 8
    324e:	56 07       	cpc	r21, r22
    3250:	49 f4       	brne	.+18     	; 0x3264 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3252:	80 e4       	ldi	r24, 0x40	; 64
    3254:	96 e0       	ldi	r25, 0x06	; 6
    3256:	82 83       	std	Z+2, r24	; 0x02
    3258:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    325a:	82 e0       	ldi	r24, 0x02	; 2
    325c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    325e:	83 e0       	ldi	r24, 0x03	; 3
    3260:	85 83       	std	Z+5, r24	; 0x05
    3262:	4c c0       	rjmp	.+152    	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3264:	40 3b       	cpi	r20, 0xB0	; 176
    3266:	78 e0       	ldi	r23, 0x08	; 8
    3268:	57 07       	cpc	r21, r23
    326a:	49 f4       	brne	.+18     	; 0x327e <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    326c:	80 e4       	ldi	r24, 0x40	; 64
    326e:	96 e0       	ldi	r25, 0x06	; 6
    3270:	82 83       	std	Z+2, r24	; 0x02
    3272:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3274:	86 e0       	ldi	r24, 0x06	; 6
    3276:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3278:	87 e0       	ldi	r24, 0x07	; 7
    327a:	85 83       	std	Z+5, r24	; 0x05
    327c:	3f c0       	rjmp	.+126    	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    327e:	40 3a       	cpi	r20, 0xA0	; 160
    3280:	89 e0       	ldi	r24, 0x09	; 9
    3282:	58 07       	cpc	r21, r24
    3284:	49 f4       	brne	.+18     	; 0x3298 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3286:	80 e6       	ldi	r24, 0x60	; 96
    3288:	96 e0       	ldi	r25, 0x06	; 6
    328a:	82 83       	std	Z+2, r24	; 0x02
    328c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    328e:	82 e0       	ldi	r24, 0x02	; 2
    3290:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3292:	83 e0       	ldi	r24, 0x03	; 3
    3294:	85 83       	std	Z+5, r24	; 0x05
    3296:	32 c0       	rjmp	.+100    	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3298:	40 3b       	cpi	r20, 0xB0	; 176
    329a:	69 e0       	ldi	r22, 0x09	; 9
    329c:	56 07       	cpc	r21, r22
    329e:	49 f4       	brne	.+18     	; 0x32b2 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    32a0:	80 e6       	ldi	r24, 0x60	; 96
    32a2:	96 e0       	ldi	r25, 0x06	; 6
    32a4:	82 83       	std	Z+2, r24	; 0x02
    32a6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    32a8:	86 e0       	ldi	r24, 0x06	; 6
    32aa:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32ac:	87 e0       	ldi	r24, 0x07	; 7
    32ae:	85 83       	std	Z+5, r24	; 0x05
    32b0:	25 c0       	rjmp	.+74     	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    32b2:	40 3a       	cpi	r20, 0xA0	; 160
    32b4:	7a e0       	ldi	r23, 0x0A	; 10
    32b6:	57 07       	cpc	r21, r23
    32b8:	49 f4       	brne	.+18     	; 0x32cc <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    32ba:	80 e8       	ldi	r24, 0x80	; 128
    32bc:	96 e0       	ldi	r25, 0x06	; 6
    32be:	82 83       	std	Z+2, r24	; 0x02
    32c0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32c2:	82 e0       	ldi	r24, 0x02	; 2
    32c4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32c6:	83 e0       	ldi	r24, 0x03	; 3
    32c8:	85 83       	std	Z+5, r24	; 0x05
    32ca:	18 c0       	rjmp	.+48     	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    32cc:	40 3b       	cpi	r20, 0xB0	; 176
    32ce:	8a e0       	ldi	r24, 0x0A	; 10
    32d0:	58 07       	cpc	r21, r24
    32d2:	49 f4       	brne	.+18     	; 0x32e6 <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    32d4:	80 e8       	ldi	r24, 0x80	; 128
    32d6:	96 e0       	ldi	r25, 0x06	; 6
    32d8:	82 83       	std	Z+2, r24	; 0x02
    32da:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    32dc:	86 e0       	ldi	r24, 0x06	; 6
    32de:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32e0:	87 e0       	ldi	r24, 0x07	; 7
    32e2:	85 83       	std	Z+5, r24	; 0x05
    32e4:	0b c0       	rjmp	.+22     	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    32e6:	40 3a       	cpi	r20, 0xA0	; 160
    32e8:	5b 40       	sbci	r21, 0x0B	; 11
    32ea:	41 f4       	brne	.+16     	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    32ec:	80 ea       	ldi	r24, 0xA0	; 160
    32ee:	96 e0       	ldi	r25, 0x06	; 6
    32f0:	82 83       	std	Z+2, r24	; 0x02
    32f2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32f4:	82 e0       	ldi	r24, 0x02	; 2
    32f6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32f8:	83 e0       	ldi	r24, 0x03	; 3
    32fa:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    32fc:	a6 83       	std	Z+6, r26	; 0x06
    32fe:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3300:	cd 01       	movw	r24, r26
    3302:	01 96       	adiw	r24, 0x01	; 1
    3304:	80 87       	std	Z+8, r24	; 0x08
    3306:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3308:	03 96       	adiw	r24, 0x03	; 3
    330a:	82 87       	std	Z+10, r24	; 0x0a
    330c:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    330e:	25 81       	ldd	r18, Z+5	; 0x05
    3310:	c2 81       	ldd	r28, Z+2	; 0x02
    3312:	d3 81       	ldd	r29, Z+3	; 0x03
    3314:	4c 81       	ldd	r20, Y+4	; 0x04
    3316:	81 e0       	ldi	r24, 0x01	; 1
    3318:	90 e0       	ldi	r25, 0x00	; 0
    331a:	bc 01       	movw	r22, r24
    331c:	02 c0       	rjmp	.+4      	; 0x3322 <_ZN7base232C1EjP12USART_struct+0xe0>
    331e:	66 0f       	add	r22, r22
    3320:	77 1f       	adc	r23, r23
    3322:	2a 95       	dec	r18
    3324:	e2 f7       	brpl	.-8      	; 0x331e <_ZN7base232C1EjP12USART_struct+0xdc>
    3326:	9b 01       	movw	r18, r22
    3328:	24 2b       	or	r18, r20
    332a:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    332c:	25 81       	ldd	r18, Z+5	; 0x05
    332e:	c2 81       	ldd	r28, Z+2	; 0x02
    3330:	d3 81       	ldd	r29, Z+3	; 0x03
    3332:	48 81       	ld	r20, Y
    3334:	bc 01       	movw	r22, r24
    3336:	02 c0       	rjmp	.+4      	; 0x333c <_ZN7base232C1EjP12USART_struct+0xfa>
    3338:	66 0f       	add	r22, r22
    333a:	77 1f       	adc	r23, r23
    333c:	2a 95       	dec	r18
    333e:	e2 f7       	brpl	.-8      	; 0x3338 <_ZN7base232C1EjP12USART_struct+0xf6>
    3340:	9b 01       	movw	r18, r22
    3342:	24 2b       	or	r18, r20
    3344:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3346:	34 81       	ldd	r19, Z+4	; 0x04
    3348:	c2 81       	ldd	r28, Z+2	; 0x02
    334a:	d3 81       	ldd	r29, Z+3	; 0x03
    334c:	28 81       	ld	r18, Y
    334e:	02 c0       	rjmp	.+4      	; 0x3354 <_ZN7base232C1EjP12USART_struct+0x112>
    3350:	88 0f       	add	r24, r24
    3352:	99 1f       	adc	r25, r25
    3354:	3a 95       	dec	r19
    3356:	e2 f7       	brpl	.-8      	; 0x3350 <_ZN7base232C1EjP12USART_struct+0x10e>
    3358:	80 95       	com	r24
    335a:	90 95       	com	r25
    335c:	82 23       	and	r24, r18
    335e:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3360:	80 e1       	ldi	r24, 0x10	; 16
    3362:	13 96       	adiw	r26, 0x03	; 3
    3364:	8c 93       	st	X, r24
    3366:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3368:	83 e0       	ldi	r24, 0x03	; 3
    336a:	15 96       	adiw	r26, 0x05	; 5
    336c:	8c 93       	st	X, r24
    336e:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3370:	80 ef       	ldi	r24, 0xF0	; 240
    3372:	17 96       	adiw	r26, 0x07	; 7
    3374:	8c 93       	st	X, r24
    3376:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3378:	81 e2       	ldi	r24, 0x21	; 33
    337a:	16 96       	adiw	r26, 0x06	; 6
    337c:	8c 93       	st	X, r24
    337e:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3380:	88 e1       	ldi	r24, 0x18	; 24
    3382:	14 96       	adiw	r26, 0x04	; 4
    3384:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3386:	80 e8       	ldi	r24, 0x80	; 128
    3388:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    338a:	80 e4       	ldi	r24, 0x40	; 64
    338c:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    338e:	80 e2       	ldi	r24, 0x20	; 32
    3390:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3392:	06 80       	ldd	r0, Z+6	; 0x06
    3394:	f7 81       	ldd	r31, Z+7	; 0x07
    3396:	e0 2d       	mov	r30, r0
    3398:	80 81       	ld	r24, Z
    339a:	80 81       	ld	r24, Z
}
    339c:	df 91       	pop	r29
    339e:	cf 91       	pop	r28
    33a0:	08 95       	ret

000033a2 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    33a2:	81 e0       	ldi	r24, 0x01	; 1
    33a4:	08 95       	ret

000033a6 <_ZN8emstream7getcharEv>:
    33a6:	80 e0       	ldi	r24, 0x00	; 0
    33a8:	90 e0       	ldi	r25, 0x00	; 0
    33aa:	08 95       	ret

000033ac <_ZN8emstream14check_for_charEv>:
    33ac:	80 e0       	ldi	r24, 0x00	; 0
    33ae:	08 95       	ret

000033b0 <_ZN8emstream12transmit_nowEv>:
    33b0:	08 95       	ret

000033b2 <_ZN8emstream12clear_screenEv>:
    33b2:	08 95       	ret

000033b4 <_ZN8emstreamC1Ev>:
    33b4:	fc 01       	movw	r30, r24
    33b6:	89 e7       	ldi	r24, 0x79	; 121
    33b8:	90 e2       	ldi	r25, 0x20	; 32
    33ba:	80 83       	st	Z, r24
    33bc:	91 83       	std	Z+1, r25	; 0x01
    33be:	8a e0       	ldi	r24, 0x0A	; 10
    33c0:	82 83       	std	Z+2, r24	; 0x02
    33c2:	13 82       	std	Z+3, r1	; 0x03
    33c4:	83 e0       	ldi	r24, 0x03	; 3
    33c6:	85 83       	std	Z+5, r24	; 0x05
    33c8:	14 82       	std	Z+4, r1	; 0x04
    33ca:	16 82       	std	Z+6, r1	; 0x06
    33cc:	17 82       	std	Z+7, r1	; 0x07
    33ce:	08 95       	ret

000033d0 <_ZN8emstream4putsEPKc>:
    33d0:	0f 93       	push	r16
    33d2:	1f 93       	push	r17
    33d4:	cf 93       	push	r28
    33d6:	df 93       	push	r29
    33d8:	8c 01       	movw	r16, r24
    33da:	fb 01       	movw	r30, r22
    33dc:	dc 01       	movw	r26, r24
    33de:	14 96       	adiw	r26, 0x04	; 4
    33e0:	8c 91       	ld	r24, X
    33e2:	81 11       	cpse	r24, r1
    33e4:	04 c0       	rjmp	.+8      	; 0x33ee <_ZN8emstream4putsEPKc+0x1e>
    33e6:	60 81       	ld	r22, Z
    33e8:	61 11       	cpse	r22, r1
    33ea:	17 c0       	rjmp	.+46     	; 0x341a <_ZN8emstream4putsEPKc+0x4a>
    33ec:	23 c0       	rjmp	.+70     	; 0x3434 <_ZN8emstream4putsEPKc+0x64>
    33ee:	d8 01       	movw	r26, r16
    33f0:	14 96       	adiw	r26, 0x04	; 4
    33f2:	1c 92       	st	X, r1
    33f4:	eb 01       	movw	r28, r22
    33f6:	21 96       	adiw	r28, 0x01	; 1
    33f8:	64 91       	lpm	r22, Z
    33fa:	66 23       	and	r22, r22
    33fc:	d9 f0       	breq	.+54     	; 0x3434 <_ZN8emstream4putsEPKc+0x64>
    33fe:	d8 01       	movw	r26, r16
    3400:	ed 91       	ld	r30, X+
    3402:	fc 91       	ld	r31, X
    3404:	02 80       	ldd	r0, Z+2	; 0x02
    3406:	f3 81       	ldd	r31, Z+3	; 0x03
    3408:	e0 2d       	mov	r30, r0
    340a:	c8 01       	movw	r24, r16
    340c:	19 95       	eicall
    340e:	fe 01       	movw	r30, r28
    3410:	64 91       	lpm	r22, Z
    3412:	21 96       	adiw	r28, 0x01	; 1
    3414:	61 11       	cpse	r22, r1
    3416:	f3 cf       	rjmp	.-26     	; 0x33fe <_ZN8emstream4putsEPKc+0x2e>
    3418:	0d c0       	rjmp	.+26     	; 0x3434 <_ZN8emstream4putsEPKc+0x64>
    341a:	ef 01       	movw	r28, r30
    341c:	21 96       	adiw	r28, 0x01	; 1
    341e:	d8 01       	movw	r26, r16
    3420:	ed 91       	ld	r30, X+
    3422:	fc 91       	ld	r31, X
    3424:	02 80       	ldd	r0, Z+2	; 0x02
    3426:	f3 81       	ldd	r31, Z+3	; 0x03
    3428:	e0 2d       	mov	r30, r0
    342a:	c8 01       	movw	r24, r16
    342c:	19 95       	eicall
    342e:	69 91       	ld	r22, Y+
    3430:	61 11       	cpse	r22, r1
    3432:	f5 cf       	rjmp	.-22     	; 0x341e <_ZN8emstream4putsEPKc+0x4e>
    3434:	df 91       	pop	r29
    3436:	cf 91       	pop	r28
    3438:	1f 91       	pop	r17
    343a:	0f 91       	pop	r16
    343c:	08 95       	ret

0000343e <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    343e:	cf 93       	push	r28
    3440:	df 93       	push	r29
    3442:	ec 01       	movw	r28, r24
	switch (new_manip)
    3444:	86 2f       	mov	r24, r22
    3446:	90 e0       	ldi	r25, 0x00	; 0
    3448:	8b 30       	cpi	r24, 0x0B	; 11
    344a:	91 05       	cpc	r25, r1
    344c:	d8 f5       	brcc	.+118    	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
    344e:	fc 01       	movw	r30, r24
    3450:	88 27       	eor	r24, r24
    3452:	e2 50       	subi	r30, 0x02	; 2
    3454:	ff 4f       	sbci	r31, 0xFF	; 255
    3456:	8f 4f       	sbci	r24, 0xFF	; 255
    3458:	0c 94 76 22 	jmp	0x44ec	; 0x44ec <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    345c:	82 e0       	ldi	r24, 0x02	; 2
    345e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3460:	31 c0       	rjmp	.+98     	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3462:	88 e0       	ldi	r24, 0x08	; 8
    3464:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3466:	2e c0       	rjmp	.+92     	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3468:	8a e0       	ldi	r24, 0x0A	; 10
    346a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    346c:	2b c0       	rjmp	.+86     	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    346e:	80 e1       	ldi	r24, 0x10	; 16
    3470:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3472:	28 c0       	rjmp	.+80     	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3474:	81 e0       	ldi	r24, 0x01	; 1
    3476:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3478:	25 c0       	rjmp	.+74     	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    347a:	1b 82       	std	Y+3, r1	; 0x03
			break;
    347c:	23 c0       	rjmp	.+70     	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    347e:	e8 81       	ld	r30, Y
    3480:	f9 81       	ldd	r31, Y+1	; 0x01
    3482:	02 80       	ldd	r0, Z+2	; 0x02
    3484:	f3 81       	ldd	r31, Z+3	; 0x03
    3486:	e0 2d       	mov	r30, r0
    3488:	6d e0       	ldi	r22, 0x0D	; 13
    348a:	ce 01       	movw	r24, r28
    348c:	19 95       	eicall
    348e:	e8 81       	ld	r30, Y
    3490:	f9 81       	ldd	r31, Y+1	; 0x01
    3492:	02 80       	ldd	r0, Z+2	; 0x02
    3494:	f3 81       	ldd	r31, Z+3	; 0x03
    3496:	e0 2d       	mov	r30, r0
    3498:	6a e0       	ldi	r22, 0x0A	; 10
    349a:	ce 01       	movw	r24, r28
    349c:	19 95       	eicall
			break;
    349e:	12 c0       	rjmp	.+36     	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    34a0:	e8 81       	ld	r30, Y
    34a2:	f9 81       	ldd	r31, Y+1	; 0x01
    34a4:	02 84       	ldd	r0, Z+10	; 0x0a
    34a6:	f3 85       	ldd	r31, Z+11	; 0x0b
    34a8:	e0 2d       	mov	r30, r0
    34aa:	ce 01       	movw	r24, r28
    34ac:	19 95       	eicall
			break;
    34ae:	0a c0       	rjmp	.+20     	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    34b0:	e8 81       	ld	r30, Y
    34b2:	f9 81       	ldd	r31, Y+1	; 0x01
    34b4:	00 84       	ldd	r0, Z+8	; 0x08
    34b6:	f1 85       	ldd	r31, Z+9	; 0x09
    34b8:	e0 2d       	mov	r30, r0
    34ba:	ce 01       	movw	r24, r28
    34bc:	19 95       	eicall
			break;
    34be:	02 c0       	rjmp	.+4      	; 0x34c4 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    34c0:	81 e0       	ldi	r24, 0x01	; 1
    34c2:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    34c4:	ce 01       	movw	r24, r28
    34c6:	df 91       	pop	r29
    34c8:	cf 91       	pop	r28
    34ca:	08 95       	ret

000034cc <_ZN8emstreamlsEb>:
 *          reference is used to string printable items together with "<<" operators
 *  @param value The boolean value to be written
 */

emstream& emstream::operator<< (bool value)
{
    34cc:	cf 93       	push	r28
    34ce:	df 93       	push	r29
    34d0:	ec 01       	movw	r28, r24
	if (value)
    34d2:	66 23       	and	r22, r22
    34d4:	41 f0       	breq	.+16     	; 0x34e6 <_ZN8emstreamlsEb+0x1a>
		putchar ('T');
    34d6:	e8 81       	ld	r30, Y
    34d8:	f9 81       	ldd	r31, Y+1	; 0x01
    34da:	02 80       	ldd	r0, Z+2	; 0x02
    34dc:	f3 81       	ldd	r31, Z+3	; 0x03
    34de:	e0 2d       	mov	r30, r0
    34e0:	64 e5       	ldi	r22, 0x54	; 84
    34e2:	19 95       	eicall
    34e4:	07 c0       	rjmp	.+14     	; 0x34f4 <_ZN8emstreamlsEb+0x28>
	else
		putchar ('F');
    34e6:	e8 81       	ld	r30, Y
    34e8:	f9 81       	ldd	r31, Y+1	; 0x01
    34ea:	02 80       	ldd	r0, Z+2	; 0x02
    34ec:	f3 81       	ldd	r31, Z+3	; 0x03
    34ee:	e0 2d       	mov	r30, r0
    34f0:	66 e4       	ldi	r22, 0x46	; 70
    34f2:	19 95       	eicall

	return (*this);
}
    34f4:	ce 01       	movw	r24, r28
    34f6:	df 91       	pop	r29
    34f8:	cf 91       	pop	r28
    34fa:	08 95       	ret

000034fc <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    34fc:	0f 93       	push	r16
    34fe:	1f 93       	push	r17
    3500:	cf 93       	push	r28
    3502:	df 93       	push	r29
    3504:	cd b7       	in	r28, 0x3d	; 61
    3506:	de b7       	in	r29, 0x3e	; 62
    3508:	61 97       	sbiw	r28, 0x11	; 17
    350a:	cd bf       	out	0x3d, r28	; 61
    350c:	de bf       	out	0x3e, r29	; 62
    350e:	8c 01       	movw	r16, r24
    3510:	9b 01       	movw	r18, r22
	if (base != 10)
    3512:	fc 01       	movw	r30, r24
    3514:	92 81       	ldd	r25, Z+2	; 0x02
    3516:	9a 30       	cpi	r25, 0x0A	; 10
    3518:	21 f0       	breq	.+8      	; 0x3522 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    351a:	c8 01       	movw	r24, r16
    351c:	0e 94 a7 1a 	call	0x354e	; 0x354e <_ZN8emstreamlsEj>
    3520:	0d c0       	rjmp	.+26     	; 0x353c <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3522:	4a e0       	ldi	r20, 0x0A	; 10
    3524:	be 01       	movw	r22, r28
    3526:	6f 5f       	subi	r22, 0xFF	; 255
    3528:	7f 4f       	sbci	r23, 0xFF	; 255
    352a:	c9 01       	movw	r24, r18
    352c:	0e 94 b8 22 	call	0x4570	; 0x4570 <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    3530:	be 01       	movw	r22, r28
    3532:	6f 5f       	subi	r22, 0xFF	; 255
    3534:	7f 4f       	sbci	r23, 0xFF	; 255
    3536:	c8 01       	movw	r24, r16
    3538:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    353c:	c8 01       	movw	r24, r16
    353e:	61 96       	adiw	r28, 0x11	; 17
    3540:	cd bf       	out	0x3d, r28	; 61
    3542:	de bf       	out	0x3e, r29	; 62
    3544:	df 91       	pop	r29
    3546:	cf 91       	pop	r28
    3548:	1f 91       	pop	r17
    354a:	0f 91       	pop	r16
    354c:	08 95       	ret

0000354e <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    354e:	ff 92       	push	r15
    3550:	0f 93       	push	r16
    3552:	1f 93       	push	r17
    3554:	cf 93       	push	r28
    3556:	df 93       	push	r29
    3558:	cd b7       	in	r28, 0x3d	; 61
    355a:	de b7       	in	r29, 0x3e	; 62
    355c:	61 97       	sbiw	r28, 0x11	; 17
    355e:	cd bf       	out	0x3d, r28	; 61
    3560:	de bf       	out	0x3e, r29	; 62
    3562:	8c 01       	movw	r16, r24
    3564:	f6 2e       	mov	r15, r22
    3566:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3568:	f8 01       	movw	r30, r16
    356a:	42 81       	ldd	r20, Z+2	; 0x02
    356c:	40 31       	cpi	r20, 0x10	; 16
    356e:	21 f0       	breq	.+8      	; 0x3578 <_ZN8emstreamlsEj+0x2a>
    3570:	48 30       	cpi	r20, 0x08	; 8
    3572:	11 f0       	breq	.+4      	; 0x3578 <_ZN8emstreamlsEj+0x2a>
    3574:	42 30       	cpi	r20, 0x02	; 2
    3576:	41 f4       	brne	.+16     	; 0x3588 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3578:	69 2f       	mov	r22, r25
    357a:	c8 01       	movw	r24, r16
    357c:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
    3580:	6f 2d       	mov	r22, r15
    3582:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
    3586:	0d c0       	rjmp	.+26     	; 0x35a2 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3588:	50 e0       	ldi	r21, 0x00	; 0
    358a:	be 01       	movw	r22, r28
    358c:	6f 5f       	subi	r22, 0xFF	; 255
    358e:	7f 4f       	sbci	r23, 0xFF	; 255
    3590:	8f 2d       	mov	r24, r15
    3592:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3596:	be 01       	movw	r22, r28
    3598:	6f 5f       	subi	r22, 0xFF	; 255
    359a:	7f 4f       	sbci	r23, 0xFF	; 255
    359c:	c8 01       	movw	r24, r16
    359e:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35a2:	c8 01       	movw	r24, r16
    35a4:	61 96       	adiw	r28, 0x11	; 17
    35a6:	cd bf       	out	0x3d, r28	; 61
    35a8:	de bf       	out	0x3e, r29	; 62
    35aa:	df 91       	pop	r29
    35ac:	cf 91       	pop	r28
    35ae:	1f 91       	pop	r17
    35b0:	0f 91       	pop	r16
    35b2:	ff 90       	pop	r15
    35b4:	08 95       	ret

000035b6 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    35b6:	df 92       	push	r13
    35b8:	ef 92       	push	r14
    35ba:	ff 92       	push	r15
    35bc:	0f 93       	push	r16
    35be:	1f 93       	push	r17
    35c0:	cf 93       	push	r28
    35c2:	df 93       	push	r29
    35c4:	cd b7       	in	r28, 0x3d	; 61
    35c6:	de b7       	in	r29, 0x3e	; 62
    35c8:	a1 97       	sbiw	r28, 0x21	; 33
    35ca:	cd bf       	out	0x3d, r28	; 61
    35cc:	de bf       	out	0x3e, r29	; 62
    35ce:	8c 01       	movw	r16, r24
    35d0:	d4 2e       	mov	r13, r20
    35d2:	e5 2e       	mov	r14, r21
    35d4:	f6 2e       	mov	r15, r22
    35d6:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    35d8:	f8 01       	movw	r30, r16
    35da:	22 81       	ldd	r18, Z+2	; 0x02
    35dc:	20 31       	cpi	r18, 0x10	; 16
    35de:	21 f0       	breq	.+8      	; 0x35e8 <_ZN8emstreamlsEm+0x32>
    35e0:	28 30       	cpi	r18, 0x08	; 8
    35e2:	11 f0       	breq	.+4      	; 0x35e8 <_ZN8emstreamlsEm+0x32>
    35e4:	22 30       	cpi	r18, 0x02	; 2
    35e6:	71 f4       	brne	.+28     	; 0x3604 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    35e8:	69 2f       	mov	r22, r25
    35ea:	c8 01       	movw	r24, r16
    35ec:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
    35f0:	6f 2d       	mov	r22, r15
    35f2:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
    35f6:	6e 2d       	mov	r22, r14
    35f8:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
    35fc:	6d 2d       	mov	r22, r13
    35fe:	0e 94 1d 1b 	call	0x363a	; 0x363a <_ZN8emstreamlsEh>
    3602:	0f c0       	rjmp	.+30     	; 0x3622 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3604:	30 e0       	ldi	r19, 0x00	; 0
    3606:	ae 01       	movw	r20, r28
    3608:	4f 5f       	subi	r20, 0xFF	; 255
    360a:	5f 4f       	sbci	r21, 0xFF	; 255
    360c:	6d 2d       	mov	r22, r13
    360e:	7e 2d       	mov	r23, r14
    3610:	8f 2d       	mov	r24, r15
    3612:	0e 94 c3 22 	call	0x4586	; 0x4586 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3616:	be 01       	movw	r22, r28
    3618:	6f 5f       	subi	r22, 0xFF	; 255
    361a:	7f 4f       	sbci	r23, 0xFF	; 255
    361c:	c8 01       	movw	r24, r16
    361e:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3622:	c8 01       	movw	r24, r16
    3624:	a1 96       	adiw	r28, 0x21	; 33
    3626:	cd bf       	out	0x3d, r28	; 61
    3628:	de bf       	out	0x3e, r29	; 62
    362a:	df 91       	pop	r29
    362c:	cf 91       	pop	r28
    362e:	1f 91       	pop	r17
    3630:	0f 91       	pop	r16
    3632:	ff 90       	pop	r15
    3634:	ef 90       	pop	r14
    3636:	df 90       	pop	r13
    3638:	08 95       	ret

0000363a <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    363a:	cf 92       	push	r12
    363c:	df 92       	push	r13
    363e:	ef 92       	push	r14
    3640:	ff 92       	push	r15
    3642:	0f 93       	push	r16
    3644:	1f 93       	push	r17
    3646:	cf 93       	push	r28
    3648:	df 93       	push	r29
    364a:	cd b7       	in	r28, 0x3d	; 61
    364c:	de b7       	in	r29, 0x3e	; 62
    364e:	29 97       	sbiw	r28, 0x09	; 9
    3650:	cd bf       	out	0x3d, r28	; 61
    3652:	de bf       	out	0x3e, r29	; 62
    3654:	8c 01       	movw	r16, r24
    3656:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3658:	dc 01       	movw	r26, r24
    365a:	13 96       	adiw	r26, 0x03	; 3
    365c:	8c 91       	ld	r24, X
    365e:	13 97       	sbiw	r26, 0x03	; 3
    3660:	88 23       	and	r24, r24
    3662:	41 f0       	breq	.+16     	; 0x3674 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3664:	ed 91       	ld	r30, X+
    3666:	fc 91       	ld	r31, X
    3668:	02 80       	ldd	r0, Z+2	; 0x02
    366a:	f3 81       	ldd	r31, Z+3	; 0x03
    366c:	e0 2d       	mov	r30, r0
    366e:	c8 01       	movw	r24, r16
    3670:	19 95       	eicall
    3672:	56 c0       	rjmp	.+172    	; 0x3720 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3674:	f8 01       	movw	r30, r16
    3676:	42 81       	ldd	r20, Z+2	; 0x02
    3678:	42 30       	cpi	r20, 0x02	; 2
    367a:	19 f5       	brne	.+70     	; 0x36c2 <_ZN8emstreamlsEh+0x88>
    367c:	68 94       	set
    367e:	cc 24       	eor	r12, r12
    3680:	c3 f8       	bld	r12, 3
    3682:	d1 2c       	mov	r13, r1
    3684:	68 94       	set
    3686:	ff 24       	eor	r15, r15
    3688:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    368a:	8e 2d       	mov	r24, r14
    368c:	8f 21       	and	r24, r15
    368e:	51 f0       	breq	.+20     	; 0x36a4 <_ZN8emstreamlsEh+0x6a>
    3690:	d8 01       	movw	r26, r16
    3692:	ed 91       	ld	r30, X+
    3694:	fc 91       	ld	r31, X
    3696:	02 80       	ldd	r0, Z+2	; 0x02
    3698:	f3 81       	ldd	r31, Z+3	; 0x03
    369a:	e0 2d       	mov	r30, r0
    369c:	61 e3       	ldi	r22, 0x31	; 49
    369e:	c8 01       	movw	r24, r16
    36a0:	19 95       	eicall
    36a2:	09 c0       	rjmp	.+18     	; 0x36b6 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    36a4:	d8 01       	movw	r26, r16
    36a6:	ed 91       	ld	r30, X+
    36a8:	fc 91       	ld	r31, X
    36aa:	02 80       	ldd	r0, Z+2	; 0x02
    36ac:	f3 81       	ldd	r31, Z+3	; 0x03
    36ae:	e0 2d       	mov	r30, r0
    36b0:	60 e3       	ldi	r22, 0x30	; 48
    36b2:	c8 01       	movw	r24, r16
    36b4:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    36b6:	f6 94       	lsr	r15
    36b8:	b1 e0       	ldi	r27, 0x01	; 1
    36ba:	cb 1a       	sub	r12, r27
    36bc:	d1 08       	sbc	r13, r1
    36be:	29 f7       	brne	.-54     	; 0x368a <_ZN8emstreamlsEh+0x50>
    36c0:	2f c0       	rjmp	.+94     	; 0x3720 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    36c2:	40 31       	cpi	r20, 0x10	; 16
    36c4:	f9 f4       	brne	.+62     	; 0x3704 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    36c6:	62 95       	swap	r22
    36c8:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    36ca:	01 90       	ld	r0, Z+
    36cc:	f0 81       	ld	r31, Z
    36ce:	e0 2d       	mov	r30, r0
    36d0:	02 80       	ldd	r0, Z+2	; 0x02
    36d2:	f3 81       	ldd	r31, Z+3	; 0x03
    36d4:	e0 2d       	mov	r30, r0
    36d6:	6a 30       	cpi	r22, 0x0A	; 10
    36d8:	10 f0       	brcs	.+4      	; 0x36de <_ZN8emstreamlsEh+0xa4>
    36da:	69 5c       	subi	r22, 0xC9	; 201
    36dc:	01 c0       	rjmp	.+2      	; 0x36e0 <_ZN8emstreamlsEh+0xa6>
    36de:	60 5d       	subi	r22, 0xD0	; 208
    36e0:	c8 01       	movw	r24, r16
    36e2:	19 95       	eicall
		temp_char = num & 0x0F;
    36e4:	6e 2d       	mov	r22, r14
    36e6:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    36e8:	d8 01       	movw	r26, r16
    36ea:	ed 91       	ld	r30, X+
    36ec:	fc 91       	ld	r31, X
    36ee:	02 80       	ldd	r0, Z+2	; 0x02
    36f0:	f3 81       	ldd	r31, Z+3	; 0x03
    36f2:	e0 2d       	mov	r30, r0
    36f4:	6a 30       	cpi	r22, 0x0A	; 10
    36f6:	10 f0       	brcs	.+4      	; 0x36fc <_ZN8emstreamlsEh+0xc2>
    36f8:	69 5c       	subi	r22, 0xC9	; 201
    36fa:	01 c0       	rjmp	.+2      	; 0x36fe <_ZN8emstreamlsEh+0xc4>
    36fc:	60 5d       	subi	r22, 0xD0	; 208
    36fe:	c8 01       	movw	r24, r16
    3700:	19 95       	eicall
    3702:	0e c0       	rjmp	.+28     	; 0x3720 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3704:	50 e0       	ldi	r21, 0x00	; 0
    3706:	be 01       	movw	r22, r28
    3708:	6f 5f       	subi	r22, 0xFF	; 255
    370a:	7f 4f       	sbci	r23, 0xFF	; 255
    370c:	8e 2d       	mov	r24, r14
    370e:	90 e0       	ldi	r25, 0x00	; 0
    3710:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3714:	be 01       	movw	r22, r28
    3716:	6f 5f       	subi	r22, 0xFF	; 255
    3718:	7f 4f       	sbci	r23, 0xFF	; 255
    371a:	c8 01       	movw	r24, r16
    371c:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3720:	c8 01       	movw	r24, r16
    3722:	29 96       	adiw	r28, 0x09	; 9
    3724:	cd bf       	out	0x3d, r28	; 61
    3726:	de bf       	out	0x3e, r29	; 62
    3728:	df 91       	pop	r29
    372a:	cf 91       	pop	r28
    372c:	1f 91       	pop	r17
    372e:	0f 91       	pop	r16
    3730:	ff 90       	pop	r15
    3732:	ef 90       	pop	r14
    3734:	df 90       	pop	r13
    3736:	cf 90       	pop	r12
    3738:	08 95       	ret

0000373a <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    373a:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    373c:	50 96       	adiw	r26, 0x10	; 16
    373e:	ed 91       	ld	r30, X+
    3740:	fc 91       	ld	r31, X
    3742:	51 97       	sbiw	r26, 0x11	; 17
    3744:	80 81       	ld	r24, Z
    3746:	54 96       	adiw	r26, 0x14	; 20
    3748:	4c 91       	ld	r20, X
    374a:	54 97       	sbiw	r26, 0x14	; 20
    374c:	84 23       	and	r24, r20
    374e:	29 f0       	breq	.+10     	; 0x375a <_ZN5rs2327putcharEc+0x20>
    3750:	09 c0       	rjmp	.+18     	; 0x3764 <_ZN5rs2327putcharEc+0x2a>
    3752:	21 50       	subi	r18, 0x01	; 1
    3754:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3756:	19 f4       	brne	.+6      	; 0x375e <_ZN5rs2327putcharEc+0x24>
    3758:	12 c0       	rjmp	.+36     	; 0x377e <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    375a:	21 e2       	ldi	r18, 0x21	; 33
    375c:	3e e4       	ldi	r19, 0x4E	; 78
    375e:	90 81       	ld	r25, Z
    3760:	94 23       	and	r25, r20
    3762:	b9 f3       	breq	.-18     	; 0x3752 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3764:	90 81       	ld	r25, Z
    3766:	56 96       	adiw	r26, 0x16	; 22
    3768:	8c 91       	ld	r24, X
    376a:	56 97       	sbiw	r26, 0x16	; 22
    376c:	89 2b       	or	r24, r25
    376e:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3770:	1e 96       	adiw	r26, 0x0e	; 14
    3772:	ed 91       	ld	r30, X+
    3774:	fc 91       	ld	r31, X
    3776:	1f 97       	sbiw	r26, 0x0f	; 15
    3778:	60 83       	st	Z, r22
	return (true);
    377a:	81 e0       	ldi	r24, 0x01	; 1
    377c:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    377e:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3780:	08 95       	ret

00003782 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3782:	cf 93       	push	r28
    3784:	df 93       	push	r29
    3786:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3788:	c1 8d       	ldd	r28, Z+25	; 0x19
    378a:	d2 8d       	ldd	r29, Z+26	; 0x1a
    378c:	28 81       	ld	r18, Y
    378e:	39 81       	ldd	r19, Y+1	; 0x01
    3790:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3792:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3794:	4d 91       	ld	r20, X+
    3796:	5c 91       	ld	r21, X
    3798:	24 17       	cp	r18, r20
    379a:	35 07       	cpc	r19, r21
    379c:	e9 f3       	breq	.-6      	; 0x3798 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    379e:	a7 89       	ldd	r26, Z+23	; 0x17
    37a0:	b0 8d       	ldd	r27, Z+24	; 0x18
    37a2:	0d 90       	ld	r0, X+
    37a4:	bc 91       	ld	r27, X
    37a6:	a0 2d       	mov	r26, r0
    37a8:	a2 0f       	add	r26, r18
    37aa:	b3 1f       	adc	r27, r19
    37ac:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    37ae:	2f 5f       	subi	r18, 0xFF	; 255
    37b0:	3f 4f       	sbci	r19, 0xFF	; 255
    37b2:	28 83       	st	Y, r18
    37b4:	39 83       	std	Y+1, r19	; 0x01
    37b6:	24 36       	cpi	r18, 0x64	; 100
    37b8:	31 05       	cpc	r19, r1
    37ba:	28 f0       	brcs	.+10     	; 0x37c6 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    37bc:	01 8c       	ldd	r0, Z+25	; 0x19
    37be:	f2 8d       	ldd	r31, Z+26	; 0x1a
    37c0:	e0 2d       	mov	r30, r0
    37c2:	10 82       	st	Z, r1
    37c4:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    37c6:	90 e0       	ldi	r25, 0x00	; 0
    37c8:	df 91       	pop	r29
    37ca:	cf 91       	pop	r28
    37cc:	08 95       	ret

000037ce <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    37ce:	cf 93       	push	r28
    37d0:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    37d2:	ec 01       	movw	r28, r24
    37d4:	a9 8d       	ldd	r26, Y+25	; 0x19
    37d6:	ba 8d       	ldd	r27, Y+26	; 0x1a
    37d8:	eb 8d       	ldd	r30, Y+27	; 0x1b
    37da:	fc 8d       	ldd	r31, Y+28	; 0x1c
    37dc:	81 e0       	ldi	r24, 0x01	; 1
    37de:	4d 91       	ld	r20, X+
    37e0:	5c 91       	ld	r21, X
    37e2:	20 81       	ld	r18, Z
    37e4:	31 81       	ldd	r19, Z+1	; 0x01
    37e6:	42 17       	cp	r20, r18
    37e8:	53 07       	cpc	r21, r19
    37ea:	09 f4       	brne	.+2      	; 0x37ee <_ZN5rs23214check_for_charEv+0x20>
    37ec:	80 e0       	ldi	r24, 0x00	; 0
}
    37ee:	df 91       	pop	r29
    37f0:	cf 91       	pop	r28
    37f2:	08 95       	ret

000037f4 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    37f4:	dc 01       	movw	r26, r24
    37f6:	ed 91       	ld	r30, X+
    37f8:	fc 91       	ld	r31, X
    37fa:	02 80       	ldd	r0, Z+2	; 0x02
    37fc:	f3 81       	ldd	r31, Z+3	; 0x03
    37fe:	e0 2d       	mov	r30, r0
    3800:	6c e0       	ldi	r22, 0x0C	; 12
    3802:	19 95       	eicall
    3804:	08 95       	ret

00003806 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3806:	ef 92       	push	r14
    3808:	ff 92       	push	r15
    380a:	0f 93       	push	r16
    380c:	1f 93       	push	r17
    380e:	cf 93       	push	r28
    3810:	df 93       	push	r29
    3812:	ec 01       	movw	r28, r24
    3814:	7b 01       	movw	r14, r22
    3816:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3818:	0e 94 da 19 	call	0x33b4	; 0x33b4 <_ZN8emstreamC1Ev>
    381c:	a8 01       	movw	r20, r16
    381e:	b7 01       	movw	r22, r14
    3820:	ce 01       	movw	r24, r28
    3822:	08 96       	adiw	r24, 0x08	; 8
    3824:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7base232C1EjP12USART_struct>
    3828:	89 e8       	ldi	r24, 0x89	; 137
    382a:	90 e2       	ldi	r25, 0x20	; 32
    382c:	88 83       	st	Y, r24
    382e:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3830:	00 3a       	cpi	r16, 0xA0	; 160
    3832:	88 e0       	ldi	r24, 0x08	; 8
    3834:	18 07       	cpc	r17, r24
    3836:	69 f4       	brne	.+26     	; 0x3852 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3838:	8e e6       	ldi	r24, 0x6E	; 110
    383a:	91 e3       	ldi	r25, 0x31	; 49
    383c:	8f 8b       	std	Y+23, r24	; 0x17
    383e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3840:	80 e6       	ldi	r24, 0x60	; 96
    3842:	91 e3       	ldi	r25, 0x31	; 49
    3844:	89 8f       	std	Y+25, r24	; 0x19
    3846:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3848:	82 e5       	ldi	r24, 0x52	; 82
    384a:	91 e3       	ldi	r25, 0x31	; 49
    384c:	8b 8f       	std	Y+27, r24	; 0x1b
    384e:	9c 8f       	std	Y+28, r25	; 0x1c
    3850:	64 c0       	rjmp	.+200    	; 0x391a <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3852:	00 3b       	cpi	r16, 0xB0	; 176
    3854:	e8 e0       	ldi	r30, 0x08	; 8
    3856:	1e 07       	cpc	r17, r30
    3858:	69 f4       	brne	.+26     	; 0x3874 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    385a:	8c e6       	ldi	r24, 0x6C	; 108
    385c:	91 e3       	ldi	r25, 0x31	; 49
    385e:	8f 8b       	std	Y+23, r24	; 0x17
    3860:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3862:	8e e5       	ldi	r24, 0x5E	; 94
    3864:	91 e3       	ldi	r25, 0x31	; 49
    3866:	89 8f       	std	Y+25, r24	; 0x19
    3868:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    386a:	80 e5       	ldi	r24, 0x50	; 80
    386c:	91 e3       	ldi	r25, 0x31	; 49
    386e:	8b 8f       	std	Y+27, r24	; 0x1b
    3870:	9c 8f       	std	Y+28, r25	; 0x1c
    3872:	53 c0       	rjmp	.+166    	; 0x391a <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3874:	00 3a       	cpi	r16, 0xA0	; 160
    3876:	f9 e0       	ldi	r31, 0x09	; 9
    3878:	1f 07       	cpc	r17, r31
    387a:	69 f4       	brne	.+26     	; 0x3896 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    387c:	8a e6       	ldi	r24, 0x6A	; 106
    387e:	91 e3       	ldi	r25, 0x31	; 49
    3880:	8f 8b       	std	Y+23, r24	; 0x17
    3882:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3884:	8c e5       	ldi	r24, 0x5C	; 92
    3886:	91 e3       	ldi	r25, 0x31	; 49
    3888:	89 8f       	std	Y+25, r24	; 0x19
    388a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    388c:	8e e4       	ldi	r24, 0x4E	; 78
    388e:	91 e3       	ldi	r25, 0x31	; 49
    3890:	8b 8f       	std	Y+27, r24	; 0x1b
    3892:	9c 8f       	std	Y+28, r25	; 0x1c
    3894:	42 c0       	rjmp	.+132    	; 0x391a <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3896:	00 3b       	cpi	r16, 0xB0	; 176
    3898:	89 e0       	ldi	r24, 0x09	; 9
    389a:	18 07       	cpc	r17, r24
    389c:	69 f4       	brne	.+26     	; 0x38b8 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    389e:	88 e6       	ldi	r24, 0x68	; 104
    38a0:	91 e3       	ldi	r25, 0x31	; 49
    38a2:	8f 8b       	std	Y+23, r24	; 0x17
    38a4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    38a6:	8a e5       	ldi	r24, 0x5A	; 90
    38a8:	91 e3       	ldi	r25, 0x31	; 49
    38aa:	89 8f       	std	Y+25, r24	; 0x19
    38ac:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    38ae:	8c e4       	ldi	r24, 0x4C	; 76
    38b0:	91 e3       	ldi	r25, 0x31	; 49
    38b2:	8b 8f       	std	Y+27, r24	; 0x1b
    38b4:	9c 8f       	std	Y+28, r25	; 0x1c
    38b6:	31 c0       	rjmp	.+98     	; 0x391a <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    38b8:	00 3a       	cpi	r16, 0xA0	; 160
    38ba:	ea e0       	ldi	r30, 0x0A	; 10
    38bc:	1e 07       	cpc	r17, r30
    38be:	69 f4       	brne	.+26     	; 0x38da <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    38c0:	86 e6       	ldi	r24, 0x66	; 102
    38c2:	91 e3       	ldi	r25, 0x31	; 49
    38c4:	8f 8b       	std	Y+23, r24	; 0x17
    38c6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    38c8:	88 e5       	ldi	r24, 0x58	; 88
    38ca:	91 e3       	ldi	r25, 0x31	; 49
    38cc:	89 8f       	std	Y+25, r24	; 0x19
    38ce:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    38d0:	8a e4       	ldi	r24, 0x4A	; 74
    38d2:	91 e3       	ldi	r25, 0x31	; 49
    38d4:	8b 8f       	std	Y+27, r24	; 0x1b
    38d6:	9c 8f       	std	Y+28, r25	; 0x1c
    38d8:	20 c0       	rjmp	.+64     	; 0x391a <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    38da:	00 3b       	cpi	r16, 0xB0	; 176
    38dc:	fa e0       	ldi	r31, 0x0A	; 10
    38de:	1f 07       	cpc	r17, r31
    38e0:	69 f4       	brne	.+26     	; 0x38fc <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    38e2:	84 e6       	ldi	r24, 0x64	; 100
    38e4:	91 e3       	ldi	r25, 0x31	; 49
    38e6:	8f 8b       	std	Y+23, r24	; 0x17
    38e8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    38ea:	86 e5       	ldi	r24, 0x56	; 86
    38ec:	91 e3       	ldi	r25, 0x31	; 49
    38ee:	89 8f       	std	Y+25, r24	; 0x19
    38f0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    38f2:	88 e4       	ldi	r24, 0x48	; 72
    38f4:	91 e3       	ldi	r25, 0x31	; 49
    38f6:	8b 8f       	std	Y+27, r24	; 0x1b
    38f8:	9c 8f       	std	Y+28, r25	; 0x1c
    38fa:	0f c0       	rjmp	.+30     	; 0x391a <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    38fc:	00 3a       	cpi	r16, 0xA0	; 160
    38fe:	1b 40       	sbci	r17, 0x0B	; 11
    3900:	61 f4       	brne	.+24     	; 0x391a <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    3902:	82 e6       	ldi	r24, 0x62	; 98
    3904:	91 e3       	ldi	r25, 0x31	; 49
    3906:	8f 8b       	std	Y+23, r24	; 0x17
    3908:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    390a:	84 e5       	ldi	r24, 0x54	; 84
    390c:	91 e3       	ldi	r25, 0x31	; 49
    390e:	89 8f       	std	Y+25, r24	; 0x19
    3910:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    3912:	86 e4       	ldi	r24, 0x46	; 70
    3914:	91 e3       	ldi	r25, 0x31	; 49
    3916:	8b 8f       	std	Y+27, r24	; 0x1b
    3918:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    391a:	0f 89       	ldd	r16, Y+23	; 0x17
    391c:	18 8d       	ldd	r17, Y+24	; 0x18
    391e:	84 e6       	ldi	r24, 0x64	; 100
    3920:	90 e0       	ldi	r25, 0x00	; 0
    3922:	0e 94 1d 19 	call	0x323a	; 0x323a <_Znaj>
    3926:	f8 01       	movw	r30, r16
    3928:	80 83       	st	Z, r24
    392a:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    392c:	e9 8d       	ldd	r30, Y+25	; 0x19
    392e:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3930:	10 82       	st	Z, r1
    3932:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3934:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3936:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3938:	10 82       	st	Z, r1
    393a:	11 82       	std	Z+1, r1	; 0x01
}
    393c:	df 91       	pop	r29
    393e:	cf 91       	pop	r28
    3940:	1f 91       	pop	r17
    3942:	0f 91       	pop	r16
    3944:	ff 90       	pop	r15
    3946:	ef 90       	pop	r14
    3948:	08 95       	ret

0000394a <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    394a:	1f 92       	push	r1
    394c:	0f 92       	push	r0
    394e:	0f b6       	in	r0, 0x3f	; 63
    3950:	0f 92       	push	r0
    3952:	11 24       	eor	r1, r1
    3954:	08 b6       	in	r0, 0x38	; 56
    3956:	0f 92       	push	r0
    3958:	18 be       	out	0x38, r1	; 56
    395a:	0b b6       	in	r0, 0x3b	; 59
    395c:	0f 92       	push	r0
    395e:	1b be       	out	0x3b, r1	; 59
    3960:	2f 93       	push	r18
    3962:	3f 93       	push	r19
    3964:	8f 93       	push	r24
    3966:	9f 93       	push	r25
    3968:	ef 93       	push	r30
    396a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    396c:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3970:	e0 91 6e 31 	lds	r30, 0x316E	; 0x80316e <rcvC0_buffer>
    3974:	f0 91 6f 31 	lds	r31, 0x316F	; 0x80316f <rcvC0_buffer+0x1>
    3978:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    397c:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    3980:	e8 0f       	add	r30, r24
    3982:	f9 1f       	adc	r31, r25
    3984:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3986:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    398a:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    398e:	01 96       	adiw	r24, 0x01	; 1
    3990:	84 36       	cpi	r24, 0x64	; 100
    3992:	91 05       	cpc	r25, r1
    3994:	60 f4       	brcc	.+24     	; 0x39ae <__vector_25+0x64>
    3996:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <rcvC0_write_index>
    399a:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    399e:	20 91 60 31 	lds	r18, 0x3160	; 0x803160 <rcvC0_read_index>
    39a2:	30 91 61 31 	lds	r19, 0x3161	; 0x803161 <rcvC0_read_index+0x1>
    39a6:	82 17       	cp	r24, r18
    39a8:	93 07       	cpc	r25, r19
    39aa:	f1 f4       	brne	.+60     	; 0x39e8 <__vector_25+0x9e>
    39ac:	0c c0       	rjmp	.+24     	; 0x39c6 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    39ae:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <rcvC0_write_index>
    39b2:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    39b6:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvC0_read_index>
    39ba:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvC0_read_index+0x1>
    39be:	18 16       	cp	r1, r24
    39c0:	19 06       	cpc	r1, r25
    39c2:	91 f4       	brne	.+36     	; 0x39e8 <__vector_25+0x9e>
    39c4:	0e c0       	rjmp	.+28     	; 0x39e2 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    39c6:	01 96       	adiw	r24, 0x01	; 1
    39c8:	84 36       	cpi	r24, 0x64	; 100
    39ca:	91 05       	cpc	r25, r1
    39cc:	28 f4       	brcc	.+10     	; 0x39d8 <__vector_25+0x8e>
    39ce:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <rcvC0_read_index>
    39d2:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <rcvC0_read_index+0x1>
    39d6:	08 c0       	rjmp	.+16     	; 0x39e8 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    39d8:	10 92 60 31 	sts	0x3160, r1	; 0x803160 <rcvC0_read_index>
    39dc:	10 92 61 31 	sts	0x3161, r1	; 0x803161 <rcvC0_read_index+0x1>
}
    39e0:	03 c0       	rjmp	.+6      	; 0x39e8 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    39e2:	81 e0       	ldi	r24, 0x01	; 1
    39e4:	90 e0       	ldi	r25, 0x00	; 0
    39e6:	f3 cf       	rjmp	.-26     	; 0x39ce <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    39e8:	ff 91       	pop	r31
    39ea:	ef 91       	pop	r30
    39ec:	9f 91       	pop	r25
    39ee:	8f 91       	pop	r24
    39f0:	3f 91       	pop	r19
    39f2:	2f 91       	pop	r18
    39f4:	0f 90       	pop	r0
    39f6:	0b be       	out	0x3b, r0	; 59
    39f8:	0f 90       	pop	r0
    39fa:	08 be       	out	0x38, r0	; 56
    39fc:	0f 90       	pop	r0
    39fe:	0f be       	out	0x3f, r0	; 63
    3a00:	0f 90       	pop	r0
    3a02:	1f 90       	pop	r1
    3a04:	18 95       	reti

00003a06 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3a06:	1f 92       	push	r1
    3a08:	0f 92       	push	r0
    3a0a:	0f b6       	in	r0, 0x3f	; 63
    3a0c:	0f 92       	push	r0
    3a0e:	11 24       	eor	r1, r1
    3a10:	08 b6       	in	r0, 0x38	; 56
    3a12:	0f 92       	push	r0
    3a14:	18 be       	out	0x38, r1	; 56
    3a16:	0b b6       	in	r0, 0x3b	; 59
    3a18:	0f 92       	push	r0
    3a1a:	1b be       	out	0x3b, r1	; 59
    3a1c:	2f 93       	push	r18
    3a1e:	3f 93       	push	r19
    3a20:	8f 93       	push	r24
    3a22:	9f 93       	push	r25
    3a24:	ef 93       	push	r30
    3a26:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3a28:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3a2c:	e0 91 6c 31 	lds	r30, 0x316C	; 0x80316c <rcvC1_buffer>
    3a30:	f0 91 6d 31 	lds	r31, 0x316D	; 0x80316d <rcvC1_buffer+0x1>
    3a34:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC1_write_index>
    3a38:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC1_write_index+0x1>
    3a3c:	e8 0f       	add	r30, r24
    3a3e:	f9 1f       	adc	r31, r25
    3a40:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3a42:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC1_write_index>
    3a46:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC1_write_index+0x1>
    3a4a:	01 96       	adiw	r24, 0x01	; 1
    3a4c:	84 36       	cpi	r24, 0x64	; 100
    3a4e:	91 05       	cpc	r25, r1
    3a50:	60 f4       	brcc	.+24     	; 0x3a6a <__vector_28+0x64>
    3a52:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvC1_write_index>
    3a56:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3a5a:	20 91 5e 31 	lds	r18, 0x315E	; 0x80315e <rcvC1_read_index>
    3a5e:	30 91 5f 31 	lds	r19, 0x315F	; 0x80315f <rcvC1_read_index+0x1>
    3a62:	82 17       	cp	r24, r18
    3a64:	93 07       	cpc	r25, r19
    3a66:	f1 f4       	brne	.+60     	; 0x3aa4 <__vector_28+0x9e>
    3a68:	0c c0       	rjmp	.+24     	; 0x3a82 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3a6a:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvC1_write_index>
    3a6e:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3a72:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvC1_read_index>
    3a76:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvC1_read_index+0x1>
    3a7a:	18 16       	cp	r1, r24
    3a7c:	19 06       	cpc	r1, r25
    3a7e:	91 f4       	brne	.+36     	; 0x3aa4 <__vector_28+0x9e>
    3a80:	0e c0       	rjmp	.+28     	; 0x3a9e <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a82:	01 96       	adiw	r24, 0x01	; 1
    3a84:	84 36       	cpi	r24, 0x64	; 100
    3a86:	91 05       	cpc	r25, r1
    3a88:	28 f4       	brcc	.+10     	; 0x3a94 <__vector_28+0x8e>
    3a8a:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <rcvC1_read_index>
    3a8e:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <rcvC1_read_index+0x1>
    3a92:	08 c0       	rjmp	.+16     	; 0x3aa4 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3a94:	10 92 5e 31 	sts	0x315E, r1	; 0x80315e <rcvC1_read_index>
    3a98:	10 92 5f 31 	sts	0x315F, r1	; 0x80315f <rcvC1_read_index+0x1>
}
    3a9c:	03 c0       	rjmp	.+6      	; 0x3aa4 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a9e:	81 e0       	ldi	r24, 0x01	; 1
    3aa0:	90 e0       	ldi	r25, 0x00	; 0
    3aa2:	f3 cf       	rjmp	.-26     	; 0x3a8a <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3aa4:	ff 91       	pop	r31
    3aa6:	ef 91       	pop	r30
    3aa8:	9f 91       	pop	r25
    3aaa:	8f 91       	pop	r24
    3aac:	3f 91       	pop	r19
    3aae:	2f 91       	pop	r18
    3ab0:	0f 90       	pop	r0
    3ab2:	0b be       	out	0x3b, r0	; 59
    3ab4:	0f 90       	pop	r0
    3ab6:	08 be       	out	0x38, r0	; 56
    3ab8:	0f 90       	pop	r0
    3aba:	0f be       	out	0x3f, r0	; 63
    3abc:	0f 90       	pop	r0
    3abe:	1f 90       	pop	r1
    3ac0:	18 95       	reti

00003ac2 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3ac2:	1f 92       	push	r1
    3ac4:	0f 92       	push	r0
    3ac6:	0f b6       	in	r0, 0x3f	; 63
    3ac8:	0f 92       	push	r0
    3aca:	11 24       	eor	r1, r1
    3acc:	08 b6       	in	r0, 0x38	; 56
    3ace:	0f 92       	push	r0
    3ad0:	18 be       	out	0x38, r1	; 56
    3ad2:	0b b6       	in	r0, 0x3b	; 59
    3ad4:	0f 92       	push	r0
    3ad6:	1b be       	out	0x3b, r1	; 59
    3ad8:	2f 93       	push	r18
    3ada:	3f 93       	push	r19
    3adc:	8f 93       	push	r24
    3ade:	9f 93       	push	r25
    3ae0:	ef 93       	push	r30
    3ae2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3ae4:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3ae8:	e0 91 6a 31 	lds	r30, 0x316A	; 0x80316a <rcvD0_buffer>
    3aec:	f0 91 6b 31 	lds	r31, 0x316B	; 0x80316b <rcvD0_buffer+0x1>
    3af0:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    3af4:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    3af8:	e8 0f       	add	r30, r24
    3afa:	f9 1f       	adc	r31, r25
    3afc:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3afe:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvD0_write_index>
    3b02:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvD0_write_index+0x1>
    3b06:	01 96       	adiw	r24, 0x01	; 1
    3b08:	84 36       	cpi	r24, 0x64	; 100
    3b0a:	91 05       	cpc	r25, r1
    3b0c:	60 f4       	brcc	.+24     	; 0x3b26 <__vector_88+0x64>
    3b0e:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvD0_write_index>
    3b12:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3b16:	20 91 5c 31 	lds	r18, 0x315C	; 0x80315c <rcvD0_read_index>
    3b1a:	30 91 5d 31 	lds	r19, 0x315D	; 0x80315d <rcvD0_read_index+0x1>
    3b1e:	82 17       	cp	r24, r18
    3b20:	93 07       	cpc	r25, r19
    3b22:	f1 f4       	brne	.+60     	; 0x3b60 <__vector_88+0x9e>
    3b24:	0c c0       	rjmp	.+24     	; 0x3b3e <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3b26:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvD0_write_index>
    3b2a:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3b2e:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvD0_read_index>
    3b32:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvD0_read_index+0x1>
    3b36:	18 16       	cp	r1, r24
    3b38:	19 06       	cpc	r1, r25
    3b3a:	91 f4       	brne	.+36     	; 0x3b60 <__vector_88+0x9e>
    3b3c:	0e c0       	rjmp	.+28     	; 0x3b5a <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3b3e:	01 96       	adiw	r24, 0x01	; 1
    3b40:	84 36       	cpi	r24, 0x64	; 100
    3b42:	91 05       	cpc	r25, r1
    3b44:	28 f4       	brcc	.+10     	; 0x3b50 <__vector_88+0x8e>
    3b46:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvD0_read_index>
    3b4a:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvD0_read_index+0x1>
    3b4e:	08 c0       	rjmp	.+16     	; 0x3b60 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3b50:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvD0_read_index>
    3b54:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvD0_read_index+0x1>
}
    3b58:	03 c0       	rjmp	.+6      	; 0x3b60 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3b5a:	81 e0       	ldi	r24, 0x01	; 1
    3b5c:	90 e0       	ldi	r25, 0x00	; 0
    3b5e:	f3 cf       	rjmp	.-26     	; 0x3b46 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3b60:	ff 91       	pop	r31
    3b62:	ef 91       	pop	r30
    3b64:	9f 91       	pop	r25
    3b66:	8f 91       	pop	r24
    3b68:	3f 91       	pop	r19
    3b6a:	2f 91       	pop	r18
    3b6c:	0f 90       	pop	r0
    3b6e:	0b be       	out	0x3b, r0	; 59
    3b70:	0f 90       	pop	r0
    3b72:	08 be       	out	0x38, r0	; 56
    3b74:	0f 90       	pop	r0
    3b76:	0f be       	out	0x3f, r0	; 63
    3b78:	0f 90       	pop	r0
    3b7a:	1f 90       	pop	r1
    3b7c:	18 95       	reti

00003b7e <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3b7e:	1f 92       	push	r1
    3b80:	0f 92       	push	r0
    3b82:	0f b6       	in	r0, 0x3f	; 63
    3b84:	0f 92       	push	r0
    3b86:	11 24       	eor	r1, r1
    3b88:	08 b6       	in	r0, 0x38	; 56
    3b8a:	0f 92       	push	r0
    3b8c:	18 be       	out	0x38, r1	; 56
    3b8e:	0b b6       	in	r0, 0x3b	; 59
    3b90:	0f 92       	push	r0
    3b92:	1b be       	out	0x3b, r1	; 59
    3b94:	2f 93       	push	r18
    3b96:	3f 93       	push	r19
    3b98:	8f 93       	push	r24
    3b9a:	9f 93       	push	r25
    3b9c:	ef 93       	push	r30
    3b9e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3ba0:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3ba4:	e0 91 68 31 	lds	r30, 0x3168	; 0x803168 <rcvD1_buffer>
    3ba8:	f0 91 69 31 	lds	r31, 0x3169	; 0x803169 <rcvD1_buffer+0x1>
    3bac:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD1_write_index>
    3bb0:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD1_write_index+0x1>
    3bb4:	e8 0f       	add	r30, r24
    3bb6:	f9 1f       	adc	r31, r25
    3bb8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3bba:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD1_write_index>
    3bbe:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD1_write_index+0x1>
    3bc2:	01 96       	adiw	r24, 0x01	; 1
    3bc4:	84 36       	cpi	r24, 0x64	; 100
    3bc6:	91 05       	cpc	r25, r1
    3bc8:	60 f4       	brcc	.+24     	; 0x3be2 <__vector_91+0x64>
    3bca:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvD1_write_index>
    3bce:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3bd2:	20 91 5a 31 	lds	r18, 0x315A	; 0x80315a <rcvD1_read_index>
    3bd6:	30 91 5b 31 	lds	r19, 0x315B	; 0x80315b <rcvD1_read_index+0x1>
    3bda:	82 17       	cp	r24, r18
    3bdc:	93 07       	cpc	r25, r19
    3bde:	f1 f4       	brne	.+60     	; 0x3c1c <__vector_91+0x9e>
    3be0:	0c c0       	rjmp	.+24     	; 0x3bfa <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3be2:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvD1_write_index>
    3be6:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3bea:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvD1_read_index>
    3bee:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvD1_read_index+0x1>
    3bf2:	18 16       	cp	r1, r24
    3bf4:	19 06       	cpc	r1, r25
    3bf6:	91 f4       	brne	.+36     	; 0x3c1c <__vector_91+0x9e>
    3bf8:	0e c0       	rjmp	.+28     	; 0x3c16 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3bfa:	01 96       	adiw	r24, 0x01	; 1
    3bfc:	84 36       	cpi	r24, 0x64	; 100
    3bfe:	91 05       	cpc	r25, r1
    3c00:	28 f4       	brcc	.+10     	; 0x3c0c <__vector_91+0x8e>
    3c02:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvD1_read_index>
    3c06:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvD1_read_index+0x1>
    3c0a:	08 c0       	rjmp	.+16     	; 0x3c1c <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3c0c:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvD1_read_index>
    3c10:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvD1_read_index+0x1>
}
    3c14:	03 c0       	rjmp	.+6      	; 0x3c1c <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3c16:	81 e0       	ldi	r24, 0x01	; 1
    3c18:	90 e0       	ldi	r25, 0x00	; 0
    3c1a:	f3 cf       	rjmp	.-26     	; 0x3c02 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3c1c:	ff 91       	pop	r31
    3c1e:	ef 91       	pop	r30
    3c20:	9f 91       	pop	r25
    3c22:	8f 91       	pop	r24
    3c24:	3f 91       	pop	r19
    3c26:	2f 91       	pop	r18
    3c28:	0f 90       	pop	r0
    3c2a:	0b be       	out	0x3b, r0	; 59
    3c2c:	0f 90       	pop	r0
    3c2e:	08 be       	out	0x38, r0	; 56
    3c30:	0f 90       	pop	r0
    3c32:	0f be       	out	0x3f, r0	; 63
    3c34:	0f 90       	pop	r0
    3c36:	1f 90       	pop	r1
    3c38:	18 95       	reti

00003c3a <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3c3a:	1f 92       	push	r1
    3c3c:	0f 92       	push	r0
    3c3e:	0f b6       	in	r0, 0x3f	; 63
    3c40:	0f 92       	push	r0
    3c42:	11 24       	eor	r1, r1
    3c44:	08 b6       	in	r0, 0x38	; 56
    3c46:	0f 92       	push	r0
    3c48:	18 be       	out	0x38, r1	; 56
    3c4a:	0b b6       	in	r0, 0x3b	; 59
    3c4c:	0f 92       	push	r0
    3c4e:	1b be       	out	0x3b, r1	; 59
    3c50:	2f 93       	push	r18
    3c52:	3f 93       	push	r19
    3c54:	8f 93       	push	r24
    3c56:	9f 93       	push	r25
    3c58:	ef 93       	push	r30
    3c5a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3c5c:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3c60:	e0 91 66 31 	lds	r30, 0x3166	; 0x803166 <rcvE0_buffer>
    3c64:	f0 91 67 31 	lds	r31, 0x3167	; 0x803167 <rcvE0_buffer+0x1>
    3c68:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvE0_write_index>
    3c6c:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvE0_write_index+0x1>
    3c70:	e8 0f       	add	r30, r24
    3c72:	f9 1f       	adc	r31, r25
    3c74:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3c76:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvE0_write_index>
    3c7a:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvE0_write_index+0x1>
    3c7e:	01 96       	adiw	r24, 0x01	; 1
    3c80:	84 36       	cpi	r24, 0x64	; 100
    3c82:	91 05       	cpc	r25, r1
    3c84:	60 f4       	brcc	.+24     	; 0x3c9e <__vector_58+0x64>
    3c86:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <rcvE0_write_index>
    3c8a:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c8e:	20 91 58 31 	lds	r18, 0x3158	; 0x803158 <rcvE0_read_index>
    3c92:	30 91 59 31 	lds	r19, 0x3159	; 0x803159 <rcvE0_read_index+0x1>
    3c96:	82 17       	cp	r24, r18
    3c98:	93 07       	cpc	r25, r19
    3c9a:	f1 f4       	brne	.+60     	; 0x3cd8 <__vector_58+0x9e>
    3c9c:	0c c0       	rjmp	.+24     	; 0x3cb6 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3c9e:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <rcvE0_write_index>
    3ca2:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3ca6:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvE0_read_index>
    3caa:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvE0_read_index+0x1>
    3cae:	18 16       	cp	r1, r24
    3cb0:	19 06       	cpc	r1, r25
    3cb2:	91 f4       	brne	.+36     	; 0x3cd8 <__vector_58+0x9e>
    3cb4:	0e c0       	rjmp	.+28     	; 0x3cd2 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3cb6:	01 96       	adiw	r24, 0x01	; 1
    3cb8:	84 36       	cpi	r24, 0x64	; 100
    3cba:	91 05       	cpc	r25, r1
    3cbc:	28 f4       	brcc	.+10     	; 0x3cc8 <__vector_58+0x8e>
    3cbe:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvE0_read_index>
    3cc2:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvE0_read_index+0x1>
    3cc6:	08 c0       	rjmp	.+16     	; 0x3cd8 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3cc8:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvE0_read_index>
    3ccc:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvE0_read_index+0x1>
}
    3cd0:	03 c0       	rjmp	.+6      	; 0x3cd8 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3cd2:	81 e0       	ldi	r24, 0x01	; 1
    3cd4:	90 e0       	ldi	r25, 0x00	; 0
    3cd6:	f3 cf       	rjmp	.-26     	; 0x3cbe <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3cd8:	ff 91       	pop	r31
    3cda:	ef 91       	pop	r30
    3cdc:	9f 91       	pop	r25
    3cde:	8f 91       	pop	r24
    3ce0:	3f 91       	pop	r19
    3ce2:	2f 91       	pop	r18
    3ce4:	0f 90       	pop	r0
    3ce6:	0b be       	out	0x3b, r0	; 59
    3ce8:	0f 90       	pop	r0
    3cea:	08 be       	out	0x38, r0	; 56
    3cec:	0f 90       	pop	r0
    3cee:	0f be       	out	0x3f, r0	; 63
    3cf0:	0f 90       	pop	r0
    3cf2:	1f 90       	pop	r1
    3cf4:	18 95       	reti

00003cf6 <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    3cf6:	1f 92       	push	r1
    3cf8:	0f 92       	push	r0
    3cfa:	0f b6       	in	r0, 0x3f	; 63
    3cfc:	0f 92       	push	r0
    3cfe:	11 24       	eor	r1, r1
    3d00:	08 b6       	in	r0, 0x38	; 56
    3d02:	0f 92       	push	r0
    3d04:	18 be       	out	0x38, r1	; 56
    3d06:	0b b6       	in	r0, 0x3b	; 59
    3d08:	0f 92       	push	r0
    3d0a:	1b be       	out	0x3b, r1	; 59
    3d0c:	2f 93       	push	r18
    3d0e:	3f 93       	push	r19
    3d10:	8f 93       	push	r24
    3d12:	9f 93       	push	r25
    3d14:	ef 93       	push	r30
    3d16:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    3d18:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    3d1c:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <rcvE1_buffer>
    3d20:	f0 91 65 31 	lds	r31, 0x3165	; 0x803165 <rcvE1_buffer+0x1>
    3d24:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvE1_write_index>
    3d28:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvE1_write_index+0x1>
    3d2c:	e8 0f       	add	r30, r24
    3d2e:	f9 1f       	adc	r31, r25
    3d30:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    3d32:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvE1_write_index>
    3d36:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvE1_write_index+0x1>
    3d3a:	01 96       	adiw	r24, 0x01	; 1
    3d3c:	84 36       	cpi	r24, 0x64	; 100
    3d3e:	91 05       	cpc	r25, r1
    3d40:	60 f4       	brcc	.+24     	; 0x3d5a <__vector_61+0x64>
    3d42:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <rcvE1_write_index>
    3d46:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3d4a:	20 91 56 31 	lds	r18, 0x3156	; 0x803156 <rcvE1_read_index>
    3d4e:	30 91 57 31 	lds	r19, 0x3157	; 0x803157 <rcvE1_read_index+0x1>
    3d52:	82 17       	cp	r24, r18
    3d54:	93 07       	cpc	r25, r19
    3d56:	f1 f4       	brne	.+60     	; 0x3d94 <__vector_61+0x9e>
    3d58:	0c c0       	rjmp	.+24     	; 0x3d72 <__vector_61+0x7c>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    3d5a:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rcvE1_write_index>
    3d5e:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3d62:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvE1_read_index>
    3d66:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvE1_read_index+0x1>
    3d6a:	18 16       	cp	r1, r24
    3d6c:	19 06       	cpc	r1, r25
    3d6e:	91 f4       	brne	.+36     	; 0x3d94 <__vector_61+0x9e>
    3d70:	0e c0       	rjmp	.+28     	; 0x3d8e <__vector_61+0x98>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3d72:	01 96       	adiw	r24, 0x01	; 1
    3d74:	84 36       	cpi	r24, 0x64	; 100
    3d76:	91 05       	cpc	r25, r1
    3d78:	28 f4       	brcc	.+10     	; 0x3d84 <__vector_61+0x8e>
    3d7a:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvE1_read_index>
    3d7e:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvE1_read_index+0x1>
    3d82:	08 c0       	rjmp	.+16     	; 0x3d94 <__vector_61+0x9e>
	rcvE1_read_index = 0;
    3d84:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvE1_read_index>
    3d88:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvE1_read_index+0x1>
}
    3d8c:	03 c0       	rjmp	.+6      	; 0x3d94 <__vector_61+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3d8e:	81 e0       	ldi	r24, 0x01	; 1
    3d90:	90 e0       	ldi	r25, 0x00	; 0
    3d92:	f3 cf       	rjmp	.-26     	; 0x3d7a <__vector_61+0x84>
	rcvE1_read_index = 0;
}
    3d94:	ff 91       	pop	r31
    3d96:	ef 91       	pop	r30
    3d98:	9f 91       	pop	r25
    3d9a:	8f 91       	pop	r24
    3d9c:	3f 91       	pop	r19
    3d9e:	2f 91       	pop	r18
    3da0:	0f 90       	pop	r0
    3da2:	0b be       	out	0x3b, r0	; 59
    3da4:	0f 90       	pop	r0
    3da6:	08 be       	out	0x38, r0	; 56
    3da8:	0f 90       	pop	r0
    3daa:	0f be       	out	0x3f, r0	; 63
    3dac:	0f 90       	pop	r0
    3dae:	1f 90       	pop	r1
    3db0:	18 95       	reti

00003db2 <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    3db2:	1f 92       	push	r1
    3db4:	0f 92       	push	r0
    3db6:	0f b6       	in	r0, 0x3f	; 63
    3db8:	0f 92       	push	r0
    3dba:	11 24       	eor	r1, r1
    3dbc:	08 b6       	in	r0, 0x38	; 56
    3dbe:	0f 92       	push	r0
    3dc0:	18 be       	out	0x38, r1	; 56
    3dc2:	0b b6       	in	r0, 0x3b	; 59
    3dc4:	0f 92       	push	r0
    3dc6:	1b be       	out	0x3b, r1	; 59
    3dc8:	2f 93       	push	r18
    3dca:	3f 93       	push	r19
    3dcc:	8f 93       	push	r24
    3dce:	9f 93       	push	r25
    3dd0:	ef 93       	push	r30
    3dd2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    3dd4:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    3dd8:	e0 91 62 31 	lds	r30, 0x3162	; 0x803162 <rcvF0_buffer>
    3ddc:	f0 91 63 31 	lds	r31, 0x3163	; 0x803163 <rcvF0_buffer+0x1>
    3de0:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvF0_write_index>
    3de4:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvF0_write_index+0x1>
    3de8:	e8 0f       	add	r30, r24
    3dea:	f9 1f       	adc	r31, r25
    3dec:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    3dee:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvF0_write_index>
    3df2:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvF0_write_index+0x1>
    3df6:	01 96       	adiw	r24, 0x01	; 1
    3df8:	84 36       	cpi	r24, 0x64	; 100
    3dfa:	91 05       	cpc	r25, r1
    3dfc:	60 f4       	brcc	.+24     	; 0x3e16 <__vector_119+0x64>
    3dfe:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvF0_write_index>
    3e02:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3e06:	20 91 54 31 	lds	r18, 0x3154	; 0x803154 <rcvF0_read_index>
    3e0a:	30 91 55 31 	lds	r19, 0x3155	; 0x803155 <rcvF0_read_index+0x1>
    3e0e:	82 17       	cp	r24, r18
    3e10:	93 07       	cpc	r25, r19
    3e12:	f1 f4       	brne	.+60     	; 0x3e50 <__vector_119+0x9e>
    3e14:	0c c0       	rjmp	.+24     	; 0x3e2e <__vector_119+0x7c>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    3e16:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvF0_write_index>
    3e1a:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3e1e:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvF0_read_index>
    3e22:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvF0_read_index+0x1>
    3e26:	18 16       	cp	r1, r24
    3e28:	19 06       	cpc	r1, r25
    3e2a:	91 f4       	brne	.+36     	; 0x3e50 <__vector_119+0x9e>
    3e2c:	0e c0       	rjmp	.+28     	; 0x3e4a <__vector_119+0x98>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3e2e:	01 96       	adiw	r24, 0x01	; 1
    3e30:	84 36       	cpi	r24, 0x64	; 100
    3e32:	91 05       	cpc	r25, r1
    3e34:	28 f4       	brcc	.+10     	; 0x3e40 <__vector_119+0x8e>
    3e36:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvF0_read_index>
    3e3a:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvF0_read_index+0x1>
    3e3e:	08 c0       	rjmp	.+16     	; 0x3e50 <__vector_119+0x9e>
	rcvF0_read_index = 0;
    3e40:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvF0_read_index>
    3e44:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvF0_read_index+0x1>
}
    3e48:	03 c0       	rjmp	.+6      	; 0x3e50 <__vector_119+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3e4a:	81 e0       	ldi	r24, 0x01	; 1
    3e4c:	90 e0       	ldi	r25, 0x00	; 0
    3e4e:	f3 cf       	rjmp	.-26     	; 0x3e36 <__vector_119+0x84>
	rcvF0_read_index = 0;
}
    3e50:	ff 91       	pop	r31
    3e52:	ef 91       	pop	r30
    3e54:	9f 91       	pop	r25
    3e56:	8f 91       	pop	r24
    3e58:	3f 91       	pop	r19
    3e5a:	2f 91       	pop	r18
    3e5c:	0f 90       	pop	r0
    3e5e:	0b be       	out	0x3b, r0	; 59
    3e60:	0f 90       	pop	r0
    3e62:	08 be       	out	0x38, r0	; 56
    3e64:	0f 90       	pop	r0
    3e66:	0f be       	out	0x3f, r0	; 63
    3e68:	0f 90       	pop	r0
    3e6a:	1f 90       	pop	r1
    3e6c:	18 95       	reti

00003e6e <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3e6e:	0f 93       	push	r16
    3e70:	cf 93       	push	r28
    3e72:	df 93       	push	r29
    3e74:	1f 92       	push	r1
    3e76:	cd b7       	in	r28, 0x3d	; 61
    3e78:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3e7a:	2f b7       	in	r18, 0x3f	; 63
    3e7c:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3e7e:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3e80:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3e82:	fc 01       	movw	r30, r24
    3e84:	08 ed       	ldi	r16, 0xD8	; 216
    3e86:	04 bf       	out	0x34, r16	; 52
    3e88:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3e8a:	89 81       	ldd	r24, Y+1	; 0x01
    3e8c:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3e8e:	0f 90       	pop	r0
    3e90:	df 91       	pop	r29
    3e92:	cf 91       	pop	r28
    3e94:	0f 91       	pop	r16
    3e96:	08 95       	ret

00003e98 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3e98:	0f 93       	push	r16
    3e9a:	1f 93       	push	r17
    3e9c:	cf 93       	push	r28
    3e9e:	df 93       	push	r29
    3ea0:	cd b7       	in	r28, 0x3d	; 61
    3ea2:	de b7       	in	r29, 0x3e	; 62
    3ea4:	6d 97       	sbiw	r28, 0x1d	; 29
    3ea6:	cd bf       	out	0x3d, r28	; 61
    3ea8:	de bf       	out	0x3e, r29	; 62
	//Clear any interrupts
	cli();
    3eaa:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3eac:	e0 e5       	ldi	r30, 0x50	; 80
    3eae:	f0 e0       	ldi	r31, 0x00	; 0
    3eb0:	80 81       	ld	r24, Z
    3eb2:	82 60       	ori	r24, 0x02	; 2
    3eb4:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3eb6:	81 81       	ldd	r24, Z+1	; 0x01
    3eb8:	81 ff       	sbrs	r24, 1
    3eba:	fd cf       	rjmp	.-6      	; 0x3eb6 <main+0x1e>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3ebc:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3ec0:	68 7f       	andi	r22, 0xF8	; 248
    3ec2:	61 60       	ori	r22, 0x01	; 1
    3ec4:	80 e4       	ldi	r24, 0x40	; 64
    3ec6:	90 e0       	ldi	r25, 0x00	; 0
    3ec8:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3ecc:	e0 e5       	ldi	r30, 0x50	; 80
    3ece:	f0 e0       	ldi	r31, 0x00	; 0
    3ed0:	80 81       	ld	r24, Z
    3ed2:	8e 7f       	andi	r24, 0xFE	; 254
    3ed4:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3ed6:	9d ef       	ldi	r25, 0xFD	; 253
    3ed8:	88 ed       	ldi	r24, 0xD8	; 216
    3eda:	08 b6       	in	r0, 0x38	; 56
    3edc:	18 be       	out	0x38, r1	; 56
    3ede:	84 bf       	out	0x34, r24	; 52
    3ee0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3ee4:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
    3ee6:	40 ea       	ldi	r20, 0xA0	; 160
    3ee8:	58 e0       	ldi	r21, 0x08	; 8
    3eea:	60 e0       	ldi	r22, 0x00	; 0
    3eec:	70 e0       	ldi	r23, 0x00	; 0
    3eee:	ce 01       	movw	r24, r28
    3ef0:	01 96       	adiw	r24, 0x01	; 1
    3ef2:	0e 94 03 1c 	call	0x3806	; 0x3806 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3ef6:	67 e0       	ldi	r22, 0x07	; 7
    3ef8:	ce 01       	movw	r24, r28
    3efa:	01 96       	adiw	r24, 0x01	; 1
    3efc:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    3f00:	8c 01       	movw	r16, r24
    3f02:	65 e9       	ldi	r22, 0x95	; 149
    3f04:	70 e2       	ldi	r23, 0x20	; 32
    3f06:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstream4putsEPKc>
    3f0a:	66 e0       	ldi	r22, 0x06	; 6
    3f0c:	c8 01       	movw	r24, r16
    3f0e:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
    3f12:	66 e0       	ldi	r22, 0x06	; 6
    3f14:	0e 94 1f 1a 	call	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3f18:	82 e1       	ldi	r24, 0x12	; 18
    3f1a:	90 e0       	ldi	r25, 0x00	; 0
    3f1c:	0e 94 15 19 	call	0x322a	; 0x322a <_Znwj>
    3f20:	8e 01       	movw	r16, r28
    3f22:	0f 5f       	subi	r16, 0xFF	; 255
    3f24:	1f 4f       	sbci	r17, 0xFF	; 255
    3f26:	24 e0       	ldi	r18, 0x04	; 4
    3f28:	31 e0       	ldi	r19, 0x01	; 1
    3f2a:	40 e0       	ldi	r20, 0x00	; 0
    3f2c:	64 eb       	ldi	r22, 0xB4	; 180
    3f2e:	70 e2       	ldi	r23, 0x20	; 32
    3f30:	0e 94 d4 06 	call	0xda8	; 0xda8 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3f34:	82 e1       	ldi	r24, 0x12	; 18
    3f36:	90 e0       	ldi	r25, 0x00	; 0
    3f38:	0e 94 15 19 	call	0x322a	; 0x322a <_Znwj>
    3f3c:	24 e0       	ldi	r18, 0x04	; 4
    3f3e:	31 e0       	ldi	r19, 0x01	; 1
    3f40:	42 e0       	ldi	r20, 0x02	; 2
    3f42:	6c eb       	ldi	r22, 0xBC	; 188
    3f44:	70 e2       	ldi	r23, 0x20	; 32
    3f46:	0e 94 9d 03 	call	0x73a	; 0x73a <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3f4a:	82 e1       	ldi	r24, 0x12	; 18
    3f4c:	90 e0       	ldi	r25, 0x00	; 0
    3f4e:	0e 94 15 19 	call	0x322a	; 0x322a <_Znwj>
    3f52:	24 e0       	ldi	r18, 0x04	; 4
    3f54:	31 e0       	ldi	r19, 0x01	; 1
    3f56:	43 e0       	ldi	r20, 0x03	; 3
    3f58:	63 ec       	ldi	r22, 0xC3	; 195
    3f5a:	70 e2       	ldi	r23, 0x20	; 32
    3f5c:	0e 94 f6 03 	call	0x7ec	; 0x7ec <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3f60:	82 e1       	ldi	r24, 0x12	; 18
    3f62:	90 e0       	ldi	r25, 0x00	; 0
    3f64:	0e 94 15 19 	call	0x322a	; 0x322a <_Znwj>
    3f68:	24 e0       	ldi	r18, 0x04	; 4
    3f6a:	31 e0       	ldi	r19, 0x01	; 1
    3f6c:	44 e0       	ldi	r20, 0x04	; 4
    3f6e:	6a ec       	ldi	r22, 0xCA	; 202
    3f70:	70 e2       	ldi	r23, 0x20	; 32
    3f72:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(1), 260, &ser_dev);
    3f76:	82 e4       	ldi	r24, 0x42	; 66
    3f78:	90 e0       	ldi	r25, 0x00	; 0
    3f7a:	0e 94 15 19 	call	0x322a	; 0x322a <_Znwj>
    3f7e:	24 e0       	ldi	r18, 0x04	; 4
    3f80:	31 e0       	ldi	r19, 0x01	; 1
    3f82:	41 e0       	ldi	r20, 0x01	; 1
    3f84:	63 ed       	ldi	r22, 0xD3	; 211
    3f86:	70 e2       	ldi	r23, 0x20	; 32
    3f88:	0e 94 93 05 	call	0xb26	; 0xb26 <_ZN5MotorC1EPKchjP8emstream>

	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3f8c:	87 e0       	ldi	r24, 0x07	; 7
    3f8e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3f92:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3f94:	0e 94 27 10 	call	0x204e	; 0x204e <vTaskStartScheduler>
	
	return 0;
    3f98:	80 e0       	ldi	r24, 0x00	; 0
    3f9a:	90 e0       	ldi	r25, 0x00	; 0
    3f9c:	6d 96       	adiw	r28, 0x1d	; 29
    3f9e:	cd bf       	out	0x3d, r28	; 61
    3fa0:	de bf       	out	0x3e, r29	; 62
    3fa2:	df 91       	pop	r29
    3fa4:	cf 91       	pop	r28
    3fa6:	1f 91       	pop	r17
    3fa8:	0f 91       	pop	r16
    3faa:	08 95       	ret

00003fac <_GLOBAL__sub_I_counter>:
    3fac:	0f 93       	push	r16
    3fae:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3fb0:	0a e0       	ldi	r16, 0x0A	; 10
    3fb2:	10 e0       	ldi	r17, 0x00	; 0
    3fb4:	20 e0       	ldi	r18, 0x00	; 0
    3fb6:	30 e0       	ldi	r19, 0x00	; 0
    3fb8:	40 e0       	ldi	r20, 0x00	; 0
    3fba:	50 e0       	ldi	r21, 0x00	; 0
    3fbc:	60 e2       	ldi	r22, 0x20	; 32
    3fbe:	70 e0       	ldi	r23, 0x00	; 0
    3fc0:	86 e7       	ldi	r24, 0x76	; 118
    3fc2:	91 e3       	ldi	r25, 0x31	; 49
    3fc4:	0e 94 81 17 	call	0x2f02	; 0x2f02 <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    3fc8:	1f 91       	pop	r17
    3fca:	0f 91       	pop	r16
    3fcc:	08 95       	ret

00003fce <__subsf3>:
    3fce:	50 58       	subi	r21, 0x80	; 128

00003fd0 <__addsf3>:
    3fd0:	bb 27       	eor	r27, r27
    3fd2:	aa 27       	eor	r26, r26
    3fd4:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__addsf3x>
    3fd8:	0c 94 79 21 	jmp	0x42f2	; 0x42f2 <__fp_round>
    3fdc:	0e 94 6b 21 	call	0x42d6	; 0x42d6 <__fp_pscA>
    3fe0:	38 f0       	brcs	.+14     	; 0x3ff0 <__addsf3+0x20>
    3fe2:	0e 94 72 21 	call	0x42e4	; 0x42e4 <__fp_pscB>
    3fe6:	20 f0       	brcs	.+8      	; 0x3ff0 <__addsf3+0x20>
    3fe8:	39 f4       	brne	.+14     	; 0x3ff8 <__addsf3+0x28>
    3fea:	9f 3f       	cpi	r25, 0xFF	; 255
    3fec:	19 f4       	brne	.+6      	; 0x3ff4 <__addsf3+0x24>
    3fee:	26 f4       	brtc	.+8      	; 0x3ff8 <__addsf3+0x28>
    3ff0:	0c 94 68 21 	jmp	0x42d0	; 0x42d0 <__fp_nan>
    3ff4:	0e f4       	brtc	.+2      	; 0x3ff8 <__addsf3+0x28>
    3ff6:	e0 95       	com	r30
    3ff8:	e7 fb       	bst	r30, 7
    3ffa:	0c 94 62 21 	jmp	0x42c4	; 0x42c4 <__fp_inf>

00003ffe <__addsf3x>:
    3ffe:	e9 2f       	mov	r30, r25
    4000:	0e 94 8a 21 	call	0x4314	; 0x4314 <__fp_split3>
    4004:	58 f3       	brcs	.-42     	; 0x3fdc <__addsf3+0xc>
    4006:	ba 17       	cp	r27, r26
    4008:	62 07       	cpc	r22, r18
    400a:	73 07       	cpc	r23, r19
    400c:	84 07       	cpc	r24, r20
    400e:	95 07       	cpc	r25, r21
    4010:	20 f0       	brcs	.+8      	; 0x401a <__stack+0x1b>
    4012:	79 f4       	brne	.+30     	; 0x4032 <__stack+0x33>
    4014:	a6 f5       	brtc	.+104    	; 0x407e <__stack+0x7f>
    4016:	0c 94 ac 21 	jmp	0x4358	; 0x4358 <__fp_zero>
    401a:	0e f4       	brtc	.+2      	; 0x401e <__stack+0x1f>
    401c:	e0 95       	com	r30
    401e:	0b 2e       	mov	r0, r27
    4020:	ba 2f       	mov	r27, r26
    4022:	a0 2d       	mov	r26, r0
    4024:	0b 01       	movw	r0, r22
    4026:	b9 01       	movw	r22, r18
    4028:	90 01       	movw	r18, r0
    402a:	0c 01       	movw	r0, r24
    402c:	ca 01       	movw	r24, r20
    402e:	a0 01       	movw	r20, r0
    4030:	11 24       	eor	r1, r1
    4032:	ff 27       	eor	r31, r31
    4034:	59 1b       	sub	r21, r25
    4036:	99 f0       	breq	.+38     	; 0x405e <__stack+0x5f>
    4038:	59 3f       	cpi	r21, 0xF9	; 249
    403a:	50 f4       	brcc	.+20     	; 0x4050 <__stack+0x51>
    403c:	50 3e       	cpi	r21, 0xE0	; 224
    403e:	68 f1       	brcs	.+90     	; 0x409a <__stack+0x9b>
    4040:	1a 16       	cp	r1, r26
    4042:	f0 40       	sbci	r31, 0x00	; 0
    4044:	a2 2f       	mov	r26, r18
    4046:	23 2f       	mov	r18, r19
    4048:	34 2f       	mov	r19, r20
    404a:	44 27       	eor	r20, r20
    404c:	58 5f       	subi	r21, 0xF8	; 248
    404e:	f3 cf       	rjmp	.-26     	; 0x4036 <__stack+0x37>
    4050:	46 95       	lsr	r20
    4052:	37 95       	ror	r19
    4054:	27 95       	ror	r18
    4056:	a7 95       	ror	r26
    4058:	f0 40       	sbci	r31, 0x00	; 0
    405a:	53 95       	inc	r21
    405c:	c9 f7       	brne	.-14     	; 0x4050 <__stack+0x51>
    405e:	7e f4       	brtc	.+30     	; 0x407e <__stack+0x7f>
    4060:	1f 16       	cp	r1, r31
    4062:	ba 0b       	sbc	r27, r26
    4064:	62 0b       	sbc	r22, r18
    4066:	73 0b       	sbc	r23, r19
    4068:	84 0b       	sbc	r24, r20
    406a:	ba f0       	brmi	.+46     	; 0x409a <__stack+0x9b>
    406c:	91 50       	subi	r25, 0x01	; 1
    406e:	a1 f0       	breq	.+40     	; 0x4098 <__stack+0x99>
    4070:	ff 0f       	add	r31, r31
    4072:	bb 1f       	adc	r27, r27
    4074:	66 1f       	adc	r22, r22
    4076:	77 1f       	adc	r23, r23
    4078:	88 1f       	adc	r24, r24
    407a:	c2 f7       	brpl	.-16     	; 0x406c <__stack+0x6d>
    407c:	0e c0       	rjmp	.+28     	; 0x409a <__stack+0x9b>
    407e:	ba 0f       	add	r27, r26
    4080:	62 1f       	adc	r22, r18
    4082:	73 1f       	adc	r23, r19
    4084:	84 1f       	adc	r24, r20
    4086:	48 f4       	brcc	.+18     	; 0x409a <__stack+0x9b>
    4088:	87 95       	ror	r24
    408a:	77 95       	ror	r23
    408c:	67 95       	ror	r22
    408e:	b7 95       	ror	r27
    4090:	f7 95       	ror	r31
    4092:	9e 3f       	cpi	r25, 0xFE	; 254
    4094:	08 f0       	brcs	.+2      	; 0x4098 <__stack+0x99>
    4096:	b0 cf       	rjmp	.-160    	; 0x3ff8 <__addsf3+0x28>
    4098:	93 95       	inc	r25
    409a:	88 0f       	add	r24, r24
    409c:	08 f0       	brcs	.+2      	; 0x40a0 <__stack+0xa1>
    409e:	99 27       	eor	r25, r25
    40a0:	ee 0f       	add	r30, r30
    40a2:	97 95       	ror	r25
    40a4:	87 95       	ror	r24
    40a6:	08 95       	ret

000040a8 <__cmpsf2>:
    40a8:	0e 94 3e 21 	call	0x427c	; 0x427c <__fp_cmp>
    40ac:	08 f4       	brcc	.+2      	; 0x40b0 <__cmpsf2+0x8>
    40ae:	81 e0       	ldi	r24, 0x01	; 1
    40b0:	08 95       	ret

000040b2 <__divsf3>:
    40b2:	0e 94 6d 20 	call	0x40da	; 0x40da <__divsf3x>
    40b6:	0c 94 79 21 	jmp	0x42f2	; 0x42f2 <__fp_round>
    40ba:	0e 94 72 21 	call	0x42e4	; 0x42e4 <__fp_pscB>
    40be:	58 f0       	brcs	.+22     	; 0x40d6 <__divsf3+0x24>
    40c0:	0e 94 6b 21 	call	0x42d6	; 0x42d6 <__fp_pscA>
    40c4:	40 f0       	brcs	.+16     	; 0x40d6 <__divsf3+0x24>
    40c6:	29 f4       	brne	.+10     	; 0x40d2 <__divsf3+0x20>
    40c8:	5f 3f       	cpi	r21, 0xFF	; 255
    40ca:	29 f0       	breq	.+10     	; 0x40d6 <__divsf3+0x24>
    40cc:	0c 94 62 21 	jmp	0x42c4	; 0x42c4 <__fp_inf>
    40d0:	51 11       	cpse	r21, r1
    40d2:	0c 94 ad 21 	jmp	0x435a	; 0x435a <__fp_szero>
    40d6:	0c 94 68 21 	jmp	0x42d0	; 0x42d0 <__fp_nan>

000040da <__divsf3x>:
    40da:	0e 94 8a 21 	call	0x4314	; 0x4314 <__fp_split3>
    40de:	68 f3       	brcs	.-38     	; 0x40ba <__divsf3+0x8>

000040e0 <__divsf3_pse>:
    40e0:	99 23       	and	r25, r25
    40e2:	b1 f3       	breq	.-20     	; 0x40d0 <__divsf3+0x1e>
    40e4:	55 23       	and	r21, r21
    40e6:	91 f3       	breq	.-28     	; 0x40cc <__divsf3+0x1a>
    40e8:	95 1b       	sub	r25, r21
    40ea:	55 0b       	sbc	r21, r21
    40ec:	bb 27       	eor	r27, r27
    40ee:	aa 27       	eor	r26, r26
    40f0:	62 17       	cp	r22, r18
    40f2:	73 07       	cpc	r23, r19
    40f4:	84 07       	cpc	r24, r20
    40f6:	38 f0       	brcs	.+14     	; 0x4106 <__divsf3_pse+0x26>
    40f8:	9f 5f       	subi	r25, 0xFF	; 255
    40fa:	5f 4f       	sbci	r21, 0xFF	; 255
    40fc:	22 0f       	add	r18, r18
    40fe:	33 1f       	adc	r19, r19
    4100:	44 1f       	adc	r20, r20
    4102:	aa 1f       	adc	r26, r26
    4104:	a9 f3       	breq	.-22     	; 0x40f0 <__divsf3_pse+0x10>
    4106:	35 d0       	rcall	.+106    	; 0x4172 <__divsf3_pse+0x92>
    4108:	0e 2e       	mov	r0, r30
    410a:	3a f0       	brmi	.+14     	; 0x411a <__divsf3_pse+0x3a>
    410c:	e0 e8       	ldi	r30, 0x80	; 128
    410e:	32 d0       	rcall	.+100    	; 0x4174 <__divsf3_pse+0x94>
    4110:	91 50       	subi	r25, 0x01	; 1
    4112:	50 40       	sbci	r21, 0x00	; 0
    4114:	e6 95       	lsr	r30
    4116:	00 1c       	adc	r0, r0
    4118:	ca f7       	brpl	.-14     	; 0x410c <__divsf3_pse+0x2c>
    411a:	2b d0       	rcall	.+86     	; 0x4172 <__divsf3_pse+0x92>
    411c:	fe 2f       	mov	r31, r30
    411e:	29 d0       	rcall	.+82     	; 0x4172 <__divsf3_pse+0x92>
    4120:	66 0f       	add	r22, r22
    4122:	77 1f       	adc	r23, r23
    4124:	88 1f       	adc	r24, r24
    4126:	bb 1f       	adc	r27, r27
    4128:	26 17       	cp	r18, r22
    412a:	37 07       	cpc	r19, r23
    412c:	48 07       	cpc	r20, r24
    412e:	ab 07       	cpc	r26, r27
    4130:	b0 e8       	ldi	r27, 0x80	; 128
    4132:	09 f0       	breq	.+2      	; 0x4136 <__divsf3_pse+0x56>
    4134:	bb 0b       	sbc	r27, r27
    4136:	80 2d       	mov	r24, r0
    4138:	bf 01       	movw	r22, r30
    413a:	ff 27       	eor	r31, r31
    413c:	93 58       	subi	r25, 0x83	; 131
    413e:	5f 4f       	sbci	r21, 0xFF	; 255
    4140:	3a f0       	brmi	.+14     	; 0x4150 <__divsf3_pse+0x70>
    4142:	9e 3f       	cpi	r25, 0xFE	; 254
    4144:	51 05       	cpc	r21, r1
    4146:	78 f0       	brcs	.+30     	; 0x4166 <__divsf3_pse+0x86>
    4148:	0c 94 62 21 	jmp	0x42c4	; 0x42c4 <__fp_inf>
    414c:	0c 94 ad 21 	jmp	0x435a	; 0x435a <__fp_szero>
    4150:	5f 3f       	cpi	r21, 0xFF	; 255
    4152:	e4 f3       	brlt	.-8      	; 0x414c <__divsf3_pse+0x6c>
    4154:	98 3e       	cpi	r25, 0xE8	; 232
    4156:	d4 f3       	brlt	.-12     	; 0x414c <__divsf3_pse+0x6c>
    4158:	86 95       	lsr	r24
    415a:	77 95       	ror	r23
    415c:	67 95       	ror	r22
    415e:	b7 95       	ror	r27
    4160:	f7 95       	ror	r31
    4162:	9f 5f       	subi	r25, 0xFF	; 255
    4164:	c9 f7       	brne	.-14     	; 0x4158 <__divsf3_pse+0x78>
    4166:	88 0f       	add	r24, r24
    4168:	91 1d       	adc	r25, r1
    416a:	96 95       	lsr	r25
    416c:	87 95       	ror	r24
    416e:	97 f9       	bld	r25, 7
    4170:	08 95       	ret
    4172:	e1 e0       	ldi	r30, 0x01	; 1
    4174:	66 0f       	add	r22, r22
    4176:	77 1f       	adc	r23, r23
    4178:	88 1f       	adc	r24, r24
    417a:	bb 1f       	adc	r27, r27
    417c:	62 17       	cp	r22, r18
    417e:	73 07       	cpc	r23, r19
    4180:	84 07       	cpc	r24, r20
    4182:	ba 07       	cpc	r27, r26
    4184:	20 f0       	brcs	.+8      	; 0x418e <__divsf3_pse+0xae>
    4186:	62 1b       	sub	r22, r18
    4188:	73 0b       	sbc	r23, r19
    418a:	84 0b       	sbc	r24, r20
    418c:	ba 0b       	sbc	r27, r26
    418e:	ee 1f       	adc	r30, r30
    4190:	88 f7       	brcc	.-30     	; 0x4174 <__divsf3_pse+0x94>
    4192:	e0 95       	com	r30
    4194:	08 95       	ret

00004196 <__fixsfsi>:
    4196:	0e 94 d2 20 	call	0x41a4	; 0x41a4 <__fixunssfsi>
    419a:	68 94       	set
    419c:	b1 11       	cpse	r27, r1
    419e:	0c 94 ad 21 	jmp	0x435a	; 0x435a <__fp_szero>
    41a2:	08 95       	ret

000041a4 <__fixunssfsi>:
    41a4:	0e 94 92 21 	call	0x4324	; 0x4324 <__fp_splitA>
    41a8:	88 f0       	brcs	.+34     	; 0x41cc <__fixunssfsi+0x28>
    41aa:	9f 57       	subi	r25, 0x7F	; 127
    41ac:	98 f0       	brcs	.+38     	; 0x41d4 <__fixunssfsi+0x30>
    41ae:	b9 2f       	mov	r27, r25
    41b0:	99 27       	eor	r25, r25
    41b2:	b7 51       	subi	r27, 0x17	; 23
    41b4:	b0 f0       	brcs	.+44     	; 0x41e2 <__fixunssfsi+0x3e>
    41b6:	e1 f0       	breq	.+56     	; 0x41f0 <__fixunssfsi+0x4c>
    41b8:	66 0f       	add	r22, r22
    41ba:	77 1f       	adc	r23, r23
    41bc:	88 1f       	adc	r24, r24
    41be:	99 1f       	adc	r25, r25
    41c0:	1a f0       	brmi	.+6      	; 0x41c8 <__fixunssfsi+0x24>
    41c2:	ba 95       	dec	r27
    41c4:	c9 f7       	brne	.-14     	; 0x41b8 <__fixunssfsi+0x14>
    41c6:	14 c0       	rjmp	.+40     	; 0x41f0 <__fixunssfsi+0x4c>
    41c8:	b1 30       	cpi	r27, 0x01	; 1
    41ca:	91 f0       	breq	.+36     	; 0x41f0 <__fixunssfsi+0x4c>
    41cc:	0e 94 ac 21 	call	0x4358	; 0x4358 <__fp_zero>
    41d0:	b1 e0       	ldi	r27, 0x01	; 1
    41d2:	08 95       	ret
    41d4:	0c 94 ac 21 	jmp	0x4358	; 0x4358 <__fp_zero>
    41d8:	67 2f       	mov	r22, r23
    41da:	78 2f       	mov	r23, r24
    41dc:	88 27       	eor	r24, r24
    41de:	b8 5f       	subi	r27, 0xF8	; 248
    41e0:	39 f0       	breq	.+14     	; 0x41f0 <__fixunssfsi+0x4c>
    41e2:	b9 3f       	cpi	r27, 0xF9	; 249
    41e4:	cc f3       	brlt	.-14     	; 0x41d8 <__fixunssfsi+0x34>
    41e6:	86 95       	lsr	r24
    41e8:	77 95       	ror	r23
    41ea:	67 95       	ror	r22
    41ec:	b3 95       	inc	r27
    41ee:	d9 f7       	brne	.-10     	; 0x41e6 <__fixunssfsi+0x42>
    41f0:	3e f4       	brtc	.+14     	; 0x4200 <__fixunssfsi+0x5c>
    41f2:	90 95       	com	r25
    41f4:	80 95       	com	r24
    41f6:	70 95       	com	r23
    41f8:	61 95       	neg	r22
    41fa:	7f 4f       	sbci	r23, 0xFF	; 255
    41fc:	8f 4f       	sbci	r24, 0xFF	; 255
    41fe:	9f 4f       	sbci	r25, 0xFF	; 255
    4200:	08 95       	ret

00004202 <__floatunsisf>:
    4202:	e8 94       	clt
    4204:	09 c0       	rjmp	.+18     	; 0x4218 <__floatsisf+0x12>

00004206 <__floatsisf>:
    4206:	97 fb       	bst	r25, 7
    4208:	3e f4       	brtc	.+14     	; 0x4218 <__floatsisf+0x12>
    420a:	90 95       	com	r25
    420c:	80 95       	com	r24
    420e:	70 95       	com	r23
    4210:	61 95       	neg	r22
    4212:	7f 4f       	sbci	r23, 0xFF	; 255
    4214:	8f 4f       	sbci	r24, 0xFF	; 255
    4216:	9f 4f       	sbci	r25, 0xFF	; 255
    4218:	99 23       	and	r25, r25
    421a:	a9 f0       	breq	.+42     	; 0x4246 <__floatsisf+0x40>
    421c:	f9 2f       	mov	r31, r25
    421e:	96 e9       	ldi	r25, 0x96	; 150
    4220:	bb 27       	eor	r27, r27
    4222:	93 95       	inc	r25
    4224:	f6 95       	lsr	r31
    4226:	87 95       	ror	r24
    4228:	77 95       	ror	r23
    422a:	67 95       	ror	r22
    422c:	b7 95       	ror	r27
    422e:	f1 11       	cpse	r31, r1
    4230:	f8 cf       	rjmp	.-16     	; 0x4222 <__floatsisf+0x1c>
    4232:	fa f4       	brpl	.+62     	; 0x4272 <__floatsisf+0x6c>
    4234:	bb 0f       	add	r27, r27
    4236:	11 f4       	brne	.+4      	; 0x423c <__floatsisf+0x36>
    4238:	60 ff       	sbrs	r22, 0
    423a:	1b c0       	rjmp	.+54     	; 0x4272 <__floatsisf+0x6c>
    423c:	6f 5f       	subi	r22, 0xFF	; 255
    423e:	7f 4f       	sbci	r23, 0xFF	; 255
    4240:	8f 4f       	sbci	r24, 0xFF	; 255
    4242:	9f 4f       	sbci	r25, 0xFF	; 255
    4244:	16 c0       	rjmp	.+44     	; 0x4272 <__floatsisf+0x6c>
    4246:	88 23       	and	r24, r24
    4248:	11 f0       	breq	.+4      	; 0x424e <__floatsisf+0x48>
    424a:	96 e9       	ldi	r25, 0x96	; 150
    424c:	11 c0       	rjmp	.+34     	; 0x4270 <__floatsisf+0x6a>
    424e:	77 23       	and	r23, r23
    4250:	21 f0       	breq	.+8      	; 0x425a <__floatsisf+0x54>
    4252:	9e e8       	ldi	r25, 0x8E	; 142
    4254:	87 2f       	mov	r24, r23
    4256:	76 2f       	mov	r23, r22
    4258:	05 c0       	rjmp	.+10     	; 0x4264 <__floatsisf+0x5e>
    425a:	66 23       	and	r22, r22
    425c:	71 f0       	breq	.+28     	; 0x427a <__floatsisf+0x74>
    425e:	96 e8       	ldi	r25, 0x86	; 134
    4260:	86 2f       	mov	r24, r22
    4262:	70 e0       	ldi	r23, 0x00	; 0
    4264:	60 e0       	ldi	r22, 0x00	; 0
    4266:	2a f0       	brmi	.+10     	; 0x4272 <__floatsisf+0x6c>
    4268:	9a 95       	dec	r25
    426a:	66 0f       	add	r22, r22
    426c:	77 1f       	adc	r23, r23
    426e:	88 1f       	adc	r24, r24
    4270:	da f7       	brpl	.-10     	; 0x4268 <__floatsisf+0x62>
    4272:	88 0f       	add	r24, r24
    4274:	96 95       	lsr	r25
    4276:	87 95       	ror	r24
    4278:	97 f9       	bld	r25, 7
    427a:	08 95       	ret

0000427c <__fp_cmp>:
    427c:	99 0f       	add	r25, r25
    427e:	00 08       	sbc	r0, r0
    4280:	55 0f       	add	r21, r21
    4282:	aa 0b       	sbc	r26, r26
    4284:	e0 e8       	ldi	r30, 0x80	; 128
    4286:	fe ef       	ldi	r31, 0xFE	; 254
    4288:	16 16       	cp	r1, r22
    428a:	17 06       	cpc	r1, r23
    428c:	e8 07       	cpc	r30, r24
    428e:	f9 07       	cpc	r31, r25
    4290:	c0 f0       	brcs	.+48     	; 0x42c2 <__fp_cmp+0x46>
    4292:	12 16       	cp	r1, r18
    4294:	13 06       	cpc	r1, r19
    4296:	e4 07       	cpc	r30, r20
    4298:	f5 07       	cpc	r31, r21
    429a:	98 f0       	brcs	.+38     	; 0x42c2 <__fp_cmp+0x46>
    429c:	62 1b       	sub	r22, r18
    429e:	73 0b       	sbc	r23, r19
    42a0:	84 0b       	sbc	r24, r20
    42a2:	95 0b       	sbc	r25, r21
    42a4:	39 f4       	brne	.+14     	; 0x42b4 <__fp_cmp+0x38>
    42a6:	0a 26       	eor	r0, r26
    42a8:	61 f0       	breq	.+24     	; 0x42c2 <__fp_cmp+0x46>
    42aa:	23 2b       	or	r18, r19
    42ac:	24 2b       	or	r18, r20
    42ae:	25 2b       	or	r18, r21
    42b0:	21 f4       	brne	.+8      	; 0x42ba <__fp_cmp+0x3e>
    42b2:	08 95       	ret
    42b4:	0a 26       	eor	r0, r26
    42b6:	09 f4       	brne	.+2      	; 0x42ba <__fp_cmp+0x3e>
    42b8:	a1 40       	sbci	r26, 0x01	; 1
    42ba:	a6 95       	lsr	r26
    42bc:	8f ef       	ldi	r24, 0xFF	; 255
    42be:	81 1d       	adc	r24, r1
    42c0:	81 1d       	adc	r24, r1
    42c2:	08 95       	ret

000042c4 <__fp_inf>:
    42c4:	97 f9       	bld	r25, 7
    42c6:	9f 67       	ori	r25, 0x7F	; 127
    42c8:	80 e8       	ldi	r24, 0x80	; 128
    42ca:	70 e0       	ldi	r23, 0x00	; 0
    42cc:	60 e0       	ldi	r22, 0x00	; 0
    42ce:	08 95       	ret

000042d0 <__fp_nan>:
    42d0:	9f ef       	ldi	r25, 0xFF	; 255
    42d2:	80 ec       	ldi	r24, 0xC0	; 192
    42d4:	08 95       	ret

000042d6 <__fp_pscA>:
    42d6:	00 24       	eor	r0, r0
    42d8:	0a 94       	dec	r0
    42da:	16 16       	cp	r1, r22
    42dc:	17 06       	cpc	r1, r23
    42de:	18 06       	cpc	r1, r24
    42e0:	09 06       	cpc	r0, r25
    42e2:	08 95       	ret

000042e4 <__fp_pscB>:
    42e4:	00 24       	eor	r0, r0
    42e6:	0a 94       	dec	r0
    42e8:	12 16       	cp	r1, r18
    42ea:	13 06       	cpc	r1, r19
    42ec:	14 06       	cpc	r1, r20
    42ee:	05 06       	cpc	r0, r21
    42f0:	08 95       	ret

000042f2 <__fp_round>:
    42f2:	09 2e       	mov	r0, r25
    42f4:	03 94       	inc	r0
    42f6:	00 0c       	add	r0, r0
    42f8:	11 f4       	brne	.+4      	; 0x42fe <__fp_round+0xc>
    42fa:	88 23       	and	r24, r24
    42fc:	52 f0       	brmi	.+20     	; 0x4312 <__fp_round+0x20>
    42fe:	bb 0f       	add	r27, r27
    4300:	40 f4       	brcc	.+16     	; 0x4312 <__fp_round+0x20>
    4302:	bf 2b       	or	r27, r31
    4304:	11 f4       	brne	.+4      	; 0x430a <__fp_round+0x18>
    4306:	60 ff       	sbrs	r22, 0
    4308:	04 c0       	rjmp	.+8      	; 0x4312 <__fp_round+0x20>
    430a:	6f 5f       	subi	r22, 0xFF	; 255
    430c:	7f 4f       	sbci	r23, 0xFF	; 255
    430e:	8f 4f       	sbci	r24, 0xFF	; 255
    4310:	9f 4f       	sbci	r25, 0xFF	; 255
    4312:	08 95       	ret

00004314 <__fp_split3>:
    4314:	57 fd       	sbrc	r21, 7
    4316:	90 58       	subi	r25, 0x80	; 128
    4318:	44 0f       	add	r20, r20
    431a:	55 1f       	adc	r21, r21
    431c:	59 f0       	breq	.+22     	; 0x4334 <__fp_splitA+0x10>
    431e:	5f 3f       	cpi	r21, 0xFF	; 255
    4320:	71 f0       	breq	.+28     	; 0x433e <__fp_splitA+0x1a>
    4322:	47 95       	ror	r20

00004324 <__fp_splitA>:
    4324:	88 0f       	add	r24, r24
    4326:	97 fb       	bst	r25, 7
    4328:	99 1f       	adc	r25, r25
    432a:	61 f0       	breq	.+24     	; 0x4344 <__fp_splitA+0x20>
    432c:	9f 3f       	cpi	r25, 0xFF	; 255
    432e:	79 f0       	breq	.+30     	; 0x434e <__fp_splitA+0x2a>
    4330:	87 95       	ror	r24
    4332:	08 95       	ret
    4334:	12 16       	cp	r1, r18
    4336:	13 06       	cpc	r1, r19
    4338:	14 06       	cpc	r1, r20
    433a:	55 1f       	adc	r21, r21
    433c:	f2 cf       	rjmp	.-28     	; 0x4322 <__fp_split3+0xe>
    433e:	46 95       	lsr	r20
    4340:	f1 df       	rcall	.-30     	; 0x4324 <__fp_splitA>
    4342:	08 c0       	rjmp	.+16     	; 0x4354 <__fp_splitA+0x30>
    4344:	16 16       	cp	r1, r22
    4346:	17 06       	cpc	r1, r23
    4348:	18 06       	cpc	r1, r24
    434a:	99 1f       	adc	r25, r25
    434c:	f1 cf       	rjmp	.-30     	; 0x4330 <__fp_splitA+0xc>
    434e:	86 95       	lsr	r24
    4350:	71 05       	cpc	r23, r1
    4352:	61 05       	cpc	r22, r1
    4354:	08 94       	sec
    4356:	08 95       	ret

00004358 <__fp_zero>:
    4358:	e8 94       	clt

0000435a <__fp_szero>:
    435a:	bb 27       	eor	r27, r27
    435c:	66 27       	eor	r22, r22
    435e:	77 27       	eor	r23, r23
    4360:	cb 01       	movw	r24, r22
    4362:	97 f9       	bld	r25, 7
    4364:	08 95       	ret

00004366 <__gesf2>:
    4366:	0e 94 3e 21 	call	0x427c	; 0x427c <__fp_cmp>
    436a:	08 f4       	brcc	.+2      	; 0x436e <__gesf2+0x8>
    436c:	8f ef       	ldi	r24, 0xFF	; 255
    436e:	08 95       	ret

00004370 <__mulsf3>:
    4370:	0e 94 cb 21 	call	0x4396	; 0x4396 <__mulsf3x>
    4374:	0c 94 79 21 	jmp	0x42f2	; 0x42f2 <__fp_round>
    4378:	0e 94 6b 21 	call	0x42d6	; 0x42d6 <__fp_pscA>
    437c:	38 f0       	brcs	.+14     	; 0x438c <__mulsf3+0x1c>
    437e:	0e 94 72 21 	call	0x42e4	; 0x42e4 <__fp_pscB>
    4382:	20 f0       	brcs	.+8      	; 0x438c <__mulsf3+0x1c>
    4384:	95 23       	and	r25, r21
    4386:	11 f0       	breq	.+4      	; 0x438c <__mulsf3+0x1c>
    4388:	0c 94 62 21 	jmp	0x42c4	; 0x42c4 <__fp_inf>
    438c:	0c 94 68 21 	jmp	0x42d0	; 0x42d0 <__fp_nan>
    4390:	11 24       	eor	r1, r1
    4392:	0c 94 ad 21 	jmp	0x435a	; 0x435a <__fp_szero>

00004396 <__mulsf3x>:
    4396:	0e 94 8a 21 	call	0x4314	; 0x4314 <__fp_split3>
    439a:	70 f3       	brcs	.-36     	; 0x4378 <__mulsf3+0x8>

0000439c <__mulsf3_pse>:
    439c:	95 9f       	mul	r25, r21
    439e:	c1 f3       	breq	.-16     	; 0x4390 <__mulsf3+0x20>
    43a0:	95 0f       	add	r25, r21
    43a2:	50 e0       	ldi	r21, 0x00	; 0
    43a4:	55 1f       	adc	r21, r21
    43a6:	62 9f       	mul	r22, r18
    43a8:	f0 01       	movw	r30, r0
    43aa:	72 9f       	mul	r23, r18
    43ac:	bb 27       	eor	r27, r27
    43ae:	f0 0d       	add	r31, r0
    43b0:	b1 1d       	adc	r27, r1
    43b2:	63 9f       	mul	r22, r19
    43b4:	aa 27       	eor	r26, r26
    43b6:	f0 0d       	add	r31, r0
    43b8:	b1 1d       	adc	r27, r1
    43ba:	aa 1f       	adc	r26, r26
    43bc:	64 9f       	mul	r22, r20
    43be:	66 27       	eor	r22, r22
    43c0:	b0 0d       	add	r27, r0
    43c2:	a1 1d       	adc	r26, r1
    43c4:	66 1f       	adc	r22, r22
    43c6:	82 9f       	mul	r24, r18
    43c8:	22 27       	eor	r18, r18
    43ca:	b0 0d       	add	r27, r0
    43cc:	a1 1d       	adc	r26, r1
    43ce:	62 1f       	adc	r22, r18
    43d0:	73 9f       	mul	r23, r19
    43d2:	b0 0d       	add	r27, r0
    43d4:	a1 1d       	adc	r26, r1
    43d6:	62 1f       	adc	r22, r18
    43d8:	83 9f       	mul	r24, r19
    43da:	a0 0d       	add	r26, r0
    43dc:	61 1d       	adc	r22, r1
    43de:	22 1f       	adc	r18, r18
    43e0:	74 9f       	mul	r23, r20
    43e2:	33 27       	eor	r19, r19
    43e4:	a0 0d       	add	r26, r0
    43e6:	61 1d       	adc	r22, r1
    43e8:	23 1f       	adc	r18, r19
    43ea:	84 9f       	mul	r24, r20
    43ec:	60 0d       	add	r22, r0
    43ee:	21 1d       	adc	r18, r1
    43f0:	82 2f       	mov	r24, r18
    43f2:	76 2f       	mov	r23, r22
    43f4:	6a 2f       	mov	r22, r26
    43f6:	11 24       	eor	r1, r1
    43f8:	9f 57       	subi	r25, 0x7F	; 127
    43fa:	50 40       	sbci	r21, 0x00	; 0
    43fc:	9a f0       	brmi	.+38     	; 0x4424 <__mulsf3_pse+0x88>
    43fe:	f1 f0       	breq	.+60     	; 0x443c <__mulsf3_pse+0xa0>
    4400:	88 23       	and	r24, r24
    4402:	4a f0       	brmi	.+18     	; 0x4416 <__mulsf3_pse+0x7a>
    4404:	ee 0f       	add	r30, r30
    4406:	ff 1f       	adc	r31, r31
    4408:	bb 1f       	adc	r27, r27
    440a:	66 1f       	adc	r22, r22
    440c:	77 1f       	adc	r23, r23
    440e:	88 1f       	adc	r24, r24
    4410:	91 50       	subi	r25, 0x01	; 1
    4412:	50 40       	sbci	r21, 0x00	; 0
    4414:	a9 f7       	brne	.-22     	; 0x4400 <__mulsf3_pse+0x64>
    4416:	9e 3f       	cpi	r25, 0xFE	; 254
    4418:	51 05       	cpc	r21, r1
    441a:	80 f0       	brcs	.+32     	; 0x443c <__mulsf3_pse+0xa0>
    441c:	0c 94 62 21 	jmp	0x42c4	; 0x42c4 <__fp_inf>
    4420:	0c 94 ad 21 	jmp	0x435a	; 0x435a <__fp_szero>
    4424:	5f 3f       	cpi	r21, 0xFF	; 255
    4426:	e4 f3       	brlt	.-8      	; 0x4420 <__mulsf3_pse+0x84>
    4428:	98 3e       	cpi	r25, 0xE8	; 232
    442a:	d4 f3       	brlt	.-12     	; 0x4420 <__mulsf3_pse+0x84>
    442c:	86 95       	lsr	r24
    442e:	77 95       	ror	r23
    4430:	67 95       	ror	r22
    4432:	b7 95       	ror	r27
    4434:	f7 95       	ror	r31
    4436:	e7 95       	ror	r30
    4438:	9f 5f       	subi	r25, 0xFF	; 255
    443a:	c1 f7       	brne	.-16     	; 0x442c <__mulsf3_pse+0x90>
    443c:	fe 2b       	or	r31, r30
    443e:	88 0f       	add	r24, r24
    4440:	91 1d       	adc	r25, r1
    4442:	96 95       	lsr	r25
    4444:	87 95       	ror	r24
    4446:	97 f9       	bld	r25, 7
    4448:	08 95       	ret

0000444a <__mulsi3>:
    444a:	db 01       	movw	r26, r22
    444c:	8f 93       	push	r24
    444e:	9f 93       	push	r25
    4450:	0e 94 7f 22 	call	0x44fe	; 0x44fe <__muluhisi3>
    4454:	bf 91       	pop	r27
    4456:	af 91       	pop	r26
    4458:	a2 9f       	mul	r26, r18
    445a:	80 0d       	add	r24, r0
    445c:	91 1d       	adc	r25, r1
    445e:	a3 9f       	mul	r26, r19
    4460:	90 0d       	add	r25, r0
    4462:	b2 9f       	mul	r27, r18
    4464:	90 0d       	add	r25, r0
    4466:	11 24       	eor	r1, r1
    4468:	08 95       	ret

0000446a <__udivmodsi4>:
    446a:	a1 e2       	ldi	r26, 0x21	; 33
    446c:	1a 2e       	mov	r1, r26
    446e:	aa 1b       	sub	r26, r26
    4470:	bb 1b       	sub	r27, r27
    4472:	fd 01       	movw	r30, r26
    4474:	0d c0       	rjmp	.+26     	; 0x4490 <__udivmodsi4_ep>

00004476 <__udivmodsi4_loop>:
    4476:	aa 1f       	adc	r26, r26
    4478:	bb 1f       	adc	r27, r27
    447a:	ee 1f       	adc	r30, r30
    447c:	ff 1f       	adc	r31, r31
    447e:	a2 17       	cp	r26, r18
    4480:	b3 07       	cpc	r27, r19
    4482:	e4 07       	cpc	r30, r20
    4484:	f5 07       	cpc	r31, r21
    4486:	20 f0       	brcs	.+8      	; 0x4490 <__udivmodsi4_ep>
    4488:	a2 1b       	sub	r26, r18
    448a:	b3 0b       	sbc	r27, r19
    448c:	e4 0b       	sbc	r30, r20
    448e:	f5 0b       	sbc	r31, r21

00004490 <__udivmodsi4_ep>:
    4490:	66 1f       	adc	r22, r22
    4492:	77 1f       	adc	r23, r23
    4494:	88 1f       	adc	r24, r24
    4496:	99 1f       	adc	r25, r25
    4498:	1a 94       	dec	r1
    449a:	69 f7       	brne	.-38     	; 0x4476 <__udivmodsi4_loop>
    449c:	60 95       	com	r22
    449e:	70 95       	com	r23
    44a0:	80 95       	com	r24
    44a2:	90 95       	com	r25
    44a4:	9b 01       	movw	r18, r22
    44a6:	ac 01       	movw	r20, r24
    44a8:	bd 01       	movw	r22, r26
    44aa:	cf 01       	movw	r24, r30
    44ac:	08 95       	ret

000044ae <__divmodsi4>:
    44ae:	05 2e       	mov	r0, r21
    44b0:	97 fb       	bst	r25, 7
    44b2:	1e f4       	brtc	.+6      	; 0x44ba <__divmodsi4+0xc>
    44b4:	00 94       	com	r0
    44b6:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__negsi2>
    44ba:	57 fd       	sbrc	r21, 7
    44bc:	07 d0       	rcall	.+14     	; 0x44cc <__divmodsi4_neg2>
    44be:	0e 94 35 22 	call	0x446a	; 0x446a <__udivmodsi4>
    44c2:	07 fc       	sbrc	r0, 7
    44c4:	03 d0       	rcall	.+6      	; 0x44cc <__divmodsi4_neg2>
    44c6:	4e f4       	brtc	.+18     	; 0x44da <__divmodsi4_exit>
    44c8:	0c 94 6e 22 	jmp	0x44dc	; 0x44dc <__negsi2>

000044cc <__divmodsi4_neg2>:
    44cc:	50 95       	com	r21
    44ce:	40 95       	com	r20
    44d0:	30 95       	com	r19
    44d2:	21 95       	neg	r18
    44d4:	3f 4f       	sbci	r19, 0xFF	; 255
    44d6:	4f 4f       	sbci	r20, 0xFF	; 255
    44d8:	5f 4f       	sbci	r21, 0xFF	; 255

000044da <__divmodsi4_exit>:
    44da:	08 95       	ret

000044dc <__negsi2>:
    44dc:	90 95       	com	r25
    44de:	80 95       	com	r24
    44e0:	70 95       	com	r23
    44e2:	61 95       	neg	r22
    44e4:	7f 4f       	sbci	r23, 0xFF	; 255
    44e6:	8f 4f       	sbci	r24, 0xFF	; 255
    44e8:	9f 4f       	sbci	r25, 0xFF	; 255
    44ea:	08 95       	ret

000044ec <__tablejump2__>:
    44ec:	ee 0f       	add	r30, r30
    44ee:	ff 1f       	adc	r31, r31
    44f0:	88 1f       	adc	r24, r24
    44f2:	8b bf       	out	0x3b, r24	; 59
    44f4:	07 90       	elpm	r0, Z+
    44f6:	f6 91       	elpm	r31, Z
    44f8:	e0 2d       	mov	r30, r0
    44fa:	1b be       	out	0x3b, r1	; 59
    44fc:	19 94       	eijmp

000044fe <__muluhisi3>:
    44fe:	0e 94 8a 22 	call	0x4514	; 0x4514 <__umulhisi3>
    4502:	a5 9f       	mul	r26, r21
    4504:	90 0d       	add	r25, r0
    4506:	b4 9f       	mul	r27, r20
    4508:	90 0d       	add	r25, r0
    450a:	a4 9f       	mul	r26, r20
    450c:	80 0d       	add	r24, r0
    450e:	91 1d       	adc	r25, r1
    4510:	11 24       	eor	r1, r1
    4512:	08 95       	ret

00004514 <__umulhisi3>:
    4514:	a2 9f       	mul	r26, r18
    4516:	b0 01       	movw	r22, r0
    4518:	b3 9f       	mul	r27, r19
    451a:	c0 01       	movw	r24, r0
    451c:	a3 9f       	mul	r26, r19
    451e:	70 0d       	add	r23, r0
    4520:	81 1d       	adc	r24, r1
    4522:	11 24       	eor	r1, r1
    4524:	91 1d       	adc	r25, r1
    4526:	b2 9f       	mul	r27, r18
    4528:	70 0d       	add	r23, r0
    452a:	81 1d       	adc	r24, r1
    452c:	11 24       	eor	r1, r1
    452e:	91 1d       	adc	r25, r1
    4530:	08 95       	ret

00004532 <memcpy>:
    4532:	fb 01       	movw	r30, r22
    4534:	dc 01       	movw	r26, r24
    4536:	02 c0       	rjmp	.+4      	; 0x453c <memcpy+0xa>
    4538:	01 90       	ld	r0, Z+
    453a:	0d 92       	st	X+, r0
    453c:	41 50       	subi	r20, 0x01	; 1
    453e:	50 40       	sbci	r21, 0x00	; 0
    4540:	d8 f7       	brcc	.-10     	; 0x4538 <memcpy+0x6>
    4542:	08 95       	ret

00004544 <memset>:
    4544:	dc 01       	movw	r26, r24
    4546:	01 c0       	rjmp	.+2      	; 0x454a <memset+0x6>
    4548:	6d 93       	st	X+, r22
    454a:	41 50       	subi	r20, 0x01	; 1
    454c:	50 40       	sbci	r21, 0x00	; 0
    454e:	e0 f7       	brcc	.-8      	; 0x4548 <memset+0x4>
    4550:	08 95       	ret

00004552 <strncpy>:
    4552:	fb 01       	movw	r30, r22
    4554:	dc 01       	movw	r26, r24
    4556:	41 50       	subi	r20, 0x01	; 1
    4558:	50 40       	sbci	r21, 0x00	; 0
    455a:	48 f0       	brcs	.+18     	; 0x456e <strncpy+0x1c>
    455c:	01 90       	ld	r0, Z+
    455e:	0d 92       	st	X+, r0
    4560:	00 20       	and	r0, r0
    4562:	c9 f7       	brne	.-14     	; 0x4556 <strncpy+0x4>
    4564:	01 c0       	rjmp	.+2      	; 0x4568 <strncpy+0x16>
    4566:	1d 92       	st	X+, r1
    4568:	41 50       	subi	r20, 0x01	; 1
    456a:	50 40       	sbci	r21, 0x00	; 0
    456c:	e0 f7       	brcc	.-8      	; 0x4566 <strncpy+0x14>
    456e:	08 95       	ret

00004570 <__itoa_ncheck>:
    4570:	bb 27       	eor	r27, r27
    4572:	4a 30       	cpi	r20, 0x0A	; 10
    4574:	31 f4       	brne	.+12     	; 0x4582 <__itoa_ncheck+0x12>
    4576:	99 23       	and	r25, r25
    4578:	22 f4       	brpl	.+8      	; 0x4582 <__itoa_ncheck+0x12>
    457a:	bd e2       	ldi	r27, 0x2D	; 45
    457c:	90 95       	com	r25
    457e:	81 95       	neg	r24
    4580:	9f 4f       	sbci	r25, 0xFF	; 255
    4582:	0c 94 fc 22 	jmp	0x45f8	; 0x45f8 <__utoa_common>

00004586 <ultoa>:
    4586:	25 32       	cpi	r18, 0x25	; 37
    4588:	31 05       	cpc	r19, r1
    458a:	20 f4       	brcc	.+8      	; 0x4594 <ultoa+0xe>
    458c:	22 30       	cpi	r18, 0x02	; 2
    458e:	10 f0       	brcs	.+4      	; 0x4594 <ultoa+0xe>
    4590:	0c 94 ce 22 	jmp	0x459c	; 0x459c <__ultoa_ncheck>
    4594:	fa 01       	movw	r30, r20
    4596:	10 82       	st	Z, r1
    4598:	ca 01       	movw	r24, r20
    459a:	08 95       	ret

0000459c <__ultoa_ncheck>:
    459c:	bb 27       	eor	r27, r27

0000459e <__ultoa_common>:
    459e:	fa 01       	movw	r30, r20
    45a0:	a6 2f       	mov	r26, r22
    45a2:	62 17       	cp	r22, r18
    45a4:	71 05       	cpc	r23, r1
    45a6:	81 05       	cpc	r24, r1
    45a8:	91 05       	cpc	r25, r1
    45aa:	33 0b       	sbc	r19, r19
    45ac:	30 fb       	bst	r19, 0
    45ae:	66 f0       	brts	.+24     	; 0x45c8 <__ultoa_common+0x2a>
    45b0:	aa 27       	eor	r26, r26
    45b2:	66 0f       	add	r22, r22
    45b4:	77 1f       	adc	r23, r23
    45b6:	88 1f       	adc	r24, r24
    45b8:	99 1f       	adc	r25, r25
    45ba:	aa 1f       	adc	r26, r26
    45bc:	a2 17       	cp	r26, r18
    45be:	10 f0       	brcs	.+4      	; 0x45c4 <__ultoa_common+0x26>
    45c0:	a2 1b       	sub	r26, r18
    45c2:	63 95       	inc	r22
    45c4:	38 50       	subi	r19, 0x08	; 8
    45c6:	a9 f7       	brne	.-22     	; 0x45b2 <__ultoa_common+0x14>
    45c8:	a0 5d       	subi	r26, 0xD0	; 208
    45ca:	aa 33       	cpi	r26, 0x3A	; 58
    45cc:	08 f0       	brcs	.+2      	; 0x45d0 <__ultoa_common+0x32>
    45ce:	a9 5d       	subi	r26, 0xD9	; 217
    45d0:	a1 93       	st	Z+, r26
    45d2:	36 f7       	brtc	.-52     	; 0x45a0 <__ultoa_common+0x2>
    45d4:	b1 11       	cpse	r27, r1
    45d6:	b1 93       	st	Z+, r27
    45d8:	10 82       	st	Z, r1
    45da:	ca 01       	movw	r24, r20
    45dc:	0c 94 15 23 	jmp	0x462a	; 0x462a <strrev>

000045e0 <utoa>:
    45e0:	45 32       	cpi	r20, 0x25	; 37
    45e2:	51 05       	cpc	r21, r1
    45e4:	20 f4       	brcc	.+8      	; 0x45ee <utoa+0xe>
    45e6:	42 30       	cpi	r20, 0x02	; 2
    45e8:	10 f0       	brcs	.+4      	; 0x45ee <utoa+0xe>
    45ea:	0c 94 fb 22 	jmp	0x45f6	; 0x45f6 <__utoa_ncheck>
    45ee:	fb 01       	movw	r30, r22
    45f0:	10 82       	st	Z, r1
    45f2:	cb 01       	movw	r24, r22
    45f4:	08 95       	ret

000045f6 <__utoa_ncheck>:
    45f6:	bb 27       	eor	r27, r27

000045f8 <__utoa_common>:
    45f8:	fb 01       	movw	r30, r22
    45fa:	55 27       	eor	r21, r21
    45fc:	aa 27       	eor	r26, r26
    45fe:	88 0f       	add	r24, r24
    4600:	99 1f       	adc	r25, r25
    4602:	aa 1f       	adc	r26, r26
    4604:	a4 17       	cp	r26, r20
    4606:	10 f0       	brcs	.+4      	; 0x460c <__utoa_common+0x14>
    4608:	a4 1b       	sub	r26, r20
    460a:	83 95       	inc	r24
    460c:	50 51       	subi	r21, 0x10	; 16
    460e:	b9 f7       	brne	.-18     	; 0x45fe <__utoa_common+0x6>
    4610:	a0 5d       	subi	r26, 0xD0	; 208
    4612:	aa 33       	cpi	r26, 0x3A	; 58
    4614:	08 f0       	brcs	.+2      	; 0x4618 <__utoa_common+0x20>
    4616:	a9 5d       	subi	r26, 0xD9	; 217
    4618:	a1 93       	st	Z+, r26
    461a:	00 97       	sbiw	r24, 0x00	; 0
    461c:	79 f7       	brne	.-34     	; 0x45fc <__utoa_common+0x4>
    461e:	b1 11       	cpse	r27, r1
    4620:	b1 93       	st	Z+, r27
    4622:	11 92       	st	Z+, r1
    4624:	cb 01       	movw	r24, r22
    4626:	0c 94 15 23 	jmp	0x462a	; 0x462a <strrev>

0000462a <strrev>:
    462a:	dc 01       	movw	r26, r24
    462c:	fc 01       	movw	r30, r24
    462e:	67 2f       	mov	r22, r23
    4630:	71 91       	ld	r23, Z+
    4632:	77 23       	and	r23, r23
    4634:	e1 f7       	brne	.-8      	; 0x462e <strrev+0x4>
    4636:	32 97       	sbiw	r30, 0x02	; 2
    4638:	04 c0       	rjmp	.+8      	; 0x4642 <strrev+0x18>
    463a:	7c 91       	ld	r23, X
    463c:	6d 93       	st	X+, r22
    463e:	70 83       	st	Z, r23
    4640:	62 91       	ld	r22, -Z
    4642:	ae 17       	cp	r26, r30
    4644:	bf 07       	cpc	r27, r31
    4646:	c8 f3       	brcs	.-14     	; 0x463a <strrev+0x10>
    4648:	08 95       	ret

0000464a <_exit>:
    464a:	f8 94       	cli

0000464c <__stop_program>:
    464c:	ff cf       	rjmp	.-2      	; 0x464c <__stop_program>
