
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ca  00802000  000040a4  00004138  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ae  008020ca  008020ca  00004202  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004202  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004234  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c0  00000000  00000000  00004274  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011cfb  00000000  00000000  00004934  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000076ab  00000000  00000000  0001662f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005025  00000000  00000000  0001dcda  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001300  00000000  00000000  00022d00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006ce1  00000000  00000000  00024000  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005cb9  00000000  00000000  0002ace1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000590  00000000  00000000  0003099a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ab 02 	jmp	0x556	; 0x556 <__ctors_end>
       4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
       8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
       c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      10:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      14:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      18:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      1c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      20:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      24:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      28:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      2c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      30:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      34:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      38:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      3c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      40:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      44:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      48:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      4c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      50:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      54:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      58:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      5c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      60:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      64:	0c 94 38 1a 	jmp	0x3470	; 0x3470 <__vector_25>
      68:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      6c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      70:	0c 94 96 1a 	jmp	0x352c	; 0x352c <__vector_28>
      74:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      78:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      7c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      80:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      84:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      88:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      8c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      90:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      94:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      98:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      9c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      ac:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      bc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      cc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      dc:	0c 94 16 0a 	jmp	0x142c	; 0x142c <__vector_55>
      e0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      e4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      e8:	0c 94 b0 1b 	jmp	0x3760	; 0x3760 <__vector_58>
      ec:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      f0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      f4:	0c 94 0e 1c 	jmp	0x381c	; 0x381c <__vector_61>
      f8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      fc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     100:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     104:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     108:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     10c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     110:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     114:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     118:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     11c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     120:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     124:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     128:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     12c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     130:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     134:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     138:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     13c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     140:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     144:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     148:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     14c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     150:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     154:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     158:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     15c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     160:	0c 94 f4 1a 	jmp	0x35e8	; 0x35e8 <__vector_88>
     164:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     168:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     16c:	0c 94 52 1b 	jmp	0x36a4	; 0x36a4 <__vector_91>
     170:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     174:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     178:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     17c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     180:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     184:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     188:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     18c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     190:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     194:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     198:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     19c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1ac:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1bc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1cc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1dc:	0c 94 6c 1c 	jmp	0x38d8	; 0x38d8 <__vector_119>
     1e0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1e4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1e8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1ec:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1fc:	02 18       	sub	r0, r2
     1fe:	05 18       	sub	r0, r5
     200:	08 18       	sub	r0, r8
     202:	0b 18       	sub	r0, r11
     204:	0e 18       	sub	r0, r14
     206:	11 18       	sub	r1, r1
     208:	13 18       	sub	r1, r3
     20a:	24 18       	sub	r2, r4
     20c:	2c 18       	sub	r2, r12
     20e:	36 18       	sub	r3, r6
     210:	34 18       	sub	r3, r4

00000212 <__trampolines_start>:
     212:	0c 94 49 04 	jmp	0x892	; 0x892 <_ZN3pid3runEv>
     216:	0c 94 7f 1d 	jmp	0x3afe	; 0x3afe <_GLOBAL__sub_I_counter>
     21a:	0c 94 3c 15 	jmp	0x2a78	; 0x2a78 <_ZN14frt_text_queue7putcharEc>
     21e:	0c 94 36 18 	jmp	0x306c	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
     222:	0c 94 08 18 	jmp	0x3010	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     226:	0c 94 a5 17 	jmp	0x2f4a	; 0x2f4a <_ZN8emstream13ready_to_sendEv>
     22a:	0c 94 0e 18 	jmp	0x301c	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x36>
     22e:	0c 94 a7 17 	jmp	0x2f4e	; 0x2f4e <_ZN8emstream7getcharEv>
     232:	0c 94 a8 02 	jmp	0x550	; 0x550 <_call_static_run_method>
     236:	0c 94 ac 17 	jmp	0x2f58	; 0x2f58 <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 0b 18 	jmp	0x3016	; 0x3016 <_ZN8emstreamlsE15ser_manipulator+0x30>
     23e:	0c 94 13 18 	jmp	0x3026	; 0x3026 <_ZN8emstreamlsE15ser_manipulator+0x40>
     242:	0c 94 ad 17 	jmp	0x2f5a	; 0x2f5a <_ZN8emstream12clear_screenEv>
     246:	0c 94 31 15 	jmp	0x2a62	; 0x2a62 <_ZN14frt_text_queue14check_for_charEv>
     24a:	0c 94 17 04 	jmp	0x82e	; 0x82e <_ZN5Motor3runEv>
     24e:	0c 94 7b 04 	jmp	0x8f6	; 0x8f6 <_ZN9PWMdriver3runEv>
     252:	0c 94 24 18 	jmp	0x3048	; 0x3048 <_ZN8emstreamlsE15ser_manipulator+0x62>
     256:	0c 94 e5 03 	jmp	0x7ca	; 0x7ca <_ZN13LimitSwitches3runEv>
     25a:	0c 94 c9 13 	jmp	0x2792	; 0x2792 <_ZN8frt_task12print_statusER8emstream>
     25e:	0c 94 f4 16 	jmp	0x2de8	; 0x2de8 <__cxa_pure_virtual>
     262:	0c 94 02 18 	jmp	0x3004	; 0x3004 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     266:	0c 94 94 03 	jmp	0x728	; 0x728 <_ZN15EncoderPendulum3runEv>
     26a:	0c 94 9a 0c 	jmp	0x1934	; 0x1934 <prvIdleTask>
     26e:	0c 94 11 18 	jmp	0x3022	; 0x3022 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     272:	0c 94 aa 17 	jmp	0x2f54	; 0x2f54 <_ZN8emstream14check_for_charEv>
     276:	0c 94 30 19 	jmp	0x3260	; 0x3260 <_ZN5rs2327putcharEc>
     27a:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <_ZN12EncoderMotor3runEv>
     27e:	0c 94 7a 19 	jmp	0x32f4	; 0x32f4 <_ZN5rs23214check_for_charEv>
     282:	0c 94 13 15 	jmp	0x2a26	; 0x2a26 <_ZN14frt_text_queue7getcharEv>
     286:	0c 94 f0 05 	jmp	0xbe0	; 0xbe0 <_ZN9task_user3runEv>
     28a:	0c 94 05 18 	jmp	0x300a	; 0x300a <_ZN8emstreamlsE15ser_manipulator+0x24>
     28e:	0c 94 34 18 	jmp	0x3068	; 0x3068 <_ZN8emstreamlsE15ser_manipulator+0x82>
     292:	0c 94 2c 18 	jmp	0x3058	; 0x3058 <_ZN8emstreamlsE15ser_manipulator+0x72>
     296:	0c 94 8d 19 	jmp	0x331a	; 0x331a <_ZN5rs23212clear_screenEv>
     29a:	0c 94 54 19 	jmp	0x32a8	; 0x32a8 <_ZN5rs2327getcharEv>

0000029e <__trampolines_end>:
     29e:	2c 20       	and	r2, r12
     2a0:	54 43       	sbci	r21, 0x34	; 52
     2a2:	43 30       	cpi	r20, 0x03	; 3
     2a4:	43 43       	sbci	r20, 0x33	; 51
     2a6:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a9 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a9:	2f 00                                               /.

000002ab <_ZZN9task_user11show_statusEvE3__c_2>:
     2ab:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b9 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b9:	54 69 6d 65 3a 20 00                                Time: .

000002c0 <_ZZN9task_user11show_statusEvE3__c_0>:
     2c0:	4e 6f 76 20 32 35 20 32 30 31 37 00                 Nov 25 2017.

000002cc <_ZZN9task_user11show_statusEvE3__c>:
     2cc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2dc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002eb <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2eb:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002fa <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2fa:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     30a:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000315 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     315:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     325:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000333 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     333:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     343:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     353:	6d 61 74 69 6f 6e 00                                mation.

0000035a <_ZZN9task_user18print_help_messageEvE3__c_6>:
     35a:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     36a:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000037b <_ZZN9task_user18print_help_messageEvE3__c_5>:
     37b:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     38b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000393 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     393:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     3a3:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003af <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3af:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bf:	68 65 20 41 56 52 00                                he AVR.

000003c6 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c6:	20 68 65 6c 70 00                                    help.

000003cc <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3cc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3dc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003eb <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3eb:	1b 5b 33 30 6d 00                                   .[30m.

000003f1 <_ZZN9task_user18print_help_messageEvE3__c>:
     3f1:	1b 5b 34 36 6d 00                                   .[46m.

000003f7 <_ZZN9task_user3runEvE3__c_3>:
     3f7:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     407:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000414 <_ZZN9task_user3runEvE3__c_2>:
     414:	3a 57 54 46 3f 00                                   :WTF?.

0000041a <_ZZN9task_user3runEvE3__c_1>:
     41a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     42a:	65 00                                               e.

0000042c <_ZZN9task_user3runEvE3__c_0>:
     42c:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000043a <_ZZN9task_user3runEvE3__c>:
     43a:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     44a:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000458 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     458:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000462 <_ZZN8frt_task15emergency_resetEvE3__c>:
     462:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000471 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     471:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     481:	61 73 6b 20 00                                      ask .

00000486 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     486:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000494 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     494:	20 63 72 65 61 74 65 64 00                           created.

0000049d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     49d:	54 61 73 6b 20 00                                   Task .

000004a3 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     4a3:	1b 5b 32 32 6d 00                                   .[22m.

000004a9 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a9:	54 61 73 6b 3a 20 00                                Task: .

000004b0 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4b0:	1b 5b 31 6d 00                                      .[1m.

000004b5 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b5:	1b 5b 32 32 6d 00                                   .[22m.

000004bb <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4bb:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c6 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c6:	1b 5b 31 6d 00                                      .[1m.

000004cb <_ZZ15print_task_listP8emstreamE3__c_9>:
     4cb:	09 09 00                                            ...

000004ce <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ce:	2f 00                                               /.

000004d0 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4d0:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004db <_ZZ15print_task_listP8emstreamE3__c_6>:
     4db:	09 2d 2d 2d 2d 00                                   .----.

000004e1 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4e1:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004ed <_ZZ15print_task_listP8emstreamE3__c_4>:
     4ed:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fe <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fe:	09 52 75 6e 73 00                                   .Runs.

00000504 <_ZZ15print_task_listP8emstreamE3__c_2>:
     504:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000510 <_ZZ15print_task_listP8emstreamE3__c_1>:
     510:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000521 <_ZZ15print_task_listP8emstreamE3__c_0>:
     521:	09 53 74 61 63 6b 00                                .Stack.

00000528 <_ZZ15print_task_listP8emstreamE3__c>:
     528:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     533:	09 00                                               ..

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     537:	2f 00                                               /.

00000539 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     539:	09 00                                               ..

0000053b <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     53b:	09 00                                               ..

0000053d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     53d:	1b 5b 32 32 6d 00                                   .[22m.

00000543 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     543:	1b 5b 31 6d 00                                      .[1m.

00000548 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     548:	1b 5b 31 6d 00                                      .[1m.

0000054d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     54d:	20 20 00                                              .

00000550 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     550:	0e 94 61 12 	call	0x24c2	; 0x24c2 <_ZN8frt_task22_call_users_run_methodEPS_>

00000554 <__ctors_start>:
     554:	7f 1d       	adc	r23, r15

00000556 <__ctors_end>:
     556:	11 24       	eor	r1, r1
     558:	1f be       	out	0x3f, r1	; 63
     55a:	cf ef       	ldi	r28, 0xFF	; 255
     55c:	cd bf       	out	0x3d, r28	; 61
     55e:	df e3       	ldi	r29, 0x3F	; 63
     560:	de bf       	out	0x3e, r29	; 62
     562:	00 e0       	ldi	r16, 0x00	; 0
     564:	0c bf       	out	0x3c, r16	; 60
     566:	18 be       	out	0x38, r1	; 56
     568:	19 be       	out	0x39, r1	; 57
     56a:	1a be       	out	0x3a, r1	; 58
     56c:	1b be       	out	0x3b, r1	; 59

0000056e <__do_copy_data>:
     56e:	10 e2       	ldi	r17, 0x20	; 32
     570:	a0 e0       	ldi	r26, 0x00	; 0
     572:	b0 e2       	ldi	r27, 0x20	; 32
     574:	e4 ea       	ldi	r30, 0xA4	; 164
     576:	f0 e4       	ldi	r31, 0x40	; 64
     578:	00 e0       	ldi	r16, 0x00	; 0
     57a:	0b bf       	out	0x3b, r16	; 59
     57c:	02 c0       	rjmp	.+4      	; 0x582 <__do_copy_data+0x14>
     57e:	07 90       	elpm	r0, Z+
     580:	0d 92       	st	X+, r0
     582:	aa 3c       	cpi	r26, 0xCA	; 202
     584:	b1 07       	cpc	r27, r17
     586:	d9 f7       	brne	.-10     	; 0x57e <__do_copy_data+0x10>
     588:	1b be       	out	0x3b, r1	; 59

0000058a <__do_clear_bss>:
     58a:	21 e3       	ldi	r18, 0x31	; 49
     58c:	aa ec       	ldi	r26, 0xCA	; 202
     58e:	b0 e2       	ldi	r27, 0x20	; 32
     590:	01 c0       	rjmp	.+2      	; 0x594 <.do_clear_bss_start>

00000592 <.do_clear_bss_loop>:
     592:	1d 92       	st	X+, r1

00000594 <.do_clear_bss_start>:
     594:	a8 37       	cpi	r26, 0x78	; 120
     596:	b2 07       	cpc	r27, r18
     598:	e1 f7       	brne	.-8      	; 0x592 <.do_clear_bss_loop>

0000059a <__do_global_ctors>:
     59a:	12 e0       	ldi	r17, 0x02	; 2
     59c:	cb ea       	ldi	r28, 0xAB	; 171
     59e:	d2 e0       	ldi	r29, 0x02	; 2
     5a0:	00 e0       	ldi	r16, 0x00	; 0
     5a2:	06 c0       	rjmp	.+12     	; 0x5b0 <__do_global_ctors+0x16>
     5a4:	21 97       	sbiw	r28, 0x01	; 1
     5a6:	01 09       	sbc	r16, r1
     5a8:	80 2f       	mov	r24, r16
     5aa:	fe 01       	movw	r30, r28
     5ac:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <__tablejump2__>
     5b0:	ca 3a       	cpi	r28, 0xAA	; 170
     5b2:	d1 07       	cpc	r29, r17
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	08 07       	cpc	r16, r24
     5b8:	a9 f7       	brne	.-22     	; 0x5a4 <__do_global_ctors+0xa>
     5ba:	0e 94 df 1c 	call	0x39be	; 0x39be <main>
     5be:	0c 94 50 20 	jmp	0x40a0	; 0x40a0 <_exit>

000005c2 <__bad_interrupt>:
     5c2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c6 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	00 d0       	rcall	.+0      	; 0x5cc <_ZN12EncoderMotor3runEv+0x6>
     5cc:	1f 92       	push	r1
     5ce:	cd b7       	in	r28, 0x3d	; 61
     5d0:	de b7       	in	r29, 0x3e	; 62
     5d2:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d4:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <xTaskGetTickCount>
     5d8:	69 83       	std	Y+1, r22	; 0x01
     5da:	7a 83       	std	Y+2, r23	; 0x02
     5dc:	8b 83       	std	Y+3, r24	; 0x03
     5de:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTC.DIRCLR = PIN0_bm | PIN1_bm;										// Set both CHa and CHb for input
     5e0:	e0 e4       	ldi	r30, 0x40	; 64
     5e2:	f6 e0       	ldi	r31, 0x06	; 6
     5e4:	83 e0       	ldi	r24, 0x03	; 3
     5e6:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN0CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e8:	80 89       	ldd	r24, Z+16	; 0x10
     5ea:	83 60       	ori	r24, 0x03	; 3
     5ec:	80 8b       	std	Z+16, r24	; 0x10
	PORTC.PIN1CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ee:	81 89       	ldd	r24, Z+17	; 0x11
     5f0:	83 60       	ori	r24, 0x03	; 3
     5f2:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTC_PIN0_gc;								// Configure CHa as a multiplexer input for event channel 0
     5f4:	e0 e8       	ldi	r30, 0x80	; 128
     5f6:	f1 e0       	ldi	r31, 0x01	; 1
     5f8:	80 e6       	ldi	r24, 0x60	; 96
     5fa:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5fc:	89 e0       	ldi	r24, 0x09	; 9
     5fe:	80 87       	std	Z+8, r24	; 0x08
	
	TCC0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     600:	e0 e0       	ldi	r30, 0x00	; 0
     602:	f8 e0       	ldi	r31, 0x08	; 8
     604:	88 e6       	ldi	r24, 0x68	; 104
     606:	83 83       	std	Z+3, r24	; 0x03
	TCC0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     608:	8f ef       	ldi	r24, 0xFF	; 255
     60a:	9f ef       	ldi	r25, 0xFF	; 255
     60c:	86 a3       	std	Z+38, r24	; 0x26
     60e:	97 a3       	std	Z+39, r25	; 0x27
	TCC0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     610:	81 e0       	ldi	r24, 0x01	; 1
     612:	80 83       	st	Z, r24
	int16_t angularVelocity;
	float x_calc;
	int16_t x;

	while(1){
		encoder_count = TCC0.CNT;											// get count
     614:	a1 2c       	mov	r10, r1
     616:	68 94       	set
     618:	bb 24       	eor	r11, r11
     61a:	b3 f8       	bld	r11, 3
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     61c:	0f 2e       	mov	r0, r31
     61e:	f4 e6       	ldi	r31, 0x64	; 100
     620:	cf 2e       	mov	r12, r31
     622:	d1 2c       	mov	r13, r1
     624:	f0 2d       	mov	r31, r0
     626:	0f 2e       	mov	r0, r31
     628:	fc e3       	ldi	r31, 0x3C	; 60
     62a:	9f 2e       	mov	r9, r31
     62c:	f0 2d       	mov	r31, r0
     62e:	f5 01       	movw	r30, r10
     630:	00 a1       	ldd	r16, Z+32	; 0x20
     632:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     634:	0f b6       	in	r0, 0x3f	; 63
     636:	f8 94       	cli
     638:	0f 92       	push	r0
			the_data = new_data;
     63a:	b8 01       	movw	r22, r16
     63c:	01 2e       	mov	r0, r17
     63e:	00 0c       	add	r0, r0
     640:	88 0b       	sbc	r24, r24
     642:	99 0b       	sbc	r25, r25
     644:	0e 94 3a 1e 	call	0x3c74	; 0x3c74 <__floatsisf>
     648:	20 e0       	ldi	r18, 0x00	; 0
     64a:	30 e0       	ldi	r19, 0x00	; 0
     64c:	4a e7       	ldi	r20, 0x7A	; 122
     64e:	55 e4       	ldi	r21, 0x45	; 69
     650:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <__divsf3>
     654:	20 e0       	ldi	r18, 0x00	; 0
     656:	30 e0       	ldi	r19, 0x00	; 0
     658:	44 eb       	ldi	r20, 0xB4	; 180
     65a:	53 e4       	ldi	r21, 0x43	; 67
     65c:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <__mulsf3>
     660:	0e 94 02 1e 	call	0x3c04	; 0x3c04 <__fixsfsi>
     664:	60 93 62 31 	sts	0x3162, r22	; 0x803162 <thMotor>
     668:	70 93 63 31 	sts	0x3163, r23	; 0x803163 <thMotor+0x1>
			portEXIT_CRITICAL ();
     66c:	0f 90       	pop	r0
     66e:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     670:	0f b6       	in	r0, 0x3f	; 63
     672:	f8 94       	cli
     674:	0f 92       	push	r0
			the_data = new_data;
     676:	c8 01       	movw	r24, r16
     678:	88 0f       	add	r24, r24
     67a:	99 1f       	adc	r25, r25
     67c:	80 0f       	add	r24, r16
     67e:	91 1f       	adc	r25, r17
     680:	b6 01       	movw	r22, r12
     682:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <__divmodhi4>
     686:	60 93 64 31 	sts	0x3164, r22	; 0x803164 <linear_position>
     68a:	70 93 65 31 	sts	0x3165, r23	; 0x803165 <linear_position+0x1>
			portEXIT_CRITICAL ();
     68e:	0f 90       	pop	r0
     690:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     692:	0f b6       	in	r0, 0x3f	; 63
     694:	f8 94       	cli
     696:	0f 92       	push	r0
			the_data = new_data;
     698:	c8 01       	movw	r24, r16
     69a:	86 19       	sub	r24, r6
     69c:	97 09       	sbc	r25, r7
     69e:	98 9e       	mul	r9, r24
     6a0:	b0 01       	movw	r22, r0
     6a2:	99 9e       	mul	r9, r25
     6a4:	70 0d       	add	r23, r0
     6a6:	11 24       	eor	r1, r1
     6a8:	07 2e       	mov	r0, r23
     6aa:	00 0c       	add	r0, r0
     6ac:	88 0b       	sbc	r24, r24
     6ae:	99 0b       	sbc	r25, r25
     6b0:	0e 94 3a 1e 	call	0x3c74	; 0x3c74 <__floatsisf>
     6b4:	20 e0       	ldi	r18, 0x00	; 0
     6b6:	30 e0       	ldi	r19, 0x00	; 0
     6b8:	4a e7       	ldi	r20, 0x7A	; 122
     6ba:	55 e4       	ldi	r21, 0x45	; 69
     6bc:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <__divsf3>
     6c0:	2f e6       	ldi	r18, 0x6F	; 111
     6c2:	32 e1       	ldi	r19, 0x12	; 18
     6c4:	43 e8       	ldi	r20, 0x83	; 131
     6c6:	5a e3       	ldi	r21, 0x3A	; 58
     6c8:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <__divsf3>
     6cc:	0e 94 02 1e 	call	0x3c04	; 0x3c04 <__fixsfsi>
     6d0:	60 93 60 31 	sts	0x3160, r22	; 0x803160 <thdMotor>
     6d4:	70 93 61 31 	sts	0x3161, r23	; 0x803161 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     6d8:	0f 90       	pop	r0
     6da:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     6dc:	f7 01       	movw	r30, r14
     6de:	86 85       	ldd	r24, Z+14	; 0x0e
     6e0:	97 85       	ldd	r25, Z+15	; 0x0f
     6e2:	a0 89       	ldd	r26, Z+16	; 0x10
     6e4:	b1 89       	ldd	r27, Z+17	; 0x11
     6e6:	01 96       	adiw	r24, 0x01	; 1
     6e8:	a1 1d       	adc	r26, r1
     6ea:	b1 1d       	adc	r27, r1
     6ec:	86 87       	std	Z+14, r24	; 0x0e
     6ee:	97 87       	std	Z+15, r25	; 0x0f
     6f0:	a0 8b       	std	Z+16, r26	; 0x10
     6f2:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     6f4:	41 e0       	ldi	r20, 0x01	; 1
     6f6:	50 e0       	ldi	r21, 0x00	; 0
     6f8:	60 e0       	ldi	r22, 0x00	; 0
     6fa:	70 e0       	ldi	r23, 0x00	; 0
     6fc:	ce 01       	movw	r24, r28
     6fe:	01 96       	adiw	r24, 0x01	; 1
     700:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <vTaskDelayUntil>
		angularVelocityCalc = ((int16_t) (encoder_count-last_encoder_count))*60/(4.00000*1000.00000)/dt;	// convert to velocity [RPM]
		angularVelocity = angularVelocityCalc;
		//*p_serial << "Angular Velocity: " << AngularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     704:	38 01       	movw	r6, r16
     706:	93 cf       	rjmp	.-218    	; 0x62e <_ZN12EncoderMotor3runEv+0x68>

00000708 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     708:	0f 93       	push	r16
     70a:	1f 93       	push	r17
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     712:	0e 94 74 12 	call	0x24e8	; 0x24e8 <_ZN8frt_taskC1EPKchjP8emstream>
     716:	8a e0       	ldi	r24, 0x0A	; 10
     718:	90 e2       	ldi	r25, 0x20	; 32
     71a:	88 83       	st	Y, r24
     71c:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     71e:	df 91       	pop	r29
     720:	cf 91       	pop	r28
     722:	1f 91       	pop	r17
     724:	0f 91       	pop	r16
     726:	08 95       	ret

00000728 <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     728:	cf 93       	push	r28
     72a:	df 93       	push	r29
     72c:	00 d0       	rcall	.+0      	; 0x72e <_ZN15EncoderPendulum3runEv+0x6>
     72e:	1f 92       	push	r1
     730:	cd b7       	in	r28, 0x3d	; 61
     732:	de b7       	in	r29, 0x3e	; 62
     734:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     736:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <xTaskGetTickCount>
     73a:	69 83       	std	Y+1, r22	; 0x01
     73c:	7a 83       	std	Y+2, r23	; 0x02
     73e:	8b 83       	std	Y+3, r24	; 0x03
     740:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTC.DIRCLR = (PIN4_bm | PIN5_bm);							// set C4 & C5 as inputs
     742:	e0 e4       	ldi	r30, 0x40	; 64
     744:	f6 e0       	ldi	r31, 0x06	; 6
     746:	80 e3       	ldi	r24, 0x30	; 48
     748:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN4CTRL = PORT_ISC_LEVEL_gc;							// set C4 for level sensing
     74a:	83 e0       	ldi	r24, 0x03	; 3
     74c:	84 8b       	std	Z+20, r24	; 0x14
	PORTC.PIN5CTRL = PORT_ISC_LEVEL_gc;							// set C5 for level sensing
     74e:	85 8b       	std	Z+21, r24	; 0x15
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTC_PIN4_gc;					// set PC4 as Multiplexer for Event Chan 0
     750:	e0 e8       	ldi	r30, 0x80	; 128
     752:	f1 e0       	ldi	r31, 0x01	; 1
     754:	84 e6       	ldi	r24, 0x64	; 100
     756:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     758:	89 e0       	ldi	r24, 0x09	; 9
     75a:	80 87       	std	Z+8, r24	; 0x08
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH1_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     75c:	e0 e4       	ldi	r30, 0x40	; 64
     75e:	f8 e0       	ldi	r31, 0x08	; 8
     760:	89 e6       	ldi	r24, 0x69	; 105
     762:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0xFFFF;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     764:	8f ef       	ldi	r24, 0xFF	; 255
     766:	9f ef       	ldi	r25, 0xFF	; 255
     768:	86 a3       	std	Z+38, r24	; 0x26
     76a:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	80 83       	st	Z, r24
	
	uint16_t count;												// contains the current encoder value
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT;
     770:	68 94       	set
     772:	ee 24       	eor	r14, r14
     774:	e6 f8       	bld	r14, 6
     776:	ff 24       	eor	r15, r15
     778:	f3 f8       	bld	r15, 3
     77a:	f7 01       	movw	r30, r14
     77c:	80 a1       	ldd	r24, Z+32	; 0x20
     77e:	91 a1       	ldd	r25, Z+33	; 0x21
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     780:	f8 01       	movw	r30, r16
     782:	86 85       	ldd	r24, Z+14	; 0x0e
     784:	97 85       	ldd	r25, Z+15	; 0x0f
     786:	a0 89       	ldd	r26, Z+16	; 0x10
     788:	b1 89       	ldd	r27, Z+17	; 0x11
     78a:	01 96       	adiw	r24, 0x01	; 1
     78c:	a1 1d       	adc	r26, r1
     78e:	b1 1d       	adc	r27, r1
     790:	86 87       	std	Z+14, r24	; 0x0e
     792:	97 87       	std	Z+15, r25	; 0x0f
     794:	a0 8b       	std	Z+16, r26	; 0x10
     796:	b1 8b       	std	Z+17, r27	; 0x11
     798:	41 e0       	ldi	r20, 0x01	; 1
     79a:	50 e0       	ldi	r21, 0x00	; 0
     79c:	60 e0       	ldi	r22, 0x00	; 0
     79e:	70 e0       	ldi	r23, 0x00	; 0
     7a0:	ce 01       	movw	r24, r28
     7a2:	01 96       	adiw	r24, 0x01	; 1
     7a4:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <vTaskDelayUntil>
     7a8:	e8 cf       	rjmp	.-48     	; 0x77a <_ZN15EncoderPendulum3runEv+0x52>

000007aa <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     7aa:	0f 93       	push	r16
     7ac:	1f 93       	push	r17
     7ae:	cf 93       	push	r28
     7b0:	df 93       	push	r29
     7b2:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7b4:	0e 94 74 12 	call	0x24e8	; 0x24e8 <_ZN8frt_taskC1EPKchjP8emstream>
     7b8:	82 e1       	ldi	r24, 0x12	; 18
     7ba:	90 e2       	ldi	r25, 0x20	; 32
     7bc:	88 83       	st	Y, r24
     7be:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     7c0:	df 91       	pop	r29
     7c2:	cf 91       	pop	r28
     7c4:	1f 91       	pop	r17
     7c6:	0f 91       	pop	r16
     7c8:	08 95       	ret

000007ca <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     7ca:	cf 93       	push	r28
     7cc:	df 93       	push	r29
     7ce:	00 d0       	rcall	.+0      	; 0x7d0 <_ZN13LimitSwitches3runEv+0x6>
     7d0:	1f 92       	push	r1
     7d2:	cd b7       	in	r28, 0x3d	; 61
     7d4:	de b7       	in	r29, 0x3e	; 62
     7d6:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7d8:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <xTaskGetTickCount>
     7dc:	69 83       	std	Y+1, r22	; 0x01
     7de:	7a 83       	std	Y+2, r23	; 0x02
     7e0:	8b 83       	std	Y+3, r24	; 0x03
     7e2:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     7e4:	f8 01       	movw	r30, r16
     7e6:	86 85       	ldd	r24, Z+14	; 0x0e
     7e8:	97 85       	ldd	r25, Z+15	; 0x0f
     7ea:	a0 89       	ldd	r26, Z+16	; 0x10
     7ec:	b1 89       	ldd	r27, Z+17	; 0x11
     7ee:	01 96       	adiw	r24, 0x01	; 1
     7f0:	a1 1d       	adc	r26, r1
     7f2:	b1 1d       	adc	r27, r1
     7f4:	86 87       	std	Z+14, r24	; 0x0e
     7f6:	97 87       	std	Z+15, r25	; 0x0f
     7f8:	a0 8b       	std	Z+16, r26	; 0x10
     7fa:	b1 8b       	std	Z+17, r27	; 0x11
     7fc:	41 e0       	ldi	r20, 0x01	; 1
     7fe:	50 e0       	ldi	r21, 0x00	; 0
     800:	60 e0       	ldi	r22, 0x00	; 0
     802:	70 e0       	ldi	r23, 0x00	; 0
     804:	ce 01       	movw	r24, r28
     806:	01 96       	adiw	r24, 0x01	; 1
     808:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <vTaskDelayUntil>
     80c:	eb cf       	rjmp	.-42     	; 0x7e4 <_ZN13LimitSwitches3runEv+0x1a>

0000080e <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     80e:	0f 93       	push	r16
     810:	1f 93       	push	r17
     812:	cf 93       	push	r28
     814:	df 93       	push	r29
     816:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     818:	0e 94 74 12 	call	0x24e8	; 0x24e8 <_ZN8frt_taskC1EPKchjP8emstream>
     81c:	8a e1       	ldi	r24, 0x1A	; 26
     81e:	90 e2       	ldi	r25, 0x20	; 32
     820:	88 83       	st	Y, r24
     822:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	1f 91       	pop	r17
     82a:	0f 91       	pop	r16
     82c:	08 95       	ret

0000082e <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	00 d0       	rcall	.+0      	; 0x834 <_ZN5Motor3runEv+0x6>
     834:	1f 92       	push	r1
     836:	cd b7       	in	r28, 0x3d	; 61
     838:	de b7       	in	r29, 0x3e	; 62
     83a:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     83c:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <xTaskGetTickCount>
     840:	69 83       	std	Y+1, r22	; 0x01
     842:	7a 83       	std	Y+2, r23	; 0x02
     844:	8b 83       	std	Y+3, r24	; 0x03
     846:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     848:	f8 01       	movw	r30, r16
     84a:	86 85       	ldd	r24, Z+14	; 0x0e
     84c:	97 85       	ldd	r25, Z+15	; 0x0f
     84e:	a0 89       	ldd	r26, Z+16	; 0x10
     850:	b1 89       	ldd	r27, Z+17	; 0x11
     852:	01 96       	adiw	r24, 0x01	; 1
     854:	a1 1d       	adc	r26, r1
     856:	b1 1d       	adc	r27, r1
     858:	86 87       	std	Z+14, r24	; 0x0e
     85a:	97 87       	std	Z+15, r25	; 0x0f
     85c:	a0 8b       	std	Z+16, r26	; 0x10
     85e:	b1 8b       	std	Z+17, r27	; 0x11
     860:	41 e0       	ldi	r20, 0x01	; 1
     862:	50 e0       	ldi	r21, 0x00	; 0
     864:	60 e0       	ldi	r22, 0x00	; 0
     866:	70 e0       	ldi	r23, 0x00	; 0
     868:	ce 01       	movw	r24, r28
     86a:	01 96       	adiw	r24, 0x01	; 1
     86c:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <vTaskDelayUntil>
     870:	eb cf       	rjmp	.-42     	; 0x848 <_ZN5Motor3runEv+0x1a>

00000872 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     872:	0f 93       	push	r16
     874:	1f 93       	push	r17
     876:	cf 93       	push	r28
     878:	df 93       	push	r29
     87a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     87c:	0e 94 74 12 	call	0x24e8	; 0x24e8 <_ZN8frt_taskC1EPKchjP8emstream>
     880:	82 e2       	ldi	r24, 0x22	; 34
     882:	90 e2       	ldi	r25, 0x20	; 32
     884:	88 83       	st	Y, r24
     886:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     888:	df 91       	pop	r29
     88a:	cf 91       	pop	r28
     88c:	1f 91       	pop	r17
     88e:	0f 91       	pop	r16
     890:	08 95       	ret

00000892 <_ZN3pid3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void pid::run(void){
     892:	cf 93       	push	r28
     894:	df 93       	push	r29
     896:	00 d0       	rcall	.+0      	; 0x898 <_ZN3pid3runEv+0x6>
     898:	1f 92       	push	r1
     89a:	cd b7       	in	r28, 0x3d	; 61
     89c:	de b7       	in	r29, 0x3e	; 62
     89e:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8a0:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <xTaskGetTickCount>
     8a4:	69 83       	std	Y+1, r22	; 0x01
     8a6:	7a 83       	std	Y+2, r23	; 0x02
     8a8:	8b 83       	std	Y+3, r24	; 0x03
     8aa:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     8ac:	f8 01       	movw	r30, r16
     8ae:	86 85       	ldd	r24, Z+14	; 0x0e
     8b0:	97 85       	ldd	r25, Z+15	; 0x0f
     8b2:	a0 89       	ldd	r26, Z+16	; 0x10
     8b4:	b1 89       	ldd	r27, Z+17	; 0x11
     8b6:	01 96       	adiw	r24, 0x01	; 1
     8b8:	a1 1d       	adc	r26, r1
     8ba:	b1 1d       	adc	r27, r1
     8bc:	86 87       	std	Z+14, r24	; 0x0e
     8be:	97 87       	std	Z+15, r25	; 0x0f
     8c0:	a0 8b       	std	Z+16, r26	; 0x10
     8c2:	b1 8b       	std	Z+17, r27	; 0x11
     8c4:	41 e0       	ldi	r20, 0x01	; 1
     8c6:	50 e0       	ldi	r21, 0x00	; 0
     8c8:	60 e0       	ldi	r22, 0x00	; 0
     8ca:	70 e0       	ldi	r23, 0x00	; 0
     8cc:	ce 01       	movw	r24, r28
     8ce:	01 96       	adiw	r24, 0x01	; 1
     8d0:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <vTaskDelayUntil>
     8d4:	eb cf       	rjmp	.-42     	; 0x8ac <_ZN3pid3runEv+0x1a>

000008d6 <_ZN3pidC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


pid::pid (const char* a_name,
     8d6:	0f 93       	push	r16
     8d8:	1f 93       	push	r17
     8da:	cf 93       	push	r28
     8dc:	df 93       	push	r29
     8de:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8e0:	0e 94 74 12 	call	0x24e8	; 0x24e8 <_ZN8frt_taskC1EPKchjP8emstream>
     8e4:	8a e2       	ldi	r24, 0x2A	; 42
     8e6:	90 e2       	ldi	r25, 0x20	; 32
     8e8:	88 83       	st	Y, r24
     8ea:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	1f 91       	pop	r17
     8f2:	0f 91       	pop	r16
     8f4:	08 95       	ret

000008f6 <_ZN9PWMdriver3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void PWMdriver::run(void){
     8f6:	cf 93       	push	r28
     8f8:	df 93       	push	r29
     8fa:	00 d0       	rcall	.+0      	; 0x8fc <_ZN9PWMdriver3runEv+0x6>
     8fc:	1f 92       	push	r1
     8fe:	cd b7       	in	r28, 0x3d	; 61
     900:	de b7       	in	r29, 0x3e	; 62
     902:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     904:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <xTaskGetTickCount>
     908:	69 83       	std	Y+1, r22	; 0x01
     90a:	7a 83       	std	Y+2, r23	; 0x02
     90c:	8b 83       	std	Y+3, r24	; 0x03
     90e:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     910:	f8 01       	movw	r30, r16
     912:	86 85       	ldd	r24, Z+14	; 0x0e
     914:	97 85       	ldd	r25, Z+15	; 0x0f
     916:	a0 89       	ldd	r26, Z+16	; 0x10
     918:	b1 89       	ldd	r27, Z+17	; 0x11
     91a:	01 96       	adiw	r24, 0x01	; 1
     91c:	a1 1d       	adc	r26, r1
     91e:	b1 1d       	adc	r27, r1
     920:	86 87       	std	Z+14, r24	; 0x0e
     922:	97 87       	std	Z+15, r25	; 0x0f
     924:	a0 8b       	std	Z+16, r26	; 0x10
     926:	b1 8b       	std	Z+17, r27	; 0x11
     928:	41 e0       	ldi	r20, 0x01	; 1
     92a:	50 e0       	ldi	r21, 0x00	; 0
     92c:	60 e0       	ldi	r22, 0x00	; 0
     92e:	70 e0       	ldi	r23, 0x00	; 0
     930:	ce 01       	movw	r24, r28
     932:	01 96       	adiw	r24, 0x01	; 1
     934:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <vTaskDelayUntil>
     938:	eb cf       	rjmp	.-42     	; 0x910 <_ZN9PWMdriver3runEv+0x1a>

0000093a <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


PWMdriver::PWMdriver(const char* a_name,
     93a:	0f 93       	push	r16
     93c:	1f 93       	push	r17
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
     942:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     944:	0e 94 74 12 	call	0x24e8	; 0x24e8 <_ZN8frt_taskC1EPKchjP8emstream>
     948:	82 e3       	ldi	r24, 0x32	; 50
     94a:	90 e2       	ldi	r25, 0x20	; 32
     94c:	88 83       	st	Y, r24
     94e:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     950:	df 91       	pop	r29
     952:	cf 91       	pop	r28
     954:	1f 91       	pop	r17
     956:	0f 91       	pop	r16
     958:	08 95       	ret

0000095a <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     95a:	0f 93       	push	r16
     95c:	1f 93       	push	r17
     95e:	cf 93       	push	r28
     960:	df 93       	push	r29
     962:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     964:	0e 94 74 12 	call	0x24e8	; 0x24e8 <_ZN8frt_taskC1EPKchjP8emstream>
     968:	8a e3       	ldi	r24, 0x3A	; 58
     96a:	90 e2       	ldi	r25, 0x20	; 32
     96c:	88 83       	st	Y, r24
     96e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     970:	df 91       	pop	r29
     972:	cf 91       	pop	r28
     974:	1f 91       	pop	r17
     976:	0f 91       	pop	r16
     978:	08 95       	ret

0000097a <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     97a:	0f 93       	push	r16
     97c:	1f 93       	push	r17
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     984:	6a e0       	ldi	r22, 0x0A	; 10
     986:	8e 81       	ldd	r24, Y+6	; 0x06
     988:	9f 81       	ldd	r25, Y+7	; 0x07
     98a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     98e:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     990:	61 ef       	ldi	r22, 0xF1	; 241
     992:	73 e0       	ldi	r23, 0x03	; 3
     994:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     998:	6a e0       	ldi	r22, 0x0A	; 10
     99a:	c8 01       	movw	r24, r16
     99c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     9a0:	8c 01       	movw	r16, r24
     9a2:	6b ee       	ldi	r22, 0xEB	; 235
     9a4:	73 e0       	ldi	r23, 0x03	; 3
     9a6:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     9aa:	67 e0       	ldi	r22, 0x07	; 7
     9ac:	c8 01       	movw	r24, r16
     9ae:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     9b2:	6a e0       	ldi	r22, 0x0A	; 10
     9b4:	8e 81       	ldd	r24, Y+6	; 0x06
     9b6:	9f 81       	ldd	r25, Y+7	; 0x07
     9b8:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     9bc:	8c 01       	movw	r16, r24
     9be:	6c ec       	ldi	r22, 0xCC	; 204
     9c0:	73 e0       	ldi	r23, 0x03	; 3
     9c2:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     9c6:	6a e0       	ldi	r22, 0x0A	; 10
     9c8:	c8 01       	movw	r24, r16
     9ca:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     9ce:	8c 01       	movw	r16, r24
     9d0:	66 ec       	ldi	r22, 0xC6	; 198
     9d2:	73 e0       	ldi	r23, 0x03	; 3
     9d4:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     9d8:	66 e0       	ldi	r22, 0x06	; 6
     9da:	c8 01       	movw	r24, r16
     9dc:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     9e0:	6a e0       	ldi	r22, 0x0A	; 10
     9e2:	8e 81       	ldd	r24, Y+6	; 0x06
     9e4:	9f 81       	ldd	r25, Y+7	; 0x07
     9e6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     9ea:	8c 01       	movw	r16, r24
     9ec:	6f ea       	ldi	r22, 0xAF	; 175
     9ee:	73 e0       	ldi	r23, 0x03	; 3
     9f0:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     9f4:	66 e0       	ldi	r22, 0x06	; 6
     9f6:	c8 01       	movw	r24, r16
     9f8:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     9fc:	6a e0       	ldi	r22, 0x0A	; 10
     9fe:	8e 81       	ldd	r24, Y+6	; 0x06
     a00:	9f 81       	ldd	r25, Y+7	; 0x07
     a02:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     a06:	8c 01       	movw	r16, r24
     a08:	63 e9       	ldi	r22, 0x93	; 147
     a0a:	73 e0       	ldi	r23, 0x03	; 3
     a0c:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     a10:	66 e0       	ldi	r22, 0x06	; 6
     a12:	c8 01       	movw	r24, r16
     a14:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     a18:	6a e0       	ldi	r22, 0x0A	; 10
     a1a:	8e 81       	ldd	r24, Y+6	; 0x06
     a1c:	9f 81       	ldd	r25, Y+7	; 0x07
     a1e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     a22:	8c 01       	movw	r16, r24
     a24:	6b e7       	ldi	r22, 0x7B	; 123
     a26:	73 e0       	ldi	r23, 0x03	; 3
     a28:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     a2c:	66 e0       	ldi	r22, 0x06	; 6
     a2e:	c8 01       	movw	r24, r16
     a30:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     a34:	6a e0       	ldi	r22, 0x0A	; 10
     a36:	8e 81       	ldd	r24, Y+6	; 0x06
     a38:	9f 81       	ldd	r25, Y+7	; 0x07
     a3a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     a3e:	8c 01       	movw	r16, r24
     a40:	6a e5       	ldi	r22, 0x5A	; 90
     a42:	73 e0       	ldi	r23, 0x03	; 3
     a44:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     a48:	66 e0       	ldi	r22, 0x06	; 6
     a4a:	c8 01       	movw	r24, r16
     a4c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     a50:	6a e0       	ldi	r22, 0x0A	; 10
     a52:	8e 81       	ldd	r24, Y+6	; 0x06
     a54:	9f 81       	ldd	r25, Y+7	; 0x07
     a56:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     a5a:	8c 01       	movw	r16, r24
     a5c:	63 e3       	ldi	r22, 0x33	; 51
     a5e:	73 e0       	ldi	r23, 0x03	; 3
     a60:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     a64:	66 e0       	ldi	r22, 0x06	; 6
     a66:	c8 01       	movw	r24, r16
     a68:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     a6c:	6a e0       	ldi	r22, 0x0A	; 10
     a6e:	8e 81       	ldd	r24, Y+6	; 0x06
     a70:	9f 81       	ldd	r25, Y+7	; 0x07
     a72:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     a76:	8c 01       	movw	r16, r24
     a78:	65 e1       	ldi	r22, 0x15	; 21
     a7a:	73 e0       	ldi	r23, 0x03	; 3
     a7c:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     a80:	66 e0       	ldi	r22, 0x06	; 6
     a82:	c8 01       	movw	r24, r16
     a84:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     a88:	6a e0       	ldi	r22, 0x0A	; 10
     a8a:	8e 81       	ldd	r24, Y+6	; 0x06
     a8c:	9f 81       	ldd	r25, Y+7	; 0x07
     a8e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     a92:	8c 01       	movw	r16, r24
     a94:	6a ef       	ldi	r22, 0xFA	; 250
     a96:	72 e0       	ldi	r23, 0x02	; 2
     a98:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     a9c:	66 e0       	ldi	r22, 0x06	; 6
     a9e:	c8 01       	movw	r24, r16
     aa0:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     aa4:	6a e0       	ldi	r22, 0x0A	; 10
     aa6:	8e 81       	ldd	r24, Y+6	; 0x06
     aa8:	9f 81       	ldd	r25, Y+7	; 0x07
     aaa:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     aae:	ec 01       	movw	r28, r24
     ab0:	6b ee       	ldi	r22, 0xEB	; 235
     ab2:	72 e0       	ldi	r23, 0x02	; 2
     ab4:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     ab8:	66 e0       	ldi	r22, 0x06	; 6
     aba:	ce 01       	movw	r24, r28
     abc:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
}
     ac0:	df 91       	pop	r29
     ac2:	cf 91       	pop	r28
     ac4:	1f 91       	pop	r17
     ac6:	0f 91       	pop	r16
     ac8:	08 95       	ret

00000aca <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     aca:	af 92       	push	r10
     acc:	bf 92       	push	r11
     ace:	cf 92       	push	r12
     ad0:	df 92       	push	r13
     ad2:	ef 92       	push	r14
     ad4:	ff 92       	push	r15
     ad6:	0f 93       	push	r16
     ad8:	1f 93       	push	r17
     ada:	cf 93       	push	r28
     adc:	df 93       	push	r29
     ade:	00 d0       	rcall	.+0      	; 0xae0 <_ZN9task_user11show_statusEv+0x16>
     ae0:	00 d0       	rcall	.+0      	; 0xae2 <_ZN9task_user11show_statusEv+0x18>
     ae2:	cd b7       	in	r28, 0x3d	; 61
     ae4:	de b7       	in	r29, 0x3e	; 62
     ae6:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     ae8:	19 82       	std	Y+1, r1	; 0x01
     aea:	1a 82       	std	Y+2, r1	; 0x02
     aec:	1b 82       	std	Y+3, r1	; 0x03
     aee:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     af0:	1d 82       	std	Y+5, r1	; 0x05
     af2:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     af4:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <xPortGetFreeHeapSize>
     af8:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     afa:	ce 01       	movw	r24, r28
     afc:	01 96       	adiw	r24, 0x01	; 1
     afe:	0e 94 25 16 	call	0x2c4a	; 0x2c4a <_ZN10time_stamp10set_to_nowEv>
     b02:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     b04:	66 e0       	ldi	r22, 0x06	; 6
     b06:	f8 01       	movw	r30, r16
     b08:	86 81       	ldd	r24, Z+6	; 0x06
     b0a:	97 81       	ldd	r25, Z+7	; 0x07
     b0c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     b10:	6a e0       	ldi	r22, 0x0A	; 10
     b12:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     b16:	7c 01       	movw	r14, r24
     b18:	6c ec       	ldi	r22, 0xCC	; 204
     b1a:	72 e0       	ldi	r23, 0x02	; 2
     b1c:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     b20:	6a e0       	ldi	r22, 0x0A	; 10
     b22:	c7 01       	movw	r24, r14
     b24:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     b28:	7c 01       	movw	r14, r24
     b2a:	60 ec       	ldi	r22, 0xC0	; 192
     b2c:	72 e0       	ldi	r23, 0x02	; 2
     b2e:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     b32:	66 e0       	ldi	r22, 0x06	; 6
     b34:	c7 01       	movw	r24, r14
     b36:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     b3a:	6a e0       	ldi	r22, 0x0A	; 10
     b3c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     b40:	7c 01       	movw	r14, r24
     b42:	69 eb       	ldi	r22, 0xB9	; 185
     b44:	72 e0       	ldi	r23, 0x02	; 2
     b46:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     b4a:	b5 01       	movw	r22, r10
     b4c:	c7 01       	movw	r24, r14
     b4e:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     b52:	6a e0       	ldi	r22, 0x0A	; 10
     b54:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     b58:	7c 01       	movw	r14, r24
     b5a:	6b ea       	ldi	r22, 0xAB	; 171
     b5c:	72 e0       	ldi	r23, 0x02	; 2
     b5e:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     b62:	b6 01       	movw	r22, r12
     b64:	c7 01       	movw	r24, r14
     b66:	0e 94 3a 18 	call	0x3074	; 0x3074 <_ZN8emstreamlsEj>
     b6a:	6a e0       	ldi	r22, 0x0A	; 10
     b6c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     b70:	7c 01       	movw	r14, r24
     b72:	69 ea       	ldi	r22, 0xA9	; 169
     b74:	72 e0       	ldi	r23, 0x02	; 2
     b76:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     b7a:	4f ef       	ldi	r20, 0xFF	; 255
     b7c:	5f e0       	ldi	r21, 0x0F	; 15
     b7e:	60 e0       	ldi	r22, 0x00	; 0
     b80:	70 e0       	ldi	r23, 0x00	; 0
     b82:	c7 01       	movw	r24, r14
     b84:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     b88:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     b8c:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     b90:	6a e0       	ldi	r22, 0x0A	; 10
     b92:	f8 01       	movw	r30, r16
     b94:	86 81       	ldd	r24, Z+6	; 0x06
     b96:	97 81       	ldd	r25, Z+7	; 0x07
     b98:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     b9c:	7c 01       	movw	r14, r24
     b9e:	6e e9       	ldi	r22, 0x9E	; 158
     ba0:	72 e0       	ldi	r23, 0x02	; 2
     ba2:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     ba6:	b6 01       	movw	r22, r12
     ba8:	c7 01       	movw	r24, r14
     baa:	0e 94 3a 18 	call	0x3074	; 0x3074 <_ZN8emstreamlsEj>
     bae:	66 e0       	ldi	r22, 0x06	; 6
     bb0:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     bb4:	66 e0       	ldi	r22, 0x06	; 6
     bb6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     bba:	f8 01       	movw	r30, r16
     bbc:	86 81       	ldd	r24, Z+6	; 0x06
     bbe:	97 81       	ldd	r25, Z+7	; 0x07
     bc0:	0e 94 82 14 	call	0x2904	; 0x2904 <_Z15print_task_listP8emstream>
}
     bc4:	26 96       	adiw	r28, 0x06	; 6
     bc6:	cd bf       	out	0x3d, r28	; 61
     bc8:	de bf       	out	0x3e, r29	; 62
     bca:	df 91       	pop	r29
     bcc:	cf 91       	pop	r28
     bce:	1f 91       	pop	r17
     bd0:	0f 91       	pop	r16
     bd2:	ff 90       	pop	r15
     bd4:	ef 90       	pop	r14
     bd6:	df 90       	pop	r13
     bd8:	cf 90       	pop	r12
     bda:	bf 90       	pop	r11
     bdc:	af 90       	pop	r10
     bde:	08 95       	ret

00000be0 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     be0:	cf 93       	push	r28
     be2:	df 93       	push	r29
     be4:	00 d0       	rcall	.+0      	; 0xbe6 <_ZN9task_user3runEv+0x6>
     be6:	00 d0       	rcall	.+0      	; 0xbe8 <_ZN9task_user3runEv+0x8>
     be8:	cd b7       	in	r28, 0x3d	; 61
     bea:	de b7       	in	r29, 0x3e	; 62
     bec:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     bee:	19 82       	std	Y+1, r1	; 0x01
     bf0:	1a 82       	std	Y+2, r1	; 0x02
     bf2:	1b 82       	std	Y+3, r1	; 0x03
     bf4:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     bf6:	1d 82       	std	Y+5, r1	; 0x05
     bf8:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     bfa:	6a e0       	ldi	r22, 0x0A	; 10
     bfc:	dc 01       	movw	r26, r24
     bfe:	16 96       	adiw	r26, 0x06	; 6
     c00:	8d 91       	ld	r24, X+
     c02:	9c 91       	ld	r25, X
     c04:	17 97       	sbiw	r26, 0x07	; 7
     c06:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     c0a:	7c 01       	movw	r14, r24
     c0c:	6a e3       	ldi	r22, 0x3A	; 58
     c0e:	74 e0       	ldi	r23, 0x04	; 4
     c10:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     c14:	66 e0       	ldi	r22, 0x06	; 6
     c16:	c7 01       	movw	r24, r14
     c18:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     c1c:	f8 01       	movw	r30, r16
     c1e:	84 85       	ldd	r24, Z+12	; 0x0c
     c20:	88 23       	and	r24, r24
     c22:	21 f0       	breq	.+8      	; 0xc2c <_ZN9task_user3runEv+0x4c>
     c24:	81 30       	cpi	r24, 0x01	; 1
     c26:	09 f4       	brne	.+2      	; 0xc2a <_ZN9task_user3runEv+0x4a>
     c28:	5d c0       	rjmp	.+186    	; 0xce4 <_ZN9task_user3runEv+0x104>
     c2a:	d8 c0       	rjmp	.+432    	; 0xddc <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     c2c:	86 81       	ldd	r24, Z+6	; 0x06
     c2e:	97 81       	ldd	r25, Z+7	; 0x07
     c30:	dc 01       	movw	r26, r24
     c32:	ed 91       	ld	r30, X+
     c34:	fc 91       	ld	r31, X
     c36:	04 80       	ldd	r0, Z+4	; 0x04
     c38:	f5 81       	ldd	r31, Z+5	; 0x05
     c3a:	e0 2d       	mov	r30, r0
     c3c:	19 95       	eicall
     c3e:	88 23       	and	r24, r24
     c40:	a9 f1       	breq	.+106    	; 0xcac <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     c42:	f8 01       	movw	r30, r16
     c44:	86 81       	ldd	r24, Z+6	; 0x06
     c46:	97 81       	ldd	r25, Z+7	; 0x07
     c48:	dc 01       	movw	r26, r24
     c4a:	ed 91       	ld	r30, X+
     c4c:	fc 91       	ld	r31, X
     c4e:	06 80       	ldd	r0, Z+6	; 0x06
     c50:	f7 81       	ldd	r31, Z+7	; 0x07
     c52:	e0 2d       	mov	r30, r0
     c54:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     c56:	99 27       	eor	r25, r25
     c58:	81 30       	cpi	r24, 0x01	; 1
     c5a:	91 05       	cpc	r25, r1
     c5c:	f9 f0       	breq	.+62     	; 0xc9c <_ZN9task_user3runEv+0xbc>
     c5e:	03 97       	sbiw	r24, 0x03	; 3
     c60:	09 f0       	breq	.+2      	; 0xc64 <_ZN9task_user3runEv+0x84>
     c62:	d8 c0       	rjmp	.+432    	; 0xe14 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     c64:	6a e0       	ldi	r22, 0x0A	; 10
     c66:	f8 01       	movw	r30, r16
     c68:	86 81       	ldd	r24, Z+6	; 0x06
     c6a:	97 81       	ldd	r25, Z+7	; 0x07
     c6c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     c70:	8c 01       	movw	r16, r24
     c72:	6c e2       	ldi	r22, 0x2C	; 44
     c74:	74 e0       	ldi	r23, 0x04	; 4
     c76:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     c7a:	66 e0       	ldi	r22, 0x06	; 6
     c7c:	c8 01       	movw	r24, r16
     c7e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     c82:	93 e0       	ldi	r25, 0x03	; 3
     c84:	88 ed       	ldi	r24, 0xD8	; 216
     c86:	08 b6       	in	r0, 0x38	; 56
     c88:	18 be       	out	0x38, r1	; 56
     c8a:	84 bf       	out	0x34, r24	; 52
     c8c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     c90:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     c94:	81 fd       	sbrc	r24, 1
     c96:	fc cf       	rjmp	.-8      	; 0xc90 <_ZN9task_user3runEv+0xb0>
     c98:	08 be       	out	0x38, r0	; 56
     c9a:	ff cf       	rjmp	.-2      	; 0xc9a <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     c9c:	c8 01       	movw	r24, r16
     c9e:	0e 94 bd 04 	call	0x97a	; 0x97a <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     ca2:	61 e0       	ldi	r22, 0x01	; 1
     ca4:	c8 01       	movw	r24, r16
     ca6:	0e 94 70 12 	call	0x24e0	; 0x24e0 <_ZN8frt_task13transition_toEh>
							break;
     caa:	b4 c0       	rjmp	.+360    	; 0xe14 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     cac:	86 e6       	ldi	r24, 0x66	; 102
     cae:	91 e3       	ldi	r25, 0x31	; 49
     cb0:	0e 94 31 15 	call	0x2a62	; 0x2a62 <_ZN14frt_text_queue14check_for_charEv>
     cb4:	88 23       	and	r24, r24
     cb6:	09 f4       	brne	.+2      	; 0xcba <_ZN9task_user3runEv+0xda>
     cb8:	ad c0       	rjmp	.+346    	; 0xe14 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     cba:	d8 01       	movw	r26, r16
     cbc:	16 96       	adiw	r26, 0x06	; 6
     cbe:	ed 91       	ld	r30, X+
     cc0:	fc 91       	ld	r31, X
     cc2:	17 97       	sbiw	r26, 0x07	; 7
     cc4:	01 90       	ld	r0, Z+
     cc6:	f0 81       	ld	r31, Z
     cc8:	e0 2d       	mov	r30, r0
     cca:	e2 80       	ldd	r14, Z+2	; 0x02
     ccc:	f3 80       	ldd	r15, Z+3	; 0x03
     cce:	86 e6       	ldi	r24, 0x66	; 102
     cd0:	91 e3       	ldi	r25, 0x31	; 49
     cd2:	0e 94 13 15 	call	0x2a26	; 0x2a26 <_ZN14frt_text_queue7getcharEv>
     cd6:	68 2f       	mov	r22, r24
     cd8:	f8 01       	movw	r30, r16
     cda:	86 81       	ldd	r24, Z+6	; 0x06
     cdc:	97 81       	ldd	r25, Z+7	; 0x07
     cde:	f7 01       	movw	r30, r14
     ce0:	19 95       	eicall
     ce2:	98 c0       	rjmp	.+304    	; 0xe14 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     ce4:	86 81       	ldd	r24, Z+6	; 0x06
     ce6:	97 81       	ldd	r25, Z+7	; 0x07
     ce8:	dc 01       	movw	r26, r24
     cea:	ed 91       	ld	r30, X+
     cec:	fc 91       	ld	r31, X
     cee:	04 80       	ldd	r0, Z+4	; 0x04
     cf0:	f5 81       	ldd	r31, Z+5	; 0x05
     cf2:	e0 2d       	mov	r30, r0
     cf4:	19 95       	eicall
     cf6:	88 23       	and	r24, r24
     cf8:	09 f4       	brne	.+2      	; 0xcfc <_ZN9task_user3runEv+0x11c>
     cfa:	8c c0       	rjmp	.+280    	; 0xe14 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     cfc:	f8 01       	movw	r30, r16
     cfe:	86 81       	ldd	r24, Z+6	; 0x06
     d00:	97 81       	ldd	r25, Z+7	; 0x07
     d02:	dc 01       	movw	r26, r24
     d04:	ed 91       	ld	r30, X+
     d06:	fc 91       	ld	r31, X
     d08:	06 80       	ldd	r0, Z+6	; 0x06
     d0a:	f7 81       	ldd	r31, Z+7	; 0x07
     d0c:	e0 2d       	mov	r30, r0
     d0e:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     d10:	9c 01       	movw	r18, r24
     d12:	33 27       	eor	r19, r19
     d14:	28 36       	cpi	r18, 0x68	; 104
     d16:	31 05       	cpc	r19, r1
     d18:	59 f1       	breq	.+86     	; 0xd70 <_ZN9task_user3runEv+0x190>
     d1a:	3c f4       	brge	.+14     	; 0xd2a <_ZN9task_user3runEv+0x14a>
     d1c:	2b 31       	cpi	r18, 0x1B	; 27
     d1e:	31 05       	cpc	r19, r1
     d20:	59 f1       	breq	.+86     	; 0xd78 <_ZN9task_user3runEv+0x198>
     d22:	25 36       	cpi	r18, 0x65	; 101
     d24:	31 05       	cpc	r19, r1
     d26:	41 f1       	breq	.+80     	; 0xd78 <_ZN9task_user3runEv+0x198>
     d28:	3b c0       	rjmp	.+118    	; 0xda0 <_ZN9task_user3runEv+0x1c0>
     d2a:	23 37       	cpi	r18, 0x73	; 115
     d2c:	31 05       	cpc	r19, r1
     d2e:	c1 f0       	breq	.+48     	; 0xd60 <_ZN9task_user3runEv+0x180>
     d30:	26 37       	cpi	r18, 0x76	; 118
     d32:	31 05       	cpc	r19, r1
     d34:	89 f0       	breq	.+34     	; 0xd58 <_ZN9task_user3runEv+0x178>
     d36:	2e 36       	cpi	r18, 0x6E	; 110
     d38:	31 05       	cpc	r19, r1
     d3a:	91 f5       	brne	.+100    	; 0xda0 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     d3c:	ce 01       	movw	r24, r28
     d3e:	01 96       	adiw	r24, 0x01	; 1
     d40:	0e 94 25 16 	call	0x2c4a	; 0x2c4a <_ZN10time_stamp10set_to_nowEv>
     d44:	bc 01       	movw	r22, r24
     d46:	f8 01       	movw	r30, r16
     d48:	86 81       	ldd	r24, Z+6	; 0x06
     d4a:	97 81       	ldd	r25, Z+7	; 0x07
     d4c:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <_ZlsR8emstreamR10time_stamp>
     d50:	66 e0       	ldi	r22, 0x06	; 6
     d52:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
							break;
     d56:	5e c0       	rjmp	.+188    	; 0xe14 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     d58:	c8 01       	movw	r24, r16
     d5a:	0e 94 65 05 	call	0xaca	; 0xaca <_ZN9task_user11show_statusEv>
							break;
     d5e:	5a c0       	rjmp	.+180    	; 0xe14 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     d60:	d8 01       	movw	r26, r16
     d62:	16 96       	adiw	r26, 0x06	; 6
     d64:	8d 91       	ld	r24, X+
     d66:	9c 91       	ld	r25, X
     d68:	17 97       	sbiw	r26, 0x07	; 7
     d6a:	0e 94 89 13 	call	0x2712	; 0x2712 <_Z17print_task_stacksP8emstream>
							break;
     d6e:	52 c0       	rjmp	.+164    	; 0xe14 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     d70:	c8 01       	movw	r24, r16
     d72:	0e 94 bd 04 	call	0x97a	; 0x97a <_ZN9task_user18print_help_messageEv>
							break;
     d76:	4e c0       	rjmp	.+156    	; 0xe14 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     d78:	6a e0       	ldi	r22, 0x0A	; 10
     d7a:	f8 01       	movw	r30, r16
     d7c:	86 81       	ldd	r24, Z+6	; 0x06
     d7e:	97 81       	ldd	r25, Z+7	; 0x07
     d80:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     d84:	7c 01       	movw	r14, r24
     d86:	6a e1       	ldi	r22, 0x1A	; 26
     d88:	74 e0       	ldi	r23, 0x04	; 4
     d8a:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     d8e:	66 e0       	ldi	r22, 0x06	; 6
     d90:	c7 01       	movw	r24, r14
     d92:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     d96:	60 e0       	ldi	r22, 0x00	; 0
     d98:	c8 01       	movw	r24, r16
     d9a:	0e 94 70 12 	call	0x24e0	; 0x24e0 <_ZN8frt_task13transition_toEh>
							break;
     d9e:	3a c0       	rjmp	.+116    	; 0xe14 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     da0:	f8 01       	movw	r30, r16
     da2:	a6 81       	ldd	r26, Z+6	; 0x06
     da4:	b7 81       	ldd	r27, Z+7	; 0x07
     da6:	ed 91       	ld	r30, X+
     da8:	fc 91       	ld	r31, X
     daa:	11 97       	sbiw	r26, 0x01	; 1
     dac:	02 80       	ldd	r0, Z+2	; 0x02
     dae:	f3 81       	ldd	r31, Z+3	; 0x03
     db0:	e0 2d       	mov	r30, r0
     db2:	68 2f       	mov	r22, r24
     db4:	cd 01       	movw	r24, r26
     db6:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     db8:	6a e0       	ldi	r22, 0x0A	; 10
     dba:	d8 01       	movw	r26, r16
     dbc:	16 96       	adiw	r26, 0x06	; 6
     dbe:	8d 91       	ld	r24, X+
     dc0:	9c 91       	ld	r25, X
     dc2:	17 97       	sbiw	r26, 0x07	; 7
     dc4:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     dc8:	7c 01       	movw	r14, r24
     dca:	64 e1       	ldi	r22, 0x14	; 20
     dcc:	74 e0       	ldi	r23, 0x04	; 4
     dce:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     dd2:	66 e0       	ldi	r22, 0x06	; 6
     dd4:	c7 01       	movw	r24, r14
     dd6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
							break;
     dda:	1c c0       	rjmp	.+56     	; 0xe14 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     ddc:	6a e0       	ldi	r22, 0x0A	; 10
     dde:	f8 01       	movw	r30, r16
     de0:	86 81       	ldd	r24, Z+6	; 0x06
     de2:	97 81       	ldd	r25, Z+7	; 0x07
     de4:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
     de8:	8c 01       	movw	r16, r24
     dea:	67 ef       	ldi	r22, 0xF7	; 247
     dec:	73 e0       	ldi	r23, 0x03	; 3
     dee:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
     df2:	66 e0       	ldi	r22, 0x06	; 6
     df4:	c8 01       	movw	r24, r16
     df6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     dfa:	93 e0       	ldi	r25, 0x03	; 3
     dfc:	88 ed       	ldi	r24, 0xD8	; 216
     dfe:	08 b6       	in	r0, 0x38	; 56
     e00:	18 be       	out	0x38, r1	; 56
     e02:	84 bf       	out	0x34, r24	; 52
     e04:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     e08:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     e0c:	81 fd       	sbrc	r24, 1
     e0e:	fc cf       	rjmp	.-8      	; 0xe08 <_ZN9task_user3runEv+0x228>
     e10:	08 be       	out	0x38, r0	; 56
     e12:	ff cf       	rjmp	.-2      	; 0xe12 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     e14:	f8 01       	movw	r30, r16
     e16:	86 85       	ldd	r24, Z+14	; 0x0e
     e18:	97 85       	ldd	r25, Z+15	; 0x0f
     e1a:	a0 89       	ldd	r26, Z+16	; 0x10
     e1c:	b1 89       	ldd	r27, Z+17	; 0x11
     e1e:	01 96       	adiw	r24, 0x01	; 1
     e20:	a1 1d       	adc	r26, r1
     e22:	b1 1d       	adc	r27, r1
     e24:	86 87       	std	Z+14, r24	; 0x0e
     e26:	97 87       	std	Z+15, r25	; 0x0f
     e28:	a0 8b       	std	Z+16, r26	; 0x10
     e2a:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     e2c:	61 e0       	ldi	r22, 0x01	; 1
     e2e:	70 e0       	ldi	r23, 0x00	; 0
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	0e 94 44 10 	call	0x2088	; 0x2088 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     e38:	f1 ce       	rjmp	.-542    	; 0xc1c <_ZN9task_user3runEv+0x3c>

00000e3a <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e3a:	0f 93       	push	r16
     e3c:	1f 93       	push	r17
     e3e:	cf 93       	push	r28
     e40:	df 93       	push	r29
     e42:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     e44:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     e48:	80 91 ca 20 	lds	r24, 0x20CA	; 0x8020ca <__data_end>
     e4c:	81 11       	cpse	r24, r1
     e4e:	1d c0       	rjmp	.+58     	; 0xe8a <pvPortMalloc+0x50>
		{
			prvHeapInit();
     e50:	af ec       	ldi	r26, 0xCF	; 207
     e52:	b0 e2       	ldi	r27, 0x20	; 32
     e54:	e3 ed       	ldi	r30, 0xD3	; 211
     e56:	f0 e2       	ldi	r31, 0x20	; 32
     e58:	ed 93       	st	X+, r30
     e5a:	fc 93       	st	X, r31
     e5c:	11 97       	sbiw	r26, 0x01	; 1
     e5e:	12 96       	adiw	r26, 0x02	; 2
     e60:	1d 92       	st	X+, r1
     e62:	1c 92       	st	X, r1
     e64:	13 97       	sbiw	r26, 0x03	; 3
     e66:	ab ec       	ldi	r26, 0xCB	; 203
     e68:	b0 e2       	ldi	r27, 0x20	; 32
     e6a:	8f ef       	ldi	r24, 0xFF	; 255
     e6c:	9f e0       	ldi	r25, 0x0F	; 15
     e6e:	12 96       	adiw	r26, 0x02	; 2
     e70:	8d 93       	st	X+, r24
     e72:	9c 93       	st	X, r25
     e74:	13 97       	sbiw	r26, 0x03	; 3
     e76:	1d 92       	st	X+, r1
     e78:	1c 92       	st	X, r1
     e7a:	11 97       	sbiw	r26, 0x01	; 1
     e7c:	82 83       	std	Z+2, r24	; 0x02
     e7e:	93 83       	std	Z+3, r25	; 0x03
     e80:	a0 83       	st	Z, r26
     e82:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     e84:	81 e0       	ldi	r24, 0x01	; 1
     e86:	80 93 ca 20 	sts	0x20CA, r24	; 0x8020ca <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     e8a:	20 97       	sbiw	r28, 0x00	; 0
     e8c:	09 f4       	brne	.+2      	; 0xe90 <pvPortMalloc+0x56>
     e8e:	5f c0       	rjmp	.+190    	; 0xf4e <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     e90:	9e 01       	movw	r18, r28
     e92:	2b 5f       	subi	r18, 0xFB	; 251
     e94:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     e96:	24 96       	adiw	r28, 0x04	; 4
     e98:	ce 3f       	cpi	r28, 0xFE	; 254
     e9a:	df 40       	sbci	r29, 0x0F	; 15
     e9c:	08 f0       	brcs	.+2      	; 0xea0 <pvPortMalloc+0x66>
     e9e:	5a c0       	rjmp	.+180    	; 0xf54 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     ea0:	e0 91 cf 20 	lds	r30, 0x20CF	; 0x8020cf <xStart>
     ea4:	f0 91 d0 20 	lds	r31, 0x20D0	; 0x8020d0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     ea8:	af ec       	ldi	r26, 0xCF	; 207
     eaa:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     eac:	02 c0       	rjmp	.+4      	; 0xeb2 <pvPortMalloc+0x78>
     eae:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     eb0:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     eb2:	82 81       	ldd	r24, Z+2	; 0x02
     eb4:	93 81       	ldd	r25, Z+3	; 0x03
     eb6:	82 17       	cp	r24, r18
     eb8:	93 07       	cpc	r25, r19
     eba:	20 f4       	brcc	.+8      	; 0xec4 <pvPortMalloc+0x8a>
     ebc:	80 81       	ld	r24, Z
     ebe:	91 81       	ldd	r25, Z+1	; 0x01
     ec0:	00 97       	sbiw	r24, 0x00	; 0
     ec2:	a9 f7       	brne	.-22     	; 0xeae <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     ec4:	c0 e2       	ldi	r28, 0x20	; 32
     ec6:	eb 3c       	cpi	r30, 0xCB	; 203
     ec8:	fc 07       	cpc	r31, r28
     eca:	09 f4       	brne	.+2      	; 0xece <pvPortMalloc+0x94>
     ecc:	46 c0       	rjmp	.+140    	; 0xf5a <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     ece:	cd 91       	ld	r28, X+
     ed0:	dc 91       	ld	r29, X
     ed2:	11 97       	sbiw	r26, 0x01	; 1
     ed4:	8e 01       	movw	r16, r28
     ed6:	0b 5f       	subi	r16, 0xFB	; 251
     ed8:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     eda:	80 81       	ld	r24, Z
     edc:	91 81       	ldd	r25, Z+1	; 0x01
     ede:	8d 93       	st	X+, r24
     ee0:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     ee2:	82 81       	ldd	r24, Z+2	; 0x02
     ee4:	93 81       	ldd	r25, Z+3	; 0x03
     ee6:	82 1b       	sub	r24, r18
     ee8:	93 0b       	sbc	r25, r19
     eea:	8b 30       	cpi	r24, 0x0B	; 11
     eec:	91 05       	cpc	r25, r1
     eee:	10 f1       	brcs	.+68     	; 0xf34 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     ef0:	bf 01       	movw	r22, r30
     ef2:	62 0f       	add	r22, r18
     ef4:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     ef6:	db 01       	movw	r26, r22
     ef8:	12 96       	adiw	r26, 0x02	; 2
     efa:	8d 93       	st	X+, r24
     efc:	9c 93       	st	X, r25
     efe:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     f00:	22 83       	std	Z+2, r18	; 0x02
     f02:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     f04:	12 96       	adiw	r26, 0x02	; 2
     f06:	4d 91       	ld	r20, X+
     f08:	5c 91       	ld	r21, X
     f0a:	13 97       	sbiw	r26, 0x03	; 3
     f0c:	8f ec       	ldi	r24, 0xCF	; 207
     f0e:	90 e2       	ldi	r25, 0x20	; 32
     f10:	01 c0       	rjmp	.+2      	; 0xf14 <pvPortMalloc+0xda>
     f12:	cd 01       	movw	r24, r26
     f14:	ec 01       	movw	r28, r24
     f16:	a8 81       	ld	r26, Y
     f18:	b9 81       	ldd	r27, Y+1	; 0x01
     f1a:	12 96       	adiw	r26, 0x02	; 2
     f1c:	2d 91       	ld	r18, X+
     f1e:	3c 91       	ld	r19, X
     f20:	13 97       	sbiw	r26, 0x03	; 3
     f22:	24 17       	cp	r18, r20
     f24:	35 07       	cpc	r19, r21
     f26:	a8 f3       	brcs	.-22     	; 0xf12 <pvPortMalloc+0xd8>
     f28:	eb 01       	movw	r28, r22
     f2a:	a8 83       	st	Y, r26
     f2c:	b9 83       	std	Y+1, r27	; 0x01
     f2e:	dc 01       	movw	r26, r24
     f30:	6d 93       	st	X+, r22
     f32:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     f34:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     f38:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     f3c:	22 81       	ldd	r18, Z+2	; 0x02
     f3e:	33 81       	ldd	r19, Z+3	; 0x03
     f40:	82 1b       	sub	r24, r18
     f42:	93 0b       	sbc	r25, r19
     f44:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     f48:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     f4c:	08 c0       	rjmp	.+16     	; 0xf5e <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     f4e:	00 e0       	ldi	r16, 0x00	; 0
     f50:	10 e0       	ldi	r17, 0x00	; 0
     f52:	05 c0       	rjmp	.+10     	; 0xf5e <pvPortMalloc+0x124>
     f54:	00 e0       	ldi	r16, 0x00	; 0
     f56:	10 e0       	ldi	r17, 0x00	; 0
     f58:	02 c0       	rjmp	.+4      	; 0xf5e <pvPortMalloc+0x124>
     f5a:	00 e0       	ldi	r16, 0x00	; 0
     f5c:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     f5e:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     f62:	c8 01       	movw	r24, r16
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	1f 91       	pop	r17
     f6a:	0f 91       	pop	r16
     f6c:	08 95       	ret

00000f6e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f6e:	0f 93       	push	r16
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     f76:	00 97       	sbiw	r24, 0x00	; 0
     f78:	41 f1       	breq	.+80     	; 0xfca <vPortFree+0x5c>
     f7a:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     f7c:	8c 01       	movw	r16, r24
     f7e:	05 50       	subi	r16, 0x05	; 5
     f80:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     f82:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     f86:	f8 01       	movw	r30, r16
     f88:	42 81       	ldd	r20, Z+2	; 0x02
     f8a:	53 81       	ldd	r21, Z+3	; 0x03
     f8c:	af ec       	ldi	r26, 0xCF	; 207
     f8e:	b0 e2       	ldi	r27, 0x20	; 32
     f90:	01 c0       	rjmp	.+2      	; 0xf94 <vPortFree+0x26>
     f92:	df 01       	movw	r26, r30
     f94:	ed 91       	ld	r30, X+
     f96:	fc 91       	ld	r31, X
     f98:	11 97       	sbiw	r26, 0x01	; 1
     f9a:	22 81       	ldd	r18, Z+2	; 0x02
     f9c:	33 81       	ldd	r19, Z+3	; 0x03
     f9e:	24 17       	cp	r18, r20
     fa0:	35 07       	cpc	r19, r21
     fa2:	b8 f3       	brcs	.-18     	; 0xf92 <vPortFree+0x24>
     fa4:	25 97       	sbiw	r28, 0x05	; 5
     fa6:	e8 83       	st	Y, r30
     fa8:	f9 83       	std	Y+1, r31	; 0x01
     faa:	0d 93       	st	X+, r16
     fac:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     fae:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
     fb2:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
     fb6:	8a 81       	ldd	r24, Y+2	; 0x02
     fb8:	9b 81       	ldd	r25, Y+3	; 0x03
     fba:	82 0f       	add	r24, r18
     fbc:	93 1f       	adc	r25, r19
     fbe:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     fc2:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
     fc6:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
	}
}
     fca:	df 91       	pop	r29
     fcc:	cf 91       	pop	r28
     fce:	1f 91       	pop	r17
     fd0:	0f 91       	pop	r16
     fd2:	08 95       	ret

00000fd4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     fd4:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     fd8:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     fdc:	08 95       	ret

00000fde <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     fde:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     fe0:	03 96       	adiw	r24, 0x03	; 3
     fe2:	81 83       	std	Z+1, r24	; 0x01
     fe4:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     fe6:	4f ef       	ldi	r20, 0xFF	; 255
     fe8:	5f ef       	ldi	r21, 0xFF	; 255
     fea:	ba 01       	movw	r22, r20
     fec:	43 83       	std	Z+3, r20	; 0x03
     fee:	54 83       	std	Z+4, r21	; 0x04
     ff0:	65 83       	std	Z+5, r22	; 0x05
     ff2:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     ff4:	87 83       	std	Z+7, r24	; 0x07
     ff6:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     ff8:	81 87       	std	Z+9, r24	; 0x09
     ffa:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     ffc:	10 82       	st	Z, r1
     ffe:	08 95       	ret

00001000 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1000:	fc 01       	movw	r30, r24
    1002:	12 86       	std	Z+10, r1	; 0x0a
    1004:	13 86       	std	Z+11, r1	; 0x0b
    1006:	08 95       	ret

00001008 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1008:	cf 93       	push	r28
    100a:	df 93       	push	r29
    100c:	fc 01       	movw	r30, r24
    100e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1010:	21 81       	ldd	r18, Z+1	; 0x01
    1012:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1014:	e9 01       	movw	r28, r18
    1016:	8c 81       	ldd	r24, Y+4	; 0x04
    1018:	9d 81       	ldd	r25, Y+5	; 0x05
    101a:	14 96       	adiw	r26, 0x04	; 4
    101c:	8d 93       	st	X+, r24
    101e:	9c 93       	st	X, r25
    1020:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1022:	81 81       	ldd	r24, Z+1	; 0x01
    1024:	92 81       	ldd	r25, Z+2	; 0x02
    1026:	16 96       	adiw	r26, 0x06	; 6
    1028:	8d 93       	st	X+, r24
    102a:	9c 93       	st	X, r25
    102c:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    102e:	8c 81       	ldd	r24, Y+4	; 0x04
    1030:	9d 81       	ldd	r25, Y+5	; 0x05
    1032:	ec 01       	movw	r28, r24
    1034:	6e 83       	std	Y+6, r22	; 0x06
    1036:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1038:	e9 01       	movw	r28, r18
    103a:	6c 83       	std	Y+4, r22	; 0x04
    103c:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    103e:	61 83       	std	Z+1, r22	; 0x01
    1040:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1042:	1a 96       	adiw	r26, 0x0a	; 10
    1044:	ed 93       	st	X+, r30
    1046:	fc 93       	st	X, r31
    1048:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    104a:	80 81       	ld	r24, Z
    104c:	8f 5f       	subi	r24, 0xFF	; 255
    104e:	80 83       	st	Z, r24
}
    1050:	df 91       	pop	r29
    1052:	cf 91       	pop	r28
    1054:	08 95       	ret

00001056 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1056:	0f 93       	push	r16
    1058:	1f 93       	push	r17
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
    105e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1060:	08 81       	ld	r16, Y
    1062:	19 81       	ldd	r17, Y+1	; 0x01
    1064:	2a 81       	ldd	r18, Y+2	; 0x02
    1066:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1068:	0f 3f       	cpi	r16, 0xFF	; 255
    106a:	4f ef       	ldi	r20, 0xFF	; 255
    106c:	14 07       	cpc	r17, r20
    106e:	24 07       	cpc	r18, r20
    1070:	34 07       	cpc	r19, r20
    1072:	31 f4       	brne	.+12     	; 0x1080 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1074:	dc 01       	movw	r26, r24
    1076:	19 96       	adiw	r26, 0x09	; 9
    1078:	ed 91       	ld	r30, X+
    107a:	fc 91       	ld	r31, X
    107c:	1a 97       	sbiw	r26, 0x0a	; 10
    107e:	1f c0       	rjmp	.+62     	; 0x10be <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1080:	fc 01       	movw	r30, r24
    1082:	33 96       	adiw	r30, 0x03	; 3
    1084:	dc 01       	movw	r26, r24
    1086:	17 96       	adiw	r26, 0x07	; 7
    1088:	4d 91       	ld	r20, X+
    108a:	5c 91       	ld	r21, X
    108c:	18 97       	sbiw	r26, 0x08	; 8
    108e:	da 01       	movw	r26, r20
    1090:	4d 91       	ld	r20, X+
    1092:	5d 91       	ld	r21, X+
    1094:	6d 91       	ld	r22, X+
    1096:	7c 91       	ld	r23, X
    1098:	04 17       	cp	r16, r20
    109a:	15 07       	cpc	r17, r21
    109c:	26 07       	cpc	r18, r22
    109e:	37 07       	cpc	r19, r23
    10a0:	70 f0       	brcs	.+28     	; 0x10be <vListInsert+0x68>
    10a2:	04 80       	ldd	r0, Z+4	; 0x04
    10a4:	f5 81       	ldd	r31, Z+5	; 0x05
    10a6:	e0 2d       	mov	r30, r0
    10a8:	a4 81       	ldd	r26, Z+4	; 0x04
    10aa:	b5 81       	ldd	r27, Z+5	; 0x05
    10ac:	4d 91       	ld	r20, X+
    10ae:	5d 91       	ld	r21, X+
    10b0:	6d 91       	ld	r22, X+
    10b2:	7c 91       	ld	r23, X
    10b4:	04 17       	cp	r16, r20
    10b6:	15 07       	cpc	r17, r21
    10b8:	26 07       	cpc	r18, r22
    10ba:	37 07       	cpc	r19, r23
    10bc:	90 f7       	brcc	.-28     	; 0x10a2 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    10be:	a4 81       	ldd	r26, Z+4	; 0x04
    10c0:	b5 81       	ldd	r27, Z+5	; 0x05
    10c2:	ac 83       	std	Y+4, r26	; 0x04
    10c4:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    10c6:	16 96       	adiw	r26, 0x06	; 6
    10c8:	cd 93       	st	X+, r28
    10ca:	dc 93       	st	X, r29
    10cc:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    10ce:	ee 83       	std	Y+6, r30	; 0x06
    10d0:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    10d2:	c4 83       	std	Z+4, r28	; 0x04
    10d4:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10d6:	8a 87       	std	Y+10, r24	; 0x0a
    10d8:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    10da:	fc 01       	movw	r30, r24
    10dc:	20 81       	ld	r18, Z
    10de:	2f 5f       	subi	r18, 0xFF	; 255
    10e0:	20 83       	st	Z, r18
}
    10e2:	df 91       	pop	r29
    10e4:	cf 91       	pop	r28
    10e6:	1f 91       	pop	r17
    10e8:	0f 91       	pop	r16
    10ea:	08 95       	ret

000010ec <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    10ec:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    10ee:	a4 81       	ldd	r26, Z+4	; 0x04
    10f0:	b5 81       	ldd	r27, Z+5	; 0x05
    10f2:	86 81       	ldd	r24, Z+6	; 0x06
    10f4:	97 81       	ldd	r25, Z+7	; 0x07
    10f6:	16 96       	adiw	r26, 0x06	; 6
    10f8:	8d 93       	st	X+, r24
    10fa:	9c 93       	st	X, r25
    10fc:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    10fe:	a6 81       	ldd	r26, Z+6	; 0x06
    1100:	b7 81       	ldd	r27, Z+7	; 0x07
    1102:	84 81       	ldd	r24, Z+4	; 0x04
    1104:	95 81       	ldd	r25, Z+5	; 0x05
    1106:	14 96       	adiw	r26, 0x04	; 4
    1108:	8d 93       	st	X+, r24
    110a:	9c 93       	st	X, r25
    110c:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    110e:	a2 85       	ldd	r26, Z+10	; 0x0a
    1110:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1112:	11 96       	adiw	r26, 0x01	; 1
    1114:	8d 91       	ld	r24, X+
    1116:	9c 91       	ld	r25, X
    1118:	12 97       	sbiw	r26, 0x02	; 2
    111a:	e8 17       	cp	r30, r24
    111c:	f9 07       	cpc	r31, r25
    111e:	31 f4       	brne	.+12     	; 0x112c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1120:	86 81       	ldd	r24, Z+6	; 0x06
    1122:	97 81       	ldd	r25, Z+7	; 0x07
    1124:	11 96       	adiw	r26, 0x01	; 1
    1126:	8d 93       	st	X+, r24
    1128:	9c 93       	st	X, r25
    112a:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    112c:	12 86       	std	Z+10, r1	; 0x0a
    112e:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1130:	8c 91       	ld	r24, X
    1132:	81 50       	subi	r24, 0x01	; 1
    1134:	8c 93       	st	X, r24
    1136:	08 95       	ret

00001138 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1138:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <portStackTopForTask>
    113c:	90 93 77 31 	sts	0x3177, r25	; 0x803177 <portStackTopForTask+0x1>
    1140:	31 e1       	ldi	r19, 0x11	; 17
    1142:	fc 01       	movw	r30, r24
    1144:	30 83       	st	Z, r19
    1146:	31 97       	sbiw	r30, 0x01	; 1
    1148:	22 e2       	ldi	r18, 0x22	; 34
    114a:	20 83       	st	Z, r18
    114c:	31 97       	sbiw	r30, 0x01	; 1
    114e:	a3 e3       	ldi	r26, 0x33	; 51
    1150:	a0 83       	st	Z, r26
    1152:	31 97       	sbiw	r30, 0x01	; 1
    1154:	60 83       	st	Z, r22
    1156:	31 97       	sbiw	r30, 0x01	; 1
    1158:	70 83       	st	Z, r23
    115a:	31 97       	sbiw	r30, 0x01	; 1
    115c:	10 82       	st	Z, r1
    115e:	31 97       	sbiw	r30, 0x01	; 1
    1160:	10 82       	st	Z, r1
    1162:	31 97       	sbiw	r30, 0x01	; 1
    1164:	60 e8       	ldi	r22, 0x80	; 128
    1166:	60 83       	st	Z, r22
    1168:	31 97       	sbiw	r30, 0x01	; 1
    116a:	10 82       	st	Z, r1
    116c:	31 97       	sbiw	r30, 0x01	; 1
    116e:	10 82       	st	Z, r1
    1170:	31 97       	sbiw	r30, 0x01	; 1
    1172:	10 82       	st	Z, r1
    1174:	31 97       	sbiw	r30, 0x01	; 1
    1176:	62 e0       	ldi	r22, 0x02	; 2
    1178:	60 83       	st	Z, r22
    117a:	31 97       	sbiw	r30, 0x01	; 1
    117c:	63 e0       	ldi	r22, 0x03	; 3
    117e:	60 83       	st	Z, r22
    1180:	31 97       	sbiw	r30, 0x01	; 1
    1182:	64 e0       	ldi	r22, 0x04	; 4
    1184:	60 83       	st	Z, r22
    1186:	31 97       	sbiw	r30, 0x01	; 1
    1188:	65 e0       	ldi	r22, 0x05	; 5
    118a:	60 83       	st	Z, r22
    118c:	31 97       	sbiw	r30, 0x01	; 1
    118e:	66 e0       	ldi	r22, 0x06	; 6
    1190:	60 83       	st	Z, r22
    1192:	31 97       	sbiw	r30, 0x01	; 1
    1194:	67 e0       	ldi	r22, 0x07	; 7
    1196:	60 83       	st	Z, r22
    1198:	31 97       	sbiw	r30, 0x01	; 1
    119a:	68 e0       	ldi	r22, 0x08	; 8
    119c:	60 83       	st	Z, r22
    119e:	31 97       	sbiw	r30, 0x01	; 1
    11a0:	69 e0       	ldi	r22, 0x09	; 9
    11a2:	60 83       	st	Z, r22
    11a4:	31 97       	sbiw	r30, 0x01	; 1
    11a6:	60 e1       	ldi	r22, 0x10	; 16
    11a8:	60 83       	st	Z, r22
    11aa:	31 97       	sbiw	r30, 0x01	; 1
    11ac:	30 83       	st	Z, r19
    11ae:	31 97       	sbiw	r30, 0x01	; 1
    11b0:	32 e1       	ldi	r19, 0x12	; 18
    11b2:	30 83       	st	Z, r19
    11b4:	31 97       	sbiw	r30, 0x01	; 1
    11b6:	33 e1       	ldi	r19, 0x13	; 19
    11b8:	30 83       	st	Z, r19
    11ba:	31 97       	sbiw	r30, 0x01	; 1
    11bc:	34 e1       	ldi	r19, 0x14	; 20
    11be:	30 83       	st	Z, r19
    11c0:	31 97       	sbiw	r30, 0x01	; 1
    11c2:	35 e1       	ldi	r19, 0x15	; 21
    11c4:	30 83       	st	Z, r19
    11c6:	31 97       	sbiw	r30, 0x01	; 1
    11c8:	36 e1       	ldi	r19, 0x16	; 22
    11ca:	30 83       	st	Z, r19
    11cc:	31 97       	sbiw	r30, 0x01	; 1
    11ce:	37 e1       	ldi	r19, 0x17	; 23
    11d0:	30 83       	st	Z, r19
    11d2:	31 97       	sbiw	r30, 0x01	; 1
    11d4:	38 e1       	ldi	r19, 0x18	; 24
    11d6:	30 83       	st	Z, r19
    11d8:	31 97       	sbiw	r30, 0x01	; 1
    11da:	39 e1       	ldi	r19, 0x19	; 25
    11dc:	30 83       	st	Z, r19
    11de:	31 97       	sbiw	r30, 0x01	; 1
    11e0:	30 e2       	ldi	r19, 0x20	; 32
    11e2:	30 83       	st	Z, r19
    11e4:	31 97       	sbiw	r30, 0x01	; 1
    11e6:	31 e2       	ldi	r19, 0x21	; 33
    11e8:	30 83       	st	Z, r19
    11ea:	31 97       	sbiw	r30, 0x01	; 1
    11ec:	20 83       	st	Z, r18
    11ee:	31 97       	sbiw	r30, 0x01	; 1
    11f0:	23 e2       	ldi	r18, 0x23	; 35
    11f2:	20 83       	st	Z, r18
    11f4:	31 97       	sbiw	r30, 0x01	; 1
    11f6:	40 83       	st	Z, r20
    11f8:	31 97       	sbiw	r30, 0x01	; 1
    11fa:	50 83       	st	Z, r21
    11fc:	31 97       	sbiw	r30, 0x01	; 1
    11fe:	26 e2       	ldi	r18, 0x26	; 38
    1200:	20 83       	st	Z, r18
    1202:	31 97       	sbiw	r30, 0x01	; 1
    1204:	27 e2       	ldi	r18, 0x27	; 39
    1206:	20 83       	st	Z, r18
    1208:	31 97       	sbiw	r30, 0x01	; 1
    120a:	28 e2       	ldi	r18, 0x28	; 40
    120c:	20 83       	st	Z, r18
    120e:	31 97       	sbiw	r30, 0x01	; 1
    1210:	29 e2       	ldi	r18, 0x29	; 41
    1212:	20 83       	st	Z, r18
    1214:	31 97       	sbiw	r30, 0x01	; 1
    1216:	20 e3       	ldi	r18, 0x30	; 48
    1218:	20 83       	st	Z, r18
    121a:	31 97       	sbiw	r30, 0x01	; 1
    121c:	21 e3       	ldi	r18, 0x31	; 49
    121e:	20 83       	st	Z, r18
    1220:	89 97       	sbiw	r24, 0x29	; 41
    1222:	08 95       	ret

00001224 <xPortStartScheduler>:
    1224:	8c e7       	ldi	r24, 0x7C	; 124
    1226:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
    122a:	8f ef       	ldi	r24, 0xFF	; 255
    122c:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
    1230:	81 e0       	ldi	r24, 0x01	; 1
    1232:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    1236:	81 e1       	ldi	r24, 0x11	; 17
    1238:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    123c:	83 e0       	ldi	r24, 0x03	; 3
    123e:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
    1242:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    1246:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    124a:	cd 91       	ld	r28, X+
    124c:	cd bf       	out	0x3d, r28	; 61
    124e:	dd 91       	ld	r29, X+
    1250:	de bf       	out	0x3e, r29	; 62
    1252:	ff 91       	pop	r31
    1254:	ef 91       	pop	r30
    1256:	df 91       	pop	r29
    1258:	cf 91       	pop	r28
    125a:	bf 91       	pop	r27
    125c:	af 91       	pop	r26
    125e:	9f 91       	pop	r25
    1260:	8f 91       	pop	r24
    1262:	7f 91       	pop	r23
    1264:	6f 91       	pop	r22
    1266:	5f 91       	pop	r21
    1268:	4f 91       	pop	r20
    126a:	3f 91       	pop	r19
    126c:	2f 91       	pop	r18
    126e:	1f 91       	pop	r17
    1270:	0f 91       	pop	r16
    1272:	ff 90       	pop	r15
    1274:	ef 90       	pop	r14
    1276:	df 90       	pop	r13
    1278:	cf 90       	pop	r12
    127a:	bf 90       	pop	r11
    127c:	af 90       	pop	r10
    127e:	9f 90       	pop	r9
    1280:	8f 90       	pop	r8
    1282:	7f 90       	pop	r7
    1284:	6f 90       	pop	r6
    1286:	5f 90       	pop	r5
    1288:	4f 90       	pop	r4
    128a:	3f 90       	pop	r3
    128c:	2f 90       	pop	r2
    128e:	1f 90       	pop	r1
    1290:	0f 90       	pop	r0
    1292:	0c be       	out	0x3c, r0	; 60
    1294:	0f 90       	pop	r0
    1296:	0b be       	out	0x3b, r0	; 59
    1298:	0f 90       	pop	r0
    129a:	0f be       	out	0x3f, r0	; 63
    129c:	0f 90       	pop	r0
    129e:	08 95       	ret
    12a0:	81 e0       	ldi	r24, 0x01	; 1
    12a2:	08 95       	ret

000012a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12a4:	0f 92       	push	r0
    12a6:	0f b6       	in	r0, 0x3f	; 63
    12a8:	f8 94       	cli
    12aa:	0f 92       	push	r0
    12ac:	0b b6       	in	r0, 0x3b	; 59
    12ae:	0f 92       	push	r0
    12b0:	0c b6       	in	r0, 0x3c	; 60
    12b2:	0f 92       	push	r0
    12b4:	1f 92       	push	r1
    12b6:	11 24       	eor	r1, r1
    12b8:	2f 92       	push	r2
    12ba:	3f 92       	push	r3
    12bc:	4f 92       	push	r4
    12be:	5f 92       	push	r5
    12c0:	6f 92       	push	r6
    12c2:	7f 92       	push	r7
    12c4:	8f 92       	push	r8
    12c6:	9f 92       	push	r9
    12c8:	af 92       	push	r10
    12ca:	bf 92       	push	r11
    12cc:	cf 92       	push	r12
    12ce:	df 92       	push	r13
    12d0:	ef 92       	push	r14
    12d2:	ff 92       	push	r15
    12d4:	0f 93       	push	r16
    12d6:	1f 93       	push	r17
    12d8:	2f 93       	push	r18
    12da:	3f 93       	push	r19
    12dc:	4f 93       	push	r20
    12de:	5f 93       	push	r21
    12e0:	6f 93       	push	r22
    12e2:	7f 93       	push	r23
    12e4:	8f 93       	push	r24
    12e6:	9f 93       	push	r25
    12e8:	af 93       	push	r26
    12ea:	bf 93       	push	r27
    12ec:	cf 93       	push	r28
    12ee:	df 93       	push	r29
    12f0:	ef 93       	push	r30
    12f2:	ff 93       	push	r31
    12f4:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    12f8:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    12fc:	0d b6       	in	r0, 0x3d	; 61
    12fe:	0d 92       	st	X+, r0
    1300:	0e b6       	in	r0, 0x3e	; 62
    1302:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1304:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1308:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    130c:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1310:	cd 91       	ld	r28, X+
    1312:	cd bf       	out	0x3d, r28	; 61
    1314:	dd 91       	ld	r29, X+
    1316:	de bf       	out	0x3e, r29	; 62
    1318:	ff 91       	pop	r31
    131a:	ef 91       	pop	r30
    131c:	df 91       	pop	r29
    131e:	cf 91       	pop	r28
    1320:	bf 91       	pop	r27
    1322:	af 91       	pop	r26
    1324:	9f 91       	pop	r25
    1326:	8f 91       	pop	r24
    1328:	7f 91       	pop	r23
    132a:	6f 91       	pop	r22
    132c:	5f 91       	pop	r21
    132e:	4f 91       	pop	r20
    1330:	3f 91       	pop	r19
    1332:	2f 91       	pop	r18
    1334:	1f 91       	pop	r17
    1336:	0f 91       	pop	r16
    1338:	ff 90       	pop	r15
    133a:	ef 90       	pop	r14
    133c:	df 90       	pop	r13
    133e:	cf 90       	pop	r12
    1340:	bf 90       	pop	r11
    1342:	af 90       	pop	r10
    1344:	9f 90       	pop	r9
    1346:	8f 90       	pop	r8
    1348:	7f 90       	pop	r7
    134a:	6f 90       	pop	r6
    134c:	5f 90       	pop	r5
    134e:	4f 90       	pop	r4
    1350:	3f 90       	pop	r3
    1352:	2f 90       	pop	r2
    1354:	1f 90       	pop	r1
    1356:	0f 90       	pop	r0
    1358:	0c be       	out	0x3c, r0	; 60
    135a:	0f 90       	pop	r0
    135c:	0b be       	out	0x3b, r0	; 59
    135e:	0f 90       	pop	r0
    1360:	0f be       	out	0x3f, r0	; 63
    1362:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1364:	08 95       	ret

00001366 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1366:	0f 92       	push	r0
    1368:	0f b6       	in	r0, 0x3f	; 63
    136a:	f8 94       	cli
    136c:	0f 92       	push	r0
    136e:	0b b6       	in	r0, 0x3b	; 59
    1370:	0f 92       	push	r0
    1372:	0c b6       	in	r0, 0x3c	; 60
    1374:	0f 92       	push	r0
    1376:	1f 92       	push	r1
    1378:	11 24       	eor	r1, r1
    137a:	2f 92       	push	r2
    137c:	3f 92       	push	r3
    137e:	4f 92       	push	r4
    1380:	5f 92       	push	r5
    1382:	6f 92       	push	r6
    1384:	7f 92       	push	r7
    1386:	8f 92       	push	r8
    1388:	9f 92       	push	r9
    138a:	af 92       	push	r10
    138c:	bf 92       	push	r11
    138e:	cf 92       	push	r12
    1390:	df 92       	push	r13
    1392:	ef 92       	push	r14
    1394:	ff 92       	push	r15
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	2f 93       	push	r18
    139c:	3f 93       	push	r19
    139e:	4f 93       	push	r20
    13a0:	5f 93       	push	r21
    13a2:	6f 93       	push	r22
    13a4:	7f 93       	push	r23
    13a6:	8f 93       	push	r24
    13a8:	9f 93       	push	r25
    13aa:	af 93       	push	r26
    13ac:	bf 93       	push	r27
    13ae:	cf 93       	push	r28
    13b0:	df 93       	push	r29
    13b2:	ef 93       	push	r30
    13b4:	ff 93       	push	r31
    13b6:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    13ba:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    13be:	0d b6       	in	r0, 0x3d	; 61
    13c0:	0d 92       	st	X+, r0
    13c2:	0e b6       	in	r0, 0x3e	; 62
    13c4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    13c6:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <vTaskIncrementTick>
	vTaskSwitchContext();
    13ca:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13ce:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    13d2:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    13d6:	cd 91       	ld	r28, X+
    13d8:	cd bf       	out	0x3d, r28	; 61
    13da:	dd 91       	ld	r29, X+
    13dc:	de bf       	out	0x3e, r29	; 62
    13de:	ff 91       	pop	r31
    13e0:	ef 91       	pop	r30
    13e2:	df 91       	pop	r29
    13e4:	cf 91       	pop	r28
    13e6:	bf 91       	pop	r27
    13e8:	af 91       	pop	r26
    13ea:	9f 91       	pop	r25
    13ec:	8f 91       	pop	r24
    13ee:	7f 91       	pop	r23
    13f0:	6f 91       	pop	r22
    13f2:	5f 91       	pop	r21
    13f4:	4f 91       	pop	r20
    13f6:	3f 91       	pop	r19
    13f8:	2f 91       	pop	r18
    13fa:	1f 91       	pop	r17
    13fc:	0f 91       	pop	r16
    13fe:	ff 90       	pop	r15
    1400:	ef 90       	pop	r14
    1402:	df 90       	pop	r13
    1404:	cf 90       	pop	r12
    1406:	bf 90       	pop	r11
    1408:	af 90       	pop	r10
    140a:	9f 90       	pop	r9
    140c:	8f 90       	pop	r8
    140e:	7f 90       	pop	r7
    1410:	6f 90       	pop	r6
    1412:	5f 90       	pop	r5
    1414:	4f 90       	pop	r4
    1416:	3f 90       	pop	r3
    1418:	2f 90       	pop	r2
    141a:	1f 90       	pop	r1
    141c:	0f 90       	pop	r0
    141e:	0c be       	out	0x3c, r0	; 60
    1420:	0f 90       	pop	r0
    1422:	0b be       	out	0x3b, r0	; 59
    1424:	0f 90       	pop	r0
    1426:	0f be       	out	0x3f, r0	; 63
    1428:	0f 90       	pop	r0

	asm volatile ( "ret" );
    142a:	08 95       	ret

0000142c <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    142c:	0e 94 b3 09 	call	0x1366	; 0x1366 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1430:	18 95       	reti

00001432 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1432:	cf 93       	push	r28
    1434:	df 93       	push	r29
    1436:	ec 01       	movw	r28, r24
    1438:	88 a1       	ldd	r24, Y+32	; 0x20
    143a:	81 11       	cpse	r24, r1
    143c:	0b c0       	rjmp	.+22     	; 0x1454 <prvCopyDataToQueue+0x22>
    143e:	88 81       	ld	r24, Y
    1440:	99 81       	ldd	r25, Y+1	; 0x01
    1442:	89 2b       	or	r24, r25
    1444:	e1 f5       	brne	.+120    	; 0x14be <prvCopyDataToQueue+0x8c>
    1446:	8a 81       	ldd	r24, Y+2	; 0x02
    1448:	9b 81       	ldd	r25, Y+3	; 0x03
    144a:	0e 94 2d 12 	call	0x245a	; 0x245a <vTaskPriorityDisinherit>
    144e:	1a 82       	std	Y+2, r1	; 0x02
    1450:	1b 82       	std	Y+3, r1	; 0x03
    1452:	35 c0       	rjmp	.+106    	; 0x14be <prvCopyDataToQueue+0x8c>
    1454:	41 11       	cpse	r20, r1
    1456:	17 c0       	rjmp	.+46     	; 0x1486 <prvCopyDataToQueue+0x54>
    1458:	48 2f       	mov	r20, r24
    145a:	50 e0       	ldi	r21, 0x00	; 0
    145c:	8c 81       	ldd	r24, Y+4	; 0x04
    145e:	9d 81       	ldd	r25, Y+5	; 0x05
    1460:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <memcpy>
    1464:	28 a1       	ldd	r18, Y+32	; 0x20
    1466:	8c 81       	ldd	r24, Y+4	; 0x04
    1468:	9d 81       	ldd	r25, Y+5	; 0x05
    146a:	82 0f       	add	r24, r18
    146c:	91 1d       	adc	r25, r1
    146e:	8c 83       	std	Y+4, r24	; 0x04
    1470:	9d 83       	std	Y+5, r25	; 0x05
    1472:	2a 81       	ldd	r18, Y+2	; 0x02
    1474:	3b 81       	ldd	r19, Y+3	; 0x03
    1476:	82 17       	cp	r24, r18
    1478:	93 07       	cpc	r25, r19
    147a:	08 f1       	brcs	.+66     	; 0x14be <prvCopyDataToQueue+0x8c>
    147c:	88 81       	ld	r24, Y
    147e:	99 81       	ldd	r25, Y+1	; 0x01
    1480:	8c 83       	std	Y+4, r24	; 0x04
    1482:	9d 83       	std	Y+5, r25	; 0x05
    1484:	1c c0       	rjmp	.+56     	; 0x14be <prvCopyDataToQueue+0x8c>
    1486:	48 2f       	mov	r20, r24
    1488:	50 e0       	ldi	r21, 0x00	; 0
    148a:	8e 81       	ldd	r24, Y+6	; 0x06
    148c:	9f 81       	ldd	r25, Y+7	; 0x07
    148e:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <memcpy>
    1492:	88 a1       	ldd	r24, Y+32	; 0x20
    1494:	90 e0       	ldi	r25, 0x00	; 0
    1496:	91 95       	neg	r25
    1498:	81 95       	neg	r24
    149a:	91 09       	sbc	r25, r1
    149c:	2e 81       	ldd	r18, Y+6	; 0x06
    149e:	3f 81       	ldd	r19, Y+7	; 0x07
    14a0:	28 0f       	add	r18, r24
    14a2:	39 1f       	adc	r19, r25
    14a4:	2e 83       	std	Y+6, r18	; 0x06
    14a6:	3f 83       	std	Y+7, r19	; 0x07
    14a8:	48 81       	ld	r20, Y
    14aa:	59 81       	ldd	r21, Y+1	; 0x01
    14ac:	24 17       	cp	r18, r20
    14ae:	35 07       	cpc	r19, r21
    14b0:	30 f4       	brcc	.+12     	; 0x14be <prvCopyDataToQueue+0x8c>
    14b2:	2a 81       	ldd	r18, Y+2	; 0x02
    14b4:	3b 81       	ldd	r19, Y+3	; 0x03
    14b6:	82 0f       	add	r24, r18
    14b8:	93 1f       	adc	r25, r19
    14ba:	8e 83       	std	Y+6, r24	; 0x06
    14bc:	9f 83       	std	Y+7, r25	; 0x07
    14be:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14c0:	8f 5f       	subi	r24, 0xFF	; 255
    14c2:	8e 8f       	std	Y+30, r24	; 0x1e
    14c4:	df 91       	pop	r29
    14c6:	cf 91       	pop	r28
    14c8:	08 95       	ret

000014ca <prvCopyDataFromQueue>:
    14ca:	fc 01       	movw	r30, r24
    14cc:	80 81       	ld	r24, Z
    14ce:	91 81       	ldd	r25, Z+1	; 0x01
    14d0:	00 97       	sbiw	r24, 0x00	; 0
    14d2:	a1 f0       	breq	.+40     	; 0x14fc <prvCopyDataFromQueue+0x32>
    14d4:	40 a1       	ldd	r20, Z+32	; 0x20
    14d6:	50 e0       	ldi	r21, 0x00	; 0
    14d8:	26 81       	ldd	r18, Z+6	; 0x06
    14da:	37 81       	ldd	r19, Z+7	; 0x07
    14dc:	24 0f       	add	r18, r20
    14de:	35 1f       	adc	r19, r21
    14e0:	26 83       	std	Z+6, r18	; 0x06
    14e2:	37 83       	std	Z+7, r19	; 0x07
    14e4:	a2 81       	ldd	r26, Z+2	; 0x02
    14e6:	b3 81       	ldd	r27, Z+3	; 0x03
    14e8:	2a 17       	cp	r18, r26
    14ea:	3b 07       	cpc	r19, r27
    14ec:	10 f0       	brcs	.+4      	; 0x14f2 <prvCopyDataFromQueue+0x28>
    14ee:	86 83       	std	Z+6, r24	; 0x06
    14f0:	97 83       	std	Z+7, r25	; 0x07
    14f2:	cb 01       	movw	r24, r22
    14f4:	66 81       	ldd	r22, Z+6	; 0x06
    14f6:	77 81       	ldd	r23, Z+7	; 0x07
    14f8:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <memcpy>
    14fc:	08 95       	ret

000014fe <prvUnlockQueue>:
    14fe:	0f 93       	push	r16
    1500:	1f 93       	push	r17
    1502:	cf 93       	push	r28
    1504:	df 93       	push	r29
    1506:	ec 01       	movw	r28, r24
    1508:	0f b6       	in	r0, 0x3f	; 63
    150a:	f8 94       	cli
    150c:	0f 92       	push	r0
    150e:	8a a1       	ldd	r24, Y+34	; 0x22
    1510:	18 16       	cp	r1, r24
    1512:	b4 f4       	brge	.+44     	; 0x1540 <prvUnlockQueue+0x42>
    1514:	8b 89       	ldd	r24, Y+19	; 0x13
    1516:	81 11       	cpse	r24, r1
    1518:	05 c0       	rjmp	.+10     	; 0x1524 <prvUnlockQueue+0x26>
    151a:	12 c0       	rjmp	.+36     	; 0x1540 <prvUnlockQueue+0x42>
    151c:	8b 89       	ldd	r24, Y+19	; 0x13
    151e:	81 11       	cpse	r24, r1
    1520:	04 c0       	rjmp	.+8      	; 0x152a <prvUnlockQueue+0x2c>
    1522:	0e c0       	rjmp	.+28     	; 0x1540 <prvUnlockQueue+0x42>
    1524:	8e 01       	movw	r16, r28
    1526:	0d 5e       	subi	r16, 0xED	; 237
    1528:	1f 4f       	sbci	r17, 0xFF	; 255
    152a:	c8 01       	movw	r24, r16
    152c:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <xTaskRemoveFromEventList>
    1530:	81 11       	cpse	r24, r1
    1532:	0e 94 b6 11 	call	0x236c	; 0x236c <vTaskMissedYield>
    1536:	8a a1       	ldd	r24, Y+34	; 0x22
    1538:	81 50       	subi	r24, 0x01	; 1
    153a:	8a a3       	std	Y+34, r24	; 0x22
    153c:	18 16       	cp	r1, r24
    153e:	74 f3       	brlt	.-36     	; 0x151c <prvUnlockQueue+0x1e>
    1540:	8f ef       	ldi	r24, 0xFF	; 255
    1542:	8a a3       	std	Y+34, r24	; 0x22
    1544:	0f 90       	pop	r0
    1546:	0f be       	out	0x3f, r0	; 63
    1548:	0f b6       	in	r0, 0x3f	; 63
    154a:	f8 94       	cli
    154c:	0f 92       	push	r0
    154e:	89 a1       	ldd	r24, Y+33	; 0x21
    1550:	18 16       	cp	r1, r24
    1552:	b4 f4       	brge	.+44     	; 0x1580 <prvUnlockQueue+0x82>
    1554:	88 85       	ldd	r24, Y+8	; 0x08
    1556:	81 11       	cpse	r24, r1
    1558:	05 c0       	rjmp	.+10     	; 0x1564 <prvUnlockQueue+0x66>
    155a:	12 c0       	rjmp	.+36     	; 0x1580 <prvUnlockQueue+0x82>
    155c:	88 85       	ldd	r24, Y+8	; 0x08
    155e:	81 11       	cpse	r24, r1
    1560:	04 c0       	rjmp	.+8      	; 0x156a <prvUnlockQueue+0x6c>
    1562:	0e c0       	rjmp	.+28     	; 0x1580 <prvUnlockQueue+0x82>
    1564:	8e 01       	movw	r16, r28
    1566:	08 5f       	subi	r16, 0xF8	; 248
    1568:	1f 4f       	sbci	r17, 0xFF	; 255
    156a:	c8 01       	movw	r24, r16
    156c:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <xTaskRemoveFromEventList>
    1570:	81 11       	cpse	r24, r1
    1572:	0e 94 b6 11 	call	0x236c	; 0x236c <vTaskMissedYield>
    1576:	89 a1       	ldd	r24, Y+33	; 0x21
    1578:	81 50       	subi	r24, 0x01	; 1
    157a:	89 a3       	std	Y+33, r24	; 0x21
    157c:	18 16       	cp	r1, r24
    157e:	74 f3       	brlt	.-36     	; 0x155c <prvUnlockQueue+0x5e>
    1580:	8f ef       	ldi	r24, 0xFF	; 255
    1582:	89 a3       	std	Y+33, r24	; 0x21
    1584:	0f 90       	pop	r0
    1586:	0f be       	out	0x3f, r0	; 63
    1588:	df 91       	pop	r29
    158a:	cf 91       	pop	r28
    158c:	1f 91       	pop	r17
    158e:	0f 91       	pop	r16
    1590:	08 95       	ret

00001592 <xQueueGenericReset>:
    1592:	1f 93       	push	r17
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	61 30       	cpi	r22, 0x01	; 1
    159a:	59 f0       	breq	.+22     	; 0x15b2 <xQueueGenericReset+0x20>
    159c:	fc 01       	movw	r30, r24
    159e:	23 89       	ldd	r18, Z+19	; 0x13
    15a0:	30 85       	ldd	r19, Z+8	; 0x08
    15a2:	31 11       	cpse	r19, r1
    15a4:	2c c0       	rjmp	.+88     	; 0x15fe <xQueueGenericReset+0x6c>
    15a6:	11 e0       	ldi	r17, 0x01	; 1
    15a8:	21 11       	cpse	r18, r1
    15aa:	10 e0       	ldi	r17, 0x00	; 0
    15ac:	21 11       	cpse	r18, r1
    15ae:	28 c0       	rjmp	.+80     	; 0x1600 <xQueueGenericReset+0x6e>
    15b0:	01 c0       	rjmp	.+2      	; 0x15b4 <xQueueGenericReset+0x22>
    15b2:	11 e0       	ldi	r17, 0x01	; 1
    15b4:	ec 01       	movw	r28, r24
    15b6:	48 81       	ld	r20, Y
    15b8:	59 81       	ldd	r21, Y+1	; 0x01
    15ba:	28 a1       	ldd	r18, Y+32	; 0x20
    15bc:	30 e0       	ldi	r19, 0x00	; 0
    15be:	6f 8d       	ldd	r22, Y+31	; 0x1f
    15c0:	62 9f       	mul	r22, r18
    15c2:	c0 01       	movw	r24, r0
    15c4:	63 9f       	mul	r22, r19
    15c6:	90 0d       	add	r25, r0
    15c8:	11 24       	eor	r1, r1
    15ca:	ba 01       	movw	r22, r20
    15cc:	68 0f       	add	r22, r24
    15ce:	79 1f       	adc	r23, r25
    15d0:	6a 83       	std	Y+2, r22	; 0x02
    15d2:	7b 83       	std	Y+3, r23	; 0x03
    15d4:	1e 8e       	std	Y+30, r1	; 0x1e
    15d6:	4c 83       	std	Y+4, r20	; 0x04
    15d8:	5d 83       	std	Y+5, r21	; 0x05
    15da:	82 1b       	sub	r24, r18
    15dc:	93 0b       	sbc	r25, r19
    15de:	84 0f       	add	r24, r20
    15e0:	95 1f       	adc	r25, r21
    15e2:	8e 83       	std	Y+6, r24	; 0x06
    15e4:	9f 83       	std	Y+7, r25	; 0x07
    15e6:	8f ef       	ldi	r24, 0xFF	; 255
    15e8:	89 a3       	std	Y+33, r24	; 0x21
    15ea:	8a a3       	std	Y+34, r24	; 0x22
    15ec:	ce 01       	movw	r24, r28
    15ee:	08 96       	adiw	r24, 0x08	; 8
    15f0:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    15f4:	ce 01       	movw	r24, r28
    15f6:	43 96       	adiw	r24, 0x13	; 19
    15f8:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    15fc:	01 c0       	rjmp	.+2      	; 0x1600 <xQueueGenericReset+0x6e>
    15fe:	10 e0       	ldi	r17, 0x00	; 0
    1600:	81 2f       	mov	r24, r17
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	1f 91       	pop	r17
    1608:	08 95       	ret

0000160a <xQueueGenericCreate>:
    160a:	0f 93       	push	r16
    160c:	1f 93       	push	r17
    160e:	cf 93       	push	r28
    1610:	df 93       	push	r29
    1612:	88 23       	and	r24, r24
    1614:	01 f1       	breq	.+64     	; 0x1656 <xQueueGenericCreate+0x4c>
    1616:	06 2f       	mov	r16, r22
    1618:	18 2f       	mov	r17, r24
    161a:	83 e2       	ldi	r24, 0x23	; 35
    161c:	90 e0       	ldi	r25, 0x00	; 0
    161e:	0e 94 1d 07 	call	0xe3a	; 0xe3a <pvPortMalloc>
    1622:	ec 01       	movw	r28, r24
    1624:	89 2b       	or	r24, r25
    1626:	c9 f0       	breq	.+50     	; 0x165a <xQueueGenericCreate+0x50>
    1628:	10 9f       	mul	r17, r16
    162a:	c0 01       	movw	r24, r0
    162c:	11 24       	eor	r1, r1
    162e:	01 96       	adiw	r24, 0x01	; 1
    1630:	0e 94 1d 07 	call	0xe3a	; 0xe3a <pvPortMalloc>
    1634:	88 83       	st	Y, r24
    1636:	99 83       	std	Y+1, r25	; 0x01
    1638:	89 2b       	or	r24, r25
    163a:	39 f0       	breq	.+14     	; 0x164a <xQueueGenericCreate+0x40>
    163c:	1f 8f       	std	Y+31, r17	; 0x1f
    163e:	08 a3       	std	Y+32, r16	; 0x20
    1640:	61 e0       	ldi	r22, 0x01	; 1
    1642:	ce 01       	movw	r24, r28
    1644:	0e 94 c9 0a 	call	0x1592	; 0x1592 <xQueueGenericReset>
    1648:	08 c0       	rjmp	.+16     	; 0x165a <xQueueGenericCreate+0x50>
    164a:	ce 01       	movw	r24, r28
    164c:	0e 94 b7 07 	call	0xf6e	; 0xf6e <vPortFree>
    1650:	c0 e0       	ldi	r28, 0x00	; 0
    1652:	d0 e0       	ldi	r29, 0x00	; 0
    1654:	02 c0       	rjmp	.+4      	; 0x165a <xQueueGenericCreate+0x50>
    1656:	c0 e0       	ldi	r28, 0x00	; 0
    1658:	d0 e0       	ldi	r29, 0x00	; 0
    165a:	ce 01       	movw	r24, r28
    165c:	df 91       	pop	r29
    165e:	cf 91       	pop	r28
    1660:	1f 91       	pop	r17
    1662:	0f 91       	pop	r16
    1664:	08 95       	ret

00001666 <xQueueGenericSend>:
    1666:	af 92       	push	r10
    1668:	bf 92       	push	r11
    166a:	cf 92       	push	r12
    166c:	df 92       	push	r13
    166e:	ef 92       	push	r14
    1670:	ff 92       	push	r15
    1672:	0f 93       	push	r16
    1674:	1f 93       	push	r17
    1676:	cf 93       	push	r28
    1678:	df 93       	push	r29
    167a:	cd b7       	in	r28, 0x3d	; 61
    167c:	de b7       	in	r29, 0x3e	; 62
    167e:	29 97       	sbiw	r28, 0x09	; 9
    1680:	cd bf       	out	0x3d, r28	; 61
    1682:	de bf       	out	0x3e, r29	; 62
    1684:	7c 01       	movw	r14, r24
    1686:	5b 01       	movw	r10, r22
    1688:	2e 83       	std	Y+6, r18	; 0x06
    168a:	3f 83       	std	Y+7, r19	; 0x07
    168c:	48 87       	std	Y+8, r20	; 0x08
    168e:	59 87       	std	Y+9, r21	; 0x09
    1690:	10 e0       	ldi	r17, 0x00	; 0
    1692:	6c 01       	movw	r12, r24
    1694:	88 e0       	ldi	r24, 0x08	; 8
    1696:	c8 0e       	add	r12, r24
    1698:	d1 1c       	adc	r13, r1
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	0f 92       	push	r0
    16a0:	f7 01       	movw	r30, r14
    16a2:	96 8d       	ldd	r25, Z+30	; 0x1e
    16a4:	87 8d       	ldd	r24, Z+31	; 0x1f
    16a6:	98 17       	cp	r25, r24
    16a8:	a8 f4       	brcc	.+42     	; 0x16d4 <xQueueGenericSend+0x6e>
    16aa:	40 2f       	mov	r20, r16
    16ac:	b5 01       	movw	r22, r10
    16ae:	c7 01       	movw	r24, r14
    16b0:	0e 94 19 0a 	call	0x1432	; 0x1432 <prvCopyDataToQueue>
    16b4:	f7 01       	movw	r30, r14
    16b6:	83 89       	ldd	r24, Z+19	; 0x13
    16b8:	88 23       	and	r24, r24
    16ba:	41 f0       	breq	.+16     	; 0x16cc <xQueueGenericSend+0x66>
    16bc:	c7 01       	movw	r24, r14
    16be:	43 96       	adiw	r24, 0x13	; 19
    16c0:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <xTaskRemoveFromEventList>
    16c4:	81 30       	cpi	r24, 0x01	; 1
    16c6:	11 f4       	brne	.+4      	; 0x16cc <xQueueGenericSend+0x66>
    16c8:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    16cc:	0f 90       	pop	r0
    16ce:	0f be       	out	0x3f, r0	; 63
    16d0:	81 e0       	ldi	r24, 0x01	; 1
    16d2:	56 c0       	rjmp	.+172    	; 0x1780 <xQueueGenericSend+0x11a>
    16d4:	8e 81       	ldd	r24, Y+6	; 0x06
    16d6:	9f 81       	ldd	r25, Y+7	; 0x07
    16d8:	a8 85       	ldd	r26, Y+8	; 0x08
    16da:	b9 85       	ldd	r27, Y+9	; 0x09
    16dc:	89 2b       	or	r24, r25
    16de:	8a 2b       	or	r24, r26
    16e0:	8b 2b       	or	r24, r27
    16e2:	21 f4       	brne	.+8      	; 0x16ec <xQueueGenericSend+0x86>
    16e4:	0f 90       	pop	r0
    16e6:	0f be       	out	0x3f, r0	; 63
    16e8:	80 e0       	ldi	r24, 0x00	; 0
    16ea:	4a c0       	rjmp	.+148    	; 0x1780 <xQueueGenericSend+0x11a>
    16ec:	11 11       	cpse	r17, r1
    16ee:	05 c0       	rjmp	.+10     	; 0x16fa <xQueueGenericSend+0x94>
    16f0:	ce 01       	movw	r24, r28
    16f2:	01 96       	adiw	r24, 0x01	; 1
    16f4:	0e 94 38 11 	call	0x2270	; 0x2270 <vTaskSetTimeOutState>
    16f8:	11 e0       	ldi	r17, 0x01	; 1
    16fa:	0f 90       	pop	r0
    16fc:	0f be       	out	0x3f, r0	; 63
    16fe:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <vTaskSuspendAll>
    1702:	0f b6       	in	r0, 0x3f	; 63
    1704:	f8 94       	cli
    1706:	0f 92       	push	r0
    1708:	f7 01       	movw	r30, r14
    170a:	81 a1       	ldd	r24, Z+33	; 0x21
    170c:	8f 3f       	cpi	r24, 0xFF	; 255
    170e:	09 f4       	brne	.+2      	; 0x1712 <xQueueGenericSend+0xac>
    1710:	11 a2       	std	Z+33, r1	; 0x21
    1712:	f7 01       	movw	r30, r14
    1714:	82 a1       	ldd	r24, Z+34	; 0x22
    1716:	8f 3f       	cpi	r24, 0xFF	; 255
    1718:	09 f4       	brne	.+2      	; 0x171c <xQueueGenericSend+0xb6>
    171a:	12 a2       	std	Z+34, r1	; 0x22
    171c:	0f 90       	pop	r0
    171e:	0f be       	out	0x3f, r0	; 63
    1720:	be 01       	movw	r22, r28
    1722:	6a 5f       	subi	r22, 0xFA	; 250
    1724:	7f 4f       	sbci	r23, 0xFF	; 255
    1726:	ce 01       	movw	r24, r28
    1728:	01 96       	adiw	r24, 0x01	; 1
    172a:	0e 94 49 11 	call	0x2292	; 0x2292 <xTaskCheckForTimeOut>
    172e:	81 11       	cpse	r24, r1
    1730:	21 c0       	rjmp	.+66     	; 0x1774 <xQueueGenericSend+0x10e>
    1732:	0f b6       	in	r0, 0x3f	; 63
    1734:	f8 94       	cli
    1736:	0f 92       	push	r0
    1738:	f7 01       	movw	r30, r14
    173a:	96 8d       	ldd	r25, Z+30	; 0x1e
    173c:	0f 90       	pop	r0
    173e:	0f be       	out	0x3f, r0	; 63
    1740:	87 8d       	ldd	r24, Z+31	; 0x1f
    1742:	98 13       	cpse	r25, r24
    1744:	11 c0       	rjmp	.+34     	; 0x1768 <xQueueGenericSend+0x102>
    1746:	4e 81       	ldd	r20, Y+6	; 0x06
    1748:	5f 81       	ldd	r21, Y+7	; 0x07
    174a:	68 85       	ldd	r22, Y+8	; 0x08
    174c:	79 85       	ldd	r23, Y+9	; 0x09
    174e:	c6 01       	movw	r24, r12
    1750:	0e 94 cf 10 	call	0x219e	; 0x219e <vTaskPlaceOnEventList>
    1754:	c7 01       	movw	r24, r14
    1756:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <prvUnlockQueue>
    175a:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
    175e:	81 11       	cpse	r24, r1
    1760:	9c cf       	rjmp	.-200    	; 0x169a <xQueueGenericSend+0x34>
    1762:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    1766:	99 cf       	rjmp	.-206    	; 0x169a <xQueueGenericSend+0x34>
    1768:	c7 01       	movw	r24, r14
    176a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <prvUnlockQueue>
    176e:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
    1772:	93 cf       	rjmp	.-218    	; 0x169a <xQueueGenericSend+0x34>
    1774:	c7 01       	movw	r24, r14
    1776:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <prvUnlockQueue>
    177a:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
    177e:	80 e0       	ldi	r24, 0x00	; 0
    1780:	29 96       	adiw	r28, 0x09	; 9
    1782:	cd bf       	out	0x3d, r28	; 61
    1784:	de bf       	out	0x3e, r29	; 62
    1786:	df 91       	pop	r29
    1788:	cf 91       	pop	r28
    178a:	1f 91       	pop	r17
    178c:	0f 91       	pop	r16
    178e:	ff 90       	pop	r15
    1790:	ef 90       	pop	r14
    1792:	df 90       	pop	r13
    1794:	cf 90       	pop	r12
    1796:	bf 90       	pop	r11
    1798:	af 90       	pop	r10
    179a:	08 95       	ret

0000179c <xQueueGenericReceive>:
    179c:	af 92       	push	r10
    179e:	bf 92       	push	r11
    17a0:	cf 92       	push	r12
    17a2:	df 92       	push	r13
    17a4:	ef 92       	push	r14
    17a6:	ff 92       	push	r15
    17a8:	0f 93       	push	r16
    17aa:	1f 93       	push	r17
    17ac:	cf 93       	push	r28
    17ae:	df 93       	push	r29
    17b0:	cd b7       	in	r28, 0x3d	; 61
    17b2:	de b7       	in	r29, 0x3e	; 62
    17b4:	29 97       	sbiw	r28, 0x09	; 9
    17b6:	cd bf       	out	0x3d, r28	; 61
    17b8:	de bf       	out	0x3e, r29	; 62
    17ba:	7c 01       	movw	r14, r24
    17bc:	5b 01       	movw	r10, r22
    17be:	2e 83       	std	Y+6, r18	; 0x06
    17c0:	3f 83       	std	Y+7, r19	; 0x07
    17c2:	48 87       	std	Y+8, r20	; 0x08
    17c4:	59 87       	std	Y+9, r21	; 0x09
    17c6:	10 e0       	ldi	r17, 0x00	; 0
    17c8:	6c 01       	movw	r12, r24
    17ca:	83 e1       	ldi	r24, 0x13	; 19
    17cc:	c8 0e       	add	r12, r24
    17ce:	d1 1c       	adc	r13, r1
    17d0:	0f b6       	in	r0, 0x3f	; 63
    17d2:	f8 94       	cli
    17d4:	0f 92       	push	r0
    17d6:	f7 01       	movw	r30, r14
    17d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    17da:	88 23       	and	r24, r24
    17dc:	99 f1       	breq	.+102    	; 0x1844 <xQueueGenericReceive+0xa8>
    17de:	c6 80       	ldd	r12, Z+6	; 0x06
    17e0:	d7 80       	ldd	r13, Z+7	; 0x07
    17e2:	b5 01       	movw	r22, r10
    17e4:	c7 01       	movw	r24, r14
    17e6:	0e 94 65 0a 	call	0x14ca	; 0x14ca <prvCopyDataFromQueue>
    17ea:	01 11       	cpse	r16, r1
    17ec:	1a c0       	rjmp	.+52     	; 0x1822 <xQueueGenericReceive+0x86>
    17ee:	f7 01       	movw	r30, r14
    17f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    17f2:	81 50       	subi	r24, 0x01	; 1
    17f4:	86 8f       	std	Z+30, r24	; 0x1e
    17f6:	80 81       	ld	r24, Z
    17f8:	91 81       	ldd	r25, Z+1	; 0x01
    17fa:	89 2b       	or	r24, r25
    17fc:	29 f4       	brne	.+10     	; 0x1808 <xQueueGenericReceive+0x6c>
    17fe:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <xTaskGetCurrentTaskHandle>
    1802:	f7 01       	movw	r30, r14
    1804:	82 83       	std	Z+2, r24	; 0x02
    1806:	93 83       	std	Z+3, r25	; 0x03
    1808:	f7 01       	movw	r30, r14
    180a:	80 85       	ldd	r24, Z+8	; 0x08
    180c:	88 23       	and	r24, r24
    180e:	b1 f0       	breq	.+44     	; 0x183c <xQueueGenericReceive+0xa0>
    1810:	c7 01       	movw	r24, r14
    1812:	08 96       	adiw	r24, 0x08	; 8
    1814:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <xTaskRemoveFromEventList>
    1818:	81 30       	cpi	r24, 0x01	; 1
    181a:	81 f4       	brne	.+32     	; 0x183c <xQueueGenericReceive+0xa0>
    181c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    1820:	0d c0       	rjmp	.+26     	; 0x183c <xQueueGenericReceive+0xa0>
    1822:	f7 01       	movw	r30, r14
    1824:	c6 82       	std	Z+6, r12	; 0x06
    1826:	d7 82       	std	Z+7, r13	; 0x07
    1828:	83 89       	ldd	r24, Z+19	; 0x13
    182a:	88 23       	and	r24, r24
    182c:	39 f0       	breq	.+14     	; 0x183c <xQueueGenericReceive+0xa0>
    182e:	c7 01       	movw	r24, r14
    1830:	43 96       	adiw	r24, 0x13	; 19
    1832:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <xTaskRemoveFromEventList>
    1836:	81 11       	cpse	r24, r1
    1838:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    183c:	0f 90       	pop	r0
    183e:	0f be       	out	0x3f, r0	; 63
    1840:	81 e0       	ldi	r24, 0x01	; 1
    1842:	62 c0       	rjmp	.+196    	; 0x1908 <xQueueGenericReceive+0x16c>
    1844:	8e 81       	ldd	r24, Y+6	; 0x06
    1846:	9f 81       	ldd	r25, Y+7	; 0x07
    1848:	a8 85       	ldd	r26, Y+8	; 0x08
    184a:	b9 85       	ldd	r27, Y+9	; 0x09
    184c:	89 2b       	or	r24, r25
    184e:	8a 2b       	or	r24, r26
    1850:	8b 2b       	or	r24, r27
    1852:	21 f4       	brne	.+8      	; 0x185c <xQueueGenericReceive+0xc0>
    1854:	0f 90       	pop	r0
    1856:	0f be       	out	0x3f, r0	; 63
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	56 c0       	rjmp	.+172    	; 0x1908 <xQueueGenericReceive+0x16c>
    185c:	11 11       	cpse	r17, r1
    185e:	05 c0       	rjmp	.+10     	; 0x186a <xQueueGenericReceive+0xce>
    1860:	ce 01       	movw	r24, r28
    1862:	01 96       	adiw	r24, 0x01	; 1
    1864:	0e 94 38 11 	call	0x2270	; 0x2270 <vTaskSetTimeOutState>
    1868:	11 e0       	ldi	r17, 0x01	; 1
    186a:	0f 90       	pop	r0
    186c:	0f be       	out	0x3f, r0	; 63
    186e:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <vTaskSuspendAll>
    1872:	0f b6       	in	r0, 0x3f	; 63
    1874:	f8 94       	cli
    1876:	0f 92       	push	r0
    1878:	f7 01       	movw	r30, r14
    187a:	81 a1       	ldd	r24, Z+33	; 0x21
    187c:	8f 3f       	cpi	r24, 0xFF	; 255
    187e:	09 f4       	brne	.+2      	; 0x1882 <xQueueGenericReceive+0xe6>
    1880:	11 a2       	std	Z+33, r1	; 0x21
    1882:	f7 01       	movw	r30, r14
    1884:	82 a1       	ldd	r24, Z+34	; 0x22
    1886:	8f 3f       	cpi	r24, 0xFF	; 255
    1888:	09 f4       	brne	.+2      	; 0x188c <xQueueGenericReceive+0xf0>
    188a:	12 a2       	std	Z+34, r1	; 0x22
    188c:	0f 90       	pop	r0
    188e:	0f be       	out	0x3f, r0	; 63
    1890:	be 01       	movw	r22, r28
    1892:	6a 5f       	subi	r22, 0xFA	; 250
    1894:	7f 4f       	sbci	r23, 0xFF	; 255
    1896:	ce 01       	movw	r24, r28
    1898:	01 96       	adiw	r24, 0x01	; 1
    189a:	0e 94 49 11 	call	0x2292	; 0x2292 <xTaskCheckForTimeOut>
    189e:	81 11       	cpse	r24, r1
    18a0:	2d c0       	rjmp	.+90     	; 0x18fc <xQueueGenericReceive+0x160>
    18a2:	0f b6       	in	r0, 0x3f	; 63
    18a4:	f8 94       	cli
    18a6:	0f 92       	push	r0
    18a8:	f7 01       	movw	r30, r14
    18aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    18ac:	0f 90       	pop	r0
    18ae:	0f be       	out	0x3f, r0	; 63
    18b0:	81 11       	cpse	r24, r1
    18b2:	1e c0       	rjmp	.+60     	; 0x18f0 <xQueueGenericReceive+0x154>
    18b4:	80 81       	ld	r24, Z
    18b6:	91 81       	ldd	r25, Z+1	; 0x01
    18b8:	89 2b       	or	r24, r25
    18ba:	49 f4       	brne	.+18     	; 0x18ce <xQueueGenericReceive+0x132>
    18bc:	0f b6       	in	r0, 0x3f	; 63
    18be:	f8 94       	cli
    18c0:	0f 92       	push	r0
    18c2:	82 81       	ldd	r24, Z+2	; 0x02
    18c4:	93 81       	ldd	r25, Z+3	; 0x03
    18c6:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <vTaskPriorityInherit>
    18ca:	0f 90       	pop	r0
    18cc:	0f be       	out	0x3f, r0	; 63
    18ce:	4e 81       	ldd	r20, Y+6	; 0x06
    18d0:	5f 81       	ldd	r21, Y+7	; 0x07
    18d2:	68 85       	ldd	r22, Y+8	; 0x08
    18d4:	79 85       	ldd	r23, Y+9	; 0x09
    18d6:	c6 01       	movw	r24, r12
    18d8:	0e 94 cf 10 	call	0x219e	; 0x219e <vTaskPlaceOnEventList>
    18dc:	c7 01       	movw	r24, r14
    18de:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <prvUnlockQueue>
    18e2:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
    18e6:	81 11       	cpse	r24, r1
    18e8:	73 cf       	rjmp	.-282    	; 0x17d0 <xQueueGenericReceive+0x34>
    18ea:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    18ee:	70 cf       	rjmp	.-288    	; 0x17d0 <xQueueGenericReceive+0x34>
    18f0:	c7 01       	movw	r24, r14
    18f2:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <prvUnlockQueue>
    18f6:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
    18fa:	6a cf       	rjmp	.-300    	; 0x17d0 <xQueueGenericReceive+0x34>
    18fc:	c7 01       	movw	r24, r14
    18fe:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <prvUnlockQueue>
    1902:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
    1906:	80 e0       	ldi	r24, 0x00	; 0
    1908:	29 96       	adiw	r28, 0x09	; 9
    190a:	cd bf       	out	0x3d, r28	; 61
    190c:	de bf       	out	0x3e, r29	; 62
    190e:	df 91       	pop	r29
    1910:	cf 91       	pop	r28
    1912:	1f 91       	pop	r17
    1914:	0f 91       	pop	r16
    1916:	ff 90       	pop	r15
    1918:	ef 90       	pop	r14
    191a:	df 90       	pop	r13
    191c:	cf 90       	pop	r12
    191e:	bf 90       	pop	r11
    1920:	af 90       	pop	r10
    1922:	08 95       	ret

00001924 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1924:	0f b6       	in	r0, 0x3f	; 63
    1926:	f8 94       	cli
    1928:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    192a:	fc 01       	movw	r30, r24
    192c:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    192e:	0f 90       	pop	r0
    1930:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1932:	08 95       	ret

00001934 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1934:	c6 e0       	ldi	r28, 0x06	; 6
    1936:	d1 e3       	ldi	r29, 0x31	; 49
    1938:	88 81       	ld	r24, Y
    193a:	82 30       	cpi	r24, 0x02	; 2
    193c:	e8 f3       	brcs	.-6      	; 0x1938 <prvIdleTask+0x4>
    193e:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    1942:	fa cf       	rjmp	.-12     	; 0x1938 <prvIdleTask+0x4>

00001944 <prvAddCurrentTaskToDelayedList>:
    1944:	cf 92       	push	r12
    1946:	df 92       	push	r13
    1948:	ef 92       	push	r14
    194a:	ff 92       	push	r15
    194c:	6b 01       	movw	r12, r22
    194e:	7c 01       	movw	r14, r24
    1950:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1954:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1958:	62 83       	std	Z+2, r22	; 0x02
    195a:	73 83       	std	Z+3, r23	; 0x03
    195c:	84 83       	std	Z+4, r24	; 0x04
    195e:	95 83       	std	Z+5, r25	; 0x05
    1960:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1964:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1968:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    196c:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1970:	c8 16       	cp	r12, r24
    1972:	d9 06       	cpc	r13, r25
    1974:	ea 06       	cpc	r14, r26
    1976:	fb 06       	cpc	r15, r27
    1978:	68 f4       	brcc	.+26     	; 0x1994 <prvAddCurrentTaskToDelayedList+0x50>
    197a:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    197e:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1982:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxOverflowDelayedTaskList>
    1986:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    198a:	6e 5f       	subi	r22, 0xFE	; 254
    198c:	7f 4f       	sbci	r23, 0xFF	; 255
    198e:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListInsert>
    1992:	21 c0       	rjmp	.+66     	; 0x19d6 <prvAddCurrentTaskToDelayedList+0x92>
    1994:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    1998:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    199c:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    19a0:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    19a4:	6e 5f       	subi	r22, 0xFE	; 254
    19a6:	7f 4f       	sbci	r23, 0xFF	; 255
    19a8:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListInsert>
    19ac:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    19b0:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    19b4:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    19b8:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    19bc:	c8 16       	cp	r12, r24
    19be:	d9 06       	cpc	r13, r25
    19c0:	ea 06       	cpc	r14, r26
    19c2:	fb 06       	cpc	r15, r27
    19c4:	40 f4       	brcc	.+16     	; 0x19d6 <prvAddCurrentTaskToDelayedList+0x92>
    19c6:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    19ca:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    19ce:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    19d2:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    19d6:	ff 90       	pop	r15
    19d8:	ef 90       	pop	r14
    19da:	df 90       	pop	r13
    19dc:	cf 90       	pop	r12
    19de:	08 95       	ret

000019e0 <xTaskGenericCreate>:
    19e0:	4f 92       	push	r4
    19e2:	5f 92       	push	r5
    19e4:	6f 92       	push	r6
    19e6:	7f 92       	push	r7
    19e8:	8f 92       	push	r8
    19ea:	9f 92       	push	r9
    19ec:	af 92       	push	r10
    19ee:	bf 92       	push	r11
    19f0:	cf 92       	push	r12
    19f2:	df 92       	push	r13
    19f4:	ef 92       	push	r14
    19f6:	ff 92       	push	r15
    19f8:	0f 93       	push	r16
    19fa:	1f 93       	push	r17
    19fc:	cf 93       	push	r28
    19fe:	df 93       	push	r29
    1a00:	5c 01       	movw	r10, r24
    1a02:	4b 01       	movw	r8, r22
    1a04:	3a 01       	movw	r6, r20
    1a06:	29 01       	movw	r4, r18
    1a08:	88 e2       	ldi	r24, 0x28	; 40
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	0e 94 1d 07 	call	0xe3a	; 0xe3a <pvPortMalloc>
    1a10:	ec 01       	movw	r28, r24
    1a12:	89 2b       	or	r24, r25
    1a14:	09 f4       	brne	.+2      	; 0x1a18 <xTaskGenericCreate+0x38>
    1a16:	d4 c0       	rjmp	.+424    	; 0x1bc0 <xTaskGenericCreate+0x1e0>
    1a18:	c1 14       	cp	r12, r1
    1a1a:	d1 04       	cpc	r13, r1
    1a1c:	09 f0       	breq	.+2      	; 0x1a20 <xTaskGenericCreate+0x40>
    1a1e:	cc c0       	rjmp	.+408    	; 0x1bb8 <xTaskGenericCreate+0x1d8>
    1a20:	c3 01       	movw	r24, r6
    1a22:	0e 94 1d 07 	call	0xe3a	; 0xe3a <pvPortMalloc>
    1a26:	8b 8f       	std	Y+27, r24	; 0x1b
    1a28:	9c 8f       	std	Y+28, r25	; 0x1c
    1a2a:	00 97       	sbiw	r24, 0x00	; 0
    1a2c:	21 f4       	brne	.+8      	; 0x1a36 <xTaskGenericCreate+0x56>
    1a2e:	ce 01       	movw	r24, r28
    1a30:	0e 94 b7 07 	call	0xf6e	; 0xf6e <vPortFree>
    1a34:	c5 c0       	rjmp	.+394    	; 0x1bc0 <xTaskGenericCreate+0x1e0>
    1a36:	a3 01       	movw	r20, r6
    1a38:	61 e1       	ldi	r22, 0x11	; 17
    1a3a:	70 e0       	ldi	r23, 0x00	; 0
    1a3c:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <memset>
    1a40:	93 01       	movw	r18, r6
    1a42:	21 50       	subi	r18, 0x01	; 1
    1a44:	31 09       	sbc	r19, r1
    1a46:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a48:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1a4a:	3c 01       	movw	r6, r24
    1a4c:	62 0e       	add	r6, r18
    1a4e:	73 1e       	adc	r7, r19
    1a50:	4a e0       	ldi	r20, 0x0A	; 10
    1a52:	50 e0       	ldi	r21, 0x00	; 0
    1a54:	b4 01       	movw	r22, r8
    1a56:	ce 01       	movw	r24, r28
    1a58:	4d 96       	adiw	r24, 0x1d	; 29
    1a5a:	0e 94 df 1f 	call	0x3fbe	; 0x3fbe <strncpy>
    1a5e:	1e a2       	std	Y+38, r1	; 0x26
    1a60:	10 2f       	mov	r17, r16
    1a62:	04 30       	cpi	r16, 0x04	; 4
    1a64:	08 f0       	brcs	.+2      	; 0x1a68 <xTaskGenericCreate+0x88>
    1a66:	13 e0       	ldi	r17, 0x03	; 3
    1a68:	1a 8f       	std	Y+26, r17	; 0x1a
    1a6a:	1f a3       	std	Y+39, r17	; 0x27
    1a6c:	6e 01       	movw	r12, r28
    1a6e:	22 e0       	ldi	r18, 0x02	; 2
    1a70:	c2 0e       	add	r12, r18
    1a72:	d1 1c       	adc	r13, r1
    1a74:	c6 01       	movw	r24, r12
    1a76:	0e 94 00 08 	call	0x1000	; 0x1000 <vListInitialiseItem>
    1a7a:	ce 01       	movw	r24, r28
    1a7c:	0e 96       	adiw	r24, 0x0e	; 14
    1a7e:	0e 94 00 08 	call	0x1000	; 0x1000 <vListInitialiseItem>
    1a82:	ca 87       	std	Y+10, r28	; 0x0a
    1a84:	db 87       	std	Y+11, r29	; 0x0b
    1a86:	84 e0       	ldi	r24, 0x04	; 4
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	a0 e0       	ldi	r26, 0x00	; 0
    1a8c:	b0 e0       	ldi	r27, 0x00	; 0
    1a8e:	81 1b       	sub	r24, r17
    1a90:	91 09       	sbc	r25, r1
    1a92:	a1 09       	sbc	r26, r1
    1a94:	b1 09       	sbc	r27, r1
    1a96:	8e 87       	std	Y+14, r24	; 0x0e
    1a98:	9f 87       	std	Y+15, r25	; 0x0f
    1a9a:	a8 8b       	std	Y+16, r26	; 0x10
    1a9c:	b9 8b       	std	Y+17, r27	; 0x11
    1a9e:	ce 8b       	std	Y+22, r28	; 0x16
    1aa0:	df 8b       	std	Y+23, r29	; 0x17
    1aa2:	a2 01       	movw	r20, r4
    1aa4:	b5 01       	movw	r22, r10
    1aa6:	c3 01       	movw	r24, r6
    1aa8:	0e 94 9c 08 	call	0x1138	; 0x1138 <pxPortInitialiseStack>
    1aac:	88 83       	st	Y, r24
    1aae:	99 83       	std	Y+1, r25	; 0x01
    1ab0:	e1 14       	cp	r14, r1
    1ab2:	f1 04       	cpc	r15, r1
    1ab4:	19 f0       	breq	.+6      	; 0x1abc <xTaskGenericCreate+0xdc>
    1ab6:	f7 01       	movw	r30, r14
    1ab8:	c0 83       	st	Z, r28
    1aba:	d1 83       	std	Z+1, r29	; 0x01
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	0f 92       	push	r0
    1ac2:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1ac6:	8f 5f       	subi	r24, 0xFF	; 255
    1ac8:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <uxCurrentNumberOfTasks>
    1acc:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1ad0:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1ad4:	89 2b       	or	r24, r25
    1ad6:	89 f5       	brne	.+98     	; 0x1b3a <xTaskGenericCreate+0x15a>
    1ad8:	c0 93 32 31 	sts	0x3132, r28	; 0x803132 <pxCurrentTCB>
    1adc:	d0 93 33 31 	sts	0x3133, r29	; 0x803133 <pxCurrentTCB+0x1>
    1ae0:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1ae4:	81 30       	cpi	r24, 0x01	; 1
    1ae6:	c1 f5       	brne	.+112    	; 0x1b58 <xTaskGenericCreate+0x178>
    1ae8:	86 e0       	ldi	r24, 0x06	; 6
    1aea:	91 e3       	ldi	r25, 0x31	; 49
    1aec:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    1af0:	81 e1       	ldi	r24, 0x11	; 17
    1af2:	91 e3       	ldi	r25, 0x31	; 49
    1af4:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    1af8:	8c e1       	ldi	r24, 0x1C	; 28
    1afa:	91 e3       	ldi	r25, 0x31	; 49
    1afc:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    1b00:	87 e2       	ldi	r24, 0x27	; 39
    1b02:	91 e3       	ldi	r25, 0x31	; 49
    1b04:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    1b08:	8b ef       	ldi	r24, 0xFB	; 251
    1b0a:	90 e3       	ldi	r25, 0x30	; 48
    1b0c:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    1b10:	80 ef       	ldi	r24, 0xF0	; 240
    1b12:	90 e3       	ldi	r25, 0x30	; 48
    1b14:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    1b18:	81 ee       	ldi	r24, 0xE1	; 225
    1b1a:	90 e3       	ldi	r25, 0x30	; 48
    1b1c:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInitialise>
    1b20:	8b ef       	ldi	r24, 0xFB	; 251
    1b22:	90 e3       	ldi	r25, 0x30	; 48
    1b24:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <pxDelayedTaskList>
    1b28:	90 93 ef 30 	sts	0x30EF, r25	; 0x8030ef <pxDelayedTaskList+0x1>
    1b2c:	80 ef       	ldi	r24, 0xF0	; 240
    1b2e:	90 e3       	ldi	r25, 0x30	; 48
    1b30:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxOverflowDelayedTaskList>
    1b34:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    1b38:	0f c0       	rjmp	.+30     	; 0x1b58 <xTaskGenericCreate+0x178>
    1b3a:	80 91 d7 30 	lds	r24, 0x30D7	; 0x8030d7 <xSchedulerRunning>
    1b3e:	81 11       	cpse	r24, r1
    1b40:	0b c0       	rjmp	.+22     	; 0x1b58 <xTaskGenericCreate+0x178>
    1b42:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1b46:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1b4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b4c:	08 17       	cp	r16, r24
    1b4e:	20 f0       	brcs	.+8      	; 0x1b58 <xTaskGenericCreate+0x178>
    1b50:	c0 93 32 31 	sts	0x3132, r28	; 0x803132 <pxCurrentTCB>
    1b54:	d0 93 33 31 	sts	0x3133, r29	; 0x803133 <pxCurrentTCB+0x1>
    1b58:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b5a:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <uxTopUsedPriority>
    1b5e:	98 17       	cp	r25, r24
    1b60:	10 f4       	brcc	.+4      	; 0x1b66 <xTaskGenericCreate+0x186>
    1b62:	80 93 d9 30 	sts	0x30D9, r24	; 0x8030d9 <uxTopUsedPriority>
    1b66:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <uxTaskNumber>
    1b6a:	9f 5f       	subi	r25, 0xFF	; 255
    1b6c:	90 93 d2 30 	sts	0x30D2, r25	; 0x8030d2 <uxTaskNumber>
    1b70:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    1b74:	98 17       	cp	r25, r24
    1b76:	10 f4       	brcc	.+4      	; 0x1b7c <xTaskGenericCreate+0x19c>
    1b78:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    1b7c:	fb e0       	ldi	r31, 0x0B	; 11
    1b7e:	8f 9f       	mul	r24, r31
    1b80:	c0 01       	movw	r24, r0
    1b82:	11 24       	eor	r1, r1
    1b84:	b6 01       	movw	r22, r12
    1b86:	8a 5f       	subi	r24, 0xFA	; 250
    1b88:	9e 4c       	sbci	r25, 0xCE	; 206
    1b8a:	0e 94 04 08 	call	0x1008	; 0x1008 <vListInsertEnd>
    1b8e:	0f 90       	pop	r0
    1b90:	0f be       	out	0x3f, r0	; 63
    1b92:	80 91 d7 30 	lds	r24, 0x30D7	; 0x8030d7 <xSchedulerRunning>
    1b96:	88 23       	and	r24, r24
    1b98:	59 f0       	breq	.+22     	; 0x1bb0 <xTaskGenericCreate+0x1d0>
    1b9a:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1b9e:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1ba2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ba4:	80 17       	cp	r24, r16
    1ba6:	30 f4       	brcc	.+12     	; 0x1bb4 <xTaskGenericCreate+0x1d4>
    1ba8:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
    1bac:	81 e0       	ldi	r24, 0x01	; 1
    1bae:	09 c0       	rjmp	.+18     	; 0x1bc2 <xTaskGenericCreate+0x1e2>
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	07 c0       	rjmp	.+14     	; 0x1bc2 <xTaskGenericCreate+0x1e2>
    1bb4:	81 e0       	ldi	r24, 0x01	; 1
    1bb6:	05 c0       	rjmp	.+10     	; 0x1bc2 <xTaskGenericCreate+0x1e2>
    1bb8:	cb 8e       	std	Y+27, r12	; 0x1b
    1bba:	dc 8e       	std	Y+28, r13	; 0x1c
    1bbc:	c6 01       	movw	r24, r12
    1bbe:	3b cf       	rjmp	.-394    	; 0x1a36 <xTaskGenericCreate+0x56>
    1bc0:	8f ef       	ldi	r24, 0xFF	; 255
    1bc2:	df 91       	pop	r29
    1bc4:	cf 91       	pop	r28
    1bc6:	1f 91       	pop	r17
    1bc8:	0f 91       	pop	r16
    1bca:	ff 90       	pop	r15
    1bcc:	ef 90       	pop	r14
    1bce:	df 90       	pop	r13
    1bd0:	cf 90       	pop	r12
    1bd2:	bf 90       	pop	r11
    1bd4:	af 90       	pop	r10
    1bd6:	9f 90       	pop	r9
    1bd8:	8f 90       	pop	r8
    1bda:	7f 90       	pop	r7
    1bdc:	6f 90       	pop	r6
    1bde:	5f 90       	pop	r5
    1be0:	4f 90       	pop	r4
    1be2:	08 95       	ret

00001be4 <uxTaskPriorityGet>:
    1be4:	0f b6       	in	r0, 0x3f	; 63
    1be6:	f8 94       	cli
    1be8:	0f 92       	push	r0
    1bea:	00 97       	sbiw	r24, 0x00	; 0
    1bec:	21 f4       	brne	.+8      	; 0x1bf6 <uxTaskPriorityGet+0x12>
    1bee:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1bf2:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1bf6:	0f 90       	pop	r0
    1bf8:	0f be       	out	0x3f, r0	; 63
    1bfa:	fc 01       	movw	r30, r24
    1bfc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bfe:	08 95       	ret

00001c00 <vTaskStartScheduler>:
    1c00:	af 92       	push	r10
    1c02:	bf 92       	push	r11
    1c04:	cf 92       	push	r12
    1c06:	df 92       	push	r13
    1c08:	ef 92       	push	r14
    1c0a:	ff 92       	push	r15
    1c0c:	0f 93       	push	r16
    1c0e:	a1 2c       	mov	r10, r1
    1c10:	b1 2c       	mov	r11, r1
    1c12:	c1 2c       	mov	r12, r1
    1c14:	d1 2c       	mov	r13, r1
    1c16:	0f 2e       	mov	r0, r31
    1c18:	ff ed       	ldi	r31, 0xDF	; 223
    1c1a:	ef 2e       	mov	r14, r31
    1c1c:	f0 e3       	ldi	r31, 0x30	; 48
    1c1e:	ff 2e       	mov	r15, r31
    1c20:	f0 2d       	mov	r31, r0
    1c22:	00 e0       	ldi	r16, 0x00	; 0
    1c24:	20 e0       	ldi	r18, 0x00	; 0
    1c26:	30 e0       	ldi	r19, 0x00	; 0
    1c28:	44 e6       	ldi	r20, 0x64	; 100
    1c2a:	50 e0       	ldi	r21, 0x00	; 0
    1c2c:	6e e3       	ldi	r22, 0x3E	; 62
    1c2e:	70 e2       	ldi	r23, 0x20	; 32
    1c30:	8a e9       	ldi	r24, 0x9A	; 154
    1c32:	9c e0       	ldi	r25, 0x0C	; 12
    1c34:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <xTaskGenericCreate>
    1c38:	81 30       	cpi	r24, 0x01	; 1
    1c3a:	69 f4       	brne	.+26     	; 0x1c56 <vTaskStartScheduler+0x56>
    1c3c:	f8 94       	cli
    1c3e:	80 93 d7 30 	sts	0x30D7, r24	; 0x8030d7 <xSchedulerRunning>
    1c42:	10 92 da 30 	sts	0x30DA, r1	; 0x8030da <xTickCount>
    1c46:	10 92 db 30 	sts	0x30DB, r1	; 0x8030db <xTickCount+0x1>
    1c4a:	10 92 dc 30 	sts	0x30DC, r1	; 0x8030dc <xTickCount+0x2>
    1c4e:	10 92 dd 30 	sts	0x30DD, r1	; 0x8030dd <xTickCount+0x3>
    1c52:	0e 94 12 09 	call	0x1224	; 0x1224 <xPortStartScheduler>
    1c56:	0f 91       	pop	r16
    1c58:	ff 90       	pop	r15
    1c5a:	ef 90       	pop	r14
    1c5c:	df 90       	pop	r13
    1c5e:	cf 90       	pop	r12
    1c60:	bf 90       	pop	r11
    1c62:	af 90       	pop	r10
    1c64:	08 95       	ret

00001c66 <vTaskSuspendAll>:
    1c66:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1c6a:	8f 5f       	subi	r24, 0xFF	; 255
    1c6c:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxSchedulerSuspended>
    1c70:	08 95       	ret

00001c72 <xTaskGetTickCount>:
    1c72:	0f b6       	in	r0, 0x3f	; 63
    1c74:	f8 94       	cli
    1c76:	0f 92       	push	r0
    1c78:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount>
    1c7c:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x1>
    1c80:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1c84:	90 91 dd 30 	lds	r25, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1c88:	0f 90       	pop	r0
    1c8a:	0f be       	out	0x3f, r0	; 63
    1c8c:	08 95       	ret

00001c8e <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1c8e:	00 97       	sbiw	r24, 0x00	; 0
    1c90:	21 f4       	brne	.+8      	; 0x1c9a <pcTaskGetTaskName+0xc>
    1c92:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1c96:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1c9a:	4d 96       	adiw	r24, 0x1d	; 29
    1c9c:	08 95       	ret

00001c9e <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1c9e:	80 91 df 30 	lds	r24, 0x30DF	; 0x8030df <xIdleTaskHandle>
    1ca2:	90 91 e0 30 	lds	r25, 0x30E0	; 0x8030e0 <xIdleTaskHandle+0x1>
    1ca6:	08 95       	ret

00001ca8 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1ca8:	ff 92       	push	r15
    1caa:	0f 93       	push	r16
    1cac:	1f 93       	push	r17
    1cae:	cf 93       	push	r28
    1cb0:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1cb2:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1cb6:	81 11       	cpse	r24, r1
    1cb8:	ed c0       	rjmp	.+474    	; 0x1e94 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    1cba:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1cbe:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1cc2:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1cc6:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1cca:	01 96       	adiw	r24, 0x01	; 1
    1ccc:	a1 1d       	adc	r26, r1
    1cce:	b1 1d       	adc	r27, r1
    1cd0:	80 93 da 30 	sts	0x30DA, r24	; 0x8030da <xTickCount>
    1cd4:	90 93 db 30 	sts	0x30DB, r25	; 0x8030db <xTickCount+0x1>
    1cd8:	a0 93 dc 30 	sts	0x30DC, r26	; 0x8030dc <xTickCount+0x2>
    1cdc:	b0 93 dd 30 	sts	0x30DD, r27	; 0x8030dd <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    1ce0:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1ce4:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1ce8:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1cec:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1cf0:	89 2b       	or	r24, r25
    1cf2:	8a 2b       	or	r24, r26
    1cf4:	8b 2b       	or	r24, r27
    1cf6:	f1 f5       	brne	.+124    	; 0x1d74 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1cf8:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1cfc:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1d00:	20 91 ec 30 	lds	r18, 0x30EC	; 0x8030ec <pxOverflowDelayedTaskList>
    1d04:	30 91 ed 30 	lds	r19, 0x30ED	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    1d08:	20 93 ee 30 	sts	0x30EE, r18	; 0x8030ee <pxDelayedTaskList>
    1d0c:	30 93 ef 30 	sts	0x30EF, r19	; 0x8030ef <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    1d10:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxOverflowDelayedTaskList>
    1d14:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    1d18:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    1d1c:	8f 5f       	subi	r24, 0xFF	; 255
    1d1e:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1d22:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1d26:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1d2a:	80 81       	ld	r24, Z
    1d2c:	81 11       	cpse	r24, r1
    1d2e:	0c c0       	rjmp	.+24     	; 0x1d48 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1d30:	8f ef       	ldi	r24, 0xFF	; 255
    1d32:	9f ef       	ldi	r25, 0xFF	; 255
    1d34:	dc 01       	movw	r26, r24
    1d36:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1d3a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d3e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d42:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d46:	16 c0       	rjmp	.+44     	; 0x1d74 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1d48:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1d4c:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1d50:	07 80       	ldd	r0, Z+7	; 0x07
    1d52:	f0 85       	ldd	r31, Z+8	; 0x08
    1d54:	e0 2d       	mov	r30, r0
    1d56:	00 84       	ldd	r0, Z+8	; 0x08
    1d58:	f1 85       	ldd	r31, Z+9	; 0x09
    1d5a:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1d5c:	82 81       	ldd	r24, Z+2	; 0x02
    1d5e:	93 81       	ldd	r25, Z+3	; 0x03
    1d60:	a4 81       	ldd	r26, Z+4	; 0x04
    1d62:	b5 81       	ldd	r27, Z+5	; 0x05
    1d64:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1d68:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d6c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d70:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1d74:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    1d78:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    1d7c:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1d80:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1d84:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1d88:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d8c:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d90:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d94:	48 17       	cp	r20, r24
    1d96:	59 07       	cpc	r21, r25
    1d98:	6a 07       	cpc	r22, r26
    1d9a:	7b 07       	cpc	r23, r27
    1d9c:	08 f4       	brcc	.+2      	; 0x1da0 <vTaskIncrementTick+0xf8>
    1d9e:	7f c0       	rjmp	.+254    	; 0x1e9e <vTaskIncrementTick+0x1f6>
    1da0:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1da4:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1da8:	80 81       	ld	r24, Z
    1daa:	88 23       	and	r24, r24
    1dac:	f9 f0       	breq	.+62     	; 0x1dec <vTaskIncrementTick+0x144>
    1dae:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1db2:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1db6:	07 80       	ldd	r0, Z+7	; 0x07
    1db8:	f0 85       	ldd	r31, Z+8	; 0x08
    1dba:	e0 2d       	mov	r30, r0
    1dbc:	c0 85       	ldd	r28, Z+8	; 0x08
    1dbe:	d1 85       	ldd	r29, Z+9	; 0x09
    1dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc2:	9b 81       	ldd	r25, Y+3	; 0x03
    1dc4:	ac 81       	ldd	r26, Y+4	; 0x04
    1dc6:	bd 81       	ldd	r27, Y+5	; 0x05
    1dc8:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    1dcc:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    1dd0:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1dd4:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1dd8:	48 17       	cp	r20, r24
    1dda:	59 07       	cpc	r21, r25
    1ddc:	6a 07       	cpc	r22, r26
    1dde:	7b 07       	cpc	r23, r27
    1de0:	58 f1       	brcs	.+86     	; 0x1e38 <vTaskIncrementTick+0x190>
    1de2:	0f 2e       	mov	r0, r31
    1de4:	fb e0       	ldi	r31, 0x0B	; 11
    1de6:	ff 2e       	mov	r15, r31
    1de8:	f0 2d       	mov	r31, r0
    1dea:	2f c0       	rjmp	.+94     	; 0x1e4a <vTaskIncrementTick+0x1a2>
    1dec:	8f ef       	ldi	r24, 0xFF	; 255
    1dee:	9f ef       	ldi	r25, 0xFF	; 255
    1df0:	dc 01       	movw	r26, r24
    1df2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1df6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dfa:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dfe:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e02:	4d c0       	rjmp	.+154    	; 0x1e9e <vTaskIncrementTick+0x1f6>
    1e04:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1e08:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1e0c:	07 80       	ldd	r0, Z+7	; 0x07
    1e0e:	f0 85       	ldd	r31, Z+8	; 0x08
    1e10:	e0 2d       	mov	r30, r0
    1e12:	c0 85       	ldd	r28, Z+8	; 0x08
    1e14:	d1 85       	ldd	r29, Z+9	; 0x09
    1e16:	8a 81       	ldd	r24, Y+2	; 0x02
    1e18:	9b 81       	ldd	r25, Y+3	; 0x03
    1e1a:	ac 81       	ldd	r26, Y+4	; 0x04
    1e1c:	bd 81       	ldd	r27, Y+5	; 0x05
    1e1e:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    1e22:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    1e26:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1e2a:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1e2e:	48 17       	cp	r20, r24
    1e30:	59 07       	cpc	r21, r25
    1e32:	6a 07       	cpc	r22, r26
    1e34:	7b 07       	cpc	r23, r27
    1e36:	48 f4       	brcc	.+18     	; 0x1e4a <vTaskIncrementTick+0x1a2>
    1e38:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1e3c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e40:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e44:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e48:	2a c0       	rjmp	.+84     	; 0x1e9e <vTaskIncrementTick+0x1f6>
    1e4a:	8e 01       	movw	r16, r28
    1e4c:	0e 5f       	subi	r16, 0xFE	; 254
    1e4e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e50:	c8 01       	movw	r24, r16
    1e52:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>
    1e56:	88 8d       	ldd	r24, Y+24	; 0x18
    1e58:	99 8d       	ldd	r25, Y+25	; 0x19
    1e5a:	89 2b       	or	r24, r25
    1e5c:	21 f0       	breq	.+8      	; 0x1e66 <vTaskIncrementTick+0x1be>
    1e5e:	ce 01       	movw	r24, r28
    1e60:	0e 96       	adiw	r24, 0x0e	; 14
    1e62:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>
    1e66:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e68:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    1e6c:	98 17       	cp	r25, r24
    1e6e:	10 f4       	brcc	.+4      	; 0x1e74 <vTaskIncrementTick+0x1cc>
    1e70:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    1e74:	f8 9e       	mul	r15, r24
    1e76:	c0 01       	movw	r24, r0
    1e78:	11 24       	eor	r1, r1
    1e7a:	b8 01       	movw	r22, r16
    1e7c:	8a 5f       	subi	r24, 0xFA	; 250
    1e7e:	9e 4c       	sbci	r25, 0xCE	; 206
    1e80:	0e 94 04 08 	call	0x1008	; 0x1008 <vListInsertEnd>
    1e84:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1e88:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1e8c:	80 81       	ld	r24, Z
    1e8e:	81 11       	cpse	r24, r1
    1e90:	b9 cf       	rjmp	.-142    	; 0x1e04 <vTaskIncrementTick+0x15c>
    1e92:	ac cf       	rjmp	.-168    	; 0x1dec <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    1e94:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1e98:	8f 5f       	subi	r24, 0xFF	; 255
    1e9a:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1e9e:	df 91       	pop	r29
    1ea0:	cf 91       	pop	r28
    1ea2:	1f 91       	pop	r17
    1ea4:	0f 91       	pop	r16
    1ea6:	ff 90       	pop	r15
    1ea8:	08 95       	ret

00001eaa <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1eaa:	cf 92       	push	r12
    1eac:	df 92       	push	r13
    1eae:	ef 92       	push	r14
    1eb0:	ff 92       	push	r15
    1eb2:	0f 93       	push	r16
    1eb4:	1f 93       	push	r17
    1eb6:	cf 93       	push	r28
    1eb8:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1eba:	0f b6       	in	r0, 0x3f	; 63
    1ebc:	f8 94       	cli
    1ebe:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1ec0:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1ec4:	81 50       	subi	r24, 0x01	; 1
    1ec6:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1eca:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1ece:	81 11       	cpse	r24, r1
    1ed0:	60 c0       	rjmp	.+192    	; 0x1f92 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1ed2:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1ed6:	81 11       	cpse	r24, r1
    1ed8:	2c c0       	rjmp	.+88     	; 0x1f32 <xTaskResumeAll+0x88>
    1eda:	5e c0       	rjmp	.+188    	; 0x1f98 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1edc:	d7 01       	movw	r26, r14
    1ede:	17 96       	adiw	r26, 0x07	; 7
    1ee0:	ed 91       	ld	r30, X+
    1ee2:	fc 91       	ld	r31, X
    1ee4:	18 97       	sbiw	r26, 0x08	; 8
    1ee6:	c0 85       	ldd	r28, Z+8	; 0x08
    1ee8:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    1eea:	ce 01       	movw	r24, r28
    1eec:	0e 96       	adiw	r24, 0x0e	; 14
    1eee:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1ef2:	8e 01       	movw	r16, r28
    1ef4:	0e 5f       	subi	r16, 0xFE	; 254
    1ef6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ef8:	c8 01       	movw	r24, r16
    1efa:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1efe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f00:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    1f04:	98 17       	cp	r25, r24
    1f06:	10 f4       	brcc	.+4      	; 0x1f0c <xTaskResumeAll+0x62>
    1f08:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    1f0c:	d8 9e       	mul	r13, r24
    1f0e:	c0 01       	movw	r24, r0
    1f10:	11 24       	eor	r1, r1
    1f12:	b8 01       	movw	r22, r16
    1f14:	8a 5f       	subi	r24, 0xFA	; 250
    1f16:	9e 4c       	sbci	r25, 0xCE	; 206
    1f18:	0e 94 04 08 	call	0x1008	; 0x1008 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1f1c:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1f20:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1f24:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f26:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f28:	98 17       	cp	r25, r24
    1f2a:	70 f0       	brcs	.+28     	; 0x1f48 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    1f2c:	cc 24       	eor	r12, r12
    1f2e:	c3 94       	inc	r12
    1f30:	0b c0       	rjmp	.+22     	; 0x1f48 <xTaskResumeAll+0x9e>
    1f32:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1f34:	0f 2e       	mov	r0, r31
    1f36:	f1 ee       	ldi	r31, 0xE1	; 225
    1f38:	ef 2e       	mov	r14, r31
    1f3a:	f0 e3       	ldi	r31, 0x30	; 48
    1f3c:	ff 2e       	mov	r15, r31
    1f3e:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1f40:	0f 2e       	mov	r0, r31
    1f42:	fb e0       	ldi	r31, 0x0B	; 11
    1f44:	df 2e       	mov	r13, r31
    1f46:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1f48:	f7 01       	movw	r30, r14
    1f4a:	80 81       	ld	r24, Z
    1f4c:	81 11       	cpse	r24, r1
    1f4e:	c6 cf       	rjmp	.-116    	; 0x1edc <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1f50:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1f54:	88 23       	and	r24, r24
    1f56:	81 f0       	breq	.+32     	; 0x1f78 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1f58:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1f5c:	88 23       	and	r24, r24
    1f5e:	99 f0       	breq	.+38     	; 0x1f86 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    1f60:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <vTaskIncrementTick>
						--uxMissedTicks;
    1f64:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1f68:	81 50       	subi	r24, 0x01	; 1
    1f6a:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1f6e:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1f72:	81 11       	cpse	r24, r1
    1f74:	f5 cf       	rjmp	.-22     	; 0x1f60 <xTaskResumeAll+0xb6>
    1f76:	07 c0       	rjmp	.+14     	; 0x1f86 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1f78:	f1 e0       	ldi	r31, 0x01	; 1
    1f7a:	cf 16       	cp	r12, r31
    1f7c:	21 f0       	breq	.+8      	; 0x1f86 <xTaskResumeAll+0xdc>
    1f7e:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <xMissedYield>
    1f82:	81 30       	cpi	r24, 0x01	; 1
    1f84:	41 f4       	brne	.+16     	; 0x1f96 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1f86:	10 92 d4 30 	sts	0x30D4, r1	; 0x8030d4 <xMissedYield>
					portYIELD_WITHIN_API();
    1f8a:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1f8e:	81 e0       	ldi	r24, 0x01	; 1
    1f90:	03 c0       	rjmp	.+6      	; 0x1f98 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1f92:	80 e0       	ldi	r24, 0x00	; 0
    1f94:	01 c0       	rjmp	.+2      	; 0x1f98 <xTaskResumeAll+0xee>
    1f96:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1f98:	0f 90       	pop	r0
    1f9a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1f9c:	df 91       	pop	r29
    1f9e:	cf 91       	pop	r28
    1fa0:	1f 91       	pop	r17
    1fa2:	0f 91       	pop	r16
    1fa4:	ff 90       	pop	r15
    1fa6:	ef 90       	pop	r14
    1fa8:	df 90       	pop	r13
    1faa:	cf 90       	pop	r12
    1fac:	08 95       	ret

00001fae <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1fae:	cf 92       	push	r12
    1fb0:	df 92       	push	r13
    1fb2:	ef 92       	push	r14
    1fb4:	ff 92       	push	r15
    1fb6:	cf 93       	push	r28
    1fb8:	df 93       	push	r29
    1fba:	ec 01       	movw	r28, r24
    1fbc:	6a 01       	movw	r12, r20
    1fbe:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1fc0:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1fc4:	88 81       	ld	r24, Y
    1fc6:	99 81       	ldd	r25, Y+1	; 0x01
    1fc8:	aa 81       	ldd	r26, Y+2	; 0x02
    1fca:	bb 81       	ldd	r27, Y+3	; 0x03
    1fcc:	c8 0e       	add	r12, r24
    1fce:	d9 1e       	adc	r13, r25
    1fd0:	ea 1e       	adc	r14, r26
    1fd2:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    1fd4:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    1fd8:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    1fdc:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1fe0:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1fe4:	48 17       	cp	r20, r24
    1fe6:	59 07       	cpc	r21, r25
    1fe8:	6a 07       	cpc	r22, r26
    1fea:	7b 07       	cpc	r23, r27
    1fec:	b8 f4       	brcc	.+46     	; 0x201c <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1fee:	c8 16       	cp	r12, r24
    1ff0:	d9 06       	cpc	r13, r25
    1ff2:	ea 06       	cpc	r14, r26
    1ff4:	fb 06       	cpc	r15, r27
    1ff6:	e0 f5       	brcc	.+120    	; 0x2070 <vTaskDelayUntil+0xc2>
    1ff8:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1ffc:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2000:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2004:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2008:	c8 82       	st	Y, r12
    200a:	d9 82       	std	Y+1, r13	; 0x01
    200c:	ea 82       	std	Y+2, r14	; 0x02
    200e:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2010:	8c 15       	cp	r24, r12
    2012:	9d 05       	cpc	r25, r13
    2014:	ae 05       	cpc	r26, r14
    2016:	bf 05       	cpc	r27, r15
    2018:	f8 f4       	brcc	.+62     	; 0x2058 <vTaskDelayUntil+0xaa>
    201a:	13 c0       	rjmp	.+38     	; 0x2042 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    201c:	c8 16       	cp	r12, r24
    201e:	d9 06       	cpc	r13, r25
    2020:	ea 06       	cpc	r14, r26
    2022:	fb 06       	cpc	r15, r27
    2024:	00 f1       	brcs	.+64     	; 0x2066 <vTaskDelayUntil+0xb8>
    2026:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    202a:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    202e:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2032:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2036:	8c 15       	cp	r24, r12
    2038:	9d 05       	cpc	r25, r13
    203a:	ae 05       	cpc	r26, r14
    203c:	bf 05       	cpc	r27, r15
    203e:	98 f0       	brcs	.+38     	; 0x2066 <vTaskDelayUntil+0xb8>
    2040:	17 c0       	rjmp	.+46     	; 0x2070 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2042:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    2046:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    204a:	02 96       	adiw	r24, 0x02	; 2
    204c:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2050:	c7 01       	movw	r24, r14
    2052:	b6 01       	movw	r22, r12
    2054:	0e 94 a2 0c 	call	0x1944	; 0x1944 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2058:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    205c:	81 11       	cpse	r24, r1
    205e:	0d c0       	rjmp	.+26     	; 0x207a <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2060:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
		}
	}
    2064:	0a c0       	rjmp	.+20     	; 0x207a <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2066:	c8 82       	st	Y, r12
    2068:	d9 82       	std	Y+1, r13	; 0x01
    206a:	ea 82       	std	Y+2, r14	; 0x02
    206c:	fb 82       	std	Y+3, r15	; 0x03
    206e:	e9 cf       	rjmp	.-46     	; 0x2042 <vTaskDelayUntil+0x94>
    2070:	c8 82       	st	Y, r12
    2072:	d9 82       	std	Y+1, r13	; 0x01
    2074:	ea 82       	std	Y+2, r14	; 0x02
    2076:	fb 82       	std	Y+3, r15	; 0x03
    2078:	ef cf       	rjmp	.-34     	; 0x2058 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    207a:	df 91       	pop	r29
    207c:	cf 91       	pop	r28
    207e:	ff 90       	pop	r15
    2080:	ef 90       	pop	r14
    2082:	df 90       	pop	r13
    2084:	cf 90       	pop	r12
    2086:	08 95       	ret

00002088 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2088:	cf 92       	push	r12
    208a:	df 92       	push	r13
    208c:	ef 92       	push	r14
    208e:	ff 92       	push	r15
    2090:	6b 01       	movw	r12, r22
    2092:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2094:	67 2b       	or	r22, r23
    2096:	68 2b       	or	r22, r24
    2098:	69 2b       	or	r22, r25
    209a:	e9 f0       	breq	.+58     	; 0x20d6 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    209c:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    20a0:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    20a4:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    20a8:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    20ac:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    20b0:	c8 0e       	add	r12, r24
    20b2:	d9 1e       	adc	r13, r25
    20b4:	ea 1e       	adc	r14, r26
    20b6:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    20b8:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    20bc:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    20c0:	02 96       	adiw	r24, 0x02	; 2
    20c2:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    20c6:	c7 01       	movw	r24, r14
    20c8:	b6 01       	movw	r22, r12
    20ca:	0e 94 a2 0c 	call	0x1944	; 0x1944 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    20ce:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    20d2:	81 11       	cpse	r24, r1
    20d4:	02 c0       	rjmp	.+4      	; 0x20da <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    20d6:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vPortYield>
		}
	}
    20da:	ff 90       	pop	r15
    20dc:	ef 90       	pop	r14
    20de:	df 90       	pop	r13
    20e0:	cf 90       	pop	r12
    20e2:	08 95       	ret

000020e4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    20e4:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    20e8:	81 11       	cpse	r24, r1
    20ea:	0c c0       	rjmp	.+24     	; 0x2104 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20ec:	e0 91 d8 30 	lds	r30, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    20f0:	4b e0       	ldi	r20, 0x0B	; 11
    20f2:	e4 9f       	mul	r30, r20
    20f4:	f0 01       	movw	r30, r0
    20f6:	11 24       	eor	r1, r1
    20f8:	ea 5f       	subi	r30, 0xFA	; 250
    20fa:	fe 4c       	sbci	r31, 0xCE	; 206
    20fc:	80 81       	ld	r24, Z
    20fe:	88 23       	and	r24, r24
    2100:	29 f0       	breq	.+10     	; 0x210c <vTaskSwitchContext+0x28>
    2102:	14 c0       	rjmp	.+40     	; 0x212c <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2104:	81 e0       	ldi	r24, 0x01	; 1
    2106:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <xMissedYield>
    210a:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    210c:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    210e:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2112:	81 50       	subi	r24, 0x01	; 1
    2114:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2118:	e0 91 d8 30 	lds	r30, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    211c:	9e 9f       	mul	r25, r30
    211e:	f0 01       	movw	r30, r0
    2120:	11 24       	eor	r1, r1
    2122:	ea 5f       	subi	r30, 0xFA	; 250
    2124:	fe 4c       	sbci	r31, 0xCE	; 206
    2126:	80 81       	ld	r24, Z
    2128:	88 23       	and	r24, r24
    212a:	89 f3       	breq	.-30     	; 0x210e <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    212c:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2130:	28 2f       	mov	r18, r24
    2132:	30 e0       	ldi	r19, 0x00	; 0
    2134:	4b e0       	ldi	r20, 0x0B	; 11
    2136:	84 9f       	mul	r24, r20
    2138:	c0 01       	movw	r24, r0
    213a:	11 24       	eor	r1, r1
    213c:	dc 01       	movw	r26, r24
    213e:	aa 5f       	subi	r26, 0xFA	; 250
    2140:	be 4c       	sbci	r27, 0xCE	; 206
    2142:	11 96       	adiw	r26, 0x01	; 1
    2144:	ed 91       	ld	r30, X+
    2146:	fc 91       	ld	r31, X
    2148:	12 97       	sbiw	r26, 0x02	; 2
    214a:	04 80       	ldd	r0, Z+4	; 0x04
    214c:	f5 81       	ldd	r31, Z+5	; 0x05
    214e:	e0 2d       	mov	r30, r0
    2150:	11 96       	adiw	r26, 0x01	; 1
    2152:	ed 93       	st	X+, r30
    2154:	fc 93       	st	X, r31
    2156:	12 97       	sbiw	r26, 0x02	; 2
    2158:	87 5f       	subi	r24, 0xF7	; 247
    215a:	9e 4c       	sbci	r25, 0xCE	; 206
    215c:	e8 17       	cp	r30, r24
    215e:	f9 07       	cpc	r31, r25
    2160:	61 f4       	brne	.+24     	; 0x217a <vTaskSwitchContext+0x96>
    2162:	84 81       	ldd	r24, Z+4	; 0x04
    2164:	95 81       	ldd	r25, Z+5	; 0x05
    2166:	4b e0       	ldi	r20, 0x0B	; 11
    2168:	42 9f       	mul	r20, r18
    216a:	f0 01       	movw	r30, r0
    216c:	43 9f       	mul	r20, r19
    216e:	f0 0d       	add	r31, r0
    2170:	11 24       	eor	r1, r1
    2172:	ea 5f       	subi	r30, 0xFA	; 250
    2174:	fe 4c       	sbci	r31, 0xCE	; 206
    2176:	81 83       	std	Z+1, r24	; 0x01
    2178:	92 83       	std	Z+2, r25	; 0x02
    217a:	8b e0       	ldi	r24, 0x0B	; 11
    217c:	82 9f       	mul	r24, r18
    217e:	f0 01       	movw	r30, r0
    2180:	83 9f       	mul	r24, r19
    2182:	f0 0d       	add	r31, r0
    2184:	11 24       	eor	r1, r1
    2186:	ea 5f       	subi	r30, 0xFA	; 250
    2188:	fe 4c       	sbci	r31, 0xCE	; 206
    218a:	01 80       	ldd	r0, Z+1	; 0x01
    218c:	f2 81       	ldd	r31, Z+2	; 0x02
    218e:	e0 2d       	mov	r30, r0
    2190:	80 85       	ldd	r24, Z+8	; 0x08
    2192:	91 85       	ldd	r25, Z+9	; 0x09
    2194:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <pxCurrentTCB>
    2198:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <pxCurrentTCB+0x1>
    219c:	08 95       	ret

0000219e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    219e:	cf 92       	push	r12
    21a0:	df 92       	push	r13
    21a2:	ef 92       	push	r14
    21a4:	ff 92       	push	r15
    21a6:	6a 01       	movw	r12, r20
    21a8:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    21aa:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    21ae:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    21b2:	62 5f       	subi	r22, 0xF2	; 242
    21b4:	7f 4f       	sbci	r23, 0xFF	; 255
    21b6:	0e 94 2b 08 	call	0x1056	; 0x1056 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    21ba:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    21be:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    21c2:	02 96       	adiw	r24, 0x02	; 2
    21c4:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    21c8:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    21cc:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    21d0:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    21d4:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    21d8:	bc 01       	movw	r22, r24
    21da:	cd 01       	movw	r24, r26
    21dc:	6c 0d       	add	r22, r12
    21de:	7d 1d       	adc	r23, r13
    21e0:	8e 1d       	adc	r24, r14
    21e2:	9f 1d       	adc	r25, r15
    21e4:	0e 94 a2 0c 	call	0x1944	; 0x1944 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    21e8:	ff 90       	pop	r15
    21ea:	ef 90       	pop	r14
    21ec:	df 90       	pop	r13
    21ee:	cf 90       	pop	r12
    21f0:	08 95       	ret

000021f2 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    21f2:	0f 93       	push	r16
    21f4:	1f 93       	push	r17
    21f6:	cf 93       	push	r28
    21f8:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    21fa:	dc 01       	movw	r26, r24
    21fc:	17 96       	adiw	r26, 0x07	; 7
    21fe:	ed 91       	ld	r30, X+
    2200:	fc 91       	ld	r31, X
    2202:	18 97       	sbiw	r26, 0x08	; 8
    2204:	c0 85       	ldd	r28, Z+8	; 0x08
    2206:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2208:	8e 01       	movw	r16, r28
    220a:	02 5f       	subi	r16, 0xF2	; 242
    220c:	1f 4f       	sbci	r17, 0xFF	; 255
    220e:	c8 01       	movw	r24, r16
    2210:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2214:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    2218:	81 11       	cpse	r24, r1
    221a:	16 c0       	rjmp	.+44     	; 0x2248 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    221c:	0c 50       	subi	r16, 0x0C	; 12
    221e:	11 09       	sbc	r17, r1
    2220:	c8 01       	movw	r24, r16
    2222:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2226:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2228:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    222c:	98 17       	cp	r25, r24
    222e:	10 f4       	brcc	.+4      	; 0x2234 <xTaskRemoveFromEventList+0x42>
    2230:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    2234:	bb e0       	ldi	r27, 0x0B	; 11
    2236:	8b 9f       	mul	r24, r27
    2238:	c0 01       	movw	r24, r0
    223a:	11 24       	eor	r1, r1
    223c:	b8 01       	movw	r22, r16
    223e:	8a 5f       	subi	r24, 0xFA	; 250
    2240:	9e 4c       	sbci	r25, 0xCE	; 206
    2242:	0e 94 04 08 	call	0x1008	; 0x1008 <vListInsertEnd>
    2246:	05 c0       	rjmp	.+10     	; 0x2252 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2248:	b8 01       	movw	r22, r16
    224a:	81 ee       	ldi	r24, 0xE1	; 225
    224c:	90 e3       	ldi	r25, 0x30	; 48
    224e:	0e 94 04 08 	call	0x1008	; 0x1008 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2252:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    2256:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    225a:	81 e0       	ldi	r24, 0x01	; 1
    225c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    225e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2260:	29 17       	cp	r18, r25
    2262:	08 f4       	brcc	.+2      	; 0x2266 <xTaskRemoveFromEventList+0x74>
    2264:	80 e0       	ldi	r24, 0x00	; 0
}
    2266:	df 91       	pop	r29
    2268:	cf 91       	pop	r28
    226a:	1f 91       	pop	r17
    226c:	0f 91       	pop	r16
    226e:	08 95       	ret

00002270 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2270:	20 91 d3 30 	lds	r18, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    2274:	fc 01       	movw	r30, r24
    2276:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2278:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    227c:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    2280:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2284:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2288:	41 83       	std	Z+1, r20	; 0x01
    228a:	52 83       	std	Z+2, r21	; 0x02
    228c:	63 83       	std	Z+3, r22	; 0x03
    228e:	74 83       	std	Z+4, r23	; 0x04
    2290:	08 95       	ret

00002292 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2292:	8f 92       	push	r8
    2294:	9f 92       	push	r9
    2296:	af 92       	push	r10
    2298:	bf 92       	push	r11
    229a:	cf 92       	push	r12
    229c:	df 92       	push	r13
    229e:	ef 92       	push	r14
    22a0:	ff 92       	push	r15
    22a2:	0f 93       	push	r16
    22a4:	1f 93       	push	r17
    22a6:	cf 93       	push	r28
    22a8:	df 93       	push	r29
    22aa:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    22ac:	0f b6       	in	r0, 0x3f	; 63
    22ae:	f8 94       	cli
    22b0:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    22b2:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    22b6:	90 81       	ld	r25, Z
    22b8:	98 17       	cp	r25, r24
    22ba:	89 f0       	breq	.+34     	; 0x22de <xTaskCheckForTimeOut+0x4c>
    22bc:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    22c0:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    22c4:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    22c8:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    22cc:	01 81       	ldd	r16, Z+1	; 0x01
    22ce:	12 81       	ldd	r17, Z+2	; 0x02
    22d0:	23 81       	ldd	r18, Z+3	; 0x03
    22d2:	34 81       	ldd	r19, Z+4	; 0x04
    22d4:	80 17       	cp	r24, r16
    22d6:	91 07       	cpc	r25, r17
    22d8:	a2 07       	cpc	r26, r18
    22da:	b3 07       	cpc	r27, r19
    22dc:	a8 f5       	brcc	.+106    	; 0x2348 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    22de:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    22e2:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    22e6:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    22ea:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    22ee:	c1 80       	ldd	r12, Z+1	; 0x01
    22f0:	d2 80       	ldd	r13, Z+2	; 0x02
    22f2:	e3 80       	ldd	r14, Z+3	; 0x03
    22f4:	f4 80       	ldd	r15, Z+4	; 0x04
    22f6:	eb 01       	movw	r28, r22
    22f8:	08 81       	ld	r16, Y
    22fa:	19 81       	ldd	r17, Y+1	; 0x01
    22fc:	2a 81       	ldd	r18, Y+2	; 0x02
    22fe:	3b 81       	ldd	r19, Y+3	; 0x03
    2300:	8c 19       	sub	r24, r12
    2302:	9d 09       	sbc	r25, r13
    2304:	ae 09       	sbc	r26, r14
    2306:	bf 09       	sbc	r27, r15
    2308:	80 17       	cp	r24, r16
    230a:	91 07       	cpc	r25, r17
    230c:	a2 07       	cpc	r26, r18
    230e:	b3 07       	cpc	r27, r19
    2310:	e8 f4       	brcc	.+58     	; 0x234c <xTaskCheckForTimeOut+0xba>
    2312:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2314:	80 90 da 30 	lds	r8, 0x30DA	; 0x8030da <xTickCount>
    2318:	90 90 db 30 	lds	r9, 0x30DB	; 0x8030db <xTickCount+0x1>
    231c:	a0 90 dc 30 	lds	r10, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2320:	b0 90 dd 30 	lds	r11, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2324:	b5 01       	movw	r22, r10
    2326:	a4 01       	movw	r20, r8
    2328:	4c 19       	sub	r20, r12
    232a:	5d 09       	sbc	r21, r13
    232c:	6e 09       	sbc	r22, r14
    232e:	7f 09       	sbc	r23, r15
    2330:	04 1b       	sub	r16, r20
    2332:	15 0b       	sbc	r17, r21
    2334:	26 0b       	sbc	r18, r22
    2336:	37 0b       	sbc	r19, r23
    2338:	08 83       	st	Y, r16
    233a:	19 83       	std	Y+1, r17	; 0x01
    233c:	2a 83       	std	Y+2, r18	; 0x02
    233e:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2340:	0e 94 38 11 	call	0x2270	; 0x2270 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2344:	80 e0       	ldi	r24, 0x00	; 0
    2346:	03 c0       	rjmp	.+6      	; 0x234e <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2348:	81 e0       	ldi	r24, 0x01	; 1
    234a:	01 c0       	rjmp	.+2      	; 0x234e <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    234c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    234e:	0f 90       	pop	r0
    2350:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2352:	df 91       	pop	r29
    2354:	cf 91       	pop	r28
    2356:	1f 91       	pop	r17
    2358:	0f 91       	pop	r16
    235a:	ff 90       	pop	r15
    235c:	ef 90       	pop	r14
    235e:	df 90       	pop	r13
    2360:	cf 90       	pop	r12
    2362:	bf 90       	pop	r11
    2364:	af 90       	pop	r10
    2366:	9f 90       	pop	r9
    2368:	8f 90       	pop	r8
    236a:	08 95       	ret

0000236c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    236c:	81 e0       	ldi	r24, 0x01	; 1
    236e:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <xMissedYield>
    2372:	08 95       	ret

00002374 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2374:	00 97       	sbiw	r24, 0x00	; 0
    2376:	21 f4       	brne	.+8      	; 0x2380 <uxTaskGetStackHighWaterMark+0xc>
    2378:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    237c:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2380:	dc 01       	movw	r26, r24
    2382:	5b 96       	adiw	r26, 0x1b	; 27
    2384:	ed 91       	ld	r30, X+
    2386:	fc 91       	ld	r31, X
    2388:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    238a:	80 81       	ld	r24, Z
    238c:	81 31       	cpi	r24, 0x11	; 17
    238e:	41 f4       	brne	.+16     	; 0x23a0 <uxTaskGetStackHighWaterMark+0x2c>
    2390:	31 96       	adiw	r30, 0x01	; 1
    2392:	80 e0       	ldi	r24, 0x00	; 0
    2394:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2396:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2398:	21 91       	ld	r18, Z+
    239a:	21 31       	cpi	r18, 0x11	; 17
    239c:	e1 f3       	breq	.-8      	; 0x2396 <uxTaskGetStackHighWaterMark+0x22>
    239e:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    23a0:	80 e0       	ldi	r24, 0x00	; 0
    23a2:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    23a4:	08 95       	ret

000023a6 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    23a6:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    23aa:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>

		return xReturn;
	}
    23ae:	08 95       	ret

000023b0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    23b0:	0f 93       	push	r16
    23b2:	1f 93       	push	r17
    23b4:	cf 93       	push	r28
    23b6:	df 93       	push	r29
    23b8:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    23ba:	22 8d       	ldd	r18, Z+26	; 0x1a
    23bc:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    23c0:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    23c4:	5a 96       	adiw	r26, 0x1a	; 26
    23c6:	8c 91       	ld	r24, X
    23c8:	28 17       	cp	r18, r24
    23ca:	08 f0       	brcs	.+2      	; 0x23ce <vTaskPriorityInherit+0x1e>
    23cc:	41 c0       	rjmp	.+130    	; 0x2450 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    23ce:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    23d2:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    23d6:	5a 96       	adiw	r26, 0x1a	; 26
    23d8:	3c 91       	ld	r19, X
    23da:	84 e0       	ldi	r24, 0x04	; 4
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	a0 e0       	ldi	r26, 0x00	; 0
    23e0:	b0 e0       	ldi	r27, 0x00	; 0
    23e2:	83 1b       	sub	r24, r19
    23e4:	91 09       	sbc	r25, r1
    23e6:	a1 09       	sbc	r26, r1
    23e8:	b1 09       	sbc	r27, r1
    23ea:	86 87       	std	Z+14, r24	; 0x0e
    23ec:	97 87       	std	Z+15, r25	; 0x0f
    23ee:	a0 8b       	std	Z+16, r26	; 0x10
    23f0:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    23f2:	8b e0       	ldi	r24, 0x0B	; 11
    23f4:	28 9f       	mul	r18, r24
    23f6:	90 01       	movw	r18, r0
    23f8:	11 24       	eor	r1, r1
    23fa:	2a 5f       	subi	r18, 0xFA	; 250
    23fc:	3e 4c       	sbci	r19, 0xCE	; 206
    23fe:	84 85       	ldd	r24, Z+12	; 0x0c
    2400:	95 85       	ldd	r25, Z+13	; 0x0d
    2402:	82 17       	cp	r24, r18
    2404:	93 07       	cpc	r25, r19
    2406:	e9 f4       	brne	.+58     	; 0x2442 <vTaskPriorityInherit+0x92>
    2408:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    240a:	ef 01       	movw	r28, r30
    240c:	22 96       	adiw	r28, 0x02	; 2
    240e:	ce 01       	movw	r24, r28
    2410:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2414:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    2418:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    241c:	82 8d       	ldd	r24, Z+26	; 0x1a
    241e:	f8 01       	movw	r30, r16
    2420:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2422:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2426:	98 17       	cp	r25, r24
    2428:	10 f4       	brcc	.+4      	; 0x242e <vTaskPriorityInherit+0x7e>
    242a:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    242e:	fb e0       	ldi	r31, 0x0B	; 11
    2430:	8f 9f       	mul	r24, r31
    2432:	c0 01       	movw	r24, r0
    2434:	11 24       	eor	r1, r1
    2436:	be 01       	movw	r22, r28
    2438:	8a 5f       	subi	r24, 0xFA	; 250
    243a:	9e 4c       	sbci	r25, 0xCE	; 206
    243c:	0e 94 04 08 	call	0x1008	; 0x1008 <vListInsertEnd>
    2440:	07 c0       	rjmp	.+14     	; 0x2450 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2442:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    2446:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    244a:	5a 96       	adiw	r26, 0x1a	; 26
    244c:	8c 91       	ld	r24, X
    244e:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2450:	df 91       	pop	r29
    2452:	cf 91       	pop	r28
    2454:	1f 91       	pop	r17
    2456:	0f 91       	pop	r16
    2458:	08 95       	ret

0000245a <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    245a:	0f 93       	push	r16
    245c:	1f 93       	push	r17
    245e:	cf 93       	push	r28
    2460:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2462:	00 97       	sbiw	r24, 0x00	; 0
    2464:	49 f1       	breq	.+82     	; 0x24b8 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2466:	fc 01       	movw	r30, r24
    2468:	32 8d       	ldd	r19, Z+26	; 0x1a
    246a:	27 a1       	ldd	r18, Z+39	; 0x27
    246c:	32 17       	cp	r19, r18
    246e:	21 f1       	breq	.+72     	; 0x24b8 <vTaskPriorityDisinherit+0x5e>
    2470:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2472:	8c 01       	movw	r16, r24
    2474:	0e 5f       	subi	r16, 0xFE	; 254
    2476:	1f 4f       	sbci	r17, 0xFF	; 255
    2478:	c8 01       	movw	r24, r16
    247a:	0e 94 76 08 	call	0x10ec	; 0x10ec <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    247e:	8f a1       	ldd	r24, Y+39	; 0x27
    2480:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2482:	44 e0       	ldi	r20, 0x04	; 4
    2484:	50 e0       	ldi	r21, 0x00	; 0
    2486:	60 e0       	ldi	r22, 0x00	; 0
    2488:	70 e0       	ldi	r23, 0x00	; 0
    248a:	48 1b       	sub	r20, r24
    248c:	51 09       	sbc	r21, r1
    248e:	61 09       	sbc	r22, r1
    2490:	71 09       	sbc	r23, r1
    2492:	4e 87       	std	Y+14, r20	; 0x0e
    2494:	5f 87       	std	Y+15, r21	; 0x0f
    2496:	68 8b       	std	Y+16, r22	; 0x10
    2498:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    249a:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    249e:	98 17       	cp	r25, r24
    24a0:	10 f4       	brcc	.+4      	; 0x24a6 <vTaskPriorityDisinherit+0x4c>
    24a2:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    24a6:	fb e0       	ldi	r31, 0x0B	; 11
    24a8:	8f 9f       	mul	r24, r31
    24aa:	c0 01       	movw	r24, r0
    24ac:	11 24       	eor	r1, r1
    24ae:	b8 01       	movw	r22, r16
    24b0:	8a 5f       	subi	r24, 0xFA	; 250
    24b2:	9e 4c       	sbci	r25, 0xCE	; 206
    24b4:	0e 94 04 08 	call	0x1008	; 0x1008 <vListInsertEnd>
			}
		}
	}
    24b8:	df 91       	pop	r29
    24ba:	cf 91       	pop	r28
    24bc:	1f 91       	pop	r17
    24be:	0f 91       	pop	r16
    24c0:	08 95       	ret

000024c2 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    24c2:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    24c4:	e8 81       	ld	r30, Y
    24c6:	f9 81       	ldd	r31, Y+1	; 0x01
    24c8:	01 90       	ld	r0, Z+
    24ca:	f0 81       	ld	r31, Z
    24cc:	e0 2d       	mov	r30, r0
    24ce:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    24d0:	1a 82       	std	Y+2, r1	; 0x02
    24d2:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    24d4:	6f ef       	ldi	r22, 0xFF	; 255
    24d6:	7f ef       	ldi	r23, 0xFF	; 255
    24d8:	cb 01       	movw	r24, r22
    24da:	0e 94 44 10 	call	0x2088	; 0x2088 <vTaskDelay>
    24de:	fa cf       	rjmp	.-12     	; 0x24d4 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000024e0 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    24e0:	fc 01       	movw	r30, r24
    24e2:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    24e4:	65 87       	std	Z+13, r22	; 0x0d
    24e6:	08 95       	ret

000024e8 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    24e8:	4f 92       	push	r4
    24ea:	5f 92       	push	r5
    24ec:	6f 92       	push	r6
    24ee:	7f 92       	push	r7
    24f0:	8f 92       	push	r8
    24f2:	9f 92       	push	r9
    24f4:	af 92       	push	r10
    24f6:	bf 92       	push	r11
    24f8:	cf 92       	push	r12
    24fa:	df 92       	push	r13
    24fc:	ef 92       	push	r14
    24fe:	ff 92       	push	r15
    2500:	0f 93       	push	r16
    2502:	1f 93       	push	r17
    2504:	cf 93       	push	r28
    2506:	df 93       	push	r29
    2508:	cd b7       	in	r28, 0x3d	; 61
    250a:	de b7       	in	r29, 0x3e	; 62
    250c:	2a 97       	sbiw	r28, 0x0a	; 10
    250e:	cd bf       	out	0x3d, r28	; 61
    2510:	de bf       	out	0x3e, r29	; 62
    2512:	4c 01       	movw	r8, r24
    2514:	29 01       	movw	r4, r18
    2516:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2518:	87 e4       	ldi	r24, 0x47	; 71
    251a:	90 e2       	ldi	r25, 0x20	; 32
    251c:	f4 01       	movw	r30, r8
    251e:	80 83       	st	Z, r24
    2520:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2522:	fb 01       	movw	r30, r22
    2524:	80 81       	ld	r24, Z
    2526:	88 23       	and	r24, r24
    2528:	69 f0       	breq	.+26     	; 0x2544 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    252a:	de 01       	movw	r26, r28
    252c:	11 96       	adiw	r26, 0x01	; 1
    252e:	31 96       	adiw	r30, 0x01	; 1
    2530:	90 e0       	ldi	r25, 0x00	; 0
    2532:	02 c0       	rjmp	.+4      	; 0x2538 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2534:	99 30       	cpi	r25, 0x09	; 9
    2536:	39 f0       	breq	.+14     	; 0x2546 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2538:	9f 5f       	subi	r25, 0xFF	; 255
    253a:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    253c:	81 91       	ld	r24, Z+
    253e:	81 11       	cpse	r24, r1
    2540:	f9 cf       	rjmp	.-14     	; 0x2534 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2542:	01 c0       	rjmp	.+2      	; 0x2546 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2544:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2546:	e1 e0       	ldi	r30, 0x01	; 1
    2548:	f0 e0       	ldi	r31, 0x00	; 0
    254a:	ec 0f       	add	r30, r28
    254c:	fd 1f       	adc	r31, r29
    254e:	e9 0f       	add	r30, r25
    2550:	f1 1d       	adc	r31, r1
    2552:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2554:	74 01       	movw	r14, r8
    2556:	f2 e0       	ldi	r31, 0x02	; 2
    2558:	ef 0e       	add	r14, r31
    255a:	f1 1c       	adc	r15, r1
    255c:	a1 2c       	mov	r10, r1
    255e:	b1 2c       	mov	r11, r1
    2560:	c1 2c       	mov	r12, r1
    2562:	d1 2c       	mov	r13, r1
    2564:	04 2f       	mov	r16, r20
    2566:	94 01       	movw	r18, r8
    2568:	a2 01       	movw	r20, r4
    256a:	be 01       	movw	r22, r28
    256c:	6f 5f       	subi	r22, 0xFF	; 255
    256e:	7f 4f       	sbci	r23, 0xFF	; 255
    2570:	88 ea       	ldi	r24, 0xA8	; 168
    2572:	92 e0       	ldi	r25, 0x02	; 2
    2574:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2578:	f4 01       	movw	r30, r8
    257a:	66 82       	std	Z+6, r6	; 0x06
    257c:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    257e:	40 86       	std	Z+8, r4	; 0x08
    2580:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2582:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <last_created_task_pointer>
    2586:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    258a:	24 83       	std	Z+4, r18	; 0x04
    258c:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    258e:	80 92 34 31 	sts	0x3134, r8	; 0x803134 <last_created_task_pointer>
    2592:	90 92 35 31 	sts	0x3135, r9	; 0x803135 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2596:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2598:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    259a:	40 90 76 31 	lds	r4, 0x3176	; 0x803176 <portStackTopForTask>
    259e:	50 90 77 31 	lds	r5, 0x3177	; 0x803177 <portStackTopForTask+0x1>
    25a2:	ff ef       	ldi	r31, 0xFF	; 255
    25a4:	4f 1a       	sub	r4, r31
    25a6:	5f 0a       	sbc	r5, r31
    25a8:	40 92 76 31 	sts	0x3176, r4	; 0x803176 <portStackTopForTask>
    25ac:	50 92 77 31 	sts	0x3177, r5	; 0x803177 <portStackTopForTask+0x1>
    25b0:	f4 01       	movw	r30, r8
    25b2:	42 86       	std	Z+10, r4	; 0x0a
    25b4:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    25b6:	16 86       	std	Z+14, r1	; 0x0e
    25b8:	17 86       	std	Z+15, r1	; 0x0f
    25ba:	10 8a       	std	Z+16, r1	; 0x10
    25bc:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    25be:	61 14       	cp	r6, r1
    25c0:	71 04       	cpc	r7, r1
    25c2:	09 f4       	brne	.+2      	; 0x25c6 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    25c4:	44 c0       	rjmp	.+136    	; 0x264e <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    25c6:	81 30       	cpi	r24, 0x01	; 1
    25c8:	79 f5       	brne	.+94     	; 0x2628 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    25ca:	6a e0       	ldi	r22, 0x0A	; 10
    25cc:	c3 01       	movw	r24, r6
    25ce:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    25d2:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    25d4:	6d e9       	ldi	r22, 0x9D	; 157
    25d6:	74 e0       	ldi	r23, 0x04	; 4
    25d8:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    25dc:	be 01       	movw	r22, r28
    25de:	6f 5f       	subi	r22, 0xFF	; 255
    25e0:	7f 4f       	sbci	r23, 0xFF	; 255
    25e2:	c7 01       	movw	r24, r14
    25e4:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    25e8:	6a e0       	ldi	r22, 0x0A	; 10
    25ea:	c7 01       	movw	r24, r14
    25ec:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    25f0:	7c 01       	movw	r14, r24
    25f2:	64 e9       	ldi	r22, 0x94	; 148
    25f4:	74 e0       	ldi	r23, 0x04	; 4
    25f6:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    25fa:	6a e0       	ldi	r22, 0x0A	; 10
    25fc:	c7 01       	movw	r24, r14
    25fe:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2602:	7c 01       	movw	r14, r24
    2604:	66 e8       	ldi	r22, 0x86	; 134
    2606:	74 e0       	ldi	r23, 0x04	; 4
    2608:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    260c:	63 e0       	ldi	r22, 0x03	; 3
    260e:	c7 01       	movw	r24, r14
    2610:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2614:	b2 01       	movw	r22, r4
    2616:	0e 94 3a 18 	call	0x3074	; 0x3074 <_ZN8emstreamlsEj>
    261a:	62 e0       	ldi	r22, 0x02	; 2
    261c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2620:	66 e0       	ldi	r22, 0x06	; 6
    2622:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2626:	13 c0       	rjmp	.+38     	; 0x264e <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2628:	6a e0       	ldi	r22, 0x0A	; 10
    262a:	c3 01       	movw	r24, r6
    262c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2630:	4c 01       	movw	r8, r24
    2632:	61 e7       	ldi	r22, 0x71	; 113
    2634:	74 e0       	ldi	r23, 0x04	; 4
    2636:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    263a:	be 01       	movw	r22, r28
    263c:	6f 5f       	subi	r22, 0xFF	; 255
    263e:	7f 4f       	sbci	r23, 0xFF	; 255
    2640:	c4 01       	movw	r24, r8
    2642:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    2646:	66 e0       	ldi	r22, 0x06	; 6
    2648:	c4 01       	movw	r24, r8
    264a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    264e:	2a 96       	adiw	r28, 0x0a	; 10
    2650:	cd bf       	out	0x3d, r28	; 61
    2652:	de bf       	out	0x3e, r29	; 62
    2654:	df 91       	pop	r29
    2656:	cf 91       	pop	r28
    2658:	1f 91       	pop	r17
    265a:	0f 91       	pop	r16
    265c:	ff 90       	pop	r15
    265e:	ef 90       	pop	r14
    2660:	df 90       	pop	r13
    2662:	cf 90       	pop	r12
    2664:	bf 90       	pop	r11
    2666:	af 90       	pop	r10
    2668:	9f 90       	pop	r9
    266a:	8f 90       	pop	r8
    266c:	7f 90       	pop	r7
    266e:	6f 90       	pop	r6
    2670:	5f 90       	pop	r5
    2672:	4f 90       	pop	r4
    2674:	08 95       	ret

00002676 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2676:	cf 92       	push	r12
    2678:	df 92       	push	r13
    267a:	ef 92       	push	r14
    267c:	ff 92       	push	r15
    267e:	0f 93       	push	r16
    2680:	1f 93       	push	r17
    2682:	cf 93       	push	r28
    2684:	df 93       	push	r29
    2686:	ec 01       	movw	r28, r24
    2688:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    268a:	8a 81       	ldd	r24, Y+2	; 0x02
    268c:	9b 81       	ldd	r25, Y+3	; 0x03
    268e:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pcTaskGetTaskName>
    2692:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2694:	6a e0       	ldi	r22, 0x0A	; 10
    2696:	c7 01       	movw	r24, r14
    2698:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    269c:	8c 01       	movw	r16, r24
    269e:	60 eb       	ldi	r22, 0xB0	; 176
    26a0:	74 e0       	ldi	r23, 0x04	; 4
    26a2:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    26a6:	6a e0       	ldi	r22, 0x0A	; 10
    26a8:	c8 01       	movw	r24, r16
    26aa:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    26ae:	8c 01       	movw	r16, r24
    26b0:	69 ea       	ldi	r22, 0xA9	; 169
    26b2:	74 e0       	ldi	r23, 0x04	; 4
    26b4:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    26b8:	b6 01       	movw	r22, r12
    26ba:	c8 01       	movw	r24, r16
    26bc:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    26c0:	6a e0       	ldi	r22, 0x0A	; 10
    26c2:	c8 01       	movw	r24, r16
    26c4:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    26c8:	8c 01       	movw	r16, r24
    26ca:	63 ea       	ldi	r22, 0xA3	; 163
    26cc:	74 e0       	ldi	r23, 0x04	; 4
    26ce:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    26d2:	66 e0       	ldi	r22, 0x06	; 6
    26d4:	c8 01       	movw	r24, r16
    26d6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    26da:	8a 85       	ldd	r24, Y+10	; 0x0a
    26dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    26de:	e8 85       	ldd	r30, Y+8	; 0x08
    26e0:	f9 85       	ldd	r31, Y+9	; 0x09
    26e2:	01 e1       	ldi	r16, 0x11	; 17
    26e4:	21 e0       	ldi	r18, 0x01	; 1
    26e6:	a7 01       	movw	r20, r14
    26e8:	bc 01       	movw	r22, r24
    26ea:	8e 1b       	sub	r24, r30
    26ec:	9f 0b       	sbc	r25, r31
    26ee:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    26f2:	8c 81       	ldd	r24, Y+4	; 0x04
    26f4:	9d 81       	ldd	r25, Y+5	; 0x05
    26f6:	00 97       	sbiw	r24, 0x00	; 0
    26f8:	19 f0       	breq	.+6      	; 0x2700 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    26fa:	b7 01       	movw	r22, r14
    26fc:	0e 94 3b 13 	call	0x2676	; 0x2676 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2700:	df 91       	pop	r29
    2702:	cf 91       	pop	r28
    2704:	1f 91       	pop	r17
    2706:	0f 91       	pop	r16
    2708:	ff 90       	pop	r15
    270a:	ef 90       	pop	r14
    270c:	df 90       	pop	r13
    270e:	cf 90       	pop	r12
    2710:	08 95       	ret

00002712 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2712:	0f 93       	push	r16
    2714:	1f 93       	push	r17
    2716:	cf 93       	push	r28
    2718:	df 93       	push	r29
    271a:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    271c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <last_created_task_pointer>
    2720:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    2724:	00 97       	sbiw	r24, 0x00	; 0
    2726:	19 f0       	breq	.+6      	; 0x272e <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2728:	be 01       	movw	r22, r28
    272a:	0e 94 3b 13 	call	0x2676	; 0x2676 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    272e:	6a e0       	ldi	r22, 0x0A	; 10
    2730:	ce 01       	movw	r24, r28
    2732:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2736:	8c 01       	movw	r16, r24
    2738:	66 ec       	ldi	r22, 0xC6	; 198
    273a:	74 e0       	ldi	r23, 0x04	; 4
    273c:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    2740:	6a e0       	ldi	r22, 0x0A	; 10
    2742:	c8 01       	movw	r24, r16
    2744:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2748:	8c 01       	movw	r16, r24
    274a:	6b eb       	ldi	r22, 0xBB	; 187
    274c:	74 e0       	ldi	r23, 0x04	; 4
    274e:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    2752:	6a e0       	ldi	r22, 0x0A	; 10
    2754:	c8 01       	movw	r24, r16
    2756:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    275a:	8c 01       	movw	r16, r24
    275c:	65 eb       	ldi	r22, 0xB5	; 181
    275e:	74 e0       	ldi	r23, 0x04	; 4
    2760:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    2764:	66 e0       	ldi	r22, 0x06	; 6
    2766:	c8 01       	movw	r24, r16
    2768:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    276c:	80 91 76 31 	lds	r24, 0x3176	; 0x803176 <portStackTopForTask>
    2770:	90 91 77 31 	lds	r25, 0x3177	; 0x803177 <portStackTopForTask+0x1>
    2774:	bc 01       	movw	r22, r24
    2776:	6f 5f       	subi	r22, 0xFF	; 255
    2778:	7f 4f       	sbci	r23, 0xFF	; 255
    277a:	01 e1       	ldi	r16, 0x11	; 17
    277c:	21 e0       	ldi	r18, 0x01	; 1
    277e:	ae 01       	movw	r20, r28
    2780:	83 56       	subi	r24, 0x63	; 99
    2782:	91 09       	sbc	r25, r1
    2784:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2788:	df 91       	pop	r29
    278a:	cf 91       	pop	r28
    278c:	1f 91       	pop	r17
    278e:	0f 91       	pop	r16
    2790:	08 95       	ret

00002792 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2792:	8f 92       	push	r8
    2794:	9f 92       	push	r9
    2796:	af 92       	push	r10
    2798:	bf 92       	push	r11
    279a:	cf 92       	push	r12
    279c:	df 92       	push	r13
    279e:	ef 92       	push	r14
    27a0:	ff 92       	push	r15
    27a2:	0f 93       	push	r16
    27a4:	1f 93       	push	r17
    27a6:	cf 93       	push	r28
    27a8:	df 93       	push	r29
    27aa:	ec 01       	movw	r28, r24
    27ac:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    27ae:	8a 81       	ldd	r24, Y+2	; 0x02
    27b0:	9b 81       	ldd	r25, Y+3	; 0x03
    27b2:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pcTaskGetTaskName>
    27b6:	bc 01       	movw	r22, r24
    27b8:	c8 01       	movw	r24, r16
    27ba:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    27be:	d8 01       	movw	r26, r16
    27c0:	ed 91       	ld	r30, X+
    27c2:	fc 91       	ld	r31, X
    27c4:	02 80       	ldd	r0, Z+2	; 0x02
    27c6:	f3 81       	ldd	r31, Z+3	; 0x03
    27c8:	e0 2d       	mov	r30, r0
    27ca:	69 e0       	ldi	r22, 0x09	; 9
    27cc:	c8 01       	movw	r24, r16
    27ce:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    27d0:	8a 81       	ldd	r24, Y+2	; 0x02
    27d2:	9b 81       	ldd	r25, Y+3	; 0x03
    27d4:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <pcTaskGetTaskName>
    27d8:	fc 01       	movw	r30, r24
    27da:	01 90       	ld	r0, Z+
    27dc:	00 20       	and	r0, r0
    27de:	e9 f7       	brne	.-6      	; 0x27da <_ZN8frt_task12print_statusER8emstream+0x48>
    27e0:	31 97       	sbiw	r30, 0x01	; 1
    27e2:	e8 1b       	sub	r30, r24
    27e4:	f9 0b       	sbc	r31, r25
    27e6:	38 97       	sbiw	r30, 0x08	; 8
    27e8:	48 f4       	brcc	.+18     	; 0x27fc <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    27ea:	d8 01       	movw	r26, r16
    27ec:	ed 91       	ld	r30, X+
    27ee:	fc 91       	ld	r31, X
    27f0:	02 80       	ldd	r0, Z+2	; 0x02
    27f2:	f3 81       	ldd	r31, Z+3	; 0x03
    27f4:	e0 2d       	mov	r30, r0
    27f6:	69 e0       	ldi	r22, 0x09	; 9
    27f8:	c8 01       	movw	r24, r16
    27fa:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    27fc:	ce 84       	ldd	r12, Y+14	; 0x0e
    27fe:	df 84       	ldd	r13, Y+15	; 0x0f
    2800:	e8 88       	ldd	r14, Y+16	; 0x10
    2802:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2804:	a8 84       	ldd	r10, Y+8	; 0x08
    2806:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2808:	8a 81       	ldd	r24, Y+2	; 0x02
    280a:	9b 81       	ldd	r25, Y+3	; 0x03
    280c:	0e 94 ba 11 	call	0x2374	; 0x2374 <uxTaskGetStackHighWaterMark>
    2810:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2812:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2814:	8a 81       	ldd	r24, Y+2	; 0x02
    2816:	9b 81       	ldd	r25, Y+3	; 0x03
    2818:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <uxTaskPriorityGet>
    281c:	68 2f       	mov	r22, r24
    281e:	c8 01       	movw	r24, r16
    2820:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
    2824:	6a e0       	ldi	r22, 0x0A	; 10
    2826:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    282a:	ec 01       	movw	r28, r24
    282c:	6b e3       	ldi	r22, 0x3B	; 59
    282e:	75 e0       	ldi	r23, 0x05	; 5
    2830:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2834:	68 2d       	mov	r22, r8
    2836:	ce 01       	movw	r24, r28
    2838:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    283c:	6a e0       	ldi	r22, 0x0A	; 10
    283e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2842:	ec 01       	movw	r28, r24
    2844:	69 e3       	ldi	r22, 0x39	; 57
    2846:	75 e0       	ldi	r23, 0x05	; 5
    2848:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    284c:	69 2d       	mov	r22, r9
    284e:	ce 01       	movw	r24, r28
    2850:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
    2854:	6a e0       	ldi	r22, 0x0A	; 10
    2856:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    285a:	ec 01       	movw	r28, r24
    285c:	67 e3       	ldi	r22, 0x37	; 55
    285e:	75 e0       	ldi	r23, 0x05	; 5
    2860:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2864:	b5 01       	movw	r22, r10
    2866:	ce 01       	movw	r24, r28
    2868:	0e 94 3a 18 	call	0x3074	; 0x3074 <_ZN8emstreamlsEj>
    286c:	6a e0       	ldi	r22, 0x0A	; 10
    286e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2872:	ec 01       	movw	r28, r24
    2874:	65 e3       	ldi	r22, 0x35	; 53
    2876:	75 e0       	ldi	r23, 0x05	; 5
    2878:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    287c:	6a e0       	ldi	r22, 0x0A	; 10
    287e:	ce 01       	movw	r24, r28
    2880:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2884:	ec 01       	movw	r28, r24
    2886:	63 e3       	ldi	r22, 0x33	; 51
    2888:	75 e0       	ldi	r23, 0x05	; 5
    288a:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    288e:	b7 01       	movw	r22, r14
    2890:	a6 01       	movw	r20, r12
    2892:	ce 01       	movw	r24, r28
    2894:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_ZN8emstreamlsEm>
}
    2898:	df 91       	pop	r29
    289a:	cf 91       	pop	r28
    289c:	1f 91       	pop	r17
    289e:	0f 91       	pop	r16
    28a0:	ff 90       	pop	r15
    28a2:	ef 90       	pop	r14
    28a4:	df 90       	pop	r13
    28a6:	cf 90       	pop	r12
    28a8:	bf 90       	pop	r11
    28aa:	af 90       	pop	r10
    28ac:	9f 90       	pop	r9
    28ae:	8f 90       	pop	r8
    28b0:	08 95       	ret

000028b2 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    28b2:	cf 93       	push	r28
    28b4:	df 93       	push	r29
    28b6:	ec 01       	movw	r28, r24
    28b8:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    28ba:	db 01       	movw	r26, r22
    28bc:	ed 91       	ld	r30, X+
    28be:	fc 91       	ld	r31, X
    28c0:	02 80       	ldd	r0, Z+2	; 0x02
    28c2:	f3 81       	ldd	r31, Z+3	; 0x03
    28c4:	e0 2d       	mov	r30, r0
    28c6:	be 01       	movw	r22, r28
    28c8:	19 95       	eicall
	return (ser_dev);
}
    28ca:	ce 01       	movw	r24, r28
    28cc:	df 91       	pop	r29
    28ce:	cf 91       	pop	r28
    28d0:	08 95       	ret

000028d2 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    28d2:	0f 93       	push	r16
    28d4:	1f 93       	push	r17
    28d6:	cf 93       	push	r28
    28d8:	df 93       	push	r29
    28da:	ec 01       	movw	r28, r24
    28dc:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    28de:	bc 01       	movw	r22, r24
    28e0:	c8 01       	movw	r24, r16
    28e2:	0e 94 59 14 	call	0x28b2	; 0x28b2 <_ZlsR8emstreamR8frt_task>
    28e6:	66 e0       	ldi	r22, 0x06	; 6
    28e8:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    28ec:	8c 81       	ldd	r24, Y+4	; 0x04
    28ee:	9d 81       	ldd	r25, Y+5	; 0x05
    28f0:	00 97       	sbiw	r24, 0x00	; 0
    28f2:	19 f0       	breq	.+6      	; 0x28fa <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    28f4:	b8 01       	movw	r22, r16
    28f6:	0e 94 69 14 	call	0x28d2	; 0x28d2 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    28fa:	df 91       	pop	r29
    28fc:	cf 91       	pop	r28
    28fe:	1f 91       	pop	r17
    2900:	0f 91       	pop	r16
    2902:	08 95       	ret

00002904 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2904:	0f 93       	push	r16
    2906:	1f 93       	push	r17
    2908:	cf 93       	push	r28
    290a:	df 93       	push	r29
    290c:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    290e:	6a e0       	ldi	r22, 0x0A	; 10
    2910:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2914:	8c 01       	movw	r16, r24
    2916:	68 e2       	ldi	r22, 0x28	; 40
    2918:	75 e0       	ldi	r23, 0x05	; 5
    291a:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    291e:	6a e0       	ldi	r22, 0x0A	; 10
    2920:	c8 01       	movw	r24, r16
    2922:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2926:	8c 01       	movw	r16, r24
    2928:	61 e2       	ldi	r22, 0x21	; 33
    292a:	75 e0       	ldi	r23, 0x05	; 5
    292c:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2930:	66 e0       	ldi	r22, 0x06	; 6
    2932:	c8 01       	movw	r24, r16
    2934:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2938:	6a e0       	ldi	r22, 0x0A	; 10
    293a:	ce 01       	movw	r24, r28
    293c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2940:	8c 01       	movw	r16, r24
    2942:	60 e1       	ldi	r22, 0x10	; 16
    2944:	75 e0       	ldi	r23, 0x05	; 5
    2946:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    294a:	6a e0       	ldi	r22, 0x0A	; 10
    294c:	c8 01       	movw	r24, r16
    294e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2952:	8c 01       	movw	r16, r24
    2954:	64 e0       	ldi	r22, 0x04	; 4
    2956:	75 e0       	ldi	r23, 0x05	; 5
    2958:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    295c:	6a e0       	ldi	r22, 0x0A	; 10
    295e:	c8 01       	movw	r24, r16
    2960:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2964:	8c 01       	movw	r16, r24
    2966:	6e ef       	ldi	r22, 0xFE	; 254
    2968:	74 e0       	ldi	r23, 0x04	; 4
    296a:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    296e:	66 e0       	ldi	r22, 0x06	; 6
    2970:	c8 01       	movw	r24, r16
    2972:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2976:	6a e0       	ldi	r22, 0x0A	; 10
    2978:	ce 01       	movw	r24, r28
    297a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    297e:	8c 01       	movw	r16, r24
    2980:	6d ee       	ldi	r22, 0xED	; 237
    2982:	74 e0       	ldi	r23, 0x04	; 4
    2984:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2988:	6a e0       	ldi	r22, 0x0A	; 10
    298a:	c8 01       	movw	r24, r16
    298c:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2990:	8c 01       	movw	r16, r24
    2992:	61 ee       	ldi	r22, 0xE1	; 225
    2994:	74 e0       	ldi	r23, 0x04	; 4
    2996:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    299a:	6a e0       	ldi	r22, 0x0A	; 10
    299c:	c8 01       	movw	r24, r16
    299e:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    29a2:	8c 01       	movw	r16, r24
    29a4:	6b ed       	ldi	r22, 0xDB	; 219
    29a6:	74 e0       	ldi	r23, 0x04	; 4
    29a8:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    29ac:	66 e0       	ldi	r22, 0x06	; 6
    29ae:	c8 01       	movw	r24, r16
    29b0:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    29b4:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <last_created_task_pointer>
    29b8:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    29bc:	00 97       	sbiw	r24, 0x00	; 0
    29be:	19 f0       	breq	.+6      	; 0x29c6 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    29c0:	be 01       	movw	r22, r28
    29c2:	0e 94 69 14 	call	0x28d2	; 0x28d2 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    29c6:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <xTaskGetIdleTaskHandle>
    29ca:	0e 94 ba 11 	call	0x2374	; 0x2374 <uxTaskGetStackHighWaterMark>
    29ce:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    29d0:	6a e0       	ldi	r22, 0x0A	; 10
    29d2:	ce 01       	movw	r24, r28
    29d4:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    29d8:	ec 01       	movw	r28, r24
    29da:	60 ed       	ldi	r22, 0xD0	; 208
    29dc:	74 e0       	ldi	r23, 0x04	; 4
    29de:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    29e2:	61 2f       	mov	r22, r17
    29e4:	ce 01       	movw	r24, r28
    29e6:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    29ea:	6a e0       	ldi	r22, 0x0A	; 10
    29ec:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    29f0:	ec 01       	movw	r28, r24
    29f2:	6e ec       	ldi	r22, 0xCE	; 206
    29f4:	74 e0       	ldi	r23, 0x04	; 4
    29f6:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    29fa:	64 e6       	ldi	r22, 0x64	; 100
    29fc:	70 e0       	ldi	r23, 0x00	; 0
    29fe:	ce 01       	movw	r24, r28
    2a00:	0e 94 3a 18 	call	0x3074	; 0x3074 <_ZN8emstreamlsEj>
    2a04:	6a e0       	ldi	r22, 0x0A	; 10
    2a06:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2a0a:	ec 01       	movw	r28, r24
    2a0c:	6b ec       	ldi	r22, 0xCB	; 203
    2a0e:	74 e0       	ldi	r23, 0x04	; 4
    2a10:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2a14:	66 e0       	ldi	r22, 0x06	; 6
    2a16:	ce 01       	movw	r24, r28
    2a18:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
}
    2a1c:	df 91       	pop	r29
    2a1e:	cf 91       	pop	r28
    2a20:	1f 91       	pop	r17
    2a22:	0f 91       	pop	r16
    2a24:	08 95       	ret

00002a26 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2a26:	0f 93       	push	r16
    2a28:	cf 93       	push	r28
    2a2a:	df 93       	push	r29
    2a2c:	1f 92       	push	r1
    2a2e:	cd b7       	in	r28, 0x3d	; 61
    2a30:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2a32:	00 e0       	ldi	r16, 0x00	; 0
    2a34:	2f ef       	ldi	r18, 0xFF	; 255
    2a36:	3f ef       	ldi	r19, 0xFF	; 255
    2a38:	a9 01       	movw	r20, r18
    2a3a:	be 01       	movw	r22, r28
    2a3c:	6f 5f       	subi	r22, 0xFF	; 255
    2a3e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a40:	fc 01       	movw	r30, r24
    2a42:	80 85       	ldd	r24, Z+8	; 0x08
    2a44:	91 85       	ldd	r25, Z+9	; 0x09
    2a46:	0e 94 ce 0b 	call	0x179c	; 0x179c <xQueueGenericReceive>
    2a4a:	81 30       	cpi	r24, 0x01	; 1
    2a4c:	19 f4       	brne	.+6      	; 0x2a54 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2a4e:	89 81       	ldd	r24, Y+1	; 0x01
    2a50:	90 e0       	ldi	r25, 0x00	; 0
    2a52:	02 c0       	rjmp	.+4      	; 0x2a58 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2a54:	8f ef       	ldi	r24, 0xFF	; 255
    2a56:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2a58:	0f 90       	pop	r0
    2a5a:	df 91       	pop	r29
    2a5c:	cf 91       	pop	r28
    2a5e:	0f 91       	pop	r16
    2a60:	08 95       	ret

00002a62 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2a62:	fc 01       	movw	r30, r24
    2a64:	80 85       	ldd	r24, Z+8	; 0x08
    2a66:	91 85       	ldd	r25, Z+9	; 0x09
    2a68:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxQueueMessagesWaiting>
    2a6c:	91 e0       	ldi	r25, 0x01	; 1
    2a6e:	81 11       	cpse	r24, r1
    2a70:	01 c0       	rjmp	.+2      	; 0x2a74 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2a72:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2a74:	89 2f       	mov	r24, r25
    2a76:	08 95       	ret

00002a78 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2a78:	0f 93       	push	r16
    2a7a:	cf 93       	push	r28
    2a7c:	df 93       	push	r29
    2a7e:	1f 92       	push	r1
    2a80:	cd b7       	in	r28, 0x3d	; 61
    2a82:	de b7       	in	r29, 0x3e	; 62
    2a84:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2a86:	fc 01       	movw	r30, r24
    2a88:	22 85       	ldd	r18, Z+10	; 0x0a
    2a8a:	33 85       	ldd	r19, Z+11	; 0x0b
    2a8c:	44 85       	ldd	r20, Z+12	; 0x0c
    2a8e:	55 85       	ldd	r21, Z+13	; 0x0d
    2a90:	00 e0       	ldi	r16, 0x00	; 0
    2a92:	be 01       	movw	r22, r28
    2a94:	6f 5f       	subi	r22, 0xFF	; 255
    2a96:	7f 4f       	sbci	r23, 0xFF	; 255
    2a98:	80 85       	ldd	r24, Z+8	; 0x08
    2a9a:	91 85       	ldd	r25, Z+9	; 0x09
    2a9c:	0e 94 33 0b 	call	0x1666	; 0x1666 <xQueueGenericSend>
    2aa0:	91 e0       	ldi	r25, 0x01	; 1
    2aa2:	81 11       	cpse	r24, r1
    2aa4:	01 c0       	rjmp	.+2      	; 0x2aa8 <_ZN14frt_text_queue7putcharEc+0x30>
    2aa6:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2aa8:	89 2f       	mov	r24, r25
    2aaa:	0f 90       	pop	r0
    2aac:	df 91       	pop	r29
    2aae:	cf 91       	pop	r28
    2ab0:	0f 91       	pop	r16
    2ab2:	08 95       	ret

00002ab4 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ab4:	8f 92       	push	r8
    2ab6:	9f 92       	push	r9
    2ab8:	bf 92       	push	r11
    2aba:	cf 92       	push	r12
    2abc:	df 92       	push	r13
    2abe:	ef 92       	push	r14
    2ac0:	ff 92       	push	r15
    2ac2:	0f 93       	push	r16
    2ac4:	1f 93       	push	r17
    2ac6:	cf 93       	push	r28
    2ac8:	df 93       	push	r29
    2aca:	ec 01       	movw	r28, r24
    2acc:	b6 2e       	mov	r11, r22
    2ace:	4a 01       	movw	r8, r20
    2ad0:	68 01       	movw	r12, r16
    2ad2:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2ad4:	0e 94 ae 17 	call	0x2f5c	; 0x2f5c <_ZN8emstreamC1Ev>
    2ad8:	8f e4       	ldi	r24, 0x4F	; 79
    2ada:	90 e2       	ldi	r25, 0x20	; 32
    2adc:	88 83       	st	Y, r24
    2ade:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2ae0:	8e 86       	std	Y+14, r8	; 0x0e
    2ae2:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2ae4:	40 e0       	ldi	r20, 0x00	; 0
    2ae6:	61 e0       	ldi	r22, 0x01	; 1
    2ae8:	8b 2d       	mov	r24, r11
    2aea:	0e 94 05 0b 	call	0x160a	; 0x160a <xQueueGenericCreate>
    2aee:	88 87       	std	Y+8, r24	; 0x08
    2af0:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2af2:	ca 86       	std	Y+10, r12	; 0x0a
    2af4:	db 86       	std	Y+11, r13	; 0x0b
    2af6:	ec 86       	std	Y+12, r14	; 0x0c
    2af8:	fd 86       	std	Y+13, r15	; 0x0d
}
    2afa:	df 91       	pop	r29
    2afc:	cf 91       	pop	r28
    2afe:	1f 91       	pop	r17
    2b00:	0f 91       	pop	r16
    2b02:	ff 90       	pop	r15
    2b04:	ef 90       	pop	r14
    2b06:	df 90       	pop	r13
    2b08:	cf 90       	pop	r12
    2b0a:	bf 90       	pop	r11
    2b0c:	9f 90       	pop	r9
    2b0e:	8f 90       	pop	r8
    2b10:	08 95       	ret

00002b12 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2b12:	cf 92       	push	r12
    2b14:	df 92       	push	r13
    2b16:	ef 92       	push	r14
    2b18:	ff 92       	push	r15
    2b1a:	cf 93       	push	r28
    2b1c:	df 93       	push	r29
    2b1e:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2b20:	68 81       	ld	r22, Y
    2b22:	79 81       	ldd	r23, Y+1	; 0x01
    2b24:	8a 81       	ldd	r24, Y+2	; 0x02
    2b26:	9b 81       	ldd	r25, Y+3	; 0x03
    2b28:	0f 2e       	mov	r0, r31
    2b2a:	f8 ee       	ldi	r31, 0xE8	; 232
    2b2c:	cf 2e       	mov	r12, r31
    2b2e:	f3 e0       	ldi	r31, 0x03	; 3
    2b30:	df 2e       	mov	r13, r31
    2b32:	e1 2c       	mov	r14, r1
    2b34:	f1 2c       	mov	r15, r1
    2b36:	f0 2d       	mov	r31, r0
    2b38:	a7 01       	movw	r20, r14
    2b3a:	96 01       	movw	r18, r12
    2b3c:	0e 94 57 1f 	call	0x3eae	; 0x3eae <__udivmodsi4>
    2b40:	9b 01       	movw	r18, r22
    2b42:	ac 01       	movw	r20, r24
    2b44:	60 e4       	ldi	r22, 0x40	; 64
    2b46:	72 e4       	ldi	r23, 0x42	; 66
    2b48:	8f e0       	ldi	r24, 0x0F	; 15
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <__mulsi3>
    2b50:	a7 01       	movw	r20, r14
    2b52:	96 01       	movw	r18, r12
    2b54:	0e 94 57 1f 	call	0x3eae	; 0x3eae <__udivmodsi4>
    2b58:	69 01       	movw	r12, r18
    2b5a:	7a 01       	movw	r14, r20
    2b5c:	ac 81       	ldd	r26, Y+4	; 0x04
    2b5e:	bd 81       	ldd	r27, Y+5	; 0x05
    2b60:	20 e4       	ldi	r18, 0x40	; 64
    2b62:	32 e4       	ldi	r19, 0x42	; 66
    2b64:	4f e0       	ldi	r20, 0x0F	; 15
    2b66:	50 e0       	ldi	r21, 0x00	; 0
    2b68:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <__muluhisi3>
    2b6c:	20 e0       	ldi	r18, 0x00	; 0
    2b6e:	38 e4       	ldi	r19, 0x48	; 72
    2b70:	48 ee       	ldi	r20, 0xE8	; 232
    2b72:	51 e0       	ldi	r21, 0x01	; 1
    2b74:	0e 94 57 1f 	call	0x3eae	; 0x3eae <__udivmodsi4>
    2b78:	c7 01       	movw	r24, r14
    2b7a:	b6 01       	movw	r22, r12
    2b7c:	62 0f       	add	r22, r18
    2b7e:	73 1f       	adc	r23, r19
    2b80:	84 1f       	adc	r24, r20
    2b82:	95 1f       	adc	r25, r21
}
    2b84:	df 91       	pop	r29
    2b86:	cf 91       	pop	r28
    2b88:	ff 90       	pop	r15
    2b8a:	ef 90       	pop	r14
    2b8c:	df 90       	pop	r13
    2b8e:	cf 90       	pop	r12
    2b90:	08 95       	ret

00002b92 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2b92:	cf 92       	push	r12
    2b94:	df 92       	push	r13
    2b96:	ef 92       	push	r14
    2b98:	ff 92       	push	r15
    2b9a:	0f 93       	push	r16
    2b9c:	1f 93       	push	r17
    2b9e:	cf 93       	push	r28
    2ba0:	df 93       	push	r29
    2ba2:	cd b7       	in	r28, 0x3d	; 61
    2ba4:	de b7       	in	r29, 0x3e	; 62
    2ba6:	2f 97       	sbiw	r28, 0x0f	; 15
    2ba8:	cd bf       	out	0x3d, r28	; 61
    2baa:	de bf       	out	0x3e, r29	; 62
    2bac:	6c 01       	movw	r12, r24
    2bae:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2bb0:	db 01       	movw	r26, r22
    2bb2:	6d 91       	ld	r22, X+
    2bb4:	7d 91       	ld	r23, X+
    2bb6:	8d 91       	ld	r24, X+
    2bb8:	9c 91       	ld	r25, X
    2bba:	28 ee       	ldi	r18, 0xE8	; 232
    2bbc:	33 e0       	ldi	r19, 0x03	; 3
    2bbe:	40 e0       	ldi	r20, 0x00	; 0
    2bc0:	50 e0       	ldi	r21, 0x00	; 0
    2bc2:	0e 94 57 1f 	call	0x3eae	; 0x3eae <__udivmodsi4>
    2bc6:	ba 01       	movw	r22, r20
    2bc8:	a9 01       	movw	r20, r18
    2bca:	c6 01       	movw	r24, r12
    2bcc:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2bd0:	d6 01       	movw	r26, r12
    2bd2:	ed 91       	ld	r30, X+
    2bd4:	fc 91       	ld	r31, X
    2bd6:	02 80       	ldd	r0, Z+2	; 0x02
    2bd8:	f3 81       	ldd	r31, Z+3	; 0x03
    2bda:	e0 2d       	mov	r30, r0
    2bdc:	6e e2       	ldi	r22, 0x2E	; 46
    2bde:	c6 01       	movw	r24, r12
    2be0:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2be2:	c8 01       	movw	r24, r16
    2be4:	0e 94 89 15 	call	0x2b12	; 0x2b12 <_ZN10time_stamp12get_microsecEv>
    2be8:	8e 01       	movw	r16, r28
    2bea:	09 5f       	subi	r16, 0xF9	; 249
    2bec:	1f 4f       	sbci	r17, 0xFF	; 255
    2bee:	fe 01       	movw	r30, r28
    2bf0:	31 96       	adiw	r30, 0x01	; 1
    2bf2:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2bf4:	2a e0       	ldi	r18, 0x0A	; 10
    2bf6:	30 e0       	ldi	r19, 0x00	; 0
    2bf8:	40 e0       	ldi	r20, 0x00	; 0
    2bfa:	50 e0       	ldi	r21, 0x00	; 0
    2bfc:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <__divmodsi4>
    2c00:	e6 2f       	mov	r30, r22
    2c02:	28 87       	std	Y+8, r18	; 0x08
    2c04:	39 87       	std	Y+9, r19	; 0x09
    2c06:	4a 87       	std	Y+10, r20	; 0x0a
    2c08:	5b 87       	std	Y+11, r21	; 0x0b
    2c0a:	68 85       	ldd	r22, Y+8	; 0x08
    2c0c:	79 85       	ldd	r23, Y+9	; 0x09
    2c0e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c10:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2c12:	20 e3       	ldi	r18, 0x30	; 48
    2c14:	2e 0f       	add	r18, r30
    2c16:	d8 01       	movw	r26, r16
    2c18:	2e 93       	st	-X, r18
    2c1a:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2c1c:	ae 15       	cp	r26, r14
    2c1e:	bf 05       	cpc	r27, r15
    2c20:	49 f7       	brne	.-46     	; 0x2bf4 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2c22:	1f 82       	std	Y+7, r1	; 0x07
    2c24:	be 01       	movw	r22, r28
    2c26:	6f 5f       	subi	r22, 0xFF	; 255
    2c28:	7f 4f       	sbci	r23, 0xFF	; 255
    2c2a:	c6 01       	movw	r24, r12
    2c2c:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2c30:	c6 01       	movw	r24, r12
    2c32:	2f 96       	adiw	r28, 0x0f	; 15
    2c34:	cd bf       	out	0x3d, r28	; 61
    2c36:	de bf       	out	0x3e, r29	; 62
    2c38:	df 91       	pop	r29
    2c3a:	cf 91       	pop	r28
    2c3c:	1f 91       	pop	r17
    2c3e:	0f 91       	pop	r16
    2c40:	ff 90       	pop	r15
    2c42:	ef 90       	pop	r14
    2c44:	df 90       	pop	r13
    2c46:	cf 90       	pop	r12
    2c48:	08 95       	ret

00002c4a <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2c4a:	cf 93       	push	r28
    2c4c:	df 93       	push	r29
    2c4e:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2c50:	0f b6       	in	r0, 0x3f	; 63
    2c52:	f8 94       	cli
    2c54:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2c56:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2c5a:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2c5e:	8c 83       	std	Y+4, r24	; 0x04
    2c60:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2c62:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <xTaskGetTickCount>
    2c66:	68 83       	st	Y, r22
    2c68:	79 83       	std	Y+1, r23	; 0x01
    2c6a:	8a 83       	std	Y+2, r24	; 0x02
    2c6c:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2c6e:	0f 90       	pop	r0
    2c70:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2c72:	ce 01       	movw	r24, r28
    2c74:	df 91       	pop	r29
    2c76:	cf 91       	pop	r28
    2c78:	08 95       	ret

00002c7a <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2c7a:	5f 92       	push	r5
    2c7c:	6f 92       	push	r6
    2c7e:	7f 92       	push	r7
    2c80:	8f 92       	push	r8
    2c82:	9f 92       	push	r9
    2c84:	af 92       	push	r10
    2c86:	bf 92       	push	r11
    2c88:	cf 92       	push	r12
    2c8a:	df 92       	push	r13
    2c8c:	ef 92       	push	r14
    2c8e:	ff 92       	push	r15
    2c90:	0f 93       	push	r16
    2c92:	1f 93       	push	r17
    2c94:	cf 93       	push	r28
    2c96:	df 93       	push	r29
    2c98:	5c 01       	movw	r10, r24
    2c9a:	4b 01       	movw	r8, r22
    2c9c:	7a 01       	movw	r14, r20
    2c9e:	12 2f       	mov	r17, r18
    2ca0:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2ca2:	63 e0       	ldi	r22, 0x03	; 3
    2ca4:	ca 01       	movw	r24, r20
    2ca6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2caa:	a8 14       	cp	r10, r8
    2cac:	b9 04       	cpc	r11, r9
    2cae:	08 f0       	brcs	.+2      	; 0x2cb2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2cb0:	7d c0       	rjmp	.+250    	; 0x2dac <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2cb2:	65 01       	movw	r12, r10
    2cb4:	84 e1       	ldi	r24, 0x14	; 20
    2cb6:	c8 0e       	add	r12, r24
    2cb8:	d1 1c       	adc	r13, r1
    2cba:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2cbc:	6a 2c       	mov	r6, r10
    2cbe:	5b 2c       	mov	r5, r11
    2cc0:	b5 01       	movw	r22, r10
    2cc2:	c7 01       	movw	r24, r14
    2cc4:	0e 94 3a 18 	call	0x3074	; 0x3074 <_ZN8emstreamlsEj>
    2cc8:	6a e0       	ldi	r22, 0x0A	; 10
    2cca:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2cce:	6d e4       	ldi	r22, 0x4D	; 77
    2cd0:	75 e0       	ldi	r23, 0x05	; 5
    2cd2:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2cd6:	11 23       	and	r17, r17
    2cd8:	09 f4       	brne	.+2      	; 0x2cdc <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2cda:	6d c0       	rjmp	.+218    	; 0x2db6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2cdc:	00 23       	and	r16, r16
    2cde:	09 f4       	brne	.+2      	; 0x2ce2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2ce0:	6a c0       	rjmp	.+212    	; 0x2db6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2ce2:	6a e0       	ldi	r22, 0x0A	; 10
    2ce4:	c7 01       	movw	r24, r14
    2ce6:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2cea:	68 e4       	ldi	r22, 0x48	; 72
    2cec:	75 e0       	ldi	r23, 0x05	; 5
    2cee:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    2cf2:	61 c0       	rjmp	.+194    	; 0x2db6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2cf4:	11 23       	and	r17, r17
    2cf6:	71 f0       	breq	.+28     	; 0x2d14 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2cf8:	01 11       	cpse	r16, r1
    2cfa:	0c c0       	rjmp	.+24     	; 0x2d14 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2cfc:	88 81       	ld	r24, Y
    2cfe:	87 15       	cp	r24, r7
    2d00:	49 f0       	breq	.+18     	; 0x2d14 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2d02:	6a e0       	ldi	r22, 0x0A	; 10
    2d04:	c7 01       	movw	r24, r14
    2d06:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2d0a:	63 e4       	ldi	r22, 0x43	; 67
    2d0c:	75 e0       	ldi	r23, 0x05	; 5
    2d0e:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2d12:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2d14:	69 91       	ld	r22, Y+
    2d16:	c7 01       	movw	r24, r14
    2d18:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2d1c:	dc 01       	movw	r26, r24
    2d1e:	ed 91       	ld	r30, X+
    2d20:	fc 91       	ld	r31, X
    2d22:	02 80       	ldd	r0, Z+2	; 0x02
    2d24:	f3 81       	ldd	r31, Z+3	; 0x03
    2d26:	e0 2d       	mov	r30, r0
    2d28:	60 e2       	ldi	r22, 0x20	; 32
    2d2a:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2d2c:	cc 16       	cp	r12, r28
    2d2e:	dd 06       	cpc	r13, r29
    2d30:	09 f7       	brne	.-62     	; 0x2cf4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2d32:	11 23       	and	r17, r17
    2d34:	89 f0       	breq	.+34     	; 0x2d58 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2d36:	6a e0       	ldi	r22, 0x0A	; 10
    2d38:	c7 01       	movw	r24, r14
    2d3a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2d3e:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2d40:	6d e3       	ldi	r22, 0x3D	; 61
    2d42:	75 e0       	ldi	r23, 0x05	; 5
    2d44:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2d48:	e8 81       	ld	r30, Y
    2d4a:	f9 81       	ldd	r31, Y+1	; 0x01
    2d4c:	02 80       	ldd	r0, Z+2	; 0x02
    2d4e:	f3 81       	ldd	r31, Z+3	; 0x03
    2d50:	e0 2d       	mov	r30, r0
    2d52:	60 e2       	ldi	r22, 0x20	; 32
    2d54:	ce 01       	movw	r24, r28
    2d56:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2d58:	c6 2d       	mov	r28, r6
    2d5a:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2d5c:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2d5e:	80 ee       	ldi	r24, 0xE0	; 224
    2d60:	86 0f       	add	r24, r22
    2d62:	8f 35       	cpi	r24, 0x5F	; 95
    2d64:	48 f4       	brcc	.+18     	; 0x2d78 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2d66:	d7 01       	movw	r26, r14
    2d68:	ed 91       	ld	r30, X+
    2d6a:	fc 91       	ld	r31, X
    2d6c:	02 80       	ldd	r0, Z+2	; 0x02
    2d6e:	f3 81       	ldd	r31, Z+3	; 0x03
    2d70:	e0 2d       	mov	r30, r0
    2d72:	c7 01       	movw	r24, r14
    2d74:	19 95       	eicall
    2d76:	09 c0       	rjmp	.+18     	; 0x2d8a <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2d78:	d7 01       	movw	r26, r14
    2d7a:	ed 91       	ld	r30, X+
    2d7c:	fc 91       	ld	r31, X
    2d7e:	02 80       	ldd	r0, Z+2	; 0x02
    2d80:	f3 81       	ldd	r31, Z+3	; 0x03
    2d82:	e0 2d       	mov	r30, r0
    2d84:	6e e2       	ldi	r22, 0x2E	; 46
    2d86:	c7 01       	movw	r24, r14
    2d88:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2d8a:	cc 16       	cp	r12, r28
    2d8c:	dd 06       	cpc	r13, r29
    2d8e:	31 f7       	brne	.-52     	; 0x2d5c <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2d90:	b4 e1       	ldi	r27, 0x14	; 20
    2d92:	ab 0e       	add	r10, r27
    2d94:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2d96:	66 e0       	ldi	r22, 0x06	; 6
    2d98:	c7 01       	movw	r24, r14
    2d9a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    2d9e:	84 e1       	ldi	r24, 0x14	; 20
    2da0:	c8 0e       	add	r12, r24
    2da2:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2da4:	a8 14       	cp	r10, r8
    2da6:	b9 04       	cpc	r11, r9
    2da8:	08 f4       	brcc	.+2      	; 0x2dac <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2daa:	88 cf       	rjmp	.-240    	; 0x2cbc <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2dac:	62 e0       	ldi	r22, 0x02	; 2
    2dae:	c7 01       	movw	r24, r14
    2db0:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
}
    2db4:	03 c0       	rjmp	.+6      	; 0x2dbc <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2db6:	c6 2d       	mov	r28, r6
    2db8:	d5 2d       	mov	r29, r5
    2dba:	9c cf       	rjmp	.-200    	; 0x2cf4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2dbc:	df 91       	pop	r29
    2dbe:	cf 91       	pop	r28
    2dc0:	1f 91       	pop	r17
    2dc2:	0f 91       	pop	r16
    2dc4:	ff 90       	pop	r15
    2dc6:	ef 90       	pop	r14
    2dc8:	df 90       	pop	r13
    2dca:	cf 90       	pop	r12
    2dcc:	bf 90       	pop	r11
    2dce:	af 90       	pop	r10
    2dd0:	9f 90       	pop	r9
    2dd2:	8f 90       	pop	r8
    2dd4:	7f 90       	pop	r7
    2dd6:	6f 90       	pop	r6
    2dd8:	5f 90       	pop	r5
    2dda:	08 95       	ret

00002ddc <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2ddc:	0e 94 1d 07 	call	0xe3a	; 0xe3a <pvPortMalloc>
    2de0:	08 95       	ret

00002de2 <_Znaj>:
    2de2:	0e 94 1d 07 	call	0xe3a	; 0xe3a <pvPortMalloc>
    2de6:	08 95       	ret

00002de8 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2de8:	08 95       	ret

00002dea <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2dea:	cf 93       	push	r28
    2dec:	df 93       	push	r29
    2dee:	fc 01       	movw	r30, r24
    2df0:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2df2:	40 3a       	cpi	r20, 0xA0	; 160
    2df4:	68 e0       	ldi	r22, 0x08	; 8
    2df6:	56 07       	cpc	r21, r22
    2df8:	49 f4       	brne	.+18     	; 0x2e0c <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2dfa:	80 e4       	ldi	r24, 0x40	; 64
    2dfc:	96 e0       	ldi	r25, 0x06	; 6
    2dfe:	82 83       	std	Z+2, r24	; 0x02
    2e00:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e02:	82 e0       	ldi	r24, 0x02	; 2
    2e04:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e06:	83 e0       	ldi	r24, 0x03	; 3
    2e08:	85 83       	std	Z+5, r24	; 0x05
    2e0a:	4c c0       	rjmp	.+152    	; 0x2ea4 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2e0c:	40 3b       	cpi	r20, 0xB0	; 176
    2e0e:	78 e0       	ldi	r23, 0x08	; 8
    2e10:	57 07       	cpc	r21, r23
    2e12:	49 f4       	brne	.+18     	; 0x2e26 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2e14:	80 e4       	ldi	r24, 0x40	; 64
    2e16:	96 e0       	ldi	r25, 0x06	; 6
    2e18:	82 83       	std	Z+2, r24	; 0x02
    2e1a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2e1c:	86 e0       	ldi	r24, 0x06	; 6
    2e1e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2e20:	87 e0       	ldi	r24, 0x07	; 7
    2e22:	85 83       	std	Z+5, r24	; 0x05
    2e24:	3f c0       	rjmp	.+126    	; 0x2ea4 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2e26:	40 3a       	cpi	r20, 0xA0	; 160
    2e28:	89 e0       	ldi	r24, 0x09	; 9
    2e2a:	58 07       	cpc	r21, r24
    2e2c:	49 f4       	brne	.+18     	; 0x2e40 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2e2e:	80 e6       	ldi	r24, 0x60	; 96
    2e30:	96 e0       	ldi	r25, 0x06	; 6
    2e32:	82 83       	std	Z+2, r24	; 0x02
    2e34:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e36:	82 e0       	ldi	r24, 0x02	; 2
    2e38:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e3a:	83 e0       	ldi	r24, 0x03	; 3
    2e3c:	85 83       	std	Z+5, r24	; 0x05
    2e3e:	32 c0       	rjmp	.+100    	; 0x2ea4 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2e40:	40 3b       	cpi	r20, 0xB0	; 176
    2e42:	69 e0       	ldi	r22, 0x09	; 9
    2e44:	56 07       	cpc	r21, r22
    2e46:	49 f4       	brne	.+18     	; 0x2e5a <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2e48:	80 e6       	ldi	r24, 0x60	; 96
    2e4a:	96 e0       	ldi	r25, 0x06	; 6
    2e4c:	82 83       	std	Z+2, r24	; 0x02
    2e4e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2e50:	86 e0       	ldi	r24, 0x06	; 6
    2e52:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2e54:	87 e0       	ldi	r24, 0x07	; 7
    2e56:	85 83       	std	Z+5, r24	; 0x05
    2e58:	25 c0       	rjmp	.+74     	; 0x2ea4 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2e5a:	40 3a       	cpi	r20, 0xA0	; 160
    2e5c:	7a e0       	ldi	r23, 0x0A	; 10
    2e5e:	57 07       	cpc	r21, r23
    2e60:	49 f4       	brne	.+18     	; 0x2e74 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    2e62:	80 e8       	ldi	r24, 0x80	; 128
    2e64:	96 e0       	ldi	r25, 0x06	; 6
    2e66:	82 83       	std	Z+2, r24	; 0x02
    2e68:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e6a:	82 e0       	ldi	r24, 0x02	; 2
    2e6c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e6e:	83 e0       	ldi	r24, 0x03	; 3
    2e70:	85 83       	std	Z+5, r24	; 0x05
    2e72:	18 c0       	rjmp	.+48     	; 0x2ea4 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    2e74:	40 3b       	cpi	r20, 0xB0	; 176
    2e76:	8a e0       	ldi	r24, 0x0A	; 10
    2e78:	58 07       	cpc	r21, r24
    2e7a:	49 f4       	brne	.+18     	; 0x2e8e <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    2e7c:	80 e8       	ldi	r24, 0x80	; 128
    2e7e:	96 e0       	ldi	r25, 0x06	; 6
    2e80:	82 83       	std	Z+2, r24	; 0x02
    2e82:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2e84:	86 e0       	ldi	r24, 0x06	; 6
    2e86:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2e88:	87 e0       	ldi	r24, 0x07	; 7
    2e8a:	85 83       	std	Z+5, r24	; 0x05
    2e8c:	0b c0       	rjmp	.+22     	; 0x2ea4 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    2e8e:	40 3a       	cpi	r20, 0xA0	; 160
    2e90:	5b 40       	sbci	r21, 0x0B	; 11
    2e92:	41 f4       	brne	.+16     	; 0x2ea4 <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    2e94:	80 ea       	ldi	r24, 0xA0	; 160
    2e96:	96 e0       	ldi	r25, 0x06	; 6
    2e98:	82 83       	std	Z+2, r24	; 0x02
    2e9a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e9c:	82 e0       	ldi	r24, 0x02	; 2
    2e9e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2ea0:	83 e0       	ldi	r24, 0x03	; 3
    2ea2:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2ea4:	a6 83       	std	Z+6, r26	; 0x06
    2ea6:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2ea8:	cd 01       	movw	r24, r26
    2eaa:	01 96       	adiw	r24, 0x01	; 1
    2eac:	80 87       	std	Z+8, r24	; 0x08
    2eae:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2eb0:	03 96       	adiw	r24, 0x03	; 3
    2eb2:	82 87       	std	Z+10, r24	; 0x0a
    2eb4:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2eb6:	25 81       	ldd	r18, Z+5	; 0x05
    2eb8:	c2 81       	ldd	r28, Z+2	; 0x02
    2eba:	d3 81       	ldd	r29, Z+3	; 0x03
    2ebc:	4c 81       	ldd	r20, Y+4	; 0x04
    2ebe:	81 e0       	ldi	r24, 0x01	; 1
    2ec0:	90 e0       	ldi	r25, 0x00	; 0
    2ec2:	bc 01       	movw	r22, r24
    2ec4:	02 c0       	rjmp	.+4      	; 0x2eca <_ZN7base232C1EjP12USART_struct+0xe0>
    2ec6:	66 0f       	add	r22, r22
    2ec8:	77 1f       	adc	r23, r23
    2eca:	2a 95       	dec	r18
    2ecc:	e2 f7       	brpl	.-8      	; 0x2ec6 <_ZN7base232C1EjP12USART_struct+0xdc>
    2ece:	9b 01       	movw	r18, r22
    2ed0:	24 2b       	or	r18, r20
    2ed2:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2ed4:	25 81       	ldd	r18, Z+5	; 0x05
    2ed6:	c2 81       	ldd	r28, Z+2	; 0x02
    2ed8:	d3 81       	ldd	r29, Z+3	; 0x03
    2eda:	48 81       	ld	r20, Y
    2edc:	bc 01       	movw	r22, r24
    2ede:	02 c0       	rjmp	.+4      	; 0x2ee4 <_ZN7base232C1EjP12USART_struct+0xfa>
    2ee0:	66 0f       	add	r22, r22
    2ee2:	77 1f       	adc	r23, r23
    2ee4:	2a 95       	dec	r18
    2ee6:	e2 f7       	brpl	.-8      	; 0x2ee0 <_ZN7base232C1EjP12USART_struct+0xf6>
    2ee8:	9b 01       	movw	r18, r22
    2eea:	24 2b       	or	r18, r20
    2eec:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2eee:	34 81       	ldd	r19, Z+4	; 0x04
    2ef0:	c2 81       	ldd	r28, Z+2	; 0x02
    2ef2:	d3 81       	ldd	r29, Z+3	; 0x03
    2ef4:	28 81       	ld	r18, Y
    2ef6:	02 c0       	rjmp	.+4      	; 0x2efc <_ZN7base232C1EjP12USART_struct+0x112>
    2ef8:	88 0f       	add	r24, r24
    2efa:	99 1f       	adc	r25, r25
    2efc:	3a 95       	dec	r19
    2efe:	e2 f7       	brpl	.-8      	; 0x2ef8 <_ZN7base232C1EjP12USART_struct+0x10e>
    2f00:	80 95       	com	r24
    2f02:	90 95       	com	r25
    2f04:	82 23       	and	r24, r18
    2f06:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2f08:	80 e1       	ldi	r24, 0x10	; 16
    2f0a:	13 96       	adiw	r26, 0x03	; 3
    2f0c:	8c 93       	st	X, r24
    2f0e:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2f10:	83 e0       	ldi	r24, 0x03	; 3
    2f12:	15 96       	adiw	r26, 0x05	; 5
    2f14:	8c 93       	st	X, r24
    2f16:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2f18:	80 ef       	ldi	r24, 0xF0	; 240
    2f1a:	17 96       	adiw	r26, 0x07	; 7
    2f1c:	8c 93       	st	X, r24
    2f1e:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2f20:	81 e2       	ldi	r24, 0x21	; 33
    2f22:	16 96       	adiw	r26, 0x06	; 6
    2f24:	8c 93       	st	X, r24
    2f26:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2f28:	88 e1       	ldi	r24, 0x18	; 24
    2f2a:	14 96       	adiw	r26, 0x04	; 4
    2f2c:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2f2e:	80 e8       	ldi	r24, 0x80	; 128
    2f30:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2f32:	80 e4       	ldi	r24, 0x40	; 64
    2f34:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2f36:	80 e2       	ldi	r24, 0x20	; 32
    2f38:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2f3a:	06 80       	ldd	r0, Z+6	; 0x06
    2f3c:	f7 81       	ldd	r31, Z+7	; 0x07
    2f3e:	e0 2d       	mov	r30, r0
    2f40:	80 81       	ld	r24, Z
    2f42:	80 81       	ld	r24, Z
}
    2f44:	df 91       	pop	r29
    2f46:	cf 91       	pop	r28
    2f48:	08 95       	ret

00002f4a <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2f4a:	81 e0       	ldi	r24, 0x01	; 1
    2f4c:	08 95       	ret

00002f4e <_ZN8emstream7getcharEv>:
    2f4e:	80 e0       	ldi	r24, 0x00	; 0
    2f50:	90 e0       	ldi	r25, 0x00	; 0
    2f52:	08 95       	ret

00002f54 <_ZN8emstream14check_for_charEv>:
    2f54:	80 e0       	ldi	r24, 0x00	; 0
    2f56:	08 95       	ret

00002f58 <_ZN8emstream12transmit_nowEv>:
    2f58:	08 95       	ret

00002f5a <_ZN8emstream12clear_screenEv>:
    2f5a:	08 95       	ret

00002f5c <_ZN8emstreamC1Ev>:
    2f5c:	fc 01       	movw	r30, r24
    2f5e:	8f e5       	ldi	r24, 0x5F	; 95
    2f60:	90 e2       	ldi	r25, 0x20	; 32
    2f62:	80 83       	st	Z, r24
    2f64:	91 83       	std	Z+1, r25	; 0x01
    2f66:	8a e0       	ldi	r24, 0x0A	; 10
    2f68:	82 83       	std	Z+2, r24	; 0x02
    2f6a:	13 82       	std	Z+3, r1	; 0x03
    2f6c:	83 e0       	ldi	r24, 0x03	; 3
    2f6e:	85 83       	std	Z+5, r24	; 0x05
    2f70:	14 82       	std	Z+4, r1	; 0x04
    2f72:	16 82       	std	Z+6, r1	; 0x06
    2f74:	17 82       	std	Z+7, r1	; 0x07
    2f76:	08 95       	ret

00002f78 <_ZN8emstream4putsEPKc>:
    2f78:	0f 93       	push	r16
    2f7a:	1f 93       	push	r17
    2f7c:	cf 93       	push	r28
    2f7e:	df 93       	push	r29
    2f80:	8c 01       	movw	r16, r24
    2f82:	fb 01       	movw	r30, r22
    2f84:	dc 01       	movw	r26, r24
    2f86:	14 96       	adiw	r26, 0x04	; 4
    2f88:	8c 91       	ld	r24, X
    2f8a:	81 11       	cpse	r24, r1
    2f8c:	04 c0       	rjmp	.+8      	; 0x2f96 <_ZN8emstream4putsEPKc+0x1e>
    2f8e:	60 81       	ld	r22, Z
    2f90:	61 11       	cpse	r22, r1
    2f92:	17 c0       	rjmp	.+46     	; 0x2fc2 <_ZN8emstream4putsEPKc+0x4a>
    2f94:	23 c0       	rjmp	.+70     	; 0x2fdc <_ZN8emstream4putsEPKc+0x64>
    2f96:	d8 01       	movw	r26, r16
    2f98:	14 96       	adiw	r26, 0x04	; 4
    2f9a:	1c 92       	st	X, r1
    2f9c:	eb 01       	movw	r28, r22
    2f9e:	21 96       	adiw	r28, 0x01	; 1
    2fa0:	64 91       	lpm	r22, Z
    2fa2:	66 23       	and	r22, r22
    2fa4:	d9 f0       	breq	.+54     	; 0x2fdc <_ZN8emstream4putsEPKc+0x64>
    2fa6:	d8 01       	movw	r26, r16
    2fa8:	ed 91       	ld	r30, X+
    2faa:	fc 91       	ld	r31, X
    2fac:	02 80       	ldd	r0, Z+2	; 0x02
    2fae:	f3 81       	ldd	r31, Z+3	; 0x03
    2fb0:	e0 2d       	mov	r30, r0
    2fb2:	c8 01       	movw	r24, r16
    2fb4:	19 95       	eicall
    2fb6:	fe 01       	movw	r30, r28
    2fb8:	64 91       	lpm	r22, Z
    2fba:	21 96       	adiw	r28, 0x01	; 1
    2fbc:	61 11       	cpse	r22, r1
    2fbe:	f3 cf       	rjmp	.-26     	; 0x2fa6 <_ZN8emstream4putsEPKc+0x2e>
    2fc0:	0d c0       	rjmp	.+26     	; 0x2fdc <_ZN8emstream4putsEPKc+0x64>
    2fc2:	ef 01       	movw	r28, r30
    2fc4:	21 96       	adiw	r28, 0x01	; 1
    2fc6:	d8 01       	movw	r26, r16
    2fc8:	ed 91       	ld	r30, X+
    2fca:	fc 91       	ld	r31, X
    2fcc:	02 80       	ldd	r0, Z+2	; 0x02
    2fce:	f3 81       	ldd	r31, Z+3	; 0x03
    2fd0:	e0 2d       	mov	r30, r0
    2fd2:	c8 01       	movw	r24, r16
    2fd4:	19 95       	eicall
    2fd6:	69 91       	ld	r22, Y+
    2fd8:	61 11       	cpse	r22, r1
    2fda:	f5 cf       	rjmp	.-22     	; 0x2fc6 <_ZN8emstream4putsEPKc+0x4e>
    2fdc:	df 91       	pop	r29
    2fde:	cf 91       	pop	r28
    2fe0:	1f 91       	pop	r17
    2fe2:	0f 91       	pop	r16
    2fe4:	08 95       	ret

00002fe6 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2fe6:	cf 93       	push	r28
    2fe8:	df 93       	push	r29
    2fea:	ec 01       	movw	r28, r24
	switch (new_manip)
    2fec:	86 2f       	mov	r24, r22
    2fee:	90 e0       	ldi	r25, 0x00	; 0
    2ff0:	8b 30       	cpi	r24, 0x0B	; 11
    2ff2:	91 05       	cpc	r25, r1
    2ff4:	d8 f5       	brcc	.+118    	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
    2ff6:	fc 01       	movw	r30, r24
    2ff8:	88 27       	eor	r24, r24
    2ffa:	e2 50       	subi	r30, 0x02	; 2
    2ffc:	ff 4f       	sbci	r31, 0xFF	; 255
    2ffe:	8f 4f       	sbci	r24, 0xFF	; 255
    3000:	0c 94 98 1f 	jmp	0x3f30	; 0x3f30 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3004:	82 e0       	ldi	r24, 0x02	; 2
    3006:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3008:	31 c0       	rjmp	.+98     	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    300a:	88 e0       	ldi	r24, 0x08	; 8
    300c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    300e:	2e c0       	rjmp	.+92     	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3010:	8a e0       	ldi	r24, 0x0A	; 10
    3012:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3014:	2b c0       	rjmp	.+86     	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3016:	80 e1       	ldi	r24, 0x10	; 16
    3018:	8a 83       	std	Y+2, r24	; 0x02
			break;
    301a:	28 c0       	rjmp	.+80     	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    301c:	81 e0       	ldi	r24, 0x01	; 1
    301e:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3020:	25 c0       	rjmp	.+74     	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3022:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3024:	23 c0       	rjmp	.+70     	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3026:	e8 81       	ld	r30, Y
    3028:	f9 81       	ldd	r31, Y+1	; 0x01
    302a:	02 80       	ldd	r0, Z+2	; 0x02
    302c:	f3 81       	ldd	r31, Z+3	; 0x03
    302e:	e0 2d       	mov	r30, r0
    3030:	6d e0       	ldi	r22, 0x0D	; 13
    3032:	ce 01       	movw	r24, r28
    3034:	19 95       	eicall
    3036:	e8 81       	ld	r30, Y
    3038:	f9 81       	ldd	r31, Y+1	; 0x01
    303a:	02 80       	ldd	r0, Z+2	; 0x02
    303c:	f3 81       	ldd	r31, Z+3	; 0x03
    303e:	e0 2d       	mov	r30, r0
    3040:	6a e0       	ldi	r22, 0x0A	; 10
    3042:	ce 01       	movw	r24, r28
    3044:	19 95       	eicall
			break;
    3046:	12 c0       	rjmp	.+36     	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3048:	e8 81       	ld	r30, Y
    304a:	f9 81       	ldd	r31, Y+1	; 0x01
    304c:	02 84       	ldd	r0, Z+10	; 0x0a
    304e:	f3 85       	ldd	r31, Z+11	; 0x0b
    3050:	e0 2d       	mov	r30, r0
    3052:	ce 01       	movw	r24, r28
    3054:	19 95       	eicall
			break;
    3056:	0a c0       	rjmp	.+20     	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3058:	e8 81       	ld	r30, Y
    305a:	f9 81       	ldd	r31, Y+1	; 0x01
    305c:	00 84       	ldd	r0, Z+8	; 0x08
    305e:	f1 85       	ldd	r31, Z+9	; 0x09
    3060:	e0 2d       	mov	r30, r0
    3062:	ce 01       	movw	r24, r28
    3064:	19 95       	eicall
			break;
    3066:	02 c0       	rjmp	.+4      	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3068:	81 e0       	ldi	r24, 0x01	; 1
    306a:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    306c:	ce 01       	movw	r24, r28
    306e:	df 91       	pop	r29
    3070:	cf 91       	pop	r28
    3072:	08 95       	ret

00003074 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3074:	ff 92       	push	r15
    3076:	0f 93       	push	r16
    3078:	1f 93       	push	r17
    307a:	cf 93       	push	r28
    307c:	df 93       	push	r29
    307e:	cd b7       	in	r28, 0x3d	; 61
    3080:	de b7       	in	r29, 0x3e	; 62
    3082:	61 97       	sbiw	r28, 0x11	; 17
    3084:	cd bf       	out	0x3d, r28	; 61
    3086:	de bf       	out	0x3e, r29	; 62
    3088:	8c 01       	movw	r16, r24
    308a:	f6 2e       	mov	r15, r22
    308c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    308e:	f8 01       	movw	r30, r16
    3090:	42 81       	ldd	r20, Z+2	; 0x02
    3092:	40 31       	cpi	r20, 0x10	; 16
    3094:	21 f0       	breq	.+8      	; 0x309e <_ZN8emstreamlsEj+0x2a>
    3096:	48 30       	cpi	r20, 0x08	; 8
    3098:	11 f0       	breq	.+4      	; 0x309e <_ZN8emstreamlsEj+0x2a>
    309a:	42 30       	cpi	r20, 0x02	; 2
    309c:	41 f4       	brne	.+16     	; 0x30ae <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    309e:	69 2f       	mov	r22, r25
    30a0:	c8 01       	movw	r24, r16
    30a2:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
    30a6:	6f 2d       	mov	r22, r15
    30a8:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
    30ac:	0d c0       	rjmp	.+26     	; 0x30c8 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    30ae:	50 e0       	ldi	r21, 0x00	; 0
    30b0:	be 01       	movw	r22, r28
    30b2:	6f 5f       	subi	r22, 0xFF	; 255
    30b4:	7f 4f       	sbci	r23, 0xFF	; 255
    30b6:	8f 2d       	mov	r24, r15
    30b8:	0e 94 1b 20 	call	0x4036	; 0x4036 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    30bc:	be 01       	movw	r22, r28
    30be:	6f 5f       	subi	r22, 0xFF	; 255
    30c0:	7f 4f       	sbci	r23, 0xFF	; 255
    30c2:	c8 01       	movw	r24, r16
    30c4:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    30c8:	c8 01       	movw	r24, r16
    30ca:	61 96       	adiw	r28, 0x11	; 17
    30cc:	cd bf       	out	0x3d, r28	; 61
    30ce:	de bf       	out	0x3e, r29	; 62
    30d0:	df 91       	pop	r29
    30d2:	cf 91       	pop	r28
    30d4:	1f 91       	pop	r17
    30d6:	0f 91       	pop	r16
    30d8:	ff 90       	pop	r15
    30da:	08 95       	ret

000030dc <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    30dc:	df 92       	push	r13
    30de:	ef 92       	push	r14
    30e0:	ff 92       	push	r15
    30e2:	0f 93       	push	r16
    30e4:	1f 93       	push	r17
    30e6:	cf 93       	push	r28
    30e8:	df 93       	push	r29
    30ea:	cd b7       	in	r28, 0x3d	; 61
    30ec:	de b7       	in	r29, 0x3e	; 62
    30ee:	a1 97       	sbiw	r28, 0x21	; 33
    30f0:	cd bf       	out	0x3d, r28	; 61
    30f2:	de bf       	out	0x3e, r29	; 62
    30f4:	8c 01       	movw	r16, r24
    30f6:	d4 2e       	mov	r13, r20
    30f8:	e5 2e       	mov	r14, r21
    30fa:	f6 2e       	mov	r15, r22
    30fc:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    30fe:	f8 01       	movw	r30, r16
    3100:	22 81       	ldd	r18, Z+2	; 0x02
    3102:	20 31       	cpi	r18, 0x10	; 16
    3104:	21 f0       	breq	.+8      	; 0x310e <_ZN8emstreamlsEm+0x32>
    3106:	28 30       	cpi	r18, 0x08	; 8
    3108:	11 f0       	breq	.+4      	; 0x310e <_ZN8emstreamlsEm+0x32>
    310a:	22 30       	cpi	r18, 0x02	; 2
    310c:	71 f4       	brne	.+28     	; 0x312a <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    310e:	69 2f       	mov	r22, r25
    3110:	c8 01       	movw	r24, r16
    3112:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
    3116:	6f 2d       	mov	r22, r15
    3118:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
    311c:	6e 2d       	mov	r22, r14
    311e:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
    3122:	6d 2d       	mov	r22, r13
    3124:	0e 94 b0 18 	call	0x3160	; 0x3160 <_ZN8emstreamlsEh>
    3128:	0f c0       	rjmp	.+30     	; 0x3148 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    312a:	30 e0       	ldi	r19, 0x00	; 0
    312c:	ae 01       	movw	r20, r28
    312e:	4f 5f       	subi	r20, 0xFF	; 255
    3130:	5f 4f       	sbci	r21, 0xFF	; 255
    3132:	6d 2d       	mov	r22, r13
    3134:	7e 2d       	mov	r23, r14
    3136:	8f 2d       	mov	r24, r15
    3138:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    313c:	be 01       	movw	r22, r28
    313e:	6f 5f       	subi	r22, 0xFF	; 255
    3140:	7f 4f       	sbci	r23, 0xFF	; 255
    3142:	c8 01       	movw	r24, r16
    3144:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3148:	c8 01       	movw	r24, r16
    314a:	a1 96       	adiw	r28, 0x21	; 33
    314c:	cd bf       	out	0x3d, r28	; 61
    314e:	de bf       	out	0x3e, r29	; 62
    3150:	df 91       	pop	r29
    3152:	cf 91       	pop	r28
    3154:	1f 91       	pop	r17
    3156:	0f 91       	pop	r16
    3158:	ff 90       	pop	r15
    315a:	ef 90       	pop	r14
    315c:	df 90       	pop	r13
    315e:	08 95       	ret

00003160 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3160:	cf 92       	push	r12
    3162:	df 92       	push	r13
    3164:	ef 92       	push	r14
    3166:	ff 92       	push	r15
    3168:	0f 93       	push	r16
    316a:	1f 93       	push	r17
    316c:	cf 93       	push	r28
    316e:	df 93       	push	r29
    3170:	cd b7       	in	r28, 0x3d	; 61
    3172:	de b7       	in	r29, 0x3e	; 62
    3174:	29 97       	sbiw	r28, 0x09	; 9
    3176:	cd bf       	out	0x3d, r28	; 61
    3178:	de bf       	out	0x3e, r29	; 62
    317a:	8c 01       	movw	r16, r24
    317c:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    317e:	dc 01       	movw	r26, r24
    3180:	13 96       	adiw	r26, 0x03	; 3
    3182:	8c 91       	ld	r24, X
    3184:	13 97       	sbiw	r26, 0x03	; 3
    3186:	88 23       	and	r24, r24
    3188:	41 f0       	breq	.+16     	; 0x319a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    318a:	ed 91       	ld	r30, X+
    318c:	fc 91       	ld	r31, X
    318e:	02 80       	ldd	r0, Z+2	; 0x02
    3190:	f3 81       	ldd	r31, Z+3	; 0x03
    3192:	e0 2d       	mov	r30, r0
    3194:	c8 01       	movw	r24, r16
    3196:	19 95       	eicall
    3198:	56 c0       	rjmp	.+172    	; 0x3246 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    319a:	f8 01       	movw	r30, r16
    319c:	42 81       	ldd	r20, Z+2	; 0x02
    319e:	42 30       	cpi	r20, 0x02	; 2
    31a0:	19 f5       	brne	.+70     	; 0x31e8 <_ZN8emstreamlsEh+0x88>
    31a2:	68 94       	set
    31a4:	cc 24       	eor	r12, r12
    31a6:	c3 f8       	bld	r12, 3
    31a8:	d1 2c       	mov	r13, r1
    31aa:	68 94       	set
    31ac:	ff 24       	eor	r15, r15
    31ae:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    31b0:	8e 2d       	mov	r24, r14
    31b2:	8f 21       	and	r24, r15
    31b4:	51 f0       	breq	.+20     	; 0x31ca <_ZN8emstreamlsEh+0x6a>
    31b6:	d8 01       	movw	r26, r16
    31b8:	ed 91       	ld	r30, X+
    31ba:	fc 91       	ld	r31, X
    31bc:	02 80       	ldd	r0, Z+2	; 0x02
    31be:	f3 81       	ldd	r31, Z+3	; 0x03
    31c0:	e0 2d       	mov	r30, r0
    31c2:	61 e3       	ldi	r22, 0x31	; 49
    31c4:	c8 01       	movw	r24, r16
    31c6:	19 95       	eicall
    31c8:	09 c0       	rjmp	.+18     	; 0x31dc <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    31ca:	d8 01       	movw	r26, r16
    31cc:	ed 91       	ld	r30, X+
    31ce:	fc 91       	ld	r31, X
    31d0:	02 80       	ldd	r0, Z+2	; 0x02
    31d2:	f3 81       	ldd	r31, Z+3	; 0x03
    31d4:	e0 2d       	mov	r30, r0
    31d6:	60 e3       	ldi	r22, 0x30	; 48
    31d8:	c8 01       	movw	r24, r16
    31da:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    31dc:	f6 94       	lsr	r15
    31de:	b1 e0       	ldi	r27, 0x01	; 1
    31e0:	cb 1a       	sub	r12, r27
    31e2:	d1 08       	sbc	r13, r1
    31e4:	29 f7       	brne	.-54     	; 0x31b0 <_ZN8emstreamlsEh+0x50>
    31e6:	2f c0       	rjmp	.+94     	; 0x3246 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    31e8:	40 31       	cpi	r20, 0x10	; 16
    31ea:	f9 f4       	brne	.+62     	; 0x322a <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    31ec:	62 95       	swap	r22
    31ee:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    31f0:	01 90       	ld	r0, Z+
    31f2:	f0 81       	ld	r31, Z
    31f4:	e0 2d       	mov	r30, r0
    31f6:	02 80       	ldd	r0, Z+2	; 0x02
    31f8:	f3 81       	ldd	r31, Z+3	; 0x03
    31fa:	e0 2d       	mov	r30, r0
    31fc:	6a 30       	cpi	r22, 0x0A	; 10
    31fe:	10 f0       	brcs	.+4      	; 0x3204 <_ZN8emstreamlsEh+0xa4>
    3200:	69 5c       	subi	r22, 0xC9	; 201
    3202:	01 c0       	rjmp	.+2      	; 0x3206 <_ZN8emstreamlsEh+0xa6>
    3204:	60 5d       	subi	r22, 0xD0	; 208
    3206:	c8 01       	movw	r24, r16
    3208:	19 95       	eicall
		temp_char = num & 0x0F;
    320a:	6e 2d       	mov	r22, r14
    320c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    320e:	d8 01       	movw	r26, r16
    3210:	ed 91       	ld	r30, X+
    3212:	fc 91       	ld	r31, X
    3214:	02 80       	ldd	r0, Z+2	; 0x02
    3216:	f3 81       	ldd	r31, Z+3	; 0x03
    3218:	e0 2d       	mov	r30, r0
    321a:	6a 30       	cpi	r22, 0x0A	; 10
    321c:	10 f0       	brcs	.+4      	; 0x3222 <_ZN8emstreamlsEh+0xc2>
    321e:	69 5c       	subi	r22, 0xC9	; 201
    3220:	01 c0       	rjmp	.+2      	; 0x3224 <_ZN8emstreamlsEh+0xc4>
    3222:	60 5d       	subi	r22, 0xD0	; 208
    3224:	c8 01       	movw	r24, r16
    3226:	19 95       	eicall
    3228:	0e c0       	rjmp	.+28     	; 0x3246 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    322a:	50 e0       	ldi	r21, 0x00	; 0
    322c:	be 01       	movw	r22, r28
    322e:	6f 5f       	subi	r22, 0xFF	; 255
    3230:	7f 4f       	sbci	r23, 0xFF	; 255
    3232:	8e 2d       	mov	r24, r14
    3234:	90 e0       	ldi	r25, 0x00	; 0
    3236:	0e 94 1b 20 	call	0x4036	; 0x4036 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    323a:	be 01       	movw	r22, r28
    323c:	6f 5f       	subi	r22, 0xFF	; 255
    323e:	7f 4f       	sbci	r23, 0xFF	; 255
    3240:	c8 01       	movw	r24, r16
    3242:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3246:	c8 01       	movw	r24, r16
    3248:	29 96       	adiw	r28, 0x09	; 9
    324a:	cd bf       	out	0x3d, r28	; 61
    324c:	de bf       	out	0x3e, r29	; 62
    324e:	df 91       	pop	r29
    3250:	cf 91       	pop	r28
    3252:	1f 91       	pop	r17
    3254:	0f 91       	pop	r16
    3256:	ff 90       	pop	r15
    3258:	ef 90       	pop	r14
    325a:	df 90       	pop	r13
    325c:	cf 90       	pop	r12
    325e:	08 95       	ret

00003260 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3260:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3262:	50 96       	adiw	r26, 0x10	; 16
    3264:	ed 91       	ld	r30, X+
    3266:	fc 91       	ld	r31, X
    3268:	51 97       	sbiw	r26, 0x11	; 17
    326a:	80 81       	ld	r24, Z
    326c:	54 96       	adiw	r26, 0x14	; 20
    326e:	4c 91       	ld	r20, X
    3270:	54 97       	sbiw	r26, 0x14	; 20
    3272:	84 23       	and	r24, r20
    3274:	29 f0       	breq	.+10     	; 0x3280 <_ZN5rs2327putcharEc+0x20>
    3276:	09 c0       	rjmp	.+18     	; 0x328a <_ZN5rs2327putcharEc+0x2a>
    3278:	21 50       	subi	r18, 0x01	; 1
    327a:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    327c:	19 f4       	brne	.+6      	; 0x3284 <_ZN5rs2327putcharEc+0x24>
    327e:	12 c0       	rjmp	.+36     	; 0x32a4 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3280:	21 e2       	ldi	r18, 0x21	; 33
    3282:	3e e4       	ldi	r19, 0x4E	; 78
    3284:	90 81       	ld	r25, Z
    3286:	94 23       	and	r25, r20
    3288:	b9 f3       	breq	.-18     	; 0x3278 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    328a:	90 81       	ld	r25, Z
    328c:	56 96       	adiw	r26, 0x16	; 22
    328e:	8c 91       	ld	r24, X
    3290:	56 97       	sbiw	r26, 0x16	; 22
    3292:	89 2b       	or	r24, r25
    3294:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3296:	1e 96       	adiw	r26, 0x0e	; 14
    3298:	ed 91       	ld	r30, X+
    329a:	fc 91       	ld	r31, X
    329c:	1f 97       	sbiw	r26, 0x0f	; 15
    329e:	60 83       	st	Z, r22
	return (true);
    32a0:	81 e0       	ldi	r24, 0x01	; 1
    32a2:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    32a4:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    32a6:	08 95       	ret

000032a8 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    32a8:	cf 93       	push	r28
    32aa:	df 93       	push	r29
    32ac:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    32ae:	c1 8d       	ldd	r28, Z+25	; 0x19
    32b0:	d2 8d       	ldd	r29, Z+26	; 0x1a
    32b2:	28 81       	ld	r18, Y
    32b4:	39 81       	ldd	r19, Y+1	; 0x01
    32b6:	a3 8d       	ldd	r26, Z+27	; 0x1b
    32b8:	b4 8d       	ldd	r27, Z+28	; 0x1c
    32ba:	4d 91       	ld	r20, X+
    32bc:	5c 91       	ld	r21, X
    32be:	24 17       	cp	r18, r20
    32c0:	35 07       	cpc	r19, r21
    32c2:	e9 f3       	breq	.-6      	; 0x32be <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    32c4:	a7 89       	ldd	r26, Z+23	; 0x17
    32c6:	b0 8d       	ldd	r27, Z+24	; 0x18
    32c8:	0d 90       	ld	r0, X+
    32ca:	bc 91       	ld	r27, X
    32cc:	a0 2d       	mov	r26, r0
    32ce:	a2 0f       	add	r26, r18
    32d0:	b3 1f       	adc	r27, r19
    32d2:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    32d4:	2f 5f       	subi	r18, 0xFF	; 255
    32d6:	3f 4f       	sbci	r19, 0xFF	; 255
    32d8:	28 83       	st	Y, r18
    32da:	39 83       	std	Y+1, r19	; 0x01
    32dc:	24 36       	cpi	r18, 0x64	; 100
    32de:	31 05       	cpc	r19, r1
    32e0:	28 f0       	brcs	.+10     	; 0x32ec <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    32e2:	01 8c       	ldd	r0, Z+25	; 0x19
    32e4:	f2 8d       	ldd	r31, Z+26	; 0x1a
    32e6:	e0 2d       	mov	r30, r0
    32e8:	10 82       	st	Z, r1
    32ea:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    32ec:	90 e0       	ldi	r25, 0x00	; 0
    32ee:	df 91       	pop	r29
    32f0:	cf 91       	pop	r28
    32f2:	08 95       	ret

000032f4 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    32f4:	cf 93       	push	r28
    32f6:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    32f8:	ec 01       	movw	r28, r24
    32fa:	a9 8d       	ldd	r26, Y+25	; 0x19
    32fc:	ba 8d       	ldd	r27, Y+26	; 0x1a
    32fe:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3300:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3302:	81 e0       	ldi	r24, 0x01	; 1
    3304:	4d 91       	ld	r20, X+
    3306:	5c 91       	ld	r21, X
    3308:	20 81       	ld	r18, Z
    330a:	31 81       	ldd	r19, Z+1	; 0x01
    330c:	42 17       	cp	r20, r18
    330e:	53 07       	cpc	r21, r19
    3310:	09 f4       	brne	.+2      	; 0x3314 <_ZN5rs23214check_for_charEv+0x20>
    3312:	80 e0       	ldi	r24, 0x00	; 0
}
    3314:	df 91       	pop	r29
    3316:	cf 91       	pop	r28
    3318:	08 95       	ret

0000331a <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    331a:	dc 01       	movw	r26, r24
    331c:	ed 91       	ld	r30, X+
    331e:	fc 91       	ld	r31, X
    3320:	02 80       	ldd	r0, Z+2	; 0x02
    3322:	f3 81       	ldd	r31, Z+3	; 0x03
    3324:	e0 2d       	mov	r30, r0
    3326:	6c e0       	ldi	r22, 0x0C	; 12
    3328:	19 95       	eicall
    332a:	08 95       	ret

0000332c <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    332c:	ef 92       	push	r14
    332e:	ff 92       	push	r15
    3330:	0f 93       	push	r16
    3332:	1f 93       	push	r17
    3334:	cf 93       	push	r28
    3336:	df 93       	push	r29
    3338:	ec 01       	movw	r28, r24
    333a:	7b 01       	movw	r14, r22
    333c:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    333e:	0e 94 ae 17 	call	0x2f5c	; 0x2f5c <_ZN8emstreamC1Ev>
    3342:	a8 01       	movw	r20, r16
    3344:	b7 01       	movw	r22, r14
    3346:	ce 01       	movw	r24, r28
    3348:	08 96       	adiw	r24, 0x08	; 8
    334a:	0e 94 f5 16 	call	0x2dea	; 0x2dea <_ZN7base232C1EjP12USART_struct>
    334e:	8f e6       	ldi	r24, 0x6F	; 111
    3350:	90 e2       	ldi	r25, 0x20	; 32
    3352:	88 83       	st	Y, r24
    3354:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3356:	00 3a       	cpi	r16, 0xA0	; 160
    3358:	88 e0       	ldi	r24, 0x08	; 8
    335a:	18 07       	cpc	r17, r24
    335c:	69 f4       	brne	.+26     	; 0x3378 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    335e:	8e e5       	ldi	r24, 0x5E	; 94
    3360:	91 e3       	ldi	r25, 0x31	; 49
    3362:	8f 8b       	std	Y+23, r24	; 0x17
    3364:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3366:	80 e5       	ldi	r24, 0x50	; 80
    3368:	91 e3       	ldi	r25, 0x31	; 49
    336a:	89 8f       	std	Y+25, r24	; 0x19
    336c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    336e:	82 e4       	ldi	r24, 0x42	; 66
    3370:	91 e3       	ldi	r25, 0x31	; 49
    3372:	8b 8f       	std	Y+27, r24	; 0x1b
    3374:	9c 8f       	std	Y+28, r25	; 0x1c
    3376:	64 c0       	rjmp	.+200    	; 0x3440 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3378:	00 3b       	cpi	r16, 0xB0	; 176
    337a:	e8 e0       	ldi	r30, 0x08	; 8
    337c:	1e 07       	cpc	r17, r30
    337e:	69 f4       	brne	.+26     	; 0x339a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3380:	8c e5       	ldi	r24, 0x5C	; 92
    3382:	91 e3       	ldi	r25, 0x31	; 49
    3384:	8f 8b       	std	Y+23, r24	; 0x17
    3386:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3388:	8e e4       	ldi	r24, 0x4E	; 78
    338a:	91 e3       	ldi	r25, 0x31	; 49
    338c:	89 8f       	std	Y+25, r24	; 0x19
    338e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3390:	80 e4       	ldi	r24, 0x40	; 64
    3392:	91 e3       	ldi	r25, 0x31	; 49
    3394:	8b 8f       	std	Y+27, r24	; 0x1b
    3396:	9c 8f       	std	Y+28, r25	; 0x1c
    3398:	53 c0       	rjmp	.+166    	; 0x3440 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    339a:	00 3a       	cpi	r16, 0xA0	; 160
    339c:	f9 e0       	ldi	r31, 0x09	; 9
    339e:	1f 07       	cpc	r17, r31
    33a0:	69 f4       	brne	.+26     	; 0x33bc <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    33a2:	8a e5       	ldi	r24, 0x5A	; 90
    33a4:	91 e3       	ldi	r25, 0x31	; 49
    33a6:	8f 8b       	std	Y+23, r24	; 0x17
    33a8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    33aa:	8c e4       	ldi	r24, 0x4C	; 76
    33ac:	91 e3       	ldi	r25, 0x31	; 49
    33ae:	89 8f       	std	Y+25, r24	; 0x19
    33b0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    33b2:	8e e3       	ldi	r24, 0x3E	; 62
    33b4:	91 e3       	ldi	r25, 0x31	; 49
    33b6:	8b 8f       	std	Y+27, r24	; 0x1b
    33b8:	9c 8f       	std	Y+28, r25	; 0x1c
    33ba:	42 c0       	rjmp	.+132    	; 0x3440 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    33bc:	00 3b       	cpi	r16, 0xB0	; 176
    33be:	89 e0       	ldi	r24, 0x09	; 9
    33c0:	18 07       	cpc	r17, r24
    33c2:	69 f4       	brne	.+26     	; 0x33de <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    33c4:	88 e5       	ldi	r24, 0x58	; 88
    33c6:	91 e3       	ldi	r25, 0x31	; 49
    33c8:	8f 8b       	std	Y+23, r24	; 0x17
    33ca:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    33cc:	8a e4       	ldi	r24, 0x4A	; 74
    33ce:	91 e3       	ldi	r25, 0x31	; 49
    33d0:	89 8f       	std	Y+25, r24	; 0x19
    33d2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    33d4:	8c e3       	ldi	r24, 0x3C	; 60
    33d6:	91 e3       	ldi	r25, 0x31	; 49
    33d8:	8b 8f       	std	Y+27, r24	; 0x1b
    33da:	9c 8f       	std	Y+28, r25	; 0x1c
    33dc:	31 c0       	rjmp	.+98     	; 0x3440 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    33de:	00 3a       	cpi	r16, 0xA0	; 160
    33e0:	ea e0       	ldi	r30, 0x0A	; 10
    33e2:	1e 07       	cpc	r17, r30
    33e4:	69 f4       	brne	.+26     	; 0x3400 <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    33e6:	86 e5       	ldi	r24, 0x56	; 86
    33e8:	91 e3       	ldi	r25, 0x31	; 49
    33ea:	8f 8b       	std	Y+23, r24	; 0x17
    33ec:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    33ee:	88 e4       	ldi	r24, 0x48	; 72
    33f0:	91 e3       	ldi	r25, 0x31	; 49
    33f2:	89 8f       	std	Y+25, r24	; 0x19
    33f4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    33f6:	8a e3       	ldi	r24, 0x3A	; 58
    33f8:	91 e3       	ldi	r25, 0x31	; 49
    33fa:	8b 8f       	std	Y+27, r24	; 0x1b
    33fc:	9c 8f       	std	Y+28, r25	; 0x1c
    33fe:	20 c0       	rjmp	.+64     	; 0x3440 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    3400:	00 3b       	cpi	r16, 0xB0	; 176
    3402:	fa e0       	ldi	r31, 0x0A	; 10
    3404:	1f 07       	cpc	r17, r31
    3406:	69 f4       	brne	.+26     	; 0x3422 <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    3408:	84 e5       	ldi	r24, 0x54	; 84
    340a:	91 e3       	ldi	r25, 0x31	; 49
    340c:	8f 8b       	std	Y+23, r24	; 0x17
    340e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    3410:	86 e4       	ldi	r24, 0x46	; 70
    3412:	91 e3       	ldi	r25, 0x31	; 49
    3414:	89 8f       	std	Y+25, r24	; 0x19
    3416:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    3418:	88 e3       	ldi	r24, 0x38	; 56
    341a:	91 e3       	ldi	r25, 0x31	; 49
    341c:	8b 8f       	std	Y+27, r24	; 0x1b
    341e:	9c 8f       	std	Y+28, r25	; 0x1c
    3420:	0f c0       	rjmp	.+30     	; 0x3440 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    3422:	00 3a       	cpi	r16, 0xA0	; 160
    3424:	1b 40       	sbci	r17, 0x0B	; 11
    3426:	61 f4       	brne	.+24     	; 0x3440 <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    3428:	82 e5       	ldi	r24, 0x52	; 82
    342a:	91 e3       	ldi	r25, 0x31	; 49
    342c:	8f 8b       	std	Y+23, r24	; 0x17
    342e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    3430:	84 e4       	ldi	r24, 0x44	; 68
    3432:	91 e3       	ldi	r25, 0x31	; 49
    3434:	89 8f       	std	Y+25, r24	; 0x19
    3436:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    3438:	86 e3       	ldi	r24, 0x36	; 54
    343a:	91 e3       	ldi	r25, 0x31	; 49
    343c:	8b 8f       	std	Y+27, r24	; 0x1b
    343e:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3440:	0f 89       	ldd	r16, Y+23	; 0x17
    3442:	18 8d       	ldd	r17, Y+24	; 0x18
    3444:	84 e6       	ldi	r24, 0x64	; 100
    3446:	90 e0       	ldi	r25, 0x00	; 0
    3448:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <_Znaj>
    344c:	f8 01       	movw	r30, r16
    344e:	80 83       	st	Z, r24
    3450:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3452:	e9 8d       	ldd	r30, Y+25	; 0x19
    3454:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3456:	10 82       	st	Z, r1
    3458:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    345a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    345c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    345e:	10 82       	st	Z, r1
    3460:	11 82       	std	Z+1, r1	; 0x01
}
    3462:	df 91       	pop	r29
    3464:	cf 91       	pop	r28
    3466:	1f 91       	pop	r17
    3468:	0f 91       	pop	r16
    346a:	ff 90       	pop	r15
    346c:	ef 90       	pop	r14
    346e:	08 95       	ret

00003470 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3470:	1f 92       	push	r1
    3472:	0f 92       	push	r0
    3474:	0f b6       	in	r0, 0x3f	; 63
    3476:	0f 92       	push	r0
    3478:	11 24       	eor	r1, r1
    347a:	08 b6       	in	r0, 0x38	; 56
    347c:	0f 92       	push	r0
    347e:	18 be       	out	0x38, r1	; 56
    3480:	0b b6       	in	r0, 0x3b	; 59
    3482:	0f 92       	push	r0
    3484:	1b be       	out	0x3b, r1	; 59
    3486:	2f 93       	push	r18
    3488:	3f 93       	push	r19
    348a:	8f 93       	push	r24
    348c:	9f 93       	push	r25
    348e:	ef 93       	push	r30
    3490:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3492:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3496:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <rcvC0_buffer>
    349a:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <rcvC0_buffer+0x1>
    349e:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    34a2:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    34a6:	e8 0f       	add	r30, r24
    34a8:	f9 1f       	adc	r31, r25
    34aa:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    34ac:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    34b0:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    34b4:	01 96       	adiw	r24, 0x01	; 1
    34b6:	84 36       	cpi	r24, 0x64	; 100
    34b8:	91 05       	cpc	r25, r1
    34ba:	60 f4       	brcc	.+24     	; 0x34d4 <__vector_25+0x64>
    34bc:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <rcvC0_write_index>
    34c0:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    34c4:	20 91 50 31 	lds	r18, 0x3150	; 0x803150 <rcvC0_read_index>
    34c8:	30 91 51 31 	lds	r19, 0x3151	; 0x803151 <rcvC0_read_index+0x1>
    34cc:	82 17       	cp	r24, r18
    34ce:	93 07       	cpc	r25, r19
    34d0:	f1 f4       	brne	.+60     	; 0x350e <__vector_25+0x9e>
    34d2:	0c c0       	rjmp	.+24     	; 0x34ec <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    34d4:	10 92 42 31 	sts	0x3142, r1	; 0x803142 <rcvC0_write_index>
    34d8:	10 92 43 31 	sts	0x3143, r1	; 0x803143 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    34dc:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC0_read_index>
    34e0:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC0_read_index+0x1>
    34e4:	18 16       	cp	r1, r24
    34e6:	19 06       	cpc	r1, r25
    34e8:	91 f4       	brne	.+36     	; 0x350e <__vector_25+0x9e>
    34ea:	0e c0       	rjmp	.+28     	; 0x3508 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    34ec:	01 96       	adiw	r24, 0x01	; 1
    34ee:	84 36       	cpi	r24, 0x64	; 100
    34f0:	91 05       	cpc	r25, r1
    34f2:	28 f4       	brcc	.+10     	; 0x34fe <__vector_25+0x8e>
    34f4:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvC0_read_index>
    34f8:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvC0_read_index+0x1>
    34fc:	08 c0       	rjmp	.+16     	; 0x350e <__vector_25+0x9e>
			rcvC0_read_index = 0;
    34fe:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvC0_read_index>
    3502:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvC0_read_index+0x1>
}
    3506:	03 c0       	rjmp	.+6      	; 0x350e <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3508:	81 e0       	ldi	r24, 0x01	; 1
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	f3 cf       	rjmp	.-26     	; 0x34f4 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    350e:	ff 91       	pop	r31
    3510:	ef 91       	pop	r30
    3512:	9f 91       	pop	r25
    3514:	8f 91       	pop	r24
    3516:	3f 91       	pop	r19
    3518:	2f 91       	pop	r18
    351a:	0f 90       	pop	r0
    351c:	0b be       	out	0x3b, r0	; 59
    351e:	0f 90       	pop	r0
    3520:	08 be       	out	0x38, r0	; 56
    3522:	0f 90       	pop	r0
    3524:	0f be       	out	0x3f, r0	; 63
    3526:	0f 90       	pop	r0
    3528:	1f 90       	pop	r1
    352a:	18 95       	reti

0000352c <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    352c:	1f 92       	push	r1
    352e:	0f 92       	push	r0
    3530:	0f b6       	in	r0, 0x3f	; 63
    3532:	0f 92       	push	r0
    3534:	11 24       	eor	r1, r1
    3536:	08 b6       	in	r0, 0x38	; 56
    3538:	0f 92       	push	r0
    353a:	18 be       	out	0x38, r1	; 56
    353c:	0b b6       	in	r0, 0x3b	; 59
    353e:	0f 92       	push	r0
    3540:	1b be       	out	0x3b, r1	; 59
    3542:	2f 93       	push	r18
    3544:	3f 93       	push	r19
    3546:	8f 93       	push	r24
    3548:	9f 93       	push	r25
    354a:	ef 93       	push	r30
    354c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    354e:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3552:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <rcvC1_buffer>
    3556:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <rcvC1_buffer+0x1>
    355a:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC1_write_index>
    355e:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC1_write_index+0x1>
    3562:	e8 0f       	add	r30, r24
    3564:	f9 1f       	adc	r31, r25
    3566:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3568:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC1_write_index>
    356c:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC1_write_index+0x1>
    3570:	01 96       	adiw	r24, 0x01	; 1
    3572:	84 36       	cpi	r24, 0x64	; 100
    3574:	91 05       	cpc	r25, r1
    3576:	60 f4       	brcc	.+24     	; 0x3590 <__vector_28+0x64>
    3578:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <rcvC1_write_index>
    357c:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3580:	20 91 4e 31 	lds	r18, 0x314E	; 0x80314e <rcvC1_read_index>
    3584:	30 91 4f 31 	lds	r19, 0x314F	; 0x80314f <rcvC1_read_index+0x1>
    3588:	82 17       	cp	r24, r18
    358a:	93 07       	cpc	r25, r19
    358c:	f1 f4       	brne	.+60     	; 0x35ca <__vector_28+0x9e>
    358e:	0c c0       	rjmp	.+24     	; 0x35a8 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3590:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rcvC1_write_index>
    3594:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3598:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvC1_read_index>
    359c:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvC1_read_index+0x1>
    35a0:	18 16       	cp	r1, r24
    35a2:	19 06       	cpc	r1, r25
    35a4:	91 f4       	brne	.+36     	; 0x35ca <__vector_28+0x9e>
    35a6:	0e c0       	rjmp	.+28     	; 0x35c4 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    35a8:	01 96       	adiw	r24, 0x01	; 1
    35aa:	84 36       	cpi	r24, 0x64	; 100
    35ac:	91 05       	cpc	r25, r1
    35ae:	28 f4       	brcc	.+10     	; 0x35ba <__vector_28+0x8e>
    35b0:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvC1_read_index>
    35b4:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvC1_read_index+0x1>
    35b8:	08 c0       	rjmp	.+16     	; 0x35ca <__vector_28+0x9e>
	rcvC1_read_index = 0;
    35ba:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvC1_read_index>
    35be:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvC1_read_index+0x1>
}
    35c2:	03 c0       	rjmp	.+6      	; 0x35ca <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    35c4:	81 e0       	ldi	r24, 0x01	; 1
    35c6:	90 e0       	ldi	r25, 0x00	; 0
    35c8:	f3 cf       	rjmp	.-26     	; 0x35b0 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    35ca:	ff 91       	pop	r31
    35cc:	ef 91       	pop	r30
    35ce:	9f 91       	pop	r25
    35d0:	8f 91       	pop	r24
    35d2:	3f 91       	pop	r19
    35d4:	2f 91       	pop	r18
    35d6:	0f 90       	pop	r0
    35d8:	0b be       	out	0x3b, r0	; 59
    35da:	0f 90       	pop	r0
    35dc:	08 be       	out	0x38, r0	; 56
    35de:	0f 90       	pop	r0
    35e0:	0f be       	out	0x3f, r0	; 63
    35e2:	0f 90       	pop	r0
    35e4:	1f 90       	pop	r1
    35e6:	18 95       	reti

000035e8 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    35e8:	1f 92       	push	r1
    35ea:	0f 92       	push	r0
    35ec:	0f b6       	in	r0, 0x3f	; 63
    35ee:	0f 92       	push	r0
    35f0:	11 24       	eor	r1, r1
    35f2:	08 b6       	in	r0, 0x38	; 56
    35f4:	0f 92       	push	r0
    35f6:	18 be       	out	0x38, r1	; 56
    35f8:	0b b6       	in	r0, 0x3b	; 59
    35fa:	0f 92       	push	r0
    35fc:	1b be       	out	0x3b, r1	; 59
    35fe:	2f 93       	push	r18
    3600:	3f 93       	push	r19
    3602:	8f 93       	push	r24
    3604:	9f 93       	push	r25
    3606:	ef 93       	push	r30
    3608:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    360a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    360e:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <rcvD0_buffer>
    3612:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <rcvD0_buffer+0x1>
    3616:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    361a:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    361e:	e8 0f       	add	r30, r24
    3620:	f9 1f       	adc	r31, r25
    3622:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3624:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvD0_write_index>
    3628:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvD0_write_index+0x1>
    362c:	01 96       	adiw	r24, 0x01	; 1
    362e:	84 36       	cpi	r24, 0x64	; 100
    3630:	91 05       	cpc	r25, r1
    3632:	60 f4       	brcc	.+24     	; 0x364c <__vector_88+0x64>
    3634:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <rcvD0_write_index>
    3638:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    363c:	20 91 4c 31 	lds	r18, 0x314C	; 0x80314c <rcvD0_read_index>
    3640:	30 91 4d 31 	lds	r19, 0x314D	; 0x80314d <rcvD0_read_index+0x1>
    3644:	82 17       	cp	r24, r18
    3646:	93 07       	cpc	r25, r19
    3648:	f1 f4       	brne	.+60     	; 0x3686 <__vector_88+0x9e>
    364a:	0c c0       	rjmp	.+24     	; 0x3664 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    364c:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <rcvD0_write_index>
    3650:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3654:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD0_read_index>
    3658:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD0_read_index+0x1>
    365c:	18 16       	cp	r1, r24
    365e:	19 06       	cpc	r1, r25
    3660:	91 f4       	brne	.+36     	; 0x3686 <__vector_88+0x9e>
    3662:	0e c0       	rjmp	.+28     	; 0x3680 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3664:	01 96       	adiw	r24, 0x01	; 1
    3666:	84 36       	cpi	r24, 0x64	; 100
    3668:	91 05       	cpc	r25, r1
    366a:	28 f4       	brcc	.+10     	; 0x3676 <__vector_88+0x8e>
    366c:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvD0_read_index>
    3670:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvD0_read_index+0x1>
    3674:	08 c0       	rjmp	.+16     	; 0x3686 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3676:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvD0_read_index>
    367a:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvD0_read_index+0x1>
}
    367e:	03 c0       	rjmp	.+6      	; 0x3686 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3680:	81 e0       	ldi	r24, 0x01	; 1
    3682:	90 e0       	ldi	r25, 0x00	; 0
    3684:	f3 cf       	rjmp	.-26     	; 0x366c <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3686:	ff 91       	pop	r31
    3688:	ef 91       	pop	r30
    368a:	9f 91       	pop	r25
    368c:	8f 91       	pop	r24
    368e:	3f 91       	pop	r19
    3690:	2f 91       	pop	r18
    3692:	0f 90       	pop	r0
    3694:	0b be       	out	0x3b, r0	; 59
    3696:	0f 90       	pop	r0
    3698:	08 be       	out	0x38, r0	; 56
    369a:	0f 90       	pop	r0
    369c:	0f be       	out	0x3f, r0	; 63
    369e:	0f 90       	pop	r0
    36a0:	1f 90       	pop	r1
    36a2:	18 95       	reti

000036a4 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    36a4:	1f 92       	push	r1
    36a6:	0f 92       	push	r0
    36a8:	0f b6       	in	r0, 0x3f	; 63
    36aa:	0f 92       	push	r0
    36ac:	11 24       	eor	r1, r1
    36ae:	08 b6       	in	r0, 0x38	; 56
    36b0:	0f 92       	push	r0
    36b2:	18 be       	out	0x38, r1	; 56
    36b4:	0b b6       	in	r0, 0x3b	; 59
    36b6:	0f 92       	push	r0
    36b8:	1b be       	out	0x3b, r1	; 59
    36ba:	2f 93       	push	r18
    36bc:	3f 93       	push	r19
    36be:	8f 93       	push	r24
    36c0:	9f 93       	push	r25
    36c2:	ef 93       	push	r30
    36c4:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    36c6:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    36ca:	e0 91 58 31 	lds	r30, 0x3158	; 0x803158 <rcvD1_buffer>
    36ce:	f0 91 59 31 	lds	r31, 0x3159	; 0x803159 <rcvD1_buffer+0x1>
    36d2:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvD1_write_index>
    36d6:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvD1_write_index+0x1>
    36da:	e8 0f       	add	r30, r24
    36dc:	f9 1f       	adc	r31, r25
    36de:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    36e0:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvD1_write_index>
    36e4:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvD1_write_index+0x1>
    36e8:	01 96       	adiw	r24, 0x01	; 1
    36ea:	84 36       	cpi	r24, 0x64	; 100
    36ec:	91 05       	cpc	r25, r1
    36ee:	60 f4       	brcc	.+24     	; 0x3708 <__vector_91+0x64>
    36f0:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <rcvD1_write_index>
    36f4:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    36f8:	20 91 4a 31 	lds	r18, 0x314A	; 0x80314a <rcvD1_read_index>
    36fc:	30 91 4b 31 	lds	r19, 0x314B	; 0x80314b <rcvD1_read_index+0x1>
    3700:	82 17       	cp	r24, r18
    3702:	93 07       	cpc	r25, r19
    3704:	f1 f4       	brne	.+60     	; 0x3742 <__vector_91+0x9e>
    3706:	0c c0       	rjmp	.+24     	; 0x3720 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3708:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rcvD1_write_index>
    370c:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3710:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvD1_read_index>
    3714:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvD1_read_index+0x1>
    3718:	18 16       	cp	r1, r24
    371a:	19 06       	cpc	r1, r25
    371c:	91 f4       	brne	.+36     	; 0x3742 <__vector_91+0x9e>
    371e:	0e c0       	rjmp	.+28     	; 0x373c <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3720:	01 96       	adiw	r24, 0x01	; 1
    3722:	84 36       	cpi	r24, 0x64	; 100
    3724:	91 05       	cpc	r25, r1
    3726:	28 f4       	brcc	.+10     	; 0x3732 <__vector_91+0x8e>
    3728:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <rcvD1_read_index>
    372c:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <rcvD1_read_index+0x1>
    3730:	08 c0       	rjmp	.+16     	; 0x3742 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3732:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <rcvD1_read_index>
    3736:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <rcvD1_read_index+0x1>
}
    373a:	03 c0       	rjmp	.+6      	; 0x3742 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    373c:	81 e0       	ldi	r24, 0x01	; 1
    373e:	90 e0       	ldi	r25, 0x00	; 0
    3740:	f3 cf       	rjmp	.-26     	; 0x3728 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3742:	ff 91       	pop	r31
    3744:	ef 91       	pop	r30
    3746:	9f 91       	pop	r25
    3748:	8f 91       	pop	r24
    374a:	3f 91       	pop	r19
    374c:	2f 91       	pop	r18
    374e:	0f 90       	pop	r0
    3750:	0b be       	out	0x3b, r0	; 59
    3752:	0f 90       	pop	r0
    3754:	08 be       	out	0x38, r0	; 56
    3756:	0f 90       	pop	r0
    3758:	0f be       	out	0x3f, r0	; 63
    375a:	0f 90       	pop	r0
    375c:	1f 90       	pop	r1
    375e:	18 95       	reti

00003760 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3760:	1f 92       	push	r1
    3762:	0f 92       	push	r0
    3764:	0f b6       	in	r0, 0x3f	; 63
    3766:	0f 92       	push	r0
    3768:	11 24       	eor	r1, r1
    376a:	08 b6       	in	r0, 0x38	; 56
    376c:	0f 92       	push	r0
    376e:	18 be       	out	0x38, r1	; 56
    3770:	0b b6       	in	r0, 0x3b	; 59
    3772:	0f 92       	push	r0
    3774:	1b be       	out	0x3b, r1	; 59
    3776:	2f 93       	push	r18
    3778:	3f 93       	push	r19
    377a:	8f 93       	push	r24
    377c:	9f 93       	push	r25
    377e:	ef 93       	push	r30
    3780:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3782:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3786:	e0 91 56 31 	lds	r30, 0x3156	; 0x803156 <rcvE0_buffer>
    378a:	f0 91 57 31 	lds	r31, 0x3157	; 0x803157 <rcvE0_buffer+0x1>
    378e:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvE0_write_index>
    3792:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvE0_write_index+0x1>
    3796:	e8 0f       	add	r30, r24
    3798:	f9 1f       	adc	r31, r25
    379a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    379c:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvE0_write_index>
    37a0:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvE0_write_index+0x1>
    37a4:	01 96       	adiw	r24, 0x01	; 1
    37a6:	84 36       	cpi	r24, 0x64	; 100
    37a8:	91 05       	cpc	r25, r1
    37aa:	60 f4       	brcc	.+24     	; 0x37c4 <__vector_58+0x64>
    37ac:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvE0_write_index>
    37b0:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    37b4:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <rcvE0_read_index>
    37b8:	30 91 49 31 	lds	r19, 0x3149	; 0x803149 <rcvE0_read_index+0x1>
    37bc:	82 17       	cp	r24, r18
    37be:	93 07       	cpc	r25, r19
    37c0:	f1 f4       	brne	.+60     	; 0x37fe <__vector_58+0x9e>
    37c2:	0c c0       	rjmp	.+24     	; 0x37dc <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    37c4:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvE0_write_index>
    37c8:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    37cc:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvE0_read_index>
    37d0:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvE0_read_index+0x1>
    37d4:	18 16       	cp	r1, r24
    37d6:	19 06       	cpc	r1, r25
    37d8:	91 f4       	brne	.+36     	; 0x37fe <__vector_58+0x9e>
    37da:	0e c0       	rjmp	.+28     	; 0x37f8 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    37dc:	01 96       	adiw	r24, 0x01	; 1
    37de:	84 36       	cpi	r24, 0x64	; 100
    37e0:	91 05       	cpc	r25, r1
    37e2:	28 f4       	brcc	.+10     	; 0x37ee <__vector_58+0x8e>
    37e4:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <rcvE0_read_index>
    37e8:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <rcvE0_read_index+0x1>
    37ec:	08 c0       	rjmp	.+16     	; 0x37fe <__vector_58+0x9e>
	rcvE0_read_index = 0;
    37ee:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rcvE0_read_index>
    37f2:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <rcvE0_read_index+0x1>
}
    37f6:	03 c0       	rjmp	.+6      	; 0x37fe <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    37f8:	81 e0       	ldi	r24, 0x01	; 1
    37fa:	90 e0       	ldi	r25, 0x00	; 0
    37fc:	f3 cf       	rjmp	.-26     	; 0x37e4 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    37fe:	ff 91       	pop	r31
    3800:	ef 91       	pop	r30
    3802:	9f 91       	pop	r25
    3804:	8f 91       	pop	r24
    3806:	3f 91       	pop	r19
    3808:	2f 91       	pop	r18
    380a:	0f 90       	pop	r0
    380c:	0b be       	out	0x3b, r0	; 59
    380e:	0f 90       	pop	r0
    3810:	08 be       	out	0x38, r0	; 56
    3812:	0f 90       	pop	r0
    3814:	0f be       	out	0x3f, r0	; 63
    3816:	0f 90       	pop	r0
    3818:	1f 90       	pop	r1
    381a:	18 95       	reti

0000381c <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    381c:	1f 92       	push	r1
    381e:	0f 92       	push	r0
    3820:	0f b6       	in	r0, 0x3f	; 63
    3822:	0f 92       	push	r0
    3824:	11 24       	eor	r1, r1
    3826:	08 b6       	in	r0, 0x38	; 56
    3828:	0f 92       	push	r0
    382a:	18 be       	out	0x38, r1	; 56
    382c:	0b b6       	in	r0, 0x3b	; 59
    382e:	0f 92       	push	r0
    3830:	1b be       	out	0x3b, r1	; 59
    3832:	2f 93       	push	r18
    3834:	3f 93       	push	r19
    3836:	8f 93       	push	r24
    3838:	9f 93       	push	r25
    383a:	ef 93       	push	r30
    383c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    383e:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    3842:	e0 91 54 31 	lds	r30, 0x3154	; 0x803154 <rcvE1_buffer>
    3846:	f0 91 55 31 	lds	r31, 0x3155	; 0x803155 <rcvE1_buffer+0x1>
    384a:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvE1_write_index>
    384e:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvE1_write_index+0x1>
    3852:	e8 0f       	add	r30, r24
    3854:	f9 1f       	adc	r31, r25
    3856:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    3858:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvE1_write_index>
    385c:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvE1_write_index+0x1>
    3860:	01 96       	adiw	r24, 0x01	; 1
    3862:	84 36       	cpi	r24, 0x64	; 100
    3864:	91 05       	cpc	r25, r1
    3866:	60 f4       	brcc	.+24     	; 0x3880 <__vector_61+0x64>
    3868:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvE1_write_index>
    386c:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3870:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <rcvE1_read_index>
    3874:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <rcvE1_read_index+0x1>
    3878:	82 17       	cp	r24, r18
    387a:	93 07       	cpc	r25, r19
    387c:	f1 f4       	brne	.+60     	; 0x38ba <__vector_61+0x9e>
    387e:	0c c0       	rjmp	.+24     	; 0x3898 <__vector_61+0x7c>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    3880:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvE1_write_index>
    3884:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3888:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvE1_read_index>
    388c:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvE1_read_index+0x1>
    3890:	18 16       	cp	r1, r24
    3892:	19 06       	cpc	r1, r25
    3894:	91 f4       	brne	.+36     	; 0x38ba <__vector_61+0x9e>
    3896:	0e c0       	rjmp	.+28     	; 0x38b4 <__vector_61+0x98>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3898:	01 96       	adiw	r24, 0x01	; 1
    389a:	84 36       	cpi	r24, 0x64	; 100
    389c:	91 05       	cpc	r25, r1
    389e:	28 f4       	brcc	.+10     	; 0x38aa <__vector_61+0x8e>
    38a0:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvE1_read_index>
    38a4:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvE1_read_index+0x1>
    38a8:	08 c0       	rjmp	.+16     	; 0x38ba <__vector_61+0x9e>
	rcvE1_read_index = 0;
    38aa:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvE1_read_index>
    38ae:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvE1_read_index+0x1>
}
    38b2:	03 c0       	rjmp	.+6      	; 0x38ba <__vector_61+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    38b4:	81 e0       	ldi	r24, 0x01	; 1
    38b6:	90 e0       	ldi	r25, 0x00	; 0
    38b8:	f3 cf       	rjmp	.-26     	; 0x38a0 <__vector_61+0x84>
	rcvE1_read_index = 0;
}
    38ba:	ff 91       	pop	r31
    38bc:	ef 91       	pop	r30
    38be:	9f 91       	pop	r25
    38c0:	8f 91       	pop	r24
    38c2:	3f 91       	pop	r19
    38c4:	2f 91       	pop	r18
    38c6:	0f 90       	pop	r0
    38c8:	0b be       	out	0x3b, r0	; 59
    38ca:	0f 90       	pop	r0
    38cc:	08 be       	out	0x38, r0	; 56
    38ce:	0f 90       	pop	r0
    38d0:	0f be       	out	0x3f, r0	; 63
    38d2:	0f 90       	pop	r0
    38d4:	1f 90       	pop	r1
    38d6:	18 95       	reti

000038d8 <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    38d8:	1f 92       	push	r1
    38da:	0f 92       	push	r0
    38dc:	0f b6       	in	r0, 0x3f	; 63
    38de:	0f 92       	push	r0
    38e0:	11 24       	eor	r1, r1
    38e2:	08 b6       	in	r0, 0x38	; 56
    38e4:	0f 92       	push	r0
    38e6:	18 be       	out	0x38, r1	; 56
    38e8:	0b b6       	in	r0, 0x3b	; 59
    38ea:	0f 92       	push	r0
    38ec:	1b be       	out	0x3b, r1	; 59
    38ee:	2f 93       	push	r18
    38f0:	3f 93       	push	r19
    38f2:	8f 93       	push	r24
    38f4:	9f 93       	push	r25
    38f6:	ef 93       	push	r30
    38f8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    38fa:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    38fe:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <rcvF0_buffer>
    3902:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <rcvF0_buffer+0x1>
    3906:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvF0_write_index>
    390a:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvF0_write_index+0x1>
    390e:	e8 0f       	add	r30, r24
    3910:	f9 1f       	adc	r31, r25
    3912:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    3914:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvF0_write_index>
    3918:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvF0_write_index+0x1>
    391c:	01 96       	adiw	r24, 0x01	; 1
    391e:	84 36       	cpi	r24, 0x64	; 100
    3920:	91 05       	cpc	r25, r1
    3922:	60 f4       	brcc	.+24     	; 0x393c <__vector_119+0x64>
    3924:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvF0_write_index>
    3928:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    392c:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <rcvF0_read_index>
    3930:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <rcvF0_read_index+0x1>
    3934:	82 17       	cp	r24, r18
    3936:	93 07       	cpc	r25, r19
    3938:	f1 f4       	brne	.+60     	; 0x3976 <__vector_119+0x9e>
    393a:	0c c0       	rjmp	.+24     	; 0x3954 <__vector_119+0x7c>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    393c:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvF0_write_index>
    3940:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3944:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <rcvF0_read_index>
    3948:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <rcvF0_read_index+0x1>
    394c:	18 16       	cp	r1, r24
    394e:	19 06       	cpc	r1, r25
    3950:	91 f4       	brne	.+36     	; 0x3976 <__vector_119+0x9e>
    3952:	0e c0       	rjmp	.+28     	; 0x3970 <__vector_119+0x98>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3954:	01 96       	adiw	r24, 0x01	; 1
    3956:	84 36       	cpi	r24, 0x64	; 100
    3958:	91 05       	cpc	r25, r1
    395a:	28 f4       	brcc	.+10     	; 0x3966 <__vector_119+0x8e>
    395c:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <rcvF0_read_index>
    3960:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <rcvF0_read_index+0x1>
    3964:	08 c0       	rjmp	.+16     	; 0x3976 <__vector_119+0x9e>
	rcvF0_read_index = 0;
    3966:	10 92 44 31 	sts	0x3144, r1	; 0x803144 <rcvF0_read_index>
    396a:	10 92 45 31 	sts	0x3145, r1	; 0x803145 <rcvF0_read_index+0x1>
}
    396e:	03 c0       	rjmp	.+6      	; 0x3976 <__vector_119+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3970:	81 e0       	ldi	r24, 0x01	; 1
    3972:	90 e0       	ldi	r25, 0x00	; 0
    3974:	f3 cf       	rjmp	.-26     	; 0x395c <__vector_119+0x84>
	rcvF0_read_index = 0;
}
    3976:	ff 91       	pop	r31
    3978:	ef 91       	pop	r30
    397a:	9f 91       	pop	r25
    397c:	8f 91       	pop	r24
    397e:	3f 91       	pop	r19
    3980:	2f 91       	pop	r18
    3982:	0f 90       	pop	r0
    3984:	0b be       	out	0x3b, r0	; 59
    3986:	0f 90       	pop	r0
    3988:	08 be       	out	0x38, r0	; 56
    398a:	0f 90       	pop	r0
    398c:	0f be       	out	0x3f, r0	; 63
    398e:	0f 90       	pop	r0
    3990:	1f 90       	pop	r1
    3992:	18 95       	reti

00003994 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3994:	0f 93       	push	r16
    3996:	cf 93       	push	r28
    3998:	df 93       	push	r29
    399a:	1f 92       	push	r1
    399c:	cd b7       	in	r28, 0x3d	; 61
    399e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    39a0:	2f b7       	in	r18, 0x3f	; 63
    39a2:	29 83       	std	Y+1, r18	; 0x01
	cli();
    39a4:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    39a6:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    39a8:	fc 01       	movw	r30, r24
    39aa:	08 ed       	ldi	r16, 0xD8	; 216
    39ac:	04 bf       	out	0x34, r16	; 52
    39ae:	60 83       	st	Z, r22

	SREG = saved_sreg;
    39b0:	89 81       	ldd	r24, Y+1	; 0x01
    39b2:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    39b4:	0f 90       	pop	r0
    39b6:	df 91       	pop	r29
    39b8:	cf 91       	pop	r28
    39ba:	0f 91       	pop	r16
    39bc:	08 95       	ret

000039be <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    39be:	0f 93       	push	r16
    39c0:	1f 93       	push	r17
    39c2:	cf 93       	push	r28
    39c4:	df 93       	push	r29
    39c6:	cd b7       	in	r28, 0x3d	; 61
    39c8:	de b7       	in	r29, 0x3e	; 62
    39ca:	6d 97       	sbiw	r28, 0x1d	; 29
    39cc:	cd bf       	out	0x3d, r28	; 61
    39ce:	de bf       	out	0x3e, r29	; 62
	//Clear any interrupts
	cli();
    39d0:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    39d2:	e0 e5       	ldi	r30, 0x50	; 80
    39d4:	f0 e0       	ldi	r31, 0x00	; 0
    39d6:	80 81       	ld	r24, Z
    39d8:	82 60       	ori	r24, 0x02	; 2
    39da:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    39dc:	81 81       	ldd	r24, Z+1	; 0x01
    39de:	81 ff       	sbrs	r24, 1
    39e0:	fd cf       	rjmp	.-6      	; 0x39dc <main+0x1e>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    39e2:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    39e6:	68 7f       	andi	r22, 0xF8	; 248
    39e8:	61 60       	ori	r22, 0x01	; 1
    39ea:	80 e4       	ldi	r24, 0x40	; 64
    39ec:	90 e0       	ldi	r25, 0x00	; 0
    39ee:	0e 94 ca 1c 	call	0x3994	; 0x3994 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    39f2:	e0 e5       	ldi	r30, 0x50	; 80
    39f4:	f0 e0       	ldi	r31, 0x00	; 0
    39f6:	80 81       	ld	r24, Z
    39f8:	8e 7f       	andi	r24, 0xFE	; 254
    39fa:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    39fc:	9d ef       	ldi	r25, 0xFD	; 253
    39fe:	88 ed       	ldi	r24, 0xD8	; 216
    3a00:	08 b6       	in	r0, 0x38	; 56
    3a02:	18 be       	out	0x38, r1	; 56
    3a04:	84 bf       	out	0x34, r24	; 52
    3a06:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3a0a:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
    3a0c:	40 ea       	ldi	r20, 0xA0	; 160
    3a0e:	58 e0       	ldi	r21, 0x08	; 8
    3a10:	60 e0       	ldi	r22, 0x00	; 0
    3a12:	70 e0       	ldi	r23, 0x00	; 0
    3a14:	ce 01       	movw	r24, r28
    3a16:	01 96       	adiw	r24, 0x01	; 1
    3a18:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3a1c:	67 e0       	ldi	r22, 0x07	; 7
    3a1e:	ce 01       	movw	r24, r28
    3a20:	01 96       	adiw	r24, 0x01	; 1
    3a22:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    3a26:	8c 01       	movw	r16, r24
    3a28:	6b e7       	ldi	r22, 0x7B	; 123
    3a2a:	70 e2       	ldi	r23, 0x20	; 32
    3a2c:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <_ZN8emstream4putsEPKc>
    3a30:	66 e0       	ldi	r22, 0x06	; 6
    3a32:	c8 01       	movw	r24, r16
    3a34:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
    3a38:	66 e0       	ldi	r22, 0x06	; 6
    3a3a:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3a3e:	82 e1       	ldi	r24, 0x12	; 18
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_Znwj>
    3a46:	8e 01       	movw	r16, r28
    3a48:	0f 5f       	subi	r16, 0xFF	; 255
    3a4a:	1f 4f       	sbci	r17, 0xFF	; 255
    3a4c:	24 e0       	ldi	r18, 0x04	; 4
    3a4e:	31 e0       	ldi	r19, 0x01	; 1
    3a50:	40 e0       	ldi	r20, 0x00	; 0
    3a52:	6a e9       	ldi	r22, 0x9A	; 154
    3a54:	70 e2       	ldi	r23, 0x20	; 32
    3a56:	0e 94 ad 04 	call	0x95a	; 0x95a <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(4), 260, &ser_dev);
    3a5a:	82 e1       	ldi	r24, 0x12	; 18
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_Znwj>
    3a62:	24 e0       	ldi	r18, 0x04	; 4
    3a64:	31 e0       	ldi	r19, 0x01	; 1
    3a66:	44 e0       	ldi	r20, 0x04	; 4
    3a68:	62 ea       	ldi	r22, 0xA2	; 162
    3a6a:	70 e2       	ldi	r23, 0x20	; 32
    3a6c:	0e 94 84 03 	call	0x708	; 0x708 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(5), 260, &ser_dev);
    3a70:	82 e1       	ldi	r24, 0x12	; 18
    3a72:	90 e0       	ldi	r25, 0x00	; 0
    3a74:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_Znwj>
    3a78:	24 e0       	ldi	r18, 0x04	; 4
    3a7a:	31 e0       	ldi	r19, 0x01	; 1
    3a7c:	44 e0       	ldi	r20, 0x04	; 4
    3a7e:	69 ea       	ldi	r22, 0xA9	; 169
    3a80:	70 e2       	ldi	r23, 0x20	; 32
    3a82:	0e 94 d5 03 	call	0x7aa	; 0x7aa <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(6), 260, &ser_dev);
    3a86:	82 e1       	ldi	r24, 0x12	; 18
    3a88:	90 e0       	ldi	r25, 0x00	; 0
    3a8a:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_Znwj>
    3a8e:	24 e0       	ldi	r18, 0x04	; 4
    3a90:	31 e0       	ldi	r19, 0x01	; 1
    3a92:	44 e0       	ldi	r20, 0x04	; 4
    3a94:	60 eb       	ldi	r22, 0xB0	; 176
    3a96:	70 e2       	ldi	r23, 0x20	; 32
    3a98:	0e 94 07 04 	call	0x80e	; 0x80e <_ZN13LimitSwitchesC1EPKchjP8emstream>
	
	// The PWMdriver task converts V to a duty cycle
	new PWMdriver ("PWMdrv", task_priority(1), 260, &ser_dev);
    3a9c:	82 e1       	ldi	r24, 0x12	; 18
    3a9e:	90 e0       	ldi	r25, 0x00	; 0
    3aa0:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_Znwj>
    3aa4:	24 e0       	ldi	r18, 0x04	; 4
    3aa6:	31 e0       	ldi	r19, 0x01	; 1
    3aa8:	41 e0       	ldi	r20, 0x01	; 1
    3aaa:	69 eb       	ldi	r22, 0xB9	; 185
    3aac:	70 e2       	ldi	r23, 0x20	; 32
    3aae:	0e 94 9d 04 	call	0x93a	; 0x93a <_ZN9PWMdriverC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(2), 260, &ser_dev);
    3ab2:	8c e3       	ldi	r24, 0x3C	; 60
    3ab4:	90 e0       	ldi	r25, 0x00	; 0
    3ab6:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_Znwj>
    3aba:	24 e0       	ldi	r18, 0x04	; 4
    3abc:	31 e0       	ldi	r19, 0x01	; 1
    3abe:	42 e0       	ldi	r20, 0x02	; 2
    3ac0:	60 ec       	ldi	r22, 0xC0	; 192
    3ac2:	70 e2       	ldi	r23, 0x20	; 32
    3ac4:	0e 94 39 04 	call	0x872	; 0x872 <_ZN5MotorC1EPKchjP8emstream>

	// The pid task takes in the error and determines the actuation signal
	new pid ("PID", task_priority(3), 260, &ser_dev);
    3ac8:	82 e1       	ldi	r24, 0x12	; 18
    3aca:	90 e0       	ldi	r25, 0x00	; 0
    3acc:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_Znwj>
    3ad0:	24 e0       	ldi	r18, 0x04	; 4
    3ad2:	31 e0       	ldi	r19, 0x01	; 1
    3ad4:	43 e0       	ldi	r20, 0x03	; 3
    3ad6:	66 ec       	ldi	r22, 0xC6	; 198
    3ad8:	70 e2       	ldi	r23, 0x20	; 32
    3ada:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <_ZN3pidC1EPKchjP8emstream>

	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3ade:	87 e0       	ldi	r24, 0x07	; 7
    3ae0:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3ae4:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3ae6:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vTaskStartScheduler>
	
	return 0;
    3aea:	80 e0       	ldi	r24, 0x00	; 0
    3aec:	90 e0       	ldi	r25, 0x00	; 0
    3aee:	6d 96       	adiw	r28, 0x1d	; 29
    3af0:	cd bf       	out	0x3d, r28	; 61
    3af2:	de bf       	out	0x3e, r29	; 62
    3af4:	df 91       	pop	r29
    3af6:	cf 91       	pop	r28
    3af8:	1f 91       	pop	r17
    3afa:	0f 91       	pop	r16
    3afc:	08 95       	ret

00003afe <_GLOBAL__sub_I_counter>:
    3afe:	0f 93       	push	r16
    3b00:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3b02:	0a e0       	ldi	r16, 0x0A	; 10
    3b04:	10 e0       	ldi	r17, 0x00	; 0
    3b06:	20 e0       	ldi	r18, 0x00	; 0
    3b08:	30 e0       	ldi	r19, 0x00	; 0
    3b0a:	40 e0       	ldi	r20, 0x00	; 0
    3b0c:	50 e0       	ldi	r21, 0x00	; 0
    3b0e:	60 e2       	ldi	r22, 0x20	; 32
    3b10:	70 e0       	ldi	r23, 0x00	; 0
    3b12:	86 e6       	ldi	r24, 0x66	; 102
    3b14:	91 e3       	ldi	r25, 0x31	; 49
    3b16:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    3b1a:	1f 91       	pop	r17
    3b1c:	0f 91       	pop	r16
    3b1e:	08 95       	ret

00003b20 <__divsf3>:
    3b20:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <__divsf3x>
    3b24:	0c 94 8c 1e 	jmp	0x3d18	; 0x3d18 <__fp_round>
    3b28:	0e 94 85 1e 	call	0x3d0a	; 0x3d0a <__fp_pscB>
    3b2c:	58 f0       	brcs	.+22     	; 0x3b44 <__divsf3+0x24>
    3b2e:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <__fp_pscA>
    3b32:	40 f0       	brcs	.+16     	; 0x3b44 <__divsf3+0x24>
    3b34:	29 f4       	brne	.+10     	; 0x3b40 <__divsf3+0x20>
    3b36:	5f 3f       	cpi	r21, 0xFF	; 255
    3b38:	29 f0       	breq	.+10     	; 0x3b44 <__divsf3+0x24>
    3b3a:	0c 94 75 1e 	jmp	0x3cea	; 0x3cea <__fp_inf>
    3b3e:	51 11       	cpse	r21, r1
    3b40:	0c 94 c0 1e 	jmp	0x3d80	; 0x3d80 <__fp_szero>
    3b44:	0c 94 7b 1e 	jmp	0x3cf6	; 0x3cf6 <__fp_nan>

00003b48 <__divsf3x>:
    3b48:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <__fp_split3>
    3b4c:	68 f3       	brcs	.-38     	; 0x3b28 <__divsf3+0x8>

00003b4e <__divsf3_pse>:
    3b4e:	99 23       	and	r25, r25
    3b50:	b1 f3       	breq	.-20     	; 0x3b3e <__divsf3+0x1e>
    3b52:	55 23       	and	r21, r21
    3b54:	91 f3       	breq	.-28     	; 0x3b3a <__divsf3+0x1a>
    3b56:	95 1b       	sub	r25, r21
    3b58:	55 0b       	sbc	r21, r21
    3b5a:	bb 27       	eor	r27, r27
    3b5c:	aa 27       	eor	r26, r26
    3b5e:	62 17       	cp	r22, r18
    3b60:	73 07       	cpc	r23, r19
    3b62:	84 07       	cpc	r24, r20
    3b64:	38 f0       	brcs	.+14     	; 0x3b74 <__divsf3_pse+0x26>
    3b66:	9f 5f       	subi	r25, 0xFF	; 255
    3b68:	5f 4f       	sbci	r21, 0xFF	; 255
    3b6a:	22 0f       	add	r18, r18
    3b6c:	33 1f       	adc	r19, r19
    3b6e:	44 1f       	adc	r20, r20
    3b70:	aa 1f       	adc	r26, r26
    3b72:	a9 f3       	breq	.-22     	; 0x3b5e <__divsf3_pse+0x10>
    3b74:	35 d0       	rcall	.+106    	; 0x3be0 <__divsf3_pse+0x92>
    3b76:	0e 2e       	mov	r0, r30
    3b78:	3a f0       	brmi	.+14     	; 0x3b88 <__divsf3_pse+0x3a>
    3b7a:	e0 e8       	ldi	r30, 0x80	; 128
    3b7c:	32 d0       	rcall	.+100    	; 0x3be2 <__divsf3_pse+0x94>
    3b7e:	91 50       	subi	r25, 0x01	; 1
    3b80:	50 40       	sbci	r21, 0x00	; 0
    3b82:	e6 95       	lsr	r30
    3b84:	00 1c       	adc	r0, r0
    3b86:	ca f7       	brpl	.-14     	; 0x3b7a <__divsf3_pse+0x2c>
    3b88:	2b d0       	rcall	.+86     	; 0x3be0 <__divsf3_pse+0x92>
    3b8a:	fe 2f       	mov	r31, r30
    3b8c:	29 d0       	rcall	.+82     	; 0x3be0 <__divsf3_pse+0x92>
    3b8e:	66 0f       	add	r22, r22
    3b90:	77 1f       	adc	r23, r23
    3b92:	88 1f       	adc	r24, r24
    3b94:	bb 1f       	adc	r27, r27
    3b96:	26 17       	cp	r18, r22
    3b98:	37 07       	cpc	r19, r23
    3b9a:	48 07       	cpc	r20, r24
    3b9c:	ab 07       	cpc	r26, r27
    3b9e:	b0 e8       	ldi	r27, 0x80	; 128
    3ba0:	09 f0       	breq	.+2      	; 0x3ba4 <__divsf3_pse+0x56>
    3ba2:	bb 0b       	sbc	r27, r27
    3ba4:	80 2d       	mov	r24, r0
    3ba6:	bf 01       	movw	r22, r30
    3ba8:	ff 27       	eor	r31, r31
    3baa:	93 58       	subi	r25, 0x83	; 131
    3bac:	5f 4f       	sbci	r21, 0xFF	; 255
    3bae:	3a f0       	brmi	.+14     	; 0x3bbe <__divsf3_pse+0x70>
    3bb0:	9e 3f       	cpi	r25, 0xFE	; 254
    3bb2:	51 05       	cpc	r21, r1
    3bb4:	78 f0       	brcs	.+30     	; 0x3bd4 <__divsf3_pse+0x86>
    3bb6:	0c 94 75 1e 	jmp	0x3cea	; 0x3cea <__fp_inf>
    3bba:	0c 94 c0 1e 	jmp	0x3d80	; 0x3d80 <__fp_szero>
    3bbe:	5f 3f       	cpi	r21, 0xFF	; 255
    3bc0:	e4 f3       	brlt	.-8      	; 0x3bba <__divsf3_pse+0x6c>
    3bc2:	98 3e       	cpi	r25, 0xE8	; 232
    3bc4:	d4 f3       	brlt	.-12     	; 0x3bba <__divsf3_pse+0x6c>
    3bc6:	86 95       	lsr	r24
    3bc8:	77 95       	ror	r23
    3bca:	67 95       	ror	r22
    3bcc:	b7 95       	ror	r27
    3bce:	f7 95       	ror	r31
    3bd0:	9f 5f       	subi	r25, 0xFF	; 255
    3bd2:	c9 f7       	brne	.-14     	; 0x3bc6 <__divsf3_pse+0x78>
    3bd4:	88 0f       	add	r24, r24
    3bd6:	91 1d       	adc	r25, r1
    3bd8:	96 95       	lsr	r25
    3bda:	87 95       	ror	r24
    3bdc:	97 f9       	bld	r25, 7
    3bde:	08 95       	ret
    3be0:	e1 e0       	ldi	r30, 0x01	; 1
    3be2:	66 0f       	add	r22, r22
    3be4:	77 1f       	adc	r23, r23
    3be6:	88 1f       	adc	r24, r24
    3be8:	bb 1f       	adc	r27, r27
    3bea:	62 17       	cp	r22, r18
    3bec:	73 07       	cpc	r23, r19
    3bee:	84 07       	cpc	r24, r20
    3bf0:	ba 07       	cpc	r27, r26
    3bf2:	20 f0       	brcs	.+8      	; 0x3bfc <__divsf3_pse+0xae>
    3bf4:	62 1b       	sub	r22, r18
    3bf6:	73 0b       	sbc	r23, r19
    3bf8:	84 0b       	sbc	r24, r20
    3bfa:	ba 0b       	sbc	r27, r26
    3bfc:	ee 1f       	adc	r30, r30
    3bfe:	88 f7       	brcc	.-30     	; 0x3be2 <__divsf3_pse+0x94>
    3c00:	e0 95       	com	r30
    3c02:	08 95       	ret

00003c04 <__fixsfsi>:
    3c04:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <__fixunssfsi>
    3c08:	68 94       	set
    3c0a:	b1 11       	cpse	r27, r1
    3c0c:	0c 94 c0 1e 	jmp	0x3d80	; 0x3d80 <__fp_szero>
    3c10:	08 95       	ret

00003c12 <__fixunssfsi>:
    3c12:	0e 94 a5 1e 	call	0x3d4a	; 0x3d4a <__fp_splitA>
    3c16:	88 f0       	brcs	.+34     	; 0x3c3a <__fixunssfsi+0x28>
    3c18:	9f 57       	subi	r25, 0x7F	; 127
    3c1a:	98 f0       	brcs	.+38     	; 0x3c42 <__fixunssfsi+0x30>
    3c1c:	b9 2f       	mov	r27, r25
    3c1e:	99 27       	eor	r25, r25
    3c20:	b7 51       	subi	r27, 0x17	; 23
    3c22:	b0 f0       	brcs	.+44     	; 0x3c50 <__fixunssfsi+0x3e>
    3c24:	e1 f0       	breq	.+56     	; 0x3c5e <__fixunssfsi+0x4c>
    3c26:	66 0f       	add	r22, r22
    3c28:	77 1f       	adc	r23, r23
    3c2a:	88 1f       	adc	r24, r24
    3c2c:	99 1f       	adc	r25, r25
    3c2e:	1a f0       	brmi	.+6      	; 0x3c36 <__fixunssfsi+0x24>
    3c30:	ba 95       	dec	r27
    3c32:	c9 f7       	brne	.-14     	; 0x3c26 <__fixunssfsi+0x14>
    3c34:	14 c0       	rjmp	.+40     	; 0x3c5e <__fixunssfsi+0x4c>
    3c36:	b1 30       	cpi	r27, 0x01	; 1
    3c38:	91 f0       	breq	.+36     	; 0x3c5e <__fixunssfsi+0x4c>
    3c3a:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <__fp_zero>
    3c3e:	b1 e0       	ldi	r27, 0x01	; 1
    3c40:	08 95       	ret
    3c42:	0c 94 bf 1e 	jmp	0x3d7e	; 0x3d7e <__fp_zero>
    3c46:	67 2f       	mov	r22, r23
    3c48:	78 2f       	mov	r23, r24
    3c4a:	88 27       	eor	r24, r24
    3c4c:	b8 5f       	subi	r27, 0xF8	; 248
    3c4e:	39 f0       	breq	.+14     	; 0x3c5e <__fixunssfsi+0x4c>
    3c50:	b9 3f       	cpi	r27, 0xF9	; 249
    3c52:	cc f3       	brlt	.-14     	; 0x3c46 <__fixunssfsi+0x34>
    3c54:	86 95       	lsr	r24
    3c56:	77 95       	ror	r23
    3c58:	67 95       	ror	r22
    3c5a:	b3 95       	inc	r27
    3c5c:	d9 f7       	brne	.-10     	; 0x3c54 <__fixunssfsi+0x42>
    3c5e:	3e f4       	brtc	.+14     	; 0x3c6e <__fixunssfsi+0x5c>
    3c60:	90 95       	com	r25
    3c62:	80 95       	com	r24
    3c64:	70 95       	com	r23
    3c66:	61 95       	neg	r22
    3c68:	7f 4f       	sbci	r23, 0xFF	; 255
    3c6a:	8f 4f       	sbci	r24, 0xFF	; 255
    3c6c:	9f 4f       	sbci	r25, 0xFF	; 255
    3c6e:	08 95       	ret

00003c70 <__floatunsisf>:
    3c70:	e8 94       	clt
    3c72:	09 c0       	rjmp	.+18     	; 0x3c86 <__floatsisf+0x12>

00003c74 <__floatsisf>:
    3c74:	97 fb       	bst	r25, 7
    3c76:	3e f4       	brtc	.+14     	; 0x3c86 <__floatsisf+0x12>
    3c78:	90 95       	com	r25
    3c7a:	80 95       	com	r24
    3c7c:	70 95       	com	r23
    3c7e:	61 95       	neg	r22
    3c80:	7f 4f       	sbci	r23, 0xFF	; 255
    3c82:	8f 4f       	sbci	r24, 0xFF	; 255
    3c84:	9f 4f       	sbci	r25, 0xFF	; 255
    3c86:	99 23       	and	r25, r25
    3c88:	a9 f0       	breq	.+42     	; 0x3cb4 <__floatsisf+0x40>
    3c8a:	f9 2f       	mov	r31, r25
    3c8c:	96 e9       	ldi	r25, 0x96	; 150
    3c8e:	bb 27       	eor	r27, r27
    3c90:	93 95       	inc	r25
    3c92:	f6 95       	lsr	r31
    3c94:	87 95       	ror	r24
    3c96:	77 95       	ror	r23
    3c98:	67 95       	ror	r22
    3c9a:	b7 95       	ror	r27
    3c9c:	f1 11       	cpse	r31, r1
    3c9e:	f8 cf       	rjmp	.-16     	; 0x3c90 <__floatsisf+0x1c>
    3ca0:	fa f4       	brpl	.+62     	; 0x3ce0 <__floatsisf+0x6c>
    3ca2:	bb 0f       	add	r27, r27
    3ca4:	11 f4       	brne	.+4      	; 0x3caa <__floatsisf+0x36>
    3ca6:	60 ff       	sbrs	r22, 0
    3ca8:	1b c0       	rjmp	.+54     	; 0x3ce0 <__floatsisf+0x6c>
    3caa:	6f 5f       	subi	r22, 0xFF	; 255
    3cac:	7f 4f       	sbci	r23, 0xFF	; 255
    3cae:	8f 4f       	sbci	r24, 0xFF	; 255
    3cb0:	9f 4f       	sbci	r25, 0xFF	; 255
    3cb2:	16 c0       	rjmp	.+44     	; 0x3ce0 <__floatsisf+0x6c>
    3cb4:	88 23       	and	r24, r24
    3cb6:	11 f0       	breq	.+4      	; 0x3cbc <__floatsisf+0x48>
    3cb8:	96 e9       	ldi	r25, 0x96	; 150
    3cba:	11 c0       	rjmp	.+34     	; 0x3cde <__floatsisf+0x6a>
    3cbc:	77 23       	and	r23, r23
    3cbe:	21 f0       	breq	.+8      	; 0x3cc8 <__floatsisf+0x54>
    3cc0:	9e e8       	ldi	r25, 0x8E	; 142
    3cc2:	87 2f       	mov	r24, r23
    3cc4:	76 2f       	mov	r23, r22
    3cc6:	05 c0       	rjmp	.+10     	; 0x3cd2 <__floatsisf+0x5e>
    3cc8:	66 23       	and	r22, r22
    3cca:	71 f0       	breq	.+28     	; 0x3ce8 <__floatsisf+0x74>
    3ccc:	96 e8       	ldi	r25, 0x86	; 134
    3cce:	86 2f       	mov	r24, r22
    3cd0:	70 e0       	ldi	r23, 0x00	; 0
    3cd2:	60 e0       	ldi	r22, 0x00	; 0
    3cd4:	2a f0       	brmi	.+10     	; 0x3ce0 <__floatsisf+0x6c>
    3cd6:	9a 95       	dec	r25
    3cd8:	66 0f       	add	r22, r22
    3cda:	77 1f       	adc	r23, r23
    3cdc:	88 1f       	adc	r24, r24
    3cde:	da f7       	brpl	.-10     	; 0x3cd6 <__floatsisf+0x62>
    3ce0:	88 0f       	add	r24, r24
    3ce2:	96 95       	lsr	r25
    3ce4:	87 95       	ror	r24
    3ce6:	97 f9       	bld	r25, 7
    3ce8:	08 95       	ret

00003cea <__fp_inf>:
    3cea:	97 f9       	bld	r25, 7
    3cec:	9f 67       	ori	r25, 0x7F	; 127
    3cee:	80 e8       	ldi	r24, 0x80	; 128
    3cf0:	70 e0       	ldi	r23, 0x00	; 0
    3cf2:	60 e0       	ldi	r22, 0x00	; 0
    3cf4:	08 95       	ret

00003cf6 <__fp_nan>:
    3cf6:	9f ef       	ldi	r25, 0xFF	; 255
    3cf8:	80 ec       	ldi	r24, 0xC0	; 192
    3cfa:	08 95       	ret

00003cfc <__fp_pscA>:
    3cfc:	00 24       	eor	r0, r0
    3cfe:	0a 94       	dec	r0
    3d00:	16 16       	cp	r1, r22
    3d02:	17 06       	cpc	r1, r23
    3d04:	18 06       	cpc	r1, r24
    3d06:	09 06       	cpc	r0, r25
    3d08:	08 95       	ret

00003d0a <__fp_pscB>:
    3d0a:	00 24       	eor	r0, r0
    3d0c:	0a 94       	dec	r0
    3d0e:	12 16       	cp	r1, r18
    3d10:	13 06       	cpc	r1, r19
    3d12:	14 06       	cpc	r1, r20
    3d14:	05 06       	cpc	r0, r21
    3d16:	08 95       	ret

00003d18 <__fp_round>:
    3d18:	09 2e       	mov	r0, r25
    3d1a:	03 94       	inc	r0
    3d1c:	00 0c       	add	r0, r0
    3d1e:	11 f4       	brne	.+4      	; 0x3d24 <__fp_round+0xc>
    3d20:	88 23       	and	r24, r24
    3d22:	52 f0       	brmi	.+20     	; 0x3d38 <__fp_round+0x20>
    3d24:	bb 0f       	add	r27, r27
    3d26:	40 f4       	brcc	.+16     	; 0x3d38 <__fp_round+0x20>
    3d28:	bf 2b       	or	r27, r31
    3d2a:	11 f4       	brne	.+4      	; 0x3d30 <__fp_round+0x18>
    3d2c:	60 ff       	sbrs	r22, 0
    3d2e:	04 c0       	rjmp	.+8      	; 0x3d38 <__fp_round+0x20>
    3d30:	6f 5f       	subi	r22, 0xFF	; 255
    3d32:	7f 4f       	sbci	r23, 0xFF	; 255
    3d34:	8f 4f       	sbci	r24, 0xFF	; 255
    3d36:	9f 4f       	sbci	r25, 0xFF	; 255
    3d38:	08 95       	ret

00003d3a <__fp_split3>:
    3d3a:	57 fd       	sbrc	r21, 7
    3d3c:	90 58       	subi	r25, 0x80	; 128
    3d3e:	44 0f       	add	r20, r20
    3d40:	55 1f       	adc	r21, r21
    3d42:	59 f0       	breq	.+22     	; 0x3d5a <__fp_splitA+0x10>
    3d44:	5f 3f       	cpi	r21, 0xFF	; 255
    3d46:	71 f0       	breq	.+28     	; 0x3d64 <__fp_splitA+0x1a>
    3d48:	47 95       	ror	r20

00003d4a <__fp_splitA>:
    3d4a:	88 0f       	add	r24, r24
    3d4c:	97 fb       	bst	r25, 7
    3d4e:	99 1f       	adc	r25, r25
    3d50:	61 f0       	breq	.+24     	; 0x3d6a <__fp_splitA+0x20>
    3d52:	9f 3f       	cpi	r25, 0xFF	; 255
    3d54:	79 f0       	breq	.+30     	; 0x3d74 <__fp_splitA+0x2a>
    3d56:	87 95       	ror	r24
    3d58:	08 95       	ret
    3d5a:	12 16       	cp	r1, r18
    3d5c:	13 06       	cpc	r1, r19
    3d5e:	14 06       	cpc	r1, r20
    3d60:	55 1f       	adc	r21, r21
    3d62:	f2 cf       	rjmp	.-28     	; 0x3d48 <__fp_split3+0xe>
    3d64:	46 95       	lsr	r20
    3d66:	f1 df       	rcall	.-30     	; 0x3d4a <__fp_splitA>
    3d68:	08 c0       	rjmp	.+16     	; 0x3d7a <__fp_splitA+0x30>
    3d6a:	16 16       	cp	r1, r22
    3d6c:	17 06       	cpc	r1, r23
    3d6e:	18 06       	cpc	r1, r24
    3d70:	99 1f       	adc	r25, r25
    3d72:	f1 cf       	rjmp	.-30     	; 0x3d56 <__fp_splitA+0xc>
    3d74:	86 95       	lsr	r24
    3d76:	71 05       	cpc	r23, r1
    3d78:	61 05       	cpc	r22, r1
    3d7a:	08 94       	sec
    3d7c:	08 95       	ret

00003d7e <__fp_zero>:
    3d7e:	e8 94       	clt

00003d80 <__fp_szero>:
    3d80:	bb 27       	eor	r27, r27
    3d82:	66 27       	eor	r22, r22
    3d84:	77 27       	eor	r23, r23
    3d86:	cb 01       	movw	r24, r22
    3d88:	97 f9       	bld	r25, 7
    3d8a:	08 95       	ret

00003d8c <__mulsf3>:
    3d8c:	0e 94 d9 1e 	call	0x3db2	; 0x3db2 <__mulsf3x>
    3d90:	0c 94 8c 1e 	jmp	0x3d18	; 0x3d18 <__fp_round>
    3d94:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <__fp_pscA>
    3d98:	38 f0       	brcs	.+14     	; 0x3da8 <__mulsf3+0x1c>
    3d9a:	0e 94 85 1e 	call	0x3d0a	; 0x3d0a <__fp_pscB>
    3d9e:	20 f0       	brcs	.+8      	; 0x3da8 <__mulsf3+0x1c>
    3da0:	95 23       	and	r25, r21
    3da2:	11 f0       	breq	.+4      	; 0x3da8 <__mulsf3+0x1c>
    3da4:	0c 94 75 1e 	jmp	0x3cea	; 0x3cea <__fp_inf>
    3da8:	0c 94 7b 1e 	jmp	0x3cf6	; 0x3cf6 <__fp_nan>
    3dac:	11 24       	eor	r1, r1
    3dae:	0c 94 c0 1e 	jmp	0x3d80	; 0x3d80 <__fp_szero>

00003db2 <__mulsf3x>:
    3db2:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <__fp_split3>
    3db6:	70 f3       	brcs	.-36     	; 0x3d94 <__mulsf3+0x8>

00003db8 <__mulsf3_pse>:
    3db8:	95 9f       	mul	r25, r21
    3dba:	c1 f3       	breq	.-16     	; 0x3dac <__mulsf3+0x20>
    3dbc:	95 0f       	add	r25, r21
    3dbe:	50 e0       	ldi	r21, 0x00	; 0
    3dc0:	55 1f       	adc	r21, r21
    3dc2:	62 9f       	mul	r22, r18
    3dc4:	f0 01       	movw	r30, r0
    3dc6:	72 9f       	mul	r23, r18
    3dc8:	bb 27       	eor	r27, r27
    3dca:	f0 0d       	add	r31, r0
    3dcc:	b1 1d       	adc	r27, r1
    3dce:	63 9f       	mul	r22, r19
    3dd0:	aa 27       	eor	r26, r26
    3dd2:	f0 0d       	add	r31, r0
    3dd4:	b1 1d       	adc	r27, r1
    3dd6:	aa 1f       	adc	r26, r26
    3dd8:	64 9f       	mul	r22, r20
    3dda:	66 27       	eor	r22, r22
    3ddc:	b0 0d       	add	r27, r0
    3dde:	a1 1d       	adc	r26, r1
    3de0:	66 1f       	adc	r22, r22
    3de2:	82 9f       	mul	r24, r18
    3de4:	22 27       	eor	r18, r18
    3de6:	b0 0d       	add	r27, r0
    3de8:	a1 1d       	adc	r26, r1
    3dea:	62 1f       	adc	r22, r18
    3dec:	73 9f       	mul	r23, r19
    3dee:	b0 0d       	add	r27, r0
    3df0:	a1 1d       	adc	r26, r1
    3df2:	62 1f       	adc	r22, r18
    3df4:	83 9f       	mul	r24, r19
    3df6:	a0 0d       	add	r26, r0
    3df8:	61 1d       	adc	r22, r1
    3dfa:	22 1f       	adc	r18, r18
    3dfc:	74 9f       	mul	r23, r20
    3dfe:	33 27       	eor	r19, r19
    3e00:	a0 0d       	add	r26, r0
    3e02:	61 1d       	adc	r22, r1
    3e04:	23 1f       	adc	r18, r19
    3e06:	84 9f       	mul	r24, r20
    3e08:	60 0d       	add	r22, r0
    3e0a:	21 1d       	adc	r18, r1
    3e0c:	82 2f       	mov	r24, r18
    3e0e:	76 2f       	mov	r23, r22
    3e10:	6a 2f       	mov	r22, r26
    3e12:	11 24       	eor	r1, r1
    3e14:	9f 57       	subi	r25, 0x7F	; 127
    3e16:	50 40       	sbci	r21, 0x00	; 0
    3e18:	9a f0       	brmi	.+38     	; 0x3e40 <__mulsf3_pse+0x88>
    3e1a:	f1 f0       	breq	.+60     	; 0x3e58 <__mulsf3_pse+0xa0>
    3e1c:	88 23       	and	r24, r24
    3e1e:	4a f0       	brmi	.+18     	; 0x3e32 <__mulsf3_pse+0x7a>
    3e20:	ee 0f       	add	r30, r30
    3e22:	ff 1f       	adc	r31, r31
    3e24:	bb 1f       	adc	r27, r27
    3e26:	66 1f       	adc	r22, r22
    3e28:	77 1f       	adc	r23, r23
    3e2a:	88 1f       	adc	r24, r24
    3e2c:	91 50       	subi	r25, 0x01	; 1
    3e2e:	50 40       	sbci	r21, 0x00	; 0
    3e30:	a9 f7       	brne	.-22     	; 0x3e1c <__mulsf3_pse+0x64>
    3e32:	9e 3f       	cpi	r25, 0xFE	; 254
    3e34:	51 05       	cpc	r21, r1
    3e36:	80 f0       	brcs	.+32     	; 0x3e58 <__mulsf3_pse+0xa0>
    3e38:	0c 94 75 1e 	jmp	0x3cea	; 0x3cea <__fp_inf>
    3e3c:	0c 94 c0 1e 	jmp	0x3d80	; 0x3d80 <__fp_szero>
    3e40:	5f 3f       	cpi	r21, 0xFF	; 255
    3e42:	e4 f3       	brlt	.-8      	; 0x3e3c <__mulsf3_pse+0x84>
    3e44:	98 3e       	cpi	r25, 0xE8	; 232
    3e46:	d4 f3       	brlt	.-12     	; 0x3e3c <__mulsf3_pse+0x84>
    3e48:	86 95       	lsr	r24
    3e4a:	77 95       	ror	r23
    3e4c:	67 95       	ror	r22
    3e4e:	b7 95       	ror	r27
    3e50:	f7 95       	ror	r31
    3e52:	e7 95       	ror	r30
    3e54:	9f 5f       	subi	r25, 0xFF	; 255
    3e56:	c1 f7       	brne	.-16     	; 0x3e48 <__mulsf3_pse+0x90>
    3e58:	fe 2b       	or	r31, r30
    3e5a:	88 0f       	add	r24, r24
    3e5c:	91 1d       	adc	r25, r1
    3e5e:	96 95       	lsr	r25
    3e60:	87 95       	ror	r24
    3e62:	97 f9       	bld	r25, 7
    3e64:	08 95       	ret

00003e66 <__mulsi3>:
    3e66:	db 01       	movw	r26, r22
    3e68:	8f 93       	push	r24
    3e6a:	9f 93       	push	r25
    3e6c:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <__muluhisi3>
    3e70:	bf 91       	pop	r27
    3e72:	af 91       	pop	r26
    3e74:	a2 9f       	mul	r26, r18
    3e76:	80 0d       	add	r24, r0
    3e78:	91 1d       	adc	r25, r1
    3e7a:	a3 9f       	mul	r26, r19
    3e7c:	90 0d       	add	r25, r0
    3e7e:	b2 9f       	mul	r27, r18
    3e80:	90 0d       	add	r25, r0
    3e82:	11 24       	eor	r1, r1
    3e84:	08 95       	ret

00003e86 <__divmodhi4>:
    3e86:	97 fb       	bst	r25, 7
    3e88:	07 2e       	mov	r0, r23
    3e8a:	16 f4       	brtc	.+4      	; 0x3e90 <__divmodhi4+0xa>
    3e8c:	00 94       	com	r0
    3e8e:	07 d0       	rcall	.+14     	; 0x3e9e <__divmodhi4_neg1>
    3e90:	77 fd       	sbrc	r23, 7
    3e92:	09 d0       	rcall	.+18     	; 0x3ea6 <__divmodhi4_neg2>
    3e94:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <__udivmodhi4>
    3e98:	07 fc       	sbrc	r0, 7
    3e9a:	05 d0       	rcall	.+10     	; 0x3ea6 <__divmodhi4_neg2>
    3e9c:	3e f4       	brtc	.+14     	; 0x3eac <__divmodhi4_exit>

00003e9e <__divmodhi4_neg1>:
    3e9e:	90 95       	com	r25
    3ea0:	81 95       	neg	r24
    3ea2:	9f 4f       	sbci	r25, 0xFF	; 255
    3ea4:	08 95       	ret

00003ea6 <__divmodhi4_neg2>:
    3ea6:	70 95       	com	r23
    3ea8:	61 95       	neg	r22
    3eaa:	7f 4f       	sbci	r23, 0xFF	; 255

00003eac <__divmodhi4_exit>:
    3eac:	08 95       	ret

00003eae <__udivmodsi4>:
    3eae:	a1 e2       	ldi	r26, 0x21	; 33
    3eb0:	1a 2e       	mov	r1, r26
    3eb2:	aa 1b       	sub	r26, r26
    3eb4:	bb 1b       	sub	r27, r27
    3eb6:	fd 01       	movw	r30, r26
    3eb8:	0d c0       	rjmp	.+26     	; 0x3ed4 <__udivmodsi4_ep>

00003eba <__udivmodsi4_loop>:
    3eba:	aa 1f       	adc	r26, r26
    3ebc:	bb 1f       	adc	r27, r27
    3ebe:	ee 1f       	adc	r30, r30
    3ec0:	ff 1f       	adc	r31, r31
    3ec2:	a2 17       	cp	r26, r18
    3ec4:	b3 07       	cpc	r27, r19
    3ec6:	e4 07       	cpc	r30, r20
    3ec8:	f5 07       	cpc	r31, r21
    3eca:	20 f0       	brcs	.+8      	; 0x3ed4 <__udivmodsi4_ep>
    3ecc:	a2 1b       	sub	r26, r18
    3ece:	b3 0b       	sbc	r27, r19
    3ed0:	e4 0b       	sbc	r30, r20
    3ed2:	f5 0b       	sbc	r31, r21

00003ed4 <__udivmodsi4_ep>:
    3ed4:	66 1f       	adc	r22, r22
    3ed6:	77 1f       	adc	r23, r23
    3ed8:	88 1f       	adc	r24, r24
    3eda:	99 1f       	adc	r25, r25
    3edc:	1a 94       	dec	r1
    3ede:	69 f7       	brne	.-38     	; 0x3eba <__udivmodsi4_loop>
    3ee0:	60 95       	com	r22
    3ee2:	70 95       	com	r23
    3ee4:	80 95       	com	r24
    3ee6:	90 95       	com	r25
    3ee8:	9b 01       	movw	r18, r22
    3eea:	ac 01       	movw	r20, r24
    3eec:	bd 01       	movw	r22, r26
    3eee:	cf 01       	movw	r24, r30
    3ef0:	08 95       	ret

00003ef2 <__divmodsi4>:
    3ef2:	05 2e       	mov	r0, r21
    3ef4:	97 fb       	bst	r25, 7
    3ef6:	1e f4       	brtc	.+6      	; 0x3efe <__divmodsi4+0xc>
    3ef8:	00 94       	com	r0
    3efa:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <__negsi2>
    3efe:	57 fd       	sbrc	r21, 7
    3f00:	07 d0       	rcall	.+14     	; 0x3f10 <__divmodsi4_neg2>
    3f02:	0e 94 57 1f 	call	0x3eae	; 0x3eae <__udivmodsi4>
    3f06:	07 fc       	sbrc	r0, 7
    3f08:	03 d0       	rcall	.+6      	; 0x3f10 <__divmodsi4_neg2>
    3f0a:	4e f4       	brtc	.+18     	; 0x3f1e <__divmodsi4_exit>
    3f0c:	0c 94 90 1f 	jmp	0x3f20	; 0x3f20 <__negsi2>

00003f10 <__divmodsi4_neg2>:
    3f10:	50 95       	com	r21
    3f12:	40 95       	com	r20
    3f14:	30 95       	com	r19
    3f16:	21 95       	neg	r18
    3f18:	3f 4f       	sbci	r19, 0xFF	; 255
    3f1a:	4f 4f       	sbci	r20, 0xFF	; 255
    3f1c:	5f 4f       	sbci	r21, 0xFF	; 255

00003f1e <__divmodsi4_exit>:
    3f1e:	08 95       	ret

00003f20 <__negsi2>:
    3f20:	90 95       	com	r25
    3f22:	80 95       	com	r24
    3f24:	70 95       	com	r23
    3f26:	61 95       	neg	r22
    3f28:	7f 4f       	sbci	r23, 0xFF	; 255
    3f2a:	8f 4f       	sbci	r24, 0xFF	; 255
    3f2c:	9f 4f       	sbci	r25, 0xFF	; 255
    3f2e:	08 95       	ret

00003f30 <__tablejump2__>:
    3f30:	ee 0f       	add	r30, r30
    3f32:	ff 1f       	adc	r31, r31
    3f34:	88 1f       	adc	r24, r24
    3f36:	8b bf       	out	0x3b, r24	; 59
    3f38:	07 90       	elpm	r0, Z+
    3f3a:	f6 91       	elpm	r31, Z
    3f3c:	e0 2d       	mov	r30, r0
    3f3e:	1b be       	out	0x3b, r1	; 59
    3f40:	19 94       	eijmp

00003f42 <__muluhisi3>:
    3f42:	0e 94 c0 1f 	call	0x3f80	; 0x3f80 <__umulhisi3>
    3f46:	a5 9f       	mul	r26, r21
    3f48:	90 0d       	add	r25, r0
    3f4a:	b4 9f       	mul	r27, r20
    3f4c:	90 0d       	add	r25, r0
    3f4e:	a4 9f       	mul	r26, r20
    3f50:	80 0d       	add	r24, r0
    3f52:	91 1d       	adc	r25, r1
    3f54:	11 24       	eor	r1, r1
    3f56:	08 95       	ret

00003f58 <__udivmodhi4>:
    3f58:	aa 1b       	sub	r26, r26
    3f5a:	bb 1b       	sub	r27, r27
    3f5c:	51 e1       	ldi	r21, 0x11	; 17
    3f5e:	07 c0       	rjmp	.+14     	; 0x3f6e <__udivmodhi4_ep>

00003f60 <__udivmodhi4_loop>:
    3f60:	aa 1f       	adc	r26, r26
    3f62:	bb 1f       	adc	r27, r27
    3f64:	a6 17       	cp	r26, r22
    3f66:	b7 07       	cpc	r27, r23
    3f68:	10 f0       	brcs	.+4      	; 0x3f6e <__udivmodhi4_ep>
    3f6a:	a6 1b       	sub	r26, r22
    3f6c:	b7 0b       	sbc	r27, r23

00003f6e <__udivmodhi4_ep>:
    3f6e:	88 1f       	adc	r24, r24
    3f70:	99 1f       	adc	r25, r25
    3f72:	5a 95       	dec	r21
    3f74:	a9 f7       	brne	.-22     	; 0x3f60 <__udivmodhi4_loop>
    3f76:	80 95       	com	r24
    3f78:	90 95       	com	r25
    3f7a:	bc 01       	movw	r22, r24
    3f7c:	cd 01       	movw	r24, r26
    3f7e:	08 95       	ret

00003f80 <__umulhisi3>:
    3f80:	a2 9f       	mul	r26, r18
    3f82:	b0 01       	movw	r22, r0
    3f84:	b3 9f       	mul	r27, r19
    3f86:	c0 01       	movw	r24, r0
    3f88:	a3 9f       	mul	r26, r19
    3f8a:	70 0d       	add	r23, r0
    3f8c:	81 1d       	adc	r24, r1
    3f8e:	11 24       	eor	r1, r1
    3f90:	91 1d       	adc	r25, r1
    3f92:	b2 9f       	mul	r27, r18
    3f94:	70 0d       	add	r23, r0
    3f96:	81 1d       	adc	r24, r1
    3f98:	11 24       	eor	r1, r1
    3f9a:	91 1d       	adc	r25, r1
    3f9c:	08 95       	ret

00003f9e <memcpy>:
    3f9e:	fb 01       	movw	r30, r22
    3fa0:	dc 01       	movw	r26, r24
    3fa2:	02 c0       	rjmp	.+4      	; 0x3fa8 <memcpy+0xa>
    3fa4:	01 90       	ld	r0, Z+
    3fa6:	0d 92       	st	X+, r0
    3fa8:	41 50       	subi	r20, 0x01	; 1
    3faa:	50 40       	sbci	r21, 0x00	; 0
    3fac:	d8 f7       	brcc	.-10     	; 0x3fa4 <memcpy+0x6>
    3fae:	08 95       	ret

00003fb0 <memset>:
    3fb0:	dc 01       	movw	r26, r24
    3fb2:	01 c0       	rjmp	.+2      	; 0x3fb6 <memset+0x6>
    3fb4:	6d 93       	st	X+, r22
    3fb6:	41 50       	subi	r20, 0x01	; 1
    3fb8:	50 40       	sbci	r21, 0x00	; 0
    3fba:	e0 f7       	brcc	.-8      	; 0x3fb4 <memset+0x4>
    3fbc:	08 95       	ret

00003fbe <strncpy>:
    3fbe:	fb 01       	movw	r30, r22
    3fc0:	dc 01       	movw	r26, r24
    3fc2:	41 50       	subi	r20, 0x01	; 1
    3fc4:	50 40       	sbci	r21, 0x00	; 0
    3fc6:	48 f0       	brcs	.+18     	; 0x3fda <strncpy+0x1c>
    3fc8:	01 90       	ld	r0, Z+
    3fca:	0d 92       	st	X+, r0
    3fcc:	00 20       	and	r0, r0
    3fce:	c9 f7       	brne	.-14     	; 0x3fc2 <strncpy+0x4>
    3fd0:	01 c0       	rjmp	.+2      	; 0x3fd4 <strncpy+0x16>
    3fd2:	1d 92       	st	X+, r1
    3fd4:	41 50       	subi	r20, 0x01	; 1
    3fd6:	50 40       	sbci	r21, 0x00	; 0
    3fd8:	e0 f7       	brcc	.-8      	; 0x3fd2 <strncpy+0x14>
    3fda:	08 95       	ret

00003fdc <ultoa>:
    3fdc:	25 32       	cpi	r18, 0x25	; 37
    3fde:	31 05       	cpc	r19, r1
    3fe0:	20 f4       	brcc	.+8      	; 0x3fea <ultoa+0xe>
    3fe2:	22 30       	cpi	r18, 0x02	; 2
    3fe4:	10 f0       	brcs	.+4      	; 0x3fea <ultoa+0xe>
    3fe6:	0c 94 f9 1f 	jmp	0x3ff2	; 0x3ff2 <__ultoa_ncheck>
    3fea:	fa 01       	movw	r30, r20
    3fec:	10 82       	st	Z, r1
    3fee:	ca 01       	movw	r24, r20
    3ff0:	08 95       	ret

00003ff2 <__ultoa_ncheck>:
    3ff2:	bb 27       	eor	r27, r27

00003ff4 <__ultoa_common>:
    3ff4:	fa 01       	movw	r30, r20
    3ff6:	a6 2f       	mov	r26, r22
    3ff8:	62 17       	cp	r22, r18
    3ffa:	71 05       	cpc	r23, r1
    3ffc:	81 05       	cpc	r24, r1
    3ffe:	91 05       	cpc	r25, r1
    4000:	33 0b       	sbc	r19, r19
    4002:	30 fb       	bst	r19, 0
    4004:	66 f0       	brts	.+24     	; 0x401e <__stack+0x1f>
    4006:	aa 27       	eor	r26, r26
    4008:	66 0f       	add	r22, r22
    400a:	77 1f       	adc	r23, r23
    400c:	88 1f       	adc	r24, r24
    400e:	99 1f       	adc	r25, r25
    4010:	aa 1f       	adc	r26, r26
    4012:	a2 17       	cp	r26, r18
    4014:	10 f0       	brcs	.+4      	; 0x401a <__stack+0x1b>
    4016:	a2 1b       	sub	r26, r18
    4018:	63 95       	inc	r22
    401a:	38 50       	subi	r19, 0x08	; 8
    401c:	a9 f7       	brne	.-22     	; 0x4008 <__stack+0x9>
    401e:	a0 5d       	subi	r26, 0xD0	; 208
    4020:	aa 33       	cpi	r26, 0x3A	; 58
    4022:	08 f0       	brcs	.+2      	; 0x4026 <__stack+0x27>
    4024:	a9 5d       	subi	r26, 0xD9	; 217
    4026:	a1 93       	st	Z+, r26
    4028:	36 f7       	brtc	.-52     	; 0x3ff6 <__ultoa_common+0x2>
    402a:	b1 11       	cpse	r27, r1
    402c:	b1 93       	st	Z+, r27
    402e:	10 82       	st	Z, r1
    4030:	ca 01       	movw	r24, r20
    4032:	0c 94 40 20 	jmp	0x4080	; 0x4080 <strrev>

00004036 <utoa>:
    4036:	45 32       	cpi	r20, 0x25	; 37
    4038:	51 05       	cpc	r21, r1
    403a:	20 f4       	brcc	.+8      	; 0x4044 <utoa+0xe>
    403c:	42 30       	cpi	r20, 0x02	; 2
    403e:	10 f0       	brcs	.+4      	; 0x4044 <utoa+0xe>
    4040:	0c 94 26 20 	jmp	0x404c	; 0x404c <__utoa_ncheck>
    4044:	fb 01       	movw	r30, r22
    4046:	10 82       	st	Z, r1
    4048:	cb 01       	movw	r24, r22
    404a:	08 95       	ret

0000404c <__utoa_ncheck>:
    404c:	bb 27       	eor	r27, r27

0000404e <__utoa_common>:
    404e:	fb 01       	movw	r30, r22
    4050:	55 27       	eor	r21, r21
    4052:	aa 27       	eor	r26, r26
    4054:	88 0f       	add	r24, r24
    4056:	99 1f       	adc	r25, r25
    4058:	aa 1f       	adc	r26, r26
    405a:	a4 17       	cp	r26, r20
    405c:	10 f0       	brcs	.+4      	; 0x4062 <__utoa_common+0x14>
    405e:	a4 1b       	sub	r26, r20
    4060:	83 95       	inc	r24
    4062:	50 51       	subi	r21, 0x10	; 16
    4064:	b9 f7       	brne	.-18     	; 0x4054 <__utoa_common+0x6>
    4066:	a0 5d       	subi	r26, 0xD0	; 208
    4068:	aa 33       	cpi	r26, 0x3A	; 58
    406a:	08 f0       	brcs	.+2      	; 0x406e <__utoa_common+0x20>
    406c:	a9 5d       	subi	r26, 0xD9	; 217
    406e:	a1 93       	st	Z+, r26
    4070:	00 97       	sbiw	r24, 0x00	; 0
    4072:	79 f7       	brne	.-34     	; 0x4052 <__utoa_common+0x4>
    4074:	b1 11       	cpse	r27, r1
    4076:	b1 93       	st	Z+, r27
    4078:	11 92       	st	Z+, r1
    407a:	cb 01       	movw	r24, r22
    407c:	0c 94 40 20 	jmp	0x4080	; 0x4080 <strrev>

00004080 <strrev>:
    4080:	dc 01       	movw	r26, r24
    4082:	fc 01       	movw	r30, r24
    4084:	67 2f       	mov	r22, r23
    4086:	71 91       	ld	r23, Z+
    4088:	77 23       	and	r23, r23
    408a:	e1 f7       	brne	.-8      	; 0x4084 <strrev+0x4>
    408c:	32 97       	sbiw	r30, 0x02	; 2
    408e:	04 c0       	rjmp	.+8      	; 0x4098 <strrev+0x18>
    4090:	7c 91       	ld	r23, X
    4092:	6d 93       	st	X+, r22
    4094:	70 83       	st	Z, r23
    4096:	62 91       	ld	r22, -Z
    4098:	ae 17       	cp	r26, r30
    409a:	bf 07       	cpc	r27, r31
    409c:	c8 f3       	brcs	.-14     	; 0x4090 <strrev+0x10>
    409e:	08 95       	ret

000040a0 <_exit>:
    40a0:	f8 94       	cli

000040a2 <__stop_program>:
    40a2:	ff cf       	rjmp	.-2      	; 0x40a2 <__stop_program>
