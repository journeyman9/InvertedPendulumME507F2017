
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000411a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  0000411a  000041ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020bc  008020bc  0000426a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000426a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000429c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006e8  00000000  00000000  000042dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012321  00000000  00000000  000049c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000666d  00000000  00000000  00016ce5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000544d  00000000  00000000  0001d352  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012dc  00000000  00000000  000227a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000061fe  00000000  00000000  00023a7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e66  00000000  00000000  00029c7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000590  00000000  00000000  0002fae0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a9 02 	jmp	0x552	; 0x552 <__ctors_end>
       4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      10:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      14:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      18:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      1c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      20:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      24:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      28:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      2c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      30:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      34:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      38:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      3c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      40:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      44:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      48:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      4c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      50:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      54:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      58:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      5c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      60:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      64:	0c 94 4b 1c 	jmp	0x3896	; 0x3896 <__vector_25>
      68:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      6c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      70:	0c 94 a9 1c 	jmp	0x3952	; 0x3952 <__vector_28>
      74:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      78:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      7c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      80:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      84:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      88:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      8c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      90:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      94:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      98:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      9c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c4:	0c 94 3c 0c 	jmp	0x1878	; 0x1878 <__vector_49>
      c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e8:	0c 94 c3 1d 	jmp	0x3b86	; 0x3b86 <__vector_58>
      ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      fc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     100:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     104:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     108:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     10c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     110:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     114:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     118:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     11c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     120:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     124:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     128:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     12c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     130:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     134:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     138:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     13c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     140:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     144:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     148:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     14c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     150:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     154:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     158:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     15c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     160:	0c 94 07 1d 	jmp	0x3a0e	; 0x3a0e <__vector_88>
     164:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     168:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     16c:	0c 94 65 1d 	jmp	0x3aca	; 0x3aca <__vector_91>
     170:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     174:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     178:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     17c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     180:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     184:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     188:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     18c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     190:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     194:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     198:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     19c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1fc:	0e 1a       	sub	r0, r30
     1fe:	11 1a       	sub	r1, r17
     200:	14 1a       	sub	r1, r20
     202:	17 1a       	sub	r1, r23
     204:	1a 1a       	sub	r1, r26
     206:	1d 1a       	sub	r1, r29
     208:	1f 1a       	sub	r1, r31
     20a:	30 1a       	sub	r3, r16
     20c:	38 1a       	sub	r3, r24
     20e:	42 1a       	sub	r4, r18
     210:	40 1a       	sub	r4, r16

00000212 <__trampolines_start>:
     212:	0c 94 af 1b 	jmp	0x375e	; 0x375e <_ZN5rs23214check_for_charEv>
     216:	0c 94 d0 1e 	jmp	0x3da0	; 0x3da0 <_GLOBAL__sub_I_counter>
     21a:	0c 94 0e 1a 	jmp	0x341c	; 0x341c <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21e:	0c 94 39 17 	jmp	0x2e72	; 0x2e72 <_ZN14frt_text_queue7getcharEv>
     222:	0c 94 b9 19 	jmp	0x3372	; 0x3372 <_ZN8emstream12clear_screenEv>
     226:	0c 94 b3 19 	jmp	0x3366	; 0x3366 <_ZN8emstream7getcharEv>
     22a:	0c 94 18 08 	jmp	0x1030	; 0x1030 <_ZN9task_user3runEv>
     22e:	0c 94 11 1a 	jmp	0x3422	; 0x3422 <_ZN8emstreamlsE15ser_manipulator+0x24>
     232:	0c 94 b6 19 	jmp	0x336c	; 0x336c <_ZN8emstream14check_for_charEv>
     236:	0c 94 b8 19 	jmp	0x3370	; 0x3370 <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 42 1a 	jmp	0x3484	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
     23e:	0c 94 1a 1a 	jmp	0x3434	; 0x3434 <_ZN8emstreamlsE15ser_manipulator+0x36>
     242:	0c 94 39 04 	jmp	0x872	; 0x872 <_ZN5Motor3runEv>
     246:	0c 94 62 17 	jmp	0x2ec4	; 0x2ec4 <_ZN14frt_text_queue7putcharEc>
     24a:	0c 94 c0 0e 	jmp	0x1d80	; 0x1d80 <prvIdleTask>
     24e:	0c 94 1a 19 	jmp	0x3234	; 0x3234 <__cxa_pure_virtual>
     252:	0c 94 d4 03 	jmp	0x7a8	; 0x7a8 <_ZN13LimitSwitches3runEv>
     256:	0c 94 64 03 	jmp	0x6c8	; 0x6c8 <_ZN15EncoderPendulum3runEv>
     25a:	0c 94 a6 02 	jmp	0x54c	; 0x54c <_call_static_run_method>
     25e:	0c 94 57 17 	jmp	0x2eae	; 0x2eae <_ZN14frt_text_queue14check_for_charEv>
     262:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator+0x40>
     266:	0c 94 b1 19 	jmp	0x3362	; 0x3362 <_ZN8emstream13ready_to_sendEv>
     26a:	0c 94 40 1a 	jmp	0x3480	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x82>
     26e:	0c 94 38 1a 	jmp	0x3470	; 0x3470 <_ZN8emstreamlsE15ser_manipulator+0x72>
     272:	0c 94 ef 15 	jmp	0x2bde	; 0x2bde <_ZN8frt_task12print_statusER8emstream>
     276:	0c 94 17 1a 	jmp	0x342e	; 0x342e <_ZN8emstreamlsE15ser_manipulator+0x30>
     27a:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_ZN12EncoderMotor3runEv>
     27e:	0c 94 65 1b 	jmp	0x36ca	; 0x36ca <_ZN5rs2327putcharEc>
     282:	0c 94 1d 1a 	jmp	0x343a	; 0x343a <_ZN8emstreamlsE15ser_manipulator+0x3c>
     286:	0c 94 30 1a 	jmp	0x3460	; 0x3460 <_ZN8emstreamlsE15ser_manipulator+0x62>
     28a:	0c 94 c2 1b 	jmp	0x3784	; 0x3784 <_ZN5rs23212clear_screenEv>
     28e:	0c 94 31 06 	jmp	0xc62	; 0xc62 <_ZN9PWMdriver3runEv>
     292:	0c 94 14 1a 	jmp	0x3428	; 0x3428 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     296:	0c 94 89 1b 	jmp	0x3712	; 0x3712 <_ZN5rs2327getcharEv>

0000029a <__trampolines_end>:
     29a:	2c 20       	and	r2, r12
     29c:	54 43       	sbci	r21, 0x34	; 52
     29e:	43 30       	cpi	r20, 0x03	; 3
     2a0:	43 43       	sbci	r20, 0x33	; 51
     2a2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a5 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a5:	2f 00                                               /.

000002a7 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b5:	54 69 6d 65 3a 20 00                                Time: .

000002bc <_ZZN9task_user11show_statusEvE3__c_0>:
     2bc:	44 65 63 20 20 35 20 32 30 31 37 00                 Dec  5 2017.

000002c8 <_ZZN9task_user11show_statusEvE3__c>:
     2c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     306:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000311 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     311:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     321:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34f:	6d 61 74 69 6f 6e 00                                mation.

00000356 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     356:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     366:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000377 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     377:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     387:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003ab <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3ab:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bb:	68 65 20 41 56 52 00                                he AVR.

000003c2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c2:	20 68 65 6c 70 00                                    help.

000003c8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e7 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e7:	1b 5b 33 30 6d 00                                   .[30m.

000003ed <_ZZN9task_user18print_help_messageEvE3__c>:
     3ed:	1b 5b 34 36 6d 00                                   .[46m.

000003f3 <_ZZN9task_user3runEvE3__c_3>:
     3f3:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     403:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000410 <_ZZN9task_user3runEvE3__c_2>:
     410:	3a 57 54 46 3f 00                                   :WTF?.

00000416 <_ZZN9task_user3runEvE3__c_1>:
     416:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     426:	65 00                                               e.

00000428 <_ZZN9task_user3runEvE3__c_0>:
     428:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000436 <_ZZN9task_user3runEvE3__c>:
     436:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     446:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000454 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     454:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045e <_ZZN8frt_task15emergency_resetEvE3__c>:
     45e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000046d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     46d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     47d:	61 73 6b 20 00                                      ask .

00000482 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     482:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000490 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     490:	20 63 72 65 61 74 65 64 00                           created.

00000499 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     499:	54 61 73 6b 20 00                                   Task .

0000049f <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49f:	1b 5b 32 32 6d 00                                   .[22m.

000004a5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a5:	54 61 73 6b 3a 20 00                                Task: .

000004ac <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4ac:	1b 5b 31 6d 00                                      .[1m.

000004b1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b1:	1b 5b 32 32 6d 00                                   .[22m.

000004b7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c2:	1b 5b 31 6d 00                                      .[1m.

000004c7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c7:	09 09 00                                            ...

000004ca <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ca:	2f 00                                               /.

000004cc <_ZZ15print_task_listP8emstreamE3__c_7>:
     4cc:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d7:	09 2d 2d 2d 2d 00                                   .----.

000004dd <_ZZ15print_task_listP8emstreamE3__c_5>:
     4dd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e9 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e9:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fa <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fa:	09 52 75 6e 73 00                                   .Runs.

00000500 <_ZZ15print_task_listP8emstreamE3__c_2>:
     500:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000050c <_ZZ15print_task_listP8emstreamE3__c_1>:
     50c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000051d <_ZZ15print_task_listP8emstreamE3__c_0>:
     51d:	09 53 74 61 63 6b 00                                .Stack.

00000524 <_ZZ15print_task_listP8emstreamE3__c>:
     524:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52f:	09 00                                               ..

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     533:	2f 00                                               /.

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     537:	09 00                                               ..

00000539 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53f:	1b 5b 31 6d 00                                      .[1m.

00000544 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     544:	1b 5b 31 6d 00                                      .[1m.

00000549 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     549:	20 20 00                                              .

0000054c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     54c:	0e 94 87 14 	call	0x290e	; 0x290e <_ZN8frt_task22_call_users_run_methodEPS_>

00000550 <__ctors_start>:
     550:	d0 1e       	adc	r13, r16

00000552 <__ctors_end>:
     552:	11 24       	eor	r1, r1
     554:	1f be       	out	0x3f, r1	; 63
     556:	cf ef       	ldi	r28, 0xFF	; 255
     558:	cd bf       	out	0x3d, r28	; 61
     55a:	df e3       	ldi	r29, 0x3F	; 63
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	00 e0       	ldi	r16, 0x00	; 0
     560:	0c bf       	out	0x3c, r16	; 60
     562:	18 be       	out	0x38, r1	; 56
     564:	19 be       	out	0x39, r1	; 57
     566:	1a be       	out	0x3a, r1	; 58
     568:	1b be       	out	0x3b, r1	; 59

0000056a <__do_copy_data>:
     56a:	10 e2       	ldi	r17, 0x20	; 32
     56c:	a0 e0       	ldi	r26, 0x00	; 0
     56e:	b0 e2       	ldi	r27, 0x20	; 32
     570:	ea e1       	ldi	r30, 0x1A	; 26
     572:	f1 e4       	ldi	r31, 0x41	; 65
     574:	00 e0       	ldi	r16, 0x00	; 0
     576:	0b bf       	out	0x3b, r16	; 59
     578:	02 c0       	rjmp	.+4      	; 0x57e <__do_copy_data+0x14>
     57a:	07 90       	elpm	r0, Z+
     57c:	0d 92       	st	X+, r0
     57e:	ac 3b       	cpi	r26, 0xBC	; 188
     580:	b1 07       	cpc	r27, r17
     582:	d9 f7       	brne	.-10     	; 0x57a <__do_copy_data+0x10>
     584:	1b be       	out	0x3b, r1	; 59

00000586 <__do_clear_bss>:
     586:	21 e3       	ldi	r18, 0x31	; 49
     588:	ac eb       	ldi	r26, 0xBC	; 188
     58a:	b0 e2       	ldi	r27, 0x20	; 32
     58c:	01 c0       	rjmp	.+2      	; 0x590 <.do_clear_bss_start>

0000058e <.do_clear_bss_loop>:
     58e:	1d 92       	st	X+, r1

00000590 <.do_clear_bss_start>:
     590:	a2 36       	cpi	r26, 0x62	; 98
     592:	b2 07       	cpc	r27, r18
     594:	e1 f7       	brne	.-8      	; 0x58e <.do_clear_bss_loop>

00000596 <__do_global_ctors>:
     596:	12 e0       	ldi	r17, 0x02	; 2
     598:	c9 ea       	ldi	r28, 0xA9	; 169
     59a:	d2 e0       	ldi	r29, 0x02	; 2
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	06 c0       	rjmp	.+12     	; 0x5ac <__do_global_ctors+0x16>
     5a0:	21 97       	sbiw	r28, 0x01	; 1
     5a2:	01 09       	sbc	r16, r1
     5a4:	80 2f       	mov	r24, r16
     5a6:	fe 01       	movw	r30, r28
     5a8:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <__tablejump2__>
     5ac:	c8 3a       	cpi	r28, 0xA8	; 168
     5ae:	d1 07       	cpc	r29, r17
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	08 07       	cpc	r16, r24
     5b4:	a9 f7       	brne	.-22     	; 0x5a0 <__do_global_ctors+0xa>
     5b6:	0e 94 36 1e 	call	0x3c6c	; 0x3c6c <main>
     5ba:	0c 94 8b 20 	jmp	0x4116	; 0x4116 <_exit>

000005be <__bad_interrupt>:
     5be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c2 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	00 d0       	rcall	.+0      	; 0x5c8 <_ZN12EncoderMotor3runEv+0x6>
     5c8:	1f 92       	push	r1
     5ca:	cd b7       	in	r28, 0x3d	; 61
     5cc:	de b7       	in	r29, 0x3e	; 62
     5ce:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d0:	0e 94 5f 10 	call	0x20be	; 0x20be <xTaskGetTickCount>
     5d4:	69 83       	std	Y+1, r22	; 0x01
     5d6:	7a 83       	std	Y+2, r23	; 0x02
     5d8:	8b 83       	std	Y+3, r24	; 0x03
     5da:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5dc:	e0 e8       	ldi	r30, 0x80	; 128
     5de:	f6 e0       	ldi	r31, 0x06	; 6
     5e0:	8c e0       	ldi	r24, 0x0C	; 12
     5e2:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e4:	82 89       	ldd	r24, Z+18	; 0x12
     5e6:	83 60       	ori	r24, 0x03	; 3
     5e8:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ea:	83 89       	ldd	r24, Z+19	; 0x13
     5ec:	83 60       	ori	r24, 0x03	; 3
     5ee:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5f0:	e0 e8       	ldi	r30, 0x80	; 128
     5f2:	f1 e0       	ldi	r31, 0x01	; 1
     5f4:	82 e7       	ldi	r24, 0x72	; 114
     5f6:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f8:	89 e0       	ldi	r24, 0x09	; 9
     5fa:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5fc:	e0 e0       	ldi	r30, 0x00	; 0
     5fe:	f9 e0       	ldi	r31, 0x09	; 9
     600:	88 e6       	ldi	r24, 0x68	; 104
     602:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     604:	8f ef       	ldi	r24, 0xFF	; 255
     606:	9f ef       	ldi	r25, 0xFF	; 255
     608:	86 a3       	std	Z+38, r24	; 0x26
     60a:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     60c:	81 e0       	ldi	r24, 0x01	; 1
     60e:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     610:	0f 2e       	mov	r0, r31
     612:	a1 2c       	mov	r10, r1
     614:	f9 e0       	ldi	r31, 0x09	; 9
     616:	bf 2e       	mov	r11, r31
     618:	f0 2d       	mov	r31, r0
     61a:	f5 01       	movw	r30, r10
     61c:	00 a1       	ldd	r16, Z+32	; 0x20
     61e:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     620:	0f b6       	in	r0, 0x3f	; 63
     622:	f8 94       	cli
     624:	0f 92       	push	r0
			the_data = new_data;
     626:	c8 01       	movw	r24, r16
     628:	01 2e       	mov	r0, r17
     62a:	00 0c       	add	r0, r0
     62c:	aa 0b       	sbc	r26, r26
     62e:	bb 0b       	sbc	r27, r27
     630:	ac 01       	movw	r20, r24
     632:	bd 01       	movw	r22, r26
     634:	44 0f       	add	r20, r20
     636:	55 1f       	adc	r21, r21
     638:	66 1f       	adc	r22, r22
     63a:	77 1f       	adc	r23, r23
     63c:	3a 01       	movw	r6, r20
     63e:	4b 01       	movw	r8, r22
     640:	68 0e       	add	r6, r24
     642:	79 1e       	adc	r7, r25
     644:	8a 1e       	adc	r8, r26
     646:	9b 1e       	adc	r9, r27
     648:	c4 01       	movw	r24, r8
     64a:	b3 01       	movw	r22, r6
     64c:	24 e6       	ldi	r18, 0x64	; 100
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	40 e0       	ldi	r20, 0x00	; 0
     652:	50 e0       	ldi	r21, 0x00	; 0
     654:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <__divmodsi4>
     658:	20 93 4e 31 	sts	0x314E, r18	; 0x80314e <linear_position>
     65c:	30 93 4f 31 	sts	0x314F, r19	; 0x80314f <linear_position+0x1>
			portEXIT_CRITICAL ();
     660:	0f 90       	pop	r0
     662:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     664:	0f b6       	in	r0, 0x3f	; 63
     666:	f8 94       	cli
     668:	0f 92       	push	r0
			the_data = new_data;
     66a:	c8 01       	movw	r24, r16
     66c:	8c 19       	sub	r24, r12
     66e:	9d 09       	sbc	r25, r13
     670:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <thdMotor>
     674:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     678:	0f 90       	pop	r0
     67a:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     67c:	f7 01       	movw	r30, r14
     67e:	86 85       	ldd	r24, Z+14	; 0x0e
     680:	97 85       	ldd	r25, Z+15	; 0x0f
     682:	a0 89       	ldd	r26, Z+16	; 0x10
     684:	b1 89       	ldd	r27, Z+17	; 0x11
     686:	01 96       	adiw	r24, 0x01	; 1
     688:	a1 1d       	adc	r26, r1
     68a:	b1 1d       	adc	r27, r1
     68c:	86 87       	std	Z+14, r24	; 0x0e
     68e:	97 87       	std	Z+15, r25	; 0x0f
     690:	a0 8b       	std	Z+16, r26	; 0x10
     692:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     694:	41 e0       	ldi	r20, 0x01	; 1
     696:	50 e0       	ldi	r21, 0x00	; 0
     698:	60 e0       	ldi	r22, 0x00	; 0
     69a:	70 e0       	ldi	r23, 0x00	; 0
     69c:	ce 01       	movw	r24, r28
     69e:	01 96       	adiw	r24, 0x01	; 1
     6a0:	0e 94 fd 11 	call	0x23fa	; 0x23fa <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6a4:	68 01       	movw	r12, r16
     6a6:	b9 cf       	rjmp	.-142    	; 0x61a <_ZN12EncoderMotor3runEv+0x58>

000006a8 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     6a8:	0f 93       	push	r16
     6aa:	1f 93       	push	r17
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
     6b0:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6b2:	0e 94 9a 14 	call	0x2934	; 0x2934 <_ZN8frt_taskC1EPKchjP8emstream>
     6b6:	8a e0       	ldi	r24, 0x0A	; 10
     6b8:	90 e2       	ldi	r25, 0x20	; 32
     6ba:	88 83       	st	Y, r24
     6bc:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	1f 91       	pop	r17
     6c4:	0f 91       	pop	r16
     6c6:	08 95       	ret

000006c8 <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	00 d0       	rcall	.+0      	; 0x6ce <_ZN15EncoderPendulum3runEv+0x6>
     6ce:	1f 92       	push	r1
     6d0:	cd b7       	in	r28, 0x3d	; 61
     6d2:	de b7       	in	r29, 0x3e	; 62
     6d4:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6d6:	0e 94 5f 10 	call	0x20be	; 0x20be <xTaskGetTickCount>
     6da:	69 83       	std	Y+1, r22	; 0x01
     6dc:	7a 83       	std	Y+2, r23	; 0x02
     6de:	8b 83       	std	Y+3, r24	; 0x03
     6e0:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     6e2:	e0 e8       	ldi	r30, 0x80	; 128
     6e4:	f6 e0       	ldi	r31, 0x06	; 6
     6e6:	83 e0       	ldi	r24, 0x03	; 3
     6e8:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     6ea:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     6ec:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     6ee:	e0 e8       	ldi	r30, 0x80	; 128
     6f0:	f1 e0       	ldi	r31, 0x01	; 1
     6f2:	80 e7       	ldi	r24, 0x70	; 112
     6f4:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     6f6:	89 e0       	ldi	r24, 0x09	; 9
     6f8:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     6fa:	e0 e4       	ldi	r30, 0x40	; 64
     6fc:	f8 e0       	ldi	r31, 0x08	; 8
     6fe:	8a e6       	ldi	r24, 0x6A	; 106
     700:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     702:	80 ea       	ldi	r24, 0xA0	; 160
     704:	95 e0       	ldi	r25, 0x05	; 5
     706:	86 a3       	std	Z+38, r24	; 0x26
     708:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     70e:	68 94       	set
     710:	ee 24       	eor	r14, r14
     712:	e6 f8       	bld	r14, 6
     714:	ff 24       	eor	r15, r15
     716:	f3 f8       	bld	r15, 3
     718:	f7 01       	movw	r30, r14
     71a:	a0 a1       	ldd	r26, Z+32	; 0x20
     71c:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     71e:	0f b6       	in	r0, 0x3f	; 63
     720:	f8 94       	cli
     722:	0f 92       	push	r0
			the_data = new_data;
     724:	24 e6       	ldi	r18, 0x64	; 100
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__usmulhisi3>
     72c:	4b 01       	movw	r8, r22
     72e:	5c 01       	movw	r10, r24
     730:	99 23       	and	r25, r25
     732:	2c f4       	brge	.+10     	; 0x73e <_ZN15EncoderPendulum3runEv+0x76>
     734:	f3 e0       	ldi	r31, 0x03	; 3
     736:	8f 0e       	add	r8, r31
     738:	91 1c       	adc	r9, r1
     73a:	a1 1c       	adc	r10, r1
     73c:	b1 1c       	adc	r11, r1
     73e:	d5 01       	movw	r26, r10
     740:	c4 01       	movw	r24, r8
     742:	b5 95       	asr	r27
     744:	a7 95       	ror	r26
     746:	97 95       	ror	r25
     748:	87 95       	ror	r24
     74a:	b5 95       	asr	r27
     74c:	a7 95       	ror	r26
     74e:	97 95       	ror	r25
     750:	87 95       	ror	r24
     752:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <thPendulum>
     756:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <thPendulum+0x1>
			portEXIT_CRITICAL ();
     75a:	0f 90       	pop	r0
     75c:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     75e:	f8 01       	movw	r30, r16
     760:	86 85       	ldd	r24, Z+14	; 0x0e
     762:	97 85       	ldd	r25, Z+15	; 0x0f
     764:	a0 89       	ldd	r26, Z+16	; 0x10
     766:	b1 89       	ldd	r27, Z+17	; 0x11
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	a1 1d       	adc	r26, r1
     76c:	b1 1d       	adc	r27, r1
     76e:	86 87       	std	Z+14, r24	; 0x0e
     770:	97 87       	std	Z+15, r25	; 0x0f
     772:	a0 8b       	std	Z+16, r26	; 0x10
     774:	b1 8b       	std	Z+17, r27	; 0x11
     776:	45 e0       	ldi	r20, 0x05	; 5
     778:	50 e0       	ldi	r21, 0x00	; 0
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	70 e0       	ldi	r23, 0x00	; 0
     77e:	ce 01       	movw	r24, r28
     780:	01 96       	adiw	r24, 0x01	; 1
     782:	0e 94 fd 11 	call	0x23fa	; 0x23fa <vTaskDelayUntil>
     786:	c8 cf       	rjmp	.-112    	; 0x718 <_ZN15EncoderPendulum3runEv+0x50>

00000788 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     788:	0f 93       	push	r16
     78a:	1f 93       	push	r17
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     792:	0e 94 9a 14 	call	0x2934	; 0x2934 <_ZN8frt_taskC1EPKchjP8emstream>
     796:	82 e1       	ldi	r24, 0x12	; 18
     798:	90 e2       	ldi	r25, 0x20	; 32
     79a:	88 83       	st	Y, r24
     79c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	1f 91       	pop	r17
     7a4:	0f 91       	pop	r16
     7a6:	08 95       	ret

000007a8 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	00 d0       	rcall	.+0      	; 0x7ae <_ZN13LimitSwitches3runEv+0x6>
     7ae:	1f 92       	push	r1
     7b0:	cd b7       	in	r28, 0x3d	; 61
     7b2:	de b7       	in	r29, 0x3e	; 62
     7b4:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7b6:	0e 94 5f 10 	call	0x20be	; 0x20be <xTaskGetTickCount>
     7ba:	69 83       	std	Y+1, r22	; 0x01
     7bc:	7a 83       	std	Y+2, r23	; 0x02
     7be:	8b 83       	std	Y+3, r24	; 0x03
     7c0:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     7c2:	e0 e6       	ldi	r30, 0x60	; 96
     7c4:	f6 e0       	ldi	r31, 0x06	; 6
     7c6:	81 e0       	ldi	r24, 0x01	; 1
     7c8:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     7ca:	84 e0       	ldi	r24, 0x04	; 4
     7cc:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     7ce:	88 e1       	ldi	r24, 0x18	; 24
     7d0:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     7d2:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     7d4:	08 e6       	ldi	r16, 0x68	; 104
     7d6:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     7d8:	dd 24       	eor	r13, r13
     7da:	d3 94       	inc	r13
     7dc:	f8 01       	movw	r30, r16
     7de:	80 81       	ld	r24, Z
     7e0:	80 fd       	sbrc	r24, 0
     7e2:	08 c0       	rjmp	.+16     	; 0x7f4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	f8 94       	cli
     7e8:	0f 92       	push	r0
			the_data = new_data;
     7ea:	d0 92 49 31 	sts	0x3149, r13	; 0x803149 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7ee:	0f 90       	pop	r0
     7f0:	0f be       	out	0x3f, r0	; 63
     7f2:	07 c0       	rjmp	.+14     	; 0x802 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7f4:	0f b6       	in	r0, 0x3f	; 63
     7f6:	f8 94       	cli
     7f8:	0f 92       	push	r0
			the_data = new_data;
     7fa:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
			*/

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     802:	f8 01       	movw	r30, r16
     804:	80 81       	ld	r24, Z
     806:	82 fd       	sbrc	r24, 2
     808:	08 c0       	rjmp	.+16     	; 0x81a <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	0f 92       	push	r0
			the_data = new_data;
     810:	d0 92 48 31 	sts	0x3148, r13	; 0x803148 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     814:	0f 90       	pop	r0
     816:	0f be       	out	0x3f, r0	; 63
     818:	07 c0       	rjmp	.+14     	; 0x828 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     81a:	0f b6       	in	r0, 0x3f	; 63
     81c:	f8 94       	cli
     81e:	0f 92       	push	r0
			the_data = new_data;
     820:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     824:	0f 90       	pop	r0
     826:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     828:	f7 01       	movw	r30, r14
     82a:	86 85       	ldd	r24, Z+14	; 0x0e
     82c:	97 85       	ldd	r25, Z+15	; 0x0f
     82e:	a0 89       	ldd	r26, Z+16	; 0x10
     830:	b1 89       	ldd	r27, Z+17	; 0x11
     832:	01 96       	adiw	r24, 0x01	; 1
     834:	a1 1d       	adc	r26, r1
     836:	b1 1d       	adc	r27, r1
     838:	86 87       	std	Z+14, r24	; 0x0e
     83a:	97 87       	std	Z+15, r25	; 0x0f
     83c:	a0 8b       	std	Z+16, r26	; 0x10
     83e:	b1 8b       	std	Z+17, r27	; 0x11
     840:	45 e0       	ldi	r20, 0x05	; 5
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	70 e0       	ldi	r23, 0x00	; 0
     848:	ce 01       	movw	r24, r28
     84a:	01 96       	adiw	r24, 0x01	; 1
     84c:	0e 94 fd 11 	call	0x23fa	; 0x23fa <vTaskDelayUntil>
     850:	c5 cf       	rjmp	.-118    	; 0x7dc <_ZN13LimitSwitches3runEv+0x34>

00000852 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     852:	0f 93       	push	r16
     854:	1f 93       	push	r17
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     85c:	0e 94 9a 14 	call	0x2934	; 0x2934 <_ZN8frt_taskC1EPKchjP8emstream>
     860:	8a e1       	ldi	r24, 0x1A	; 26
     862:	90 e2       	ldi	r25, 0x20	; 32
     864:	88 83       	st	Y, r24
     866:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	1f 91       	pop	r17
     86e:	0f 91       	pop	r16
     870:	08 95       	ret

00000872 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	66 97       	sbiw	r28, 0x16	; 22
     87c:	cd bf       	out	0x3d, r28	; 61
     87e:	de bf       	out	0x3e, r29	; 62
     880:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     882:	0e 94 5f 10 	call	0x20be	; 0x20be <xTaskGetTickCount>
     886:	69 83       	std	Y+1, r22	; 0x01
     888:	7a 83       	std	Y+2, r23	; 0x02
     88a:	8b 83       	std	Y+3, r24	; 0x03
     88c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 5; // [ms]
     88e:	f8 01       	movw	r30, r16
     890:	fe 96       	adiw	r30, 0x3e	; 62
     892:	85 e0       	ldi	r24, 0x05	; 5
     894:	90 e0       	ldi	r25, 0x00	; 0
     896:	a0 e0       	ldi	r26, 0x00	; 0
     898:	b0 e0       	ldi	r27, 0x00	; 0
     89a:	80 83       	st	Z, r24
     89c:	91 83       	std	Z+1, r25	; 0x01
     89e:	a2 83       	std	Z+2, r26	; 0x02
     8a0:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     8a2:	81 e0       	ldi	r24, 0x01	; 1
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	f8 01       	movw	r30, r16
     8a8:	84 af       	std	Z+60, r24	; 0x3c
     8aa:	95 af       	std	Z+61, r25	; 0x3d
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 7;
     8ac:	98 01       	movw	r18, r16
     8ae:	28 5b       	subi	r18, 0xB8	; 184
     8b0:	3f 4f       	sbci	r19, 0xFF	; 255
     8b2:	2d 83       	std	Y+5, r18	; 0x05
     8b4:	3e 83       	std	Y+6, r19	; 0x06
     8b6:	37 e0       	ldi	r19, 0x07	; 7
     8b8:	3d 8b       	std	Y+21, r19	; 0x15
     8ba:	1e 8a       	std	Y+22, r1	; 0x16
		_Ki = .7*256;
     8bc:	a8 01       	movw	r20, r16
     8be:	44 5b       	subi	r20, 0xB4	; 180
     8c0:	5f 4f       	sbci	r21, 0xFF	; 255
     8c2:	4f 83       	std	Y+7, r20	; 0x07
     8c4:	58 87       	std	Y+8, r21	; 0x08
		_Kd = 0;
     8c6:	c8 01       	movw	r24, r16
     8c8:	86 5b       	subi	r24, 0xB6	; 182
     8ca:	9f 4f       	sbci	r25, 0xFF	; 255
     8cc:	8f 87       	std	Y+15, r24	; 0x0f
     8ce:	98 8b       	std	Y+16, r25	; 0x10
		antiwind_gain = .95*256;
     8d0:	ec 59       	subi	r30, 0x9C	; 156
     8d2:	ff 4f       	sbci	r31, 0xFF	; 255
     8d4:	e9 87       	std	Y+9, r30	; 0x09
     8d6:	fa 87       	std	Y+10, r31	; 0x0a
		
		_max = 1600;
     8d8:	98 01       	movw	r18, r16
     8da:	2c 5b       	subi	r18, 0xBC	; 188
     8dc:	3f 4f       	sbci	r19, 0xFF	; 255
     8de:	2b 87       	std	Y+11, r18	; 0x0b
     8e0:	3c 87       	std	Y+12, r19	; 0x0c
		_min = -1600;
     8e2:	46 50       	subi	r20, 0x06	; 6
     8e4:	51 09       	sbc	r21, r1
     8e6:	4d 87       	std	Y+13, r20	; 0x0d
     8e8:	5e 87       	std	Y+14, r21	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     8ea:	42 96       	adiw	r24, 0x12	; 18
     8ec:	89 8b       	std	Y+17, r24	; 0x11
     8ee:	9a 8b       	std	Y+18, r25	; 0x12

		// Integral term
		error_int = error - antiwind_correct;
     8f0:	18 01       	movw	r2, r16
     8f2:	96 e6       	ldi	r25, 0x66	; 102
     8f4:	29 0e       	add	r2, r25
     8f6:	31 1c       	adc	r3, r1
     8f8:	34 96       	adiw	r30, 0x04	; 4
     8fa:	eb 8b       	std	Y+19, r30	; 0x13
     8fc:	fc 8b       	std	Y+20, r31	; 0x14
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     8fe:	48 01       	movw	r8, r16
     900:	fe e3       	ldi	r31, 0x3E	; 62
     902:	8f 0e       	add	r8, r31
     904:	91 1c       	adc	r9, r1
     906:	58 01       	movw	r10, r16
     908:	20 e5       	ldi	r18, 0x50	; 80
     90a:	a2 0e       	add	r10, r18
     90c:	b1 1c       	adc	r11, r1

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);

		output_correct = output;
     90e:	68 01       	movw	r12, r16
     910:	3e e5       	ldi	r19, 0x5E	; 94
     912:	c3 0e       	add	r12, r19
     914:	d1 1c       	adc	r13, r1
	dt = 5; // [ms]
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     916:	f8 01       	movw	r30, r16
     918:	86 85       	ldd	r24, Z+14	; 0x0e
     91a:	97 85       	ldd	r25, Z+15	; 0x0f
     91c:	a0 89       	ldd	r26, Z+16	; 0x10
     91e:	b1 89       	ldd	r27, Z+17	; 0x11
     920:	01 96       	adiw	r24, 0x01	; 1
     922:	a1 1d       	adc	r26, r1
     924:	b1 1d       	adc	r27, r1
     926:	86 87       	std	Z+14, r24	; 0x0e
     928:	97 87       	std	Z+15, r25	; 0x0f
     92a:	a0 8b       	std	Z+16, r26	; 0x10
     92c:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
		omegam_set = 100; // [ticks/ms]
     92e:	24 e6       	ldi	r18, 0x64	; 100
     930:	30 e0       	ldi	r19, 0x00	; 0
     932:	22 8f       	std	Z+26, r18	; 0x1a
     934:	33 8f       	std	Z+27, r19	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     936:	0f b6       	in	r0, 0x3f	; 63
     938:	f8 94       	cli
     93a:	0f 92       	push	r0
			temporary_copy = the_data;
     93c:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <thdMotor>
     940:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     944:	0f 90       	pop	r0
     946:	0f be       	out	0x3f, r0	; 63

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     948:	86 8f       	std	Z+30, r24	; 0x1e
     94a:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 7;
     94c:	4d 89       	ldd	r20, Y+21	; 0x15
     94e:	ed 81       	ldd	r30, Y+5	; 0x05
     950:	fe 81       	ldd	r31, Y+6	; 0x06
     952:	40 83       	st	Z, r20
     954:	5e 89       	ldd	r21, Y+22	; 0x16
     956:	51 83       	std	Z+1, r21	; 0x01
		_Ki = .7*256;
     958:	43 eb       	ldi	r20, 0xB3	; 179
     95a:	50 e0       	ldi	r21, 0x00	; 0
     95c:	ef 81       	ldd	r30, Y+7	; 0x07
     95e:	f8 85       	ldd	r31, Y+8	; 0x08
     960:	40 83       	st	Z, r20
     962:	51 83       	std	Z+1, r21	; 0x01
		_Kd = 0;
     964:	ef 85       	ldd	r30, Y+15	; 0x0f
     966:	f8 89       	ldd	r31, Y+16	; 0x10
     968:	10 82       	st	Z, r1
     96a:	11 82       	std	Z+1, r1	; 0x01
		antiwind_gain = .95*256;
     96c:	43 ef       	ldi	r20, 0xF3	; 243
     96e:	50 e0       	ldi	r21, 0x00	; 0
     970:	e9 85       	ldd	r30, Y+9	; 0x09
     972:	fa 85       	ldd	r31, Y+10	; 0x0a
     974:	40 83       	st	Z, r20
     976:	51 83       	std	Z+1, r21	; 0x01
		
		_max = 1600;
     978:	40 e4       	ldi	r20, 0x40	; 64
     97a:	56 e0       	ldi	r21, 0x06	; 6
     97c:	eb 85       	ldd	r30, Y+11	; 0x0b
     97e:	fc 85       	ldd	r31, Y+12	; 0x0c
     980:	40 83       	st	Z, r20
     982:	51 83       	std	Z+1, r21	; 0x01
		_min = -1600;
     984:	40 ec       	ldi	r20, 0xC0	; 192
     986:	59 ef       	ldi	r21, 0xF9	; 249
     988:	ed 85       	ldd	r30, Y+13	; 0x0d
     98a:	fe 85       	ldd	r31, Y+14	; 0x0e
     98c:	40 83       	st	Z, r20
     98e:	51 83       	std	Z+1, r21	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     990:	79 01       	movw	r14, r18
     992:	e8 1a       	sub	r14, r24
     994:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     996:	b7 01       	movw	r22, r14
     998:	87 e0       	ldi	r24, 0x07	; 7
     99a:	90 e0       	ldi	r25, 0x00	; 0
     99c:	0e 94 c3 06 	call	0xd86	; 0xd86 <_ZN7satmath20signed_saturated_mulEii>
     9a0:	2b 01       	movw	r4, r22
     9a2:	3c 01       	movw	r6, r24
     9a4:	e9 89       	ldd	r30, Y+17	; 0x11
     9a6:	fa 89       	ldd	r31, Y+18	; 0x12
     9a8:	60 83       	st	Z, r22
     9aa:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     9ac:	f1 01       	movw	r30, r2
     9ae:	80 81       	ld	r24, Z
     9b0:	91 81       	ldd	r25, Z+1	; 0x01
     9b2:	97 01       	movw	r18, r14
     9b4:	28 1b       	sub	r18, r24
     9b6:	39 0b       	sbc	r19, r25
     9b8:	c9 01       	movw	r24, r18
     9ba:	eb 89       	ldd	r30, Y+19	; 0x13
     9bc:	fc 89       	ldd	r31, Y+20	; 0x14
     9be:	20 83       	st	Z, r18
     9c0:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     9c2:	ef 81       	ldd	r30, Y+7	; 0x07
     9c4:	f8 85       	ldd	r31, Y+8	; 0x08
     9c6:	20 81       	ld	r18, Z
     9c8:	31 81       	ldd	r19, Z+1	; 0x01
     9ca:	82 9f       	mul	r24, r18
     9cc:	d0 01       	movw	r26, r0
     9ce:	83 9f       	mul	r24, r19
     9d0:	b0 0d       	add	r27, r0
     9d2:	92 9f       	mul	r25, r18
     9d4:	b0 0d       	add	r27, r0
     9d6:	11 24       	eor	r1, r1
     9d8:	f8 01       	movw	r30, r16
     9da:	e6 59       	subi	r30, 0x96	; 150
     9dc:	ff 4f       	sbci	r31, 0xFF	; 255
     9de:	a0 83       	st	Z, r26
     9e0:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     9e2:	f4 01       	movw	r30, r8
     9e4:	20 81       	ld	r18, Z
     9e6:	31 81       	ldd	r19, Z+1	; 0x01
     9e8:	42 81       	ldd	r20, Z+2	; 0x02
     9ea:	53 81       	ldd	r21, Z+3	; 0x03
     9ec:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <__mulshisi3>
     9f0:	9b 01       	movw	r18, r22
     9f2:	ac 01       	movw	r20, r24
     9f4:	99 23       	and	r25, r25
     9f6:	24 f4       	brge	.+8      	; 0xa00 <_ZN5Motor3runEv+0x18e>
     9f8:	21 50       	subi	r18, 0x01	; 1
     9fa:	3f 4f       	sbci	r19, 0xFF	; 255
     9fc:	4f 4f       	sbci	r20, 0xFF	; 255
     9fe:	5f 4f       	sbci	r21, 0xFF	; 255
     a00:	bb 27       	eor	r27, r27
     a02:	57 fd       	sbrc	r21, 7
     a04:	ba 95       	dec	r27
     a06:	a5 2f       	mov	r26, r21
     a08:	94 2f       	mov	r25, r20
     a0a:	83 2f       	mov	r24, r19
     a0c:	f5 01       	movw	r30, r10
     a0e:	40 81       	ld	r20, Z
     a10:	51 81       	ldd	r21, Z+1	; 0x01
     a12:	62 81       	ldd	r22, Z+2	; 0x02
     a14:	73 81       	ldd	r23, Z+3	; 0x03
     a16:	84 0f       	add	r24, r20
     a18:	95 1f       	adc	r25, r21
     a1a:	a6 1f       	adc	r26, r22
     a1c:	b7 1f       	adc	r27, r23
		if(_integral < 1000000000)
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
     a1e:	81 30       	cpi	r24, 0x01	; 1
     a20:	fa ec       	ldi	r31, 0xCA	; 202
     a22:	9f 07       	cpc	r25, r31
     a24:	fa e9       	ldi	r31, 0x9A	; 154
     a26:	af 07       	cpc	r26, r31
     a28:	fb e3       	ldi	r31, 0x3B	; 59
     a2a:	bf 07       	cpc	r27, r31
     a2c:	34 f4       	brge	.+12     	; 0xa3a <_ZN5Motor3runEv+0x1c8>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     a2e:	f5 01       	movw	r30, r10
     a30:	80 83       	st	Z, r24
     a32:	91 83       	std	Z+1, r25	; 0x01
     a34:	a2 83       	std	Z+2, r26	; 0x02
     a36:	b3 83       	std	Z+3, r27	; 0x03
     a38:	09 c0       	rjmp	.+18     	; 0xa4c <_ZN5Motor3runEv+0x1da>
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
		{
			_integral = 1000000000;
     a3a:	80 e0       	ldi	r24, 0x00	; 0
     a3c:	9a ec       	ldi	r25, 0xCA	; 202
     a3e:	aa e9       	ldi	r26, 0x9A	; 154
     a40:	bb e3       	ldi	r27, 0x3B	; 59
     a42:	f5 01       	movw	r30, r10
     a44:	80 83       	st	Z, r24
     a46:	91 83       	std	Z+1, r25	; 0x01
     a48:	a2 83       	std	Z+2, r26	; 0x02
     a4a:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     a4c:	f5 01       	movw	r30, r10
     a4e:	60 81       	ld	r22, Z
     a50:	71 81       	ldd	r23, Z+1	; 0x01
     a52:	c2 01       	movw	r24, r4
     a54:	0e 94 a7 06 	call	0xd4e	; 0xd4e <_ZN7satmath20signed_saturated_addEii>
     a58:	f8 01       	movw	r30, r16
     a5a:	e0 5a       	subi	r30, 0xA0	; 160
     a5c:	ff 4f       	sbci	r31, 0xFF	; 255
     a5e:	80 83       	st	Z, r24
     a60:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     a62:	f6 01       	movw	r30, r12
     a64:	80 83       	st	Z, r24
     a66:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     a68:	eb 85       	ldd	r30, Y+11	; 0x0b
     a6a:	fc 85       	ldd	r31, Y+12	; 0x0c
     a6c:	20 81       	ld	r18, Z
     a6e:	31 81       	ldd	r19, Z+1	; 0x01
     a70:	28 17       	cp	r18, r24
     a72:	39 07       	cpc	r19, r25
     a74:	24 f4       	brge	.+8      	; 0xa7e <_ZN5Motor3runEv+0x20c>
		output_correct = _max;
     a76:	f6 01       	movw	r30, r12
     a78:	20 83       	st	Z, r18
     a7a:	31 83       	std	Z+1, r19	; 0x01
     a7c:	0a c0       	rjmp	.+20     	; 0xa92 <_ZN5Motor3runEv+0x220>
		else if( output_correct < _min )
     a7e:	ed 85       	ldd	r30, Y+13	; 0x0d
     a80:	fe 85       	ldd	r31, Y+14	; 0x0e
     a82:	20 81       	ld	r18, Z
     a84:	31 81       	ldd	r19, Z+1	; 0x01
     a86:	82 17       	cp	r24, r18
     a88:	93 07       	cpc	r25, r19
     a8a:	1c f4       	brge	.+6      	; 0xa92 <_ZN5Motor3runEv+0x220>
		output_correct = _min;
     a8c:	f6 01       	movw	r30, r12
     a8e:	20 83       	st	Z, r18
     a90:	31 83       	std	Z+1, r19	; 0x01

		// Save error to previous error
		_pre_error = error;
     a92:	f8 01       	movw	r30, r16
     a94:	e2 5b       	subi	r30, 0xB2	; 178
     a96:	ff 4f       	sbci	r31, 0xFF	; 255
     a98:	e0 82       	st	Z, r14
     a9a:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     a9c:	f6 01       	movw	r30, r12
     a9e:	20 81       	ld	r18, Z
     aa0:	31 81       	ldd	r19, Z+1	; 0x01
     aa2:	82 1b       	sub	r24, r18
     aa4:	93 0b       	sbc	r25, r19
     aa6:	f8 01       	movw	r30, r16
     aa8:	ee 59       	subi	r30, 0x9E	; 158
     aaa:	ff 4f       	sbci	r31, 0xFF	; 255
     aac:	80 83       	st	Z, r24
     aae:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     ab0:	e9 85       	ldd	r30, Y+9	; 0x09
     ab2:	fa 85       	ldd	r31, Y+10	; 0x0a
     ab4:	40 81       	ld	r20, Z
     ab6:	51 81       	ldd	r21, Z+1	; 0x01
     ab8:	84 9f       	mul	r24, r20
     aba:	90 01       	movw	r18, r0
     abc:	85 9f       	mul	r24, r21
     abe:	30 0d       	add	r19, r0
     ac0:	94 9f       	mul	r25, r20
     ac2:	30 0d       	add	r19, r0
     ac4:	11 24       	eor	r1, r1
     ac6:	33 23       	and	r19, r19
     ac8:	14 f4       	brge	.+4      	; 0xace <_ZN5Motor3runEv+0x25c>
     aca:	21 50       	subi	r18, 0x01	; 1
     acc:	3f 4f       	sbci	r19, 0xFF	; 255
     ace:	83 2f       	mov	r24, r19
     ad0:	88 0f       	add	r24, r24
     ad2:	88 0b       	sbc	r24, r24
     ad4:	f1 01       	movw	r30, r2
     ad6:	30 83       	st	Z, r19
     ad8:	81 83       	std	Z+1, r24	; 0x01
		
		
			if(runs%5==0){
     ada:	f8 01       	movw	r30, r16
     adc:	66 85       	ldd	r22, Z+14	; 0x0e
     ade:	77 85       	ldd	r23, Z+15	; 0x0f
     ae0:	80 89       	ldd	r24, Z+16	; 0x10
     ae2:	91 89       	ldd	r25, Z+17	; 0x11
     ae4:	25 e0       	ldi	r18, 0x05	; 5
     ae6:	30 e0       	ldi	r19, 0x00	; 0
     ae8:	40 e0       	ldi	r20, 0x00	; 0
     aea:	50 e0       	ldi	r21, 0x00	; 0
     aec:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <__udivmodsi4>
     af0:	67 2b       	or	r22, r23
     af2:	68 2b       	or	r22, r24
     af4:	69 2b       	or	r22, r25
     af6:	51 f4       	brne	.+20     	; 0xb0c <_ZN5Motor3runEv+0x29a>
				//*p_serial << "Pout: " << Pout << endl;
				//*p_serial << "error: " << error << endl;
				//*p_serial << "Integral: " << _integral << endl;
				//*p_serial << "Measured: " << omegam_measured << endl;
				//*p_serial << "PWM Signal: " << output_correct << endl;
				*p_serial << omegam_measured << endl;
     af8:	f8 01       	movw	r30, r16
     afa:	66 8d       	ldd	r22, Z+30	; 0x1e
     afc:	77 8d       	ldd	r23, Z+31	; 0x1f
     afe:	86 81       	ldd	r24, Z+6	; 0x06
     b00:	97 81       	ldd	r25, Z+7	; 0x07
     b02:	0e 94 46 1a 	call	0x348c	; 0x348c <_ZN8emstreamlsEi>
     b06:	66 e0       	ldi	r22, 0x06	; 6
     b08:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b0c:	0f b6       	in	r0, 0x3f	; 63
     b0e:	f8 94       	cli
     b10:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b12:	0f 90       	pop	r0
     b14:	0f be       	out	0x3f, r0	; 63
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     b16:	80 91 49 31 	lds	r24, 0x3149	; 0x803149 <leftLimitSwitch>
     b1a:	81 11       	cpse	r24, r1
     b1c:	09 c0       	rjmp	.+18     	; 0xb30 <_ZN5Motor3runEv+0x2be>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b1e:	0f b6       	in	r0, 0x3f	; 63
     b20:	f8 94       	cli
     b22:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b24:	0f 90       	pop	r0
     b26:	0f be       	out	0x3f, r0	; 63
     b28:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rightLimitSwitch>
     b2c:	88 23       	and	r24, r24
     b2e:	59 f0       	breq	.+22     	; 0xb46 <_ZN5Motor3runEv+0x2d4>
		{
			omegam_set = 0; // [ticks/ms]
     b30:	f8 01       	movw	r30, r16
     b32:	12 8e       	std	Z+26, r1	; 0x1a
     b34:	13 8e       	std	Z+27, r1	; 0x1b
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     b36:	f5 01       	movw	r30, r10
     b38:	10 82       	st	Z, r1
     b3a:	11 82       	std	Z+1, r1	; 0x01
     b3c:	12 82       	std	Z+2, r1	; 0x02
     b3e:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;
     b40:	f6 01       	movw	r30, r12
     b42:	10 82       	st	Z, r1
     b44:	11 82       	std	Z+1, r1	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b46:	0f b6       	in	r0, 0x3f	; 63
     b48:	f8 94       	cli
     b4a:	0f 92       	push	r0
			the_data = new_data;
     b4c:	f6 01       	movw	r30, r12
     b4e:	80 81       	ld	r24, Z
     b50:	91 81       	ldd	r25, Z+1	; 0x01
     b52:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <PWMvalue>
     b56:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     b5a:	0f 90       	pop	r0
     b5c:	0f be       	out	0x3f, r0	; 63
			}
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     b5e:	f8 01       	movw	r30, r16
     b60:	10 a6       	std	Z+40, r1	; 0x28
     b62:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     b64:	82 a1       	ldd	r24, Z+34	; 0x22
     b66:	93 a1       	ldd	r25, Z+35	; 0x23
     b68:	60 e0       	ldi	r22, 0x00	; 0
     b6a:	70 e0       	ldi	r23, 0x00	; 0
     b6c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <__divmodhi4>
     b70:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     b72:	07 2e       	mov	r0, r23
     b74:	00 0c       	add	r0, r0
     b76:	88 0b       	sbc	r24, r24
     b78:	99 0b       	sbc	r25, r25
     b7a:	0e 94 e8 1e 	call	0x3dd0	; 0x3dd0 <__floatsisf>
     b7e:	2b 01       	movw	r4, r22
     b80:	3c 01       	movw	r6, r24
     b82:	23 e3       	ldi	r18, 0x33	; 51
     b84:	33 e3       	ldi	r19, 0x33	; 51
     b86:	4b e8       	ldi	r20, 0x8B	; 139
     b88:	51 e4       	ldi	r21, 0x41	; 65
     b8a:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <__gesf2>
     b8e:	18 16       	cp	r1, r24
     b90:	34 f4       	brge	.+12     	; 0xb9e <_ZN5Motor3runEv+0x32c>
			Im_set = 17.4;
     b92:	81 e1       	ldi	r24, 0x11	; 17
     b94:	90 e0       	ldi	r25, 0x00	; 0
     b96:	f8 01       	movw	r30, r16
     b98:	84 a3       	std	Z+36, r24	; 0x24
     b9a:	95 a3       	std	Z+37, r25	; 0x25
     b9c:	13 c0       	rjmp	.+38     	; 0xbc4 <_ZN5Motor3runEv+0x352>
		} else if(Im_set < -17.4) {
     b9e:	23 e3       	ldi	r18, 0x33	; 51
     ba0:	33 e3       	ldi	r19, 0x33	; 51
     ba2:	4b e8       	ldi	r20, 0x8B	; 139
     ba4:	51 ec       	ldi	r21, 0xC1	; 193
     ba6:	c3 01       	movw	r24, r6
     ba8:	b2 01       	movw	r22, r4
     baa:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <__cmpsf2>
     bae:	88 23       	and	r24, r24
     bb0:	24 f0       	brlt	.+8      	; 0xbba <_ZN5Motor3runEv+0x348>
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     bb2:	f8 01       	movw	r30, r16
     bb4:	e4 a2       	std	Z+36, r14	; 0x24
     bb6:	f5 a2       	std	Z+37, r15	; 0x25
     bb8:	05 c0       	rjmp	.+10     	; 0xbc4 <_ZN5Motor3runEv+0x352>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     bba:	8f ee       	ldi	r24, 0xEF	; 239
     bbc:	9f ef       	ldi	r25, 0xFF	; 255
     bbe:	f8 01       	movw	r30, r16
     bc0:	84 a3       	std	Z+36, r24	; 0x24
     bc2:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     bc4:	f8 01       	movw	r30, r16
     bc6:	16 aa       	std	Z+54, r1	; 0x36
     bc8:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     bca:	12 aa       	std	Z+50, r1	; 0x32
     bcc:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     bce:	14 aa       	std	Z+52, r1	; 0x34
     bd0:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
     bd2:	80 a9       	ldd	r24, Z+48	; 0x30
     bd4:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
     bd6:	89 31       	cpi	r24, 0x19	; 25
     bd8:	91 05       	cpc	r25, r1
     bda:	2c f0       	brlt	.+10     	; 0xbe6 <_ZN5Motor3runEv+0x374>
			V_m = 24;
     bdc:	88 e1       	ldi	r24, 0x18	; 24
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	80 af       	std	Z+56, r24	; 0x38
     be2:	91 af       	std	Z+57, r25	; 0x39
     be4:	0d c0       	rjmp	.+26     	; 0xc00 <_ZN5Motor3runEv+0x38e>
		} else if(V_m < -24) {
     be6:	88 3e       	cpi	r24, 0xE8	; 232
     be8:	ff ef       	ldi	r31, 0xFF	; 255
     bea:	9f 07       	cpc	r25, r31
     bec:	24 f0       	brlt	.+8      	; 0xbf6 <_ZN5Motor3runEv+0x384>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     bee:	f8 01       	movw	r30, r16
     bf0:	80 af       	std	Z+56, r24	; 0x38
     bf2:	91 af       	std	Z+57, r25	; 0x39
     bf4:	05 c0       	rjmp	.+10     	; 0xc00 <_ZN5Motor3runEv+0x38e>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     bf6:	88 ee       	ldi	r24, 0xE8	; 232
     bf8:	9f ef       	ldi	r25, 0xFF	; 255
     bfa:	f8 01       	movw	r30, r16
     bfc:	80 af       	std	Z+56, r24	; 0x38
     bfe:	91 af       	std	Z+57, r25	; 0x39

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
     c00:	f4 01       	movw	r30, r8
     c02:	20 81       	ld	r18, Z
     c04:	31 81       	ldd	r19, Z+1	; 0x01
     c06:	42 81       	ldd	r20, Z+2	; 0x02
     c08:	53 81       	ldd	r21, Z+3	; 0x03
     c0a:	a8 ee       	ldi	r26, 0xE8	; 232
     c0c:	b3 e0       	ldi	r27, 0x03	; 3
     c0e:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <__muluhisi3>
     c12:	68 3e       	cpi	r22, 0xE8	; 232
     c14:	f3 e0       	ldi	r31, 0x03	; 3
     c16:	7f 07       	cpc	r23, r31
     c18:	81 05       	cpc	r24, r1
     c1a:	91 05       	cpc	r25, r1
     c1c:	48 f0       	brcs	.+18     	; 0xc30 <_ZN5Motor3runEv+0x3be>
     c1e:	28 ee       	ldi	r18, 0xE8	; 232
     c20:	33 e0       	ldi	r19, 0x03	; 3
     c22:	40 e0       	ldi	r20, 0x00	; 0
     c24:	50 e0       	ldi	r21, 0x00	; 0
     c26:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <__udivmodsi4>
     c2a:	ba 01       	movw	r22, r20
     c2c:	a9 01       	movw	r20, r18
     c2e:	04 c0       	rjmp	.+8      	; 0xc38 <_ZN5Motor3runEv+0x3c6>
     c30:	41 e0       	ldi	r20, 0x01	; 1
     c32:	50 e0       	ldi	r21, 0x00	; 0
     c34:	60 e0       	ldi	r22, 0x00	; 0
     c36:	70 e0       	ldi	r23, 0x00	; 0
     c38:	ce 01       	movw	r24, r28
     c3a:	01 96       	adiw	r24, 0x01	; 1
     c3c:	0e 94 fd 11 	call	0x23fa	; 0x23fa <vTaskDelayUntil>
     c40:	6a ce       	rjmp	.-812    	; 0x916 <_ZN5Motor3runEv+0xa4>

00000c42 <_ZN5MotorC1EPKchjP8emstream>:
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
     c4a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     c4c:	0e 94 9a 14 	call	0x2934	; 0x2934 <_ZN8frt_taskC1EPKchjP8emstream>
     c50:	82 e2       	ldi	r24, 0x22	; 34
     c52:	90 e2       	ldi	r25, 0x20	; 32
     c54:	88 83       	st	Y, r24
     c56:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	1f 91       	pop	r17
     c5e:	0f 91       	pop	r16
     c60:	08 95       	ret

00000c62 <_ZN9PWMdriver3runEv>:
		// Nothing to do in this constructor other than call the parent constructor
	}



void PWMdriver::run(void){
     c62:	cf 93       	push	r28
     c64:	df 93       	push	r29
     c66:	00 d0       	rcall	.+0      	; 0xc68 <_ZN9PWMdriver3runEv+0x6>
     c68:	1f 92       	push	r1
     c6a:	cd b7       	in	r28, 0x3d	; 61
     c6c:	de b7       	in	r29, 0x3e	; 62
     c6e:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     c70:	0e 94 5f 10 	call	0x20be	; 0x20be <xTaskGetTickCount>
     c74:	69 83       	std	Y+1, r22	; 0x01
     c76:	7a 83       	std	Y+2, r23	; 0x02
     c78:	8b 83       	std	Y+3, r24	; 0x03
     c7a:	9c 83       	std	Y+4, r25	; 0x04
	//PC0 - MD0
	//PC1 - MD1
	
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     c7c:	a0 e4       	ldi	r26, 0x40	; 64
     c7e:	b6 e0       	ldi	r27, 0x06	; 6
     c80:	87 e0       	ldi	r24, 0x07	; 7
     c82:	11 96       	adiw	r26, 0x01	; 1
     c84:	8c 93       	st	X, r24
     c86:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     c88:	84 e0       	ldi	r24, 0x04	; 4
     c8a:	15 96       	adiw	r26, 0x05	; 5
     c8c:	8c 93       	st	X, r24
     c8e:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     c90:	e0 e0       	ldi	r30, 0x00	; 0
     c92:	f8 e0       	ldi	r31, 0x08	; 8
     c94:	81 e0       	ldi	r24, 0x01	; 1
     c96:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     c98:	83 e0       	ldi	r24, 0x03	; 3
     c9a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     c9c:	a6 a3       	std	Z+38, r26	; 0x26
     c9e:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     ca0:	10 a6       	std	Z+40, r1	; 0x28
     ca2:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     ca4:	12 a6       	std	Z+42, r1	; 0x2a
     ca6:	13 a6       	std	Z+43, r1	; 0x2b
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     ca8:	81 81       	ldd	r24, Z+1	; 0x01
     caa:	80 63       	ori	r24, 0x30	; 48
     cac:	81 83       	std	Z+1, r24	; 0x01
	
	while(1){
		// Increment counter for debugging
		runs++;
		
		TCC0.CCA = PWMvalue.get();
     cae:	00 e0       	ldi	r16, 0x00	; 0
     cb0:	18 e0       	ldi	r17, 0x08	; 8
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
	
	while(1){
		// Increment counter for debugging
		runs++;
     cb2:	f7 01       	movw	r30, r14
     cb4:	86 85       	ldd	r24, Z+14	; 0x0e
     cb6:	97 85       	ldd	r25, Z+15	; 0x0f
     cb8:	a0 89       	ldd	r26, Z+16	; 0x10
     cba:	b1 89       	ldd	r27, Z+17	; 0x11
     cbc:	01 96       	adiw	r24, 0x01	; 1
     cbe:	a1 1d       	adc	r26, r1
     cc0:	b1 1d       	adc	r27, r1
     cc2:	86 87       	std	Z+14, r24	; 0x0e
     cc4:	97 87       	std	Z+15, r25	; 0x0f
     cc6:	a0 8b       	std	Z+16, r26	; 0x10
     cc8:	b1 8b       	std	Z+17, r27	; 0x11
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cca:	0f b6       	in	r0, 0x3f	; 63
     ccc:	f8 94       	cli
     cce:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cd0:	0f 90       	pop	r0
     cd2:	0f be       	out	0x3f, r0	; 63
		
		TCC0.CCA = PWMvalue.get();
     cd4:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <PWMvalue>
     cd8:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <PWMvalue+0x1>
     cdc:	f8 01       	movw	r30, r16
     cde:	80 a7       	std	Z+40, r24	; 0x28
     ce0:	91 a7       	std	Z+41, r25	; 0x29
		TCC0.CCB = 0;
     ce2:	12 a6       	std	Z+42, r1	; 0x2a
     ce4:	13 a6       	std	Z+43, r1	; 0x2b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ce6:	0f b6       	in	r0, 0x3f	; 63
     ce8:	f8 94       	cli
     cea:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cec:	0f 90       	pop	r0
     cee:	0f be       	out	0x3f, r0	; 63
		if(runs%100==0){
			*p_serial << PWMvalue.get() << endl;
		}	
		*/
		
		if (!leftLimitSwitch.get() && !rightLimitSwitch.get())
     cf0:	20 91 49 31 	lds	r18, 0x3149	; 0x803149 <leftLimitSwitch>
     cf4:	21 11       	cpse	r18, r1
     cf6:	12 c0       	rjmp	.+36     	; 0xd1c <_ZN9PWMdriver3runEv+0xba>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cf8:	0f b6       	in	r0, 0x3f	; 63
     cfa:	f8 94       	cli
     cfc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cfe:	0f 90       	pop	r0
     d00:	0f be       	out	0x3f, r0	; 63
     d02:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <rightLimitSwitch>
     d06:	21 11       	cpse	r18, r1
     d08:	09 c0       	rjmp	.+18     	; 0xd1c <_ZN9PWMdriver3runEv+0xba>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d0a:	0f b6       	in	r0, 0x3f	; 63
     d0c:	f8 94       	cli
     d0e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d10:	0f 90       	pop	r0
     d12:	0f be       	out	0x3f, r0	; 63
		{
			TCC0.CCA = PWMvalue.get();
     d14:	80 a7       	std	Z+40, r24	; 0x28
     d16:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
     d18:	12 a6       	std	Z+42, r1	; 0x2a
     d1a:	13 a6       	std	Z+43, r1	; 0x2b
     d1c:	44 e1       	ldi	r20, 0x14	; 20
     d1e:	50 e0       	ldi	r21, 0x00	; 0
     d20:	60 e0       	ldi	r22, 0x00	; 0
     d22:	70 e0       	ldi	r23, 0x00	; 0
     d24:	ce 01       	movw	r24, r28
     d26:	01 96       	adiw	r24, 0x01	; 1
     d28:	0e 94 fd 11 	call	0x23fa	; 0x23fa <vTaskDelayUntil>
     d2c:	c2 cf       	rjmp	.-124    	; 0xcb2 <_ZN9PWMdriver3runEv+0x50>

00000d2e <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

PWMdriver::PWMdriver(const char* a_name,
     d2e:	0f 93       	push	r16
     d30:	1f 93       	push	r17
     d32:	cf 93       	push	r28
     d34:	df 93       	push	r29
     d36:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d38:	0e 94 9a 14 	call	0x2934	; 0x2934 <_ZN8frt_taskC1EPKchjP8emstream>
     d3c:	8a e2       	ldi	r24, 0x2A	; 42
     d3e:	90 e2       	ldi	r25, 0x20	; 32
     d40:	88 83       	st	Y, r24
     d42:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	08 95       	ret

00000d4e <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
     d4e:	9c 01       	movw	r18, r24
     d50:	93 2f       	mov	r25, r19
     d52:	99 1f       	adc	r25, r25
     d54:	99 27       	eor	r25, r25
     d56:	99 1f       	adc	r25, r25
     d58:	89 2f       	mov	r24, r25
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	81 50       	subi	r24, 0x01	; 1
     d5e:	90 48       	sbci	r25, 0x80	; 128
     d60:	43 2f       	mov	r20, r19
     d62:	40 95       	com	r20
     d64:	44 1f       	adc	r20, r20
     d66:	44 27       	eor	r20, r20
     d68:	44 1f       	adc	r20, r20
     d6a:	fc 01       	movw	r30, r24
     d6c:	e2 1b       	sub	r30, r18
     d6e:	f3 0b       	sbc	r31, r19
     d70:	51 e0       	ldi	r21, 0x01	; 1
     d72:	e6 17       	cp	r30, r22
     d74:	f7 07       	cpc	r31, r23
     d76:	0c f0       	brlt	.+2      	; 0xd7a <_ZN7satmath20signed_saturated_addEii+0x2c>
     d78:	50 e0       	ldi	r21, 0x00	; 0
     d7a:	45 17       	cp	r20, r21
     d7c:	19 f0       	breq	.+6      	; 0xd84 <_ZN7satmath20signed_saturated_addEii+0x36>
     d7e:	c9 01       	movw	r24, r18
     d80:	86 0f       	add	r24, r22
     d82:	97 1f       	adc	r25, r23
     d84:	08 95       	ret

00000d86 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     d86:	81 15       	cp	r24, r1
     d88:	20 e8       	ldi	r18, 0x80	; 128
     d8a:	92 07       	cpc	r25, r18
     d8c:	21 f4       	brne	.+8      	; 0xd96 <_ZN7satmath20signed_saturated_mulEii+0x10>
     d8e:	61 15       	cp	r22, r1
     d90:	20 e8       	ldi	r18, 0x80	; 128
     d92:	72 07       	cpc	r23, r18
     d94:	29 f0       	breq	.+10     	; 0xda0 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     d96:	9c 01       	movw	r18, r24
     d98:	db 01       	movw	r26, r22
     d9a:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <__mulhisi3>
     d9e:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     da0:	6f ef       	ldi	r22, 0xFF	; 255
     da2:	7f ef       	ldi	r23, 0xFF	; 255
     da4:	8f ef       	ldi	r24, 0xFF	; 255
     da6:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     da8:	08 95       	ret

00000daa <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     db4:	0e 94 9a 14 	call	0x2934	; 0x2934 <_ZN8frt_taskC1EPKchjP8emstream>
     db8:	82 e3       	ldi	r24, 0x32	; 50
     dba:	90 e2       	ldi	r25, 0x20	; 32
     dbc:	88 83       	st	Y, r24
     dbe:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     dc0:	df 91       	pop	r29
     dc2:	cf 91       	pop	r28
     dc4:	1f 91       	pop	r17
     dc6:	0f 91       	pop	r16
     dc8:	08 95       	ret

00000dca <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     dca:	0f 93       	push	r16
     dcc:	1f 93       	push	r17
     dce:	cf 93       	push	r28
     dd0:	df 93       	push	r29
     dd2:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     dd4:	6a e0       	ldi	r22, 0x0A	; 10
     dd6:	8e 81       	ldd	r24, Y+6	; 0x06
     dd8:	9f 81       	ldd	r25, Y+7	; 0x07
     dda:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     dde:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     de0:	6d ee       	ldi	r22, 0xED	; 237
     de2:	73 e0       	ldi	r23, 0x03	; 3
     de4:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     de8:	6a e0       	ldi	r22, 0x0A	; 10
     dea:	c8 01       	movw	r24, r16
     dec:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     df0:	8c 01       	movw	r16, r24
     df2:	67 ee       	ldi	r22, 0xE7	; 231
     df4:	73 e0       	ldi	r23, 0x03	; 3
     df6:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     dfa:	67 e0       	ldi	r22, 0x07	; 7
     dfc:	c8 01       	movw	r24, r16
     dfe:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     e02:	6a e0       	ldi	r22, 0x0A	; 10
     e04:	8e 81       	ldd	r24, Y+6	; 0x06
     e06:	9f 81       	ldd	r25, Y+7	; 0x07
     e08:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     e0c:	8c 01       	movw	r16, r24
     e0e:	68 ec       	ldi	r22, 0xC8	; 200
     e10:	73 e0       	ldi	r23, 0x03	; 3
     e12:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     e16:	6a e0       	ldi	r22, 0x0A	; 10
     e18:	c8 01       	movw	r24, r16
     e1a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     e1e:	8c 01       	movw	r16, r24
     e20:	62 ec       	ldi	r22, 0xC2	; 194
     e22:	73 e0       	ldi	r23, 0x03	; 3
     e24:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     e28:	66 e0       	ldi	r22, 0x06	; 6
     e2a:	c8 01       	movw	r24, r16
     e2c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e30:	6a e0       	ldi	r22, 0x0A	; 10
     e32:	8e 81       	ldd	r24, Y+6	; 0x06
     e34:	9f 81       	ldd	r25, Y+7	; 0x07
     e36:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     e3a:	8c 01       	movw	r16, r24
     e3c:	6b ea       	ldi	r22, 0xAB	; 171
     e3e:	73 e0       	ldi	r23, 0x03	; 3
     e40:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     e44:	66 e0       	ldi	r22, 0x06	; 6
     e46:	c8 01       	movw	r24, r16
     e48:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e4c:	6a e0       	ldi	r22, 0x0A	; 10
     e4e:	8e 81       	ldd	r24, Y+6	; 0x06
     e50:	9f 81       	ldd	r25, Y+7	; 0x07
     e52:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     e56:	8c 01       	movw	r16, r24
     e58:	6f e8       	ldi	r22, 0x8F	; 143
     e5a:	73 e0       	ldi	r23, 0x03	; 3
     e5c:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     e60:	66 e0       	ldi	r22, 0x06	; 6
     e62:	c8 01       	movw	r24, r16
     e64:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e68:	6a e0       	ldi	r22, 0x0A	; 10
     e6a:	8e 81       	ldd	r24, Y+6	; 0x06
     e6c:	9f 81       	ldd	r25, Y+7	; 0x07
     e6e:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     e72:	8c 01       	movw	r16, r24
     e74:	67 e7       	ldi	r22, 0x77	; 119
     e76:	73 e0       	ldi	r23, 0x03	; 3
     e78:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     e7c:	66 e0       	ldi	r22, 0x06	; 6
     e7e:	c8 01       	movw	r24, r16
     e80:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e84:	6a e0       	ldi	r22, 0x0A	; 10
     e86:	8e 81       	ldd	r24, Y+6	; 0x06
     e88:	9f 81       	ldd	r25, Y+7	; 0x07
     e8a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     e8e:	8c 01       	movw	r16, r24
     e90:	66 e5       	ldi	r22, 0x56	; 86
     e92:	73 e0       	ldi	r23, 0x03	; 3
     e94:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     e98:	66 e0       	ldi	r22, 0x06	; 6
     e9a:	c8 01       	movw	r24, r16
     e9c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     ea0:	6a e0       	ldi	r22, 0x0A	; 10
     ea2:	8e 81       	ldd	r24, Y+6	; 0x06
     ea4:	9f 81       	ldd	r25, Y+7	; 0x07
     ea6:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     eaa:	8c 01       	movw	r16, r24
     eac:	6f e2       	ldi	r22, 0x2F	; 47
     eae:	73 e0       	ldi	r23, 0x03	; 3
     eb0:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     eb4:	66 e0       	ldi	r22, 0x06	; 6
     eb6:	c8 01       	movw	r24, r16
     eb8:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     ebc:	6a e0       	ldi	r22, 0x0A	; 10
     ebe:	8e 81       	ldd	r24, Y+6	; 0x06
     ec0:	9f 81       	ldd	r25, Y+7	; 0x07
     ec2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     ec6:	8c 01       	movw	r16, r24
     ec8:	61 e1       	ldi	r22, 0x11	; 17
     eca:	73 e0       	ldi	r23, 0x03	; 3
     ecc:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     ed0:	66 e0       	ldi	r22, 0x06	; 6
     ed2:	c8 01       	movw	r24, r16
     ed4:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     ed8:	6a e0       	ldi	r22, 0x0A	; 10
     eda:	8e 81       	ldd	r24, Y+6	; 0x06
     edc:	9f 81       	ldd	r25, Y+7	; 0x07
     ede:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     ee2:	8c 01       	movw	r16, r24
     ee4:	66 ef       	ldi	r22, 0xF6	; 246
     ee6:	72 e0       	ldi	r23, 0x02	; 2
     ee8:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     eec:	66 e0       	ldi	r22, 0x06	; 6
     eee:	c8 01       	movw	r24, r16
     ef0:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     ef4:	6a e0       	ldi	r22, 0x0A	; 10
     ef6:	8e 81       	ldd	r24, Y+6	; 0x06
     ef8:	9f 81       	ldd	r25, Y+7	; 0x07
     efa:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     efe:	ec 01       	movw	r28, r24
     f00:	67 ee       	ldi	r22, 0xE7	; 231
     f02:	72 e0       	ldi	r23, 0x02	; 2
     f04:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     f08:	66 e0       	ldi	r22, 0x06	; 6
     f0a:	ce 01       	movw	r24, r28
     f0c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
}
     f10:	df 91       	pop	r29
     f12:	cf 91       	pop	r28
     f14:	1f 91       	pop	r17
     f16:	0f 91       	pop	r16
     f18:	08 95       	ret

00000f1a <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     f1a:	af 92       	push	r10
     f1c:	bf 92       	push	r11
     f1e:	cf 92       	push	r12
     f20:	df 92       	push	r13
     f22:	ef 92       	push	r14
     f24:	ff 92       	push	r15
     f26:	0f 93       	push	r16
     f28:	1f 93       	push	r17
     f2a:	cf 93       	push	r28
     f2c:	df 93       	push	r29
     f2e:	00 d0       	rcall	.+0      	; 0xf30 <_ZN9task_user11show_statusEv+0x16>
     f30:	00 d0       	rcall	.+0      	; 0xf32 <_ZN9task_user11show_statusEv+0x18>
     f32:	cd b7       	in	r28, 0x3d	; 61
     f34:	de b7       	in	r29, 0x3e	; 62
     f36:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f38:	19 82       	std	Y+1, r1	; 0x01
     f3a:	1a 82       	std	Y+2, r1	; 0x02
     f3c:	1b 82       	std	Y+3, r1	; 0x03
     f3e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f40:	1d 82       	std	Y+5, r1	; 0x05
     f42:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f44:	0e 94 12 0a 	call	0x1424	; 0x1424 <xPortGetFreeHeapSize>
     f48:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f4a:	ce 01       	movw	r24, r28
     f4c:	01 96       	adiw	r24, 0x01	; 1
     f4e:	0e 94 4b 18 	call	0x3096	; 0x3096 <_ZN10time_stamp10set_to_nowEv>
     f52:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f54:	66 e0       	ldi	r22, 0x06	; 6
     f56:	f8 01       	movw	r30, r16
     f58:	86 81       	ldd	r24, Z+6	; 0x06
     f5a:	97 81       	ldd	r25, Z+7	; 0x07
     f5c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     f60:	6a e0       	ldi	r22, 0x0A	; 10
     f62:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     f66:	7c 01       	movw	r14, r24
     f68:	68 ec       	ldi	r22, 0xC8	; 200
     f6a:	72 e0       	ldi	r23, 0x02	; 2
     f6c:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     f70:	6a e0       	ldi	r22, 0x0A	; 10
     f72:	c7 01       	movw	r24, r14
     f74:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     f78:	7c 01       	movw	r14, r24
     f7a:	6c eb       	ldi	r22, 0xBC	; 188
     f7c:	72 e0       	ldi	r23, 0x02	; 2
     f7e:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     f82:	66 e0       	ldi	r22, 0x06	; 6
     f84:	c7 01       	movw	r24, r14
     f86:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f8a:	6a e0       	ldi	r22, 0x0A	; 10
     f8c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     f90:	7c 01       	movw	r14, r24
     f92:	65 eb       	ldi	r22, 0xB5	; 181
     f94:	72 e0       	ldi	r23, 0x02	; 2
     f96:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     f9a:	b5 01       	movw	r22, r10
     f9c:	c7 01       	movw	r24, r14
     f9e:	0e 94 ef 17 	call	0x2fde	; 0x2fde <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     fa2:	6a e0       	ldi	r22, 0x0A	; 10
     fa4:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     fa8:	7c 01       	movw	r14, r24
     faa:	67 ea       	ldi	r22, 0xA7	; 167
     fac:	72 e0       	ldi	r23, 0x02	; 2
     fae:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     fb2:	b6 01       	movw	r22, r12
     fb4:	c7 01       	movw	r24, r14
     fb6:	0e 94 6f 1a 	call	0x34de	; 0x34de <_ZN8emstreamlsEj>
     fba:	6a e0       	ldi	r22, 0x0A	; 10
     fbc:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     fc0:	7c 01       	movw	r14, r24
     fc2:	65 ea       	ldi	r22, 0xA5	; 165
     fc4:	72 e0       	ldi	r23, 0x02	; 2
     fc6:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     fca:	4f ef       	ldi	r20, 0xFF	; 255
     fcc:	5f e0       	ldi	r21, 0x0F	; 15
     fce:	60 e0       	ldi	r22, 0x00	; 0
     fd0:	70 e0       	ldi	r23, 0x00	; 0
     fd2:	c7 01       	movw	r24, r14
     fd4:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     fd8:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     fdc:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     fe0:	6a e0       	ldi	r22, 0x0A	; 10
     fe2:	f8 01       	movw	r30, r16
     fe4:	86 81       	ldd	r24, Z+6	; 0x06
     fe6:	97 81       	ldd	r25, Z+7	; 0x07
     fe8:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
     fec:	7c 01       	movw	r14, r24
     fee:	6a e9       	ldi	r22, 0x9A	; 154
     ff0:	72 e0       	ldi	r23, 0x02	; 2
     ff2:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
     ff6:	b6 01       	movw	r22, r12
     ff8:	c7 01       	movw	r24, r14
     ffa:	0e 94 6f 1a 	call	0x34de	; 0x34de <_ZN8emstreamlsEj>
     ffe:	66 e0       	ldi	r22, 0x06	; 6
    1000:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    1004:	66 e0       	ldi	r22, 0x06	; 6
    1006:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    100a:	f8 01       	movw	r30, r16
    100c:	86 81       	ldd	r24, Z+6	; 0x06
    100e:	97 81       	ldd	r25, Z+7	; 0x07
    1010:	0e 94 a8 16 	call	0x2d50	; 0x2d50 <_Z15print_task_listP8emstream>
}
    1014:	26 96       	adiw	r28, 0x06	; 6
    1016:	cd bf       	out	0x3d, r28	; 61
    1018:	de bf       	out	0x3e, r29	; 62
    101a:	df 91       	pop	r29
    101c:	cf 91       	pop	r28
    101e:	1f 91       	pop	r17
    1020:	0f 91       	pop	r16
    1022:	ff 90       	pop	r15
    1024:	ef 90       	pop	r14
    1026:	df 90       	pop	r13
    1028:	cf 90       	pop	r12
    102a:	bf 90       	pop	r11
    102c:	af 90       	pop	r10
    102e:	08 95       	ret

00001030 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1030:	cf 93       	push	r28
    1032:	df 93       	push	r29
    1034:	00 d0       	rcall	.+0      	; 0x1036 <_ZN9task_user3runEv+0x6>
    1036:	00 d0       	rcall	.+0      	; 0x1038 <_ZN9task_user3runEv+0x8>
    1038:	cd b7       	in	r28, 0x3d	; 61
    103a:	de b7       	in	r29, 0x3e	; 62
    103c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    103e:	19 82       	std	Y+1, r1	; 0x01
    1040:	1a 82       	std	Y+2, r1	; 0x02
    1042:	1b 82       	std	Y+3, r1	; 0x03
    1044:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1046:	1d 82       	std	Y+5, r1	; 0x05
    1048:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    104a:	6a e0       	ldi	r22, 0x0A	; 10
    104c:	dc 01       	movw	r26, r24
    104e:	16 96       	adiw	r26, 0x06	; 6
    1050:	8d 91       	ld	r24, X+
    1052:	9c 91       	ld	r25, X
    1054:	17 97       	sbiw	r26, 0x07	; 7
    1056:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    105a:	7c 01       	movw	r14, r24
    105c:	66 e3       	ldi	r22, 0x36	; 54
    105e:	74 e0       	ldi	r23, 0x04	; 4
    1060:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    1064:	66 e0       	ldi	r22, 0x06	; 6
    1066:	c7 01       	movw	r24, r14
    1068:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    106c:	f8 01       	movw	r30, r16
    106e:	84 85       	ldd	r24, Z+12	; 0x0c
    1070:	88 23       	and	r24, r24
    1072:	21 f0       	breq	.+8      	; 0x107c <_ZN9task_user3runEv+0x4c>
    1074:	81 30       	cpi	r24, 0x01	; 1
    1076:	09 f4       	brne	.+2      	; 0x107a <_ZN9task_user3runEv+0x4a>
    1078:	5d c0       	rjmp	.+186    	; 0x1134 <_ZN9task_user3runEv+0x104>
    107a:	d8 c0       	rjmp	.+432    	; 0x122c <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    107c:	86 81       	ldd	r24, Z+6	; 0x06
    107e:	97 81       	ldd	r25, Z+7	; 0x07
    1080:	dc 01       	movw	r26, r24
    1082:	ed 91       	ld	r30, X+
    1084:	fc 91       	ld	r31, X
    1086:	04 80       	ldd	r0, Z+4	; 0x04
    1088:	f5 81       	ldd	r31, Z+5	; 0x05
    108a:	e0 2d       	mov	r30, r0
    108c:	19 95       	eicall
    108e:	88 23       	and	r24, r24
    1090:	a9 f1       	breq	.+106    	; 0x10fc <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1092:	f8 01       	movw	r30, r16
    1094:	86 81       	ldd	r24, Z+6	; 0x06
    1096:	97 81       	ldd	r25, Z+7	; 0x07
    1098:	dc 01       	movw	r26, r24
    109a:	ed 91       	ld	r30, X+
    109c:	fc 91       	ld	r31, X
    109e:	06 80       	ldd	r0, Z+6	; 0x06
    10a0:	f7 81       	ldd	r31, Z+7	; 0x07
    10a2:	e0 2d       	mov	r30, r0
    10a4:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    10a6:	99 27       	eor	r25, r25
    10a8:	81 30       	cpi	r24, 0x01	; 1
    10aa:	91 05       	cpc	r25, r1
    10ac:	f9 f0       	breq	.+62     	; 0x10ec <_ZN9task_user3runEv+0xbc>
    10ae:	03 97       	sbiw	r24, 0x03	; 3
    10b0:	09 f0       	breq	.+2      	; 0x10b4 <_ZN9task_user3runEv+0x84>
    10b2:	d8 c0       	rjmp	.+432    	; 0x1264 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    10b4:	6a e0       	ldi	r22, 0x0A	; 10
    10b6:	f8 01       	movw	r30, r16
    10b8:	86 81       	ldd	r24, Z+6	; 0x06
    10ba:	97 81       	ldd	r25, Z+7	; 0x07
    10bc:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    10c0:	8c 01       	movw	r16, r24
    10c2:	68 e2       	ldi	r22, 0x28	; 40
    10c4:	74 e0       	ldi	r23, 0x04	; 4
    10c6:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    10ca:	66 e0       	ldi	r22, 0x06	; 6
    10cc:	c8 01       	movw	r24, r16
    10ce:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10d2:	93 e0       	ldi	r25, 0x03	; 3
    10d4:	88 ed       	ldi	r24, 0xD8	; 216
    10d6:	08 b6       	in	r0, 0x38	; 56
    10d8:	18 be       	out	0x38, r1	; 56
    10da:	84 bf       	out	0x34, r24	; 52
    10dc:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10e0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10e4:	81 fd       	sbrc	r24, 1
    10e6:	fc cf       	rjmp	.-8      	; 0x10e0 <_ZN9task_user3runEv+0xb0>
    10e8:	08 be       	out	0x38, r0	; 56
    10ea:	ff cf       	rjmp	.-2      	; 0x10ea <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10ec:	c8 01       	movw	r24, r16
    10ee:	0e 94 e5 06 	call	0xdca	; 0xdca <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10f2:	61 e0       	ldi	r22, 0x01	; 1
    10f4:	c8 01       	movw	r24, r16
    10f6:	0e 94 96 14 	call	0x292c	; 0x292c <_ZN8frt_task13transition_toEh>
							break;
    10fa:	b4 c0       	rjmp	.+360    	; 0x1264 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10fc:	80 e5       	ldi	r24, 0x50	; 80
    10fe:	91 e3       	ldi	r25, 0x31	; 49
    1100:	0e 94 57 17 	call	0x2eae	; 0x2eae <_ZN14frt_text_queue14check_for_charEv>
    1104:	88 23       	and	r24, r24
    1106:	09 f4       	brne	.+2      	; 0x110a <_ZN9task_user3runEv+0xda>
    1108:	ad c0       	rjmp	.+346    	; 0x1264 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    110a:	d8 01       	movw	r26, r16
    110c:	16 96       	adiw	r26, 0x06	; 6
    110e:	ed 91       	ld	r30, X+
    1110:	fc 91       	ld	r31, X
    1112:	17 97       	sbiw	r26, 0x07	; 7
    1114:	01 90       	ld	r0, Z+
    1116:	f0 81       	ld	r31, Z
    1118:	e0 2d       	mov	r30, r0
    111a:	e2 80       	ldd	r14, Z+2	; 0x02
    111c:	f3 80       	ldd	r15, Z+3	; 0x03
    111e:	80 e5       	ldi	r24, 0x50	; 80
    1120:	91 e3       	ldi	r25, 0x31	; 49
    1122:	0e 94 39 17 	call	0x2e72	; 0x2e72 <_ZN14frt_text_queue7getcharEv>
    1126:	68 2f       	mov	r22, r24
    1128:	f8 01       	movw	r30, r16
    112a:	86 81       	ldd	r24, Z+6	; 0x06
    112c:	97 81       	ldd	r25, Z+7	; 0x07
    112e:	f7 01       	movw	r30, r14
    1130:	19 95       	eicall
    1132:	98 c0       	rjmp	.+304    	; 0x1264 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1134:	86 81       	ldd	r24, Z+6	; 0x06
    1136:	97 81       	ldd	r25, Z+7	; 0x07
    1138:	dc 01       	movw	r26, r24
    113a:	ed 91       	ld	r30, X+
    113c:	fc 91       	ld	r31, X
    113e:	04 80       	ldd	r0, Z+4	; 0x04
    1140:	f5 81       	ldd	r31, Z+5	; 0x05
    1142:	e0 2d       	mov	r30, r0
    1144:	19 95       	eicall
    1146:	88 23       	and	r24, r24
    1148:	09 f4       	brne	.+2      	; 0x114c <_ZN9task_user3runEv+0x11c>
    114a:	8c c0       	rjmp	.+280    	; 0x1264 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    114c:	f8 01       	movw	r30, r16
    114e:	86 81       	ldd	r24, Z+6	; 0x06
    1150:	97 81       	ldd	r25, Z+7	; 0x07
    1152:	dc 01       	movw	r26, r24
    1154:	ed 91       	ld	r30, X+
    1156:	fc 91       	ld	r31, X
    1158:	06 80       	ldd	r0, Z+6	; 0x06
    115a:	f7 81       	ldd	r31, Z+7	; 0x07
    115c:	e0 2d       	mov	r30, r0
    115e:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1160:	9c 01       	movw	r18, r24
    1162:	33 27       	eor	r19, r19
    1164:	28 36       	cpi	r18, 0x68	; 104
    1166:	31 05       	cpc	r19, r1
    1168:	59 f1       	breq	.+86     	; 0x11c0 <_ZN9task_user3runEv+0x190>
    116a:	3c f4       	brge	.+14     	; 0x117a <_ZN9task_user3runEv+0x14a>
    116c:	2b 31       	cpi	r18, 0x1B	; 27
    116e:	31 05       	cpc	r19, r1
    1170:	59 f1       	breq	.+86     	; 0x11c8 <_ZN9task_user3runEv+0x198>
    1172:	25 36       	cpi	r18, 0x65	; 101
    1174:	31 05       	cpc	r19, r1
    1176:	41 f1       	breq	.+80     	; 0x11c8 <_ZN9task_user3runEv+0x198>
    1178:	3b c0       	rjmp	.+118    	; 0x11f0 <_ZN9task_user3runEv+0x1c0>
    117a:	23 37       	cpi	r18, 0x73	; 115
    117c:	31 05       	cpc	r19, r1
    117e:	c1 f0       	breq	.+48     	; 0x11b0 <_ZN9task_user3runEv+0x180>
    1180:	26 37       	cpi	r18, 0x76	; 118
    1182:	31 05       	cpc	r19, r1
    1184:	89 f0       	breq	.+34     	; 0x11a8 <_ZN9task_user3runEv+0x178>
    1186:	2e 36       	cpi	r18, 0x6E	; 110
    1188:	31 05       	cpc	r19, r1
    118a:	91 f5       	brne	.+100    	; 0x11f0 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    118c:	ce 01       	movw	r24, r28
    118e:	01 96       	adiw	r24, 0x01	; 1
    1190:	0e 94 4b 18 	call	0x3096	; 0x3096 <_ZN10time_stamp10set_to_nowEv>
    1194:	bc 01       	movw	r22, r24
    1196:	f8 01       	movw	r30, r16
    1198:	86 81       	ldd	r24, Z+6	; 0x06
    119a:	97 81       	ldd	r25, Z+7	; 0x07
    119c:	0e 94 ef 17 	call	0x2fde	; 0x2fde <_ZlsR8emstreamR10time_stamp>
    11a0:	66 e0       	ldi	r22, 0x06	; 6
    11a2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
							break;
    11a6:	5e c0       	rjmp	.+188    	; 0x1264 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    11a8:	c8 01       	movw	r24, r16
    11aa:	0e 94 8d 07 	call	0xf1a	; 0xf1a <_ZN9task_user11show_statusEv>
							break;
    11ae:	5a c0       	rjmp	.+180    	; 0x1264 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    11b0:	d8 01       	movw	r26, r16
    11b2:	16 96       	adiw	r26, 0x06	; 6
    11b4:	8d 91       	ld	r24, X+
    11b6:	9c 91       	ld	r25, X
    11b8:	17 97       	sbiw	r26, 0x07	; 7
    11ba:	0e 94 af 15 	call	0x2b5e	; 0x2b5e <_Z17print_task_stacksP8emstream>
							break;
    11be:	52 c0       	rjmp	.+164    	; 0x1264 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    11c0:	c8 01       	movw	r24, r16
    11c2:	0e 94 e5 06 	call	0xdca	; 0xdca <_ZN9task_user18print_help_messageEv>
							break;
    11c6:	4e c0       	rjmp	.+156    	; 0x1264 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    11c8:	6a e0       	ldi	r22, 0x0A	; 10
    11ca:	f8 01       	movw	r30, r16
    11cc:	86 81       	ldd	r24, Z+6	; 0x06
    11ce:	97 81       	ldd	r25, Z+7	; 0x07
    11d0:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    11d4:	7c 01       	movw	r14, r24
    11d6:	66 e1       	ldi	r22, 0x16	; 22
    11d8:	74 e0       	ldi	r23, 0x04	; 4
    11da:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    11de:	66 e0       	ldi	r22, 0x06	; 6
    11e0:	c7 01       	movw	r24, r14
    11e2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11e6:	60 e0       	ldi	r22, 0x00	; 0
    11e8:	c8 01       	movw	r24, r16
    11ea:	0e 94 96 14 	call	0x292c	; 0x292c <_ZN8frt_task13transition_toEh>
							break;
    11ee:	3a c0       	rjmp	.+116    	; 0x1264 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11f0:	f8 01       	movw	r30, r16
    11f2:	a6 81       	ldd	r26, Z+6	; 0x06
    11f4:	b7 81       	ldd	r27, Z+7	; 0x07
    11f6:	ed 91       	ld	r30, X+
    11f8:	fc 91       	ld	r31, X
    11fa:	11 97       	sbiw	r26, 0x01	; 1
    11fc:	02 80       	ldd	r0, Z+2	; 0x02
    11fe:	f3 81       	ldd	r31, Z+3	; 0x03
    1200:	e0 2d       	mov	r30, r0
    1202:	68 2f       	mov	r22, r24
    1204:	cd 01       	movw	r24, r26
    1206:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1208:	6a e0       	ldi	r22, 0x0A	; 10
    120a:	d8 01       	movw	r26, r16
    120c:	16 96       	adiw	r26, 0x06	; 6
    120e:	8d 91       	ld	r24, X+
    1210:	9c 91       	ld	r25, X
    1212:	17 97       	sbiw	r26, 0x07	; 7
    1214:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    1218:	7c 01       	movw	r14, r24
    121a:	60 e1       	ldi	r22, 0x10	; 16
    121c:	74 e0       	ldi	r23, 0x04	; 4
    121e:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    1222:	66 e0       	ldi	r22, 0x06	; 6
    1224:	c7 01       	movw	r24, r14
    1226:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
							break;
    122a:	1c c0       	rjmp	.+56     	; 0x1264 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    122c:	6a e0       	ldi	r22, 0x0A	; 10
    122e:	f8 01       	movw	r30, r16
    1230:	86 81       	ldd	r24, Z+6	; 0x06
    1232:	97 81       	ldd	r25, Z+7	; 0x07
    1234:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    1238:	8c 01       	movw	r16, r24
    123a:	63 ef       	ldi	r22, 0xF3	; 243
    123c:	73 e0       	ldi	r23, 0x03	; 3
    123e:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    1242:	66 e0       	ldi	r22, 0x06	; 6
    1244:	c8 01       	movw	r24, r16
    1246:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    124a:	93 e0       	ldi	r25, 0x03	; 3
    124c:	88 ed       	ldi	r24, 0xD8	; 216
    124e:	08 b6       	in	r0, 0x38	; 56
    1250:	18 be       	out	0x38, r1	; 56
    1252:	84 bf       	out	0x34, r24	; 52
    1254:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1258:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    125c:	81 fd       	sbrc	r24, 1
    125e:	fc cf       	rjmp	.-8      	; 0x1258 <_ZN9task_user3runEv+0x228>
    1260:	08 be       	out	0x38, r0	; 56
    1262:	ff cf       	rjmp	.-2      	; 0x1262 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1264:	f8 01       	movw	r30, r16
    1266:	86 85       	ldd	r24, Z+14	; 0x0e
    1268:	97 85       	ldd	r25, Z+15	; 0x0f
    126a:	a0 89       	ldd	r26, Z+16	; 0x10
    126c:	b1 89       	ldd	r27, Z+17	; 0x11
    126e:	01 96       	adiw	r24, 0x01	; 1
    1270:	a1 1d       	adc	r26, r1
    1272:	b1 1d       	adc	r27, r1
    1274:	86 87       	std	Z+14, r24	; 0x0e
    1276:	97 87       	std	Z+15, r25	; 0x0f
    1278:	a0 8b       	std	Z+16, r26	; 0x10
    127a:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    127c:	61 e0       	ldi	r22, 0x01	; 1
    127e:	70 e0       	ldi	r23, 0x00	; 0
    1280:	80 e0       	ldi	r24, 0x00	; 0
    1282:	90 e0       	ldi	r25, 0x00	; 0
    1284:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1288:	f1 ce       	rjmp	.-542    	; 0x106c <_ZN9task_user3runEv+0x3c>

0000128a <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    128a:	0f 93       	push	r16
    128c:	1f 93       	push	r17
    128e:	cf 93       	push	r28
    1290:	df 93       	push	r29
    1292:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1294:	0e 94 59 10 	call	0x20b2	; 0x20b2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1298:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    129c:	81 11       	cpse	r24, r1
    129e:	1d c0       	rjmp	.+58     	; 0x12da <pvPortMalloc+0x50>
		{
			prvHeapInit();
    12a0:	a1 ec       	ldi	r26, 0xC1	; 193
    12a2:	b0 e2       	ldi	r27, 0x20	; 32
    12a4:	e5 ec       	ldi	r30, 0xC5	; 197
    12a6:	f0 e2       	ldi	r31, 0x20	; 32
    12a8:	ed 93       	st	X+, r30
    12aa:	fc 93       	st	X, r31
    12ac:	11 97       	sbiw	r26, 0x01	; 1
    12ae:	12 96       	adiw	r26, 0x02	; 2
    12b0:	1d 92       	st	X+, r1
    12b2:	1c 92       	st	X, r1
    12b4:	13 97       	sbiw	r26, 0x03	; 3
    12b6:	ad eb       	ldi	r26, 0xBD	; 189
    12b8:	b0 e2       	ldi	r27, 0x20	; 32
    12ba:	8f ef       	ldi	r24, 0xFF	; 255
    12bc:	9f e0       	ldi	r25, 0x0F	; 15
    12be:	12 96       	adiw	r26, 0x02	; 2
    12c0:	8d 93       	st	X+, r24
    12c2:	9c 93       	st	X, r25
    12c4:	13 97       	sbiw	r26, 0x03	; 3
    12c6:	1d 92       	st	X+, r1
    12c8:	1c 92       	st	X, r1
    12ca:	11 97       	sbiw	r26, 0x01	; 1
    12cc:	82 83       	std	Z+2, r24	; 0x02
    12ce:	93 83       	std	Z+3, r25	; 0x03
    12d0:	a0 83       	st	Z, r26
    12d2:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12da:	20 97       	sbiw	r28, 0x00	; 0
    12dc:	09 f4       	brne	.+2      	; 0x12e0 <pvPortMalloc+0x56>
    12de:	5f c0       	rjmp	.+190    	; 0x139e <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12e0:	9e 01       	movw	r18, r28
    12e2:	2b 5f       	subi	r18, 0xFB	; 251
    12e4:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    12e6:	24 96       	adiw	r28, 0x04	; 4
    12e8:	ce 3f       	cpi	r28, 0xFE	; 254
    12ea:	df 40       	sbci	r29, 0x0F	; 15
    12ec:	08 f0       	brcs	.+2      	; 0x12f0 <pvPortMalloc+0x66>
    12ee:	5a c0       	rjmp	.+180    	; 0x13a4 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    12f0:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    12f4:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    12f8:	a1 ec       	ldi	r26, 0xC1	; 193
    12fa:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12fc:	02 c0       	rjmp	.+4      	; 0x1302 <pvPortMalloc+0x78>
    12fe:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1300:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1302:	82 81       	ldd	r24, Z+2	; 0x02
    1304:	93 81       	ldd	r25, Z+3	; 0x03
    1306:	82 17       	cp	r24, r18
    1308:	93 07       	cpc	r25, r19
    130a:	20 f4       	brcc	.+8      	; 0x1314 <pvPortMalloc+0x8a>
    130c:	80 81       	ld	r24, Z
    130e:	91 81       	ldd	r25, Z+1	; 0x01
    1310:	00 97       	sbiw	r24, 0x00	; 0
    1312:	a9 f7       	brne	.-22     	; 0x12fe <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1314:	c0 e2       	ldi	r28, 0x20	; 32
    1316:	ed 3b       	cpi	r30, 0xBD	; 189
    1318:	fc 07       	cpc	r31, r28
    131a:	09 f4       	brne	.+2      	; 0x131e <pvPortMalloc+0x94>
    131c:	46 c0       	rjmp	.+140    	; 0x13aa <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    131e:	cd 91       	ld	r28, X+
    1320:	dc 91       	ld	r29, X
    1322:	11 97       	sbiw	r26, 0x01	; 1
    1324:	8e 01       	movw	r16, r28
    1326:	0b 5f       	subi	r16, 0xFB	; 251
    1328:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    132a:	80 81       	ld	r24, Z
    132c:	91 81       	ldd	r25, Z+1	; 0x01
    132e:	8d 93       	st	X+, r24
    1330:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1332:	82 81       	ldd	r24, Z+2	; 0x02
    1334:	93 81       	ldd	r25, Z+3	; 0x03
    1336:	82 1b       	sub	r24, r18
    1338:	93 0b       	sbc	r25, r19
    133a:	8b 30       	cpi	r24, 0x0B	; 11
    133c:	91 05       	cpc	r25, r1
    133e:	10 f1       	brcs	.+68     	; 0x1384 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1340:	bf 01       	movw	r22, r30
    1342:	62 0f       	add	r22, r18
    1344:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1346:	db 01       	movw	r26, r22
    1348:	12 96       	adiw	r26, 0x02	; 2
    134a:	8d 93       	st	X+, r24
    134c:	9c 93       	st	X, r25
    134e:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1350:	22 83       	std	Z+2, r18	; 0x02
    1352:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1354:	12 96       	adiw	r26, 0x02	; 2
    1356:	4d 91       	ld	r20, X+
    1358:	5c 91       	ld	r21, X
    135a:	13 97       	sbiw	r26, 0x03	; 3
    135c:	81 ec       	ldi	r24, 0xC1	; 193
    135e:	90 e2       	ldi	r25, 0x20	; 32
    1360:	01 c0       	rjmp	.+2      	; 0x1364 <pvPortMalloc+0xda>
    1362:	cd 01       	movw	r24, r26
    1364:	ec 01       	movw	r28, r24
    1366:	a8 81       	ld	r26, Y
    1368:	b9 81       	ldd	r27, Y+1	; 0x01
    136a:	12 96       	adiw	r26, 0x02	; 2
    136c:	2d 91       	ld	r18, X+
    136e:	3c 91       	ld	r19, X
    1370:	13 97       	sbiw	r26, 0x03	; 3
    1372:	24 17       	cp	r18, r20
    1374:	35 07       	cpc	r19, r21
    1376:	a8 f3       	brcs	.-22     	; 0x1362 <pvPortMalloc+0xd8>
    1378:	eb 01       	movw	r28, r22
    137a:	a8 83       	st	Y, r26
    137c:	b9 83       	std	Y+1, r27	; 0x01
    137e:	dc 01       	movw	r26, r24
    1380:	6d 93       	st	X+, r22
    1382:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1384:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1388:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    138c:	22 81       	ldd	r18, Z+2	; 0x02
    138e:	33 81       	ldd	r19, Z+3	; 0x03
    1390:	82 1b       	sub	r24, r18
    1392:	93 0b       	sbc	r25, r19
    1394:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1398:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    139c:	08 c0       	rjmp	.+16     	; 0x13ae <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    139e:	00 e0       	ldi	r16, 0x00	; 0
    13a0:	10 e0       	ldi	r17, 0x00	; 0
    13a2:	05 c0       	rjmp	.+10     	; 0x13ae <pvPortMalloc+0x124>
    13a4:	00 e0       	ldi	r16, 0x00	; 0
    13a6:	10 e0       	ldi	r17, 0x00	; 0
    13a8:	02 c0       	rjmp	.+4      	; 0x13ae <pvPortMalloc+0x124>
    13aa:	00 e0       	ldi	r16, 0x00	; 0
    13ac:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    13ae:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    13b2:	c8 01       	movw	r24, r16
    13b4:	df 91       	pop	r29
    13b6:	cf 91       	pop	r28
    13b8:	1f 91       	pop	r17
    13ba:	0f 91       	pop	r16
    13bc:	08 95       	ret

000013be <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    13be:	0f 93       	push	r16
    13c0:	1f 93       	push	r17
    13c2:	cf 93       	push	r28
    13c4:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    13c6:	00 97       	sbiw	r24, 0x00	; 0
    13c8:	41 f1       	breq	.+80     	; 0x141a <vPortFree+0x5c>
    13ca:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    13cc:	8c 01       	movw	r16, r24
    13ce:	05 50       	subi	r16, 0x05	; 5
    13d0:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    13d2:	0e 94 59 10 	call	0x20b2	; 0x20b2 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    13d6:	f8 01       	movw	r30, r16
    13d8:	42 81       	ldd	r20, Z+2	; 0x02
    13da:	53 81       	ldd	r21, Z+3	; 0x03
    13dc:	a1 ec       	ldi	r26, 0xC1	; 193
    13de:	b0 e2       	ldi	r27, 0x20	; 32
    13e0:	01 c0       	rjmp	.+2      	; 0x13e4 <vPortFree+0x26>
    13e2:	df 01       	movw	r26, r30
    13e4:	ed 91       	ld	r30, X+
    13e6:	fc 91       	ld	r31, X
    13e8:	11 97       	sbiw	r26, 0x01	; 1
    13ea:	22 81       	ldd	r18, Z+2	; 0x02
    13ec:	33 81       	ldd	r19, Z+3	; 0x03
    13ee:	24 17       	cp	r18, r20
    13f0:	35 07       	cpc	r19, r21
    13f2:	b8 f3       	brcs	.-18     	; 0x13e2 <vPortFree+0x24>
    13f4:	25 97       	sbiw	r28, 0x05	; 5
    13f6:	e8 83       	st	Y, r30
    13f8:	f9 83       	std	Y+1, r31	; 0x01
    13fa:	0d 93       	st	X+, r16
    13fc:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    13fe:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1402:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1406:	8a 81       	ldd	r24, Y+2	; 0x02
    1408:	9b 81       	ldd	r25, Y+3	; 0x03
    140a:	82 0f       	add	r24, r18
    140c:	93 1f       	adc	r25, r19
    140e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1412:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1416:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
	}
}
    141a:	df 91       	pop	r29
    141c:	cf 91       	pop	r28
    141e:	1f 91       	pop	r17
    1420:	0f 91       	pop	r16
    1422:	08 95       	ret

00001424 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1424:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1428:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    142c:	08 95       	ret

0000142e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    142e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1430:	03 96       	adiw	r24, 0x03	; 3
    1432:	81 83       	std	Z+1, r24	; 0x01
    1434:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1436:	4f ef       	ldi	r20, 0xFF	; 255
    1438:	5f ef       	ldi	r21, 0xFF	; 255
    143a:	ba 01       	movw	r22, r20
    143c:	43 83       	std	Z+3, r20	; 0x03
    143e:	54 83       	std	Z+4, r21	; 0x04
    1440:	65 83       	std	Z+5, r22	; 0x05
    1442:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1444:	87 83       	std	Z+7, r24	; 0x07
    1446:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1448:	81 87       	std	Z+9, r24	; 0x09
    144a:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    144c:	10 82       	st	Z, r1
    144e:	08 95       	ret

00001450 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1450:	fc 01       	movw	r30, r24
    1452:	12 86       	std	Z+10, r1	; 0x0a
    1454:	13 86       	std	Z+11, r1	; 0x0b
    1456:	08 95       	ret

00001458 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	fc 01       	movw	r30, r24
    145e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1460:	21 81       	ldd	r18, Z+1	; 0x01
    1462:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1464:	e9 01       	movw	r28, r18
    1466:	8c 81       	ldd	r24, Y+4	; 0x04
    1468:	9d 81       	ldd	r25, Y+5	; 0x05
    146a:	14 96       	adiw	r26, 0x04	; 4
    146c:	8d 93       	st	X+, r24
    146e:	9c 93       	st	X, r25
    1470:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1472:	81 81       	ldd	r24, Z+1	; 0x01
    1474:	92 81       	ldd	r25, Z+2	; 0x02
    1476:	16 96       	adiw	r26, 0x06	; 6
    1478:	8d 93       	st	X+, r24
    147a:	9c 93       	st	X, r25
    147c:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    147e:	8c 81       	ldd	r24, Y+4	; 0x04
    1480:	9d 81       	ldd	r25, Y+5	; 0x05
    1482:	ec 01       	movw	r28, r24
    1484:	6e 83       	std	Y+6, r22	; 0x06
    1486:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1488:	e9 01       	movw	r28, r18
    148a:	6c 83       	std	Y+4, r22	; 0x04
    148c:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    148e:	61 83       	std	Z+1, r22	; 0x01
    1490:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1492:	1a 96       	adiw	r26, 0x0a	; 10
    1494:	ed 93       	st	X+, r30
    1496:	fc 93       	st	X, r31
    1498:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    149a:	80 81       	ld	r24, Z
    149c:	8f 5f       	subi	r24, 0xFF	; 255
    149e:	80 83       	st	Z, r24
}
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	08 95       	ret

000014a6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    14a6:	0f 93       	push	r16
    14a8:	1f 93       	push	r17
    14aa:	cf 93       	push	r28
    14ac:	df 93       	push	r29
    14ae:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    14b0:	08 81       	ld	r16, Y
    14b2:	19 81       	ldd	r17, Y+1	; 0x01
    14b4:	2a 81       	ldd	r18, Y+2	; 0x02
    14b6:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14b8:	0f 3f       	cpi	r16, 0xFF	; 255
    14ba:	4f ef       	ldi	r20, 0xFF	; 255
    14bc:	14 07       	cpc	r17, r20
    14be:	24 07       	cpc	r18, r20
    14c0:	34 07       	cpc	r19, r20
    14c2:	31 f4       	brne	.+12     	; 0x14d0 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14c4:	dc 01       	movw	r26, r24
    14c6:	19 96       	adiw	r26, 0x09	; 9
    14c8:	ed 91       	ld	r30, X+
    14ca:	fc 91       	ld	r31, X
    14cc:	1a 97       	sbiw	r26, 0x0a	; 10
    14ce:	1f c0       	rjmp	.+62     	; 0x150e <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14d0:	fc 01       	movw	r30, r24
    14d2:	33 96       	adiw	r30, 0x03	; 3
    14d4:	dc 01       	movw	r26, r24
    14d6:	17 96       	adiw	r26, 0x07	; 7
    14d8:	4d 91       	ld	r20, X+
    14da:	5c 91       	ld	r21, X
    14dc:	18 97       	sbiw	r26, 0x08	; 8
    14de:	da 01       	movw	r26, r20
    14e0:	4d 91       	ld	r20, X+
    14e2:	5d 91       	ld	r21, X+
    14e4:	6d 91       	ld	r22, X+
    14e6:	7c 91       	ld	r23, X
    14e8:	04 17       	cp	r16, r20
    14ea:	15 07       	cpc	r17, r21
    14ec:	26 07       	cpc	r18, r22
    14ee:	37 07       	cpc	r19, r23
    14f0:	70 f0       	brcs	.+28     	; 0x150e <vListInsert+0x68>
    14f2:	04 80       	ldd	r0, Z+4	; 0x04
    14f4:	f5 81       	ldd	r31, Z+5	; 0x05
    14f6:	e0 2d       	mov	r30, r0
    14f8:	a4 81       	ldd	r26, Z+4	; 0x04
    14fa:	b5 81       	ldd	r27, Z+5	; 0x05
    14fc:	4d 91       	ld	r20, X+
    14fe:	5d 91       	ld	r21, X+
    1500:	6d 91       	ld	r22, X+
    1502:	7c 91       	ld	r23, X
    1504:	04 17       	cp	r16, r20
    1506:	15 07       	cpc	r17, r21
    1508:	26 07       	cpc	r18, r22
    150a:	37 07       	cpc	r19, r23
    150c:	90 f7       	brcc	.-28     	; 0x14f2 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    150e:	a4 81       	ldd	r26, Z+4	; 0x04
    1510:	b5 81       	ldd	r27, Z+5	; 0x05
    1512:	ac 83       	std	Y+4, r26	; 0x04
    1514:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1516:	16 96       	adiw	r26, 0x06	; 6
    1518:	cd 93       	st	X+, r28
    151a:	dc 93       	st	X, r29
    151c:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    151e:	ee 83       	std	Y+6, r30	; 0x06
    1520:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1522:	c4 83       	std	Z+4, r28	; 0x04
    1524:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1526:	8a 87       	std	Y+10, r24	; 0x0a
    1528:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    152a:	fc 01       	movw	r30, r24
    152c:	20 81       	ld	r18, Z
    152e:	2f 5f       	subi	r18, 0xFF	; 255
    1530:	20 83       	st	Z, r18
}
    1532:	df 91       	pop	r29
    1534:	cf 91       	pop	r28
    1536:	1f 91       	pop	r17
    1538:	0f 91       	pop	r16
    153a:	08 95       	ret

0000153c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    153c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    153e:	a4 81       	ldd	r26, Z+4	; 0x04
    1540:	b5 81       	ldd	r27, Z+5	; 0x05
    1542:	86 81       	ldd	r24, Z+6	; 0x06
    1544:	97 81       	ldd	r25, Z+7	; 0x07
    1546:	16 96       	adiw	r26, 0x06	; 6
    1548:	8d 93       	st	X+, r24
    154a:	9c 93       	st	X, r25
    154c:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    154e:	a6 81       	ldd	r26, Z+6	; 0x06
    1550:	b7 81       	ldd	r27, Z+7	; 0x07
    1552:	84 81       	ldd	r24, Z+4	; 0x04
    1554:	95 81       	ldd	r25, Z+5	; 0x05
    1556:	14 96       	adiw	r26, 0x04	; 4
    1558:	8d 93       	st	X+, r24
    155a:	9c 93       	st	X, r25
    155c:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    155e:	a2 85       	ldd	r26, Z+10	; 0x0a
    1560:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1562:	11 96       	adiw	r26, 0x01	; 1
    1564:	8d 91       	ld	r24, X+
    1566:	9c 91       	ld	r25, X
    1568:	12 97       	sbiw	r26, 0x02	; 2
    156a:	e8 17       	cp	r30, r24
    156c:	f9 07       	cpc	r31, r25
    156e:	31 f4       	brne	.+12     	; 0x157c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1570:	86 81       	ldd	r24, Z+6	; 0x06
    1572:	97 81       	ldd	r25, Z+7	; 0x07
    1574:	11 96       	adiw	r26, 0x01	; 1
    1576:	8d 93       	st	X+, r24
    1578:	9c 93       	st	X, r25
    157a:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    157c:	12 86       	std	Z+10, r1	; 0x0a
    157e:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1580:	8c 91       	ld	r24, X
    1582:	81 50       	subi	r24, 0x01	; 1
    1584:	8c 93       	st	X, r24
    1586:	08 95       	ret

00001588 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1588:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <portStackTopForTask>
    158c:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <portStackTopForTask+0x1>
    1590:	31 e1       	ldi	r19, 0x11	; 17
    1592:	fc 01       	movw	r30, r24
    1594:	30 83       	st	Z, r19
    1596:	31 97       	sbiw	r30, 0x01	; 1
    1598:	22 e2       	ldi	r18, 0x22	; 34
    159a:	20 83       	st	Z, r18
    159c:	31 97       	sbiw	r30, 0x01	; 1
    159e:	a3 e3       	ldi	r26, 0x33	; 51
    15a0:	a0 83       	st	Z, r26
    15a2:	31 97       	sbiw	r30, 0x01	; 1
    15a4:	60 83       	st	Z, r22
    15a6:	31 97       	sbiw	r30, 0x01	; 1
    15a8:	70 83       	st	Z, r23
    15aa:	31 97       	sbiw	r30, 0x01	; 1
    15ac:	10 82       	st	Z, r1
    15ae:	31 97       	sbiw	r30, 0x01	; 1
    15b0:	10 82       	st	Z, r1
    15b2:	31 97       	sbiw	r30, 0x01	; 1
    15b4:	60 e8       	ldi	r22, 0x80	; 128
    15b6:	60 83       	st	Z, r22
    15b8:	31 97       	sbiw	r30, 0x01	; 1
    15ba:	10 82       	st	Z, r1
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	10 82       	st	Z, r1
    15c0:	31 97       	sbiw	r30, 0x01	; 1
    15c2:	10 82       	st	Z, r1
    15c4:	31 97       	sbiw	r30, 0x01	; 1
    15c6:	62 e0       	ldi	r22, 0x02	; 2
    15c8:	60 83       	st	Z, r22
    15ca:	31 97       	sbiw	r30, 0x01	; 1
    15cc:	63 e0       	ldi	r22, 0x03	; 3
    15ce:	60 83       	st	Z, r22
    15d0:	31 97       	sbiw	r30, 0x01	; 1
    15d2:	64 e0       	ldi	r22, 0x04	; 4
    15d4:	60 83       	st	Z, r22
    15d6:	31 97       	sbiw	r30, 0x01	; 1
    15d8:	65 e0       	ldi	r22, 0x05	; 5
    15da:	60 83       	st	Z, r22
    15dc:	31 97       	sbiw	r30, 0x01	; 1
    15de:	66 e0       	ldi	r22, 0x06	; 6
    15e0:	60 83       	st	Z, r22
    15e2:	31 97       	sbiw	r30, 0x01	; 1
    15e4:	67 e0       	ldi	r22, 0x07	; 7
    15e6:	60 83       	st	Z, r22
    15e8:	31 97       	sbiw	r30, 0x01	; 1
    15ea:	68 e0       	ldi	r22, 0x08	; 8
    15ec:	60 83       	st	Z, r22
    15ee:	31 97       	sbiw	r30, 0x01	; 1
    15f0:	69 e0       	ldi	r22, 0x09	; 9
    15f2:	60 83       	st	Z, r22
    15f4:	31 97       	sbiw	r30, 0x01	; 1
    15f6:	60 e1       	ldi	r22, 0x10	; 16
    15f8:	60 83       	st	Z, r22
    15fa:	31 97       	sbiw	r30, 0x01	; 1
    15fc:	30 83       	st	Z, r19
    15fe:	31 97       	sbiw	r30, 0x01	; 1
    1600:	32 e1       	ldi	r19, 0x12	; 18
    1602:	30 83       	st	Z, r19
    1604:	31 97       	sbiw	r30, 0x01	; 1
    1606:	33 e1       	ldi	r19, 0x13	; 19
    1608:	30 83       	st	Z, r19
    160a:	31 97       	sbiw	r30, 0x01	; 1
    160c:	34 e1       	ldi	r19, 0x14	; 20
    160e:	30 83       	st	Z, r19
    1610:	31 97       	sbiw	r30, 0x01	; 1
    1612:	35 e1       	ldi	r19, 0x15	; 21
    1614:	30 83       	st	Z, r19
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	36 e1       	ldi	r19, 0x16	; 22
    161a:	30 83       	st	Z, r19
    161c:	31 97       	sbiw	r30, 0x01	; 1
    161e:	37 e1       	ldi	r19, 0x17	; 23
    1620:	30 83       	st	Z, r19
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	38 e1       	ldi	r19, 0x18	; 24
    1626:	30 83       	st	Z, r19
    1628:	31 97       	sbiw	r30, 0x01	; 1
    162a:	39 e1       	ldi	r19, 0x19	; 25
    162c:	30 83       	st	Z, r19
    162e:	31 97       	sbiw	r30, 0x01	; 1
    1630:	30 e2       	ldi	r19, 0x20	; 32
    1632:	30 83       	st	Z, r19
    1634:	31 97       	sbiw	r30, 0x01	; 1
    1636:	31 e2       	ldi	r19, 0x21	; 33
    1638:	30 83       	st	Z, r19
    163a:	31 97       	sbiw	r30, 0x01	; 1
    163c:	20 83       	st	Z, r18
    163e:	31 97       	sbiw	r30, 0x01	; 1
    1640:	23 e2       	ldi	r18, 0x23	; 35
    1642:	20 83       	st	Z, r18
    1644:	31 97       	sbiw	r30, 0x01	; 1
    1646:	40 83       	st	Z, r20
    1648:	31 97       	sbiw	r30, 0x01	; 1
    164a:	50 83       	st	Z, r21
    164c:	31 97       	sbiw	r30, 0x01	; 1
    164e:	26 e2       	ldi	r18, 0x26	; 38
    1650:	20 83       	st	Z, r18
    1652:	31 97       	sbiw	r30, 0x01	; 1
    1654:	27 e2       	ldi	r18, 0x27	; 39
    1656:	20 83       	st	Z, r18
    1658:	31 97       	sbiw	r30, 0x01	; 1
    165a:	28 e2       	ldi	r18, 0x28	; 40
    165c:	20 83       	st	Z, r18
    165e:	31 97       	sbiw	r30, 0x01	; 1
    1660:	29 e2       	ldi	r18, 0x29	; 41
    1662:	20 83       	st	Z, r18
    1664:	31 97       	sbiw	r30, 0x01	; 1
    1666:	20 e3       	ldi	r18, 0x30	; 48
    1668:	20 83       	st	Z, r18
    166a:	31 97       	sbiw	r30, 0x01	; 1
    166c:	21 e3       	ldi	r18, 0x31	; 49
    166e:	20 83       	st	Z, r18
    1670:	89 97       	sbiw	r24, 0x29	; 41
    1672:	08 95       	ret

00001674 <xPortStartScheduler>:
    1674:	8c e7       	ldi	r24, 0x7C	; 124
    1676:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    167a:	8f ef       	ldi	r24, 0xFF	; 255
    167c:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1686:	91 e1       	ldi	r25, 0x11	; 17
    1688:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    168c:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1690:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1694:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1698:	cd 91       	ld	r28, X+
    169a:	cd bf       	out	0x3d, r28	; 61
    169c:	dd 91       	ld	r29, X+
    169e:	de bf       	out	0x3e, r29	; 62
    16a0:	ff 91       	pop	r31
    16a2:	ef 91       	pop	r30
    16a4:	df 91       	pop	r29
    16a6:	cf 91       	pop	r28
    16a8:	bf 91       	pop	r27
    16aa:	af 91       	pop	r26
    16ac:	9f 91       	pop	r25
    16ae:	8f 91       	pop	r24
    16b0:	7f 91       	pop	r23
    16b2:	6f 91       	pop	r22
    16b4:	5f 91       	pop	r21
    16b6:	4f 91       	pop	r20
    16b8:	3f 91       	pop	r19
    16ba:	2f 91       	pop	r18
    16bc:	1f 91       	pop	r17
    16be:	0f 91       	pop	r16
    16c0:	ff 90       	pop	r15
    16c2:	ef 90       	pop	r14
    16c4:	df 90       	pop	r13
    16c6:	cf 90       	pop	r12
    16c8:	bf 90       	pop	r11
    16ca:	af 90       	pop	r10
    16cc:	9f 90       	pop	r9
    16ce:	8f 90       	pop	r8
    16d0:	7f 90       	pop	r7
    16d2:	6f 90       	pop	r6
    16d4:	5f 90       	pop	r5
    16d6:	4f 90       	pop	r4
    16d8:	3f 90       	pop	r3
    16da:	2f 90       	pop	r2
    16dc:	1f 90       	pop	r1
    16de:	0f 90       	pop	r0
    16e0:	0c be       	out	0x3c, r0	; 60
    16e2:	0f 90       	pop	r0
    16e4:	0b be       	out	0x3b, r0	; 59
    16e6:	0f 90       	pop	r0
    16e8:	0f be       	out	0x3f, r0	; 63
    16ea:	0f 90       	pop	r0
    16ec:	08 95       	ret
    16ee:	08 95       	ret

000016f0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16f0:	0f 92       	push	r0
    16f2:	0f b6       	in	r0, 0x3f	; 63
    16f4:	f8 94       	cli
    16f6:	0f 92       	push	r0
    16f8:	0b b6       	in	r0, 0x3b	; 59
    16fa:	0f 92       	push	r0
    16fc:	0c b6       	in	r0, 0x3c	; 60
    16fe:	0f 92       	push	r0
    1700:	1f 92       	push	r1
    1702:	11 24       	eor	r1, r1
    1704:	2f 92       	push	r2
    1706:	3f 92       	push	r3
    1708:	4f 92       	push	r4
    170a:	5f 92       	push	r5
    170c:	6f 92       	push	r6
    170e:	7f 92       	push	r7
    1710:	8f 92       	push	r8
    1712:	9f 92       	push	r9
    1714:	af 92       	push	r10
    1716:	bf 92       	push	r11
    1718:	cf 92       	push	r12
    171a:	df 92       	push	r13
    171c:	ef 92       	push	r14
    171e:	ff 92       	push	r15
    1720:	0f 93       	push	r16
    1722:	1f 93       	push	r17
    1724:	2f 93       	push	r18
    1726:	3f 93       	push	r19
    1728:	4f 93       	push	r20
    172a:	5f 93       	push	r21
    172c:	6f 93       	push	r22
    172e:	7f 93       	push	r23
    1730:	8f 93       	push	r24
    1732:	9f 93       	push	r25
    1734:	af 93       	push	r26
    1736:	bf 93       	push	r27
    1738:	cf 93       	push	r28
    173a:	df 93       	push	r29
    173c:	ef 93       	push	r30
    173e:	ff 93       	push	r31
    1740:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1744:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1748:	0d b6       	in	r0, 0x3d	; 61
    174a:	0d 92       	st	X+, r0
    174c:	0e b6       	in	r0, 0x3e	; 62
    174e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1750:	0e 94 98 12 	call	0x2530	; 0x2530 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1754:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1758:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    175c:	cd 91       	ld	r28, X+
    175e:	cd bf       	out	0x3d, r28	; 61
    1760:	dd 91       	ld	r29, X+
    1762:	de bf       	out	0x3e, r29	; 62
    1764:	ff 91       	pop	r31
    1766:	ef 91       	pop	r30
    1768:	df 91       	pop	r29
    176a:	cf 91       	pop	r28
    176c:	bf 91       	pop	r27
    176e:	af 91       	pop	r26
    1770:	9f 91       	pop	r25
    1772:	8f 91       	pop	r24
    1774:	7f 91       	pop	r23
    1776:	6f 91       	pop	r22
    1778:	5f 91       	pop	r21
    177a:	4f 91       	pop	r20
    177c:	3f 91       	pop	r19
    177e:	2f 91       	pop	r18
    1780:	1f 91       	pop	r17
    1782:	0f 91       	pop	r16
    1784:	ff 90       	pop	r15
    1786:	ef 90       	pop	r14
    1788:	df 90       	pop	r13
    178a:	cf 90       	pop	r12
    178c:	bf 90       	pop	r11
    178e:	af 90       	pop	r10
    1790:	9f 90       	pop	r9
    1792:	8f 90       	pop	r8
    1794:	7f 90       	pop	r7
    1796:	6f 90       	pop	r6
    1798:	5f 90       	pop	r5
    179a:	4f 90       	pop	r4
    179c:	3f 90       	pop	r3
    179e:	2f 90       	pop	r2
    17a0:	1f 90       	pop	r1
    17a2:	0f 90       	pop	r0
    17a4:	0c be       	out	0x3c, r0	; 60
    17a6:	0f 90       	pop	r0
    17a8:	0b be       	out	0x3b, r0	; 59
    17aa:	0f 90       	pop	r0
    17ac:	0f be       	out	0x3f, r0	; 63
    17ae:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17b0:	08 95       	ret

000017b2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17b2:	0f 92       	push	r0
    17b4:	0f b6       	in	r0, 0x3f	; 63
    17b6:	f8 94       	cli
    17b8:	0f 92       	push	r0
    17ba:	0b b6       	in	r0, 0x3b	; 59
    17bc:	0f 92       	push	r0
    17be:	0c b6       	in	r0, 0x3c	; 60
    17c0:	0f 92       	push	r0
    17c2:	1f 92       	push	r1
    17c4:	11 24       	eor	r1, r1
    17c6:	2f 92       	push	r2
    17c8:	3f 92       	push	r3
    17ca:	4f 92       	push	r4
    17cc:	5f 92       	push	r5
    17ce:	6f 92       	push	r6
    17d0:	7f 92       	push	r7
    17d2:	8f 92       	push	r8
    17d4:	9f 92       	push	r9
    17d6:	af 92       	push	r10
    17d8:	bf 92       	push	r11
    17da:	cf 92       	push	r12
    17dc:	df 92       	push	r13
    17de:	ef 92       	push	r14
    17e0:	ff 92       	push	r15
    17e2:	0f 93       	push	r16
    17e4:	1f 93       	push	r17
    17e6:	2f 93       	push	r18
    17e8:	3f 93       	push	r19
    17ea:	4f 93       	push	r20
    17ec:	5f 93       	push	r21
    17ee:	6f 93       	push	r22
    17f0:	7f 93       	push	r23
    17f2:	8f 93       	push	r24
    17f4:	9f 93       	push	r25
    17f6:	af 93       	push	r26
    17f8:	bf 93       	push	r27
    17fa:	cf 93       	push	r28
    17fc:	df 93       	push	r29
    17fe:	ef 93       	push	r30
    1800:	ff 93       	push	r31
    1802:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1806:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    180a:	0d b6       	in	r0, 0x3d	; 61
    180c:	0d 92       	st	X+, r0
    180e:	0e b6       	in	r0, 0x3e	; 62
    1810:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1812:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <vTaskIncrementTick>
	vTaskSwitchContext();
    1816:	0e 94 98 12 	call	0x2530	; 0x2530 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    181a:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    181e:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1822:	cd 91       	ld	r28, X+
    1824:	cd bf       	out	0x3d, r28	; 61
    1826:	dd 91       	ld	r29, X+
    1828:	de bf       	out	0x3e, r29	; 62
    182a:	ff 91       	pop	r31
    182c:	ef 91       	pop	r30
    182e:	df 91       	pop	r29
    1830:	cf 91       	pop	r28
    1832:	bf 91       	pop	r27
    1834:	af 91       	pop	r26
    1836:	9f 91       	pop	r25
    1838:	8f 91       	pop	r24
    183a:	7f 91       	pop	r23
    183c:	6f 91       	pop	r22
    183e:	5f 91       	pop	r21
    1840:	4f 91       	pop	r20
    1842:	3f 91       	pop	r19
    1844:	2f 91       	pop	r18
    1846:	1f 91       	pop	r17
    1848:	0f 91       	pop	r16
    184a:	ff 90       	pop	r15
    184c:	ef 90       	pop	r14
    184e:	df 90       	pop	r13
    1850:	cf 90       	pop	r12
    1852:	bf 90       	pop	r11
    1854:	af 90       	pop	r10
    1856:	9f 90       	pop	r9
    1858:	8f 90       	pop	r8
    185a:	7f 90       	pop	r7
    185c:	6f 90       	pop	r6
    185e:	5f 90       	pop	r5
    1860:	4f 90       	pop	r4
    1862:	3f 90       	pop	r3
    1864:	2f 90       	pop	r2
    1866:	1f 90       	pop	r1
    1868:	0f 90       	pop	r0
    186a:	0c be       	out	0x3c, r0	; 60
    186c:	0f 90       	pop	r0
    186e:	0b be       	out	0x3b, r0	; 59
    1870:	0f 90       	pop	r0
    1872:	0f be       	out	0x3f, r0	; 63
    1874:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1876:	08 95       	ret

00001878 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1878:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <vPortYieldFromTick>
		asm volatile ( "reti" );
    187c:	18 95       	reti

0000187e <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    187e:	cf 93       	push	r28
    1880:	df 93       	push	r29
    1882:	ec 01       	movw	r28, r24
    1884:	88 a1       	ldd	r24, Y+32	; 0x20
    1886:	81 11       	cpse	r24, r1
    1888:	0b c0       	rjmp	.+22     	; 0x18a0 <prvCopyDataToQueue+0x22>
    188a:	88 81       	ld	r24, Y
    188c:	99 81       	ldd	r25, Y+1	; 0x01
    188e:	89 2b       	or	r24, r25
    1890:	e1 f5       	brne	.+120    	; 0x190a <prvCopyDataToQueue+0x8c>
    1892:	8a 81       	ldd	r24, Y+2	; 0x02
    1894:	9b 81       	ldd	r25, Y+3	; 0x03
    1896:	0e 94 53 14 	call	0x28a6	; 0x28a6 <vTaskPriorityDisinherit>
    189a:	1a 82       	std	Y+2, r1	; 0x02
    189c:	1b 82       	std	Y+3, r1	; 0x03
    189e:	35 c0       	rjmp	.+106    	; 0x190a <prvCopyDataToQueue+0x8c>
    18a0:	41 11       	cpse	r20, r1
    18a2:	17 c0       	rjmp	.+46     	; 0x18d2 <prvCopyDataToQueue+0x54>
    18a4:	48 2f       	mov	r20, r24
    18a6:	50 e0       	ldi	r21, 0x00	; 0
    18a8:	8c 81       	ldd	r24, Y+4	; 0x04
    18aa:	9d 81       	ldd	r25, Y+5	; 0x05
    18ac:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <memcpy>
    18b0:	28 a1       	ldd	r18, Y+32	; 0x20
    18b2:	8c 81       	ldd	r24, Y+4	; 0x04
    18b4:	9d 81       	ldd	r25, Y+5	; 0x05
    18b6:	82 0f       	add	r24, r18
    18b8:	91 1d       	adc	r25, r1
    18ba:	8c 83       	std	Y+4, r24	; 0x04
    18bc:	9d 83       	std	Y+5, r25	; 0x05
    18be:	2a 81       	ldd	r18, Y+2	; 0x02
    18c0:	3b 81       	ldd	r19, Y+3	; 0x03
    18c2:	82 17       	cp	r24, r18
    18c4:	93 07       	cpc	r25, r19
    18c6:	08 f1       	brcs	.+66     	; 0x190a <prvCopyDataToQueue+0x8c>
    18c8:	88 81       	ld	r24, Y
    18ca:	99 81       	ldd	r25, Y+1	; 0x01
    18cc:	8c 83       	std	Y+4, r24	; 0x04
    18ce:	9d 83       	std	Y+5, r25	; 0x05
    18d0:	1c c0       	rjmp	.+56     	; 0x190a <prvCopyDataToQueue+0x8c>
    18d2:	48 2f       	mov	r20, r24
    18d4:	50 e0       	ldi	r21, 0x00	; 0
    18d6:	8e 81       	ldd	r24, Y+6	; 0x06
    18d8:	9f 81       	ldd	r25, Y+7	; 0x07
    18da:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <memcpy>
    18de:	88 a1       	ldd	r24, Y+32	; 0x20
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	91 95       	neg	r25
    18e4:	81 95       	neg	r24
    18e6:	91 09       	sbc	r25, r1
    18e8:	2e 81       	ldd	r18, Y+6	; 0x06
    18ea:	3f 81       	ldd	r19, Y+7	; 0x07
    18ec:	28 0f       	add	r18, r24
    18ee:	39 1f       	adc	r19, r25
    18f0:	2e 83       	std	Y+6, r18	; 0x06
    18f2:	3f 83       	std	Y+7, r19	; 0x07
    18f4:	48 81       	ld	r20, Y
    18f6:	59 81       	ldd	r21, Y+1	; 0x01
    18f8:	24 17       	cp	r18, r20
    18fa:	35 07       	cpc	r19, r21
    18fc:	30 f4       	brcc	.+12     	; 0x190a <prvCopyDataToQueue+0x8c>
    18fe:	2a 81       	ldd	r18, Y+2	; 0x02
    1900:	3b 81       	ldd	r19, Y+3	; 0x03
    1902:	82 0f       	add	r24, r18
    1904:	93 1f       	adc	r25, r19
    1906:	8e 83       	std	Y+6, r24	; 0x06
    1908:	9f 83       	std	Y+7, r25	; 0x07
    190a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    190c:	8f 5f       	subi	r24, 0xFF	; 255
    190e:	8e 8f       	std	Y+30, r24	; 0x1e
    1910:	df 91       	pop	r29
    1912:	cf 91       	pop	r28
    1914:	08 95       	ret

00001916 <prvCopyDataFromQueue>:
    1916:	fc 01       	movw	r30, r24
    1918:	80 81       	ld	r24, Z
    191a:	91 81       	ldd	r25, Z+1	; 0x01
    191c:	00 97       	sbiw	r24, 0x00	; 0
    191e:	a1 f0       	breq	.+40     	; 0x1948 <prvCopyDataFromQueue+0x32>
    1920:	40 a1       	ldd	r20, Z+32	; 0x20
    1922:	50 e0       	ldi	r21, 0x00	; 0
    1924:	26 81       	ldd	r18, Z+6	; 0x06
    1926:	37 81       	ldd	r19, Z+7	; 0x07
    1928:	24 0f       	add	r18, r20
    192a:	35 1f       	adc	r19, r21
    192c:	26 83       	std	Z+6, r18	; 0x06
    192e:	37 83       	std	Z+7, r19	; 0x07
    1930:	a2 81       	ldd	r26, Z+2	; 0x02
    1932:	b3 81       	ldd	r27, Z+3	; 0x03
    1934:	2a 17       	cp	r18, r26
    1936:	3b 07       	cpc	r19, r27
    1938:	10 f0       	brcs	.+4      	; 0x193e <prvCopyDataFromQueue+0x28>
    193a:	86 83       	std	Z+6, r24	; 0x06
    193c:	97 83       	std	Z+7, r25	; 0x07
    193e:	cb 01       	movw	r24, r22
    1940:	66 81       	ldd	r22, Z+6	; 0x06
    1942:	77 81       	ldd	r23, Z+7	; 0x07
    1944:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <memcpy>
    1948:	08 95       	ret

0000194a <prvUnlockQueue>:
    194a:	0f 93       	push	r16
    194c:	1f 93       	push	r17
    194e:	cf 93       	push	r28
    1950:	df 93       	push	r29
    1952:	ec 01       	movw	r28, r24
    1954:	0f b6       	in	r0, 0x3f	; 63
    1956:	f8 94       	cli
    1958:	0f 92       	push	r0
    195a:	8a a1       	ldd	r24, Y+34	; 0x22
    195c:	18 16       	cp	r1, r24
    195e:	b4 f4       	brge	.+44     	; 0x198c <prvUnlockQueue+0x42>
    1960:	8b 89       	ldd	r24, Y+19	; 0x13
    1962:	81 11       	cpse	r24, r1
    1964:	05 c0       	rjmp	.+10     	; 0x1970 <prvUnlockQueue+0x26>
    1966:	12 c0       	rjmp	.+36     	; 0x198c <prvUnlockQueue+0x42>
    1968:	8b 89       	ldd	r24, Y+19	; 0x13
    196a:	81 11       	cpse	r24, r1
    196c:	04 c0       	rjmp	.+8      	; 0x1976 <prvUnlockQueue+0x2c>
    196e:	0e c0       	rjmp	.+28     	; 0x198c <prvUnlockQueue+0x42>
    1970:	8e 01       	movw	r16, r28
    1972:	0d 5e       	subi	r16, 0xED	; 237
    1974:	1f 4f       	sbci	r17, 0xFF	; 255
    1976:	c8 01       	movw	r24, r16
    1978:	0e 94 1f 13 	call	0x263e	; 0x263e <xTaskRemoveFromEventList>
    197c:	81 11       	cpse	r24, r1
    197e:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <vTaskMissedYield>
    1982:	8a a1       	ldd	r24, Y+34	; 0x22
    1984:	81 50       	subi	r24, 0x01	; 1
    1986:	8a a3       	std	Y+34, r24	; 0x22
    1988:	18 16       	cp	r1, r24
    198a:	74 f3       	brlt	.-36     	; 0x1968 <prvUnlockQueue+0x1e>
    198c:	8f ef       	ldi	r24, 0xFF	; 255
    198e:	8a a3       	std	Y+34, r24	; 0x22
    1990:	0f 90       	pop	r0
    1992:	0f be       	out	0x3f, r0	; 63
    1994:	0f b6       	in	r0, 0x3f	; 63
    1996:	f8 94       	cli
    1998:	0f 92       	push	r0
    199a:	89 a1       	ldd	r24, Y+33	; 0x21
    199c:	18 16       	cp	r1, r24
    199e:	b4 f4       	brge	.+44     	; 0x19cc <prvUnlockQueue+0x82>
    19a0:	88 85       	ldd	r24, Y+8	; 0x08
    19a2:	81 11       	cpse	r24, r1
    19a4:	05 c0       	rjmp	.+10     	; 0x19b0 <prvUnlockQueue+0x66>
    19a6:	12 c0       	rjmp	.+36     	; 0x19cc <prvUnlockQueue+0x82>
    19a8:	88 85       	ldd	r24, Y+8	; 0x08
    19aa:	81 11       	cpse	r24, r1
    19ac:	04 c0       	rjmp	.+8      	; 0x19b6 <prvUnlockQueue+0x6c>
    19ae:	0e c0       	rjmp	.+28     	; 0x19cc <prvUnlockQueue+0x82>
    19b0:	8e 01       	movw	r16, r28
    19b2:	08 5f       	subi	r16, 0xF8	; 248
    19b4:	1f 4f       	sbci	r17, 0xFF	; 255
    19b6:	c8 01       	movw	r24, r16
    19b8:	0e 94 1f 13 	call	0x263e	; 0x263e <xTaskRemoveFromEventList>
    19bc:	81 11       	cpse	r24, r1
    19be:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <vTaskMissedYield>
    19c2:	89 a1       	ldd	r24, Y+33	; 0x21
    19c4:	81 50       	subi	r24, 0x01	; 1
    19c6:	89 a3       	std	Y+33, r24	; 0x21
    19c8:	18 16       	cp	r1, r24
    19ca:	74 f3       	brlt	.-36     	; 0x19a8 <prvUnlockQueue+0x5e>
    19cc:	8f ef       	ldi	r24, 0xFF	; 255
    19ce:	89 a3       	std	Y+33, r24	; 0x21
    19d0:	0f 90       	pop	r0
    19d2:	0f be       	out	0x3f, r0	; 63
    19d4:	df 91       	pop	r29
    19d6:	cf 91       	pop	r28
    19d8:	1f 91       	pop	r17
    19da:	0f 91       	pop	r16
    19dc:	08 95       	ret

000019de <xQueueGenericReset>:
    19de:	1f 93       	push	r17
    19e0:	cf 93       	push	r28
    19e2:	df 93       	push	r29
    19e4:	61 30       	cpi	r22, 0x01	; 1
    19e6:	59 f0       	breq	.+22     	; 0x19fe <xQueueGenericReset+0x20>
    19e8:	fc 01       	movw	r30, r24
    19ea:	23 89       	ldd	r18, Z+19	; 0x13
    19ec:	30 85       	ldd	r19, Z+8	; 0x08
    19ee:	31 11       	cpse	r19, r1
    19f0:	2c c0       	rjmp	.+88     	; 0x1a4a <xQueueGenericReset+0x6c>
    19f2:	11 e0       	ldi	r17, 0x01	; 1
    19f4:	21 11       	cpse	r18, r1
    19f6:	10 e0       	ldi	r17, 0x00	; 0
    19f8:	21 11       	cpse	r18, r1
    19fa:	28 c0       	rjmp	.+80     	; 0x1a4c <xQueueGenericReset+0x6e>
    19fc:	01 c0       	rjmp	.+2      	; 0x1a00 <xQueueGenericReset+0x22>
    19fe:	11 e0       	ldi	r17, 0x01	; 1
    1a00:	ec 01       	movw	r28, r24
    1a02:	48 81       	ld	r20, Y
    1a04:	59 81       	ldd	r21, Y+1	; 0x01
    1a06:	28 a1       	ldd	r18, Y+32	; 0x20
    1a08:	30 e0       	ldi	r19, 0x00	; 0
    1a0a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a0c:	62 9f       	mul	r22, r18
    1a0e:	c0 01       	movw	r24, r0
    1a10:	63 9f       	mul	r22, r19
    1a12:	90 0d       	add	r25, r0
    1a14:	11 24       	eor	r1, r1
    1a16:	ba 01       	movw	r22, r20
    1a18:	68 0f       	add	r22, r24
    1a1a:	79 1f       	adc	r23, r25
    1a1c:	6a 83       	std	Y+2, r22	; 0x02
    1a1e:	7b 83       	std	Y+3, r23	; 0x03
    1a20:	1e 8e       	std	Y+30, r1	; 0x1e
    1a22:	4c 83       	std	Y+4, r20	; 0x04
    1a24:	5d 83       	std	Y+5, r21	; 0x05
    1a26:	82 1b       	sub	r24, r18
    1a28:	93 0b       	sbc	r25, r19
    1a2a:	84 0f       	add	r24, r20
    1a2c:	95 1f       	adc	r25, r21
    1a2e:	8e 83       	std	Y+6, r24	; 0x06
    1a30:	9f 83       	std	Y+7, r25	; 0x07
    1a32:	8f ef       	ldi	r24, 0xFF	; 255
    1a34:	89 a3       	std	Y+33, r24	; 0x21
    1a36:	8a a3       	std	Y+34, r24	; 0x22
    1a38:	ce 01       	movw	r24, r28
    1a3a:	08 96       	adiw	r24, 0x08	; 8
    1a3c:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1a40:	ce 01       	movw	r24, r28
    1a42:	43 96       	adiw	r24, 0x13	; 19
    1a44:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1a48:	01 c0       	rjmp	.+2      	; 0x1a4c <xQueueGenericReset+0x6e>
    1a4a:	10 e0       	ldi	r17, 0x00	; 0
    1a4c:	81 2f       	mov	r24, r17
    1a4e:	df 91       	pop	r29
    1a50:	cf 91       	pop	r28
    1a52:	1f 91       	pop	r17
    1a54:	08 95       	ret

00001a56 <xQueueGenericCreate>:
    1a56:	0f 93       	push	r16
    1a58:	1f 93       	push	r17
    1a5a:	cf 93       	push	r28
    1a5c:	df 93       	push	r29
    1a5e:	88 23       	and	r24, r24
    1a60:	01 f1       	breq	.+64     	; 0x1aa2 <xQueueGenericCreate+0x4c>
    1a62:	06 2f       	mov	r16, r22
    1a64:	18 2f       	mov	r17, r24
    1a66:	83 e2       	ldi	r24, 0x23	; 35
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	0e 94 45 09 	call	0x128a	; 0x128a <pvPortMalloc>
    1a6e:	ec 01       	movw	r28, r24
    1a70:	89 2b       	or	r24, r25
    1a72:	c9 f0       	breq	.+50     	; 0x1aa6 <xQueueGenericCreate+0x50>
    1a74:	10 9f       	mul	r17, r16
    1a76:	c0 01       	movw	r24, r0
    1a78:	11 24       	eor	r1, r1
    1a7a:	01 96       	adiw	r24, 0x01	; 1
    1a7c:	0e 94 45 09 	call	0x128a	; 0x128a <pvPortMalloc>
    1a80:	88 83       	st	Y, r24
    1a82:	99 83       	std	Y+1, r25	; 0x01
    1a84:	89 2b       	or	r24, r25
    1a86:	39 f0       	breq	.+14     	; 0x1a96 <xQueueGenericCreate+0x40>
    1a88:	1f 8f       	std	Y+31, r17	; 0x1f
    1a8a:	08 a3       	std	Y+32, r16	; 0x20
    1a8c:	61 e0       	ldi	r22, 0x01	; 1
    1a8e:	ce 01       	movw	r24, r28
    1a90:	0e 94 ef 0c 	call	0x19de	; 0x19de <xQueueGenericReset>
    1a94:	08 c0       	rjmp	.+16     	; 0x1aa6 <xQueueGenericCreate+0x50>
    1a96:	ce 01       	movw	r24, r28
    1a98:	0e 94 df 09 	call	0x13be	; 0x13be <vPortFree>
    1a9c:	c0 e0       	ldi	r28, 0x00	; 0
    1a9e:	d0 e0       	ldi	r29, 0x00	; 0
    1aa0:	02 c0       	rjmp	.+4      	; 0x1aa6 <xQueueGenericCreate+0x50>
    1aa2:	c0 e0       	ldi	r28, 0x00	; 0
    1aa4:	d0 e0       	ldi	r29, 0x00	; 0
    1aa6:	ce 01       	movw	r24, r28
    1aa8:	df 91       	pop	r29
    1aaa:	cf 91       	pop	r28
    1aac:	1f 91       	pop	r17
    1aae:	0f 91       	pop	r16
    1ab0:	08 95       	ret

00001ab2 <xQueueGenericSend>:
    1ab2:	af 92       	push	r10
    1ab4:	bf 92       	push	r11
    1ab6:	cf 92       	push	r12
    1ab8:	df 92       	push	r13
    1aba:	ef 92       	push	r14
    1abc:	ff 92       	push	r15
    1abe:	0f 93       	push	r16
    1ac0:	1f 93       	push	r17
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
    1ac6:	cd b7       	in	r28, 0x3d	; 61
    1ac8:	de b7       	in	r29, 0x3e	; 62
    1aca:	29 97       	sbiw	r28, 0x09	; 9
    1acc:	cd bf       	out	0x3d, r28	; 61
    1ace:	de bf       	out	0x3e, r29	; 62
    1ad0:	7c 01       	movw	r14, r24
    1ad2:	5b 01       	movw	r10, r22
    1ad4:	2e 83       	std	Y+6, r18	; 0x06
    1ad6:	3f 83       	std	Y+7, r19	; 0x07
    1ad8:	48 87       	std	Y+8, r20	; 0x08
    1ada:	59 87       	std	Y+9, r21	; 0x09
    1adc:	10 e0       	ldi	r17, 0x00	; 0
    1ade:	6c 01       	movw	r12, r24
    1ae0:	88 e0       	ldi	r24, 0x08	; 8
    1ae2:	c8 0e       	add	r12, r24
    1ae4:	d1 1c       	adc	r13, r1
    1ae6:	0f b6       	in	r0, 0x3f	; 63
    1ae8:	f8 94       	cli
    1aea:	0f 92       	push	r0
    1aec:	f7 01       	movw	r30, r14
    1aee:	96 8d       	ldd	r25, Z+30	; 0x1e
    1af0:	87 8d       	ldd	r24, Z+31	; 0x1f
    1af2:	98 17       	cp	r25, r24
    1af4:	a8 f4       	brcc	.+42     	; 0x1b20 <xQueueGenericSend+0x6e>
    1af6:	40 2f       	mov	r20, r16
    1af8:	b5 01       	movw	r22, r10
    1afa:	c7 01       	movw	r24, r14
    1afc:	0e 94 3f 0c 	call	0x187e	; 0x187e <prvCopyDataToQueue>
    1b00:	f7 01       	movw	r30, r14
    1b02:	83 89       	ldd	r24, Z+19	; 0x13
    1b04:	88 23       	and	r24, r24
    1b06:	41 f0       	breq	.+16     	; 0x1b18 <xQueueGenericSend+0x66>
    1b08:	c7 01       	movw	r24, r14
    1b0a:	43 96       	adiw	r24, 0x13	; 19
    1b0c:	0e 94 1f 13 	call	0x263e	; 0x263e <xTaskRemoveFromEventList>
    1b10:	81 30       	cpi	r24, 0x01	; 1
    1b12:	11 f4       	brne	.+4      	; 0x1b18 <xQueueGenericSend+0x66>
    1b14:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
    1b18:	0f 90       	pop	r0
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
    1b1e:	56 c0       	rjmp	.+172    	; 0x1bcc <xQueueGenericSend+0x11a>
    1b20:	8e 81       	ldd	r24, Y+6	; 0x06
    1b22:	9f 81       	ldd	r25, Y+7	; 0x07
    1b24:	a8 85       	ldd	r26, Y+8	; 0x08
    1b26:	b9 85       	ldd	r27, Y+9	; 0x09
    1b28:	89 2b       	or	r24, r25
    1b2a:	8a 2b       	or	r24, r26
    1b2c:	8b 2b       	or	r24, r27
    1b2e:	21 f4       	brne	.+8      	; 0x1b38 <xQueueGenericSend+0x86>
    1b30:	0f 90       	pop	r0
    1b32:	0f be       	out	0x3f, r0	; 63
    1b34:	80 e0       	ldi	r24, 0x00	; 0
    1b36:	4a c0       	rjmp	.+148    	; 0x1bcc <xQueueGenericSend+0x11a>
    1b38:	11 11       	cpse	r17, r1
    1b3a:	05 c0       	rjmp	.+10     	; 0x1b46 <xQueueGenericSend+0x94>
    1b3c:	ce 01       	movw	r24, r28
    1b3e:	01 96       	adiw	r24, 0x01	; 1
    1b40:	0e 94 5e 13 	call	0x26bc	; 0x26bc <vTaskSetTimeOutState>
    1b44:	11 e0       	ldi	r17, 0x01	; 1
    1b46:	0f 90       	pop	r0
    1b48:	0f be       	out	0x3f, r0	; 63
    1b4a:	0e 94 59 10 	call	0x20b2	; 0x20b2 <vTaskSuspendAll>
    1b4e:	0f b6       	in	r0, 0x3f	; 63
    1b50:	f8 94       	cli
    1b52:	0f 92       	push	r0
    1b54:	f7 01       	movw	r30, r14
    1b56:	81 a1       	ldd	r24, Z+33	; 0x21
    1b58:	8f 3f       	cpi	r24, 0xFF	; 255
    1b5a:	09 f4       	brne	.+2      	; 0x1b5e <xQueueGenericSend+0xac>
    1b5c:	11 a2       	std	Z+33, r1	; 0x21
    1b5e:	f7 01       	movw	r30, r14
    1b60:	82 a1       	ldd	r24, Z+34	; 0x22
    1b62:	8f 3f       	cpi	r24, 0xFF	; 255
    1b64:	09 f4       	brne	.+2      	; 0x1b68 <xQueueGenericSend+0xb6>
    1b66:	12 a2       	std	Z+34, r1	; 0x22
    1b68:	0f 90       	pop	r0
    1b6a:	0f be       	out	0x3f, r0	; 63
    1b6c:	be 01       	movw	r22, r28
    1b6e:	6a 5f       	subi	r22, 0xFA	; 250
    1b70:	7f 4f       	sbci	r23, 0xFF	; 255
    1b72:	ce 01       	movw	r24, r28
    1b74:	01 96       	adiw	r24, 0x01	; 1
    1b76:	0e 94 6f 13 	call	0x26de	; 0x26de <xTaskCheckForTimeOut>
    1b7a:	81 11       	cpse	r24, r1
    1b7c:	21 c0       	rjmp	.+66     	; 0x1bc0 <xQueueGenericSend+0x10e>
    1b7e:	0f b6       	in	r0, 0x3f	; 63
    1b80:	f8 94       	cli
    1b82:	0f 92       	push	r0
    1b84:	f7 01       	movw	r30, r14
    1b86:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b88:	0f 90       	pop	r0
    1b8a:	0f be       	out	0x3f, r0	; 63
    1b8c:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b8e:	98 13       	cpse	r25, r24
    1b90:	11 c0       	rjmp	.+34     	; 0x1bb4 <xQueueGenericSend+0x102>
    1b92:	4e 81       	ldd	r20, Y+6	; 0x06
    1b94:	5f 81       	ldd	r21, Y+7	; 0x07
    1b96:	68 85       	ldd	r22, Y+8	; 0x08
    1b98:	79 85       	ldd	r23, Y+9	; 0x09
    1b9a:	c6 01       	movw	r24, r12
    1b9c:	0e 94 f5 12 	call	0x25ea	; 0x25ea <vTaskPlaceOnEventList>
    1ba0:	c7 01       	movw	r24, r14
    1ba2:	0e 94 a5 0c 	call	0x194a	; 0x194a <prvUnlockQueue>
    1ba6:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
    1baa:	81 11       	cpse	r24, r1
    1bac:	9c cf       	rjmp	.-200    	; 0x1ae6 <xQueueGenericSend+0x34>
    1bae:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
    1bb2:	99 cf       	rjmp	.-206    	; 0x1ae6 <xQueueGenericSend+0x34>
    1bb4:	c7 01       	movw	r24, r14
    1bb6:	0e 94 a5 0c 	call	0x194a	; 0x194a <prvUnlockQueue>
    1bba:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
    1bbe:	93 cf       	rjmp	.-218    	; 0x1ae6 <xQueueGenericSend+0x34>
    1bc0:	c7 01       	movw	r24, r14
    1bc2:	0e 94 a5 0c 	call	0x194a	; 0x194a <prvUnlockQueue>
    1bc6:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
    1bca:	80 e0       	ldi	r24, 0x00	; 0
    1bcc:	29 96       	adiw	r28, 0x09	; 9
    1bce:	cd bf       	out	0x3d, r28	; 61
    1bd0:	de bf       	out	0x3e, r29	; 62
    1bd2:	df 91       	pop	r29
    1bd4:	cf 91       	pop	r28
    1bd6:	1f 91       	pop	r17
    1bd8:	0f 91       	pop	r16
    1bda:	ff 90       	pop	r15
    1bdc:	ef 90       	pop	r14
    1bde:	df 90       	pop	r13
    1be0:	cf 90       	pop	r12
    1be2:	bf 90       	pop	r11
    1be4:	af 90       	pop	r10
    1be6:	08 95       	ret

00001be8 <xQueueGenericReceive>:
    1be8:	af 92       	push	r10
    1bea:	bf 92       	push	r11
    1bec:	cf 92       	push	r12
    1bee:	df 92       	push	r13
    1bf0:	ef 92       	push	r14
    1bf2:	ff 92       	push	r15
    1bf4:	0f 93       	push	r16
    1bf6:	1f 93       	push	r17
    1bf8:	cf 93       	push	r28
    1bfa:	df 93       	push	r29
    1bfc:	cd b7       	in	r28, 0x3d	; 61
    1bfe:	de b7       	in	r29, 0x3e	; 62
    1c00:	29 97       	sbiw	r28, 0x09	; 9
    1c02:	cd bf       	out	0x3d, r28	; 61
    1c04:	de bf       	out	0x3e, r29	; 62
    1c06:	7c 01       	movw	r14, r24
    1c08:	5b 01       	movw	r10, r22
    1c0a:	2e 83       	std	Y+6, r18	; 0x06
    1c0c:	3f 83       	std	Y+7, r19	; 0x07
    1c0e:	48 87       	std	Y+8, r20	; 0x08
    1c10:	59 87       	std	Y+9, r21	; 0x09
    1c12:	10 e0       	ldi	r17, 0x00	; 0
    1c14:	6c 01       	movw	r12, r24
    1c16:	83 e1       	ldi	r24, 0x13	; 19
    1c18:	c8 0e       	add	r12, r24
    1c1a:	d1 1c       	adc	r13, r1
    1c1c:	0f b6       	in	r0, 0x3f	; 63
    1c1e:	f8 94       	cli
    1c20:	0f 92       	push	r0
    1c22:	f7 01       	movw	r30, r14
    1c24:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c26:	88 23       	and	r24, r24
    1c28:	99 f1       	breq	.+102    	; 0x1c90 <xQueueGenericReceive+0xa8>
    1c2a:	c6 80       	ldd	r12, Z+6	; 0x06
    1c2c:	d7 80       	ldd	r13, Z+7	; 0x07
    1c2e:	b5 01       	movw	r22, r10
    1c30:	c7 01       	movw	r24, r14
    1c32:	0e 94 8b 0c 	call	0x1916	; 0x1916 <prvCopyDataFromQueue>
    1c36:	01 11       	cpse	r16, r1
    1c38:	1a c0       	rjmp	.+52     	; 0x1c6e <xQueueGenericReceive+0x86>
    1c3a:	f7 01       	movw	r30, r14
    1c3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c3e:	81 50       	subi	r24, 0x01	; 1
    1c40:	86 8f       	std	Z+30, r24	; 0x1e
    1c42:	80 81       	ld	r24, Z
    1c44:	91 81       	ldd	r25, Z+1	; 0x01
    1c46:	89 2b       	or	r24, r25
    1c48:	29 f4       	brne	.+10     	; 0x1c54 <xQueueGenericReceive+0x6c>
    1c4a:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <xTaskGetCurrentTaskHandle>
    1c4e:	f7 01       	movw	r30, r14
    1c50:	82 83       	std	Z+2, r24	; 0x02
    1c52:	93 83       	std	Z+3, r25	; 0x03
    1c54:	f7 01       	movw	r30, r14
    1c56:	80 85       	ldd	r24, Z+8	; 0x08
    1c58:	88 23       	and	r24, r24
    1c5a:	b1 f0       	breq	.+44     	; 0x1c88 <xQueueGenericReceive+0xa0>
    1c5c:	c7 01       	movw	r24, r14
    1c5e:	08 96       	adiw	r24, 0x08	; 8
    1c60:	0e 94 1f 13 	call	0x263e	; 0x263e <xTaskRemoveFromEventList>
    1c64:	81 30       	cpi	r24, 0x01	; 1
    1c66:	81 f4       	brne	.+32     	; 0x1c88 <xQueueGenericReceive+0xa0>
    1c68:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
    1c6c:	0d c0       	rjmp	.+26     	; 0x1c88 <xQueueGenericReceive+0xa0>
    1c6e:	f7 01       	movw	r30, r14
    1c70:	c6 82       	std	Z+6, r12	; 0x06
    1c72:	d7 82       	std	Z+7, r13	; 0x07
    1c74:	83 89       	ldd	r24, Z+19	; 0x13
    1c76:	88 23       	and	r24, r24
    1c78:	39 f0       	breq	.+14     	; 0x1c88 <xQueueGenericReceive+0xa0>
    1c7a:	c7 01       	movw	r24, r14
    1c7c:	43 96       	adiw	r24, 0x13	; 19
    1c7e:	0e 94 1f 13 	call	0x263e	; 0x263e <xTaskRemoveFromEventList>
    1c82:	81 11       	cpse	r24, r1
    1c84:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
    1c88:	0f 90       	pop	r0
    1c8a:	0f be       	out	0x3f, r0	; 63
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	62 c0       	rjmp	.+196    	; 0x1d54 <xQueueGenericReceive+0x16c>
    1c90:	8e 81       	ldd	r24, Y+6	; 0x06
    1c92:	9f 81       	ldd	r25, Y+7	; 0x07
    1c94:	a8 85       	ldd	r26, Y+8	; 0x08
    1c96:	b9 85       	ldd	r27, Y+9	; 0x09
    1c98:	89 2b       	or	r24, r25
    1c9a:	8a 2b       	or	r24, r26
    1c9c:	8b 2b       	or	r24, r27
    1c9e:	21 f4       	brne	.+8      	; 0x1ca8 <xQueueGenericReceive+0xc0>
    1ca0:	0f 90       	pop	r0
    1ca2:	0f be       	out	0x3f, r0	; 63
    1ca4:	80 e0       	ldi	r24, 0x00	; 0
    1ca6:	56 c0       	rjmp	.+172    	; 0x1d54 <xQueueGenericReceive+0x16c>
    1ca8:	11 11       	cpse	r17, r1
    1caa:	05 c0       	rjmp	.+10     	; 0x1cb6 <xQueueGenericReceive+0xce>
    1cac:	ce 01       	movw	r24, r28
    1cae:	01 96       	adiw	r24, 0x01	; 1
    1cb0:	0e 94 5e 13 	call	0x26bc	; 0x26bc <vTaskSetTimeOutState>
    1cb4:	11 e0       	ldi	r17, 0x01	; 1
    1cb6:	0f 90       	pop	r0
    1cb8:	0f be       	out	0x3f, r0	; 63
    1cba:	0e 94 59 10 	call	0x20b2	; 0x20b2 <vTaskSuspendAll>
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	f8 94       	cli
    1cc2:	0f 92       	push	r0
    1cc4:	f7 01       	movw	r30, r14
    1cc6:	81 a1       	ldd	r24, Z+33	; 0x21
    1cc8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cca:	09 f4       	brne	.+2      	; 0x1cce <xQueueGenericReceive+0xe6>
    1ccc:	11 a2       	std	Z+33, r1	; 0x21
    1cce:	f7 01       	movw	r30, r14
    1cd0:	82 a1       	ldd	r24, Z+34	; 0x22
    1cd2:	8f 3f       	cpi	r24, 0xFF	; 255
    1cd4:	09 f4       	brne	.+2      	; 0x1cd8 <xQueueGenericReceive+0xf0>
    1cd6:	12 a2       	std	Z+34, r1	; 0x22
    1cd8:	0f 90       	pop	r0
    1cda:	0f be       	out	0x3f, r0	; 63
    1cdc:	be 01       	movw	r22, r28
    1cde:	6a 5f       	subi	r22, 0xFA	; 250
    1ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce2:	ce 01       	movw	r24, r28
    1ce4:	01 96       	adiw	r24, 0x01	; 1
    1ce6:	0e 94 6f 13 	call	0x26de	; 0x26de <xTaskCheckForTimeOut>
    1cea:	81 11       	cpse	r24, r1
    1cec:	2d c0       	rjmp	.+90     	; 0x1d48 <xQueueGenericReceive+0x160>
    1cee:	0f b6       	in	r0, 0x3f	; 63
    1cf0:	f8 94       	cli
    1cf2:	0f 92       	push	r0
    1cf4:	f7 01       	movw	r30, r14
    1cf6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cf8:	0f 90       	pop	r0
    1cfa:	0f be       	out	0x3f, r0	; 63
    1cfc:	81 11       	cpse	r24, r1
    1cfe:	1e c0       	rjmp	.+60     	; 0x1d3c <xQueueGenericReceive+0x154>
    1d00:	80 81       	ld	r24, Z
    1d02:	91 81       	ldd	r25, Z+1	; 0x01
    1d04:	89 2b       	or	r24, r25
    1d06:	49 f4       	brne	.+18     	; 0x1d1a <xQueueGenericReceive+0x132>
    1d08:	0f b6       	in	r0, 0x3f	; 63
    1d0a:	f8 94       	cli
    1d0c:	0f 92       	push	r0
    1d0e:	82 81       	ldd	r24, Z+2	; 0x02
    1d10:	93 81       	ldd	r25, Z+3	; 0x03
    1d12:	0e 94 fe 13 	call	0x27fc	; 0x27fc <vTaskPriorityInherit>
    1d16:	0f 90       	pop	r0
    1d18:	0f be       	out	0x3f, r0	; 63
    1d1a:	4e 81       	ldd	r20, Y+6	; 0x06
    1d1c:	5f 81       	ldd	r21, Y+7	; 0x07
    1d1e:	68 85       	ldd	r22, Y+8	; 0x08
    1d20:	79 85       	ldd	r23, Y+9	; 0x09
    1d22:	c6 01       	movw	r24, r12
    1d24:	0e 94 f5 12 	call	0x25ea	; 0x25ea <vTaskPlaceOnEventList>
    1d28:	c7 01       	movw	r24, r14
    1d2a:	0e 94 a5 0c 	call	0x194a	; 0x194a <prvUnlockQueue>
    1d2e:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
    1d32:	81 11       	cpse	r24, r1
    1d34:	73 cf       	rjmp	.-282    	; 0x1c1c <xQueueGenericReceive+0x34>
    1d36:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
    1d3a:	70 cf       	rjmp	.-288    	; 0x1c1c <xQueueGenericReceive+0x34>
    1d3c:	c7 01       	movw	r24, r14
    1d3e:	0e 94 a5 0c 	call	0x194a	; 0x194a <prvUnlockQueue>
    1d42:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
    1d46:	6a cf       	rjmp	.-300    	; 0x1c1c <xQueueGenericReceive+0x34>
    1d48:	c7 01       	movw	r24, r14
    1d4a:	0e 94 a5 0c 	call	0x194a	; 0x194a <prvUnlockQueue>
    1d4e:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
    1d52:	80 e0       	ldi	r24, 0x00	; 0
    1d54:	29 96       	adiw	r28, 0x09	; 9
    1d56:	cd bf       	out	0x3d, r28	; 61
    1d58:	de bf       	out	0x3e, r29	; 62
    1d5a:	df 91       	pop	r29
    1d5c:	cf 91       	pop	r28
    1d5e:	1f 91       	pop	r17
    1d60:	0f 91       	pop	r16
    1d62:	ff 90       	pop	r15
    1d64:	ef 90       	pop	r14
    1d66:	df 90       	pop	r13
    1d68:	cf 90       	pop	r12
    1d6a:	bf 90       	pop	r11
    1d6c:	af 90       	pop	r10
    1d6e:	08 95       	ret

00001d70 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d70:	0f b6       	in	r0, 0x3f	; 63
    1d72:	f8 94       	cli
    1d74:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d76:	fc 01       	movw	r30, r24
    1d78:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d7a:	0f 90       	pop	r0
    1d7c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d7e:	08 95       	ret

00001d80 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d80:	c8 ef       	ldi	r28, 0xF8	; 248
    1d82:	d0 e3       	ldi	r29, 0x30	; 48
    1d84:	88 81       	ld	r24, Y
    1d86:	82 30       	cpi	r24, 0x02	; 2
    1d88:	e8 f3       	brcs	.-6      	; 0x1d84 <prvIdleTask+0x4>
    1d8a:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
    1d8e:	fa cf       	rjmp	.-12     	; 0x1d84 <prvIdleTask+0x4>

00001d90 <prvAddCurrentTaskToDelayedList>:
    1d90:	cf 92       	push	r12
    1d92:	df 92       	push	r13
    1d94:	ef 92       	push	r14
    1d96:	ff 92       	push	r15
    1d98:	6b 01       	movw	r12, r22
    1d9a:	7c 01       	movw	r14, r24
    1d9c:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1da0:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1da4:	62 83       	std	Z+2, r22	; 0x02
    1da6:	73 83       	std	Z+3, r23	; 0x03
    1da8:	84 83       	std	Z+4, r24	; 0x04
    1daa:	95 83       	std	Z+5, r25	; 0x05
    1dac:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    1db0:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    1db4:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    1db8:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    1dbc:	c8 16       	cp	r12, r24
    1dbe:	d9 06       	cpc	r13, r25
    1dc0:	ea 06       	cpc	r14, r26
    1dc2:	fb 06       	cpc	r15, r27
    1dc4:	68 f4       	brcc	.+26     	; 0x1de0 <prvAddCurrentTaskToDelayedList+0x50>
    1dc6:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1dca:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1dce:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    1dd2:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    1dd6:	6e 5f       	subi	r22, 0xFE	; 254
    1dd8:	7f 4f       	sbci	r23, 0xFF	; 255
    1dda:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <vListInsert>
    1dde:	21 c0       	rjmp	.+66     	; 0x1e22 <prvAddCurrentTaskToDelayedList+0x92>
    1de0:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1de4:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1de8:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    1dec:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    1df0:	6e 5f       	subi	r22, 0xFE	; 254
    1df2:	7f 4f       	sbci	r23, 0xFF	; 255
    1df4:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <vListInsert>
    1df8:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1dfc:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e00:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e04:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e08:	c8 16       	cp	r12, r24
    1e0a:	d9 06       	cpc	r13, r25
    1e0c:	ea 06       	cpc	r14, r26
    1e0e:	fb 06       	cpc	r15, r27
    1e10:	40 f4       	brcc	.+16     	; 0x1e22 <prvAddCurrentTaskToDelayedList+0x92>
    1e12:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e16:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e1a:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e1e:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e22:	ff 90       	pop	r15
    1e24:	ef 90       	pop	r14
    1e26:	df 90       	pop	r13
    1e28:	cf 90       	pop	r12
    1e2a:	08 95       	ret

00001e2c <xTaskGenericCreate>:
    1e2c:	4f 92       	push	r4
    1e2e:	5f 92       	push	r5
    1e30:	6f 92       	push	r6
    1e32:	7f 92       	push	r7
    1e34:	8f 92       	push	r8
    1e36:	9f 92       	push	r9
    1e38:	af 92       	push	r10
    1e3a:	bf 92       	push	r11
    1e3c:	cf 92       	push	r12
    1e3e:	df 92       	push	r13
    1e40:	ef 92       	push	r14
    1e42:	ff 92       	push	r15
    1e44:	0f 93       	push	r16
    1e46:	1f 93       	push	r17
    1e48:	cf 93       	push	r28
    1e4a:	df 93       	push	r29
    1e4c:	5c 01       	movw	r10, r24
    1e4e:	4b 01       	movw	r8, r22
    1e50:	3a 01       	movw	r6, r20
    1e52:	29 01       	movw	r4, r18
    1e54:	88 e2       	ldi	r24, 0x28	; 40
    1e56:	90 e0       	ldi	r25, 0x00	; 0
    1e58:	0e 94 45 09 	call	0x128a	; 0x128a <pvPortMalloc>
    1e5c:	ec 01       	movw	r28, r24
    1e5e:	89 2b       	or	r24, r25
    1e60:	09 f4       	brne	.+2      	; 0x1e64 <xTaskGenericCreate+0x38>
    1e62:	d4 c0       	rjmp	.+424    	; 0x200c <xTaskGenericCreate+0x1e0>
    1e64:	c1 14       	cp	r12, r1
    1e66:	d1 04       	cpc	r13, r1
    1e68:	09 f0       	breq	.+2      	; 0x1e6c <xTaskGenericCreate+0x40>
    1e6a:	cc c0       	rjmp	.+408    	; 0x2004 <xTaskGenericCreate+0x1d8>
    1e6c:	c3 01       	movw	r24, r6
    1e6e:	0e 94 45 09 	call	0x128a	; 0x128a <pvPortMalloc>
    1e72:	8b 8f       	std	Y+27, r24	; 0x1b
    1e74:	9c 8f       	std	Y+28, r25	; 0x1c
    1e76:	00 97       	sbiw	r24, 0x00	; 0
    1e78:	21 f4       	brne	.+8      	; 0x1e82 <xTaskGenericCreate+0x56>
    1e7a:	ce 01       	movw	r24, r28
    1e7c:	0e 94 df 09 	call	0x13be	; 0x13be <vPortFree>
    1e80:	c5 c0       	rjmp	.+394    	; 0x200c <xTaskGenericCreate+0x1e0>
    1e82:	a3 01       	movw	r20, r6
    1e84:	61 e1       	ldi	r22, 0x11	; 17
    1e86:	70 e0       	ldi	r23, 0x00	; 0
    1e88:	0e 94 08 20 	call	0x4010	; 0x4010 <memset>
    1e8c:	93 01       	movw	r18, r6
    1e8e:	21 50       	subi	r18, 0x01	; 1
    1e90:	31 09       	sbc	r19, r1
    1e92:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e94:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e96:	3c 01       	movw	r6, r24
    1e98:	62 0e       	add	r6, r18
    1e9a:	73 1e       	adc	r7, r19
    1e9c:	4a e0       	ldi	r20, 0x0A	; 10
    1e9e:	50 e0       	ldi	r21, 0x00	; 0
    1ea0:	b4 01       	movw	r22, r8
    1ea2:	ce 01       	movw	r24, r28
    1ea4:	4d 96       	adiw	r24, 0x1d	; 29
    1ea6:	0e 94 0f 20 	call	0x401e	; 0x401e <strncpy>
    1eaa:	1e a2       	std	Y+38, r1	; 0x26
    1eac:	10 2f       	mov	r17, r16
    1eae:	04 30       	cpi	r16, 0x04	; 4
    1eb0:	08 f0       	brcs	.+2      	; 0x1eb4 <xTaskGenericCreate+0x88>
    1eb2:	13 e0       	ldi	r17, 0x03	; 3
    1eb4:	1a 8f       	std	Y+26, r17	; 0x1a
    1eb6:	1f a3       	std	Y+39, r17	; 0x27
    1eb8:	6e 01       	movw	r12, r28
    1eba:	22 e0       	ldi	r18, 0x02	; 2
    1ebc:	c2 0e       	add	r12, r18
    1ebe:	d1 1c       	adc	r13, r1
    1ec0:	c6 01       	movw	r24, r12
    1ec2:	0e 94 28 0a 	call	0x1450	; 0x1450 <vListInitialiseItem>
    1ec6:	ce 01       	movw	r24, r28
    1ec8:	0e 96       	adiw	r24, 0x0e	; 14
    1eca:	0e 94 28 0a 	call	0x1450	; 0x1450 <vListInitialiseItem>
    1ece:	ca 87       	std	Y+10, r28	; 0x0a
    1ed0:	db 87       	std	Y+11, r29	; 0x0b
    1ed2:	84 e0       	ldi	r24, 0x04	; 4
    1ed4:	90 e0       	ldi	r25, 0x00	; 0
    1ed6:	a0 e0       	ldi	r26, 0x00	; 0
    1ed8:	b0 e0       	ldi	r27, 0x00	; 0
    1eda:	81 1b       	sub	r24, r17
    1edc:	91 09       	sbc	r25, r1
    1ede:	a1 09       	sbc	r26, r1
    1ee0:	b1 09       	sbc	r27, r1
    1ee2:	8e 87       	std	Y+14, r24	; 0x0e
    1ee4:	9f 87       	std	Y+15, r25	; 0x0f
    1ee6:	a8 8b       	std	Y+16, r26	; 0x10
    1ee8:	b9 8b       	std	Y+17, r27	; 0x11
    1eea:	ce 8b       	std	Y+22, r28	; 0x16
    1eec:	df 8b       	std	Y+23, r29	; 0x17
    1eee:	a2 01       	movw	r20, r4
    1ef0:	b5 01       	movw	r22, r10
    1ef2:	c3 01       	movw	r24, r6
    1ef4:	0e 94 c4 0a 	call	0x1588	; 0x1588 <pxPortInitialiseStack>
    1ef8:	88 83       	st	Y, r24
    1efa:	99 83       	std	Y+1, r25	; 0x01
    1efc:	e1 14       	cp	r14, r1
    1efe:	f1 04       	cpc	r15, r1
    1f00:	19 f0       	breq	.+6      	; 0x1f08 <xTaskGenericCreate+0xdc>
    1f02:	f7 01       	movw	r30, r14
    1f04:	c0 83       	st	Z, r28
    1f06:	d1 83       	std	Z+1, r29	; 0x01
    1f08:	0f b6       	in	r0, 0x3f	; 63
    1f0a:	f8 94       	cli
    1f0c:	0f 92       	push	r0
    1f0e:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f12:	8f 5f       	subi	r24, 0xFF	; 255
    1f14:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f18:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    1f1c:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1f20:	89 2b       	or	r24, r25
    1f22:	89 f5       	brne	.+98     	; 0x1f86 <xTaskGenericCreate+0x15a>
    1f24:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    1f28:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    1f2c:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f30:	81 30       	cpi	r24, 0x01	; 1
    1f32:	c1 f5       	brne	.+112    	; 0x1fa4 <xTaskGenericCreate+0x178>
    1f34:	88 ef       	ldi	r24, 0xF8	; 248
    1f36:	90 e3       	ldi	r25, 0x30	; 48
    1f38:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1f3c:	83 e0       	ldi	r24, 0x03	; 3
    1f3e:	91 e3       	ldi	r25, 0x31	; 49
    1f40:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1f44:	8e e0       	ldi	r24, 0x0E	; 14
    1f46:	91 e3       	ldi	r25, 0x31	; 49
    1f48:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1f4c:	89 e1       	ldi	r24, 0x19	; 25
    1f4e:	91 e3       	ldi	r25, 0x31	; 49
    1f50:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1f54:	8d ee       	ldi	r24, 0xED	; 237
    1f56:	90 e3       	ldi	r25, 0x30	; 48
    1f58:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1f5c:	82 ee       	ldi	r24, 0xE2	; 226
    1f5e:	90 e3       	ldi	r25, 0x30	; 48
    1f60:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1f64:	83 ed       	ldi	r24, 0xD3	; 211
    1f66:	90 e3       	ldi	r25, 0x30	; 48
    1f68:	0e 94 17 0a 	call	0x142e	; 0x142e <vListInitialise>
    1f6c:	8d ee       	ldi	r24, 0xED	; 237
    1f6e:	90 e3       	ldi	r25, 0x30	; 48
    1f70:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    1f74:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    1f78:	82 ee       	ldi	r24, 0xE2	; 226
    1f7a:	90 e3       	ldi	r25, 0x30	; 48
    1f7c:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    1f80:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    1f84:	0f c0       	rjmp	.+30     	; 0x1fa4 <xTaskGenericCreate+0x178>
    1f86:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    1f8a:	81 11       	cpse	r24, r1
    1f8c:	0b c0       	rjmp	.+22     	; 0x1fa4 <xTaskGenericCreate+0x178>
    1f8e:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1f92:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1f96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f98:	08 17       	cp	r16, r24
    1f9a:	20 f0       	brcs	.+8      	; 0x1fa4 <xTaskGenericCreate+0x178>
    1f9c:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    1fa0:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    1fa4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fa6:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    1faa:	98 17       	cp	r25, r24
    1fac:	10 f4       	brcc	.+4      	; 0x1fb2 <xTaskGenericCreate+0x186>
    1fae:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    1fb2:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    1fb6:	9f 5f       	subi	r25, 0xFF	; 255
    1fb8:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    1fbc:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    1fc0:	98 17       	cp	r25, r24
    1fc2:	10 f4       	brcc	.+4      	; 0x1fc8 <xTaskGenericCreate+0x19c>
    1fc4:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    1fc8:	fb e0       	ldi	r31, 0x0B	; 11
    1fca:	8f 9f       	mul	r24, r31
    1fcc:	c0 01       	movw	r24, r0
    1fce:	11 24       	eor	r1, r1
    1fd0:	b6 01       	movw	r22, r12
    1fd2:	88 50       	subi	r24, 0x08	; 8
    1fd4:	9f 4c       	sbci	r25, 0xCF	; 207
    1fd6:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListInsertEnd>
    1fda:	0f 90       	pop	r0
    1fdc:	0f be       	out	0x3f, r0	; 63
    1fde:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    1fe2:	88 23       	and	r24, r24
    1fe4:	59 f0       	breq	.+22     	; 0x1ffc <xTaskGenericCreate+0x1d0>
    1fe6:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1fea:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1fee:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ff0:	80 17       	cp	r24, r16
    1ff2:	30 f4       	brcc	.+12     	; 0x2000 <xTaskGenericCreate+0x1d4>
    1ff4:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	09 c0       	rjmp	.+18     	; 0x200e <xTaskGenericCreate+0x1e2>
    1ffc:	81 e0       	ldi	r24, 0x01	; 1
    1ffe:	07 c0       	rjmp	.+14     	; 0x200e <xTaskGenericCreate+0x1e2>
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	05 c0       	rjmp	.+10     	; 0x200e <xTaskGenericCreate+0x1e2>
    2004:	cb 8e       	std	Y+27, r12	; 0x1b
    2006:	dc 8e       	std	Y+28, r13	; 0x1c
    2008:	c6 01       	movw	r24, r12
    200a:	3b cf       	rjmp	.-394    	; 0x1e82 <xTaskGenericCreate+0x56>
    200c:	8f ef       	ldi	r24, 0xFF	; 255
    200e:	df 91       	pop	r29
    2010:	cf 91       	pop	r28
    2012:	1f 91       	pop	r17
    2014:	0f 91       	pop	r16
    2016:	ff 90       	pop	r15
    2018:	ef 90       	pop	r14
    201a:	df 90       	pop	r13
    201c:	cf 90       	pop	r12
    201e:	bf 90       	pop	r11
    2020:	af 90       	pop	r10
    2022:	9f 90       	pop	r9
    2024:	8f 90       	pop	r8
    2026:	7f 90       	pop	r7
    2028:	6f 90       	pop	r6
    202a:	5f 90       	pop	r5
    202c:	4f 90       	pop	r4
    202e:	08 95       	ret

00002030 <uxTaskPriorityGet>:
    2030:	0f b6       	in	r0, 0x3f	; 63
    2032:	f8 94       	cli
    2034:	0f 92       	push	r0
    2036:	00 97       	sbiw	r24, 0x00	; 0
    2038:	21 f4       	brne	.+8      	; 0x2042 <uxTaskPriorityGet+0x12>
    203a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    203e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2042:	0f 90       	pop	r0
    2044:	0f be       	out	0x3f, r0	; 63
    2046:	fc 01       	movw	r30, r24
    2048:	82 8d       	ldd	r24, Z+26	; 0x1a
    204a:	08 95       	ret

0000204c <vTaskStartScheduler>:
    204c:	af 92       	push	r10
    204e:	bf 92       	push	r11
    2050:	cf 92       	push	r12
    2052:	df 92       	push	r13
    2054:	ef 92       	push	r14
    2056:	ff 92       	push	r15
    2058:	0f 93       	push	r16
    205a:	a1 2c       	mov	r10, r1
    205c:	b1 2c       	mov	r11, r1
    205e:	c1 2c       	mov	r12, r1
    2060:	d1 2c       	mov	r13, r1
    2062:	0f 2e       	mov	r0, r31
    2064:	f1 ed       	ldi	r31, 0xD1	; 209
    2066:	ef 2e       	mov	r14, r31
    2068:	f0 e3       	ldi	r31, 0x30	; 48
    206a:	ff 2e       	mov	r15, r31
    206c:	f0 2d       	mov	r31, r0
    206e:	00 e0       	ldi	r16, 0x00	; 0
    2070:	20 e0       	ldi	r18, 0x00	; 0
    2072:	30 e0       	ldi	r19, 0x00	; 0
    2074:	44 e6       	ldi	r20, 0x64	; 100
    2076:	50 e0       	ldi	r21, 0x00	; 0
    2078:	66 e3       	ldi	r22, 0x36	; 54
    207a:	70 e2       	ldi	r23, 0x20	; 32
    207c:	80 ec       	ldi	r24, 0xC0	; 192
    207e:	9e e0       	ldi	r25, 0x0E	; 14
    2080:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <xTaskGenericCreate>
    2084:	81 30       	cpi	r24, 0x01	; 1
    2086:	69 f4       	brne	.+26     	; 0x20a2 <vTaskStartScheduler+0x56>
    2088:	f8 94       	cli
    208a:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    208e:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    2092:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    2096:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    209a:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    209e:	0e 94 3a 0b 	call	0x1674	; 0x1674 <xPortStartScheduler>
    20a2:	0f 91       	pop	r16
    20a4:	ff 90       	pop	r15
    20a6:	ef 90       	pop	r14
    20a8:	df 90       	pop	r13
    20aa:	cf 90       	pop	r12
    20ac:	bf 90       	pop	r11
    20ae:	af 90       	pop	r10
    20b0:	08 95       	ret

000020b2 <vTaskSuspendAll>:
    20b2:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    20b6:	8f 5f       	subi	r24, 0xFF	; 255
    20b8:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    20bc:	08 95       	ret

000020be <xTaskGetTickCount>:
    20be:	0f b6       	in	r0, 0x3f	; 63
    20c0:	f8 94       	cli
    20c2:	0f 92       	push	r0
    20c4:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    20c8:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    20cc:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    20d0:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    20d4:	0f 90       	pop	r0
    20d6:	0f be       	out	0x3f, r0	; 63
    20d8:	08 95       	ret

000020da <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20da:	00 97       	sbiw	r24, 0x00	; 0
    20dc:	21 f4       	brne	.+8      	; 0x20e6 <pcTaskGetTaskName+0xc>
    20de:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    20e2:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20e6:	4d 96       	adiw	r24, 0x1d	; 29
    20e8:	08 95       	ret

000020ea <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20ea:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    20ee:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    20f2:	08 95       	ret

000020f4 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20f4:	ff 92       	push	r15
    20f6:	0f 93       	push	r16
    20f8:	1f 93       	push	r17
    20fa:	cf 93       	push	r28
    20fc:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20fe:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2102:	81 11       	cpse	r24, r1
    2104:	ed c0       	rjmp	.+474    	; 0x22e0 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    2106:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    210a:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    210e:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2112:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2116:	01 96       	adiw	r24, 0x01	; 1
    2118:	a1 1d       	adc	r26, r1
    211a:	b1 1d       	adc	r27, r1
    211c:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2120:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    2124:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    2128:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    212c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2130:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2134:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2138:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    213c:	89 2b       	or	r24, r25
    213e:	8a 2b       	or	r24, r26
    2140:	8b 2b       	or	r24, r27
    2142:	f1 f5       	brne	.+124    	; 0x21c0 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2144:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2148:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    214c:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2150:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    2154:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    2158:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    215c:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    2160:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2164:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2168:	8f 5f       	subi	r24, 0xFF	; 255
    216a:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    216e:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2172:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2176:	80 81       	ld	r24, Z
    2178:	81 11       	cpse	r24, r1
    217a:	0c c0       	rjmp	.+24     	; 0x2194 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    217c:	8f ef       	ldi	r24, 0xFF	; 255
    217e:	9f ef       	ldi	r25, 0xFF	; 255
    2180:	dc 01       	movw	r26, r24
    2182:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2186:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    218a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    218e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2192:	16 c0       	rjmp	.+44     	; 0x21c0 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2194:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2198:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    219c:	07 80       	ldd	r0, Z+7	; 0x07
    219e:	f0 85       	ldd	r31, Z+8	; 0x08
    21a0:	e0 2d       	mov	r30, r0
    21a2:	00 84       	ldd	r0, Z+8	; 0x08
    21a4:	f1 85       	ldd	r31, Z+9	; 0x09
    21a6:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    21a8:	82 81       	ldd	r24, Z+2	; 0x02
    21aa:	93 81       	ldd	r25, Z+3	; 0x03
    21ac:	a4 81       	ldd	r26, Z+4	; 0x04
    21ae:	b5 81       	ldd	r27, Z+5	; 0x05
    21b0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21b4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21b8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21bc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    21c0:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    21c4:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    21c8:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    21cc:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    21d0:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    21d4:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21d8:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21dc:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21e0:	48 17       	cp	r20, r24
    21e2:	59 07       	cpc	r21, r25
    21e4:	6a 07       	cpc	r22, r26
    21e6:	7b 07       	cpc	r23, r27
    21e8:	08 f4       	brcc	.+2      	; 0x21ec <vTaskIncrementTick+0xf8>
    21ea:	7f c0       	rjmp	.+254    	; 0x22ea <vTaskIncrementTick+0x1f6>
    21ec:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    21f0:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    21f4:	80 81       	ld	r24, Z
    21f6:	88 23       	and	r24, r24
    21f8:	f9 f0       	breq	.+62     	; 0x2238 <vTaskIncrementTick+0x144>
    21fa:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    21fe:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2202:	07 80       	ldd	r0, Z+7	; 0x07
    2204:	f0 85       	ldd	r31, Z+8	; 0x08
    2206:	e0 2d       	mov	r30, r0
    2208:	c0 85       	ldd	r28, Z+8	; 0x08
    220a:	d1 85       	ldd	r29, Z+9	; 0x09
    220c:	8a 81       	ldd	r24, Y+2	; 0x02
    220e:	9b 81       	ldd	r25, Y+3	; 0x03
    2210:	ac 81       	ldd	r26, Y+4	; 0x04
    2212:	bd 81       	ldd	r27, Y+5	; 0x05
    2214:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2218:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    221c:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2220:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2224:	48 17       	cp	r20, r24
    2226:	59 07       	cpc	r21, r25
    2228:	6a 07       	cpc	r22, r26
    222a:	7b 07       	cpc	r23, r27
    222c:	58 f1       	brcs	.+86     	; 0x2284 <vTaskIncrementTick+0x190>
    222e:	0f 2e       	mov	r0, r31
    2230:	fb e0       	ldi	r31, 0x0B	; 11
    2232:	ff 2e       	mov	r15, r31
    2234:	f0 2d       	mov	r31, r0
    2236:	2f c0       	rjmp	.+94     	; 0x2296 <vTaskIncrementTick+0x1a2>
    2238:	8f ef       	ldi	r24, 0xFF	; 255
    223a:	9f ef       	ldi	r25, 0xFF	; 255
    223c:	dc 01       	movw	r26, r24
    223e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2242:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2246:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    224a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    224e:	4d c0       	rjmp	.+154    	; 0x22ea <vTaskIncrementTick+0x1f6>
    2250:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2254:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2258:	07 80       	ldd	r0, Z+7	; 0x07
    225a:	f0 85       	ldd	r31, Z+8	; 0x08
    225c:	e0 2d       	mov	r30, r0
    225e:	c0 85       	ldd	r28, Z+8	; 0x08
    2260:	d1 85       	ldd	r29, Z+9	; 0x09
    2262:	8a 81       	ldd	r24, Y+2	; 0x02
    2264:	9b 81       	ldd	r25, Y+3	; 0x03
    2266:	ac 81       	ldd	r26, Y+4	; 0x04
    2268:	bd 81       	ldd	r27, Y+5	; 0x05
    226a:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    226e:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2272:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2276:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    227a:	48 17       	cp	r20, r24
    227c:	59 07       	cpc	r21, r25
    227e:	6a 07       	cpc	r22, r26
    2280:	7b 07       	cpc	r23, r27
    2282:	48 f4       	brcc	.+18     	; 0x2296 <vTaskIncrementTick+0x1a2>
    2284:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2288:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    228c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2290:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2294:	2a c0       	rjmp	.+84     	; 0x22ea <vTaskIncrementTick+0x1f6>
    2296:	8e 01       	movw	r16, r28
    2298:	0e 5f       	subi	r16, 0xFE	; 254
    229a:	1f 4f       	sbci	r17, 0xFF	; 255
    229c:	c8 01       	movw	r24, r16
    229e:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>
    22a2:	88 8d       	ldd	r24, Y+24	; 0x18
    22a4:	99 8d       	ldd	r25, Y+25	; 0x19
    22a6:	89 2b       	or	r24, r25
    22a8:	21 f0       	breq	.+8      	; 0x22b2 <vTaskIncrementTick+0x1be>
    22aa:	ce 01       	movw	r24, r28
    22ac:	0e 96       	adiw	r24, 0x0e	; 14
    22ae:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>
    22b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22b4:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    22b8:	98 17       	cp	r25, r24
    22ba:	10 f4       	brcc	.+4      	; 0x22c0 <vTaskIncrementTick+0x1cc>
    22bc:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    22c0:	f8 9e       	mul	r15, r24
    22c2:	c0 01       	movw	r24, r0
    22c4:	11 24       	eor	r1, r1
    22c6:	b8 01       	movw	r22, r16
    22c8:	88 50       	subi	r24, 0x08	; 8
    22ca:	9f 4c       	sbci	r25, 0xCF	; 207
    22cc:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListInsertEnd>
    22d0:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    22d4:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    22d8:	80 81       	ld	r24, Z
    22da:	81 11       	cpse	r24, r1
    22dc:	b9 cf       	rjmp	.-142    	; 0x2250 <vTaskIncrementTick+0x15c>
    22de:	ac cf       	rjmp	.-168    	; 0x2238 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22e0:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    22e4:	8f 5f       	subi	r24, 0xFF	; 255
    22e6:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22ea:	df 91       	pop	r29
    22ec:	cf 91       	pop	r28
    22ee:	1f 91       	pop	r17
    22f0:	0f 91       	pop	r16
    22f2:	ff 90       	pop	r15
    22f4:	08 95       	ret

000022f6 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22f6:	cf 92       	push	r12
    22f8:	df 92       	push	r13
    22fa:	ef 92       	push	r14
    22fc:	ff 92       	push	r15
    22fe:	0f 93       	push	r16
    2300:	1f 93       	push	r17
    2302:	cf 93       	push	r28
    2304:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2306:	0f b6       	in	r0, 0x3f	; 63
    2308:	f8 94       	cli
    230a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    230c:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2310:	81 50       	subi	r24, 0x01	; 1
    2312:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2316:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    231a:	81 11       	cpse	r24, r1
    231c:	60 c0       	rjmp	.+192    	; 0x23de <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    231e:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2322:	81 11       	cpse	r24, r1
    2324:	2c c0       	rjmp	.+88     	; 0x237e <xTaskResumeAll+0x88>
    2326:	5e c0       	rjmp	.+188    	; 0x23e4 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2328:	d7 01       	movw	r26, r14
    232a:	17 96       	adiw	r26, 0x07	; 7
    232c:	ed 91       	ld	r30, X+
    232e:	fc 91       	ld	r31, X
    2330:	18 97       	sbiw	r26, 0x08	; 8
    2332:	c0 85       	ldd	r28, Z+8	; 0x08
    2334:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2336:	ce 01       	movw	r24, r28
    2338:	0e 96       	adiw	r24, 0x0e	; 14
    233a:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    233e:	8e 01       	movw	r16, r28
    2340:	0e 5f       	subi	r16, 0xFE	; 254
    2342:	1f 4f       	sbci	r17, 0xFF	; 255
    2344:	c8 01       	movw	r24, r16
    2346:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    234a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    234c:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2350:	98 17       	cp	r25, r24
    2352:	10 f4       	brcc	.+4      	; 0x2358 <xTaskResumeAll+0x62>
    2354:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2358:	d8 9e       	mul	r13, r24
    235a:	c0 01       	movw	r24, r0
    235c:	11 24       	eor	r1, r1
    235e:	b8 01       	movw	r22, r16
    2360:	88 50       	subi	r24, 0x08	; 8
    2362:	9f 4c       	sbci	r25, 0xCF	; 207
    2364:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2368:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    236c:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2370:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2372:	82 8d       	ldd	r24, Z+26	; 0x1a
    2374:	98 17       	cp	r25, r24
    2376:	70 f0       	brcs	.+28     	; 0x2394 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2378:	cc 24       	eor	r12, r12
    237a:	c3 94       	inc	r12
    237c:	0b c0       	rjmp	.+22     	; 0x2394 <xTaskResumeAll+0x9e>
    237e:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2380:	0f 2e       	mov	r0, r31
    2382:	f3 ed       	ldi	r31, 0xD3	; 211
    2384:	ef 2e       	mov	r14, r31
    2386:	f0 e3       	ldi	r31, 0x30	; 48
    2388:	ff 2e       	mov	r15, r31
    238a:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    238c:	0f 2e       	mov	r0, r31
    238e:	fb e0       	ldi	r31, 0x0B	; 11
    2390:	df 2e       	mov	r13, r31
    2392:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2394:	f7 01       	movw	r30, r14
    2396:	80 81       	ld	r24, Z
    2398:	81 11       	cpse	r24, r1
    239a:	c6 cf       	rjmp	.-116    	; 0x2328 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    239c:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23a0:	88 23       	and	r24, r24
    23a2:	81 f0       	breq	.+32     	; 0x23c4 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23a4:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23a8:	88 23       	and	r24, r24
    23aa:	99 f0       	breq	.+38     	; 0x23d2 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    23ac:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <vTaskIncrementTick>
						--uxMissedTicks;
    23b0:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23b4:	81 50       	subi	r24, 0x01	; 1
    23b6:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23ba:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23be:	81 11       	cpse	r24, r1
    23c0:	f5 cf       	rjmp	.-22     	; 0x23ac <xTaskResumeAll+0xb6>
    23c2:	07 c0       	rjmp	.+14     	; 0x23d2 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    23c4:	f1 e0       	ldi	r31, 0x01	; 1
    23c6:	cf 16       	cp	r12, r31
    23c8:	21 f0       	breq	.+8      	; 0x23d2 <xTaskResumeAll+0xdc>
    23ca:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    23ce:	81 30       	cpi	r24, 0x01	; 1
    23d0:	41 f4       	brne	.+16     	; 0x23e2 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23d2:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    23d6:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23da:	81 e0       	ldi	r24, 0x01	; 1
    23dc:	03 c0       	rjmp	.+6      	; 0x23e4 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23de:	80 e0       	ldi	r24, 0x00	; 0
    23e0:	01 c0       	rjmp	.+2      	; 0x23e4 <xTaskResumeAll+0xee>
    23e2:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23e4:	0f 90       	pop	r0
    23e6:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	1f 91       	pop	r17
    23ee:	0f 91       	pop	r16
    23f0:	ff 90       	pop	r15
    23f2:	ef 90       	pop	r14
    23f4:	df 90       	pop	r13
    23f6:	cf 90       	pop	r12
    23f8:	08 95       	ret

000023fa <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    23fa:	cf 92       	push	r12
    23fc:	df 92       	push	r13
    23fe:	ef 92       	push	r14
    2400:	ff 92       	push	r15
    2402:	cf 93       	push	r28
    2404:	df 93       	push	r29
    2406:	ec 01       	movw	r28, r24
    2408:	6a 01       	movw	r12, r20
    240a:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    240c:	0e 94 59 10 	call	0x20b2	; 0x20b2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2410:	88 81       	ld	r24, Y
    2412:	99 81       	ldd	r25, Y+1	; 0x01
    2414:	aa 81       	ldd	r26, Y+2	; 0x02
    2416:	bb 81       	ldd	r27, Y+3	; 0x03
    2418:	c8 0e       	add	r12, r24
    241a:	d9 1e       	adc	r13, r25
    241c:	ea 1e       	adc	r14, r26
    241e:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2420:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2424:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2428:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    242c:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2430:	48 17       	cp	r20, r24
    2432:	59 07       	cpc	r21, r25
    2434:	6a 07       	cpc	r22, r26
    2436:	7b 07       	cpc	r23, r27
    2438:	b8 f4       	brcc	.+46     	; 0x2468 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    243a:	c8 16       	cp	r12, r24
    243c:	d9 06       	cpc	r13, r25
    243e:	ea 06       	cpc	r14, r26
    2440:	fb 06       	cpc	r15, r27
    2442:	e0 f5       	brcc	.+120    	; 0x24bc <vTaskDelayUntil+0xc2>
    2444:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2448:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    244c:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2450:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2454:	c8 82       	st	Y, r12
    2456:	d9 82       	std	Y+1, r13	; 0x01
    2458:	ea 82       	std	Y+2, r14	; 0x02
    245a:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    245c:	8c 15       	cp	r24, r12
    245e:	9d 05       	cpc	r25, r13
    2460:	ae 05       	cpc	r26, r14
    2462:	bf 05       	cpc	r27, r15
    2464:	f8 f4       	brcc	.+62     	; 0x24a4 <vTaskDelayUntil+0xaa>
    2466:	13 c0       	rjmp	.+38     	; 0x248e <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2468:	c8 16       	cp	r12, r24
    246a:	d9 06       	cpc	r13, r25
    246c:	ea 06       	cpc	r14, r26
    246e:	fb 06       	cpc	r15, r27
    2470:	00 f1       	brcs	.+64     	; 0x24b2 <vTaskDelayUntil+0xb8>
    2472:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2476:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    247a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    247e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2482:	8c 15       	cp	r24, r12
    2484:	9d 05       	cpc	r25, r13
    2486:	ae 05       	cpc	r26, r14
    2488:	bf 05       	cpc	r27, r15
    248a:	98 f0       	brcs	.+38     	; 0x24b2 <vTaskDelayUntil+0xb8>
    248c:	17 c0       	rjmp	.+46     	; 0x24bc <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    248e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2492:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2496:	02 96       	adiw	r24, 0x02	; 2
    2498:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    249c:	c7 01       	movw	r24, r14
    249e:	b6 01       	movw	r22, r12
    24a0:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    24a4:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24a8:	81 11       	cpse	r24, r1
    24aa:	0d c0       	rjmp	.+26     	; 0x24c6 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    24ac:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
		}
	}
    24b0:	0a c0       	rjmp	.+20     	; 0x24c6 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24b2:	c8 82       	st	Y, r12
    24b4:	d9 82       	std	Y+1, r13	; 0x01
    24b6:	ea 82       	std	Y+2, r14	; 0x02
    24b8:	fb 82       	std	Y+3, r15	; 0x03
    24ba:	e9 cf       	rjmp	.-46     	; 0x248e <vTaskDelayUntil+0x94>
    24bc:	c8 82       	st	Y, r12
    24be:	d9 82       	std	Y+1, r13	; 0x01
    24c0:	ea 82       	std	Y+2, r14	; 0x02
    24c2:	fb 82       	std	Y+3, r15	; 0x03
    24c4:	ef cf       	rjmp	.-34     	; 0x24a4 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    24c6:	df 91       	pop	r29
    24c8:	cf 91       	pop	r28
    24ca:	ff 90       	pop	r15
    24cc:	ef 90       	pop	r14
    24ce:	df 90       	pop	r13
    24d0:	cf 90       	pop	r12
    24d2:	08 95       	ret

000024d4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    24d4:	cf 92       	push	r12
    24d6:	df 92       	push	r13
    24d8:	ef 92       	push	r14
    24da:	ff 92       	push	r15
    24dc:	6b 01       	movw	r12, r22
    24de:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24e0:	67 2b       	or	r22, r23
    24e2:	68 2b       	or	r22, r24
    24e4:	69 2b       	or	r22, r25
    24e6:	e9 f0       	breq	.+58     	; 0x2522 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    24e8:	0e 94 59 10 	call	0x20b2	; 0x20b2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24ec:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    24f0:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    24f4:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    24f8:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    24fc:	c8 0e       	add	r12, r24
    24fe:	d9 1e       	adc	r13, r25
    2500:	ea 1e       	adc	r14, r26
    2502:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2504:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2508:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    250c:	02 96       	adiw	r24, 0x02	; 2
    250e:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2512:	c7 01       	movw	r24, r14
    2514:	b6 01       	movw	r22, r12
    2516:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    251a:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    251e:	81 11       	cpse	r24, r1
    2520:	02 c0       	rjmp	.+4      	; 0x2526 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2522:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <vPortYield>
		}
	}
    2526:	ff 90       	pop	r15
    2528:	ef 90       	pop	r14
    252a:	df 90       	pop	r13
    252c:	cf 90       	pop	r12
    252e:	08 95       	ret

00002530 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2530:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2534:	81 11       	cpse	r24, r1
    2536:	0c c0       	rjmp	.+24     	; 0x2550 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2538:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    253c:	4b e0       	ldi	r20, 0x0B	; 11
    253e:	e4 9f       	mul	r30, r20
    2540:	f0 01       	movw	r30, r0
    2542:	11 24       	eor	r1, r1
    2544:	e8 50       	subi	r30, 0x08	; 8
    2546:	ff 4c       	sbci	r31, 0xCF	; 207
    2548:	80 81       	ld	r24, Z
    254a:	88 23       	and	r24, r24
    254c:	29 f0       	breq	.+10     	; 0x2558 <vTaskSwitchContext+0x28>
    254e:	14 c0       	rjmp	.+40     	; 0x2578 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2550:	81 e0       	ldi	r24, 0x01	; 1
    2552:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2556:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2558:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    255a:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    255e:	81 50       	subi	r24, 0x01	; 1
    2560:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2564:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2568:	9e 9f       	mul	r25, r30
    256a:	f0 01       	movw	r30, r0
    256c:	11 24       	eor	r1, r1
    256e:	e8 50       	subi	r30, 0x08	; 8
    2570:	ff 4c       	sbci	r31, 0xCF	; 207
    2572:	80 81       	ld	r24, Z
    2574:	88 23       	and	r24, r24
    2576:	89 f3       	breq	.-30     	; 0x255a <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2578:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    257c:	28 2f       	mov	r18, r24
    257e:	30 e0       	ldi	r19, 0x00	; 0
    2580:	4b e0       	ldi	r20, 0x0B	; 11
    2582:	84 9f       	mul	r24, r20
    2584:	c0 01       	movw	r24, r0
    2586:	11 24       	eor	r1, r1
    2588:	dc 01       	movw	r26, r24
    258a:	a8 50       	subi	r26, 0x08	; 8
    258c:	bf 4c       	sbci	r27, 0xCF	; 207
    258e:	11 96       	adiw	r26, 0x01	; 1
    2590:	ed 91       	ld	r30, X+
    2592:	fc 91       	ld	r31, X
    2594:	12 97       	sbiw	r26, 0x02	; 2
    2596:	04 80       	ldd	r0, Z+4	; 0x04
    2598:	f5 81       	ldd	r31, Z+5	; 0x05
    259a:	e0 2d       	mov	r30, r0
    259c:	11 96       	adiw	r26, 0x01	; 1
    259e:	ed 93       	st	X+, r30
    25a0:	fc 93       	st	X, r31
    25a2:	12 97       	sbiw	r26, 0x02	; 2
    25a4:	85 50       	subi	r24, 0x05	; 5
    25a6:	9f 4c       	sbci	r25, 0xCF	; 207
    25a8:	e8 17       	cp	r30, r24
    25aa:	f9 07       	cpc	r31, r25
    25ac:	61 f4       	brne	.+24     	; 0x25c6 <vTaskSwitchContext+0x96>
    25ae:	84 81       	ldd	r24, Z+4	; 0x04
    25b0:	95 81       	ldd	r25, Z+5	; 0x05
    25b2:	4b e0       	ldi	r20, 0x0B	; 11
    25b4:	42 9f       	mul	r20, r18
    25b6:	f0 01       	movw	r30, r0
    25b8:	43 9f       	mul	r20, r19
    25ba:	f0 0d       	add	r31, r0
    25bc:	11 24       	eor	r1, r1
    25be:	e8 50       	subi	r30, 0x08	; 8
    25c0:	ff 4c       	sbci	r31, 0xCF	; 207
    25c2:	81 83       	std	Z+1, r24	; 0x01
    25c4:	92 83       	std	Z+2, r25	; 0x02
    25c6:	8b e0       	ldi	r24, 0x0B	; 11
    25c8:	82 9f       	mul	r24, r18
    25ca:	f0 01       	movw	r30, r0
    25cc:	83 9f       	mul	r24, r19
    25ce:	f0 0d       	add	r31, r0
    25d0:	11 24       	eor	r1, r1
    25d2:	e8 50       	subi	r30, 0x08	; 8
    25d4:	ff 4c       	sbci	r31, 0xCF	; 207
    25d6:	01 80       	ldd	r0, Z+1	; 0x01
    25d8:	f2 81       	ldd	r31, Z+2	; 0x02
    25da:	e0 2d       	mov	r30, r0
    25dc:	80 85       	ldd	r24, Z+8	; 0x08
    25de:	91 85       	ldd	r25, Z+9	; 0x09
    25e0:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    25e4:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    25e8:	08 95       	ret

000025ea <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25ea:	cf 92       	push	r12
    25ec:	df 92       	push	r13
    25ee:	ef 92       	push	r14
    25f0:	ff 92       	push	r15
    25f2:	6a 01       	movw	r12, r20
    25f4:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25f6:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    25fa:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    25fe:	62 5f       	subi	r22, 0xF2	; 242
    2600:	7f 4f       	sbci	r23, 0xFF	; 255
    2602:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2606:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    260a:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    260e:	02 96       	adiw	r24, 0x02	; 2
    2610:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2614:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2618:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    261c:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2620:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2624:	bc 01       	movw	r22, r24
    2626:	cd 01       	movw	r24, r26
    2628:	6c 0d       	add	r22, r12
    262a:	7d 1d       	adc	r23, r13
    262c:	8e 1d       	adc	r24, r14
    262e:	9f 1d       	adc	r25, r15
    2630:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2634:	ff 90       	pop	r15
    2636:	ef 90       	pop	r14
    2638:	df 90       	pop	r13
    263a:	cf 90       	pop	r12
    263c:	08 95       	ret

0000263e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    263e:	0f 93       	push	r16
    2640:	1f 93       	push	r17
    2642:	cf 93       	push	r28
    2644:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2646:	dc 01       	movw	r26, r24
    2648:	17 96       	adiw	r26, 0x07	; 7
    264a:	ed 91       	ld	r30, X+
    264c:	fc 91       	ld	r31, X
    264e:	18 97       	sbiw	r26, 0x08	; 8
    2650:	c0 85       	ldd	r28, Z+8	; 0x08
    2652:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2654:	8e 01       	movw	r16, r28
    2656:	02 5f       	subi	r16, 0xF2	; 242
    2658:	1f 4f       	sbci	r17, 0xFF	; 255
    265a:	c8 01       	movw	r24, r16
    265c:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2660:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2664:	81 11       	cpse	r24, r1
    2666:	16 c0       	rjmp	.+44     	; 0x2694 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2668:	0c 50       	subi	r16, 0x0C	; 12
    266a:	11 09       	sbc	r17, r1
    266c:	c8 01       	movw	r24, r16
    266e:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2672:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2674:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2678:	98 17       	cp	r25, r24
    267a:	10 f4       	brcc	.+4      	; 0x2680 <xTaskRemoveFromEventList+0x42>
    267c:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2680:	bb e0       	ldi	r27, 0x0B	; 11
    2682:	8b 9f       	mul	r24, r27
    2684:	c0 01       	movw	r24, r0
    2686:	11 24       	eor	r1, r1
    2688:	b8 01       	movw	r22, r16
    268a:	88 50       	subi	r24, 0x08	; 8
    268c:	9f 4c       	sbci	r25, 0xCF	; 207
    268e:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListInsertEnd>
    2692:	05 c0       	rjmp	.+10     	; 0x269e <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2694:	b8 01       	movw	r22, r16
    2696:	83 ed       	ldi	r24, 0xD3	; 211
    2698:	90 e3       	ldi	r25, 0x30	; 48
    269a:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    269e:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    26a2:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    26a6:	81 e0       	ldi	r24, 0x01	; 1
    26a8:	2a 8d       	ldd	r18, Y+26	; 0x1a
    26aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    26ac:	29 17       	cp	r18, r25
    26ae:	08 f4       	brcc	.+2      	; 0x26b2 <xTaskRemoveFromEventList+0x74>
    26b0:	80 e0       	ldi	r24, 0x00	; 0
}
    26b2:	df 91       	pop	r29
    26b4:	cf 91       	pop	r28
    26b6:	1f 91       	pop	r17
    26b8:	0f 91       	pop	r16
    26ba:	08 95       	ret

000026bc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    26bc:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    26c0:	fc 01       	movw	r30, r24
    26c2:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    26c4:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    26c8:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    26cc:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    26d0:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    26d4:	41 83       	std	Z+1, r20	; 0x01
    26d6:	52 83       	std	Z+2, r21	; 0x02
    26d8:	63 83       	std	Z+3, r22	; 0x03
    26da:	74 83       	std	Z+4, r23	; 0x04
    26dc:	08 95       	ret

000026de <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26de:	8f 92       	push	r8
    26e0:	9f 92       	push	r9
    26e2:	af 92       	push	r10
    26e4:	bf 92       	push	r11
    26e6:	cf 92       	push	r12
    26e8:	df 92       	push	r13
    26ea:	ef 92       	push	r14
    26ec:	ff 92       	push	r15
    26ee:	0f 93       	push	r16
    26f0:	1f 93       	push	r17
    26f2:	cf 93       	push	r28
    26f4:	df 93       	push	r29
    26f6:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	f8 94       	cli
    26fc:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26fe:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2702:	90 81       	ld	r25, Z
    2704:	98 17       	cp	r25, r24
    2706:	89 f0       	breq	.+34     	; 0x272a <xTaskCheckForTimeOut+0x4c>
    2708:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    270c:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2710:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2714:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2718:	01 81       	ldd	r16, Z+1	; 0x01
    271a:	12 81       	ldd	r17, Z+2	; 0x02
    271c:	23 81       	ldd	r18, Z+3	; 0x03
    271e:	34 81       	ldd	r19, Z+4	; 0x04
    2720:	80 17       	cp	r24, r16
    2722:	91 07       	cpc	r25, r17
    2724:	a2 07       	cpc	r26, r18
    2726:	b3 07       	cpc	r27, r19
    2728:	a8 f5       	brcc	.+106    	; 0x2794 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    272a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    272e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2732:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2736:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    273a:	c1 80       	ldd	r12, Z+1	; 0x01
    273c:	d2 80       	ldd	r13, Z+2	; 0x02
    273e:	e3 80       	ldd	r14, Z+3	; 0x03
    2740:	f4 80       	ldd	r15, Z+4	; 0x04
    2742:	eb 01       	movw	r28, r22
    2744:	08 81       	ld	r16, Y
    2746:	19 81       	ldd	r17, Y+1	; 0x01
    2748:	2a 81       	ldd	r18, Y+2	; 0x02
    274a:	3b 81       	ldd	r19, Y+3	; 0x03
    274c:	8c 19       	sub	r24, r12
    274e:	9d 09       	sbc	r25, r13
    2750:	ae 09       	sbc	r26, r14
    2752:	bf 09       	sbc	r27, r15
    2754:	80 17       	cp	r24, r16
    2756:	91 07       	cpc	r25, r17
    2758:	a2 07       	cpc	r26, r18
    275a:	b3 07       	cpc	r27, r19
    275c:	e8 f4       	brcc	.+58     	; 0x2798 <xTaskCheckForTimeOut+0xba>
    275e:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2760:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    2764:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2768:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    276c:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2770:	b5 01       	movw	r22, r10
    2772:	a4 01       	movw	r20, r8
    2774:	4c 19       	sub	r20, r12
    2776:	5d 09       	sbc	r21, r13
    2778:	6e 09       	sbc	r22, r14
    277a:	7f 09       	sbc	r23, r15
    277c:	04 1b       	sub	r16, r20
    277e:	15 0b       	sbc	r17, r21
    2780:	26 0b       	sbc	r18, r22
    2782:	37 0b       	sbc	r19, r23
    2784:	08 83       	st	Y, r16
    2786:	19 83       	std	Y+1, r17	; 0x01
    2788:	2a 83       	std	Y+2, r18	; 0x02
    278a:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    278c:	0e 94 5e 13 	call	0x26bc	; 0x26bc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2790:	80 e0       	ldi	r24, 0x00	; 0
    2792:	03 c0       	rjmp	.+6      	; 0x279a <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2794:	81 e0       	ldi	r24, 0x01	; 1
    2796:	01 c0       	rjmp	.+2      	; 0x279a <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2798:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    279a:	0f 90       	pop	r0
    279c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    279e:	df 91       	pop	r29
    27a0:	cf 91       	pop	r28
    27a2:	1f 91       	pop	r17
    27a4:	0f 91       	pop	r16
    27a6:	ff 90       	pop	r15
    27a8:	ef 90       	pop	r14
    27aa:	df 90       	pop	r13
    27ac:	cf 90       	pop	r12
    27ae:	bf 90       	pop	r11
    27b0:	af 90       	pop	r10
    27b2:	9f 90       	pop	r9
    27b4:	8f 90       	pop	r8
    27b6:	08 95       	ret

000027b8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    27be:	08 95       	ret

000027c0 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27c0:	00 97       	sbiw	r24, 0x00	; 0
    27c2:	21 f4       	brne	.+8      	; 0x27cc <uxTaskGetStackHighWaterMark+0xc>
    27c4:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    27c8:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    27cc:	dc 01       	movw	r26, r24
    27ce:	5b 96       	adiw	r26, 0x1b	; 27
    27d0:	ed 91       	ld	r30, X+
    27d2:	fc 91       	ld	r31, X
    27d4:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27d6:	80 81       	ld	r24, Z
    27d8:	81 31       	cpi	r24, 0x11	; 17
    27da:	41 f4       	brne	.+16     	; 0x27ec <uxTaskGetStackHighWaterMark+0x2c>
    27dc:	31 96       	adiw	r30, 0x01	; 1
    27de:	80 e0       	ldi	r24, 0x00	; 0
    27e0:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27e2:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27e4:	21 91       	ld	r18, Z+
    27e6:	21 31       	cpi	r18, 0x11	; 17
    27e8:	e1 f3       	breq	.-8      	; 0x27e2 <uxTaskGetStackHighWaterMark+0x22>
    27ea:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27ec:	80 e0       	ldi	r24, 0x00	; 0
    27ee:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27f0:	08 95       	ret

000027f2 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27f2:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    27f6:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    27fa:	08 95       	ret

000027fc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27fc:	0f 93       	push	r16
    27fe:	1f 93       	push	r17
    2800:	cf 93       	push	r28
    2802:	df 93       	push	r29
    2804:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2806:	22 8d       	ldd	r18, Z+26	; 0x1a
    2808:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    280c:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2810:	5a 96       	adiw	r26, 0x1a	; 26
    2812:	8c 91       	ld	r24, X
    2814:	28 17       	cp	r18, r24
    2816:	08 f0       	brcs	.+2      	; 0x281a <vTaskPriorityInherit+0x1e>
    2818:	41 c0       	rjmp	.+130    	; 0x289c <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    281a:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    281e:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2822:	5a 96       	adiw	r26, 0x1a	; 26
    2824:	3c 91       	ld	r19, X
    2826:	84 e0       	ldi	r24, 0x04	; 4
    2828:	90 e0       	ldi	r25, 0x00	; 0
    282a:	a0 e0       	ldi	r26, 0x00	; 0
    282c:	b0 e0       	ldi	r27, 0x00	; 0
    282e:	83 1b       	sub	r24, r19
    2830:	91 09       	sbc	r25, r1
    2832:	a1 09       	sbc	r26, r1
    2834:	b1 09       	sbc	r27, r1
    2836:	86 87       	std	Z+14, r24	; 0x0e
    2838:	97 87       	std	Z+15, r25	; 0x0f
    283a:	a0 8b       	std	Z+16, r26	; 0x10
    283c:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    283e:	8b e0       	ldi	r24, 0x0B	; 11
    2840:	28 9f       	mul	r18, r24
    2842:	90 01       	movw	r18, r0
    2844:	11 24       	eor	r1, r1
    2846:	28 50       	subi	r18, 0x08	; 8
    2848:	3f 4c       	sbci	r19, 0xCF	; 207
    284a:	84 85       	ldd	r24, Z+12	; 0x0c
    284c:	95 85       	ldd	r25, Z+13	; 0x0d
    284e:	82 17       	cp	r24, r18
    2850:	93 07       	cpc	r25, r19
    2852:	e9 f4       	brne	.+58     	; 0x288e <vTaskPriorityInherit+0x92>
    2854:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2856:	ef 01       	movw	r28, r30
    2858:	22 96       	adiw	r28, 0x02	; 2
    285a:	ce 01       	movw	r24, r28
    285c:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2860:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2864:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2868:	82 8d       	ldd	r24, Z+26	; 0x1a
    286a:	f8 01       	movw	r30, r16
    286c:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    286e:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2872:	98 17       	cp	r25, r24
    2874:	10 f4       	brcc	.+4      	; 0x287a <vTaskPriorityInherit+0x7e>
    2876:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    287a:	fb e0       	ldi	r31, 0x0B	; 11
    287c:	8f 9f       	mul	r24, r31
    287e:	c0 01       	movw	r24, r0
    2880:	11 24       	eor	r1, r1
    2882:	be 01       	movw	r22, r28
    2884:	88 50       	subi	r24, 0x08	; 8
    2886:	9f 4c       	sbci	r25, 0xCF	; 207
    2888:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListInsertEnd>
    288c:	07 c0       	rjmp	.+14     	; 0x289c <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    288e:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2892:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2896:	5a 96       	adiw	r26, 0x1a	; 26
    2898:	8c 91       	ld	r24, X
    289a:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    289c:	df 91       	pop	r29
    289e:	cf 91       	pop	r28
    28a0:	1f 91       	pop	r17
    28a2:	0f 91       	pop	r16
    28a4:	08 95       	ret

000028a6 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    28a6:	0f 93       	push	r16
    28a8:	1f 93       	push	r17
    28aa:	cf 93       	push	r28
    28ac:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    28ae:	00 97       	sbiw	r24, 0x00	; 0
    28b0:	49 f1       	breq	.+82     	; 0x2904 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    28b2:	fc 01       	movw	r30, r24
    28b4:	32 8d       	ldd	r19, Z+26	; 0x1a
    28b6:	27 a1       	ldd	r18, Z+39	; 0x27
    28b8:	32 17       	cp	r19, r18
    28ba:	21 f1       	breq	.+72     	; 0x2904 <vTaskPriorityDisinherit+0x5e>
    28bc:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    28be:	8c 01       	movw	r16, r24
    28c0:	0e 5f       	subi	r16, 0xFE	; 254
    28c2:	1f 4f       	sbci	r17, 0xFF	; 255
    28c4:	c8 01       	movw	r24, r16
    28c6:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28ca:	8f a1       	ldd	r24, Y+39	; 0x27
    28cc:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28ce:	44 e0       	ldi	r20, 0x04	; 4
    28d0:	50 e0       	ldi	r21, 0x00	; 0
    28d2:	60 e0       	ldi	r22, 0x00	; 0
    28d4:	70 e0       	ldi	r23, 0x00	; 0
    28d6:	48 1b       	sub	r20, r24
    28d8:	51 09       	sbc	r21, r1
    28da:	61 09       	sbc	r22, r1
    28dc:	71 09       	sbc	r23, r1
    28de:	4e 87       	std	Y+14, r20	; 0x0e
    28e0:	5f 87       	std	Y+15, r21	; 0x0f
    28e2:	68 8b       	std	Y+16, r22	; 0x10
    28e4:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28e6:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    28ea:	98 17       	cp	r25, r24
    28ec:	10 f4       	brcc	.+4      	; 0x28f2 <vTaskPriorityDisinherit+0x4c>
    28ee:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    28f2:	fb e0       	ldi	r31, 0x0B	; 11
    28f4:	8f 9f       	mul	r24, r31
    28f6:	c0 01       	movw	r24, r0
    28f8:	11 24       	eor	r1, r1
    28fa:	b8 01       	movw	r22, r16
    28fc:	88 50       	subi	r24, 0x08	; 8
    28fe:	9f 4c       	sbci	r25, 0xCF	; 207
    2900:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListInsertEnd>
			}
		}
	}
    2904:	df 91       	pop	r29
    2906:	cf 91       	pop	r28
    2908:	1f 91       	pop	r17
    290a:	0f 91       	pop	r16
    290c:	08 95       	ret

0000290e <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    290e:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2910:	e8 81       	ld	r30, Y
    2912:	f9 81       	ldd	r31, Y+1	; 0x01
    2914:	01 90       	ld	r0, Z+
    2916:	f0 81       	ld	r31, Z
    2918:	e0 2d       	mov	r30, r0
    291a:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    291c:	1a 82       	std	Y+2, r1	; 0x02
    291e:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2920:	6f ef       	ldi	r22, 0xFF	; 255
    2922:	7f ef       	ldi	r23, 0xFF	; 255
    2924:	cb 01       	movw	r24, r22
    2926:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <vTaskDelay>
    292a:	fa cf       	rjmp	.-12     	; 0x2920 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000292c <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    292c:	fc 01       	movw	r30, r24
    292e:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2930:	65 87       	std	Z+13, r22	; 0x0d
    2932:	08 95       	ret

00002934 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2934:	4f 92       	push	r4
    2936:	5f 92       	push	r5
    2938:	6f 92       	push	r6
    293a:	7f 92       	push	r7
    293c:	8f 92       	push	r8
    293e:	9f 92       	push	r9
    2940:	af 92       	push	r10
    2942:	bf 92       	push	r11
    2944:	cf 92       	push	r12
    2946:	df 92       	push	r13
    2948:	ef 92       	push	r14
    294a:	ff 92       	push	r15
    294c:	0f 93       	push	r16
    294e:	1f 93       	push	r17
    2950:	cf 93       	push	r28
    2952:	df 93       	push	r29
    2954:	cd b7       	in	r28, 0x3d	; 61
    2956:	de b7       	in	r29, 0x3e	; 62
    2958:	2a 97       	sbiw	r28, 0x0a	; 10
    295a:	cd bf       	out	0x3d, r28	; 61
    295c:	de bf       	out	0x3e, r29	; 62
    295e:	4c 01       	movw	r8, r24
    2960:	29 01       	movw	r4, r18
    2962:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2964:	8f e3       	ldi	r24, 0x3F	; 63
    2966:	90 e2       	ldi	r25, 0x20	; 32
    2968:	f4 01       	movw	r30, r8
    296a:	80 83       	st	Z, r24
    296c:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    296e:	fb 01       	movw	r30, r22
    2970:	80 81       	ld	r24, Z
    2972:	88 23       	and	r24, r24
    2974:	69 f0       	breq	.+26     	; 0x2990 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2976:	de 01       	movw	r26, r28
    2978:	11 96       	adiw	r26, 0x01	; 1
    297a:	31 96       	adiw	r30, 0x01	; 1
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	02 c0       	rjmp	.+4      	; 0x2984 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2980:	99 30       	cpi	r25, 0x09	; 9
    2982:	39 f0       	breq	.+14     	; 0x2992 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2984:	9f 5f       	subi	r25, 0xFF	; 255
    2986:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2988:	81 91       	ld	r24, Z+
    298a:	81 11       	cpse	r24, r1
    298c:	f9 cf       	rjmp	.-14     	; 0x2980 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    298e:	01 c0       	rjmp	.+2      	; 0x2992 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2990:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2992:	e1 e0       	ldi	r30, 0x01	; 1
    2994:	f0 e0       	ldi	r31, 0x00	; 0
    2996:	ec 0f       	add	r30, r28
    2998:	fd 1f       	adc	r31, r29
    299a:	e9 0f       	add	r30, r25
    299c:	f1 1d       	adc	r31, r1
    299e:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    29a0:	74 01       	movw	r14, r8
    29a2:	f2 e0       	ldi	r31, 0x02	; 2
    29a4:	ef 0e       	add	r14, r31
    29a6:	f1 1c       	adc	r15, r1
    29a8:	a1 2c       	mov	r10, r1
    29aa:	b1 2c       	mov	r11, r1
    29ac:	c1 2c       	mov	r12, r1
    29ae:	d1 2c       	mov	r13, r1
    29b0:	04 2f       	mov	r16, r20
    29b2:	94 01       	movw	r18, r8
    29b4:	a2 01       	movw	r20, r4
    29b6:	be 01       	movw	r22, r28
    29b8:	6f 5f       	subi	r22, 0xFF	; 255
    29ba:	7f 4f       	sbci	r23, 0xFF	; 255
    29bc:	86 ea       	ldi	r24, 0xA6	; 166
    29be:	92 e0       	ldi	r25, 0x02	; 2
    29c0:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    29c4:	f4 01       	movw	r30, r8
    29c6:	66 82       	std	Z+6, r6	; 0x06
    29c8:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    29ca:	40 86       	std	Z+8, r4	; 0x08
    29cc:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    29ce:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    29d2:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    29d6:	24 83       	std	Z+4, r18	; 0x04
    29d8:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29da:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    29de:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29e2:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29e4:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29e6:	40 90 60 31 	lds	r4, 0x3160	; 0x803160 <portStackTopForTask>
    29ea:	50 90 61 31 	lds	r5, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    29ee:	ff ef       	ldi	r31, 0xFF	; 255
    29f0:	4f 1a       	sub	r4, r31
    29f2:	5f 0a       	sbc	r5, r31
    29f4:	40 92 60 31 	sts	0x3160, r4	; 0x803160 <portStackTopForTask>
    29f8:	50 92 61 31 	sts	0x3161, r5	; 0x803161 <portStackTopForTask+0x1>
    29fc:	f4 01       	movw	r30, r8
    29fe:	42 86       	std	Z+10, r4	; 0x0a
    2a00:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2a02:	16 86       	std	Z+14, r1	; 0x0e
    2a04:	17 86       	std	Z+15, r1	; 0x0f
    2a06:	10 8a       	std	Z+16, r1	; 0x10
    2a08:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2a0a:	61 14       	cp	r6, r1
    2a0c:	71 04       	cpc	r7, r1
    2a0e:	09 f4       	brne	.+2      	; 0x2a12 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a10:	44 c0       	rjmp	.+136    	; 0x2a9a <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a12:	81 30       	cpi	r24, 0x01	; 1
    2a14:	79 f5       	brne	.+94     	; 0x2a74 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a16:	6a e0       	ldi	r22, 0x0A	; 10
    2a18:	c3 01       	movw	r24, r6
    2a1a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2a1e:	7c 01       	movw	r14, r24
    2a20:	69 e9       	ldi	r22, 0x99	; 153
    2a22:	74 e0       	ldi	r23, 0x04	; 4
    2a24:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2a28:	be 01       	movw	r22, r28
    2a2a:	6f 5f       	subi	r22, 0xFF	; 255
    2a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a2e:	c7 01       	movw	r24, r14
    2a30:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2a34:	6a e0       	ldi	r22, 0x0A	; 10
    2a36:	c7 01       	movw	r24, r14
    2a38:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2a3c:	7c 01       	movw	r14, r24
    2a3e:	60 e9       	ldi	r22, 0x90	; 144
    2a40:	74 e0       	ldi	r23, 0x04	; 4
    2a42:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a46:	6a e0       	ldi	r22, 0x0A	; 10
    2a48:	c7 01       	movw	r24, r14
    2a4a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2a4e:	7c 01       	movw	r14, r24
    2a50:	62 e8       	ldi	r22, 0x82	; 130
    2a52:	74 e0       	ldi	r23, 0x04	; 4
    2a54:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2a58:	63 e0       	ldi	r22, 0x03	; 3
    2a5a:	c7 01       	movw	r24, r14
    2a5c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2a60:	b2 01       	movw	r22, r4
    2a62:	0e 94 6f 1a 	call	0x34de	; 0x34de <_ZN8emstreamlsEj>
    2a66:	62 e0       	ldi	r22, 0x02	; 2
    2a68:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2a6c:	66 e0       	ldi	r22, 0x06	; 6
    2a6e:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2a72:	13 c0       	rjmp	.+38     	; 0x2a9a <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a74:	6a e0       	ldi	r22, 0x0A	; 10
    2a76:	c3 01       	movw	r24, r6
    2a78:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2a7c:	4c 01       	movw	r8, r24
    2a7e:	6d e6       	ldi	r22, 0x6D	; 109
    2a80:	74 e0       	ldi	r23, 0x04	; 4
    2a82:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2a86:	be 01       	movw	r22, r28
    2a88:	6f 5f       	subi	r22, 0xFF	; 255
    2a8a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8c:	c4 01       	movw	r24, r8
    2a8e:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2a92:	66 e0       	ldi	r22, 0x06	; 6
    2a94:	c4 01       	movw	r24, r8
    2a96:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a9a:	2a 96       	adiw	r28, 0x0a	; 10
    2a9c:	cd bf       	out	0x3d, r28	; 61
    2a9e:	de bf       	out	0x3e, r29	; 62
    2aa0:	df 91       	pop	r29
    2aa2:	cf 91       	pop	r28
    2aa4:	1f 91       	pop	r17
    2aa6:	0f 91       	pop	r16
    2aa8:	ff 90       	pop	r15
    2aaa:	ef 90       	pop	r14
    2aac:	df 90       	pop	r13
    2aae:	cf 90       	pop	r12
    2ab0:	bf 90       	pop	r11
    2ab2:	af 90       	pop	r10
    2ab4:	9f 90       	pop	r9
    2ab6:	8f 90       	pop	r8
    2ab8:	7f 90       	pop	r7
    2aba:	6f 90       	pop	r6
    2abc:	5f 90       	pop	r5
    2abe:	4f 90       	pop	r4
    2ac0:	08 95       	ret

00002ac2 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2ac2:	cf 92       	push	r12
    2ac4:	df 92       	push	r13
    2ac6:	ef 92       	push	r14
    2ac8:	ff 92       	push	r15
    2aca:	0f 93       	push	r16
    2acc:	1f 93       	push	r17
    2ace:	cf 93       	push	r28
    2ad0:	df 93       	push	r29
    2ad2:	ec 01       	movw	r28, r24
    2ad4:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2ad6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad8:	9b 81       	ldd	r25, Y+3	; 0x03
    2ada:	0e 94 6d 10 	call	0x20da	; 0x20da <pcTaskGetTaskName>
    2ade:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2ae0:	6a e0       	ldi	r22, 0x0A	; 10
    2ae2:	c7 01       	movw	r24, r14
    2ae4:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2ae8:	8c 01       	movw	r16, r24
    2aea:	6c ea       	ldi	r22, 0xAC	; 172
    2aec:	74 e0       	ldi	r23, 0x04	; 4
    2aee:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2af2:	6a e0       	ldi	r22, 0x0A	; 10
    2af4:	c8 01       	movw	r24, r16
    2af6:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2afa:	8c 01       	movw	r16, r24
    2afc:	65 ea       	ldi	r22, 0xA5	; 165
    2afe:	74 e0       	ldi	r23, 0x04	; 4
    2b00:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2b04:	b6 01       	movw	r22, r12
    2b06:	c8 01       	movw	r24, r16
    2b08:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2b0c:	6a e0       	ldi	r22, 0x0A	; 10
    2b0e:	c8 01       	movw	r24, r16
    2b10:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2b14:	8c 01       	movw	r16, r24
    2b16:	6f e9       	ldi	r22, 0x9F	; 159
    2b18:	74 e0       	ldi	r23, 0x04	; 4
    2b1a:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2b1e:	66 e0       	ldi	r22, 0x06	; 6
    2b20:	c8 01       	movw	r24, r16
    2b22:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b26:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b28:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b2a:	e8 85       	ldd	r30, Y+8	; 0x08
    2b2c:	f9 85       	ldd	r31, Y+9	; 0x09
    2b2e:	01 e1       	ldi	r16, 0x11	; 17
    2b30:	21 e0       	ldi	r18, 0x01	; 1
    2b32:	a7 01       	movw	r20, r14
    2b34:	bc 01       	movw	r22, r24
    2b36:	8e 1b       	sub	r24, r30
    2b38:	9f 0b       	sbc	r25, r31
    2b3a:	0e 94 63 18 	call	0x30c6	; 0x30c6 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b3e:	8c 81       	ldd	r24, Y+4	; 0x04
    2b40:	9d 81       	ldd	r25, Y+5	; 0x05
    2b42:	00 97       	sbiw	r24, 0x00	; 0
    2b44:	19 f0       	breq	.+6      	; 0x2b4c <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b46:	b7 01       	movw	r22, r14
    2b48:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b4c:	df 91       	pop	r29
    2b4e:	cf 91       	pop	r28
    2b50:	1f 91       	pop	r17
    2b52:	0f 91       	pop	r16
    2b54:	ff 90       	pop	r15
    2b56:	ef 90       	pop	r14
    2b58:	df 90       	pop	r13
    2b5a:	cf 90       	pop	r12
    2b5c:	08 95       	ret

00002b5e <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b5e:	0f 93       	push	r16
    2b60:	1f 93       	push	r17
    2b62:	cf 93       	push	r28
    2b64:	df 93       	push	r29
    2b66:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b68:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2b6c:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2b70:	00 97       	sbiw	r24, 0x00	; 0
    2b72:	19 f0       	breq	.+6      	; 0x2b7a <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b74:	be 01       	movw	r22, r28
    2b76:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b7a:	6a e0       	ldi	r22, 0x0A	; 10
    2b7c:	ce 01       	movw	r24, r28
    2b7e:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2b82:	8c 01       	movw	r16, r24
    2b84:	62 ec       	ldi	r22, 0xC2	; 194
    2b86:	74 e0       	ldi	r23, 0x04	; 4
    2b88:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2b8c:	6a e0       	ldi	r22, 0x0A	; 10
    2b8e:	c8 01       	movw	r24, r16
    2b90:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2b94:	8c 01       	movw	r16, r24
    2b96:	67 eb       	ldi	r22, 0xB7	; 183
    2b98:	74 e0       	ldi	r23, 0x04	; 4
    2b9a:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2b9e:	6a e0       	ldi	r22, 0x0A	; 10
    2ba0:	c8 01       	movw	r24, r16
    2ba2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2ba6:	8c 01       	movw	r16, r24
    2ba8:	61 eb       	ldi	r22, 0xB1	; 177
    2baa:	74 e0       	ldi	r23, 0x04	; 4
    2bac:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2bb0:	66 e0       	ldi	r22, 0x06	; 6
    2bb2:	c8 01       	movw	r24, r16
    2bb4:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2bb8:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <portStackTopForTask>
    2bbc:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    2bc0:	bc 01       	movw	r22, r24
    2bc2:	6f 5f       	subi	r22, 0xFF	; 255
    2bc4:	7f 4f       	sbci	r23, 0xFF	; 255
    2bc6:	01 e1       	ldi	r16, 0x11	; 17
    2bc8:	21 e0       	ldi	r18, 0x01	; 1
    2bca:	ae 01       	movw	r20, r28
    2bcc:	83 56       	subi	r24, 0x63	; 99
    2bce:	91 09       	sbc	r25, r1
    2bd0:	0e 94 63 18 	call	0x30c6	; 0x30c6 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2bd4:	df 91       	pop	r29
    2bd6:	cf 91       	pop	r28
    2bd8:	1f 91       	pop	r17
    2bda:	0f 91       	pop	r16
    2bdc:	08 95       	ret

00002bde <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2bde:	8f 92       	push	r8
    2be0:	9f 92       	push	r9
    2be2:	af 92       	push	r10
    2be4:	bf 92       	push	r11
    2be6:	cf 92       	push	r12
    2be8:	df 92       	push	r13
    2bea:	ef 92       	push	r14
    2bec:	ff 92       	push	r15
    2bee:	0f 93       	push	r16
    2bf0:	1f 93       	push	r17
    2bf2:	cf 93       	push	r28
    2bf4:	df 93       	push	r29
    2bf6:	ec 01       	movw	r28, r24
    2bf8:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2bfa:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfc:	9b 81       	ldd	r25, Y+3	; 0x03
    2bfe:	0e 94 6d 10 	call	0x20da	; 0x20da <pcTaskGetTaskName>
    2c02:	bc 01       	movw	r22, r24
    2c04:	c8 01       	movw	r24, r16
    2c06:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2c0a:	d8 01       	movw	r26, r16
    2c0c:	ed 91       	ld	r30, X+
    2c0e:	fc 91       	ld	r31, X
    2c10:	02 80       	ldd	r0, Z+2	; 0x02
    2c12:	f3 81       	ldd	r31, Z+3	; 0x03
    2c14:	e0 2d       	mov	r30, r0
    2c16:	69 e0       	ldi	r22, 0x09	; 9
    2c18:	c8 01       	movw	r24, r16
    2c1a:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c20:	0e 94 6d 10 	call	0x20da	; 0x20da <pcTaskGetTaskName>
    2c24:	fc 01       	movw	r30, r24
    2c26:	01 90       	ld	r0, Z+
    2c28:	00 20       	and	r0, r0
    2c2a:	e9 f7       	brne	.-6      	; 0x2c26 <_ZN8frt_task12print_statusER8emstream+0x48>
    2c2c:	31 97       	sbiw	r30, 0x01	; 1
    2c2e:	e8 1b       	sub	r30, r24
    2c30:	f9 0b       	sbc	r31, r25
    2c32:	38 97       	sbiw	r30, 0x08	; 8
    2c34:	48 f4       	brcc	.+18     	; 0x2c48 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2c36:	d8 01       	movw	r26, r16
    2c38:	ed 91       	ld	r30, X+
    2c3a:	fc 91       	ld	r31, X
    2c3c:	02 80       	ldd	r0, Z+2	; 0x02
    2c3e:	f3 81       	ldd	r31, Z+3	; 0x03
    2c40:	e0 2d       	mov	r30, r0
    2c42:	69 e0       	ldi	r22, 0x09	; 9
    2c44:	c8 01       	movw	r24, r16
    2c46:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c48:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c4a:	df 84       	ldd	r13, Y+15	; 0x0f
    2c4c:	e8 88       	ldd	r14, Y+16	; 0x10
    2c4e:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c50:	a8 84       	ldd	r10, Y+8	; 0x08
    2c52:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c54:	8a 81       	ldd	r24, Y+2	; 0x02
    2c56:	9b 81       	ldd	r25, Y+3	; 0x03
    2c58:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <uxTaskGetStackHighWaterMark>
    2c5c:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c5e:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c60:	8a 81       	ldd	r24, Y+2	; 0x02
    2c62:	9b 81       	ldd	r25, Y+3	; 0x03
    2c64:	0e 94 18 10 	call	0x2030	; 0x2030 <uxTaskPriorityGet>
    2c68:	68 2f       	mov	r22, r24
    2c6a:	c8 01       	movw	r24, r16
    2c6c:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
    2c70:	6a e0       	ldi	r22, 0x0A	; 10
    2c72:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2c76:	ec 01       	movw	r28, r24
    2c78:	67 e3       	ldi	r22, 0x37	; 55
    2c7a:	75 e0       	ldi	r23, 0x05	; 5
    2c7c:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c80:	68 2d       	mov	r22, r8
    2c82:	ce 01       	movw	r24, r28
    2c84:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c88:	6a e0       	ldi	r22, 0x0A	; 10
    2c8a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2c8e:	ec 01       	movw	r28, r24
    2c90:	65 e3       	ldi	r22, 0x35	; 53
    2c92:	75 e0       	ldi	r23, 0x05	; 5
    2c94:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2c98:	69 2d       	mov	r22, r9
    2c9a:	ce 01       	movw	r24, r28
    2c9c:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
    2ca0:	6a e0       	ldi	r22, 0x0A	; 10
    2ca2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2ca6:	ec 01       	movw	r28, r24
    2ca8:	63 e3       	ldi	r22, 0x33	; 51
    2caa:	75 e0       	ldi	r23, 0x05	; 5
    2cac:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2cb0:	b5 01       	movw	r22, r10
    2cb2:	ce 01       	movw	r24, r28
    2cb4:	0e 94 6f 1a 	call	0x34de	; 0x34de <_ZN8emstreamlsEj>
    2cb8:	6a e0       	ldi	r22, 0x0A	; 10
    2cba:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2cbe:	ec 01       	movw	r28, r24
    2cc0:	61 e3       	ldi	r22, 0x31	; 49
    2cc2:	75 e0       	ldi	r23, 0x05	; 5
    2cc4:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2cc8:	6a e0       	ldi	r22, 0x0A	; 10
    2cca:	ce 01       	movw	r24, r28
    2ccc:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2cd0:	ec 01       	movw	r28, r24
    2cd2:	6f e2       	ldi	r22, 0x2F	; 47
    2cd4:	75 e0       	ldi	r23, 0x05	; 5
    2cd6:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2cda:	b7 01       	movw	r22, r14
    2cdc:	a6 01       	movw	r20, r12
    2cde:	ce 01       	movw	r24, r28
    2ce0:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN8emstreamlsEm>
}
    2ce4:	df 91       	pop	r29
    2ce6:	cf 91       	pop	r28
    2ce8:	1f 91       	pop	r17
    2cea:	0f 91       	pop	r16
    2cec:	ff 90       	pop	r15
    2cee:	ef 90       	pop	r14
    2cf0:	df 90       	pop	r13
    2cf2:	cf 90       	pop	r12
    2cf4:	bf 90       	pop	r11
    2cf6:	af 90       	pop	r10
    2cf8:	9f 90       	pop	r9
    2cfa:	8f 90       	pop	r8
    2cfc:	08 95       	ret

00002cfe <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2cfe:	cf 93       	push	r28
    2d00:	df 93       	push	r29
    2d02:	ec 01       	movw	r28, r24
    2d04:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2d06:	db 01       	movw	r26, r22
    2d08:	ed 91       	ld	r30, X+
    2d0a:	fc 91       	ld	r31, X
    2d0c:	02 80       	ldd	r0, Z+2	; 0x02
    2d0e:	f3 81       	ldd	r31, Z+3	; 0x03
    2d10:	e0 2d       	mov	r30, r0
    2d12:	be 01       	movw	r22, r28
    2d14:	19 95       	eicall
	return (ser_dev);
}
    2d16:	ce 01       	movw	r24, r28
    2d18:	df 91       	pop	r29
    2d1a:	cf 91       	pop	r28
    2d1c:	08 95       	ret

00002d1e <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2d1e:	0f 93       	push	r16
    2d20:	1f 93       	push	r17
    2d22:	cf 93       	push	r28
    2d24:	df 93       	push	r29
    2d26:	ec 01       	movw	r28, r24
    2d28:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d2a:	bc 01       	movw	r22, r24
    2d2c:	c8 01       	movw	r24, r16
    2d2e:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <_ZlsR8emstreamR8frt_task>
    2d32:	66 e0       	ldi	r22, 0x06	; 6
    2d34:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d38:	8c 81       	ldd	r24, Y+4	; 0x04
    2d3a:	9d 81       	ldd	r25, Y+5	; 0x05
    2d3c:	00 97       	sbiw	r24, 0x00	; 0
    2d3e:	19 f0       	breq	.+6      	; 0x2d46 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d40:	b8 01       	movw	r22, r16
    2d42:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d46:	df 91       	pop	r29
    2d48:	cf 91       	pop	r28
    2d4a:	1f 91       	pop	r17
    2d4c:	0f 91       	pop	r16
    2d4e:	08 95       	ret

00002d50 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d50:	0f 93       	push	r16
    2d52:	1f 93       	push	r17
    2d54:	cf 93       	push	r28
    2d56:	df 93       	push	r29
    2d58:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d5a:	6a e0       	ldi	r22, 0x0A	; 10
    2d5c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2d60:	8c 01       	movw	r16, r24
    2d62:	64 e2       	ldi	r22, 0x24	; 36
    2d64:	75 e0       	ldi	r23, 0x05	; 5
    2d66:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d6a:	6a e0       	ldi	r22, 0x0A	; 10
    2d6c:	c8 01       	movw	r24, r16
    2d6e:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2d72:	8c 01       	movw	r16, r24
    2d74:	6d e1       	ldi	r22, 0x1D	; 29
    2d76:	75 e0       	ldi	r23, 0x05	; 5
    2d78:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d7c:	66 e0       	ldi	r22, 0x06	; 6
    2d7e:	c8 01       	movw	r24, r16
    2d80:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d84:	6a e0       	ldi	r22, 0x0A	; 10
    2d86:	ce 01       	movw	r24, r28
    2d88:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2d8c:	8c 01       	movw	r16, r24
    2d8e:	6c e0       	ldi	r22, 0x0C	; 12
    2d90:	75 e0       	ldi	r23, 0x05	; 5
    2d92:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2d96:	6a e0       	ldi	r22, 0x0A	; 10
    2d98:	c8 01       	movw	r24, r16
    2d9a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2d9e:	8c 01       	movw	r16, r24
    2da0:	60 e0       	ldi	r22, 0x00	; 0
    2da2:	75 e0       	ldi	r23, 0x05	; 5
    2da4:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2da8:	6a e0       	ldi	r22, 0x0A	; 10
    2daa:	c8 01       	movw	r24, r16
    2dac:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2db0:	8c 01       	movw	r16, r24
    2db2:	6a ef       	ldi	r22, 0xFA	; 250
    2db4:	74 e0       	ldi	r23, 0x04	; 4
    2db6:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2dba:	66 e0       	ldi	r22, 0x06	; 6
    2dbc:	c8 01       	movw	r24, r16
    2dbe:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2dc2:	6a e0       	ldi	r22, 0x0A	; 10
    2dc4:	ce 01       	movw	r24, r28
    2dc6:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2dca:	8c 01       	movw	r16, r24
    2dcc:	69 ee       	ldi	r22, 0xE9	; 233
    2dce:	74 e0       	ldi	r23, 0x04	; 4
    2dd0:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2dd4:	6a e0       	ldi	r22, 0x0A	; 10
    2dd6:	c8 01       	movw	r24, r16
    2dd8:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2ddc:	8c 01       	movw	r16, r24
    2dde:	6d ed       	ldi	r22, 0xDD	; 221
    2de0:	74 e0       	ldi	r23, 0x04	; 4
    2de2:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2de6:	6a e0       	ldi	r22, 0x0A	; 10
    2de8:	c8 01       	movw	r24, r16
    2dea:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2dee:	8c 01       	movw	r16, r24
    2df0:	67 ed       	ldi	r22, 0xD7	; 215
    2df2:	74 e0       	ldi	r23, 0x04	; 4
    2df4:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2df8:	66 e0       	ldi	r22, 0x06	; 6
    2dfa:	c8 01       	movw	r24, r16
    2dfc:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2e00:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2e04:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2e08:	00 97       	sbiw	r24, 0x00	; 0
    2e0a:	19 f0       	breq	.+6      	; 0x2e12 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2e0c:	be 01       	movw	r22, r28
    2e0e:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e12:	0e 94 75 10 	call	0x20ea	; 0x20ea <xTaskGetIdleTaskHandle>
    2e16:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <uxTaskGetStackHighWaterMark>
    2e1a:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2e1c:	6a e0       	ldi	r22, 0x0A	; 10
    2e1e:	ce 01       	movw	r24, r28
    2e20:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2e24:	ec 01       	movw	r28, r24
    2e26:	6c ec       	ldi	r22, 0xCC	; 204
    2e28:	74 e0       	ldi	r23, 0x04	; 4
    2e2a:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e2e:	61 2f       	mov	r22, r17
    2e30:	ce 01       	movw	r24, r28
    2e32:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2e36:	6a e0       	ldi	r22, 0x0A	; 10
    2e38:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2e3c:	ec 01       	movw	r28, r24
    2e3e:	6a ec       	ldi	r22, 0xCA	; 202
    2e40:	74 e0       	ldi	r23, 0x04	; 4
    2e42:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    2e46:	64 e6       	ldi	r22, 0x64	; 100
    2e48:	70 e0       	ldi	r23, 0x00	; 0
    2e4a:	ce 01       	movw	r24, r28
    2e4c:	0e 94 6f 1a 	call	0x34de	; 0x34de <_ZN8emstreamlsEj>
    2e50:	6a e0       	ldi	r22, 0x0A	; 10
    2e52:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    2e56:	ec 01       	movw	r28, r24
    2e58:	67 ec       	ldi	r22, 0xC7	; 199
    2e5a:	74 e0       	ldi	r23, 0x04	; 4
    2e5c:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e60:	66 e0       	ldi	r22, 0x06	; 6
    2e62:	ce 01       	movw	r24, r28
    2e64:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
}
    2e68:	df 91       	pop	r29
    2e6a:	cf 91       	pop	r28
    2e6c:	1f 91       	pop	r17
    2e6e:	0f 91       	pop	r16
    2e70:	08 95       	ret

00002e72 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e72:	0f 93       	push	r16
    2e74:	cf 93       	push	r28
    2e76:	df 93       	push	r29
    2e78:	1f 92       	push	r1
    2e7a:	cd b7       	in	r28, 0x3d	; 61
    2e7c:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e7e:	00 e0       	ldi	r16, 0x00	; 0
    2e80:	2f ef       	ldi	r18, 0xFF	; 255
    2e82:	3f ef       	ldi	r19, 0xFF	; 255
    2e84:	a9 01       	movw	r20, r18
    2e86:	be 01       	movw	r22, r28
    2e88:	6f 5f       	subi	r22, 0xFF	; 255
    2e8a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e8c:	fc 01       	movw	r30, r24
    2e8e:	80 85       	ldd	r24, Z+8	; 0x08
    2e90:	91 85       	ldd	r25, Z+9	; 0x09
    2e92:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <xQueueGenericReceive>
    2e96:	81 30       	cpi	r24, 0x01	; 1
    2e98:	19 f4       	brne	.+6      	; 0x2ea0 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e9a:	89 81       	ldd	r24, Y+1	; 0x01
    2e9c:	90 e0       	ldi	r25, 0x00	; 0
    2e9e:	02 c0       	rjmp	.+4      	; 0x2ea4 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2ea0:	8f ef       	ldi	r24, 0xFF	; 255
    2ea2:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2ea4:	0f 90       	pop	r0
    2ea6:	df 91       	pop	r29
    2ea8:	cf 91       	pop	r28
    2eaa:	0f 91       	pop	r16
    2eac:	08 95       	ret

00002eae <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2eae:	fc 01       	movw	r30, r24
    2eb0:	80 85       	ldd	r24, Z+8	; 0x08
    2eb2:	91 85       	ldd	r25, Z+9	; 0x09
    2eb4:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <uxQueueMessagesWaiting>
    2eb8:	91 e0       	ldi	r25, 0x01	; 1
    2eba:	81 11       	cpse	r24, r1
    2ebc:	01 c0       	rjmp	.+2      	; 0x2ec0 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2ebe:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2ec0:	89 2f       	mov	r24, r25
    2ec2:	08 95       	ret

00002ec4 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2ec4:	0f 93       	push	r16
    2ec6:	cf 93       	push	r28
    2ec8:	df 93       	push	r29
    2eca:	1f 92       	push	r1
    2ecc:	cd b7       	in	r28, 0x3d	; 61
    2ece:	de b7       	in	r29, 0x3e	; 62
    2ed0:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2ed2:	fc 01       	movw	r30, r24
    2ed4:	22 85       	ldd	r18, Z+10	; 0x0a
    2ed6:	33 85       	ldd	r19, Z+11	; 0x0b
    2ed8:	44 85       	ldd	r20, Z+12	; 0x0c
    2eda:	55 85       	ldd	r21, Z+13	; 0x0d
    2edc:	00 e0       	ldi	r16, 0x00	; 0
    2ede:	be 01       	movw	r22, r28
    2ee0:	6f 5f       	subi	r22, 0xFF	; 255
    2ee2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ee4:	80 85       	ldd	r24, Z+8	; 0x08
    2ee6:	91 85       	ldd	r25, Z+9	; 0x09
    2ee8:	0e 94 59 0d 	call	0x1ab2	; 0x1ab2 <xQueueGenericSend>
    2eec:	91 e0       	ldi	r25, 0x01	; 1
    2eee:	81 11       	cpse	r24, r1
    2ef0:	01 c0       	rjmp	.+2      	; 0x2ef4 <_ZN14frt_text_queue7putcharEc+0x30>
    2ef2:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2ef4:	89 2f       	mov	r24, r25
    2ef6:	0f 90       	pop	r0
    2ef8:	df 91       	pop	r29
    2efa:	cf 91       	pop	r28
    2efc:	0f 91       	pop	r16
    2efe:	08 95       	ret

00002f00 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2f00:	8f 92       	push	r8
    2f02:	9f 92       	push	r9
    2f04:	bf 92       	push	r11
    2f06:	cf 92       	push	r12
    2f08:	df 92       	push	r13
    2f0a:	ef 92       	push	r14
    2f0c:	ff 92       	push	r15
    2f0e:	0f 93       	push	r16
    2f10:	1f 93       	push	r17
    2f12:	cf 93       	push	r28
    2f14:	df 93       	push	r29
    2f16:	ec 01       	movw	r28, r24
    2f18:	b6 2e       	mov	r11, r22
    2f1a:	4a 01       	movw	r8, r20
    2f1c:	68 01       	movw	r12, r16
    2f1e:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f20:	0e 94 ba 19 	call	0x3374	; 0x3374 <_ZN8emstreamC1Ev>
    2f24:	87 e4       	ldi	r24, 0x47	; 71
    2f26:	90 e2       	ldi	r25, 0x20	; 32
    2f28:	88 83       	st	Y, r24
    2f2a:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f2c:	8e 86       	std	Y+14, r8	; 0x0e
    2f2e:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f30:	40 e0       	ldi	r20, 0x00	; 0
    2f32:	61 e0       	ldi	r22, 0x01	; 1
    2f34:	8b 2d       	mov	r24, r11
    2f36:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xQueueGenericCreate>
    2f3a:	88 87       	std	Y+8, r24	; 0x08
    2f3c:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f3e:	ca 86       	std	Y+10, r12	; 0x0a
    2f40:	db 86       	std	Y+11, r13	; 0x0b
    2f42:	ec 86       	std	Y+12, r14	; 0x0c
    2f44:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f46:	df 91       	pop	r29
    2f48:	cf 91       	pop	r28
    2f4a:	1f 91       	pop	r17
    2f4c:	0f 91       	pop	r16
    2f4e:	ff 90       	pop	r15
    2f50:	ef 90       	pop	r14
    2f52:	df 90       	pop	r13
    2f54:	cf 90       	pop	r12
    2f56:	bf 90       	pop	r11
    2f58:	9f 90       	pop	r9
    2f5a:	8f 90       	pop	r8
    2f5c:	08 95       	ret

00002f5e <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f5e:	cf 92       	push	r12
    2f60:	df 92       	push	r13
    2f62:	ef 92       	push	r14
    2f64:	ff 92       	push	r15
    2f66:	cf 93       	push	r28
    2f68:	df 93       	push	r29
    2f6a:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f6c:	68 81       	ld	r22, Y
    2f6e:	79 81       	ldd	r23, Y+1	; 0x01
    2f70:	8a 81       	ldd	r24, Y+2	; 0x02
    2f72:	9b 81       	ldd	r25, Y+3	; 0x03
    2f74:	0f 2e       	mov	r0, r31
    2f76:	f8 ee       	ldi	r31, 0xE8	; 232
    2f78:	cf 2e       	mov	r12, r31
    2f7a:	f3 e0       	ldi	r31, 0x03	; 3
    2f7c:	df 2e       	mov	r13, r31
    2f7e:	e1 2c       	mov	r14, r1
    2f80:	f1 2c       	mov	r15, r1
    2f82:	f0 2d       	mov	r31, r0
    2f84:	a7 01       	movw	r20, r14
    2f86:	96 01       	movw	r18, r12
    2f88:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <__udivmodsi4>
    2f8c:	9b 01       	movw	r18, r22
    2f8e:	ac 01       	movw	r20, r24
    2f90:	60 e4       	ldi	r22, 0x40	; 64
    2f92:	72 e4       	ldi	r23, 0x42	; 66
    2f94:	8f e0       	ldi	r24, 0x0F	; 15
    2f96:	90 e0       	ldi	r25, 0x00	; 0
    2f98:	0e 94 4c 1f 	call	0x3e98	; 0x3e98 <__mulsi3>
    2f9c:	a7 01       	movw	r20, r14
    2f9e:	96 01       	movw	r18, r12
    2fa0:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <__udivmodsi4>
    2fa4:	69 01       	movw	r12, r18
    2fa6:	7a 01       	movw	r14, r20
    2fa8:	ac 81       	ldd	r26, Y+4	; 0x04
    2faa:	bd 81       	ldd	r27, Y+5	; 0x05
    2fac:	20 e4       	ldi	r18, 0x40	; 64
    2fae:	32 e4       	ldi	r19, 0x42	; 66
    2fb0:	4f e0       	ldi	r20, 0x0F	; 15
    2fb2:	50 e0       	ldi	r21, 0x00	; 0
    2fb4:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <__muluhisi3>
    2fb8:	20 e0       	ldi	r18, 0x00	; 0
    2fba:	38 e4       	ldi	r19, 0x48	; 72
    2fbc:	48 ee       	ldi	r20, 0xE8	; 232
    2fbe:	51 e0       	ldi	r21, 0x01	; 1
    2fc0:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <__udivmodsi4>
    2fc4:	c7 01       	movw	r24, r14
    2fc6:	b6 01       	movw	r22, r12
    2fc8:	62 0f       	add	r22, r18
    2fca:	73 1f       	adc	r23, r19
    2fcc:	84 1f       	adc	r24, r20
    2fce:	95 1f       	adc	r25, r21
}
    2fd0:	df 91       	pop	r29
    2fd2:	cf 91       	pop	r28
    2fd4:	ff 90       	pop	r15
    2fd6:	ef 90       	pop	r14
    2fd8:	df 90       	pop	r13
    2fda:	cf 90       	pop	r12
    2fdc:	08 95       	ret

00002fde <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2fde:	cf 92       	push	r12
    2fe0:	df 92       	push	r13
    2fe2:	ef 92       	push	r14
    2fe4:	ff 92       	push	r15
    2fe6:	0f 93       	push	r16
    2fe8:	1f 93       	push	r17
    2fea:	cf 93       	push	r28
    2fec:	df 93       	push	r29
    2fee:	cd b7       	in	r28, 0x3d	; 61
    2ff0:	de b7       	in	r29, 0x3e	; 62
    2ff2:	2f 97       	sbiw	r28, 0x0f	; 15
    2ff4:	cd bf       	out	0x3d, r28	; 61
    2ff6:	de bf       	out	0x3e, r29	; 62
    2ff8:	6c 01       	movw	r12, r24
    2ffa:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2ffc:	db 01       	movw	r26, r22
    2ffe:	6d 91       	ld	r22, X+
    3000:	7d 91       	ld	r23, X+
    3002:	8d 91       	ld	r24, X+
    3004:	9c 91       	ld	r25, X
    3006:	28 ee       	ldi	r18, 0xE8	; 232
    3008:	33 e0       	ldi	r19, 0x03	; 3
    300a:	40 e0       	ldi	r20, 0x00	; 0
    300c:	50 e0       	ldi	r21, 0x00	; 0
    300e:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <__udivmodsi4>
    3012:	ba 01       	movw	r22, r20
    3014:	a9 01       	movw	r20, r18
    3016:	c6 01       	movw	r24, r12
    3018:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    301c:	d6 01       	movw	r26, r12
    301e:	ed 91       	ld	r30, X+
    3020:	fc 91       	ld	r31, X
    3022:	02 80       	ldd	r0, Z+2	; 0x02
    3024:	f3 81       	ldd	r31, Z+3	; 0x03
    3026:	e0 2d       	mov	r30, r0
    3028:	6e e2       	ldi	r22, 0x2E	; 46
    302a:	c6 01       	movw	r24, r12
    302c:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    302e:	c8 01       	movw	r24, r16
    3030:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN10time_stamp12get_microsecEv>
    3034:	8e 01       	movw	r16, r28
    3036:	09 5f       	subi	r16, 0xF9	; 249
    3038:	1f 4f       	sbci	r17, 0xFF	; 255
    303a:	fe 01       	movw	r30, r28
    303c:	31 96       	adiw	r30, 0x01	; 1
    303e:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3040:	2a e0       	ldi	r18, 0x0A	; 10
    3042:	30 e0       	ldi	r19, 0x00	; 0
    3044:	40 e0       	ldi	r20, 0x00	; 0
    3046:	50 e0       	ldi	r21, 0x00	; 0
    3048:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <__divmodsi4>
    304c:	e6 2f       	mov	r30, r22
    304e:	28 87       	std	Y+8, r18	; 0x08
    3050:	39 87       	std	Y+9, r19	; 0x09
    3052:	4a 87       	std	Y+10, r20	; 0x0a
    3054:	5b 87       	std	Y+11, r21	; 0x0b
    3056:	68 85       	ldd	r22, Y+8	; 0x08
    3058:	79 85       	ldd	r23, Y+9	; 0x09
    305a:	8a 85       	ldd	r24, Y+10	; 0x0a
    305c:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    305e:	20 e3       	ldi	r18, 0x30	; 48
    3060:	2e 0f       	add	r18, r30
    3062:	d8 01       	movw	r26, r16
    3064:	2e 93       	st	-X, r18
    3066:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3068:	ae 15       	cp	r26, r14
    306a:	bf 05       	cpc	r27, r15
    306c:	49 f7       	brne	.-46     	; 0x3040 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    306e:	1f 82       	std	Y+7, r1	; 0x07
    3070:	be 01       	movw	r22, r28
    3072:	6f 5f       	subi	r22, 0xFF	; 255
    3074:	7f 4f       	sbci	r23, 0xFF	; 255
    3076:	c6 01       	movw	r24, r12
    3078:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    307c:	c6 01       	movw	r24, r12
    307e:	2f 96       	adiw	r28, 0x0f	; 15
    3080:	cd bf       	out	0x3d, r28	; 61
    3082:	de bf       	out	0x3e, r29	; 62
    3084:	df 91       	pop	r29
    3086:	cf 91       	pop	r28
    3088:	1f 91       	pop	r17
    308a:	0f 91       	pop	r16
    308c:	ff 90       	pop	r15
    308e:	ef 90       	pop	r14
    3090:	df 90       	pop	r13
    3092:	cf 90       	pop	r12
    3094:	08 95       	ret

00003096 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3096:	cf 93       	push	r28
    3098:	df 93       	push	r29
    309a:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    309c:	0f b6       	in	r0, 0x3f	; 63
    309e:	f8 94       	cli
    30a0:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    30a2:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    30a6:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    30aa:	8c 83       	std	Y+4, r24	; 0x04
    30ac:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    30ae:	0e 94 5f 10 	call	0x20be	; 0x20be <xTaskGetTickCount>
    30b2:	68 83       	st	Y, r22
    30b4:	79 83       	std	Y+1, r23	; 0x01
    30b6:	8a 83       	std	Y+2, r24	; 0x02
    30b8:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    30ba:	0f 90       	pop	r0
    30bc:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    30be:	ce 01       	movw	r24, r28
    30c0:	df 91       	pop	r29
    30c2:	cf 91       	pop	r28
    30c4:	08 95       	ret

000030c6 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    30c6:	5f 92       	push	r5
    30c8:	6f 92       	push	r6
    30ca:	7f 92       	push	r7
    30cc:	8f 92       	push	r8
    30ce:	9f 92       	push	r9
    30d0:	af 92       	push	r10
    30d2:	bf 92       	push	r11
    30d4:	cf 92       	push	r12
    30d6:	df 92       	push	r13
    30d8:	ef 92       	push	r14
    30da:	ff 92       	push	r15
    30dc:	0f 93       	push	r16
    30de:	1f 93       	push	r17
    30e0:	cf 93       	push	r28
    30e2:	df 93       	push	r29
    30e4:	5c 01       	movw	r10, r24
    30e6:	4b 01       	movw	r8, r22
    30e8:	7a 01       	movw	r14, r20
    30ea:	12 2f       	mov	r17, r18
    30ec:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    30ee:	63 e0       	ldi	r22, 0x03	; 3
    30f0:	ca 01       	movw	r24, r20
    30f2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    30f6:	a8 14       	cp	r10, r8
    30f8:	b9 04       	cpc	r11, r9
    30fa:	08 f0       	brcs	.+2      	; 0x30fe <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    30fc:	7d c0       	rjmp	.+250    	; 0x31f8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30fe:	65 01       	movw	r12, r10
    3100:	84 e1       	ldi	r24, 0x14	; 20
    3102:	c8 0e       	add	r12, r24
    3104:	d1 1c       	adc	r13, r1
    3106:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3108:	6a 2c       	mov	r6, r10
    310a:	5b 2c       	mov	r5, r11
    310c:	b5 01       	movw	r22, r10
    310e:	c7 01       	movw	r24, r14
    3110:	0e 94 6f 1a 	call	0x34de	; 0x34de <_ZN8emstreamlsEj>
    3114:	6a e0       	ldi	r22, 0x0A	; 10
    3116:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    311a:	69 e4       	ldi	r22, 0x49	; 73
    311c:	75 e0       	ldi	r23, 0x05	; 5
    311e:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3122:	11 23       	and	r17, r17
    3124:	09 f4       	brne	.+2      	; 0x3128 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3126:	6d c0       	rjmp	.+218    	; 0x3202 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3128:	00 23       	and	r16, r16
    312a:	09 f4       	brne	.+2      	; 0x312e <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    312c:	6a c0       	rjmp	.+212    	; 0x3202 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    312e:	6a e0       	ldi	r22, 0x0A	; 10
    3130:	c7 01       	movw	r24, r14
    3132:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    3136:	64 e4       	ldi	r22, 0x44	; 68
    3138:	75 e0       	ldi	r23, 0x05	; 5
    313a:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    313e:	61 c0       	rjmp	.+194    	; 0x3202 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3140:	11 23       	and	r17, r17
    3142:	71 f0       	breq	.+28     	; 0x3160 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3144:	01 11       	cpse	r16, r1
    3146:	0c c0       	rjmp	.+24     	; 0x3160 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3148:	88 81       	ld	r24, Y
    314a:	87 15       	cp	r24, r7
    314c:	49 f0       	breq	.+18     	; 0x3160 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    314e:	6a e0       	ldi	r22, 0x0A	; 10
    3150:	c7 01       	movw	r24, r14
    3152:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    3156:	6f e3       	ldi	r22, 0x3F	; 63
    3158:	75 e0       	ldi	r23, 0x05	; 5
    315a:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    315e:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3160:	69 91       	ld	r22, Y+
    3162:	c7 01       	movw	r24, r14
    3164:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3168:	dc 01       	movw	r26, r24
    316a:	ed 91       	ld	r30, X+
    316c:	fc 91       	ld	r31, X
    316e:	02 80       	ldd	r0, Z+2	; 0x02
    3170:	f3 81       	ldd	r31, Z+3	; 0x03
    3172:	e0 2d       	mov	r30, r0
    3174:	60 e2       	ldi	r22, 0x20	; 32
    3176:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3178:	cc 16       	cp	r12, r28
    317a:	dd 06       	cpc	r13, r29
    317c:	09 f7       	brne	.-62     	; 0x3140 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    317e:	11 23       	and	r17, r17
    3180:	89 f0       	breq	.+34     	; 0x31a4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3182:	6a e0       	ldi	r22, 0x0A	; 10
    3184:	c7 01       	movw	r24, r14
    3186:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    318a:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    318c:	69 e3       	ldi	r22, 0x39	; 57
    318e:	75 e0       	ldi	r23, 0x05	; 5
    3190:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3194:	e8 81       	ld	r30, Y
    3196:	f9 81       	ldd	r31, Y+1	; 0x01
    3198:	02 80       	ldd	r0, Z+2	; 0x02
    319a:	f3 81       	ldd	r31, Z+3	; 0x03
    319c:	e0 2d       	mov	r30, r0
    319e:	60 e2       	ldi	r22, 0x20	; 32
    31a0:	ce 01       	movw	r24, r28
    31a2:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    31a4:	c6 2d       	mov	r28, r6
    31a6:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    31a8:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    31aa:	80 ee       	ldi	r24, 0xE0	; 224
    31ac:	86 0f       	add	r24, r22
    31ae:	8f 35       	cpi	r24, 0x5F	; 95
    31b0:	48 f4       	brcc	.+18     	; 0x31c4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    31b2:	d7 01       	movw	r26, r14
    31b4:	ed 91       	ld	r30, X+
    31b6:	fc 91       	ld	r31, X
    31b8:	02 80       	ldd	r0, Z+2	; 0x02
    31ba:	f3 81       	ldd	r31, Z+3	; 0x03
    31bc:	e0 2d       	mov	r30, r0
    31be:	c7 01       	movw	r24, r14
    31c0:	19 95       	eicall
    31c2:	09 c0       	rjmp	.+18     	; 0x31d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    31c4:	d7 01       	movw	r26, r14
    31c6:	ed 91       	ld	r30, X+
    31c8:	fc 91       	ld	r31, X
    31ca:	02 80       	ldd	r0, Z+2	; 0x02
    31cc:	f3 81       	ldd	r31, Z+3	; 0x03
    31ce:	e0 2d       	mov	r30, r0
    31d0:	6e e2       	ldi	r22, 0x2E	; 46
    31d2:	c7 01       	movw	r24, r14
    31d4:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    31d6:	cc 16       	cp	r12, r28
    31d8:	dd 06       	cpc	r13, r29
    31da:	31 f7       	brne	.-52     	; 0x31a8 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31dc:	b4 e1       	ldi	r27, 0x14	; 20
    31de:	ab 0e       	add	r10, r27
    31e0:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31e2:	66 e0       	ldi	r22, 0x06	; 6
    31e4:	c7 01       	movw	r24, r14
    31e6:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    31ea:	84 e1       	ldi	r24, 0x14	; 20
    31ec:	c8 0e       	add	r12, r24
    31ee:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31f0:	a8 14       	cp	r10, r8
    31f2:	b9 04       	cpc	r11, r9
    31f4:	08 f4       	brcc	.+2      	; 0x31f8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31f6:	88 cf       	rjmp	.-240    	; 0x3108 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    31f8:	62 e0       	ldi	r22, 0x02	; 2
    31fa:	c7 01       	movw	r24, r14
    31fc:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
}
    3200:	03 c0       	rjmp	.+6      	; 0x3208 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3202:	c6 2d       	mov	r28, r6
    3204:	d5 2d       	mov	r29, r5
    3206:	9c cf       	rjmp	.-200    	; 0x3140 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3208:	df 91       	pop	r29
    320a:	cf 91       	pop	r28
    320c:	1f 91       	pop	r17
    320e:	0f 91       	pop	r16
    3210:	ff 90       	pop	r15
    3212:	ef 90       	pop	r14
    3214:	df 90       	pop	r13
    3216:	cf 90       	pop	r12
    3218:	bf 90       	pop	r11
    321a:	af 90       	pop	r10
    321c:	9f 90       	pop	r9
    321e:	8f 90       	pop	r8
    3220:	7f 90       	pop	r7
    3222:	6f 90       	pop	r6
    3224:	5f 90       	pop	r5
    3226:	08 95       	ret

00003228 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3228:	0e 94 45 09 	call	0x128a	; 0x128a <pvPortMalloc>
    322c:	08 95       	ret

0000322e <_Znaj>:
    322e:	0e 94 45 09 	call	0x128a	; 0x128a <pvPortMalloc>
    3232:	08 95       	ret

00003234 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3234:	08 95       	ret

00003236 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3236:	cf 93       	push	r28
    3238:	df 93       	push	r29
    323a:	fc 01       	movw	r30, r24
    323c:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    323e:	40 3a       	cpi	r20, 0xA0	; 160
    3240:	68 e0       	ldi	r22, 0x08	; 8
    3242:	56 07       	cpc	r21, r22
    3244:	49 f4       	brne	.+18     	; 0x3258 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3246:	80 e4       	ldi	r24, 0x40	; 64
    3248:	96 e0       	ldi	r25, 0x06	; 6
    324a:	82 83       	std	Z+2, r24	; 0x02
    324c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    324e:	82 e0       	ldi	r24, 0x02	; 2
    3250:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3252:	83 e0       	ldi	r24, 0x03	; 3
    3254:	85 83       	std	Z+5, r24	; 0x05
    3256:	32 c0       	rjmp	.+100    	; 0x32bc <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3258:	40 3b       	cpi	r20, 0xB0	; 176
    325a:	78 e0       	ldi	r23, 0x08	; 8
    325c:	57 07       	cpc	r21, r23
    325e:	49 f4       	brne	.+18     	; 0x3272 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3260:	80 e4       	ldi	r24, 0x40	; 64
    3262:	96 e0       	ldi	r25, 0x06	; 6
    3264:	82 83       	std	Z+2, r24	; 0x02
    3266:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3268:	86 e0       	ldi	r24, 0x06	; 6
    326a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    326c:	87 e0       	ldi	r24, 0x07	; 7
    326e:	85 83       	std	Z+5, r24	; 0x05
    3270:	25 c0       	rjmp	.+74     	; 0x32bc <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3272:	40 3a       	cpi	r20, 0xA0	; 160
    3274:	89 e0       	ldi	r24, 0x09	; 9
    3276:	58 07       	cpc	r21, r24
    3278:	49 f4       	brne	.+18     	; 0x328c <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    327a:	80 e6       	ldi	r24, 0x60	; 96
    327c:	96 e0       	ldi	r25, 0x06	; 6
    327e:	82 83       	std	Z+2, r24	; 0x02
    3280:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3282:	82 e0       	ldi	r24, 0x02	; 2
    3284:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3286:	83 e0       	ldi	r24, 0x03	; 3
    3288:	85 83       	std	Z+5, r24	; 0x05
    328a:	18 c0       	rjmp	.+48     	; 0x32bc <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    328c:	40 3b       	cpi	r20, 0xB0	; 176
    328e:	69 e0       	ldi	r22, 0x09	; 9
    3290:	56 07       	cpc	r21, r22
    3292:	49 f4       	brne	.+18     	; 0x32a6 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3294:	80 e6       	ldi	r24, 0x60	; 96
    3296:	96 e0       	ldi	r25, 0x06	; 6
    3298:	82 83       	std	Z+2, r24	; 0x02
    329a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    329c:	86 e0       	ldi	r24, 0x06	; 6
    329e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32a0:	87 e0       	ldi	r24, 0x07	; 7
    32a2:	85 83       	std	Z+5, r24	; 0x05
    32a4:	0b c0       	rjmp	.+22     	; 0x32bc <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    32a6:	40 3a       	cpi	r20, 0xA0	; 160
    32a8:	5a 40       	sbci	r21, 0x0A	; 10
    32aa:	41 f4       	brne	.+16     	; 0x32bc <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    32ac:	80 e8       	ldi	r24, 0x80	; 128
    32ae:	96 e0       	ldi	r25, 0x06	; 6
    32b0:	82 83       	std	Z+2, r24	; 0x02
    32b2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32b4:	82 e0       	ldi	r24, 0x02	; 2
    32b6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32b8:	83 e0       	ldi	r24, 0x03	; 3
    32ba:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    32bc:	a6 83       	std	Z+6, r26	; 0x06
    32be:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    32c0:	cd 01       	movw	r24, r26
    32c2:	01 96       	adiw	r24, 0x01	; 1
    32c4:	80 87       	std	Z+8, r24	; 0x08
    32c6:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    32c8:	03 96       	adiw	r24, 0x03	; 3
    32ca:	82 87       	std	Z+10, r24	; 0x0a
    32cc:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    32ce:	25 81       	ldd	r18, Z+5	; 0x05
    32d0:	c2 81       	ldd	r28, Z+2	; 0x02
    32d2:	d3 81       	ldd	r29, Z+3	; 0x03
    32d4:	4c 81       	ldd	r20, Y+4	; 0x04
    32d6:	81 e0       	ldi	r24, 0x01	; 1
    32d8:	90 e0       	ldi	r25, 0x00	; 0
    32da:	bc 01       	movw	r22, r24
    32dc:	02 c0       	rjmp	.+4      	; 0x32e2 <_ZN7base232C1EjP12USART_struct+0xac>
    32de:	66 0f       	add	r22, r22
    32e0:	77 1f       	adc	r23, r23
    32e2:	2a 95       	dec	r18
    32e4:	e2 f7       	brpl	.-8      	; 0x32de <_ZN7base232C1EjP12USART_struct+0xa8>
    32e6:	9b 01       	movw	r18, r22
    32e8:	24 2b       	or	r18, r20
    32ea:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    32ec:	25 81       	ldd	r18, Z+5	; 0x05
    32ee:	c2 81       	ldd	r28, Z+2	; 0x02
    32f0:	d3 81       	ldd	r29, Z+3	; 0x03
    32f2:	48 81       	ld	r20, Y
    32f4:	bc 01       	movw	r22, r24
    32f6:	02 c0       	rjmp	.+4      	; 0x32fc <_ZN7base232C1EjP12USART_struct+0xc6>
    32f8:	66 0f       	add	r22, r22
    32fa:	77 1f       	adc	r23, r23
    32fc:	2a 95       	dec	r18
    32fe:	e2 f7       	brpl	.-8      	; 0x32f8 <_ZN7base232C1EjP12USART_struct+0xc2>
    3300:	9b 01       	movw	r18, r22
    3302:	24 2b       	or	r18, r20
    3304:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3306:	34 81       	ldd	r19, Z+4	; 0x04
    3308:	c2 81       	ldd	r28, Z+2	; 0x02
    330a:	d3 81       	ldd	r29, Z+3	; 0x03
    330c:	28 81       	ld	r18, Y
    330e:	02 c0       	rjmp	.+4      	; 0x3314 <_ZN7base232C1EjP12USART_struct+0xde>
    3310:	88 0f       	add	r24, r24
    3312:	99 1f       	adc	r25, r25
    3314:	3a 95       	dec	r19
    3316:	e2 f7       	brpl	.-8      	; 0x3310 <_ZN7base232C1EjP12USART_struct+0xda>
    3318:	80 95       	com	r24
    331a:	90 95       	com	r25
    331c:	82 23       	and	r24, r18
    331e:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3320:	80 e1       	ldi	r24, 0x10	; 16
    3322:	13 96       	adiw	r26, 0x03	; 3
    3324:	8c 93       	st	X, r24
    3326:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3328:	83 e0       	ldi	r24, 0x03	; 3
    332a:	15 96       	adiw	r26, 0x05	; 5
    332c:	8c 93       	st	X, r24
    332e:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3330:	80 ef       	ldi	r24, 0xF0	; 240
    3332:	17 96       	adiw	r26, 0x07	; 7
    3334:	8c 93       	st	X, r24
    3336:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3338:	81 e2       	ldi	r24, 0x21	; 33
    333a:	16 96       	adiw	r26, 0x06	; 6
    333c:	8c 93       	st	X, r24
    333e:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3340:	88 e1       	ldi	r24, 0x18	; 24
    3342:	14 96       	adiw	r26, 0x04	; 4
    3344:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3346:	80 e8       	ldi	r24, 0x80	; 128
    3348:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    334a:	80 e4       	ldi	r24, 0x40	; 64
    334c:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    334e:	80 e2       	ldi	r24, 0x20	; 32
    3350:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3352:	06 80       	ldd	r0, Z+6	; 0x06
    3354:	f7 81       	ldd	r31, Z+7	; 0x07
    3356:	e0 2d       	mov	r30, r0
    3358:	80 81       	ld	r24, Z
    335a:	80 81       	ld	r24, Z
}
    335c:	df 91       	pop	r29
    335e:	cf 91       	pop	r28
    3360:	08 95       	ret

00003362 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3362:	81 e0       	ldi	r24, 0x01	; 1
    3364:	08 95       	ret

00003366 <_ZN8emstream7getcharEv>:
    3366:	80 e0       	ldi	r24, 0x00	; 0
    3368:	90 e0       	ldi	r25, 0x00	; 0
    336a:	08 95       	ret

0000336c <_ZN8emstream14check_for_charEv>:
    336c:	80 e0       	ldi	r24, 0x00	; 0
    336e:	08 95       	ret

00003370 <_ZN8emstream12transmit_nowEv>:
    3370:	08 95       	ret

00003372 <_ZN8emstream12clear_screenEv>:
    3372:	08 95       	ret

00003374 <_ZN8emstreamC1Ev>:
    3374:	fc 01       	movw	r30, r24
    3376:	87 e5       	ldi	r24, 0x57	; 87
    3378:	90 e2       	ldi	r25, 0x20	; 32
    337a:	80 83       	st	Z, r24
    337c:	91 83       	std	Z+1, r25	; 0x01
    337e:	8a e0       	ldi	r24, 0x0A	; 10
    3380:	82 83       	std	Z+2, r24	; 0x02
    3382:	13 82       	std	Z+3, r1	; 0x03
    3384:	83 e0       	ldi	r24, 0x03	; 3
    3386:	85 83       	std	Z+5, r24	; 0x05
    3388:	14 82       	std	Z+4, r1	; 0x04
    338a:	16 82       	std	Z+6, r1	; 0x06
    338c:	17 82       	std	Z+7, r1	; 0x07
    338e:	08 95       	ret

00003390 <_ZN8emstream4putsEPKc>:
    3390:	0f 93       	push	r16
    3392:	1f 93       	push	r17
    3394:	cf 93       	push	r28
    3396:	df 93       	push	r29
    3398:	8c 01       	movw	r16, r24
    339a:	fb 01       	movw	r30, r22
    339c:	dc 01       	movw	r26, r24
    339e:	14 96       	adiw	r26, 0x04	; 4
    33a0:	8c 91       	ld	r24, X
    33a2:	81 11       	cpse	r24, r1
    33a4:	04 c0       	rjmp	.+8      	; 0x33ae <_ZN8emstream4putsEPKc+0x1e>
    33a6:	60 81       	ld	r22, Z
    33a8:	61 11       	cpse	r22, r1
    33aa:	17 c0       	rjmp	.+46     	; 0x33da <_ZN8emstream4putsEPKc+0x4a>
    33ac:	23 c0       	rjmp	.+70     	; 0x33f4 <_ZN8emstream4putsEPKc+0x64>
    33ae:	d8 01       	movw	r26, r16
    33b0:	14 96       	adiw	r26, 0x04	; 4
    33b2:	1c 92       	st	X, r1
    33b4:	eb 01       	movw	r28, r22
    33b6:	21 96       	adiw	r28, 0x01	; 1
    33b8:	64 91       	lpm	r22, Z
    33ba:	66 23       	and	r22, r22
    33bc:	d9 f0       	breq	.+54     	; 0x33f4 <_ZN8emstream4putsEPKc+0x64>
    33be:	d8 01       	movw	r26, r16
    33c0:	ed 91       	ld	r30, X+
    33c2:	fc 91       	ld	r31, X
    33c4:	02 80       	ldd	r0, Z+2	; 0x02
    33c6:	f3 81       	ldd	r31, Z+3	; 0x03
    33c8:	e0 2d       	mov	r30, r0
    33ca:	c8 01       	movw	r24, r16
    33cc:	19 95       	eicall
    33ce:	fe 01       	movw	r30, r28
    33d0:	64 91       	lpm	r22, Z
    33d2:	21 96       	adiw	r28, 0x01	; 1
    33d4:	61 11       	cpse	r22, r1
    33d6:	f3 cf       	rjmp	.-26     	; 0x33be <_ZN8emstream4putsEPKc+0x2e>
    33d8:	0d c0       	rjmp	.+26     	; 0x33f4 <_ZN8emstream4putsEPKc+0x64>
    33da:	ef 01       	movw	r28, r30
    33dc:	21 96       	adiw	r28, 0x01	; 1
    33de:	d8 01       	movw	r26, r16
    33e0:	ed 91       	ld	r30, X+
    33e2:	fc 91       	ld	r31, X
    33e4:	02 80       	ldd	r0, Z+2	; 0x02
    33e6:	f3 81       	ldd	r31, Z+3	; 0x03
    33e8:	e0 2d       	mov	r30, r0
    33ea:	c8 01       	movw	r24, r16
    33ec:	19 95       	eicall
    33ee:	69 91       	ld	r22, Y+
    33f0:	61 11       	cpse	r22, r1
    33f2:	f5 cf       	rjmp	.-22     	; 0x33de <_ZN8emstream4putsEPKc+0x4e>
    33f4:	df 91       	pop	r29
    33f6:	cf 91       	pop	r28
    33f8:	1f 91       	pop	r17
    33fa:	0f 91       	pop	r16
    33fc:	08 95       	ret

000033fe <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    33fe:	cf 93       	push	r28
    3400:	df 93       	push	r29
    3402:	ec 01       	movw	r28, r24
	switch (new_manip)
    3404:	86 2f       	mov	r24, r22
    3406:	90 e0       	ldi	r25, 0x00	; 0
    3408:	8b 30       	cpi	r24, 0x0B	; 11
    340a:	91 05       	cpc	r25, r1
    340c:	d8 f5       	brcc	.+118    	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
    340e:	fc 01       	movw	r30, r24
    3410:	88 27       	eor	r24, r24
    3412:	e2 50       	subi	r30, 0x02	; 2
    3414:	ff 4f       	sbci	r31, 0xFF	; 255
    3416:	8f 4f       	sbci	r24, 0xFF	; 255
    3418:	0c 94 b1 1f 	jmp	0x3f62	; 0x3f62 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    341c:	82 e0       	ldi	r24, 0x02	; 2
    341e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3420:	31 c0       	rjmp	.+98     	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3422:	88 e0       	ldi	r24, 0x08	; 8
    3424:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3426:	2e c0       	rjmp	.+92     	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3428:	8a e0       	ldi	r24, 0x0A	; 10
    342a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    342c:	2b c0       	rjmp	.+86     	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    342e:	80 e1       	ldi	r24, 0x10	; 16
    3430:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3432:	28 c0       	rjmp	.+80     	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3434:	81 e0       	ldi	r24, 0x01	; 1
    3436:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3438:	25 c0       	rjmp	.+74     	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    343a:	1b 82       	std	Y+3, r1	; 0x03
			break;
    343c:	23 c0       	rjmp	.+70     	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    343e:	e8 81       	ld	r30, Y
    3440:	f9 81       	ldd	r31, Y+1	; 0x01
    3442:	02 80       	ldd	r0, Z+2	; 0x02
    3444:	f3 81       	ldd	r31, Z+3	; 0x03
    3446:	e0 2d       	mov	r30, r0
    3448:	6d e0       	ldi	r22, 0x0D	; 13
    344a:	ce 01       	movw	r24, r28
    344c:	19 95       	eicall
    344e:	e8 81       	ld	r30, Y
    3450:	f9 81       	ldd	r31, Y+1	; 0x01
    3452:	02 80       	ldd	r0, Z+2	; 0x02
    3454:	f3 81       	ldd	r31, Z+3	; 0x03
    3456:	e0 2d       	mov	r30, r0
    3458:	6a e0       	ldi	r22, 0x0A	; 10
    345a:	ce 01       	movw	r24, r28
    345c:	19 95       	eicall
			break;
    345e:	12 c0       	rjmp	.+36     	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3460:	e8 81       	ld	r30, Y
    3462:	f9 81       	ldd	r31, Y+1	; 0x01
    3464:	02 84       	ldd	r0, Z+10	; 0x0a
    3466:	f3 85       	ldd	r31, Z+11	; 0x0b
    3468:	e0 2d       	mov	r30, r0
    346a:	ce 01       	movw	r24, r28
    346c:	19 95       	eicall
			break;
    346e:	0a c0       	rjmp	.+20     	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3470:	e8 81       	ld	r30, Y
    3472:	f9 81       	ldd	r31, Y+1	; 0x01
    3474:	00 84       	ldd	r0, Z+8	; 0x08
    3476:	f1 85       	ldd	r31, Z+9	; 0x09
    3478:	e0 2d       	mov	r30, r0
    347a:	ce 01       	movw	r24, r28
    347c:	19 95       	eicall
			break;
    347e:	02 c0       	rjmp	.+4      	; 0x3484 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3480:	81 e0       	ldi	r24, 0x01	; 1
    3482:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3484:	ce 01       	movw	r24, r28
    3486:	df 91       	pop	r29
    3488:	cf 91       	pop	r28
    348a:	08 95       	ret

0000348c <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    348c:	0f 93       	push	r16
    348e:	1f 93       	push	r17
    3490:	cf 93       	push	r28
    3492:	df 93       	push	r29
    3494:	cd b7       	in	r28, 0x3d	; 61
    3496:	de b7       	in	r29, 0x3e	; 62
    3498:	61 97       	sbiw	r28, 0x11	; 17
    349a:	cd bf       	out	0x3d, r28	; 61
    349c:	de bf       	out	0x3e, r29	; 62
    349e:	8c 01       	movw	r16, r24
    34a0:	9b 01       	movw	r18, r22
	if (base != 10)
    34a2:	fc 01       	movw	r30, r24
    34a4:	92 81       	ldd	r25, Z+2	; 0x02
    34a6:	9a 30       	cpi	r25, 0x0A	; 10
    34a8:	21 f0       	breq	.+8      	; 0x34b2 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    34aa:	c8 01       	movw	r24, r16
    34ac:	0e 94 6f 1a 	call	0x34de	; 0x34de <_ZN8emstreamlsEj>
    34b0:	0d c0       	rjmp	.+26     	; 0x34cc <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    34b2:	4a e0       	ldi	r20, 0x0A	; 10
    34b4:	be 01       	movw	r22, r28
    34b6:	6f 5f       	subi	r22, 0xFF	; 255
    34b8:	7f 4f       	sbci	r23, 0xFF	; 255
    34ba:	c9 01       	movw	r24, r18
    34bc:	0e 94 1e 20 	call	0x403c	; 0x403c <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    34c0:	be 01       	movw	r22, r28
    34c2:	6f 5f       	subi	r22, 0xFF	; 255
    34c4:	7f 4f       	sbci	r23, 0xFF	; 255
    34c6:	c8 01       	movw	r24, r16
    34c8:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    34cc:	c8 01       	movw	r24, r16
    34ce:	61 96       	adiw	r28, 0x11	; 17
    34d0:	cd bf       	out	0x3d, r28	; 61
    34d2:	de bf       	out	0x3e, r29	; 62
    34d4:	df 91       	pop	r29
    34d6:	cf 91       	pop	r28
    34d8:	1f 91       	pop	r17
    34da:	0f 91       	pop	r16
    34dc:	08 95       	ret

000034de <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    34de:	ff 92       	push	r15
    34e0:	0f 93       	push	r16
    34e2:	1f 93       	push	r17
    34e4:	cf 93       	push	r28
    34e6:	df 93       	push	r29
    34e8:	cd b7       	in	r28, 0x3d	; 61
    34ea:	de b7       	in	r29, 0x3e	; 62
    34ec:	61 97       	sbiw	r28, 0x11	; 17
    34ee:	cd bf       	out	0x3d, r28	; 61
    34f0:	de bf       	out	0x3e, r29	; 62
    34f2:	8c 01       	movw	r16, r24
    34f4:	f6 2e       	mov	r15, r22
    34f6:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    34f8:	f8 01       	movw	r30, r16
    34fa:	42 81       	ldd	r20, Z+2	; 0x02
    34fc:	40 31       	cpi	r20, 0x10	; 16
    34fe:	21 f0       	breq	.+8      	; 0x3508 <_ZN8emstreamlsEj+0x2a>
    3500:	48 30       	cpi	r20, 0x08	; 8
    3502:	11 f0       	breq	.+4      	; 0x3508 <_ZN8emstreamlsEj+0x2a>
    3504:	42 30       	cpi	r20, 0x02	; 2
    3506:	41 f4       	brne	.+16     	; 0x3518 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3508:	69 2f       	mov	r22, r25
    350a:	c8 01       	movw	r24, r16
    350c:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
    3510:	6f 2d       	mov	r22, r15
    3512:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
    3516:	0d c0       	rjmp	.+26     	; 0x3532 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3518:	50 e0       	ldi	r21, 0x00	; 0
    351a:	be 01       	movw	r22, r28
    351c:	6f 5f       	subi	r22, 0xFF	; 255
    351e:	7f 4f       	sbci	r23, 0xFF	; 255
    3520:	8f 2d       	mov	r24, r15
    3522:	0e 94 56 20 	call	0x40ac	; 0x40ac <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3526:	be 01       	movw	r22, r28
    3528:	6f 5f       	subi	r22, 0xFF	; 255
    352a:	7f 4f       	sbci	r23, 0xFF	; 255
    352c:	c8 01       	movw	r24, r16
    352e:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3532:	c8 01       	movw	r24, r16
    3534:	61 96       	adiw	r28, 0x11	; 17
    3536:	cd bf       	out	0x3d, r28	; 61
    3538:	de bf       	out	0x3e, r29	; 62
    353a:	df 91       	pop	r29
    353c:	cf 91       	pop	r28
    353e:	1f 91       	pop	r17
    3540:	0f 91       	pop	r16
    3542:	ff 90       	pop	r15
    3544:	08 95       	ret

00003546 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3546:	df 92       	push	r13
    3548:	ef 92       	push	r14
    354a:	ff 92       	push	r15
    354c:	0f 93       	push	r16
    354e:	1f 93       	push	r17
    3550:	cf 93       	push	r28
    3552:	df 93       	push	r29
    3554:	cd b7       	in	r28, 0x3d	; 61
    3556:	de b7       	in	r29, 0x3e	; 62
    3558:	a1 97       	sbiw	r28, 0x21	; 33
    355a:	cd bf       	out	0x3d, r28	; 61
    355c:	de bf       	out	0x3e, r29	; 62
    355e:	8c 01       	movw	r16, r24
    3560:	d4 2e       	mov	r13, r20
    3562:	e5 2e       	mov	r14, r21
    3564:	f6 2e       	mov	r15, r22
    3566:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3568:	f8 01       	movw	r30, r16
    356a:	22 81       	ldd	r18, Z+2	; 0x02
    356c:	20 31       	cpi	r18, 0x10	; 16
    356e:	21 f0       	breq	.+8      	; 0x3578 <_ZN8emstreamlsEm+0x32>
    3570:	28 30       	cpi	r18, 0x08	; 8
    3572:	11 f0       	breq	.+4      	; 0x3578 <_ZN8emstreamlsEm+0x32>
    3574:	22 30       	cpi	r18, 0x02	; 2
    3576:	71 f4       	brne	.+28     	; 0x3594 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3578:	69 2f       	mov	r22, r25
    357a:	c8 01       	movw	r24, r16
    357c:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
    3580:	6f 2d       	mov	r22, r15
    3582:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
    3586:	6e 2d       	mov	r22, r14
    3588:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
    358c:	6d 2d       	mov	r22, r13
    358e:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <_ZN8emstreamlsEh>
    3592:	0f c0       	rjmp	.+30     	; 0x35b2 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3594:	30 e0       	ldi	r19, 0x00	; 0
    3596:	ae 01       	movw	r20, r28
    3598:	4f 5f       	subi	r20, 0xFF	; 255
    359a:	5f 4f       	sbci	r21, 0xFF	; 255
    359c:	6d 2d       	mov	r22, r13
    359e:	7e 2d       	mov	r23, r14
    35a0:	8f 2d       	mov	r24, r15
    35a2:	0e 94 29 20 	call	0x4052	; 0x4052 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    35a6:	be 01       	movw	r22, r28
    35a8:	6f 5f       	subi	r22, 0xFF	; 255
    35aa:	7f 4f       	sbci	r23, 0xFF	; 255
    35ac:	c8 01       	movw	r24, r16
    35ae:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35b2:	c8 01       	movw	r24, r16
    35b4:	a1 96       	adiw	r28, 0x21	; 33
    35b6:	cd bf       	out	0x3d, r28	; 61
    35b8:	de bf       	out	0x3e, r29	; 62
    35ba:	df 91       	pop	r29
    35bc:	cf 91       	pop	r28
    35be:	1f 91       	pop	r17
    35c0:	0f 91       	pop	r16
    35c2:	ff 90       	pop	r15
    35c4:	ef 90       	pop	r14
    35c6:	df 90       	pop	r13
    35c8:	08 95       	ret

000035ca <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    35ca:	cf 92       	push	r12
    35cc:	df 92       	push	r13
    35ce:	ef 92       	push	r14
    35d0:	ff 92       	push	r15
    35d2:	0f 93       	push	r16
    35d4:	1f 93       	push	r17
    35d6:	cf 93       	push	r28
    35d8:	df 93       	push	r29
    35da:	cd b7       	in	r28, 0x3d	; 61
    35dc:	de b7       	in	r29, 0x3e	; 62
    35de:	29 97       	sbiw	r28, 0x09	; 9
    35e0:	cd bf       	out	0x3d, r28	; 61
    35e2:	de bf       	out	0x3e, r29	; 62
    35e4:	8c 01       	movw	r16, r24
    35e6:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    35e8:	dc 01       	movw	r26, r24
    35ea:	13 96       	adiw	r26, 0x03	; 3
    35ec:	8c 91       	ld	r24, X
    35ee:	13 97       	sbiw	r26, 0x03	; 3
    35f0:	88 23       	and	r24, r24
    35f2:	41 f0       	breq	.+16     	; 0x3604 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    35f4:	ed 91       	ld	r30, X+
    35f6:	fc 91       	ld	r31, X
    35f8:	02 80       	ldd	r0, Z+2	; 0x02
    35fa:	f3 81       	ldd	r31, Z+3	; 0x03
    35fc:	e0 2d       	mov	r30, r0
    35fe:	c8 01       	movw	r24, r16
    3600:	19 95       	eicall
    3602:	56 c0       	rjmp	.+172    	; 0x36b0 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3604:	f8 01       	movw	r30, r16
    3606:	42 81       	ldd	r20, Z+2	; 0x02
    3608:	42 30       	cpi	r20, 0x02	; 2
    360a:	19 f5       	brne	.+70     	; 0x3652 <_ZN8emstreamlsEh+0x88>
    360c:	68 94       	set
    360e:	cc 24       	eor	r12, r12
    3610:	c3 f8       	bld	r12, 3
    3612:	d1 2c       	mov	r13, r1
    3614:	68 94       	set
    3616:	ff 24       	eor	r15, r15
    3618:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    361a:	8e 2d       	mov	r24, r14
    361c:	8f 21       	and	r24, r15
    361e:	51 f0       	breq	.+20     	; 0x3634 <_ZN8emstreamlsEh+0x6a>
    3620:	d8 01       	movw	r26, r16
    3622:	ed 91       	ld	r30, X+
    3624:	fc 91       	ld	r31, X
    3626:	02 80       	ldd	r0, Z+2	; 0x02
    3628:	f3 81       	ldd	r31, Z+3	; 0x03
    362a:	e0 2d       	mov	r30, r0
    362c:	61 e3       	ldi	r22, 0x31	; 49
    362e:	c8 01       	movw	r24, r16
    3630:	19 95       	eicall
    3632:	09 c0       	rjmp	.+18     	; 0x3646 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3634:	d8 01       	movw	r26, r16
    3636:	ed 91       	ld	r30, X+
    3638:	fc 91       	ld	r31, X
    363a:	02 80       	ldd	r0, Z+2	; 0x02
    363c:	f3 81       	ldd	r31, Z+3	; 0x03
    363e:	e0 2d       	mov	r30, r0
    3640:	60 e3       	ldi	r22, 0x30	; 48
    3642:	c8 01       	movw	r24, r16
    3644:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3646:	f6 94       	lsr	r15
    3648:	b1 e0       	ldi	r27, 0x01	; 1
    364a:	cb 1a       	sub	r12, r27
    364c:	d1 08       	sbc	r13, r1
    364e:	29 f7       	brne	.-54     	; 0x361a <_ZN8emstreamlsEh+0x50>
    3650:	2f c0       	rjmp	.+94     	; 0x36b0 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3652:	40 31       	cpi	r20, 0x10	; 16
    3654:	f9 f4       	brne	.+62     	; 0x3694 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3656:	62 95       	swap	r22
    3658:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    365a:	01 90       	ld	r0, Z+
    365c:	f0 81       	ld	r31, Z
    365e:	e0 2d       	mov	r30, r0
    3660:	02 80       	ldd	r0, Z+2	; 0x02
    3662:	f3 81       	ldd	r31, Z+3	; 0x03
    3664:	e0 2d       	mov	r30, r0
    3666:	6a 30       	cpi	r22, 0x0A	; 10
    3668:	10 f0       	brcs	.+4      	; 0x366e <_ZN8emstreamlsEh+0xa4>
    366a:	69 5c       	subi	r22, 0xC9	; 201
    366c:	01 c0       	rjmp	.+2      	; 0x3670 <_ZN8emstreamlsEh+0xa6>
    366e:	60 5d       	subi	r22, 0xD0	; 208
    3670:	c8 01       	movw	r24, r16
    3672:	19 95       	eicall
		temp_char = num & 0x0F;
    3674:	6e 2d       	mov	r22, r14
    3676:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3678:	d8 01       	movw	r26, r16
    367a:	ed 91       	ld	r30, X+
    367c:	fc 91       	ld	r31, X
    367e:	02 80       	ldd	r0, Z+2	; 0x02
    3680:	f3 81       	ldd	r31, Z+3	; 0x03
    3682:	e0 2d       	mov	r30, r0
    3684:	6a 30       	cpi	r22, 0x0A	; 10
    3686:	10 f0       	brcs	.+4      	; 0x368c <_ZN8emstreamlsEh+0xc2>
    3688:	69 5c       	subi	r22, 0xC9	; 201
    368a:	01 c0       	rjmp	.+2      	; 0x368e <_ZN8emstreamlsEh+0xc4>
    368c:	60 5d       	subi	r22, 0xD0	; 208
    368e:	c8 01       	movw	r24, r16
    3690:	19 95       	eicall
    3692:	0e c0       	rjmp	.+28     	; 0x36b0 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3694:	50 e0       	ldi	r21, 0x00	; 0
    3696:	be 01       	movw	r22, r28
    3698:	6f 5f       	subi	r22, 0xFF	; 255
    369a:	7f 4f       	sbci	r23, 0xFF	; 255
    369c:	8e 2d       	mov	r24, r14
    369e:	90 e0       	ldi	r25, 0x00	; 0
    36a0:	0e 94 56 20 	call	0x40ac	; 0x40ac <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    36a4:	be 01       	movw	r22, r28
    36a6:	6f 5f       	subi	r22, 0xFF	; 255
    36a8:	7f 4f       	sbci	r23, 0xFF	; 255
    36aa:	c8 01       	movw	r24, r16
    36ac:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    36b0:	c8 01       	movw	r24, r16
    36b2:	29 96       	adiw	r28, 0x09	; 9
    36b4:	cd bf       	out	0x3d, r28	; 61
    36b6:	de bf       	out	0x3e, r29	; 62
    36b8:	df 91       	pop	r29
    36ba:	cf 91       	pop	r28
    36bc:	1f 91       	pop	r17
    36be:	0f 91       	pop	r16
    36c0:	ff 90       	pop	r15
    36c2:	ef 90       	pop	r14
    36c4:	df 90       	pop	r13
    36c6:	cf 90       	pop	r12
    36c8:	08 95       	ret

000036ca <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    36ca:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36cc:	50 96       	adiw	r26, 0x10	; 16
    36ce:	ed 91       	ld	r30, X+
    36d0:	fc 91       	ld	r31, X
    36d2:	51 97       	sbiw	r26, 0x11	; 17
    36d4:	80 81       	ld	r24, Z
    36d6:	54 96       	adiw	r26, 0x14	; 20
    36d8:	4c 91       	ld	r20, X
    36da:	54 97       	sbiw	r26, 0x14	; 20
    36dc:	84 23       	and	r24, r20
    36de:	29 f0       	breq	.+10     	; 0x36ea <_ZN5rs2327putcharEc+0x20>
    36e0:	09 c0       	rjmp	.+18     	; 0x36f4 <_ZN5rs2327putcharEc+0x2a>
    36e2:	21 50       	subi	r18, 0x01	; 1
    36e4:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    36e6:	19 f4       	brne	.+6      	; 0x36ee <_ZN5rs2327putcharEc+0x24>
    36e8:	12 c0       	rjmp	.+36     	; 0x370e <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36ea:	21 e2       	ldi	r18, 0x21	; 33
    36ec:	3e e4       	ldi	r19, 0x4E	; 78
    36ee:	90 81       	ld	r25, Z
    36f0:	94 23       	and	r25, r20
    36f2:	b9 f3       	breq	.-18     	; 0x36e2 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    36f4:	90 81       	ld	r25, Z
    36f6:	56 96       	adiw	r26, 0x16	; 22
    36f8:	8c 91       	ld	r24, X
    36fa:	56 97       	sbiw	r26, 0x16	; 22
    36fc:	89 2b       	or	r24, r25
    36fe:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3700:	1e 96       	adiw	r26, 0x0e	; 14
    3702:	ed 91       	ld	r30, X+
    3704:	fc 91       	ld	r31, X
    3706:	1f 97       	sbiw	r26, 0x0f	; 15
    3708:	60 83       	st	Z, r22
	return (true);
    370a:	81 e0       	ldi	r24, 0x01	; 1
    370c:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    370e:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3710:	08 95       	ret

00003712 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3712:	cf 93       	push	r28
    3714:	df 93       	push	r29
    3716:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3718:	c1 8d       	ldd	r28, Z+25	; 0x19
    371a:	d2 8d       	ldd	r29, Z+26	; 0x1a
    371c:	28 81       	ld	r18, Y
    371e:	39 81       	ldd	r19, Y+1	; 0x01
    3720:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3722:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3724:	4d 91       	ld	r20, X+
    3726:	5c 91       	ld	r21, X
    3728:	24 17       	cp	r18, r20
    372a:	35 07       	cpc	r19, r21
    372c:	e9 f3       	breq	.-6      	; 0x3728 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    372e:	a7 89       	ldd	r26, Z+23	; 0x17
    3730:	b0 8d       	ldd	r27, Z+24	; 0x18
    3732:	0d 90       	ld	r0, X+
    3734:	bc 91       	ld	r27, X
    3736:	a0 2d       	mov	r26, r0
    3738:	a2 0f       	add	r26, r18
    373a:	b3 1f       	adc	r27, r19
    373c:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    373e:	2f 5f       	subi	r18, 0xFF	; 255
    3740:	3f 4f       	sbci	r19, 0xFF	; 255
    3742:	28 83       	st	Y, r18
    3744:	39 83       	std	Y+1, r19	; 0x01
    3746:	24 36       	cpi	r18, 0x64	; 100
    3748:	31 05       	cpc	r19, r1
    374a:	28 f0       	brcs	.+10     	; 0x3756 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    374c:	01 8c       	ldd	r0, Z+25	; 0x19
    374e:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3750:	e0 2d       	mov	r30, r0
    3752:	10 82       	st	Z, r1
    3754:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3756:	90 e0       	ldi	r25, 0x00	; 0
    3758:	df 91       	pop	r29
    375a:	cf 91       	pop	r28
    375c:	08 95       	ret

0000375e <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    375e:	cf 93       	push	r28
    3760:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3762:	ec 01       	movw	r28, r24
    3764:	a9 8d       	ldd	r26, Y+25	; 0x19
    3766:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3768:	eb 8d       	ldd	r30, Y+27	; 0x1b
    376a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    376c:	81 e0       	ldi	r24, 0x01	; 1
    376e:	4d 91       	ld	r20, X+
    3770:	5c 91       	ld	r21, X
    3772:	20 81       	ld	r18, Z
    3774:	31 81       	ldd	r19, Z+1	; 0x01
    3776:	42 17       	cp	r20, r18
    3778:	53 07       	cpc	r21, r19
    377a:	09 f4       	brne	.+2      	; 0x377e <_ZN5rs23214check_for_charEv+0x20>
    377c:	80 e0       	ldi	r24, 0x00	; 0
}
    377e:	df 91       	pop	r29
    3780:	cf 91       	pop	r28
    3782:	08 95       	ret

00003784 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3784:	dc 01       	movw	r26, r24
    3786:	ed 91       	ld	r30, X+
    3788:	fc 91       	ld	r31, X
    378a:	02 80       	ldd	r0, Z+2	; 0x02
    378c:	f3 81       	ldd	r31, Z+3	; 0x03
    378e:	e0 2d       	mov	r30, r0
    3790:	6c e0       	ldi	r22, 0x0C	; 12
    3792:	19 95       	eicall
    3794:	08 95       	ret

00003796 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3796:	ef 92       	push	r14
    3798:	ff 92       	push	r15
    379a:	0f 93       	push	r16
    379c:	1f 93       	push	r17
    379e:	cf 93       	push	r28
    37a0:	df 93       	push	r29
    37a2:	ec 01       	movw	r28, r24
    37a4:	7b 01       	movw	r14, r22
    37a6:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    37a8:	0e 94 ba 19 	call	0x3374	; 0x3374 <_ZN8emstreamC1Ev>
    37ac:	a8 01       	movw	r20, r16
    37ae:	b7 01       	movw	r22, r14
    37b0:	ce 01       	movw	r24, r28
    37b2:	08 96       	adiw	r24, 0x08	; 8
    37b4:	0e 94 1b 19 	call	0x3236	; 0x3236 <_ZN7base232C1EjP12USART_struct>
    37b8:	87 e6       	ldi	r24, 0x67	; 103
    37ba:	90 e2       	ldi	r25, 0x20	; 32
    37bc:	88 83       	st	Y, r24
    37be:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    37c0:	00 3a       	cpi	r16, 0xA0	; 160
    37c2:	88 e0       	ldi	r24, 0x08	; 8
    37c4:	18 07       	cpc	r17, r24
    37c6:	69 f4       	brne	.+26     	; 0x37e2 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    37c8:	84 e4       	ldi	r24, 0x44	; 68
    37ca:	91 e3       	ldi	r25, 0x31	; 49
    37cc:	8f 8b       	std	Y+23, r24	; 0x17
    37ce:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    37d0:	8a e3       	ldi	r24, 0x3A	; 58
    37d2:	91 e3       	ldi	r25, 0x31	; 49
    37d4:	89 8f       	std	Y+25, r24	; 0x19
    37d6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    37d8:	80 e3       	ldi	r24, 0x30	; 48
    37da:	91 e3       	ldi	r25, 0x31	; 49
    37dc:	8b 8f       	std	Y+27, r24	; 0x1b
    37de:	9c 8f       	std	Y+28, r25	; 0x1c
    37e0:	42 c0       	rjmp	.+132    	; 0x3866 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    37e2:	00 3b       	cpi	r16, 0xB0	; 176
    37e4:	e8 e0       	ldi	r30, 0x08	; 8
    37e6:	1e 07       	cpc	r17, r30
    37e8:	69 f4       	brne	.+26     	; 0x3804 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    37ea:	82 e4       	ldi	r24, 0x42	; 66
    37ec:	91 e3       	ldi	r25, 0x31	; 49
    37ee:	8f 8b       	std	Y+23, r24	; 0x17
    37f0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    37f2:	88 e3       	ldi	r24, 0x38	; 56
    37f4:	91 e3       	ldi	r25, 0x31	; 49
    37f6:	89 8f       	std	Y+25, r24	; 0x19
    37f8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    37fa:	8e e2       	ldi	r24, 0x2E	; 46
    37fc:	91 e3       	ldi	r25, 0x31	; 49
    37fe:	8b 8f       	std	Y+27, r24	; 0x1b
    3800:	9c 8f       	std	Y+28, r25	; 0x1c
    3802:	31 c0       	rjmp	.+98     	; 0x3866 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3804:	00 3a       	cpi	r16, 0xA0	; 160
    3806:	f9 e0       	ldi	r31, 0x09	; 9
    3808:	1f 07       	cpc	r17, r31
    380a:	69 f4       	brne	.+26     	; 0x3826 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    380c:	80 e4       	ldi	r24, 0x40	; 64
    380e:	91 e3       	ldi	r25, 0x31	; 49
    3810:	8f 8b       	std	Y+23, r24	; 0x17
    3812:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3814:	86 e3       	ldi	r24, 0x36	; 54
    3816:	91 e3       	ldi	r25, 0x31	; 49
    3818:	89 8f       	std	Y+25, r24	; 0x19
    381a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    381c:	8c e2       	ldi	r24, 0x2C	; 44
    381e:	91 e3       	ldi	r25, 0x31	; 49
    3820:	8b 8f       	std	Y+27, r24	; 0x1b
    3822:	9c 8f       	std	Y+28, r25	; 0x1c
    3824:	20 c0       	rjmp	.+64     	; 0x3866 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3826:	00 3b       	cpi	r16, 0xB0	; 176
    3828:	89 e0       	ldi	r24, 0x09	; 9
    382a:	18 07       	cpc	r17, r24
    382c:	69 f4       	brne	.+26     	; 0x3848 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    382e:	8e e3       	ldi	r24, 0x3E	; 62
    3830:	91 e3       	ldi	r25, 0x31	; 49
    3832:	8f 8b       	std	Y+23, r24	; 0x17
    3834:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3836:	84 e3       	ldi	r24, 0x34	; 52
    3838:	91 e3       	ldi	r25, 0x31	; 49
    383a:	89 8f       	std	Y+25, r24	; 0x19
    383c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    383e:	8a e2       	ldi	r24, 0x2A	; 42
    3840:	91 e3       	ldi	r25, 0x31	; 49
    3842:	8b 8f       	std	Y+27, r24	; 0x1b
    3844:	9c 8f       	std	Y+28, r25	; 0x1c
    3846:	0f c0       	rjmp	.+30     	; 0x3866 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3848:	00 3a       	cpi	r16, 0xA0	; 160
    384a:	1a 40       	sbci	r17, 0x0A	; 10
    384c:	61 f4       	brne	.+24     	; 0x3866 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    384e:	8c e3       	ldi	r24, 0x3C	; 60
    3850:	91 e3       	ldi	r25, 0x31	; 49
    3852:	8f 8b       	std	Y+23, r24	; 0x17
    3854:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3856:	82 e3       	ldi	r24, 0x32	; 50
    3858:	91 e3       	ldi	r25, 0x31	; 49
    385a:	89 8f       	std	Y+25, r24	; 0x19
    385c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    385e:	88 e2       	ldi	r24, 0x28	; 40
    3860:	91 e3       	ldi	r25, 0x31	; 49
    3862:	8b 8f       	std	Y+27, r24	; 0x1b
    3864:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3866:	0f 89       	ldd	r16, Y+23	; 0x17
    3868:	18 8d       	ldd	r17, Y+24	; 0x18
    386a:	84 e6       	ldi	r24, 0x64	; 100
    386c:	90 e0       	ldi	r25, 0x00	; 0
    386e:	0e 94 17 19 	call	0x322e	; 0x322e <_Znaj>
    3872:	f8 01       	movw	r30, r16
    3874:	80 83       	st	Z, r24
    3876:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3878:	e9 8d       	ldd	r30, Y+25	; 0x19
    387a:	fa 8d       	ldd	r31, Y+26	; 0x1a
    387c:	10 82       	st	Z, r1
    387e:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3880:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3882:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3884:	10 82       	st	Z, r1
    3886:	11 82       	std	Z+1, r1	; 0x01
}
    3888:	df 91       	pop	r29
    388a:	cf 91       	pop	r28
    388c:	1f 91       	pop	r17
    388e:	0f 91       	pop	r16
    3890:	ff 90       	pop	r15
    3892:	ef 90       	pop	r14
    3894:	08 95       	ret

00003896 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3896:	1f 92       	push	r1
    3898:	0f 92       	push	r0
    389a:	0f b6       	in	r0, 0x3f	; 63
    389c:	0f 92       	push	r0
    389e:	11 24       	eor	r1, r1
    38a0:	08 b6       	in	r0, 0x38	; 56
    38a2:	0f 92       	push	r0
    38a4:	18 be       	out	0x38, r1	; 56
    38a6:	0b b6       	in	r0, 0x3b	; 59
    38a8:	0f 92       	push	r0
    38aa:	1b be       	out	0x3b, r1	; 59
    38ac:	2f 93       	push	r18
    38ae:	3f 93       	push	r19
    38b0:	8f 93       	push	r24
    38b2:	9f 93       	push	r25
    38b4:	ef 93       	push	r30
    38b6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    38b8:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    38bc:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    38c0:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    38c4:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    38c8:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    38cc:	e8 0f       	add	r30, r24
    38ce:	f9 1f       	adc	r31, r25
    38d0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    38d2:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    38d6:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    38da:	01 96       	adiw	r24, 0x01	; 1
    38dc:	84 36       	cpi	r24, 0x64	; 100
    38de:	91 05       	cpc	r25, r1
    38e0:	60 f4       	brcc	.+24     	; 0x38fa <__vector_25+0x64>
    38e2:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    38e6:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    38ea:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    38ee:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    38f2:	82 17       	cp	r24, r18
    38f4:	93 07       	cpc	r25, r19
    38f6:	f1 f4       	brne	.+60     	; 0x3934 <__vector_25+0x9e>
    38f8:	0c c0       	rjmp	.+24     	; 0x3912 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    38fa:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    38fe:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3902:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    3906:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    390a:	18 16       	cp	r1, r24
    390c:	19 06       	cpc	r1, r25
    390e:	91 f4       	brne	.+36     	; 0x3934 <__vector_25+0x9e>
    3910:	0e c0       	rjmp	.+28     	; 0x392e <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3912:	01 96       	adiw	r24, 0x01	; 1
    3914:	84 36       	cpi	r24, 0x64	; 100
    3916:	91 05       	cpc	r25, r1
    3918:	28 f4       	brcc	.+10     	; 0x3924 <__vector_25+0x8e>
    391a:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    391e:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    3922:	08 c0       	rjmp	.+16     	; 0x3934 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3924:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    3928:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    392c:	03 c0       	rjmp	.+6      	; 0x3934 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    392e:	81 e0       	ldi	r24, 0x01	; 1
    3930:	90 e0       	ldi	r25, 0x00	; 0
    3932:	f3 cf       	rjmp	.-26     	; 0x391a <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3934:	ff 91       	pop	r31
    3936:	ef 91       	pop	r30
    3938:	9f 91       	pop	r25
    393a:	8f 91       	pop	r24
    393c:	3f 91       	pop	r19
    393e:	2f 91       	pop	r18
    3940:	0f 90       	pop	r0
    3942:	0b be       	out	0x3b, r0	; 59
    3944:	0f 90       	pop	r0
    3946:	08 be       	out	0x38, r0	; 56
    3948:	0f 90       	pop	r0
    394a:	0f be       	out	0x3f, r0	; 63
    394c:	0f 90       	pop	r0
    394e:	1f 90       	pop	r1
    3950:	18 95       	reti

00003952 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3952:	1f 92       	push	r1
    3954:	0f 92       	push	r0
    3956:	0f b6       	in	r0, 0x3f	; 63
    3958:	0f 92       	push	r0
    395a:	11 24       	eor	r1, r1
    395c:	08 b6       	in	r0, 0x38	; 56
    395e:	0f 92       	push	r0
    3960:	18 be       	out	0x38, r1	; 56
    3962:	0b b6       	in	r0, 0x3b	; 59
    3964:	0f 92       	push	r0
    3966:	1b be       	out	0x3b, r1	; 59
    3968:	2f 93       	push	r18
    396a:	3f 93       	push	r19
    396c:	8f 93       	push	r24
    396e:	9f 93       	push	r25
    3970:	ef 93       	push	r30
    3972:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3974:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3978:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    397c:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3980:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3984:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3988:	e8 0f       	add	r30, r24
    398a:	f9 1f       	adc	r31, r25
    398c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    398e:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3992:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3996:	01 96       	adiw	r24, 0x01	; 1
    3998:	84 36       	cpi	r24, 0x64	; 100
    399a:	91 05       	cpc	r25, r1
    399c:	60 f4       	brcc	.+24     	; 0x39b6 <__vector_28+0x64>
    399e:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    39a2:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39a6:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    39aa:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    39ae:	82 17       	cp	r24, r18
    39b0:	93 07       	cpc	r25, r19
    39b2:	f1 f4       	brne	.+60     	; 0x39f0 <__vector_28+0x9e>
    39b4:	0c c0       	rjmp	.+24     	; 0x39ce <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    39b6:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    39ba:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39be:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    39c2:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    39c6:	18 16       	cp	r1, r24
    39c8:	19 06       	cpc	r1, r25
    39ca:	91 f4       	brne	.+36     	; 0x39f0 <__vector_28+0x9e>
    39cc:	0e c0       	rjmp	.+28     	; 0x39ea <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    39ce:	01 96       	adiw	r24, 0x01	; 1
    39d0:	84 36       	cpi	r24, 0x64	; 100
    39d2:	91 05       	cpc	r25, r1
    39d4:	28 f4       	brcc	.+10     	; 0x39e0 <__vector_28+0x8e>
    39d6:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    39da:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    39de:	08 c0       	rjmp	.+16     	; 0x39f0 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    39e0:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    39e4:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    39e8:	03 c0       	rjmp	.+6      	; 0x39f0 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    39ea:	81 e0       	ldi	r24, 0x01	; 1
    39ec:	90 e0       	ldi	r25, 0x00	; 0
    39ee:	f3 cf       	rjmp	.-26     	; 0x39d6 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    39f0:	ff 91       	pop	r31
    39f2:	ef 91       	pop	r30
    39f4:	9f 91       	pop	r25
    39f6:	8f 91       	pop	r24
    39f8:	3f 91       	pop	r19
    39fa:	2f 91       	pop	r18
    39fc:	0f 90       	pop	r0
    39fe:	0b be       	out	0x3b, r0	; 59
    3a00:	0f 90       	pop	r0
    3a02:	08 be       	out	0x38, r0	; 56
    3a04:	0f 90       	pop	r0
    3a06:	0f be       	out	0x3f, r0	; 63
    3a08:	0f 90       	pop	r0
    3a0a:	1f 90       	pop	r1
    3a0c:	18 95       	reti

00003a0e <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3a0e:	1f 92       	push	r1
    3a10:	0f 92       	push	r0
    3a12:	0f b6       	in	r0, 0x3f	; 63
    3a14:	0f 92       	push	r0
    3a16:	11 24       	eor	r1, r1
    3a18:	08 b6       	in	r0, 0x38	; 56
    3a1a:	0f 92       	push	r0
    3a1c:	18 be       	out	0x38, r1	; 56
    3a1e:	0b b6       	in	r0, 0x3b	; 59
    3a20:	0f 92       	push	r0
    3a22:	1b be       	out	0x3b, r1	; 59
    3a24:	2f 93       	push	r18
    3a26:	3f 93       	push	r19
    3a28:	8f 93       	push	r24
    3a2a:	9f 93       	push	r25
    3a2c:	ef 93       	push	r30
    3a2e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3a30:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3a34:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    3a38:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    3a3c:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3a40:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3a44:	e8 0f       	add	r30, r24
    3a46:	f9 1f       	adc	r31, r25
    3a48:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3a4a:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    3a4e:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    3a52:	01 96       	adiw	r24, 0x01	; 1
    3a54:	84 36       	cpi	r24, 0x64	; 100
    3a56:	91 05       	cpc	r25, r1
    3a58:	60 f4       	brcc	.+24     	; 0x3a72 <__vector_88+0x64>
    3a5a:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    3a5e:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a62:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    3a66:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3a6a:	82 17       	cp	r24, r18
    3a6c:	93 07       	cpc	r25, r19
    3a6e:	f1 f4       	brne	.+60     	; 0x3aac <__vector_88+0x9e>
    3a70:	0c c0       	rjmp	.+24     	; 0x3a8a <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3a72:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    3a76:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a7a:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    3a7e:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3a82:	18 16       	cp	r1, r24
    3a84:	19 06       	cpc	r1, r25
    3a86:	91 f4       	brne	.+36     	; 0x3aac <__vector_88+0x9e>
    3a88:	0e c0       	rjmp	.+28     	; 0x3aa6 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a8a:	01 96       	adiw	r24, 0x01	; 1
    3a8c:	84 36       	cpi	r24, 0x64	; 100
    3a8e:	91 05       	cpc	r25, r1
    3a90:	28 f4       	brcc	.+10     	; 0x3a9c <__vector_88+0x8e>
    3a92:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    3a96:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    3a9a:	08 c0       	rjmp	.+16     	; 0x3aac <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3a9c:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    3aa0:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    3aa4:	03 c0       	rjmp	.+6      	; 0x3aac <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3aa6:	81 e0       	ldi	r24, 0x01	; 1
    3aa8:	90 e0       	ldi	r25, 0x00	; 0
    3aaa:	f3 cf       	rjmp	.-26     	; 0x3a92 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3aac:	ff 91       	pop	r31
    3aae:	ef 91       	pop	r30
    3ab0:	9f 91       	pop	r25
    3ab2:	8f 91       	pop	r24
    3ab4:	3f 91       	pop	r19
    3ab6:	2f 91       	pop	r18
    3ab8:	0f 90       	pop	r0
    3aba:	0b be       	out	0x3b, r0	; 59
    3abc:	0f 90       	pop	r0
    3abe:	08 be       	out	0x38, r0	; 56
    3ac0:	0f 90       	pop	r0
    3ac2:	0f be       	out	0x3f, r0	; 63
    3ac4:	0f 90       	pop	r0
    3ac6:	1f 90       	pop	r1
    3ac8:	18 95       	reti

00003aca <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3aca:	1f 92       	push	r1
    3acc:	0f 92       	push	r0
    3ace:	0f b6       	in	r0, 0x3f	; 63
    3ad0:	0f 92       	push	r0
    3ad2:	11 24       	eor	r1, r1
    3ad4:	08 b6       	in	r0, 0x38	; 56
    3ad6:	0f 92       	push	r0
    3ad8:	18 be       	out	0x38, r1	; 56
    3ada:	0b b6       	in	r0, 0x3b	; 59
    3adc:	0f 92       	push	r0
    3ade:	1b be       	out	0x3b, r1	; 59
    3ae0:	2f 93       	push	r18
    3ae2:	3f 93       	push	r19
    3ae4:	8f 93       	push	r24
    3ae6:	9f 93       	push	r25
    3ae8:	ef 93       	push	r30
    3aea:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3aec:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3af0:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    3af4:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    3af8:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3afc:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3b00:	e8 0f       	add	r30, r24
    3b02:	f9 1f       	adc	r31, r25
    3b04:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3b06:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3b0a:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3b0e:	01 96       	adiw	r24, 0x01	; 1
    3b10:	84 36       	cpi	r24, 0x64	; 100
    3b12:	91 05       	cpc	r25, r1
    3b14:	60 f4       	brcc	.+24     	; 0x3b2e <__vector_91+0x64>
    3b16:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    3b1a:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b1e:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    3b22:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3b26:	82 17       	cp	r24, r18
    3b28:	93 07       	cpc	r25, r19
    3b2a:	f1 f4       	brne	.+60     	; 0x3b68 <__vector_91+0x9e>
    3b2c:	0c c0       	rjmp	.+24     	; 0x3b46 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3b2e:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    3b32:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b36:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    3b3a:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3b3e:	18 16       	cp	r1, r24
    3b40:	19 06       	cpc	r1, r25
    3b42:	91 f4       	brne	.+36     	; 0x3b68 <__vector_91+0x9e>
    3b44:	0e c0       	rjmp	.+28     	; 0x3b62 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b46:	01 96       	adiw	r24, 0x01	; 1
    3b48:	84 36       	cpi	r24, 0x64	; 100
    3b4a:	91 05       	cpc	r25, r1
    3b4c:	28 f4       	brcc	.+10     	; 0x3b58 <__vector_91+0x8e>
    3b4e:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    3b52:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    3b56:	08 c0       	rjmp	.+16     	; 0x3b68 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3b58:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    3b5c:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    3b60:	03 c0       	rjmp	.+6      	; 0x3b68 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b62:	81 e0       	ldi	r24, 0x01	; 1
    3b64:	90 e0       	ldi	r25, 0x00	; 0
    3b66:	f3 cf       	rjmp	.-26     	; 0x3b4e <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3b68:	ff 91       	pop	r31
    3b6a:	ef 91       	pop	r30
    3b6c:	9f 91       	pop	r25
    3b6e:	8f 91       	pop	r24
    3b70:	3f 91       	pop	r19
    3b72:	2f 91       	pop	r18
    3b74:	0f 90       	pop	r0
    3b76:	0b be       	out	0x3b, r0	; 59
    3b78:	0f 90       	pop	r0
    3b7a:	08 be       	out	0x38, r0	; 56
    3b7c:	0f 90       	pop	r0
    3b7e:	0f be       	out	0x3f, r0	; 63
    3b80:	0f 90       	pop	r0
    3b82:	1f 90       	pop	r1
    3b84:	18 95       	reti

00003b86 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3b86:	1f 92       	push	r1
    3b88:	0f 92       	push	r0
    3b8a:	0f b6       	in	r0, 0x3f	; 63
    3b8c:	0f 92       	push	r0
    3b8e:	11 24       	eor	r1, r1
    3b90:	08 b6       	in	r0, 0x38	; 56
    3b92:	0f 92       	push	r0
    3b94:	18 be       	out	0x38, r1	; 56
    3b96:	0b b6       	in	r0, 0x3b	; 59
    3b98:	0f 92       	push	r0
    3b9a:	1b be       	out	0x3b, r1	; 59
    3b9c:	2f 93       	push	r18
    3b9e:	3f 93       	push	r19
    3ba0:	8f 93       	push	r24
    3ba2:	9f 93       	push	r25
    3ba4:	ef 93       	push	r30
    3ba6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3ba8:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3bac:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    3bb0:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    3bb4:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3bb8:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3bbc:	e8 0f       	add	r30, r24
    3bbe:	f9 1f       	adc	r31, r25
    3bc0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3bc2:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3bc6:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3bca:	01 96       	adiw	r24, 0x01	; 1
    3bcc:	84 36       	cpi	r24, 0x64	; 100
    3bce:	91 05       	cpc	r25, r1
    3bd0:	60 f4       	brcc	.+24     	; 0x3bea <__vector_58+0x64>
    3bd2:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    3bd6:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3bda:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    3bde:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3be2:	82 17       	cp	r24, r18
    3be4:	93 07       	cpc	r25, r19
    3be6:	f1 f4       	brne	.+60     	; 0x3c24 <__vector_58+0x9e>
    3be8:	0c c0       	rjmp	.+24     	; 0x3c02 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3bea:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    3bee:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3bf2:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    3bf6:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3bfa:	18 16       	cp	r1, r24
    3bfc:	19 06       	cpc	r1, r25
    3bfe:	91 f4       	brne	.+36     	; 0x3c24 <__vector_58+0x9e>
    3c00:	0e c0       	rjmp	.+28     	; 0x3c1e <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c02:	01 96       	adiw	r24, 0x01	; 1
    3c04:	84 36       	cpi	r24, 0x64	; 100
    3c06:	91 05       	cpc	r25, r1
    3c08:	28 f4       	brcc	.+10     	; 0x3c14 <__vector_58+0x8e>
    3c0a:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    3c0e:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    3c12:	08 c0       	rjmp	.+16     	; 0x3c24 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3c14:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    3c18:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    3c1c:	03 c0       	rjmp	.+6      	; 0x3c24 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c1e:	81 e0       	ldi	r24, 0x01	; 1
    3c20:	90 e0       	ldi	r25, 0x00	; 0
    3c22:	f3 cf       	rjmp	.-26     	; 0x3c0a <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3c24:	ff 91       	pop	r31
    3c26:	ef 91       	pop	r30
    3c28:	9f 91       	pop	r25
    3c2a:	8f 91       	pop	r24
    3c2c:	3f 91       	pop	r19
    3c2e:	2f 91       	pop	r18
    3c30:	0f 90       	pop	r0
    3c32:	0b be       	out	0x3b, r0	; 59
    3c34:	0f 90       	pop	r0
    3c36:	08 be       	out	0x38, r0	; 56
    3c38:	0f 90       	pop	r0
    3c3a:	0f be       	out	0x3f, r0	; 63
    3c3c:	0f 90       	pop	r0
    3c3e:	1f 90       	pop	r1
    3c40:	18 95       	reti

00003c42 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3c42:	0f 93       	push	r16
    3c44:	cf 93       	push	r28
    3c46:	df 93       	push	r29
    3c48:	1f 92       	push	r1
    3c4a:	cd b7       	in	r28, 0x3d	; 61
    3c4c:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3c4e:	2f b7       	in	r18, 0x3f	; 63
    3c50:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3c52:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3c54:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3c56:	fc 01       	movw	r30, r24
    3c58:	08 ed       	ldi	r16, 0xD8	; 216
    3c5a:	04 bf       	out	0x34, r16	; 52
    3c5c:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3c5e:	89 81       	ldd	r24, Y+1	; 0x01
    3c60:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3c62:	0f 90       	pop	r0
    3c64:	df 91       	pop	r29
    3c66:	cf 91       	pop	r28
    3c68:	0f 91       	pop	r16
    3c6a:	08 95       	ret

00003c6c <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3c6c:	0f 93       	push	r16
    3c6e:	1f 93       	push	r17
    3c70:	cf 93       	push	r28
    3c72:	df 93       	push	r29
    3c74:	cd b7       	in	r28, 0x3d	; 61
    3c76:	de b7       	in	r29, 0x3e	; 62
    3c78:	6d 97       	sbiw	r28, 0x1d	; 29
    3c7a:	cd bf       	out	0x3d, r28	; 61
    3c7c:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3c7e:	e0 e6       	ldi	r30, 0x60	; 96
    3c80:	f6 e0       	ldi	r31, 0x06	; 6
    3c82:	80 e4       	ldi	r24, 0x40	; 64
    3c84:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3c86:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3c88:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3c8a:	e0 e5       	ldi	r30, 0x50	; 80
    3c8c:	f0 e0       	ldi	r31, 0x00	; 0
    3c8e:	80 81       	ld	r24, Z
    3c90:	82 60       	ori	r24, 0x02	; 2
    3c92:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3c94:	81 81       	ldd	r24, Z+1	; 0x01
    3c96:	81 ff       	sbrs	r24, 1
    3c98:	fd cf       	rjmp	.-6      	; 0x3c94 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3c9a:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3c9e:	68 7f       	andi	r22, 0xF8	; 248
    3ca0:	61 60       	ori	r22, 0x01	; 1
    3ca2:	80 e4       	ldi	r24, 0x40	; 64
    3ca4:	90 e0       	ldi	r25, 0x00	; 0
    3ca6:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3caa:	e0 e5       	ldi	r30, 0x50	; 80
    3cac:	f0 e0       	ldi	r31, 0x00	; 0
    3cae:	80 81       	ld	r24, Z
    3cb0:	8e 7f       	andi	r24, 0xFE	; 254
    3cb2:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3cb4:	9d ef       	ldi	r25, 0xFD	; 253
    3cb6:	88 ed       	ldi	r24, 0xD8	; 216
    3cb8:	08 b6       	in	r0, 0x38	; 56
    3cba:	18 be       	out	0x38, r1	; 56
    3cbc:	84 bf       	out	0x34, r24	; 52
    3cbe:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3cc2:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3cc4:	40 eb       	ldi	r20, 0xB0	; 176
    3cc6:	58 e0       	ldi	r21, 0x08	; 8
    3cc8:	60 e0       	ldi	r22, 0x00	; 0
    3cca:	70 e0       	ldi	r23, 0x00	; 0
    3ccc:	ce 01       	movw	r24, r28
    3cce:	01 96       	adiw	r24, 0x01	; 1
    3cd0:	0e 94 cb 1b 	call	0x3796	; 0x3796 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3cd4:	67 e0       	ldi	r22, 0x07	; 7
    3cd6:	ce 01       	movw	r24, r28
    3cd8:	01 96       	adiw	r24, 0x01	; 1
    3cda:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    3cde:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3ce0:	63 e7       	ldi	r22, 0x73	; 115
    3ce2:	70 e2       	ldi	r23, 0x20	; 32
    3ce4:	0e 94 c8 19 	call	0x3390	; 0x3390 <_ZN8emstream4putsEPKc>
    3ce8:	66 e0       	ldi	r22, 0x06	; 6
    3cea:	c8 01       	movw	r24, r16
    3cec:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
    3cf0:	66 e0       	ldi	r22, 0x06	; 6
    3cf2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3cf6:	82 e1       	ldi	r24, 0x12	; 18
    3cf8:	90 e0       	ldi	r25, 0x00	; 0
    3cfa:	0e 94 14 19 	call	0x3228	; 0x3228 <_Znwj>
    3cfe:	8e 01       	movw	r16, r28
    3d00:	0f 5f       	subi	r16, 0xFF	; 255
    3d02:	1f 4f       	sbci	r17, 0xFF	; 255
    3d04:	24 e0       	ldi	r18, 0x04	; 4
    3d06:	31 e0       	ldi	r19, 0x01	; 1
    3d08:	40 e0       	ldi	r20, 0x00	; 0
    3d0a:	62 e9       	ldi	r22, 0x92	; 146
    3d0c:	70 e2       	ldi	r23, 0x20	; 32
    3d0e:	0e 94 d5 06 	call	0xdaa	; 0xdaa <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3d12:	82 e1       	ldi	r24, 0x12	; 18
    3d14:	90 e0       	ldi	r25, 0x00	; 0
    3d16:	0e 94 14 19 	call	0x3228	; 0x3228 <_Znwj>
    3d1a:	24 e0       	ldi	r18, 0x04	; 4
    3d1c:	31 e0       	ldi	r19, 0x01	; 1
    3d1e:	42 e0       	ldi	r20, 0x02	; 2
    3d20:	6a e9       	ldi	r22, 0x9A	; 154
    3d22:	70 e2       	ldi	r23, 0x20	; 32
    3d24:	0e 94 54 03 	call	0x6a8	; 0x6a8 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3d28:	82 e1       	ldi	r24, 0x12	; 18
    3d2a:	90 e0       	ldi	r25, 0x00	; 0
    3d2c:	0e 94 14 19 	call	0x3228	; 0x3228 <_Znwj>
    3d30:	24 e0       	ldi	r18, 0x04	; 4
    3d32:	31 e0       	ldi	r19, 0x01	; 1
    3d34:	43 e0       	ldi	r20, 0x03	; 3
    3d36:	61 ea       	ldi	r22, 0xA1	; 161
    3d38:	70 e2       	ldi	r23, 0x20	; 32
    3d3a:	0e 94 c4 03 	call	0x788	; 0x788 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3d3e:	82 e1       	ldi	r24, 0x12	; 18
    3d40:	90 e0       	ldi	r25, 0x00	; 0
    3d42:	0e 94 14 19 	call	0x3228	; 0x3228 <_Znwj>
    3d46:	24 e0       	ldi	r18, 0x04	; 4
    3d48:	31 e0       	ldi	r19, 0x01	; 1
    3d4a:	44 e0       	ldi	r20, 0x04	; 4
    3d4c:	68 ea       	ldi	r22, 0xA8	; 168
    3d4e:	70 e2       	ldi	r23, 0x20	; 32
    3d50:	0e 94 29 04 	call	0x852	; 0x852 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3d54:	8e e5       	ldi	r24, 0x5E	; 94
    3d56:	90 e0       	ldi	r25, 0x00	; 0
    3d58:	0e 94 14 19 	call	0x3228	; 0x3228 <_Znwj>
    3d5c:	24 e0       	ldi	r18, 0x04	; 4
    3d5e:	31 e0       	ldi	r19, 0x01	; 1
    3d60:	43 e0       	ldi	r20, 0x03	; 3
    3d62:	61 eb       	ldi	r22, 0xB1	; 177
    3d64:	70 e2       	ldi	r23, 0x20	; 32
    3d66:	0e 94 21 06 	call	0xc42	; 0xc42 <_ZN5MotorC1EPKchjP8emstream>
	
	new PWMdriver ("PWM", task_priority(5), 260, &ser_dev);
    3d6a:	82 e1       	ldi	r24, 0x12	; 18
    3d6c:	90 e0       	ldi	r25, 0x00	; 0
    3d6e:	0e 94 14 19 	call	0x3228	; 0x3228 <_Znwj>
    3d72:	24 e0       	ldi	r18, 0x04	; 4
    3d74:	31 e0       	ldi	r19, 0x01	; 1
    3d76:	44 e0       	ldi	r20, 0x04	; 4
    3d78:	67 eb       	ldi	r22, 0xB7	; 183
    3d7a:	70 e2       	ldi	r23, 0x20	; 32
    3d7c:	0e 94 97 06 	call	0xd2e	; 0xd2e <_ZN9PWMdriverC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3d80:	87 e0       	ldi	r24, 0x07	; 7
    3d82:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3d86:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3d88:	0e 94 26 10 	call	0x204c	; 0x204c <vTaskStartScheduler>
	
	
	return 0;
    3d8c:	80 e0       	ldi	r24, 0x00	; 0
    3d8e:	90 e0       	ldi	r25, 0x00	; 0
    3d90:	6d 96       	adiw	r28, 0x1d	; 29
    3d92:	cd bf       	out	0x3d, r28	; 61
    3d94:	de bf       	out	0x3e, r29	; 62
    3d96:	df 91       	pop	r29
    3d98:	cf 91       	pop	r28
    3d9a:	1f 91       	pop	r17
    3d9c:	0f 91       	pop	r16
    3d9e:	08 95       	ret

00003da0 <_GLOBAL__sub_I_counter>:
    3da0:	0f 93       	push	r16
    3da2:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3da4:	0a e0       	ldi	r16, 0x0A	; 10
    3da6:	10 e0       	ldi	r17, 0x00	; 0
    3da8:	20 e0       	ldi	r18, 0x00	; 0
    3daa:	30 e0       	ldi	r19, 0x00	; 0
    3dac:	40 e0       	ldi	r20, 0x00	; 0
    3dae:	50 e0       	ldi	r21, 0x00	; 0
    3db0:	60 e2       	ldi	r22, 0x20	; 32
    3db2:	70 e0       	ldi	r23, 0x00	; 0
    3db4:	80 e5       	ldi	r24, 0x50	; 80
    3db6:	91 e3       	ldi	r25, 0x31	; 49
    3db8:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3dbc:	1f 91       	pop	r17
    3dbe:	0f 91       	pop	r16
    3dc0:	08 95       	ret

00003dc2 <__cmpsf2>:
    3dc2:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <__fp_cmp>
    3dc6:	08 f4       	brcc	.+2      	; 0x3dca <__cmpsf2+0x8>
    3dc8:	81 e0       	ldi	r24, 0x01	; 1
    3dca:	08 95       	ret

00003dcc <__floatunsisf>:
    3dcc:	e8 94       	clt
    3dce:	09 c0       	rjmp	.+18     	; 0x3de2 <__floatsisf+0x12>

00003dd0 <__floatsisf>:
    3dd0:	97 fb       	bst	r25, 7
    3dd2:	3e f4       	brtc	.+14     	; 0x3de2 <__floatsisf+0x12>
    3dd4:	90 95       	com	r25
    3dd6:	80 95       	com	r24
    3dd8:	70 95       	com	r23
    3dda:	61 95       	neg	r22
    3ddc:	7f 4f       	sbci	r23, 0xFF	; 255
    3dde:	8f 4f       	sbci	r24, 0xFF	; 255
    3de0:	9f 4f       	sbci	r25, 0xFF	; 255
    3de2:	99 23       	and	r25, r25
    3de4:	a9 f0       	breq	.+42     	; 0x3e10 <__floatsisf+0x40>
    3de6:	f9 2f       	mov	r31, r25
    3de8:	96 e9       	ldi	r25, 0x96	; 150
    3dea:	bb 27       	eor	r27, r27
    3dec:	93 95       	inc	r25
    3dee:	f6 95       	lsr	r31
    3df0:	87 95       	ror	r24
    3df2:	77 95       	ror	r23
    3df4:	67 95       	ror	r22
    3df6:	b7 95       	ror	r27
    3df8:	f1 11       	cpse	r31, r1
    3dfa:	f8 cf       	rjmp	.-16     	; 0x3dec <__floatsisf+0x1c>
    3dfc:	fa f4       	brpl	.+62     	; 0x3e3c <__floatsisf+0x6c>
    3dfe:	bb 0f       	add	r27, r27
    3e00:	11 f4       	brne	.+4      	; 0x3e06 <__floatsisf+0x36>
    3e02:	60 ff       	sbrs	r22, 0
    3e04:	1b c0       	rjmp	.+54     	; 0x3e3c <__floatsisf+0x6c>
    3e06:	6f 5f       	subi	r22, 0xFF	; 255
    3e08:	7f 4f       	sbci	r23, 0xFF	; 255
    3e0a:	8f 4f       	sbci	r24, 0xFF	; 255
    3e0c:	9f 4f       	sbci	r25, 0xFF	; 255
    3e0e:	16 c0       	rjmp	.+44     	; 0x3e3c <__floatsisf+0x6c>
    3e10:	88 23       	and	r24, r24
    3e12:	11 f0       	breq	.+4      	; 0x3e18 <__floatsisf+0x48>
    3e14:	96 e9       	ldi	r25, 0x96	; 150
    3e16:	11 c0       	rjmp	.+34     	; 0x3e3a <__floatsisf+0x6a>
    3e18:	77 23       	and	r23, r23
    3e1a:	21 f0       	breq	.+8      	; 0x3e24 <__floatsisf+0x54>
    3e1c:	9e e8       	ldi	r25, 0x8E	; 142
    3e1e:	87 2f       	mov	r24, r23
    3e20:	76 2f       	mov	r23, r22
    3e22:	05 c0       	rjmp	.+10     	; 0x3e2e <__floatsisf+0x5e>
    3e24:	66 23       	and	r22, r22
    3e26:	71 f0       	breq	.+28     	; 0x3e44 <__floatsisf+0x74>
    3e28:	96 e8       	ldi	r25, 0x86	; 134
    3e2a:	86 2f       	mov	r24, r22
    3e2c:	70 e0       	ldi	r23, 0x00	; 0
    3e2e:	60 e0       	ldi	r22, 0x00	; 0
    3e30:	2a f0       	brmi	.+10     	; 0x3e3c <__floatsisf+0x6c>
    3e32:	9a 95       	dec	r25
    3e34:	66 0f       	add	r22, r22
    3e36:	77 1f       	adc	r23, r23
    3e38:	88 1f       	adc	r24, r24
    3e3a:	da f7       	brpl	.-10     	; 0x3e32 <__floatsisf+0x62>
    3e3c:	88 0f       	add	r24, r24
    3e3e:	96 95       	lsr	r25
    3e40:	87 95       	ror	r24
    3e42:	97 f9       	bld	r25, 7
    3e44:	08 95       	ret

00003e46 <__fp_cmp>:
    3e46:	99 0f       	add	r25, r25
    3e48:	00 08       	sbc	r0, r0
    3e4a:	55 0f       	add	r21, r21
    3e4c:	aa 0b       	sbc	r26, r26
    3e4e:	e0 e8       	ldi	r30, 0x80	; 128
    3e50:	fe ef       	ldi	r31, 0xFE	; 254
    3e52:	16 16       	cp	r1, r22
    3e54:	17 06       	cpc	r1, r23
    3e56:	e8 07       	cpc	r30, r24
    3e58:	f9 07       	cpc	r31, r25
    3e5a:	c0 f0       	brcs	.+48     	; 0x3e8c <__fp_cmp+0x46>
    3e5c:	12 16       	cp	r1, r18
    3e5e:	13 06       	cpc	r1, r19
    3e60:	e4 07       	cpc	r30, r20
    3e62:	f5 07       	cpc	r31, r21
    3e64:	98 f0       	brcs	.+38     	; 0x3e8c <__fp_cmp+0x46>
    3e66:	62 1b       	sub	r22, r18
    3e68:	73 0b       	sbc	r23, r19
    3e6a:	84 0b       	sbc	r24, r20
    3e6c:	95 0b       	sbc	r25, r21
    3e6e:	39 f4       	brne	.+14     	; 0x3e7e <__fp_cmp+0x38>
    3e70:	0a 26       	eor	r0, r26
    3e72:	61 f0       	breq	.+24     	; 0x3e8c <__fp_cmp+0x46>
    3e74:	23 2b       	or	r18, r19
    3e76:	24 2b       	or	r18, r20
    3e78:	25 2b       	or	r18, r21
    3e7a:	21 f4       	brne	.+8      	; 0x3e84 <__fp_cmp+0x3e>
    3e7c:	08 95       	ret
    3e7e:	0a 26       	eor	r0, r26
    3e80:	09 f4       	brne	.+2      	; 0x3e84 <__fp_cmp+0x3e>
    3e82:	a1 40       	sbci	r26, 0x01	; 1
    3e84:	a6 95       	lsr	r26
    3e86:	8f ef       	ldi	r24, 0xFF	; 255
    3e88:	81 1d       	adc	r24, r1
    3e8a:	81 1d       	adc	r24, r1
    3e8c:	08 95       	ret

00003e8e <__gesf2>:
    3e8e:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <__fp_cmp>
    3e92:	08 f4       	brcc	.+2      	; 0x3e96 <__gesf2+0x8>
    3e94:	8f ef       	ldi	r24, 0xFF	; 255
    3e96:	08 95       	ret

00003e98 <__mulsi3>:
    3e98:	db 01       	movw	r26, r22
    3e9a:	8f 93       	push	r24
    3e9c:	9f 93       	push	r25
    3e9e:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <__muluhisi3>
    3ea2:	bf 91       	pop	r27
    3ea4:	af 91       	pop	r26
    3ea6:	a2 9f       	mul	r26, r18
    3ea8:	80 0d       	add	r24, r0
    3eaa:	91 1d       	adc	r25, r1
    3eac:	a3 9f       	mul	r26, r19
    3eae:	90 0d       	add	r25, r0
    3eb0:	b2 9f       	mul	r27, r18
    3eb2:	90 0d       	add	r25, r0
    3eb4:	11 24       	eor	r1, r1
    3eb6:	08 95       	ret

00003eb8 <__divmodhi4>:
    3eb8:	97 fb       	bst	r25, 7
    3eba:	07 2e       	mov	r0, r23
    3ebc:	16 f4       	brtc	.+4      	; 0x3ec2 <__divmodhi4+0xa>
    3ebe:	00 94       	com	r0
    3ec0:	07 d0       	rcall	.+14     	; 0x3ed0 <__divmodhi4_neg1>
    3ec2:	77 fd       	sbrc	r23, 7
    3ec4:	09 d0       	rcall	.+18     	; 0x3ed8 <__divmodhi4_neg2>
    3ec6:	0e 94 eb 1f 	call	0x3fd6	; 0x3fd6 <__udivmodhi4>
    3eca:	07 fc       	sbrc	r0, 7
    3ecc:	05 d0       	rcall	.+10     	; 0x3ed8 <__divmodhi4_neg2>
    3ece:	3e f4       	brtc	.+14     	; 0x3ede <__divmodhi4_exit>

00003ed0 <__divmodhi4_neg1>:
    3ed0:	90 95       	com	r25
    3ed2:	81 95       	neg	r24
    3ed4:	9f 4f       	sbci	r25, 0xFF	; 255
    3ed6:	08 95       	ret

00003ed8 <__divmodhi4_neg2>:
    3ed8:	70 95       	com	r23
    3eda:	61 95       	neg	r22
    3edc:	7f 4f       	sbci	r23, 0xFF	; 255

00003ede <__divmodhi4_exit>:
    3ede:	08 95       	ret

00003ee0 <__udivmodsi4>:
    3ee0:	a1 e2       	ldi	r26, 0x21	; 33
    3ee2:	1a 2e       	mov	r1, r26
    3ee4:	aa 1b       	sub	r26, r26
    3ee6:	bb 1b       	sub	r27, r27
    3ee8:	fd 01       	movw	r30, r26
    3eea:	0d c0       	rjmp	.+26     	; 0x3f06 <__udivmodsi4_ep>

00003eec <__udivmodsi4_loop>:
    3eec:	aa 1f       	adc	r26, r26
    3eee:	bb 1f       	adc	r27, r27
    3ef0:	ee 1f       	adc	r30, r30
    3ef2:	ff 1f       	adc	r31, r31
    3ef4:	a2 17       	cp	r26, r18
    3ef6:	b3 07       	cpc	r27, r19
    3ef8:	e4 07       	cpc	r30, r20
    3efa:	f5 07       	cpc	r31, r21
    3efc:	20 f0       	brcs	.+8      	; 0x3f06 <__udivmodsi4_ep>
    3efe:	a2 1b       	sub	r26, r18
    3f00:	b3 0b       	sbc	r27, r19
    3f02:	e4 0b       	sbc	r30, r20
    3f04:	f5 0b       	sbc	r31, r21

00003f06 <__udivmodsi4_ep>:
    3f06:	66 1f       	adc	r22, r22
    3f08:	77 1f       	adc	r23, r23
    3f0a:	88 1f       	adc	r24, r24
    3f0c:	99 1f       	adc	r25, r25
    3f0e:	1a 94       	dec	r1
    3f10:	69 f7       	brne	.-38     	; 0x3eec <__udivmodsi4_loop>
    3f12:	60 95       	com	r22
    3f14:	70 95       	com	r23
    3f16:	80 95       	com	r24
    3f18:	90 95       	com	r25
    3f1a:	9b 01       	movw	r18, r22
    3f1c:	ac 01       	movw	r20, r24
    3f1e:	bd 01       	movw	r22, r26
    3f20:	cf 01       	movw	r24, r30
    3f22:	08 95       	ret

00003f24 <__divmodsi4>:
    3f24:	05 2e       	mov	r0, r21
    3f26:	97 fb       	bst	r25, 7
    3f28:	1e f4       	brtc	.+6      	; 0x3f30 <__divmodsi4+0xc>
    3f2a:	00 94       	com	r0
    3f2c:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <__negsi2>
    3f30:	57 fd       	sbrc	r21, 7
    3f32:	07 d0       	rcall	.+14     	; 0x3f42 <__divmodsi4_neg2>
    3f34:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <__udivmodsi4>
    3f38:	07 fc       	sbrc	r0, 7
    3f3a:	03 d0       	rcall	.+6      	; 0x3f42 <__divmodsi4_neg2>
    3f3c:	4e f4       	brtc	.+18     	; 0x3f50 <__divmodsi4_exit>
    3f3e:	0c 94 a9 1f 	jmp	0x3f52	; 0x3f52 <__negsi2>

00003f42 <__divmodsi4_neg2>:
    3f42:	50 95       	com	r21
    3f44:	40 95       	com	r20
    3f46:	30 95       	com	r19
    3f48:	21 95       	neg	r18
    3f4a:	3f 4f       	sbci	r19, 0xFF	; 255
    3f4c:	4f 4f       	sbci	r20, 0xFF	; 255
    3f4e:	5f 4f       	sbci	r21, 0xFF	; 255

00003f50 <__divmodsi4_exit>:
    3f50:	08 95       	ret

00003f52 <__negsi2>:
    3f52:	90 95       	com	r25
    3f54:	80 95       	com	r24
    3f56:	70 95       	com	r23
    3f58:	61 95       	neg	r22
    3f5a:	7f 4f       	sbci	r23, 0xFF	; 255
    3f5c:	8f 4f       	sbci	r24, 0xFF	; 255
    3f5e:	9f 4f       	sbci	r25, 0xFF	; 255
    3f60:	08 95       	ret

00003f62 <__tablejump2__>:
    3f62:	ee 0f       	add	r30, r30
    3f64:	ff 1f       	adc	r31, r31
    3f66:	88 1f       	adc	r24, r24
    3f68:	8b bf       	out	0x3b, r24	; 59
    3f6a:	07 90       	elpm	r0, Z+
    3f6c:	f6 91       	elpm	r31, Z
    3f6e:	e0 2d       	mov	r30, r0
    3f70:	1b be       	out	0x3b, r1	; 59
    3f72:	19 94       	eijmp

00003f74 <__mulhisi3>:
    3f74:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <__umulhisi3>
    3f78:	33 23       	and	r19, r19
    3f7a:	12 f4       	brpl	.+4      	; 0x3f80 <__mulhisi3+0xc>
    3f7c:	8a 1b       	sub	r24, r26
    3f7e:	9b 0b       	sbc	r25, r27
    3f80:	0c 94 d3 1f 	jmp	0x3fa6	; 0x3fa6 <__usmulhisi3_tail>

00003f84 <__umulhisi3>:
    3f84:	a2 9f       	mul	r26, r18
    3f86:	b0 01       	movw	r22, r0
    3f88:	b3 9f       	mul	r27, r19
    3f8a:	c0 01       	movw	r24, r0
    3f8c:	a3 9f       	mul	r26, r19
    3f8e:	70 0d       	add	r23, r0
    3f90:	81 1d       	adc	r24, r1
    3f92:	11 24       	eor	r1, r1
    3f94:	91 1d       	adc	r25, r1
    3f96:	b2 9f       	mul	r27, r18
    3f98:	70 0d       	add	r23, r0
    3f9a:	81 1d       	adc	r24, r1
    3f9c:	11 24       	eor	r1, r1
    3f9e:	91 1d       	adc	r25, r1
    3fa0:	08 95       	ret

00003fa2 <__usmulhisi3>:
    3fa2:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <__umulhisi3>

00003fa6 <__usmulhisi3_tail>:
    3fa6:	b7 ff       	sbrs	r27, 7
    3fa8:	08 95       	ret
    3faa:	82 1b       	sub	r24, r18
    3fac:	93 0b       	sbc	r25, r19
    3fae:	08 95       	ret

00003fb0 <__muluhisi3>:
    3fb0:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <__umulhisi3>
    3fb4:	a5 9f       	mul	r26, r21
    3fb6:	90 0d       	add	r25, r0
    3fb8:	b4 9f       	mul	r27, r20
    3fba:	90 0d       	add	r25, r0
    3fbc:	a4 9f       	mul	r26, r20
    3fbe:	80 0d       	add	r24, r0
    3fc0:	91 1d       	adc	r25, r1
    3fc2:	11 24       	eor	r1, r1
    3fc4:	08 95       	ret

00003fc6 <__mulshisi3>:
    3fc6:	b7 ff       	sbrs	r27, 7
    3fc8:	0c 94 d8 1f 	jmp	0x3fb0	; 0x3fb0 <__muluhisi3>

00003fcc <__mulohisi3>:
    3fcc:	0e 94 d8 1f 	call	0x3fb0	; 0x3fb0 <__muluhisi3>
    3fd0:	82 1b       	sub	r24, r18
    3fd2:	93 0b       	sbc	r25, r19
    3fd4:	08 95       	ret

00003fd6 <__udivmodhi4>:
    3fd6:	aa 1b       	sub	r26, r26
    3fd8:	bb 1b       	sub	r27, r27
    3fda:	51 e1       	ldi	r21, 0x11	; 17
    3fdc:	07 c0       	rjmp	.+14     	; 0x3fec <__udivmodhi4_ep>

00003fde <__udivmodhi4_loop>:
    3fde:	aa 1f       	adc	r26, r26
    3fe0:	bb 1f       	adc	r27, r27
    3fe2:	a6 17       	cp	r26, r22
    3fe4:	b7 07       	cpc	r27, r23
    3fe6:	10 f0       	brcs	.+4      	; 0x3fec <__udivmodhi4_ep>
    3fe8:	a6 1b       	sub	r26, r22
    3fea:	b7 0b       	sbc	r27, r23

00003fec <__udivmodhi4_ep>:
    3fec:	88 1f       	adc	r24, r24
    3fee:	99 1f       	adc	r25, r25
    3ff0:	5a 95       	dec	r21
    3ff2:	a9 f7       	brne	.-22     	; 0x3fde <__udivmodhi4_loop>
    3ff4:	80 95       	com	r24
    3ff6:	90 95       	com	r25
    3ff8:	bc 01       	movw	r22, r24
    3ffa:	cd 01       	movw	r24, r26
    3ffc:	08 95       	ret

00003ffe <memcpy>:
    3ffe:	fb 01       	movw	r30, r22
    4000:	dc 01       	movw	r26, r24
    4002:	02 c0       	rjmp	.+4      	; 0x4008 <__stack+0x9>
    4004:	01 90       	ld	r0, Z+
    4006:	0d 92       	st	X+, r0
    4008:	41 50       	subi	r20, 0x01	; 1
    400a:	50 40       	sbci	r21, 0x00	; 0
    400c:	d8 f7       	brcc	.-10     	; 0x4004 <__stack+0x5>
    400e:	08 95       	ret

00004010 <memset>:
    4010:	dc 01       	movw	r26, r24
    4012:	01 c0       	rjmp	.+2      	; 0x4016 <memset+0x6>
    4014:	6d 93       	st	X+, r22
    4016:	41 50       	subi	r20, 0x01	; 1
    4018:	50 40       	sbci	r21, 0x00	; 0
    401a:	e0 f7       	brcc	.-8      	; 0x4014 <memset+0x4>
    401c:	08 95       	ret

0000401e <strncpy>:
    401e:	fb 01       	movw	r30, r22
    4020:	dc 01       	movw	r26, r24
    4022:	41 50       	subi	r20, 0x01	; 1
    4024:	50 40       	sbci	r21, 0x00	; 0
    4026:	48 f0       	brcs	.+18     	; 0x403a <strncpy+0x1c>
    4028:	01 90       	ld	r0, Z+
    402a:	0d 92       	st	X+, r0
    402c:	00 20       	and	r0, r0
    402e:	c9 f7       	brne	.-14     	; 0x4022 <strncpy+0x4>
    4030:	01 c0       	rjmp	.+2      	; 0x4034 <strncpy+0x16>
    4032:	1d 92       	st	X+, r1
    4034:	41 50       	subi	r20, 0x01	; 1
    4036:	50 40       	sbci	r21, 0x00	; 0
    4038:	e0 f7       	brcc	.-8      	; 0x4032 <strncpy+0x14>
    403a:	08 95       	ret

0000403c <__itoa_ncheck>:
    403c:	bb 27       	eor	r27, r27
    403e:	4a 30       	cpi	r20, 0x0A	; 10
    4040:	31 f4       	brne	.+12     	; 0x404e <__itoa_ncheck+0x12>
    4042:	99 23       	and	r25, r25
    4044:	22 f4       	brpl	.+8      	; 0x404e <__itoa_ncheck+0x12>
    4046:	bd e2       	ldi	r27, 0x2D	; 45
    4048:	90 95       	com	r25
    404a:	81 95       	neg	r24
    404c:	9f 4f       	sbci	r25, 0xFF	; 255
    404e:	0c 94 62 20 	jmp	0x40c4	; 0x40c4 <__utoa_common>

00004052 <ultoa>:
    4052:	25 32       	cpi	r18, 0x25	; 37
    4054:	31 05       	cpc	r19, r1
    4056:	20 f4       	brcc	.+8      	; 0x4060 <ultoa+0xe>
    4058:	22 30       	cpi	r18, 0x02	; 2
    405a:	10 f0       	brcs	.+4      	; 0x4060 <ultoa+0xe>
    405c:	0c 94 34 20 	jmp	0x4068	; 0x4068 <__ultoa_ncheck>
    4060:	fa 01       	movw	r30, r20
    4062:	10 82       	st	Z, r1
    4064:	ca 01       	movw	r24, r20
    4066:	08 95       	ret

00004068 <__ultoa_ncheck>:
    4068:	bb 27       	eor	r27, r27

0000406a <__ultoa_common>:
    406a:	fa 01       	movw	r30, r20
    406c:	a6 2f       	mov	r26, r22
    406e:	62 17       	cp	r22, r18
    4070:	71 05       	cpc	r23, r1
    4072:	81 05       	cpc	r24, r1
    4074:	91 05       	cpc	r25, r1
    4076:	33 0b       	sbc	r19, r19
    4078:	30 fb       	bst	r19, 0
    407a:	66 f0       	brts	.+24     	; 0x4094 <__ultoa_common+0x2a>
    407c:	aa 27       	eor	r26, r26
    407e:	66 0f       	add	r22, r22
    4080:	77 1f       	adc	r23, r23
    4082:	88 1f       	adc	r24, r24
    4084:	99 1f       	adc	r25, r25
    4086:	aa 1f       	adc	r26, r26
    4088:	a2 17       	cp	r26, r18
    408a:	10 f0       	brcs	.+4      	; 0x4090 <__ultoa_common+0x26>
    408c:	a2 1b       	sub	r26, r18
    408e:	63 95       	inc	r22
    4090:	38 50       	subi	r19, 0x08	; 8
    4092:	a9 f7       	brne	.-22     	; 0x407e <__ultoa_common+0x14>
    4094:	a0 5d       	subi	r26, 0xD0	; 208
    4096:	aa 33       	cpi	r26, 0x3A	; 58
    4098:	08 f0       	brcs	.+2      	; 0x409c <__ultoa_common+0x32>
    409a:	a9 5d       	subi	r26, 0xD9	; 217
    409c:	a1 93       	st	Z+, r26
    409e:	36 f7       	brtc	.-52     	; 0x406c <__ultoa_common+0x2>
    40a0:	b1 11       	cpse	r27, r1
    40a2:	b1 93       	st	Z+, r27
    40a4:	10 82       	st	Z, r1
    40a6:	ca 01       	movw	r24, r20
    40a8:	0c 94 7b 20 	jmp	0x40f6	; 0x40f6 <strrev>

000040ac <utoa>:
    40ac:	45 32       	cpi	r20, 0x25	; 37
    40ae:	51 05       	cpc	r21, r1
    40b0:	20 f4       	brcc	.+8      	; 0x40ba <utoa+0xe>
    40b2:	42 30       	cpi	r20, 0x02	; 2
    40b4:	10 f0       	brcs	.+4      	; 0x40ba <utoa+0xe>
    40b6:	0c 94 61 20 	jmp	0x40c2	; 0x40c2 <__utoa_ncheck>
    40ba:	fb 01       	movw	r30, r22
    40bc:	10 82       	st	Z, r1
    40be:	cb 01       	movw	r24, r22
    40c0:	08 95       	ret

000040c2 <__utoa_ncheck>:
    40c2:	bb 27       	eor	r27, r27

000040c4 <__utoa_common>:
    40c4:	fb 01       	movw	r30, r22
    40c6:	55 27       	eor	r21, r21
    40c8:	aa 27       	eor	r26, r26
    40ca:	88 0f       	add	r24, r24
    40cc:	99 1f       	adc	r25, r25
    40ce:	aa 1f       	adc	r26, r26
    40d0:	a4 17       	cp	r26, r20
    40d2:	10 f0       	brcs	.+4      	; 0x40d8 <__utoa_common+0x14>
    40d4:	a4 1b       	sub	r26, r20
    40d6:	83 95       	inc	r24
    40d8:	50 51       	subi	r21, 0x10	; 16
    40da:	b9 f7       	brne	.-18     	; 0x40ca <__utoa_common+0x6>
    40dc:	a0 5d       	subi	r26, 0xD0	; 208
    40de:	aa 33       	cpi	r26, 0x3A	; 58
    40e0:	08 f0       	brcs	.+2      	; 0x40e4 <__utoa_common+0x20>
    40e2:	a9 5d       	subi	r26, 0xD9	; 217
    40e4:	a1 93       	st	Z+, r26
    40e6:	00 97       	sbiw	r24, 0x00	; 0
    40e8:	79 f7       	brne	.-34     	; 0x40c8 <__utoa_common+0x4>
    40ea:	b1 11       	cpse	r27, r1
    40ec:	b1 93       	st	Z+, r27
    40ee:	11 92       	st	Z+, r1
    40f0:	cb 01       	movw	r24, r22
    40f2:	0c 94 7b 20 	jmp	0x40f6	; 0x40f6 <strrev>

000040f6 <strrev>:
    40f6:	dc 01       	movw	r26, r24
    40f8:	fc 01       	movw	r30, r24
    40fa:	67 2f       	mov	r22, r23
    40fc:	71 91       	ld	r23, Z+
    40fe:	77 23       	and	r23, r23
    4100:	e1 f7       	brne	.-8      	; 0x40fa <strrev+0x4>
    4102:	32 97       	sbiw	r30, 0x02	; 2
    4104:	04 c0       	rjmp	.+8      	; 0x410e <strrev+0x18>
    4106:	7c 91       	ld	r23, X
    4108:	6d 93       	st	X+, r22
    410a:	70 83       	st	Z, r23
    410c:	62 91       	ld	r22, -Z
    410e:	ae 17       	cp	r26, r30
    4110:	bf 07       	cpc	r27, r31
    4112:	c8 f3       	brcs	.-14     	; 0x4106 <strrev+0x10>
    4114:	08 95       	ret

00004116 <_exit>:
    4116:	f8 94       	cli

00004118 <__stop_program>:
    4118:	ff cf       	rjmp	.-2      	; 0x4118 <__stop_program>
