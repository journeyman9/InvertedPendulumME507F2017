
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040a6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ea  00802000  000040a6  0000413a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020ea  008020ea  00004224  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004224  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004254  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000718  00000000  00000000  00004294  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011d2c  00000000  00000000  000049ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000067b8  00000000  00000000  000166d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000055c0  00000000  00000000  0001ce90  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000134c  00000000  00000000  00022450  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000063e2  00000000  00000000  0002379c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006034  00000000  00000000  00029b7e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005b0  00000000  00000000  0002fbb2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ad 02 	jmp	0x55a	; 0x55a <__ctors_end>
       4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
       8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
       c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      10:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      14:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      18:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      1c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      20:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      24:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      28:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      2c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      30:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      34:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      38:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      3c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      40:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      44:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      48:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      4c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      50:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      54:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      58:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      5c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      60:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      64:	0c 94 06 1c 	jmp	0x380c	; 0x380c <__vector_25>
      68:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      6c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      70:	0c 94 64 1c 	jmp	0x38c8	; 0x38c8 <__vector_28>
      74:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      78:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      7c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      80:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      84:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      88:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      8c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      90:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      94:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      98:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      9c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      a0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      a4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      a8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      ac:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      b0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      b4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      b8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      bc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      c0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      c4:	0c 94 20 0c 	jmp	0x1840	; 0x1840 <__vector_49>
      c8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      cc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      d0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      d4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      d8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      dc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      e0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      e4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      e8:	0c 94 7e 1d 	jmp	0x3afc	; 0x3afc <__vector_58>
      ec:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      f0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      f4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      f8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
      fc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     100:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     104:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     108:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     10c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     110:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     114:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     118:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     11c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     120:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     124:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     128:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     12c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     130:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     134:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     138:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     13c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     140:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     144:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     148:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     14c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     150:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     154:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     158:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     15c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     160:	0c 94 c2 1c 	jmp	0x3984	; 0x3984 <__vector_88>
     164:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     168:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     16c:	0c 94 20 1d 	jmp	0x3a40	; 0x3a40 <__vector_91>
     170:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     174:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     178:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     17c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     180:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     184:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     188:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     18c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     190:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     194:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     198:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     19c:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1a0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1a4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1a8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1ac:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1b0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1b4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1b8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1bc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1c0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1c4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1c8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1cc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1d0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1d4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1d8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1dc:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1e0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1e4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1e8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1ec:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1f0:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1f4:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1f8:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <__bad_interrupt>
     1fc:	f2 19       	sub	r31, r2
     1fe:	f5 19       	sub	r31, r5
     200:	f8 19       	sub	r31, r8
     202:	fb 19       	sub	r31, r11
     204:	fe 19       	sub	r31, r14
     206:	01 1a       	sub	r0, r17
     208:	03 1a       	sub	r0, r19
     20a:	14 1a       	sub	r1, r20
     20c:	1c 1a       	sub	r1, r28
     20e:	26 1a       	sub	r2, r22
     210:	24 1a       	sub	r2, r20

00000212 <__trampolines_start>:
     212:	0c 94 38 03 	jmp	0x670	; 0x670 <_ZN17task_EncoderMotor3runEv>
     216:	0c 94 1d 17 	jmp	0x2e3a	; 0x2e3a <_ZN14frt_text_queue7getcharEv>
     21a:	0c 94 d3 15 	jmp	0x2ba6	; 0x2ba6 <_ZN8frt_task12print_statusER8emstream>
     21e:	0c 94 24 1a 	jmp	0x3448	; 0x3448 <_ZN8emstreamlsE15ser_manipulator+0x82>
     222:	0c 94 01 1a 	jmp	0x3402	; 0x3402 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     226:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <_ZN14frt_text_queue14check_for_charEv>
     22a:	0c 94 f2 19 	jmp	0x33e4	; 0x33e4 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     22e:	0c 94 a4 0e 	jmp	0x1d48	; 0x1d48 <prvIdleTask>
     232:	0c 94 90 04 	jmp	0x920	; 0x920 <_ZN10task_Motor3runEv>
     236:	0c 94 d7 07 	jmp	0xfae	; 0xfae <_ZN9task_user3runEv>
     23a:	0c 94 97 19 	jmp	0x332e	; 0x332e <_ZN8emstream7getcharEv>
     23e:	0c 94 fe 18 	jmp	0x31fc	; 0x31fc <__cxa_pure_virtual>
     242:	0c 94 6f 06 	jmp	0xcde	; 0xcde <_ZN13task_Position3runEv>
     246:	0c 94 6a 1b 	jmp	0x36d4	; 0x36d4 <_ZN5rs23214check_for_charEv>
     24a:	0c 94 f8 19 	jmp	0x33f0	; 0x33f0 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     24e:	0c 94 14 1a 	jmp	0x3428	; 0x3428 <_ZN8emstreamlsE15ser_manipulator+0x62>
     252:	0c 94 9c 19 	jmp	0x3338	; 0x3338 <_ZN8emstream12transmit_nowEv>
     256:	0c 94 9d 19 	jmp	0x333a	; 0x333a <_ZN8emstream12clear_screenEv>
     25a:	0c 94 bb 03 	jmp	0x776	; 0x776 <_ZN20task_EncoderPendulum3runEv>
     25e:	0c 94 04 09 	jmp	0x1208	; 0x1208 <_ZN13task_Velocity3runEv>
     262:	0c 94 20 1b 	jmp	0x3640	; 0x3640 <_ZN5rs2327putcharEc>
     266:	0c 94 9a 19 	jmp	0x3334	; 0x3334 <_ZN8emstream14check_for_charEv>
     26a:	0c 94 95 19 	jmp	0x332a	; 0x332a <_ZN8emstream13ready_to_sendEv>
     26e:	0c 94 a1 1e 	jmp	0x3d42	; 0x3d42 <_GLOBAL__sub_I_counter>
     272:	0c 94 aa 02 	jmp	0x554	; 0x554 <_call_static_run_method>
     276:	0c 94 46 17 	jmp	0x2e8c	; 0x2e8c <_ZN14frt_text_queue7putcharEc>
     27a:	0c 94 7d 1b 	jmp	0x36fa	; 0x36fa <_ZN5rs23212clear_screenEv>
     27e:	0c 94 44 1b 	jmp	0x3688	; 0x3688 <_ZN5rs2327getcharEv>
     282:	0c 94 2b 04 	jmp	0x856	; 0x856 <_ZN18task_LimitSwitches3runEv>
     286:	0c 94 1c 1a 	jmp	0x3438	; 0x3438 <_ZN8emstreamlsE15ser_manipulator+0x72>
     28a:	0c 94 03 1a 	jmp	0x3406	; 0x3406 <_ZN8emstreamlsE15ser_manipulator+0x40>
     28e:	0c 94 26 1a 	jmp	0x344c	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
     292:	0c 94 13 03 	jmp	0x626	; 0x626 <_ZN10task_Angle3runEv>
     296:	0c 94 fe 19 	jmp	0x33fc	; 0x33fc <_ZN8emstreamlsE15ser_manipulator+0x36>
     29a:	0c 94 f5 19 	jmp	0x33ea	; 0x33ea <_ZN8emstreamlsE15ser_manipulator+0x24>
     29e:	0c 94 fb 19 	jmp	0x33f6	; 0x33f6 <_ZN8emstreamlsE15ser_manipulator+0x30>

000002a2 <__trampolines_end>:
     2a2:	2c 20       	and	r2, r12
     2a4:	54 43       	sbci	r21, 0x34	; 52
     2a6:	43 30       	cpi	r20, 0x03	; 3
     2a8:	43 43       	sbci	r20, 0x33	; 51
     2aa:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002ad <_ZZN9task_user11show_statusEvE3__c_3>:
     2ad:	2f 00                                               /.

000002af <_ZZN9task_user11show_statusEvE3__c_2>:
     2af:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002bd <_ZZN9task_user11show_statusEvE3__c_1>:
     2bd:	54 69 6d 65 3a 20 00                                Time: .

000002c4 <_ZZN9task_user11show_statusEvE3__c_0>:
     2c4:	44 65 63 20 20 36 20 32 30 31 37 00                 Dec  6 2017.

000002d0 <_ZZN9task_user11show_statusEvE3__c>:
     2d0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2e0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002ef <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2ef:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002fe <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2fe:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     30e:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000319 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     319:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     329:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000337 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     337:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     347:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     357:	6d 61 74 69 6f 6e 00                                mation.

0000035e <_ZZN9task_user18print_help_messageEvE3__c_6>:
     35e:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     36e:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000037f <_ZZN9task_user18print_help_messageEvE3__c_5>:
     37f:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     38f:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000397 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     397:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     3a7:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003b3 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3b3:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3c3:	68 65 20 41 56 52 00                                he AVR.

000003ca <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3ca:	20 68 65 6c 70 00                                    help.

000003d0 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3d0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3e0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003ef <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3ef:	1b 5b 33 30 6d 00                                   .[30m.

000003f5 <_ZZN9task_user18print_help_messageEvE3__c>:
     3f5:	1b 5b 34 36 6d 00                                   .[46m.

000003fb <_ZZN9task_user3runEvE3__c_3>:
     3fb:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     40b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000418 <_ZZN9task_user3runEvE3__c_2>:
     418:	3a 57 54 46 3f 00                                   :WTF?.

0000041e <_ZZN9task_user3runEvE3__c_1>:
     41e:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     42e:	65 00                                               e.

00000430 <_ZZN9task_user3runEvE3__c_0>:
     430:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000043e <_ZZN9task_user3runEvE3__c>:
     43e:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     44e:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

0000045c <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     45c:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000466 <_ZZN8frt_task15emergency_resetEvE3__c>:
     466:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000475 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     475:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     485:	61 73 6b 20 00                                      ask .

0000048a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     48a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000498 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     498:	20 63 72 65 61 74 65 64 00                           created.

000004a1 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     4a1:	54 61 73 6b 20 00                                   Task .

000004a7 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     4a7:	1b 5b 32 32 6d 00                                   .[22m.

000004ad <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4ad:	54 61 73 6b 3a 20 00                                Task: .

000004b4 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4b4:	1b 5b 31 6d 00                                      .[1m.

000004b9 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b9:	1b 5b 32 32 6d 00                                   .[22m.

000004bf <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4bf:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004ca <_ZZ17print_task_stacksP8emstreamE3__c>:
     4ca:	1b 5b 31 6d 00                                      .[1m.

000004cf <_ZZ15print_task_listP8emstreamE3__c_9>:
     4cf:	09 09 00                                            ...

000004d2 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4d2:	2f 00                                               /.

000004d4 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4d4:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004df <_ZZ15print_task_listP8emstreamE3__c_6>:
     4df:	09 2d 2d 2d 2d 00                                   .----.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4e5:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004f1 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4f1:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000502 <_ZZ15print_task_listP8emstreamE3__c_3>:
     502:	09 52 75 6e 73 00                                   .Runs.

00000508 <_ZZ15print_task_listP8emstreamE3__c_2>:
     508:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000514 <_ZZ15print_task_listP8emstreamE3__c_1>:
     514:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000525 <_ZZ15print_task_listP8emstreamE3__c_0>:
     525:	09 53 74 61 63 6b 00                                .Stack.

0000052c <_ZZ15print_task_listP8emstreamE3__c>:
     52c:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     537:	09 00                                               ..

00000539 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     539:	09 00                                               ..

0000053b <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     53b:	2f 00                                               /.

0000053d <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     53d:	09 00                                               ..

0000053f <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     53f:	09 00                                               ..

00000541 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     541:	1b 5b 32 32 6d 00                                   .[22m.

00000547 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     547:	1b 5b 31 6d 00                                      .[1m.

0000054c <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     54c:	1b 5b 31 6d 00                                      .[1m.

00000551 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     551:	20 20 00                                              .

00000554 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     554:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <_ZN8frt_task22_call_users_run_methodEPS_>

00000558 <__ctors_start>:
     558:	a1 1e       	adc	r10, r17

0000055a <__ctors_end>:
     55a:	11 24       	eor	r1, r1
     55c:	1f be       	out	0x3f, r1	; 63
     55e:	cf ef       	ldi	r28, 0xFF	; 255
     560:	cd bf       	out	0x3d, r28	; 61
     562:	df e3       	ldi	r29, 0x3F	; 63
     564:	de bf       	out	0x3e, r29	; 62
     566:	00 e0       	ldi	r16, 0x00	; 0
     568:	0c bf       	out	0x3c, r16	; 60
     56a:	18 be       	out	0x38, r1	; 56
     56c:	19 be       	out	0x39, r1	; 57
     56e:	1a be       	out	0x3a, r1	; 58
     570:	1b be       	out	0x3b, r1	; 59

00000572 <__do_copy_data>:
     572:	10 e2       	ldi	r17, 0x20	; 32
     574:	a0 e0       	ldi	r26, 0x00	; 0
     576:	b0 e2       	ldi	r27, 0x20	; 32
     578:	e6 ea       	ldi	r30, 0xA6	; 166
     57a:	f0 e4       	ldi	r31, 0x40	; 64
     57c:	00 e0       	ldi	r16, 0x00	; 0
     57e:	0b bf       	out	0x3b, r16	; 59
     580:	02 c0       	rjmp	.+4      	; 0x586 <__do_copy_data+0x14>
     582:	07 90       	elpm	r0, Z+
     584:	0d 92       	st	X+, r0
     586:	aa 3e       	cpi	r26, 0xEA	; 234
     588:	b1 07       	cpc	r27, r17
     58a:	d9 f7       	brne	.-10     	; 0x582 <__do_copy_data+0x10>
     58c:	1b be       	out	0x3b, r1	; 59

0000058e <__do_clear_bss>:
     58e:	21 e3       	ldi	r18, 0x31	; 49
     590:	aa ee       	ldi	r26, 0xEA	; 234
     592:	b0 e2       	ldi	r27, 0x20	; 32
     594:	01 c0       	rjmp	.+2      	; 0x598 <.do_clear_bss_start>

00000596 <.do_clear_bss_loop>:
     596:	1d 92       	st	X+, r1

00000598 <.do_clear_bss_start>:
     598:	a0 39       	cpi	r26, 0x90	; 144
     59a:	b2 07       	cpc	r27, r18
     59c:	e1 f7       	brne	.-8      	; 0x596 <.do_clear_bss_loop>

0000059e <__do_global_ctors>:
     59e:	12 e0       	ldi	r17, 0x02	; 2
     5a0:	cd ea       	ldi	r28, 0xAD	; 173
     5a2:	d2 e0       	ldi	r29, 0x02	; 2
     5a4:	00 e0       	ldi	r16, 0x00	; 0
     5a6:	06 c0       	rjmp	.+12     	; 0x5b4 <__do_global_ctors+0x16>
     5a8:	21 97       	sbiw	r28, 0x01	; 1
     5aa:	01 09       	sbc	r16, r1
     5ac:	80 2f       	mov	r24, r16
     5ae:	fe 01       	movw	r30, r28
     5b0:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <__tablejump2__>
     5b4:	cc 3a       	cpi	r28, 0xAC	; 172
     5b6:	d1 07       	cpc	r29, r17
     5b8:	80 e0       	ldi	r24, 0x00	; 0
     5ba:	08 07       	cpc	r16, r24
     5bc:	a9 f7       	brne	.-22     	; 0x5a8 <__do_global_ctors+0xa>
     5be:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <main>
     5c2:	0c 94 51 20 	jmp	0x40a2	; 0x40a2 <_exit>

000005c6 <__bad_interrupt>:
     5c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005ca <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
     5ca:	9c 01       	movw	r18, r24
     5cc:	93 2f       	mov	r25, r19
     5ce:	99 1f       	adc	r25, r25
     5d0:	99 27       	eor	r25, r25
     5d2:	99 1f       	adc	r25, r25
     5d4:	89 2f       	mov	r24, r25
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	81 50       	subi	r24, 0x01	; 1
     5da:	90 48       	sbci	r25, 0x80	; 128
     5dc:	43 2f       	mov	r20, r19
     5de:	40 95       	com	r20
     5e0:	44 1f       	adc	r20, r20
     5e2:	44 27       	eor	r20, r20
     5e4:	44 1f       	adc	r20, r20
     5e6:	fc 01       	movw	r30, r24
     5e8:	e2 1b       	sub	r30, r18
     5ea:	f3 0b       	sbc	r31, r19
     5ec:	51 e0       	ldi	r21, 0x01	; 1
     5ee:	e6 17       	cp	r30, r22
     5f0:	f7 07       	cpc	r31, r23
     5f2:	0c f0       	brlt	.+2      	; 0x5f6 <_ZN7satmath20signed_saturated_addEii+0x2c>
     5f4:	50 e0       	ldi	r21, 0x00	; 0
     5f6:	45 17       	cp	r20, r21
     5f8:	19 f0       	breq	.+6      	; 0x600 <_ZN7satmath20signed_saturated_addEii+0x36>
     5fa:	c9 01       	movw	r24, r18
     5fc:	86 0f       	add	r24, r22
     5fe:	97 1f       	adc	r25, r23
     600:	08 95       	ret

00000602 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     602:	81 15       	cp	r24, r1
     604:	20 e8       	ldi	r18, 0x80	; 128
     606:	92 07       	cpc	r25, r18
     608:	21 f4       	brne	.+8      	; 0x612 <_ZN7satmath20signed_saturated_mulEii+0x10>
     60a:	61 15       	cp	r22, r1
     60c:	20 e8       	ldi	r18, 0x80	; 128
     60e:	72 07       	cpc	r23, r18
     610:	29 f0       	breq	.+10     	; 0x61c <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     612:	9c 01       	movw	r18, r24
     614:	db 01       	movw	r26, r22
     616:	0e 94 8b 1f 	call	0x3f16	; 0x3f16 <__mulhisi3>
     61a:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     61c:	6f ef       	ldi	r22, 0xFF	; 255
     61e:	7f ef       	ldi	r23, 0xFF	; 255
     620:	8f ef       	ldi	r24, 0xFF	; 255
     622:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     624:	08 95       	ret

00000626 <_ZN10task_Angle3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void task_Angle::run (void)
{
     626:	cf 93       	push	r28
     628:	df 93       	push	r29
     62a:	00 d0       	rcall	.+0      	; 0x62c <_ZN10task_Angle3runEv+0x6>
     62c:	1f 92       	push	r1
     62e:	cd b7       	in	r28, 0x3d	; 61
     630:	de b7       	in	r29, 0x3e	; 62
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     632:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
     636:	69 83       	std	Y+1, r22	; 0x01
     638:	7a 83       	std	Y+2, r23	; 0x02
     63a:	8b 83       	std	Y+3, r24	; 0x03
     63c:	9c 83       	std	Y+4, r25	; 0x04
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     63e:	42 e1       	ldi	r20, 0x12	; 18
     640:	50 e0       	ldi	r21, 0x00	; 0
     642:	60 e0       	ldi	r22, 0x00	; 0
     644:	70 e0       	ldi	r23, 0x00	; 0
     646:	ce 01       	movw	r24, r28
     648:	01 96       	adiw	r24, 0x01	; 1
     64a:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelayUntil>
     64e:	f7 cf       	rjmp	.-18     	; 0x63e <_ZN10task_Angle3runEv+0x18>

00000650 <_ZN10task_AngleC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_Angle::task_Angle(const char* a_name,
     650:	0f 93       	push	r16
     652:	1f 93       	push	r17
     654:	cf 93       	push	r28
     656:	df 93       	push	r29
     658:	ec 01       	movw	r28, r24
size_t a_stack_size,
emstream* p_ser_dev
)

// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     65a:	0e 94 7e 14 	call	0x28fc	; 0x28fc <_ZN8frt_taskC1EPKchjP8emstream>
     65e:	8a e0       	ldi	r24, 0x0A	; 10
     660:	90 e2       	ldi	r25, 0x20	; 32
     662:	88 83       	st	Y, r24
     664:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	08 95       	ret

00000670 <_ZN17task_EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void task_EncoderMotor::run (void)
{ 
     670:	cf 93       	push	r28
     672:	df 93       	push	r29
     674:	00 d0       	rcall	.+0      	; 0x676 <_ZN17task_EncoderMotor3runEv+0x6>
     676:	1f 92       	push	r1
     678:	cd b7       	in	r28, 0x3d	; 61
     67a:	de b7       	in	r29, 0x3e	; 62
     67c:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     67e:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
     682:	69 83       	std	Y+1, r22	; 0x01
     684:	7a 83       	std	Y+2, r23	; 0x02
     686:	8b 83       	std	Y+3, r24	; 0x03
     688:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     68a:	e0 e8       	ldi	r30, 0x80	; 128
     68c:	f6 e0       	ldi	r31, 0x06	; 6
     68e:	8c e0       	ldi	r24, 0x0C	; 12
     690:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     692:	82 89       	ldd	r24, Z+18	; 0x12
     694:	83 60       	ori	r24, 0x03	; 3
     696:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     698:	83 89       	ldd	r24, Z+19	; 0x13
     69a:	83 60       	ori	r24, 0x03	; 3
     69c:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     69e:	e0 e8       	ldi	r30, 0x80	; 128
     6a0:	f1 e0       	ldi	r31, 0x01	; 1
     6a2:	82 e7       	ldi	r24, 0x72	; 114
     6a4:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     6a6:	89 e0       	ldi	r24, 0x09	; 9
     6a8:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     6aa:	e0 e0       	ldi	r30, 0x00	; 0
     6ac:	f9 e0       	ldi	r31, 0x09	; 9
     6ae:	88 e6       	ldi	r24, 0x68	; 104
     6b0:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     6b2:	8f ef       	ldi	r24, 0xFF	; 255
     6b4:	9f ef       	ldi	r25, 0xFF	; 255
     6b6:	86 a3       	std	Z+38, r24	; 0x26
     6b8:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     6ba:	81 e0       	ldi	r24, 0x01	; 1
     6bc:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     6be:	0f 2e       	mov	r0, r31
     6c0:	a1 2c       	mov	r10, r1
     6c2:	f9 e0       	ldi	r31, 0x09	; 9
     6c4:	bf 2e       	mov	r11, r31
     6c6:	f0 2d       	mov	r31, r0
     6c8:	f5 01       	movw	r30, r10
     6ca:	00 a1       	ldd	r16, Z+32	; 0x20
     6cc:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     6ce:	0f b6       	in	r0, 0x3f	; 63
     6d0:	f8 94       	cli
     6d2:	0f 92       	push	r0
			the_data = new_data;
     6d4:	c8 01       	movw	r24, r16
     6d6:	01 2e       	mov	r0, r17
     6d8:	00 0c       	add	r0, r0
     6da:	aa 0b       	sbc	r26, r26
     6dc:	bb 0b       	sbc	r27, r27
     6de:	ac 01       	movw	r20, r24
     6e0:	bd 01       	movw	r22, r26
     6e2:	44 0f       	add	r20, r20
     6e4:	55 1f       	adc	r21, r21
     6e6:	66 1f       	adc	r22, r22
     6e8:	77 1f       	adc	r23, r23
     6ea:	3a 01       	movw	r6, r20
     6ec:	4b 01       	movw	r8, r22
     6ee:	68 0e       	add	r6, r24
     6f0:	79 1e       	adc	r7, r25
     6f2:	8a 1e       	adc	r8, r26
     6f4:	9b 1e       	adc	r9, r27
     6f6:	c4 01       	movw	r24, r8
     6f8:	b3 01       	movw	r22, r6
     6fa:	24 e6       	ldi	r18, 0x64	; 100
     6fc:	30 e0       	ldi	r19, 0x00	; 0
     6fe:	40 e0       	ldi	r20, 0x00	; 0
     700:	50 e0       	ldi	r21, 0x00	; 0
     702:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <__divmodsi4>
     706:	20 93 7c 31 	sts	0x317C, r18	; 0x80317c <linear_position>
     70a:	30 93 7d 31 	sts	0x317D, r19	; 0x80317d <linear_position+0x1>
			portEXIT_CRITICAL ();
     70e:	0f 90       	pop	r0
     710:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	0f 92       	push	r0
			the_data = new_data;
     718:	c8 01       	movw	r24, r16
     71a:	8c 19       	sub	r24, r12
     71c:	9d 09       	sbc	r25, r13
     71e:	80 93 7a 31 	sts	0x317A, r24	; 0x80317a <thdMotor>
     722:	90 93 7b 31 	sts	0x317B, r25	; 0x80317b <thdMotor+0x1>
			portEXIT_CRITICAL ();
     726:	0f 90       	pop	r0
     728:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     72a:	f7 01       	movw	r30, r14
     72c:	86 85       	ldd	r24, Z+14	; 0x0e
     72e:	97 85       	ldd	r25, Z+15	; 0x0f
     730:	a0 89       	ldd	r26, Z+16	; 0x10
     732:	b1 89       	ldd	r27, Z+17	; 0x11
     734:	01 96       	adiw	r24, 0x01	; 1
     736:	a1 1d       	adc	r26, r1
     738:	b1 1d       	adc	r27, r1
     73a:	86 87       	std	Z+14, r24	; 0x0e
     73c:	97 87       	std	Z+15, r25	; 0x0f
     73e:	a0 8b       	std	Z+16, r26	; 0x10
     740:	b1 8b       	std	Z+17, r27	; 0x11
     742:	41 e0       	ldi	r20, 0x01	; 1
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	60 e0       	ldi	r22, 0x00	; 0
     748:	70 e0       	ldi	r23, 0x00	; 0
     74a:	ce 01       	movw	r24, r28
     74c:	01 96       	adiw	r24, 0x01	; 1
     74e:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     752:	68 01       	movw	r12, r16
     754:	b9 cf       	rjmp	.-142    	; 0x6c8 <_ZN17task_EncoderMotor3runEv+0x58>

00000756 <_ZN17task_EncoderMotorC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_EncoderMotor::task_EncoderMotor(const char* a_name,
     756:	0f 93       	push	r16
     758:	1f 93       	push	r17
     75a:	cf 93       	push	r28
     75c:	df 93       	push	r29
     75e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     760:	0e 94 7e 14 	call	0x28fc	; 0x28fc <_ZN8frt_taskC1EPKchjP8emstream>
     764:	82 e1       	ldi	r24, 0x12	; 18
     766:	90 e2       	ldi	r25, 0x20	; 32
     768:	88 83       	st	Y, r24
     76a:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	1f 91       	pop	r17
     772:	0f 91       	pop	r16
     774:	08 95       	ret

00000776 <_ZN20task_EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void task_EncoderPendulum::run(void){
     776:	cf 93       	push	r28
     778:	df 93       	push	r29
     77a:	00 d0       	rcall	.+0      	; 0x77c <_ZN20task_EncoderPendulum3runEv+0x6>
     77c:	1f 92       	push	r1
     77e:	cd b7       	in	r28, 0x3d	; 61
     780:	de b7       	in	r29, 0x3e	; 62
     782:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     784:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
     788:	69 83       	std	Y+1, r22	; 0x01
     78a:	7a 83       	std	Y+2, r23	; 0x02
     78c:	8b 83       	std	Y+3, r24	; 0x03
     78e:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     790:	e0 e8       	ldi	r30, 0x80	; 128
     792:	f6 e0       	ldi	r31, 0x06	; 6
     794:	83 e0       	ldi	r24, 0x03	; 3
     796:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     798:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     79a:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     79c:	e0 e8       	ldi	r30, 0x80	; 128
     79e:	f1 e0       	ldi	r31, 0x01	; 1
     7a0:	80 e7       	ldi	r24, 0x70	; 112
     7a2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     7a4:	89 e0       	ldi	r24, 0x09	; 9
     7a6:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     7a8:	e0 e4       	ldi	r30, 0x40	; 64
     7aa:	f8 e0       	ldi	r31, 0x08	; 8
     7ac:	8a e6       	ldi	r24, 0x6A	; 106
     7ae:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     7b0:	80 ea       	ldi	r24, 0xA0	; 160
     7b2:	95 e0       	ldi	r25, 0x05	; 5
     7b4:	86 a3       	std	Z+38, r24	; 0x26
     7b6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     7b8:	81 e0       	ldi	r24, 0x01	; 1
     7ba:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     7bc:	68 94       	set
     7be:	ee 24       	eor	r14, r14
     7c0:	e6 f8       	bld	r14, 6
     7c2:	ff 24       	eor	r15, r15
     7c4:	f3 f8       	bld	r15, 3
     7c6:	f7 01       	movw	r30, r14
     7c8:	a0 a1       	ldd	r26, Z+32	; 0x20
     7ca:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7cc:	0f b6       	in	r0, 0x3f	; 63
     7ce:	f8 94       	cli
     7d0:	0f 92       	push	r0
			the_data = new_data;
     7d2:	24 e6       	ldi	r18, 0x64	; 100
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	0e 94 a2 1f 	call	0x3f44	; 0x3f44 <__usmulhisi3>
     7da:	4b 01       	movw	r8, r22
     7dc:	5c 01       	movw	r10, r24
     7de:	99 23       	and	r25, r25
     7e0:	2c f4       	brge	.+10     	; 0x7ec <_ZN20task_EncoderPendulum3runEv+0x76>
     7e2:	f3 e0       	ldi	r31, 0x03	; 3
     7e4:	8f 0e       	add	r8, r31
     7e6:	91 1c       	adc	r9, r1
     7e8:	a1 1c       	adc	r10, r1
     7ea:	b1 1c       	adc	r11, r1
     7ec:	d5 01       	movw	r26, r10
     7ee:	c4 01       	movw	r24, r8
     7f0:	b5 95       	asr	r27
     7f2:	a7 95       	ror	r26
     7f4:	97 95       	ror	r25
     7f6:	87 95       	ror	r24
     7f8:	b5 95       	asr	r27
     7fa:	a7 95       	ror	r26
     7fc:	97 95       	ror	r25
     7fe:	87 95       	ror	r24
     800:	80 93 78 31 	sts	0x3178, r24	; 0x803178 <thPendulum>
     804:	90 93 79 31 	sts	0x3179, r25	; 0x803179 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     808:	0f 90       	pop	r0
     80a:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     80c:	f8 01       	movw	r30, r16
     80e:	86 85       	ldd	r24, Z+14	; 0x0e
     810:	97 85       	ldd	r25, Z+15	; 0x0f
     812:	a0 89       	ldd	r26, Z+16	; 0x10
     814:	b1 89       	ldd	r27, Z+17	; 0x11
     816:	01 96       	adiw	r24, 0x01	; 1
     818:	a1 1d       	adc	r26, r1
     81a:	b1 1d       	adc	r27, r1
     81c:	86 87       	std	Z+14, r24	; 0x0e
     81e:	97 87       	std	Z+15, r25	; 0x0f
     820:	a0 8b       	std	Z+16, r26	; 0x10
     822:	b1 8b       	std	Z+17, r27	; 0x11
     824:	43 e0       	ldi	r20, 0x03	; 3
     826:	50 e0       	ldi	r21, 0x00	; 0
     828:	60 e0       	ldi	r22, 0x00	; 0
     82a:	70 e0       	ldi	r23, 0x00	; 0
     82c:	ce 01       	movw	r24, r28
     82e:	01 96       	adiw	r24, 0x01	; 1
     830:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelayUntil>
     834:	c8 cf       	rjmp	.-112    	; 0x7c6 <_ZN20task_EncoderPendulum3runEv+0x50>

00000836 <_ZN20task_EncoderPendulumC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_EncoderPendulum::task_EncoderPendulum(const char* a_name,
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     840:	0e 94 7e 14 	call	0x28fc	; 0x28fc <_ZN8frt_taskC1EPKchjP8emstream>
     844:	8a e1       	ldi	r24, 0x1A	; 26
     846:	90 e2       	ldi	r25, 0x20	; 32
     848:	88 83       	st	Y, r24
     84a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	08 95       	ret

00000856 <_ZN18task_LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void task_LimitSwitches::run(void){
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	00 d0       	rcall	.+0      	; 0x85c <_ZN18task_LimitSwitches3runEv+0x6>
     85c:	1f 92       	push	r1
     85e:	cd b7       	in	r28, 0x3d	; 61
     860:	de b7       	in	r29, 0x3e	; 62
     862:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     864:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
     868:	69 83       	std	Y+1, r22	; 0x01
     86a:	7a 83       	std	Y+2, r23	; 0x02
     86c:	8b 83       	std	Y+3, r24	; 0x03
     86e:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     870:	e0 e6       	ldi	r30, 0x60	; 96
     872:	f6 e0       	ldi	r31, 0x06	; 6
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     878:	84 e0       	ldi	r24, 0x04	; 4
     87a:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     87c:	88 e1       	ldi	r24, 0x18	; 24
     87e:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     880:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     882:	08 e6       	ldi	r16, 0x68	; 104
     884:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     886:	dd 24       	eor	r13, r13
     888:	d3 94       	inc	r13
     88a:	f8 01       	movw	r30, r16
     88c:	80 81       	ld	r24, Z
     88e:	80 fd       	sbrc	r24, 0
     890:	08 c0       	rjmp	.+16     	; 0x8a2 <_ZN18task_LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	f8 94       	cli
     896:	0f 92       	push	r0
			the_data = new_data;
     898:	d0 92 77 31 	sts	0x3177, r13	; 0x803177 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     89c:	0f 90       	pop	r0
     89e:	0f be       	out	0x3f, r0	; 63
     8a0:	07 c0       	rjmp	.+14     	; 0x8b0 <_ZN18task_LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	f8 94       	cli
     8a6:	0f 92       	push	r0
			the_data = new_data;
     8a8:	10 92 77 31 	sts	0x3177, r1	; 0x803177 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     8ac:	0f 90       	pop	r0
     8ae:	0f be       	out	0x3f, r0	; 63
			*/

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     8b0:	f8 01       	movw	r30, r16
     8b2:	80 81       	ld	r24, Z
     8b4:	82 fd       	sbrc	r24, 2
     8b6:	08 c0       	rjmp	.+16     	; 0x8c8 <_ZN18task_LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8b8:	0f b6       	in	r0, 0x3f	; 63
     8ba:	f8 94       	cli
     8bc:	0f 92       	push	r0
			the_data = new_data;
     8be:	d0 92 76 31 	sts	0x3176, r13	; 0x803176 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     8c2:	0f 90       	pop	r0
     8c4:	0f be       	out	0x3f, r0	; 63
     8c6:	07 c0       	rjmp	.+14     	; 0x8d6 <_ZN18task_LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	f8 94       	cli
     8cc:	0f 92       	push	r0
			the_data = new_data;
     8ce:	10 92 76 31 	sts	0x3176, r1	; 0x803176 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     8d2:	0f 90       	pop	r0
     8d4:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     8d6:	f7 01       	movw	r30, r14
     8d8:	86 85       	ldd	r24, Z+14	; 0x0e
     8da:	97 85       	ldd	r25, Z+15	; 0x0f
     8dc:	a0 89       	ldd	r26, Z+16	; 0x10
     8de:	b1 89       	ldd	r27, Z+17	; 0x11
     8e0:	01 96       	adiw	r24, 0x01	; 1
     8e2:	a1 1d       	adc	r26, r1
     8e4:	b1 1d       	adc	r27, r1
     8e6:	86 87       	std	Z+14, r24	; 0x0e
     8e8:	97 87       	std	Z+15, r25	; 0x0f
     8ea:	a0 8b       	std	Z+16, r26	; 0x10
     8ec:	b1 8b       	std	Z+17, r27	; 0x11
     8ee:	43 e0       	ldi	r20, 0x03	; 3
     8f0:	50 e0       	ldi	r21, 0x00	; 0
     8f2:	60 e0       	ldi	r22, 0x00	; 0
     8f4:	70 e0       	ldi	r23, 0x00	; 0
     8f6:	ce 01       	movw	r24, r28
     8f8:	01 96       	adiw	r24, 0x01	; 1
     8fa:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelayUntil>
     8fe:	c5 cf       	rjmp	.-118    	; 0x88a <_ZN18task_LimitSwitches3runEv+0x34>

00000900 <_ZN18task_LimitSwitchesC1EPKchjP8emstream>:
#include "task_LimitSwitches.h"				// Header for Limit Switches
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

task_LimitSwitches::task_LimitSwitches(const char* a_name,
     900:	0f 93       	push	r16
     902:	1f 93       	push	r17
     904:	cf 93       	push	r28
     906:	df 93       	push	r29
     908:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     90a:	0e 94 7e 14 	call	0x28fc	; 0x28fc <_ZN8frt_taskC1EPKchjP8emstream>
     90e:	82 e2       	ldi	r24, 0x22	; 34
     910:	90 e2       	ldi	r25, 0x20	; 32
     912:	88 83       	st	Y, r24
     914:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	08 95       	ret

00000920 <_ZN10task_Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void task_Motor::run(void){
     920:	cf 93       	push	r28
     922:	df 93       	push	r29
     924:	cd b7       	in	r28, 0x3d	; 61
     926:	de b7       	in	r29, 0x3e	; 62
     928:	66 97       	sbiw	r28, 0x16	; 22
     92a:	cd bf       	out	0x3d, r28	; 61
     92c:	de bf       	out	0x3e, r29	; 62
     92e:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     930:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
     934:	69 83       	std	Y+1, r22	; 0x01
     936:	7a 83       	std	Y+2, r23	; 0x02
     938:	8b 83       	std	Y+3, r24	; 0x03
     93a:	9c 83       	std	Y+4, r25	; 0x04

	dt = 5; // [ms]
     93c:	f8 01       	movw	r30, r16
     93e:	fe 96       	adiw	r30, 0x3e	; 62
     940:	85 e0       	ldi	r24, 0x05	; 5
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	a0 e0       	ldi	r26, 0x00	; 0
     946:	b0 e0       	ldi	r27, 0x00	; 0
     948:	80 83       	st	Z, r24
     94a:	91 83       	std	Z+1, r25	; 0x01
     94c:	a2 83       	std	Z+2, r26	; 0x02
     94e:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     950:	81 e0       	ldi	r24, 0x01	; 1
     952:	90 e0       	ldi	r25, 0x00	; 0
     954:	f8 01       	movw	r30, r16
     956:	84 af       	std	Z+60, r24	; 0x3c
     958:	95 af       	std	Z+61, r25	; 0x3d
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 7;
     95a:	98 01       	movw	r18, r16
     95c:	28 5b       	subi	r18, 0xB8	; 184
     95e:	3f 4f       	sbci	r19, 0xFF	; 255
     960:	2d 83       	std	Y+5, r18	; 0x05
     962:	3e 83       	std	Y+6, r19	; 0x06
     964:	37 e0       	ldi	r19, 0x07	; 7
     966:	3d 8b       	std	Y+21, r19	; 0x15
     968:	1e 8a       	std	Y+22, r1	; 0x16
		_Ki = .7*256;
     96a:	a8 01       	movw	r20, r16
     96c:	44 5b       	subi	r20, 0xB4	; 180
     96e:	5f 4f       	sbci	r21, 0xFF	; 255
     970:	4f 83       	std	Y+7, r20	; 0x07
     972:	58 87       	std	Y+8, r21	; 0x08
		_Kd = 0;
     974:	c8 01       	movw	r24, r16
     976:	86 5b       	subi	r24, 0xB6	; 182
     978:	9f 4f       	sbci	r25, 0xFF	; 255
     97a:	8f 87       	std	Y+15, r24	; 0x0f
     97c:	98 8b       	std	Y+16, r25	; 0x10
		antiwind_gain = .95*256;
     97e:	ec 59       	subi	r30, 0x9C	; 156
     980:	ff 4f       	sbci	r31, 0xFF	; 255
     982:	e9 87       	std	Y+9, r30	; 0x09
     984:	fa 87       	std	Y+10, r31	; 0x0a
		
		_max = 1600;
     986:	98 01       	movw	r18, r16
     988:	2c 5b       	subi	r18, 0xBC	; 188
     98a:	3f 4f       	sbci	r19, 0xFF	; 255
     98c:	2b 87       	std	Y+11, r18	; 0x0b
     98e:	3c 87       	std	Y+12, r19	; 0x0c
		_min = -1600;
     990:	46 50       	subi	r20, 0x06	; 6
     992:	51 09       	sbc	r21, r1
     994:	4d 87       	std	Y+13, r20	; 0x0d
     996:	5e 87       	std	Y+14, r21	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     998:	42 96       	adiw	r24, 0x12	; 18
     99a:	89 8b       	std	Y+17, r24	; 0x11
     99c:	9a 8b       	std	Y+18, r25	; 0x12

		// Integral term
		error_int = error - antiwind_correct;
     99e:	18 01       	movw	r2, r16
     9a0:	96 e6       	ldi	r25, 0x66	; 102
     9a2:	29 0e       	add	r2, r25
     9a4:	31 1c       	adc	r3, r1
     9a6:	34 96       	adiw	r30, 0x04	; 4
     9a8:	eb 8b       	std	Y+19, r30	; 0x13
     9aa:	fc 8b       	std	Y+20, r31	; 0x14
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     9ac:	48 01       	movw	r8, r16
     9ae:	fe e3       	ldi	r31, 0x3E	; 62
     9b0:	8f 0e       	add	r8, r31
     9b2:	91 1c       	adc	r9, r1
     9b4:	58 01       	movw	r10, r16
     9b6:	20 e5       	ldi	r18, 0x50	; 80
     9b8:	a2 0e       	add	r10, r18
     9ba:	b1 1c       	adc	r11, r1

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);

		output_correct = output;
     9bc:	68 01       	movw	r12, r16
     9be:	3e e5       	ldi	r19, 0x5E	; 94
     9c0:	c3 0e       	add	r12, r19
     9c2:	d1 1c       	adc	r13, r1
	dt = 5; // [ms]
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     9c4:	f8 01       	movw	r30, r16
     9c6:	86 85       	ldd	r24, Z+14	; 0x0e
     9c8:	97 85       	ldd	r25, Z+15	; 0x0f
     9ca:	a0 89       	ldd	r26, Z+16	; 0x10
     9cc:	b1 89       	ldd	r27, Z+17	; 0x11
     9ce:	01 96       	adiw	r24, 0x01	; 1
     9d0:	a1 1d       	adc	r26, r1
     9d2:	b1 1d       	adc	r27, r1
     9d4:	86 87       	std	Z+14, r24	; 0x0e
     9d6:	97 87       	std	Z+15, r25	; 0x0f
     9d8:	a0 8b       	std	Z+16, r26	; 0x10
     9da:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
		omegam_set = 100; // [ticks/ms]
     9dc:	24 e6       	ldi	r18, 0x64	; 100
     9de:	30 e0       	ldi	r19, 0x00	; 0
     9e0:	22 8f       	std	Z+26, r18	; 0x1a
     9e2:	33 8f       	std	Z+27, r19	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     9e4:	0f b6       	in	r0, 0x3f	; 63
     9e6:	f8 94       	cli
     9e8:	0f 92       	push	r0
			temporary_copy = the_data;
     9ea:	80 91 7a 31 	lds	r24, 0x317A	; 0x80317a <thdMotor>
     9ee:	90 91 7b 31 	lds	r25, 0x317B	; 0x80317b <thdMotor+0x1>
			portEXIT_CRITICAL ();
     9f2:	0f 90       	pop	r0
     9f4:	0f be       	out	0x3f, r0	; 63

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     9f6:	86 8f       	std	Z+30, r24	; 0x1e
     9f8:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 7;
     9fa:	4d 89       	ldd	r20, Y+21	; 0x15
     9fc:	ed 81       	ldd	r30, Y+5	; 0x05
     9fe:	fe 81       	ldd	r31, Y+6	; 0x06
     a00:	40 83       	st	Z, r20
     a02:	5e 89       	ldd	r21, Y+22	; 0x16
     a04:	51 83       	std	Z+1, r21	; 0x01
		_Ki = .7*256;
     a06:	43 eb       	ldi	r20, 0xB3	; 179
     a08:	50 e0       	ldi	r21, 0x00	; 0
     a0a:	ef 81       	ldd	r30, Y+7	; 0x07
     a0c:	f8 85       	ldd	r31, Y+8	; 0x08
     a0e:	40 83       	st	Z, r20
     a10:	51 83       	std	Z+1, r21	; 0x01
		_Kd = 0;
     a12:	ef 85       	ldd	r30, Y+15	; 0x0f
     a14:	f8 89       	ldd	r31, Y+16	; 0x10
     a16:	10 82       	st	Z, r1
     a18:	11 82       	std	Z+1, r1	; 0x01
		antiwind_gain = .95*256;
     a1a:	43 ef       	ldi	r20, 0xF3	; 243
     a1c:	50 e0       	ldi	r21, 0x00	; 0
     a1e:	e9 85       	ldd	r30, Y+9	; 0x09
     a20:	fa 85       	ldd	r31, Y+10	; 0x0a
     a22:	40 83       	st	Z, r20
     a24:	51 83       	std	Z+1, r21	; 0x01
		
		_max = 1600;
     a26:	40 e4       	ldi	r20, 0x40	; 64
     a28:	56 e0       	ldi	r21, 0x06	; 6
     a2a:	eb 85       	ldd	r30, Y+11	; 0x0b
     a2c:	fc 85       	ldd	r31, Y+12	; 0x0c
     a2e:	40 83       	st	Z, r20
     a30:	51 83       	std	Z+1, r21	; 0x01
		_min = -1600;
     a32:	40 ec       	ldi	r20, 0xC0	; 192
     a34:	59 ef       	ldi	r21, 0xF9	; 249
     a36:	ed 85       	ldd	r30, Y+13	; 0x0d
     a38:	fe 85       	ldd	r31, Y+14	; 0x0e
     a3a:	40 83       	st	Z, r20
     a3c:	51 83       	std	Z+1, r21	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     a3e:	79 01       	movw	r14, r18
     a40:	e8 1a       	sub	r14, r24
     a42:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     a44:	b7 01       	movw	r22, r14
     a46:	87 e0       	ldi	r24, 0x07	; 7
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	0e 94 01 03 	call	0x602	; 0x602 <_ZN7satmath20signed_saturated_mulEii>
     a4e:	2b 01       	movw	r4, r22
     a50:	3c 01       	movw	r6, r24
     a52:	e9 89       	ldd	r30, Y+17	; 0x11
     a54:	fa 89       	ldd	r31, Y+18	; 0x12
     a56:	60 83       	st	Z, r22
     a58:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     a5a:	f1 01       	movw	r30, r2
     a5c:	80 81       	ld	r24, Z
     a5e:	91 81       	ldd	r25, Z+1	; 0x01
     a60:	97 01       	movw	r18, r14
     a62:	28 1b       	sub	r18, r24
     a64:	39 0b       	sbc	r19, r25
     a66:	c9 01       	movw	r24, r18
     a68:	eb 89       	ldd	r30, Y+19	; 0x13
     a6a:	fc 89       	ldd	r31, Y+20	; 0x14
     a6c:	20 83       	st	Z, r18
     a6e:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     a70:	ef 81       	ldd	r30, Y+7	; 0x07
     a72:	f8 85       	ldd	r31, Y+8	; 0x08
     a74:	20 81       	ld	r18, Z
     a76:	31 81       	ldd	r19, Z+1	; 0x01
     a78:	82 9f       	mul	r24, r18
     a7a:	d0 01       	movw	r26, r0
     a7c:	83 9f       	mul	r24, r19
     a7e:	b0 0d       	add	r27, r0
     a80:	92 9f       	mul	r25, r18
     a82:	b0 0d       	add	r27, r0
     a84:	11 24       	eor	r1, r1
     a86:	f8 01       	movw	r30, r16
     a88:	e6 59       	subi	r30, 0x96	; 150
     a8a:	ff 4f       	sbci	r31, 0xFF	; 255
     a8c:	a0 83       	st	Z, r26
     a8e:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     a90:	f4 01       	movw	r30, r8
     a92:	20 81       	ld	r18, Z
     a94:	31 81       	ldd	r19, Z+1	; 0x01
     a96:	42 81       	ldd	r20, Z+2	; 0x02
     a98:	53 81       	ldd	r21, Z+3	; 0x03
     a9a:	0e 94 b4 1f 	call	0x3f68	; 0x3f68 <__mulshisi3>
     a9e:	9b 01       	movw	r18, r22
     aa0:	ac 01       	movw	r20, r24
     aa2:	99 23       	and	r25, r25
     aa4:	24 f4       	brge	.+8      	; 0xaae <_ZN10task_Motor3runEv+0x18e>
     aa6:	21 50       	subi	r18, 0x01	; 1
     aa8:	3f 4f       	sbci	r19, 0xFF	; 255
     aaa:	4f 4f       	sbci	r20, 0xFF	; 255
     aac:	5f 4f       	sbci	r21, 0xFF	; 255
     aae:	bb 27       	eor	r27, r27
     ab0:	57 fd       	sbrc	r21, 7
     ab2:	ba 95       	dec	r27
     ab4:	a5 2f       	mov	r26, r21
     ab6:	94 2f       	mov	r25, r20
     ab8:	83 2f       	mov	r24, r19
     aba:	f5 01       	movw	r30, r10
     abc:	40 81       	ld	r20, Z
     abe:	51 81       	ldd	r21, Z+1	; 0x01
     ac0:	62 81       	ldd	r22, Z+2	; 0x02
     ac2:	73 81       	ldd	r23, Z+3	; 0x03
     ac4:	84 0f       	add	r24, r20
     ac6:	95 1f       	adc	r25, r21
     ac8:	a6 1f       	adc	r26, r22
     aca:	b7 1f       	adc	r27, r23
		if(_integral < 1000000000)
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
     acc:	81 30       	cpi	r24, 0x01	; 1
     ace:	fa ec       	ldi	r31, 0xCA	; 202
     ad0:	9f 07       	cpc	r25, r31
     ad2:	fa e9       	ldi	r31, 0x9A	; 154
     ad4:	af 07       	cpc	r26, r31
     ad6:	fb e3       	ldi	r31, 0x3B	; 59
     ad8:	bf 07       	cpc	r27, r31
     ada:	34 f4       	brge	.+12     	; 0xae8 <_ZN10task_Motor3runEv+0x1c8>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     adc:	f5 01       	movw	r30, r10
     ade:	80 83       	st	Z, r24
     ae0:	91 83       	std	Z+1, r25	; 0x01
     ae2:	a2 83       	std	Z+2, r26	; 0x02
     ae4:	b3 83       	std	Z+3, r27	; 0x03
     ae6:	09 c0       	rjmp	.+18     	; 0xafa <_ZN10task_Motor3runEv+0x1da>
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
		{
			_integral = 1000000000;
     ae8:	80 e0       	ldi	r24, 0x00	; 0
     aea:	9a ec       	ldi	r25, 0xCA	; 202
     aec:	aa e9       	ldi	r26, 0x9A	; 154
     aee:	bb e3       	ldi	r27, 0x3B	; 59
     af0:	f5 01       	movw	r30, r10
     af2:	80 83       	st	Z, r24
     af4:	91 83       	std	Z+1, r25	; 0x01
     af6:	a2 83       	std	Z+2, r26	; 0x02
     af8:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     afa:	f5 01       	movw	r30, r10
     afc:	60 81       	ld	r22, Z
     afe:	71 81       	ldd	r23, Z+1	; 0x01
     b00:	c2 01       	movw	r24, r4
     b02:	0e 94 e5 02 	call	0x5ca	; 0x5ca <_ZN7satmath20signed_saturated_addEii>
     b06:	f8 01       	movw	r30, r16
     b08:	e0 5a       	subi	r30, 0xA0	; 160
     b0a:	ff 4f       	sbci	r31, 0xFF	; 255
     b0c:	80 83       	st	Z, r24
     b0e:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     b10:	f6 01       	movw	r30, r12
     b12:	80 83       	st	Z, r24
     b14:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     b16:	eb 85       	ldd	r30, Y+11	; 0x0b
     b18:	fc 85       	ldd	r31, Y+12	; 0x0c
     b1a:	20 81       	ld	r18, Z
     b1c:	31 81       	ldd	r19, Z+1	; 0x01
     b1e:	28 17       	cp	r18, r24
     b20:	39 07       	cpc	r19, r25
     b22:	24 f4       	brge	.+8      	; 0xb2c <_ZN10task_Motor3runEv+0x20c>
		output_correct = _max;
     b24:	f6 01       	movw	r30, r12
     b26:	20 83       	st	Z, r18
     b28:	31 83       	std	Z+1, r19	; 0x01
     b2a:	0a c0       	rjmp	.+20     	; 0xb40 <_ZN10task_Motor3runEv+0x220>
		else if( output_correct < _min )
     b2c:	ed 85       	ldd	r30, Y+13	; 0x0d
     b2e:	fe 85       	ldd	r31, Y+14	; 0x0e
     b30:	20 81       	ld	r18, Z
     b32:	31 81       	ldd	r19, Z+1	; 0x01
     b34:	82 17       	cp	r24, r18
     b36:	93 07       	cpc	r25, r19
     b38:	1c f4       	brge	.+6      	; 0xb40 <_ZN10task_Motor3runEv+0x220>
		output_correct = _min;
     b3a:	f6 01       	movw	r30, r12
     b3c:	20 83       	st	Z, r18
     b3e:	31 83       	std	Z+1, r19	; 0x01

		// Save error to previous error
		_pre_error = error;
     b40:	f8 01       	movw	r30, r16
     b42:	e2 5b       	subi	r30, 0xB2	; 178
     b44:	ff 4f       	sbci	r31, 0xFF	; 255
     b46:	e0 82       	st	Z, r14
     b48:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     b4a:	f6 01       	movw	r30, r12
     b4c:	20 81       	ld	r18, Z
     b4e:	31 81       	ldd	r19, Z+1	; 0x01
     b50:	82 1b       	sub	r24, r18
     b52:	93 0b       	sbc	r25, r19
     b54:	f8 01       	movw	r30, r16
     b56:	ee 59       	subi	r30, 0x9E	; 158
     b58:	ff 4f       	sbci	r31, 0xFF	; 255
     b5a:	80 83       	st	Z, r24
     b5c:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     b5e:	e9 85       	ldd	r30, Y+9	; 0x09
     b60:	fa 85       	ldd	r31, Y+10	; 0x0a
     b62:	40 81       	ld	r20, Z
     b64:	51 81       	ldd	r21, Z+1	; 0x01
     b66:	84 9f       	mul	r24, r20
     b68:	90 01       	movw	r18, r0
     b6a:	85 9f       	mul	r24, r21
     b6c:	30 0d       	add	r19, r0
     b6e:	94 9f       	mul	r25, r20
     b70:	30 0d       	add	r19, r0
     b72:	11 24       	eor	r1, r1
     b74:	33 23       	and	r19, r19
     b76:	14 f4       	brge	.+4      	; 0xb7c <_ZN10task_Motor3runEv+0x25c>
     b78:	21 50       	subi	r18, 0x01	; 1
     b7a:	3f 4f       	sbci	r19, 0xFF	; 255
     b7c:	83 2f       	mov	r24, r19
     b7e:	88 0f       	add	r24, r24
     b80:	88 0b       	sbc	r24, r24
     b82:	f1 01       	movw	r30, r2
     b84:	30 83       	st	Z, r19
     b86:	81 83       	std	Z+1, r24	; 0x01
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b88:	0f b6       	in	r0, 0x3f	; 63
     b8a:	f8 94       	cli
     b8c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b8e:	0f 90       	pop	r0
     b90:	0f be       	out	0x3f, r0	; 63
				//*p_serial << "Measured: " << omegam_measured << endl;
				//*p_serial << "PWM Signal: " << output_correct << endl;
				//*p_serial << omegam_measured << endl;
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     b92:	80 91 77 31 	lds	r24, 0x3177	; 0x803177 <leftLimitSwitch>
     b96:	81 11       	cpse	r24, r1
     b98:	09 c0       	rjmp	.+18     	; 0xbac <_ZN10task_Motor3runEv+0x28c>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b9a:	0f b6       	in	r0, 0x3f	; 63
     b9c:	f8 94       	cli
     b9e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     ba0:	0f 90       	pop	r0
     ba2:	0f be       	out	0x3f, r0	; 63
     ba4:	80 91 76 31 	lds	r24, 0x3176	; 0x803176 <rightLimitSwitch>
     ba8:	88 23       	and	r24, r24
     baa:	59 f0       	breq	.+22     	; 0xbc2 <_ZN10task_Motor3runEv+0x2a2>
		{
			omegam_set = 0; // [ticks/ms]
     bac:	f8 01       	movw	r30, r16
     bae:	12 8e       	std	Z+26, r1	; 0x1a
     bb0:	13 8e       	std	Z+27, r1	; 0x1b
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     bb2:	f5 01       	movw	r30, r10
     bb4:	10 82       	st	Z, r1
     bb6:	11 82       	std	Z+1, r1	; 0x01
     bb8:	12 82       	std	Z+2, r1	; 0x02
     bba:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;
     bbc:	f6 01       	movw	r30, r12
     bbe:	10 82       	st	Z, r1
     bc0:	11 82       	std	Z+1, r1	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bc2:	0f b6       	in	r0, 0x3f	; 63
     bc4:	f8 94       	cli
     bc6:	0f 92       	push	r0
			the_data = new_data;
     bc8:	f6 01       	movw	r30, r12
     bca:	80 81       	ld	r24, Z
     bcc:	91 81       	ldd	r25, Z+1	; 0x01
     bce:	80 93 74 31 	sts	0x3174, r24	; 0x803174 <PWMvalue>
     bd2:	90 93 75 31 	sts	0x3175, r25	; 0x803175 <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     bd6:	0f 90       	pop	r0
     bd8:	0f be       	out	0x3f, r0	; 63
			}
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     bda:	f8 01       	movw	r30, r16
     bdc:	10 a6       	std	Z+40, r1	; 0x28
     bde:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     be0:	82 a1       	ldd	r24, Z+34	; 0x22
     be2:	93 a1       	ldd	r25, Z+35	; 0x23
     be4:	60 e0       	ldi	r22, 0x00	; 0
     be6:	70 e0       	ldi	r23, 0x00	; 0
     be8:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__divmodhi4>
     bec:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     bee:	07 2e       	mov	r0, r23
     bf0:	00 0c       	add	r0, r0
     bf2:	88 0b       	sbc	r24, r24
     bf4:	99 0b       	sbc	r25, r25
     bf6:	0e 94 b9 1e 	call	0x3d72	; 0x3d72 <__floatsisf>
     bfa:	2b 01       	movw	r4, r22
     bfc:	3c 01       	movw	r6, r24
     bfe:	23 e3       	ldi	r18, 0x33	; 51
     c00:	33 e3       	ldi	r19, 0x33	; 51
     c02:	4b e8       	ldi	r20, 0x8B	; 139
     c04:	51 e4       	ldi	r21, 0x41	; 65
     c06:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__gesf2>
     c0a:	18 16       	cp	r1, r24
     c0c:	34 f4       	brge	.+12     	; 0xc1a <_ZN10task_Motor3runEv+0x2fa>
			Im_set = 17.4;
     c0e:	81 e1       	ldi	r24, 0x11	; 17
     c10:	90 e0       	ldi	r25, 0x00	; 0
     c12:	f8 01       	movw	r30, r16
     c14:	84 a3       	std	Z+36, r24	; 0x24
     c16:	95 a3       	std	Z+37, r25	; 0x25
     c18:	13 c0       	rjmp	.+38     	; 0xc40 <_ZN10task_Motor3runEv+0x320>
		} else if(Im_set < -17.4) {
     c1a:	23 e3       	ldi	r18, 0x33	; 51
     c1c:	33 e3       	ldi	r19, 0x33	; 51
     c1e:	4b e8       	ldi	r20, 0x8B	; 139
     c20:	51 ec       	ldi	r21, 0xC1	; 193
     c22:	c3 01       	movw	r24, r6
     c24:	b2 01       	movw	r22, r4
     c26:	0e 94 b2 1e 	call	0x3d64	; 0x3d64 <__cmpsf2>
     c2a:	88 23       	and	r24, r24
     c2c:	24 f0       	brlt	.+8      	; 0xc36 <_ZN10task_Motor3runEv+0x316>
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     c2e:	f8 01       	movw	r30, r16
     c30:	e4 a2       	std	Z+36, r14	; 0x24
     c32:	f5 a2       	std	Z+37, r15	; 0x25
     c34:	05 c0       	rjmp	.+10     	; 0xc40 <_ZN10task_Motor3runEv+0x320>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     c36:	8f ee       	ldi	r24, 0xEF	; 239
     c38:	9f ef       	ldi	r25, 0xFF	; 255
     c3a:	f8 01       	movw	r30, r16
     c3c:	84 a3       	std	Z+36, r24	; 0x24
     c3e:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     c40:	f8 01       	movw	r30, r16
     c42:	16 aa       	std	Z+54, r1	; 0x36
     c44:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     c46:	12 aa       	std	Z+50, r1	; 0x32
     c48:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     c4a:	14 aa       	std	Z+52, r1	; 0x34
     c4c:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
     c4e:	80 a9       	ldd	r24, Z+48	; 0x30
     c50:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
     c52:	89 31       	cpi	r24, 0x19	; 25
     c54:	91 05       	cpc	r25, r1
     c56:	2c f0       	brlt	.+10     	; 0xc62 <_ZN10task_Motor3runEv+0x342>
			V_m = 24;
     c58:	88 e1       	ldi	r24, 0x18	; 24
     c5a:	90 e0       	ldi	r25, 0x00	; 0
     c5c:	80 af       	std	Z+56, r24	; 0x38
     c5e:	91 af       	std	Z+57, r25	; 0x39
     c60:	0d c0       	rjmp	.+26     	; 0xc7c <_ZN10task_Motor3runEv+0x35c>
		} else if(V_m < -24) {
     c62:	88 3e       	cpi	r24, 0xE8	; 232
     c64:	ff ef       	ldi	r31, 0xFF	; 255
     c66:	9f 07       	cpc	r25, r31
     c68:	24 f0       	brlt	.+8      	; 0xc72 <_ZN10task_Motor3runEv+0x352>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     c6a:	f8 01       	movw	r30, r16
     c6c:	80 af       	std	Z+56, r24	; 0x38
     c6e:	91 af       	std	Z+57, r25	; 0x39
     c70:	05 c0       	rjmp	.+10     	; 0xc7c <_ZN10task_Motor3runEv+0x35c>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     c72:	88 ee       	ldi	r24, 0xE8	; 232
     c74:	9f ef       	ldi	r25, 0xFF	; 255
     c76:	f8 01       	movw	r30, r16
     c78:	80 af       	std	Z+56, r24	; 0x38
     c7a:	91 af       	std	Z+57, r25	; 0x39

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
     c7c:	f4 01       	movw	r30, r8
     c7e:	20 81       	ld	r18, Z
     c80:	31 81       	ldd	r19, Z+1	; 0x01
     c82:	42 81       	ldd	r20, Z+2	; 0x02
     c84:	53 81       	ldd	r21, Z+3	; 0x03
     c86:	a8 ee       	ldi	r26, 0xE8	; 232
     c88:	b3 e0       	ldi	r27, 0x03	; 3
     c8a:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <__muluhisi3>
     c8e:	68 3e       	cpi	r22, 0xE8	; 232
     c90:	f3 e0       	ldi	r31, 0x03	; 3
     c92:	7f 07       	cpc	r23, r31
     c94:	81 05       	cpc	r24, r1
     c96:	91 05       	cpc	r25, r1
     c98:	48 f0       	brcs	.+18     	; 0xcac <_ZN10task_Motor3runEv+0x38c>
     c9a:	28 ee       	ldi	r18, 0xE8	; 232
     c9c:	33 e0       	ldi	r19, 0x03	; 3
     c9e:	40 e0       	ldi	r20, 0x00	; 0
     ca0:	50 e0       	ldi	r21, 0x00	; 0
     ca2:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <__udivmodsi4>
     ca6:	ba 01       	movw	r22, r20
     ca8:	a9 01       	movw	r20, r18
     caa:	04 c0       	rjmp	.+8      	; 0xcb4 <_ZN10task_Motor3runEv+0x394>
     cac:	41 e0       	ldi	r20, 0x01	; 1
     cae:	50 e0       	ldi	r21, 0x00	; 0
     cb0:	60 e0       	ldi	r22, 0x00	; 0
     cb2:	70 e0       	ldi	r23, 0x00	; 0
     cb4:	ce 01       	movw	r24, r28
     cb6:	01 96       	adiw	r24, 0x01	; 1
     cb8:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelayUntil>
     cbc:	83 ce       	rjmp	.-762    	; 0x9c4 <_ZN10task_Motor3runEv+0xa4>

00000cbe <_ZN10task_MotorC1EPKchjP8emstream>:
#include "task_LimitSwitches.h"				// Header for Limit Switches
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

task_Motor::task_Motor(const char* a_name,
     cbe:	0f 93       	push	r16
     cc0:	1f 93       	push	r17
     cc2:	cf 93       	push	r28
     cc4:	df 93       	push	r29
     cc6:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     cc8:	0e 94 7e 14 	call	0x28fc	; 0x28fc <_ZN8frt_taskC1EPKchjP8emstream>
     ccc:	8a e2       	ldi	r24, 0x2A	; 42
     cce:	90 e2       	ldi	r25, 0x20	; 32
     cd0:	88 83       	st	Y, r24
     cd2:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	1f 91       	pop	r17
     cda:	0f 91       	pop	r16
     cdc:	08 95       	ret

00000cde <_ZN13task_Position3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void task_Position::run (void)
{
     cde:	cf 93       	push	r28
     ce0:	df 93       	push	r29
     ce2:	00 d0       	rcall	.+0      	; 0xce4 <_ZN13task_Position3runEv+0x6>
     ce4:	1f 92       	push	r1
     ce6:	cd b7       	in	r28, 0x3d	; 61
     ce8:	de b7       	in	r29, 0x3e	; 62
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     cea:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
     cee:	69 83       	std	Y+1, r22	; 0x01
     cf0:	7a 83       	std	Y+2, r23	; 0x02
     cf2:	8b 83       	std	Y+3, r24	; 0x03
     cf4:	9c 83       	std	Y+4, r25	; 0x04
     cf6:	46 e0       	ldi	r20, 0x06	; 6
     cf8:	50 e0       	ldi	r21, 0x00	; 0
     cfa:	60 e0       	ldi	r22, 0x00	; 0
     cfc:	70 e0       	ldi	r23, 0x00	; 0
     cfe:	ce 01       	movw	r24, r28
     d00:	01 96       	adiw	r24, 0x01	; 1
     d02:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelayUntil>
     d06:	f7 cf       	rjmp	.-18     	; 0xcf6 <_ZN13task_Position3runEv+0x18>

00000d08 <_ZN13task_PositionC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_Position::task_Position(const char* a_name,
     d08:	0f 93       	push	r16
     d0a:	1f 93       	push	r17
     d0c:	cf 93       	push	r28
     d0e:	df 93       	push	r29
     d10:	ec 01       	movw	r28, r24
size_t a_stack_size,
emstream* p_ser_dev
)

// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d12:	0e 94 7e 14 	call	0x28fc	; 0x28fc <_ZN8frt_taskC1EPKchjP8emstream>
     d16:	82 e3       	ldi	r24, 0x32	; 50
     d18:	90 e2       	ldi	r25, 0x20	; 32
     d1a:	88 83       	st	Y, r24
     d1c:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     d1e:	df 91       	pop	r29
     d20:	cf 91       	pop	r28
     d22:	1f 91       	pop	r17
     d24:	0f 91       	pop	r16
     d26:	08 95       	ret

00000d28 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     d28:	0f 93       	push	r16
     d2a:	1f 93       	push	r17
     d2c:	cf 93       	push	r28
     d2e:	df 93       	push	r29
     d30:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d32:	0e 94 7e 14 	call	0x28fc	; 0x28fc <_ZN8frt_taskC1EPKchjP8emstream>
     d36:	8a e3       	ldi	r24, 0x3A	; 58
     d38:	90 e2       	ldi	r25, 0x20	; 32
     d3a:	88 83       	st	Y, r24
     d3c:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
     d42:	1f 91       	pop	r17
     d44:	0f 91       	pop	r16
     d46:	08 95       	ret

00000d48 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     d48:	0f 93       	push	r16
     d4a:	1f 93       	push	r17
     d4c:	cf 93       	push	r28
     d4e:	df 93       	push	r29
     d50:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     d52:	6a e0       	ldi	r22, 0x0A	; 10
     d54:	8e 81       	ldd	r24, Y+6	; 0x06
     d56:	9f 81       	ldd	r25, Y+7	; 0x07
     d58:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     d5c:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     d5e:	65 ef       	ldi	r22, 0xF5	; 245
     d60:	73 e0       	ldi	r23, 0x03	; 3
     d62:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     d66:	6a e0       	ldi	r22, 0x0A	; 10
     d68:	c8 01       	movw	r24, r16
     d6a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     d6e:	8c 01       	movw	r16, r24
     d70:	6f ee       	ldi	r22, 0xEF	; 239
     d72:	73 e0       	ldi	r23, 0x03	; 3
     d74:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     d78:	67 e0       	ldi	r22, 0x07	; 7
     d7a:	c8 01       	movw	r24, r16
     d7c:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     d80:	6a e0       	ldi	r22, 0x0A	; 10
     d82:	8e 81       	ldd	r24, Y+6	; 0x06
     d84:	9f 81       	ldd	r25, Y+7	; 0x07
     d86:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     d8a:	8c 01       	movw	r16, r24
     d8c:	60 ed       	ldi	r22, 0xD0	; 208
     d8e:	73 e0       	ldi	r23, 0x03	; 3
     d90:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     d94:	6a e0       	ldi	r22, 0x0A	; 10
     d96:	c8 01       	movw	r24, r16
     d98:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     d9c:	8c 01       	movw	r16, r24
     d9e:	6a ec       	ldi	r22, 0xCA	; 202
     da0:	73 e0       	ldi	r23, 0x03	; 3
     da2:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     da6:	66 e0       	ldi	r22, 0x06	; 6
     da8:	c8 01       	movw	r24, r16
     daa:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     dae:	6a e0       	ldi	r22, 0x0A	; 10
     db0:	8e 81       	ldd	r24, Y+6	; 0x06
     db2:	9f 81       	ldd	r25, Y+7	; 0x07
     db4:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     db8:	8c 01       	movw	r16, r24
     dba:	63 eb       	ldi	r22, 0xB3	; 179
     dbc:	73 e0       	ldi	r23, 0x03	; 3
     dbe:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     dc2:	66 e0       	ldi	r22, 0x06	; 6
     dc4:	c8 01       	movw	r24, r16
     dc6:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     dca:	6a e0       	ldi	r22, 0x0A	; 10
     dcc:	8e 81       	ldd	r24, Y+6	; 0x06
     dce:	9f 81       	ldd	r25, Y+7	; 0x07
     dd0:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     dd4:	8c 01       	movw	r16, r24
     dd6:	67 e9       	ldi	r22, 0x97	; 151
     dd8:	73 e0       	ldi	r23, 0x03	; 3
     dda:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     dde:	66 e0       	ldi	r22, 0x06	; 6
     de0:	c8 01       	movw	r24, r16
     de2:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     de6:	6a e0       	ldi	r22, 0x0A	; 10
     de8:	8e 81       	ldd	r24, Y+6	; 0x06
     dea:	9f 81       	ldd	r25, Y+7	; 0x07
     dec:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     df0:	8c 01       	movw	r16, r24
     df2:	6f e7       	ldi	r22, 0x7F	; 127
     df4:	73 e0       	ldi	r23, 0x03	; 3
     df6:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     dfa:	66 e0       	ldi	r22, 0x06	; 6
     dfc:	c8 01       	movw	r24, r16
     dfe:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e02:	6a e0       	ldi	r22, 0x0A	; 10
     e04:	8e 81       	ldd	r24, Y+6	; 0x06
     e06:	9f 81       	ldd	r25, Y+7	; 0x07
     e08:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     e0c:	8c 01       	movw	r16, r24
     e0e:	6e e5       	ldi	r22, 0x5E	; 94
     e10:	73 e0       	ldi	r23, 0x03	; 3
     e12:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     e16:	66 e0       	ldi	r22, 0x06	; 6
     e18:	c8 01       	movw	r24, r16
     e1a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e1e:	6a e0       	ldi	r22, 0x0A	; 10
     e20:	8e 81       	ldd	r24, Y+6	; 0x06
     e22:	9f 81       	ldd	r25, Y+7	; 0x07
     e24:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     e28:	8c 01       	movw	r16, r24
     e2a:	67 e3       	ldi	r22, 0x37	; 55
     e2c:	73 e0       	ldi	r23, 0x03	; 3
     e2e:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     e32:	66 e0       	ldi	r22, 0x06	; 6
     e34:	c8 01       	movw	r24, r16
     e36:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     e3a:	6a e0       	ldi	r22, 0x0A	; 10
     e3c:	8e 81       	ldd	r24, Y+6	; 0x06
     e3e:	9f 81       	ldd	r25, Y+7	; 0x07
     e40:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     e44:	8c 01       	movw	r16, r24
     e46:	69 e1       	ldi	r22, 0x19	; 25
     e48:	73 e0       	ldi	r23, 0x03	; 3
     e4a:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     e4e:	66 e0       	ldi	r22, 0x06	; 6
     e50:	c8 01       	movw	r24, r16
     e52:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     e56:	6a e0       	ldi	r22, 0x0A	; 10
     e58:	8e 81       	ldd	r24, Y+6	; 0x06
     e5a:	9f 81       	ldd	r25, Y+7	; 0x07
     e5c:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     e60:	8c 01       	movw	r16, r24
     e62:	6e ef       	ldi	r22, 0xFE	; 254
     e64:	72 e0       	ldi	r23, 0x02	; 2
     e66:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     e6a:	66 e0       	ldi	r22, 0x06	; 6
     e6c:	c8 01       	movw	r24, r16
     e6e:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     e72:	6a e0       	ldi	r22, 0x0A	; 10
     e74:	8e 81       	ldd	r24, Y+6	; 0x06
     e76:	9f 81       	ldd	r25, Y+7	; 0x07
     e78:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     e7c:	ec 01       	movw	r28, r24
     e7e:	6f ee       	ldi	r22, 0xEF	; 239
     e80:	72 e0       	ldi	r23, 0x02	; 2
     e82:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     e86:	66 e0       	ldi	r22, 0x06	; 6
     e88:	ce 01       	movw	r24, r28
     e8a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
}
     e8e:	df 91       	pop	r29
     e90:	cf 91       	pop	r28
     e92:	1f 91       	pop	r17
     e94:	0f 91       	pop	r16
     e96:	08 95       	ret

00000e98 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     e98:	af 92       	push	r10
     e9a:	bf 92       	push	r11
     e9c:	cf 92       	push	r12
     e9e:	df 92       	push	r13
     ea0:	ef 92       	push	r14
     ea2:	ff 92       	push	r15
     ea4:	0f 93       	push	r16
     ea6:	1f 93       	push	r17
     ea8:	cf 93       	push	r28
     eaa:	df 93       	push	r29
     eac:	00 d0       	rcall	.+0      	; 0xeae <_ZN9task_user11show_statusEv+0x16>
     eae:	00 d0       	rcall	.+0      	; 0xeb0 <_ZN9task_user11show_statusEv+0x18>
     eb0:	cd b7       	in	r28, 0x3d	; 61
     eb2:	de b7       	in	r29, 0x3e	; 62
     eb4:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     eb6:	19 82       	std	Y+1, r1	; 0x01
     eb8:	1a 82       	std	Y+2, r1	; 0x02
     eba:	1b 82       	std	Y+3, r1	; 0x03
     ebc:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     ebe:	1d 82       	std	Y+5, r1	; 0x05
     ec0:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     ec2:	0e 94 f6 09 	call	0x13ec	; 0x13ec <xPortGetFreeHeapSize>
     ec6:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     ec8:	ce 01       	movw	r24, r28
     eca:	01 96       	adiw	r24, 0x01	; 1
     ecc:	0e 94 2f 18 	call	0x305e	; 0x305e <_ZN10time_stamp10set_to_nowEv>
     ed0:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     ed2:	66 e0       	ldi	r22, 0x06	; 6
     ed4:	f8 01       	movw	r30, r16
     ed6:	86 81       	ldd	r24, Z+6	; 0x06
     ed8:	97 81       	ldd	r25, Z+7	; 0x07
     eda:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     ede:	6a e0       	ldi	r22, 0x0A	; 10
     ee0:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     ee4:	7c 01       	movw	r14, r24
     ee6:	60 ed       	ldi	r22, 0xD0	; 208
     ee8:	72 e0       	ldi	r23, 0x02	; 2
     eea:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     eee:	6a e0       	ldi	r22, 0x0A	; 10
     ef0:	c7 01       	movw	r24, r14
     ef2:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     ef6:	7c 01       	movw	r14, r24
     ef8:	64 ec       	ldi	r22, 0xC4	; 196
     efa:	72 e0       	ldi	r23, 0x02	; 2
     efc:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     f00:	66 e0       	ldi	r22, 0x06	; 6
     f02:	c7 01       	movw	r24, r14
     f04:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f08:	6a e0       	ldi	r22, 0x0A	; 10
     f0a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     f0e:	7c 01       	movw	r14, r24
     f10:	6d eb       	ldi	r22, 0xBD	; 189
     f12:	72 e0       	ldi	r23, 0x02	; 2
     f14:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     f18:	b5 01       	movw	r22, r10
     f1a:	c7 01       	movw	r24, r14
     f1c:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f20:	6a e0       	ldi	r22, 0x0A	; 10
     f22:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     f26:	7c 01       	movw	r14, r24
     f28:	6f ea       	ldi	r22, 0xAF	; 175
     f2a:	72 e0       	ldi	r23, 0x02	; 2
     f2c:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     f30:	b6 01       	movw	r22, r12
     f32:	c7 01       	movw	r24, r14
     f34:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEj>
     f38:	6a e0       	ldi	r22, 0x0A	; 10
     f3a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     f3e:	7c 01       	movw	r14, r24
     f40:	6d ea       	ldi	r22, 0xAD	; 173
     f42:	72 e0       	ldi	r23, 0x02	; 2
     f44:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     f48:	4f ef       	ldi	r20, 0xFF	; 255
     f4a:	5f e0       	ldi	r21, 0x0F	; 15
     f4c:	60 e0       	ldi	r22, 0x00	; 0
     f4e:	70 e0       	ldi	r23, 0x00	; 0
     f50:	c7 01       	movw	r24, r14
     f52:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     f56:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     f5a:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     f5e:	6a e0       	ldi	r22, 0x0A	; 10
     f60:	f8 01       	movw	r30, r16
     f62:	86 81       	ldd	r24, Z+6	; 0x06
     f64:	97 81       	ldd	r25, Z+7	; 0x07
     f66:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     f6a:	7c 01       	movw	r14, r24
     f6c:	62 ea       	ldi	r22, 0xA2	; 162
     f6e:	72 e0       	ldi	r23, 0x02	; 2
     f70:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     f74:	b6 01       	movw	r22, r12
     f76:	c7 01       	movw	r24, r14
     f78:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEj>
     f7c:	66 e0       	ldi	r22, 0x06	; 6
     f7e:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     f82:	66 e0       	ldi	r22, 0x06	; 6
     f84:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     f88:	f8 01       	movw	r30, r16
     f8a:	86 81       	ldd	r24, Z+6	; 0x06
     f8c:	97 81       	ldd	r25, Z+7	; 0x07
     f8e:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_Z15print_task_listP8emstream>
}
     f92:	26 96       	adiw	r28, 0x06	; 6
     f94:	cd bf       	out	0x3d, r28	; 61
     f96:	de bf       	out	0x3e, r29	; 62
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	1f 91       	pop	r17
     f9e:	0f 91       	pop	r16
     fa0:	ff 90       	pop	r15
     fa2:	ef 90       	pop	r14
     fa4:	df 90       	pop	r13
     fa6:	cf 90       	pop	r12
     fa8:	bf 90       	pop	r11
     faa:	af 90       	pop	r10
     fac:	08 95       	ret

00000fae <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	00 d0       	rcall	.+0      	; 0xfb4 <_ZN9task_user3runEv+0x6>
     fb4:	00 d0       	rcall	.+0      	; 0xfb6 <_ZN9task_user3runEv+0x8>
     fb6:	cd b7       	in	r28, 0x3d	; 61
     fb8:	de b7       	in	r29, 0x3e	; 62
     fba:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     fbc:	19 82       	std	Y+1, r1	; 0x01
     fbe:	1a 82       	std	Y+2, r1	; 0x02
     fc0:	1b 82       	std	Y+3, r1	; 0x03
     fc2:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     fc4:	1d 82       	std	Y+5, r1	; 0x05
     fc6:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     fc8:	6a e0       	ldi	r22, 0x0A	; 10
     fca:	dc 01       	movw	r26, r24
     fcc:	16 96       	adiw	r26, 0x06	; 6
     fce:	8d 91       	ld	r24, X+
     fd0:	9c 91       	ld	r25, X
     fd2:	17 97       	sbiw	r26, 0x07	; 7
     fd4:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
     fd8:	7c 01       	movw	r14, r24
     fda:	6e e3       	ldi	r22, 0x3E	; 62
     fdc:	74 e0       	ldi	r23, 0x04	; 4
     fde:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
     fe2:	66 e0       	ldi	r22, 0x06	; 6
     fe4:	c7 01       	movw	r24, r14
     fe6:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     fea:	f8 01       	movw	r30, r16
     fec:	84 85       	ldd	r24, Z+12	; 0x0c
     fee:	88 23       	and	r24, r24
     ff0:	21 f0       	breq	.+8      	; 0xffa <_ZN9task_user3runEv+0x4c>
     ff2:	81 30       	cpi	r24, 0x01	; 1
     ff4:	09 f4       	brne	.+2      	; 0xff8 <_ZN9task_user3runEv+0x4a>
     ff6:	5d c0       	rjmp	.+186    	; 0x10b2 <_ZN9task_user3runEv+0x104>
     ff8:	d8 c0       	rjmp	.+432    	; 0x11aa <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     ffa:	86 81       	ldd	r24, Z+6	; 0x06
     ffc:	97 81       	ldd	r25, Z+7	; 0x07
     ffe:	dc 01       	movw	r26, r24
    1000:	ed 91       	ld	r30, X+
    1002:	fc 91       	ld	r31, X
    1004:	04 80       	ldd	r0, Z+4	; 0x04
    1006:	f5 81       	ldd	r31, Z+5	; 0x05
    1008:	e0 2d       	mov	r30, r0
    100a:	19 95       	eicall
    100c:	88 23       	and	r24, r24
    100e:	a9 f1       	breq	.+106    	; 0x107a <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1010:	f8 01       	movw	r30, r16
    1012:	86 81       	ldd	r24, Z+6	; 0x06
    1014:	97 81       	ldd	r25, Z+7	; 0x07
    1016:	dc 01       	movw	r26, r24
    1018:	ed 91       	ld	r30, X+
    101a:	fc 91       	ld	r31, X
    101c:	06 80       	ldd	r0, Z+6	; 0x06
    101e:	f7 81       	ldd	r31, Z+7	; 0x07
    1020:	e0 2d       	mov	r30, r0
    1022:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1024:	99 27       	eor	r25, r25
    1026:	81 30       	cpi	r24, 0x01	; 1
    1028:	91 05       	cpc	r25, r1
    102a:	f9 f0       	breq	.+62     	; 0x106a <_ZN9task_user3runEv+0xbc>
    102c:	03 97       	sbiw	r24, 0x03	; 3
    102e:	09 f0       	breq	.+2      	; 0x1032 <_ZN9task_user3runEv+0x84>
    1030:	d8 c0       	rjmp	.+432    	; 0x11e2 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1032:	6a e0       	ldi	r22, 0x0A	; 10
    1034:	f8 01       	movw	r30, r16
    1036:	86 81       	ldd	r24, Z+6	; 0x06
    1038:	97 81       	ldd	r25, Z+7	; 0x07
    103a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    103e:	8c 01       	movw	r16, r24
    1040:	60 e3       	ldi	r22, 0x30	; 48
    1042:	74 e0       	ldi	r23, 0x04	; 4
    1044:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    1048:	66 e0       	ldi	r22, 0x06	; 6
    104a:	c8 01       	movw	r24, r16
    104c:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1050:	93 e0       	ldi	r25, 0x03	; 3
    1052:	88 ed       	ldi	r24, 0xD8	; 216
    1054:	08 b6       	in	r0, 0x38	; 56
    1056:	18 be       	out	0x38, r1	; 56
    1058:	84 bf       	out	0x34, r24	; 52
    105a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    105e:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1062:	81 fd       	sbrc	r24, 1
    1064:	fc cf       	rjmp	.-8      	; 0x105e <_ZN9task_user3runEv+0xb0>
    1066:	08 be       	out	0x38, r0	; 56
    1068:	ff cf       	rjmp	.-2      	; 0x1068 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    106a:	c8 01       	movw	r24, r16
    106c:	0e 94 a4 06 	call	0xd48	; 0xd48 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1070:	61 e0       	ldi	r22, 0x01	; 1
    1072:	c8 01       	movw	r24, r16
    1074:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <_ZN8frt_task13transition_toEh>
							break;
    1078:	b4 c0       	rjmp	.+360    	; 0x11e2 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    107a:	8e e7       	ldi	r24, 0x7E	; 126
    107c:	91 e3       	ldi	r25, 0x31	; 49
    107e:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <_ZN14frt_text_queue14check_for_charEv>
    1082:	88 23       	and	r24, r24
    1084:	09 f4       	brne	.+2      	; 0x1088 <_ZN9task_user3runEv+0xda>
    1086:	ad c0       	rjmp	.+346    	; 0x11e2 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1088:	d8 01       	movw	r26, r16
    108a:	16 96       	adiw	r26, 0x06	; 6
    108c:	ed 91       	ld	r30, X+
    108e:	fc 91       	ld	r31, X
    1090:	17 97       	sbiw	r26, 0x07	; 7
    1092:	01 90       	ld	r0, Z+
    1094:	f0 81       	ld	r31, Z
    1096:	e0 2d       	mov	r30, r0
    1098:	e2 80       	ldd	r14, Z+2	; 0x02
    109a:	f3 80       	ldd	r15, Z+3	; 0x03
    109c:	8e e7       	ldi	r24, 0x7E	; 126
    109e:	91 e3       	ldi	r25, 0x31	; 49
    10a0:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <_ZN14frt_text_queue7getcharEv>
    10a4:	68 2f       	mov	r22, r24
    10a6:	f8 01       	movw	r30, r16
    10a8:	86 81       	ldd	r24, Z+6	; 0x06
    10aa:	97 81       	ldd	r25, Z+7	; 0x07
    10ac:	f7 01       	movw	r30, r14
    10ae:	19 95       	eicall
    10b0:	98 c0       	rjmp	.+304    	; 0x11e2 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    10b2:	86 81       	ldd	r24, Z+6	; 0x06
    10b4:	97 81       	ldd	r25, Z+7	; 0x07
    10b6:	dc 01       	movw	r26, r24
    10b8:	ed 91       	ld	r30, X+
    10ba:	fc 91       	ld	r31, X
    10bc:	04 80       	ldd	r0, Z+4	; 0x04
    10be:	f5 81       	ldd	r31, Z+5	; 0x05
    10c0:	e0 2d       	mov	r30, r0
    10c2:	19 95       	eicall
    10c4:	88 23       	and	r24, r24
    10c6:	09 f4       	brne	.+2      	; 0x10ca <_ZN9task_user3runEv+0x11c>
    10c8:	8c c0       	rjmp	.+280    	; 0x11e2 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    10ca:	f8 01       	movw	r30, r16
    10cc:	86 81       	ldd	r24, Z+6	; 0x06
    10ce:	97 81       	ldd	r25, Z+7	; 0x07
    10d0:	dc 01       	movw	r26, r24
    10d2:	ed 91       	ld	r30, X+
    10d4:	fc 91       	ld	r31, X
    10d6:	06 80       	ldd	r0, Z+6	; 0x06
    10d8:	f7 81       	ldd	r31, Z+7	; 0x07
    10da:	e0 2d       	mov	r30, r0
    10dc:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    10de:	9c 01       	movw	r18, r24
    10e0:	33 27       	eor	r19, r19
    10e2:	28 36       	cpi	r18, 0x68	; 104
    10e4:	31 05       	cpc	r19, r1
    10e6:	59 f1       	breq	.+86     	; 0x113e <_ZN9task_user3runEv+0x190>
    10e8:	3c f4       	brge	.+14     	; 0x10f8 <_ZN9task_user3runEv+0x14a>
    10ea:	2b 31       	cpi	r18, 0x1B	; 27
    10ec:	31 05       	cpc	r19, r1
    10ee:	59 f1       	breq	.+86     	; 0x1146 <_ZN9task_user3runEv+0x198>
    10f0:	25 36       	cpi	r18, 0x65	; 101
    10f2:	31 05       	cpc	r19, r1
    10f4:	41 f1       	breq	.+80     	; 0x1146 <_ZN9task_user3runEv+0x198>
    10f6:	3b c0       	rjmp	.+118    	; 0x116e <_ZN9task_user3runEv+0x1c0>
    10f8:	23 37       	cpi	r18, 0x73	; 115
    10fa:	31 05       	cpc	r19, r1
    10fc:	c1 f0       	breq	.+48     	; 0x112e <_ZN9task_user3runEv+0x180>
    10fe:	26 37       	cpi	r18, 0x76	; 118
    1100:	31 05       	cpc	r19, r1
    1102:	89 f0       	breq	.+34     	; 0x1126 <_ZN9task_user3runEv+0x178>
    1104:	2e 36       	cpi	r18, 0x6E	; 110
    1106:	31 05       	cpc	r19, r1
    1108:	91 f5       	brne	.+100    	; 0x116e <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    110a:	ce 01       	movw	r24, r28
    110c:	01 96       	adiw	r24, 0x01	; 1
    110e:	0e 94 2f 18 	call	0x305e	; 0x305e <_ZN10time_stamp10set_to_nowEv>
    1112:	bc 01       	movw	r22, r24
    1114:	f8 01       	movw	r30, r16
    1116:	86 81       	ldd	r24, Z+6	; 0x06
    1118:	97 81       	ldd	r25, Z+7	; 0x07
    111a:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <_ZlsR8emstreamR10time_stamp>
    111e:	66 e0       	ldi	r22, 0x06	; 6
    1120:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1124:	5e c0       	rjmp	.+188    	; 0x11e2 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1126:	c8 01       	movw	r24, r16
    1128:	0e 94 4c 07 	call	0xe98	; 0xe98 <_ZN9task_user11show_statusEv>
							break;
    112c:	5a c0       	rjmp	.+180    	; 0x11e2 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    112e:	d8 01       	movw	r26, r16
    1130:	16 96       	adiw	r26, 0x06	; 6
    1132:	8d 91       	ld	r24, X+
    1134:	9c 91       	ld	r25, X
    1136:	17 97       	sbiw	r26, 0x07	; 7
    1138:	0e 94 93 15 	call	0x2b26	; 0x2b26 <_Z17print_task_stacksP8emstream>
							break;
    113c:	52 c0       	rjmp	.+164    	; 0x11e2 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    113e:	c8 01       	movw	r24, r16
    1140:	0e 94 a4 06 	call	0xd48	; 0xd48 <_ZN9task_user18print_help_messageEv>
							break;
    1144:	4e c0       	rjmp	.+156    	; 0x11e2 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1146:	6a e0       	ldi	r22, 0x0A	; 10
    1148:	f8 01       	movw	r30, r16
    114a:	86 81       	ldd	r24, Z+6	; 0x06
    114c:	97 81       	ldd	r25, Z+7	; 0x07
    114e:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    1152:	7c 01       	movw	r14, r24
    1154:	6e e1       	ldi	r22, 0x1E	; 30
    1156:	74 e0       	ldi	r23, 0x04	; 4
    1158:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    115c:	66 e0       	ldi	r22, 0x06	; 6
    115e:	c7 01       	movw	r24, r14
    1160:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1164:	60 e0       	ldi	r22, 0x00	; 0
    1166:	c8 01       	movw	r24, r16
    1168:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <_ZN8frt_task13transition_toEh>
							break;
    116c:	3a c0       	rjmp	.+116    	; 0x11e2 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    116e:	f8 01       	movw	r30, r16
    1170:	a6 81       	ldd	r26, Z+6	; 0x06
    1172:	b7 81       	ldd	r27, Z+7	; 0x07
    1174:	ed 91       	ld	r30, X+
    1176:	fc 91       	ld	r31, X
    1178:	11 97       	sbiw	r26, 0x01	; 1
    117a:	02 80       	ldd	r0, Z+2	; 0x02
    117c:	f3 81       	ldd	r31, Z+3	; 0x03
    117e:	e0 2d       	mov	r30, r0
    1180:	68 2f       	mov	r22, r24
    1182:	cd 01       	movw	r24, r26
    1184:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1186:	6a e0       	ldi	r22, 0x0A	; 10
    1188:	d8 01       	movw	r26, r16
    118a:	16 96       	adiw	r26, 0x06	; 6
    118c:	8d 91       	ld	r24, X+
    118e:	9c 91       	ld	r25, X
    1190:	17 97       	sbiw	r26, 0x07	; 7
    1192:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    1196:	7c 01       	movw	r14, r24
    1198:	68 e1       	ldi	r22, 0x18	; 24
    119a:	74 e0       	ldi	r23, 0x04	; 4
    119c:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    11a0:	66 e0       	ldi	r22, 0x06	; 6
    11a2:	c7 01       	movw	r24, r14
    11a4:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
							break;
    11a8:	1c c0       	rjmp	.+56     	; 0x11e2 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    11aa:	6a e0       	ldi	r22, 0x0A	; 10
    11ac:	f8 01       	movw	r30, r16
    11ae:	86 81       	ldd	r24, Z+6	; 0x06
    11b0:	97 81       	ldd	r25, Z+7	; 0x07
    11b2:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    11b6:	8c 01       	movw	r16, r24
    11b8:	6b ef       	ldi	r22, 0xFB	; 251
    11ba:	73 e0       	ldi	r23, 0x03	; 3
    11bc:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    11c0:	66 e0       	ldi	r22, 0x06	; 6
    11c2:	c8 01       	movw	r24, r16
    11c4:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    11c8:	93 e0       	ldi	r25, 0x03	; 3
    11ca:	88 ed       	ldi	r24, 0xD8	; 216
    11cc:	08 b6       	in	r0, 0x38	; 56
    11ce:	18 be       	out	0x38, r1	; 56
    11d0:	84 bf       	out	0x34, r24	; 52
    11d2:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    11d6:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    11da:	81 fd       	sbrc	r24, 1
    11dc:	fc cf       	rjmp	.-8      	; 0x11d6 <_ZN9task_user3runEv+0x228>
    11de:	08 be       	out	0x38, r0	; 56
    11e0:	ff cf       	rjmp	.-2      	; 0x11e0 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    11e2:	f8 01       	movw	r30, r16
    11e4:	86 85       	ldd	r24, Z+14	; 0x0e
    11e6:	97 85       	ldd	r25, Z+15	; 0x0f
    11e8:	a0 89       	ldd	r26, Z+16	; 0x10
    11ea:	b1 89       	ldd	r27, Z+17	; 0x11
    11ec:	01 96       	adiw	r24, 0x01	; 1
    11ee:	a1 1d       	adc	r26, r1
    11f0:	b1 1d       	adc	r27, r1
    11f2:	86 87       	std	Z+14, r24	; 0x0e
    11f4:	97 87       	std	Z+15, r25	; 0x0f
    11f6:	a0 8b       	std	Z+16, r26	; 0x10
    11f8:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    11fa:	61 e0       	ldi	r22, 0x01	; 1
    11fc:	70 e0       	ldi	r23, 0x00	; 0
    11fe:	80 e0       	ldi	r24, 0x00	; 0
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	0e 94 4e 12 	call	0x249c	; 0x249c <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1206:	f1 ce       	rjmp	.-542    	; 0xfea <_ZN9task_user3runEv+0x3c>

00001208 <_ZN13task_Velocity3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void task_Velocity::run (void)
{ 
    1208:	cf 93       	push	r28
    120a:	df 93       	push	r29
    120c:	00 d0       	rcall	.+0      	; 0x120e <_ZN13task_Velocity3runEv+0x6>
    120e:	1f 92       	push	r1
    1210:	cd b7       	in	r28, 0x3d	; 61
    1212:	de b7       	in	r29, 0x3e	; 62
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
    1214:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
    1218:	69 83       	std	Y+1, r22	; 0x01
    121a:	7a 83       	std	Y+2, r23	; 0x02
    121c:	8b 83       	std	Y+3, r24	; 0x03
    121e:	9c 83       	std	Y+4, r25	; 0x04
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
    1220:	42 e0       	ldi	r20, 0x02	; 2
    1222:	50 e0       	ldi	r21, 0x00	; 0
    1224:	60 e0       	ldi	r22, 0x00	; 0
    1226:	70 e0       	ldi	r23, 0x00	; 0
    1228:	ce 01       	movw	r24, r28
    122a:	01 96       	adiw	r24, 0x01	; 1
    122c:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelayUntil>
    1230:	f7 cf       	rjmp	.-18     	; 0x1220 <_ZN13task_Velocity3runEv+0x18>

00001232 <_ZN13task_VelocityC1EPKchjP8emstream>:
#include "satmath.h"
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


task_Velocity::task_Velocity(const char* a_name,
    1232:	0f 93       	push	r16
    1234:	1f 93       	push	r17
    1236:	cf 93       	push	r28
    1238:	df 93       	push	r29
    123a:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    123c:	0e 94 7e 14 	call	0x28fc	; 0x28fc <_ZN8frt_taskC1EPKchjP8emstream>
    1240:	82 e4       	ldi	r24, 0x42	; 66
    1242:	90 e2       	ldi	r25, 0x20	; 32
    1244:	88 83       	st	Y, r24
    1246:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
    1248:	df 91       	pop	r29
    124a:	cf 91       	pop	r28
    124c:	1f 91       	pop	r17
    124e:	0f 91       	pop	r16
    1250:	08 95       	ret

00001252 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1252:	0f 93       	push	r16
    1254:	1f 93       	push	r17
    1256:	cf 93       	push	r28
    1258:	df 93       	push	r29
    125a:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    125c:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1260:	80 91 ea 20 	lds	r24, 0x20EA	; 0x8020ea <__data_end>
    1264:	81 11       	cpse	r24, r1
    1266:	1d c0       	rjmp	.+58     	; 0x12a2 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1268:	af ee       	ldi	r26, 0xEF	; 239
    126a:	b0 e2       	ldi	r27, 0x20	; 32
    126c:	e3 ef       	ldi	r30, 0xF3	; 243
    126e:	f0 e2       	ldi	r31, 0x20	; 32
    1270:	ed 93       	st	X+, r30
    1272:	fc 93       	st	X, r31
    1274:	11 97       	sbiw	r26, 0x01	; 1
    1276:	12 96       	adiw	r26, 0x02	; 2
    1278:	1d 92       	st	X+, r1
    127a:	1c 92       	st	X, r1
    127c:	13 97       	sbiw	r26, 0x03	; 3
    127e:	ab ee       	ldi	r26, 0xEB	; 235
    1280:	b0 e2       	ldi	r27, 0x20	; 32
    1282:	8f ef       	ldi	r24, 0xFF	; 255
    1284:	9f e0       	ldi	r25, 0x0F	; 15
    1286:	12 96       	adiw	r26, 0x02	; 2
    1288:	8d 93       	st	X+, r24
    128a:	9c 93       	st	X, r25
    128c:	13 97       	sbiw	r26, 0x03	; 3
    128e:	1d 92       	st	X+, r1
    1290:	1c 92       	st	X, r1
    1292:	11 97       	sbiw	r26, 0x01	; 1
    1294:	82 83       	std	Z+2, r24	; 0x02
    1296:	93 83       	std	Z+3, r25	; 0x03
    1298:	a0 83       	st	Z, r26
    129a:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	80 93 ea 20 	sts	0x20EA, r24	; 0x8020ea <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12a2:	20 97       	sbiw	r28, 0x00	; 0
    12a4:	09 f4       	brne	.+2      	; 0x12a8 <pvPortMalloc+0x56>
    12a6:	5f c0       	rjmp	.+190    	; 0x1366 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12a8:	9e 01       	movw	r18, r28
    12aa:	2b 5f       	subi	r18, 0xFB	; 251
    12ac:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    12ae:	24 96       	adiw	r28, 0x04	; 4
    12b0:	ce 3f       	cpi	r28, 0xFE	; 254
    12b2:	df 40       	sbci	r29, 0x0F	; 15
    12b4:	08 f0       	brcs	.+2      	; 0x12b8 <pvPortMalloc+0x66>
    12b6:	5a c0       	rjmp	.+180    	; 0x136c <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    12b8:	e0 91 ef 20 	lds	r30, 0x20EF	; 0x8020ef <xStart>
    12bc:	f0 91 f0 20 	lds	r31, 0x20F0	; 0x8020f0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    12c0:	af ee       	ldi	r26, 0xEF	; 239
    12c2:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12c4:	02 c0       	rjmp	.+4      	; 0x12ca <pvPortMalloc+0x78>
    12c6:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    12c8:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12ca:	82 81       	ldd	r24, Z+2	; 0x02
    12cc:	93 81       	ldd	r25, Z+3	; 0x03
    12ce:	82 17       	cp	r24, r18
    12d0:	93 07       	cpc	r25, r19
    12d2:	20 f4       	brcc	.+8      	; 0x12dc <pvPortMalloc+0x8a>
    12d4:	80 81       	ld	r24, Z
    12d6:	91 81       	ldd	r25, Z+1	; 0x01
    12d8:	00 97       	sbiw	r24, 0x00	; 0
    12da:	a9 f7       	brne	.-22     	; 0x12c6 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    12dc:	c0 e2       	ldi	r28, 0x20	; 32
    12de:	eb 3e       	cpi	r30, 0xEB	; 235
    12e0:	fc 07       	cpc	r31, r28
    12e2:	09 f4       	brne	.+2      	; 0x12e6 <pvPortMalloc+0x94>
    12e4:	46 c0       	rjmp	.+140    	; 0x1372 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    12e6:	cd 91       	ld	r28, X+
    12e8:	dc 91       	ld	r29, X
    12ea:	11 97       	sbiw	r26, 0x01	; 1
    12ec:	8e 01       	movw	r16, r28
    12ee:	0b 5f       	subi	r16, 0xFB	; 251
    12f0:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    12f2:	80 81       	ld	r24, Z
    12f4:	91 81       	ldd	r25, Z+1	; 0x01
    12f6:	8d 93       	st	X+, r24
    12f8:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    12fa:	82 81       	ldd	r24, Z+2	; 0x02
    12fc:	93 81       	ldd	r25, Z+3	; 0x03
    12fe:	82 1b       	sub	r24, r18
    1300:	93 0b       	sbc	r25, r19
    1302:	8b 30       	cpi	r24, 0x0B	; 11
    1304:	91 05       	cpc	r25, r1
    1306:	10 f1       	brcs	.+68     	; 0x134c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1308:	bf 01       	movw	r22, r30
    130a:	62 0f       	add	r22, r18
    130c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    130e:	db 01       	movw	r26, r22
    1310:	12 96       	adiw	r26, 0x02	; 2
    1312:	8d 93       	st	X+, r24
    1314:	9c 93       	st	X, r25
    1316:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1318:	22 83       	std	Z+2, r18	; 0x02
    131a:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    131c:	12 96       	adiw	r26, 0x02	; 2
    131e:	4d 91       	ld	r20, X+
    1320:	5c 91       	ld	r21, X
    1322:	13 97       	sbiw	r26, 0x03	; 3
    1324:	8f ee       	ldi	r24, 0xEF	; 239
    1326:	90 e2       	ldi	r25, 0x20	; 32
    1328:	01 c0       	rjmp	.+2      	; 0x132c <pvPortMalloc+0xda>
    132a:	cd 01       	movw	r24, r26
    132c:	ec 01       	movw	r28, r24
    132e:	a8 81       	ld	r26, Y
    1330:	b9 81       	ldd	r27, Y+1	; 0x01
    1332:	12 96       	adiw	r26, 0x02	; 2
    1334:	2d 91       	ld	r18, X+
    1336:	3c 91       	ld	r19, X
    1338:	13 97       	sbiw	r26, 0x03	; 3
    133a:	24 17       	cp	r18, r20
    133c:	35 07       	cpc	r19, r21
    133e:	a8 f3       	brcs	.-22     	; 0x132a <pvPortMalloc+0xd8>
    1340:	eb 01       	movw	r28, r22
    1342:	a8 83       	st	Y, r26
    1344:	b9 83       	std	Y+1, r27	; 0x01
    1346:	dc 01       	movw	r26, r24
    1348:	6d 93       	st	X+, r22
    134a:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    134c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1350:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1354:	22 81       	ldd	r18, Z+2	; 0x02
    1356:	33 81       	ldd	r19, Z+3	; 0x03
    1358:	82 1b       	sub	r24, r18
    135a:	93 0b       	sbc	r25, r19
    135c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1360:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1364:	08 c0       	rjmp	.+16     	; 0x1376 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1366:	00 e0       	ldi	r16, 0x00	; 0
    1368:	10 e0       	ldi	r17, 0x00	; 0
    136a:	05 c0       	rjmp	.+10     	; 0x1376 <pvPortMalloc+0x124>
    136c:	00 e0       	ldi	r16, 0x00	; 0
    136e:	10 e0       	ldi	r17, 0x00	; 0
    1370:	02 c0       	rjmp	.+4      	; 0x1376 <pvPortMalloc+0x124>
    1372:	00 e0       	ldi	r16, 0x00	; 0
    1374:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1376:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    137a:	c8 01       	movw	r24, r16
    137c:	df 91       	pop	r29
    137e:	cf 91       	pop	r28
    1380:	1f 91       	pop	r17
    1382:	0f 91       	pop	r16
    1384:	08 95       	ret

00001386 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1386:	0f 93       	push	r16
    1388:	1f 93       	push	r17
    138a:	cf 93       	push	r28
    138c:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    138e:	00 97       	sbiw	r24, 0x00	; 0
    1390:	41 f1       	breq	.+80     	; 0x13e2 <vPortFree+0x5c>
    1392:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1394:	8c 01       	movw	r16, r24
    1396:	05 50       	subi	r16, 0x05	; 5
    1398:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    139a:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    139e:	f8 01       	movw	r30, r16
    13a0:	42 81       	ldd	r20, Z+2	; 0x02
    13a2:	53 81       	ldd	r21, Z+3	; 0x03
    13a4:	af ee       	ldi	r26, 0xEF	; 239
    13a6:	b0 e2       	ldi	r27, 0x20	; 32
    13a8:	01 c0       	rjmp	.+2      	; 0x13ac <vPortFree+0x26>
    13aa:	df 01       	movw	r26, r30
    13ac:	ed 91       	ld	r30, X+
    13ae:	fc 91       	ld	r31, X
    13b0:	11 97       	sbiw	r26, 0x01	; 1
    13b2:	22 81       	ldd	r18, Z+2	; 0x02
    13b4:	33 81       	ldd	r19, Z+3	; 0x03
    13b6:	24 17       	cp	r18, r20
    13b8:	35 07       	cpc	r19, r21
    13ba:	b8 f3       	brcs	.-18     	; 0x13aa <vPortFree+0x24>
    13bc:	25 97       	sbiw	r28, 0x05	; 5
    13be:	e8 83       	st	Y, r30
    13c0:	f9 83       	std	Y+1, r31	; 0x01
    13c2:	0d 93       	st	X+, r16
    13c4:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    13c6:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    13ca:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    13ce:	8a 81       	ldd	r24, Y+2	; 0x02
    13d0:	9b 81       	ldd	r25, Y+3	; 0x03
    13d2:	82 0f       	add	r24, r18
    13d4:	93 1f       	adc	r25, r19
    13d6:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    13da:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    13de:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
	}
}
    13e2:	df 91       	pop	r29
    13e4:	cf 91       	pop	r28
    13e6:	1f 91       	pop	r17
    13e8:	0f 91       	pop	r16
    13ea:	08 95       	ret

000013ec <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    13ec:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    13f0:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    13f4:	08 95       	ret

000013f6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    13f6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    13f8:	03 96       	adiw	r24, 0x03	; 3
    13fa:	81 83       	std	Z+1, r24	; 0x01
    13fc:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    13fe:	4f ef       	ldi	r20, 0xFF	; 255
    1400:	5f ef       	ldi	r21, 0xFF	; 255
    1402:	ba 01       	movw	r22, r20
    1404:	43 83       	std	Z+3, r20	; 0x03
    1406:	54 83       	std	Z+4, r21	; 0x04
    1408:	65 83       	std	Z+5, r22	; 0x05
    140a:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    140c:	87 83       	std	Z+7, r24	; 0x07
    140e:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1410:	81 87       	std	Z+9, r24	; 0x09
    1412:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1414:	10 82       	st	Z, r1
    1416:	08 95       	ret

00001418 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1418:	fc 01       	movw	r30, r24
    141a:	12 86       	std	Z+10, r1	; 0x0a
    141c:	13 86       	std	Z+11, r1	; 0x0b
    141e:	08 95       	ret

00001420 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1420:	cf 93       	push	r28
    1422:	df 93       	push	r29
    1424:	fc 01       	movw	r30, r24
    1426:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1428:	21 81       	ldd	r18, Z+1	; 0x01
    142a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    142c:	e9 01       	movw	r28, r18
    142e:	8c 81       	ldd	r24, Y+4	; 0x04
    1430:	9d 81       	ldd	r25, Y+5	; 0x05
    1432:	14 96       	adiw	r26, 0x04	; 4
    1434:	8d 93       	st	X+, r24
    1436:	9c 93       	st	X, r25
    1438:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    143a:	81 81       	ldd	r24, Z+1	; 0x01
    143c:	92 81       	ldd	r25, Z+2	; 0x02
    143e:	16 96       	adiw	r26, 0x06	; 6
    1440:	8d 93       	st	X+, r24
    1442:	9c 93       	st	X, r25
    1444:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1446:	8c 81       	ldd	r24, Y+4	; 0x04
    1448:	9d 81       	ldd	r25, Y+5	; 0x05
    144a:	ec 01       	movw	r28, r24
    144c:	6e 83       	std	Y+6, r22	; 0x06
    144e:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1450:	e9 01       	movw	r28, r18
    1452:	6c 83       	std	Y+4, r22	; 0x04
    1454:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1456:	61 83       	std	Z+1, r22	; 0x01
    1458:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    145a:	1a 96       	adiw	r26, 0x0a	; 10
    145c:	ed 93       	st	X+, r30
    145e:	fc 93       	st	X, r31
    1460:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1462:	80 81       	ld	r24, Z
    1464:	8f 5f       	subi	r24, 0xFF	; 255
    1466:	80 83       	st	Z, r24
}
    1468:	df 91       	pop	r29
    146a:	cf 91       	pop	r28
    146c:	08 95       	ret

0000146e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    146e:	0f 93       	push	r16
    1470:	1f 93       	push	r17
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1478:	08 81       	ld	r16, Y
    147a:	19 81       	ldd	r17, Y+1	; 0x01
    147c:	2a 81       	ldd	r18, Y+2	; 0x02
    147e:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1480:	0f 3f       	cpi	r16, 0xFF	; 255
    1482:	4f ef       	ldi	r20, 0xFF	; 255
    1484:	14 07       	cpc	r17, r20
    1486:	24 07       	cpc	r18, r20
    1488:	34 07       	cpc	r19, r20
    148a:	31 f4       	brne	.+12     	; 0x1498 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    148c:	dc 01       	movw	r26, r24
    148e:	19 96       	adiw	r26, 0x09	; 9
    1490:	ed 91       	ld	r30, X+
    1492:	fc 91       	ld	r31, X
    1494:	1a 97       	sbiw	r26, 0x0a	; 10
    1496:	1f c0       	rjmp	.+62     	; 0x14d6 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1498:	fc 01       	movw	r30, r24
    149a:	33 96       	adiw	r30, 0x03	; 3
    149c:	dc 01       	movw	r26, r24
    149e:	17 96       	adiw	r26, 0x07	; 7
    14a0:	4d 91       	ld	r20, X+
    14a2:	5c 91       	ld	r21, X
    14a4:	18 97       	sbiw	r26, 0x08	; 8
    14a6:	da 01       	movw	r26, r20
    14a8:	4d 91       	ld	r20, X+
    14aa:	5d 91       	ld	r21, X+
    14ac:	6d 91       	ld	r22, X+
    14ae:	7c 91       	ld	r23, X
    14b0:	04 17       	cp	r16, r20
    14b2:	15 07       	cpc	r17, r21
    14b4:	26 07       	cpc	r18, r22
    14b6:	37 07       	cpc	r19, r23
    14b8:	70 f0       	brcs	.+28     	; 0x14d6 <vListInsert+0x68>
    14ba:	04 80       	ldd	r0, Z+4	; 0x04
    14bc:	f5 81       	ldd	r31, Z+5	; 0x05
    14be:	e0 2d       	mov	r30, r0
    14c0:	a4 81       	ldd	r26, Z+4	; 0x04
    14c2:	b5 81       	ldd	r27, Z+5	; 0x05
    14c4:	4d 91       	ld	r20, X+
    14c6:	5d 91       	ld	r21, X+
    14c8:	6d 91       	ld	r22, X+
    14ca:	7c 91       	ld	r23, X
    14cc:	04 17       	cp	r16, r20
    14ce:	15 07       	cpc	r17, r21
    14d0:	26 07       	cpc	r18, r22
    14d2:	37 07       	cpc	r19, r23
    14d4:	90 f7       	brcc	.-28     	; 0x14ba <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    14d6:	a4 81       	ldd	r26, Z+4	; 0x04
    14d8:	b5 81       	ldd	r27, Z+5	; 0x05
    14da:	ac 83       	std	Y+4, r26	; 0x04
    14dc:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    14de:	16 96       	adiw	r26, 0x06	; 6
    14e0:	cd 93       	st	X+, r28
    14e2:	dc 93       	st	X, r29
    14e4:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    14e6:	ee 83       	std	Y+6, r30	; 0x06
    14e8:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    14ea:	c4 83       	std	Z+4, r28	; 0x04
    14ec:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14ee:	8a 87       	std	Y+10, r24	; 0x0a
    14f0:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    14f2:	fc 01       	movw	r30, r24
    14f4:	20 81       	ld	r18, Z
    14f6:	2f 5f       	subi	r18, 0xFF	; 255
    14f8:	20 83       	st	Z, r18
}
    14fa:	df 91       	pop	r29
    14fc:	cf 91       	pop	r28
    14fe:	1f 91       	pop	r17
    1500:	0f 91       	pop	r16
    1502:	08 95       	ret

00001504 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1504:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1506:	a4 81       	ldd	r26, Z+4	; 0x04
    1508:	b5 81       	ldd	r27, Z+5	; 0x05
    150a:	86 81       	ldd	r24, Z+6	; 0x06
    150c:	97 81       	ldd	r25, Z+7	; 0x07
    150e:	16 96       	adiw	r26, 0x06	; 6
    1510:	8d 93       	st	X+, r24
    1512:	9c 93       	st	X, r25
    1514:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1516:	a6 81       	ldd	r26, Z+6	; 0x06
    1518:	b7 81       	ldd	r27, Z+7	; 0x07
    151a:	84 81       	ldd	r24, Z+4	; 0x04
    151c:	95 81       	ldd	r25, Z+5	; 0x05
    151e:	14 96       	adiw	r26, 0x04	; 4
    1520:	8d 93       	st	X+, r24
    1522:	9c 93       	st	X, r25
    1524:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1526:	a2 85       	ldd	r26, Z+10	; 0x0a
    1528:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    152a:	11 96       	adiw	r26, 0x01	; 1
    152c:	8d 91       	ld	r24, X+
    152e:	9c 91       	ld	r25, X
    1530:	12 97       	sbiw	r26, 0x02	; 2
    1532:	e8 17       	cp	r30, r24
    1534:	f9 07       	cpc	r31, r25
    1536:	31 f4       	brne	.+12     	; 0x1544 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1538:	86 81       	ldd	r24, Z+6	; 0x06
    153a:	97 81       	ldd	r25, Z+7	; 0x07
    153c:	11 96       	adiw	r26, 0x01	; 1
    153e:	8d 93       	st	X+, r24
    1540:	9c 93       	st	X, r25
    1542:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1544:	12 86       	std	Z+10, r1	; 0x0a
    1546:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1548:	8c 91       	ld	r24, X
    154a:	81 50       	subi	r24, 0x01	; 1
    154c:	8c 93       	st	X, r24
    154e:	08 95       	ret

00001550 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1550:	80 93 8e 31 	sts	0x318E, r24	; 0x80318e <portStackTopForTask>
    1554:	90 93 8f 31 	sts	0x318F, r25	; 0x80318f <portStackTopForTask+0x1>
    1558:	31 e1       	ldi	r19, 0x11	; 17
    155a:	fc 01       	movw	r30, r24
    155c:	30 83       	st	Z, r19
    155e:	31 97       	sbiw	r30, 0x01	; 1
    1560:	22 e2       	ldi	r18, 0x22	; 34
    1562:	20 83       	st	Z, r18
    1564:	31 97       	sbiw	r30, 0x01	; 1
    1566:	a3 e3       	ldi	r26, 0x33	; 51
    1568:	a0 83       	st	Z, r26
    156a:	31 97       	sbiw	r30, 0x01	; 1
    156c:	60 83       	st	Z, r22
    156e:	31 97       	sbiw	r30, 0x01	; 1
    1570:	70 83       	st	Z, r23
    1572:	31 97       	sbiw	r30, 0x01	; 1
    1574:	10 82       	st	Z, r1
    1576:	31 97       	sbiw	r30, 0x01	; 1
    1578:	10 82       	st	Z, r1
    157a:	31 97       	sbiw	r30, 0x01	; 1
    157c:	60 e8       	ldi	r22, 0x80	; 128
    157e:	60 83       	st	Z, r22
    1580:	31 97       	sbiw	r30, 0x01	; 1
    1582:	10 82       	st	Z, r1
    1584:	31 97       	sbiw	r30, 0x01	; 1
    1586:	10 82       	st	Z, r1
    1588:	31 97       	sbiw	r30, 0x01	; 1
    158a:	10 82       	st	Z, r1
    158c:	31 97       	sbiw	r30, 0x01	; 1
    158e:	62 e0       	ldi	r22, 0x02	; 2
    1590:	60 83       	st	Z, r22
    1592:	31 97       	sbiw	r30, 0x01	; 1
    1594:	63 e0       	ldi	r22, 0x03	; 3
    1596:	60 83       	st	Z, r22
    1598:	31 97       	sbiw	r30, 0x01	; 1
    159a:	64 e0       	ldi	r22, 0x04	; 4
    159c:	60 83       	st	Z, r22
    159e:	31 97       	sbiw	r30, 0x01	; 1
    15a0:	65 e0       	ldi	r22, 0x05	; 5
    15a2:	60 83       	st	Z, r22
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	66 e0       	ldi	r22, 0x06	; 6
    15a8:	60 83       	st	Z, r22
    15aa:	31 97       	sbiw	r30, 0x01	; 1
    15ac:	67 e0       	ldi	r22, 0x07	; 7
    15ae:	60 83       	st	Z, r22
    15b0:	31 97       	sbiw	r30, 0x01	; 1
    15b2:	68 e0       	ldi	r22, 0x08	; 8
    15b4:	60 83       	st	Z, r22
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	69 e0       	ldi	r22, 0x09	; 9
    15ba:	60 83       	st	Z, r22
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	60 e1       	ldi	r22, 0x10	; 16
    15c0:	60 83       	st	Z, r22
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	30 83       	st	Z, r19
    15c6:	31 97       	sbiw	r30, 0x01	; 1
    15c8:	32 e1       	ldi	r19, 0x12	; 18
    15ca:	30 83       	st	Z, r19
    15cc:	31 97       	sbiw	r30, 0x01	; 1
    15ce:	33 e1       	ldi	r19, 0x13	; 19
    15d0:	30 83       	st	Z, r19
    15d2:	31 97       	sbiw	r30, 0x01	; 1
    15d4:	34 e1       	ldi	r19, 0x14	; 20
    15d6:	30 83       	st	Z, r19
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	35 e1       	ldi	r19, 0x15	; 21
    15dc:	30 83       	st	Z, r19
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	36 e1       	ldi	r19, 0x16	; 22
    15e2:	30 83       	st	Z, r19
    15e4:	31 97       	sbiw	r30, 0x01	; 1
    15e6:	37 e1       	ldi	r19, 0x17	; 23
    15e8:	30 83       	st	Z, r19
    15ea:	31 97       	sbiw	r30, 0x01	; 1
    15ec:	38 e1       	ldi	r19, 0x18	; 24
    15ee:	30 83       	st	Z, r19
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	39 e1       	ldi	r19, 0x19	; 25
    15f4:	30 83       	st	Z, r19
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	30 e2       	ldi	r19, 0x20	; 32
    15fa:	30 83       	st	Z, r19
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	31 e2       	ldi	r19, 0x21	; 33
    1600:	30 83       	st	Z, r19
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	20 83       	st	Z, r18
    1606:	31 97       	sbiw	r30, 0x01	; 1
    1608:	23 e2       	ldi	r18, 0x23	; 35
    160a:	20 83       	st	Z, r18
    160c:	31 97       	sbiw	r30, 0x01	; 1
    160e:	40 83       	st	Z, r20
    1610:	31 97       	sbiw	r30, 0x01	; 1
    1612:	50 83       	st	Z, r21
    1614:	31 97       	sbiw	r30, 0x01	; 1
    1616:	26 e2       	ldi	r18, 0x26	; 38
    1618:	20 83       	st	Z, r18
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	27 e2       	ldi	r18, 0x27	; 39
    161e:	20 83       	st	Z, r18
    1620:	31 97       	sbiw	r30, 0x01	; 1
    1622:	28 e2       	ldi	r18, 0x28	; 40
    1624:	20 83       	st	Z, r18
    1626:	31 97       	sbiw	r30, 0x01	; 1
    1628:	29 e2       	ldi	r18, 0x29	; 41
    162a:	20 83       	st	Z, r18
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	20 e3       	ldi	r18, 0x30	; 48
    1630:	20 83       	st	Z, r18
    1632:	31 97       	sbiw	r30, 0x01	; 1
    1634:	21 e3       	ldi	r18, 0x31	; 49
    1636:	20 83       	st	Z, r18
    1638:	89 97       	sbiw	r24, 0x29	; 41
    163a:	08 95       	ret

0000163c <xPortStartScheduler>:
    163c:	8c e7       	ldi	r24, 0x7C	; 124
    163e:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1642:	8f ef       	ldi	r24, 0xFF	; 255
    1644:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    164e:	91 e1       	ldi	r25, 0x11	; 17
    1650:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1654:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1658:	a0 91 52 31 	lds	r26, 0x3152	; 0x803152 <pxCurrentTCB>
    165c:	b0 91 53 31 	lds	r27, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1660:	cd 91       	ld	r28, X+
    1662:	cd bf       	out	0x3d, r28	; 61
    1664:	dd 91       	ld	r29, X+
    1666:	de bf       	out	0x3e, r29	; 62
    1668:	ff 91       	pop	r31
    166a:	ef 91       	pop	r30
    166c:	df 91       	pop	r29
    166e:	cf 91       	pop	r28
    1670:	bf 91       	pop	r27
    1672:	af 91       	pop	r26
    1674:	9f 91       	pop	r25
    1676:	8f 91       	pop	r24
    1678:	7f 91       	pop	r23
    167a:	6f 91       	pop	r22
    167c:	5f 91       	pop	r21
    167e:	4f 91       	pop	r20
    1680:	3f 91       	pop	r19
    1682:	2f 91       	pop	r18
    1684:	1f 91       	pop	r17
    1686:	0f 91       	pop	r16
    1688:	ff 90       	pop	r15
    168a:	ef 90       	pop	r14
    168c:	df 90       	pop	r13
    168e:	cf 90       	pop	r12
    1690:	bf 90       	pop	r11
    1692:	af 90       	pop	r10
    1694:	9f 90       	pop	r9
    1696:	8f 90       	pop	r8
    1698:	7f 90       	pop	r7
    169a:	6f 90       	pop	r6
    169c:	5f 90       	pop	r5
    169e:	4f 90       	pop	r4
    16a0:	3f 90       	pop	r3
    16a2:	2f 90       	pop	r2
    16a4:	1f 90       	pop	r1
    16a6:	0f 90       	pop	r0
    16a8:	0c be       	out	0x3c, r0	; 60
    16aa:	0f 90       	pop	r0
    16ac:	0b be       	out	0x3b, r0	; 59
    16ae:	0f 90       	pop	r0
    16b0:	0f be       	out	0x3f, r0	; 63
    16b2:	0f 90       	pop	r0
    16b4:	08 95       	ret
    16b6:	08 95       	ret

000016b8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16b8:	0f 92       	push	r0
    16ba:	0f b6       	in	r0, 0x3f	; 63
    16bc:	f8 94       	cli
    16be:	0f 92       	push	r0
    16c0:	0b b6       	in	r0, 0x3b	; 59
    16c2:	0f 92       	push	r0
    16c4:	0c b6       	in	r0, 0x3c	; 60
    16c6:	0f 92       	push	r0
    16c8:	1f 92       	push	r1
    16ca:	11 24       	eor	r1, r1
    16cc:	2f 92       	push	r2
    16ce:	3f 92       	push	r3
    16d0:	4f 92       	push	r4
    16d2:	5f 92       	push	r5
    16d4:	6f 92       	push	r6
    16d6:	7f 92       	push	r7
    16d8:	8f 92       	push	r8
    16da:	9f 92       	push	r9
    16dc:	af 92       	push	r10
    16de:	bf 92       	push	r11
    16e0:	cf 92       	push	r12
    16e2:	df 92       	push	r13
    16e4:	ef 92       	push	r14
    16e6:	ff 92       	push	r15
    16e8:	0f 93       	push	r16
    16ea:	1f 93       	push	r17
    16ec:	2f 93       	push	r18
    16ee:	3f 93       	push	r19
    16f0:	4f 93       	push	r20
    16f2:	5f 93       	push	r21
    16f4:	6f 93       	push	r22
    16f6:	7f 93       	push	r23
    16f8:	8f 93       	push	r24
    16fa:	9f 93       	push	r25
    16fc:	af 93       	push	r26
    16fe:	bf 93       	push	r27
    1700:	cf 93       	push	r28
    1702:	df 93       	push	r29
    1704:	ef 93       	push	r30
    1706:	ff 93       	push	r31
    1708:	a0 91 52 31 	lds	r26, 0x3152	; 0x803152 <pxCurrentTCB>
    170c:	b0 91 53 31 	lds	r27, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1710:	0d b6       	in	r0, 0x3d	; 61
    1712:	0d 92       	st	X+, r0
    1714:	0e b6       	in	r0, 0x3e	; 62
    1716:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1718:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    171c:	a0 91 52 31 	lds	r26, 0x3152	; 0x803152 <pxCurrentTCB>
    1720:	b0 91 53 31 	lds	r27, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1724:	cd 91       	ld	r28, X+
    1726:	cd bf       	out	0x3d, r28	; 61
    1728:	dd 91       	ld	r29, X+
    172a:	de bf       	out	0x3e, r29	; 62
    172c:	ff 91       	pop	r31
    172e:	ef 91       	pop	r30
    1730:	df 91       	pop	r29
    1732:	cf 91       	pop	r28
    1734:	bf 91       	pop	r27
    1736:	af 91       	pop	r26
    1738:	9f 91       	pop	r25
    173a:	8f 91       	pop	r24
    173c:	7f 91       	pop	r23
    173e:	6f 91       	pop	r22
    1740:	5f 91       	pop	r21
    1742:	4f 91       	pop	r20
    1744:	3f 91       	pop	r19
    1746:	2f 91       	pop	r18
    1748:	1f 91       	pop	r17
    174a:	0f 91       	pop	r16
    174c:	ff 90       	pop	r15
    174e:	ef 90       	pop	r14
    1750:	df 90       	pop	r13
    1752:	cf 90       	pop	r12
    1754:	bf 90       	pop	r11
    1756:	af 90       	pop	r10
    1758:	9f 90       	pop	r9
    175a:	8f 90       	pop	r8
    175c:	7f 90       	pop	r7
    175e:	6f 90       	pop	r6
    1760:	5f 90       	pop	r5
    1762:	4f 90       	pop	r4
    1764:	3f 90       	pop	r3
    1766:	2f 90       	pop	r2
    1768:	1f 90       	pop	r1
    176a:	0f 90       	pop	r0
    176c:	0c be       	out	0x3c, r0	; 60
    176e:	0f 90       	pop	r0
    1770:	0b be       	out	0x3b, r0	; 59
    1772:	0f 90       	pop	r0
    1774:	0f be       	out	0x3f, r0	; 63
    1776:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1778:	08 95       	ret

0000177a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    177a:	0f 92       	push	r0
    177c:	0f b6       	in	r0, 0x3f	; 63
    177e:	f8 94       	cli
    1780:	0f 92       	push	r0
    1782:	0b b6       	in	r0, 0x3b	; 59
    1784:	0f 92       	push	r0
    1786:	0c b6       	in	r0, 0x3c	; 60
    1788:	0f 92       	push	r0
    178a:	1f 92       	push	r1
    178c:	11 24       	eor	r1, r1
    178e:	2f 92       	push	r2
    1790:	3f 92       	push	r3
    1792:	4f 92       	push	r4
    1794:	5f 92       	push	r5
    1796:	6f 92       	push	r6
    1798:	7f 92       	push	r7
    179a:	8f 92       	push	r8
    179c:	9f 92       	push	r9
    179e:	af 92       	push	r10
    17a0:	bf 92       	push	r11
    17a2:	cf 92       	push	r12
    17a4:	df 92       	push	r13
    17a6:	ef 92       	push	r14
    17a8:	ff 92       	push	r15
    17aa:	0f 93       	push	r16
    17ac:	1f 93       	push	r17
    17ae:	2f 93       	push	r18
    17b0:	3f 93       	push	r19
    17b2:	4f 93       	push	r20
    17b4:	5f 93       	push	r21
    17b6:	6f 93       	push	r22
    17b8:	7f 93       	push	r23
    17ba:	8f 93       	push	r24
    17bc:	9f 93       	push	r25
    17be:	af 93       	push	r26
    17c0:	bf 93       	push	r27
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	ef 93       	push	r30
    17c8:	ff 93       	push	r31
    17ca:	a0 91 52 31 	lds	r26, 0x3152	; 0x803152 <pxCurrentTCB>
    17ce:	b0 91 53 31 	lds	r27, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    17d2:	0d b6       	in	r0, 0x3d	; 61
    17d4:	0d 92       	st	X+, r0
    17d6:	0e b6       	in	r0, 0x3e	; 62
    17d8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    17da:	0e 94 5e 10 	call	0x20bc	; 0x20bc <vTaskIncrementTick>
	vTaskSwitchContext();
    17de:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17e2:	a0 91 52 31 	lds	r26, 0x3152	; 0x803152 <pxCurrentTCB>
    17e6:	b0 91 53 31 	lds	r27, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    17ea:	cd 91       	ld	r28, X+
    17ec:	cd bf       	out	0x3d, r28	; 61
    17ee:	dd 91       	ld	r29, X+
    17f0:	de bf       	out	0x3e, r29	; 62
    17f2:	ff 91       	pop	r31
    17f4:	ef 91       	pop	r30
    17f6:	df 91       	pop	r29
    17f8:	cf 91       	pop	r28
    17fa:	bf 91       	pop	r27
    17fc:	af 91       	pop	r26
    17fe:	9f 91       	pop	r25
    1800:	8f 91       	pop	r24
    1802:	7f 91       	pop	r23
    1804:	6f 91       	pop	r22
    1806:	5f 91       	pop	r21
    1808:	4f 91       	pop	r20
    180a:	3f 91       	pop	r19
    180c:	2f 91       	pop	r18
    180e:	1f 91       	pop	r17
    1810:	0f 91       	pop	r16
    1812:	ff 90       	pop	r15
    1814:	ef 90       	pop	r14
    1816:	df 90       	pop	r13
    1818:	cf 90       	pop	r12
    181a:	bf 90       	pop	r11
    181c:	af 90       	pop	r10
    181e:	9f 90       	pop	r9
    1820:	8f 90       	pop	r8
    1822:	7f 90       	pop	r7
    1824:	6f 90       	pop	r6
    1826:	5f 90       	pop	r5
    1828:	4f 90       	pop	r4
    182a:	3f 90       	pop	r3
    182c:	2f 90       	pop	r2
    182e:	1f 90       	pop	r1
    1830:	0f 90       	pop	r0
    1832:	0c be       	out	0x3c, r0	; 60
    1834:	0f 90       	pop	r0
    1836:	0b be       	out	0x3b, r0	; 59
    1838:	0f 90       	pop	r0
    183a:	0f be       	out	0x3f, r0	; 63
    183c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    183e:	08 95       	ret

00001840 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1840:	0e 94 bd 0b 	call	0x177a	; 0x177a <vPortYieldFromTick>
		asm volatile ( "reti" );
    1844:	18 95       	reti

00001846 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1846:	cf 93       	push	r28
    1848:	df 93       	push	r29
    184a:	ec 01       	movw	r28, r24
    184c:	88 a1       	ldd	r24, Y+32	; 0x20
    184e:	81 11       	cpse	r24, r1
    1850:	0b c0       	rjmp	.+22     	; 0x1868 <prvCopyDataToQueue+0x22>
    1852:	88 81       	ld	r24, Y
    1854:	99 81       	ldd	r25, Y+1	; 0x01
    1856:	89 2b       	or	r24, r25
    1858:	e1 f5       	brne	.+120    	; 0x18d2 <prvCopyDataToQueue+0x8c>
    185a:	8a 81       	ldd	r24, Y+2	; 0x02
    185c:	9b 81       	ldd	r25, Y+3	; 0x03
    185e:	0e 94 37 14 	call	0x286e	; 0x286e <vTaskPriorityDisinherit>
    1862:	1a 82       	std	Y+2, r1	; 0x02
    1864:	1b 82       	std	Y+3, r1	; 0x03
    1866:	35 c0       	rjmp	.+106    	; 0x18d2 <prvCopyDataToQueue+0x8c>
    1868:	41 11       	cpse	r20, r1
    186a:	17 c0       	rjmp	.+46     	; 0x189a <prvCopyDataToQueue+0x54>
    186c:	48 2f       	mov	r20, r24
    186e:	50 e0       	ldi	r21, 0x00	; 0
    1870:	8c 81       	ldd	r24, Y+4	; 0x04
    1872:	9d 81       	ldd	r25, Y+5	; 0x05
    1874:	0e 94 d0 1f 	call	0x3fa0	; 0x3fa0 <memcpy>
    1878:	28 a1       	ldd	r18, Y+32	; 0x20
    187a:	8c 81       	ldd	r24, Y+4	; 0x04
    187c:	9d 81       	ldd	r25, Y+5	; 0x05
    187e:	82 0f       	add	r24, r18
    1880:	91 1d       	adc	r25, r1
    1882:	8c 83       	std	Y+4, r24	; 0x04
    1884:	9d 83       	std	Y+5, r25	; 0x05
    1886:	2a 81       	ldd	r18, Y+2	; 0x02
    1888:	3b 81       	ldd	r19, Y+3	; 0x03
    188a:	82 17       	cp	r24, r18
    188c:	93 07       	cpc	r25, r19
    188e:	08 f1       	brcs	.+66     	; 0x18d2 <prvCopyDataToQueue+0x8c>
    1890:	88 81       	ld	r24, Y
    1892:	99 81       	ldd	r25, Y+1	; 0x01
    1894:	8c 83       	std	Y+4, r24	; 0x04
    1896:	9d 83       	std	Y+5, r25	; 0x05
    1898:	1c c0       	rjmp	.+56     	; 0x18d2 <prvCopyDataToQueue+0x8c>
    189a:	48 2f       	mov	r20, r24
    189c:	50 e0       	ldi	r21, 0x00	; 0
    189e:	8e 81       	ldd	r24, Y+6	; 0x06
    18a0:	9f 81       	ldd	r25, Y+7	; 0x07
    18a2:	0e 94 d0 1f 	call	0x3fa0	; 0x3fa0 <memcpy>
    18a6:	88 a1       	ldd	r24, Y+32	; 0x20
    18a8:	90 e0       	ldi	r25, 0x00	; 0
    18aa:	91 95       	neg	r25
    18ac:	81 95       	neg	r24
    18ae:	91 09       	sbc	r25, r1
    18b0:	2e 81       	ldd	r18, Y+6	; 0x06
    18b2:	3f 81       	ldd	r19, Y+7	; 0x07
    18b4:	28 0f       	add	r18, r24
    18b6:	39 1f       	adc	r19, r25
    18b8:	2e 83       	std	Y+6, r18	; 0x06
    18ba:	3f 83       	std	Y+7, r19	; 0x07
    18bc:	48 81       	ld	r20, Y
    18be:	59 81       	ldd	r21, Y+1	; 0x01
    18c0:	24 17       	cp	r18, r20
    18c2:	35 07       	cpc	r19, r21
    18c4:	30 f4       	brcc	.+12     	; 0x18d2 <prvCopyDataToQueue+0x8c>
    18c6:	2a 81       	ldd	r18, Y+2	; 0x02
    18c8:	3b 81       	ldd	r19, Y+3	; 0x03
    18ca:	82 0f       	add	r24, r18
    18cc:	93 1f       	adc	r25, r19
    18ce:	8e 83       	std	Y+6, r24	; 0x06
    18d0:	9f 83       	std	Y+7, r25	; 0x07
    18d2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18d4:	8f 5f       	subi	r24, 0xFF	; 255
    18d6:	8e 8f       	std	Y+30, r24	; 0x1e
    18d8:	df 91       	pop	r29
    18da:	cf 91       	pop	r28
    18dc:	08 95       	ret

000018de <prvCopyDataFromQueue>:
    18de:	fc 01       	movw	r30, r24
    18e0:	80 81       	ld	r24, Z
    18e2:	91 81       	ldd	r25, Z+1	; 0x01
    18e4:	00 97       	sbiw	r24, 0x00	; 0
    18e6:	a1 f0       	breq	.+40     	; 0x1910 <prvCopyDataFromQueue+0x32>
    18e8:	40 a1       	ldd	r20, Z+32	; 0x20
    18ea:	50 e0       	ldi	r21, 0x00	; 0
    18ec:	26 81       	ldd	r18, Z+6	; 0x06
    18ee:	37 81       	ldd	r19, Z+7	; 0x07
    18f0:	24 0f       	add	r18, r20
    18f2:	35 1f       	adc	r19, r21
    18f4:	26 83       	std	Z+6, r18	; 0x06
    18f6:	37 83       	std	Z+7, r19	; 0x07
    18f8:	a2 81       	ldd	r26, Z+2	; 0x02
    18fa:	b3 81       	ldd	r27, Z+3	; 0x03
    18fc:	2a 17       	cp	r18, r26
    18fe:	3b 07       	cpc	r19, r27
    1900:	10 f0       	brcs	.+4      	; 0x1906 <prvCopyDataFromQueue+0x28>
    1902:	86 83       	std	Z+6, r24	; 0x06
    1904:	97 83       	std	Z+7, r25	; 0x07
    1906:	cb 01       	movw	r24, r22
    1908:	66 81       	ldd	r22, Z+6	; 0x06
    190a:	77 81       	ldd	r23, Z+7	; 0x07
    190c:	0e 94 d0 1f 	call	0x3fa0	; 0x3fa0 <memcpy>
    1910:	08 95       	ret

00001912 <prvUnlockQueue>:
    1912:	0f 93       	push	r16
    1914:	1f 93       	push	r17
    1916:	cf 93       	push	r28
    1918:	df 93       	push	r29
    191a:	ec 01       	movw	r28, r24
    191c:	0f b6       	in	r0, 0x3f	; 63
    191e:	f8 94       	cli
    1920:	0f 92       	push	r0
    1922:	8a a1       	ldd	r24, Y+34	; 0x22
    1924:	18 16       	cp	r1, r24
    1926:	b4 f4       	brge	.+44     	; 0x1954 <prvUnlockQueue+0x42>
    1928:	8b 89       	ldd	r24, Y+19	; 0x13
    192a:	81 11       	cpse	r24, r1
    192c:	05 c0       	rjmp	.+10     	; 0x1938 <prvUnlockQueue+0x26>
    192e:	12 c0       	rjmp	.+36     	; 0x1954 <prvUnlockQueue+0x42>
    1930:	8b 89       	ldd	r24, Y+19	; 0x13
    1932:	81 11       	cpse	r24, r1
    1934:	04 c0       	rjmp	.+8      	; 0x193e <prvUnlockQueue+0x2c>
    1936:	0e c0       	rjmp	.+28     	; 0x1954 <prvUnlockQueue+0x42>
    1938:	8e 01       	movw	r16, r28
    193a:	0d 5e       	subi	r16, 0xED	; 237
    193c:	1f 4f       	sbci	r17, 0xFF	; 255
    193e:	c8 01       	movw	r24, r16
    1940:	0e 94 03 13 	call	0x2606	; 0x2606 <xTaskRemoveFromEventList>
    1944:	81 11       	cpse	r24, r1
    1946:	0e 94 c0 13 	call	0x2780	; 0x2780 <vTaskMissedYield>
    194a:	8a a1       	ldd	r24, Y+34	; 0x22
    194c:	81 50       	subi	r24, 0x01	; 1
    194e:	8a a3       	std	Y+34, r24	; 0x22
    1950:	18 16       	cp	r1, r24
    1952:	74 f3       	brlt	.-36     	; 0x1930 <prvUnlockQueue+0x1e>
    1954:	8f ef       	ldi	r24, 0xFF	; 255
    1956:	8a a3       	std	Y+34, r24	; 0x22
    1958:	0f 90       	pop	r0
    195a:	0f be       	out	0x3f, r0	; 63
    195c:	0f b6       	in	r0, 0x3f	; 63
    195e:	f8 94       	cli
    1960:	0f 92       	push	r0
    1962:	89 a1       	ldd	r24, Y+33	; 0x21
    1964:	18 16       	cp	r1, r24
    1966:	b4 f4       	brge	.+44     	; 0x1994 <prvUnlockQueue+0x82>
    1968:	88 85       	ldd	r24, Y+8	; 0x08
    196a:	81 11       	cpse	r24, r1
    196c:	05 c0       	rjmp	.+10     	; 0x1978 <prvUnlockQueue+0x66>
    196e:	12 c0       	rjmp	.+36     	; 0x1994 <prvUnlockQueue+0x82>
    1970:	88 85       	ldd	r24, Y+8	; 0x08
    1972:	81 11       	cpse	r24, r1
    1974:	04 c0       	rjmp	.+8      	; 0x197e <prvUnlockQueue+0x6c>
    1976:	0e c0       	rjmp	.+28     	; 0x1994 <prvUnlockQueue+0x82>
    1978:	8e 01       	movw	r16, r28
    197a:	08 5f       	subi	r16, 0xF8	; 248
    197c:	1f 4f       	sbci	r17, 0xFF	; 255
    197e:	c8 01       	movw	r24, r16
    1980:	0e 94 03 13 	call	0x2606	; 0x2606 <xTaskRemoveFromEventList>
    1984:	81 11       	cpse	r24, r1
    1986:	0e 94 c0 13 	call	0x2780	; 0x2780 <vTaskMissedYield>
    198a:	89 a1       	ldd	r24, Y+33	; 0x21
    198c:	81 50       	subi	r24, 0x01	; 1
    198e:	89 a3       	std	Y+33, r24	; 0x21
    1990:	18 16       	cp	r1, r24
    1992:	74 f3       	brlt	.-36     	; 0x1970 <prvUnlockQueue+0x5e>
    1994:	8f ef       	ldi	r24, 0xFF	; 255
    1996:	89 a3       	std	Y+33, r24	; 0x21
    1998:	0f 90       	pop	r0
    199a:	0f be       	out	0x3f, r0	; 63
    199c:	df 91       	pop	r29
    199e:	cf 91       	pop	r28
    19a0:	1f 91       	pop	r17
    19a2:	0f 91       	pop	r16
    19a4:	08 95       	ret

000019a6 <xQueueGenericReset>:
    19a6:	1f 93       	push	r17
    19a8:	cf 93       	push	r28
    19aa:	df 93       	push	r29
    19ac:	61 30       	cpi	r22, 0x01	; 1
    19ae:	59 f0       	breq	.+22     	; 0x19c6 <xQueueGenericReset+0x20>
    19b0:	fc 01       	movw	r30, r24
    19b2:	23 89       	ldd	r18, Z+19	; 0x13
    19b4:	30 85       	ldd	r19, Z+8	; 0x08
    19b6:	31 11       	cpse	r19, r1
    19b8:	2c c0       	rjmp	.+88     	; 0x1a12 <xQueueGenericReset+0x6c>
    19ba:	11 e0       	ldi	r17, 0x01	; 1
    19bc:	21 11       	cpse	r18, r1
    19be:	10 e0       	ldi	r17, 0x00	; 0
    19c0:	21 11       	cpse	r18, r1
    19c2:	28 c0       	rjmp	.+80     	; 0x1a14 <xQueueGenericReset+0x6e>
    19c4:	01 c0       	rjmp	.+2      	; 0x19c8 <xQueueGenericReset+0x22>
    19c6:	11 e0       	ldi	r17, 0x01	; 1
    19c8:	ec 01       	movw	r28, r24
    19ca:	48 81       	ld	r20, Y
    19cc:	59 81       	ldd	r21, Y+1	; 0x01
    19ce:	28 a1       	ldd	r18, Y+32	; 0x20
    19d0:	30 e0       	ldi	r19, 0x00	; 0
    19d2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    19d4:	62 9f       	mul	r22, r18
    19d6:	c0 01       	movw	r24, r0
    19d8:	63 9f       	mul	r22, r19
    19da:	90 0d       	add	r25, r0
    19dc:	11 24       	eor	r1, r1
    19de:	ba 01       	movw	r22, r20
    19e0:	68 0f       	add	r22, r24
    19e2:	79 1f       	adc	r23, r25
    19e4:	6a 83       	std	Y+2, r22	; 0x02
    19e6:	7b 83       	std	Y+3, r23	; 0x03
    19e8:	1e 8e       	std	Y+30, r1	; 0x1e
    19ea:	4c 83       	std	Y+4, r20	; 0x04
    19ec:	5d 83       	std	Y+5, r21	; 0x05
    19ee:	82 1b       	sub	r24, r18
    19f0:	93 0b       	sbc	r25, r19
    19f2:	84 0f       	add	r24, r20
    19f4:	95 1f       	adc	r25, r21
    19f6:	8e 83       	std	Y+6, r24	; 0x06
    19f8:	9f 83       	std	Y+7, r25	; 0x07
    19fa:	8f ef       	ldi	r24, 0xFF	; 255
    19fc:	89 a3       	std	Y+33, r24	; 0x21
    19fe:	8a a3       	std	Y+34, r24	; 0x22
    1a00:	ce 01       	movw	r24, r28
    1a02:	08 96       	adiw	r24, 0x08	; 8
    1a04:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1a08:	ce 01       	movw	r24, r28
    1a0a:	43 96       	adiw	r24, 0x13	; 19
    1a0c:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1a10:	01 c0       	rjmp	.+2      	; 0x1a14 <xQueueGenericReset+0x6e>
    1a12:	10 e0       	ldi	r17, 0x00	; 0
    1a14:	81 2f       	mov	r24, r17
    1a16:	df 91       	pop	r29
    1a18:	cf 91       	pop	r28
    1a1a:	1f 91       	pop	r17
    1a1c:	08 95       	ret

00001a1e <xQueueGenericCreate>:
    1a1e:	0f 93       	push	r16
    1a20:	1f 93       	push	r17
    1a22:	cf 93       	push	r28
    1a24:	df 93       	push	r29
    1a26:	88 23       	and	r24, r24
    1a28:	01 f1       	breq	.+64     	; 0x1a6a <xQueueGenericCreate+0x4c>
    1a2a:	06 2f       	mov	r16, r22
    1a2c:	18 2f       	mov	r17, r24
    1a2e:	83 e2       	ldi	r24, 0x23	; 35
    1a30:	90 e0       	ldi	r25, 0x00	; 0
    1a32:	0e 94 29 09 	call	0x1252	; 0x1252 <pvPortMalloc>
    1a36:	ec 01       	movw	r28, r24
    1a38:	89 2b       	or	r24, r25
    1a3a:	c9 f0       	breq	.+50     	; 0x1a6e <xQueueGenericCreate+0x50>
    1a3c:	10 9f       	mul	r17, r16
    1a3e:	c0 01       	movw	r24, r0
    1a40:	11 24       	eor	r1, r1
    1a42:	01 96       	adiw	r24, 0x01	; 1
    1a44:	0e 94 29 09 	call	0x1252	; 0x1252 <pvPortMalloc>
    1a48:	88 83       	st	Y, r24
    1a4a:	99 83       	std	Y+1, r25	; 0x01
    1a4c:	89 2b       	or	r24, r25
    1a4e:	39 f0       	breq	.+14     	; 0x1a5e <xQueueGenericCreate+0x40>
    1a50:	1f 8f       	std	Y+31, r17	; 0x1f
    1a52:	08 a3       	std	Y+32, r16	; 0x20
    1a54:	61 e0       	ldi	r22, 0x01	; 1
    1a56:	ce 01       	movw	r24, r28
    1a58:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <xQueueGenericReset>
    1a5c:	08 c0       	rjmp	.+16     	; 0x1a6e <xQueueGenericCreate+0x50>
    1a5e:	ce 01       	movw	r24, r28
    1a60:	0e 94 c3 09 	call	0x1386	; 0x1386 <vPortFree>
    1a64:	c0 e0       	ldi	r28, 0x00	; 0
    1a66:	d0 e0       	ldi	r29, 0x00	; 0
    1a68:	02 c0       	rjmp	.+4      	; 0x1a6e <xQueueGenericCreate+0x50>
    1a6a:	c0 e0       	ldi	r28, 0x00	; 0
    1a6c:	d0 e0       	ldi	r29, 0x00	; 0
    1a6e:	ce 01       	movw	r24, r28
    1a70:	df 91       	pop	r29
    1a72:	cf 91       	pop	r28
    1a74:	1f 91       	pop	r17
    1a76:	0f 91       	pop	r16
    1a78:	08 95       	ret

00001a7a <xQueueGenericSend>:
    1a7a:	af 92       	push	r10
    1a7c:	bf 92       	push	r11
    1a7e:	cf 92       	push	r12
    1a80:	df 92       	push	r13
    1a82:	ef 92       	push	r14
    1a84:	ff 92       	push	r15
    1a86:	0f 93       	push	r16
    1a88:	1f 93       	push	r17
    1a8a:	cf 93       	push	r28
    1a8c:	df 93       	push	r29
    1a8e:	cd b7       	in	r28, 0x3d	; 61
    1a90:	de b7       	in	r29, 0x3e	; 62
    1a92:	29 97       	sbiw	r28, 0x09	; 9
    1a94:	cd bf       	out	0x3d, r28	; 61
    1a96:	de bf       	out	0x3e, r29	; 62
    1a98:	7c 01       	movw	r14, r24
    1a9a:	5b 01       	movw	r10, r22
    1a9c:	2e 83       	std	Y+6, r18	; 0x06
    1a9e:	3f 83       	std	Y+7, r19	; 0x07
    1aa0:	48 87       	std	Y+8, r20	; 0x08
    1aa2:	59 87       	std	Y+9, r21	; 0x09
    1aa4:	10 e0       	ldi	r17, 0x00	; 0
    1aa6:	6c 01       	movw	r12, r24
    1aa8:	88 e0       	ldi	r24, 0x08	; 8
    1aaa:	c8 0e       	add	r12, r24
    1aac:	d1 1c       	adc	r13, r1
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	0f 92       	push	r0
    1ab4:	f7 01       	movw	r30, r14
    1ab6:	96 8d       	ldd	r25, Z+30	; 0x1e
    1ab8:	87 8d       	ldd	r24, Z+31	; 0x1f
    1aba:	98 17       	cp	r25, r24
    1abc:	a8 f4       	brcc	.+42     	; 0x1ae8 <xQueueGenericSend+0x6e>
    1abe:	40 2f       	mov	r20, r16
    1ac0:	b5 01       	movw	r22, r10
    1ac2:	c7 01       	movw	r24, r14
    1ac4:	0e 94 23 0c 	call	0x1846	; 0x1846 <prvCopyDataToQueue>
    1ac8:	f7 01       	movw	r30, r14
    1aca:	83 89       	ldd	r24, Z+19	; 0x13
    1acc:	88 23       	and	r24, r24
    1ace:	41 f0       	breq	.+16     	; 0x1ae0 <xQueueGenericSend+0x66>
    1ad0:	c7 01       	movw	r24, r14
    1ad2:	43 96       	adiw	r24, 0x13	; 19
    1ad4:	0e 94 03 13 	call	0x2606	; 0x2606 <xTaskRemoveFromEventList>
    1ad8:	81 30       	cpi	r24, 0x01	; 1
    1ada:	11 f4       	brne	.+4      	; 0x1ae0 <xQueueGenericSend+0x66>
    1adc:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
    1ae0:	0f 90       	pop	r0
    1ae2:	0f be       	out	0x3f, r0	; 63
    1ae4:	81 e0       	ldi	r24, 0x01	; 1
    1ae6:	56 c0       	rjmp	.+172    	; 0x1b94 <xQueueGenericSend+0x11a>
    1ae8:	8e 81       	ldd	r24, Y+6	; 0x06
    1aea:	9f 81       	ldd	r25, Y+7	; 0x07
    1aec:	a8 85       	ldd	r26, Y+8	; 0x08
    1aee:	b9 85       	ldd	r27, Y+9	; 0x09
    1af0:	89 2b       	or	r24, r25
    1af2:	8a 2b       	or	r24, r26
    1af4:	8b 2b       	or	r24, r27
    1af6:	21 f4       	brne	.+8      	; 0x1b00 <xQueueGenericSend+0x86>
    1af8:	0f 90       	pop	r0
    1afa:	0f be       	out	0x3f, r0	; 63
    1afc:	80 e0       	ldi	r24, 0x00	; 0
    1afe:	4a c0       	rjmp	.+148    	; 0x1b94 <xQueueGenericSend+0x11a>
    1b00:	11 11       	cpse	r17, r1
    1b02:	05 c0       	rjmp	.+10     	; 0x1b0e <xQueueGenericSend+0x94>
    1b04:	ce 01       	movw	r24, r28
    1b06:	01 96       	adiw	r24, 0x01	; 1
    1b08:	0e 94 42 13 	call	0x2684	; 0x2684 <vTaskSetTimeOutState>
    1b0c:	11 e0       	ldi	r17, 0x01	; 1
    1b0e:	0f 90       	pop	r0
    1b10:	0f be       	out	0x3f, r0	; 63
    1b12:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
    1b1c:	f7 01       	movw	r30, r14
    1b1e:	81 a1       	ldd	r24, Z+33	; 0x21
    1b20:	8f 3f       	cpi	r24, 0xFF	; 255
    1b22:	09 f4       	brne	.+2      	; 0x1b26 <xQueueGenericSend+0xac>
    1b24:	11 a2       	std	Z+33, r1	; 0x21
    1b26:	f7 01       	movw	r30, r14
    1b28:	82 a1       	ldd	r24, Z+34	; 0x22
    1b2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b2c:	09 f4       	brne	.+2      	; 0x1b30 <xQueueGenericSend+0xb6>
    1b2e:	12 a2       	std	Z+34, r1	; 0x22
    1b30:	0f 90       	pop	r0
    1b32:	0f be       	out	0x3f, r0	; 63
    1b34:	be 01       	movw	r22, r28
    1b36:	6a 5f       	subi	r22, 0xFA	; 250
    1b38:	7f 4f       	sbci	r23, 0xFF	; 255
    1b3a:	ce 01       	movw	r24, r28
    1b3c:	01 96       	adiw	r24, 0x01	; 1
    1b3e:	0e 94 53 13 	call	0x26a6	; 0x26a6 <xTaskCheckForTimeOut>
    1b42:	81 11       	cpse	r24, r1
    1b44:	21 c0       	rjmp	.+66     	; 0x1b88 <xQueueGenericSend+0x10e>
    1b46:	0f b6       	in	r0, 0x3f	; 63
    1b48:	f8 94       	cli
    1b4a:	0f 92       	push	r0
    1b4c:	f7 01       	movw	r30, r14
    1b4e:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b50:	0f 90       	pop	r0
    1b52:	0f be       	out	0x3f, r0	; 63
    1b54:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b56:	98 13       	cpse	r25, r24
    1b58:	11 c0       	rjmp	.+34     	; 0x1b7c <xQueueGenericSend+0x102>
    1b5a:	4e 81       	ldd	r20, Y+6	; 0x06
    1b5c:	5f 81       	ldd	r21, Y+7	; 0x07
    1b5e:	68 85       	ldd	r22, Y+8	; 0x08
    1b60:	79 85       	ldd	r23, Y+9	; 0x09
    1b62:	c6 01       	movw	r24, r12
    1b64:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <vTaskPlaceOnEventList>
    1b68:	c7 01       	movw	r24, r14
    1b6a:	0e 94 89 0c 	call	0x1912	; 0x1912 <prvUnlockQueue>
    1b6e:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
    1b72:	81 11       	cpse	r24, r1
    1b74:	9c cf       	rjmp	.-200    	; 0x1aae <xQueueGenericSend+0x34>
    1b76:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
    1b7a:	99 cf       	rjmp	.-206    	; 0x1aae <xQueueGenericSend+0x34>
    1b7c:	c7 01       	movw	r24, r14
    1b7e:	0e 94 89 0c 	call	0x1912	; 0x1912 <prvUnlockQueue>
    1b82:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
    1b86:	93 cf       	rjmp	.-218    	; 0x1aae <xQueueGenericSend+0x34>
    1b88:	c7 01       	movw	r24, r14
    1b8a:	0e 94 89 0c 	call	0x1912	; 0x1912 <prvUnlockQueue>
    1b8e:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
    1b92:	80 e0       	ldi	r24, 0x00	; 0
    1b94:	29 96       	adiw	r28, 0x09	; 9
    1b96:	cd bf       	out	0x3d, r28	; 61
    1b98:	de bf       	out	0x3e, r29	; 62
    1b9a:	df 91       	pop	r29
    1b9c:	cf 91       	pop	r28
    1b9e:	1f 91       	pop	r17
    1ba0:	0f 91       	pop	r16
    1ba2:	ff 90       	pop	r15
    1ba4:	ef 90       	pop	r14
    1ba6:	df 90       	pop	r13
    1ba8:	cf 90       	pop	r12
    1baa:	bf 90       	pop	r11
    1bac:	af 90       	pop	r10
    1bae:	08 95       	ret

00001bb0 <xQueueGenericReceive>:
    1bb0:	af 92       	push	r10
    1bb2:	bf 92       	push	r11
    1bb4:	cf 92       	push	r12
    1bb6:	df 92       	push	r13
    1bb8:	ef 92       	push	r14
    1bba:	ff 92       	push	r15
    1bbc:	0f 93       	push	r16
    1bbe:	1f 93       	push	r17
    1bc0:	cf 93       	push	r28
    1bc2:	df 93       	push	r29
    1bc4:	cd b7       	in	r28, 0x3d	; 61
    1bc6:	de b7       	in	r29, 0x3e	; 62
    1bc8:	29 97       	sbiw	r28, 0x09	; 9
    1bca:	cd bf       	out	0x3d, r28	; 61
    1bcc:	de bf       	out	0x3e, r29	; 62
    1bce:	7c 01       	movw	r14, r24
    1bd0:	5b 01       	movw	r10, r22
    1bd2:	2e 83       	std	Y+6, r18	; 0x06
    1bd4:	3f 83       	std	Y+7, r19	; 0x07
    1bd6:	48 87       	std	Y+8, r20	; 0x08
    1bd8:	59 87       	std	Y+9, r21	; 0x09
    1bda:	10 e0       	ldi	r17, 0x00	; 0
    1bdc:	6c 01       	movw	r12, r24
    1bde:	83 e1       	ldi	r24, 0x13	; 19
    1be0:	c8 0e       	add	r12, r24
    1be2:	d1 1c       	adc	r13, r1
    1be4:	0f b6       	in	r0, 0x3f	; 63
    1be6:	f8 94       	cli
    1be8:	0f 92       	push	r0
    1bea:	f7 01       	movw	r30, r14
    1bec:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bee:	88 23       	and	r24, r24
    1bf0:	99 f1       	breq	.+102    	; 0x1c58 <xQueueGenericReceive+0xa8>
    1bf2:	c6 80       	ldd	r12, Z+6	; 0x06
    1bf4:	d7 80       	ldd	r13, Z+7	; 0x07
    1bf6:	b5 01       	movw	r22, r10
    1bf8:	c7 01       	movw	r24, r14
    1bfa:	0e 94 6f 0c 	call	0x18de	; 0x18de <prvCopyDataFromQueue>
    1bfe:	01 11       	cpse	r16, r1
    1c00:	1a c0       	rjmp	.+52     	; 0x1c36 <xQueueGenericReceive+0x86>
    1c02:	f7 01       	movw	r30, r14
    1c04:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c06:	81 50       	subi	r24, 0x01	; 1
    1c08:	86 8f       	std	Z+30, r24	; 0x1e
    1c0a:	80 81       	ld	r24, Z
    1c0c:	91 81       	ldd	r25, Z+1	; 0x01
    1c0e:	89 2b       	or	r24, r25
    1c10:	29 f4       	brne	.+10     	; 0x1c1c <xQueueGenericReceive+0x6c>
    1c12:	0e 94 dd 13 	call	0x27ba	; 0x27ba <xTaskGetCurrentTaskHandle>
    1c16:	f7 01       	movw	r30, r14
    1c18:	82 83       	std	Z+2, r24	; 0x02
    1c1a:	93 83       	std	Z+3, r25	; 0x03
    1c1c:	f7 01       	movw	r30, r14
    1c1e:	80 85       	ldd	r24, Z+8	; 0x08
    1c20:	88 23       	and	r24, r24
    1c22:	b1 f0       	breq	.+44     	; 0x1c50 <xQueueGenericReceive+0xa0>
    1c24:	c7 01       	movw	r24, r14
    1c26:	08 96       	adiw	r24, 0x08	; 8
    1c28:	0e 94 03 13 	call	0x2606	; 0x2606 <xTaskRemoveFromEventList>
    1c2c:	81 30       	cpi	r24, 0x01	; 1
    1c2e:	81 f4       	brne	.+32     	; 0x1c50 <xQueueGenericReceive+0xa0>
    1c30:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
    1c34:	0d c0       	rjmp	.+26     	; 0x1c50 <xQueueGenericReceive+0xa0>
    1c36:	f7 01       	movw	r30, r14
    1c38:	c6 82       	std	Z+6, r12	; 0x06
    1c3a:	d7 82       	std	Z+7, r13	; 0x07
    1c3c:	83 89       	ldd	r24, Z+19	; 0x13
    1c3e:	88 23       	and	r24, r24
    1c40:	39 f0       	breq	.+14     	; 0x1c50 <xQueueGenericReceive+0xa0>
    1c42:	c7 01       	movw	r24, r14
    1c44:	43 96       	adiw	r24, 0x13	; 19
    1c46:	0e 94 03 13 	call	0x2606	; 0x2606 <xTaskRemoveFromEventList>
    1c4a:	81 11       	cpse	r24, r1
    1c4c:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
    1c50:	0f 90       	pop	r0
    1c52:	0f be       	out	0x3f, r0	; 63
    1c54:	81 e0       	ldi	r24, 0x01	; 1
    1c56:	62 c0       	rjmp	.+196    	; 0x1d1c <xQueueGenericReceive+0x16c>
    1c58:	8e 81       	ldd	r24, Y+6	; 0x06
    1c5a:	9f 81       	ldd	r25, Y+7	; 0x07
    1c5c:	a8 85       	ldd	r26, Y+8	; 0x08
    1c5e:	b9 85       	ldd	r27, Y+9	; 0x09
    1c60:	89 2b       	or	r24, r25
    1c62:	8a 2b       	or	r24, r26
    1c64:	8b 2b       	or	r24, r27
    1c66:	21 f4       	brne	.+8      	; 0x1c70 <xQueueGenericReceive+0xc0>
    1c68:	0f 90       	pop	r0
    1c6a:	0f be       	out	0x3f, r0	; 63
    1c6c:	80 e0       	ldi	r24, 0x00	; 0
    1c6e:	56 c0       	rjmp	.+172    	; 0x1d1c <xQueueGenericReceive+0x16c>
    1c70:	11 11       	cpse	r17, r1
    1c72:	05 c0       	rjmp	.+10     	; 0x1c7e <xQueueGenericReceive+0xce>
    1c74:	ce 01       	movw	r24, r28
    1c76:	01 96       	adiw	r24, 0x01	; 1
    1c78:	0e 94 42 13 	call	0x2684	; 0x2684 <vTaskSetTimeOutState>
    1c7c:	11 e0       	ldi	r17, 0x01	; 1
    1c7e:	0f 90       	pop	r0
    1c80:	0f be       	out	0x3f, r0	; 63
    1c82:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
    1c86:	0f b6       	in	r0, 0x3f	; 63
    1c88:	f8 94       	cli
    1c8a:	0f 92       	push	r0
    1c8c:	f7 01       	movw	r30, r14
    1c8e:	81 a1       	ldd	r24, Z+33	; 0x21
    1c90:	8f 3f       	cpi	r24, 0xFF	; 255
    1c92:	09 f4       	brne	.+2      	; 0x1c96 <xQueueGenericReceive+0xe6>
    1c94:	11 a2       	std	Z+33, r1	; 0x21
    1c96:	f7 01       	movw	r30, r14
    1c98:	82 a1       	ldd	r24, Z+34	; 0x22
    1c9a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c9c:	09 f4       	brne	.+2      	; 0x1ca0 <xQueueGenericReceive+0xf0>
    1c9e:	12 a2       	std	Z+34, r1	; 0x22
    1ca0:	0f 90       	pop	r0
    1ca2:	0f be       	out	0x3f, r0	; 63
    1ca4:	be 01       	movw	r22, r28
    1ca6:	6a 5f       	subi	r22, 0xFA	; 250
    1ca8:	7f 4f       	sbci	r23, 0xFF	; 255
    1caa:	ce 01       	movw	r24, r28
    1cac:	01 96       	adiw	r24, 0x01	; 1
    1cae:	0e 94 53 13 	call	0x26a6	; 0x26a6 <xTaskCheckForTimeOut>
    1cb2:	81 11       	cpse	r24, r1
    1cb4:	2d c0       	rjmp	.+90     	; 0x1d10 <xQueueGenericReceive+0x160>
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	f8 94       	cli
    1cba:	0f 92       	push	r0
    1cbc:	f7 01       	movw	r30, r14
    1cbe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cc0:	0f 90       	pop	r0
    1cc2:	0f be       	out	0x3f, r0	; 63
    1cc4:	81 11       	cpse	r24, r1
    1cc6:	1e c0       	rjmp	.+60     	; 0x1d04 <xQueueGenericReceive+0x154>
    1cc8:	80 81       	ld	r24, Z
    1cca:	91 81       	ldd	r25, Z+1	; 0x01
    1ccc:	89 2b       	or	r24, r25
    1cce:	49 f4       	brne	.+18     	; 0x1ce2 <xQueueGenericReceive+0x132>
    1cd0:	0f b6       	in	r0, 0x3f	; 63
    1cd2:	f8 94       	cli
    1cd4:	0f 92       	push	r0
    1cd6:	82 81       	ldd	r24, Z+2	; 0x02
    1cd8:	93 81       	ldd	r25, Z+3	; 0x03
    1cda:	0e 94 e2 13 	call	0x27c4	; 0x27c4 <vTaskPriorityInherit>
    1cde:	0f 90       	pop	r0
    1ce0:	0f be       	out	0x3f, r0	; 63
    1ce2:	4e 81       	ldd	r20, Y+6	; 0x06
    1ce4:	5f 81       	ldd	r21, Y+7	; 0x07
    1ce6:	68 85       	ldd	r22, Y+8	; 0x08
    1ce8:	79 85       	ldd	r23, Y+9	; 0x09
    1cea:	c6 01       	movw	r24, r12
    1cec:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <vTaskPlaceOnEventList>
    1cf0:	c7 01       	movw	r24, r14
    1cf2:	0e 94 89 0c 	call	0x1912	; 0x1912 <prvUnlockQueue>
    1cf6:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
    1cfa:	81 11       	cpse	r24, r1
    1cfc:	73 cf       	rjmp	.-282    	; 0x1be4 <xQueueGenericReceive+0x34>
    1cfe:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
    1d02:	70 cf       	rjmp	.-288    	; 0x1be4 <xQueueGenericReceive+0x34>
    1d04:	c7 01       	movw	r24, r14
    1d06:	0e 94 89 0c 	call	0x1912	; 0x1912 <prvUnlockQueue>
    1d0a:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
    1d0e:	6a cf       	rjmp	.-300    	; 0x1be4 <xQueueGenericReceive+0x34>
    1d10:	c7 01       	movw	r24, r14
    1d12:	0e 94 89 0c 	call	0x1912	; 0x1912 <prvUnlockQueue>
    1d16:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
    1d1a:	80 e0       	ldi	r24, 0x00	; 0
    1d1c:	29 96       	adiw	r28, 0x09	; 9
    1d1e:	cd bf       	out	0x3d, r28	; 61
    1d20:	de bf       	out	0x3e, r29	; 62
    1d22:	df 91       	pop	r29
    1d24:	cf 91       	pop	r28
    1d26:	1f 91       	pop	r17
    1d28:	0f 91       	pop	r16
    1d2a:	ff 90       	pop	r15
    1d2c:	ef 90       	pop	r14
    1d2e:	df 90       	pop	r13
    1d30:	cf 90       	pop	r12
    1d32:	bf 90       	pop	r11
    1d34:	af 90       	pop	r10
    1d36:	08 95       	ret

00001d38 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d38:	0f b6       	in	r0, 0x3f	; 63
    1d3a:	f8 94       	cli
    1d3c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d3e:	fc 01       	movw	r30, r24
    1d40:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d42:	0f 90       	pop	r0
    1d44:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d46:	08 95       	ret

00001d48 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d48:	c6 e2       	ldi	r28, 0x26	; 38
    1d4a:	d1 e3       	ldi	r29, 0x31	; 49
    1d4c:	88 81       	ld	r24, Y
    1d4e:	82 30       	cpi	r24, 0x02	; 2
    1d50:	e8 f3       	brcs	.-6      	; 0x1d4c <prvIdleTask+0x4>
    1d52:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
    1d56:	fa cf       	rjmp	.-12     	; 0x1d4c <prvIdleTask+0x4>

00001d58 <prvAddCurrentTaskToDelayedList>:
    1d58:	cf 92       	push	r12
    1d5a:	df 92       	push	r13
    1d5c:	ef 92       	push	r14
    1d5e:	ff 92       	push	r15
    1d60:	6b 01       	movw	r12, r22
    1d62:	7c 01       	movw	r14, r24
    1d64:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <pxCurrentTCB>
    1d68:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1d6c:	62 83       	std	Z+2, r22	; 0x02
    1d6e:	73 83       	std	Z+3, r23	; 0x03
    1d70:	84 83       	std	Z+4, r24	; 0x04
    1d72:	95 83       	std	Z+5, r25	; 0x05
    1d74:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    1d78:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    1d7c:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    1d80:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
    1d84:	c8 16       	cp	r12, r24
    1d86:	d9 06       	cpc	r13, r25
    1d88:	ea 06       	cpc	r14, r26
    1d8a:	fb 06       	cpc	r15, r27
    1d8c:	68 f4       	brcc	.+26     	; 0x1da8 <prvAddCurrentTaskToDelayedList+0x50>
    1d8e:	60 91 52 31 	lds	r22, 0x3152	; 0x803152 <pxCurrentTCB>
    1d92:	70 91 53 31 	lds	r23, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1d96:	80 91 0c 31 	lds	r24, 0x310C	; 0x80310c <pxOverflowDelayedTaskList>
    1d9a:	90 91 0d 31 	lds	r25, 0x310D	; 0x80310d <pxOverflowDelayedTaskList+0x1>
    1d9e:	6e 5f       	subi	r22, 0xFE	; 254
    1da0:	7f 4f       	sbci	r23, 0xFF	; 255
    1da2:	0e 94 37 0a 	call	0x146e	; 0x146e <vListInsert>
    1da6:	21 c0       	rjmp	.+66     	; 0x1dea <prvAddCurrentTaskToDelayedList+0x92>
    1da8:	60 91 52 31 	lds	r22, 0x3152	; 0x803152 <pxCurrentTCB>
    1dac:	70 91 53 31 	lds	r23, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1db0:	80 91 0e 31 	lds	r24, 0x310E	; 0x80310e <pxDelayedTaskList>
    1db4:	90 91 0f 31 	lds	r25, 0x310F	; 0x80310f <pxDelayedTaskList+0x1>
    1db8:	6e 5f       	subi	r22, 0xFE	; 254
    1dba:	7f 4f       	sbci	r23, 0xFF	; 255
    1dbc:	0e 94 37 0a 	call	0x146e	; 0x146e <vListInsert>
    1dc0:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1dc4:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dc8:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dcc:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dd0:	c8 16       	cp	r12, r24
    1dd2:	d9 06       	cpc	r13, r25
    1dd4:	ea 06       	cpc	r14, r26
    1dd6:	fb 06       	cpc	r15, r27
    1dd8:	40 f4       	brcc	.+16     	; 0x1dea <prvAddCurrentTaskToDelayedList+0x92>
    1dda:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1dde:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1de2:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1de6:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dea:	ff 90       	pop	r15
    1dec:	ef 90       	pop	r14
    1dee:	df 90       	pop	r13
    1df0:	cf 90       	pop	r12
    1df2:	08 95       	ret

00001df4 <xTaskGenericCreate>:
    1df4:	4f 92       	push	r4
    1df6:	5f 92       	push	r5
    1df8:	6f 92       	push	r6
    1dfa:	7f 92       	push	r7
    1dfc:	8f 92       	push	r8
    1dfe:	9f 92       	push	r9
    1e00:	af 92       	push	r10
    1e02:	bf 92       	push	r11
    1e04:	cf 92       	push	r12
    1e06:	df 92       	push	r13
    1e08:	ef 92       	push	r14
    1e0a:	ff 92       	push	r15
    1e0c:	0f 93       	push	r16
    1e0e:	1f 93       	push	r17
    1e10:	cf 93       	push	r28
    1e12:	df 93       	push	r29
    1e14:	5c 01       	movw	r10, r24
    1e16:	4b 01       	movw	r8, r22
    1e18:	3a 01       	movw	r6, r20
    1e1a:	29 01       	movw	r4, r18
    1e1c:	88 e2       	ldi	r24, 0x28	; 40
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	0e 94 29 09 	call	0x1252	; 0x1252 <pvPortMalloc>
    1e24:	ec 01       	movw	r28, r24
    1e26:	89 2b       	or	r24, r25
    1e28:	09 f4       	brne	.+2      	; 0x1e2c <xTaskGenericCreate+0x38>
    1e2a:	d4 c0       	rjmp	.+424    	; 0x1fd4 <xTaskGenericCreate+0x1e0>
    1e2c:	c1 14       	cp	r12, r1
    1e2e:	d1 04       	cpc	r13, r1
    1e30:	09 f0       	breq	.+2      	; 0x1e34 <xTaskGenericCreate+0x40>
    1e32:	cc c0       	rjmp	.+408    	; 0x1fcc <xTaskGenericCreate+0x1d8>
    1e34:	c3 01       	movw	r24, r6
    1e36:	0e 94 29 09 	call	0x1252	; 0x1252 <pvPortMalloc>
    1e3a:	8b 8f       	std	Y+27, r24	; 0x1b
    1e3c:	9c 8f       	std	Y+28, r25	; 0x1c
    1e3e:	00 97       	sbiw	r24, 0x00	; 0
    1e40:	21 f4       	brne	.+8      	; 0x1e4a <xTaskGenericCreate+0x56>
    1e42:	ce 01       	movw	r24, r28
    1e44:	0e 94 c3 09 	call	0x1386	; 0x1386 <vPortFree>
    1e48:	c5 c0       	rjmp	.+394    	; 0x1fd4 <xTaskGenericCreate+0x1e0>
    1e4a:	a3 01       	movw	r20, r6
    1e4c:	61 e1       	ldi	r22, 0x11	; 17
    1e4e:	70 e0       	ldi	r23, 0x00	; 0
    1e50:	0e 94 d9 1f 	call	0x3fb2	; 0x3fb2 <memset>
    1e54:	93 01       	movw	r18, r6
    1e56:	21 50       	subi	r18, 0x01	; 1
    1e58:	31 09       	sbc	r19, r1
    1e5a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e5c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e5e:	3c 01       	movw	r6, r24
    1e60:	62 0e       	add	r6, r18
    1e62:	73 1e       	adc	r7, r19
    1e64:	4a e0       	ldi	r20, 0x0A	; 10
    1e66:	50 e0       	ldi	r21, 0x00	; 0
    1e68:	b4 01       	movw	r22, r8
    1e6a:	ce 01       	movw	r24, r28
    1e6c:	4d 96       	adiw	r24, 0x1d	; 29
    1e6e:	0e 94 e0 1f 	call	0x3fc0	; 0x3fc0 <strncpy>
    1e72:	1e a2       	std	Y+38, r1	; 0x26
    1e74:	10 2f       	mov	r17, r16
    1e76:	04 30       	cpi	r16, 0x04	; 4
    1e78:	08 f0       	brcs	.+2      	; 0x1e7c <xTaskGenericCreate+0x88>
    1e7a:	13 e0       	ldi	r17, 0x03	; 3
    1e7c:	1a 8f       	std	Y+26, r17	; 0x1a
    1e7e:	1f a3       	std	Y+39, r17	; 0x27
    1e80:	6e 01       	movw	r12, r28
    1e82:	22 e0       	ldi	r18, 0x02	; 2
    1e84:	c2 0e       	add	r12, r18
    1e86:	d1 1c       	adc	r13, r1
    1e88:	c6 01       	movw	r24, r12
    1e8a:	0e 94 0c 0a 	call	0x1418	; 0x1418 <vListInitialiseItem>
    1e8e:	ce 01       	movw	r24, r28
    1e90:	0e 96       	adiw	r24, 0x0e	; 14
    1e92:	0e 94 0c 0a 	call	0x1418	; 0x1418 <vListInitialiseItem>
    1e96:	ca 87       	std	Y+10, r28	; 0x0a
    1e98:	db 87       	std	Y+11, r29	; 0x0b
    1e9a:	84 e0       	ldi	r24, 0x04	; 4
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	a0 e0       	ldi	r26, 0x00	; 0
    1ea0:	b0 e0       	ldi	r27, 0x00	; 0
    1ea2:	81 1b       	sub	r24, r17
    1ea4:	91 09       	sbc	r25, r1
    1ea6:	a1 09       	sbc	r26, r1
    1ea8:	b1 09       	sbc	r27, r1
    1eaa:	8e 87       	std	Y+14, r24	; 0x0e
    1eac:	9f 87       	std	Y+15, r25	; 0x0f
    1eae:	a8 8b       	std	Y+16, r26	; 0x10
    1eb0:	b9 8b       	std	Y+17, r27	; 0x11
    1eb2:	ce 8b       	std	Y+22, r28	; 0x16
    1eb4:	df 8b       	std	Y+23, r29	; 0x17
    1eb6:	a2 01       	movw	r20, r4
    1eb8:	b5 01       	movw	r22, r10
    1eba:	c3 01       	movw	r24, r6
    1ebc:	0e 94 a8 0a 	call	0x1550	; 0x1550 <pxPortInitialiseStack>
    1ec0:	88 83       	st	Y, r24
    1ec2:	99 83       	std	Y+1, r25	; 0x01
    1ec4:	e1 14       	cp	r14, r1
    1ec6:	f1 04       	cpc	r15, r1
    1ec8:	19 f0       	breq	.+6      	; 0x1ed0 <xTaskGenericCreate+0xdc>
    1eca:	f7 01       	movw	r30, r14
    1ecc:	c0 83       	st	Z, r28
    1ece:	d1 83       	std	Z+1, r29	; 0x01
    1ed0:	0f b6       	in	r0, 0x3f	; 63
    1ed2:	f8 94       	cli
    1ed4:	0f 92       	push	r0
    1ed6:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxCurrentNumberOfTasks>
    1eda:	8f 5f       	subi	r24, 0xFF	; 255
    1edc:	80 93 fe 30 	sts	0x30FE, r24	; 0x8030fe <uxCurrentNumberOfTasks>
    1ee0:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <pxCurrentTCB>
    1ee4:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1ee8:	89 2b       	or	r24, r25
    1eea:	89 f5       	brne	.+98     	; 0x1f4e <xTaskGenericCreate+0x15a>
    1eec:	c0 93 52 31 	sts	0x3152, r28	; 0x803152 <pxCurrentTCB>
    1ef0:	d0 93 53 31 	sts	0x3153, r29	; 0x803153 <pxCurrentTCB+0x1>
    1ef4:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxCurrentNumberOfTasks>
    1ef8:	81 30       	cpi	r24, 0x01	; 1
    1efa:	c1 f5       	brne	.+112    	; 0x1f6c <xTaskGenericCreate+0x178>
    1efc:	86 e2       	ldi	r24, 0x26	; 38
    1efe:	91 e3       	ldi	r25, 0x31	; 49
    1f00:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1f04:	81 e3       	ldi	r24, 0x31	; 49
    1f06:	91 e3       	ldi	r25, 0x31	; 49
    1f08:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1f0c:	8c e3       	ldi	r24, 0x3C	; 60
    1f0e:	91 e3       	ldi	r25, 0x31	; 49
    1f10:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1f14:	87 e4       	ldi	r24, 0x47	; 71
    1f16:	91 e3       	ldi	r25, 0x31	; 49
    1f18:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1f1c:	8b e1       	ldi	r24, 0x1B	; 27
    1f1e:	91 e3       	ldi	r25, 0x31	; 49
    1f20:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1f24:	80 e1       	ldi	r24, 0x10	; 16
    1f26:	91 e3       	ldi	r25, 0x31	; 49
    1f28:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1f2c:	81 e0       	ldi	r24, 0x01	; 1
    1f2e:	91 e3       	ldi	r25, 0x31	; 49
    1f30:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInitialise>
    1f34:	8b e1       	ldi	r24, 0x1B	; 27
    1f36:	91 e3       	ldi	r25, 0x31	; 49
    1f38:	80 93 0e 31 	sts	0x310E, r24	; 0x80310e <pxDelayedTaskList>
    1f3c:	90 93 0f 31 	sts	0x310F, r25	; 0x80310f <pxDelayedTaskList+0x1>
    1f40:	80 e1       	ldi	r24, 0x10	; 16
    1f42:	91 e3       	ldi	r25, 0x31	; 49
    1f44:	80 93 0c 31 	sts	0x310C, r24	; 0x80310c <pxOverflowDelayedTaskList>
    1f48:	90 93 0d 31 	sts	0x310D, r25	; 0x80310d <pxOverflowDelayedTaskList+0x1>
    1f4c:	0f c0       	rjmp	.+30     	; 0x1f6c <xTaskGenericCreate+0x178>
    1f4e:	80 91 f7 30 	lds	r24, 0x30F7	; 0x8030f7 <xSchedulerRunning>
    1f52:	81 11       	cpse	r24, r1
    1f54:	0b c0       	rjmp	.+22     	; 0x1f6c <xTaskGenericCreate+0x178>
    1f56:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <pxCurrentTCB>
    1f5a:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1f5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f60:	08 17       	cp	r16, r24
    1f62:	20 f0       	brcs	.+8      	; 0x1f6c <xTaskGenericCreate+0x178>
    1f64:	c0 93 52 31 	sts	0x3152, r28	; 0x803152 <pxCurrentTCB>
    1f68:	d0 93 53 31 	sts	0x3153, r29	; 0x803153 <pxCurrentTCB+0x1>
    1f6c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f6e:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <uxTopUsedPriority>
    1f72:	98 17       	cp	r25, r24
    1f74:	10 f4       	brcc	.+4      	; 0x1f7a <xTaskGenericCreate+0x186>
    1f76:	80 93 f9 30 	sts	0x30F9, r24	; 0x8030f9 <uxTopUsedPriority>
    1f7a:	90 91 f2 30 	lds	r25, 0x30F2	; 0x8030f2 <uxTaskNumber>
    1f7e:	9f 5f       	subi	r25, 0xFF	; 255
    1f80:	90 93 f2 30 	sts	0x30F2, r25	; 0x8030f2 <uxTaskNumber>
    1f84:	90 91 f8 30 	lds	r25, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    1f88:	98 17       	cp	r25, r24
    1f8a:	10 f4       	brcc	.+4      	; 0x1f90 <xTaskGenericCreate+0x19c>
    1f8c:	80 93 f8 30 	sts	0x30F8, r24	; 0x8030f8 <uxTopReadyPriority>
    1f90:	fb e0       	ldi	r31, 0x0B	; 11
    1f92:	8f 9f       	mul	r24, r31
    1f94:	c0 01       	movw	r24, r0
    1f96:	11 24       	eor	r1, r1
    1f98:	b6 01       	movw	r22, r12
    1f9a:	8a 5d       	subi	r24, 0xDA	; 218
    1f9c:	9e 4c       	sbci	r25, 0xCE	; 206
    1f9e:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInsertEnd>
    1fa2:	0f 90       	pop	r0
    1fa4:	0f be       	out	0x3f, r0	; 63
    1fa6:	80 91 f7 30 	lds	r24, 0x30F7	; 0x8030f7 <xSchedulerRunning>
    1faa:	88 23       	and	r24, r24
    1fac:	59 f0       	breq	.+22     	; 0x1fc4 <xTaskGenericCreate+0x1d0>
    1fae:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <pxCurrentTCB>
    1fb2:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    1fb6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb8:	80 17       	cp	r24, r16
    1fba:	30 f4       	brcc	.+12     	; 0x1fc8 <xTaskGenericCreate+0x1d4>
    1fbc:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
    1fc0:	81 e0       	ldi	r24, 0x01	; 1
    1fc2:	09 c0       	rjmp	.+18     	; 0x1fd6 <xTaskGenericCreate+0x1e2>
    1fc4:	81 e0       	ldi	r24, 0x01	; 1
    1fc6:	07 c0       	rjmp	.+14     	; 0x1fd6 <xTaskGenericCreate+0x1e2>
    1fc8:	81 e0       	ldi	r24, 0x01	; 1
    1fca:	05 c0       	rjmp	.+10     	; 0x1fd6 <xTaskGenericCreate+0x1e2>
    1fcc:	cb 8e       	std	Y+27, r12	; 0x1b
    1fce:	dc 8e       	std	Y+28, r13	; 0x1c
    1fd0:	c6 01       	movw	r24, r12
    1fd2:	3b cf       	rjmp	.-394    	; 0x1e4a <xTaskGenericCreate+0x56>
    1fd4:	8f ef       	ldi	r24, 0xFF	; 255
    1fd6:	df 91       	pop	r29
    1fd8:	cf 91       	pop	r28
    1fda:	1f 91       	pop	r17
    1fdc:	0f 91       	pop	r16
    1fde:	ff 90       	pop	r15
    1fe0:	ef 90       	pop	r14
    1fe2:	df 90       	pop	r13
    1fe4:	cf 90       	pop	r12
    1fe6:	bf 90       	pop	r11
    1fe8:	af 90       	pop	r10
    1fea:	9f 90       	pop	r9
    1fec:	8f 90       	pop	r8
    1fee:	7f 90       	pop	r7
    1ff0:	6f 90       	pop	r6
    1ff2:	5f 90       	pop	r5
    1ff4:	4f 90       	pop	r4
    1ff6:	08 95       	ret

00001ff8 <uxTaskPriorityGet>:
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	f8 94       	cli
    1ffc:	0f 92       	push	r0
    1ffe:	00 97       	sbiw	r24, 0x00	; 0
    2000:	21 f4       	brne	.+8      	; 0x200a <uxTaskPriorityGet+0x12>
    2002:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <pxCurrentTCB>
    2006:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    200a:	0f 90       	pop	r0
    200c:	0f be       	out	0x3f, r0	; 63
    200e:	fc 01       	movw	r30, r24
    2010:	82 8d       	ldd	r24, Z+26	; 0x1a
    2012:	08 95       	ret

00002014 <vTaskStartScheduler>:
    2014:	af 92       	push	r10
    2016:	bf 92       	push	r11
    2018:	cf 92       	push	r12
    201a:	df 92       	push	r13
    201c:	ef 92       	push	r14
    201e:	ff 92       	push	r15
    2020:	0f 93       	push	r16
    2022:	a1 2c       	mov	r10, r1
    2024:	b1 2c       	mov	r11, r1
    2026:	c1 2c       	mov	r12, r1
    2028:	d1 2c       	mov	r13, r1
    202a:	0f 2e       	mov	r0, r31
    202c:	ff ef       	ldi	r31, 0xFF	; 255
    202e:	ef 2e       	mov	r14, r31
    2030:	f0 e3       	ldi	r31, 0x30	; 48
    2032:	ff 2e       	mov	r15, r31
    2034:	f0 2d       	mov	r31, r0
    2036:	00 e0       	ldi	r16, 0x00	; 0
    2038:	20 e0       	ldi	r18, 0x00	; 0
    203a:	30 e0       	ldi	r19, 0x00	; 0
    203c:	44 e6       	ldi	r20, 0x64	; 100
    203e:	50 e0       	ldi	r21, 0x00	; 0
    2040:	66 e4       	ldi	r22, 0x46	; 70
    2042:	70 e2       	ldi	r23, 0x20	; 32
    2044:	84 ea       	ldi	r24, 0xA4	; 164
    2046:	9e e0       	ldi	r25, 0x0E	; 14
    2048:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <xTaskGenericCreate>
    204c:	81 30       	cpi	r24, 0x01	; 1
    204e:	69 f4       	brne	.+26     	; 0x206a <vTaskStartScheduler+0x56>
    2050:	f8 94       	cli
    2052:	80 93 f7 30 	sts	0x30F7, r24	; 0x8030f7 <xSchedulerRunning>
    2056:	10 92 fa 30 	sts	0x30FA, r1	; 0x8030fa <xTickCount>
    205a:	10 92 fb 30 	sts	0x30FB, r1	; 0x8030fb <xTickCount+0x1>
    205e:	10 92 fc 30 	sts	0x30FC, r1	; 0x8030fc <xTickCount+0x2>
    2062:	10 92 fd 30 	sts	0x30FD, r1	; 0x8030fd <xTickCount+0x3>
    2066:	0e 94 1e 0b 	call	0x163c	; 0x163c <xPortStartScheduler>
    206a:	0f 91       	pop	r16
    206c:	ff 90       	pop	r15
    206e:	ef 90       	pop	r14
    2070:	df 90       	pop	r13
    2072:	cf 90       	pop	r12
    2074:	bf 90       	pop	r11
    2076:	af 90       	pop	r10
    2078:	08 95       	ret

0000207a <vTaskSuspendAll>:
    207a:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxSchedulerSuspended>
    207e:	8f 5f       	subi	r24, 0xFF	; 255
    2080:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxSchedulerSuspended>
    2084:	08 95       	ret

00002086 <xTaskGetTickCount>:
    2086:	0f b6       	in	r0, 0x3f	; 63
    2088:	f8 94       	cli
    208a:	0f 92       	push	r0
    208c:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <xTickCount>
    2090:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <xTickCount+0x1>
    2094:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <xTickCount+0x2>
    2098:	90 91 fd 30 	lds	r25, 0x30FD	; 0x8030fd <xTickCount+0x3>
    209c:	0f 90       	pop	r0
    209e:	0f be       	out	0x3f, r0	; 63
    20a0:	08 95       	ret

000020a2 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20a2:	00 97       	sbiw	r24, 0x00	; 0
    20a4:	21 f4       	brne	.+8      	; 0x20ae <pcTaskGetTaskName+0xc>
    20a6:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <pxCurrentTCB>
    20aa:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20ae:	4d 96       	adiw	r24, 0x1d	; 29
    20b0:	08 95       	ret

000020b2 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20b2:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <xIdleTaskHandle>
    20b6:	90 91 00 31 	lds	r25, 0x3100	; 0x803100 <xIdleTaskHandle+0x1>
    20ba:	08 95       	ret

000020bc <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20bc:	ff 92       	push	r15
    20be:	0f 93       	push	r16
    20c0:	1f 93       	push	r17
    20c2:	cf 93       	push	r28
    20c4:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20c6:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxSchedulerSuspended>
    20ca:	81 11       	cpse	r24, r1
    20cc:	ed c0       	rjmp	.+474    	; 0x22a8 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    20ce:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    20d2:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    20d6:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    20da:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
    20de:	01 96       	adiw	r24, 0x01	; 1
    20e0:	a1 1d       	adc	r26, r1
    20e2:	b1 1d       	adc	r27, r1
    20e4:	80 93 fa 30 	sts	0x30FA, r24	; 0x8030fa <xTickCount>
    20e8:	90 93 fb 30 	sts	0x30FB, r25	; 0x8030fb <xTickCount+0x1>
    20ec:	a0 93 fc 30 	sts	0x30FC, r26	; 0x8030fc <xTickCount+0x2>
    20f0:	b0 93 fd 30 	sts	0x30FD, r27	; 0x8030fd <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    20f4:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    20f8:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    20fc:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    2100:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
    2104:	89 2b       	or	r24, r25
    2106:	8a 2b       	or	r24, r26
    2108:	8b 2b       	or	r24, r27
    210a:	f1 f5       	brne	.+124    	; 0x2188 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    210c:	80 91 0e 31 	lds	r24, 0x310E	; 0x80310e <pxDelayedTaskList>
    2110:	90 91 0f 31 	lds	r25, 0x310F	; 0x80310f <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2114:	20 91 0c 31 	lds	r18, 0x310C	; 0x80310c <pxOverflowDelayedTaskList>
    2118:	30 91 0d 31 	lds	r19, 0x310D	; 0x80310d <pxOverflowDelayedTaskList+0x1>
    211c:	20 93 0e 31 	sts	0x310E, r18	; 0x80310e <pxDelayedTaskList>
    2120:	30 93 0f 31 	sts	0x310F, r19	; 0x80310f <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2124:	80 93 0c 31 	sts	0x310C, r24	; 0x80310c <pxOverflowDelayedTaskList>
    2128:	90 93 0d 31 	sts	0x310D, r25	; 0x80310d <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    212c:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <xNumOfOverflows>
    2130:	8f 5f       	subi	r24, 0xFF	; 255
    2132:	80 93 f3 30 	sts	0x30F3, r24	; 0x8030f3 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2136:	e0 91 0e 31 	lds	r30, 0x310E	; 0x80310e <pxDelayedTaskList>
    213a:	f0 91 0f 31 	lds	r31, 0x310F	; 0x80310f <pxDelayedTaskList+0x1>
    213e:	80 81       	ld	r24, Z
    2140:	81 11       	cpse	r24, r1
    2142:	0c c0       	rjmp	.+24     	; 0x215c <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2144:	8f ef       	ldi	r24, 0xFF	; 255
    2146:	9f ef       	ldi	r25, 0xFF	; 255
    2148:	dc 01       	movw	r26, r24
    214a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    214e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2152:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2156:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    215a:	16 c0       	rjmp	.+44     	; 0x2188 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    215c:	e0 91 0e 31 	lds	r30, 0x310E	; 0x80310e <pxDelayedTaskList>
    2160:	f0 91 0f 31 	lds	r31, 0x310F	; 0x80310f <pxDelayedTaskList+0x1>
    2164:	07 80       	ldd	r0, Z+7	; 0x07
    2166:	f0 85       	ldd	r31, Z+8	; 0x08
    2168:	e0 2d       	mov	r30, r0
    216a:	00 84       	ldd	r0, Z+8	; 0x08
    216c:	f1 85       	ldd	r31, Z+9	; 0x09
    216e:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2170:	82 81       	ldd	r24, Z+2	; 0x02
    2172:	93 81       	ldd	r25, Z+3	; 0x03
    2174:	a4 81       	ldd	r26, Z+4	; 0x04
    2176:	b5 81       	ldd	r27, Z+5	; 0x05
    2178:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    217c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2180:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2184:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2188:	40 91 fa 30 	lds	r20, 0x30FA	; 0x8030fa <xTickCount>
    218c:	50 91 fb 30 	lds	r21, 0x30FB	; 0x8030fb <xTickCount+0x1>
    2190:	60 91 fc 30 	lds	r22, 0x30FC	; 0x8030fc <xTickCount+0x2>
    2194:	70 91 fd 30 	lds	r23, 0x30FD	; 0x8030fd <xTickCount+0x3>
    2198:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    219c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21a0:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21a4:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21a8:	48 17       	cp	r20, r24
    21aa:	59 07       	cpc	r21, r25
    21ac:	6a 07       	cpc	r22, r26
    21ae:	7b 07       	cpc	r23, r27
    21b0:	08 f4       	brcc	.+2      	; 0x21b4 <vTaskIncrementTick+0xf8>
    21b2:	7f c0       	rjmp	.+254    	; 0x22b2 <vTaskIncrementTick+0x1f6>
    21b4:	e0 91 0e 31 	lds	r30, 0x310E	; 0x80310e <pxDelayedTaskList>
    21b8:	f0 91 0f 31 	lds	r31, 0x310F	; 0x80310f <pxDelayedTaskList+0x1>
    21bc:	80 81       	ld	r24, Z
    21be:	88 23       	and	r24, r24
    21c0:	f9 f0       	breq	.+62     	; 0x2200 <vTaskIncrementTick+0x144>
    21c2:	e0 91 0e 31 	lds	r30, 0x310E	; 0x80310e <pxDelayedTaskList>
    21c6:	f0 91 0f 31 	lds	r31, 0x310F	; 0x80310f <pxDelayedTaskList+0x1>
    21ca:	07 80       	ldd	r0, Z+7	; 0x07
    21cc:	f0 85       	ldd	r31, Z+8	; 0x08
    21ce:	e0 2d       	mov	r30, r0
    21d0:	c0 85       	ldd	r28, Z+8	; 0x08
    21d2:	d1 85       	ldd	r29, Z+9	; 0x09
    21d4:	8a 81       	ldd	r24, Y+2	; 0x02
    21d6:	9b 81       	ldd	r25, Y+3	; 0x03
    21d8:	ac 81       	ldd	r26, Y+4	; 0x04
    21da:	bd 81       	ldd	r27, Y+5	; 0x05
    21dc:	40 91 fa 30 	lds	r20, 0x30FA	; 0x8030fa <xTickCount>
    21e0:	50 91 fb 30 	lds	r21, 0x30FB	; 0x8030fb <xTickCount+0x1>
    21e4:	60 91 fc 30 	lds	r22, 0x30FC	; 0x8030fc <xTickCount+0x2>
    21e8:	70 91 fd 30 	lds	r23, 0x30FD	; 0x8030fd <xTickCount+0x3>
    21ec:	48 17       	cp	r20, r24
    21ee:	59 07       	cpc	r21, r25
    21f0:	6a 07       	cpc	r22, r26
    21f2:	7b 07       	cpc	r23, r27
    21f4:	58 f1       	brcs	.+86     	; 0x224c <vTaskIncrementTick+0x190>
    21f6:	0f 2e       	mov	r0, r31
    21f8:	fb e0       	ldi	r31, 0x0B	; 11
    21fa:	ff 2e       	mov	r15, r31
    21fc:	f0 2d       	mov	r31, r0
    21fe:	2f c0       	rjmp	.+94     	; 0x225e <vTaskIncrementTick+0x1a2>
    2200:	8f ef       	ldi	r24, 0xFF	; 255
    2202:	9f ef       	ldi	r25, 0xFF	; 255
    2204:	dc 01       	movw	r26, r24
    2206:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    220a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    220e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2212:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2216:	4d c0       	rjmp	.+154    	; 0x22b2 <vTaskIncrementTick+0x1f6>
    2218:	e0 91 0e 31 	lds	r30, 0x310E	; 0x80310e <pxDelayedTaskList>
    221c:	f0 91 0f 31 	lds	r31, 0x310F	; 0x80310f <pxDelayedTaskList+0x1>
    2220:	07 80       	ldd	r0, Z+7	; 0x07
    2222:	f0 85       	ldd	r31, Z+8	; 0x08
    2224:	e0 2d       	mov	r30, r0
    2226:	c0 85       	ldd	r28, Z+8	; 0x08
    2228:	d1 85       	ldd	r29, Z+9	; 0x09
    222a:	8a 81       	ldd	r24, Y+2	; 0x02
    222c:	9b 81       	ldd	r25, Y+3	; 0x03
    222e:	ac 81       	ldd	r26, Y+4	; 0x04
    2230:	bd 81       	ldd	r27, Y+5	; 0x05
    2232:	40 91 fa 30 	lds	r20, 0x30FA	; 0x8030fa <xTickCount>
    2236:	50 91 fb 30 	lds	r21, 0x30FB	; 0x8030fb <xTickCount+0x1>
    223a:	60 91 fc 30 	lds	r22, 0x30FC	; 0x8030fc <xTickCount+0x2>
    223e:	70 91 fd 30 	lds	r23, 0x30FD	; 0x8030fd <xTickCount+0x3>
    2242:	48 17       	cp	r20, r24
    2244:	59 07       	cpc	r21, r25
    2246:	6a 07       	cpc	r22, r26
    2248:	7b 07       	cpc	r23, r27
    224a:	48 f4       	brcc	.+18     	; 0x225e <vTaskIncrementTick+0x1a2>
    224c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2250:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2254:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2258:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    225c:	2a c0       	rjmp	.+84     	; 0x22b2 <vTaskIncrementTick+0x1f6>
    225e:	8e 01       	movw	r16, r28
    2260:	0e 5f       	subi	r16, 0xFE	; 254
    2262:	1f 4f       	sbci	r17, 0xFF	; 255
    2264:	c8 01       	movw	r24, r16
    2266:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>
    226a:	88 8d       	ldd	r24, Y+24	; 0x18
    226c:	99 8d       	ldd	r25, Y+25	; 0x19
    226e:	89 2b       	or	r24, r25
    2270:	21 f0       	breq	.+8      	; 0x227a <vTaskIncrementTick+0x1be>
    2272:	ce 01       	movw	r24, r28
    2274:	0e 96       	adiw	r24, 0x0e	; 14
    2276:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>
    227a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    227c:	90 91 f8 30 	lds	r25, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    2280:	98 17       	cp	r25, r24
    2282:	10 f4       	brcc	.+4      	; 0x2288 <vTaskIncrementTick+0x1cc>
    2284:	80 93 f8 30 	sts	0x30F8, r24	; 0x8030f8 <uxTopReadyPriority>
    2288:	f8 9e       	mul	r15, r24
    228a:	c0 01       	movw	r24, r0
    228c:	11 24       	eor	r1, r1
    228e:	b8 01       	movw	r22, r16
    2290:	8a 5d       	subi	r24, 0xDA	; 218
    2292:	9e 4c       	sbci	r25, 0xCE	; 206
    2294:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInsertEnd>
    2298:	e0 91 0e 31 	lds	r30, 0x310E	; 0x80310e <pxDelayedTaskList>
    229c:	f0 91 0f 31 	lds	r31, 0x310F	; 0x80310f <pxDelayedTaskList+0x1>
    22a0:	80 81       	ld	r24, Z
    22a2:	81 11       	cpse	r24, r1
    22a4:	b9 cf       	rjmp	.-142    	; 0x2218 <vTaskIncrementTick+0x15c>
    22a6:	ac cf       	rjmp	.-168    	; 0x2200 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22a8:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <uxMissedTicks>
    22ac:	8f 5f       	subi	r24, 0xFF	; 255
    22ae:	80 93 f5 30 	sts	0x30F5, r24	; 0x8030f5 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22b2:	df 91       	pop	r29
    22b4:	cf 91       	pop	r28
    22b6:	1f 91       	pop	r17
    22b8:	0f 91       	pop	r16
    22ba:	ff 90       	pop	r15
    22bc:	08 95       	ret

000022be <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22be:	cf 92       	push	r12
    22c0:	df 92       	push	r13
    22c2:	ef 92       	push	r14
    22c4:	ff 92       	push	r15
    22c6:	0f 93       	push	r16
    22c8:	1f 93       	push	r17
    22ca:	cf 93       	push	r28
    22cc:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    22ce:	0f b6       	in	r0, 0x3f	; 63
    22d0:	f8 94       	cli
    22d2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    22d4:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxSchedulerSuspended>
    22d8:	81 50       	subi	r24, 0x01	; 1
    22da:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22de:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxSchedulerSuspended>
    22e2:	81 11       	cpse	r24, r1
    22e4:	60 c0       	rjmp	.+192    	; 0x23a6 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    22e6:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxCurrentNumberOfTasks>
    22ea:	81 11       	cpse	r24, r1
    22ec:	2c c0       	rjmp	.+88     	; 0x2346 <xTaskResumeAll+0x88>
    22ee:	5e c0       	rjmp	.+188    	; 0x23ac <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    22f0:	d7 01       	movw	r26, r14
    22f2:	17 96       	adiw	r26, 0x07	; 7
    22f4:	ed 91       	ld	r30, X+
    22f6:	fc 91       	ld	r31, X
    22f8:	18 97       	sbiw	r26, 0x08	; 8
    22fa:	c0 85       	ldd	r28, Z+8	; 0x08
    22fc:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    22fe:	ce 01       	movw	r24, r28
    2300:	0e 96       	adiw	r24, 0x0e	; 14
    2302:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2306:	8e 01       	movw	r16, r28
    2308:	0e 5f       	subi	r16, 0xFE	; 254
    230a:	1f 4f       	sbci	r17, 0xFF	; 255
    230c:	c8 01       	movw	r24, r16
    230e:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2312:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2314:	90 91 f8 30 	lds	r25, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    2318:	98 17       	cp	r25, r24
    231a:	10 f4       	brcc	.+4      	; 0x2320 <xTaskResumeAll+0x62>
    231c:	80 93 f8 30 	sts	0x30F8, r24	; 0x8030f8 <uxTopReadyPriority>
    2320:	d8 9e       	mul	r13, r24
    2322:	c0 01       	movw	r24, r0
    2324:	11 24       	eor	r1, r1
    2326:	b8 01       	movw	r22, r16
    2328:	8a 5d       	subi	r24, 0xDA	; 218
    232a:	9e 4c       	sbci	r25, 0xCE	; 206
    232c:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2330:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <pxCurrentTCB>
    2334:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    2338:	9a 8d       	ldd	r25, Y+26	; 0x1a
    233a:	82 8d       	ldd	r24, Z+26	; 0x1a
    233c:	98 17       	cp	r25, r24
    233e:	70 f0       	brcs	.+28     	; 0x235c <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2340:	cc 24       	eor	r12, r12
    2342:	c3 94       	inc	r12
    2344:	0b c0       	rjmp	.+22     	; 0x235c <xTaskResumeAll+0x9e>
    2346:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2348:	0f 2e       	mov	r0, r31
    234a:	f1 e0       	ldi	r31, 0x01	; 1
    234c:	ef 2e       	mov	r14, r31
    234e:	f1 e3       	ldi	r31, 0x31	; 49
    2350:	ff 2e       	mov	r15, r31
    2352:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2354:	0f 2e       	mov	r0, r31
    2356:	fb e0       	ldi	r31, 0x0B	; 11
    2358:	df 2e       	mov	r13, r31
    235a:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    235c:	f7 01       	movw	r30, r14
    235e:	80 81       	ld	r24, Z
    2360:	81 11       	cpse	r24, r1
    2362:	c6 cf       	rjmp	.-116    	; 0x22f0 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2364:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <uxMissedTicks>
    2368:	88 23       	and	r24, r24
    236a:	81 f0       	breq	.+32     	; 0x238c <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    236c:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <uxMissedTicks>
    2370:	88 23       	and	r24, r24
    2372:	99 f0       	breq	.+38     	; 0x239a <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2374:	0e 94 5e 10 	call	0x20bc	; 0x20bc <vTaskIncrementTick>
						--uxMissedTicks;
    2378:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <uxMissedTicks>
    237c:	81 50       	subi	r24, 0x01	; 1
    237e:	80 93 f5 30 	sts	0x30F5, r24	; 0x8030f5 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2382:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <uxMissedTicks>
    2386:	81 11       	cpse	r24, r1
    2388:	f5 cf       	rjmp	.-22     	; 0x2374 <xTaskResumeAll+0xb6>
    238a:	07 c0       	rjmp	.+14     	; 0x239a <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    238c:	f1 e0       	ldi	r31, 0x01	; 1
    238e:	cf 16       	cp	r12, r31
    2390:	21 f0       	breq	.+8      	; 0x239a <xTaskResumeAll+0xdc>
    2392:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <xMissedYield>
    2396:	81 30       	cpi	r24, 0x01	; 1
    2398:	41 f4       	brne	.+16     	; 0x23aa <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    239a:	10 92 f4 30 	sts	0x30F4, r1	; 0x8030f4 <xMissedYield>
					portYIELD_WITHIN_API();
    239e:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23a2:	81 e0       	ldi	r24, 0x01	; 1
    23a4:	03 c0       	rjmp	.+6      	; 0x23ac <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23a6:	80 e0       	ldi	r24, 0x00	; 0
    23a8:	01 c0       	rjmp	.+2      	; 0x23ac <xTaskResumeAll+0xee>
    23aa:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23ac:	0f 90       	pop	r0
    23ae:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23b0:	df 91       	pop	r29
    23b2:	cf 91       	pop	r28
    23b4:	1f 91       	pop	r17
    23b6:	0f 91       	pop	r16
    23b8:	ff 90       	pop	r15
    23ba:	ef 90       	pop	r14
    23bc:	df 90       	pop	r13
    23be:	cf 90       	pop	r12
    23c0:	08 95       	ret

000023c2 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    23c2:	cf 92       	push	r12
    23c4:	df 92       	push	r13
    23c6:	ef 92       	push	r14
    23c8:	ff 92       	push	r15
    23ca:	cf 93       	push	r28
    23cc:	df 93       	push	r29
    23ce:	ec 01       	movw	r28, r24
    23d0:	6a 01       	movw	r12, r20
    23d2:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    23d4:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    23d8:	88 81       	ld	r24, Y
    23da:	99 81       	ldd	r25, Y+1	; 0x01
    23dc:	aa 81       	ldd	r26, Y+2	; 0x02
    23de:	bb 81       	ldd	r27, Y+3	; 0x03
    23e0:	c8 0e       	add	r12, r24
    23e2:	d9 1e       	adc	r13, r25
    23e4:	ea 1e       	adc	r14, r26
    23e6:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    23e8:	40 91 fa 30 	lds	r20, 0x30FA	; 0x8030fa <xTickCount>
    23ec:	50 91 fb 30 	lds	r21, 0x30FB	; 0x8030fb <xTickCount+0x1>
    23f0:	60 91 fc 30 	lds	r22, 0x30FC	; 0x8030fc <xTickCount+0x2>
    23f4:	70 91 fd 30 	lds	r23, 0x30FD	; 0x8030fd <xTickCount+0x3>
    23f8:	48 17       	cp	r20, r24
    23fa:	59 07       	cpc	r21, r25
    23fc:	6a 07       	cpc	r22, r26
    23fe:	7b 07       	cpc	r23, r27
    2400:	b8 f4       	brcc	.+46     	; 0x2430 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2402:	c8 16       	cp	r12, r24
    2404:	d9 06       	cpc	r13, r25
    2406:	ea 06       	cpc	r14, r26
    2408:	fb 06       	cpc	r15, r27
    240a:	e0 f5       	brcc	.+120    	; 0x2484 <vTaskDelayUntil+0xc2>
    240c:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    2410:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    2414:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    2418:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    241c:	c8 82       	st	Y, r12
    241e:	d9 82       	std	Y+1, r13	; 0x01
    2420:	ea 82       	std	Y+2, r14	; 0x02
    2422:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2424:	8c 15       	cp	r24, r12
    2426:	9d 05       	cpc	r25, r13
    2428:	ae 05       	cpc	r26, r14
    242a:	bf 05       	cpc	r27, r15
    242c:	f8 f4       	brcc	.+62     	; 0x246c <vTaskDelayUntil+0xaa>
    242e:	13 c0       	rjmp	.+38     	; 0x2456 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2430:	c8 16       	cp	r12, r24
    2432:	d9 06       	cpc	r13, r25
    2434:	ea 06       	cpc	r14, r26
    2436:	fb 06       	cpc	r15, r27
    2438:	00 f1       	brcs	.+64     	; 0x247a <vTaskDelayUntil+0xb8>
    243a:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    243e:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    2442:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    2446:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
    244a:	8c 15       	cp	r24, r12
    244c:	9d 05       	cpc	r25, r13
    244e:	ae 05       	cpc	r26, r14
    2450:	bf 05       	cpc	r27, r15
    2452:	98 f0       	brcs	.+38     	; 0x247a <vTaskDelayUntil+0xb8>
    2454:	17 c0       	rjmp	.+46     	; 0x2484 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2456:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <pxCurrentTCB>
    245a:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    245e:	02 96       	adiw	r24, 0x02	; 2
    2460:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2464:	c7 01       	movw	r24, r14
    2466:	b6 01       	movw	r22, r12
    2468:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    246c:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2470:	81 11       	cpse	r24, r1
    2472:	0d c0       	rjmp	.+26     	; 0x248e <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2474:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
		}
	}
    2478:	0a c0       	rjmp	.+20     	; 0x248e <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    247a:	c8 82       	st	Y, r12
    247c:	d9 82       	std	Y+1, r13	; 0x01
    247e:	ea 82       	std	Y+2, r14	; 0x02
    2480:	fb 82       	std	Y+3, r15	; 0x03
    2482:	e9 cf       	rjmp	.-46     	; 0x2456 <vTaskDelayUntil+0x94>
    2484:	c8 82       	st	Y, r12
    2486:	d9 82       	std	Y+1, r13	; 0x01
    2488:	ea 82       	std	Y+2, r14	; 0x02
    248a:	fb 82       	std	Y+3, r15	; 0x03
    248c:	ef cf       	rjmp	.-34     	; 0x246c <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    248e:	df 91       	pop	r29
    2490:	cf 91       	pop	r28
    2492:	ff 90       	pop	r15
    2494:	ef 90       	pop	r14
    2496:	df 90       	pop	r13
    2498:	cf 90       	pop	r12
    249a:	08 95       	ret

0000249c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    249c:	cf 92       	push	r12
    249e:	df 92       	push	r13
    24a0:	ef 92       	push	r14
    24a2:	ff 92       	push	r15
    24a4:	6b 01       	movw	r12, r22
    24a6:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24a8:	67 2b       	or	r22, r23
    24aa:	68 2b       	or	r22, r24
    24ac:	69 2b       	or	r22, r25
    24ae:	e9 f0       	breq	.+58     	; 0x24ea <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    24b0:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24b4:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    24b8:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    24bc:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    24c0:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
    24c4:	c8 0e       	add	r12, r24
    24c6:	d9 1e       	adc	r13, r25
    24c8:	ea 1e       	adc	r14, r26
    24ca:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24cc:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <pxCurrentTCB>
    24d0:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    24d4:	02 96       	adiw	r24, 0x02	; 2
    24d6:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24da:	c7 01       	movw	r24, r14
    24dc:	b6 01       	movw	r22, r12
    24de:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    24e2:	0e 94 5f 11 	call	0x22be	; 0x22be <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24e6:	81 11       	cpse	r24, r1
    24e8:	02 c0       	rjmp	.+4      	; 0x24ee <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    24ea:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <vPortYield>
		}
	}
    24ee:	ff 90       	pop	r15
    24f0:	ef 90       	pop	r14
    24f2:	df 90       	pop	r13
    24f4:	cf 90       	pop	r12
    24f6:	08 95       	ret

000024f8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    24f8:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxSchedulerSuspended>
    24fc:	81 11       	cpse	r24, r1
    24fe:	0c c0       	rjmp	.+24     	; 0x2518 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2500:	e0 91 f8 30 	lds	r30, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    2504:	4b e0       	ldi	r20, 0x0B	; 11
    2506:	e4 9f       	mul	r30, r20
    2508:	f0 01       	movw	r30, r0
    250a:	11 24       	eor	r1, r1
    250c:	ea 5d       	subi	r30, 0xDA	; 218
    250e:	fe 4c       	sbci	r31, 0xCE	; 206
    2510:	80 81       	ld	r24, Z
    2512:	88 23       	and	r24, r24
    2514:	29 f0       	breq	.+10     	; 0x2520 <vTaskSwitchContext+0x28>
    2516:	14 c0       	rjmp	.+40     	; 0x2540 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2518:	81 e0       	ldi	r24, 0x01	; 1
    251a:	80 93 f4 30 	sts	0x30F4, r24	; 0x8030f4 <xMissedYield>
    251e:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2520:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2522:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    2526:	81 50       	subi	r24, 0x01	; 1
    2528:	80 93 f8 30 	sts	0x30F8, r24	; 0x8030f8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    252c:	e0 91 f8 30 	lds	r30, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    2530:	9e 9f       	mul	r25, r30
    2532:	f0 01       	movw	r30, r0
    2534:	11 24       	eor	r1, r1
    2536:	ea 5d       	subi	r30, 0xDA	; 218
    2538:	fe 4c       	sbci	r31, 0xCE	; 206
    253a:	80 81       	ld	r24, Z
    253c:	88 23       	and	r24, r24
    253e:	89 f3       	breq	.-30     	; 0x2522 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2540:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    2544:	28 2f       	mov	r18, r24
    2546:	30 e0       	ldi	r19, 0x00	; 0
    2548:	4b e0       	ldi	r20, 0x0B	; 11
    254a:	84 9f       	mul	r24, r20
    254c:	c0 01       	movw	r24, r0
    254e:	11 24       	eor	r1, r1
    2550:	dc 01       	movw	r26, r24
    2552:	aa 5d       	subi	r26, 0xDA	; 218
    2554:	be 4c       	sbci	r27, 0xCE	; 206
    2556:	11 96       	adiw	r26, 0x01	; 1
    2558:	ed 91       	ld	r30, X+
    255a:	fc 91       	ld	r31, X
    255c:	12 97       	sbiw	r26, 0x02	; 2
    255e:	04 80       	ldd	r0, Z+4	; 0x04
    2560:	f5 81       	ldd	r31, Z+5	; 0x05
    2562:	e0 2d       	mov	r30, r0
    2564:	11 96       	adiw	r26, 0x01	; 1
    2566:	ed 93       	st	X+, r30
    2568:	fc 93       	st	X, r31
    256a:	12 97       	sbiw	r26, 0x02	; 2
    256c:	87 5d       	subi	r24, 0xD7	; 215
    256e:	9e 4c       	sbci	r25, 0xCE	; 206
    2570:	e8 17       	cp	r30, r24
    2572:	f9 07       	cpc	r31, r25
    2574:	61 f4       	brne	.+24     	; 0x258e <vTaskSwitchContext+0x96>
    2576:	84 81       	ldd	r24, Z+4	; 0x04
    2578:	95 81       	ldd	r25, Z+5	; 0x05
    257a:	4b e0       	ldi	r20, 0x0B	; 11
    257c:	42 9f       	mul	r20, r18
    257e:	f0 01       	movw	r30, r0
    2580:	43 9f       	mul	r20, r19
    2582:	f0 0d       	add	r31, r0
    2584:	11 24       	eor	r1, r1
    2586:	ea 5d       	subi	r30, 0xDA	; 218
    2588:	fe 4c       	sbci	r31, 0xCE	; 206
    258a:	81 83       	std	Z+1, r24	; 0x01
    258c:	92 83       	std	Z+2, r25	; 0x02
    258e:	8b e0       	ldi	r24, 0x0B	; 11
    2590:	82 9f       	mul	r24, r18
    2592:	f0 01       	movw	r30, r0
    2594:	83 9f       	mul	r24, r19
    2596:	f0 0d       	add	r31, r0
    2598:	11 24       	eor	r1, r1
    259a:	ea 5d       	subi	r30, 0xDA	; 218
    259c:	fe 4c       	sbci	r31, 0xCE	; 206
    259e:	01 80       	ldd	r0, Z+1	; 0x01
    25a0:	f2 81       	ldd	r31, Z+2	; 0x02
    25a2:	e0 2d       	mov	r30, r0
    25a4:	80 85       	ldd	r24, Z+8	; 0x08
    25a6:	91 85       	ldd	r25, Z+9	; 0x09
    25a8:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <pxCurrentTCB>
    25ac:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <pxCurrentTCB+0x1>
    25b0:	08 95       	ret

000025b2 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25b2:	cf 92       	push	r12
    25b4:	df 92       	push	r13
    25b6:	ef 92       	push	r14
    25b8:	ff 92       	push	r15
    25ba:	6a 01       	movw	r12, r20
    25bc:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25be:	60 91 52 31 	lds	r22, 0x3152	; 0x803152 <pxCurrentTCB>
    25c2:	70 91 53 31 	lds	r23, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    25c6:	62 5f       	subi	r22, 0xF2	; 242
    25c8:	7f 4f       	sbci	r23, 0xFF	; 255
    25ca:	0e 94 37 0a 	call	0x146e	; 0x146e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25ce:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <pxCurrentTCB>
    25d2:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    25d6:	02 96       	adiw	r24, 0x02	; 2
    25d8:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    25dc:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    25e0:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    25e4:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    25e8:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    25ec:	bc 01       	movw	r22, r24
    25ee:	cd 01       	movw	r24, r26
    25f0:	6c 0d       	add	r22, r12
    25f2:	7d 1d       	adc	r23, r13
    25f4:	8e 1d       	adc	r24, r14
    25f6:	9f 1d       	adc	r25, r15
    25f8:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    25fc:	ff 90       	pop	r15
    25fe:	ef 90       	pop	r14
    2600:	df 90       	pop	r13
    2602:	cf 90       	pop	r12
    2604:	08 95       	ret

00002606 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2606:	0f 93       	push	r16
    2608:	1f 93       	push	r17
    260a:	cf 93       	push	r28
    260c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    260e:	dc 01       	movw	r26, r24
    2610:	17 96       	adiw	r26, 0x07	; 7
    2612:	ed 91       	ld	r30, X+
    2614:	fc 91       	ld	r31, X
    2616:	18 97       	sbiw	r26, 0x08	; 8
    2618:	c0 85       	ldd	r28, Z+8	; 0x08
    261a:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    261c:	8e 01       	movw	r16, r28
    261e:	02 5f       	subi	r16, 0xF2	; 242
    2620:	1f 4f       	sbci	r17, 0xFF	; 255
    2622:	c8 01       	movw	r24, r16
    2624:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2628:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxSchedulerSuspended>
    262c:	81 11       	cpse	r24, r1
    262e:	16 c0       	rjmp	.+44     	; 0x265c <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2630:	0c 50       	subi	r16, 0x0C	; 12
    2632:	11 09       	sbc	r17, r1
    2634:	c8 01       	movw	r24, r16
    2636:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    263a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    263c:	90 91 f8 30 	lds	r25, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    2640:	98 17       	cp	r25, r24
    2642:	10 f4       	brcc	.+4      	; 0x2648 <xTaskRemoveFromEventList+0x42>
    2644:	80 93 f8 30 	sts	0x30F8, r24	; 0x8030f8 <uxTopReadyPriority>
    2648:	bb e0       	ldi	r27, 0x0B	; 11
    264a:	8b 9f       	mul	r24, r27
    264c:	c0 01       	movw	r24, r0
    264e:	11 24       	eor	r1, r1
    2650:	b8 01       	movw	r22, r16
    2652:	8a 5d       	subi	r24, 0xDA	; 218
    2654:	9e 4c       	sbci	r25, 0xCE	; 206
    2656:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInsertEnd>
    265a:	05 c0       	rjmp	.+10     	; 0x2666 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    265c:	b8 01       	movw	r22, r16
    265e:	81 e0       	ldi	r24, 0x01	; 1
    2660:	91 e3       	ldi	r25, 0x31	; 49
    2662:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2666:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <pxCurrentTCB>
    266a:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    266e:	81 e0       	ldi	r24, 0x01	; 1
    2670:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2672:	92 8d       	ldd	r25, Z+26	; 0x1a
    2674:	29 17       	cp	r18, r25
    2676:	08 f4       	brcc	.+2      	; 0x267a <xTaskRemoveFromEventList+0x74>
    2678:	80 e0       	ldi	r24, 0x00	; 0
}
    267a:	df 91       	pop	r29
    267c:	cf 91       	pop	r28
    267e:	1f 91       	pop	r17
    2680:	0f 91       	pop	r16
    2682:	08 95       	ret

00002684 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2684:	20 91 f3 30 	lds	r18, 0x30F3	; 0x8030f3 <xNumOfOverflows>
    2688:	fc 01       	movw	r30, r24
    268a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    268c:	40 91 fa 30 	lds	r20, 0x30FA	; 0x8030fa <xTickCount>
    2690:	50 91 fb 30 	lds	r21, 0x30FB	; 0x8030fb <xTickCount+0x1>
    2694:	60 91 fc 30 	lds	r22, 0x30FC	; 0x8030fc <xTickCount+0x2>
    2698:	70 91 fd 30 	lds	r23, 0x30FD	; 0x8030fd <xTickCount+0x3>
    269c:	41 83       	std	Z+1, r20	; 0x01
    269e:	52 83       	std	Z+2, r21	; 0x02
    26a0:	63 83       	std	Z+3, r22	; 0x03
    26a2:	74 83       	std	Z+4, r23	; 0x04
    26a4:	08 95       	ret

000026a6 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26a6:	8f 92       	push	r8
    26a8:	9f 92       	push	r9
    26aa:	af 92       	push	r10
    26ac:	bf 92       	push	r11
    26ae:	cf 92       	push	r12
    26b0:	df 92       	push	r13
    26b2:	ef 92       	push	r14
    26b4:	ff 92       	push	r15
    26b6:	0f 93       	push	r16
    26b8:	1f 93       	push	r17
    26ba:	cf 93       	push	r28
    26bc:	df 93       	push	r29
    26be:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26c0:	0f b6       	in	r0, 0x3f	; 63
    26c2:	f8 94       	cli
    26c4:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26c6:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <xNumOfOverflows>
    26ca:	90 81       	ld	r25, Z
    26cc:	98 17       	cp	r25, r24
    26ce:	89 f0       	breq	.+34     	; 0x26f2 <xTaskCheckForTimeOut+0x4c>
    26d0:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    26d4:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    26d8:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    26dc:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
    26e0:	01 81       	ldd	r16, Z+1	; 0x01
    26e2:	12 81       	ldd	r17, Z+2	; 0x02
    26e4:	23 81       	ldd	r18, Z+3	; 0x03
    26e6:	34 81       	ldd	r19, Z+4	; 0x04
    26e8:	80 17       	cp	r24, r16
    26ea:	91 07       	cpc	r25, r17
    26ec:	a2 07       	cpc	r26, r18
    26ee:	b3 07       	cpc	r27, r19
    26f0:	a8 f5       	brcc	.+106    	; 0x275c <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    26f2:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount>
    26f6:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x1>
    26fa:	a0 91 fc 30 	lds	r26, 0x30FC	; 0x8030fc <xTickCount+0x2>
    26fe:	b0 91 fd 30 	lds	r27, 0x30FD	; 0x8030fd <xTickCount+0x3>
    2702:	c1 80       	ldd	r12, Z+1	; 0x01
    2704:	d2 80       	ldd	r13, Z+2	; 0x02
    2706:	e3 80       	ldd	r14, Z+3	; 0x03
    2708:	f4 80       	ldd	r15, Z+4	; 0x04
    270a:	eb 01       	movw	r28, r22
    270c:	08 81       	ld	r16, Y
    270e:	19 81       	ldd	r17, Y+1	; 0x01
    2710:	2a 81       	ldd	r18, Y+2	; 0x02
    2712:	3b 81       	ldd	r19, Y+3	; 0x03
    2714:	8c 19       	sub	r24, r12
    2716:	9d 09       	sbc	r25, r13
    2718:	ae 09       	sbc	r26, r14
    271a:	bf 09       	sbc	r27, r15
    271c:	80 17       	cp	r24, r16
    271e:	91 07       	cpc	r25, r17
    2720:	a2 07       	cpc	r26, r18
    2722:	b3 07       	cpc	r27, r19
    2724:	e8 f4       	brcc	.+58     	; 0x2760 <xTaskCheckForTimeOut+0xba>
    2726:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2728:	80 90 fa 30 	lds	r8, 0x30FA	; 0x8030fa <xTickCount>
    272c:	90 90 fb 30 	lds	r9, 0x30FB	; 0x8030fb <xTickCount+0x1>
    2730:	a0 90 fc 30 	lds	r10, 0x30FC	; 0x8030fc <xTickCount+0x2>
    2734:	b0 90 fd 30 	lds	r11, 0x30FD	; 0x8030fd <xTickCount+0x3>
    2738:	b5 01       	movw	r22, r10
    273a:	a4 01       	movw	r20, r8
    273c:	4c 19       	sub	r20, r12
    273e:	5d 09       	sbc	r21, r13
    2740:	6e 09       	sbc	r22, r14
    2742:	7f 09       	sbc	r23, r15
    2744:	04 1b       	sub	r16, r20
    2746:	15 0b       	sbc	r17, r21
    2748:	26 0b       	sbc	r18, r22
    274a:	37 0b       	sbc	r19, r23
    274c:	08 83       	st	Y, r16
    274e:	19 83       	std	Y+1, r17	; 0x01
    2750:	2a 83       	std	Y+2, r18	; 0x02
    2752:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2754:	0e 94 42 13 	call	0x2684	; 0x2684 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2758:	80 e0       	ldi	r24, 0x00	; 0
    275a:	03 c0       	rjmp	.+6      	; 0x2762 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    275c:	81 e0       	ldi	r24, 0x01	; 1
    275e:	01 c0       	rjmp	.+2      	; 0x2762 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2760:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2762:	0f 90       	pop	r0
    2764:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2766:	df 91       	pop	r29
    2768:	cf 91       	pop	r28
    276a:	1f 91       	pop	r17
    276c:	0f 91       	pop	r16
    276e:	ff 90       	pop	r15
    2770:	ef 90       	pop	r14
    2772:	df 90       	pop	r13
    2774:	cf 90       	pop	r12
    2776:	bf 90       	pop	r11
    2778:	af 90       	pop	r10
    277a:	9f 90       	pop	r9
    277c:	8f 90       	pop	r8
    277e:	08 95       	ret

00002780 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2780:	81 e0       	ldi	r24, 0x01	; 1
    2782:	80 93 f4 30 	sts	0x30F4, r24	; 0x8030f4 <xMissedYield>
    2786:	08 95       	ret

00002788 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2788:	00 97       	sbiw	r24, 0x00	; 0
    278a:	21 f4       	brne	.+8      	; 0x2794 <uxTaskGetStackHighWaterMark+0xc>
    278c:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <pxCurrentTCB>
    2790:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2794:	dc 01       	movw	r26, r24
    2796:	5b 96       	adiw	r26, 0x1b	; 27
    2798:	ed 91       	ld	r30, X+
    279a:	fc 91       	ld	r31, X
    279c:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    279e:	80 81       	ld	r24, Z
    27a0:	81 31       	cpi	r24, 0x11	; 17
    27a2:	41 f4       	brne	.+16     	; 0x27b4 <uxTaskGetStackHighWaterMark+0x2c>
    27a4:	31 96       	adiw	r30, 0x01	; 1
    27a6:	80 e0       	ldi	r24, 0x00	; 0
    27a8:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27aa:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27ac:	21 91       	ld	r18, Z+
    27ae:	21 31       	cpi	r18, 0x11	; 17
    27b0:	e1 f3       	breq	.-8      	; 0x27aa <uxTaskGetStackHighWaterMark+0x22>
    27b2:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27b4:	80 e0       	ldi	r24, 0x00	; 0
    27b6:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27b8:	08 95       	ret

000027ba <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27ba:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <pxCurrentTCB>
    27be:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <pxCurrentTCB+0x1>

		return xReturn;
	}
    27c2:	08 95       	ret

000027c4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27c4:	0f 93       	push	r16
    27c6:	1f 93       	push	r17
    27c8:	cf 93       	push	r28
    27ca:	df 93       	push	r29
    27cc:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    27ce:	22 8d       	ldd	r18, Z+26	; 0x1a
    27d0:	a0 91 52 31 	lds	r26, 0x3152	; 0x803152 <pxCurrentTCB>
    27d4:	b0 91 53 31 	lds	r27, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    27d8:	5a 96       	adiw	r26, 0x1a	; 26
    27da:	8c 91       	ld	r24, X
    27dc:	28 17       	cp	r18, r24
    27de:	08 f0       	brcs	.+2      	; 0x27e2 <vTaskPriorityInherit+0x1e>
    27e0:	41 c0       	rjmp	.+130    	; 0x2864 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    27e2:	a0 91 52 31 	lds	r26, 0x3152	; 0x803152 <pxCurrentTCB>
    27e6:	b0 91 53 31 	lds	r27, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    27ea:	5a 96       	adiw	r26, 0x1a	; 26
    27ec:	3c 91       	ld	r19, X
    27ee:	84 e0       	ldi	r24, 0x04	; 4
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	a0 e0       	ldi	r26, 0x00	; 0
    27f4:	b0 e0       	ldi	r27, 0x00	; 0
    27f6:	83 1b       	sub	r24, r19
    27f8:	91 09       	sbc	r25, r1
    27fa:	a1 09       	sbc	r26, r1
    27fc:	b1 09       	sbc	r27, r1
    27fe:	86 87       	std	Z+14, r24	; 0x0e
    2800:	97 87       	std	Z+15, r25	; 0x0f
    2802:	a0 8b       	std	Z+16, r26	; 0x10
    2804:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2806:	8b e0       	ldi	r24, 0x0B	; 11
    2808:	28 9f       	mul	r18, r24
    280a:	90 01       	movw	r18, r0
    280c:	11 24       	eor	r1, r1
    280e:	2a 5d       	subi	r18, 0xDA	; 218
    2810:	3e 4c       	sbci	r19, 0xCE	; 206
    2812:	84 85       	ldd	r24, Z+12	; 0x0c
    2814:	95 85       	ldd	r25, Z+13	; 0x0d
    2816:	82 17       	cp	r24, r18
    2818:	93 07       	cpc	r25, r19
    281a:	e9 f4       	brne	.+58     	; 0x2856 <vTaskPriorityInherit+0x92>
    281c:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    281e:	ef 01       	movw	r28, r30
    2820:	22 96       	adiw	r28, 0x02	; 2
    2822:	ce 01       	movw	r24, r28
    2824:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2828:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <pxCurrentTCB>
    282c:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    2830:	82 8d       	ldd	r24, Z+26	; 0x1a
    2832:	f8 01       	movw	r30, r16
    2834:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2836:	90 91 f8 30 	lds	r25, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    283a:	98 17       	cp	r25, r24
    283c:	10 f4       	brcc	.+4      	; 0x2842 <vTaskPriorityInherit+0x7e>
    283e:	80 93 f8 30 	sts	0x30F8, r24	; 0x8030f8 <uxTopReadyPriority>
    2842:	fb e0       	ldi	r31, 0x0B	; 11
    2844:	8f 9f       	mul	r24, r31
    2846:	c0 01       	movw	r24, r0
    2848:	11 24       	eor	r1, r1
    284a:	be 01       	movw	r22, r28
    284c:	8a 5d       	subi	r24, 0xDA	; 218
    284e:	9e 4c       	sbci	r25, 0xCE	; 206
    2850:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInsertEnd>
    2854:	07 c0       	rjmp	.+14     	; 0x2864 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2856:	a0 91 52 31 	lds	r26, 0x3152	; 0x803152 <pxCurrentTCB>
    285a:	b0 91 53 31 	lds	r27, 0x3153	; 0x803153 <pxCurrentTCB+0x1>
    285e:	5a 96       	adiw	r26, 0x1a	; 26
    2860:	8c 91       	ld	r24, X
    2862:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2864:	df 91       	pop	r29
    2866:	cf 91       	pop	r28
    2868:	1f 91       	pop	r17
    286a:	0f 91       	pop	r16
    286c:	08 95       	ret

0000286e <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    286e:	0f 93       	push	r16
    2870:	1f 93       	push	r17
    2872:	cf 93       	push	r28
    2874:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2876:	00 97       	sbiw	r24, 0x00	; 0
    2878:	49 f1       	breq	.+82     	; 0x28cc <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    287a:	fc 01       	movw	r30, r24
    287c:	32 8d       	ldd	r19, Z+26	; 0x1a
    287e:	27 a1       	ldd	r18, Z+39	; 0x27
    2880:	32 17       	cp	r19, r18
    2882:	21 f1       	breq	.+72     	; 0x28cc <vTaskPriorityDisinherit+0x5e>
    2884:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2886:	8c 01       	movw	r16, r24
    2888:	0e 5f       	subi	r16, 0xFE	; 254
    288a:	1f 4f       	sbci	r17, 0xFF	; 255
    288c:	c8 01       	movw	r24, r16
    288e:	0e 94 82 0a 	call	0x1504	; 0x1504 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2892:	8f a1       	ldd	r24, Y+39	; 0x27
    2894:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2896:	44 e0       	ldi	r20, 0x04	; 4
    2898:	50 e0       	ldi	r21, 0x00	; 0
    289a:	60 e0       	ldi	r22, 0x00	; 0
    289c:	70 e0       	ldi	r23, 0x00	; 0
    289e:	48 1b       	sub	r20, r24
    28a0:	51 09       	sbc	r21, r1
    28a2:	61 09       	sbc	r22, r1
    28a4:	71 09       	sbc	r23, r1
    28a6:	4e 87       	std	Y+14, r20	; 0x0e
    28a8:	5f 87       	std	Y+15, r21	; 0x0f
    28aa:	68 8b       	std	Y+16, r22	; 0x10
    28ac:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28ae:	90 91 f8 30 	lds	r25, 0x30F8	; 0x8030f8 <uxTopReadyPriority>
    28b2:	98 17       	cp	r25, r24
    28b4:	10 f4       	brcc	.+4      	; 0x28ba <vTaskPriorityDisinherit+0x4c>
    28b6:	80 93 f8 30 	sts	0x30F8, r24	; 0x8030f8 <uxTopReadyPriority>
    28ba:	fb e0       	ldi	r31, 0x0B	; 11
    28bc:	8f 9f       	mul	r24, r31
    28be:	c0 01       	movw	r24, r0
    28c0:	11 24       	eor	r1, r1
    28c2:	b8 01       	movw	r22, r16
    28c4:	8a 5d       	subi	r24, 0xDA	; 218
    28c6:	9e 4c       	sbci	r25, 0xCE	; 206
    28c8:	0e 94 10 0a 	call	0x1420	; 0x1420 <vListInsertEnd>
			}
		}
	}
    28cc:	df 91       	pop	r29
    28ce:	cf 91       	pop	r28
    28d0:	1f 91       	pop	r17
    28d2:	0f 91       	pop	r16
    28d4:	08 95       	ret

000028d6 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    28d6:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    28d8:	e8 81       	ld	r30, Y
    28da:	f9 81       	ldd	r31, Y+1	; 0x01
    28dc:	01 90       	ld	r0, Z+
    28de:	f0 81       	ld	r31, Z
    28e0:	e0 2d       	mov	r30, r0
    28e2:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    28e4:	1a 82       	std	Y+2, r1	; 0x02
    28e6:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    28e8:	6f ef       	ldi	r22, 0xFF	; 255
    28ea:	7f ef       	ldi	r23, 0xFF	; 255
    28ec:	cb 01       	movw	r24, r22
    28ee:	0e 94 4e 12 	call	0x249c	; 0x249c <vTaskDelay>
    28f2:	fa cf       	rjmp	.-12     	; 0x28e8 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000028f4 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    28f4:	fc 01       	movw	r30, r24
    28f6:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    28f8:	65 87       	std	Z+13, r22	; 0x0d
    28fa:	08 95       	ret

000028fc <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    28fc:	4f 92       	push	r4
    28fe:	5f 92       	push	r5
    2900:	6f 92       	push	r6
    2902:	7f 92       	push	r7
    2904:	8f 92       	push	r8
    2906:	9f 92       	push	r9
    2908:	af 92       	push	r10
    290a:	bf 92       	push	r11
    290c:	cf 92       	push	r12
    290e:	df 92       	push	r13
    2910:	ef 92       	push	r14
    2912:	ff 92       	push	r15
    2914:	0f 93       	push	r16
    2916:	1f 93       	push	r17
    2918:	cf 93       	push	r28
    291a:	df 93       	push	r29
    291c:	cd b7       	in	r28, 0x3d	; 61
    291e:	de b7       	in	r29, 0x3e	; 62
    2920:	2a 97       	sbiw	r28, 0x0a	; 10
    2922:	cd bf       	out	0x3d, r28	; 61
    2924:	de bf       	out	0x3e, r29	; 62
    2926:	4c 01       	movw	r8, r24
    2928:	29 01       	movw	r4, r18
    292a:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    292c:	8f e4       	ldi	r24, 0x4F	; 79
    292e:	90 e2       	ldi	r25, 0x20	; 32
    2930:	f4 01       	movw	r30, r8
    2932:	80 83       	st	Z, r24
    2934:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2936:	fb 01       	movw	r30, r22
    2938:	80 81       	ld	r24, Z
    293a:	88 23       	and	r24, r24
    293c:	69 f0       	breq	.+26     	; 0x2958 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    293e:	de 01       	movw	r26, r28
    2940:	11 96       	adiw	r26, 0x01	; 1
    2942:	31 96       	adiw	r30, 0x01	; 1
    2944:	90 e0       	ldi	r25, 0x00	; 0
    2946:	02 c0       	rjmp	.+4      	; 0x294c <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2948:	99 30       	cpi	r25, 0x09	; 9
    294a:	39 f0       	breq	.+14     	; 0x295a <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    294c:	9f 5f       	subi	r25, 0xFF	; 255
    294e:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2950:	81 91       	ld	r24, Z+
    2952:	81 11       	cpse	r24, r1
    2954:	f9 cf       	rjmp	.-14     	; 0x2948 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2956:	01 c0       	rjmp	.+2      	; 0x295a <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2958:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    295a:	e1 e0       	ldi	r30, 0x01	; 1
    295c:	f0 e0       	ldi	r31, 0x00	; 0
    295e:	ec 0f       	add	r30, r28
    2960:	fd 1f       	adc	r31, r29
    2962:	e9 0f       	add	r30, r25
    2964:	f1 1d       	adc	r31, r1
    2966:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2968:	74 01       	movw	r14, r8
    296a:	f2 e0       	ldi	r31, 0x02	; 2
    296c:	ef 0e       	add	r14, r31
    296e:	f1 1c       	adc	r15, r1
    2970:	a1 2c       	mov	r10, r1
    2972:	b1 2c       	mov	r11, r1
    2974:	c1 2c       	mov	r12, r1
    2976:	d1 2c       	mov	r13, r1
    2978:	04 2f       	mov	r16, r20
    297a:	94 01       	movw	r18, r8
    297c:	a2 01       	movw	r20, r4
    297e:	be 01       	movw	r22, r28
    2980:	6f 5f       	subi	r22, 0xFF	; 255
    2982:	7f 4f       	sbci	r23, 0xFF	; 255
    2984:	8a ea       	ldi	r24, 0xAA	; 170
    2986:	92 e0       	ldi	r25, 0x02	; 2
    2988:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    298c:	f4 01       	movw	r30, r8
    298e:	66 82       	std	Z+6, r6	; 0x06
    2990:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2992:	40 86       	std	Z+8, r4	; 0x08
    2994:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2996:	20 91 54 31 	lds	r18, 0x3154	; 0x803154 <last_created_task_pointer>
    299a:	30 91 55 31 	lds	r19, 0x3155	; 0x803155 <last_created_task_pointer+0x1>
    299e:	24 83       	std	Z+4, r18	; 0x04
    29a0:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29a2:	80 92 54 31 	sts	0x3154, r8	; 0x803154 <last_created_task_pointer>
    29a6:	90 92 55 31 	sts	0x3155, r9	; 0x803155 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29aa:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29ac:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29ae:	40 90 8e 31 	lds	r4, 0x318E	; 0x80318e <portStackTopForTask>
    29b2:	50 90 8f 31 	lds	r5, 0x318F	; 0x80318f <portStackTopForTask+0x1>
    29b6:	ff ef       	ldi	r31, 0xFF	; 255
    29b8:	4f 1a       	sub	r4, r31
    29ba:	5f 0a       	sbc	r5, r31
    29bc:	40 92 8e 31 	sts	0x318E, r4	; 0x80318e <portStackTopForTask>
    29c0:	50 92 8f 31 	sts	0x318F, r5	; 0x80318f <portStackTopForTask+0x1>
    29c4:	f4 01       	movw	r30, r8
    29c6:	42 86       	std	Z+10, r4	; 0x0a
    29c8:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    29ca:	16 86       	std	Z+14, r1	; 0x0e
    29cc:	17 86       	std	Z+15, r1	; 0x0f
    29ce:	10 8a       	std	Z+16, r1	; 0x10
    29d0:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    29d2:	61 14       	cp	r6, r1
    29d4:	71 04       	cpc	r7, r1
    29d6:	09 f4       	brne	.+2      	; 0x29da <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    29d8:	44 c0       	rjmp	.+136    	; 0x2a62 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    29da:	81 30       	cpi	r24, 0x01	; 1
    29dc:	79 f5       	brne	.+94     	; 0x2a3c <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    29de:	6a e0       	ldi	r22, 0x0A	; 10
    29e0:	c3 01       	movw	r24, r6
    29e2:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    29e6:	7c 01       	movw	r14, r24
    29e8:	61 ea       	ldi	r22, 0xA1	; 161
    29ea:	74 e0       	ldi	r23, 0x04	; 4
    29ec:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    29f0:	be 01       	movw	r22, r28
    29f2:	6f 5f       	subi	r22, 0xFF	; 255
    29f4:	7f 4f       	sbci	r23, 0xFF	; 255
    29f6:	c7 01       	movw	r24, r14
    29f8:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    29fc:	6a e0       	ldi	r22, 0x0A	; 10
    29fe:	c7 01       	movw	r24, r14
    2a00:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2a04:	7c 01       	movw	r14, r24
    2a06:	68 e9       	ldi	r22, 0x98	; 152
    2a08:	74 e0       	ldi	r23, 0x04	; 4
    2a0a:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a0e:	6a e0       	ldi	r22, 0x0A	; 10
    2a10:	c7 01       	movw	r24, r14
    2a12:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2a16:	7c 01       	movw	r14, r24
    2a18:	6a e8       	ldi	r22, 0x8A	; 138
    2a1a:	74 e0       	ldi	r23, 0x04	; 4
    2a1c:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2a20:	63 e0       	ldi	r22, 0x03	; 3
    2a22:	c7 01       	movw	r24, r14
    2a24:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2a28:	b2 01       	movw	r22, r4
    2a2a:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEj>
    2a2e:	62 e0       	ldi	r22, 0x02	; 2
    2a30:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2a34:	66 e0       	ldi	r22, 0x06	; 6
    2a36:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2a3a:	13 c0       	rjmp	.+38     	; 0x2a62 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a3c:	6a e0       	ldi	r22, 0x0A	; 10
    2a3e:	c3 01       	movw	r24, r6
    2a40:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2a44:	4c 01       	movw	r8, r24
    2a46:	65 e7       	ldi	r22, 0x75	; 117
    2a48:	74 e0       	ldi	r23, 0x04	; 4
    2a4a:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2a4e:	be 01       	movw	r22, r28
    2a50:	6f 5f       	subi	r22, 0xFF	; 255
    2a52:	7f 4f       	sbci	r23, 0xFF	; 255
    2a54:	c4 01       	movw	r24, r8
    2a56:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2a5a:	66 e0       	ldi	r22, 0x06	; 6
    2a5c:	c4 01       	movw	r24, r8
    2a5e:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a62:	2a 96       	adiw	r28, 0x0a	; 10
    2a64:	cd bf       	out	0x3d, r28	; 61
    2a66:	de bf       	out	0x3e, r29	; 62
    2a68:	df 91       	pop	r29
    2a6a:	cf 91       	pop	r28
    2a6c:	1f 91       	pop	r17
    2a6e:	0f 91       	pop	r16
    2a70:	ff 90       	pop	r15
    2a72:	ef 90       	pop	r14
    2a74:	df 90       	pop	r13
    2a76:	cf 90       	pop	r12
    2a78:	bf 90       	pop	r11
    2a7a:	af 90       	pop	r10
    2a7c:	9f 90       	pop	r9
    2a7e:	8f 90       	pop	r8
    2a80:	7f 90       	pop	r7
    2a82:	6f 90       	pop	r6
    2a84:	5f 90       	pop	r5
    2a86:	4f 90       	pop	r4
    2a88:	08 95       	ret

00002a8a <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2a8a:	cf 92       	push	r12
    2a8c:	df 92       	push	r13
    2a8e:	ef 92       	push	r14
    2a90:	ff 92       	push	r15
    2a92:	0f 93       	push	r16
    2a94:	1f 93       	push	r17
    2a96:	cf 93       	push	r28
    2a98:	df 93       	push	r29
    2a9a:	ec 01       	movw	r28, r24
    2a9c:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2a9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2aa0:	9b 81       	ldd	r25, Y+3	; 0x03
    2aa2:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pcTaskGetTaskName>
    2aa6:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2aa8:	6a e0       	ldi	r22, 0x0A	; 10
    2aaa:	c7 01       	movw	r24, r14
    2aac:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2ab0:	8c 01       	movw	r16, r24
    2ab2:	64 eb       	ldi	r22, 0xB4	; 180
    2ab4:	74 e0       	ldi	r23, 0x04	; 4
    2ab6:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2aba:	6a e0       	ldi	r22, 0x0A	; 10
    2abc:	c8 01       	movw	r24, r16
    2abe:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2ac2:	8c 01       	movw	r16, r24
    2ac4:	6d ea       	ldi	r22, 0xAD	; 173
    2ac6:	74 e0       	ldi	r23, 0x04	; 4
    2ac8:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2acc:	b6 01       	movw	r22, r12
    2ace:	c8 01       	movw	r24, r16
    2ad0:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2ad4:	6a e0       	ldi	r22, 0x0A	; 10
    2ad6:	c8 01       	movw	r24, r16
    2ad8:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2adc:	8c 01       	movw	r16, r24
    2ade:	67 ea       	ldi	r22, 0xA7	; 167
    2ae0:	74 e0       	ldi	r23, 0x04	; 4
    2ae2:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2ae6:	66 e0       	ldi	r22, 0x06	; 6
    2ae8:	c8 01       	movw	r24, r16
    2aea:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2aee:	8a 85       	ldd	r24, Y+10	; 0x0a
    2af0:	9b 85       	ldd	r25, Y+11	; 0x0b
    2af2:	e8 85       	ldd	r30, Y+8	; 0x08
    2af4:	f9 85       	ldd	r31, Y+9	; 0x09
    2af6:	01 e1       	ldi	r16, 0x11	; 17
    2af8:	21 e0       	ldi	r18, 0x01	; 1
    2afa:	a7 01       	movw	r20, r14
    2afc:	bc 01       	movw	r22, r24
    2afe:	8e 1b       	sub	r24, r30
    2b00:	9f 0b       	sbc	r25, r31
    2b02:	0e 94 47 18 	call	0x308e	; 0x308e <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b06:	8c 81       	ldd	r24, Y+4	; 0x04
    2b08:	9d 81       	ldd	r25, Y+5	; 0x05
    2b0a:	00 97       	sbiw	r24, 0x00	; 0
    2b0c:	19 f0       	breq	.+6      	; 0x2b14 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b0e:	b7 01       	movw	r22, r14
    2b10:	0e 94 45 15 	call	0x2a8a	; 0x2a8a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b14:	df 91       	pop	r29
    2b16:	cf 91       	pop	r28
    2b18:	1f 91       	pop	r17
    2b1a:	0f 91       	pop	r16
    2b1c:	ff 90       	pop	r15
    2b1e:	ef 90       	pop	r14
    2b20:	df 90       	pop	r13
    2b22:	cf 90       	pop	r12
    2b24:	08 95       	ret

00002b26 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b26:	0f 93       	push	r16
    2b28:	1f 93       	push	r17
    2b2a:	cf 93       	push	r28
    2b2c:	df 93       	push	r29
    2b2e:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b30:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <last_created_task_pointer>
    2b34:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <last_created_task_pointer+0x1>
    2b38:	00 97       	sbiw	r24, 0x00	; 0
    2b3a:	19 f0       	breq	.+6      	; 0x2b42 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b3c:	be 01       	movw	r22, r28
    2b3e:	0e 94 45 15 	call	0x2a8a	; 0x2a8a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b42:	6a e0       	ldi	r22, 0x0A	; 10
    2b44:	ce 01       	movw	r24, r28
    2b46:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2b4a:	8c 01       	movw	r16, r24
    2b4c:	6a ec       	ldi	r22, 0xCA	; 202
    2b4e:	74 e0       	ldi	r23, 0x04	; 4
    2b50:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2b54:	6a e0       	ldi	r22, 0x0A	; 10
    2b56:	c8 01       	movw	r24, r16
    2b58:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2b5c:	8c 01       	movw	r16, r24
    2b5e:	6f eb       	ldi	r22, 0xBF	; 191
    2b60:	74 e0       	ldi	r23, 0x04	; 4
    2b62:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2b66:	6a e0       	ldi	r22, 0x0A	; 10
    2b68:	c8 01       	movw	r24, r16
    2b6a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2b6e:	8c 01       	movw	r16, r24
    2b70:	69 eb       	ldi	r22, 0xB9	; 185
    2b72:	74 e0       	ldi	r23, 0x04	; 4
    2b74:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2b78:	66 e0       	ldi	r22, 0x06	; 6
    2b7a:	c8 01       	movw	r24, r16
    2b7c:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2b80:	80 91 8e 31 	lds	r24, 0x318E	; 0x80318e <portStackTopForTask>
    2b84:	90 91 8f 31 	lds	r25, 0x318F	; 0x80318f <portStackTopForTask+0x1>
    2b88:	bc 01       	movw	r22, r24
    2b8a:	6f 5f       	subi	r22, 0xFF	; 255
    2b8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2b8e:	01 e1       	ldi	r16, 0x11	; 17
    2b90:	21 e0       	ldi	r18, 0x01	; 1
    2b92:	ae 01       	movw	r20, r28
    2b94:	83 56       	subi	r24, 0x63	; 99
    2b96:	91 09       	sbc	r25, r1
    2b98:	0e 94 47 18 	call	0x308e	; 0x308e <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2b9c:	df 91       	pop	r29
    2b9e:	cf 91       	pop	r28
    2ba0:	1f 91       	pop	r17
    2ba2:	0f 91       	pop	r16
    2ba4:	08 95       	ret

00002ba6 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2ba6:	8f 92       	push	r8
    2ba8:	9f 92       	push	r9
    2baa:	af 92       	push	r10
    2bac:	bf 92       	push	r11
    2bae:	cf 92       	push	r12
    2bb0:	df 92       	push	r13
    2bb2:	ef 92       	push	r14
    2bb4:	ff 92       	push	r15
    2bb6:	0f 93       	push	r16
    2bb8:	1f 93       	push	r17
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	ec 01       	movw	r28, r24
    2bc0:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2bc2:	8a 81       	ldd	r24, Y+2	; 0x02
    2bc4:	9b 81       	ldd	r25, Y+3	; 0x03
    2bc6:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pcTaskGetTaskName>
    2bca:	bc 01       	movw	r22, r24
    2bcc:	c8 01       	movw	r24, r16
    2bce:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2bd2:	d8 01       	movw	r26, r16
    2bd4:	ed 91       	ld	r30, X+
    2bd6:	fc 91       	ld	r31, X
    2bd8:	02 80       	ldd	r0, Z+2	; 0x02
    2bda:	f3 81       	ldd	r31, Z+3	; 0x03
    2bdc:	e0 2d       	mov	r30, r0
    2bde:	69 e0       	ldi	r22, 0x09	; 9
    2be0:	c8 01       	movw	r24, r16
    2be2:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2be4:	8a 81       	ldd	r24, Y+2	; 0x02
    2be6:	9b 81       	ldd	r25, Y+3	; 0x03
    2be8:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pcTaskGetTaskName>
    2bec:	fc 01       	movw	r30, r24
    2bee:	01 90       	ld	r0, Z+
    2bf0:	00 20       	and	r0, r0
    2bf2:	e9 f7       	brne	.-6      	; 0x2bee <_ZN8frt_task12print_statusER8emstream+0x48>
    2bf4:	31 97       	sbiw	r30, 0x01	; 1
    2bf6:	e8 1b       	sub	r30, r24
    2bf8:	f9 0b       	sbc	r31, r25
    2bfa:	38 97       	sbiw	r30, 0x08	; 8
    2bfc:	48 f4       	brcc	.+18     	; 0x2c10 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2bfe:	d8 01       	movw	r26, r16
    2c00:	ed 91       	ld	r30, X+
    2c02:	fc 91       	ld	r31, X
    2c04:	02 80       	ldd	r0, Z+2	; 0x02
    2c06:	f3 81       	ldd	r31, Z+3	; 0x03
    2c08:	e0 2d       	mov	r30, r0
    2c0a:	69 e0       	ldi	r22, 0x09	; 9
    2c0c:	c8 01       	movw	r24, r16
    2c0e:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c10:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c12:	df 84       	ldd	r13, Y+15	; 0x0f
    2c14:	e8 88       	ldd	r14, Y+16	; 0x10
    2c16:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c18:	a8 84       	ldd	r10, Y+8	; 0x08
    2c1a:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c20:	0e 94 c4 13 	call	0x2788	; 0x2788 <uxTaskGetStackHighWaterMark>
    2c24:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c26:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c28:	8a 81       	ldd	r24, Y+2	; 0x02
    2c2a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c2c:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <uxTaskPriorityGet>
    2c30:	68 2f       	mov	r22, r24
    2c32:	c8 01       	movw	r24, r16
    2c34:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
    2c38:	6a e0       	ldi	r22, 0x0A	; 10
    2c3a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2c3e:	ec 01       	movw	r28, r24
    2c40:	6f e3       	ldi	r22, 0x3F	; 63
    2c42:	75 e0       	ldi	r23, 0x05	; 5
    2c44:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c48:	68 2d       	mov	r22, r8
    2c4a:	ce 01       	movw	r24, r28
    2c4c:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c50:	6a e0       	ldi	r22, 0x0A	; 10
    2c52:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2c56:	ec 01       	movw	r28, r24
    2c58:	6d e3       	ldi	r22, 0x3D	; 61
    2c5a:	75 e0       	ldi	r23, 0x05	; 5
    2c5c:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2c60:	69 2d       	mov	r22, r9
    2c62:	ce 01       	movw	r24, r28
    2c64:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
    2c68:	6a e0       	ldi	r22, 0x0A	; 10
    2c6a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2c6e:	ec 01       	movw	r28, r24
    2c70:	6b e3       	ldi	r22, 0x3B	; 59
    2c72:	75 e0       	ldi	r23, 0x05	; 5
    2c74:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2c78:	b5 01       	movw	r22, r10
    2c7a:	ce 01       	movw	r24, r28
    2c7c:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEj>
    2c80:	6a e0       	ldi	r22, 0x0A	; 10
    2c82:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2c86:	ec 01       	movw	r28, r24
    2c88:	69 e3       	ldi	r22, 0x39	; 57
    2c8a:	75 e0       	ldi	r23, 0x05	; 5
    2c8c:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2c90:	6a e0       	ldi	r22, 0x0A	; 10
    2c92:	ce 01       	movw	r24, r28
    2c94:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2c98:	ec 01       	movw	r28, r24
    2c9a:	67 e3       	ldi	r22, 0x37	; 55
    2c9c:	75 e0       	ldi	r23, 0x05	; 5
    2c9e:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2ca2:	b7 01       	movw	r22, r14
    2ca4:	a6 01       	movw	r20, r12
    2ca6:	ce 01       	movw	r24, r28
    2ca8:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <_ZN8emstreamlsEm>
}
    2cac:	df 91       	pop	r29
    2cae:	cf 91       	pop	r28
    2cb0:	1f 91       	pop	r17
    2cb2:	0f 91       	pop	r16
    2cb4:	ff 90       	pop	r15
    2cb6:	ef 90       	pop	r14
    2cb8:	df 90       	pop	r13
    2cba:	cf 90       	pop	r12
    2cbc:	bf 90       	pop	r11
    2cbe:	af 90       	pop	r10
    2cc0:	9f 90       	pop	r9
    2cc2:	8f 90       	pop	r8
    2cc4:	08 95       	ret

00002cc6 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2cc6:	cf 93       	push	r28
    2cc8:	df 93       	push	r29
    2cca:	ec 01       	movw	r28, r24
    2ccc:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2cce:	db 01       	movw	r26, r22
    2cd0:	ed 91       	ld	r30, X+
    2cd2:	fc 91       	ld	r31, X
    2cd4:	02 80       	ldd	r0, Z+2	; 0x02
    2cd6:	f3 81       	ldd	r31, Z+3	; 0x03
    2cd8:	e0 2d       	mov	r30, r0
    2cda:	be 01       	movw	r22, r28
    2cdc:	19 95       	eicall
	return (ser_dev);
}
    2cde:	ce 01       	movw	r24, r28
    2ce0:	df 91       	pop	r29
    2ce2:	cf 91       	pop	r28
    2ce4:	08 95       	ret

00002ce6 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2ce6:	0f 93       	push	r16
    2ce8:	1f 93       	push	r17
    2cea:	cf 93       	push	r28
    2cec:	df 93       	push	r29
    2cee:	ec 01       	movw	r28, r24
    2cf0:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2cf2:	bc 01       	movw	r22, r24
    2cf4:	c8 01       	movw	r24, r16
    2cf6:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <_ZlsR8emstreamR8frt_task>
    2cfa:	66 e0       	ldi	r22, 0x06	; 6
    2cfc:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d00:	8c 81       	ldd	r24, Y+4	; 0x04
    2d02:	9d 81       	ldd	r25, Y+5	; 0x05
    2d04:	00 97       	sbiw	r24, 0x00	; 0
    2d06:	19 f0       	breq	.+6      	; 0x2d0e <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d08:	b8 01       	movw	r22, r16
    2d0a:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d0e:	df 91       	pop	r29
    2d10:	cf 91       	pop	r28
    2d12:	1f 91       	pop	r17
    2d14:	0f 91       	pop	r16
    2d16:	08 95       	ret

00002d18 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d18:	0f 93       	push	r16
    2d1a:	1f 93       	push	r17
    2d1c:	cf 93       	push	r28
    2d1e:	df 93       	push	r29
    2d20:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d22:	6a e0       	ldi	r22, 0x0A	; 10
    2d24:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2d28:	8c 01       	movw	r16, r24
    2d2a:	6c e2       	ldi	r22, 0x2C	; 44
    2d2c:	75 e0       	ldi	r23, 0x05	; 5
    2d2e:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d32:	6a e0       	ldi	r22, 0x0A	; 10
    2d34:	c8 01       	movw	r24, r16
    2d36:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2d3a:	8c 01       	movw	r16, r24
    2d3c:	65 e2       	ldi	r22, 0x25	; 37
    2d3e:	75 e0       	ldi	r23, 0x05	; 5
    2d40:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d44:	66 e0       	ldi	r22, 0x06	; 6
    2d46:	c8 01       	movw	r24, r16
    2d48:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d4c:	6a e0       	ldi	r22, 0x0A	; 10
    2d4e:	ce 01       	movw	r24, r28
    2d50:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2d54:	8c 01       	movw	r16, r24
    2d56:	64 e1       	ldi	r22, 0x14	; 20
    2d58:	75 e0       	ldi	r23, 0x05	; 5
    2d5a:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2d5e:	6a e0       	ldi	r22, 0x0A	; 10
    2d60:	c8 01       	movw	r24, r16
    2d62:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2d66:	8c 01       	movw	r16, r24
    2d68:	68 e0       	ldi	r22, 0x08	; 8
    2d6a:	75 e0       	ldi	r23, 0x05	; 5
    2d6c:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2d70:	6a e0       	ldi	r22, 0x0A	; 10
    2d72:	c8 01       	movw	r24, r16
    2d74:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2d78:	8c 01       	movw	r16, r24
    2d7a:	62 e0       	ldi	r22, 0x02	; 2
    2d7c:	75 e0       	ldi	r23, 0x05	; 5
    2d7e:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2d82:	66 e0       	ldi	r22, 0x06	; 6
    2d84:	c8 01       	movw	r24, r16
    2d86:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2d8a:	6a e0       	ldi	r22, 0x0A	; 10
    2d8c:	ce 01       	movw	r24, r28
    2d8e:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2d92:	8c 01       	movw	r16, r24
    2d94:	61 ef       	ldi	r22, 0xF1	; 241
    2d96:	74 e0       	ldi	r23, 0x04	; 4
    2d98:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2d9c:	6a e0       	ldi	r22, 0x0A	; 10
    2d9e:	c8 01       	movw	r24, r16
    2da0:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2da4:	8c 01       	movw	r16, r24
    2da6:	65 ee       	ldi	r22, 0xE5	; 229
    2da8:	74 e0       	ldi	r23, 0x04	; 4
    2daa:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2dae:	6a e0       	ldi	r22, 0x0A	; 10
    2db0:	c8 01       	movw	r24, r16
    2db2:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2db6:	8c 01       	movw	r16, r24
    2db8:	6f ed       	ldi	r22, 0xDF	; 223
    2dba:	74 e0       	ldi	r23, 0x04	; 4
    2dbc:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2dc0:	66 e0       	ldi	r22, 0x06	; 6
    2dc2:	c8 01       	movw	r24, r16
    2dc4:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2dc8:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <last_created_task_pointer>
    2dcc:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <last_created_task_pointer+0x1>
    2dd0:	00 97       	sbiw	r24, 0x00	; 0
    2dd2:	19 f0       	breq	.+6      	; 0x2dda <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2dd4:	be 01       	movw	r22, r28
    2dd6:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2dda:	0e 94 59 10 	call	0x20b2	; 0x20b2 <xTaskGetIdleTaskHandle>
    2dde:	0e 94 c4 13 	call	0x2788	; 0x2788 <uxTaskGetStackHighWaterMark>
    2de2:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2de4:	6a e0       	ldi	r22, 0x0A	; 10
    2de6:	ce 01       	movw	r24, r28
    2de8:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2dec:	ec 01       	movw	r28, r24
    2dee:	64 ed       	ldi	r22, 0xD4	; 212
    2df0:	74 e0       	ldi	r23, 0x04	; 4
    2df2:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2df6:	61 2f       	mov	r22, r17
    2df8:	ce 01       	movw	r24, r28
    2dfa:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2dfe:	6a e0       	ldi	r22, 0x0A	; 10
    2e00:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2e04:	ec 01       	movw	r28, r24
    2e06:	62 ed       	ldi	r22, 0xD2	; 210
    2e08:	74 e0       	ldi	r23, 0x04	; 4
    2e0a:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    2e0e:	64 e6       	ldi	r22, 0x64	; 100
    2e10:	70 e0       	ldi	r23, 0x00	; 0
    2e12:	ce 01       	movw	r24, r28
    2e14:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEj>
    2e18:	6a e0       	ldi	r22, 0x0A	; 10
    2e1a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    2e1e:	ec 01       	movw	r28, r24
    2e20:	6f ec       	ldi	r22, 0xCF	; 207
    2e22:	74 e0       	ldi	r23, 0x04	; 4
    2e24:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e28:	66 e0       	ldi	r22, 0x06	; 6
    2e2a:	ce 01       	movw	r24, r28
    2e2c:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
}
    2e30:	df 91       	pop	r29
    2e32:	cf 91       	pop	r28
    2e34:	1f 91       	pop	r17
    2e36:	0f 91       	pop	r16
    2e38:	08 95       	ret

00002e3a <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e3a:	0f 93       	push	r16
    2e3c:	cf 93       	push	r28
    2e3e:	df 93       	push	r29
    2e40:	1f 92       	push	r1
    2e42:	cd b7       	in	r28, 0x3d	; 61
    2e44:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e46:	00 e0       	ldi	r16, 0x00	; 0
    2e48:	2f ef       	ldi	r18, 0xFF	; 255
    2e4a:	3f ef       	ldi	r19, 0xFF	; 255
    2e4c:	a9 01       	movw	r20, r18
    2e4e:	be 01       	movw	r22, r28
    2e50:	6f 5f       	subi	r22, 0xFF	; 255
    2e52:	7f 4f       	sbci	r23, 0xFF	; 255
    2e54:	fc 01       	movw	r30, r24
    2e56:	80 85       	ldd	r24, Z+8	; 0x08
    2e58:	91 85       	ldd	r25, Z+9	; 0x09
    2e5a:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <xQueueGenericReceive>
    2e5e:	81 30       	cpi	r24, 0x01	; 1
    2e60:	19 f4       	brne	.+6      	; 0x2e68 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e62:	89 81       	ldd	r24, Y+1	; 0x01
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	02 c0       	rjmp	.+4      	; 0x2e6c <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2e68:	8f ef       	ldi	r24, 0xFF	; 255
    2e6a:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2e6c:	0f 90       	pop	r0
    2e6e:	df 91       	pop	r29
    2e70:	cf 91       	pop	r28
    2e72:	0f 91       	pop	r16
    2e74:	08 95       	ret

00002e76 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2e76:	fc 01       	movw	r30, r24
    2e78:	80 85       	ldd	r24, Z+8	; 0x08
    2e7a:	91 85       	ldd	r25, Z+9	; 0x09
    2e7c:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxQueueMessagesWaiting>
    2e80:	91 e0       	ldi	r25, 0x01	; 1
    2e82:	81 11       	cpse	r24, r1
    2e84:	01 c0       	rjmp	.+2      	; 0x2e88 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2e86:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2e88:	89 2f       	mov	r24, r25
    2e8a:	08 95       	ret

00002e8c <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2e8c:	0f 93       	push	r16
    2e8e:	cf 93       	push	r28
    2e90:	df 93       	push	r29
    2e92:	1f 92       	push	r1
    2e94:	cd b7       	in	r28, 0x3d	; 61
    2e96:	de b7       	in	r29, 0x3e	; 62
    2e98:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2e9a:	fc 01       	movw	r30, r24
    2e9c:	22 85       	ldd	r18, Z+10	; 0x0a
    2e9e:	33 85       	ldd	r19, Z+11	; 0x0b
    2ea0:	44 85       	ldd	r20, Z+12	; 0x0c
    2ea2:	55 85       	ldd	r21, Z+13	; 0x0d
    2ea4:	00 e0       	ldi	r16, 0x00	; 0
    2ea6:	be 01       	movw	r22, r28
    2ea8:	6f 5f       	subi	r22, 0xFF	; 255
    2eaa:	7f 4f       	sbci	r23, 0xFF	; 255
    2eac:	80 85       	ldd	r24, Z+8	; 0x08
    2eae:	91 85       	ldd	r25, Z+9	; 0x09
    2eb0:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <xQueueGenericSend>
    2eb4:	91 e0       	ldi	r25, 0x01	; 1
    2eb6:	81 11       	cpse	r24, r1
    2eb8:	01 c0       	rjmp	.+2      	; 0x2ebc <_ZN14frt_text_queue7putcharEc+0x30>
    2eba:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2ebc:	89 2f       	mov	r24, r25
    2ebe:	0f 90       	pop	r0
    2ec0:	df 91       	pop	r29
    2ec2:	cf 91       	pop	r28
    2ec4:	0f 91       	pop	r16
    2ec6:	08 95       	ret

00002ec8 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ec8:	8f 92       	push	r8
    2eca:	9f 92       	push	r9
    2ecc:	bf 92       	push	r11
    2ece:	cf 92       	push	r12
    2ed0:	df 92       	push	r13
    2ed2:	ef 92       	push	r14
    2ed4:	ff 92       	push	r15
    2ed6:	0f 93       	push	r16
    2ed8:	1f 93       	push	r17
    2eda:	cf 93       	push	r28
    2edc:	df 93       	push	r29
    2ede:	ec 01       	movw	r28, r24
    2ee0:	b6 2e       	mov	r11, r22
    2ee2:	4a 01       	movw	r8, r20
    2ee4:	68 01       	movw	r12, r16
    2ee6:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2ee8:	0e 94 9e 19 	call	0x333c	; 0x333c <_ZN8emstreamC1Ev>
    2eec:	87 e5       	ldi	r24, 0x57	; 87
    2eee:	90 e2       	ldi	r25, 0x20	; 32
    2ef0:	88 83       	st	Y, r24
    2ef2:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2ef4:	8e 86       	std	Y+14, r8	; 0x0e
    2ef6:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2ef8:	40 e0       	ldi	r20, 0x00	; 0
    2efa:	61 e0       	ldi	r22, 0x01	; 1
    2efc:	8b 2d       	mov	r24, r11
    2efe:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <xQueueGenericCreate>
    2f02:	88 87       	std	Y+8, r24	; 0x08
    2f04:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f06:	ca 86       	std	Y+10, r12	; 0x0a
    2f08:	db 86       	std	Y+11, r13	; 0x0b
    2f0a:	ec 86       	std	Y+12, r14	; 0x0c
    2f0c:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f0e:	df 91       	pop	r29
    2f10:	cf 91       	pop	r28
    2f12:	1f 91       	pop	r17
    2f14:	0f 91       	pop	r16
    2f16:	ff 90       	pop	r15
    2f18:	ef 90       	pop	r14
    2f1a:	df 90       	pop	r13
    2f1c:	cf 90       	pop	r12
    2f1e:	bf 90       	pop	r11
    2f20:	9f 90       	pop	r9
    2f22:	8f 90       	pop	r8
    2f24:	08 95       	ret

00002f26 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f26:	cf 92       	push	r12
    2f28:	df 92       	push	r13
    2f2a:	ef 92       	push	r14
    2f2c:	ff 92       	push	r15
    2f2e:	cf 93       	push	r28
    2f30:	df 93       	push	r29
    2f32:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f34:	68 81       	ld	r22, Y
    2f36:	79 81       	ldd	r23, Y+1	; 0x01
    2f38:	8a 81       	ldd	r24, Y+2	; 0x02
    2f3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f3c:	0f 2e       	mov	r0, r31
    2f3e:	f8 ee       	ldi	r31, 0xE8	; 232
    2f40:	cf 2e       	mov	r12, r31
    2f42:	f3 e0       	ldi	r31, 0x03	; 3
    2f44:	df 2e       	mov	r13, r31
    2f46:	e1 2c       	mov	r14, r1
    2f48:	f1 2c       	mov	r15, r1
    2f4a:	f0 2d       	mov	r31, r0
    2f4c:	a7 01       	movw	r20, r14
    2f4e:	96 01       	movw	r18, r12
    2f50:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <__udivmodsi4>
    2f54:	9b 01       	movw	r18, r22
    2f56:	ac 01       	movw	r20, r24
    2f58:	60 e4       	ldi	r22, 0x40	; 64
    2f5a:	72 e4       	ldi	r23, 0x42	; 66
    2f5c:	8f e0       	ldi	r24, 0x0F	; 15
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
    2f60:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <__mulsi3>
    2f64:	a7 01       	movw	r20, r14
    2f66:	96 01       	movw	r18, r12
    2f68:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <__udivmodsi4>
    2f6c:	69 01       	movw	r12, r18
    2f6e:	7a 01       	movw	r14, r20
    2f70:	ac 81       	ldd	r26, Y+4	; 0x04
    2f72:	bd 81       	ldd	r27, Y+5	; 0x05
    2f74:	20 e4       	ldi	r18, 0x40	; 64
    2f76:	32 e4       	ldi	r19, 0x42	; 66
    2f78:	4f e0       	ldi	r20, 0x0F	; 15
    2f7a:	50 e0       	ldi	r21, 0x00	; 0
    2f7c:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <__muluhisi3>
    2f80:	20 e0       	ldi	r18, 0x00	; 0
    2f82:	38 e4       	ldi	r19, 0x48	; 72
    2f84:	48 ee       	ldi	r20, 0xE8	; 232
    2f86:	51 e0       	ldi	r21, 0x01	; 1
    2f88:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <__udivmodsi4>
    2f8c:	c7 01       	movw	r24, r14
    2f8e:	b6 01       	movw	r22, r12
    2f90:	62 0f       	add	r22, r18
    2f92:	73 1f       	adc	r23, r19
    2f94:	84 1f       	adc	r24, r20
    2f96:	95 1f       	adc	r25, r21
}
    2f98:	df 91       	pop	r29
    2f9a:	cf 91       	pop	r28
    2f9c:	ff 90       	pop	r15
    2f9e:	ef 90       	pop	r14
    2fa0:	df 90       	pop	r13
    2fa2:	cf 90       	pop	r12
    2fa4:	08 95       	ret

00002fa6 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2fa6:	cf 92       	push	r12
    2fa8:	df 92       	push	r13
    2faa:	ef 92       	push	r14
    2fac:	ff 92       	push	r15
    2fae:	0f 93       	push	r16
    2fb0:	1f 93       	push	r17
    2fb2:	cf 93       	push	r28
    2fb4:	df 93       	push	r29
    2fb6:	cd b7       	in	r28, 0x3d	; 61
    2fb8:	de b7       	in	r29, 0x3e	; 62
    2fba:	2f 97       	sbiw	r28, 0x0f	; 15
    2fbc:	cd bf       	out	0x3d, r28	; 61
    2fbe:	de bf       	out	0x3e, r29	; 62
    2fc0:	6c 01       	movw	r12, r24
    2fc2:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2fc4:	db 01       	movw	r26, r22
    2fc6:	6d 91       	ld	r22, X+
    2fc8:	7d 91       	ld	r23, X+
    2fca:	8d 91       	ld	r24, X+
    2fcc:	9c 91       	ld	r25, X
    2fce:	28 ee       	ldi	r18, 0xE8	; 232
    2fd0:	33 e0       	ldi	r19, 0x03	; 3
    2fd2:	40 e0       	ldi	r20, 0x00	; 0
    2fd4:	50 e0       	ldi	r21, 0x00	; 0
    2fd6:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <__udivmodsi4>
    2fda:	ba 01       	movw	r22, r20
    2fdc:	a9 01       	movw	r20, r18
    2fde:	c6 01       	movw	r24, r12
    2fe0:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2fe4:	d6 01       	movw	r26, r12
    2fe6:	ed 91       	ld	r30, X+
    2fe8:	fc 91       	ld	r31, X
    2fea:	02 80       	ldd	r0, Z+2	; 0x02
    2fec:	f3 81       	ldd	r31, Z+3	; 0x03
    2fee:	e0 2d       	mov	r30, r0
    2ff0:	6e e2       	ldi	r22, 0x2E	; 46
    2ff2:	c6 01       	movw	r24, r12
    2ff4:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2ff6:	c8 01       	movw	r24, r16
    2ff8:	0e 94 93 17 	call	0x2f26	; 0x2f26 <_ZN10time_stamp12get_microsecEv>
    2ffc:	8e 01       	movw	r16, r28
    2ffe:	09 5f       	subi	r16, 0xF9	; 249
    3000:	1f 4f       	sbci	r17, 0xFF	; 255
    3002:	fe 01       	movw	r30, r28
    3004:	31 96       	adiw	r30, 0x01	; 1
    3006:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3008:	2a e0       	ldi	r18, 0x0A	; 10
    300a:	30 e0       	ldi	r19, 0x00	; 0
    300c:	40 e0       	ldi	r20, 0x00	; 0
    300e:	50 e0       	ldi	r21, 0x00	; 0
    3010:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <__divmodsi4>
    3014:	e6 2f       	mov	r30, r22
    3016:	28 87       	std	Y+8, r18	; 0x08
    3018:	39 87       	std	Y+9, r19	; 0x09
    301a:	4a 87       	std	Y+10, r20	; 0x0a
    301c:	5b 87       	std	Y+11, r21	; 0x0b
    301e:	68 85       	ldd	r22, Y+8	; 0x08
    3020:	79 85       	ldd	r23, Y+9	; 0x09
    3022:	8a 85       	ldd	r24, Y+10	; 0x0a
    3024:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3026:	20 e3       	ldi	r18, 0x30	; 48
    3028:	2e 0f       	add	r18, r30
    302a:	d8 01       	movw	r26, r16
    302c:	2e 93       	st	-X, r18
    302e:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3030:	ae 15       	cp	r26, r14
    3032:	bf 05       	cpc	r27, r15
    3034:	49 f7       	brne	.-46     	; 0x3008 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3036:	1f 82       	std	Y+7, r1	; 0x07
    3038:	be 01       	movw	r22, r28
    303a:	6f 5f       	subi	r22, 0xFF	; 255
    303c:	7f 4f       	sbci	r23, 0xFF	; 255
    303e:	c6 01       	movw	r24, r12
    3040:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3044:	c6 01       	movw	r24, r12
    3046:	2f 96       	adiw	r28, 0x0f	; 15
    3048:	cd bf       	out	0x3d, r28	; 61
    304a:	de bf       	out	0x3e, r29	; 62
    304c:	df 91       	pop	r29
    304e:	cf 91       	pop	r28
    3050:	1f 91       	pop	r17
    3052:	0f 91       	pop	r16
    3054:	ff 90       	pop	r15
    3056:	ef 90       	pop	r14
    3058:	df 90       	pop	r13
    305a:	cf 90       	pop	r12
    305c:	08 95       	ret

0000305e <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    305e:	cf 93       	push	r28
    3060:	df 93       	push	r29
    3062:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3064:	0f b6       	in	r0, 0x3f	; 63
    3066:	f8 94       	cli
    3068:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    306a:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    306e:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3072:	8c 83       	std	Y+4, r24	; 0x04
    3074:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3076:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
    307a:	68 83       	st	Y, r22
    307c:	79 83       	std	Y+1, r23	; 0x01
    307e:	8a 83       	std	Y+2, r24	; 0x02
    3080:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3082:	0f 90       	pop	r0
    3084:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3086:	ce 01       	movw	r24, r28
    3088:	df 91       	pop	r29
    308a:	cf 91       	pop	r28
    308c:	08 95       	ret

0000308e <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    308e:	5f 92       	push	r5
    3090:	6f 92       	push	r6
    3092:	7f 92       	push	r7
    3094:	8f 92       	push	r8
    3096:	9f 92       	push	r9
    3098:	af 92       	push	r10
    309a:	bf 92       	push	r11
    309c:	cf 92       	push	r12
    309e:	df 92       	push	r13
    30a0:	ef 92       	push	r14
    30a2:	ff 92       	push	r15
    30a4:	0f 93       	push	r16
    30a6:	1f 93       	push	r17
    30a8:	cf 93       	push	r28
    30aa:	df 93       	push	r29
    30ac:	5c 01       	movw	r10, r24
    30ae:	4b 01       	movw	r8, r22
    30b0:	7a 01       	movw	r14, r20
    30b2:	12 2f       	mov	r17, r18
    30b4:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    30b6:	63 e0       	ldi	r22, 0x03	; 3
    30b8:	ca 01       	movw	r24, r20
    30ba:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    30be:	a8 14       	cp	r10, r8
    30c0:	b9 04       	cpc	r11, r9
    30c2:	08 f0       	brcs	.+2      	; 0x30c6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    30c4:	7d c0       	rjmp	.+250    	; 0x31c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30c6:	65 01       	movw	r12, r10
    30c8:	84 e1       	ldi	r24, 0x14	; 20
    30ca:	c8 0e       	add	r12, r24
    30cc:	d1 1c       	adc	r13, r1
    30ce:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    30d0:	6a 2c       	mov	r6, r10
    30d2:	5b 2c       	mov	r5, r11
    30d4:	b5 01       	movw	r22, r10
    30d6:	c7 01       	movw	r24, r14
    30d8:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEj>
    30dc:	6a e0       	ldi	r22, 0x0A	; 10
    30de:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    30e2:	61 e5       	ldi	r22, 0x51	; 81
    30e4:	75 e0       	ldi	r23, 0x05	; 5
    30e6:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    30ea:	11 23       	and	r17, r17
    30ec:	09 f4       	brne	.+2      	; 0x30f0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    30ee:	6d c0       	rjmp	.+218    	; 0x31ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    30f0:	00 23       	and	r16, r16
    30f2:	09 f4       	brne	.+2      	; 0x30f6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    30f4:	6a c0       	rjmp	.+212    	; 0x31ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    30f6:	6a e0       	ldi	r22, 0x0A	; 10
    30f8:	c7 01       	movw	r24, r14
    30fa:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    30fe:	6c e4       	ldi	r22, 0x4C	; 76
    3100:	75 e0       	ldi	r23, 0x05	; 5
    3102:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    3106:	61 c0       	rjmp	.+194    	; 0x31ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3108:	11 23       	and	r17, r17
    310a:	71 f0       	breq	.+28     	; 0x3128 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    310c:	01 11       	cpse	r16, r1
    310e:	0c c0       	rjmp	.+24     	; 0x3128 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3110:	88 81       	ld	r24, Y
    3112:	87 15       	cp	r24, r7
    3114:	49 f0       	breq	.+18     	; 0x3128 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3116:	6a e0       	ldi	r22, 0x0A	; 10
    3118:	c7 01       	movw	r24, r14
    311a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    311e:	67 e4       	ldi	r22, 0x47	; 71
    3120:	75 e0       	ldi	r23, 0x05	; 5
    3122:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3126:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3128:	69 91       	ld	r22, Y+
    312a:	c7 01       	movw	r24, r14
    312c:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3130:	dc 01       	movw	r26, r24
    3132:	ed 91       	ld	r30, X+
    3134:	fc 91       	ld	r31, X
    3136:	02 80       	ldd	r0, Z+2	; 0x02
    3138:	f3 81       	ldd	r31, Z+3	; 0x03
    313a:	e0 2d       	mov	r30, r0
    313c:	60 e2       	ldi	r22, 0x20	; 32
    313e:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3140:	cc 16       	cp	r12, r28
    3142:	dd 06       	cpc	r13, r29
    3144:	09 f7       	brne	.-62     	; 0x3108 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3146:	11 23       	and	r17, r17
    3148:	89 f0       	breq	.+34     	; 0x316c <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    314a:	6a e0       	ldi	r22, 0x0A	; 10
    314c:	c7 01       	movw	r24, r14
    314e:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    3152:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3154:	61 e4       	ldi	r22, 0x41	; 65
    3156:	75 e0       	ldi	r23, 0x05	; 5
    3158:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    315c:	e8 81       	ld	r30, Y
    315e:	f9 81       	ldd	r31, Y+1	; 0x01
    3160:	02 80       	ldd	r0, Z+2	; 0x02
    3162:	f3 81       	ldd	r31, Z+3	; 0x03
    3164:	e0 2d       	mov	r30, r0
    3166:	60 e2       	ldi	r22, 0x20	; 32
    3168:	ce 01       	movw	r24, r28
    316a:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    316c:	c6 2d       	mov	r28, r6
    316e:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3170:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3172:	80 ee       	ldi	r24, 0xE0	; 224
    3174:	86 0f       	add	r24, r22
    3176:	8f 35       	cpi	r24, 0x5F	; 95
    3178:	48 f4       	brcc	.+18     	; 0x318c <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    317a:	d7 01       	movw	r26, r14
    317c:	ed 91       	ld	r30, X+
    317e:	fc 91       	ld	r31, X
    3180:	02 80       	ldd	r0, Z+2	; 0x02
    3182:	f3 81       	ldd	r31, Z+3	; 0x03
    3184:	e0 2d       	mov	r30, r0
    3186:	c7 01       	movw	r24, r14
    3188:	19 95       	eicall
    318a:	09 c0       	rjmp	.+18     	; 0x319e <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    318c:	d7 01       	movw	r26, r14
    318e:	ed 91       	ld	r30, X+
    3190:	fc 91       	ld	r31, X
    3192:	02 80       	ldd	r0, Z+2	; 0x02
    3194:	f3 81       	ldd	r31, Z+3	; 0x03
    3196:	e0 2d       	mov	r30, r0
    3198:	6e e2       	ldi	r22, 0x2E	; 46
    319a:	c7 01       	movw	r24, r14
    319c:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    319e:	cc 16       	cp	r12, r28
    31a0:	dd 06       	cpc	r13, r29
    31a2:	31 f7       	brne	.-52     	; 0x3170 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31a4:	b4 e1       	ldi	r27, 0x14	; 20
    31a6:	ab 0e       	add	r10, r27
    31a8:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31aa:	66 e0       	ldi	r22, 0x06	; 6
    31ac:	c7 01       	movw	r24, r14
    31ae:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    31b2:	84 e1       	ldi	r24, 0x14	; 20
    31b4:	c8 0e       	add	r12, r24
    31b6:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31b8:	a8 14       	cp	r10, r8
    31ba:	b9 04       	cpc	r11, r9
    31bc:	08 f4       	brcc	.+2      	; 0x31c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31be:	88 cf       	rjmp	.-240    	; 0x30d0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    31c0:	62 e0       	ldi	r22, 0x02	; 2
    31c2:	c7 01       	movw	r24, r14
    31c4:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
}
    31c8:	03 c0       	rjmp	.+6      	; 0x31d0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31ca:	c6 2d       	mov	r28, r6
    31cc:	d5 2d       	mov	r29, r5
    31ce:	9c cf       	rjmp	.-200    	; 0x3108 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    31d0:	df 91       	pop	r29
    31d2:	cf 91       	pop	r28
    31d4:	1f 91       	pop	r17
    31d6:	0f 91       	pop	r16
    31d8:	ff 90       	pop	r15
    31da:	ef 90       	pop	r14
    31dc:	df 90       	pop	r13
    31de:	cf 90       	pop	r12
    31e0:	bf 90       	pop	r11
    31e2:	af 90       	pop	r10
    31e4:	9f 90       	pop	r9
    31e6:	8f 90       	pop	r8
    31e8:	7f 90       	pop	r7
    31ea:	6f 90       	pop	r6
    31ec:	5f 90       	pop	r5
    31ee:	08 95       	ret

000031f0 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    31f0:	0e 94 29 09 	call	0x1252	; 0x1252 <pvPortMalloc>
    31f4:	08 95       	ret

000031f6 <_Znaj>:
    31f6:	0e 94 29 09 	call	0x1252	; 0x1252 <pvPortMalloc>
    31fa:	08 95       	ret

000031fc <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    31fc:	08 95       	ret

000031fe <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    31fe:	cf 93       	push	r28
    3200:	df 93       	push	r29
    3202:	fc 01       	movw	r30, r24
    3204:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3206:	40 3a       	cpi	r20, 0xA0	; 160
    3208:	68 e0       	ldi	r22, 0x08	; 8
    320a:	56 07       	cpc	r21, r22
    320c:	49 f4       	brne	.+18     	; 0x3220 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    320e:	80 e4       	ldi	r24, 0x40	; 64
    3210:	96 e0       	ldi	r25, 0x06	; 6
    3212:	82 83       	std	Z+2, r24	; 0x02
    3214:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3216:	82 e0       	ldi	r24, 0x02	; 2
    3218:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    321a:	83 e0       	ldi	r24, 0x03	; 3
    321c:	85 83       	std	Z+5, r24	; 0x05
    321e:	32 c0       	rjmp	.+100    	; 0x3284 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3220:	40 3b       	cpi	r20, 0xB0	; 176
    3222:	78 e0       	ldi	r23, 0x08	; 8
    3224:	57 07       	cpc	r21, r23
    3226:	49 f4       	brne	.+18     	; 0x323a <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3228:	80 e4       	ldi	r24, 0x40	; 64
    322a:	96 e0       	ldi	r25, 0x06	; 6
    322c:	82 83       	std	Z+2, r24	; 0x02
    322e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3230:	86 e0       	ldi	r24, 0x06	; 6
    3232:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3234:	87 e0       	ldi	r24, 0x07	; 7
    3236:	85 83       	std	Z+5, r24	; 0x05
    3238:	25 c0       	rjmp	.+74     	; 0x3284 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    323a:	40 3a       	cpi	r20, 0xA0	; 160
    323c:	89 e0       	ldi	r24, 0x09	; 9
    323e:	58 07       	cpc	r21, r24
    3240:	49 f4       	brne	.+18     	; 0x3254 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3242:	80 e6       	ldi	r24, 0x60	; 96
    3244:	96 e0       	ldi	r25, 0x06	; 6
    3246:	82 83       	std	Z+2, r24	; 0x02
    3248:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    324a:	82 e0       	ldi	r24, 0x02	; 2
    324c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    324e:	83 e0       	ldi	r24, 0x03	; 3
    3250:	85 83       	std	Z+5, r24	; 0x05
    3252:	18 c0       	rjmp	.+48     	; 0x3284 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3254:	40 3b       	cpi	r20, 0xB0	; 176
    3256:	69 e0       	ldi	r22, 0x09	; 9
    3258:	56 07       	cpc	r21, r22
    325a:	49 f4       	brne	.+18     	; 0x326e <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    325c:	80 e6       	ldi	r24, 0x60	; 96
    325e:	96 e0       	ldi	r25, 0x06	; 6
    3260:	82 83       	std	Z+2, r24	; 0x02
    3262:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3264:	86 e0       	ldi	r24, 0x06	; 6
    3266:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3268:	87 e0       	ldi	r24, 0x07	; 7
    326a:	85 83       	std	Z+5, r24	; 0x05
    326c:	0b c0       	rjmp	.+22     	; 0x3284 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    326e:	40 3a       	cpi	r20, 0xA0	; 160
    3270:	5a 40       	sbci	r21, 0x0A	; 10
    3272:	41 f4       	brne	.+16     	; 0x3284 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3274:	80 e8       	ldi	r24, 0x80	; 128
    3276:	96 e0       	ldi	r25, 0x06	; 6
    3278:	82 83       	std	Z+2, r24	; 0x02
    327a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    327c:	82 e0       	ldi	r24, 0x02	; 2
    327e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3280:	83 e0       	ldi	r24, 0x03	; 3
    3282:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3284:	a6 83       	std	Z+6, r26	; 0x06
    3286:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3288:	cd 01       	movw	r24, r26
    328a:	01 96       	adiw	r24, 0x01	; 1
    328c:	80 87       	std	Z+8, r24	; 0x08
    328e:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3290:	03 96       	adiw	r24, 0x03	; 3
    3292:	82 87       	std	Z+10, r24	; 0x0a
    3294:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3296:	25 81       	ldd	r18, Z+5	; 0x05
    3298:	c2 81       	ldd	r28, Z+2	; 0x02
    329a:	d3 81       	ldd	r29, Z+3	; 0x03
    329c:	4c 81       	ldd	r20, Y+4	; 0x04
    329e:	81 e0       	ldi	r24, 0x01	; 1
    32a0:	90 e0       	ldi	r25, 0x00	; 0
    32a2:	bc 01       	movw	r22, r24
    32a4:	02 c0       	rjmp	.+4      	; 0x32aa <_ZN7base232C1EjP12USART_struct+0xac>
    32a6:	66 0f       	add	r22, r22
    32a8:	77 1f       	adc	r23, r23
    32aa:	2a 95       	dec	r18
    32ac:	e2 f7       	brpl	.-8      	; 0x32a6 <_ZN7base232C1EjP12USART_struct+0xa8>
    32ae:	9b 01       	movw	r18, r22
    32b0:	24 2b       	or	r18, r20
    32b2:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    32b4:	25 81       	ldd	r18, Z+5	; 0x05
    32b6:	c2 81       	ldd	r28, Z+2	; 0x02
    32b8:	d3 81       	ldd	r29, Z+3	; 0x03
    32ba:	48 81       	ld	r20, Y
    32bc:	bc 01       	movw	r22, r24
    32be:	02 c0       	rjmp	.+4      	; 0x32c4 <_ZN7base232C1EjP12USART_struct+0xc6>
    32c0:	66 0f       	add	r22, r22
    32c2:	77 1f       	adc	r23, r23
    32c4:	2a 95       	dec	r18
    32c6:	e2 f7       	brpl	.-8      	; 0x32c0 <_ZN7base232C1EjP12USART_struct+0xc2>
    32c8:	9b 01       	movw	r18, r22
    32ca:	24 2b       	or	r18, r20
    32cc:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    32ce:	34 81       	ldd	r19, Z+4	; 0x04
    32d0:	c2 81       	ldd	r28, Z+2	; 0x02
    32d2:	d3 81       	ldd	r29, Z+3	; 0x03
    32d4:	28 81       	ld	r18, Y
    32d6:	02 c0       	rjmp	.+4      	; 0x32dc <_ZN7base232C1EjP12USART_struct+0xde>
    32d8:	88 0f       	add	r24, r24
    32da:	99 1f       	adc	r25, r25
    32dc:	3a 95       	dec	r19
    32de:	e2 f7       	brpl	.-8      	; 0x32d8 <_ZN7base232C1EjP12USART_struct+0xda>
    32e0:	80 95       	com	r24
    32e2:	90 95       	com	r25
    32e4:	82 23       	and	r24, r18
    32e6:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    32e8:	80 e1       	ldi	r24, 0x10	; 16
    32ea:	13 96       	adiw	r26, 0x03	; 3
    32ec:	8c 93       	st	X, r24
    32ee:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    32f0:	83 e0       	ldi	r24, 0x03	; 3
    32f2:	15 96       	adiw	r26, 0x05	; 5
    32f4:	8c 93       	st	X, r24
    32f6:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    32f8:	80 ef       	ldi	r24, 0xF0	; 240
    32fa:	17 96       	adiw	r26, 0x07	; 7
    32fc:	8c 93       	st	X, r24
    32fe:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3300:	81 e2       	ldi	r24, 0x21	; 33
    3302:	16 96       	adiw	r26, 0x06	; 6
    3304:	8c 93       	st	X, r24
    3306:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3308:	88 e1       	ldi	r24, 0x18	; 24
    330a:	14 96       	adiw	r26, 0x04	; 4
    330c:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    330e:	80 e8       	ldi	r24, 0x80	; 128
    3310:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3312:	80 e4       	ldi	r24, 0x40	; 64
    3314:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3316:	80 e2       	ldi	r24, 0x20	; 32
    3318:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    331a:	06 80       	ldd	r0, Z+6	; 0x06
    331c:	f7 81       	ldd	r31, Z+7	; 0x07
    331e:	e0 2d       	mov	r30, r0
    3320:	80 81       	ld	r24, Z
    3322:	80 81       	ld	r24, Z
}
    3324:	df 91       	pop	r29
    3326:	cf 91       	pop	r28
    3328:	08 95       	ret

0000332a <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    332a:	81 e0       	ldi	r24, 0x01	; 1
    332c:	08 95       	ret

0000332e <_ZN8emstream7getcharEv>:
    332e:	80 e0       	ldi	r24, 0x00	; 0
    3330:	90 e0       	ldi	r25, 0x00	; 0
    3332:	08 95       	ret

00003334 <_ZN8emstream14check_for_charEv>:
    3334:	80 e0       	ldi	r24, 0x00	; 0
    3336:	08 95       	ret

00003338 <_ZN8emstream12transmit_nowEv>:
    3338:	08 95       	ret

0000333a <_ZN8emstream12clear_screenEv>:
    333a:	08 95       	ret

0000333c <_ZN8emstreamC1Ev>:
    333c:	fc 01       	movw	r30, r24
    333e:	87 e6       	ldi	r24, 0x67	; 103
    3340:	90 e2       	ldi	r25, 0x20	; 32
    3342:	80 83       	st	Z, r24
    3344:	91 83       	std	Z+1, r25	; 0x01
    3346:	8a e0       	ldi	r24, 0x0A	; 10
    3348:	82 83       	std	Z+2, r24	; 0x02
    334a:	13 82       	std	Z+3, r1	; 0x03
    334c:	83 e0       	ldi	r24, 0x03	; 3
    334e:	85 83       	std	Z+5, r24	; 0x05
    3350:	14 82       	std	Z+4, r1	; 0x04
    3352:	16 82       	std	Z+6, r1	; 0x06
    3354:	17 82       	std	Z+7, r1	; 0x07
    3356:	08 95       	ret

00003358 <_ZN8emstream4putsEPKc>:
    3358:	0f 93       	push	r16
    335a:	1f 93       	push	r17
    335c:	cf 93       	push	r28
    335e:	df 93       	push	r29
    3360:	8c 01       	movw	r16, r24
    3362:	fb 01       	movw	r30, r22
    3364:	dc 01       	movw	r26, r24
    3366:	14 96       	adiw	r26, 0x04	; 4
    3368:	8c 91       	ld	r24, X
    336a:	81 11       	cpse	r24, r1
    336c:	04 c0       	rjmp	.+8      	; 0x3376 <_ZN8emstream4putsEPKc+0x1e>
    336e:	60 81       	ld	r22, Z
    3370:	61 11       	cpse	r22, r1
    3372:	17 c0       	rjmp	.+46     	; 0x33a2 <_ZN8emstream4putsEPKc+0x4a>
    3374:	23 c0       	rjmp	.+70     	; 0x33bc <_ZN8emstream4putsEPKc+0x64>
    3376:	d8 01       	movw	r26, r16
    3378:	14 96       	adiw	r26, 0x04	; 4
    337a:	1c 92       	st	X, r1
    337c:	eb 01       	movw	r28, r22
    337e:	21 96       	adiw	r28, 0x01	; 1
    3380:	64 91       	lpm	r22, Z
    3382:	66 23       	and	r22, r22
    3384:	d9 f0       	breq	.+54     	; 0x33bc <_ZN8emstream4putsEPKc+0x64>
    3386:	d8 01       	movw	r26, r16
    3388:	ed 91       	ld	r30, X+
    338a:	fc 91       	ld	r31, X
    338c:	02 80       	ldd	r0, Z+2	; 0x02
    338e:	f3 81       	ldd	r31, Z+3	; 0x03
    3390:	e0 2d       	mov	r30, r0
    3392:	c8 01       	movw	r24, r16
    3394:	19 95       	eicall
    3396:	fe 01       	movw	r30, r28
    3398:	64 91       	lpm	r22, Z
    339a:	21 96       	adiw	r28, 0x01	; 1
    339c:	61 11       	cpse	r22, r1
    339e:	f3 cf       	rjmp	.-26     	; 0x3386 <_ZN8emstream4putsEPKc+0x2e>
    33a0:	0d c0       	rjmp	.+26     	; 0x33bc <_ZN8emstream4putsEPKc+0x64>
    33a2:	ef 01       	movw	r28, r30
    33a4:	21 96       	adiw	r28, 0x01	; 1
    33a6:	d8 01       	movw	r26, r16
    33a8:	ed 91       	ld	r30, X+
    33aa:	fc 91       	ld	r31, X
    33ac:	02 80       	ldd	r0, Z+2	; 0x02
    33ae:	f3 81       	ldd	r31, Z+3	; 0x03
    33b0:	e0 2d       	mov	r30, r0
    33b2:	c8 01       	movw	r24, r16
    33b4:	19 95       	eicall
    33b6:	69 91       	ld	r22, Y+
    33b8:	61 11       	cpse	r22, r1
    33ba:	f5 cf       	rjmp	.-22     	; 0x33a6 <_ZN8emstream4putsEPKc+0x4e>
    33bc:	df 91       	pop	r29
    33be:	cf 91       	pop	r28
    33c0:	1f 91       	pop	r17
    33c2:	0f 91       	pop	r16
    33c4:	08 95       	ret

000033c6 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    33c6:	cf 93       	push	r28
    33c8:	df 93       	push	r29
    33ca:	ec 01       	movw	r28, r24
	switch (new_manip)
    33cc:	86 2f       	mov	r24, r22
    33ce:	90 e0       	ldi	r25, 0x00	; 0
    33d0:	8b 30       	cpi	r24, 0x0B	; 11
    33d2:	91 05       	cpc	r25, r1
    33d4:	d8 f5       	brcc	.+118    	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
    33d6:	fc 01       	movw	r30, r24
    33d8:	88 27       	eor	r24, r24
    33da:	e2 50       	subi	r30, 0x02	; 2
    33dc:	ff 4f       	sbci	r31, 0xFF	; 255
    33de:	8f 4f       	sbci	r24, 0xFF	; 255
    33e0:	0c 94 82 1f 	jmp	0x3f04	; 0x3f04 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    33e4:	82 e0       	ldi	r24, 0x02	; 2
    33e6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    33e8:	31 c0       	rjmp	.+98     	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    33ea:	88 e0       	ldi	r24, 0x08	; 8
    33ec:	8a 83       	std	Y+2, r24	; 0x02
			break;
    33ee:	2e c0       	rjmp	.+92     	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    33f0:	8a e0       	ldi	r24, 0x0A	; 10
    33f2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    33f4:	2b c0       	rjmp	.+86     	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    33f6:	80 e1       	ldi	r24, 0x10	; 16
    33f8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    33fa:	28 c0       	rjmp	.+80     	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    33fc:	81 e0       	ldi	r24, 0x01	; 1
    33fe:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3400:	25 c0       	rjmp	.+74     	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3402:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3404:	23 c0       	rjmp	.+70     	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3406:	e8 81       	ld	r30, Y
    3408:	f9 81       	ldd	r31, Y+1	; 0x01
    340a:	02 80       	ldd	r0, Z+2	; 0x02
    340c:	f3 81       	ldd	r31, Z+3	; 0x03
    340e:	e0 2d       	mov	r30, r0
    3410:	6d e0       	ldi	r22, 0x0D	; 13
    3412:	ce 01       	movw	r24, r28
    3414:	19 95       	eicall
    3416:	e8 81       	ld	r30, Y
    3418:	f9 81       	ldd	r31, Y+1	; 0x01
    341a:	02 80       	ldd	r0, Z+2	; 0x02
    341c:	f3 81       	ldd	r31, Z+3	; 0x03
    341e:	e0 2d       	mov	r30, r0
    3420:	6a e0       	ldi	r22, 0x0A	; 10
    3422:	ce 01       	movw	r24, r28
    3424:	19 95       	eicall
			break;
    3426:	12 c0       	rjmp	.+36     	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3428:	e8 81       	ld	r30, Y
    342a:	f9 81       	ldd	r31, Y+1	; 0x01
    342c:	02 84       	ldd	r0, Z+10	; 0x0a
    342e:	f3 85       	ldd	r31, Z+11	; 0x0b
    3430:	e0 2d       	mov	r30, r0
    3432:	ce 01       	movw	r24, r28
    3434:	19 95       	eicall
			break;
    3436:	0a c0       	rjmp	.+20     	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3438:	e8 81       	ld	r30, Y
    343a:	f9 81       	ldd	r31, Y+1	; 0x01
    343c:	00 84       	ldd	r0, Z+8	; 0x08
    343e:	f1 85       	ldd	r31, Z+9	; 0x09
    3440:	e0 2d       	mov	r30, r0
    3442:	ce 01       	movw	r24, r28
    3444:	19 95       	eicall
			break;
    3446:	02 c0       	rjmp	.+4      	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3448:	81 e0       	ldi	r24, 0x01	; 1
    344a:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    344c:	ce 01       	movw	r24, r28
    344e:	df 91       	pop	r29
    3450:	cf 91       	pop	r28
    3452:	08 95       	ret

00003454 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3454:	ff 92       	push	r15
    3456:	0f 93       	push	r16
    3458:	1f 93       	push	r17
    345a:	cf 93       	push	r28
    345c:	df 93       	push	r29
    345e:	cd b7       	in	r28, 0x3d	; 61
    3460:	de b7       	in	r29, 0x3e	; 62
    3462:	61 97       	sbiw	r28, 0x11	; 17
    3464:	cd bf       	out	0x3d, r28	; 61
    3466:	de bf       	out	0x3e, r29	; 62
    3468:	8c 01       	movw	r16, r24
    346a:	f6 2e       	mov	r15, r22
    346c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    346e:	f8 01       	movw	r30, r16
    3470:	42 81       	ldd	r20, Z+2	; 0x02
    3472:	40 31       	cpi	r20, 0x10	; 16
    3474:	21 f0       	breq	.+8      	; 0x347e <_ZN8emstreamlsEj+0x2a>
    3476:	48 30       	cpi	r20, 0x08	; 8
    3478:	11 f0       	breq	.+4      	; 0x347e <_ZN8emstreamlsEj+0x2a>
    347a:	42 30       	cpi	r20, 0x02	; 2
    347c:	41 f4       	brne	.+16     	; 0x348e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    347e:	69 2f       	mov	r22, r25
    3480:	c8 01       	movw	r24, r16
    3482:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
    3486:	6f 2d       	mov	r22, r15
    3488:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
    348c:	0d c0       	rjmp	.+26     	; 0x34a8 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    348e:	50 e0       	ldi	r21, 0x00	; 0
    3490:	be 01       	movw	r22, r28
    3492:	6f 5f       	subi	r22, 0xFF	; 255
    3494:	7f 4f       	sbci	r23, 0xFF	; 255
    3496:	8f 2d       	mov	r24, r15
    3498:	0e 94 1c 20 	call	0x4038	; 0x4038 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    349c:	be 01       	movw	r22, r28
    349e:	6f 5f       	subi	r22, 0xFF	; 255
    34a0:	7f 4f       	sbci	r23, 0xFF	; 255
    34a2:	c8 01       	movw	r24, r16
    34a4:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    34a8:	c8 01       	movw	r24, r16
    34aa:	61 96       	adiw	r28, 0x11	; 17
    34ac:	cd bf       	out	0x3d, r28	; 61
    34ae:	de bf       	out	0x3e, r29	; 62
    34b0:	df 91       	pop	r29
    34b2:	cf 91       	pop	r28
    34b4:	1f 91       	pop	r17
    34b6:	0f 91       	pop	r16
    34b8:	ff 90       	pop	r15
    34ba:	08 95       	ret

000034bc <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    34bc:	df 92       	push	r13
    34be:	ef 92       	push	r14
    34c0:	ff 92       	push	r15
    34c2:	0f 93       	push	r16
    34c4:	1f 93       	push	r17
    34c6:	cf 93       	push	r28
    34c8:	df 93       	push	r29
    34ca:	cd b7       	in	r28, 0x3d	; 61
    34cc:	de b7       	in	r29, 0x3e	; 62
    34ce:	a1 97       	sbiw	r28, 0x21	; 33
    34d0:	cd bf       	out	0x3d, r28	; 61
    34d2:	de bf       	out	0x3e, r29	; 62
    34d4:	8c 01       	movw	r16, r24
    34d6:	d4 2e       	mov	r13, r20
    34d8:	e5 2e       	mov	r14, r21
    34da:	f6 2e       	mov	r15, r22
    34dc:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    34de:	f8 01       	movw	r30, r16
    34e0:	22 81       	ldd	r18, Z+2	; 0x02
    34e2:	20 31       	cpi	r18, 0x10	; 16
    34e4:	21 f0       	breq	.+8      	; 0x34ee <_ZN8emstreamlsEm+0x32>
    34e6:	28 30       	cpi	r18, 0x08	; 8
    34e8:	11 f0       	breq	.+4      	; 0x34ee <_ZN8emstreamlsEm+0x32>
    34ea:	22 30       	cpi	r18, 0x02	; 2
    34ec:	71 f4       	brne	.+28     	; 0x350a <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    34ee:	69 2f       	mov	r22, r25
    34f0:	c8 01       	movw	r24, r16
    34f2:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
    34f6:	6f 2d       	mov	r22, r15
    34f8:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
    34fc:	6e 2d       	mov	r22, r14
    34fe:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
    3502:	6d 2d       	mov	r22, r13
    3504:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEh>
    3508:	0f c0       	rjmp	.+30     	; 0x3528 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    350a:	30 e0       	ldi	r19, 0x00	; 0
    350c:	ae 01       	movw	r20, r28
    350e:	4f 5f       	subi	r20, 0xFF	; 255
    3510:	5f 4f       	sbci	r21, 0xFF	; 255
    3512:	6d 2d       	mov	r22, r13
    3514:	7e 2d       	mov	r23, r14
    3516:	8f 2d       	mov	r24, r15
    3518:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    351c:	be 01       	movw	r22, r28
    351e:	6f 5f       	subi	r22, 0xFF	; 255
    3520:	7f 4f       	sbci	r23, 0xFF	; 255
    3522:	c8 01       	movw	r24, r16
    3524:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3528:	c8 01       	movw	r24, r16
    352a:	a1 96       	adiw	r28, 0x21	; 33
    352c:	cd bf       	out	0x3d, r28	; 61
    352e:	de bf       	out	0x3e, r29	; 62
    3530:	df 91       	pop	r29
    3532:	cf 91       	pop	r28
    3534:	1f 91       	pop	r17
    3536:	0f 91       	pop	r16
    3538:	ff 90       	pop	r15
    353a:	ef 90       	pop	r14
    353c:	df 90       	pop	r13
    353e:	08 95       	ret

00003540 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3540:	cf 92       	push	r12
    3542:	df 92       	push	r13
    3544:	ef 92       	push	r14
    3546:	ff 92       	push	r15
    3548:	0f 93       	push	r16
    354a:	1f 93       	push	r17
    354c:	cf 93       	push	r28
    354e:	df 93       	push	r29
    3550:	cd b7       	in	r28, 0x3d	; 61
    3552:	de b7       	in	r29, 0x3e	; 62
    3554:	29 97       	sbiw	r28, 0x09	; 9
    3556:	cd bf       	out	0x3d, r28	; 61
    3558:	de bf       	out	0x3e, r29	; 62
    355a:	8c 01       	movw	r16, r24
    355c:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    355e:	dc 01       	movw	r26, r24
    3560:	13 96       	adiw	r26, 0x03	; 3
    3562:	8c 91       	ld	r24, X
    3564:	13 97       	sbiw	r26, 0x03	; 3
    3566:	88 23       	and	r24, r24
    3568:	41 f0       	breq	.+16     	; 0x357a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    356a:	ed 91       	ld	r30, X+
    356c:	fc 91       	ld	r31, X
    356e:	02 80       	ldd	r0, Z+2	; 0x02
    3570:	f3 81       	ldd	r31, Z+3	; 0x03
    3572:	e0 2d       	mov	r30, r0
    3574:	c8 01       	movw	r24, r16
    3576:	19 95       	eicall
    3578:	56 c0       	rjmp	.+172    	; 0x3626 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    357a:	f8 01       	movw	r30, r16
    357c:	42 81       	ldd	r20, Z+2	; 0x02
    357e:	42 30       	cpi	r20, 0x02	; 2
    3580:	19 f5       	brne	.+70     	; 0x35c8 <_ZN8emstreamlsEh+0x88>
    3582:	68 94       	set
    3584:	cc 24       	eor	r12, r12
    3586:	c3 f8       	bld	r12, 3
    3588:	d1 2c       	mov	r13, r1
    358a:	68 94       	set
    358c:	ff 24       	eor	r15, r15
    358e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3590:	8e 2d       	mov	r24, r14
    3592:	8f 21       	and	r24, r15
    3594:	51 f0       	breq	.+20     	; 0x35aa <_ZN8emstreamlsEh+0x6a>
    3596:	d8 01       	movw	r26, r16
    3598:	ed 91       	ld	r30, X+
    359a:	fc 91       	ld	r31, X
    359c:	02 80       	ldd	r0, Z+2	; 0x02
    359e:	f3 81       	ldd	r31, Z+3	; 0x03
    35a0:	e0 2d       	mov	r30, r0
    35a2:	61 e3       	ldi	r22, 0x31	; 49
    35a4:	c8 01       	movw	r24, r16
    35a6:	19 95       	eicall
    35a8:	09 c0       	rjmp	.+18     	; 0x35bc <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    35aa:	d8 01       	movw	r26, r16
    35ac:	ed 91       	ld	r30, X+
    35ae:	fc 91       	ld	r31, X
    35b0:	02 80       	ldd	r0, Z+2	; 0x02
    35b2:	f3 81       	ldd	r31, Z+3	; 0x03
    35b4:	e0 2d       	mov	r30, r0
    35b6:	60 e3       	ldi	r22, 0x30	; 48
    35b8:	c8 01       	movw	r24, r16
    35ba:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    35bc:	f6 94       	lsr	r15
    35be:	b1 e0       	ldi	r27, 0x01	; 1
    35c0:	cb 1a       	sub	r12, r27
    35c2:	d1 08       	sbc	r13, r1
    35c4:	29 f7       	brne	.-54     	; 0x3590 <_ZN8emstreamlsEh+0x50>
    35c6:	2f c0       	rjmp	.+94     	; 0x3626 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    35c8:	40 31       	cpi	r20, 0x10	; 16
    35ca:	f9 f4       	brne	.+62     	; 0x360a <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    35cc:	62 95       	swap	r22
    35ce:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    35d0:	01 90       	ld	r0, Z+
    35d2:	f0 81       	ld	r31, Z
    35d4:	e0 2d       	mov	r30, r0
    35d6:	02 80       	ldd	r0, Z+2	; 0x02
    35d8:	f3 81       	ldd	r31, Z+3	; 0x03
    35da:	e0 2d       	mov	r30, r0
    35dc:	6a 30       	cpi	r22, 0x0A	; 10
    35de:	10 f0       	brcs	.+4      	; 0x35e4 <_ZN8emstreamlsEh+0xa4>
    35e0:	69 5c       	subi	r22, 0xC9	; 201
    35e2:	01 c0       	rjmp	.+2      	; 0x35e6 <_ZN8emstreamlsEh+0xa6>
    35e4:	60 5d       	subi	r22, 0xD0	; 208
    35e6:	c8 01       	movw	r24, r16
    35e8:	19 95       	eicall
		temp_char = num & 0x0F;
    35ea:	6e 2d       	mov	r22, r14
    35ec:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    35ee:	d8 01       	movw	r26, r16
    35f0:	ed 91       	ld	r30, X+
    35f2:	fc 91       	ld	r31, X
    35f4:	02 80       	ldd	r0, Z+2	; 0x02
    35f6:	f3 81       	ldd	r31, Z+3	; 0x03
    35f8:	e0 2d       	mov	r30, r0
    35fa:	6a 30       	cpi	r22, 0x0A	; 10
    35fc:	10 f0       	brcs	.+4      	; 0x3602 <_ZN8emstreamlsEh+0xc2>
    35fe:	69 5c       	subi	r22, 0xC9	; 201
    3600:	01 c0       	rjmp	.+2      	; 0x3604 <_ZN8emstreamlsEh+0xc4>
    3602:	60 5d       	subi	r22, 0xD0	; 208
    3604:	c8 01       	movw	r24, r16
    3606:	19 95       	eicall
    3608:	0e c0       	rjmp	.+28     	; 0x3626 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    360a:	50 e0       	ldi	r21, 0x00	; 0
    360c:	be 01       	movw	r22, r28
    360e:	6f 5f       	subi	r22, 0xFF	; 255
    3610:	7f 4f       	sbci	r23, 0xFF	; 255
    3612:	8e 2d       	mov	r24, r14
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	0e 94 1c 20 	call	0x4038	; 0x4038 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    361a:	be 01       	movw	r22, r28
    361c:	6f 5f       	subi	r22, 0xFF	; 255
    361e:	7f 4f       	sbci	r23, 0xFF	; 255
    3620:	c8 01       	movw	r24, r16
    3622:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3626:	c8 01       	movw	r24, r16
    3628:	29 96       	adiw	r28, 0x09	; 9
    362a:	cd bf       	out	0x3d, r28	; 61
    362c:	de bf       	out	0x3e, r29	; 62
    362e:	df 91       	pop	r29
    3630:	cf 91       	pop	r28
    3632:	1f 91       	pop	r17
    3634:	0f 91       	pop	r16
    3636:	ff 90       	pop	r15
    3638:	ef 90       	pop	r14
    363a:	df 90       	pop	r13
    363c:	cf 90       	pop	r12
    363e:	08 95       	ret

00003640 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3640:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3642:	50 96       	adiw	r26, 0x10	; 16
    3644:	ed 91       	ld	r30, X+
    3646:	fc 91       	ld	r31, X
    3648:	51 97       	sbiw	r26, 0x11	; 17
    364a:	80 81       	ld	r24, Z
    364c:	54 96       	adiw	r26, 0x14	; 20
    364e:	4c 91       	ld	r20, X
    3650:	54 97       	sbiw	r26, 0x14	; 20
    3652:	84 23       	and	r24, r20
    3654:	29 f0       	breq	.+10     	; 0x3660 <_ZN5rs2327putcharEc+0x20>
    3656:	09 c0       	rjmp	.+18     	; 0x366a <_ZN5rs2327putcharEc+0x2a>
    3658:	21 50       	subi	r18, 0x01	; 1
    365a:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    365c:	19 f4       	brne	.+6      	; 0x3664 <_ZN5rs2327putcharEc+0x24>
    365e:	12 c0       	rjmp	.+36     	; 0x3684 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3660:	21 e2       	ldi	r18, 0x21	; 33
    3662:	3e e4       	ldi	r19, 0x4E	; 78
    3664:	90 81       	ld	r25, Z
    3666:	94 23       	and	r25, r20
    3668:	b9 f3       	breq	.-18     	; 0x3658 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    366a:	90 81       	ld	r25, Z
    366c:	56 96       	adiw	r26, 0x16	; 22
    366e:	8c 91       	ld	r24, X
    3670:	56 97       	sbiw	r26, 0x16	; 22
    3672:	89 2b       	or	r24, r25
    3674:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3676:	1e 96       	adiw	r26, 0x0e	; 14
    3678:	ed 91       	ld	r30, X+
    367a:	fc 91       	ld	r31, X
    367c:	1f 97       	sbiw	r26, 0x0f	; 15
    367e:	60 83       	st	Z, r22
	return (true);
    3680:	81 e0       	ldi	r24, 0x01	; 1
    3682:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3684:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3686:	08 95       	ret

00003688 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3688:	cf 93       	push	r28
    368a:	df 93       	push	r29
    368c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    368e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3690:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3692:	28 81       	ld	r18, Y
    3694:	39 81       	ldd	r19, Y+1	; 0x01
    3696:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3698:	b4 8d       	ldd	r27, Z+28	; 0x1c
    369a:	4d 91       	ld	r20, X+
    369c:	5c 91       	ld	r21, X
    369e:	24 17       	cp	r18, r20
    36a0:	35 07       	cpc	r19, r21
    36a2:	e9 f3       	breq	.-6      	; 0x369e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    36a4:	a7 89       	ldd	r26, Z+23	; 0x17
    36a6:	b0 8d       	ldd	r27, Z+24	; 0x18
    36a8:	0d 90       	ld	r0, X+
    36aa:	bc 91       	ld	r27, X
    36ac:	a0 2d       	mov	r26, r0
    36ae:	a2 0f       	add	r26, r18
    36b0:	b3 1f       	adc	r27, r19
    36b2:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    36b4:	2f 5f       	subi	r18, 0xFF	; 255
    36b6:	3f 4f       	sbci	r19, 0xFF	; 255
    36b8:	28 83       	st	Y, r18
    36ba:	39 83       	std	Y+1, r19	; 0x01
    36bc:	24 36       	cpi	r18, 0x64	; 100
    36be:	31 05       	cpc	r19, r1
    36c0:	28 f0       	brcs	.+10     	; 0x36cc <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    36c2:	01 8c       	ldd	r0, Z+25	; 0x19
    36c4:	f2 8d       	ldd	r31, Z+26	; 0x1a
    36c6:	e0 2d       	mov	r30, r0
    36c8:	10 82       	st	Z, r1
    36ca:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    36cc:	90 e0       	ldi	r25, 0x00	; 0
    36ce:	df 91       	pop	r29
    36d0:	cf 91       	pop	r28
    36d2:	08 95       	ret

000036d4 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    36d4:	cf 93       	push	r28
    36d6:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    36d8:	ec 01       	movw	r28, r24
    36da:	a9 8d       	ldd	r26, Y+25	; 0x19
    36dc:	ba 8d       	ldd	r27, Y+26	; 0x1a
    36de:	eb 8d       	ldd	r30, Y+27	; 0x1b
    36e0:	fc 8d       	ldd	r31, Y+28	; 0x1c
    36e2:	81 e0       	ldi	r24, 0x01	; 1
    36e4:	4d 91       	ld	r20, X+
    36e6:	5c 91       	ld	r21, X
    36e8:	20 81       	ld	r18, Z
    36ea:	31 81       	ldd	r19, Z+1	; 0x01
    36ec:	42 17       	cp	r20, r18
    36ee:	53 07       	cpc	r21, r19
    36f0:	09 f4       	brne	.+2      	; 0x36f4 <_ZN5rs23214check_for_charEv+0x20>
    36f2:	80 e0       	ldi	r24, 0x00	; 0
}
    36f4:	df 91       	pop	r29
    36f6:	cf 91       	pop	r28
    36f8:	08 95       	ret

000036fa <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    36fa:	dc 01       	movw	r26, r24
    36fc:	ed 91       	ld	r30, X+
    36fe:	fc 91       	ld	r31, X
    3700:	02 80       	ldd	r0, Z+2	; 0x02
    3702:	f3 81       	ldd	r31, Z+3	; 0x03
    3704:	e0 2d       	mov	r30, r0
    3706:	6c e0       	ldi	r22, 0x0C	; 12
    3708:	19 95       	eicall
    370a:	08 95       	ret

0000370c <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    370c:	ef 92       	push	r14
    370e:	ff 92       	push	r15
    3710:	0f 93       	push	r16
    3712:	1f 93       	push	r17
    3714:	cf 93       	push	r28
    3716:	df 93       	push	r29
    3718:	ec 01       	movw	r28, r24
    371a:	7b 01       	movw	r14, r22
    371c:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    371e:	0e 94 9e 19 	call	0x333c	; 0x333c <_ZN8emstreamC1Ev>
    3722:	a8 01       	movw	r20, r16
    3724:	b7 01       	movw	r22, r14
    3726:	ce 01       	movw	r24, r28
    3728:	08 96       	adiw	r24, 0x08	; 8
    372a:	0e 94 ff 18 	call	0x31fe	; 0x31fe <_ZN7base232C1EjP12USART_struct>
    372e:	87 e7       	ldi	r24, 0x77	; 119
    3730:	90 e2       	ldi	r25, 0x20	; 32
    3732:	88 83       	st	Y, r24
    3734:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3736:	00 3a       	cpi	r16, 0xA0	; 160
    3738:	88 e0       	ldi	r24, 0x08	; 8
    373a:	18 07       	cpc	r17, r24
    373c:	69 f4       	brne	.+26     	; 0x3758 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    373e:	82 e7       	ldi	r24, 0x72	; 114
    3740:	91 e3       	ldi	r25, 0x31	; 49
    3742:	8f 8b       	std	Y+23, r24	; 0x17
    3744:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3746:	88 e6       	ldi	r24, 0x68	; 104
    3748:	91 e3       	ldi	r25, 0x31	; 49
    374a:	89 8f       	std	Y+25, r24	; 0x19
    374c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    374e:	8e e5       	ldi	r24, 0x5E	; 94
    3750:	91 e3       	ldi	r25, 0x31	; 49
    3752:	8b 8f       	std	Y+27, r24	; 0x1b
    3754:	9c 8f       	std	Y+28, r25	; 0x1c
    3756:	42 c0       	rjmp	.+132    	; 0x37dc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3758:	00 3b       	cpi	r16, 0xB0	; 176
    375a:	e8 e0       	ldi	r30, 0x08	; 8
    375c:	1e 07       	cpc	r17, r30
    375e:	69 f4       	brne	.+26     	; 0x377a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3760:	80 e7       	ldi	r24, 0x70	; 112
    3762:	91 e3       	ldi	r25, 0x31	; 49
    3764:	8f 8b       	std	Y+23, r24	; 0x17
    3766:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3768:	86 e6       	ldi	r24, 0x66	; 102
    376a:	91 e3       	ldi	r25, 0x31	; 49
    376c:	89 8f       	std	Y+25, r24	; 0x19
    376e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3770:	8c e5       	ldi	r24, 0x5C	; 92
    3772:	91 e3       	ldi	r25, 0x31	; 49
    3774:	8b 8f       	std	Y+27, r24	; 0x1b
    3776:	9c 8f       	std	Y+28, r25	; 0x1c
    3778:	31 c0       	rjmp	.+98     	; 0x37dc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    377a:	00 3a       	cpi	r16, 0xA0	; 160
    377c:	f9 e0       	ldi	r31, 0x09	; 9
    377e:	1f 07       	cpc	r17, r31
    3780:	69 f4       	brne	.+26     	; 0x379c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3782:	8e e6       	ldi	r24, 0x6E	; 110
    3784:	91 e3       	ldi	r25, 0x31	; 49
    3786:	8f 8b       	std	Y+23, r24	; 0x17
    3788:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    378a:	84 e6       	ldi	r24, 0x64	; 100
    378c:	91 e3       	ldi	r25, 0x31	; 49
    378e:	89 8f       	std	Y+25, r24	; 0x19
    3790:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3792:	8a e5       	ldi	r24, 0x5A	; 90
    3794:	91 e3       	ldi	r25, 0x31	; 49
    3796:	8b 8f       	std	Y+27, r24	; 0x1b
    3798:	9c 8f       	std	Y+28, r25	; 0x1c
    379a:	20 c0       	rjmp	.+64     	; 0x37dc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    379c:	00 3b       	cpi	r16, 0xB0	; 176
    379e:	89 e0       	ldi	r24, 0x09	; 9
    37a0:	18 07       	cpc	r17, r24
    37a2:	69 f4       	brne	.+26     	; 0x37be <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    37a4:	8c e6       	ldi	r24, 0x6C	; 108
    37a6:	91 e3       	ldi	r25, 0x31	; 49
    37a8:	8f 8b       	std	Y+23, r24	; 0x17
    37aa:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    37ac:	82 e6       	ldi	r24, 0x62	; 98
    37ae:	91 e3       	ldi	r25, 0x31	; 49
    37b0:	89 8f       	std	Y+25, r24	; 0x19
    37b2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    37b4:	88 e5       	ldi	r24, 0x58	; 88
    37b6:	91 e3       	ldi	r25, 0x31	; 49
    37b8:	8b 8f       	std	Y+27, r24	; 0x1b
    37ba:	9c 8f       	std	Y+28, r25	; 0x1c
    37bc:	0f c0       	rjmp	.+30     	; 0x37dc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    37be:	00 3a       	cpi	r16, 0xA0	; 160
    37c0:	1a 40       	sbci	r17, 0x0A	; 10
    37c2:	61 f4       	brne	.+24     	; 0x37dc <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    37c4:	8a e6       	ldi	r24, 0x6A	; 106
    37c6:	91 e3       	ldi	r25, 0x31	; 49
    37c8:	8f 8b       	std	Y+23, r24	; 0x17
    37ca:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    37cc:	80 e6       	ldi	r24, 0x60	; 96
    37ce:	91 e3       	ldi	r25, 0x31	; 49
    37d0:	89 8f       	std	Y+25, r24	; 0x19
    37d2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    37d4:	86 e5       	ldi	r24, 0x56	; 86
    37d6:	91 e3       	ldi	r25, 0x31	; 49
    37d8:	8b 8f       	std	Y+27, r24	; 0x1b
    37da:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    37dc:	0f 89       	ldd	r16, Y+23	; 0x17
    37de:	18 8d       	ldd	r17, Y+24	; 0x18
    37e0:	84 e6       	ldi	r24, 0x64	; 100
    37e2:	90 e0       	ldi	r25, 0x00	; 0
    37e4:	0e 94 fb 18 	call	0x31f6	; 0x31f6 <_Znaj>
    37e8:	f8 01       	movw	r30, r16
    37ea:	80 83       	st	Z, r24
    37ec:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    37ee:	e9 8d       	ldd	r30, Y+25	; 0x19
    37f0:	fa 8d       	ldd	r31, Y+26	; 0x1a
    37f2:	10 82       	st	Z, r1
    37f4:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    37f6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    37f8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    37fa:	10 82       	st	Z, r1
    37fc:	11 82       	std	Z+1, r1	; 0x01
}
    37fe:	df 91       	pop	r29
    3800:	cf 91       	pop	r28
    3802:	1f 91       	pop	r17
    3804:	0f 91       	pop	r16
    3806:	ff 90       	pop	r15
    3808:	ef 90       	pop	r14
    380a:	08 95       	ret

0000380c <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    380c:	1f 92       	push	r1
    380e:	0f 92       	push	r0
    3810:	0f b6       	in	r0, 0x3f	; 63
    3812:	0f 92       	push	r0
    3814:	11 24       	eor	r1, r1
    3816:	08 b6       	in	r0, 0x38	; 56
    3818:	0f 92       	push	r0
    381a:	18 be       	out	0x38, r1	; 56
    381c:	0b b6       	in	r0, 0x3b	; 59
    381e:	0f 92       	push	r0
    3820:	1b be       	out	0x3b, r1	; 59
    3822:	2f 93       	push	r18
    3824:	3f 93       	push	r19
    3826:	8f 93       	push	r24
    3828:	9f 93       	push	r25
    382a:	ef 93       	push	r30
    382c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    382e:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3832:	e0 91 72 31 	lds	r30, 0x3172	; 0x803172 <rcvC0_buffer>
    3836:	f0 91 73 31 	lds	r31, 0x3173	; 0x803173 <rcvC0_buffer+0x1>
    383a:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvC0_write_index>
    383e:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvC0_write_index+0x1>
    3842:	e8 0f       	add	r30, r24
    3844:	f9 1f       	adc	r31, r25
    3846:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3848:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvC0_write_index>
    384c:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvC0_write_index+0x1>
    3850:	01 96       	adiw	r24, 0x01	; 1
    3852:	84 36       	cpi	r24, 0x64	; 100
    3854:	91 05       	cpc	r25, r1
    3856:	60 f4       	brcc	.+24     	; 0x3870 <__vector_25+0x64>
    3858:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <rcvC0_write_index>
    385c:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3860:	20 91 68 31 	lds	r18, 0x3168	; 0x803168 <rcvC0_read_index>
    3864:	30 91 69 31 	lds	r19, 0x3169	; 0x803169 <rcvC0_read_index+0x1>
    3868:	82 17       	cp	r24, r18
    386a:	93 07       	cpc	r25, r19
    386c:	f1 f4       	brne	.+60     	; 0x38aa <__vector_25+0x9e>
    386e:	0c c0       	rjmp	.+24     	; 0x3888 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3870:	10 92 5e 31 	sts	0x315E, r1	; 0x80315e <rcvC0_write_index>
    3874:	10 92 5f 31 	sts	0x315F, r1	; 0x80315f <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3878:	80 91 68 31 	lds	r24, 0x3168	; 0x803168 <rcvC0_read_index>
    387c:	90 91 69 31 	lds	r25, 0x3169	; 0x803169 <rcvC0_read_index+0x1>
    3880:	18 16       	cp	r1, r24
    3882:	19 06       	cpc	r1, r25
    3884:	91 f4       	brne	.+36     	; 0x38aa <__vector_25+0x9e>
    3886:	0e c0       	rjmp	.+28     	; 0x38a4 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3888:	01 96       	adiw	r24, 0x01	; 1
    388a:	84 36       	cpi	r24, 0x64	; 100
    388c:	91 05       	cpc	r25, r1
    388e:	28 f4       	brcc	.+10     	; 0x389a <__vector_25+0x8e>
    3890:	80 93 68 31 	sts	0x3168, r24	; 0x803168 <rcvC0_read_index>
    3894:	90 93 69 31 	sts	0x3169, r25	; 0x803169 <rcvC0_read_index+0x1>
    3898:	08 c0       	rjmp	.+16     	; 0x38aa <__vector_25+0x9e>
			rcvC0_read_index = 0;
    389a:	10 92 68 31 	sts	0x3168, r1	; 0x803168 <rcvC0_read_index>
    389e:	10 92 69 31 	sts	0x3169, r1	; 0x803169 <rcvC0_read_index+0x1>
}
    38a2:	03 c0       	rjmp	.+6      	; 0x38aa <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    38a4:	81 e0       	ldi	r24, 0x01	; 1
    38a6:	90 e0       	ldi	r25, 0x00	; 0
    38a8:	f3 cf       	rjmp	.-26     	; 0x3890 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    38aa:	ff 91       	pop	r31
    38ac:	ef 91       	pop	r30
    38ae:	9f 91       	pop	r25
    38b0:	8f 91       	pop	r24
    38b2:	3f 91       	pop	r19
    38b4:	2f 91       	pop	r18
    38b6:	0f 90       	pop	r0
    38b8:	0b be       	out	0x3b, r0	; 59
    38ba:	0f 90       	pop	r0
    38bc:	08 be       	out	0x38, r0	; 56
    38be:	0f 90       	pop	r0
    38c0:	0f be       	out	0x3f, r0	; 63
    38c2:	0f 90       	pop	r0
    38c4:	1f 90       	pop	r1
    38c6:	18 95       	reti

000038c8 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    38c8:	1f 92       	push	r1
    38ca:	0f 92       	push	r0
    38cc:	0f b6       	in	r0, 0x3f	; 63
    38ce:	0f 92       	push	r0
    38d0:	11 24       	eor	r1, r1
    38d2:	08 b6       	in	r0, 0x38	; 56
    38d4:	0f 92       	push	r0
    38d6:	18 be       	out	0x38, r1	; 56
    38d8:	0b b6       	in	r0, 0x3b	; 59
    38da:	0f 92       	push	r0
    38dc:	1b be       	out	0x3b, r1	; 59
    38de:	2f 93       	push	r18
    38e0:	3f 93       	push	r19
    38e2:	8f 93       	push	r24
    38e4:	9f 93       	push	r25
    38e6:	ef 93       	push	r30
    38e8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    38ea:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    38ee:	e0 91 70 31 	lds	r30, 0x3170	; 0x803170 <rcvC1_buffer>
    38f2:	f0 91 71 31 	lds	r31, 0x3171	; 0x803171 <rcvC1_buffer+0x1>
    38f6:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC1_write_index>
    38fa:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC1_write_index+0x1>
    38fe:	e8 0f       	add	r30, r24
    3900:	f9 1f       	adc	r31, r25
    3902:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3904:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC1_write_index>
    3908:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC1_write_index+0x1>
    390c:	01 96       	adiw	r24, 0x01	; 1
    390e:	84 36       	cpi	r24, 0x64	; 100
    3910:	91 05       	cpc	r25, r1
    3912:	60 f4       	brcc	.+24     	; 0x392c <__vector_28+0x64>
    3914:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvC1_write_index>
    3918:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    391c:	20 91 66 31 	lds	r18, 0x3166	; 0x803166 <rcvC1_read_index>
    3920:	30 91 67 31 	lds	r19, 0x3167	; 0x803167 <rcvC1_read_index+0x1>
    3924:	82 17       	cp	r24, r18
    3926:	93 07       	cpc	r25, r19
    3928:	f1 f4       	brne	.+60     	; 0x3966 <__vector_28+0x9e>
    392a:	0c c0       	rjmp	.+24     	; 0x3944 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    392c:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvC1_write_index>
    3930:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3934:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <rcvC1_read_index>
    3938:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <rcvC1_read_index+0x1>
    393c:	18 16       	cp	r1, r24
    393e:	19 06       	cpc	r1, r25
    3940:	91 f4       	brne	.+36     	; 0x3966 <__vector_28+0x9e>
    3942:	0e c0       	rjmp	.+28     	; 0x3960 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3944:	01 96       	adiw	r24, 0x01	; 1
    3946:	84 36       	cpi	r24, 0x64	; 100
    3948:	91 05       	cpc	r25, r1
    394a:	28 f4       	brcc	.+10     	; 0x3956 <__vector_28+0x8e>
    394c:	80 93 66 31 	sts	0x3166, r24	; 0x803166 <rcvC1_read_index>
    3950:	90 93 67 31 	sts	0x3167, r25	; 0x803167 <rcvC1_read_index+0x1>
    3954:	08 c0       	rjmp	.+16     	; 0x3966 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3956:	10 92 66 31 	sts	0x3166, r1	; 0x803166 <rcvC1_read_index>
    395a:	10 92 67 31 	sts	0x3167, r1	; 0x803167 <rcvC1_read_index+0x1>
}
    395e:	03 c0       	rjmp	.+6      	; 0x3966 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3960:	81 e0       	ldi	r24, 0x01	; 1
    3962:	90 e0       	ldi	r25, 0x00	; 0
    3964:	f3 cf       	rjmp	.-26     	; 0x394c <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3966:	ff 91       	pop	r31
    3968:	ef 91       	pop	r30
    396a:	9f 91       	pop	r25
    396c:	8f 91       	pop	r24
    396e:	3f 91       	pop	r19
    3970:	2f 91       	pop	r18
    3972:	0f 90       	pop	r0
    3974:	0b be       	out	0x3b, r0	; 59
    3976:	0f 90       	pop	r0
    3978:	08 be       	out	0x38, r0	; 56
    397a:	0f 90       	pop	r0
    397c:	0f be       	out	0x3f, r0	; 63
    397e:	0f 90       	pop	r0
    3980:	1f 90       	pop	r1
    3982:	18 95       	reti

00003984 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3984:	1f 92       	push	r1
    3986:	0f 92       	push	r0
    3988:	0f b6       	in	r0, 0x3f	; 63
    398a:	0f 92       	push	r0
    398c:	11 24       	eor	r1, r1
    398e:	08 b6       	in	r0, 0x38	; 56
    3990:	0f 92       	push	r0
    3992:	18 be       	out	0x38, r1	; 56
    3994:	0b b6       	in	r0, 0x3b	; 59
    3996:	0f 92       	push	r0
    3998:	1b be       	out	0x3b, r1	; 59
    399a:	2f 93       	push	r18
    399c:	3f 93       	push	r19
    399e:	8f 93       	push	r24
    39a0:	9f 93       	push	r25
    39a2:	ef 93       	push	r30
    39a4:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    39a6:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    39aa:	e0 91 6e 31 	lds	r30, 0x316E	; 0x80316e <rcvD0_buffer>
    39ae:	f0 91 6f 31 	lds	r31, 0x316F	; 0x80316f <rcvD0_buffer+0x1>
    39b2:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvC0_write_index>
    39b6:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvC0_write_index+0x1>
    39ba:	e8 0f       	add	r30, r24
    39bc:	f9 1f       	adc	r31, r25
    39be:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    39c0:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvD0_write_index>
    39c4:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvD0_write_index+0x1>
    39c8:	01 96       	adiw	r24, 0x01	; 1
    39ca:	84 36       	cpi	r24, 0x64	; 100
    39cc:	91 05       	cpc	r25, r1
    39ce:	60 f4       	brcc	.+24     	; 0x39e8 <__vector_88+0x64>
    39d0:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvD0_write_index>
    39d4:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    39d8:	20 91 64 31 	lds	r18, 0x3164	; 0x803164 <rcvD0_read_index>
    39dc:	30 91 65 31 	lds	r19, 0x3165	; 0x803165 <rcvD0_read_index+0x1>
    39e0:	82 17       	cp	r24, r18
    39e2:	93 07       	cpc	r25, r19
    39e4:	f1 f4       	brne	.+60     	; 0x3a22 <__vector_88+0x9e>
    39e6:	0c c0       	rjmp	.+24     	; 0x3a00 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    39e8:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvD0_write_index>
    39ec:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    39f0:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <rcvD0_read_index>
    39f4:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <rcvD0_read_index+0x1>
    39f8:	18 16       	cp	r1, r24
    39fa:	19 06       	cpc	r1, r25
    39fc:	91 f4       	brne	.+36     	; 0x3a22 <__vector_88+0x9e>
    39fe:	0e c0       	rjmp	.+28     	; 0x3a1c <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a00:	01 96       	adiw	r24, 0x01	; 1
    3a02:	84 36       	cpi	r24, 0x64	; 100
    3a04:	91 05       	cpc	r25, r1
    3a06:	28 f4       	brcc	.+10     	; 0x3a12 <__vector_88+0x8e>
    3a08:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <rcvD0_read_index>
    3a0c:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <rcvD0_read_index+0x1>
    3a10:	08 c0       	rjmp	.+16     	; 0x3a22 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3a12:	10 92 64 31 	sts	0x3164, r1	; 0x803164 <rcvD0_read_index>
    3a16:	10 92 65 31 	sts	0x3165, r1	; 0x803165 <rcvD0_read_index+0x1>
}
    3a1a:	03 c0       	rjmp	.+6      	; 0x3a22 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a1c:	81 e0       	ldi	r24, 0x01	; 1
    3a1e:	90 e0       	ldi	r25, 0x00	; 0
    3a20:	f3 cf       	rjmp	.-26     	; 0x3a08 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3a22:	ff 91       	pop	r31
    3a24:	ef 91       	pop	r30
    3a26:	9f 91       	pop	r25
    3a28:	8f 91       	pop	r24
    3a2a:	3f 91       	pop	r19
    3a2c:	2f 91       	pop	r18
    3a2e:	0f 90       	pop	r0
    3a30:	0b be       	out	0x3b, r0	; 59
    3a32:	0f 90       	pop	r0
    3a34:	08 be       	out	0x38, r0	; 56
    3a36:	0f 90       	pop	r0
    3a38:	0f be       	out	0x3f, r0	; 63
    3a3a:	0f 90       	pop	r0
    3a3c:	1f 90       	pop	r1
    3a3e:	18 95       	reti

00003a40 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3a40:	1f 92       	push	r1
    3a42:	0f 92       	push	r0
    3a44:	0f b6       	in	r0, 0x3f	; 63
    3a46:	0f 92       	push	r0
    3a48:	11 24       	eor	r1, r1
    3a4a:	08 b6       	in	r0, 0x38	; 56
    3a4c:	0f 92       	push	r0
    3a4e:	18 be       	out	0x38, r1	; 56
    3a50:	0b b6       	in	r0, 0x3b	; 59
    3a52:	0f 92       	push	r0
    3a54:	1b be       	out	0x3b, r1	; 59
    3a56:	2f 93       	push	r18
    3a58:	3f 93       	push	r19
    3a5a:	8f 93       	push	r24
    3a5c:	9f 93       	push	r25
    3a5e:	ef 93       	push	r30
    3a60:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3a62:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3a66:	e0 91 6c 31 	lds	r30, 0x316C	; 0x80316c <rcvD1_buffer>
    3a6a:	f0 91 6d 31 	lds	r31, 0x316D	; 0x80316d <rcvD1_buffer+0x1>
    3a6e:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvD1_write_index>
    3a72:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvD1_write_index+0x1>
    3a76:	e8 0f       	add	r30, r24
    3a78:	f9 1f       	adc	r31, r25
    3a7a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3a7c:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvD1_write_index>
    3a80:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvD1_write_index+0x1>
    3a84:	01 96       	adiw	r24, 0x01	; 1
    3a86:	84 36       	cpi	r24, 0x64	; 100
    3a88:	91 05       	cpc	r25, r1
    3a8a:	60 f4       	brcc	.+24     	; 0x3aa4 <__vector_91+0x64>
    3a8c:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvD1_write_index>
    3a90:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3a94:	20 91 62 31 	lds	r18, 0x3162	; 0x803162 <rcvD1_read_index>
    3a98:	30 91 63 31 	lds	r19, 0x3163	; 0x803163 <rcvD1_read_index+0x1>
    3a9c:	82 17       	cp	r24, r18
    3a9e:	93 07       	cpc	r25, r19
    3aa0:	f1 f4       	brne	.+60     	; 0x3ade <__vector_91+0x9e>
    3aa2:	0c c0       	rjmp	.+24     	; 0x3abc <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3aa4:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvD1_write_index>
    3aa8:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3aac:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <rcvD1_read_index>
    3ab0:	90 91 63 31 	lds	r25, 0x3163	; 0x803163 <rcvD1_read_index+0x1>
    3ab4:	18 16       	cp	r1, r24
    3ab6:	19 06       	cpc	r1, r25
    3ab8:	91 f4       	brne	.+36     	; 0x3ade <__vector_91+0x9e>
    3aba:	0e c0       	rjmp	.+28     	; 0x3ad8 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3abc:	01 96       	adiw	r24, 0x01	; 1
    3abe:	84 36       	cpi	r24, 0x64	; 100
    3ac0:	91 05       	cpc	r25, r1
    3ac2:	28 f4       	brcc	.+10     	; 0x3ace <__vector_91+0x8e>
    3ac4:	80 93 62 31 	sts	0x3162, r24	; 0x803162 <rcvD1_read_index>
    3ac8:	90 93 63 31 	sts	0x3163, r25	; 0x803163 <rcvD1_read_index+0x1>
    3acc:	08 c0       	rjmp	.+16     	; 0x3ade <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3ace:	10 92 62 31 	sts	0x3162, r1	; 0x803162 <rcvD1_read_index>
    3ad2:	10 92 63 31 	sts	0x3163, r1	; 0x803163 <rcvD1_read_index+0x1>
}
    3ad6:	03 c0       	rjmp	.+6      	; 0x3ade <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3ad8:	81 e0       	ldi	r24, 0x01	; 1
    3ada:	90 e0       	ldi	r25, 0x00	; 0
    3adc:	f3 cf       	rjmp	.-26     	; 0x3ac4 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3ade:	ff 91       	pop	r31
    3ae0:	ef 91       	pop	r30
    3ae2:	9f 91       	pop	r25
    3ae4:	8f 91       	pop	r24
    3ae6:	3f 91       	pop	r19
    3ae8:	2f 91       	pop	r18
    3aea:	0f 90       	pop	r0
    3aec:	0b be       	out	0x3b, r0	; 59
    3aee:	0f 90       	pop	r0
    3af0:	08 be       	out	0x38, r0	; 56
    3af2:	0f 90       	pop	r0
    3af4:	0f be       	out	0x3f, r0	; 63
    3af6:	0f 90       	pop	r0
    3af8:	1f 90       	pop	r1
    3afa:	18 95       	reti

00003afc <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3afc:	1f 92       	push	r1
    3afe:	0f 92       	push	r0
    3b00:	0f b6       	in	r0, 0x3f	; 63
    3b02:	0f 92       	push	r0
    3b04:	11 24       	eor	r1, r1
    3b06:	08 b6       	in	r0, 0x38	; 56
    3b08:	0f 92       	push	r0
    3b0a:	18 be       	out	0x38, r1	; 56
    3b0c:	0b b6       	in	r0, 0x3b	; 59
    3b0e:	0f 92       	push	r0
    3b10:	1b be       	out	0x3b, r1	; 59
    3b12:	2f 93       	push	r18
    3b14:	3f 93       	push	r19
    3b16:	8f 93       	push	r24
    3b18:	9f 93       	push	r25
    3b1a:	ef 93       	push	r30
    3b1c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3b1e:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3b22:	e0 91 6a 31 	lds	r30, 0x316A	; 0x80316a <rcvE0_buffer>
    3b26:	f0 91 6b 31 	lds	r31, 0x316B	; 0x80316b <rcvE0_buffer+0x1>
    3b2a:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvE0_write_index>
    3b2e:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvE0_write_index+0x1>
    3b32:	e8 0f       	add	r30, r24
    3b34:	f9 1f       	adc	r31, r25
    3b36:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3b38:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvE0_write_index>
    3b3c:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvE0_write_index+0x1>
    3b40:	01 96       	adiw	r24, 0x01	; 1
    3b42:	84 36       	cpi	r24, 0x64	; 100
    3b44:	91 05       	cpc	r25, r1
    3b46:	60 f4       	brcc	.+24     	; 0x3b60 <__vector_58+0x64>
    3b48:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvE0_write_index>
    3b4c:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3b50:	20 91 60 31 	lds	r18, 0x3160	; 0x803160 <rcvE0_read_index>
    3b54:	30 91 61 31 	lds	r19, 0x3161	; 0x803161 <rcvE0_read_index+0x1>
    3b58:	82 17       	cp	r24, r18
    3b5a:	93 07       	cpc	r25, r19
    3b5c:	f1 f4       	brne	.+60     	; 0x3b9a <__vector_58+0x9e>
    3b5e:	0c c0       	rjmp	.+24     	; 0x3b78 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3b60:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvE0_write_index>
    3b64:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3b68:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvE0_read_index>
    3b6c:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvE0_read_index+0x1>
    3b70:	18 16       	cp	r1, r24
    3b72:	19 06       	cpc	r1, r25
    3b74:	91 f4       	brne	.+36     	; 0x3b9a <__vector_58+0x9e>
    3b76:	0e c0       	rjmp	.+28     	; 0x3b94 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3b78:	01 96       	adiw	r24, 0x01	; 1
    3b7a:	84 36       	cpi	r24, 0x64	; 100
    3b7c:	91 05       	cpc	r25, r1
    3b7e:	28 f4       	brcc	.+10     	; 0x3b8a <__vector_58+0x8e>
    3b80:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <rcvE0_read_index>
    3b84:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <rcvE0_read_index+0x1>
    3b88:	08 c0       	rjmp	.+16     	; 0x3b9a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3b8a:	10 92 60 31 	sts	0x3160, r1	; 0x803160 <rcvE0_read_index>
    3b8e:	10 92 61 31 	sts	0x3161, r1	; 0x803161 <rcvE0_read_index+0x1>
}
    3b92:	03 c0       	rjmp	.+6      	; 0x3b9a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3b94:	81 e0       	ldi	r24, 0x01	; 1
    3b96:	90 e0       	ldi	r25, 0x00	; 0
    3b98:	f3 cf       	rjmp	.-26     	; 0x3b80 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3b9a:	ff 91       	pop	r31
    3b9c:	ef 91       	pop	r30
    3b9e:	9f 91       	pop	r25
    3ba0:	8f 91       	pop	r24
    3ba2:	3f 91       	pop	r19
    3ba4:	2f 91       	pop	r18
    3ba6:	0f 90       	pop	r0
    3ba8:	0b be       	out	0x3b, r0	; 59
    3baa:	0f 90       	pop	r0
    3bac:	08 be       	out	0x38, r0	; 56
    3bae:	0f 90       	pop	r0
    3bb0:	0f be       	out	0x3f, r0	; 63
    3bb2:	0f 90       	pop	r0
    3bb4:	1f 90       	pop	r1
    3bb6:	18 95       	reti

00003bb8 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3bb8:	0f 93       	push	r16
    3bba:	cf 93       	push	r28
    3bbc:	df 93       	push	r29
    3bbe:	1f 92       	push	r1
    3bc0:	cd b7       	in	r28, 0x3d	; 61
    3bc2:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3bc4:	2f b7       	in	r18, 0x3f	; 63
    3bc6:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3bc8:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3bca:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3bcc:	fc 01       	movw	r30, r24
    3bce:	08 ed       	ldi	r16, 0xD8	; 216
    3bd0:	04 bf       	out	0x34, r16	; 52
    3bd2:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3bd4:	89 81       	ldd	r24, Y+1	; 0x01
    3bd6:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3bd8:	0f 90       	pop	r0
    3bda:	df 91       	pop	r29
    3bdc:	cf 91       	pop	r28
    3bde:	0f 91       	pop	r16
    3be0:	08 95       	ret

00003be2 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3be2:	0f 93       	push	r16
    3be4:	1f 93       	push	r17
    3be6:	cf 93       	push	r28
    3be8:	df 93       	push	r29
    3bea:	cd b7       	in	r28, 0x3d	; 61
    3bec:	de b7       	in	r29, 0x3e	; 62
    3bee:	6d 97       	sbiw	r28, 0x1d	; 29
    3bf0:	cd bf       	out	0x3d, r28	; 61
    3bf2:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3bf4:	e0 e6       	ldi	r30, 0x60	; 96
    3bf6:	f6 e0       	ldi	r31, 0x06	; 6
    3bf8:	80 e4       	ldi	r24, 0x40	; 64
    3bfa:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3bfc:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3bfe:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3c00:	e0 e5       	ldi	r30, 0x50	; 80
    3c02:	f0 e0       	ldi	r31, 0x00	; 0
    3c04:	80 81       	ld	r24, Z
    3c06:	82 60       	ori	r24, 0x02	; 2
    3c08:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3c0a:	81 81       	ldd	r24, Z+1	; 0x01
    3c0c:	81 ff       	sbrs	r24, 1
    3c0e:	fd cf       	rjmp	.-6      	; 0x3c0a <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3c10:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3c14:	68 7f       	andi	r22, 0xF8	; 248
    3c16:	61 60       	ori	r22, 0x01	; 1
    3c18:	80 e4       	ldi	r24, 0x40	; 64
    3c1a:	90 e0       	ldi	r25, 0x00	; 0
    3c1c:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3c20:	e0 e5       	ldi	r30, 0x50	; 80
    3c22:	f0 e0       	ldi	r31, 0x00	; 0
    3c24:	80 81       	ld	r24, Z
    3c26:	8e 7f       	andi	r24, 0xFE	; 254
    3c28:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3c2a:	9d ef       	ldi	r25, 0xFD	; 253
    3c2c:	88 ed       	ldi	r24, 0xD8	; 216
    3c2e:	08 b6       	in	r0, 0x38	; 56
    3c30:	18 be       	out	0x38, r1	; 56
    3c32:	84 bf       	out	0x34, r24	; 52
    3c34:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3c38:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3c3a:	40 eb       	ldi	r20, 0xB0	; 176
    3c3c:	58 e0       	ldi	r21, 0x08	; 8
    3c3e:	60 e0       	ldi	r22, 0x00	; 0
    3c40:	70 e0       	ldi	r23, 0x00	; 0
    3c42:	ce 01       	movw	r24, r28
    3c44:	01 96       	adiw	r24, 0x01	; 1
    3c46:	0e 94 86 1b 	call	0x370c	; 0x370c <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3c4a:	67 e0       	ldi	r22, 0x07	; 7
    3c4c:	ce 01       	movw	r24, r28
    3c4e:	01 96       	adiw	r24, 0x01	; 1
    3c50:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    3c54:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c56:	63 e8       	ldi	r22, 0x83	; 131
    3c58:	70 e2       	ldi	r23, 0x20	; 32
    3c5a:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN8emstream4putsEPKc>
    3c5e:	66 e0       	ldi	r22, 0x06	; 6
    3c60:	c8 01       	movw	r24, r16
    3c62:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
    3c66:	66 e0       	ldi	r22, 0x06	; 6
    3c68:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3c6c:	82 e1       	ldi	r24, 0x12	; 18
    3c6e:	90 e0       	ldi	r25, 0x00	; 0
    3c70:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_Znwj>
    3c74:	8e 01       	movw	r16, r28
    3c76:	0f 5f       	subi	r16, 0xFF	; 255
    3c78:	1f 4f       	sbci	r17, 0xFF	; 255
    3c7a:	24 e0       	ldi	r18, 0x04	; 4
    3c7c:	31 e0       	ldi	r19, 0x01	; 1
    3c7e:	40 e0       	ldi	r20, 0x00	; 0
    3c80:	62 ea       	ldi	r22, 0xA2	; 162
    3c82:	70 e2       	ldi	r23, 0x20	; 32
    3c84:	0e 94 94 06 	call	0xd28	; 0xd28 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new task_EncoderMotor ("EncMtr", task_priority(7), 260, &ser_dev);
    3c88:	82 e1       	ldi	r24, 0x12	; 18
    3c8a:	90 e0       	ldi	r25, 0x00	; 0
    3c8c:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_Znwj>
    3c90:	24 e0       	ldi	r18, 0x04	; 4
    3c92:	31 e0       	ldi	r19, 0x01	; 1
    3c94:	44 e0       	ldi	r20, 0x04	; 4
    3c96:	6a ea       	ldi	r22, 0xAA	; 170
    3c98:	70 e2       	ldi	r23, 0x20	; 32
    3c9a:	0e 94 ab 03 	call	0x756	; 0x756 <_ZN17task_EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new task_EncoderPendulum ("EncPen", task_priority(6), 260, &ser_dev);
    3c9e:	82 e1       	ldi	r24, 0x12	; 18
    3ca0:	90 e0       	ldi	r25, 0x00	; 0
    3ca2:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_Znwj>
    3ca6:	24 e0       	ldi	r18, 0x04	; 4
    3ca8:	31 e0       	ldi	r19, 0x01	; 1
    3caa:	44 e0       	ldi	r20, 0x04	; 4
    3cac:	61 eb       	ldi	r22, 0xB1	; 177
    3cae:	70 e2       	ldi	r23, 0x20	; 32
    3cb0:	0e 94 1b 04 	call	0x836	; 0x836 <_ZN20task_EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new task_LimitSwitches ("LimSwtch", task_priority(5), 260, &ser_dev);
    3cb4:	82 e1       	ldi	r24, 0x12	; 18
    3cb6:	90 e0       	ldi	r25, 0x00	; 0
    3cb8:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_Znwj>
    3cbc:	24 e0       	ldi	r18, 0x04	; 4
    3cbe:	31 e0       	ldi	r19, 0x01	; 1
    3cc0:	44 e0       	ldi	r20, 0x04	; 4
    3cc2:	68 eb       	ldi	r22, 0xB8	; 184
    3cc4:	70 e2       	ldi	r23, 0x20	; 32
    3cc6:	0e 94 80 04 	call	0x900	; 0x900 <_ZN18task_LimitSwitchesC1EPKchjP8emstream>

	// The Motor task receives actuator signal and outputs PWM to the motor
	new task_Motor ("Motor", task_priority(4), 260, &ser_dev);
    3cca:	8c e6       	ldi	r24, 0x6C	; 108
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_Znwj>
    3cd2:	24 e0       	ldi	r18, 0x04	; 4
    3cd4:	31 e0       	ldi	r19, 0x01	; 1
    3cd6:	44 e0       	ldi	r20, 0x04	; 4
    3cd8:	61 ec       	ldi	r22, 0xC1	; 193
    3cda:	70 e2       	ldi	r23, 0x20	; 32
    3cdc:	0e 94 5f 06 	call	0xcbe	; 0xcbe <_ZN10task_MotorC1EPKchjP8emstream>
	
	// The Velocity task handles the inner control loop
	new task_Velocity ("WLoopCtrl", task_priority(1), 260, &ser_dev);
    3ce0:	82 e1       	ldi	r24, 0x12	; 18
    3ce2:	90 e0       	ldi	r25, 0x00	; 0
    3ce4:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_Znwj>
    3ce8:	24 e0       	ldi	r18, 0x04	; 4
    3cea:	31 e0       	ldi	r19, 0x01	; 1
    3cec:	41 e0       	ldi	r20, 0x01	; 1
    3cee:	67 ec       	ldi	r22, 0xC7	; 199
    3cf0:	70 e2       	ldi	r23, 0x20	; 32
    3cf2:	0e 94 19 09 	call	0x1232	; 0x1232 <_ZN13task_VelocityC1EPKchjP8emstream>
	
	// The Position task handles the middle control loop wrapped around velocity
	new task_Position ("PosLoopCtrl", task_priority(2), 260, &ser_dev);
    3cf6:	82 e1       	ldi	r24, 0x12	; 18
    3cf8:	90 e0       	ldi	r25, 0x00	; 0
    3cfa:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_Znwj>
    3cfe:	24 e0       	ldi	r18, 0x04	; 4
    3d00:	31 e0       	ldi	r19, 0x01	; 1
    3d02:	42 e0       	ldi	r20, 0x02	; 2
    3d04:	61 ed       	ldi	r22, 0xD1	; 209
    3d06:	70 e2       	ldi	r23, 0x20	; 32
    3d08:	0e 94 84 06 	call	0xd08	; 0xd08 <_ZN13task_PositionC1EPKchjP8emstream>
	
	// The Angle task is the outer control loop. It takes in angle error and outputs a position command
	new task_Angle ("AngLoopCtrl", task_priority(3), 260, &ser_dev);
    3d0c:	82 e1       	ldi	r24, 0x12	; 18
    3d0e:	90 e0       	ldi	r25, 0x00	; 0
    3d10:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_Znwj>
    3d14:	24 e0       	ldi	r18, 0x04	; 4
    3d16:	31 e0       	ldi	r19, 0x01	; 1
    3d18:	43 e0       	ldi	r20, 0x03	; 3
    3d1a:	6d ed       	ldi	r22, 0xDD	; 221
    3d1c:	70 e2       	ldi	r23, 0x20	; 32
    3d1e:	0e 94 28 03 	call	0x650	; 0x650 <_ZN10task_AngleC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3d22:	87 e0       	ldi	r24, 0x07	; 7
    3d24:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3d28:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3d2a:	0e 94 0a 10 	call	0x2014	; 0x2014 <vTaskStartScheduler>
	
	
	return 0;
    3d2e:	80 e0       	ldi	r24, 0x00	; 0
    3d30:	90 e0       	ldi	r25, 0x00	; 0
    3d32:	6d 96       	adiw	r28, 0x1d	; 29
    3d34:	cd bf       	out	0x3d, r28	; 61
    3d36:	de bf       	out	0x3e, r29	; 62
    3d38:	df 91       	pop	r29
    3d3a:	cf 91       	pop	r28
    3d3c:	1f 91       	pop	r17
    3d3e:	0f 91       	pop	r16
    3d40:	08 95       	ret

00003d42 <_GLOBAL__sub_I_counter>:
    3d42:	0f 93       	push	r16
    3d44:	1f 93       	push	r17
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3d46:	0a e0       	ldi	r16, 0x0A	; 10
    3d48:	10 e0       	ldi	r17, 0x00	; 0
    3d4a:	20 e0       	ldi	r18, 0x00	; 0
    3d4c:	30 e0       	ldi	r19, 0x00	; 0
    3d4e:	40 e0       	ldi	r20, 0x00	; 0
    3d50:	50 e0       	ldi	r21, 0x00	; 0
    3d52:	60 e2       	ldi	r22, 0x20	; 32
    3d54:	70 e0       	ldi	r23, 0x00	; 0
    3d56:	8e e7       	ldi	r24, 0x7E	; 126
    3d58:	91 e3       	ldi	r25, 0x31	; 49
    3d5a:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3d5e:	1f 91       	pop	r17
    3d60:	0f 91       	pop	r16
    3d62:	08 95       	ret

00003d64 <__cmpsf2>:
    3d64:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <__fp_cmp>
    3d68:	08 f4       	brcc	.+2      	; 0x3d6c <__cmpsf2+0x8>
    3d6a:	81 e0       	ldi	r24, 0x01	; 1
    3d6c:	08 95       	ret

00003d6e <__floatunsisf>:
    3d6e:	e8 94       	clt
    3d70:	09 c0       	rjmp	.+18     	; 0x3d84 <__floatsisf+0x12>

00003d72 <__floatsisf>:
    3d72:	97 fb       	bst	r25, 7
    3d74:	3e f4       	brtc	.+14     	; 0x3d84 <__floatsisf+0x12>
    3d76:	90 95       	com	r25
    3d78:	80 95       	com	r24
    3d7a:	70 95       	com	r23
    3d7c:	61 95       	neg	r22
    3d7e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d80:	8f 4f       	sbci	r24, 0xFF	; 255
    3d82:	9f 4f       	sbci	r25, 0xFF	; 255
    3d84:	99 23       	and	r25, r25
    3d86:	a9 f0       	breq	.+42     	; 0x3db2 <__floatsisf+0x40>
    3d88:	f9 2f       	mov	r31, r25
    3d8a:	96 e9       	ldi	r25, 0x96	; 150
    3d8c:	bb 27       	eor	r27, r27
    3d8e:	93 95       	inc	r25
    3d90:	f6 95       	lsr	r31
    3d92:	87 95       	ror	r24
    3d94:	77 95       	ror	r23
    3d96:	67 95       	ror	r22
    3d98:	b7 95       	ror	r27
    3d9a:	f1 11       	cpse	r31, r1
    3d9c:	f8 cf       	rjmp	.-16     	; 0x3d8e <__floatsisf+0x1c>
    3d9e:	fa f4       	brpl	.+62     	; 0x3dde <__floatsisf+0x6c>
    3da0:	bb 0f       	add	r27, r27
    3da2:	11 f4       	brne	.+4      	; 0x3da8 <__floatsisf+0x36>
    3da4:	60 ff       	sbrs	r22, 0
    3da6:	1b c0       	rjmp	.+54     	; 0x3dde <__floatsisf+0x6c>
    3da8:	6f 5f       	subi	r22, 0xFF	; 255
    3daa:	7f 4f       	sbci	r23, 0xFF	; 255
    3dac:	8f 4f       	sbci	r24, 0xFF	; 255
    3dae:	9f 4f       	sbci	r25, 0xFF	; 255
    3db0:	16 c0       	rjmp	.+44     	; 0x3dde <__floatsisf+0x6c>
    3db2:	88 23       	and	r24, r24
    3db4:	11 f0       	breq	.+4      	; 0x3dba <__floatsisf+0x48>
    3db6:	96 e9       	ldi	r25, 0x96	; 150
    3db8:	11 c0       	rjmp	.+34     	; 0x3ddc <__floatsisf+0x6a>
    3dba:	77 23       	and	r23, r23
    3dbc:	21 f0       	breq	.+8      	; 0x3dc6 <__floatsisf+0x54>
    3dbe:	9e e8       	ldi	r25, 0x8E	; 142
    3dc0:	87 2f       	mov	r24, r23
    3dc2:	76 2f       	mov	r23, r22
    3dc4:	05 c0       	rjmp	.+10     	; 0x3dd0 <__floatsisf+0x5e>
    3dc6:	66 23       	and	r22, r22
    3dc8:	71 f0       	breq	.+28     	; 0x3de6 <__floatsisf+0x74>
    3dca:	96 e8       	ldi	r25, 0x86	; 134
    3dcc:	86 2f       	mov	r24, r22
    3dce:	70 e0       	ldi	r23, 0x00	; 0
    3dd0:	60 e0       	ldi	r22, 0x00	; 0
    3dd2:	2a f0       	brmi	.+10     	; 0x3dde <__floatsisf+0x6c>
    3dd4:	9a 95       	dec	r25
    3dd6:	66 0f       	add	r22, r22
    3dd8:	77 1f       	adc	r23, r23
    3dda:	88 1f       	adc	r24, r24
    3ddc:	da f7       	brpl	.-10     	; 0x3dd4 <__floatsisf+0x62>
    3dde:	88 0f       	add	r24, r24
    3de0:	96 95       	lsr	r25
    3de2:	87 95       	ror	r24
    3de4:	97 f9       	bld	r25, 7
    3de6:	08 95       	ret

00003de8 <__fp_cmp>:
    3de8:	99 0f       	add	r25, r25
    3dea:	00 08       	sbc	r0, r0
    3dec:	55 0f       	add	r21, r21
    3dee:	aa 0b       	sbc	r26, r26
    3df0:	e0 e8       	ldi	r30, 0x80	; 128
    3df2:	fe ef       	ldi	r31, 0xFE	; 254
    3df4:	16 16       	cp	r1, r22
    3df6:	17 06       	cpc	r1, r23
    3df8:	e8 07       	cpc	r30, r24
    3dfa:	f9 07       	cpc	r31, r25
    3dfc:	c0 f0       	brcs	.+48     	; 0x3e2e <__fp_cmp+0x46>
    3dfe:	12 16       	cp	r1, r18
    3e00:	13 06       	cpc	r1, r19
    3e02:	e4 07       	cpc	r30, r20
    3e04:	f5 07       	cpc	r31, r21
    3e06:	98 f0       	brcs	.+38     	; 0x3e2e <__fp_cmp+0x46>
    3e08:	62 1b       	sub	r22, r18
    3e0a:	73 0b       	sbc	r23, r19
    3e0c:	84 0b       	sbc	r24, r20
    3e0e:	95 0b       	sbc	r25, r21
    3e10:	39 f4       	brne	.+14     	; 0x3e20 <__fp_cmp+0x38>
    3e12:	0a 26       	eor	r0, r26
    3e14:	61 f0       	breq	.+24     	; 0x3e2e <__fp_cmp+0x46>
    3e16:	23 2b       	or	r18, r19
    3e18:	24 2b       	or	r18, r20
    3e1a:	25 2b       	or	r18, r21
    3e1c:	21 f4       	brne	.+8      	; 0x3e26 <__fp_cmp+0x3e>
    3e1e:	08 95       	ret
    3e20:	0a 26       	eor	r0, r26
    3e22:	09 f4       	brne	.+2      	; 0x3e26 <__fp_cmp+0x3e>
    3e24:	a1 40       	sbci	r26, 0x01	; 1
    3e26:	a6 95       	lsr	r26
    3e28:	8f ef       	ldi	r24, 0xFF	; 255
    3e2a:	81 1d       	adc	r24, r1
    3e2c:	81 1d       	adc	r24, r1
    3e2e:	08 95       	ret

00003e30 <__gesf2>:
    3e30:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <__fp_cmp>
    3e34:	08 f4       	brcc	.+2      	; 0x3e38 <__gesf2+0x8>
    3e36:	8f ef       	ldi	r24, 0xFF	; 255
    3e38:	08 95       	ret

00003e3a <__mulsi3>:
    3e3a:	db 01       	movw	r26, r22
    3e3c:	8f 93       	push	r24
    3e3e:	9f 93       	push	r25
    3e40:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <__muluhisi3>
    3e44:	bf 91       	pop	r27
    3e46:	af 91       	pop	r26
    3e48:	a2 9f       	mul	r26, r18
    3e4a:	80 0d       	add	r24, r0
    3e4c:	91 1d       	adc	r25, r1
    3e4e:	a3 9f       	mul	r26, r19
    3e50:	90 0d       	add	r25, r0
    3e52:	b2 9f       	mul	r27, r18
    3e54:	90 0d       	add	r25, r0
    3e56:	11 24       	eor	r1, r1
    3e58:	08 95       	ret

00003e5a <__divmodhi4>:
    3e5a:	97 fb       	bst	r25, 7
    3e5c:	07 2e       	mov	r0, r23
    3e5e:	16 f4       	brtc	.+4      	; 0x3e64 <__divmodhi4+0xa>
    3e60:	00 94       	com	r0
    3e62:	07 d0       	rcall	.+14     	; 0x3e72 <__divmodhi4_neg1>
    3e64:	77 fd       	sbrc	r23, 7
    3e66:	09 d0       	rcall	.+18     	; 0x3e7a <__divmodhi4_neg2>
    3e68:	0e 94 bc 1f 	call	0x3f78	; 0x3f78 <__udivmodhi4>
    3e6c:	07 fc       	sbrc	r0, 7
    3e6e:	05 d0       	rcall	.+10     	; 0x3e7a <__divmodhi4_neg2>
    3e70:	3e f4       	brtc	.+14     	; 0x3e80 <__divmodhi4_exit>

00003e72 <__divmodhi4_neg1>:
    3e72:	90 95       	com	r25
    3e74:	81 95       	neg	r24
    3e76:	9f 4f       	sbci	r25, 0xFF	; 255
    3e78:	08 95       	ret

00003e7a <__divmodhi4_neg2>:
    3e7a:	70 95       	com	r23
    3e7c:	61 95       	neg	r22
    3e7e:	7f 4f       	sbci	r23, 0xFF	; 255

00003e80 <__divmodhi4_exit>:
    3e80:	08 95       	ret

00003e82 <__udivmodsi4>:
    3e82:	a1 e2       	ldi	r26, 0x21	; 33
    3e84:	1a 2e       	mov	r1, r26
    3e86:	aa 1b       	sub	r26, r26
    3e88:	bb 1b       	sub	r27, r27
    3e8a:	fd 01       	movw	r30, r26
    3e8c:	0d c0       	rjmp	.+26     	; 0x3ea8 <__udivmodsi4_ep>

00003e8e <__udivmodsi4_loop>:
    3e8e:	aa 1f       	adc	r26, r26
    3e90:	bb 1f       	adc	r27, r27
    3e92:	ee 1f       	adc	r30, r30
    3e94:	ff 1f       	adc	r31, r31
    3e96:	a2 17       	cp	r26, r18
    3e98:	b3 07       	cpc	r27, r19
    3e9a:	e4 07       	cpc	r30, r20
    3e9c:	f5 07       	cpc	r31, r21
    3e9e:	20 f0       	brcs	.+8      	; 0x3ea8 <__udivmodsi4_ep>
    3ea0:	a2 1b       	sub	r26, r18
    3ea2:	b3 0b       	sbc	r27, r19
    3ea4:	e4 0b       	sbc	r30, r20
    3ea6:	f5 0b       	sbc	r31, r21

00003ea8 <__udivmodsi4_ep>:
    3ea8:	66 1f       	adc	r22, r22
    3eaa:	77 1f       	adc	r23, r23
    3eac:	88 1f       	adc	r24, r24
    3eae:	99 1f       	adc	r25, r25
    3eb0:	1a 94       	dec	r1
    3eb2:	69 f7       	brne	.-38     	; 0x3e8e <__udivmodsi4_loop>
    3eb4:	60 95       	com	r22
    3eb6:	70 95       	com	r23
    3eb8:	80 95       	com	r24
    3eba:	90 95       	com	r25
    3ebc:	9b 01       	movw	r18, r22
    3ebe:	ac 01       	movw	r20, r24
    3ec0:	bd 01       	movw	r22, r26
    3ec2:	cf 01       	movw	r24, r30
    3ec4:	08 95       	ret

00003ec6 <__divmodsi4>:
    3ec6:	05 2e       	mov	r0, r21
    3ec8:	97 fb       	bst	r25, 7
    3eca:	1e f4       	brtc	.+6      	; 0x3ed2 <__divmodsi4+0xc>
    3ecc:	00 94       	com	r0
    3ece:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <__negsi2>
    3ed2:	57 fd       	sbrc	r21, 7
    3ed4:	07 d0       	rcall	.+14     	; 0x3ee4 <__divmodsi4_neg2>
    3ed6:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <__udivmodsi4>
    3eda:	07 fc       	sbrc	r0, 7
    3edc:	03 d0       	rcall	.+6      	; 0x3ee4 <__divmodsi4_neg2>
    3ede:	4e f4       	brtc	.+18     	; 0x3ef2 <__divmodsi4_exit>
    3ee0:	0c 94 7a 1f 	jmp	0x3ef4	; 0x3ef4 <__negsi2>

00003ee4 <__divmodsi4_neg2>:
    3ee4:	50 95       	com	r21
    3ee6:	40 95       	com	r20
    3ee8:	30 95       	com	r19
    3eea:	21 95       	neg	r18
    3eec:	3f 4f       	sbci	r19, 0xFF	; 255
    3eee:	4f 4f       	sbci	r20, 0xFF	; 255
    3ef0:	5f 4f       	sbci	r21, 0xFF	; 255

00003ef2 <__divmodsi4_exit>:
    3ef2:	08 95       	ret

00003ef4 <__negsi2>:
    3ef4:	90 95       	com	r25
    3ef6:	80 95       	com	r24
    3ef8:	70 95       	com	r23
    3efa:	61 95       	neg	r22
    3efc:	7f 4f       	sbci	r23, 0xFF	; 255
    3efe:	8f 4f       	sbci	r24, 0xFF	; 255
    3f00:	9f 4f       	sbci	r25, 0xFF	; 255
    3f02:	08 95       	ret

00003f04 <__tablejump2__>:
    3f04:	ee 0f       	add	r30, r30
    3f06:	ff 1f       	adc	r31, r31
    3f08:	88 1f       	adc	r24, r24
    3f0a:	8b bf       	out	0x3b, r24	; 59
    3f0c:	07 90       	elpm	r0, Z+
    3f0e:	f6 91       	elpm	r31, Z
    3f10:	e0 2d       	mov	r30, r0
    3f12:	1b be       	out	0x3b, r1	; 59
    3f14:	19 94       	eijmp

00003f16 <__mulhisi3>:
    3f16:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__umulhisi3>
    3f1a:	33 23       	and	r19, r19
    3f1c:	12 f4       	brpl	.+4      	; 0x3f22 <__mulhisi3+0xc>
    3f1e:	8a 1b       	sub	r24, r26
    3f20:	9b 0b       	sbc	r25, r27
    3f22:	0c 94 a4 1f 	jmp	0x3f48	; 0x3f48 <__usmulhisi3_tail>

00003f26 <__umulhisi3>:
    3f26:	a2 9f       	mul	r26, r18
    3f28:	b0 01       	movw	r22, r0
    3f2a:	b3 9f       	mul	r27, r19
    3f2c:	c0 01       	movw	r24, r0
    3f2e:	a3 9f       	mul	r26, r19
    3f30:	70 0d       	add	r23, r0
    3f32:	81 1d       	adc	r24, r1
    3f34:	11 24       	eor	r1, r1
    3f36:	91 1d       	adc	r25, r1
    3f38:	b2 9f       	mul	r27, r18
    3f3a:	70 0d       	add	r23, r0
    3f3c:	81 1d       	adc	r24, r1
    3f3e:	11 24       	eor	r1, r1
    3f40:	91 1d       	adc	r25, r1
    3f42:	08 95       	ret

00003f44 <__usmulhisi3>:
    3f44:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__umulhisi3>

00003f48 <__usmulhisi3_tail>:
    3f48:	b7 ff       	sbrs	r27, 7
    3f4a:	08 95       	ret
    3f4c:	82 1b       	sub	r24, r18
    3f4e:	93 0b       	sbc	r25, r19
    3f50:	08 95       	ret

00003f52 <__muluhisi3>:
    3f52:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <__umulhisi3>
    3f56:	a5 9f       	mul	r26, r21
    3f58:	90 0d       	add	r25, r0
    3f5a:	b4 9f       	mul	r27, r20
    3f5c:	90 0d       	add	r25, r0
    3f5e:	a4 9f       	mul	r26, r20
    3f60:	80 0d       	add	r24, r0
    3f62:	91 1d       	adc	r25, r1
    3f64:	11 24       	eor	r1, r1
    3f66:	08 95       	ret

00003f68 <__mulshisi3>:
    3f68:	b7 ff       	sbrs	r27, 7
    3f6a:	0c 94 a9 1f 	jmp	0x3f52	; 0x3f52 <__muluhisi3>

00003f6e <__mulohisi3>:
    3f6e:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <__muluhisi3>
    3f72:	82 1b       	sub	r24, r18
    3f74:	93 0b       	sbc	r25, r19
    3f76:	08 95       	ret

00003f78 <__udivmodhi4>:
    3f78:	aa 1b       	sub	r26, r26
    3f7a:	bb 1b       	sub	r27, r27
    3f7c:	51 e1       	ldi	r21, 0x11	; 17
    3f7e:	07 c0       	rjmp	.+14     	; 0x3f8e <__udivmodhi4_ep>

00003f80 <__udivmodhi4_loop>:
    3f80:	aa 1f       	adc	r26, r26
    3f82:	bb 1f       	adc	r27, r27
    3f84:	a6 17       	cp	r26, r22
    3f86:	b7 07       	cpc	r27, r23
    3f88:	10 f0       	brcs	.+4      	; 0x3f8e <__udivmodhi4_ep>
    3f8a:	a6 1b       	sub	r26, r22
    3f8c:	b7 0b       	sbc	r27, r23

00003f8e <__udivmodhi4_ep>:
    3f8e:	88 1f       	adc	r24, r24
    3f90:	99 1f       	adc	r25, r25
    3f92:	5a 95       	dec	r21
    3f94:	a9 f7       	brne	.-22     	; 0x3f80 <__udivmodhi4_loop>
    3f96:	80 95       	com	r24
    3f98:	90 95       	com	r25
    3f9a:	bc 01       	movw	r22, r24
    3f9c:	cd 01       	movw	r24, r26
    3f9e:	08 95       	ret

00003fa0 <memcpy>:
    3fa0:	fb 01       	movw	r30, r22
    3fa2:	dc 01       	movw	r26, r24
    3fa4:	02 c0       	rjmp	.+4      	; 0x3faa <memcpy+0xa>
    3fa6:	01 90       	ld	r0, Z+
    3fa8:	0d 92       	st	X+, r0
    3faa:	41 50       	subi	r20, 0x01	; 1
    3fac:	50 40       	sbci	r21, 0x00	; 0
    3fae:	d8 f7       	brcc	.-10     	; 0x3fa6 <memcpy+0x6>
    3fb0:	08 95       	ret

00003fb2 <memset>:
    3fb2:	dc 01       	movw	r26, r24
    3fb4:	01 c0       	rjmp	.+2      	; 0x3fb8 <memset+0x6>
    3fb6:	6d 93       	st	X+, r22
    3fb8:	41 50       	subi	r20, 0x01	; 1
    3fba:	50 40       	sbci	r21, 0x00	; 0
    3fbc:	e0 f7       	brcc	.-8      	; 0x3fb6 <memset+0x4>
    3fbe:	08 95       	ret

00003fc0 <strncpy>:
    3fc0:	fb 01       	movw	r30, r22
    3fc2:	dc 01       	movw	r26, r24
    3fc4:	41 50       	subi	r20, 0x01	; 1
    3fc6:	50 40       	sbci	r21, 0x00	; 0
    3fc8:	48 f0       	brcs	.+18     	; 0x3fdc <strncpy+0x1c>
    3fca:	01 90       	ld	r0, Z+
    3fcc:	0d 92       	st	X+, r0
    3fce:	00 20       	and	r0, r0
    3fd0:	c9 f7       	brne	.-14     	; 0x3fc4 <strncpy+0x4>
    3fd2:	01 c0       	rjmp	.+2      	; 0x3fd6 <strncpy+0x16>
    3fd4:	1d 92       	st	X+, r1
    3fd6:	41 50       	subi	r20, 0x01	; 1
    3fd8:	50 40       	sbci	r21, 0x00	; 0
    3fda:	e0 f7       	brcc	.-8      	; 0x3fd4 <strncpy+0x14>
    3fdc:	08 95       	ret

00003fde <ultoa>:
    3fde:	25 32       	cpi	r18, 0x25	; 37
    3fe0:	31 05       	cpc	r19, r1
    3fe2:	20 f4       	brcc	.+8      	; 0x3fec <ultoa+0xe>
    3fe4:	22 30       	cpi	r18, 0x02	; 2
    3fe6:	10 f0       	brcs	.+4      	; 0x3fec <ultoa+0xe>
    3fe8:	0c 94 fa 1f 	jmp	0x3ff4	; 0x3ff4 <__ultoa_ncheck>
    3fec:	fa 01       	movw	r30, r20
    3fee:	10 82       	st	Z, r1
    3ff0:	ca 01       	movw	r24, r20
    3ff2:	08 95       	ret

00003ff4 <__ultoa_ncheck>:
    3ff4:	bb 27       	eor	r27, r27

00003ff6 <__ultoa_common>:
    3ff6:	fa 01       	movw	r30, r20
    3ff8:	a6 2f       	mov	r26, r22
    3ffa:	62 17       	cp	r22, r18
    3ffc:	71 05       	cpc	r23, r1
    3ffe:	81 05       	cpc	r24, r1
    4000:	91 05       	cpc	r25, r1
    4002:	33 0b       	sbc	r19, r19
    4004:	30 fb       	bst	r19, 0
    4006:	66 f0       	brts	.+24     	; 0x4020 <__stack+0x21>
    4008:	aa 27       	eor	r26, r26
    400a:	66 0f       	add	r22, r22
    400c:	77 1f       	adc	r23, r23
    400e:	88 1f       	adc	r24, r24
    4010:	99 1f       	adc	r25, r25
    4012:	aa 1f       	adc	r26, r26
    4014:	a2 17       	cp	r26, r18
    4016:	10 f0       	brcs	.+4      	; 0x401c <__stack+0x1d>
    4018:	a2 1b       	sub	r26, r18
    401a:	63 95       	inc	r22
    401c:	38 50       	subi	r19, 0x08	; 8
    401e:	a9 f7       	brne	.-22     	; 0x400a <__stack+0xb>
    4020:	a0 5d       	subi	r26, 0xD0	; 208
    4022:	aa 33       	cpi	r26, 0x3A	; 58
    4024:	08 f0       	brcs	.+2      	; 0x4028 <__stack+0x29>
    4026:	a9 5d       	subi	r26, 0xD9	; 217
    4028:	a1 93       	st	Z+, r26
    402a:	36 f7       	brtc	.-52     	; 0x3ff8 <__ultoa_common+0x2>
    402c:	b1 11       	cpse	r27, r1
    402e:	b1 93       	st	Z+, r27
    4030:	10 82       	st	Z, r1
    4032:	ca 01       	movw	r24, r20
    4034:	0c 94 41 20 	jmp	0x4082	; 0x4082 <strrev>

00004038 <utoa>:
    4038:	45 32       	cpi	r20, 0x25	; 37
    403a:	51 05       	cpc	r21, r1
    403c:	20 f4       	brcc	.+8      	; 0x4046 <utoa+0xe>
    403e:	42 30       	cpi	r20, 0x02	; 2
    4040:	10 f0       	brcs	.+4      	; 0x4046 <utoa+0xe>
    4042:	0c 94 27 20 	jmp	0x404e	; 0x404e <__utoa_ncheck>
    4046:	fb 01       	movw	r30, r22
    4048:	10 82       	st	Z, r1
    404a:	cb 01       	movw	r24, r22
    404c:	08 95       	ret

0000404e <__utoa_ncheck>:
    404e:	bb 27       	eor	r27, r27

00004050 <__utoa_common>:
    4050:	fb 01       	movw	r30, r22
    4052:	55 27       	eor	r21, r21
    4054:	aa 27       	eor	r26, r26
    4056:	88 0f       	add	r24, r24
    4058:	99 1f       	adc	r25, r25
    405a:	aa 1f       	adc	r26, r26
    405c:	a4 17       	cp	r26, r20
    405e:	10 f0       	brcs	.+4      	; 0x4064 <__utoa_common+0x14>
    4060:	a4 1b       	sub	r26, r20
    4062:	83 95       	inc	r24
    4064:	50 51       	subi	r21, 0x10	; 16
    4066:	b9 f7       	brne	.-18     	; 0x4056 <__utoa_common+0x6>
    4068:	a0 5d       	subi	r26, 0xD0	; 208
    406a:	aa 33       	cpi	r26, 0x3A	; 58
    406c:	08 f0       	brcs	.+2      	; 0x4070 <__utoa_common+0x20>
    406e:	a9 5d       	subi	r26, 0xD9	; 217
    4070:	a1 93       	st	Z+, r26
    4072:	00 97       	sbiw	r24, 0x00	; 0
    4074:	79 f7       	brne	.-34     	; 0x4054 <__utoa_common+0x4>
    4076:	b1 11       	cpse	r27, r1
    4078:	b1 93       	st	Z+, r27
    407a:	11 92       	st	Z+, r1
    407c:	cb 01       	movw	r24, r22
    407e:	0c 94 41 20 	jmp	0x4082	; 0x4082 <strrev>

00004082 <strrev>:
    4082:	dc 01       	movw	r26, r24
    4084:	fc 01       	movw	r30, r24
    4086:	67 2f       	mov	r22, r23
    4088:	71 91       	ld	r23, Z+
    408a:	77 23       	and	r23, r23
    408c:	e1 f7       	brne	.-8      	; 0x4086 <strrev+0x4>
    408e:	32 97       	sbiw	r30, 0x02	; 2
    4090:	04 c0       	rjmp	.+8      	; 0x409a <strrev+0x18>
    4092:	7c 91       	ld	r23, X
    4094:	6d 93       	st	X+, r22
    4096:	70 83       	st	Z, r23
    4098:	62 91       	ld	r22, -Z
    409a:	ae 17       	cp	r26, r30
    409c:	bf 07       	cpc	r27, r31
    409e:	c8 f3       	brcs	.-14     	; 0x4092 <strrev+0x10>
    40a0:	08 95       	ret

000040a2 <_exit>:
    40a2:	f8 94       	cli

000040a4 <__stop_program>:
    40a4:	ff cf       	rjmp	.-2      	; 0x40a4 <__stop_program>
