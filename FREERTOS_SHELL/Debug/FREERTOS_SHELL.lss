
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
<<<<<<< HEAD
  0 .text         00004020  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ac  00802000  00004020  000040b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a4  008020ac  008020ac  00004160  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004160  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004190  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c0  00000000  00000000  000041d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011181  00000000  00000000  00004890  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000634d  00000000  00000000  00015a11  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005193  00000000  00000000  0001bd5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001284  00000000  00000000  00020ef4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000610b  00000000  00000000  00022178  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005c68  00000000  00000000  00028283  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000578  00000000  00000000  0002deeb  2**0
=======
  0 .text         000041fa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e2  00802000  000041fa  0000428e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020e2  008020e2  00004370  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004370  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000043a0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000708  00000000  00000000  000043e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012825  00000000  00000000  00004ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006815  00000000  00000000  0001730d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005587  00000000  00000000  0001db22  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000131c  00000000  00000000  000230ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000061e7  00000000  00000000  000243c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006024  00000000  00000000  0002a5af  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005a0  00000000  00000000  000305d3  2**0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
<<<<<<< HEAD
       0:	0c 94 a7 02 	jmp	0x54e	; 0x54e <__ctors_end>
       4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      10:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      14:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      18:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      1c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      20:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      24:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      28:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      2c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      30:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      34:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      38:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      3c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      40:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      44:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      4c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      50:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      54:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      58:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      5c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      60:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      64:	0c 94 d9 1b 	jmp	0x37b2	; 0x37b2 <__vector_25>
      68:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      6c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      70:	0c 94 37 1c 	jmp	0x386e	; 0x386e <__vector_28>
      74:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      78:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      7c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      80:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      84:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      88:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      8c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      90:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      94:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      98:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      9c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c4:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <__vector_49>
      c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e8:	0c 94 51 1d 	jmp	0x3aa2	; 0x3aa2 <__vector_58>
      ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      fc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     100:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     104:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     108:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     10c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     110:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     114:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     118:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     11c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     120:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     124:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     128:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     12c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     130:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     134:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     138:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     13c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     140:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     144:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     148:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     14c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     150:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     154:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     158:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     15c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     160:	0c 94 95 1c 	jmp	0x392a	; 0x392a <__vector_88>
     164:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     168:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     16c:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__vector_91>
     170:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     174:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     178:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     17c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     180:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     184:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     188:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     18c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     190:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     194:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     198:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     19c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1fc:	9c 19       	sub	r25, r12
     1fe:	9f 19       	sub	r25, r15
     200:	a2 19       	sub	r26, r2
     202:	a5 19       	sub	r26, r5
     204:	a8 19       	sub	r26, r8
     206:	ab 19       	sub	r26, r11
     208:	ad 19       	sub	r26, r13
     20a:	be 19       	sub	r27, r14
     20c:	c6 19       	sub	r28, r6
     20e:	d0 19       	sub	r29, r0
     210:	ce 19       	sub	r28, r14

00000212 <__trampolines_start>:
     212:	0c 94 3d 1b 	jmp	0x367a	; 0x367a <_ZN5rs23214check_for_charEv>
     216:	0c 94 53 1e 	jmp	0x3ca6	; 0x3ca6 <_GLOBAL__sub_I_counter>
     21a:	0c 94 9c 19 	jmp	0x3338	; 0x3338 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21e:	0c 94 c7 16 	jmp	0x2d8e	; 0x2d8e <_ZN14frt_text_queue7getcharEv>
     222:	0c 94 47 19 	jmp	0x328e	; 0x328e <_ZN8emstream12clear_screenEv>
     226:	0c 94 41 19 	jmp	0x3282	; 0x3282 <_ZN8emstream7getcharEv>
     22a:	0c 94 a6 07 	jmp	0xf4c	; 0xf4c <_ZN9task_user3runEv>
     22e:	0c 94 9f 19 	jmp	0x333e	; 0x333e <_ZN8emstreamlsE15ser_manipulator+0x24>
     232:	0c 94 44 19 	jmp	0x3288	; 0x3288 <_ZN8emstream14check_for_charEv>
     236:	0c 94 46 19 	jmp	0x328c	; 0x328c <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 d0 19 	jmp	0x33a0	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
     23e:	0c 94 a8 19 	jmp	0x3350	; 0x3350 <_ZN8emstreamlsE15ser_manipulator+0x36>
     242:	0c 94 c7 03 	jmp	0x78e	; 0x78e <_ZN5Motor3runEv>
     246:	0c 94 f0 16 	jmp	0x2de0	; 0x2de0 <_ZN14frt_text_queue7putcharEc>
     24a:	0c 94 4e 0e 	jmp	0x1c9c	; 0x1c9c <prvIdleTask>
     24e:	0c 94 a8 18 	jmp	0x3150	; 0x3150 <__cxa_pure_virtual>
     252:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <_ZN13LimitSwitches3runEv>
     256:	0c 94 a4 02 	jmp	0x548	; 0x548 <_call_static_run_method>
     25a:	0c 94 e5 16 	jmp	0x2dca	; 0x2dca <_ZN14frt_text_queue14check_for_charEv>
     25e:	0c 94 ad 19 	jmp	0x335a	; 0x335a <_ZN8emstreamlsE15ser_manipulator+0x40>
     262:	0c 94 3f 19 	jmp	0x327e	; 0x327e <_ZN8emstream13ready_to_sendEv>
     266:	0c 94 ce 19 	jmp	0x339c	; 0x339c <_ZN8emstreamlsE15ser_manipulator+0x82>
     26a:	0c 94 c6 19 	jmp	0x338c	; 0x338c <_ZN8emstreamlsE15ser_manipulator+0x72>
     26e:	0c 94 7d 15 	jmp	0x2afa	; 0x2afa <_ZN8frt_task12print_statusER8emstream>
     272:	0c 94 a5 19 	jmp	0x334a	; 0x334a <_ZN8emstreamlsE15ser_manipulator+0x30>
     276:	0c 94 df 02 	jmp	0x5be	; 0x5be <_ZN12EncoderMotor3runEv>
     27a:	0c 94 f3 1a 	jmp	0x35e6	; 0x35e6 <_ZN5rs2327putcharEc>
     27e:	0c 94 ab 19 	jmp	0x3356	; 0x3356 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     282:	0c 94 be 19 	jmp	0x337c	; 0x337c <_ZN8emstreamlsE15ser_manipulator+0x62>
     286:	0c 94 50 1b 	jmp	0x36a0	; 0x36a0 <_ZN5rs23212clear_screenEv>
     28a:	0c 94 bf 05 	jmp	0xb7e	; 0xb7e <_ZN9PWMdriver3runEv>
     28e:	0c 94 a2 19 	jmp	0x3344	; 0x3344 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     292:	0c 94 17 1b 	jmp	0x362e	; 0x362e <_ZN5rs2327getcharEv>

00000296 <__trampolines_end>:
     296:	2c 20       	and	r2, r12
     298:	54 43       	sbci	r21, 0x34	; 52
     29a:	43 30       	cpi	r20, 0x03	; 3
     29c:	43 43       	sbci	r20, 0x33	; 51
     29e:	41 3d       	cpi	r20, 0xD1	; 209
=======
       0:	0c 94 a9 02 	jmp	0x552	; 0x552 <__ctors_end>
       4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      10:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      14:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      18:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      1c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      20:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      24:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      28:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      2c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      30:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      34:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      38:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      3c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      40:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      44:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      48:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      4c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      50:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      54:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      58:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      5c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      60:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      64:	0c 94 ac 1c 	jmp	0x3958	; 0x3958 <__vector_25>
      68:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      6c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      70:	0c 94 0a 1d 	jmp	0x3a14	; 0x3a14 <__vector_28>
      74:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      78:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      7c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      80:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      84:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      88:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      8c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      90:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      94:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      98:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      9c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c4:	0c 94 72 0c 	jmp	0x18e4	; 0x18e4 <__vector_49>
      c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e8:	0c 94 24 1e 	jmp	0x3c48	; 0x3c48 <__vector_58>
      ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      fc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     100:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     104:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     108:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     10c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     110:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     114:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     118:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     11c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     120:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     124:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     128:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     12c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     130:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     134:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     138:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     13c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     140:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     144:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     148:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     14c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     150:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     154:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     158:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     15c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     160:	0c 94 68 1d 	jmp	0x3ad0	; 0x3ad0 <__vector_88>
     164:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     168:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     16c:	0c 94 c6 1d 	jmp	0x3b8c	; 0x3b8c <__vector_91>
     170:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     174:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     178:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     17c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     180:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     184:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     188:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     18c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     190:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     194:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     198:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     19c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1fc:	44 1a       	sub	r4, r20
     1fe:	47 1a       	sub	r4, r23
     200:	4a 1a       	sub	r4, r26
     202:	4d 1a       	sub	r4, r29
     204:	50 1a       	sub	r5, r16
     206:	53 1a       	sub	r5, r19
     208:	55 1a       	sub	r5, r21
     20a:	66 1a       	sub	r6, r22
     20c:	6e 1a       	sub	r6, r30
     20e:	78 1a       	sub	r7, r24
     210:	76 1a       	sub	r7, r22

00000212 <__trampolines_start>:
     212:	0c 94 ea 1b 	jmp	0x37d4	; 0x37d4 <_ZN5rs2327getcharEv>
     216:	0c 94 53 1a 	jmp	0x34a6	; 0x34a6 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     21a:	0c 94 25 16 	jmp	0x2c4a	; 0x2c4a <_ZN8frt_task12print_statusER8emstream>
     21e:	0c 94 4a 1a 	jmp	0x3494	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     222:	0c 94 ee 19 	jmp	0x33dc	; 0x33dc <_ZN8emstream12transmit_nowEv>
     226:	0c 94 50 1a 	jmp	0x34a0	; 0x34a0 <_ZN8emstreamlsE15ser_manipulator+0x36>
     22a:	0c 94 e7 19 	jmp	0x33ce	; 0x33ce <_ZN8emstream13ready_to_sendEv>
     22e:	0c 94 e9 19 	jmp	0x33d2	; 0x33d2 <_ZN8emstream7getcharEv>
     232:	0c 94 ec 19 	jmp	0x33d8	; 0x33d8 <_ZN8emstream14check_for_charEv>
     236:	0c 94 44 1a 	jmp	0x3488	; 0x3488 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     23a:	0c 94 4e 08 	jmp	0x109c	; 0x109c <_ZN9task_user3runEv>
     23e:	0c 94 78 1a 	jmp	0x34f0	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
     242:	0c 94 8d 17 	jmp	0x2f1a	; 0x2f1a <_ZN14frt_text_queue14check_for_charEv>
     246:	0c 94 55 1a 	jmp	0x34aa	; 0x34aa <_ZN8emstreamlsE15ser_manipulator+0x40>
     24a:	0c 94 ef 19 	jmp	0x33de	; 0x33de <_ZN8emstream12clear_screenEv>
     24e:	0c 94 d4 03 	jmp	0x7a8	; 0x7a8 <_ZN13LimitSwitches3runEv>
     252:	0c 94 67 06 	jmp	0xcce	; 0xcce <_ZN9PWMdriver3runEv>
     256:	0c 94 4d 1a 	jmp	0x349a	; 0x349a <_ZN8emstreamlsE15ser_manipulator+0x30>
     25a:	0c 94 64 03 	jmp	0x6c8	; 0x6c8 <_ZN15EncoderPendulum3runEv>
     25e:	0c 94 6e 1a 	jmp	0x34dc	; 0x34dc <_ZN8emstreamlsE15ser_manipulator+0x72>
     262:	0c 94 66 1a 	jmp	0x34cc	; 0x34cc <_ZN8emstreamlsE15ser_manipulator+0x62>
     266:	0c 94 50 19 	jmp	0x32a0	; 0x32a0 <__cxa_pure_virtual>
     26a:	0c 94 a6 02 	jmp	0x54c	; 0x54c <_call_static_run_method>
     26e:	0c 94 6f 17 	jmp	0x2ede	; 0x2ede <_ZN14frt_text_queue7getcharEv>
     272:	0c 94 23 1c 	jmp	0x3846	; 0x3846 <_ZN5rs23212clear_screenEv>
     276:	0c 94 47 1a 	jmp	0x348e	; 0x348e <_ZN8emstreamlsE15ser_manipulator+0x24>
     27a:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_ZN12EncoderMotor3runEv>
     27e:	0c 94 f6 0e 	jmp	0x1dec	; 0x1dec <prvIdleTask>
     282:	0c 94 31 1f 	jmp	0x3e62	; 0x3e62 <_GLOBAL__sub_I_counter>
     286:	0c 94 39 04 	jmp	0x872	; 0x872 <_ZN5Motor3runEv>
     28a:	0c 94 10 1c 	jmp	0x3820	; 0x3820 <_ZN5rs23214check_for_charEv>
     28e:	0c 94 98 17 	jmp	0x2f30	; 0x2f30 <_ZN14frt_text_queue7putcharEc>
     292:	0c 94 76 1a 	jmp	0x34ec	; 0x34ec <_ZN8emstreamlsE15ser_manipulator+0x82>
     296:	0c 94 c6 1b 	jmp	0x378c	; 0x378c <_ZN5rs2327putcharEc>

0000029a <__trampolines_end>:
     29a:	2c 20       	and	r2, r12
     29c:	54 43       	sbci	r21, 0x34	; 52
     29e:	43 30       	cpi	r20, 0x03	; 3
     2a0:	43 43       	sbci	r20, 0x33	; 51
     2a2:	41 3d       	cpi	r20, 0xD1	; 209
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	...

000002a1 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a1:	2f 00                                               /.

000002a3 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b1 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b1:	54 69 6d 65 3a 20 00                                Time: .

<<<<<<< HEAD
000002b8 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b8:	44 65 63 20 20 36 20 32 30 31 37 00                 Dec  6 2017.
=======
000002bc <_ZZN9task_user11show_statusEvE3__c_0>:
     2bc:	44 65 63 20 20 35 20 32 30 31 37 00                 Dec  5 2017.
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

000002c4 <_ZZN9task_user11show_statusEvE3__c>:
     2c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     302:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000030d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     30d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     31d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34b:	6d 61 74 69 6f 6e 00                                mation.

00000352 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     352:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     362:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000373 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     373:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     383:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3a7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3b7:	68 65 20 41 56 52 00                                he AVR.

000003be <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3be:	20 68 65 6c 70 00                                    help.

000003c4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e3:	1b 5b 33 30 6d 00                                   .[30m.

000003e9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e9:	1b 5b 34 36 6d 00                                   .[46m.

000003ef <_ZZN9task_user3runEvE3__c_3>:
     3ef:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ff:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000040c <_ZZN9task_user3runEvE3__c_2>:
     40c:	3a 57 54 46 3f 00                                   :WTF?.

00000412 <_ZZN9task_user3runEvE3__c_1>:
     412:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     422:	65 00                                               e.

00000424 <_ZZN9task_user3runEvE3__c_0>:
     424:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000432 <_ZZN9task_user3runEvE3__c>:
     432:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     442:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000450 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     450:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045a <_ZZN8frt_task15emergency_resetEvE3__c>:
     45a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000469 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     469:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     479:	61 73 6b 20 00                                      ask .

0000047e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     47e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000048c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     48c:	20 63 72 65 61 74 65 64 00                           created.

00000495 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     495:	54 61 73 6b 20 00                                   Task .

0000049b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49b:	1b 5b 32 32 6d 00                                   .[22m.

000004a1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a1:	54 61 73 6b 3a 20 00                                Task: .

000004a8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a8:	1b 5b 31 6d 00                                      .[1m.

000004ad <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4ad:	1b 5b 32 32 6d 00                                   .[22m.

000004b3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004be <_ZZ17print_task_stacksP8emstreamE3__c>:
     4be:	1b 5b 31 6d 00                                      .[1m.

000004c3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c3:	09 09 00                                            ...

000004c6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4c6:	2f 00                                               /.

000004c8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d3:	09 2d 2d 2d 2d 00                                   .----.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004f6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4f6:	09 52 75 6e 73 00                                   .Runs.

000004fc <_ZZ15print_task_listP8emstreamE3__c_2>:
     4fc:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000508 <_ZZ15print_task_listP8emstreamE3__c_1>:
     508:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000519 <_ZZ15print_task_listP8emstreamE3__c_0>:
     519:	09 53 74 61 63 6b 00                                .Stack.

00000520 <_ZZ15print_task_listP8emstreamE3__c>:
     520:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52b:	09 00                                               ..

0000052d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     52d:	09 00                                               ..

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     52f:	2f 00                                               /.

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     533:	09 00                                               ..

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53b:	1b 5b 31 6d 00                                      .[1m.

00000540 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     545:	20 20 00                                              .

00000548 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
<<<<<<< HEAD
     548:	0e 94 15 14 	call	0x282a	; 0x282a <_ZN8frt_task22_call_users_run_methodEPS_>

0000054c <__ctors_start>:
     54c:	53 1e       	adc	r5, r19

0000054e <__ctors_end>:
     54e:	11 24       	eor	r1, r1
     550:	1f be       	out	0x3f, r1	; 63
     552:	cf ef       	ldi	r28, 0xFF	; 255
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df e3       	ldi	r29, 0x3F	; 63
     558:	de bf       	out	0x3e, r29	; 62
     55a:	00 e0       	ldi	r16, 0x00	; 0
     55c:	0c bf       	out	0x3c, r16	; 60
     55e:	18 be       	out	0x38, r1	; 56
     560:	19 be       	out	0x39, r1	; 57
     562:	1a be       	out	0x3a, r1	; 58
     564:	1b be       	out	0x3b, r1	; 59

00000566 <__do_copy_data>:
     566:	10 e2       	ldi	r17, 0x20	; 32
     568:	a0 e0       	ldi	r26, 0x00	; 0
     56a:	b0 e2       	ldi	r27, 0x20	; 32
     56c:	e0 e2       	ldi	r30, 0x20	; 32
     56e:	f0 e4       	ldi	r31, 0x40	; 64
     570:	00 e0       	ldi	r16, 0x00	; 0
     572:	0b bf       	out	0x3b, r16	; 59
     574:	02 c0       	rjmp	.+4      	; 0x57a <__do_copy_data+0x14>
     576:	07 90       	elpm	r0, Z+
     578:	0d 92       	st	X+, r0
     57a:	ac 3a       	cpi	r26, 0xAC	; 172
     57c:	b1 07       	cpc	r27, r17
     57e:	d9 f7       	brne	.-10     	; 0x576 <__do_copy_data+0x10>
     580:	1b be       	out	0x3b, r1	; 59

00000582 <__do_clear_bss>:
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	ac ea       	ldi	r26, 0xAC	; 172
     586:	b0 e2       	ldi	r27, 0x20	; 32
     588:	01 c0       	rjmp	.+2      	; 0x58c <.do_clear_bss_start>

0000058a <.do_clear_bss_loop>:
     58a:	1d 92       	st	X+, r1

0000058c <.do_clear_bss_start>:
     58c:	a0 35       	cpi	r26, 0x50	; 80
     58e:	b2 07       	cpc	r27, r18
     590:	e1 f7       	brne	.-8      	; 0x58a <.do_clear_bss_loop>

00000592 <__do_global_ctors>:
     592:	12 e0       	ldi	r17, 0x02	; 2
     594:	c7 ea       	ldi	r28, 0xA7	; 167
     596:	d2 e0       	ldi	r29, 0x02	; 2
     598:	00 e0       	ldi	r16, 0x00	; 0
     59a:	06 c0       	rjmp	.+12     	; 0x5a8 <__do_global_ctors+0x16>
     59c:	21 97       	sbiw	r28, 0x01	; 1
     59e:	01 09       	sbc	r16, r1
     5a0:	80 2f       	mov	r24, r16
     5a2:	fe 01       	movw	r30, r28
     5a4:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <__tablejump2__>
     5a8:	c6 3a       	cpi	r28, 0xA6	; 166
     5aa:	d1 07       	cpc	r29, r17
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 07       	cpc	r16, r24
     5b0:	a9 f7       	brne	.-22     	; 0x59c <__do_global_ctors+0xa>
     5b2:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <main>
     5b6:	0c 94 0e 20 	jmp	0x401c	; 0x401c <_exit>

000005ba <__bad_interrupt>:
     5ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005be <_ZN12EncoderMotor3runEv>:
=======
     54c:	0e 94 bd 14 	call	0x297a	; 0x297a <_ZN8frt_task22_call_users_run_methodEPS_>

00000550 <__ctors_start>:
     550:	31 1f       	adc	r19, r17

00000552 <__ctors_end>:
     552:	11 24       	eor	r1, r1
     554:	1f be       	out	0x3f, r1	; 63
     556:	cf ef       	ldi	r28, 0xFF	; 255
     558:	cd bf       	out	0x3d, r28	; 61
     55a:	df e3       	ldi	r29, 0x3F	; 63
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	00 e0       	ldi	r16, 0x00	; 0
     560:	0c bf       	out	0x3c, r16	; 60
     562:	18 be       	out	0x38, r1	; 56
     564:	19 be       	out	0x39, r1	; 57
     566:	1a be       	out	0x3a, r1	; 58
     568:	1b be       	out	0x3b, r1	; 59

0000056a <__do_copy_data>:
     56a:	10 e2       	ldi	r17, 0x20	; 32
     56c:	a0 e0       	ldi	r26, 0x00	; 0
     56e:	b0 e2       	ldi	r27, 0x20	; 32
     570:	ea ef       	ldi	r30, 0xFA	; 250
     572:	f1 e4       	ldi	r31, 0x41	; 65
     574:	00 e0       	ldi	r16, 0x00	; 0
     576:	0b bf       	out	0x3b, r16	; 59
     578:	02 c0       	rjmp	.+4      	; 0x57e <__do_copy_data+0x14>
     57a:	07 90       	elpm	r0, Z+
     57c:	0d 92       	st	X+, r0
     57e:	a2 3e       	cpi	r26, 0xE2	; 226
     580:	b1 07       	cpc	r27, r17
     582:	d9 f7       	brne	.-10     	; 0x57a <__do_copy_data+0x10>
     584:	1b be       	out	0x3b, r1	; 59

00000586 <__do_clear_bss>:
     586:	21 e3       	ldi	r18, 0x31	; 49
     588:	a2 ee       	ldi	r26, 0xE2	; 226
     58a:	b0 e2       	ldi	r27, 0x20	; 32
     58c:	01 c0       	rjmp	.+2      	; 0x590 <.do_clear_bss_start>

0000058e <.do_clear_bss_loop>:
     58e:	1d 92       	st	X+, r1

00000590 <.do_clear_bss_start>:
     590:	a8 38       	cpi	r26, 0x88	; 136
     592:	b2 07       	cpc	r27, r18
     594:	e1 f7       	brne	.-8      	; 0x58e <.do_clear_bss_loop>

00000596 <__do_global_ctors>:
     596:	12 e0       	ldi	r17, 0x02	; 2
     598:	c9 ea       	ldi	r28, 0xA9	; 169
     59a:	d2 e0       	ldi	r29, 0x02	; 2
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	06 c0       	rjmp	.+12     	; 0x5ac <__do_global_ctors+0x16>
     5a0:	21 97       	sbiw	r28, 0x01	; 1
     5a2:	01 09       	sbc	r16, r1
     5a4:	80 2f       	mov	r24, r16
     5a6:	fe 01       	movw	r30, r28
     5a8:	0e 94 12 20 	call	0x4024	; 0x4024 <__tablejump2__>
     5ac:	c8 3a       	cpi	r28, 0xA8	; 168
     5ae:	d1 07       	cpc	r29, r17
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	08 07       	cpc	r16, r24
     5b4:	a9 f7       	brne	.-22     	; 0x5a0 <__do_global_ctors+0xa>
     5b6:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <main>
     5ba:	0c 94 fb 20 	jmp	0x41f6	; 0x41f6 <_exit>

000005be <__bad_interrupt>:
     5be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c2 <_ZN12EncoderMotor3runEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN12EncoderMotor3runEv+0x6>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
<<<<<<< HEAD
     5cc:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <xTaskGetTickCount>
     5d0:	69 83       	std	Y+1, r22	; 0x01
     5d2:	7a 83       	std	Y+2, r23	; 0x02
     5d4:	8b 83       	std	Y+3, r24	; 0x03
     5d6:	9c 83       	std	Y+4, r25	; 0x04
=======
     5d0:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     5d4:	69 83       	std	Y+1, r22	; 0x01
     5d6:	7a 83       	std	Y+2, r23	; 0x02
     5d8:	8b 83       	std	Y+3, r24	; 0x03
     5da:	9c 83       	std	Y+4, r25	; 0x04
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5d8:	e0 e8       	ldi	r30, 0x80	; 128
     5da:	f6 e0       	ldi	r31, 0x06	; 6
     5dc:	8c e0       	ldi	r24, 0x0C	; 12
     5de:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e0:	82 89       	ldd	r24, Z+18	; 0x12
     5e2:	83 60       	ori	r24, 0x03	; 3
     5e4:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5e6:	83 89       	ldd	r24, Z+19	; 0x13
     5e8:	83 60       	ori	r24, 0x03	; 3
     5ea:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	82 e7       	ldi	r24, 0x72	; 114
     5f2:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f4:	89 e0       	ldi	r24, 0x09	; 9
     5f6:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f8:	e0 e0       	ldi	r30, 0x00	; 0
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	88 e6       	ldi	r24, 0x68	; 104
     5fe:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	86 a3       	std	Z+38, r24	; 0x26
     606:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
<<<<<<< HEAD
     60c:	0f 2e       	mov	r0, r31
     60e:	a1 2c       	mov	r10, r1
     610:	f9 e0       	ldi	r31, 0x09	; 9
     612:	bf 2e       	mov	r11, r31
     614:	f0 2d       	mov	r31, r0
     616:	f5 01       	movw	r30, r10
     618:	00 a1       	ldd	r16, Z+32	; 0x20
     61a:	11 a1       	ldd	r17, Z+33	; 0x21
=======
     610:	0f 2e       	mov	r0, r31
     612:	a1 2c       	mov	r10, r1
     614:	f9 e0       	ldi	r31, 0x09	; 9
     616:	bf 2e       	mov	r11, r31
     618:	f0 2d       	mov	r31, r0
     61a:	f5 01       	movw	r30, r10
     61c:	00 a1       	ldd	r16, Z+32	; 0x20
     61e:	11 a1       	ldd	r17, Z+33	; 0x21
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
<<<<<<< HEAD
     61c:	0f b6       	in	r0, 0x3f	; 63
     61e:	f8 94       	cli
     620:	0f 92       	push	r0
			the_data = new_data;
     622:	c8 01       	movw	r24, r16
     624:	01 2e       	mov	r0, r17
     626:	00 0c       	add	r0, r0
     628:	aa 0b       	sbc	r26, r26
     62a:	bb 0b       	sbc	r27, r27
     62c:	ac 01       	movw	r20, r24
     62e:	bd 01       	movw	r22, r26
     630:	44 0f       	add	r20, r20
     632:	55 1f       	adc	r21, r21
     634:	66 1f       	adc	r22, r22
     636:	77 1f       	adc	r23, r23
     638:	3a 01       	movw	r6, r20
     63a:	4b 01       	movw	r8, r22
     63c:	68 0e       	add	r6, r24
     63e:	79 1e       	adc	r7, r25
     640:	8a 1e       	adc	r8, r26
     642:	9b 1e       	adc	r9, r27
     644:	c4 01       	movw	r24, r8
     646:	b3 01       	movw	r22, r6
     648:	24 e6       	ldi	r18, 0x64	; 100
     64a:	30 e0       	ldi	r19, 0x00	; 0
     64c:	40 e0       	ldi	r20, 0x00	; 0
     64e:	50 e0       	ldi	r21, 0x00	; 0
     650:	0e 94 15 1f 	call	0x3e2a	; 0x3e2a <__divmodsi4>
     654:	20 93 3c 31 	sts	0x313C, r18	; 0x80313c <linear_position>
     658:	30 93 3d 31 	sts	0x313D, r19	; 0x80313d <linear_position+0x1>
			portEXIT_CRITICAL ();
     65c:	0f 90       	pop	r0
     65e:	0f be       	out	0x3f, r0	; 63
=======
     620:	0f b6       	in	r0, 0x3f	; 63
     622:	f8 94       	cli
     624:	0f 92       	push	r0
			the_data = new_data;
     626:	c8 01       	movw	r24, r16
     628:	01 2e       	mov	r0, r17
     62a:	00 0c       	add	r0, r0
     62c:	aa 0b       	sbc	r26, r26
     62e:	bb 0b       	sbc	r27, r27
     630:	ac 01       	movw	r20, r24
     632:	bd 01       	movw	r22, r26
     634:	44 0f       	add	r20, r20
     636:	55 1f       	adc	r21, r21
     638:	66 1f       	adc	r22, r22
     63a:	77 1f       	adc	r23, r23
     63c:	3a 01       	movw	r6, r20
     63e:	4b 01       	movw	r8, r22
     640:	68 0e       	add	r6, r24
     642:	79 1e       	adc	r7, r25
     644:	8a 1e       	adc	r8, r26
     646:	9b 1e       	adc	r9, r27
     648:	c4 01       	movw	r24, r8
     64a:	b3 01       	movw	r22, r6
     64c:	24 e6       	ldi	r18, 0x64	; 100
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	40 e0       	ldi	r20, 0x00	; 0
     652:	50 e0       	ldi	r21, 0x00	; 0
     654:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <__divmodsi4>
     658:	20 93 74 31 	sts	0x3174, r18	; 0x803174 <linear_position>
     65c:	30 93 75 31 	sts	0x3175, r19	; 0x803175 <linear_position+0x1>
			portEXIT_CRITICAL ();
     660:	0f 90       	pop	r0
     662:	0f be       	out	0x3f, r0	; 63
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
<<<<<<< HEAD
     660:	0f b6       	in	r0, 0x3f	; 63
     662:	f8 94       	cli
     664:	0f 92       	push	r0
			the_data = new_data;
     666:	c8 01       	movw	r24, r16
     668:	8c 19       	sub	r24, r12
     66a:	9d 09       	sbc	r25, r13
     66c:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <thdMotor>
     670:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <thdMotor+0x1>
			portEXIT_CRITICAL ();
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
=======
     664:	0f b6       	in	r0, 0x3f	; 63
     666:	f8 94       	cli
     668:	0f 92       	push	r0
			the_data = new_data;
     66a:	c8 01       	movw	r24, r16
     66c:	8c 19       	sub	r24, r12
     66e:	9d 09       	sbc	r25, r13
     670:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <thdMotor>
     674:	90 93 73 31 	sts	0x3173, r25	; 0x803173 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     678:	0f 90       	pop	r0
     67a:	0f be       	out	0x3f, r0	; 63
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
<<<<<<< HEAD
     678:	f7 01       	movw	r30, r14
     67a:	86 85       	ldd	r24, Z+14	; 0x0e
     67c:	97 85       	ldd	r25, Z+15	; 0x0f
     67e:	a0 89       	ldd	r26, Z+16	; 0x10
     680:	b1 89       	ldd	r27, Z+17	; 0x11
     682:	01 96       	adiw	r24, 0x01	; 1
     684:	a1 1d       	adc	r26, r1
     686:	b1 1d       	adc	r27, r1
     688:	86 87       	std	Z+14, r24	; 0x0e
     68a:	97 87       	std	Z+15, r25	; 0x0f
     68c:	a0 8b       	std	Z+16, r26	; 0x10
     68e:	b1 8b       	std	Z+17, r27	; 0x11
=======
     67c:	f7 01       	movw	r30, r14
     67e:	86 85       	ldd	r24, Z+14	; 0x0e
     680:	97 85       	ldd	r25, Z+15	; 0x0f
     682:	a0 89       	ldd	r26, Z+16	; 0x10
     684:	b1 89       	ldd	r27, Z+17	; 0x11
     686:	01 96       	adiw	r24, 0x01	; 1
     688:	a1 1d       	adc	r26, r1
     68a:	b1 1d       	adc	r27, r1
     68c:	86 87       	std	Z+14, r24	; 0x0e
     68e:	97 87       	std	Z+15, r25	; 0x0f
     690:	a0 8b       	std	Z+16, r26	; 0x10
     692:	b1 8b       	std	Z+17, r27	; 0x11
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
<<<<<<< HEAD
     690:	41 e0       	ldi	r20, 0x01	; 1
     692:	50 e0       	ldi	r21, 0x00	; 0
     694:	60 e0       	ldi	r22, 0x00	; 0
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	ce 01       	movw	r24, r28
     69a:	01 96       	adiw	r24, 0x01	; 1
     69c:	0e 94 8b 11 	call	0x2316	; 0x2316 <vTaskDelayUntil>
=======
     694:	41 e0       	ldi	r20, 0x01	; 1
     696:	50 e0       	ldi	r21, 0x00	; 0
     698:	60 e0       	ldi	r22, 0x00	; 0
     69a:	70 e0       	ldi	r23, 0x00	; 0
     69c:	ce 01       	movw	r24, r28
     69e:	01 96       	adiw	r24, 0x01	; 1
     6a0:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
<<<<<<< HEAD
     6a0:	68 01       	movw	r12, r16
     6a2:	b9 cf       	rjmp	.-142    	; 0x616 <_ZN12EncoderMotor3runEv+0x58>

000006a4 <_ZN12EncoderMotorC1EPKchjP8emstream>:
=======
     6a4:	68 01       	movw	r12, r16
     6a6:	b9 cf       	rjmp	.-142    	; 0x61a <_ZN12EncoderMotor3runEv+0x58>

000006a8 <_ZN12EncoderMotorC1EPKchjP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
<<<<<<< HEAD
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	cf 93       	push	r28
     6aa:	df 93       	push	r29
     6ac:	ec 01       	movw	r28, r24
=======
     6a8:	0f 93       	push	r16
     6aa:	1f 93       	push	r17
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
     6b0:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
<<<<<<< HEAD
     6ae:	0e 94 28 14 	call	0x2850	; 0x2850 <_ZN8frt_taskC1EPKchjP8emstream>
     6b2:	8a e0       	ldi	r24, 0x0A	; 10
     6b4:	90 e2       	ldi	r25, 0x20	; 32
     6b6:	88 83       	st	Y, r24
     6b8:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	08 95       	ret

000006c4 <_ZN13LimitSwitches3runEv>:
=======
     6b2:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     6b6:	8a e0       	ldi	r24, 0x0A	; 10
     6b8:	90 e2       	ldi	r25, 0x20	; 32
     6ba:	88 83       	st	Y, r24
     6bc:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	1f 91       	pop	r17
     6c4:	0f 91       	pop	r16
     6c6:	08 95       	ret

000006c8 <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	00 d0       	rcall	.+0      	; 0x6ce <_ZN15EncoderPendulum3runEv+0x6>
     6ce:	1f 92       	push	r1
     6d0:	cd b7       	in	r28, 0x3d	; 61
     6d2:	de b7       	in	r29, 0x3e	; 62
     6d4:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6d6:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     6da:	69 83       	std	Y+1, r22	; 0x01
     6dc:	7a 83       	std	Y+2, r23	; 0x02
     6de:	8b 83       	std	Y+3, r24	; 0x03
     6e0:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     6e2:	e0 e8       	ldi	r30, 0x80	; 128
     6e4:	f6 e0       	ldi	r31, 0x06	; 6
     6e6:	83 e0       	ldi	r24, 0x03	; 3
     6e8:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     6ea:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     6ec:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     6ee:	e0 e8       	ldi	r30, 0x80	; 128
     6f0:	f1 e0       	ldi	r31, 0x01	; 1
     6f2:	80 e7       	ldi	r24, 0x70	; 112
     6f4:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     6f6:	89 e0       	ldi	r24, 0x09	; 9
     6f8:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     6fa:	e0 e4       	ldi	r30, 0x40	; 64
     6fc:	f8 e0       	ldi	r31, 0x08	; 8
     6fe:	8a e6       	ldi	r24, 0x6A	; 106
     700:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     702:	80 ea       	ldi	r24, 0xA0	; 160
     704:	95 e0       	ldi	r25, 0x05	; 5
     706:	86 a3       	std	Z+38, r24	; 0x26
     708:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     70e:	68 94       	set
     710:	ee 24       	eor	r14, r14
     712:	e6 f8       	bld	r14, 6
     714:	ff 24       	eor	r15, r15
     716:	f3 f8       	bld	r15, 3
     718:	f7 01       	movw	r30, r14
     71a:	a0 a1       	ldd	r26, Z+32	; 0x20
     71c:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     71e:	0f b6       	in	r0, 0x3f	; 63
     720:	f8 94       	cli
     722:	0f 92       	push	r0
			the_data = new_data;
     724:	24 e6       	ldi	r18, 0x64	; 100
     726:	30 e0       	ldi	r19, 0x00	; 0
     728:	0e 94 32 20 	call	0x4064	; 0x4064 <__usmulhisi3>
     72c:	4b 01       	movw	r8, r22
     72e:	5c 01       	movw	r10, r24
     730:	99 23       	and	r25, r25
     732:	2c f4       	brge	.+10     	; 0x73e <_ZN15EncoderPendulum3runEv+0x76>
     734:	f3 e0       	ldi	r31, 0x03	; 3
     736:	8f 0e       	add	r8, r31
     738:	91 1c       	adc	r9, r1
     73a:	a1 1c       	adc	r10, r1
     73c:	b1 1c       	adc	r11, r1
     73e:	d5 01       	movw	r26, r10
     740:	c4 01       	movw	r24, r8
     742:	b5 95       	asr	r27
     744:	a7 95       	ror	r26
     746:	97 95       	ror	r25
     748:	87 95       	ror	r24
     74a:	b5 95       	asr	r27
     74c:	a7 95       	ror	r26
     74e:	97 95       	ror	r25
     750:	87 95       	ror	r24
     752:	80 93 70 31 	sts	0x3170, r24	; 0x803170 <thPendulum>
     756:	90 93 71 31 	sts	0x3171, r25	; 0x803171 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     75a:	0f 90       	pop	r0
     75c:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     75e:	f8 01       	movw	r30, r16
     760:	86 85       	ldd	r24, Z+14	; 0x0e
     762:	97 85       	ldd	r25, Z+15	; 0x0f
     764:	a0 89       	ldd	r26, Z+16	; 0x10
     766:	b1 89       	ldd	r27, Z+17	; 0x11
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	a1 1d       	adc	r26, r1
     76c:	b1 1d       	adc	r27, r1
     76e:	86 87       	std	Z+14, r24	; 0x0e
     770:	97 87       	std	Z+15, r25	; 0x0f
     772:	a0 8b       	std	Z+16, r26	; 0x10
     774:	b1 8b       	std	Z+17, r27	; 0x11
     776:	45 e0       	ldi	r20, 0x05	; 5
     778:	50 e0       	ldi	r21, 0x00	; 0
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	70 e0       	ldi	r23, 0x00	; 0
     77e:	ce 01       	movw	r24, r28
     780:	01 96       	adiw	r24, 0x01	; 1
     782:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
     786:	c8 cf       	rjmp	.-112    	; 0x718 <_ZN15EncoderPendulum3runEv+0x50>

00000788 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     788:	0f 93       	push	r16
     78a:	1f 93       	push	r17
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     792:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     796:	82 e1       	ldi	r24, 0x12	; 18
     798:	90 e2       	ldi	r25, 0x20	; 32
     79a:	88 83       	st	Y, r24
     79c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	1f 91       	pop	r17
     7a4:	0f 91       	pop	r16
     7a6:	08 95       	ret

000007a8 <_ZN13LimitSwitches3runEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
<<<<<<< HEAD
     6c4:	cf 93       	push	r28
     6c6:	df 93       	push	r29
     6c8:	00 d0       	rcall	.+0      	; 0x6ca <_ZN13LimitSwitches3runEv+0x6>
     6ca:	1f 92       	push	r1
     6cc:	cd b7       	in	r28, 0x3d	; 61
     6ce:	de b7       	in	r29, 0x3e	; 62
     6d0:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6d2:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <xTaskGetTickCount>
     6d6:	69 83       	std	Y+1, r22	; 0x01
     6d8:	7a 83       	std	Y+2, r23	; 0x02
     6da:	8b 83       	std	Y+3, r24	; 0x03
     6dc:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     6de:	e0 e6       	ldi	r30, 0x60	; 96
     6e0:	f6 e0       	ldi	r31, 0x06	; 6
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     6e6:	84 e0       	ldi	r24, 0x04	; 4
     6e8:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     6ea:	88 e1       	ldi	r24, 0x18	; 24
     6ec:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     6ee:	82 8b       	std	Z+18, r24	; 0x12
=======
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	00 d0       	rcall	.+0      	; 0x7ae <_ZN13LimitSwitches3runEv+0x6>
     7ae:	1f 92       	push	r1
     7b0:	cd b7       	in	r28, 0x3d	; 61
     7b2:	de b7       	in	r29, 0x3e	; 62
     7b4:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7b6:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     7ba:	69 83       	std	Y+1, r22	; 0x01
     7bc:	7a 83       	std	Y+2, r23	; 0x02
     7be:	8b 83       	std	Y+3, r24	; 0x03
     7c0:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     7c2:	e0 e6       	ldi	r30, 0x60	; 96
     7c4:	f6 e0       	ldi	r31, 0x06	; 6
     7c6:	81 e0       	ldi	r24, 0x01	; 1
     7c8:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     7ca:	84 e0       	ldi	r24, 0x04	; 4
     7cc:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     7ce:	88 e1       	ldi	r24, 0x18	; 24
     7d0:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     7d2:	82 8b       	std	Z+18, r24	; 0x12
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
<<<<<<< HEAD
     6f0:	08 e6       	ldi	r16, 0x68	; 104
     6f2:	16 e0       	ldi	r17, 0x06	; 6
=======
     7d4:	08 e6       	ldi	r16, 0x68	; 104
     7d6:	16 e0       	ldi	r17, 0x06	; 6
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
<<<<<<< HEAD
     6f4:	dd 24       	eor	r13, r13
     6f6:	d3 94       	inc	r13
     6f8:	f8 01       	movw	r30, r16
     6fa:	80 81       	ld	r24, Z
     6fc:	80 fd       	sbrc	r24, 0
     6fe:	08 c0       	rjmp	.+16     	; 0x710 <_ZN13LimitSwitches3runEv+0x4c>
=======
     7d8:	dd 24       	eor	r13, r13
     7da:	d3 94       	inc	r13
     7dc:	f8 01       	movw	r30, r16
     7de:	80 81       	ld	r24, Z
     7e0:	80 fd       	sbrc	r24, 0
     7e2:	08 c0       	rjmp	.+16     	; 0x7f4 <_ZN13LimitSwitches3runEv+0x4c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
<<<<<<< HEAD
     700:	0f b6       	in	r0, 0x3f	; 63
     702:	f8 94       	cli
     704:	0f 92       	push	r0
			the_data = new_data;
     706:	d0 92 39 31 	sts	0x3139, r13	; 0x803139 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     70a:	0f 90       	pop	r0
     70c:	0f be       	out	0x3f, r0	; 63
     70e:	07 c0       	rjmp	.+14     	; 0x71e <_ZN13LimitSwitches3runEv+0x5a>
=======
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	f8 94       	cli
     7e8:	0f 92       	push	r0
			the_data = new_data;
     7ea:	d0 92 6f 31 	sts	0x316F, r13	; 0x80316f <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7ee:	0f 90       	pop	r0
     7f0:	0f be       	out	0x3f, r0	; 63
     7f2:	07 c0       	rjmp	.+14     	; 0x802 <_ZN13LimitSwitches3runEv+0x5a>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
<<<<<<< HEAD
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	0f 92       	push	r0
			the_data = new_data;
     716:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     71a:	0f 90       	pop	r0
     71c:	0f be       	out	0x3f, r0	; 63
=======
     7f4:	0f b6       	in	r0, 0x3f	; 63
     7f6:	f8 94       	cli
     7f8:	0f 92       	push	r0
			the_data = new_data;
     7fa:	10 92 6f 31 	sts	0x316F, r1	; 0x80316f <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			*/

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
<<<<<<< HEAD
     71e:	f8 01       	movw	r30, r16
     720:	80 81       	ld	r24, Z
     722:	82 fd       	sbrc	r24, 2
     724:	08 c0       	rjmp	.+16     	; 0x736 <_ZN13LimitSwitches3runEv+0x72>
=======
     802:	f8 01       	movw	r30, r16
     804:	80 81       	ld	r24, Z
     806:	82 fd       	sbrc	r24, 2
     808:	08 c0       	rjmp	.+16     	; 0x81a <_ZN13LimitSwitches3runEv+0x72>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
<<<<<<< HEAD
     726:	0f b6       	in	r0, 0x3f	; 63
     728:	f8 94       	cli
     72a:	0f 92       	push	r0
			the_data = new_data;
     72c:	d0 92 38 31 	sts	0x3138, r13	; 0x803138 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     730:	0f 90       	pop	r0
     732:	0f be       	out	0x3f, r0	; 63
     734:	07 c0       	rjmp	.+14     	; 0x744 <_ZN13LimitSwitches3runEv+0x80>
=======
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	0f 92       	push	r0
			the_data = new_data;
     810:	d0 92 6e 31 	sts	0x316E, r13	; 0x80316e <rightLimitSwitch>
			portEXIT_CRITICAL ();
     814:	0f 90       	pop	r0
     816:	0f be       	out	0x3f, r0	; 63
     818:	07 c0       	rjmp	.+14     	; 0x828 <_ZN13LimitSwitches3runEv+0x80>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
<<<<<<< HEAD
     736:	0f b6       	in	r0, 0x3f	; 63
     738:	f8 94       	cli
     73a:	0f 92       	push	r0
			the_data = new_data;
     73c:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     740:	0f 90       	pop	r0
     742:	0f be       	out	0x3f, r0	; 63
=======
     81a:	0f b6       	in	r0, 0x3f	; 63
     81c:	f8 94       	cli
     81e:	0f 92       	push	r0
			the_data = new_data;
     820:	10 92 6e 31 	sts	0x316E, r1	; 0x80316e <rightLimitSwitch>
			portEXIT_CRITICAL ();
     824:	0f 90       	pop	r0
     826:	0f be       	out	0x3f, r0	; 63
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			}
			*/

		
		// Increment counter for debugging
		runs++;
<<<<<<< HEAD
     744:	f7 01       	movw	r30, r14
     746:	86 85       	ldd	r24, Z+14	; 0x0e
     748:	97 85       	ldd	r25, Z+15	; 0x0f
     74a:	a0 89       	ldd	r26, Z+16	; 0x10
     74c:	b1 89       	ldd	r27, Z+17	; 0x11
     74e:	01 96       	adiw	r24, 0x01	; 1
     750:	a1 1d       	adc	r26, r1
     752:	b1 1d       	adc	r27, r1
     754:	86 87       	std	Z+14, r24	; 0x0e
     756:	97 87       	std	Z+15, r25	; 0x0f
     758:	a0 8b       	std	Z+16, r26	; 0x10
     75a:	b1 8b       	std	Z+17, r27	; 0x11
     75c:	45 e0       	ldi	r20, 0x05	; 5
     75e:	50 e0       	ldi	r21, 0x00	; 0
     760:	60 e0       	ldi	r22, 0x00	; 0
     762:	70 e0       	ldi	r23, 0x00	; 0
     764:	ce 01       	movw	r24, r28
     766:	01 96       	adiw	r24, 0x01	; 1
     768:	0e 94 8b 11 	call	0x2316	; 0x2316 <vTaskDelayUntil>
     76c:	c5 cf       	rjmp	.-118    	; 0x6f8 <_ZN13LimitSwitches3runEv+0x34>

0000076e <_ZN13LimitSwitchesC1EPKchjP8emstream>:
=======
     828:	f7 01       	movw	r30, r14
     82a:	86 85       	ldd	r24, Z+14	; 0x0e
     82c:	97 85       	ldd	r25, Z+15	; 0x0f
     82e:	a0 89       	ldd	r26, Z+16	; 0x10
     830:	b1 89       	ldd	r27, Z+17	; 0x11
     832:	01 96       	adiw	r24, 0x01	; 1
     834:	a1 1d       	adc	r26, r1
     836:	b1 1d       	adc	r27, r1
     838:	86 87       	std	Z+14, r24	; 0x0e
     83a:	97 87       	std	Z+15, r25	; 0x0f
     83c:	a0 8b       	std	Z+16, r26	; 0x10
     83e:	b1 8b       	std	Z+17, r27	; 0x11
     840:	45 e0       	ldi	r20, 0x05	; 5
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	70 e0       	ldi	r23, 0x00	; 0
     848:	ce 01       	movw	r24, r28
     84a:	01 96       	adiw	r24, 0x01	; 1
     84c:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
     850:	c5 cf       	rjmp	.-118    	; 0x7dc <_ZN13LimitSwitches3runEv+0x34>

00000852 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
<<<<<<< HEAD
     76e:	0f 93       	push	r16
     770:	1f 93       	push	r17
     772:	cf 93       	push	r28
     774:	df 93       	push	r29
     776:	ec 01       	movw	r28, r24
=======
     852:	0f 93       	push	r16
     854:	1f 93       	push	r17
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
<<<<<<< HEAD
     778:	0e 94 28 14 	call	0x2850	; 0x2850 <_ZN8frt_taskC1EPKchjP8emstream>
     77c:	82 e1       	ldi	r24, 0x12	; 18
     77e:	90 e2       	ldi	r25, 0x20	; 32
     780:	88 83       	st	Y, r24
     782:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     784:	df 91       	pop	r29
     786:	cf 91       	pop	r28
     788:	1f 91       	pop	r17
     78a:	0f 91       	pop	r16
     78c:	08 95       	ret

0000078e <_ZN5Motor3runEv>:
=======
     85c:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     860:	8a e1       	ldi	r24, 0x1A	; 26
     862:	90 e2       	ldi	r25, 0x20	; 32
     864:	88 83       	st	Y, r24
     866:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	1f 91       	pop	r17
     86e:	0f 91       	pop	r16
     870:	08 95       	ret

00000872 <_ZN5Motor3runEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
<<<<<<< HEAD
     78e:	cf 93       	push	r28
     790:	df 93       	push	r29
     792:	cd b7       	in	r28, 0x3d	; 61
     794:	de b7       	in	r29, 0x3e	; 62
     796:	66 97       	sbiw	r28, 0x16	; 22
     798:	cd bf       	out	0x3d, r28	; 61
     79a:	de bf       	out	0x3e, r29	; 62
     79c:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     79e:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <xTaskGetTickCount>
     7a2:	69 83       	std	Y+1, r22	; 0x01
     7a4:	7a 83       	std	Y+2, r23	; 0x02
     7a6:	8b 83       	std	Y+3, r24	; 0x03
     7a8:	9c 83       	std	Y+4, r25	; 0x04

	dt = 5; // [ms]
     7aa:	f8 01       	movw	r30, r16
     7ac:	fe 96       	adiw	r30, 0x3e	; 62
     7ae:	85 e0       	ldi	r24, 0x05	; 5
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	a0 e0       	ldi	r26, 0x00	; 0
     7b4:	b0 e0       	ldi	r27, 0x00	; 0
     7b6:	80 83       	st	Z, r24
     7b8:	91 83       	std	Z+1, r25	; 0x01
     7ba:	a2 83       	std	Z+2, r26	; 0x02
     7bc:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     7be:	81 e0       	ldi	r24, 0x01	; 1
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	f8 01       	movw	r30, r16
     7c4:	84 af       	std	Z+60, r24	; 0x3c
     7c6:	95 af       	std	Z+61, r25	; 0x3d
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 21; //8
     7c8:	98 01       	movw	r18, r16
     7ca:	28 5b       	subi	r18, 0xB8	; 184
     7cc:	3f 4f       	sbci	r19, 0xFF	; 255
     7ce:	2d 83       	std	Y+5, r18	; 0x05
     7d0:	3e 83       	std	Y+6, r19	; 0x06
     7d2:	35 e1       	ldi	r19, 0x15	; 21
     7d4:	3d 8b       	std	Y+21, r19	; 0x15
     7d6:	1e 8a       	std	Y+22, r1	; 0x16
		_Ki = .55*256; //8
     7d8:	a8 01       	movw	r20, r16
     7da:	44 5b       	subi	r20, 0xB4	; 180
     7dc:	5f 4f       	sbci	r21, 0xFF	; 255
     7de:	4f 83       	std	Y+7, r20	; 0x07
     7e0:	58 87       	std	Y+8, r21	; 0x08
		_Kd = 0;
     7e2:	c8 01       	movw	r24, r16
     7e4:	86 5b       	subi	r24, 0xB6	; 182
     7e6:	9f 4f       	sbci	r25, 0xFF	; 255
     7e8:	8f 87       	std	Y+15, r24	; 0x0f
     7ea:	98 8b       	std	Y+16, r25	; 0x10
		antiwind_gain = 0.5*256; //7
     7ec:	ec 59       	subi	r30, 0x9C	; 156
     7ee:	ff 4f       	sbci	r31, 0xFF	; 255
     7f0:	e9 87       	std	Y+9, r30	; 0x09
     7f2:	fa 87       	std	Y+10, r31	; 0x0a
		
		_max = 1600;
     7f4:	98 01       	movw	r18, r16
     7f6:	2c 5b       	subi	r18, 0xBC	; 188
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	2b 87       	std	Y+11, r18	; 0x0b
     7fc:	3c 87       	std	Y+12, r19	; 0x0c
		_min = -1600;
     7fe:	46 50       	subi	r20, 0x06	; 6
     800:	51 09       	sbc	r21, r1
     802:	4d 87       	std	Y+13, r20	; 0x0d
     804:	5e 87       	std	Y+14, r21	; 0x0e
=======
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	cd b7       	in	r28, 0x3d	; 61
     878:	de b7       	in	r29, 0x3e	; 62
     87a:	6c 97       	sbiw	r28, 0x1c	; 28
     87c:	cd bf       	out	0x3d, r28	; 61
     87e:	de bf       	out	0x3e, r29	; 62
     880:	1c 01       	movw	r2, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     882:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     886:	69 83       	std	Y+1, r22	; 0x01
     888:	7a 83       	std	Y+2, r23	; 0x02
     88a:	8b 83       	std	Y+3, r24	; 0x03
     88c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 5; // [ms]
     88e:	f1 01       	movw	r30, r2
     890:	fe 96       	adiw	r30, 0x3e	; 62
     892:	85 e0       	ldi	r24, 0x05	; 5
     894:	90 e0       	ldi	r25, 0x00	; 0
     896:	a0 e0       	ldi	r26, 0x00	; 0
     898:	b0 e0       	ldi	r27, 0x00	; 0
     89a:	80 83       	st	Z, r24
     89c:	91 83       	std	Z+1, r25	; 0x01
     89e:	a2 83       	std	Z+2, r26	; 0x02
     8a0:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     8a2:	81 e0       	ldi	r24, 0x01	; 1
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	d1 01       	movw	r26, r2
     8a8:	dc 96       	adiw	r26, 0x3c	; 60
     8aa:	8d 93       	st	X+, r24
     8ac:	9c 93       	st	X, r25
     8ae:	dd 97       	sbiw	r26, 0x3d	; 61
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
		omegam_set = 200; // [ticks/ms]
     8b0:	0f 2e       	mov	r0, r31
     8b2:	f8 ec       	ldi	r31, 0xC8	; 200
     8b4:	cf 2e       	mov	r12, r31
     8b6:	d1 2c       	mov	r13, r1
     8b8:	f0 2d       	mov	r31, r0
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     8ba:	71 01       	movw	r14, r2
     8bc:	b0 e5       	ldi	r27, 0x50	; 80
     8be:	eb 0e       	add	r14, r27
     8c0:	f1 1c       	adc	r15, r1
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 22;
     8c2:	3a 96       	adiw	r30, 0x0a	; 10
     8c4:	ed 83       	std	Y+5, r30	; 0x05
     8c6:	fe 83       	std	Y+6, r31	; 0x06
     8c8:	f6 e1       	ldi	r31, 0x16	; 22
     8ca:	ff 8b       	std	Y+23, r31	; 0x17
     8cc:	18 8e       	std	Y+24, r1	; 0x18
		_Ki = 0.5*256;
     8ce:	91 01       	movw	r18, r2
     8d0:	24 5b       	subi	r18, 0xB4	; 180
     8d2:	3f 4f       	sbci	r19, 0xFF	; 255
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	38 87       	std	Y+8, r19	; 0x08
		_Kd = 0;
     8d8:	c1 01       	movw	r24, r2
     8da:	86 5b       	subi	r24, 0xB6	; 182
     8dc:	9f 4f       	sbci	r25, 0xFF	; 255
     8de:	8b 8b       	std	Y+19, r24	; 0x13
     8e0:	9c 8b       	std	Y+20, r25	; 0x14
		_max = 1600;
     8e2:	d1 01       	movw	r26, r2
     8e4:	ac 5b       	subi	r26, 0xBC	; 188
     8e6:	bf 4f       	sbci	r27, 0xFF	; 255
     8e8:	a9 87       	std	Y+9, r26	; 0x09
     8ea:	ba 87       	std	Y+10, r27	; 0x0a
		_min = -1600;
     8ec:	f1 01       	movw	r30, r2
     8ee:	ea 5b       	subi	r30, 0xBA	; 186
     8f0:	ff 4f       	sbci	r31, 0xFF	; 255
     8f2:	ed 87       	std	Y+13, r30	; 0x0d
     8f4:	fe 87       	std	Y+14, r31	; 0x0e
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
<<<<<<< HEAD
     806:	42 96       	adiw	r24, 0x12	; 18
     808:	89 8b       	std	Y+17, r24	; 0x11
     80a:	9a 8b       	std	Y+18, r25	; 0x12

		// Integral term
		error_int = error - antiwind_correct;
     80c:	18 01       	movw	r2, r16
     80e:	96 e6       	ldi	r25, 0x66	; 102
     810:	29 0e       	add	r2, r25
     812:	31 1c       	adc	r3, r1
     814:	34 96       	adiw	r30, 0x04	; 4
     816:	eb 8b       	std	Y+19, r30	; 0x13
     818:	fc 8b       	std	Y+20, r31	; 0x14
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     81a:	48 01       	movw	r8, r16
     81c:	fe e3       	ldi	r31, 0x3E	; 62
     81e:	8f 0e       	add	r8, r31
     820:	91 1c       	adc	r9, r1
     822:	58 01       	movw	r10, r16
     824:	20 e5       	ldi	r18, 0x50	; 80
     826:	a2 0e       	add	r10, r18
     828:	b1 1c       	adc	r11, r1

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);

		output_correct = output;
     82a:	68 01       	movw	r12, r16
     82c:	3e e5       	ldi	r19, 0x5E	; 94
     82e:	c3 0e       	add	r12, r19
     830:	d1 1c       	adc	r13, r1
=======
     8f6:	20 5f       	subi	r18, 0xF0	; 240
     8f8:	3f 4f       	sbci	r19, 0xFF	; 255
     8fa:	2f 87       	std	Y+15, r18	; 0x0f
     8fc:	38 8b       	std	Y+16, r19	; 0x10

		// Integral term
		_integral += error * dt;
     8fe:	0c 97       	sbiw	r24, 0x0c	; 12
     900:	8b 87       	std	Y+11, r24	; 0x0b
     902:	9c 87       	std	Y+12, r25	; 0x0c
		_integral = arbitraryNumber;
		else if( _integral < arbitraryNumber )
		_integral = arbitraryNumber;
		*/
		
		Iout = (_Ki * _integral)/256;
     904:	54 96       	adiw	r26, 0x14	; 20
     906:	a9 8b       	std	Y+17, r26	; 0x11
     908:	ba 8b       	std	Y+18, r27	; 0x12
		output = _max;
		else if( output < _min )
		output = _min;

		// Save error to previous error
		_pre_error = error;
     90a:	38 96       	adiw	r30, 0x08	; 8
     90c:	ed 8b       	std	Y+21, r30	; 0x15
     90e:	fe 8b       	std	Y+22, r31	; 0x16
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	dt = 5; // [ms]
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
<<<<<<< HEAD
     832:	f8 01       	movw	r30, r16
     834:	86 85       	ldd	r24, Z+14	; 0x0e
     836:	97 85       	ldd	r25, Z+15	; 0x0f
     838:	a0 89       	ldd	r26, Z+16	; 0x10
     83a:	b1 89       	ldd	r27, Z+17	; 0x11
     83c:	01 96       	adiw	r24, 0x01	; 1
     83e:	a1 1d       	adc	r26, r1
     840:	b1 1d       	adc	r27, r1
     842:	86 87       	std	Z+14, r24	; 0x0e
     844:	97 87       	std	Z+15, r25	; 0x0f
     846:	a0 8b       	std	Z+16, r26	; 0x10
     848:	b1 8b       	std	Z+17, r27	; 0x11
=======
     910:	f1 01       	movw	r30, r2
     912:	86 85       	ldd	r24, Z+14	; 0x0e
     914:	97 85       	ldd	r25, Z+15	; 0x0f
     916:	a0 89       	ldd	r26, Z+16	; 0x10
     918:	b1 89       	ldd	r27, Z+17	; 0x11
     91a:	01 96       	adiw	r24, 0x01	; 1
     91c:	a1 1d       	adc	r26, r1
     91e:	b1 1d       	adc	r27, r1
     920:	86 87       	std	Z+14, r24	; 0x0e
     922:	97 87       	std	Z+15, r25	; 0x0f
     924:	a0 8b       	std	Z+16, r26	; 0x10
     926:	b1 8b       	std	Z+17, r27	; 0x11
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
<<<<<<< HEAD
		omegam_set = 100; // [ticks/ms]
     84a:	24 e6       	ldi	r18, 0x64	; 100
     84c:	30 e0       	ldi	r19, 0x00	; 0
     84e:	22 8f       	std	Z+26, r18	; 0x1a
     850:	33 8f       	std	Z+27, r19	; 0x1b
=======
		omegam_set = 200; // [ticks/ms]
     928:	c2 8e       	std	Z+26, r12	; 0x1a
     92a:	d3 8e       	std	Z+27, r13	; 0x1b
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
<<<<<<< HEAD
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
=======
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	0f 92       	push	r0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			temporary_copy = the_data;
     858:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <thdMotor>
     85c:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <thdMotor+0x1>
			portEXIT_CRITICAL ();
<<<<<<< HEAD
     860:	0f 90       	pop	r0
     862:	0f be       	out	0x3f, r0	; 63

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     864:	86 8f       	std	Z+30, r24	; 0x1e
     866:	97 8f       	std	Z+31, r25	; 0x1f
=======
     932:	0f 90       	pop	r0
     934:	0f be       	out	0x3f, r0	; 63
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     936:	80 91 6f 31 	lds	r24, 0x316F	; 0x80316f <leftLimitSwitch>
     93a:	81 11       	cpse	r24, r1
     93c:	09 c0       	rjmp	.+18     	; 0x950 <_ZN5Motor3runEv+0xde>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     93e:	0f b6       	in	r0, 0x3f	; 63
     940:	f8 94       	cli
     942:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     944:	0f 90       	pop	r0
     946:	0f be       	out	0x3f, r0	; 63
     948:	80 91 6e 31 	lds	r24, 0x316E	; 0x80316e <rightLimitSwitch>
     94c:	88 23       	and	r24, r24
     94e:	31 f0       	breq	.+12     	; 0x95c <_ZN5Motor3runEv+0xea>
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     950:	d7 01       	movw	r26, r14
     952:	1d 92       	st	X+, r1
     954:	1d 92       	st	X+, r1
     956:	1d 92       	st	X+, r1
     958:	1c 92       	st	X, r1
     95a:	13 97       	sbiw	r26, 0x03	; 3
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     95c:	0f b6       	in	r0, 0x3f	; 63
     95e:	f8 94       	cli
     960:	0f 92       	push	r0
			temporary_copy = the_data;
     962:	80 91 72 31 	lds	r24, 0x3172	; 0x803172 <thdMotor>
     966:	90 91 73 31 	lds	r25, 0x3173	; 0x803173 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     96a:	0f 90       	pop	r0
     96c:	0f be       	out	0x3f, r0	; 63
		{
		omegam_set = 200; // [ticks/ms]
		}

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     96e:	f1 01       	movw	r30, r2
     970:	86 8f       	std	Z+30, r24	; 0x1e
     972:	97 8f       	std	Z+31, r25	; 0x1f
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
<<<<<<< HEAD
		_Kp = 21; //8
     868:	4d 89       	ldd	r20, Y+21	; 0x15
     86a:	ed 81       	ldd	r30, Y+5	; 0x05
     86c:	fe 81       	ldd	r31, Y+6	; 0x06
     86e:	40 83       	st	Z, r20
     870:	5e 89       	ldd	r21, Y+22	; 0x16
     872:	51 83       	std	Z+1, r21	; 0x01
		_Ki = .55*256; //8
     874:	4c e8       	ldi	r20, 0x8C	; 140
     876:	50 e0       	ldi	r21, 0x00	; 0
     878:	ef 81       	ldd	r30, Y+7	; 0x07
     87a:	f8 85       	ldd	r31, Y+8	; 0x08
     87c:	40 83       	st	Z, r20
     87e:	51 83       	std	Z+1, r21	; 0x01
		_Kd = 0;
     880:	ef 85       	ldd	r30, Y+15	; 0x0f
     882:	f8 89       	ldd	r31, Y+16	; 0x10
     884:	10 82       	st	Z, r1
     886:	11 82       	std	Z+1, r1	; 0x01
		antiwind_gain = 0.5*256; //7
     888:	40 e8       	ldi	r20, 0x80	; 128
     88a:	50 e0       	ldi	r21, 0x00	; 0
     88c:	e9 85       	ldd	r30, Y+9	; 0x09
     88e:	fa 85       	ldd	r31, Y+10	; 0x0a
     890:	40 83       	st	Z, r20
     892:	51 83       	std	Z+1, r21	; 0x01
		
		_max = 1600;
     894:	40 e4       	ldi	r20, 0x40	; 64
     896:	56 e0       	ldi	r21, 0x06	; 6
     898:	eb 85       	ldd	r30, Y+11	; 0x0b
     89a:	fc 85       	ldd	r31, Y+12	; 0x0c
     89c:	40 83       	st	Z, r20
     89e:	51 83       	std	Z+1, r21	; 0x01
		_min = -1600;
     8a0:	40 ec       	ldi	r20, 0xC0	; 192
     8a2:	59 ef       	ldi	r21, 0xF9	; 249
     8a4:	ed 85       	ldd	r30, Y+13	; 0x0d
     8a6:	fe 85       	ldd	r31, Y+14	; 0x0e
     8a8:	40 83       	st	Z, r20
     8aa:	51 83       	std	Z+1, r21	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     8ac:	79 01       	movw	r14, r18
     8ae:	e8 1a       	sub	r14, r24
     8b0:	f9 0a       	sbc	r15, r25
=======
		_Kp = 22;
     974:	ef 89       	ldd	r30, Y+23	; 0x17
     976:	ad 81       	ldd	r26, Y+5	; 0x05
     978:	be 81       	ldd	r27, Y+6	; 0x06
     97a:	ec 93       	st	X, r30
     97c:	f8 8d       	ldd	r31, Y+24	; 0x18
     97e:	11 96       	adiw	r26, 0x01	; 1
     980:	fc 93       	st	X, r31
		_Ki = 0.5*256;
     982:	e0 e8       	ldi	r30, 0x80	; 128
     984:	f0 e0       	ldi	r31, 0x00	; 0
     986:	af 81       	ldd	r26, Y+7	; 0x07
     988:	b8 85       	ldd	r27, Y+8	; 0x08
     98a:	ed 93       	st	X+, r30
     98c:	fc 93       	st	X, r31
		_Kd = 0;
     98e:	ab 89       	ldd	r26, Y+19	; 0x13
     990:	bc 89       	ldd	r27, Y+20	; 0x14
     992:	1d 92       	st	X+, r1
     994:	1c 92       	st	X, r1
		_max = 1600;
     996:	20 e4       	ldi	r18, 0x40	; 64
     998:	36 e0       	ldi	r19, 0x06	; 6
     99a:	e9 85       	ldd	r30, Y+9	; 0x09
     99c:	fa 85       	ldd	r31, Y+10	; 0x0a
     99e:	20 83       	st	Z, r18
     9a0:	31 83       	std	Z+1, r19	; 0x01
		_min = -1600;
     9a2:	e0 ec       	ldi	r30, 0xC0	; 192
     9a4:	f9 ef       	ldi	r31, 0xF9	; 249
     9a6:	ad 85       	ldd	r26, Y+13	; 0x0d
     9a8:	be 85       	ldd	r27, Y+14	; 0x0e
     9aa:	ed 93       	st	X+, r30
     9ac:	fc 93       	st	X, r31
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     9ae:	86 01       	movw	r16, r12
     9b0:	08 1b       	sub	r16, r24
     9b2:	19 0b       	sbc	r17, r25
     9b4:	48 01       	movw	r8, r16
     9b6:	01 2e       	mov	r0, r17
     9b8:	00 0c       	add	r0, r0
     9ba:	aa 08       	sbc	r10, r10
     9bc:	bb 08       	sbc	r11, r11
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
<<<<<<< HEAD
     8b2:	b7 01       	movw	r22, r14
     8b4:	85 e1       	ldi	r24, 0x15	; 21
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	0e 94 51 06 	call	0xca2	; 0xca2 <_ZN7satmath20signed_saturated_mulEii>
     8bc:	2b 01       	movw	r4, r22
     8be:	3c 01       	movw	r6, r24
     8c0:	e9 89       	ldd	r30, Y+17	; 0x11
     8c2:	fa 89       	ldd	r31, Y+18	; 0x12
     8c4:	60 83       	st	Z, r22
     8c6:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     8c8:	f1 01       	movw	r30, r2
     8ca:	80 81       	ld	r24, Z
     8cc:	91 81       	ldd	r25, Z+1	; 0x01
     8ce:	97 01       	movw	r18, r14
     8d0:	28 1b       	sub	r18, r24
     8d2:	39 0b       	sbc	r19, r25
     8d4:	c9 01       	movw	r24, r18
     8d6:	eb 89       	ldd	r30, Y+19	; 0x13
     8d8:	fc 89       	ldd	r31, Y+20	; 0x14
     8da:	20 83       	st	Z, r18
     8dc:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     8de:	ef 81       	ldd	r30, Y+7	; 0x07
     8e0:	f8 85       	ldd	r31, Y+8	; 0x08
     8e2:	20 81       	ld	r18, Z
     8e4:	31 81       	ldd	r19, Z+1	; 0x01
     8e6:	82 9f       	mul	r24, r18
     8e8:	d0 01       	movw	r26, r0
     8ea:	83 9f       	mul	r24, r19
     8ec:	b0 0d       	add	r27, r0
     8ee:	92 9f       	mul	r25, r18
     8f0:	b0 0d       	add	r27, r0
     8f2:	11 24       	eor	r1, r1
     8f4:	f8 01       	movw	r30, r16
     8f6:	e6 59       	subi	r30, 0x96	; 150
     8f8:	ff 4f       	sbci	r31, 0xFF	; 255
     8fa:	a0 83       	st	Z, r26
     8fc:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     8fe:	f4 01       	movw	r30, r8
     900:	20 81       	ld	r18, Z
     902:	31 81       	ldd	r19, Z+1	; 0x01
     904:	42 81       	ldd	r20, Z+2	; 0x02
     906:	53 81       	ldd	r21, Z+3	; 0x03
     908:	0e 94 66 1f 	call	0x3ecc	; 0x3ecc <__mulshisi3>
     90c:	9b 01       	movw	r18, r22
     90e:	ac 01       	movw	r20, r24
     910:	99 23       	and	r25, r25
     912:	24 f4       	brge	.+8      	; 0x91c <_ZN5Motor3runEv+0x18e>
     914:	21 50       	subi	r18, 0x01	; 1
     916:	3f 4f       	sbci	r19, 0xFF	; 255
     918:	4f 4f       	sbci	r20, 0xFF	; 255
     91a:	5f 4f       	sbci	r21, 0xFF	; 255
     91c:	bb 27       	eor	r27, r27
     91e:	57 fd       	sbrc	r21, 7
     920:	ba 95       	dec	r27
     922:	a5 2f       	mov	r26, r21
     924:	94 2f       	mov	r25, r20
     926:	83 2f       	mov	r24, r19
     928:	f5 01       	movw	r30, r10
     92a:	40 81       	ld	r20, Z
     92c:	51 81       	ldd	r21, Z+1	; 0x01
     92e:	62 81       	ldd	r22, Z+2	; 0x02
     930:	73 81       	ldd	r23, Z+3	; 0x03
     932:	84 0f       	add	r24, r20
     934:	95 1f       	adc	r25, r21
     936:	a6 1f       	adc	r26, r22
     938:	b7 1f       	adc	r27, r23
=======
     9be:	b8 01       	movw	r22, r16
     9c0:	86 e1       	ldi	r24, 0x16	; 22
     9c2:	90 e0       	ldi	r25, 0x00	; 0
     9c4:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <_ZN7satmath20signed_saturated_mulEii>
     9c8:	2b 01       	movw	r4, r22
     9ca:	3c 01       	movw	r6, r24
     9cc:	af 85       	ldd	r26, Y+15	; 0x0f
     9ce:	b8 89       	ldd	r27, Y+16	; 0x10
     9d0:	6d 93       	st	X+, r22
     9d2:	7c 93       	st	X, r23

		// Integral term
		_integral += error * dt;
     9d4:	eb 85       	ldd	r30, Y+11	; 0x0b
     9d6:	fc 85       	ldd	r31, Y+12	; 0x0c
     9d8:	60 81       	ld	r22, Z
     9da:	71 81       	ldd	r23, Z+1	; 0x01
     9dc:	82 81       	ldd	r24, Z+2	; 0x02
     9de:	93 81       	ldd	r25, Z+3	; 0x03
     9e0:	a5 01       	movw	r20, r10
     9e2:	94 01       	movw	r18, r8
     9e4:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <__mulsi3>
     9e8:	d7 01       	movw	r26, r14
     9ea:	2d 91       	ld	r18, X+
     9ec:	3d 91       	ld	r19, X+
     9ee:	4d 91       	ld	r20, X+
     9f0:	5c 91       	ld	r21, X
     9f2:	dc 01       	movw	r26, r24
     9f4:	cb 01       	movw	r24, r22
     9f6:	82 0f       	add	r24, r18
     9f8:	93 1f       	adc	r25, r19
     9fa:	a4 1f       	adc	r26, r20
     9fc:	b5 1f       	adc	r27, r21
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		if(_integral < 1000000000)
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
<<<<<<< HEAD
     93a:	81 30       	cpi	r24, 0x01	; 1
     93c:	fa ec       	ldi	r31, 0xCA	; 202
     93e:	9f 07       	cpc	r25, r31
     940:	fa e9       	ldi	r31, 0x9A	; 154
     942:	af 07       	cpc	r26, r31
     944:	fb e3       	ldi	r31, 0x3B	; 59
     946:	bf 07       	cpc	r27, r31
     948:	34 f4       	brge	.+12     	; 0x956 <_ZN5Motor3runEv+0x1c8>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     94a:	f5 01       	movw	r30, r10
     94c:	80 83       	st	Z, r24
     94e:	91 83       	std	Z+1, r25	; 0x01
     950:	a2 83       	std	Z+2, r26	; 0x02
     952:	b3 83       	std	Z+3, r27	; 0x03
     954:	09 c0       	rjmp	.+18     	; 0x968 <_ZN5Motor3runEv+0x1da>
=======
     9fe:	81 30       	cpi	r24, 0x01	; 1
     a00:	ea ec       	ldi	r30, 0xCA	; 202
     a02:	9e 07       	cpc	r25, r30
     a04:	ea e9       	ldi	r30, 0x9A	; 154
     a06:	ae 07       	cpc	r26, r30
     a08:	eb e3       	ldi	r30, 0x3B	; 59
     a0a:	be 07       	cpc	r27, r30
     a0c:	34 f4       	brge	.+12     	; 0xa1a <_ZN5Motor3runEv+0x1a8>
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);

		// Integral term
		_integral += error * dt;
     a0e:	f7 01       	movw	r30, r14
     a10:	80 83       	st	Z, r24
     a12:	91 83       	std	Z+1, r25	; 0x01
     a14:	a2 83       	std	Z+2, r26	; 0x02
     a16:	b3 83       	std	Z+3, r27	; 0x03
     a18:	09 c0       	rjmp	.+18     	; 0xa2c <_ZN5Motor3runEv+0x1ba>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			_integral = _integral;
		}
		else if(_integral > 1000000000)
		{
			_integral = 1000000000;
<<<<<<< HEAD
     956:	80 e0       	ldi	r24, 0x00	; 0
     958:	9a ec       	ldi	r25, 0xCA	; 202
     95a:	aa e9       	ldi	r26, 0x9A	; 154
     95c:	bb e3       	ldi	r27, 0x3B	; 59
     95e:	f5 01       	movw	r30, r10
     960:	80 83       	st	Z, r24
     962:	91 83       	std	Z+1, r25	; 0x01
     964:	a2 83       	std	Z+2, r26	; 0x02
     966:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     968:	f5 01       	movw	r30, r10
     96a:	60 81       	ld	r22, Z
     96c:	71 81       	ldd	r23, Z+1	; 0x01
     96e:	c2 01       	movw	r24, r4
     970:	0e 94 35 06 	call	0xc6a	; 0xc6a <_ZN7satmath20signed_saturated_addEii>
     974:	f8 01       	movw	r30, r16
     976:	e0 5a       	subi	r30, 0xA0	; 160
     978:	ff 4f       	sbci	r31, 0xFF	; 255
     97a:	80 83       	st	Z, r24
     97c:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     97e:	f6 01       	movw	r30, r12
     980:	80 83       	st	Z, r24
     982:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     984:	eb 85       	ldd	r30, Y+11	; 0x0b
     986:	fc 85       	ldd	r31, Y+12	; 0x0c
     988:	20 81       	ld	r18, Z
     98a:	31 81       	ldd	r19, Z+1	; 0x01
     98c:	28 17       	cp	r18, r24
     98e:	39 07       	cpc	r19, r25
     990:	24 f4       	brge	.+8      	; 0x99a <_ZN5Motor3runEv+0x20c>
		output_correct = _max;
     992:	f6 01       	movw	r30, r12
     994:	20 83       	st	Z, r18
     996:	31 83       	std	Z+1, r19	; 0x01
     998:	0a c0       	rjmp	.+20     	; 0x9ae <_ZN5Motor3runEv+0x220>
		else if( output_correct < _min )
     99a:	ed 85       	ldd	r30, Y+13	; 0x0d
     99c:	fe 85       	ldd	r31, Y+14	; 0x0e
     99e:	20 81       	ld	r18, Z
     9a0:	31 81       	ldd	r19, Z+1	; 0x01
     9a2:	82 17       	cp	r24, r18
     9a4:	93 07       	cpc	r25, r19
     9a6:	1c f4       	brge	.+6      	; 0x9ae <_ZN5Motor3runEv+0x220>
		output_correct = _min;
     9a8:	f6 01       	movw	r30, r12
     9aa:	20 83       	st	Z, r18
     9ac:	31 83       	std	Z+1, r19	; 0x01

		// Save error to previous error
		_pre_error = error;
     9ae:	f8 01       	movw	r30, r16
     9b0:	e2 5b       	subi	r30, 0xB2	; 178
     9b2:	ff 4f       	sbci	r31, 0xFF	; 255
     9b4:	e0 82       	st	Z, r14
     9b6:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     9b8:	f6 01       	movw	r30, r12
     9ba:	20 81       	ld	r18, Z
     9bc:	31 81       	ldd	r19, Z+1	; 0x01
     9be:	82 1b       	sub	r24, r18
     9c0:	93 0b       	sbc	r25, r19
     9c2:	f8 01       	movw	r30, r16
     9c4:	ee 59       	subi	r30, 0x9E	; 158
     9c6:	ff 4f       	sbci	r31, 0xFF	; 255
     9c8:	80 83       	st	Z, r24
     9ca:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     9cc:	e9 85       	ldd	r30, Y+9	; 0x09
     9ce:	fa 85       	ldd	r31, Y+10	; 0x0a
     9d0:	40 81       	ld	r20, Z
     9d2:	51 81       	ldd	r21, Z+1	; 0x01
     9d4:	84 9f       	mul	r24, r20
     9d6:	90 01       	movw	r18, r0
     9d8:	85 9f       	mul	r24, r21
     9da:	30 0d       	add	r19, r0
     9dc:	94 9f       	mul	r25, r20
     9de:	30 0d       	add	r19, r0
     9e0:	11 24       	eor	r1, r1
     9e2:	33 23       	and	r19, r19
     9e4:	14 f4       	brge	.+4      	; 0x9ea <_ZN5Motor3runEv+0x25c>
     9e6:	21 50       	subi	r18, 0x01	; 1
     9e8:	3f 4f       	sbci	r19, 0xFF	; 255
     9ea:	83 2f       	mov	r24, r19
     9ec:	88 0f       	add	r24, r24
     9ee:	88 0b       	sbc	r24, r24
     9f0:	f1 01       	movw	r30, r2
     9f2:	30 83       	st	Z, r19
     9f4:	81 83       	std	Z+1, r24	; 0x01
		
		
			if(runs%5==0){
     9f6:	f8 01       	movw	r30, r16
     9f8:	66 85       	ldd	r22, Z+14	; 0x0e
     9fa:	77 85       	ldd	r23, Z+15	; 0x0f
     9fc:	80 89       	ldd	r24, Z+16	; 0x10
     9fe:	91 89       	ldd	r25, Z+17	; 0x11
     a00:	25 e0       	ldi	r18, 0x05	; 5
     a02:	30 e0       	ldi	r19, 0x00	; 0
     a04:	40 e0       	ldi	r20, 0x00	; 0
     a06:	50 e0       	ldi	r21, 0x00	; 0
     a08:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <__udivmodsi4>
     a0c:	67 2b       	or	r22, r23
     a0e:	68 2b       	or	r22, r24
     a10:	69 2b       	or	r22, r25
     a12:	51 f4       	brne	.+20     	; 0xa28 <_ZN5Motor3runEv+0x29a>
				//*p_serial << "Pout: " << Pout << endl;
				//*p_serial << "error: " << error << endl;
				//*p_serial << "Integral: " << _integral << endl;
				//*p_serial << "Measured: " << omegam_measured << endl;
				//*p_serial << "PWM Signal: " << output_correct << endl;
				*p_serial << omegam_measured << endl;
     a14:	f8 01       	movw	r30, r16
     a16:	66 8d       	ldd	r22, Z+30	; 0x1e
     a18:	77 8d       	ldd	r23, Z+31	; 0x1f
     a1a:	86 81       	ldd	r24, Z+6	; 0x06
     a1c:	97 81       	ldd	r25, Z+7	; 0x07
     a1e:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstreamlsEi>
     a22:	66 e0       	ldi	r22, 0x06	; 6
     a24:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     a28:	0f b6       	in	r0, 0x3f	; 63
     a2a:	f8 94       	cli
     a2c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     a2e:	0f 90       	pop	r0
     a30:	0f be       	out	0x3f, r0	; 63
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     a32:	80 91 39 31 	lds	r24, 0x3139	; 0x803139 <leftLimitSwitch>
     a36:	81 11       	cpse	r24, r1
     a38:	09 c0       	rjmp	.+18     	; 0xa4c <_ZN5Motor3runEv+0x2be>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     a3a:	0f b6       	in	r0, 0x3f	; 63
     a3c:	f8 94       	cli
     a3e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     a40:	0f 90       	pop	r0
     a42:	0f be       	out	0x3f, r0	; 63
     a44:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rightLimitSwitch>
     a48:	88 23       	and	r24, r24
     a4a:	59 f0       	breq	.+22     	; 0xa62 <_ZN5Motor3runEv+0x2d4>
		{
			omegam_set = 0; // [ticks/ms]
     a4c:	f8 01       	movw	r30, r16
     a4e:	12 8e       	std	Z+26, r1	; 0x1a
     a50:	13 8e       	std	Z+27, r1	; 0x1b
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     a52:	f5 01       	movw	r30, r10
     a54:	10 82       	st	Z, r1
     a56:	11 82       	std	Z+1, r1	; 0x01
     a58:	12 82       	std	Z+2, r1	; 0x02
     a5a:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;
     a5c:	f6 01       	movw	r30, r12
     a5e:	10 82       	st	Z, r1
     a60:	11 82       	std	Z+1, r1	; 0x01
=======
     a1a:	80 e0       	ldi	r24, 0x00	; 0
     a1c:	9a ec       	ldi	r25, 0xCA	; 202
     a1e:	aa e9       	ldi	r26, 0x9A	; 154
     a20:	bb e3       	ldi	r27, 0x3B	; 59
     a22:	f7 01       	movw	r30, r14
     a24:	80 83       	st	Z, r24
     a26:	91 83       	std	Z+1, r25	; 0x01
     a28:	a2 83       	std	Z+2, r26	; 0x02
     a2a:	b3 83       	std	Z+3, r27	; 0x03
		_integral = arbitraryNumber;
		else if( _integral < arbitraryNumber )
		_integral = arbitraryNumber;
		*/
		
		Iout = (_Ki * _integral)/256;
     a2c:	ef 81       	ldd	r30, Y+7	; 0x07
     a2e:	f8 85       	ldd	r31, Y+8	; 0x08
     a30:	a0 81       	ld	r26, Z
     a32:	b1 81       	ldd	r27, Z+1	; 0x01
     a34:	f7 01       	movw	r30, r14
     a36:	20 81       	ld	r18, Z
     a38:	31 81       	ldd	r19, Z+1	; 0x01
     a3a:	42 81       	ldd	r20, Z+2	; 0x02
     a3c:	53 81       	ldd	r21, Z+3	; 0x03
     a3e:	0e 94 44 20 	call	0x4088	; 0x4088 <__mulshisi3>
     a42:	9b 01       	movw	r18, r22
     a44:	ac 01       	movw	r20, r24
     a46:	99 23       	and	r25, r25
     a48:	24 f4       	brge	.+8      	; 0xa52 <_ZN5Motor3runEv+0x1e0>
     a4a:	21 50       	subi	r18, 0x01	; 1
     a4c:	3f 4f       	sbci	r19, 0xFF	; 255
     a4e:	4f 4f       	sbci	r20, 0xFF	; 255
     a50:	5f 4f       	sbci	r21, 0xFF	; 255
     a52:	99 27       	eor	r25, r25
     a54:	57 fd       	sbrc	r21, 7
     a56:	9a 95       	dec	r25
     a58:	85 2f       	mov	r24, r21
     a5a:	74 2f       	mov	r23, r20
     a5c:	63 2f       	mov	r22, r19
     a5e:	a9 89       	ldd	r26, Y+17	; 0x11
     a60:	ba 89       	ldd	r27, Y+18	; 0x12
     a62:	6d 93       	st	X+, r22
     a64:	7d 93       	st	X+, r23
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	13 97       	sbiw	r26, 0x03	; 3
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output
		// int16_t output = Pout + Iout + Dout;
		int16_t output = ssadd(Pout, Iout);
     a6c:	c2 01       	movw	r24, r4
     a6e:	0e 94 dd 06 	call	0xdba	; 0xdba <_ZN7satmath20signed_saturated_addEii>

		// Restrict to max/min
		if( output > _max )
     a72:	e9 85       	ldd	r30, Y+9	; 0x09
     a74:	fa 85       	ldd	r31, Y+10	; 0x0a
     a76:	60 80       	ld	r6, Z
     a78:	71 80       	ldd	r7, Z+1	; 0x01
     a7a:	68 16       	cp	r6, r24
     a7c:	79 06       	cpc	r7, r25
     a7e:	4c f0       	brlt	.+18     	; 0xa92 <_ZN5Motor3runEv+0x220>
		output = _max;
		else if( output < _min )
     a80:	ad 85       	ldd	r26, Y+13	; 0x0d
     a82:	be 85       	ldd	r27, Y+14	; 0x0e
     a84:	2d 91       	ld	r18, X+
     a86:	3c 91       	ld	r19, X
     a88:	3c 01       	movw	r6, r24
     a8a:	82 17       	cp	r24, r18
     a8c:	93 07       	cpc	r25, r19
     a8e:	0c f4       	brge	.+2      	; 0xa92 <_ZN5Motor3runEv+0x220>
     a90:	39 01       	movw	r6, r18
		output = _min;

		// Save error to previous error
		_pre_error = error;
     a92:	ed 89       	ldd	r30, Y+21	; 0x15
     a94:	fe 89       	ldd	r31, Y+22	; 0x16
     a96:	00 83       	st	Z, r16
     a98:	11 83       	std	Z+1, r17	; 0x01
		
		
			if(runs%5==0){
     a9a:	d1 01       	movw	r26, r2
     a9c:	1e 96       	adiw	r26, 0x0e	; 14
     a9e:	6d 91       	ld	r22, X+
     aa0:	7d 91       	ld	r23, X+
     aa2:	8d 91       	ld	r24, X+
     aa4:	9c 91       	ld	r25, X
     aa6:	51 97       	sbiw	r26, 0x11	; 17
     aa8:	25 e0       	ldi	r18, 0x05	; 5
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
     ab4:	67 2b       	or	r22, r23
     ab6:	68 2b       	or	r22, r24
     ab8:	69 2b       	or	r22, r25
     aba:	09 f0       	breq	.+2      	; 0xabe <_ZN5Motor3runEv+0x24c>
     abc:	6a c0       	rjmp	.+212    	; 0xb92 <_ZN5Motor3runEv+0x320>
				*p_serial << "Ierror: " << Iout << endl;
     abe:	a9 89       	ldd	r26, Y+17	; 0x11
     ac0:	ba 89       	ldd	r27, Y+18	; 0x12
     ac2:	8d 91       	ld	r24, X+
     ac4:	9d 91       	ld	r25, X+
     ac6:	0d 90       	ld	r0, X+
     ac8:	bc 91       	ld	r27, X
     aca:	a0 2d       	mov	r26, r0
     acc:	89 8f       	std	Y+25, r24	; 0x19
     ace:	9a 8f       	std	Y+26, r25	; 0x1a
     ad0:	ab 8f       	std	Y+27, r26	; 0x1b
     ad2:	bc 8f       	std	Y+28, r27	; 0x1c
     ad4:	f1 01       	movw	r30, r2
     ad6:	06 81       	ldd	r16, Z+6	; 0x06
     ad8:	17 81       	ldd	r17, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     ada:	6e e1       	ldi	r22, 0x1E	; 30
     adc:	70 e2       	ldi	r23, 0x20	; 32
     ade:	c8 01       	movw	r24, r16
     ae0:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     ae4:	49 8d       	ldd	r20, Y+25	; 0x19
     ae6:	5a 8d       	ldd	r21, Y+26	; 0x1a
     ae8:	6b 8d       	ldd	r22, Y+27	; 0x1b
     aea:	7c 8d       	ldd	r23, Y+28	; 0x1c
     aec:	c8 01       	movw	r24, r16
     aee:	0e 94 a5 1a 	call	0x354a	; 0x354a <_ZN8emstreamlsEl>
     af2:	66 e0       	ldi	r22, 0x06	; 6
     af4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "Pout: " << Pout << endl;
     af8:	af 85       	ldd	r26, Y+15	; 0x0f
     afa:	b8 89       	ldd	r27, Y+16	; 0x10
     afc:	4d 90       	ld	r4, X+
     afe:	5c 90       	ld	r5, X
     b00:	f1 01       	movw	r30, r2
     b02:	06 81       	ldd	r16, Z+6	; 0x06
     b04:	17 81       	ldd	r17, Z+7	; 0x07
     b06:	67 e2       	ldi	r22, 0x27	; 39
     b08:	70 e2       	ldi	r23, 0x20	; 32
     b0a:	c8 01       	movw	r24, r16
     b0c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     b10:	b2 01       	movw	r22, r4
     b12:	c8 01       	movw	r24, r16
     b14:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEi>
     b18:	66 e0       	ldi	r22, 0x06	; 6
     b1a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "error: " << error << endl;
     b1e:	d1 01       	movw	r26, r2
     b20:	16 96       	adiw	r26, 0x06	; 6
     b22:	0d 91       	ld	r16, X+
     b24:	1c 91       	ld	r17, X
     b26:	17 97       	sbiw	r26, 0x07	; 7
     b28:	6f e1       	ldi	r22, 0x1F	; 31
     b2a:	70 e2       	ldi	r23, 0x20	; 32
     b2c:	c8 01       	movw	r24, r16
     b2e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     b32:	b5 01       	movw	r22, r10
     b34:	a4 01       	movw	r20, r8
     b36:	c8 01       	movw	r24, r16
     b38:	0e 94 a5 1a 	call	0x354a	; 0x354a <_ZN8emstreamlsEl>
     b3c:	66 e0       	ldi	r22, 0x06	; 6
     b3e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "Integral: " << _integral << endl;
     b42:	f7 01       	movw	r30, r14
     b44:	80 80       	ld	r8, Z
     b46:	91 80       	ldd	r9, Z+1	; 0x01
     b48:	a2 80       	ldd	r10, Z+2	; 0x02
     b4a:	b3 80       	ldd	r11, Z+3	; 0x03
     b4c:	d1 01       	movw	r26, r2
     b4e:	16 96       	adiw	r26, 0x06	; 6
     b50:	0d 91       	ld	r16, X+
     b52:	1c 91       	ld	r17, X
     b54:	17 97       	sbiw	r26, 0x07	; 7
     b56:	6e e2       	ldi	r22, 0x2E	; 46
     b58:	70 e2       	ldi	r23, 0x20	; 32
     b5a:	c8 01       	movw	r24, r16
     b5c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     b60:	b5 01       	movw	r22, r10
     b62:	a4 01       	movw	r20, r8
     b64:	c8 01       	movw	r24, r16
     b66:	0e 94 a5 1a 	call	0x354a	; 0x354a <_ZN8emstreamlsEl>
     b6a:	66 e0       	ldi	r22, 0x06	; 6
     b6c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "Measured: " << omegam_measured << endl;
     b70:	f1 01       	movw	r30, r2
     b72:	a6 8c       	ldd	r10, Z+30	; 0x1e
     b74:	b7 8c       	ldd	r11, Z+31	; 0x1f
     b76:	06 81       	ldd	r16, Z+6	; 0x06
     b78:	17 81       	ldd	r17, Z+7	; 0x07
     b7a:	69 e3       	ldi	r22, 0x39	; 57
     b7c:	70 e2       	ldi	r23, 0x20	; 32
     b7e:	c8 01       	movw	r24, r16
     b80:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     b84:	b5 01       	movw	r22, r10
     b86:	c8 01       	movw	r24, r16
     b88:	0e 94 7c 1a 	call	0x34f8	; 0x34f8 <_ZN8emstreamlsEi>
     b8c:	66 e0       	ldi	r22, 0x06	; 6
     b8e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
<<<<<<< HEAD
     a62:	0f b6       	in	r0, 0x3f	; 63
     a64:	f8 94       	cli
     a66:	0f 92       	push	r0
			the_data = new_data;
     a68:	f6 01       	movw	r30, r12
     a6a:	80 81       	ld	r24, Z
     a6c:	91 81       	ldd	r25, Z+1	; 0x01
     a6e:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <PWMvalue>
     a72:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     a76:	0f 90       	pop	r0
     a78:	0f be       	out	0x3f, r0	; 63
=======
     b92:	0f b6       	in	r0, 0x3f	; 63
     b94:	f8 94       	cli
     b96:	0f 92       	push	r0
			the_data = new_data;
     b98:	60 92 6c 31 	sts	0x316C, r6	; 0x80316c <PWMvalue>
     b9c:	70 92 6d 31 	sts	0x316D, r7	; 0x80316d <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     ba0:	0f 90       	pop	r0
     ba2:	0f be       	out	0x3f, r0	; 63
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			}
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
<<<<<<< HEAD
     a7a:	f8 01       	movw	r30, r16
     a7c:	10 a6       	std	Z+40, r1	; 0x28
     a7e:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     a80:	82 a1       	ldd	r24, Z+34	; 0x22
     a82:	93 a1       	ldd	r25, Z+35	; 0x23
     a84:	60 e0       	ldi	r22, 0x00	; 0
     a86:	70 e0       	ldi	r23, 0x00	; 0
     a88:	0e 94 df 1e 	call	0x3dbe	; 0x3dbe <__divmodhi4>
     a8c:	7b 01       	movw	r14, r22
=======
     ba4:	d1 01       	movw	r26, r2
     ba6:	98 96       	adiw	r26, 0x28	; 40
     ba8:	1d 92       	st	X+, r1
     baa:	1c 92       	st	X, r1
     bac:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
     bae:	92 96       	adiw	r26, 0x22	; 34
     bb0:	8d 91       	ld	r24, X+
     bb2:	9c 91       	ld	r25, X
     bb4:	93 97       	sbiw	r26, 0x23	; 35
     bb6:	60 e0       	ldi	r22, 0x00	; 0
     bb8:	70 e0       	ldi	r23, 0x00	; 0
     bba:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <__divmodhi4>
     bbe:	8b 01       	movw	r16, r22
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		// Saturater for current
		
		if(Im_set > 17.4) {
<<<<<<< HEAD
     a8e:	07 2e       	mov	r0, r23
     a90:	00 0c       	add	r0, r0
     a92:	88 0b       	sbc	r24, r24
     a94:	99 0b       	sbc	r25, r25
     a96:	0e 94 6b 1e 	call	0x3cd6	; 0x3cd6 <__floatsisf>
     a9a:	2b 01       	movw	r4, r22
     a9c:	3c 01       	movw	r6, r24
     a9e:	23 e3       	ldi	r18, 0x33	; 51
     aa0:	33 e3       	ldi	r19, 0x33	; 51
     aa2:	4b e8       	ldi	r20, 0x8B	; 139
     aa4:	51 e4       	ldi	r21, 0x41	; 65
     aa6:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <__gesf2>
     aaa:	18 16       	cp	r1, r24
     aac:	34 f4       	brge	.+12     	; 0xaba <_ZN5Motor3runEv+0x32c>
			Im_set = 17.4;
     aae:	81 e1       	ldi	r24, 0x11	; 17
     ab0:	90 e0       	ldi	r25, 0x00	; 0
     ab2:	f8 01       	movw	r30, r16
     ab4:	84 a3       	std	Z+36, r24	; 0x24
     ab6:	95 a3       	std	Z+37, r25	; 0x25
     ab8:	13 c0       	rjmp	.+38     	; 0xae0 <_ZN5Motor3runEv+0x352>
		} else if(Im_set < -17.4) {
     aba:	23 e3       	ldi	r18, 0x33	; 51
     abc:	33 e3       	ldi	r19, 0x33	; 51
     abe:	4b e8       	ldi	r20, 0x8B	; 139
     ac0:	51 ec       	ldi	r21, 0xC1	; 193
     ac2:	c3 01       	movw	r24, r6
     ac4:	b2 01       	movw	r22, r4
     ac6:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <__cmpsf2>
     aca:	88 23       	and	r24, r24
     acc:	24 f0       	brlt	.+8      	; 0xad6 <_ZN5Motor3runEv+0x348>
=======
     bc0:	07 2e       	mov	r0, r23
     bc2:	00 0c       	add	r0, r0
     bc4:	88 0b       	sbc	r24, r24
     bc6:	99 0b       	sbc	r25, r25
     bc8:	0e 94 49 1f 	call	0x3e92	; 0x3e92 <__floatsisf>
     bcc:	4b 01       	movw	r8, r22
     bce:	5c 01       	movw	r10, r24
     bd0:	23 e3       	ldi	r18, 0x33	; 51
     bd2:	33 e3       	ldi	r19, 0x33	; 51
     bd4:	4b e8       	ldi	r20, 0x8B	; 139
     bd6:	51 e4       	ldi	r21, 0x41	; 65
     bd8:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <__gesf2>
     bdc:	18 16       	cp	r1, r24
     bde:	34 f4       	brge	.+12     	; 0xbec <_ZN5Motor3runEv+0x37a>
			Im_set = 17.4;
     be0:	81 e1       	ldi	r24, 0x11	; 17
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	f1 01       	movw	r30, r2
     be6:	84 a3       	std	Z+36, r24	; 0x24
     be8:	95 a3       	std	Z+37, r25	; 0x25
     bea:	15 c0       	rjmp	.+42     	; 0xc16 <_ZN5Motor3runEv+0x3a4>
		} else if(Im_set < -17.4) {
     bec:	23 e3       	ldi	r18, 0x33	; 51
     bee:	33 e3       	ldi	r19, 0x33	; 51
     bf0:	4b e8       	ldi	r20, 0x8B	; 139
     bf2:	51 ec       	ldi	r21, 0xC1	; 193
     bf4:	c5 01       	movw	r24, r10
     bf6:	b4 01       	movw	r22, r8
     bf8:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <__cmpsf2>
     bfc:	88 23       	and	r24, r24
     bfe:	34 f0       	brlt	.+12     	; 0xc0c <_ZN5Motor3runEv+0x39a>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
<<<<<<< HEAD
     ace:	f8 01       	movw	r30, r16
     ad0:	e4 a2       	std	Z+36, r14	; 0x24
     ad2:	f5 a2       	std	Z+37, r15	; 0x25
     ad4:	05 c0       	rjmp	.+10     	; 0xae0 <_ZN5Motor3runEv+0x352>
=======
     c00:	d1 01       	movw	r26, r2
     c02:	94 96       	adiw	r26, 0x24	; 36
     c04:	0d 93       	st	X+, r16
     c06:	1c 93       	st	X, r17
     c08:	95 97       	sbiw	r26, 0x25	; 37
     c0a:	05 c0       	rjmp	.+10     	; 0xc16 <_ZN5Motor3runEv+0x3a4>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
<<<<<<< HEAD
     ad6:	8f ee       	ldi	r24, 0xEF	; 239
     ad8:	9f ef       	ldi	r25, 0xFF	; 255
     ada:	f8 01       	movw	r30, r16
     adc:	84 a3       	std	Z+36, r24	; 0x24
     ade:	95 a3       	std	Z+37, r25	; 0x25
=======
     c0c:	8f ee       	ldi	r24, 0xEF	; 239
     c0e:	9f ef       	ldi	r25, 0xFF	; 255
     c10:	f1 01       	movw	r30, r2
     c12:	84 a3       	std	Z+36, r24	; 0x24
     c14:	95 a3       	std	Z+37, r25	; 0x25
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
<<<<<<< HEAD
     ae0:	f8 01       	movw	r30, r16
     ae2:	16 aa       	std	Z+54, r1	; 0x36
     ae4:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     ae6:	12 aa       	std	Z+50, r1	; 0x32
     ae8:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     aea:	14 aa       	std	Z+52, r1	; 0x34
     aec:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
     aee:	80 a9       	ldd	r24, Z+48	; 0x30
     af0:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
     af2:	89 31       	cpi	r24, 0x19	; 25
     af4:	91 05       	cpc	r25, r1
     af6:	2c f0       	brlt	.+10     	; 0xb02 <_ZN5Motor3runEv+0x374>
			V_m = 24;
     af8:	88 e1       	ldi	r24, 0x18	; 24
     afa:	90 e0       	ldi	r25, 0x00	; 0
     afc:	80 af       	std	Z+56, r24	; 0x38
     afe:	91 af       	std	Z+57, r25	; 0x39
     b00:	0d c0       	rjmp	.+26     	; 0xb1c <_ZN5Motor3runEv+0x38e>
		} else if(V_m < -24) {
     b02:	88 3e       	cpi	r24, 0xE8	; 232
     b04:	ff ef       	ldi	r31, 0xFF	; 255
     b06:	9f 07       	cpc	r25, r31
     b08:	24 f0       	brlt	.+8      	; 0xb12 <_ZN5Motor3runEv+0x384>
=======
     c16:	d1 01       	movw	r26, r2
     c18:	d6 96       	adiw	r26, 0x36	; 54
     c1a:	1d 92       	st	X+, r1
     c1c:	1c 92       	st	X, r1
     c1e:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     c20:	d2 96       	adiw	r26, 0x32	; 50
     c22:	1d 92       	st	X+, r1
     c24:	1c 92       	st	X, r1
     c26:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     c28:	d4 96       	adiw	r26, 0x34	; 52
     c2a:	1d 92       	st	X+, r1
     c2c:	1c 92       	st	X, r1
     c2e:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
     c30:	d0 96       	adiw	r26, 0x30	; 48
     c32:	8d 91       	ld	r24, X+
     c34:	9c 91       	ld	r25, X
     c36:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
     c38:	89 31       	cpi	r24, 0x19	; 25
     c3a:	91 05       	cpc	r25, r1
     c3c:	3c f0       	brlt	.+14     	; 0xc4c <_ZN5Motor3runEv+0x3da>
			V_m = 24;
     c3e:	88 e1       	ldi	r24, 0x18	; 24
     c40:	90 e0       	ldi	r25, 0x00	; 0
     c42:	d8 96       	adiw	r26, 0x38	; 56
     c44:	8d 93       	st	X+, r24
     c46:	9c 93       	st	X, r25
     c48:	d9 97       	sbiw	r26, 0x39	; 57
     c4a:	0f c0       	rjmp	.+30     	; 0xc6a <_ZN5Motor3runEv+0x3f8>
		} else if(V_m < -24) {
     c4c:	88 3e       	cpi	r24, 0xE8	; 232
     c4e:	bf ef       	ldi	r27, 0xFF	; 255
     c50:	9b 07       	cpc	r25, r27
     c52:	24 f0       	brlt	.+8      	; 0xc5c <_ZN5Motor3runEv+0x3ea>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
<<<<<<< HEAD
     b0a:	f8 01       	movw	r30, r16
     b0c:	80 af       	std	Z+56, r24	; 0x38
     b0e:	91 af       	std	Z+57, r25	; 0x39
     b10:	05 c0       	rjmp	.+10     	; 0xb1c <_ZN5Motor3runEv+0x38e>
=======
     c54:	f1 01       	movw	r30, r2
     c56:	80 af       	std	Z+56, r24	; 0x38
     c58:	91 af       	std	Z+57, r25	; 0x39
     c5a:	07 c0       	rjmp	.+14     	; 0xc6a <_ZN5Motor3runEv+0x3f8>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
<<<<<<< HEAD
     b12:	88 ee       	ldi	r24, 0xE8	; 232
     b14:	9f ef       	ldi	r25, 0xFF	; 255
     b16:	f8 01       	movw	r30, r16
     b18:	80 af       	std	Z+56, r24	; 0x38
     b1a:	91 af       	std	Z+57, r25	; 0x39
=======
     c5c:	88 ee       	ldi	r24, 0xE8	; 232
     c5e:	9f ef       	ldi	r25, 0xFF	; 255
     c60:	d1 01       	movw	r26, r2
     c62:	d8 96       	adiw	r26, 0x38	; 56
     c64:	8d 93       	st	X+, r24
     c66:	9c 93       	st	X, r25
     c68:	d9 97       	sbiw	r26, 0x39	; 57
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
<<<<<<< HEAD
     b1c:	f4 01       	movw	r30, r8
     b1e:	20 81       	ld	r18, Z
     b20:	31 81       	ldd	r19, Z+1	; 0x01
     b22:	42 81       	ldd	r20, Z+2	; 0x02
     b24:	53 81       	ldd	r21, Z+3	; 0x03
     b26:	a8 ee       	ldi	r26, 0xE8	; 232
     b28:	b3 e0       	ldi	r27, 0x03	; 3
     b2a:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <__muluhisi3>
     b2e:	68 3e       	cpi	r22, 0xE8	; 232
     b30:	f3 e0       	ldi	r31, 0x03	; 3
     b32:	7f 07       	cpc	r23, r31
     b34:	81 05       	cpc	r24, r1
     b36:	91 05       	cpc	r25, r1
     b38:	48 f0       	brcs	.+18     	; 0xb4c <_ZN5Motor3runEv+0x3be>
     b3a:	28 ee       	ldi	r18, 0xE8	; 232
     b3c:	33 e0       	ldi	r19, 0x03	; 3
     b3e:	40 e0       	ldi	r20, 0x00	; 0
     b40:	50 e0       	ldi	r21, 0x00	; 0
     b42:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <__udivmodsi4>
     b46:	ba 01       	movw	r22, r20
     b48:	a9 01       	movw	r20, r18
     b4a:	04 c0       	rjmp	.+8      	; 0xb54 <_ZN5Motor3runEv+0x3c6>
     b4c:	41 e0       	ldi	r20, 0x01	; 1
     b4e:	50 e0       	ldi	r21, 0x00	; 0
     b50:	60 e0       	ldi	r22, 0x00	; 0
     b52:	70 e0       	ldi	r23, 0x00	; 0
     b54:	ce 01       	movw	r24, r28
     b56:	01 96       	adiw	r24, 0x01	; 1
     b58:	0e 94 8b 11 	call	0x2316	; 0x2316 <vTaskDelayUntil>
     b5c:	6a ce       	rjmp	.-812    	; 0x832 <_ZN5Motor3runEv+0xa4>

00000b5e <_ZN5MotorC1EPKchjP8emstream>:
=======
     c6a:	eb 85       	ldd	r30, Y+11	; 0x0b
     c6c:	fc 85       	ldd	r31, Y+12	; 0x0c
     c6e:	20 81       	ld	r18, Z
     c70:	31 81       	ldd	r19, Z+1	; 0x01
     c72:	42 81       	ldd	r20, Z+2	; 0x02
     c74:	53 81       	ldd	r21, Z+3	; 0x03
     c76:	a8 ee       	ldi	r26, 0xE8	; 232
     c78:	b3 e0       	ldi	r27, 0x03	; 3
     c7a:	0e 94 39 20 	call	0x4072	; 0x4072 <__muluhisi3>
     c7e:	68 3e       	cpi	r22, 0xE8	; 232
     c80:	f3 e0       	ldi	r31, 0x03	; 3
     c82:	7f 07       	cpc	r23, r31
     c84:	81 05       	cpc	r24, r1
     c86:	91 05       	cpc	r25, r1
     c88:	48 f0       	brcs	.+18     	; 0xc9c <_ZN5Motor3runEv+0x42a>
     c8a:	28 ee       	ldi	r18, 0xE8	; 232
     c8c:	33 e0       	ldi	r19, 0x03	; 3
     c8e:	40 e0       	ldi	r20, 0x00	; 0
     c90:	50 e0       	ldi	r21, 0x00	; 0
     c92:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
     c96:	ba 01       	movw	r22, r20
     c98:	a9 01       	movw	r20, r18
     c9a:	04 c0       	rjmp	.+8      	; 0xca4 <_ZN5Motor3runEv+0x432>
     c9c:	41 e0       	ldi	r20, 0x01	; 1
     c9e:	50 e0       	ldi	r21, 0x00	; 0
     ca0:	60 e0       	ldi	r22, 0x00	; 0
     ca2:	70 e0       	ldi	r23, 0x00	; 0
     ca4:	ce 01       	movw	r24, r28
     ca6:	01 96       	adiw	r24, 0x01	; 1
     ca8:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
     cac:	31 ce       	rjmp	.-926    	; 0x910 <_ZN5Motor3runEv+0x9e>

00000cae <_ZN5MotorC1EPKchjP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
<<<<<<< HEAD
     b5e:	0f 93       	push	r16
     b60:	1f 93       	push	r17
     b62:	cf 93       	push	r28
     b64:	df 93       	push	r29
     b66:	ec 01       	movw	r28, r24
=======
     cae:	0f 93       	push	r16
     cb0:	1f 93       	push	r17
     cb2:	cf 93       	push	r28
     cb4:	df 93       	push	r29
     cb6:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
<<<<<<< HEAD
     b68:	0e 94 28 14 	call	0x2850	; 0x2850 <_ZN8frt_taskC1EPKchjP8emstream>
     b6c:	8a e1       	ldi	r24, 0x1A	; 26
     b6e:	90 e2       	ldi	r25, 0x20	; 32
     b70:	88 83       	st	Y, r24
     b72:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
     b78:	1f 91       	pop	r17
     b7a:	0f 91       	pop	r16
     b7c:	08 95       	ret

00000b7e <_ZN9PWMdriver3runEv>:
=======
     cb8:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     cbc:	88 e4       	ldi	r24, 0x48	; 72
     cbe:	90 e2       	ldi	r25, 0x20	; 32
     cc0:	88 83       	st	Y, r24
     cc2:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     cc4:	df 91       	pop	r29
     cc6:	cf 91       	pop	r28
     cc8:	1f 91       	pop	r17
     cca:	0f 91       	pop	r16
     ccc:	08 95       	ret

00000cce <_ZN9PWMdriver3runEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		// Nothing to do in this constructor other than call the parent constructor
	}



void PWMdriver::run(void){
<<<<<<< HEAD
     b7e:	cf 93       	push	r28
     b80:	df 93       	push	r29
     b82:	00 d0       	rcall	.+0      	; 0xb84 <_ZN9PWMdriver3runEv+0x6>
     b84:	1f 92       	push	r1
     b86:	cd b7       	in	r28, 0x3d	; 61
     b88:	de b7       	in	r29, 0x3e	; 62
     b8a:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     b8c:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <xTaskGetTickCount>
     b90:	69 83       	std	Y+1, r22	; 0x01
     b92:	7a 83       	std	Y+2, r23	; 0x02
     b94:	8b 83       	std	Y+3, r24	; 0x03
     b96:	9c 83       	std	Y+4, r25	; 0x04
=======
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	00 d0       	rcall	.+0      	; 0xcd4 <_ZN9PWMdriver3runEv+0x6>
     cd4:	1f 92       	push	r1
     cd6:	cd b7       	in	r28, 0x3d	; 61
     cd8:	de b7       	in	r29, 0x3e	; 62
     cda:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     cdc:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
     ce0:	69 83       	std	Y+1, r22	; 0x01
     ce2:	7a 83       	std	Y+2, r23	; 0x02
     ce4:	8b 83       	std	Y+3, r24	; 0x03
     ce6:	9c 83       	std	Y+4, r25	; 0x04
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	//PC0 - MD0
	//PC1 - MD1
	
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
<<<<<<< HEAD
     b98:	a0 e4       	ldi	r26, 0x40	; 64
     b9a:	b6 e0       	ldi	r27, 0x06	; 6
     b9c:	87 e0       	ldi	r24, 0x07	; 7
     b9e:	11 96       	adiw	r26, 0x01	; 1
     ba0:	8c 93       	st	X, r24
     ba2:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     ba4:	84 e0       	ldi	r24, 0x04	; 4
     ba6:	15 96       	adiw	r26, 0x05	; 5
     ba8:	8c 93       	st	X, r24
     baa:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     bac:	e0 e0       	ldi	r30, 0x00	; 0
     bae:	f8 e0       	ldi	r31, 0x08	; 8
     bb0:	81 e0       	ldi	r24, 0x01	; 1
     bb2:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     bb4:	83 e0       	ldi	r24, 0x03	; 3
     bb6:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     bb8:	a6 a3       	std	Z+38, r26	; 0x26
     bba:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     bbc:	10 a6       	std	Z+40, r1	; 0x28
     bbe:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     bc0:	12 a6       	std	Z+42, r1	; 0x2a
     bc2:	13 a6       	std	Z+43, r1	; 0x2b
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     bc4:	81 81       	ldd	r24, Z+1	; 0x01
     bc6:	80 63       	ori	r24, 0x30	; 48
     bc8:	81 83       	std	Z+1, r24	; 0x01
=======
     ce8:	a0 e4       	ldi	r26, 0x40	; 64
     cea:	b6 e0       	ldi	r27, 0x06	; 6
     cec:	87 e0       	ldi	r24, 0x07	; 7
     cee:	11 96       	adiw	r26, 0x01	; 1
     cf0:	8c 93       	st	X, r24
     cf2:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     cf4:	84 e0       	ldi	r24, 0x04	; 4
     cf6:	15 96       	adiw	r26, 0x05	; 5
     cf8:	8c 93       	st	X, r24
     cfa:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     cfc:	e0 e0       	ldi	r30, 0x00	; 0
     cfe:	f8 e0       	ldi	r31, 0x08	; 8
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     d04:	83 e0       	ldi	r24, 0x03	; 3
     d06:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     d08:	a6 a3       	std	Z+38, r26	; 0x26
     d0a:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     d0c:	10 a6       	std	Z+40, r1	; 0x28
     d0e:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     d10:	12 a6       	std	Z+42, r1	; 0x2a
     d12:	13 a6       	std	Z+43, r1	; 0x2b
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     d14:	81 81       	ldd	r24, Z+1	; 0x01
     d16:	80 63       	ori	r24, 0x30	; 48
     d18:	81 83       	std	Z+1, r24	; 0x01
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
	while(1){
		// Increment counter for debugging
		runs++;
		
		TCC0.CCA = PWMvalue.get();
<<<<<<< HEAD
     bca:	00 e0       	ldi	r16, 0x00	; 0
     bcc:	18 e0       	ldi	r17, 0x08	; 8
=======
     d1a:	00 e0       	ldi	r16, 0x00	; 0
     d1c:	18 e0       	ldi	r17, 0x08	; 8
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
	
	while(1){
		// Increment counter for debugging
		runs++;
<<<<<<< HEAD
     bce:	f7 01       	movw	r30, r14
     bd0:	86 85       	ldd	r24, Z+14	; 0x0e
     bd2:	97 85       	ldd	r25, Z+15	; 0x0f
     bd4:	a0 89       	ldd	r26, Z+16	; 0x10
     bd6:	b1 89       	ldd	r27, Z+17	; 0x11
     bd8:	01 96       	adiw	r24, 0x01	; 1
     bda:	a1 1d       	adc	r26, r1
     bdc:	b1 1d       	adc	r27, r1
     bde:	86 87       	std	Z+14, r24	; 0x0e
     be0:	97 87       	std	Z+15, r25	; 0x0f
     be2:	a0 8b       	std	Z+16, r26	; 0x10
     be4:	b1 8b       	std	Z+17, r27	; 0x11
=======
     d1e:	f7 01       	movw	r30, r14
     d20:	86 85       	ldd	r24, Z+14	; 0x0e
     d22:	97 85       	ldd	r25, Z+15	; 0x0f
     d24:	a0 89       	ldd	r26, Z+16	; 0x10
     d26:	b1 89       	ldd	r27, Z+17	; 0x11
     d28:	01 96       	adiw	r24, 0x01	; 1
     d2a:	a1 1d       	adc	r26, r1
     d2c:	b1 1d       	adc	r27, r1
     d2e:	86 87       	std	Z+14, r24	; 0x0e
     d30:	97 87       	std	Z+15, r25	; 0x0f
     d32:	a0 8b       	std	Z+16, r26	; 0x10
     d34:	b1 8b       	std	Z+17, r27	; 0x11
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d36:	0f b6       	in	r0, 0x3f	; 63
     d38:	f8 94       	cli
     d3a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
<<<<<<< HEAD
     bec:	0f 90       	pop	r0
     bee:	0f be       	out	0x3f, r0	; 63
		
		TCC0.CCA = PWMvalue.get();
     bf0:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <PWMvalue>
     bf4:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <PWMvalue+0x1>
     bf8:	f8 01       	movw	r30, r16
     bfa:	80 a7       	std	Z+40, r24	; 0x28
     bfc:	91 a7       	std	Z+41, r25	; 0x29
		TCC0.CCB = 0;
     bfe:	12 a6       	std	Z+42, r1	; 0x2a
     c00:	13 a6       	std	Z+43, r1	; 0x2b
=======
     d3c:	0f 90       	pop	r0
     d3e:	0f be       	out	0x3f, r0	; 63
		
		TCC0.CCA = PWMvalue.get();
     d40:	80 91 6c 31 	lds	r24, 0x316C	; 0x80316c <PWMvalue>
     d44:	90 91 6d 31 	lds	r25, 0x316D	; 0x80316d <PWMvalue+0x1>
     d48:	f8 01       	movw	r30, r16
     d4a:	80 a7       	std	Z+40, r24	; 0x28
     d4c:	91 a7       	std	Z+41, r25	; 0x29
		TCC0.CCB = 0;
     d4e:	12 a6       	std	Z+42, r1	; 0x2a
     d50:	13 a6       	std	Z+43, r1	; 0x2b
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
<<<<<<< HEAD
     c02:	0f b6       	in	r0, 0x3f	; 63
     c04:	f8 94       	cli
     c06:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c08:	0f 90       	pop	r0
     c0a:	0f be       	out	0x3f, r0	; 63
=======
     d52:	0f b6       	in	r0, 0x3f	; 63
     d54:	f8 94       	cli
     d56:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		if(runs%100==0){
			*p_serial << PWMvalue.get() << endl;
		}	
		*/
		
		if (!leftLimitSwitch.get() && !rightLimitSwitch.get())
<<<<<<< HEAD
     c0c:	20 91 39 31 	lds	r18, 0x3139	; 0x803139 <leftLimitSwitch>
     c10:	21 11       	cpse	r18, r1
     c12:	12 c0       	rjmp	.+36     	; 0xc38 <_ZN9PWMdriver3runEv+0xba>
=======
     d5c:	20 91 6f 31 	lds	r18, 0x316F	; 0x80316f <leftLimitSwitch>
     d60:	21 11       	cpse	r18, r1
     d62:	12 c0       	rjmp	.+36     	; 0xd88 <_ZN9PWMdriver3runEv+0xba>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
<<<<<<< HEAD
     c14:	0f b6       	in	r0, 0x3f	; 63
     c16:	f8 94       	cli
     c18:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c1a:	0f 90       	pop	r0
     c1c:	0f be       	out	0x3f, r0	; 63
     c1e:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rightLimitSwitch>
     c22:	21 11       	cpse	r18, r1
     c24:	09 c0       	rjmp	.+18     	; 0xc38 <_ZN9PWMdriver3runEv+0xba>
=======
     d64:	0f b6       	in	r0, 0x3f	; 63
     d66:	f8 94       	cli
     d68:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d6a:	0f 90       	pop	r0
     d6c:	0f be       	out	0x3f, r0	; 63
     d6e:	20 91 6e 31 	lds	r18, 0x316E	; 0x80316e <rightLimitSwitch>
     d72:	21 11       	cpse	r18, r1
     d74:	09 c0       	rjmp	.+18     	; 0xd88 <_ZN9PWMdriver3runEv+0xba>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
<<<<<<< HEAD
     c26:	0f b6       	in	r0, 0x3f	; 63
     c28:	f8 94       	cli
     c2a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c2c:	0f 90       	pop	r0
     c2e:	0f be       	out	0x3f, r0	; 63
		{
			TCC0.CCA = PWMvalue.get();
     c30:	80 a7       	std	Z+40, r24	; 0x28
     c32:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
     c34:	12 a6       	std	Z+42, r1	; 0x2a
     c36:	13 a6       	std	Z+43, r1	; 0x2b
     c38:	44 e1       	ldi	r20, 0x14	; 20
     c3a:	50 e0       	ldi	r21, 0x00	; 0
     c3c:	60 e0       	ldi	r22, 0x00	; 0
     c3e:	70 e0       	ldi	r23, 0x00	; 0
     c40:	ce 01       	movw	r24, r28
     c42:	01 96       	adiw	r24, 0x01	; 1
     c44:	0e 94 8b 11 	call	0x2316	; 0x2316 <vTaskDelayUntil>
     c48:	c2 cf       	rjmp	.-124    	; 0xbce <_ZN9PWMdriver3runEv+0x50>

00000c4a <_ZN9PWMdriverC1EPKchjP8emstream>:
=======
     d76:	0f b6       	in	r0, 0x3f	; 63
     d78:	f8 94       	cli
     d7a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d7c:	0f 90       	pop	r0
     d7e:	0f be       	out	0x3f, r0	; 63
		{
			TCC0.CCA = PWMvalue.get();
     d80:	80 a7       	std	Z+40, r24	; 0x28
     d82:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
     d84:	12 a6       	std	Z+42, r1	; 0x2a
     d86:	13 a6       	std	Z+43, r1	; 0x2b
     d88:	44 e1       	ldi	r20, 0x14	; 20
     d8a:	50 e0       	ldi	r21, 0x00	; 0
     d8c:	60 e0       	ldi	r22, 0x00	; 0
     d8e:	70 e0       	ldi	r23, 0x00	; 0
     d90:	ce 01       	movw	r24, r28
     d92:	01 96       	adiw	r24, 0x01	; 1
     d94:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskDelayUntil>
     d98:	c2 cf       	rjmp	.-124    	; 0xd1e <_ZN9PWMdriver3runEv+0x50>

00000d9a <_ZN9PWMdriverC1EPKchjP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

PWMdriver::PWMdriver(const char* a_name,
<<<<<<< HEAD
     c4a:	0f 93       	push	r16
     c4c:	1f 93       	push	r17
     c4e:	cf 93       	push	r28
     c50:	df 93       	push	r29
     c52:	ec 01       	movw	r28, r24
=======
     d9a:	0f 93       	push	r16
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
<<<<<<< HEAD
     c54:	0e 94 28 14 	call	0x2850	; 0x2850 <_ZN8frt_taskC1EPKchjP8emstream>
     c58:	82 e2       	ldi	r24, 0x22	; 34
     c5a:	90 e2       	ldi	r25, 0x20	; 32
     c5c:	88 83       	st	Y, r24
     c5e:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     c60:	df 91       	pop	r29
     c62:	cf 91       	pop	r28
     c64:	1f 91       	pop	r17
     c66:	0f 91       	pop	r16
     c68:	08 95       	ret

00000c6a <_ZN7satmath20signed_saturated_addEii>:
=======
     da4:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     da8:	80 e5       	ldi	r24, 0x50	; 80
     daa:	90 e2       	ldi	r25, 0x20	; 32
     dac:	88 83       	st	Y, r24
     dae:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	1f 91       	pop	r17
     db6:	0f 91       	pop	r16
     db8:	08 95       	ret

00000dba <_ZN7satmath20signed_saturated_addEii>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
<<<<<<< HEAD
     c6a:	9c 01       	movw	r18, r24
     c6c:	93 2f       	mov	r25, r19
     c6e:	99 1f       	adc	r25, r25
     c70:	99 27       	eor	r25, r25
     c72:	99 1f       	adc	r25, r25
     c74:	89 2f       	mov	r24, r25
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	81 50       	subi	r24, 0x01	; 1
     c7a:	90 48       	sbci	r25, 0x80	; 128
     c7c:	43 2f       	mov	r20, r19
     c7e:	40 95       	com	r20
     c80:	44 1f       	adc	r20, r20
     c82:	44 27       	eor	r20, r20
     c84:	44 1f       	adc	r20, r20
     c86:	fc 01       	movw	r30, r24
     c88:	e2 1b       	sub	r30, r18
     c8a:	f3 0b       	sbc	r31, r19
     c8c:	51 e0       	ldi	r21, 0x01	; 1
     c8e:	e6 17       	cp	r30, r22
     c90:	f7 07       	cpc	r31, r23
     c92:	0c f0       	brlt	.+2      	; 0xc96 <_ZN7satmath20signed_saturated_addEii+0x2c>
     c94:	50 e0       	ldi	r21, 0x00	; 0
     c96:	45 17       	cp	r20, r21
     c98:	19 f0       	breq	.+6      	; 0xca0 <_ZN7satmath20signed_saturated_addEii+0x36>
     c9a:	c9 01       	movw	r24, r18
     c9c:	86 0f       	add	r24, r22
     c9e:	97 1f       	adc	r25, r23
     ca0:	08 95       	ret

00000ca2 <_ZN7satmath20signed_saturated_mulEii>:
=======
     dba:	9c 01       	movw	r18, r24
     dbc:	93 2f       	mov	r25, r19
     dbe:	99 1f       	adc	r25, r25
     dc0:	99 27       	eor	r25, r25
     dc2:	99 1f       	adc	r25, r25
     dc4:	89 2f       	mov	r24, r25
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	81 50       	subi	r24, 0x01	; 1
     dca:	90 48       	sbci	r25, 0x80	; 128
     dcc:	43 2f       	mov	r20, r19
     dce:	40 95       	com	r20
     dd0:	44 1f       	adc	r20, r20
     dd2:	44 27       	eor	r20, r20
     dd4:	44 1f       	adc	r20, r20
     dd6:	fc 01       	movw	r30, r24
     dd8:	e2 1b       	sub	r30, r18
     dda:	f3 0b       	sbc	r31, r19
     ddc:	51 e0       	ldi	r21, 0x01	; 1
     dde:	e6 17       	cp	r30, r22
     de0:	f7 07       	cpc	r31, r23
     de2:	0c f0       	brlt	.+2      	; 0xde6 <_ZN7satmath20signed_saturated_addEii+0x2c>
     de4:	50 e0       	ldi	r21, 0x00	; 0
     de6:	45 17       	cp	r20, r21
     de8:	19 f0       	breq	.+6      	; 0xdf0 <_ZN7satmath20signed_saturated_addEii+0x36>
     dea:	c9 01       	movw	r24, r18
     dec:	86 0f       	add	r24, r22
     dee:	97 1f       	adc	r25, r23
     df0:	08 95       	ret

00000df2 <_ZN7satmath20signed_saturated_mulEii>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
<<<<<<< HEAD
     ca2:	81 15       	cp	r24, r1
     ca4:	20 e8       	ldi	r18, 0x80	; 128
     ca6:	92 07       	cpc	r25, r18
     ca8:	21 f4       	brne	.+8      	; 0xcb2 <_ZN7satmath20signed_saturated_mulEii+0x10>
     caa:	61 15       	cp	r22, r1
     cac:	20 e8       	ldi	r18, 0x80	; 128
     cae:	72 07       	cpc	r23, r18
     cb0:	29 f0       	breq	.+10     	; 0xcbc <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     cb2:	9c 01       	movw	r18, r24
     cb4:	db 01       	movw	r26, r22
     cb6:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <__mulhisi3>
     cba:	08 95       	ret
=======
     df2:	81 15       	cp	r24, r1
     df4:	20 e8       	ldi	r18, 0x80	; 128
     df6:	92 07       	cpc	r25, r18
     df8:	21 f4       	brne	.+8      	; 0xe02 <_ZN7satmath20signed_saturated_mulEii+0x10>
     dfa:	61 15       	cp	r22, r1
     dfc:	20 e8       	ldi	r18, 0x80	; 128
     dfe:	72 07       	cpc	r23, r18
     e00:	29 f0       	breq	.+10     	; 0xe0c <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     e02:	9c 01       	movw	r18, r24
     e04:	db 01       	movw	r26, r22
     e06:	0e 94 1b 20 	call	0x4036	; 0x4036 <__mulhisi3>
     e0a:	08 95       	ret
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
<<<<<<< HEAD
     cbc:	6f ef       	ldi	r22, 0xFF	; 255
     cbe:	7f ef       	ldi	r23, 0xFF	; 255
     cc0:	8f ef       	ldi	r24, 0xFF	; 255
     cc2:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     cc4:	08 95       	ret

00000cc6 <_ZN9task_userC1EPKchjP8emstream>:
=======
     e0c:	6f ef       	ldi	r22, 0xFF	; 255
     e0e:	7f ef       	ldi	r23, 0xFF	; 255
     e10:	8f ef       	ldi	r24, 0xFF	; 255
     e12:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     e14:	08 95       	ret

00000e16 <_ZN9task_userC1EPKchjP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
<<<<<<< HEAD
     cc6:	0f 93       	push	r16
     cc8:	1f 93       	push	r17
     cca:	cf 93       	push	r28
     ccc:	df 93       	push	r29
     cce:	ec 01       	movw	r28, r24
=======
     e16:	0f 93       	push	r16
     e18:	1f 93       	push	r17
     e1a:	cf 93       	push	r28
     e1c:	df 93       	push	r29
     e1e:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
<<<<<<< HEAD
     cd0:	0e 94 28 14 	call	0x2850	; 0x2850 <_ZN8frt_taskC1EPKchjP8emstream>
     cd4:	8a e2       	ldi	r24, 0x2A	; 42
     cd6:	90 e2       	ldi	r25, 0x20	; 32
     cd8:	88 83       	st	Y, r24
     cda:	99 83       	std	Y+1, r25	; 0x01
=======
     e20:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <_ZN8frt_taskC1EPKchjP8emstream>
     e24:	88 e5       	ldi	r24, 0x58	; 88
     e26:	90 e2       	ldi	r25, 0x20	; 32
     e28:	88 83       	st	Y, r24
     e2a:	99 83       	std	Y+1, r25	; 0x01
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
<<<<<<< HEAD
     cdc:	df 91       	pop	r29
     cde:	cf 91       	pop	r28
     ce0:	1f 91       	pop	r17
     ce2:	0f 91       	pop	r16
     ce4:	08 95       	ret

00000ce6 <_ZN9task_user18print_help_messageEv>:
=======
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <_ZN9task_user18print_help_messageEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
<<<<<<< HEAD
     ce6:	0f 93       	push	r16
     ce8:	1f 93       	push	r17
     cea:	cf 93       	push	r28
     cec:	df 93       	push	r29
     cee:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     cf0:	6a e0       	ldi	r22, 0x0A	; 10
     cf2:	8e 81       	ldd	r24, Y+6	; 0x06
     cf4:	9f 81       	ldd	r25, Y+7	; 0x07
     cf6:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     cfa:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     cfc:	69 ee       	ldi	r22, 0xE9	; 233
     cfe:	73 e0       	ldi	r23, 0x03	; 3
     d00:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     d04:	6a e0       	ldi	r22, 0x0A	; 10
     d06:	c8 01       	movw	r24, r16
     d08:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     d0c:	8c 01       	movw	r16, r24
     d0e:	63 ee       	ldi	r22, 0xE3	; 227
     d10:	73 e0       	ldi	r23, 0x03	; 3
     d12:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     d16:	67 e0       	ldi	r22, 0x07	; 7
     d18:	c8 01       	movw	r24, r16
     d1a:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     d1e:	6a e0       	ldi	r22, 0x0A	; 10
     d20:	8e 81       	ldd	r24, Y+6	; 0x06
     d22:	9f 81       	ldd	r25, Y+7	; 0x07
     d24:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     d28:	8c 01       	movw	r16, r24
     d2a:	64 ec       	ldi	r22, 0xC4	; 196
     d2c:	73 e0       	ldi	r23, 0x03	; 3
     d2e:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     d32:	6a e0       	ldi	r22, 0x0A	; 10
     d34:	c8 01       	movw	r24, r16
     d36:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     d3a:	8c 01       	movw	r16, r24
     d3c:	6e eb       	ldi	r22, 0xBE	; 190
     d3e:	73 e0       	ldi	r23, 0x03	; 3
     d40:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     d44:	66 e0       	ldi	r22, 0x06	; 6
     d46:	c8 01       	movw	r24, r16
     d48:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     d4c:	6a e0       	ldi	r22, 0x0A	; 10
     d4e:	8e 81       	ldd	r24, Y+6	; 0x06
     d50:	9f 81       	ldd	r25, Y+7	; 0x07
     d52:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     d56:	8c 01       	movw	r16, r24
     d58:	67 ea       	ldi	r22, 0xA7	; 167
     d5a:	73 e0       	ldi	r23, 0x03	; 3
     d5c:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     d60:	66 e0       	ldi	r22, 0x06	; 6
     d62:	c8 01       	movw	r24, r16
     d64:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     d68:	6a e0       	ldi	r22, 0x0A	; 10
     d6a:	8e 81       	ldd	r24, Y+6	; 0x06
     d6c:	9f 81       	ldd	r25, Y+7	; 0x07
     d6e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     d72:	8c 01       	movw	r16, r24
     d74:	6b e8       	ldi	r22, 0x8B	; 139
     d76:	73 e0       	ldi	r23, 0x03	; 3
     d78:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     d7c:	66 e0       	ldi	r22, 0x06	; 6
     d7e:	c8 01       	movw	r24, r16
     d80:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     d84:	6a e0       	ldi	r22, 0x0A	; 10
     d86:	8e 81       	ldd	r24, Y+6	; 0x06
     d88:	9f 81       	ldd	r25, Y+7	; 0x07
     d8a:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     d8e:	8c 01       	movw	r16, r24
     d90:	63 e7       	ldi	r22, 0x73	; 115
     d92:	73 e0       	ldi	r23, 0x03	; 3
     d94:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     d98:	66 e0       	ldi	r22, 0x06	; 6
     d9a:	c8 01       	movw	r24, r16
     d9c:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     da0:	6a e0       	ldi	r22, 0x0A	; 10
     da2:	8e 81       	ldd	r24, Y+6	; 0x06
     da4:	9f 81       	ldd	r25, Y+7	; 0x07
     da6:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     daa:	8c 01       	movw	r16, r24
     dac:	62 e5       	ldi	r22, 0x52	; 82
     dae:	73 e0       	ldi	r23, 0x03	; 3
     db0:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     db4:	66 e0       	ldi	r22, 0x06	; 6
     db6:	c8 01       	movw	r24, r16
     db8:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     dbc:	6a e0       	ldi	r22, 0x0A	; 10
     dbe:	8e 81       	ldd	r24, Y+6	; 0x06
     dc0:	9f 81       	ldd	r25, Y+7	; 0x07
     dc2:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     dc6:	8c 01       	movw	r16, r24
     dc8:	6b e2       	ldi	r22, 0x2B	; 43
     dca:	73 e0       	ldi	r23, 0x03	; 3
     dcc:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     dd0:	66 e0       	ldi	r22, 0x06	; 6
     dd2:	c8 01       	movw	r24, r16
     dd4:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     dd8:	6a e0       	ldi	r22, 0x0A	; 10
     dda:	8e 81       	ldd	r24, Y+6	; 0x06
     ddc:	9f 81       	ldd	r25, Y+7	; 0x07
     dde:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     de2:	8c 01       	movw	r16, r24
     de4:	6d e0       	ldi	r22, 0x0D	; 13
     de6:	73 e0       	ldi	r23, 0x03	; 3
     de8:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     dec:	66 e0       	ldi	r22, 0x06	; 6
     dee:	c8 01       	movw	r24, r16
     df0:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     df4:	6a e0       	ldi	r22, 0x0A	; 10
     df6:	8e 81       	ldd	r24, Y+6	; 0x06
     df8:	9f 81       	ldd	r25, Y+7	; 0x07
     dfa:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     dfe:	8c 01       	movw	r16, r24
     e00:	62 ef       	ldi	r22, 0xF2	; 242
     e02:	72 e0       	ldi	r23, 0x02	; 2
     e04:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     e08:	66 e0       	ldi	r22, 0x06	; 6
     e0a:	c8 01       	movw	r24, r16
     e0c:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     e10:	6a e0       	ldi	r22, 0x0A	; 10
     e12:	8e 81       	ldd	r24, Y+6	; 0x06
     e14:	9f 81       	ldd	r25, Y+7	; 0x07
     e16:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     e1a:	ec 01       	movw	r28, r24
     e1c:	63 ee       	ldi	r22, 0xE3	; 227
     e1e:	72 e0       	ldi	r23, 0x02	; 2
     e20:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     e24:	66 e0       	ldi	r22, 0x06	; 6
     e26:	ce 01       	movw	r24, r28
     e28:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <_ZN9task_user11show_statusEv>:
=======
     e36:	0f 93       	push	r16
     e38:	1f 93       	push	r17
     e3a:	cf 93       	push	r28
     e3c:	df 93       	push	r29
     e3e:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     e40:	6a e0       	ldi	r22, 0x0A	; 10
     e42:	8e 81       	ldd	r24, Y+6	; 0x06
     e44:	9f 81       	ldd	r25, Y+7	; 0x07
     e46:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     e4a:	8c 01       	movw	r16, r24
     e4c:	6d ee       	ldi	r22, 0xED	; 237
     e4e:	73 e0       	ldi	r23, 0x03	; 3
     e50:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     e54:	6a e0       	ldi	r22, 0x0A	; 10
     e56:	c8 01       	movw	r24, r16
     e58:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     e5c:	8c 01       	movw	r16, r24
     e5e:	67 ee       	ldi	r22, 0xE7	; 231
     e60:	73 e0       	ldi	r23, 0x03	; 3
     e62:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     e66:	67 e0       	ldi	r22, 0x07	; 7
     e68:	c8 01       	movw	r24, r16
     e6a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     e6e:	6a e0       	ldi	r22, 0x0A	; 10
     e70:	8e 81       	ldd	r24, Y+6	; 0x06
     e72:	9f 81       	ldd	r25, Y+7	; 0x07
     e74:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     e78:	8c 01       	movw	r16, r24
     e7a:	68 ec       	ldi	r22, 0xC8	; 200
     e7c:	73 e0       	ldi	r23, 0x03	; 3
     e7e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     e82:	6a e0       	ldi	r22, 0x0A	; 10
     e84:	c8 01       	movw	r24, r16
     e86:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     e8a:	8c 01       	movw	r16, r24
     e8c:	62 ec       	ldi	r22, 0xC2	; 194
     e8e:	73 e0       	ldi	r23, 0x03	; 3
     e90:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     e94:	66 e0       	ldi	r22, 0x06	; 6
     e96:	c8 01       	movw	r24, r16
     e98:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e9c:	6a e0       	ldi	r22, 0x0A	; 10
     e9e:	8e 81       	ldd	r24, Y+6	; 0x06
     ea0:	9f 81       	ldd	r25, Y+7	; 0x07
     ea2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     ea6:	8c 01       	movw	r16, r24
     ea8:	6b ea       	ldi	r22, 0xAB	; 171
     eaa:	73 e0       	ldi	r23, 0x03	; 3
     eac:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     eb0:	66 e0       	ldi	r22, 0x06	; 6
     eb2:	c8 01       	movw	r24, r16
     eb4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     eb8:	6a e0       	ldi	r22, 0x0A	; 10
     eba:	8e 81       	ldd	r24, Y+6	; 0x06
     ebc:	9f 81       	ldd	r25, Y+7	; 0x07
     ebe:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     ec2:	8c 01       	movw	r16, r24
     ec4:	6f e8       	ldi	r22, 0x8F	; 143
     ec6:	73 e0       	ldi	r23, 0x03	; 3
     ec8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     ecc:	66 e0       	ldi	r22, 0x06	; 6
     ece:	c8 01       	movw	r24, r16
     ed0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     ed4:	6a e0       	ldi	r22, 0x0A	; 10
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	9f 81       	ldd	r25, Y+7	; 0x07
     eda:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     ede:	8c 01       	movw	r16, r24
     ee0:	67 e7       	ldi	r22, 0x77	; 119
     ee2:	73 e0       	ldi	r23, 0x03	; 3
     ee4:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     ee8:	66 e0       	ldi	r22, 0x06	; 6
     eea:	c8 01       	movw	r24, r16
     eec:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     ef0:	6a e0       	ldi	r22, 0x0A	; 10
     ef2:	8e 81       	ldd	r24, Y+6	; 0x06
     ef4:	9f 81       	ldd	r25, Y+7	; 0x07
     ef6:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     efa:	8c 01       	movw	r16, r24
     efc:	66 e5       	ldi	r22, 0x56	; 86
     efe:	73 e0       	ldi	r23, 0x03	; 3
     f00:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f04:	66 e0       	ldi	r22, 0x06	; 6
     f06:	c8 01       	movw	r24, r16
     f08:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     f0c:	6a e0       	ldi	r22, 0x0A	; 10
     f0e:	8e 81       	ldd	r24, Y+6	; 0x06
     f10:	9f 81       	ldd	r25, Y+7	; 0x07
     f12:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     f16:	8c 01       	movw	r16, r24
     f18:	6f e2       	ldi	r22, 0x2F	; 47
     f1a:	73 e0       	ldi	r23, 0x03	; 3
     f1c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f20:	66 e0       	ldi	r22, 0x06	; 6
     f22:	c8 01       	movw	r24, r16
     f24:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     f28:	6a e0       	ldi	r22, 0x0A	; 10
     f2a:	8e 81       	ldd	r24, Y+6	; 0x06
     f2c:	9f 81       	ldd	r25, Y+7	; 0x07
     f2e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     f32:	8c 01       	movw	r16, r24
     f34:	61 e1       	ldi	r22, 0x11	; 17
     f36:	73 e0       	ldi	r23, 0x03	; 3
     f38:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f3c:	66 e0       	ldi	r22, 0x06	; 6
     f3e:	c8 01       	movw	r24, r16
     f40:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     f44:	6a e0       	ldi	r22, 0x0A	; 10
     f46:	8e 81       	ldd	r24, Y+6	; 0x06
     f48:	9f 81       	ldd	r25, Y+7	; 0x07
     f4a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     f4e:	8c 01       	movw	r16, r24
     f50:	66 ef       	ldi	r22, 0xF6	; 246
     f52:	72 e0       	ldi	r23, 0x02	; 2
     f54:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f58:	66 e0       	ldi	r22, 0x06	; 6
     f5a:	c8 01       	movw	r24, r16
     f5c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     f60:	6a e0       	ldi	r22, 0x0A	; 10
     f62:	8e 81       	ldd	r24, Y+6	; 0x06
     f64:	9f 81       	ldd	r25, Y+7	; 0x07
     f66:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     f6a:	ec 01       	movw	r28, r24
     f6c:	67 ee       	ldi	r22, 0xE7	; 231
     f6e:	72 e0       	ldi	r23, 0x02	; 2
     f70:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     f74:	66 e0       	ldi	r22, 0x06	; 6
     f76:	ce 01       	movw	r24, r28
     f78:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
}
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	1f 91       	pop	r17
     f82:	0f 91       	pop	r16
     f84:	08 95       	ret

00000f86 <_ZN9task_user11show_statusEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
<<<<<<< HEAD
     e36:	af 92       	push	r10
     e38:	bf 92       	push	r11
     e3a:	cf 92       	push	r12
     e3c:	df 92       	push	r13
     e3e:	ef 92       	push	r14
     e40:	ff 92       	push	r15
     e42:	0f 93       	push	r16
     e44:	1f 93       	push	r17
     e46:	cf 93       	push	r28
     e48:	df 93       	push	r29
     e4a:	00 d0       	rcall	.+0      	; 0xe4c <_ZN9task_user11show_statusEv+0x16>
     e4c:	00 d0       	rcall	.+0      	; 0xe4e <_ZN9task_user11show_statusEv+0x18>
     e4e:	cd b7       	in	r28, 0x3d	; 61
     e50:	de b7       	in	r29, 0x3e	; 62
     e52:	8c 01       	movw	r16, r24
=======
     f86:	af 92       	push	r10
     f88:	bf 92       	push	r11
     f8a:	cf 92       	push	r12
     f8c:	df 92       	push	r13
     f8e:	ef 92       	push	r14
     f90:	ff 92       	push	r15
     f92:	0f 93       	push	r16
     f94:	1f 93       	push	r17
     f96:	cf 93       	push	r28
     f98:	df 93       	push	r29
     f9a:	00 d0       	rcall	.+0      	; 0xf9c <_ZN9task_user11show_statusEv+0x16>
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <_ZN9task_user11show_statusEv+0x18>
     f9e:	cd b7       	in	r28, 0x3d	; 61
     fa0:	de b7       	in	r29, 0x3e	; 62
     fa2:	8c 01       	movw	r16, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
<<<<<<< HEAD
     e54:	19 82       	std	Y+1, r1	; 0x01
     e56:	1a 82       	std	Y+2, r1	; 0x02
     e58:	1b 82       	std	Y+3, r1	; 0x03
     e5a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     e5c:	1d 82       	std	Y+5, r1	; 0x05
     e5e:	1e 82       	std	Y+6, r1	; 0x06
=======
     fa4:	19 82       	std	Y+1, r1	; 0x01
     fa6:	1a 82       	std	Y+2, r1	; 0x02
     fa8:	1b 82       	std	Y+3, r1	; 0x03
     faa:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     fac:	1d 82       	std	Y+5, r1	; 0x05
     fae:	1e 82       	std	Y+6, r1	; 0x06
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
<<<<<<< HEAD
     e60:	0e 94 a0 09 	call	0x1340	; 0x1340 <xPortGetFreeHeapSize>
     e64:	6c 01       	movw	r12, r24
=======
     fb0:	0e 94 48 0a 	call	0x1490	; 0x1490 <xPortGetFreeHeapSize>
     fb4:	6c 01       	movw	r12, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
<<<<<<< HEAD
     e66:	ce 01       	movw	r24, r28
     e68:	01 96       	adiw	r24, 0x01	; 1
     e6a:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN10time_stamp10set_to_nowEv>
     e6e:	5c 01       	movw	r10, r24
=======
     fb6:	ce 01       	movw	r24, r28
     fb8:	01 96       	adiw	r24, 0x01	; 1
     fba:	0e 94 81 18 	call	0x3102	; 0x3102 <_ZN10time_stamp10set_to_nowEv>
     fbe:	5c 01       	movw	r10, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
<<<<<<< HEAD
     e70:	66 e0       	ldi	r22, 0x06	; 6
     e72:	f8 01       	movw	r30, r16
     e74:	86 81       	ldd	r24, Z+6	; 0x06
     e76:	97 81       	ldd	r25, Z+7	; 0x07
     e78:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     e7c:	6a e0       	ldi	r22, 0x0A	; 10
     e7e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     e82:	7c 01       	movw	r14, r24
     e84:	64 ec       	ldi	r22, 0xC4	; 196
     e86:	72 e0       	ldi	r23, 0x02	; 2
     e88:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     e8c:	6a e0       	ldi	r22, 0x0A	; 10
     e8e:	c7 01       	movw	r24, r14
     e90:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     e94:	7c 01       	movw	r14, r24
     e96:	68 eb       	ldi	r22, 0xB8	; 184
     e98:	72 e0       	ldi	r23, 0x02	; 2
     e9a:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     e9e:	66 e0       	ldi	r22, 0x06	; 6
     ea0:	c7 01       	movw	r24, r14
     ea2:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     ea6:	6a e0       	ldi	r22, 0x0A	; 10
     ea8:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     eac:	7c 01       	movw	r14, r24
     eae:	61 eb       	ldi	r22, 0xB1	; 177
     eb0:	72 e0       	ldi	r23, 0x02	; 2
     eb2:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     eb6:	b5 01       	movw	r22, r10
     eb8:	c7 01       	movw	r24, r14
     eba:	0e 94 7d 17 	call	0x2efa	; 0x2efa <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     ebe:	6a e0       	ldi	r22, 0x0A	; 10
     ec0:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     ec4:	7c 01       	movw	r14, r24
     ec6:	63 ea       	ldi	r22, 0xA3	; 163
     ec8:	72 e0       	ldi	r23, 0x02	; 2
     eca:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     ece:	b6 01       	movw	r22, r12
     ed0:	c7 01       	movw	r24, r14
     ed2:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsEj>
     ed6:	6a e0       	ldi	r22, 0x0A	; 10
     ed8:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     edc:	7c 01       	movw	r14, r24
     ede:	61 ea       	ldi	r22, 0xA1	; 161
     ee0:	72 e0       	ldi	r23, 0x02	; 2
     ee2:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     ee6:	4f ef       	ldi	r20, 0xFF	; 255
     ee8:	5f e0       	ldi	r21, 0x0F	; 15
     eea:	60 e0       	ldi	r22, 0x00	; 0
     eec:	70 e0       	ldi	r23, 0x00	; 0
     eee:	c7 01       	movw	r24, r14
     ef0:	0e 94 31 1a 	call	0x3462	; 0x3462 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     ef4:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     ef8:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     efc:	6a e0       	ldi	r22, 0x0A	; 10
     efe:	f8 01       	movw	r30, r16
     f00:	86 81       	ldd	r24, Z+6	; 0x06
     f02:	97 81       	ldd	r25, Z+7	; 0x07
     f04:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     f08:	7c 01       	movw	r14, r24
     f0a:	66 e9       	ldi	r22, 0x96	; 150
     f0c:	72 e0       	ldi	r23, 0x02	; 2
     f0e:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     f12:	b6 01       	movw	r22, r12
     f14:	c7 01       	movw	r24, r14
     f16:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsEj>
     f1a:	66 e0       	ldi	r22, 0x06	; 6
     f1c:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     f20:	66 e0       	ldi	r22, 0x06	; 6
     f22:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     f26:	f8 01       	movw	r30, r16
     f28:	86 81       	ldd	r24, Z+6	; 0x06
     f2a:	97 81       	ldd	r25, Z+7	; 0x07
     f2c:	0e 94 36 16 	call	0x2c6c	; 0x2c6c <_Z15print_task_listP8emstream>
}
     f30:	26 96       	adiw	r28, 0x06	; 6
     f32:	cd bf       	out	0x3d, r28	; 61
     f34:	de bf       	out	0x3e, r29	; 62
     f36:	df 91       	pop	r29
     f38:	cf 91       	pop	r28
     f3a:	1f 91       	pop	r17
     f3c:	0f 91       	pop	r16
     f3e:	ff 90       	pop	r15
     f40:	ef 90       	pop	r14
     f42:	df 90       	pop	r13
     f44:	cf 90       	pop	r12
     f46:	bf 90       	pop	r11
     f48:	af 90       	pop	r10
     f4a:	08 95       	ret

00000f4c <_ZN9task_user3runEv>:
=======
     fc0:	66 e0       	ldi	r22, 0x06	; 6
     fc2:	f8 01       	movw	r30, r16
     fc4:	86 81       	ldd	r24, Z+6	; 0x06
     fc6:	97 81       	ldd	r25, Z+7	; 0x07
     fc8:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     fcc:	6a e0       	ldi	r22, 0x0A	; 10
     fce:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     fd2:	7c 01       	movw	r14, r24
     fd4:	68 ec       	ldi	r22, 0xC8	; 200
     fd6:	72 e0       	ldi	r23, 0x02	; 2
     fd8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     fdc:	6a e0       	ldi	r22, 0x0A	; 10
     fde:	c7 01       	movw	r24, r14
     fe0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     fe4:	7c 01       	movw	r14, r24
     fe6:	6c eb       	ldi	r22, 0xBC	; 188
     fe8:	72 e0       	ldi	r23, 0x02	; 2
     fea:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
     fee:	66 e0       	ldi	r22, 0x06	; 6
     ff0:	c7 01       	movw	r24, r14
     ff2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     ff6:	6a e0       	ldi	r22, 0x0A	; 10
     ff8:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
     ffc:	7c 01       	movw	r14, r24
     ffe:	65 eb       	ldi	r22, 0xB5	; 181
    1000:	72 e0       	ldi	r23, 0x02	; 2
    1002:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    1006:	b5 01       	movw	r22, r10
    1008:	c7 01       	movw	r24, r14
    100a:	0e 94 25 18 	call	0x304a	; 0x304a <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    100e:	6a e0       	ldi	r22, 0x0A	; 10
    1010:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1014:	7c 01       	movw	r14, r24
    1016:	67 ea       	ldi	r22, 0xA7	; 167
    1018:	72 e0       	ldi	r23, 0x02	; 2
    101a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    101e:	b6 01       	movw	r22, r12
    1020:	c7 01       	movw	r24, r14
    1022:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    1026:	6a e0       	ldi	r22, 0x0A	; 10
    1028:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    102c:	7c 01       	movw	r14, r24
    102e:	65 ea       	ldi	r22, 0xA5	; 165
    1030:	72 e0       	ldi	r23, 0x02	; 2
    1032:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1036:	4f ef       	ldi	r20, 0xFF	; 255
    1038:	5f e0       	ldi	r21, 0x0F	; 15
    103a:	60 e0       	ldi	r22, 0x00	; 0
    103c:	70 e0       	ldi	r23, 0x00	; 0
    103e:	c7 01       	movw	r24, r14
    1040:	0e 94 04 1b 	call	0x3608	; 0x3608 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1044:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1048:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    104c:	6a e0       	ldi	r22, 0x0A	; 10
    104e:	f8 01       	movw	r30, r16
    1050:	86 81       	ldd	r24, Z+6	; 0x06
    1052:	97 81       	ldd	r25, Z+7	; 0x07
    1054:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1058:	7c 01       	movw	r14, r24
    105a:	6a e9       	ldi	r22, 0x9A	; 154
    105c:	72 e0       	ldi	r23, 0x02	; 2
    105e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    1062:	b6 01       	movw	r22, r12
    1064:	c7 01       	movw	r24, r14
    1066:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    106a:	66 e0       	ldi	r22, 0x06	; 6
    106c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1070:	66 e0       	ldi	r22, 0x06	; 6
    1072:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1076:	f8 01       	movw	r30, r16
    1078:	86 81       	ldd	r24, Z+6	; 0x06
    107a:	97 81       	ldd	r25, Z+7	; 0x07
    107c:	0e 94 de 16 	call	0x2dbc	; 0x2dbc <_Z15print_task_listP8emstream>
}
    1080:	26 96       	adiw	r28, 0x06	; 6
    1082:	cd bf       	out	0x3d, r28	; 61
    1084:	de bf       	out	0x3e, r29	; 62
    1086:	df 91       	pop	r29
    1088:	cf 91       	pop	r28
    108a:	1f 91       	pop	r17
    108c:	0f 91       	pop	r16
    108e:	ff 90       	pop	r15
    1090:	ef 90       	pop	r14
    1092:	df 90       	pop	r13
    1094:	cf 90       	pop	r12
    1096:	bf 90       	pop	r11
    1098:	af 90       	pop	r10
    109a:	08 95       	ret

0000109c <_ZN9task_user3runEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
<<<<<<< HEAD
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	00 d0       	rcall	.+0      	; 0xf52 <_ZN9task_user3runEv+0x6>
     f52:	00 d0       	rcall	.+0      	; 0xf54 <_ZN9task_user3runEv+0x8>
     f54:	cd b7       	in	r28, 0x3d	; 61
     f56:	de b7       	in	r29, 0x3e	; 62
     f58:	8c 01       	movw	r16, r24
=======
    109c:	cf 93       	push	r28
    109e:	df 93       	push	r29
    10a0:	00 d0       	rcall	.+0      	; 0x10a2 <_ZN9task_user3runEv+0x6>
    10a2:	00 d0       	rcall	.+0      	; 0x10a4 <_ZN9task_user3runEv+0x8>
    10a4:	cd b7       	in	r28, 0x3d	; 61
    10a6:	de b7       	in	r29, 0x3e	; 62
    10a8:	8c 01       	movw	r16, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
<<<<<<< HEAD
     f5a:	19 82       	std	Y+1, r1	; 0x01
     f5c:	1a 82       	std	Y+2, r1	; 0x02
     f5e:	1b 82       	std	Y+3, r1	; 0x03
     f60:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f62:	1d 82       	std	Y+5, r1	; 0x05
     f64:	1e 82       	std	Y+6, r1	; 0x06
=======
    10aa:	19 82       	std	Y+1, r1	; 0x01
    10ac:	1a 82       	std	Y+2, r1	; 0x02
    10ae:	1b 82       	std	Y+3, r1	; 0x03
    10b0:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    10b2:	1d 82       	std	Y+5, r1	; 0x05
    10b4:	1e 82       	std	Y+6, r1	; 0x06
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
<<<<<<< HEAD
     f66:	6a e0       	ldi	r22, 0x0A	; 10
     f68:	dc 01       	movw	r26, r24
     f6a:	16 96       	adiw	r26, 0x06	; 6
     f6c:	8d 91       	ld	r24, X+
     f6e:	9c 91       	ld	r25, X
     f70:	17 97       	sbiw	r26, 0x07	; 7
     f72:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     f76:	7c 01       	movw	r14, r24
     f78:	62 e3       	ldi	r22, 0x32	; 50
     f7a:	74 e0       	ldi	r23, 0x04	; 4
     f7c:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     f80:	66 e0       	ldi	r22, 0x06	; 6
     f82:	c7 01       	movw	r24, r14
     f84:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
=======
    10b6:	6a e0       	ldi	r22, 0x0A	; 10
    10b8:	dc 01       	movw	r26, r24
    10ba:	16 96       	adiw	r26, 0x06	; 6
    10bc:	8d 91       	ld	r24, X+
    10be:	9c 91       	ld	r25, X
    10c0:	17 97       	sbiw	r26, 0x07	; 7
    10c2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    10c6:	7c 01       	movw	r14, r24
    10c8:	66 e3       	ldi	r22, 0x36	; 54
    10ca:	74 e0       	ldi	r23, 0x04	; 4
    10cc:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    10d0:	66 e0       	ldi	r22, 0x06	; 6
    10d2:	c7 01       	movw	r24, r14
    10d4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
<<<<<<< HEAD
     f88:	f8 01       	movw	r30, r16
     f8a:	84 85       	ldd	r24, Z+12	; 0x0c
     f8c:	88 23       	and	r24, r24
     f8e:	21 f0       	breq	.+8      	; 0xf98 <_ZN9task_user3runEv+0x4c>
     f90:	81 30       	cpi	r24, 0x01	; 1
     f92:	09 f4       	brne	.+2      	; 0xf96 <_ZN9task_user3runEv+0x4a>
     f94:	5d c0       	rjmp	.+186    	; 0x1050 <_ZN9task_user3runEv+0x104>
     f96:	d8 c0       	rjmp	.+432    	; 0x1148 <_ZN9task_user3runEv+0x1fc>
=======
    10d8:	f8 01       	movw	r30, r16
    10da:	84 85       	ldd	r24, Z+12	; 0x0c
    10dc:	88 23       	and	r24, r24
    10de:	21 f0       	breq	.+8      	; 0x10e8 <_ZN9task_user3runEv+0x4c>
    10e0:	81 30       	cpi	r24, 0x01	; 1
    10e2:	09 f4       	brne	.+2      	; 0x10e6 <_ZN9task_user3runEv+0x4a>
    10e4:	5d c0       	rjmp	.+186    	; 0x11a0 <_ZN9task_user3runEv+0x104>
    10e6:	d8 c0       	rjmp	.+432    	; 0x1298 <_ZN9task_user3runEv+0x1fc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
<<<<<<< HEAD
     f98:	86 81       	ldd	r24, Z+6	; 0x06
     f9a:	97 81       	ldd	r25, Z+7	; 0x07
     f9c:	dc 01       	movw	r26, r24
     f9e:	ed 91       	ld	r30, X+
     fa0:	fc 91       	ld	r31, X
     fa2:	04 80       	ldd	r0, Z+4	; 0x04
     fa4:	f5 81       	ldd	r31, Z+5	; 0x05
     fa6:	e0 2d       	mov	r30, r0
     fa8:	19 95       	eicall
     faa:	88 23       	and	r24, r24
     fac:	a9 f1       	breq	.+106    	; 0x1018 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     fae:	f8 01       	movw	r30, r16
     fb0:	86 81       	ldd	r24, Z+6	; 0x06
     fb2:	97 81       	ldd	r25, Z+7	; 0x07
     fb4:	dc 01       	movw	r26, r24
     fb6:	ed 91       	ld	r30, X+
     fb8:	fc 91       	ld	r31, X
     fba:	06 80       	ldd	r0, Z+6	; 0x06
     fbc:	f7 81       	ldd	r31, Z+7	; 0x07
     fbe:	e0 2d       	mov	r30, r0
     fc0:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     fc2:	99 27       	eor	r25, r25
     fc4:	81 30       	cpi	r24, 0x01	; 1
     fc6:	91 05       	cpc	r25, r1
     fc8:	f9 f0       	breq	.+62     	; 0x1008 <_ZN9task_user3runEv+0xbc>
     fca:	03 97       	sbiw	r24, 0x03	; 3
     fcc:	09 f0       	breq	.+2      	; 0xfd0 <_ZN9task_user3runEv+0x84>
     fce:	d8 c0       	rjmp	.+432    	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    10e8:	86 81       	ldd	r24, Z+6	; 0x06
    10ea:	97 81       	ldd	r25, Z+7	; 0x07
    10ec:	dc 01       	movw	r26, r24
    10ee:	ed 91       	ld	r30, X+
    10f0:	fc 91       	ld	r31, X
    10f2:	04 80       	ldd	r0, Z+4	; 0x04
    10f4:	f5 81       	ldd	r31, Z+5	; 0x05
    10f6:	e0 2d       	mov	r30, r0
    10f8:	19 95       	eicall
    10fa:	88 23       	and	r24, r24
    10fc:	a9 f1       	breq	.+106    	; 0x1168 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    10fe:	f8 01       	movw	r30, r16
    1100:	86 81       	ldd	r24, Z+6	; 0x06
    1102:	97 81       	ldd	r25, Z+7	; 0x07
    1104:	dc 01       	movw	r26, r24
    1106:	ed 91       	ld	r30, X+
    1108:	fc 91       	ld	r31, X
    110a:	06 80       	ldd	r0, Z+6	; 0x06
    110c:	f7 81       	ldd	r31, Z+7	; 0x07
    110e:	e0 2d       	mov	r30, r0
    1110:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1112:	99 27       	eor	r25, r25
    1114:	81 30       	cpi	r24, 0x01	; 1
    1116:	91 05       	cpc	r25, r1
    1118:	f9 f0       	breq	.+62     	; 0x1158 <_ZN9task_user3runEv+0xbc>
    111a:	03 97       	sbiw	r24, 0x03	; 3
    111c:	09 f0       	breq	.+2      	; 0x1120 <_ZN9task_user3runEv+0x84>
    111e:	d8 c0       	rjmp	.+432    	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
<<<<<<< HEAD
     fd0:	6a e0       	ldi	r22, 0x0A	; 10
     fd2:	f8 01       	movw	r30, r16
     fd4:	86 81       	ldd	r24, Z+6	; 0x06
     fd6:	97 81       	ldd	r25, Z+7	; 0x07
     fd8:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
     fdc:	8c 01       	movw	r16, r24
     fde:	64 e2       	ldi	r22, 0x24	; 36
     fe0:	74 e0       	ldi	r23, 0x04	; 4
     fe2:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
     fe6:	66 e0       	ldi	r22, 0x06	; 6
     fe8:	c8 01       	movw	r24, r16
     fea:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     fee:	93 e0       	ldi	r25, 0x03	; 3
     ff0:	88 ed       	ldi	r24, 0xD8	; 216
     ff2:	08 b6       	in	r0, 0x38	; 56
     ff4:	18 be       	out	0x38, r1	; 56
     ff6:	84 bf       	out	0x34, r24	; 52
     ff8:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     ffc:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1000:	81 fd       	sbrc	r24, 1
    1002:	fc cf       	rjmp	.-8      	; 0xffc <_ZN9task_user3runEv+0xb0>
    1004:	08 be       	out	0x38, r0	; 56
    1006:	ff cf       	rjmp	.-2      	; 0x1006 <_ZN9task_user3runEv+0xba>
=======
    1120:	6a e0       	ldi	r22, 0x0A	; 10
    1122:	f8 01       	movw	r30, r16
    1124:	86 81       	ldd	r24, Z+6	; 0x06
    1126:	97 81       	ldd	r25, Z+7	; 0x07
    1128:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    112c:	8c 01       	movw	r16, r24
    112e:	68 e2       	ldi	r22, 0x28	; 40
    1130:	74 e0       	ldi	r23, 0x04	; 4
    1132:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    1136:	66 e0       	ldi	r22, 0x06	; 6
    1138:	c8 01       	movw	r24, r16
    113a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    113e:	93 e0       	ldi	r25, 0x03	; 3
    1140:	88 ed       	ldi	r24, 0xD8	; 216
    1142:	08 b6       	in	r0, 0x38	; 56
    1144:	18 be       	out	0x38, r1	; 56
    1146:	84 bf       	out	0x34, r24	; 52
    1148:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    114c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1150:	81 fd       	sbrc	r24, 1
    1152:	fc cf       	rjmp	.-8      	; 0x114c <_ZN9task_user3runEv+0xb0>
    1154:	08 be       	out	0x38, r0	; 56
    1156:	ff cf       	rjmp	.-2      	; 0x1156 <_ZN9task_user3runEv+0xba>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
<<<<<<< HEAD
    1008:	c8 01       	movw	r24, r16
    100a:	0e 94 73 06 	call	0xce6	; 0xce6 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    100e:	61 e0       	ldi	r22, 0x01	; 1
    1010:	c8 01       	movw	r24, r16
    1012:	0e 94 24 14 	call	0x2848	; 0x2848 <_ZN8frt_task13transition_toEh>
							break;
    1016:	b4 c0       	rjmp	.+360    	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    1158:	c8 01       	movw	r24, r16
    115a:	0e 94 1b 07 	call	0xe36	; 0xe36 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    115e:	61 e0       	ldi	r22, 0x01	; 1
    1160:	c8 01       	movw	r24, r16
    1162:	0e 94 cc 14 	call	0x2998	; 0x2998 <_ZN8frt_task13transition_toEh>
							break;
    1166:	b4 c0       	rjmp	.+360    	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
<<<<<<< HEAD
    1018:	8e e3       	ldi	r24, 0x3E	; 62
    101a:	91 e3       	ldi	r25, 0x31	; 49
    101c:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN14frt_text_queue14check_for_charEv>
    1020:	88 23       	and	r24, r24
    1022:	09 f4       	brne	.+2      	; 0x1026 <_ZN9task_user3runEv+0xda>
    1024:	ad c0       	rjmp	.+346    	; 0x1180 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1026:	d8 01       	movw	r26, r16
    1028:	16 96       	adiw	r26, 0x06	; 6
    102a:	ed 91       	ld	r30, X+
    102c:	fc 91       	ld	r31, X
    102e:	17 97       	sbiw	r26, 0x07	; 7
    1030:	01 90       	ld	r0, Z+
    1032:	f0 81       	ld	r31, Z
    1034:	e0 2d       	mov	r30, r0
    1036:	e2 80       	ldd	r14, Z+2	; 0x02
    1038:	f3 80       	ldd	r15, Z+3	; 0x03
    103a:	8e e3       	ldi	r24, 0x3E	; 62
    103c:	91 e3       	ldi	r25, 0x31	; 49
    103e:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <_ZN14frt_text_queue7getcharEv>
    1042:	68 2f       	mov	r22, r24
    1044:	f8 01       	movw	r30, r16
    1046:	86 81       	ldd	r24, Z+6	; 0x06
    1048:	97 81       	ldd	r25, Z+7	; 0x07
    104a:	f7 01       	movw	r30, r14
    104c:	19 95       	eicall
    104e:	98 c0       	rjmp	.+304    	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    1168:	86 e7       	ldi	r24, 0x76	; 118
    116a:	91 e3       	ldi	r25, 0x31	; 49
    116c:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <_ZN14frt_text_queue14check_for_charEv>
    1170:	88 23       	and	r24, r24
    1172:	09 f4       	brne	.+2      	; 0x1176 <_ZN9task_user3runEv+0xda>
    1174:	ad c0       	rjmp	.+346    	; 0x12d0 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1176:	d8 01       	movw	r26, r16
    1178:	16 96       	adiw	r26, 0x06	; 6
    117a:	ed 91       	ld	r30, X+
    117c:	fc 91       	ld	r31, X
    117e:	17 97       	sbiw	r26, 0x07	; 7
    1180:	01 90       	ld	r0, Z+
    1182:	f0 81       	ld	r31, Z
    1184:	e0 2d       	mov	r30, r0
    1186:	e2 80       	ldd	r14, Z+2	; 0x02
    1188:	f3 80       	ldd	r15, Z+3	; 0x03
    118a:	86 e7       	ldi	r24, 0x76	; 118
    118c:	91 e3       	ldi	r25, 0x31	; 49
    118e:	0e 94 6f 17 	call	0x2ede	; 0x2ede <_ZN14frt_text_queue7getcharEv>
    1192:	68 2f       	mov	r22, r24
    1194:	f8 01       	movw	r30, r16
    1196:	86 81       	ldd	r24, Z+6	; 0x06
    1198:	97 81       	ldd	r25, Z+7	; 0x07
    119a:	f7 01       	movw	r30, r14
    119c:	19 95       	eicall
    119e:	98 c0       	rjmp	.+304    	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
<<<<<<< HEAD
    1050:	86 81       	ldd	r24, Z+6	; 0x06
    1052:	97 81       	ldd	r25, Z+7	; 0x07
    1054:	dc 01       	movw	r26, r24
    1056:	ed 91       	ld	r30, X+
    1058:	fc 91       	ld	r31, X
    105a:	04 80       	ldd	r0, Z+4	; 0x04
    105c:	f5 81       	ldd	r31, Z+5	; 0x05
    105e:	e0 2d       	mov	r30, r0
    1060:	19 95       	eicall
    1062:	88 23       	and	r24, r24
    1064:	09 f4       	brne	.+2      	; 0x1068 <_ZN9task_user3runEv+0x11c>
    1066:	8c c0       	rjmp	.+280    	; 0x1180 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1068:	f8 01       	movw	r30, r16
    106a:	86 81       	ldd	r24, Z+6	; 0x06
    106c:	97 81       	ldd	r25, Z+7	; 0x07
    106e:	dc 01       	movw	r26, r24
    1070:	ed 91       	ld	r30, X+
    1072:	fc 91       	ld	r31, X
    1074:	06 80       	ldd	r0, Z+6	; 0x06
    1076:	f7 81       	ldd	r31, Z+7	; 0x07
    1078:	e0 2d       	mov	r30, r0
    107a:	19 95       	eicall
=======
    11a0:	86 81       	ldd	r24, Z+6	; 0x06
    11a2:	97 81       	ldd	r25, Z+7	; 0x07
    11a4:	dc 01       	movw	r26, r24
    11a6:	ed 91       	ld	r30, X+
    11a8:	fc 91       	ld	r31, X
    11aa:	04 80       	ldd	r0, Z+4	; 0x04
    11ac:	f5 81       	ldd	r31, Z+5	; 0x05
    11ae:	e0 2d       	mov	r30, r0
    11b0:	19 95       	eicall
    11b2:	88 23       	and	r24, r24
    11b4:	09 f4       	brne	.+2      	; 0x11b8 <_ZN9task_user3runEv+0x11c>
    11b6:	8c c0       	rjmp	.+280    	; 0x12d0 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    11b8:	f8 01       	movw	r30, r16
    11ba:	86 81       	ldd	r24, Z+6	; 0x06
    11bc:	97 81       	ldd	r25, Z+7	; 0x07
    11be:	dc 01       	movw	r26, r24
    11c0:	ed 91       	ld	r30, X+
    11c2:	fc 91       	ld	r31, X
    11c4:	06 80       	ldd	r0, Z+6	; 0x06
    11c6:	f7 81       	ldd	r31, Z+7	; 0x07
    11c8:	e0 2d       	mov	r30, r0
    11ca:	19 95       	eicall
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
<<<<<<< HEAD
    107c:	9c 01       	movw	r18, r24
    107e:	33 27       	eor	r19, r19
    1080:	28 36       	cpi	r18, 0x68	; 104
    1082:	31 05       	cpc	r19, r1
    1084:	59 f1       	breq	.+86     	; 0x10dc <_ZN9task_user3runEv+0x190>
    1086:	3c f4       	brge	.+14     	; 0x1096 <_ZN9task_user3runEv+0x14a>
    1088:	2b 31       	cpi	r18, 0x1B	; 27
    108a:	31 05       	cpc	r19, r1
    108c:	59 f1       	breq	.+86     	; 0x10e4 <_ZN9task_user3runEv+0x198>
    108e:	25 36       	cpi	r18, 0x65	; 101
    1090:	31 05       	cpc	r19, r1
    1092:	41 f1       	breq	.+80     	; 0x10e4 <_ZN9task_user3runEv+0x198>
    1094:	3b c0       	rjmp	.+118    	; 0x110c <_ZN9task_user3runEv+0x1c0>
    1096:	23 37       	cpi	r18, 0x73	; 115
    1098:	31 05       	cpc	r19, r1
    109a:	c1 f0       	breq	.+48     	; 0x10cc <_ZN9task_user3runEv+0x180>
    109c:	26 37       	cpi	r18, 0x76	; 118
    109e:	31 05       	cpc	r19, r1
    10a0:	89 f0       	breq	.+34     	; 0x10c4 <_ZN9task_user3runEv+0x178>
    10a2:	2e 36       	cpi	r18, 0x6E	; 110
    10a4:	31 05       	cpc	r19, r1
    10a6:	91 f5       	brne	.+100    	; 0x110c <_ZN9task_user3runEv+0x1c0>
=======
    11cc:	9c 01       	movw	r18, r24
    11ce:	33 27       	eor	r19, r19
    11d0:	28 36       	cpi	r18, 0x68	; 104
    11d2:	31 05       	cpc	r19, r1
    11d4:	59 f1       	breq	.+86     	; 0x122c <_ZN9task_user3runEv+0x190>
    11d6:	3c f4       	brge	.+14     	; 0x11e6 <_ZN9task_user3runEv+0x14a>
    11d8:	2b 31       	cpi	r18, 0x1B	; 27
    11da:	31 05       	cpc	r19, r1
    11dc:	59 f1       	breq	.+86     	; 0x1234 <_ZN9task_user3runEv+0x198>
    11de:	25 36       	cpi	r18, 0x65	; 101
    11e0:	31 05       	cpc	r19, r1
    11e2:	41 f1       	breq	.+80     	; 0x1234 <_ZN9task_user3runEv+0x198>
    11e4:	3b c0       	rjmp	.+118    	; 0x125c <_ZN9task_user3runEv+0x1c0>
    11e6:	23 37       	cpi	r18, 0x73	; 115
    11e8:	31 05       	cpc	r19, r1
    11ea:	c1 f0       	breq	.+48     	; 0x121c <_ZN9task_user3runEv+0x180>
    11ec:	26 37       	cpi	r18, 0x76	; 118
    11ee:	31 05       	cpc	r19, r1
    11f0:	89 f0       	breq	.+34     	; 0x1214 <_ZN9task_user3runEv+0x178>
    11f2:	2e 36       	cpi	r18, 0x6E	; 110
    11f4:	31 05       	cpc	r19, r1
    11f6:	91 f5       	brne	.+100    	; 0x125c <_ZN9task_user3runEv+0x1c0>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
<<<<<<< HEAD
    10a8:	ce 01       	movw	r24, r28
    10aa:	01 96       	adiw	r24, 0x01	; 1
    10ac:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN10time_stamp10set_to_nowEv>
    10b0:	bc 01       	movw	r22, r24
    10b2:	f8 01       	movw	r30, r16
    10b4:	86 81       	ldd	r24, Z+6	; 0x06
    10b6:	97 81       	ldd	r25, Z+7	; 0x07
    10b8:	0e 94 7d 17 	call	0x2efa	; 0x2efa <_ZlsR8emstreamR10time_stamp>
    10bc:	66 e0       	ldi	r22, 0x06	; 6
    10be:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
							break;
    10c2:	5e c0       	rjmp	.+188    	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    11f8:	ce 01       	movw	r24, r28
    11fa:	01 96       	adiw	r24, 0x01	; 1
    11fc:	0e 94 81 18 	call	0x3102	; 0x3102 <_ZN10time_stamp10set_to_nowEv>
    1200:	bc 01       	movw	r22, r24
    1202:	f8 01       	movw	r30, r16
    1204:	86 81       	ldd	r24, Z+6	; 0x06
    1206:	97 81       	ldd	r25, Z+7	; 0x07
    1208:	0e 94 25 18 	call	0x304a	; 0x304a <_ZlsR8emstreamR10time_stamp>
    120c:	66 e0       	ldi	r22, 0x06	; 6
    120e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
							break;
    1212:	5e c0       	rjmp	.+188    	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
<<<<<<< HEAD
    10c4:	c8 01       	movw	r24, r16
    10c6:	0e 94 1b 07 	call	0xe36	; 0xe36 <_ZN9task_user11show_statusEv>
							break;
    10ca:	5a c0       	rjmp	.+180    	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    1214:	c8 01       	movw	r24, r16
    1216:	0e 94 c3 07 	call	0xf86	; 0xf86 <_ZN9task_user11show_statusEv>
							break;
    121a:	5a c0       	rjmp	.+180    	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
<<<<<<< HEAD
    10cc:	d8 01       	movw	r26, r16
    10ce:	16 96       	adiw	r26, 0x06	; 6
    10d0:	8d 91       	ld	r24, X+
    10d2:	9c 91       	ld	r25, X
    10d4:	17 97       	sbiw	r26, 0x07	; 7
    10d6:	0e 94 3d 15 	call	0x2a7a	; 0x2a7a <_Z17print_task_stacksP8emstream>
							break;
    10da:	52 c0       	rjmp	.+164    	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    121c:	d8 01       	movw	r26, r16
    121e:	16 96       	adiw	r26, 0x06	; 6
    1220:	8d 91       	ld	r24, X+
    1222:	9c 91       	ld	r25, X
    1224:	17 97       	sbiw	r26, 0x07	; 7
    1226:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_Z17print_task_stacksP8emstream>
							break;
    122a:	52 c0       	rjmp	.+164    	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
<<<<<<< HEAD
    10dc:	c8 01       	movw	r24, r16
    10de:	0e 94 73 06 	call	0xce6	; 0xce6 <_ZN9task_user18print_help_messageEv>
							break;
    10e2:	4e c0       	rjmp	.+156    	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    122c:	c8 01       	movw	r24, r16
    122e:	0e 94 1b 07 	call	0xe36	; 0xe36 <_ZN9task_user18print_help_messageEv>
							break;
    1232:	4e c0       	rjmp	.+156    	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
<<<<<<< HEAD
    10e4:	6a e0       	ldi	r22, 0x0A	; 10
    10e6:	f8 01       	movw	r30, r16
    10e8:	86 81       	ldd	r24, Z+6	; 0x06
    10ea:	97 81       	ldd	r25, Z+7	; 0x07
    10ec:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    10f0:	7c 01       	movw	r14, r24
    10f2:	62 e1       	ldi	r22, 0x12	; 18
    10f4:	74 e0       	ldi	r23, 0x04	; 4
    10f6:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    10fa:	66 e0       	ldi	r22, 0x06	; 6
    10fc:	c7 01       	movw	r24, r14
    10fe:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1102:	60 e0       	ldi	r22, 0x00	; 0
    1104:	c8 01       	movw	r24, r16
    1106:	0e 94 24 14 	call	0x2848	; 0x2848 <_ZN8frt_task13transition_toEh>
							break;
    110a:	3a c0       	rjmp	.+116    	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    1234:	6a e0       	ldi	r22, 0x0A	; 10
    1236:	f8 01       	movw	r30, r16
    1238:	86 81       	ldd	r24, Z+6	; 0x06
    123a:	97 81       	ldd	r25, Z+7	; 0x07
    123c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1240:	7c 01       	movw	r14, r24
    1242:	66 e1       	ldi	r22, 0x16	; 22
    1244:	74 e0       	ldi	r23, 0x04	; 4
    1246:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    124a:	66 e0       	ldi	r22, 0x06	; 6
    124c:	c7 01       	movw	r24, r14
    124e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1252:	60 e0       	ldi	r22, 0x00	; 0
    1254:	c8 01       	movw	r24, r16
    1256:	0e 94 cc 14 	call	0x2998	; 0x2998 <_ZN8frt_task13transition_toEh>
							break;
    125a:	3a c0       	rjmp	.+116    	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
<<<<<<< HEAD
    110c:	f8 01       	movw	r30, r16
    110e:	a6 81       	ldd	r26, Z+6	; 0x06
    1110:	b7 81       	ldd	r27, Z+7	; 0x07
    1112:	ed 91       	ld	r30, X+
    1114:	fc 91       	ld	r31, X
    1116:	11 97       	sbiw	r26, 0x01	; 1
    1118:	02 80       	ldd	r0, Z+2	; 0x02
    111a:	f3 81       	ldd	r31, Z+3	; 0x03
    111c:	e0 2d       	mov	r30, r0
    111e:	68 2f       	mov	r22, r24
    1120:	cd 01       	movw	r24, r26
    1122:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1124:	6a e0       	ldi	r22, 0x0A	; 10
    1126:	d8 01       	movw	r26, r16
    1128:	16 96       	adiw	r26, 0x06	; 6
    112a:	8d 91       	ld	r24, X+
    112c:	9c 91       	ld	r25, X
    112e:	17 97       	sbiw	r26, 0x07	; 7
    1130:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    1134:	7c 01       	movw	r14, r24
    1136:	6c e0       	ldi	r22, 0x0C	; 12
    1138:	74 e0       	ldi	r23, 0x04	; 4
    113a:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    113e:	66 e0       	ldi	r22, 0x06	; 6
    1140:	c7 01       	movw	r24, r14
    1142:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
							break;
    1146:	1c c0       	rjmp	.+56     	; 0x1180 <_ZN9task_user3runEv+0x234>
=======
    125c:	f8 01       	movw	r30, r16
    125e:	a6 81       	ldd	r26, Z+6	; 0x06
    1260:	b7 81       	ldd	r27, Z+7	; 0x07
    1262:	ed 91       	ld	r30, X+
    1264:	fc 91       	ld	r31, X
    1266:	11 97       	sbiw	r26, 0x01	; 1
    1268:	02 80       	ldd	r0, Z+2	; 0x02
    126a:	f3 81       	ldd	r31, Z+3	; 0x03
    126c:	e0 2d       	mov	r30, r0
    126e:	68 2f       	mov	r22, r24
    1270:	cd 01       	movw	r24, r26
    1272:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1274:	6a e0       	ldi	r22, 0x0A	; 10
    1276:	d8 01       	movw	r26, r16
    1278:	16 96       	adiw	r26, 0x06	; 6
    127a:	8d 91       	ld	r24, X+
    127c:	9c 91       	ld	r25, X
    127e:	17 97       	sbiw	r26, 0x07	; 7
    1280:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    1284:	7c 01       	movw	r14, r24
    1286:	60 e1       	ldi	r22, 0x10	; 16
    1288:	74 e0       	ldi	r23, 0x04	; 4
    128a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    128e:	66 e0       	ldi	r22, 0x06	; 6
    1290:	c7 01       	movw	r24, r14
    1292:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
							break;
    1296:	1c c0       	rjmp	.+56     	; 0x12d0 <_ZN9task_user3runEv+0x234>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
<<<<<<< HEAD
    1148:	6a e0       	ldi	r22, 0x0A	; 10
    114a:	f8 01       	movw	r30, r16
    114c:	86 81       	ldd	r24, Z+6	; 0x06
    114e:	97 81       	ldd	r25, Z+7	; 0x07
    1150:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    1154:	8c 01       	movw	r16, r24
    1156:	6f ee       	ldi	r22, 0xEF	; 239
    1158:	73 e0       	ldi	r23, 0x03	; 3
    115a:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    115e:	66 e0       	ldi	r22, 0x06	; 6
    1160:	c8 01       	movw	r24, r16
    1162:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1166:	93 e0       	ldi	r25, 0x03	; 3
    1168:	88 ed       	ldi	r24, 0xD8	; 216
    116a:	08 b6       	in	r0, 0x38	; 56
    116c:	18 be       	out	0x38, r1	; 56
    116e:	84 bf       	out	0x34, r24	; 52
    1170:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1174:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1178:	81 fd       	sbrc	r24, 1
    117a:	fc cf       	rjmp	.-8      	; 0x1174 <_ZN9task_user3runEv+0x228>
    117c:	08 be       	out	0x38, r0	; 56
    117e:	ff cf       	rjmp	.-2      	; 0x117e <_ZN9task_user3runEv+0x232>
=======
    1298:	6a e0       	ldi	r22, 0x0A	; 10
    129a:	f8 01       	movw	r30, r16
    129c:	86 81       	ldd	r24, Z+6	; 0x06
    129e:	97 81       	ldd	r25, Z+7	; 0x07
    12a0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    12a4:	8c 01       	movw	r16, r24
    12a6:	63 ef       	ldi	r22, 0xF3	; 243
    12a8:	73 e0       	ldi	r23, 0x03	; 3
    12aa:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    12ae:	66 e0       	ldi	r22, 0x06	; 6
    12b0:	c8 01       	movw	r24, r16
    12b2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    12b6:	93 e0       	ldi	r25, 0x03	; 3
    12b8:	88 ed       	ldi	r24, 0xD8	; 216
    12ba:	08 b6       	in	r0, 0x38	; 56
    12bc:	18 be       	out	0x38, r1	; 56
    12be:	84 bf       	out	0x34, r24	; 52
    12c0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    12c4:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    12c8:	81 fd       	sbrc	r24, 1
    12ca:	fc cf       	rjmp	.-8      	; 0x12c4 <_ZN9task_user3runEv+0x228>
    12cc:	08 be       	out	0x38, r0	; 56
    12ce:	ff cf       	rjmp	.-2      	; 0x12ce <_ZN9task_user3runEv+0x232>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
<<<<<<< HEAD
    1180:	f8 01       	movw	r30, r16
    1182:	86 85       	ldd	r24, Z+14	; 0x0e
    1184:	97 85       	ldd	r25, Z+15	; 0x0f
    1186:	a0 89       	ldd	r26, Z+16	; 0x10
    1188:	b1 89       	ldd	r27, Z+17	; 0x11
    118a:	01 96       	adiw	r24, 0x01	; 1
    118c:	a1 1d       	adc	r26, r1
    118e:	b1 1d       	adc	r27, r1
    1190:	86 87       	std	Z+14, r24	; 0x0e
    1192:	97 87       	std	Z+15, r25	; 0x0f
    1194:	a0 8b       	std	Z+16, r26	; 0x10
    1196:	b1 8b       	std	Z+17, r27	; 0x11
=======
    12d0:	f8 01       	movw	r30, r16
    12d2:	86 85       	ldd	r24, Z+14	; 0x0e
    12d4:	97 85       	ldd	r25, Z+15	; 0x0f
    12d6:	a0 89       	ldd	r26, Z+16	; 0x10
    12d8:	b1 89       	ldd	r27, Z+17	; 0x11
    12da:	01 96       	adiw	r24, 0x01	; 1
    12dc:	a1 1d       	adc	r26, r1
    12de:	b1 1d       	adc	r27, r1
    12e0:	86 87       	std	Z+14, r24	; 0x0e
    12e2:	97 87       	std	Z+15, r25	; 0x0f
    12e4:	a0 8b       	std	Z+16, r26	; 0x10
    12e6:	b1 8b       	std	Z+17, r27	; 0x11
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
<<<<<<< HEAD
    1198:	61 e0       	ldi	r22, 0x01	; 1
    119a:	70 e0       	ldi	r23, 0x00	; 0
    119c:	80 e0       	ldi	r24, 0x00	; 0
    119e:	90 e0       	ldi	r25, 0x00	; 0
    11a0:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskDelay>
=======
    12e8:	61 e0       	ldi	r22, 0x01	; 1
    12ea:	70 e0       	ldi	r23, 0x00	; 0
    12ec:	80 e0       	ldi	r24, 0x00	; 0
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	0e 94 a0 12 	call	0x2540	; 0x2540 <vTaskDelay>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
<<<<<<< HEAD
    11a4:	f1 ce       	rjmp	.-542    	; 0xf88 <_ZN9task_user3runEv+0x3c>

000011a6 <pvPortMalloc>:
=======
    12f4:	f1 ce       	rjmp	.-542    	; 0x10d8 <_ZN9task_user3runEv+0x3c>

000012f6 <pvPortMalloc>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
<<<<<<< HEAD
    11a6:	0f 93       	push	r16
    11a8:	1f 93       	push	r17
    11aa:	cf 93       	push	r28
    11ac:	df 93       	push	r29
    11ae:	ec 01       	movw	r28, r24
=======
    12f6:	0f 93       	push	r16
    12f8:	1f 93       	push	r17
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
<<<<<<< HEAD
    11b0:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskSuspendAll>
=======
    1300:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
<<<<<<< HEAD
    11b4:	80 91 ac 20 	lds	r24, 0x20AC	; 0x8020ac <__data_end>
    11b8:	81 11       	cpse	r24, r1
    11ba:	1d c0       	rjmp	.+58     	; 0x11f6 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    11bc:	a1 eb       	ldi	r26, 0xB1	; 177
    11be:	b0 e2       	ldi	r27, 0x20	; 32
    11c0:	e5 eb       	ldi	r30, 0xB5	; 181
    11c2:	f0 e2       	ldi	r31, 0x20	; 32
    11c4:	ed 93       	st	X+, r30
    11c6:	fc 93       	st	X, r31
    11c8:	11 97       	sbiw	r26, 0x01	; 1
    11ca:	12 96       	adiw	r26, 0x02	; 2
    11cc:	1d 92       	st	X+, r1
    11ce:	1c 92       	st	X, r1
    11d0:	13 97       	sbiw	r26, 0x03	; 3
    11d2:	ad ea       	ldi	r26, 0xAD	; 173
    11d4:	b0 e2       	ldi	r27, 0x20	; 32
    11d6:	8f ef       	ldi	r24, 0xFF	; 255
    11d8:	9f e0       	ldi	r25, 0x0F	; 15
    11da:	12 96       	adiw	r26, 0x02	; 2
    11dc:	8d 93       	st	X+, r24
    11de:	9c 93       	st	X, r25
    11e0:	13 97       	sbiw	r26, 0x03	; 3
    11e2:	1d 92       	st	X+, r1
    11e4:	1c 92       	st	X, r1
    11e6:	11 97       	sbiw	r26, 0x01	; 1
    11e8:	82 83       	std	Z+2, r24	; 0x02
    11ea:	93 83       	std	Z+3, r25	; 0x03
    11ec:	a0 83       	st	Z, r26
    11ee:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    11f0:	81 e0       	ldi	r24, 0x01	; 1
    11f2:	80 93 ac 20 	sts	0x20AC, r24	; 0x8020ac <__data_end>
=======
    1304:	80 91 e2 20 	lds	r24, 0x20E2	; 0x8020e2 <__data_end>
    1308:	81 11       	cpse	r24, r1
    130a:	1d c0       	rjmp	.+58     	; 0x1346 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    130c:	a7 ee       	ldi	r26, 0xE7	; 231
    130e:	b0 e2       	ldi	r27, 0x20	; 32
    1310:	eb ee       	ldi	r30, 0xEB	; 235
    1312:	f0 e2       	ldi	r31, 0x20	; 32
    1314:	ed 93       	st	X+, r30
    1316:	fc 93       	st	X, r31
    1318:	11 97       	sbiw	r26, 0x01	; 1
    131a:	12 96       	adiw	r26, 0x02	; 2
    131c:	1d 92       	st	X+, r1
    131e:	1c 92       	st	X, r1
    1320:	13 97       	sbiw	r26, 0x03	; 3
    1322:	a3 ee       	ldi	r26, 0xE3	; 227
    1324:	b0 e2       	ldi	r27, 0x20	; 32
    1326:	8f ef       	ldi	r24, 0xFF	; 255
    1328:	9f e0       	ldi	r25, 0x0F	; 15
    132a:	12 96       	adiw	r26, 0x02	; 2
    132c:	8d 93       	st	X+, r24
    132e:	9c 93       	st	X, r25
    1330:	13 97       	sbiw	r26, 0x03	; 3
    1332:	1d 92       	st	X+, r1
    1334:	1c 92       	st	X, r1
    1336:	11 97       	sbiw	r26, 0x01	; 1
    1338:	82 83       	std	Z+2, r24	; 0x02
    133a:	93 83       	std	Z+3, r25	; 0x03
    133c:	a0 83       	st	Z, r26
    133e:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	80 93 e2 20 	sts	0x20E2, r24	; 0x8020e2 <__data_end>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
<<<<<<< HEAD
    11f6:	20 97       	sbiw	r28, 0x00	; 0
    11f8:	09 f4       	brne	.+2      	; 0x11fc <pvPortMalloc+0x56>
    11fa:	5f c0       	rjmp	.+190    	; 0x12ba <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    11fc:	9e 01       	movw	r18, r28
    11fe:	2b 5f       	subi	r18, 0xFB	; 251
    1200:	3f 4f       	sbci	r19, 0xFF	; 255
=======
    1346:	20 97       	sbiw	r28, 0x00	; 0
    1348:	09 f4       	brne	.+2      	; 0x134c <pvPortMalloc+0x56>
    134a:	5f c0       	rjmp	.+190    	; 0x140a <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    134c:	9e 01       	movw	r18, r28
    134e:	2b 5f       	subi	r18, 0xFB	; 251
    1350:	3f 4f       	sbci	r19, 0xFF	; 255
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
<<<<<<< HEAD
    1202:	24 96       	adiw	r28, 0x04	; 4
    1204:	ce 3f       	cpi	r28, 0xFE	; 254
    1206:	df 40       	sbci	r29, 0x0F	; 15
    1208:	08 f0       	brcs	.+2      	; 0x120c <pvPortMalloc+0x66>
    120a:	5a c0       	rjmp	.+180    	; 0x12c0 <pvPortMalloc+0x11a>
=======
    1352:	24 96       	adiw	r28, 0x04	; 4
    1354:	ce 3f       	cpi	r28, 0xFE	; 254
    1356:	df 40       	sbci	r29, 0x0F	; 15
    1358:	08 f0       	brcs	.+2      	; 0x135c <pvPortMalloc+0x66>
    135a:	5a c0       	rjmp	.+180    	; 0x1410 <pvPortMalloc+0x11a>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
<<<<<<< HEAD
    120c:	e0 91 b1 20 	lds	r30, 0x20B1	; 0x8020b1 <xStart>
    1210:	f0 91 b2 20 	lds	r31, 0x20B2	; 0x8020b2 <xStart+0x1>
=======
    135c:	e0 91 e7 20 	lds	r30, 0x20E7	; 0x8020e7 <xStart>
    1360:	f0 91 e8 20 	lds	r31, 0x20E8	; 0x8020e8 <xStart+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
<<<<<<< HEAD
    1214:	a1 eb       	ldi	r26, 0xB1	; 177
    1216:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1218:	02 c0       	rjmp	.+4      	; 0x121e <pvPortMalloc+0x78>
    121a:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    121c:	fc 01       	movw	r30, r24
=======
    1364:	a7 ee       	ldi	r26, 0xE7	; 231
    1366:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1368:	02 c0       	rjmp	.+4      	; 0x136e <pvPortMalloc+0x78>
    136a:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    136c:	fc 01       	movw	r30, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
<<<<<<< HEAD
    121e:	82 81       	ldd	r24, Z+2	; 0x02
    1220:	93 81       	ldd	r25, Z+3	; 0x03
    1222:	82 17       	cp	r24, r18
    1224:	93 07       	cpc	r25, r19
    1226:	20 f4       	brcc	.+8      	; 0x1230 <pvPortMalloc+0x8a>
    1228:	80 81       	ld	r24, Z
    122a:	91 81       	ldd	r25, Z+1	; 0x01
    122c:	00 97       	sbiw	r24, 0x00	; 0
    122e:	a9 f7       	brne	.-22     	; 0x121a <pvPortMalloc+0x74>
=======
    136e:	82 81       	ldd	r24, Z+2	; 0x02
    1370:	93 81       	ldd	r25, Z+3	; 0x03
    1372:	82 17       	cp	r24, r18
    1374:	93 07       	cpc	r25, r19
    1376:	20 f4       	brcc	.+8      	; 0x1380 <pvPortMalloc+0x8a>
    1378:	80 81       	ld	r24, Z
    137a:	91 81       	ldd	r25, Z+1	; 0x01
    137c:	00 97       	sbiw	r24, 0x00	; 0
    137e:	a9 f7       	brne	.-22     	; 0x136a <pvPortMalloc+0x74>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
<<<<<<< HEAD
    1230:	c0 e2       	ldi	r28, 0x20	; 32
    1232:	ed 3a       	cpi	r30, 0xAD	; 173
    1234:	fc 07       	cpc	r31, r28
    1236:	09 f4       	brne	.+2      	; 0x123a <pvPortMalloc+0x94>
    1238:	46 c0       	rjmp	.+140    	; 0x12c6 <pvPortMalloc+0x120>
=======
    1380:	c0 e2       	ldi	r28, 0x20	; 32
    1382:	e3 3e       	cpi	r30, 0xE3	; 227
    1384:	fc 07       	cpc	r31, r28
    1386:	09 f4       	brne	.+2      	; 0x138a <pvPortMalloc+0x94>
    1388:	46 c0       	rjmp	.+140    	; 0x1416 <pvPortMalloc+0x120>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
<<<<<<< HEAD
    123a:	cd 91       	ld	r28, X+
    123c:	dc 91       	ld	r29, X
    123e:	11 97       	sbiw	r26, 0x01	; 1
    1240:	8e 01       	movw	r16, r28
    1242:	0b 5f       	subi	r16, 0xFB	; 251
    1244:	1f 4f       	sbci	r17, 0xFF	; 255
=======
    138a:	cd 91       	ld	r28, X+
    138c:	dc 91       	ld	r29, X
    138e:	11 97       	sbiw	r26, 0x01	; 1
    1390:	8e 01       	movw	r16, r28
    1392:	0b 5f       	subi	r16, 0xFB	; 251
    1394:	1f 4f       	sbci	r17, 0xFF	; 255
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
<<<<<<< HEAD
    1246:	80 81       	ld	r24, Z
    1248:	91 81       	ldd	r25, Z+1	; 0x01
    124a:	8d 93       	st	X+, r24
    124c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    124e:	82 81       	ldd	r24, Z+2	; 0x02
    1250:	93 81       	ldd	r25, Z+3	; 0x03
    1252:	82 1b       	sub	r24, r18
    1254:	93 0b       	sbc	r25, r19
    1256:	8b 30       	cpi	r24, 0x0B	; 11
    1258:	91 05       	cpc	r25, r1
    125a:	10 f1       	brcs	.+68     	; 0x12a0 <pvPortMalloc+0xfa>
=======
    1396:	80 81       	ld	r24, Z
    1398:	91 81       	ldd	r25, Z+1	; 0x01
    139a:	8d 93       	st	X+, r24
    139c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    139e:	82 81       	ldd	r24, Z+2	; 0x02
    13a0:	93 81       	ldd	r25, Z+3	; 0x03
    13a2:	82 1b       	sub	r24, r18
    13a4:	93 0b       	sbc	r25, r19
    13a6:	8b 30       	cpi	r24, 0x0B	; 11
    13a8:	91 05       	cpc	r25, r1
    13aa:	10 f1       	brcs	.+68     	; 0x13f0 <pvPortMalloc+0xfa>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
<<<<<<< HEAD
    125c:	bf 01       	movw	r22, r30
    125e:	62 0f       	add	r22, r18
    1260:	73 1f       	adc	r23, r19
=======
    13ac:	bf 01       	movw	r22, r30
    13ae:	62 0f       	add	r22, r18
    13b0:	73 1f       	adc	r23, r19
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
<<<<<<< HEAD
    1262:	db 01       	movw	r26, r22
    1264:	12 96       	adiw	r26, 0x02	; 2
    1266:	8d 93       	st	X+, r24
    1268:	9c 93       	st	X, r25
    126a:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    126c:	22 83       	std	Z+2, r18	; 0x02
    126e:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1270:	12 96       	adiw	r26, 0x02	; 2
    1272:	4d 91       	ld	r20, X+
    1274:	5c 91       	ld	r21, X
    1276:	13 97       	sbiw	r26, 0x03	; 3
    1278:	81 eb       	ldi	r24, 0xB1	; 177
    127a:	90 e2       	ldi	r25, 0x20	; 32
    127c:	01 c0       	rjmp	.+2      	; 0x1280 <pvPortMalloc+0xda>
    127e:	cd 01       	movw	r24, r26
    1280:	ec 01       	movw	r28, r24
    1282:	a8 81       	ld	r26, Y
    1284:	b9 81       	ldd	r27, Y+1	; 0x01
    1286:	12 96       	adiw	r26, 0x02	; 2
    1288:	2d 91       	ld	r18, X+
    128a:	3c 91       	ld	r19, X
    128c:	13 97       	sbiw	r26, 0x03	; 3
    128e:	24 17       	cp	r18, r20
    1290:	35 07       	cpc	r19, r21
    1292:	a8 f3       	brcs	.-22     	; 0x127e <pvPortMalloc+0xd8>
    1294:	eb 01       	movw	r28, r22
    1296:	a8 83       	st	Y, r26
    1298:	b9 83       	std	Y+1, r27	; 0x01
    129a:	dc 01       	movw	r26, r24
    129c:	6d 93       	st	X+, r22
    129e:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    12a0:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    12a4:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    12a8:	22 81       	ldd	r18, Z+2	; 0x02
    12aa:	33 81       	ldd	r19, Z+3	; 0x03
    12ac:	82 1b       	sub	r24, r18
    12ae:	93 0b       	sbc	r25, r19
    12b0:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    12b4:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    12b8:	08 c0       	rjmp	.+16     	; 0x12ca <pvPortMalloc+0x124>
=======
    13b2:	db 01       	movw	r26, r22
    13b4:	12 96       	adiw	r26, 0x02	; 2
    13b6:	8d 93       	st	X+, r24
    13b8:	9c 93       	st	X, r25
    13ba:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    13bc:	22 83       	std	Z+2, r18	; 0x02
    13be:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    13c0:	12 96       	adiw	r26, 0x02	; 2
    13c2:	4d 91       	ld	r20, X+
    13c4:	5c 91       	ld	r21, X
    13c6:	13 97       	sbiw	r26, 0x03	; 3
    13c8:	87 ee       	ldi	r24, 0xE7	; 231
    13ca:	90 e2       	ldi	r25, 0x20	; 32
    13cc:	01 c0       	rjmp	.+2      	; 0x13d0 <pvPortMalloc+0xda>
    13ce:	cd 01       	movw	r24, r26
    13d0:	ec 01       	movw	r28, r24
    13d2:	a8 81       	ld	r26, Y
    13d4:	b9 81       	ldd	r27, Y+1	; 0x01
    13d6:	12 96       	adiw	r26, 0x02	; 2
    13d8:	2d 91       	ld	r18, X+
    13da:	3c 91       	ld	r19, X
    13dc:	13 97       	sbiw	r26, 0x03	; 3
    13de:	24 17       	cp	r18, r20
    13e0:	35 07       	cpc	r19, r21
    13e2:	a8 f3       	brcs	.-22     	; 0x13ce <pvPortMalloc+0xd8>
    13e4:	eb 01       	movw	r28, r22
    13e6:	a8 83       	st	Y, r26
    13e8:	b9 83       	std	Y+1, r27	; 0x01
    13ea:	dc 01       	movw	r26, r24
    13ec:	6d 93       	st	X+, r22
    13ee:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    13f0:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    13f4:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    13f8:	22 81       	ldd	r18, Z+2	; 0x02
    13fa:	33 81       	ldd	r19, Z+3	; 0x03
    13fc:	82 1b       	sub	r24, r18
    13fe:	93 0b       	sbc	r25, r19
    1400:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1404:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1408:	08 c0       	rjmp	.+16     	; 0x141a <pvPortMalloc+0x124>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
<<<<<<< HEAD
    12ba:	00 e0       	ldi	r16, 0x00	; 0
    12bc:	10 e0       	ldi	r17, 0x00	; 0
    12be:	05 c0       	rjmp	.+10     	; 0x12ca <pvPortMalloc+0x124>
    12c0:	00 e0       	ldi	r16, 0x00	; 0
    12c2:	10 e0       	ldi	r17, 0x00	; 0
    12c4:	02 c0       	rjmp	.+4      	; 0x12ca <pvPortMalloc+0x124>
    12c6:	00 e0       	ldi	r16, 0x00	; 0
    12c8:	10 e0       	ldi	r17, 0x00	; 0
=======
    140a:	00 e0       	ldi	r16, 0x00	; 0
    140c:	10 e0       	ldi	r17, 0x00	; 0
    140e:	05 c0       	rjmp	.+10     	; 0x141a <pvPortMalloc+0x124>
    1410:	00 e0       	ldi	r16, 0x00	; 0
    1412:	10 e0       	ldi	r17, 0x00	; 0
    1414:	02 c0       	rjmp	.+4      	; 0x141a <pvPortMalloc+0x124>
    1416:	00 e0       	ldi	r16, 0x00	; 0
    1418:	10 e0       	ldi	r17, 0x00	; 0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
<<<<<<< HEAD
    12ca:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
=======
    141a:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}
	}
	#endif

	return pvReturn;
}
<<<<<<< HEAD
    12ce:	c8 01       	movw	r24, r16
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	08 95       	ret

000012da <vPortFree>:
=======
    141e:	c8 01       	movw	r24, r16
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	1f 91       	pop	r17
    1426:	0f 91       	pop	r16
    1428:	08 95       	ret

0000142a <vPortFree>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
<<<<<<< HEAD
    12da:	0f 93       	push	r16
    12dc:	1f 93       	push	r17
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
=======
    142a:	0f 93       	push	r16
    142c:	1f 93       	push	r17
    142e:	cf 93       	push	r28
    1430:	df 93       	push	r29
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
<<<<<<< HEAD
    12e2:	00 97       	sbiw	r24, 0x00	; 0
    12e4:	41 f1       	breq	.+80     	; 0x1336 <vPortFree+0x5c>
    12e6:	ec 01       	movw	r28, r24
=======
    1432:	00 97       	sbiw	r24, 0x00	; 0
    1434:	41 f1       	breq	.+80     	; 0x1486 <vPortFree+0x5c>
    1436:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
<<<<<<< HEAD
    12e8:	8c 01       	movw	r16, r24
    12ea:	05 50       	subi	r16, 0x05	; 5
    12ec:	11 09       	sbc	r17, r1
=======
    1438:	8c 01       	movw	r16, r24
    143a:	05 50       	subi	r16, 0x05	; 5
    143c:	11 09       	sbc	r17, r1
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
<<<<<<< HEAD
    12ee:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    12f2:	f8 01       	movw	r30, r16
    12f4:	42 81       	ldd	r20, Z+2	; 0x02
    12f6:	53 81       	ldd	r21, Z+3	; 0x03
    12f8:	a1 eb       	ldi	r26, 0xB1	; 177
    12fa:	b0 e2       	ldi	r27, 0x20	; 32
    12fc:	01 c0       	rjmp	.+2      	; 0x1300 <vPortFree+0x26>
    12fe:	df 01       	movw	r26, r30
    1300:	ed 91       	ld	r30, X+
    1302:	fc 91       	ld	r31, X
    1304:	11 97       	sbiw	r26, 0x01	; 1
    1306:	22 81       	ldd	r18, Z+2	; 0x02
    1308:	33 81       	ldd	r19, Z+3	; 0x03
    130a:	24 17       	cp	r18, r20
    130c:	35 07       	cpc	r19, r21
    130e:	b8 f3       	brcs	.-18     	; 0x12fe <vPortFree+0x24>
    1310:	25 97       	sbiw	r28, 0x05	; 5
    1312:	e8 83       	st	Y, r30
    1314:	f9 83       	std	Y+1, r31	; 0x01
    1316:	0d 93       	st	X+, r16
    1318:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    131a:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    131e:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1322:	8a 81       	ldd	r24, Y+2	; 0x02
    1324:	9b 81       	ldd	r25, Y+3	; 0x03
    1326:	82 0f       	add	r24, r18
    1328:	93 1f       	adc	r25, r19
    132a:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    132e:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1332:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
	}
}
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	08 95       	ret

00001340 <xPortGetFreeHeapSize>:
=======
    143e:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1442:	f8 01       	movw	r30, r16
    1444:	42 81       	ldd	r20, Z+2	; 0x02
    1446:	53 81       	ldd	r21, Z+3	; 0x03
    1448:	a7 ee       	ldi	r26, 0xE7	; 231
    144a:	b0 e2       	ldi	r27, 0x20	; 32
    144c:	01 c0       	rjmp	.+2      	; 0x1450 <vPortFree+0x26>
    144e:	df 01       	movw	r26, r30
    1450:	ed 91       	ld	r30, X+
    1452:	fc 91       	ld	r31, X
    1454:	11 97       	sbiw	r26, 0x01	; 1
    1456:	22 81       	ldd	r18, Z+2	; 0x02
    1458:	33 81       	ldd	r19, Z+3	; 0x03
    145a:	24 17       	cp	r18, r20
    145c:	35 07       	cpc	r19, r21
    145e:	b8 f3       	brcs	.-18     	; 0x144e <vPortFree+0x24>
    1460:	25 97       	sbiw	r28, 0x05	; 5
    1462:	e8 83       	st	Y, r30
    1464:	f9 83       	std	Y+1, r31	; 0x01
    1466:	0d 93       	st	X+, r16
    1468:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    146a:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    146e:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1472:	8a 81       	ldd	r24, Y+2	; 0x02
    1474:	9b 81       	ldd	r25, Y+3	; 0x03
    1476:	82 0f       	add	r24, r18
    1478:	93 1f       	adc	r25, r19
    147a:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    147e:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1482:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
	}
}
    1486:	df 91       	pop	r29
    1488:	cf 91       	pop	r28
    148a:	1f 91       	pop	r17
    148c:	0f 91       	pop	r16
    148e:	08 95       	ret

00001490 <xPortGetFreeHeapSize>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
<<<<<<< HEAD
    1340:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1344:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1348:	08 95       	ret

0000134a <vListInitialise>:
=======
    1490:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1494:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1498:	08 95       	ret

0000149a <vListInitialise>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
<<<<<<< HEAD
    134a:	fc 01       	movw	r30, r24
=======
    149a:	fc 01       	movw	r30, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
<<<<<<< HEAD
    134c:	03 96       	adiw	r24, 0x03	; 3
    134e:	81 83       	std	Z+1, r24	; 0x01
    1350:	92 83       	std	Z+2, r25	; 0x02
=======
    149c:	03 96       	adiw	r24, 0x03	; 3
    149e:	81 83       	std	Z+1, r24	; 0x01
    14a0:	92 83       	std	Z+2, r25	; 0x02
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
<<<<<<< HEAD
    1352:	4f ef       	ldi	r20, 0xFF	; 255
    1354:	5f ef       	ldi	r21, 0xFF	; 255
    1356:	ba 01       	movw	r22, r20
    1358:	43 83       	std	Z+3, r20	; 0x03
    135a:	54 83       	std	Z+4, r21	; 0x04
    135c:	65 83       	std	Z+5, r22	; 0x05
    135e:	76 83       	std	Z+6, r23	; 0x06
=======
    14a2:	4f ef       	ldi	r20, 0xFF	; 255
    14a4:	5f ef       	ldi	r21, 0xFF	; 255
    14a6:	ba 01       	movw	r22, r20
    14a8:	43 83       	std	Z+3, r20	; 0x03
    14aa:	54 83       	std	Z+4, r21	; 0x04
    14ac:	65 83       	std	Z+5, r22	; 0x05
    14ae:	76 83       	std	Z+6, r23	; 0x06
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
<<<<<<< HEAD
    1360:	87 83       	std	Z+7, r24	; 0x07
    1362:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1364:	81 87       	std	Z+9, r24	; 0x09
    1366:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1368:	10 82       	st	Z, r1
    136a:	08 95       	ret

0000136c <vListInitialiseItem>:
=======
    14b0:	87 83       	std	Z+7, r24	; 0x07
    14b2:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    14b4:	81 87       	std	Z+9, r24	; 0x09
    14b6:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    14b8:	10 82       	st	Z, r1
    14ba:	08 95       	ret

000014bc <vListInitialiseItem>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
<<<<<<< HEAD
    136c:	fc 01       	movw	r30, r24
    136e:	12 86       	std	Z+10, r1	; 0x0a
    1370:	13 86       	std	Z+11, r1	; 0x0b
    1372:	08 95       	ret

00001374 <vListInsertEnd>:
=======
    14bc:	fc 01       	movw	r30, r24
    14be:	12 86       	std	Z+10, r1	; 0x0a
    14c0:	13 86       	std	Z+11, r1	; 0x0b
    14c2:	08 95       	ret

000014c4 <vListInsertEnd>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
<<<<<<< HEAD
    1374:	cf 93       	push	r28
    1376:	df 93       	push	r29
    1378:	fc 01       	movw	r30, r24
    137a:	db 01       	movw	r26, r22
=======
    14c4:	cf 93       	push	r28
    14c6:	df 93       	push	r29
    14c8:	fc 01       	movw	r30, r24
    14ca:	db 01       	movw	r26, r22
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
<<<<<<< HEAD
    137c:	21 81       	ldd	r18, Z+1	; 0x01
    137e:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1380:	e9 01       	movw	r28, r18
    1382:	8c 81       	ldd	r24, Y+4	; 0x04
    1384:	9d 81       	ldd	r25, Y+5	; 0x05
    1386:	14 96       	adiw	r26, 0x04	; 4
    1388:	8d 93       	st	X+, r24
    138a:	9c 93       	st	X, r25
    138c:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    138e:	81 81       	ldd	r24, Z+1	; 0x01
    1390:	92 81       	ldd	r25, Z+2	; 0x02
    1392:	16 96       	adiw	r26, 0x06	; 6
    1394:	8d 93       	st	X+, r24
    1396:	9c 93       	st	X, r25
    1398:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    139a:	8c 81       	ldd	r24, Y+4	; 0x04
    139c:	9d 81       	ldd	r25, Y+5	; 0x05
    139e:	ec 01       	movw	r28, r24
    13a0:	6e 83       	std	Y+6, r22	; 0x06
    13a2:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    13a4:	e9 01       	movw	r28, r18
    13a6:	6c 83       	std	Y+4, r22	; 0x04
    13a8:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    13aa:	61 83       	std	Z+1, r22	; 0x01
    13ac:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    13ae:	1a 96       	adiw	r26, 0x0a	; 10
    13b0:	ed 93       	st	X+, r30
    13b2:	fc 93       	st	X, r31
    13b4:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    13b6:	80 81       	ld	r24, Z
    13b8:	8f 5f       	subi	r24, 0xFF	; 255
    13ba:	80 83       	st	Z, r24
}
    13bc:	df 91       	pop	r29
    13be:	cf 91       	pop	r28
    13c0:	08 95       	ret

000013c2 <vListInsert>:
=======
    14cc:	21 81       	ldd	r18, Z+1	; 0x01
    14ce:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    14d0:	e9 01       	movw	r28, r18
    14d2:	8c 81       	ldd	r24, Y+4	; 0x04
    14d4:	9d 81       	ldd	r25, Y+5	; 0x05
    14d6:	14 96       	adiw	r26, 0x04	; 4
    14d8:	8d 93       	st	X+, r24
    14da:	9c 93       	st	X, r25
    14dc:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    14de:	81 81       	ldd	r24, Z+1	; 0x01
    14e0:	92 81       	ldd	r25, Z+2	; 0x02
    14e2:	16 96       	adiw	r26, 0x06	; 6
    14e4:	8d 93       	st	X+, r24
    14e6:	9c 93       	st	X, r25
    14e8:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    14ea:	8c 81       	ldd	r24, Y+4	; 0x04
    14ec:	9d 81       	ldd	r25, Y+5	; 0x05
    14ee:	ec 01       	movw	r28, r24
    14f0:	6e 83       	std	Y+6, r22	; 0x06
    14f2:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    14f4:	e9 01       	movw	r28, r18
    14f6:	6c 83       	std	Y+4, r22	; 0x04
    14f8:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    14fa:	61 83       	std	Z+1, r22	; 0x01
    14fc:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14fe:	1a 96       	adiw	r26, 0x0a	; 10
    1500:	ed 93       	st	X+, r30
    1502:	fc 93       	st	X, r31
    1504:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1506:	80 81       	ld	r24, Z
    1508:	8f 5f       	subi	r24, 0xFF	; 255
    150a:	80 83       	st	Z, r24
}
    150c:	df 91       	pop	r29
    150e:	cf 91       	pop	r28
    1510:	08 95       	ret

00001512 <vListInsert>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
<<<<<<< HEAD
    13c2:	0f 93       	push	r16
    13c4:	1f 93       	push	r17
    13c6:	cf 93       	push	r28
    13c8:	df 93       	push	r29
    13ca:	eb 01       	movw	r28, r22
=======
    1512:	0f 93       	push	r16
    1514:	1f 93       	push	r17
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
    151a:	eb 01       	movw	r28, r22
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
<<<<<<< HEAD
    13cc:	08 81       	ld	r16, Y
    13ce:	19 81       	ldd	r17, Y+1	; 0x01
    13d0:	2a 81       	ldd	r18, Y+2	; 0x02
    13d2:	3b 81       	ldd	r19, Y+3	; 0x03
=======
    151c:	08 81       	ld	r16, Y
    151e:	19 81       	ldd	r17, Y+1	; 0x01
    1520:	2a 81       	ldd	r18, Y+2	; 0x02
    1522:	3b 81       	ldd	r19, Y+3	; 0x03
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
<<<<<<< HEAD
    13d4:	0f 3f       	cpi	r16, 0xFF	; 255
    13d6:	4f ef       	ldi	r20, 0xFF	; 255
    13d8:	14 07       	cpc	r17, r20
    13da:	24 07       	cpc	r18, r20
    13dc:	34 07       	cpc	r19, r20
    13de:	31 f4       	brne	.+12     	; 0x13ec <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    13e0:	dc 01       	movw	r26, r24
    13e2:	19 96       	adiw	r26, 0x09	; 9
    13e4:	ed 91       	ld	r30, X+
    13e6:	fc 91       	ld	r31, X
    13e8:	1a 97       	sbiw	r26, 0x0a	; 10
    13ea:	1f c0       	rjmp	.+62     	; 0x142a <vListInsert+0x68>
=======
    1524:	0f 3f       	cpi	r16, 0xFF	; 255
    1526:	4f ef       	ldi	r20, 0xFF	; 255
    1528:	14 07       	cpc	r17, r20
    152a:	24 07       	cpc	r18, r20
    152c:	34 07       	cpc	r19, r20
    152e:	31 f4       	brne	.+12     	; 0x153c <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1530:	dc 01       	movw	r26, r24
    1532:	19 96       	adiw	r26, 0x09	; 9
    1534:	ed 91       	ld	r30, X+
    1536:	fc 91       	ld	r31, X
    1538:	1a 97       	sbiw	r26, 0x0a	; 10
    153a:	1f c0       	rjmp	.+62     	; 0x157a <vListInsert+0x68>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
<<<<<<< HEAD
    13ec:	fc 01       	movw	r30, r24
    13ee:	33 96       	adiw	r30, 0x03	; 3
    13f0:	dc 01       	movw	r26, r24
    13f2:	17 96       	adiw	r26, 0x07	; 7
    13f4:	4d 91       	ld	r20, X+
    13f6:	5c 91       	ld	r21, X
    13f8:	18 97       	sbiw	r26, 0x08	; 8
    13fa:	da 01       	movw	r26, r20
    13fc:	4d 91       	ld	r20, X+
    13fe:	5d 91       	ld	r21, X+
    1400:	6d 91       	ld	r22, X+
    1402:	7c 91       	ld	r23, X
    1404:	04 17       	cp	r16, r20
    1406:	15 07       	cpc	r17, r21
    1408:	26 07       	cpc	r18, r22
    140a:	37 07       	cpc	r19, r23
    140c:	70 f0       	brcs	.+28     	; 0x142a <vListInsert+0x68>
    140e:	04 80       	ldd	r0, Z+4	; 0x04
    1410:	f5 81       	ldd	r31, Z+5	; 0x05
    1412:	e0 2d       	mov	r30, r0
    1414:	a4 81       	ldd	r26, Z+4	; 0x04
    1416:	b5 81       	ldd	r27, Z+5	; 0x05
    1418:	4d 91       	ld	r20, X+
    141a:	5d 91       	ld	r21, X+
    141c:	6d 91       	ld	r22, X+
    141e:	7c 91       	ld	r23, X
    1420:	04 17       	cp	r16, r20
    1422:	15 07       	cpc	r17, r21
    1424:	26 07       	cpc	r18, r22
    1426:	37 07       	cpc	r19, r23
    1428:	90 f7       	brcc	.-28     	; 0x140e <vListInsert+0x4c>
=======
    153c:	fc 01       	movw	r30, r24
    153e:	33 96       	adiw	r30, 0x03	; 3
    1540:	dc 01       	movw	r26, r24
    1542:	17 96       	adiw	r26, 0x07	; 7
    1544:	4d 91       	ld	r20, X+
    1546:	5c 91       	ld	r21, X
    1548:	18 97       	sbiw	r26, 0x08	; 8
    154a:	da 01       	movw	r26, r20
    154c:	4d 91       	ld	r20, X+
    154e:	5d 91       	ld	r21, X+
    1550:	6d 91       	ld	r22, X+
    1552:	7c 91       	ld	r23, X
    1554:	04 17       	cp	r16, r20
    1556:	15 07       	cpc	r17, r21
    1558:	26 07       	cpc	r18, r22
    155a:	37 07       	cpc	r19, r23
    155c:	70 f0       	brcs	.+28     	; 0x157a <vListInsert+0x68>
    155e:	04 80       	ldd	r0, Z+4	; 0x04
    1560:	f5 81       	ldd	r31, Z+5	; 0x05
    1562:	e0 2d       	mov	r30, r0
    1564:	a4 81       	ldd	r26, Z+4	; 0x04
    1566:	b5 81       	ldd	r27, Z+5	; 0x05
    1568:	4d 91       	ld	r20, X+
    156a:	5d 91       	ld	r21, X+
    156c:	6d 91       	ld	r22, X+
    156e:	7c 91       	ld	r23, X
    1570:	04 17       	cp	r16, r20
    1572:	15 07       	cpc	r17, r21
    1574:	26 07       	cpc	r18, r22
    1576:	37 07       	cpc	r19, r23
    1578:	90 f7       	brcc	.-28     	; 0x155e <vListInsert+0x4c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
<<<<<<< HEAD
    142a:	a4 81       	ldd	r26, Z+4	; 0x04
    142c:	b5 81       	ldd	r27, Z+5	; 0x05
    142e:	ac 83       	std	Y+4, r26	; 0x04
    1430:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1432:	16 96       	adiw	r26, 0x06	; 6
    1434:	cd 93       	st	X+, r28
    1436:	dc 93       	st	X, r29
    1438:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    143a:	ee 83       	std	Y+6, r30	; 0x06
    143c:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    143e:	c4 83       	std	Z+4, r28	; 0x04
    1440:	d5 83       	std	Z+5, r29	; 0x05
=======
    157a:	a4 81       	ldd	r26, Z+4	; 0x04
    157c:	b5 81       	ldd	r27, Z+5	; 0x05
    157e:	ac 83       	std	Y+4, r26	; 0x04
    1580:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1582:	16 96       	adiw	r26, 0x06	; 6
    1584:	cd 93       	st	X+, r28
    1586:	dc 93       	st	X, r29
    1588:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    158a:	ee 83       	std	Y+6, r30	; 0x06
    158c:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    158e:	c4 83       	std	Z+4, r28	; 0x04
    1590:	d5 83       	std	Z+5, r29	; 0x05
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
<<<<<<< HEAD
    1442:	8a 87       	std	Y+10, r24	; 0x0a
    1444:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1446:	fc 01       	movw	r30, r24
    1448:	20 81       	ld	r18, Z
    144a:	2f 5f       	subi	r18, 0xFF	; 255
    144c:	20 83       	st	Z, r18
}
    144e:	df 91       	pop	r29
    1450:	cf 91       	pop	r28
    1452:	1f 91       	pop	r17
    1454:	0f 91       	pop	r16
    1456:	08 95       	ret

00001458 <vListRemove>:
=======
    1592:	8a 87       	std	Y+10, r24	; 0x0a
    1594:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1596:	fc 01       	movw	r30, r24
    1598:	20 81       	ld	r18, Z
    159a:	2f 5f       	subi	r18, 0xFF	; 255
    159c:	20 83       	st	Z, r18
}
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	1f 91       	pop	r17
    15a4:	0f 91       	pop	r16
    15a6:	08 95       	ret

000015a8 <vListRemove>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
<<<<<<< HEAD
    1458:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    145a:	a4 81       	ldd	r26, Z+4	; 0x04
    145c:	b5 81       	ldd	r27, Z+5	; 0x05
    145e:	86 81       	ldd	r24, Z+6	; 0x06
    1460:	97 81       	ldd	r25, Z+7	; 0x07
    1462:	16 96       	adiw	r26, 0x06	; 6
    1464:	8d 93       	st	X+, r24
    1466:	9c 93       	st	X, r25
    1468:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    146a:	a6 81       	ldd	r26, Z+6	; 0x06
    146c:	b7 81       	ldd	r27, Z+7	; 0x07
    146e:	84 81       	ldd	r24, Z+4	; 0x04
    1470:	95 81       	ldd	r25, Z+5	; 0x05
    1472:	14 96       	adiw	r26, 0x04	; 4
    1474:	8d 93       	st	X+, r24
    1476:	9c 93       	st	X, r25
    1478:	15 97       	sbiw	r26, 0x05	; 5
=======
    15a8:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    15aa:	a4 81       	ldd	r26, Z+4	; 0x04
    15ac:	b5 81       	ldd	r27, Z+5	; 0x05
    15ae:	86 81       	ldd	r24, Z+6	; 0x06
    15b0:	97 81       	ldd	r25, Z+7	; 0x07
    15b2:	16 96       	adiw	r26, 0x06	; 6
    15b4:	8d 93       	st	X+, r24
    15b6:	9c 93       	st	X, r25
    15b8:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    15ba:	a6 81       	ldd	r26, Z+6	; 0x06
    15bc:	b7 81       	ldd	r27, Z+7	; 0x07
    15be:	84 81       	ldd	r24, Z+4	; 0x04
    15c0:	95 81       	ldd	r25, Z+5	; 0x05
    15c2:	14 96       	adiw	r26, 0x04	; 4
    15c4:	8d 93       	st	X+, r24
    15c6:	9c 93       	st	X, r25
    15c8:	15 97       	sbiw	r26, 0x05	; 5
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
<<<<<<< HEAD
    147a:	a2 85       	ldd	r26, Z+10	; 0x0a
    147c:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    147e:	11 96       	adiw	r26, 0x01	; 1
    1480:	8d 91       	ld	r24, X+
    1482:	9c 91       	ld	r25, X
    1484:	12 97       	sbiw	r26, 0x02	; 2
    1486:	e8 17       	cp	r30, r24
    1488:	f9 07       	cpc	r31, r25
    148a:	31 f4       	brne	.+12     	; 0x1498 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    148c:	86 81       	ldd	r24, Z+6	; 0x06
    148e:	97 81       	ldd	r25, Z+7	; 0x07
    1490:	11 96       	adiw	r26, 0x01	; 1
    1492:	8d 93       	st	X+, r24
    1494:	9c 93       	st	X, r25
    1496:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1498:	12 86       	std	Z+10, r1	; 0x0a
    149a:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    149c:	8c 91       	ld	r24, X
    149e:	81 50       	subi	r24, 0x01	; 1
    14a0:	8c 93       	st	X, r24
    14a2:	08 95       	ret

000014a4 <pxPortInitialiseStack>:
=======
    15ca:	a2 85       	ldd	r26, Z+10	; 0x0a
    15cc:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    15ce:	11 96       	adiw	r26, 0x01	; 1
    15d0:	8d 91       	ld	r24, X+
    15d2:	9c 91       	ld	r25, X
    15d4:	12 97       	sbiw	r26, 0x02	; 2
    15d6:	e8 17       	cp	r30, r24
    15d8:	f9 07       	cpc	r31, r25
    15da:	31 f4       	brne	.+12     	; 0x15e8 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    15dc:	86 81       	ldd	r24, Z+6	; 0x06
    15de:	97 81       	ldd	r25, Z+7	; 0x07
    15e0:	11 96       	adiw	r26, 0x01	; 1
    15e2:	8d 93       	st	X+, r24
    15e4:	9c 93       	st	X, r25
    15e6:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    15e8:	12 86       	std	Z+10, r1	; 0x0a
    15ea:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    15ec:	8c 91       	ld	r24, X
    15ee:	81 50       	subi	r24, 0x01	; 1
    15f0:	8c 93       	st	X, r24
    15f2:	08 95       	ret

000015f4 <pxPortInitialiseStack>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
<<<<<<< HEAD
    14a4:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <portStackTopForTask>
    14a8:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <portStackTopForTask+0x1>
    14ac:	31 e1       	ldi	r19, 0x11	; 17
    14ae:	fc 01       	movw	r30, r24
    14b0:	30 83       	st	Z, r19
    14b2:	31 97       	sbiw	r30, 0x01	; 1
    14b4:	22 e2       	ldi	r18, 0x22	; 34
    14b6:	20 83       	st	Z, r18
    14b8:	31 97       	sbiw	r30, 0x01	; 1
    14ba:	a3 e3       	ldi	r26, 0x33	; 51
    14bc:	a0 83       	st	Z, r26
    14be:	31 97       	sbiw	r30, 0x01	; 1
    14c0:	60 83       	st	Z, r22
    14c2:	31 97       	sbiw	r30, 0x01	; 1
    14c4:	70 83       	st	Z, r23
    14c6:	31 97       	sbiw	r30, 0x01	; 1
    14c8:	10 82       	st	Z, r1
    14ca:	31 97       	sbiw	r30, 0x01	; 1
    14cc:	10 82       	st	Z, r1
    14ce:	31 97       	sbiw	r30, 0x01	; 1
    14d0:	60 e8       	ldi	r22, 0x80	; 128
    14d2:	60 83       	st	Z, r22
    14d4:	31 97       	sbiw	r30, 0x01	; 1
    14d6:	10 82       	st	Z, r1
    14d8:	31 97       	sbiw	r30, 0x01	; 1
    14da:	10 82       	st	Z, r1
    14dc:	31 97       	sbiw	r30, 0x01	; 1
    14de:	10 82       	st	Z, r1
    14e0:	31 97       	sbiw	r30, 0x01	; 1
    14e2:	62 e0       	ldi	r22, 0x02	; 2
    14e4:	60 83       	st	Z, r22
    14e6:	31 97       	sbiw	r30, 0x01	; 1
    14e8:	63 e0       	ldi	r22, 0x03	; 3
    14ea:	60 83       	st	Z, r22
    14ec:	31 97       	sbiw	r30, 0x01	; 1
    14ee:	64 e0       	ldi	r22, 0x04	; 4
    14f0:	60 83       	st	Z, r22
    14f2:	31 97       	sbiw	r30, 0x01	; 1
    14f4:	65 e0       	ldi	r22, 0x05	; 5
    14f6:	60 83       	st	Z, r22
    14f8:	31 97       	sbiw	r30, 0x01	; 1
    14fa:	66 e0       	ldi	r22, 0x06	; 6
    14fc:	60 83       	st	Z, r22
    14fe:	31 97       	sbiw	r30, 0x01	; 1
    1500:	67 e0       	ldi	r22, 0x07	; 7
    1502:	60 83       	st	Z, r22
    1504:	31 97       	sbiw	r30, 0x01	; 1
    1506:	68 e0       	ldi	r22, 0x08	; 8
    1508:	60 83       	st	Z, r22
    150a:	31 97       	sbiw	r30, 0x01	; 1
    150c:	69 e0       	ldi	r22, 0x09	; 9
    150e:	60 83       	st	Z, r22
    1510:	31 97       	sbiw	r30, 0x01	; 1
    1512:	60 e1       	ldi	r22, 0x10	; 16
    1514:	60 83       	st	Z, r22
    1516:	31 97       	sbiw	r30, 0x01	; 1
    1518:	30 83       	st	Z, r19
    151a:	31 97       	sbiw	r30, 0x01	; 1
    151c:	32 e1       	ldi	r19, 0x12	; 18
    151e:	30 83       	st	Z, r19
    1520:	31 97       	sbiw	r30, 0x01	; 1
    1522:	33 e1       	ldi	r19, 0x13	; 19
    1524:	30 83       	st	Z, r19
    1526:	31 97       	sbiw	r30, 0x01	; 1
    1528:	34 e1       	ldi	r19, 0x14	; 20
    152a:	30 83       	st	Z, r19
    152c:	31 97       	sbiw	r30, 0x01	; 1
    152e:	35 e1       	ldi	r19, 0x15	; 21
    1530:	30 83       	st	Z, r19
    1532:	31 97       	sbiw	r30, 0x01	; 1
    1534:	36 e1       	ldi	r19, 0x16	; 22
    1536:	30 83       	st	Z, r19
    1538:	31 97       	sbiw	r30, 0x01	; 1
    153a:	37 e1       	ldi	r19, 0x17	; 23
    153c:	30 83       	st	Z, r19
    153e:	31 97       	sbiw	r30, 0x01	; 1
    1540:	38 e1       	ldi	r19, 0x18	; 24
    1542:	30 83       	st	Z, r19
    1544:	31 97       	sbiw	r30, 0x01	; 1
    1546:	39 e1       	ldi	r19, 0x19	; 25
    1548:	30 83       	st	Z, r19
    154a:	31 97       	sbiw	r30, 0x01	; 1
    154c:	30 e2       	ldi	r19, 0x20	; 32
    154e:	30 83       	st	Z, r19
    1550:	31 97       	sbiw	r30, 0x01	; 1
    1552:	31 e2       	ldi	r19, 0x21	; 33
    1554:	30 83       	st	Z, r19
    1556:	31 97       	sbiw	r30, 0x01	; 1
    1558:	20 83       	st	Z, r18
    155a:	31 97       	sbiw	r30, 0x01	; 1
    155c:	23 e2       	ldi	r18, 0x23	; 35
    155e:	20 83       	st	Z, r18
    1560:	31 97       	sbiw	r30, 0x01	; 1
    1562:	40 83       	st	Z, r20
    1564:	31 97       	sbiw	r30, 0x01	; 1
    1566:	50 83       	st	Z, r21
    1568:	31 97       	sbiw	r30, 0x01	; 1
    156a:	26 e2       	ldi	r18, 0x26	; 38
    156c:	20 83       	st	Z, r18
    156e:	31 97       	sbiw	r30, 0x01	; 1
    1570:	27 e2       	ldi	r18, 0x27	; 39
    1572:	20 83       	st	Z, r18
    1574:	31 97       	sbiw	r30, 0x01	; 1
    1576:	28 e2       	ldi	r18, 0x28	; 40
    1578:	20 83       	st	Z, r18
    157a:	31 97       	sbiw	r30, 0x01	; 1
    157c:	29 e2       	ldi	r18, 0x29	; 41
    157e:	20 83       	st	Z, r18
    1580:	31 97       	sbiw	r30, 0x01	; 1
    1582:	20 e3       	ldi	r18, 0x30	; 48
    1584:	20 83       	st	Z, r18
    1586:	31 97       	sbiw	r30, 0x01	; 1
    1588:	21 e3       	ldi	r18, 0x31	; 49
    158a:	20 83       	st	Z, r18
    158c:	89 97       	sbiw	r24, 0x29	; 41
    158e:	08 95       	ret

00001590 <xPortStartScheduler>:
    1590:	8c e7       	ldi	r24, 0x7C	; 124
    1592:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1596:	8f ef       	ldi	r24, 0xFF	; 255
    1598:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    159c:	81 e0       	ldi	r24, 0x01	; 1
    159e:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    15a2:	91 e1       	ldi	r25, 0x11	; 17
    15a4:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    15a8:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    15ac:	a0 91 14 31 	lds	r26, 0x3114	; 0x803114 <pxCurrentTCB>
    15b0:	b0 91 15 31 	lds	r27, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    15b4:	cd 91       	ld	r28, X+
    15b6:	cd bf       	out	0x3d, r28	; 61
    15b8:	dd 91       	ld	r29, X+
    15ba:	de bf       	out	0x3e, r29	; 62
    15bc:	ff 91       	pop	r31
    15be:	ef 91       	pop	r30
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	bf 91       	pop	r27
    15c6:	af 91       	pop	r26
    15c8:	9f 91       	pop	r25
    15ca:	8f 91       	pop	r24
    15cc:	7f 91       	pop	r23
    15ce:	6f 91       	pop	r22
    15d0:	5f 91       	pop	r21
    15d2:	4f 91       	pop	r20
    15d4:	3f 91       	pop	r19
    15d6:	2f 91       	pop	r18
    15d8:	1f 91       	pop	r17
    15da:	0f 91       	pop	r16
    15dc:	ff 90       	pop	r15
    15de:	ef 90       	pop	r14
    15e0:	df 90       	pop	r13
    15e2:	cf 90       	pop	r12
    15e4:	bf 90       	pop	r11
    15e6:	af 90       	pop	r10
    15e8:	9f 90       	pop	r9
    15ea:	8f 90       	pop	r8
    15ec:	7f 90       	pop	r7
    15ee:	6f 90       	pop	r6
    15f0:	5f 90       	pop	r5
    15f2:	4f 90       	pop	r4
    15f4:	3f 90       	pop	r3
    15f6:	2f 90       	pop	r2
    15f8:	1f 90       	pop	r1
    15fa:	0f 90       	pop	r0
    15fc:	0c be       	out	0x3c, r0	; 60
    15fe:	0f 90       	pop	r0
    1600:	0b be       	out	0x3b, r0	; 59
    1602:	0f 90       	pop	r0
    1604:	0f be       	out	0x3f, r0	; 63
    1606:	0f 90       	pop	r0
    1608:	08 95       	ret
    160a:	08 95       	ret

0000160c <vPortYield>:
=======
    15f4:	80 93 86 31 	sts	0x3186, r24	; 0x803186 <portStackTopForTask>
    15f8:	90 93 87 31 	sts	0x3187, r25	; 0x803187 <portStackTopForTask+0x1>
    15fc:	31 e1       	ldi	r19, 0x11	; 17
    15fe:	fc 01       	movw	r30, r24
    1600:	30 83       	st	Z, r19
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	22 e2       	ldi	r18, 0x22	; 34
    1606:	20 83       	st	Z, r18
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	a3 e3       	ldi	r26, 0x33	; 51
    160c:	a0 83       	st	Z, r26
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	60 83       	st	Z, r22
    1612:	31 97       	sbiw	r30, 0x01	; 1
    1614:	70 83       	st	Z, r23
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	10 82       	st	Z, r1
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	10 82       	st	Z, r1
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	60 e8       	ldi	r22, 0x80	; 128
    1622:	60 83       	st	Z, r22
    1624:	31 97       	sbiw	r30, 0x01	; 1
    1626:	10 82       	st	Z, r1
    1628:	31 97       	sbiw	r30, 0x01	; 1
    162a:	10 82       	st	Z, r1
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	10 82       	st	Z, r1
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	62 e0       	ldi	r22, 0x02	; 2
    1634:	60 83       	st	Z, r22
    1636:	31 97       	sbiw	r30, 0x01	; 1
    1638:	63 e0       	ldi	r22, 0x03	; 3
    163a:	60 83       	st	Z, r22
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	64 e0       	ldi	r22, 0x04	; 4
    1640:	60 83       	st	Z, r22
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	65 e0       	ldi	r22, 0x05	; 5
    1646:	60 83       	st	Z, r22
    1648:	31 97       	sbiw	r30, 0x01	; 1
    164a:	66 e0       	ldi	r22, 0x06	; 6
    164c:	60 83       	st	Z, r22
    164e:	31 97       	sbiw	r30, 0x01	; 1
    1650:	67 e0       	ldi	r22, 0x07	; 7
    1652:	60 83       	st	Z, r22
    1654:	31 97       	sbiw	r30, 0x01	; 1
    1656:	68 e0       	ldi	r22, 0x08	; 8
    1658:	60 83       	st	Z, r22
    165a:	31 97       	sbiw	r30, 0x01	; 1
    165c:	69 e0       	ldi	r22, 0x09	; 9
    165e:	60 83       	st	Z, r22
    1660:	31 97       	sbiw	r30, 0x01	; 1
    1662:	60 e1       	ldi	r22, 0x10	; 16
    1664:	60 83       	st	Z, r22
    1666:	31 97       	sbiw	r30, 0x01	; 1
    1668:	30 83       	st	Z, r19
    166a:	31 97       	sbiw	r30, 0x01	; 1
    166c:	32 e1       	ldi	r19, 0x12	; 18
    166e:	30 83       	st	Z, r19
    1670:	31 97       	sbiw	r30, 0x01	; 1
    1672:	33 e1       	ldi	r19, 0x13	; 19
    1674:	30 83       	st	Z, r19
    1676:	31 97       	sbiw	r30, 0x01	; 1
    1678:	34 e1       	ldi	r19, 0x14	; 20
    167a:	30 83       	st	Z, r19
    167c:	31 97       	sbiw	r30, 0x01	; 1
    167e:	35 e1       	ldi	r19, 0x15	; 21
    1680:	30 83       	st	Z, r19
    1682:	31 97       	sbiw	r30, 0x01	; 1
    1684:	36 e1       	ldi	r19, 0x16	; 22
    1686:	30 83       	st	Z, r19
    1688:	31 97       	sbiw	r30, 0x01	; 1
    168a:	37 e1       	ldi	r19, 0x17	; 23
    168c:	30 83       	st	Z, r19
    168e:	31 97       	sbiw	r30, 0x01	; 1
    1690:	38 e1       	ldi	r19, 0x18	; 24
    1692:	30 83       	st	Z, r19
    1694:	31 97       	sbiw	r30, 0x01	; 1
    1696:	39 e1       	ldi	r19, 0x19	; 25
    1698:	30 83       	st	Z, r19
    169a:	31 97       	sbiw	r30, 0x01	; 1
    169c:	30 e2       	ldi	r19, 0x20	; 32
    169e:	30 83       	st	Z, r19
    16a0:	31 97       	sbiw	r30, 0x01	; 1
    16a2:	31 e2       	ldi	r19, 0x21	; 33
    16a4:	30 83       	st	Z, r19
    16a6:	31 97       	sbiw	r30, 0x01	; 1
    16a8:	20 83       	st	Z, r18
    16aa:	31 97       	sbiw	r30, 0x01	; 1
    16ac:	23 e2       	ldi	r18, 0x23	; 35
    16ae:	20 83       	st	Z, r18
    16b0:	31 97       	sbiw	r30, 0x01	; 1
    16b2:	40 83       	st	Z, r20
    16b4:	31 97       	sbiw	r30, 0x01	; 1
    16b6:	50 83       	st	Z, r21
    16b8:	31 97       	sbiw	r30, 0x01	; 1
    16ba:	26 e2       	ldi	r18, 0x26	; 38
    16bc:	20 83       	st	Z, r18
    16be:	31 97       	sbiw	r30, 0x01	; 1
    16c0:	27 e2       	ldi	r18, 0x27	; 39
    16c2:	20 83       	st	Z, r18
    16c4:	31 97       	sbiw	r30, 0x01	; 1
    16c6:	28 e2       	ldi	r18, 0x28	; 40
    16c8:	20 83       	st	Z, r18
    16ca:	31 97       	sbiw	r30, 0x01	; 1
    16cc:	29 e2       	ldi	r18, 0x29	; 41
    16ce:	20 83       	st	Z, r18
    16d0:	31 97       	sbiw	r30, 0x01	; 1
    16d2:	20 e3       	ldi	r18, 0x30	; 48
    16d4:	20 83       	st	Z, r18
    16d6:	31 97       	sbiw	r30, 0x01	; 1
    16d8:	21 e3       	ldi	r18, 0x31	; 49
    16da:	20 83       	st	Z, r18
    16dc:	89 97       	sbiw	r24, 0x29	; 41
    16de:	08 95       	ret

000016e0 <xPortStartScheduler>:
    16e0:	8c e7       	ldi	r24, 0x7C	; 124
    16e2:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    16e6:	8f ef       	ldi	r24, 0xFF	; 255
    16e8:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    16ec:	81 e0       	ldi	r24, 0x01	; 1
    16ee:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    16f2:	91 e1       	ldi	r25, 0x11	; 17
    16f4:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    16f8:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    16fc:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    1700:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1704:	cd 91       	ld	r28, X+
    1706:	cd bf       	out	0x3d, r28	; 61
    1708:	dd 91       	ld	r29, X+
    170a:	de bf       	out	0x3e, r29	; 62
    170c:	ff 91       	pop	r31
    170e:	ef 91       	pop	r30
    1710:	df 91       	pop	r29
    1712:	cf 91       	pop	r28
    1714:	bf 91       	pop	r27
    1716:	af 91       	pop	r26
    1718:	9f 91       	pop	r25
    171a:	8f 91       	pop	r24
    171c:	7f 91       	pop	r23
    171e:	6f 91       	pop	r22
    1720:	5f 91       	pop	r21
    1722:	4f 91       	pop	r20
    1724:	3f 91       	pop	r19
    1726:	2f 91       	pop	r18
    1728:	1f 91       	pop	r17
    172a:	0f 91       	pop	r16
    172c:	ff 90       	pop	r15
    172e:	ef 90       	pop	r14
    1730:	df 90       	pop	r13
    1732:	cf 90       	pop	r12
    1734:	bf 90       	pop	r11
    1736:	af 90       	pop	r10
    1738:	9f 90       	pop	r9
    173a:	8f 90       	pop	r8
    173c:	7f 90       	pop	r7
    173e:	6f 90       	pop	r6
    1740:	5f 90       	pop	r5
    1742:	4f 90       	pop	r4
    1744:	3f 90       	pop	r3
    1746:	2f 90       	pop	r2
    1748:	1f 90       	pop	r1
    174a:	0f 90       	pop	r0
    174c:	0c be       	out	0x3c, r0	; 60
    174e:	0f 90       	pop	r0
    1750:	0b be       	out	0x3b, r0	; 59
    1752:	0f 90       	pop	r0
    1754:	0f be       	out	0x3f, r0	; 63
    1756:	0f 90       	pop	r0
    1758:	08 95       	ret
    175a:	08 95       	ret

0000175c <vPortYield>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
<<<<<<< HEAD
    160c:	0f 92       	push	r0
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	0f 92       	push	r0
    1614:	0b b6       	in	r0, 0x3b	; 59
    1616:	0f 92       	push	r0
    1618:	0c b6       	in	r0, 0x3c	; 60
    161a:	0f 92       	push	r0
    161c:	1f 92       	push	r1
    161e:	11 24       	eor	r1, r1
    1620:	2f 92       	push	r2
    1622:	3f 92       	push	r3
    1624:	4f 92       	push	r4
    1626:	5f 92       	push	r5
    1628:	6f 92       	push	r6
    162a:	7f 92       	push	r7
    162c:	8f 92       	push	r8
    162e:	9f 92       	push	r9
    1630:	af 92       	push	r10
    1632:	bf 92       	push	r11
    1634:	cf 92       	push	r12
    1636:	df 92       	push	r13
    1638:	ef 92       	push	r14
    163a:	ff 92       	push	r15
    163c:	0f 93       	push	r16
    163e:	1f 93       	push	r17
    1640:	2f 93       	push	r18
    1642:	3f 93       	push	r19
    1644:	4f 93       	push	r20
    1646:	5f 93       	push	r21
    1648:	6f 93       	push	r22
    164a:	7f 93       	push	r23
    164c:	8f 93       	push	r24
    164e:	9f 93       	push	r25
    1650:	af 93       	push	r26
    1652:	bf 93       	push	r27
    1654:	cf 93       	push	r28
    1656:	df 93       	push	r29
    1658:	ef 93       	push	r30
    165a:	ff 93       	push	r31
    165c:	a0 91 14 31 	lds	r26, 0x3114	; 0x803114 <pxCurrentTCB>
    1660:	b0 91 15 31 	lds	r27, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1664:	0d b6       	in	r0, 0x3d	; 61
    1666:	0d 92       	st	X+, r0
    1668:	0e b6       	in	r0, 0x3e	; 62
    166a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    166c:	0e 94 26 12 	call	0x244c	; 0x244c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1670:	a0 91 14 31 	lds	r26, 0x3114	; 0x803114 <pxCurrentTCB>
    1674:	b0 91 15 31 	lds	r27, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1678:	cd 91       	ld	r28, X+
    167a:	cd bf       	out	0x3d, r28	; 61
    167c:	dd 91       	ld	r29, X+
    167e:	de bf       	out	0x3e, r29	; 62
    1680:	ff 91       	pop	r31
    1682:	ef 91       	pop	r30
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
    1688:	bf 91       	pop	r27
    168a:	af 91       	pop	r26
    168c:	9f 91       	pop	r25
    168e:	8f 91       	pop	r24
    1690:	7f 91       	pop	r23
    1692:	6f 91       	pop	r22
    1694:	5f 91       	pop	r21
    1696:	4f 91       	pop	r20
    1698:	3f 91       	pop	r19
    169a:	2f 91       	pop	r18
    169c:	1f 91       	pop	r17
    169e:	0f 91       	pop	r16
    16a0:	ff 90       	pop	r15
    16a2:	ef 90       	pop	r14
    16a4:	df 90       	pop	r13
    16a6:	cf 90       	pop	r12
    16a8:	bf 90       	pop	r11
    16aa:	af 90       	pop	r10
    16ac:	9f 90       	pop	r9
    16ae:	8f 90       	pop	r8
    16b0:	7f 90       	pop	r7
    16b2:	6f 90       	pop	r6
    16b4:	5f 90       	pop	r5
    16b6:	4f 90       	pop	r4
    16b8:	3f 90       	pop	r3
    16ba:	2f 90       	pop	r2
    16bc:	1f 90       	pop	r1
    16be:	0f 90       	pop	r0
    16c0:	0c be       	out	0x3c, r0	; 60
    16c2:	0f 90       	pop	r0
    16c4:	0b be       	out	0x3b, r0	; 59
    16c6:	0f 90       	pop	r0
    16c8:	0f be       	out	0x3f, r0	; 63
    16ca:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16cc:	08 95       	ret

000016ce <vPortYieldFromTick>:
=======
    175c:	0f 92       	push	r0
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	0f 92       	push	r0
    1764:	0b b6       	in	r0, 0x3b	; 59
    1766:	0f 92       	push	r0
    1768:	0c b6       	in	r0, 0x3c	; 60
    176a:	0f 92       	push	r0
    176c:	1f 92       	push	r1
    176e:	11 24       	eor	r1, r1
    1770:	2f 92       	push	r2
    1772:	3f 92       	push	r3
    1774:	4f 92       	push	r4
    1776:	5f 92       	push	r5
    1778:	6f 92       	push	r6
    177a:	7f 92       	push	r7
    177c:	8f 92       	push	r8
    177e:	9f 92       	push	r9
    1780:	af 92       	push	r10
    1782:	bf 92       	push	r11
    1784:	cf 92       	push	r12
    1786:	df 92       	push	r13
    1788:	ef 92       	push	r14
    178a:	ff 92       	push	r15
    178c:	0f 93       	push	r16
    178e:	1f 93       	push	r17
    1790:	2f 93       	push	r18
    1792:	3f 93       	push	r19
    1794:	4f 93       	push	r20
    1796:	5f 93       	push	r21
    1798:	6f 93       	push	r22
    179a:	7f 93       	push	r23
    179c:	8f 93       	push	r24
    179e:	9f 93       	push	r25
    17a0:	af 93       	push	r26
    17a2:	bf 93       	push	r27
    17a4:	cf 93       	push	r28
    17a6:	df 93       	push	r29
    17a8:	ef 93       	push	r30
    17aa:	ff 93       	push	r31
    17ac:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    17b0:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    17b4:	0d b6       	in	r0, 0x3d	; 61
    17b6:	0d 92       	st	X+, r0
    17b8:	0e b6       	in	r0, 0x3e	; 62
    17ba:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    17bc:	0e 94 ce 12 	call	0x259c	; 0x259c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17c0:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    17c4:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    17c8:	cd 91       	ld	r28, X+
    17ca:	cd bf       	out	0x3d, r28	; 61
    17cc:	dd 91       	ld	r29, X+
    17ce:	de bf       	out	0x3e, r29	; 62
    17d0:	ff 91       	pop	r31
    17d2:	ef 91       	pop	r30
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	bf 91       	pop	r27
    17da:	af 91       	pop	r26
    17dc:	9f 91       	pop	r25
    17de:	8f 91       	pop	r24
    17e0:	7f 91       	pop	r23
    17e2:	6f 91       	pop	r22
    17e4:	5f 91       	pop	r21
    17e6:	4f 91       	pop	r20
    17e8:	3f 91       	pop	r19
    17ea:	2f 91       	pop	r18
    17ec:	1f 91       	pop	r17
    17ee:	0f 91       	pop	r16
    17f0:	ff 90       	pop	r15
    17f2:	ef 90       	pop	r14
    17f4:	df 90       	pop	r13
    17f6:	cf 90       	pop	r12
    17f8:	bf 90       	pop	r11
    17fa:	af 90       	pop	r10
    17fc:	9f 90       	pop	r9
    17fe:	8f 90       	pop	r8
    1800:	7f 90       	pop	r7
    1802:	6f 90       	pop	r6
    1804:	5f 90       	pop	r5
    1806:	4f 90       	pop	r4
    1808:	3f 90       	pop	r3
    180a:	2f 90       	pop	r2
    180c:	1f 90       	pop	r1
    180e:	0f 90       	pop	r0
    1810:	0c be       	out	0x3c, r0	; 60
    1812:	0f 90       	pop	r0
    1814:	0b be       	out	0x3b, r0	; 59
    1816:	0f 90       	pop	r0
    1818:	0f be       	out	0x3f, r0	; 63
    181a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    181c:	08 95       	ret

0000181e <vPortYieldFromTick>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
<<<<<<< HEAD
    16ce:	0f 92       	push	r0
    16d0:	0f b6       	in	r0, 0x3f	; 63
    16d2:	f8 94       	cli
    16d4:	0f 92       	push	r0
    16d6:	0b b6       	in	r0, 0x3b	; 59
    16d8:	0f 92       	push	r0
    16da:	0c b6       	in	r0, 0x3c	; 60
    16dc:	0f 92       	push	r0
    16de:	1f 92       	push	r1
    16e0:	11 24       	eor	r1, r1
    16e2:	2f 92       	push	r2
    16e4:	3f 92       	push	r3
    16e6:	4f 92       	push	r4
    16e8:	5f 92       	push	r5
    16ea:	6f 92       	push	r6
    16ec:	7f 92       	push	r7
    16ee:	8f 92       	push	r8
    16f0:	9f 92       	push	r9
    16f2:	af 92       	push	r10
    16f4:	bf 92       	push	r11
    16f6:	cf 92       	push	r12
    16f8:	df 92       	push	r13
    16fa:	ef 92       	push	r14
    16fc:	ff 92       	push	r15
    16fe:	0f 93       	push	r16
    1700:	1f 93       	push	r17
    1702:	2f 93       	push	r18
    1704:	3f 93       	push	r19
    1706:	4f 93       	push	r20
    1708:	5f 93       	push	r21
    170a:	6f 93       	push	r22
    170c:	7f 93       	push	r23
    170e:	8f 93       	push	r24
    1710:	9f 93       	push	r25
    1712:	af 93       	push	r26
    1714:	bf 93       	push	r27
    1716:	cf 93       	push	r28
    1718:	df 93       	push	r29
    171a:	ef 93       	push	r30
    171c:	ff 93       	push	r31
    171e:	a0 91 14 31 	lds	r26, 0x3114	; 0x803114 <pxCurrentTCB>
    1722:	b0 91 15 31 	lds	r27, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1726:	0d b6       	in	r0, 0x3d	; 61
    1728:	0d 92       	st	X+, r0
    172a:	0e b6       	in	r0, 0x3e	; 62
    172c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    172e:	0e 94 08 10 	call	0x2010	; 0x2010 <vTaskIncrementTick>
	vTaskSwitchContext();
    1732:	0e 94 26 12 	call	0x244c	; 0x244c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1736:	a0 91 14 31 	lds	r26, 0x3114	; 0x803114 <pxCurrentTCB>
    173a:	b0 91 15 31 	lds	r27, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    173e:	cd 91       	ld	r28, X+
    1740:	cd bf       	out	0x3d, r28	; 61
    1742:	dd 91       	ld	r29, X+
    1744:	de bf       	out	0x3e, r29	; 62
    1746:	ff 91       	pop	r31
    1748:	ef 91       	pop	r30
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	bf 91       	pop	r27
    1750:	af 91       	pop	r26
    1752:	9f 91       	pop	r25
    1754:	8f 91       	pop	r24
    1756:	7f 91       	pop	r23
    1758:	6f 91       	pop	r22
    175a:	5f 91       	pop	r21
    175c:	4f 91       	pop	r20
    175e:	3f 91       	pop	r19
    1760:	2f 91       	pop	r18
    1762:	1f 91       	pop	r17
    1764:	0f 91       	pop	r16
    1766:	ff 90       	pop	r15
    1768:	ef 90       	pop	r14
    176a:	df 90       	pop	r13
    176c:	cf 90       	pop	r12
    176e:	bf 90       	pop	r11
    1770:	af 90       	pop	r10
    1772:	9f 90       	pop	r9
    1774:	8f 90       	pop	r8
    1776:	7f 90       	pop	r7
    1778:	6f 90       	pop	r6
    177a:	5f 90       	pop	r5
    177c:	4f 90       	pop	r4
    177e:	3f 90       	pop	r3
    1780:	2f 90       	pop	r2
    1782:	1f 90       	pop	r1
    1784:	0f 90       	pop	r0
    1786:	0c be       	out	0x3c, r0	; 60
    1788:	0f 90       	pop	r0
    178a:	0b be       	out	0x3b, r0	; 59
    178c:	0f 90       	pop	r0
    178e:	0f be       	out	0x3f, r0	; 63
    1790:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1792:	08 95       	ret

00001794 <__vector_49>:
=======
    181e:	0f 92       	push	r0
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	f8 94       	cli
    1824:	0f 92       	push	r0
    1826:	0b b6       	in	r0, 0x3b	; 59
    1828:	0f 92       	push	r0
    182a:	0c b6       	in	r0, 0x3c	; 60
    182c:	0f 92       	push	r0
    182e:	1f 92       	push	r1
    1830:	11 24       	eor	r1, r1
    1832:	2f 92       	push	r2
    1834:	3f 92       	push	r3
    1836:	4f 92       	push	r4
    1838:	5f 92       	push	r5
    183a:	6f 92       	push	r6
    183c:	7f 92       	push	r7
    183e:	8f 92       	push	r8
    1840:	9f 92       	push	r9
    1842:	af 92       	push	r10
    1844:	bf 92       	push	r11
    1846:	cf 92       	push	r12
    1848:	df 92       	push	r13
    184a:	ef 92       	push	r14
    184c:	ff 92       	push	r15
    184e:	0f 93       	push	r16
    1850:	1f 93       	push	r17
    1852:	2f 93       	push	r18
    1854:	3f 93       	push	r19
    1856:	4f 93       	push	r20
    1858:	5f 93       	push	r21
    185a:	6f 93       	push	r22
    185c:	7f 93       	push	r23
    185e:	8f 93       	push	r24
    1860:	9f 93       	push	r25
    1862:	af 93       	push	r26
    1864:	bf 93       	push	r27
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	ef 93       	push	r30
    186c:	ff 93       	push	r31
    186e:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    1872:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1876:	0d b6       	in	r0, 0x3d	; 61
    1878:	0d 92       	st	X+, r0
    187a:	0e b6       	in	r0, 0x3e	; 62
    187c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    187e:	0e 94 b0 10 	call	0x2160	; 0x2160 <vTaskIncrementTick>
	vTaskSwitchContext();
    1882:	0e 94 ce 12 	call	0x259c	; 0x259c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1886:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    188a:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    188e:	cd 91       	ld	r28, X+
    1890:	cd bf       	out	0x3d, r28	; 61
    1892:	dd 91       	ld	r29, X+
    1894:	de bf       	out	0x3e, r29	; 62
    1896:	ff 91       	pop	r31
    1898:	ef 91       	pop	r30
    189a:	df 91       	pop	r29
    189c:	cf 91       	pop	r28
    189e:	bf 91       	pop	r27
    18a0:	af 91       	pop	r26
    18a2:	9f 91       	pop	r25
    18a4:	8f 91       	pop	r24
    18a6:	7f 91       	pop	r23
    18a8:	6f 91       	pop	r22
    18aa:	5f 91       	pop	r21
    18ac:	4f 91       	pop	r20
    18ae:	3f 91       	pop	r19
    18b0:	2f 91       	pop	r18
    18b2:	1f 91       	pop	r17
    18b4:	0f 91       	pop	r16
    18b6:	ff 90       	pop	r15
    18b8:	ef 90       	pop	r14
    18ba:	df 90       	pop	r13
    18bc:	cf 90       	pop	r12
    18be:	bf 90       	pop	r11
    18c0:	af 90       	pop	r10
    18c2:	9f 90       	pop	r9
    18c4:	8f 90       	pop	r8
    18c6:	7f 90       	pop	r7
    18c8:	6f 90       	pop	r6
    18ca:	5f 90       	pop	r5
    18cc:	4f 90       	pop	r4
    18ce:	3f 90       	pop	r3
    18d0:	2f 90       	pop	r2
    18d2:	1f 90       	pop	r1
    18d4:	0f 90       	pop	r0
    18d6:	0c be       	out	0x3c, r0	; 60
    18d8:	0f 90       	pop	r0
    18da:	0b be       	out	0x3b, r0	; 59
    18dc:	0f 90       	pop	r0
    18de:	0f be       	out	0x3f, r0	; 63
    18e0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18e2:	08 95       	ret

000018e4 <__vector_49>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
<<<<<<< HEAD
    1794:	0e 94 67 0b 	call	0x16ce	; 0x16ce <vPortYieldFromTick>
		asm volatile ( "reti" );
    1798:	18 95       	reti

0000179a <prvCopyDataToQueue>:
=======
    18e4:	0e 94 0f 0c 	call	0x181e	; 0x181e <vPortYieldFromTick>
		asm volatile ( "reti" );
    18e8:	18 95       	reti

000018ea <prvCopyDataToQueue>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
<<<<<<< HEAD
    179a:	cf 93       	push	r28
    179c:	df 93       	push	r29
    179e:	ec 01       	movw	r28, r24
    17a0:	88 a1       	ldd	r24, Y+32	; 0x20
    17a2:	81 11       	cpse	r24, r1
    17a4:	0b c0       	rjmp	.+22     	; 0x17bc <prvCopyDataToQueue+0x22>
    17a6:	88 81       	ld	r24, Y
    17a8:	99 81       	ldd	r25, Y+1	; 0x01
    17aa:	89 2b       	or	r24, r25
    17ac:	e1 f5       	brne	.+120    	; 0x1826 <prvCopyDataToQueue+0x8c>
    17ae:	8a 81       	ldd	r24, Y+2	; 0x02
    17b0:	9b 81       	ldd	r25, Y+3	; 0x03
    17b2:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <vTaskPriorityDisinherit>
    17b6:	1a 82       	std	Y+2, r1	; 0x02
    17b8:	1b 82       	std	Y+3, r1	; 0x03
    17ba:	35 c0       	rjmp	.+106    	; 0x1826 <prvCopyDataToQueue+0x8c>
    17bc:	41 11       	cpse	r20, r1
    17be:	17 c0       	rjmp	.+46     	; 0x17ee <prvCopyDataToQueue+0x54>
    17c0:	48 2f       	mov	r20, r24
    17c2:	50 e0       	ldi	r21, 0x00	; 0
    17c4:	8c 81       	ldd	r24, Y+4	; 0x04
    17c6:	9d 81       	ldd	r25, Y+5	; 0x05
    17c8:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <memcpy>
    17cc:	28 a1       	ldd	r18, Y+32	; 0x20
    17ce:	8c 81       	ldd	r24, Y+4	; 0x04
    17d0:	9d 81       	ldd	r25, Y+5	; 0x05
    17d2:	82 0f       	add	r24, r18
    17d4:	91 1d       	adc	r25, r1
    17d6:	8c 83       	std	Y+4, r24	; 0x04
    17d8:	9d 83       	std	Y+5, r25	; 0x05
    17da:	2a 81       	ldd	r18, Y+2	; 0x02
    17dc:	3b 81       	ldd	r19, Y+3	; 0x03
    17de:	82 17       	cp	r24, r18
    17e0:	93 07       	cpc	r25, r19
    17e2:	08 f1       	brcs	.+66     	; 0x1826 <prvCopyDataToQueue+0x8c>
    17e4:	88 81       	ld	r24, Y
    17e6:	99 81       	ldd	r25, Y+1	; 0x01
    17e8:	8c 83       	std	Y+4, r24	; 0x04
    17ea:	9d 83       	std	Y+5, r25	; 0x05
    17ec:	1c c0       	rjmp	.+56     	; 0x1826 <prvCopyDataToQueue+0x8c>
    17ee:	48 2f       	mov	r20, r24
    17f0:	50 e0       	ldi	r21, 0x00	; 0
    17f2:	8e 81       	ldd	r24, Y+6	; 0x06
    17f4:	9f 81       	ldd	r25, Y+7	; 0x07
    17f6:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <memcpy>
    17fa:	88 a1       	ldd	r24, Y+32	; 0x20
    17fc:	90 e0       	ldi	r25, 0x00	; 0
    17fe:	91 95       	neg	r25
    1800:	81 95       	neg	r24
    1802:	91 09       	sbc	r25, r1
    1804:	2e 81       	ldd	r18, Y+6	; 0x06
    1806:	3f 81       	ldd	r19, Y+7	; 0x07
    1808:	28 0f       	add	r18, r24
    180a:	39 1f       	adc	r19, r25
    180c:	2e 83       	std	Y+6, r18	; 0x06
    180e:	3f 83       	std	Y+7, r19	; 0x07
    1810:	48 81       	ld	r20, Y
    1812:	59 81       	ldd	r21, Y+1	; 0x01
    1814:	24 17       	cp	r18, r20
    1816:	35 07       	cpc	r19, r21
    1818:	30 f4       	brcc	.+12     	; 0x1826 <prvCopyDataToQueue+0x8c>
    181a:	2a 81       	ldd	r18, Y+2	; 0x02
    181c:	3b 81       	ldd	r19, Y+3	; 0x03
    181e:	82 0f       	add	r24, r18
    1820:	93 1f       	adc	r25, r19
    1822:	8e 83       	std	Y+6, r24	; 0x06
    1824:	9f 83       	std	Y+7, r25	; 0x07
    1826:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1828:	8f 5f       	subi	r24, 0xFF	; 255
    182a:	8e 8f       	std	Y+30, r24	; 0x1e
    182c:	df 91       	pop	r29
    182e:	cf 91       	pop	r28
    1830:	08 95       	ret

00001832 <prvCopyDataFromQueue>:
    1832:	fc 01       	movw	r30, r24
    1834:	80 81       	ld	r24, Z
    1836:	91 81       	ldd	r25, Z+1	; 0x01
    1838:	00 97       	sbiw	r24, 0x00	; 0
    183a:	a1 f0       	breq	.+40     	; 0x1864 <prvCopyDataFromQueue+0x32>
    183c:	40 a1       	ldd	r20, Z+32	; 0x20
    183e:	50 e0       	ldi	r21, 0x00	; 0
    1840:	26 81       	ldd	r18, Z+6	; 0x06
    1842:	37 81       	ldd	r19, Z+7	; 0x07
    1844:	24 0f       	add	r18, r20
    1846:	35 1f       	adc	r19, r21
    1848:	26 83       	std	Z+6, r18	; 0x06
    184a:	37 83       	std	Z+7, r19	; 0x07
    184c:	a2 81       	ldd	r26, Z+2	; 0x02
    184e:	b3 81       	ldd	r27, Z+3	; 0x03
    1850:	2a 17       	cp	r18, r26
    1852:	3b 07       	cpc	r19, r27
    1854:	10 f0       	brcs	.+4      	; 0x185a <prvCopyDataFromQueue+0x28>
    1856:	86 83       	std	Z+6, r24	; 0x06
    1858:	97 83       	std	Z+7, r25	; 0x07
    185a:	cb 01       	movw	r24, r22
    185c:	66 81       	ldd	r22, Z+6	; 0x06
    185e:	77 81       	ldd	r23, Z+7	; 0x07
    1860:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <memcpy>
    1864:	08 95       	ret

00001866 <prvUnlockQueue>:
    1866:	0f 93       	push	r16
    1868:	1f 93       	push	r17
    186a:	cf 93       	push	r28
    186c:	df 93       	push	r29
    186e:	ec 01       	movw	r28, r24
    1870:	0f b6       	in	r0, 0x3f	; 63
    1872:	f8 94       	cli
    1874:	0f 92       	push	r0
    1876:	8a a1       	ldd	r24, Y+34	; 0x22
    1878:	18 16       	cp	r1, r24
    187a:	b4 f4       	brge	.+44     	; 0x18a8 <prvUnlockQueue+0x42>
    187c:	8b 89       	ldd	r24, Y+19	; 0x13
    187e:	81 11       	cpse	r24, r1
    1880:	05 c0       	rjmp	.+10     	; 0x188c <prvUnlockQueue+0x26>
    1882:	12 c0       	rjmp	.+36     	; 0x18a8 <prvUnlockQueue+0x42>
    1884:	8b 89       	ldd	r24, Y+19	; 0x13
    1886:	81 11       	cpse	r24, r1
    1888:	04 c0       	rjmp	.+8      	; 0x1892 <prvUnlockQueue+0x2c>
    188a:	0e c0       	rjmp	.+28     	; 0x18a8 <prvUnlockQueue+0x42>
    188c:	8e 01       	movw	r16, r28
    188e:	0d 5e       	subi	r16, 0xED	; 237
    1890:	1f 4f       	sbci	r17, 0xFF	; 255
    1892:	c8 01       	movw	r24, r16
    1894:	0e 94 ad 12 	call	0x255a	; 0x255a <xTaskRemoveFromEventList>
    1898:	81 11       	cpse	r24, r1
    189a:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <vTaskMissedYield>
    189e:	8a a1       	ldd	r24, Y+34	; 0x22
    18a0:	81 50       	subi	r24, 0x01	; 1
    18a2:	8a a3       	std	Y+34, r24	; 0x22
    18a4:	18 16       	cp	r1, r24
    18a6:	74 f3       	brlt	.-36     	; 0x1884 <prvUnlockQueue+0x1e>
    18a8:	8f ef       	ldi	r24, 0xFF	; 255
    18aa:	8a a3       	std	Y+34, r24	; 0x22
    18ac:	0f 90       	pop	r0
    18ae:	0f be       	out	0x3f, r0	; 63
    18b0:	0f b6       	in	r0, 0x3f	; 63
    18b2:	f8 94       	cli
    18b4:	0f 92       	push	r0
    18b6:	89 a1       	ldd	r24, Y+33	; 0x21
    18b8:	18 16       	cp	r1, r24
    18ba:	b4 f4       	brge	.+44     	; 0x18e8 <prvUnlockQueue+0x82>
    18bc:	88 85       	ldd	r24, Y+8	; 0x08
    18be:	81 11       	cpse	r24, r1
    18c0:	05 c0       	rjmp	.+10     	; 0x18cc <prvUnlockQueue+0x66>
    18c2:	12 c0       	rjmp	.+36     	; 0x18e8 <prvUnlockQueue+0x82>
    18c4:	88 85       	ldd	r24, Y+8	; 0x08
    18c6:	81 11       	cpse	r24, r1
    18c8:	04 c0       	rjmp	.+8      	; 0x18d2 <prvUnlockQueue+0x6c>
    18ca:	0e c0       	rjmp	.+28     	; 0x18e8 <prvUnlockQueue+0x82>
    18cc:	8e 01       	movw	r16, r28
    18ce:	08 5f       	subi	r16, 0xF8	; 248
    18d0:	1f 4f       	sbci	r17, 0xFF	; 255
    18d2:	c8 01       	movw	r24, r16
    18d4:	0e 94 ad 12 	call	0x255a	; 0x255a <xTaskRemoveFromEventList>
    18d8:	81 11       	cpse	r24, r1
    18da:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <vTaskMissedYield>
    18de:	89 a1       	ldd	r24, Y+33	; 0x21
    18e0:	81 50       	subi	r24, 0x01	; 1
    18e2:	89 a3       	std	Y+33, r24	; 0x21
    18e4:	18 16       	cp	r1, r24
    18e6:	74 f3       	brlt	.-36     	; 0x18c4 <prvUnlockQueue+0x5e>
    18e8:	8f ef       	ldi	r24, 0xFF	; 255
    18ea:	89 a3       	std	Y+33, r24	; 0x21
    18ec:	0f 90       	pop	r0
    18ee:	0f be       	out	0x3f, r0	; 63
    18f0:	df 91       	pop	r29
    18f2:	cf 91       	pop	r28
    18f4:	1f 91       	pop	r17
    18f6:	0f 91       	pop	r16
    18f8:	08 95       	ret

000018fa <xQueueGenericReset>:
    18fa:	1f 93       	push	r17
    18fc:	cf 93       	push	r28
    18fe:	df 93       	push	r29
    1900:	61 30       	cpi	r22, 0x01	; 1
    1902:	59 f0       	breq	.+22     	; 0x191a <xQueueGenericReset+0x20>
    1904:	fc 01       	movw	r30, r24
    1906:	23 89       	ldd	r18, Z+19	; 0x13
    1908:	30 85       	ldd	r19, Z+8	; 0x08
    190a:	31 11       	cpse	r19, r1
    190c:	2c c0       	rjmp	.+88     	; 0x1966 <xQueueGenericReset+0x6c>
    190e:	11 e0       	ldi	r17, 0x01	; 1
    1910:	21 11       	cpse	r18, r1
    1912:	10 e0       	ldi	r17, 0x00	; 0
    1914:	21 11       	cpse	r18, r1
    1916:	28 c0       	rjmp	.+80     	; 0x1968 <xQueueGenericReset+0x6e>
    1918:	01 c0       	rjmp	.+2      	; 0x191c <xQueueGenericReset+0x22>
    191a:	11 e0       	ldi	r17, 0x01	; 1
    191c:	ec 01       	movw	r28, r24
    191e:	48 81       	ld	r20, Y
    1920:	59 81       	ldd	r21, Y+1	; 0x01
    1922:	28 a1       	ldd	r18, Y+32	; 0x20
    1924:	30 e0       	ldi	r19, 0x00	; 0
    1926:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1928:	62 9f       	mul	r22, r18
    192a:	c0 01       	movw	r24, r0
    192c:	63 9f       	mul	r22, r19
    192e:	90 0d       	add	r25, r0
    1930:	11 24       	eor	r1, r1
    1932:	ba 01       	movw	r22, r20
    1934:	68 0f       	add	r22, r24
    1936:	79 1f       	adc	r23, r25
    1938:	6a 83       	std	Y+2, r22	; 0x02
    193a:	7b 83       	std	Y+3, r23	; 0x03
    193c:	1e 8e       	std	Y+30, r1	; 0x1e
    193e:	4c 83       	std	Y+4, r20	; 0x04
    1940:	5d 83       	std	Y+5, r21	; 0x05
    1942:	82 1b       	sub	r24, r18
    1944:	93 0b       	sbc	r25, r19
    1946:	84 0f       	add	r24, r20
    1948:	95 1f       	adc	r25, r21
    194a:	8e 83       	std	Y+6, r24	; 0x06
    194c:	9f 83       	std	Y+7, r25	; 0x07
    194e:	8f ef       	ldi	r24, 0xFF	; 255
    1950:	89 a3       	std	Y+33, r24	; 0x21
    1952:	8a a3       	std	Y+34, r24	; 0x22
    1954:	ce 01       	movw	r24, r28
    1956:	08 96       	adiw	r24, 0x08	; 8
    1958:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    195c:	ce 01       	movw	r24, r28
    195e:	43 96       	adiw	r24, 0x13	; 19
    1960:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    1964:	01 c0       	rjmp	.+2      	; 0x1968 <xQueueGenericReset+0x6e>
    1966:	10 e0       	ldi	r17, 0x00	; 0
    1968:	81 2f       	mov	r24, r17
    196a:	df 91       	pop	r29
    196c:	cf 91       	pop	r28
    196e:	1f 91       	pop	r17
    1970:	08 95       	ret

00001972 <xQueueGenericCreate>:
    1972:	0f 93       	push	r16
    1974:	1f 93       	push	r17
    1976:	cf 93       	push	r28
    1978:	df 93       	push	r29
    197a:	88 23       	and	r24, r24
    197c:	01 f1       	breq	.+64     	; 0x19be <xQueueGenericCreate+0x4c>
    197e:	06 2f       	mov	r16, r22
    1980:	18 2f       	mov	r17, r24
    1982:	83 e2       	ldi	r24, 0x23	; 35
    1984:	90 e0       	ldi	r25, 0x00	; 0
    1986:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <pvPortMalloc>
    198a:	ec 01       	movw	r28, r24
    198c:	89 2b       	or	r24, r25
    198e:	c9 f0       	breq	.+50     	; 0x19c2 <xQueueGenericCreate+0x50>
    1990:	10 9f       	mul	r17, r16
    1992:	c0 01       	movw	r24, r0
    1994:	11 24       	eor	r1, r1
    1996:	01 96       	adiw	r24, 0x01	; 1
    1998:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <pvPortMalloc>
    199c:	88 83       	st	Y, r24
    199e:	99 83       	std	Y+1, r25	; 0x01
    19a0:	89 2b       	or	r24, r25
    19a2:	39 f0       	breq	.+14     	; 0x19b2 <xQueueGenericCreate+0x40>
    19a4:	1f 8f       	std	Y+31, r17	; 0x1f
    19a6:	08 a3       	std	Y+32, r16	; 0x20
    19a8:	61 e0       	ldi	r22, 0x01	; 1
    19aa:	ce 01       	movw	r24, r28
    19ac:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <xQueueGenericReset>
    19b0:	08 c0       	rjmp	.+16     	; 0x19c2 <xQueueGenericCreate+0x50>
    19b2:	ce 01       	movw	r24, r28
    19b4:	0e 94 6d 09 	call	0x12da	; 0x12da <vPortFree>
    19b8:	c0 e0       	ldi	r28, 0x00	; 0
    19ba:	d0 e0       	ldi	r29, 0x00	; 0
    19bc:	02 c0       	rjmp	.+4      	; 0x19c2 <xQueueGenericCreate+0x50>
    19be:	c0 e0       	ldi	r28, 0x00	; 0
    19c0:	d0 e0       	ldi	r29, 0x00	; 0
    19c2:	ce 01       	movw	r24, r28
    19c4:	df 91       	pop	r29
    19c6:	cf 91       	pop	r28
    19c8:	1f 91       	pop	r17
    19ca:	0f 91       	pop	r16
    19cc:	08 95       	ret

000019ce <xQueueGenericSend>:
    19ce:	af 92       	push	r10
    19d0:	bf 92       	push	r11
    19d2:	cf 92       	push	r12
    19d4:	df 92       	push	r13
    19d6:	ef 92       	push	r14
    19d8:	ff 92       	push	r15
    19da:	0f 93       	push	r16
    19dc:	1f 93       	push	r17
    19de:	cf 93       	push	r28
    19e0:	df 93       	push	r29
    19e2:	cd b7       	in	r28, 0x3d	; 61
    19e4:	de b7       	in	r29, 0x3e	; 62
    19e6:	29 97       	sbiw	r28, 0x09	; 9
    19e8:	cd bf       	out	0x3d, r28	; 61
    19ea:	de bf       	out	0x3e, r29	; 62
    19ec:	7c 01       	movw	r14, r24
    19ee:	5b 01       	movw	r10, r22
    19f0:	2e 83       	std	Y+6, r18	; 0x06
    19f2:	3f 83       	std	Y+7, r19	; 0x07
    19f4:	48 87       	std	Y+8, r20	; 0x08
    19f6:	59 87       	std	Y+9, r21	; 0x09
    19f8:	10 e0       	ldi	r17, 0x00	; 0
    19fa:	6c 01       	movw	r12, r24
    19fc:	88 e0       	ldi	r24, 0x08	; 8
    19fe:	c8 0e       	add	r12, r24
    1a00:	d1 1c       	adc	r13, r1
    1a02:	0f b6       	in	r0, 0x3f	; 63
    1a04:	f8 94       	cli
    1a06:	0f 92       	push	r0
    1a08:	f7 01       	movw	r30, r14
    1a0a:	96 8d       	ldd	r25, Z+30	; 0x1e
    1a0c:	87 8d       	ldd	r24, Z+31	; 0x1f
    1a0e:	98 17       	cp	r25, r24
    1a10:	a8 f4       	brcc	.+42     	; 0x1a3c <xQueueGenericSend+0x6e>
    1a12:	40 2f       	mov	r20, r16
    1a14:	b5 01       	movw	r22, r10
    1a16:	c7 01       	movw	r24, r14
    1a18:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvCopyDataToQueue>
    1a1c:	f7 01       	movw	r30, r14
    1a1e:	83 89       	ldd	r24, Z+19	; 0x13
    1a20:	88 23       	and	r24, r24
    1a22:	41 f0       	breq	.+16     	; 0x1a34 <xQueueGenericSend+0x66>
    1a24:	c7 01       	movw	r24, r14
    1a26:	43 96       	adiw	r24, 0x13	; 19
    1a28:	0e 94 ad 12 	call	0x255a	; 0x255a <xTaskRemoveFromEventList>
    1a2c:	81 30       	cpi	r24, 0x01	; 1
    1a2e:	11 f4       	brne	.+4      	; 0x1a34 <xQueueGenericSend+0x66>
    1a30:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
    1a34:	0f 90       	pop	r0
    1a36:	0f be       	out	0x3f, r0	; 63
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	56 c0       	rjmp	.+172    	; 0x1ae8 <xQueueGenericSend+0x11a>
    1a3c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a3e:	9f 81       	ldd	r25, Y+7	; 0x07
    1a40:	a8 85       	ldd	r26, Y+8	; 0x08
    1a42:	b9 85       	ldd	r27, Y+9	; 0x09
    1a44:	89 2b       	or	r24, r25
    1a46:	8a 2b       	or	r24, r26
    1a48:	8b 2b       	or	r24, r27
    1a4a:	21 f4       	brne	.+8      	; 0x1a54 <xQueueGenericSend+0x86>
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63
    1a50:	80 e0       	ldi	r24, 0x00	; 0
    1a52:	4a c0       	rjmp	.+148    	; 0x1ae8 <xQueueGenericSend+0x11a>
    1a54:	11 11       	cpse	r17, r1
    1a56:	05 c0       	rjmp	.+10     	; 0x1a62 <xQueueGenericSend+0x94>
    1a58:	ce 01       	movw	r24, r28
    1a5a:	01 96       	adiw	r24, 0x01	; 1
    1a5c:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <vTaskSetTimeOutState>
    1a60:	11 e0       	ldi	r17, 0x01	; 1
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskSuspendAll>
    1a6a:	0f b6       	in	r0, 0x3f	; 63
    1a6c:	f8 94       	cli
    1a6e:	0f 92       	push	r0
    1a70:	f7 01       	movw	r30, r14
    1a72:	81 a1       	ldd	r24, Z+33	; 0x21
    1a74:	8f 3f       	cpi	r24, 0xFF	; 255
    1a76:	09 f4       	brne	.+2      	; 0x1a7a <xQueueGenericSend+0xac>
    1a78:	11 a2       	std	Z+33, r1	; 0x21
    1a7a:	f7 01       	movw	r30, r14
    1a7c:	82 a1       	ldd	r24, Z+34	; 0x22
    1a7e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a80:	09 f4       	brne	.+2      	; 0x1a84 <xQueueGenericSend+0xb6>
    1a82:	12 a2       	std	Z+34, r1	; 0x22
    1a84:	0f 90       	pop	r0
    1a86:	0f be       	out	0x3f, r0	; 63
    1a88:	be 01       	movw	r22, r28
    1a8a:	6a 5f       	subi	r22, 0xFA	; 250
    1a8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a8e:	ce 01       	movw	r24, r28
    1a90:	01 96       	adiw	r24, 0x01	; 1
    1a92:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskCheckForTimeOut>
    1a96:	81 11       	cpse	r24, r1
    1a98:	21 c0       	rjmp	.+66     	; 0x1adc <xQueueGenericSend+0x10e>
    1a9a:	0f b6       	in	r0, 0x3f	; 63
    1a9c:	f8 94       	cli
    1a9e:	0f 92       	push	r0
    1aa0:	f7 01       	movw	r30, r14
    1aa2:	96 8d       	ldd	r25, Z+30	; 0x1e
    1aa4:	0f 90       	pop	r0
    1aa6:	0f be       	out	0x3f, r0	; 63
    1aa8:	87 8d       	ldd	r24, Z+31	; 0x1f
    1aaa:	98 13       	cpse	r25, r24
    1aac:	11 c0       	rjmp	.+34     	; 0x1ad0 <xQueueGenericSend+0x102>
    1aae:	4e 81       	ldd	r20, Y+6	; 0x06
    1ab0:	5f 81       	ldd	r21, Y+7	; 0x07
    1ab2:	68 85       	ldd	r22, Y+8	; 0x08
    1ab4:	79 85       	ldd	r23, Y+9	; 0x09
    1ab6:	c6 01       	movw	r24, r12
    1ab8:	0e 94 83 12 	call	0x2506	; 0x2506 <vTaskPlaceOnEventList>
    1abc:	c7 01       	movw	r24, r14
    1abe:	0e 94 33 0c 	call	0x1866	; 0x1866 <prvUnlockQueue>
    1ac2:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
    1ac6:	81 11       	cpse	r24, r1
    1ac8:	9c cf       	rjmp	.-200    	; 0x1a02 <xQueueGenericSend+0x34>
    1aca:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
    1ace:	99 cf       	rjmp	.-206    	; 0x1a02 <xQueueGenericSend+0x34>
    1ad0:	c7 01       	movw	r24, r14
    1ad2:	0e 94 33 0c 	call	0x1866	; 0x1866 <prvUnlockQueue>
    1ad6:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
    1ada:	93 cf       	rjmp	.-218    	; 0x1a02 <xQueueGenericSend+0x34>
    1adc:	c7 01       	movw	r24, r14
    1ade:	0e 94 33 0c 	call	0x1866	; 0x1866 <prvUnlockQueue>
    1ae2:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
    1ae6:	80 e0       	ldi	r24, 0x00	; 0
    1ae8:	29 96       	adiw	r28, 0x09	; 9
    1aea:	cd bf       	out	0x3d, r28	; 61
    1aec:	de bf       	out	0x3e, r29	; 62
    1aee:	df 91       	pop	r29
    1af0:	cf 91       	pop	r28
    1af2:	1f 91       	pop	r17
    1af4:	0f 91       	pop	r16
    1af6:	ff 90       	pop	r15
    1af8:	ef 90       	pop	r14
    1afa:	df 90       	pop	r13
    1afc:	cf 90       	pop	r12
    1afe:	bf 90       	pop	r11
    1b00:	af 90       	pop	r10
    1b02:	08 95       	ret

00001b04 <xQueueGenericReceive>:
    1b04:	af 92       	push	r10
    1b06:	bf 92       	push	r11
    1b08:	cf 92       	push	r12
    1b0a:	df 92       	push	r13
    1b0c:	ef 92       	push	r14
    1b0e:	ff 92       	push	r15
    1b10:	0f 93       	push	r16
    1b12:	1f 93       	push	r17
    1b14:	cf 93       	push	r28
    1b16:	df 93       	push	r29
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	29 97       	sbiw	r28, 0x09	; 9
    1b1e:	cd bf       	out	0x3d, r28	; 61
    1b20:	de bf       	out	0x3e, r29	; 62
    1b22:	7c 01       	movw	r14, r24
    1b24:	5b 01       	movw	r10, r22
    1b26:	2e 83       	std	Y+6, r18	; 0x06
    1b28:	3f 83       	std	Y+7, r19	; 0x07
    1b2a:	48 87       	std	Y+8, r20	; 0x08
    1b2c:	59 87       	std	Y+9, r21	; 0x09
    1b2e:	10 e0       	ldi	r17, 0x00	; 0
    1b30:	6c 01       	movw	r12, r24
    1b32:	83 e1       	ldi	r24, 0x13	; 19
    1b34:	c8 0e       	add	r12, r24
    1b36:	d1 1c       	adc	r13, r1
    1b38:	0f b6       	in	r0, 0x3f	; 63
    1b3a:	f8 94       	cli
    1b3c:	0f 92       	push	r0
    1b3e:	f7 01       	movw	r30, r14
    1b40:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b42:	88 23       	and	r24, r24
    1b44:	99 f1       	breq	.+102    	; 0x1bac <xQueueGenericReceive+0xa8>
    1b46:	c6 80       	ldd	r12, Z+6	; 0x06
    1b48:	d7 80       	ldd	r13, Z+7	; 0x07
    1b4a:	b5 01       	movw	r22, r10
    1b4c:	c7 01       	movw	r24, r14
    1b4e:	0e 94 19 0c 	call	0x1832	; 0x1832 <prvCopyDataFromQueue>
    1b52:	01 11       	cpse	r16, r1
    1b54:	1a c0       	rjmp	.+52     	; 0x1b8a <xQueueGenericReceive+0x86>
    1b56:	f7 01       	movw	r30, r14
    1b58:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b5a:	81 50       	subi	r24, 0x01	; 1
    1b5c:	86 8f       	std	Z+30, r24	; 0x1e
    1b5e:	80 81       	ld	r24, Z
    1b60:	91 81       	ldd	r25, Z+1	; 0x01
    1b62:	89 2b       	or	r24, r25
    1b64:	29 f4       	brne	.+10     	; 0x1b70 <xQueueGenericReceive+0x6c>
    1b66:	0e 94 87 13 	call	0x270e	; 0x270e <xTaskGetCurrentTaskHandle>
    1b6a:	f7 01       	movw	r30, r14
    1b6c:	82 83       	std	Z+2, r24	; 0x02
    1b6e:	93 83       	std	Z+3, r25	; 0x03
    1b70:	f7 01       	movw	r30, r14
    1b72:	80 85       	ldd	r24, Z+8	; 0x08
    1b74:	88 23       	and	r24, r24
    1b76:	b1 f0       	breq	.+44     	; 0x1ba4 <xQueueGenericReceive+0xa0>
    1b78:	c7 01       	movw	r24, r14
    1b7a:	08 96       	adiw	r24, 0x08	; 8
    1b7c:	0e 94 ad 12 	call	0x255a	; 0x255a <xTaskRemoveFromEventList>
    1b80:	81 30       	cpi	r24, 0x01	; 1
    1b82:	81 f4       	brne	.+32     	; 0x1ba4 <xQueueGenericReceive+0xa0>
    1b84:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
    1b88:	0d c0       	rjmp	.+26     	; 0x1ba4 <xQueueGenericReceive+0xa0>
    1b8a:	f7 01       	movw	r30, r14
    1b8c:	c6 82       	std	Z+6, r12	; 0x06
    1b8e:	d7 82       	std	Z+7, r13	; 0x07
    1b90:	83 89       	ldd	r24, Z+19	; 0x13
    1b92:	88 23       	and	r24, r24
    1b94:	39 f0       	breq	.+14     	; 0x1ba4 <xQueueGenericReceive+0xa0>
    1b96:	c7 01       	movw	r24, r14
    1b98:	43 96       	adiw	r24, 0x13	; 19
    1b9a:	0e 94 ad 12 	call	0x255a	; 0x255a <xTaskRemoveFromEventList>
    1b9e:	81 11       	cpse	r24, r1
    1ba0:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
    1ba4:	0f 90       	pop	r0
    1ba6:	0f be       	out	0x3f, r0	; 63
    1ba8:	81 e0       	ldi	r24, 0x01	; 1
    1baa:	62 c0       	rjmp	.+196    	; 0x1c70 <xQueueGenericReceive+0x16c>
    1bac:	8e 81       	ldd	r24, Y+6	; 0x06
    1bae:	9f 81       	ldd	r25, Y+7	; 0x07
    1bb0:	a8 85       	ldd	r26, Y+8	; 0x08
    1bb2:	b9 85       	ldd	r27, Y+9	; 0x09
    1bb4:	89 2b       	or	r24, r25
    1bb6:	8a 2b       	or	r24, r26
    1bb8:	8b 2b       	or	r24, r27
    1bba:	21 f4       	brne	.+8      	; 0x1bc4 <xQueueGenericReceive+0xc0>
    1bbc:	0f 90       	pop	r0
    1bbe:	0f be       	out	0x3f, r0	; 63
    1bc0:	80 e0       	ldi	r24, 0x00	; 0
    1bc2:	56 c0       	rjmp	.+172    	; 0x1c70 <xQueueGenericReceive+0x16c>
    1bc4:	11 11       	cpse	r17, r1
    1bc6:	05 c0       	rjmp	.+10     	; 0x1bd2 <xQueueGenericReceive+0xce>
    1bc8:	ce 01       	movw	r24, r28
    1bca:	01 96       	adiw	r24, 0x01	; 1
    1bcc:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <vTaskSetTimeOutState>
    1bd0:	11 e0       	ldi	r17, 0x01	; 1
    1bd2:	0f 90       	pop	r0
    1bd4:	0f be       	out	0x3f, r0	; 63
    1bd6:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskSuspendAll>
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
    1be0:	f7 01       	movw	r30, r14
    1be2:	81 a1       	ldd	r24, Z+33	; 0x21
    1be4:	8f 3f       	cpi	r24, 0xFF	; 255
    1be6:	09 f4       	brne	.+2      	; 0x1bea <xQueueGenericReceive+0xe6>
    1be8:	11 a2       	std	Z+33, r1	; 0x21
    1bea:	f7 01       	movw	r30, r14
    1bec:	82 a1       	ldd	r24, Z+34	; 0x22
    1bee:	8f 3f       	cpi	r24, 0xFF	; 255
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <xQueueGenericReceive+0xf0>
    1bf2:	12 a2       	std	Z+34, r1	; 0x22
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63
    1bf8:	be 01       	movw	r22, r28
    1bfa:	6a 5f       	subi	r22, 0xFA	; 250
    1bfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfe:	ce 01       	movw	r24, r28
    1c00:	01 96       	adiw	r24, 0x01	; 1
    1c02:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskCheckForTimeOut>
    1c06:	81 11       	cpse	r24, r1
    1c08:	2d c0       	rjmp	.+90     	; 0x1c64 <xQueueGenericReceive+0x160>
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	f8 94       	cli
    1c0e:	0f 92       	push	r0
    1c10:	f7 01       	movw	r30, r14
    1c12:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c14:	0f 90       	pop	r0
    1c16:	0f be       	out	0x3f, r0	; 63
    1c18:	81 11       	cpse	r24, r1
    1c1a:	1e c0       	rjmp	.+60     	; 0x1c58 <xQueueGenericReceive+0x154>
    1c1c:	80 81       	ld	r24, Z
    1c1e:	91 81       	ldd	r25, Z+1	; 0x01
    1c20:	89 2b       	or	r24, r25
    1c22:	49 f4       	brne	.+18     	; 0x1c36 <xQueueGenericReceive+0x132>
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	0f 92       	push	r0
    1c2a:	82 81       	ldd	r24, Z+2	; 0x02
    1c2c:	93 81       	ldd	r25, Z+3	; 0x03
    1c2e:	0e 94 8c 13 	call	0x2718	; 0x2718 <vTaskPriorityInherit>
    1c32:	0f 90       	pop	r0
    1c34:	0f be       	out	0x3f, r0	; 63
    1c36:	4e 81       	ldd	r20, Y+6	; 0x06
    1c38:	5f 81       	ldd	r21, Y+7	; 0x07
    1c3a:	68 85       	ldd	r22, Y+8	; 0x08
    1c3c:	79 85       	ldd	r23, Y+9	; 0x09
    1c3e:	c6 01       	movw	r24, r12
    1c40:	0e 94 83 12 	call	0x2506	; 0x2506 <vTaskPlaceOnEventList>
    1c44:	c7 01       	movw	r24, r14
    1c46:	0e 94 33 0c 	call	0x1866	; 0x1866 <prvUnlockQueue>
    1c4a:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
    1c4e:	81 11       	cpse	r24, r1
    1c50:	73 cf       	rjmp	.-282    	; 0x1b38 <xQueueGenericReceive+0x34>
    1c52:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
    1c56:	70 cf       	rjmp	.-288    	; 0x1b38 <xQueueGenericReceive+0x34>
    1c58:	c7 01       	movw	r24, r14
    1c5a:	0e 94 33 0c 	call	0x1866	; 0x1866 <prvUnlockQueue>
    1c5e:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
    1c62:	6a cf       	rjmp	.-300    	; 0x1b38 <xQueueGenericReceive+0x34>
    1c64:	c7 01       	movw	r24, r14
    1c66:	0e 94 33 0c 	call	0x1866	; 0x1866 <prvUnlockQueue>
    1c6a:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
    1c6e:	80 e0       	ldi	r24, 0x00	; 0
    1c70:	29 96       	adiw	r28, 0x09	; 9
    1c72:	cd bf       	out	0x3d, r28	; 61
    1c74:	de bf       	out	0x3e, r29	; 62
    1c76:	df 91       	pop	r29
    1c78:	cf 91       	pop	r28
    1c7a:	1f 91       	pop	r17
    1c7c:	0f 91       	pop	r16
    1c7e:	ff 90       	pop	r15
    1c80:	ef 90       	pop	r14
    1c82:	df 90       	pop	r13
    1c84:	cf 90       	pop	r12
    1c86:	bf 90       	pop	r11
    1c88:	af 90       	pop	r10
    1c8a:	08 95       	ret

00001c8c <uxQueueMessagesWaiting>:
=======
    18ea:	cf 93       	push	r28
    18ec:	df 93       	push	r29
    18ee:	ec 01       	movw	r28, r24
    18f0:	88 a1       	ldd	r24, Y+32	; 0x20
    18f2:	81 11       	cpse	r24, r1
    18f4:	0b c0       	rjmp	.+22     	; 0x190c <prvCopyDataToQueue+0x22>
    18f6:	88 81       	ld	r24, Y
    18f8:	99 81       	ldd	r25, Y+1	; 0x01
    18fa:	89 2b       	or	r24, r25
    18fc:	e1 f5       	brne	.+120    	; 0x1976 <prvCopyDataToQueue+0x8c>
    18fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1900:	9b 81       	ldd	r25, Y+3	; 0x03
    1902:	0e 94 89 14 	call	0x2912	; 0x2912 <vTaskPriorityDisinherit>
    1906:	1a 82       	std	Y+2, r1	; 0x02
    1908:	1b 82       	std	Y+3, r1	; 0x03
    190a:	35 c0       	rjmp	.+106    	; 0x1976 <prvCopyDataToQueue+0x8c>
    190c:	41 11       	cpse	r20, r1
    190e:	17 c0       	rjmp	.+46     	; 0x193e <prvCopyDataToQueue+0x54>
    1910:	48 2f       	mov	r20, r24
    1912:	50 e0       	ldi	r21, 0x00	; 0
    1914:	8c 81       	ldd	r24, Y+4	; 0x04
    1916:	9d 81       	ldd	r25, Y+5	; 0x05
    1918:	0e 94 60 20 	call	0x40c0	; 0x40c0 <memcpy>
    191c:	28 a1       	ldd	r18, Y+32	; 0x20
    191e:	8c 81       	ldd	r24, Y+4	; 0x04
    1920:	9d 81       	ldd	r25, Y+5	; 0x05
    1922:	82 0f       	add	r24, r18
    1924:	91 1d       	adc	r25, r1
    1926:	8c 83       	std	Y+4, r24	; 0x04
    1928:	9d 83       	std	Y+5, r25	; 0x05
    192a:	2a 81       	ldd	r18, Y+2	; 0x02
    192c:	3b 81       	ldd	r19, Y+3	; 0x03
    192e:	82 17       	cp	r24, r18
    1930:	93 07       	cpc	r25, r19
    1932:	08 f1       	brcs	.+66     	; 0x1976 <prvCopyDataToQueue+0x8c>
    1934:	88 81       	ld	r24, Y
    1936:	99 81       	ldd	r25, Y+1	; 0x01
    1938:	8c 83       	std	Y+4, r24	; 0x04
    193a:	9d 83       	std	Y+5, r25	; 0x05
    193c:	1c c0       	rjmp	.+56     	; 0x1976 <prvCopyDataToQueue+0x8c>
    193e:	48 2f       	mov	r20, r24
    1940:	50 e0       	ldi	r21, 0x00	; 0
    1942:	8e 81       	ldd	r24, Y+6	; 0x06
    1944:	9f 81       	ldd	r25, Y+7	; 0x07
    1946:	0e 94 60 20 	call	0x40c0	; 0x40c0 <memcpy>
    194a:	88 a1       	ldd	r24, Y+32	; 0x20
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	91 95       	neg	r25
    1950:	81 95       	neg	r24
    1952:	91 09       	sbc	r25, r1
    1954:	2e 81       	ldd	r18, Y+6	; 0x06
    1956:	3f 81       	ldd	r19, Y+7	; 0x07
    1958:	28 0f       	add	r18, r24
    195a:	39 1f       	adc	r19, r25
    195c:	2e 83       	std	Y+6, r18	; 0x06
    195e:	3f 83       	std	Y+7, r19	; 0x07
    1960:	48 81       	ld	r20, Y
    1962:	59 81       	ldd	r21, Y+1	; 0x01
    1964:	24 17       	cp	r18, r20
    1966:	35 07       	cpc	r19, r21
    1968:	30 f4       	brcc	.+12     	; 0x1976 <prvCopyDataToQueue+0x8c>
    196a:	2a 81       	ldd	r18, Y+2	; 0x02
    196c:	3b 81       	ldd	r19, Y+3	; 0x03
    196e:	82 0f       	add	r24, r18
    1970:	93 1f       	adc	r25, r19
    1972:	8e 83       	std	Y+6, r24	; 0x06
    1974:	9f 83       	std	Y+7, r25	; 0x07
    1976:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1978:	8f 5f       	subi	r24, 0xFF	; 255
    197a:	8e 8f       	std	Y+30, r24	; 0x1e
    197c:	df 91       	pop	r29
    197e:	cf 91       	pop	r28
    1980:	08 95       	ret

00001982 <prvCopyDataFromQueue>:
    1982:	fc 01       	movw	r30, r24
    1984:	80 81       	ld	r24, Z
    1986:	91 81       	ldd	r25, Z+1	; 0x01
    1988:	00 97       	sbiw	r24, 0x00	; 0
    198a:	a1 f0       	breq	.+40     	; 0x19b4 <prvCopyDataFromQueue+0x32>
    198c:	40 a1       	ldd	r20, Z+32	; 0x20
    198e:	50 e0       	ldi	r21, 0x00	; 0
    1990:	26 81       	ldd	r18, Z+6	; 0x06
    1992:	37 81       	ldd	r19, Z+7	; 0x07
    1994:	24 0f       	add	r18, r20
    1996:	35 1f       	adc	r19, r21
    1998:	26 83       	std	Z+6, r18	; 0x06
    199a:	37 83       	std	Z+7, r19	; 0x07
    199c:	a2 81       	ldd	r26, Z+2	; 0x02
    199e:	b3 81       	ldd	r27, Z+3	; 0x03
    19a0:	2a 17       	cp	r18, r26
    19a2:	3b 07       	cpc	r19, r27
    19a4:	10 f0       	brcs	.+4      	; 0x19aa <prvCopyDataFromQueue+0x28>
    19a6:	86 83       	std	Z+6, r24	; 0x06
    19a8:	97 83       	std	Z+7, r25	; 0x07
    19aa:	cb 01       	movw	r24, r22
    19ac:	66 81       	ldd	r22, Z+6	; 0x06
    19ae:	77 81       	ldd	r23, Z+7	; 0x07
    19b0:	0e 94 60 20 	call	0x40c0	; 0x40c0 <memcpy>
    19b4:	08 95       	ret

000019b6 <prvUnlockQueue>:
    19b6:	0f 93       	push	r16
    19b8:	1f 93       	push	r17
    19ba:	cf 93       	push	r28
    19bc:	df 93       	push	r29
    19be:	ec 01       	movw	r28, r24
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
    19c6:	8a a1       	ldd	r24, Y+34	; 0x22
    19c8:	18 16       	cp	r1, r24
    19ca:	b4 f4       	brge	.+44     	; 0x19f8 <prvUnlockQueue+0x42>
    19cc:	8b 89       	ldd	r24, Y+19	; 0x13
    19ce:	81 11       	cpse	r24, r1
    19d0:	05 c0       	rjmp	.+10     	; 0x19dc <prvUnlockQueue+0x26>
    19d2:	12 c0       	rjmp	.+36     	; 0x19f8 <prvUnlockQueue+0x42>
    19d4:	8b 89       	ldd	r24, Y+19	; 0x13
    19d6:	81 11       	cpse	r24, r1
    19d8:	04 c0       	rjmp	.+8      	; 0x19e2 <prvUnlockQueue+0x2c>
    19da:	0e c0       	rjmp	.+28     	; 0x19f8 <prvUnlockQueue+0x42>
    19dc:	8e 01       	movw	r16, r28
    19de:	0d 5e       	subi	r16, 0xED	; 237
    19e0:	1f 4f       	sbci	r17, 0xFF	; 255
    19e2:	c8 01       	movw	r24, r16
    19e4:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    19e8:	81 11       	cpse	r24, r1
    19ea:	0e 94 12 14 	call	0x2824	; 0x2824 <vTaskMissedYield>
    19ee:	8a a1       	ldd	r24, Y+34	; 0x22
    19f0:	81 50       	subi	r24, 0x01	; 1
    19f2:	8a a3       	std	Y+34, r24	; 0x22
    19f4:	18 16       	cp	r1, r24
    19f6:	74 f3       	brlt	.-36     	; 0x19d4 <prvUnlockQueue+0x1e>
    19f8:	8f ef       	ldi	r24, 0xFF	; 255
    19fa:	8a a3       	std	Y+34, r24	; 0x22
    19fc:	0f 90       	pop	r0
    19fe:	0f be       	out	0x3f, r0	; 63
    1a00:	0f b6       	in	r0, 0x3f	; 63
    1a02:	f8 94       	cli
    1a04:	0f 92       	push	r0
    1a06:	89 a1       	ldd	r24, Y+33	; 0x21
    1a08:	18 16       	cp	r1, r24
    1a0a:	b4 f4       	brge	.+44     	; 0x1a38 <prvUnlockQueue+0x82>
    1a0c:	88 85       	ldd	r24, Y+8	; 0x08
    1a0e:	81 11       	cpse	r24, r1
    1a10:	05 c0       	rjmp	.+10     	; 0x1a1c <prvUnlockQueue+0x66>
    1a12:	12 c0       	rjmp	.+36     	; 0x1a38 <prvUnlockQueue+0x82>
    1a14:	88 85       	ldd	r24, Y+8	; 0x08
    1a16:	81 11       	cpse	r24, r1
    1a18:	04 c0       	rjmp	.+8      	; 0x1a22 <prvUnlockQueue+0x6c>
    1a1a:	0e c0       	rjmp	.+28     	; 0x1a38 <prvUnlockQueue+0x82>
    1a1c:	8e 01       	movw	r16, r28
    1a1e:	08 5f       	subi	r16, 0xF8	; 248
    1a20:	1f 4f       	sbci	r17, 0xFF	; 255
    1a22:	c8 01       	movw	r24, r16
    1a24:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    1a28:	81 11       	cpse	r24, r1
    1a2a:	0e 94 12 14 	call	0x2824	; 0x2824 <vTaskMissedYield>
    1a2e:	89 a1       	ldd	r24, Y+33	; 0x21
    1a30:	81 50       	subi	r24, 0x01	; 1
    1a32:	89 a3       	std	Y+33, r24	; 0x21
    1a34:	18 16       	cp	r1, r24
    1a36:	74 f3       	brlt	.-36     	; 0x1a14 <prvUnlockQueue+0x5e>
    1a38:	8f ef       	ldi	r24, 0xFF	; 255
    1a3a:	89 a3       	std	Y+33, r24	; 0x21
    1a3c:	0f 90       	pop	r0
    1a3e:	0f be       	out	0x3f, r0	; 63
    1a40:	df 91       	pop	r29
    1a42:	cf 91       	pop	r28
    1a44:	1f 91       	pop	r17
    1a46:	0f 91       	pop	r16
    1a48:	08 95       	ret

00001a4a <xQueueGenericReset>:
    1a4a:	1f 93       	push	r17
    1a4c:	cf 93       	push	r28
    1a4e:	df 93       	push	r29
    1a50:	61 30       	cpi	r22, 0x01	; 1
    1a52:	59 f0       	breq	.+22     	; 0x1a6a <xQueueGenericReset+0x20>
    1a54:	fc 01       	movw	r30, r24
    1a56:	23 89       	ldd	r18, Z+19	; 0x13
    1a58:	30 85       	ldd	r19, Z+8	; 0x08
    1a5a:	31 11       	cpse	r19, r1
    1a5c:	2c c0       	rjmp	.+88     	; 0x1ab6 <xQueueGenericReset+0x6c>
    1a5e:	11 e0       	ldi	r17, 0x01	; 1
    1a60:	21 11       	cpse	r18, r1
    1a62:	10 e0       	ldi	r17, 0x00	; 0
    1a64:	21 11       	cpse	r18, r1
    1a66:	28 c0       	rjmp	.+80     	; 0x1ab8 <xQueueGenericReset+0x6e>
    1a68:	01 c0       	rjmp	.+2      	; 0x1a6c <xQueueGenericReset+0x22>
    1a6a:	11 e0       	ldi	r17, 0x01	; 1
    1a6c:	ec 01       	movw	r28, r24
    1a6e:	48 81       	ld	r20, Y
    1a70:	59 81       	ldd	r21, Y+1	; 0x01
    1a72:	28 a1       	ldd	r18, Y+32	; 0x20
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a78:	62 9f       	mul	r22, r18
    1a7a:	c0 01       	movw	r24, r0
    1a7c:	63 9f       	mul	r22, r19
    1a7e:	90 0d       	add	r25, r0
    1a80:	11 24       	eor	r1, r1
    1a82:	ba 01       	movw	r22, r20
    1a84:	68 0f       	add	r22, r24
    1a86:	79 1f       	adc	r23, r25
    1a88:	6a 83       	std	Y+2, r22	; 0x02
    1a8a:	7b 83       	std	Y+3, r23	; 0x03
    1a8c:	1e 8e       	std	Y+30, r1	; 0x1e
    1a8e:	4c 83       	std	Y+4, r20	; 0x04
    1a90:	5d 83       	std	Y+5, r21	; 0x05
    1a92:	82 1b       	sub	r24, r18
    1a94:	93 0b       	sbc	r25, r19
    1a96:	84 0f       	add	r24, r20
    1a98:	95 1f       	adc	r25, r21
    1a9a:	8e 83       	std	Y+6, r24	; 0x06
    1a9c:	9f 83       	std	Y+7, r25	; 0x07
    1a9e:	8f ef       	ldi	r24, 0xFF	; 255
    1aa0:	89 a3       	std	Y+33, r24	; 0x21
    1aa2:	8a a3       	std	Y+34, r24	; 0x22
    1aa4:	ce 01       	movw	r24, r28
    1aa6:	08 96       	adiw	r24, 0x08	; 8
    1aa8:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1aac:	ce 01       	movw	r24, r28
    1aae:	43 96       	adiw	r24, 0x13	; 19
    1ab0:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1ab4:	01 c0       	rjmp	.+2      	; 0x1ab8 <xQueueGenericReset+0x6e>
    1ab6:	10 e0       	ldi	r17, 0x00	; 0
    1ab8:	81 2f       	mov	r24, r17
    1aba:	df 91       	pop	r29
    1abc:	cf 91       	pop	r28
    1abe:	1f 91       	pop	r17
    1ac0:	08 95       	ret

00001ac2 <xQueueGenericCreate>:
    1ac2:	0f 93       	push	r16
    1ac4:	1f 93       	push	r17
    1ac6:	cf 93       	push	r28
    1ac8:	df 93       	push	r29
    1aca:	88 23       	and	r24, r24
    1acc:	01 f1       	breq	.+64     	; 0x1b0e <xQueueGenericCreate+0x4c>
    1ace:	06 2f       	mov	r16, r22
    1ad0:	18 2f       	mov	r17, r24
    1ad2:	83 e2       	ldi	r24, 0x23	; 35
    1ad4:	90 e0       	ldi	r25, 0x00	; 0
    1ad6:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    1ada:	ec 01       	movw	r28, r24
    1adc:	89 2b       	or	r24, r25
    1ade:	c9 f0       	breq	.+50     	; 0x1b12 <xQueueGenericCreate+0x50>
    1ae0:	10 9f       	mul	r17, r16
    1ae2:	c0 01       	movw	r24, r0
    1ae4:	11 24       	eor	r1, r1
    1ae6:	01 96       	adiw	r24, 0x01	; 1
    1ae8:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    1aec:	88 83       	st	Y, r24
    1aee:	99 83       	std	Y+1, r25	; 0x01
    1af0:	89 2b       	or	r24, r25
    1af2:	39 f0       	breq	.+14     	; 0x1b02 <xQueueGenericCreate+0x40>
    1af4:	1f 8f       	std	Y+31, r17	; 0x1f
    1af6:	08 a3       	std	Y+32, r16	; 0x20
    1af8:	61 e0       	ldi	r22, 0x01	; 1
    1afa:	ce 01       	movw	r24, r28
    1afc:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <xQueueGenericReset>
    1b00:	08 c0       	rjmp	.+16     	; 0x1b12 <xQueueGenericCreate+0x50>
    1b02:	ce 01       	movw	r24, r28
    1b04:	0e 94 15 0a 	call	0x142a	; 0x142a <vPortFree>
    1b08:	c0 e0       	ldi	r28, 0x00	; 0
    1b0a:	d0 e0       	ldi	r29, 0x00	; 0
    1b0c:	02 c0       	rjmp	.+4      	; 0x1b12 <xQueueGenericCreate+0x50>
    1b0e:	c0 e0       	ldi	r28, 0x00	; 0
    1b10:	d0 e0       	ldi	r29, 0x00	; 0
    1b12:	ce 01       	movw	r24, r28
    1b14:	df 91       	pop	r29
    1b16:	cf 91       	pop	r28
    1b18:	1f 91       	pop	r17
    1b1a:	0f 91       	pop	r16
    1b1c:	08 95       	ret

00001b1e <xQueueGenericSend>:
    1b1e:	af 92       	push	r10
    1b20:	bf 92       	push	r11
    1b22:	cf 92       	push	r12
    1b24:	df 92       	push	r13
    1b26:	ef 92       	push	r14
    1b28:	ff 92       	push	r15
    1b2a:	0f 93       	push	r16
    1b2c:	1f 93       	push	r17
    1b2e:	cf 93       	push	r28
    1b30:	df 93       	push	r29
    1b32:	cd b7       	in	r28, 0x3d	; 61
    1b34:	de b7       	in	r29, 0x3e	; 62
    1b36:	29 97       	sbiw	r28, 0x09	; 9
    1b38:	cd bf       	out	0x3d, r28	; 61
    1b3a:	de bf       	out	0x3e, r29	; 62
    1b3c:	7c 01       	movw	r14, r24
    1b3e:	5b 01       	movw	r10, r22
    1b40:	2e 83       	std	Y+6, r18	; 0x06
    1b42:	3f 83       	std	Y+7, r19	; 0x07
    1b44:	48 87       	std	Y+8, r20	; 0x08
    1b46:	59 87       	std	Y+9, r21	; 0x09
    1b48:	10 e0       	ldi	r17, 0x00	; 0
    1b4a:	6c 01       	movw	r12, r24
    1b4c:	88 e0       	ldi	r24, 0x08	; 8
    1b4e:	c8 0e       	add	r12, r24
    1b50:	d1 1c       	adc	r13, r1
    1b52:	0f b6       	in	r0, 0x3f	; 63
    1b54:	f8 94       	cli
    1b56:	0f 92       	push	r0
    1b58:	f7 01       	movw	r30, r14
    1b5a:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b5c:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b5e:	98 17       	cp	r25, r24
    1b60:	a8 f4       	brcc	.+42     	; 0x1b8c <xQueueGenericSend+0x6e>
    1b62:	40 2f       	mov	r20, r16
    1b64:	b5 01       	movw	r22, r10
    1b66:	c7 01       	movw	r24, r14
    1b68:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvCopyDataToQueue>
    1b6c:	f7 01       	movw	r30, r14
    1b6e:	83 89       	ldd	r24, Z+19	; 0x13
    1b70:	88 23       	and	r24, r24
    1b72:	41 f0       	breq	.+16     	; 0x1b84 <xQueueGenericSend+0x66>
    1b74:	c7 01       	movw	r24, r14
    1b76:	43 96       	adiw	r24, 0x13	; 19
    1b78:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    1b7c:	81 30       	cpi	r24, 0x01	; 1
    1b7e:	11 f4       	brne	.+4      	; 0x1b84 <xQueueGenericSend+0x66>
    1b80:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1b84:	0f 90       	pop	r0
    1b86:	0f be       	out	0x3f, r0	; 63
    1b88:	81 e0       	ldi	r24, 0x01	; 1
    1b8a:	56 c0       	rjmp	.+172    	; 0x1c38 <xQueueGenericSend+0x11a>
    1b8c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b8e:	9f 81       	ldd	r25, Y+7	; 0x07
    1b90:	a8 85       	ldd	r26, Y+8	; 0x08
    1b92:	b9 85       	ldd	r27, Y+9	; 0x09
    1b94:	89 2b       	or	r24, r25
    1b96:	8a 2b       	or	r24, r26
    1b98:	8b 2b       	or	r24, r27
    1b9a:	21 f4       	brne	.+8      	; 0x1ba4 <xQueueGenericSend+0x86>
    1b9c:	0f 90       	pop	r0
    1b9e:	0f be       	out	0x3f, r0	; 63
    1ba0:	80 e0       	ldi	r24, 0x00	; 0
    1ba2:	4a c0       	rjmp	.+148    	; 0x1c38 <xQueueGenericSend+0x11a>
    1ba4:	11 11       	cpse	r17, r1
    1ba6:	05 c0       	rjmp	.+10     	; 0x1bb2 <xQueueGenericSend+0x94>
    1ba8:	ce 01       	movw	r24, r28
    1baa:	01 96       	adiw	r24, 0x01	; 1
    1bac:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSetTimeOutState>
    1bb0:	11 e0       	ldi	r17, 0x01	; 1
    1bb2:	0f 90       	pop	r0
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	0f 92       	push	r0
    1bc0:	f7 01       	movw	r30, r14
    1bc2:	81 a1       	ldd	r24, Z+33	; 0x21
    1bc4:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc6:	09 f4       	brne	.+2      	; 0x1bca <xQueueGenericSend+0xac>
    1bc8:	11 a2       	std	Z+33, r1	; 0x21
    1bca:	f7 01       	movw	r30, r14
    1bcc:	82 a1       	ldd	r24, Z+34	; 0x22
    1bce:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd0:	09 f4       	brne	.+2      	; 0x1bd4 <xQueueGenericSend+0xb6>
    1bd2:	12 a2       	std	Z+34, r1	; 0x22
    1bd4:	0f 90       	pop	r0
    1bd6:	0f be       	out	0x3f, r0	; 63
    1bd8:	be 01       	movw	r22, r28
    1bda:	6a 5f       	subi	r22, 0xFA	; 250
    1bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bde:	ce 01       	movw	r24, r28
    1be0:	01 96       	adiw	r24, 0x01	; 1
    1be2:	0e 94 a5 13 	call	0x274a	; 0x274a <xTaskCheckForTimeOut>
    1be6:	81 11       	cpse	r24, r1
    1be8:	21 c0       	rjmp	.+66     	; 0x1c2c <xQueueGenericSend+0x10e>
    1bea:	0f b6       	in	r0, 0x3f	; 63
    1bec:	f8 94       	cli
    1bee:	0f 92       	push	r0
    1bf0:	f7 01       	movw	r30, r14
    1bf2:	96 8d       	ldd	r25, Z+30	; 0x1e
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63
    1bf8:	87 8d       	ldd	r24, Z+31	; 0x1f
    1bfa:	98 13       	cpse	r25, r24
    1bfc:	11 c0       	rjmp	.+34     	; 0x1c20 <xQueueGenericSend+0x102>
    1bfe:	4e 81       	ldd	r20, Y+6	; 0x06
    1c00:	5f 81       	ldd	r21, Y+7	; 0x07
    1c02:	68 85       	ldd	r22, Y+8	; 0x08
    1c04:	79 85       	ldd	r23, Y+9	; 0x09
    1c06:	c6 01       	movw	r24, r12
    1c08:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskPlaceOnEventList>
    1c0c:	c7 01       	movw	r24, r14
    1c0e:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1c12:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1c16:	81 11       	cpse	r24, r1
    1c18:	9c cf       	rjmp	.-200    	; 0x1b52 <xQueueGenericSend+0x34>
    1c1a:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1c1e:	99 cf       	rjmp	.-206    	; 0x1b52 <xQueueGenericSend+0x34>
    1c20:	c7 01       	movw	r24, r14
    1c22:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1c26:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1c2a:	93 cf       	rjmp	.-218    	; 0x1b52 <xQueueGenericSend+0x34>
    1c2c:	c7 01       	movw	r24, r14
    1c2e:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1c32:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1c36:	80 e0       	ldi	r24, 0x00	; 0
    1c38:	29 96       	adiw	r28, 0x09	; 9
    1c3a:	cd bf       	out	0x3d, r28	; 61
    1c3c:	de bf       	out	0x3e, r29	; 62
    1c3e:	df 91       	pop	r29
    1c40:	cf 91       	pop	r28
    1c42:	1f 91       	pop	r17
    1c44:	0f 91       	pop	r16
    1c46:	ff 90       	pop	r15
    1c48:	ef 90       	pop	r14
    1c4a:	df 90       	pop	r13
    1c4c:	cf 90       	pop	r12
    1c4e:	bf 90       	pop	r11
    1c50:	af 90       	pop	r10
    1c52:	08 95       	ret

00001c54 <xQueueGenericReceive>:
    1c54:	af 92       	push	r10
    1c56:	bf 92       	push	r11
    1c58:	cf 92       	push	r12
    1c5a:	df 92       	push	r13
    1c5c:	ef 92       	push	r14
    1c5e:	ff 92       	push	r15
    1c60:	0f 93       	push	r16
    1c62:	1f 93       	push	r17
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	cd b7       	in	r28, 0x3d	; 61
    1c6a:	de b7       	in	r29, 0x3e	; 62
    1c6c:	29 97       	sbiw	r28, 0x09	; 9
    1c6e:	cd bf       	out	0x3d, r28	; 61
    1c70:	de bf       	out	0x3e, r29	; 62
    1c72:	7c 01       	movw	r14, r24
    1c74:	5b 01       	movw	r10, r22
    1c76:	2e 83       	std	Y+6, r18	; 0x06
    1c78:	3f 83       	std	Y+7, r19	; 0x07
    1c7a:	48 87       	std	Y+8, r20	; 0x08
    1c7c:	59 87       	std	Y+9, r21	; 0x09
    1c7e:	10 e0       	ldi	r17, 0x00	; 0
    1c80:	6c 01       	movw	r12, r24
    1c82:	83 e1       	ldi	r24, 0x13	; 19
    1c84:	c8 0e       	add	r12, r24
    1c86:	d1 1c       	adc	r13, r1
    1c88:	0f b6       	in	r0, 0x3f	; 63
    1c8a:	f8 94       	cli
    1c8c:	0f 92       	push	r0
    1c8e:	f7 01       	movw	r30, r14
    1c90:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c92:	88 23       	and	r24, r24
    1c94:	99 f1       	breq	.+102    	; 0x1cfc <xQueueGenericReceive+0xa8>
    1c96:	c6 80       	ldd	r12, Z+6	; 0x06
    1c98:	d7 80       	ldd	r13, Z+7	; 0x07
    1c9a:	b5 01       	movw	r22, r10
    1c9c:	c7 01       	movw	r24, r14
    1c9e:	0e 94 c1 0c 	call	0x1982	; 0x1982 <prvCopyDataFromQueue>
    1ca2:	01 11       	cpse	r16, r1
    1ca4:	1a c0       	rjmp	.+52     	; 0x1cda <xQueueGenericReceive+0x86>
    1ca6:	f7 01       	movw	r30, r14
    1ca8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1caa:	81 50       	subi	r24, 0x01	; 1
    1cac:	86 8f       	std	Z+30, r24	; 0x1e
    1cae:	80 81       	ld	r24, Z
    1cb0:	91 81       	ldd	r25, Z+1	; 0x01
    1cb2:	89 2b       	or	r24, r25
    1cb4:	29 f4       	brne	.+10     	; 0x1cc0 <xQueueGenericReceive+0x6c>
    1cb6:	0e 94 2f 14 	call	0x285e	; 0x285e <xTaskGetCurrentTaskHandle>
    1cba:	f7 01       	movw	r30, r14
    1cbc:	82 83       	std	Z+2, r24	; 0x02
    1cbe:	93 83       	std	Z+3, r25	; 0x03
    1cc0:	f7 01       	movw	r30, r14
    1cc2:	80 85       	ldd	r24, Z+8	; 0x08
    1cc4:	88 23       	and	r24, r24
    1cc6:	b1 f0       	breq	.+44     	; 0x1cf4 <xQueueGenericReceive+0xa0>
    1cc8:	c7 01       	movw	r24, r14
    1cca:	08 96       	adiw	r24, 0x08	; 8
    1ccc:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    1cd0:	81 30       	cpi	r24, 0x01	; 1
    1cd2:	81 f4       	brne	.+32     	; 0x1cf4 <xQueueGenericReceive+0xa0>
    1cd4:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1cd8:	0d c0       	rjmp	.+26     	; 0x1cf4 <xQueueGenericReceive+0xa0>
    1cda:	f7 01       	movw	r30, r14
    1cdc:	c6 82       	std	Z+6, r12	; 0x06
    1cde:	d7 82       	std	Z+7, r13	; 0x07
    1ce0:	83 89       	ldd	r24, Z+19	; 0x13
    1ce2:	88 23       	and	r24, r24
    1ce4:	39 f0       	breq	.+14     	; 0x1cf4 <xQueueGenericReceive+0xa0>
    1ce6:	c7 01       	movw	r24, r14
    1ce8:	43 96       	adiw	r24, 0x13	; 19
    1cea:	0e 94 55 13 	call	0x26aa	; 0x26aa <xTaskRemoveFromEventList>
    1cee:	81 11       	cpse	r24, r1
    1cf0:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1cf4:	0f 90       	pop	r0
    1cf6:	0f be       	out	0x3f, r0	; 63
    1cf8:	81 e0       	ldi	r24, 0x01	; 1
    1cfa:	62 c0       	rjmp	.+196    	; 0x1dc0 <xQueueGenericReceive+0x16c>
    1cfc:	8e 81       	ldd	r24, Y+6	; 0x06
    1cfe:	9f 81       	ldd	r25, Y+7	; 0x07
    1d00:	a8 85       	ldd	r26, Y+8	; 0x08
    1d02:	b9 85       	ldd	r27, Y+9	; 0x09
    1d04:	89 2b       	or	r24, r25
    1d06:	8a 2b       	or	r24, r26
    1d08:	8b 2b       	or	r24, r27
    1d0a:	21 f4       	brne	.+8      	; 0x1d14 <xQueueGenericReceive+0xc0>
    1d0c:	0f 90       	pop	r0
    1d0e:	0f be       	out	0x3f, r0	; 63
    1d10:	80 e0       	ldi	r24, 0x00	; 0
    1d12:	56 c0       	rjmp	.+172    	; 0x1dc0 <xQueueGenericReceive+0x16c>
    1d14:	11 11       	cpse	r17, r1
    1d16:	05 c0       	rjmp	.+10     	; 0x1d22 <xQueueGenericReceive+0xce>
    1d18:	ce 01       	movw	r24, r28
    1d1a:	01 96       	adiw	r24, 0x01	; 1
    1d1c:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSetTimeOutState>
    1d20:	11 e0       	ldi	r17, 0x01	; 1
    1d22:	0f 90       	pop	r0
    1d24:	0f be       	out	0x3f, r0	; 63
    1d26:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	f8 94       	cli
    1d2e:	0f 92       	push	r0
    1d30:	f7 01       	movw	r30, r14
    1d32:	81 a1       	ldd	r24, Z+33	; 0x21
    1d34:	8f 3f       	cpi	r24, 0xFF	; 255
    1d36:	09 f4       	brne	.+2      	; 0x1d3a <xQueueGenericReceive+0xe6>
    1d38:	11 a2       	std	Z+33, r1	; 0x21
    1d3a:	f7 01       	movw	r30, r14
    1d3c:	82 a1       	ldd	r24, Z+34	; 0x22
    1d3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d40:	09 f4       	brne	.+2      	; 0x1d44 <xQueueGenericReceive+0xf0>
    1d42:	12 a2       	std	Z+34, r1	; 0x22
    1d44:	0f 90       	pop	r0
    1d46:	0f be       	out	0x3f, r0	; 63
    1d48:	be 01       	movw	r22, r28
    1d4a:	6a 5f       	subi	r22, 0xFA	; 250
    1d4c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d4e:	ce 01       	movw	r24, r28
    1d50:	01 96       	adiw	r24, 0x01	; 1
    1d52:	0e 94 a5 13 	call	0x274a	; 0x274a <xTaskCheckForTimeOut>
    1d56:	81 11       	cpse	r24, r1
    1d58:	2d c0       	rjmp	.+90     	; 0x1db4 <xQueueGenericReceive+0x160>
    1d5a:	0f b6       	in	r0, 0x3f	; 63
    1d5c:	f8 94       	cli
    1d5e:	0f 92       	push	r0
    1d60:	f7 01       	movw	r30, r14
    1d62:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d64:	0f 90       	pop	r0
    1d66:	0f be       	out	0x3f, r0	; 63
    1d68:	81 11       	cpse	r24, r1
    1d6a:	1e c0       	rjmp	.+60     	; 0x1da8 <xQueueGenericReceive+0x154>
    1d6c:	80 81       	ld	r24, Z
    1d6e:	91 81       	ldd	r25, Z+1	; 0x01
    1d70:	89 2b       	or	r24, r25
    1d72:	49 f4       	brne	.+18     	; 0x1d86 <xQueueGenericReceive+0x132>
    1d74:	0f b6       	in	r0, 0x3f	; 63
    1d76:	f8 94       	cli
    1d78:	0f 92       	push	r0
    1d7a:	82 81       	ldd	r24, Z+2	; 0x02
    1d7c:	93 81       	ldd	r25, Z+3	; 0x03
    1d7e:	0e 94 34 14 	call	0x2868	; 0x2868 <vTaskPriorityInherit>
    1d82:	0f 90       	pop	r0
    1d84:	0f be       	out	0x3f, r0	; 63
    1d86:	4e 81       	ldd	r20, Y+6	; 0x06
    1d88:	5f 81       	ldd	r21, Y+7	; 0x07
    1d8a:	68 85       	ldd	r22, Y+8	; 0x08
    1d8c:	79 85       	ldd	r23, Y+9	; 0x09
    1d8e:	c6 01       	movw	r24, r12
    1d90:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskPlaceOnEventList>
    1d94:	c7 01       	movw	r24, r14
    1d96:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1d9a:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1d9e:	81 11       	cpse	r24, r1
    1da0:	73 cf       	rjmp	.-282    	; 0x1c88 <xQueueGenericReceive+0x34>
    1da2:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1da6:	70 cf       	rjmp	.-288    	; 0x1c88 <xQueueGenericReceive+0x34>
    1da8:	c7 01       	movw	r24, r14
    1daa:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1dae:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1db2:	6a cf       	rjmp	.-300    	; 0x1c88 <xQueueGenericReceive+0x34>
    1db4:	c7 01       	movw	r24, r14
    1db6:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <prvUnlockQueue>
    1dba:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
    1dbe:	80 e0       	ldi	r24, 0x00	; 0
    1dc0:	29 96       	adiw	r28, 0x09	; 9
    1dc2:	cd bf       	out	0x3d, r28	; 61
    1dc4:	de bf       	out	0x3e, r29	; 62
    1dc6:	df 91       	pop	r29
    1dc8:	cf 91       	pop	r28
    1dca:	1f 91       	pop	r17
    1dcc:	0f 91       	pop	r16
    1dce:	ff 90       	pop	r15
    1dd0:	ef 90       	pop	r14
    1dd2:	df 90       	pop	r13
    1dd4:	cf 90       	pop	r12
    1dd6:	bf 90       	pop	r11
    1dd8:	af 90       	pop	r10
    1dda:	08 95       	ret

00001ddc <uxQueueMessagesWaiting>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
<<<<<<< HEAD
    1c8c:	0f b6       	in	r0, 0x3f	; 63
    1c8e:	f8 94       	cli
    1c90:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1c92:	fc 01       	movw	r30, r24
    1c94:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1c96:	0f 90       	pop	r0
    1c98:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1c9a:	08 95       	ret

00001c9c <prvIdleTask>:
=======
    1ddc:	0f b6       	in	r0, 0x3f	; 63
    1dde:	f8 94       	cli
    1de0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1de2:	fc 01       	movw	r30, r24
    1de4:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1de6:	0f 90       	pop	r0
    1de8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1dea:	08 95       	ret

00001dec <prvIdleTask>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
<<<<<<< HEAD
    1c9c:	c8 ee       	ldi	r28, 0xE8	; 232
    1c9e:	d0 e3       	ldi	r29, 0x30	; 48
    1ca0:	88 81       	ld	r24, Y
    1ca2:	82 30       	cpi	r24, 0x02	; 2
    1ca4:	e8 f3       	brcs	.-6      	; 0x1ca0 <prvIdleTask+0x4>
    1ca6:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
    1caa:	fa cf       	rjmp	.-12     	; 0x1ca0 <prvIdleTask+0x4>

00001cac <prvAddCurrentTaskToDelayedList>:
    1cac:	cf 92       	push	r12
    1cae:	df 92       	push	r13
    1cb0:	ef 92       	push	r14
    1cb2:	ff 92       	push	r15
    1cb4:	6b 01       	movw	r12, r22
    1cb6:	7c 01       	movw	r14, r24
    1cb8:	e0 91 14 31 	lds	r30, 0x3114	; 0x803114 <pxCurrentTCB>
    1cbc:	f0 91 15 31 	lds	r31, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1cc0:	62 83       	std	Z+2, r22	; 0x02
    1cc2:	73 83       	std	Z+3, r23	; 0x03
    1cc4:	84 83       	std	Z+4, r24	; 0x04
    1cc6:	95 83       	std	Z+5, r25	; 0x05
    1cc8:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    1ccc:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    1cd0:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    1cd4:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
    1cd8:	c8 16       	cp	r12, r24
    1cda:	d9 06       	cpc	r13, r25
    1cdc:	ea 06       	cpc	r14, r26
    1cde:	fb 06       	cpc	r15, r27
    1ce0:	68 f4       	brcc	.+26     	; 0x1cfc <prvAddCurrentTaskToDelayedList+0x50>
    1ce2:	60 91 14 31 	lds	r22, 0x3114	; 0x803114 <pxCurrentTCB>
    1ce6:	70 91 15 31 	lds	r23, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1cea:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <pxOverflowDelayedTaskList>
    1cee:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <pxOverflowDelayedTaskList+0x1>
    1cf2:	6e 5f       	subi	r22, 0xFE	; 254
    1cf4:	7f 4f       	sbci	r23, 0xFF	; 255
    1cf6:	0e 94 e1 09 	call	0x13c2	; 0x13c2 <vListInsert>
    1cfa:	21 c0       	rjmp	.+66     	; 0x1d3e <prvAddCurrentTaskToDelayedList+0x92>
    1cfc:	60 91 14 31 	lds	r22, 0x3114	; 0x803114 <pxCurrentTCB>
    1d00:	70 91 15 31 	lds	r23, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1d04:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <pxDelayedTaskList>
    1d08:	90 91 d1 30 	lds	r25, 0x30D1	; 0x8030d1 <pxDelayedTaskList+0x1>
    1d0c:	6e 5f       	subi	r22, 0xFE	; 254
    1d0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d10:	0e 94 e1 09 	call	0x13c2	; 0x13c2 <vListInsert>
    1d14:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1d18:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d1c:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d20:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d24:	c8 16       	cp	r12, r24
    1d26:	d9 06       	cpc	r13, r25
    1d28:	ea 06       	cpc	r14, r26
    1d2a:	fb 06       	cpc	r15, r27
    1d2c:	40 f4       	brcc	.+16     	; 0x1d3e <prvAddCurrentTaskToDelayedList+0x92>
    1d2e:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1d32:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d36:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d3a:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d3e:	ff 90       	pop	r15
    1d40:	ef 90       	pop	r14
    1d42:	df 90       	pop	r13
    1d44:	cf 90       	pop	r12
    1d46:	08 95       	ret

00001d48 <xTaskGenericCreate>:
    1d48:	4f 92       	push	r4
    1d4a:	5f 92       	push	r5
    1d4c:	6f 92       	push	r6
    1d4e:	7f 92       	push	r7
    1d50:	8f 92       	push	r8
    1d52:	9f 92       	push	r9
    1d54:	af 92       	push	r10
    1d56:	bf 92       	push	r11
    1d58:	cf 92       	push	r12
    1d5a:	df 92       	push	r13
    1d5c:	ef 92       	push	r14
    1d5e:	ff 92       	push	r15
    1d60:	0f 93       	push	r16
    1d62:	1f 93       	push	r17
    1d64:	cf 93       	push	r28
    1d66:	df 93       	push	r29
    1d68:	5c 01       	movw	r10, r24
    1d6a:	4b 01       	movw	r8, r22
    1d6c:	3a 01       	movw	r6, r20
    1d6e:	29 01       	movw	r4, r18
    1d70:	88 e2       	ldi	r24, 0x28	; 40
    1d72:	90 e0       	ldi	r25, 0x00	; 0
    1d74:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <pvPortMalloc>
    1d78:	ec 01       	movw	r28, r24
    1d7a:	89 2b       	or	r24, r25
    1d7c:	09 f4       	brne	.+2      	; 0x1d80 <xTaskGenericCreate+0x38>
    1d7e:	d4 c0       	rjmp	.+424    	; 0x1f28 <xTaskGenericCreate+0x1e0>
    1d80:	c1 14       	cp	r12, r1
    1d82:	d1 04       	cpc	r13, r1
    1d84:	09 f0       	breq	.+2      	; 0x1d88 <xTaskGenericCreate+0x40>
    1d86:	cc c0       	rjmp	.+408    	; 0x1f20 <xTaskGenericCreate+0x1d8>
    1d88:	c3 01       	movw	r24, r6
    1d8a:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <pvPortMalloc>
    1d8e:	8b 8f       	std	Y+27, r24	; 0x1b
    1d90:	9c 8f       	std	Y+28, r25	; 0x1c
    1d92:	00 97       	sbiw	r24, 0x00	; 0
    1d94:	21 f4       	brne	.+8      	; 0x1d9e <xTaskGenericCreate+0x56>
    1d96:	ce 01       	movw	r24, r28
    1d98:	0e 94 6d 09 	call	0x12da	; 0x12da <vPortFree>
    1d9c:	c5 c0       	rjmp	.+394    	; 0x1f28 <xTaskGenericCreate+0x1e0>
    1d9e:	a3 01       	movw	r20, r6
    1da0:	61 e1       	ldi	r22, 0x11	; 17
    1da2:	70 e0       	ldi	r23, 0x00	; 0
    1da4:	0e 94 8b 1f 	call	0x3f16	; 0x3f16 <memset>
    1da8:	93 01       	movw	r18, r6
    1daa:	21 50       	subi	r18, 0x01	; 1
    1dac:	31 09       	sbc	r19, r1
    1dae:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1db0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1db2:	3c 01       	movw	r6, r24
    1db4:	62 0e       	add	r6, r18
    1db6:	73 1e       	adc	r7, r19
    1db8:	4a e0       	ldi	r20, 0x0A	; 10
    1dba:	50 e0       	ldi	r21, 0x00	; 0
    1dbc:	b4 01       	movw	r22, r8
    1dbe:	ce 01       	movw	r24, r28
    1dc0:	4d 96       	adiw	r24, 0x1d	; 29
    1dc2:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <strncpy>
    1dc6:	1e a2       	std	Y+38, r1	; 0x26
    1dc8:	10 2f       	mov	r17, r16
    1dca:	04 30       	cpi	r16, 0x04	; 4
    1dcc:	08 f0       	brcs	.+2      	; 0x1dd0 <xTaskGenericCreate+0x88>
    1dce:	13 e0       	ldi	r17, 0x03	; 3
    1dd0:	1a 8f       	std	Y+26, r17	; 0x1a
    1dd2:	1f a3       	std	Y+39, r17	; 0x27
    1dd4:	6e 01       	movw	r12, r28
    1dd6:	22 e0       	ldi	r18, 0x02	; 2
    1dd8:	c2 0e       	add	r12, r18
    1dda:	d1 1c       	adc	r13, r1
    1ddc:	c6 01       	movw	r24, r12
    1dde:	0e 94 b6 09 	call	0x136c	; 0x136c <vListInitialiseItem>
    1de2:	ce 01       	movw	r24, r28
    1de4:	0e 96       	adiw	r24, 0x0e	; 14
    1de6:	0e 94 b6 09 	call	0x136c	; 0x136c <vListInitialiseItem>
    1dea:	ca 87       	std	Y+10, r28	; 0x0a
    1dec:	db 87       	std	Y+11, r29	; 0x0b
    1dee:	84 e0       	ldi	r24, 0x04	; 4
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	a0 e0       	ldi	r26, 0x00	; 0
    1df4:	b0 e0       	ldi	r27, 0x00	; 0
    1df6:	81 1b       	sub	r24, r17
    1df8:	91 09       	sbc	r25, r1
    1dfa:	a1 09       	sbc	r26, r1
    1dfc:	b1 09       	sbc	r27, r1
    1dfe:	8e 87       	std	Y+14, r24	; 0x0e
    1e00:	9f 87       	std	Y+15, r25	; 0x0f
    1e02:	a8 8b       	std	Y+16, r26	; 0x10
    1e04:	b9 8b       	std	Y+17, r27	; 0x11
    1e06:	ce 8b       	std	Y+22, r28	; 0x16
    1e08:	df 8b       	std	Y+23, r29	; 0x17
    1e0a:	a2 01       	movw	r20, r4
    1e0c:	b5 01       	movw	r22, r10
    1e0e:	c3 01       	movw	r24, r6
    1e10:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <pxPortInitialiseStack>
    1e14:	88 83       	st	Y, r24
    1e16:	99 83       	std	Y+1, r25	; 0x01
    1e18:	e1 14       	cp	r14, r1
    1e1a:	f1 04       	cpc	r15, r1
    1e1c:	19 f0       	breq	.+6      	; 0x1e24 <xTaskGenericCreate+0xdc>
    1e1e:	f7 01       	movw	r30, r14
    1e20:	c0 83       	st	Z, r28
    1e22:	d1 83       	std	Z+1, r29	; 0x01
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	0f 92       	push	r0
    1e2a:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <uxCurrentNumberOfTasks>
    1e2e:	8f 5f       	subi	r24, 0xFF	; 255
    1e30:	80 93 c0 30 	sts	0x30C0, r24	; 0x8030c0 <uxCurrentNumberOfTasks>
    1e34:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxCurrentTCB>
    1e38:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1e3c:	89 2b       	or	r24, r25
    1e3e:	89 f5       	brne	.+98     	; 0x1ea2 <xTaskGenericCreate+0x15a>
    1e40:	c0 93 14 31 	sts	0x3114, r28	; 0x803114 <pxCurrentTCB>
    1e44:	d0 93 15 31 	sts	0x3115, r29	; 0x803115 <pxCurrentTCB+0x1>
    1e48:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <uxCurrentNumberOfTasks>
    1e4c:	81 30       	cpi	r24, 0x01	; 1
    1e4e:	c1 f5       	brne	.+112    	; 0x1ec0 <xTaskGenericCreate+0x178>
    1e50:	88 ee       	ldi	r24, 0xE8	; 232
    1e52:	90 e3       	ldi	r25, 0x30	; 48
    1e54:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    1e58:	83 ef       	ldi	r24, 0xF3	; 243
    1e5a:	90 e3       	ldi	r25, 0x30	; 48
    1e5c:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    1e60:	8e ef       	ldi	r24, 0xFE	; 254
    1e62:	90 e3       	ldi	r25, 0x30	; 48
    1e64:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    1e68:	89 e0       	ldi	r24, 0x09	; 9
    1e6a:	91 e3       	ldi	r25, 0x31	; 49
    1e6c:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    1e70:	8d ed       	ldi	r24, 0xDD	; 221
    1e72:	90 e3       	ldi	r25, 0x30	; 48
    1e74:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    1e78:	82 ed       	ldi	r24, 0xD2	; 210
    1e7a:	90 e3       	ldi	r25, 0x30	; 48
    1e7c:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    1e80:	83 ec       	ldi	r24, 0xC3	; 195
    1e82:	90 e3       	ldi	r25, 0x30	; 48
    1e84:	0e 94 a5 09 	call	0x134a	; 0x134a <vListInitialise>
    1e88:	8d ed       	ldi	r24, 0xDD	; 221
    1e8a:	90 e3       	ldi	r25, 0x30	; 48
    1e8c:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <pxDelayedTaskList>
    1e90:	90 93 d1 30 	sts	0x30D1, r25	; 0x8030d1 <pxDelayedTaskList+0x1>
    1e94:	82 ed       	ldi	r24, 0xD2	; 210
    1e96:	90 e3       	ldi	r25, 0x30	; 48
    1e98:	80 93 ce 30 	sts	0x30CE, r24	; 0x8030ce <pxOverflowDelayedTaskList>
    1e9c:	90 93 cf 30 	sts	0x30CF, r25	; 0x8030cf <pxOverflowDelayedTaskList+0x1>
    1ea0:	0f c0       	rjmp	.+30     	; 0x1ec0 <xTaskGenericCreate+0x178>
    1ea2:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xSchedulerRunning>
    1ea6:	81 11       	cpse	r24, r1
    1ea8:	0b c0       	rjmp	.+22     	; 0x1ec0 <xTaskGenericCreate+0x178>
    1eaa:	e0 91 14 31 	lds	r30, 0x3114	; 0x803114 <pxCurrentTCB>
    1eae:	f0 91 15 31 	lds	r31, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1eb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eb4:	08 17       	cp	r16, r24
    1eb6:	20 f0       	brcs	.+8      	; 0x1ec0 <xTaskGenericCreate+0x178>
    1eb8:	c0 93 14 31 	sts	0x3114, r28	; 0x803114 <pxCurrentTCB>
    1ebc:	d0 93 15 31 	sts	0x3115, r29	; 0x803115 <pxCurrentTCB+0x1>
    1ec0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ec2:	90 91 bb 30 	lds	r25, 0x30BB	; 0x8030bb <uxTopUsedPriority>
    1ec6:	98 17       	cp	r25, r24
    1ec8:	10 f4       	brcc	.+4      	; 0x1ece <xTaskGenericCreate+0x186>
    1eca:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxTopUsedPriority>
    1ece:	90 91 b4 30 	lds	r25, 0x30B4	; 0x8030b4 <uxTaskNumber>
    1ed2:	9f 5f       	subi	r25, 0xFF	; 255
    1ed4:	90 93 b4 30 	sts	0x30B4, r25	; 0x8030b4 <uxTaskNumber>
    1ed8:	90 91 ba 30 	lds	r25, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    1edc:	98 17       	cp	r25, r24
    1ede:	10 f4       	brcc	.+4      	; 0x1ee4 <xTaskGenericCreate+0x19c>
    1ee0:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <uxTopReadyPriority>
    1ee4:	fb e0       	ldi	r31, 0x0B	; 11
    1ee6:	8f 9f       	mul	r24, r31
    1ee8:	c0 01       	movw	r24, r0
    1eea:	11 24       	eor	r1, r1
    1eec:	b6 01       	movw	r22, r12
    1eee:	88 51       	subi	r24, 0x18	; 24
    1ef0:	9f 4c       	sbci	r25, 0xCF	; 207
    1ef2:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsertEnd>
    1ef6:	0f 90       	pop	r0
    1ef8:	0f be       	out	0x3f, r0	; 63
    1efa:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xSchedulerRunning>
    1efe:	88 23       	and	r24, r24
    1f00:	59 f0       	breq	.+22     	; 0x1f18 <xTaskGenericCreate+0x1d0>
    1f02:	e0 91 14 31 	lds	r30, 0x3114	; 0x803114 <pxCurrentTCB>
    1f06:	f0 91 15 31 	lds	r31, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1f0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f0c:	80 17       	cp	r24, r16
    1f0e:	30 f4       	brcc	.+12     	; 0x1f1c <xTaskGenericCreate+0x1d4>
    1f10:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
    1f14:	81 e0       	ldi	r24, 0x01	; 1
    1f16:	09 c0       	rjmp	.+18     	; 0x1f2a <xTaskGenericCreate+0x1e2>
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	07 c0       	rjmp	.+14     	; 0x1f2a <xTaskGenericCreate+0x1e2>
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	05 c0       	rjmp	.+10     	; 0x1f2a <xTaskGenericCreate+0x1e2>
    1f20:	cb 8e       	std	Y+27, r12	; 0x1b
    1f22:	dc 8e       	std	Y+28, r13	; 0x1c
    1f24:	c6 01       	movw	r24, r12
    1f26:	3b cf       	rjmp	.-394    	; 0x1d9e <xTaskGenericCreate+0x56>
    1f28:	8f ef       	ldi	r24, 0xFF	; 255
    1f2a:	df 91       	pop	r29
    1f2c:	cf 91       	pop	r28
    1f2e:	1f 91       	pop	r17
    1f30:	0f 91       	pop	r16
    1f32:	ff 90       	pop	r15
    1f34:	ef 90       	pop	r14
    1f36:	df 90       	pop	r13
    1f38:	cf 90       	pop	r12
    1f3a:	bf 90       	pop	r11
    1f3c:	af 90       	pop	r10
    1f3e:	9f 90       	pop	r9
    1f40:	8f 90       	pop	r8
    1f42:	7f 90       	pop	r7
    1f44:	6f 90       	pop	r6
    1f46:	5f 90       	pop	r5
    1f48:	4f 90       	pop	r4
    1f4a:	08 95       	ret

00001f4c <uxTaskPriorityGet>:
    1f4c:	0f b6       	in	r0, 0x3f	; 63
    1f4e:	f8 94       	cli
    1f50:	0f 92       	push	r0
    1f52:	00 97       	sbiw	r24, 0x00	; 0
    1f54:	21 f4       	brne	.+8      	; 0x1f5e <uxTaskPriorityGet+0x12>
    1f56:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxCurrentTCB>
    1f5a:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    1f5e:	0f 90       	pop	r0
    1f60:	0f be       	out	0x3f, r0	; 63
    1f62:	fc 01       	movw	r30, r24
    1f64:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f66:	08 95       	ret

00001f68 <vTaskStartScheduler>:
    1f68:	af 92       	push	r10
    1f6a:	bf 92       	push	r11
    1f6c:	cf 92       	push	r12
    1f6e:	df 92       	push	r13
    1f70:	ef 92       	push	r14
    1f72:	ff 92       	push	r15
    1f74:	0f 93       	push	r16
    1f76:	a1 2c       	mov	r10, r1
    1f78:	b1 2c       	mov	r11, r1
    1f7a:	c1 2c       	mov	r12, r1
    1f7c:	d1 2c       	mov	r13, r1
    1f7e:	0f 2e       	mov	r0, r31
    1f80:	f1 ec       	ldi	r31, 0xC1	; 193
    1f82:	ef 2e       	mov	r14, r31
    1f84:	f0 e3       	ldi	r31, 0x30	; 48
    1f86:	ff 2e       	mov	r15, r31
    1f88:	f0 2d       	mov	r31, r0
    1f8a:	00 e0       	ldi	r16, 0x00	; 0
    1f8c:	20 e0       	ldi	r18, 0x00	; 0
    1f8e:	30 e0       	ldi	r19, 0x00	; 0
    1f90:	44 e6       	ldi	r20, 0x64	; 100
    1f92:	50 e0       	ldi	r21, 0x00	; 0
    1f94:	6e e2       	ldi	r22, 0x2E	; 46
    1f96:	70 e2       	ldi	r23, 0x20	; 32
    1f98:	8e e4       	ldi	r24, 0x4E	; 78
    1f9a:	9e e0       	ldi	r25, 0x0E	; 14
    1f9c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <xTaskGenericCreate>
    1fa0:	81 30       	cpi	r24, 0x01	; 1
    1fa2:	69 f4       	brne	.+26     	; 0x1fbe <vTaskStartScheduler+0x56>
    1fa4:	f8 94       	cli
    1fa6:	80 93 b9 30 	sts	0x30B9, r24	; 0x8030b9 <xSchedulerRunning>
    1faa:	10 92 bc 30 	sts	0x30BC, r1	; 0x8030bc <xTickCount>
    1fae:	10 92 bd 30 	sts	0x30BD, r1	; 0x8030bd <xTickCount+0x1>
    1fb2:	10 92 be 30 	sts	0x30BE, r1	; 0x8030be <xTickCount+0x2>
    1fb6:	10 92 bf 30 	sts	0x30BF, r1	; 0x8030bf <xTickCount+0x3>
    1fba:	0e 94 c8 0a 	call	0x1590	; 0x1590 <xPortStartScheduler>
    1fbe:	0f 91       	pop	r16
    1fc0:	ff 90       	pop	r15
    1fc2:	ef 90       	pop	r14
    1fc4:	df 90       	pop	r13
    1fc6:	cf 90       	pop	r12
    1fc8:	bf 90       	pop	r11
    1fca:	af 90       	pop	r10
    1fcc:	08 95       	ret

00001fce <vTaskSuspendAll>:
    1fce:	80 91 b8 30 	lds	r24, 0x30B8	; 0x8030b8 <uxSchedulerSuspended>
    1fd2:	8f 5f       	subi	r24, 0xFF	; 255
    1fd4:	80 93 b8 30 	sts	0x30B8, r24	; 0x8030b8 <uxSchedulerSuspended>
    1fd8:	08 95       	ret

00001fda <xTaskGetTickCount>:
    1fda:	0f b6       	in	r0, 0x3f	; 63
    1fdc:	f8 94       	cli
    1fde:	0f 92       	push	r0
    1fe0:	60 91 bc 30 	lds	r22, 0x30BC	; 0x8030bc <xTickCount>
    1fe4:	70 91 bd 30 	lds	r23, 0x30BD	; 0x8030bd <xTickCount+0x1>
    1fe8:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <xTickCount+0x2>
    1fec:	90 91 bf 30 	lds	r25, 0x30BF	; 0x8030bf <xTickCount+0x3>
    1ff0:	0f 90       	pop	r0
    1ff2:	0f be       	out	0x3f, r0	; 63
    1ff4:	08 95       	ret

00001ff6 <pcTaskGetTaskName>:
=======
    1dec:	ce e1       	ldi	r28, 0x1E	; 30
    1dee:	d1 e3       	ldi	r29, 0x31	; 49
    1df0:	88 81       	ld	r24, Y
    1df2:	82 30       	cpi	r24, 0x02	; 2
    1df4:	e8 f3       	brcs	.-6      	; 0x1df0 <prvIdleTask+0x4>
    1df6:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    1dfa:	fa cf       	rjmp	.-12     	; 0x1df0 <prvIdleTask+0x4>

00001dfc <prvAddCurrentTaskToDelayedList>:
    1dfc:	cf 92       	push	r12
    1dfe:	df 92       	push	r13
    1e00:	ef 92       	push	r14
    1e02:	ff 92       	push	r15
    1e04:	6b 01       	movw	r12, r22
    1e06:	7c 01       	movw	r14, r24
    1e08:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    1e0c:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1e10:	62 83       	std	Z+2, r22	; 0x02
    1e12:	73 83       	std	Z+3, r23	; 0x03
    1e14:	84 83       	std	Z+4, r24	; 0x04
    1e16:	95 83       	std	Z+5, r25	; 0x05
    1e18:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    1e1c:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    1e20:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    1e24:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    1e28:	c8 16       	cp	r12, r24
    1e2a:	d9 06       	cpc	r13, r25
    1e2c:	ea 06       	cpc	r14, r26
    1e2e:	fb 06       	cpc	r15, r27
    1e30:	68 f4       	brcc	.+26     	; 0x1e4c <prvAddCurrentTaskToDelayedList+0x50>
    1e32:	60 91 4a 31 	lds	r22, 0x314A	; 0x80314a <pxCurrentTCB>
    1e36:	70 91 4b 31 	lds	r23, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1e3a:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <pxOverflowDelayedTaskList>
    1e3e:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <pxOverflowDelayedTaskList+0x1>
    1e42:	6e 5f       	subi	r22, 0xFE	; 254
    1e44:	7f 4f       	sbci	r23, 0xFF	; 255
    1e46:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInsert>
    1e4a:	21 c0       	rjmp	.+66     	; 0x1e8e <prvAddCurrentTaskToDelayedList+0x92>
    1e4c:	60 91 4a 31 	lds	r22, 0x314A	; 0x80314a <pxCurrentTCB>
    1e50:	70 91 4b 31 	lds	r23, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1e54:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <pxDelayedTaskList>
    1e58:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    1e5c:	6e 5f       	subi	r22, 0xFE	; 254
    1e5e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e60:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInsert>
    1e64:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e68:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e6c:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e70:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e74:	c8 16       	cp	r12, r24
    1e76:	d9 06       	cpc	r13, r25
    1e78:	ea 06       	cpc	r14, r26
    1e7a:	fb 06       	cpc	r15, r27
    1e7c:	40 f4       	brcc	.+16     	; 0x1e8e <prvAddCurrentTaskToDelayedList+0x92>
    1e7e:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e82:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e86:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e8a:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e8e:	ff 90       	pop	r15
    1e90:	ef 90       	pop	r14
    1e92:	df 90       	pop	r13
    1e94:	cf 90       	pop	r12
    1e96:	08 95       	ret

00001e98 <xTaskGenericCreate>:
    1e98:	4f 92       	push	r4
    1e9a:	5f 92       	push	r5
    1e9c:	6f 92       	push	r6
    1e9e:	7f 92       	push	r7
    1ea0:	8f 92       	push	r8
    1ea2:	9f 92       	push	r9
    1ea4:	af 92       	push	r10
    1ea6:	bf 92       	push	r11
    1ea8:	cf 92       	push	r12
    1eaa:	df 92       	push	r13
    1eac:	ef 92       	push	r14
    1eae:	ff 92       	push	r15
    1eb0:	0f 93       	push	r16
    1eb2:	1f 93       	push	r17
    1eb4:	cf 93       	push	r28
    1eb6:	df 93       	push	r29
    1eb8:	5c 01       	movw	r10, r24
    1eba:	4b 01       	movw	r8, r22
    1ebc:	3a 01       	movw	r6, r20
    1ebe:	29 01       	movw	r4, r18
    1ec0:	88 e2       	ldi	r24, 0x28	; 40
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    1ec8:	ec 01       	movw	r28, r24
    1eca:	89 2b       	or	r24, r25
    1ecc:	09 f4       	brne	.+2      	; 0x1ed0 <xTaskGenericCreate+0x38>
    1ece:	d4 c0       	rjmp	.+424    	; 0x2078 <xTaskGenericCreate+0x1e0>
    1ed0:	c1 14       	cp	r12, r1
    1ed2:	d1 04       	cpc	r13, r1
    1ed4:	09 f0       	breq	.+2      	; 0x1ed8 <xTaskGenericCreate+0x40>
    1ed6:	cc c0       	rjmp	.+408    	; 0x2070 <xTaskGenericCreate+0x1d8>
    1ed8:	c3 01       	movw	r24, r6
    1eda:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    1ede:	8b 8f       	std	Y+27, r24	; 0x1b
    1ee0:	9c 8f       	std	Y+28, r25	; 0x1c
    1ee2:	00 97       	sbiw	r24, 0x00	; 0
    1ee4:	21 f4       	brne	.+8      	; 0x1eee <xTaskGenericCreate+0x56>
    1ee6:	ce 01       	movw	r24, r28
    1ee8:	0e 94 15 0a 	call	0x142a	; 0x142a <vPortFree>
    1eec:	c5 c0       	rjmp	.+394    	; 0x2078 <xTaskGenericCreate+0x1e0>
    1eee:	a3 01       	movw	r20, r6
    1ef0:	61 e1       	ldi	r22, 0x11	; 17
    1ef2:	70 e0       	ldi	r23, 0x00	; 0
    1ef4:	0e 94 69 20 	call	0x40d2	; 0x40d2 <memset>
    1ef8:	93 01       	movw	r18, r6
    1efa:	21 50       	subi	r18, 0x01	; 1
    1efc:	31 09       	sbc	r19, r1
    1efe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f00:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1f02:	3c 01       	movw	r6, r24
    1f04:	62 0e       	add	r6, r18
    1f06:	73 1e       	adc	r7, r19
    1f08:	4a e0       	ldi	r20, 0x0A	; 10
    1f0a:	50 e0       	ldi	r21, 0x00	; 0
    1f0c:	b4 01       	movw	r22, r8
    1f0e:	ce 01       	movw	r24, r28
    1f10:	4d 96       	adiw	r24, 0x1d	; 29
    1f12:	0e 94 70 20 	call	0x40e0	; 0x40e0 <strncpy>
    1f16:	1e a2       	std	Y+38, r1	; 0x26
    1f18:	10 2f       	mov	r17, r16
    1f1a:	04 30       	cpi	r16, 0x04	; 4
    1f1c:	08 f0       	brcs	.+2      	; 0x1f20 <xTaskGenericCreate+0x88>
    1f1e:	13 e0       	ldi	r17, 0x03	; 3
    1f20:	1a 8f       	std	Y+26, r17	; 0x1a
    1f22:	1f a3       	std	Y+39, r17	; 0x27
    1f24:	6e 01       	movw	r12, r28
    1f26:	22 e0       	ldi	r18, 0x02	; 2
    1f28:	c2 0e       	add	r12, r18
    1f2a:	d1 1c       	adc	r13, r1
    1f2c:	c6 01       	movw	r24, r12
    1f2e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <vListInitialiseItem>
    1f32:	ce 01       	movw	r24, r28
    1f34:	0e 96       	adiw	r24, 0x0e	; 14
    1f36:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <vListInitialiseItem>
    1f3a:	ca 87       	std	Y+10, r28	; 0x0a
    1f3c:	db 87       	std	Y+11, r29	; 0x0b
    1f3e:	84 e0       	ldi	r24, 0x04	; 4
    1f40:	90 e0       	ldi	r25, 0x00	; 0
    1f42:	a0 e0       	ldi	r26, 0x00	; 0
    1f44:	b0 e0       	ldi	r27, 0x00	; 0
    1f46:	81 1b       	sub	r24, r17
    1f48:	91 09       	sbc	r25, r1
    1f4a:	a1 09       	sbc	r26, r1
    1f4c:	b1 09       	sbc	r27, r1
    1f4e:	8e 87       	std	Y+14, r24	; 0x0e
    1f50:	9f 87       	std	Y+15, r25	; 0x0f
    1f52:	a8 8b       	std	Y+16, r26	; 0x10
    1f54:	b9 8b       	std	Y+17, r27	; 0x11
    1f56:	ce 8b       	std	Y+22, r28	; 0x16
    1f58:	df 8b       	std	Y+23, r29	; 0x17
    1f5a:	a2 01       	movw	r20, r4
    1f5c:	b5 01       	movw	r22, r10
    1f5e:	c3 01       	movw	r24, r6
    1f60:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <pxPortInitialiseStack>
    1f64:	88 83       	st	Y, r24
    1f66:	99 83       	std	Y+1, r25	; 0x01
    1f68:	e1 14       	cp	r14, r1
    1f6a:	f1 04       	cpc	r15, r1
    1f6c:	19 f0       	breq	.+6      	; 0x1f74 <xTaskGenericCreate+0xdc>
    1f6e:	f7 01       	movw	r30, r14
    1f70:	c0 83       	st	Z, r28
    1f72:	d1 83       	std	Z+1, r29	; 0x01
    1f74:	0f b6       	in	r0, 0x3f	; 63
    1f76:	f8 94       	cli
    1f78:	0f 92       	push	r0
    1f7a:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxCurrentNumberOfTasks>
    1f7e:	8f 5f       	subi	r24, 0xFF	; 255
    1f80:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxCurrentNumberOfTasks>
    1f84:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    1f88:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    1f8c:	89 2b       	or	r24, r25
    1f8e:	89 f5       	brne	.+98     	; 0x1ff2 <xTaskGenericCreate+0x15a>
    1f90:	c0 93 4a 31 	sts	0x314A, r28	; 0x80314a <pxCurrentTCB>
    1f94:	d0 93 4b 31 	sts	0x314B, r29	; 0x80314b <pxCurrentTCB+0x1>
    1f98:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxCurrentNumberOfTasks>
    1f9c:	81 30       	cpi	r24, 0x01	; 1
    1f9e:	c1 f5       	brne	.+112    	; 0x2010 <xTaskGenericCreate+0x178>
    1fa0:	8e e1       	ldi	r24, 0x1E	; 30
    1fa2:	91 e3       	ldi	r25, 0x31	; 49
    1fa4:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fa8:	89 e2       	ldi	r24, 0x29	; 41
    1faa:	91 e3       	ldi	r25, 0x31	; 49
    1fac:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fb0:	84 e3       	ldi	r24, 0x34	; 52
    1fb2:	91 e3       	ldi	r25, 0x31	; 49
    1fb4:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fb8:	8f e3       	ldi	r24, 0x3F	; 63
    1fba:	91 e3       	ldi	r25, 0x31	; 49
    1fbc:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fc0:	83 e1       	ldi	r24, 0x13	; 19
    1fc2:	91 e3       	ldi	r25, 0x31	; 49
    1fc4:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fc8:	88 e0       	ldi	r24, 0x08	; 8
    1fca:	91 e3       	ldi	r25, 0x31	; 49
    1fcc:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fd0:	89 ef       	ldi	r24, 0xF9	; 249
    1fd2:	90 e3       	ldi	r25, 0x30	; 48
    1fd4:	0e 94 4d 0a 	call	0x149a	; 0x149a <vListInitialise>
    1fd8:	83 e1       	ldi	r24, 0x13	; 19
    1fda:	91 e3       	ldi	r25, 0x31	; 49
    1fdc:	80 93 06 31 	sts	0x3106, r24	; 0x803106 <pxDelayedTaskList>
    1fe0:	90 93 07 31 	sts	0x3107, r25	; 0x803107 <pxDelayedTaskList+0x1>
    1fe4:	88 e0       	ldi	r24, 0x08	; 8
    1fe6:	91 e3       	ldi	r25, 0x31	; 49
    1fe8:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <pxOverflowDelayedTaskList>
    1fec:	90 93 05 31 	sts	0x3105, r25	; 0x803105 <pxOverflowDelayedTaskList+0x1>
    1ff0:	0f c0       	rjmp	.+30     	; 0x2010 <xTaskGenericCreate+0x178>
    1ff2:	80 91 ef 30 	lds	r24, 0x30EF	; 0x8030ef <xSchedulerRunning>
    1ff6:	81 11       	cpse	r24, r1
    1ff8:	0b c0       	rjmp	.+22     	; 0x2010 <xTaskGenericCreate+0x178>
    1ffa:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    1ffe:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    2002:	82 8d       	ldd	r24, Z+26	; 0x1a
    2004:	08 17       	cp	r16, r24
    2006:	20 f0       	brcs	.+8      	; 0x2010 <xTaskGenericCreate+0x178>
    2008:	c0 93 4a 31 	sts	0x314A, r28	; 0x80314a <pxCurrentTCB>
    200c:	d0 93 4b 31 	sts	0x314B, r29	; 0x80314b <pxCurrentTCB+0x1>
    2010:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2012:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <uxTopUsedPriority>
    2016:	98 17       	cp	r25, r24
    2018:	10 f4       	brcc	.+4      	; 0x201e <xTaskGenericCreate+0x186>
    201a:	80 93 f1 30 	sts	0x30F1, r24	; 0x8030f1 <uxTopUsedPriority>
    201e:	90 91 ea 30 	lds	r25, 0x30EA	; 0x8030ea <uxTaskNumber>
    2022:	9f 5f       	subi	r25, 0xFF	; 255
    2024:	90 93 ea 30 	sts	0x30EA, r25	; 0x8030ea <uxTaskNumber>
    2028:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    202c:	98 17       	cp	r25, r24
    202e:	10 f4       	brcc	.+4      	; 0x2034 <xTaskGenericCreate+0x19c>
    2030:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    2034:	fb e0       	ldi	r31, 0x0B	; 11
    2036:	8f 9f       	mul	r24, r31
    2038:	c0 01       	movw	r24, r0
    203a:	11 24       	eor	r1, r1
    203c:	b6 01       	movw	r22, r12
    203e:	82 5e       	subi	r24, 0xE2	; 226
    2040:	9e 4c       	sbci	r25, 0xCE	; 206
    2042:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63
    204a:	80 91 ef 30 	lds	r24, 0x30EF	; 0x8030ef <xSchedulerRunning>
    204e:	88 23       	and	r24, r24
    2050:	59 f0       	breq	.+22     	; 0x2068 <xTaskGenericCreate+0x1d0>
    2052:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    2056:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    205a:	82 8d       	ldd	r24, Z+26	; 0x1a
    205c:	80 17       	cp	r24, r16
    205e:	30 f4       	brcc	.+12     	; 0x206c <xTaskGenericCreate+0x1d4>
    2060:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
    2064:	81 e0       	ldi	r24, 0x01	; 1
    2066:	09 c0       	rjmp	.+18     	; 0x207a <xTaskGenericCreate+0x1e2>
    2068:	81 e0       	ldi	r24, 0x01	; 1
    206a:	07 c0       	rjmp	.+14     	; 0x207a <xTaskGenericCreate+0x1e2>
    206c:	81 e0       	ldi	r24, 0x01	; 1
    206e:	05 c0       	rjmp	.+10     	; 0x207a <xTaskGenericCreate+0x1e2>
    2070:	cb 8e       	std	Y+27, r12	; 0x1b
    2072:	dc 8e       	std	Y+28, r13	; 0x1c
    2074:	c6 01       	movw	r24, r12
    2076:	3b cf       	rjmp	.-394    	; 0x1eee <xTaskGenericCreate+0x56>
    2078:	8f ef       	ldi	r24, 0xFF	; 255
    207a:	df 91       	pop	r29
    207c:	cf 91       	pop	r28
    207e:	1f 91       	pop	r17
    2080:	0f 91       	pop	r16
    2082:	ff 90       	pop	r15
    2084:	ef 90       	pop	r14
    2086:	df 90       	pop	r13
    2088:	cf 90       	pop	r12
    208a:	bf 90       	pop	r11
    208c:	af 90       	pop	r10
    208e:	9f 90       	pop	r9
    2090:	8f 90       	pop	r8
    2092:	7f 90       	pop	r7
    2094:	6f 90       	pop	r6
    2096:	5f 90       	pop	r5
    2098:	4f 90       	pop	r4
    209a:	08 95       	ret

0000209c <uxTaskPriorityGet>:
    209c:	0f b6       	in	r0, 0x3f	; 63
    209e:	f8 94       	cli
    20a0:	0f 92       	push	r0
    20a2:	00 97       	sbiw	r24, 0x00	; 0
    20a4:	21 f4       	brne	.+8      	; 0x20ae <uxTaskPriorityGet+0x12>
    20a6:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    20aa:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    20ae:	0f 90       	pop	r0
    20b0:	0f be       	out	0x3f, r0	; 63
    20b2:	fc 01       	movw	r30, r24
    20b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    20b6:	08 95       	ret

000020b8 <vTaskStartScheduler>:
    20b8:	af 92       	push	r10
    20ba:	bf 92       	push	r11
    20bc:	cf 92       	push	r12
    20be:	df 92       	push	r13
    20c0:	ef 92       	push	r14
    20c2:	ff 92       	push	r15
    20c4:	0f 93       	push	r16
    20c6:	a1 2c       	mov	r10, r1
    20c8:	b1 2c       	mov	r11, r1
    20ca:	c1 2c       	mov	r12, r1
    20cc:	d1 2c       	mov	r13, r1
    20ce:	0f 2e       	mov	r0, r31
    20d0:	f7 ef       	ldi	r31, 0xF7	; 247
    20d2:	ef 2e       	mov	r14, r31
    20d4:	f0 e3       	ldi	r31, 0x30	; 48
    20d6:	ff 2e       	mov	r15, r31
    20d8:	f0 2d       	mov	r31, r0
    20da:	00 e0       	ldi	r16, 0x00	; 0
    20dc:	20 e0       	ldi	r18, 0x00	; 0
    20de:	30 e0       	ldi	r19, 0x00	; 0
    20e0:	44 e6       	ldi	r20, 0x64	; 100
    20e2:	50 e0       	ldi	r21, 0x00	; 0
    20e4:	6c e5       	ldi	r22, 0x5C	; 92
    20e6:	70 e2       	ldi	r23, 0x20	; 32
    20e8:	86 ef       	ldi	r24, 0xF6	; 246
    20ea:	9e e0       	ldi	r25, 0x0E	; 14
    20ec:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <xTaskGenericCreate>
    20f0:	81 30       	cpi	r24, 0x01	; 1
    20f2:	69 f4       	brne	.+26     	; 0x210e <vTaskStartScheduler+0x56>
    20f4:	f8 94       	cli
    20f6:	80 93 ef 30 	sts	0x30EF, r24	; 0x8030ef <xSchedulerRunning>
    20fa:	10 92 f2 30 	sts	0x30F2, r1	; 0x8030f2 <xTickCount>
    20fe:	10 92 f3 30 	sts	0x30F3, r1	; 0x8030f3 <xTickCount+0x1>
    2102:	10 92 f4 30 	sts	0x30F4, r1	; 0x8030f4 <xTickCount+0x2>
    2106:	10 92 f5 30 	sts	0x30F5, r1	; 0x8030f5 <xTickCount+0x3>
    210a:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <xPortStartScheduler>
    210e:	0f 91       	pop	r16
    2110:	ff 90       	pop	r15
    2112:	ef 90       	pop	r14
    2114:	df 90       	pop	r13
    2116:	cf 90       	pop	r12
    2118:	bf 90       	pop	r11
    211a:	af 90       	pop	r10
    211c:	08 95       	ret

0000211e <vTaskSuspendAll>:
    211e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    2122:	8f 5f       	subi	r24, 0xFF	; 255
    2124:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxSchedulerSuspended>
    2128:	08 95       	ret

0000212a <xTaskGetTickCount>:
    212a:	0f b6       	in	r0, 0x3f	; 63
    212c:	f8 94       	cli
    212e:	0f 92       	push	r0
    2130:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount>
    2134:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2138:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    213c:	90 91 f5 30 	lds	r25, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2140:	0f 90       	pop	r0
    2142:	0f be       	out	0x3f, r0	; 63
    2144:	08 95       	ret

00002146 <pcTaskGetTaskName>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
<<<<<<< HEAD
    1ff6:	00 97       	sbiw	r24, 0x00	; 0
    1ff8:	21 f4       	brne	.+8      	; 0x2002 <pcTaskGetTaskName+0xc>
    1ffa:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxCurrentTCB>
    1ffe:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    2002:	4d 96       	adiw	r24, 0x1d	; 29
    2004:	08 95       	ret

00002006 <xTaskGetIdleTaskHandle>:
=======
    2146:	00 97       	sbiw	r24, 0x00	; 0
    2148:	21 f4       	brne	.+8      	; 0x2152 <pcTaskGetTaskName+0xc>
    214a:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    214e:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    2152:	4d 96       	adiw	r24, 0x1d	; 29
    2154:	08 95       	ret

00002156 <xTaskGetIdleTaskHandle>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
<<<<<<< HEAD
    2006:	80 91 c1 30 	lds	r24, 0x30C1	; 0x8030c1 <xIdleTaskHandle>
    200a:	90 91 c2 30 	lds	r25, 0x30C2	; 0x8030c2 <xIdleTaskHandle+0x1>
    200e:	08 95       	ret

00002010 <vTaskIncrementTick>:
=======
    2156:	80 91 f7 30 	lds	r24, 0x30F7	; 0x8030f7 <xIdleTaskHandle>
    215a:	90 91 f8 30 	lds	r25, 0x30F8	; 0x8030f8 <xIdleTaskHandle+0x1>
    215e:	08 95       	ret

00002160 <vTaskIncrementTick>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
<<<<<<< HEAD
    2010:	ff 92       	push	r15
    2012:	0f 93       	push	r16
    2014:	1f 93       	push	r17
    2016:	cf 93       	push	r28
    2018:	df 93       	push	r29
=======
    2160:	ff 92       	push	r15
    2162:	0f 93       	push	r16
    2164:	1f 93       	push	r17
    2166:	cf 93       	push	r28
    2168:	df 93       	push	r29
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
<<<<<<< HEAD
    201a:	80 91 b8 30 	lds	r24, 0x30B8	; 0x8030b8 <uxSchedulerSuspended>
    201e:	81 11       	cpse	r24, r1
    2020:	ed c0       	rjmp	.+474    	; 0x21fc <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    2022:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    2026:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    202a:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    202e:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
    2032:	01 96       	adiw	r24, 0x01	; 1
    2034:	a1 1d       	adc	r26, r1
    2036:	b1 1d       	adc	r27, r1
    2038:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <xTickCount>
    203c:	90 93 bd 30 	sts	0x30BD, r25	; 0x8030bd <xTickCount+0x1>
    2040:	a0 93 be 30 	sts	0x30BE, r26	; 0x8030be <xTickCount+0x2>
    2044:	b0 93 bf 30 	sts	0x30BF, r27	; 0x8030bf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2048:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    204c:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    2050:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    2054:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
    2058:	89 2b       	or	r24, r25
    205a:	8a 2b       	or	r24, r26
    205c:	8b 2b       	or	r24, r27
    205e:	f1 f5       	brne	.+124    	; 0x20dc <vTaskIncrementTick+0xcc>
=======
    216a:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    216e:	81 11       	cpse	r24, r1
    2170:	ed c0       	rjmp	.+474    	; 0x234c <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    2172:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    2176:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    217a:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    217e:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2182:	01 96       	adiw	r24, 0x01	; 1
    2184:	a1 1d       	adc	r26, r1
    2186:	b1 1d       	adc	r27, r1
    2188:	80 93 f2 30 	sts	0x30F2, r24	; 0x8030f2 <xTickCount>
    218c:	90 93 f3 30 	sts	0x30F3, r25	; 0x8030f3 <xTickCount+0x1>
    2190:	a0 93 f4 30 	sts	0x30F4, r26	; 0x8030f4 <xTickCount+0x2>
    2194:	b0 93 f5 30 	sts	0x30F5, r27	; 0x8030f5 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2198:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    219c:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    21a0:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    21a4:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    21a8:	89 2b       	or	r24, r25
    21aa:	8a 2b       	or	r24, r26
    21ac:	8b 2b       	or	r24, r27
    21ae:	f1 f5       	brne	.+124    	; 0x222c <vTaskIncrementTick+0xcc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
<<<<<<< HEAD
    2060:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <pxDelayedTaskList>
    2064:	90 91 d1 30 	lds	r25, 0x30D1	; 0x8030d1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2068:	20 91 ce 30 	lds	r18, 0x30CE	; 0x8030ce <pxOverflowDelayedTaskList>
    206c:	30 91 cf 30 	lds	r19, 0x30CF	; 0x8030cf <pxOverflowDelayedTaskList+0x1>
    2070:	20 93 d0 30 	sts	0x30D0, r18	; 0x8030d0 <pxDelayedTaskList>
    2074:	30 93 d1 30 	sts	0x30D1, r19	; 0x8030d1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2078:	80 93 ce 30 	sts	0x30CE, r24	; 0x8030ce <pxOverflowDelayedTaskList>
    207c:	90 93 cf 30 	sts	0x30CF, r25	; 0x8030cf <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2080:	80 91 b5 30 	lds	r24, 0x30B5	; 0x8030b5 <xNumOfOverflows>
    2084:	8f 5f       	subi	r24, 0xFF	; 255
    2086:	80 93 b5 30 	sts	0x30B5, r24	; 0x8030b5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    208a:	e0 91 d0 30 	lds	r30, 0x30D0	; 0x8030d0 <pxDelayedTaskList>
    208e:	f0 91 d1 30 	lds	r31, 0x30D1	; 0x8030d1 <pxDelayedTaskList+0x1>
    2092:	80 81       	ld	r24, Z
    2094:	81 11       	cpse	r24, r1
    2096:	0c c0       	rjmp	.+24     	; 0x20b0 <vTaskIncrementTick+0xa0>
=======
    21b0:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <pxDelayedTaskList>
    21b4:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    21b8:	20 91 04 31 	lds	r18, 0x3104	; 0x803104 <pxOverflowDelayedTaskList>
    21bc:	30 91 05 31 	lds	r19, 0x3105	; 0x803105 <pxOverflowDelayedTaskList+0x1>
    21c0:	20 93 06 31 	sts	0x3106, r18	; 0x803106 <pxDelayedTaskList>
    21c4:	30 93 07 31 	sts	0x3107, r19	; 0x803107 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    21c8:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <pxOverflowDelayedTaskList>
    21cc:	90 93 05 31 	sts	0x3105, r25	; 0x803105 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    21d0:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <xNumOfOverflows>
    21d4:	8f 5f       	subi	r24, 0xFF	; 255
    21d6:	80 93 eb 30 	sts	0x30EB, r24	; 0x8030eb <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    21da:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    21de:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    21e2:	80 81       	ld	r24, Z
    21e4:	81 11       	cpse	r24, r1
    21e6:	0c c0       	rjmp	.+24     	; 0x2200 <vTaskIncrementTick+0xa0>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
<<<<<<< HEAD
    2098:	8f ef       	ldi	r24, 0xFF	; 255
    209a:	9f ef       	ldi	r25, 0xFF	; 255
    209c:	dc 01       	movw	r26, r24
    209e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    20a2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    20a6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    20aa:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    20ae:	16 c0       	rjmp	.+44     	; 0x20dc <vTaskIncrementTick+0xcc>
=======
    21e8:	8f ef       	ldi	r24, 0xFF	; 255
    21ea:	9f ef       	ldi	r25, 0xFF	; 255
    21ec:	dc 01       	movw	r26, r24
    21ee:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21f2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21f6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21fa:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    21fe:	16 c0       	rjmp	.+44     	; 0x222c <vTaskIncrementTick+0xcc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
<<<<<<< HEAD
    20b0:	e0 91 d0 30 	lds	r30, 0x30D0	; 0x8030d0 <pxDelayedTaskList>
    20b4:	f0 91 d1 30 	lds	r31, 0x30D1	; 0x8030d1 <pxDelayedTaskList+0x1>
    20b8:	07 80       	ldd	r0, Z+7	; 0x07
    20ba:	f0 85       	ldd	r31, Z+8	; 0x08
    20bc:	e0 2d       	mov	r30, r0
    20be:	00 84       	ldd	r0, Z+8	; 0x08
    20c0:	f1 85       	ldd	r31, Z+9	; 0x09
    20c2:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    20c4:	82 81       	ldd	r24, Z+2	; 0x02
    20c6:	93 81       	ldd	r25, Z+3	; 0x03
    20c8:	a4 81       	ldd	r26, Z+4	; 0x04
    20ca:	b5 81       	ldd	r27, Z+5	; 0x05
    20cc:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    20d0:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    20d4:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    20d8:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
=======
    2200:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    2204:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    2208:	07 80       	ldd	r0, Z+7	; 0x07
    220a:	f0 85       	ldd	r31, Z+8	; 0x08
    220c:	e0 2d       	mov	r30, r0
    220e:	00 84       	ldd	r0, Z+8	; 0x08
    2210:	f1 85       	ldd	r31, Z+9	; 0x09
    2212:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2214:	82 81       	ldd	r24, Z+2	; 0x02
    2216:	93 81       	ldd	r25, Z+3	; 0x03
    2218:	a4 81       	ldd	r26, Z+4	; 0x04
    221a:	b5 81       	ldd	r27, Z+5	; 0x05
    221c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2220:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2224:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2228:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
<<<<<<< HEAD
    20dc:	40 91 bc 30 	lds	r20, 0x30BC	; 0x8030bc <xTickCount>
    20e0:	50 91 bd 30 	lds	r21, 0x30BD	; 0x8030bd <xTickCount+0x1>
    20e4:	60 91 be 30 	lds	r22, 0x30BE	; 0x8030be <xTickCount+0x2>
    20e8:	70 91 bf 30 	lds	r23, 0x30BF	; 0x8030bf <xTickCount+0x3>
    20ec:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    20f0:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    20f4:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    20f8:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    20fc:	48 17       	cp	r20, r24
    20fe:	59 07       	cpc	r21, r25
    2100:	6a 07       	cpc	r22, r26
    2102:	7b 07       	cpc	r23, r27
    2104:	08 f4       	brcc	.+2      	; 0x2108 <vTaskIncrementTick+0xf8>
    2106:	7f c0       	rjmp	.+254    	; 0x2206 <vTaskIncrementTick+0x1f6>
    2108:	e0 91 d0 30 	lds	r30, 0x30D0	; 0x8030d0 <pxDelayedTaskList>
    210c:	f0 91 d1 30 	lds	r31, 0x30D1	; 0x8030d1 <pxDelayedTaskList+0x1>
    2110:	80 81       	ld	r24, Z
    2112:	88 23       	and	r24, r24
    2114:	f9 f0       	breq	.+62     	; 0x2154 <vTaskIncrementTick+0x144>
    2116:	e0 91 d0 30 	lds	r30, 0x30D0	; 0x8030d0 <pxDelayedTaskList>
    211a:	f0 91 d1 30 	lds	r31, 0x30D1	; 0x8030d1 <pxDelayedTaskList+0x1>
    211e:	07 80       	ldd	r0, Z+7	; 0x07
    2120:	f0 85       	ldd	r31, Z+8	; 0x08
    2122:	e0 2d       	mov	r30, r0
    2124:	c0 85       	ldd	r28, Z+8	; 0x08
    2126:	d1 85       	ldd	r29, Z+9	; 0x09
    2128:	8a 81       	ldd	r24, Y+2	; 0x02
    212a:	9b 81       	ldd	r25, Y+3	; 0x03
    212c:	ac 81       	ldd	r26, Y+4	; 0x04
    212e:	bd 81       	ldd	r27, Y+5	; 0x05
    2130:	40 91 bc 30 	lds	r20, 0x30BC	; 0x8030bc <xTickCount>
    2134:	50 91 bd 30 	lds	r21, 0x30BD	; 0x8030bd <xTickCount+0x1>
    2138:	60 91 be 30 	lds	r22, 0x30BE	; 0x8030be <xTickCount+0x2>
    213c:	70 91 bf 30 	lds	r23, 0x30BF	; 0x8030bf <xTickCount+0x3>
    2140:	48 17       	cp	r20, r24
    2142:	59 07       	cpc	r21, r25
    2144:	6a 07       	cpc	r22, r26
    2146:	7b 07       	cpc	r23, r27
    2148:	58 f1       	brcs	.+86     	; 0x21a0 <vTaskIncrementTick+0x190>
    214a:	0f 2e       	mov	r0, r31
    214c:	fb e0       	ldi	r31, 0x0B	; 11
    214e:	ff 2e       	mov	r15, r31
    2150:	f0 2d       	mov	r31, r0
    2152:	2f c0       	rjmp	.+94     	; 0x21b2 <vTaskIncrementTick+0x1a2>
    2154:	8f ef       	ldi	r24, 0xFF	; 255
    2156:	9f ef       	ldi	r25, 0xFF	; 255
    2158:	dc 01       	movw	r26, r24
    215a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    215e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2162:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2166:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    216a:	4d c0       	rjmp	.+154    	; 0x2206 <vTaskIncrementTick+0x1f6>
    216c:	e0 91 d0 30 	lds	r30, 0x30D0	; 0x8030d0 <pxDelayedTaskList>
    2170:	f0 91 d1 30 	lds	r31, 0x30D1	; 0x8030d1 <pxDelayedTaskList+0x1>
    2174:	07 80       	ldd	r0, Z+7	; 0x07
    2176:	f0 85       	ldd	r31, Z+8	; 0x08
    2178:	e0 2d       	mov	r30, r0
    217a:	c0 85       	ldd	r28, Z+8	; 0x08
    217c:	d1 85       	ldd	r29, Z+9	; 0x09
    217e:	8a 81       	ldd	r24, Y+2	; 0x02
    2180:	9b 81       	ldd	r25, Y+3	; 0x03
    2182:	ac 81       	ldd	r26, Y+4	; 0x04
    2184:	bd 81       	ldd	r27, Y+5	; 0x05
    2186:	40 91 bc 30 	lds	r20, 0x30BC	; 0x8030bc <xTickCount>
    218a:	50 91 bd 30 	lds	r21, 0x30BD	; 0x8030bd <xTickCount+0x1>
    218e:	60 91 be 30 	lds	r22, 0x30BE	; 0x8030be <xTickCount+0x2>
    2192:	70 91 bf 30 	lds	r23, 0x30BF	; 0x8030bf <xTickCount+0x3>
    2196:	48 17       	cp	r20, r24
    2198:	59 07       	cpc	r21, r25
    219a:	6a 07       	cpc	r22, r26
    219c:	7b 07       	cpc	r23, r27
    219e:	48 f4       	brcc	.+18     	; 0x21b2 <vTaskIncrementTick+0x1a2>
    21a0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21a4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21a8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21ac:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    21b0:	2a c0       	rjmp	.+84     	; 0x2206 <vTaskIncrementTick+0x1f6>
    21b2:	8e 01       	movw	r16, r28
    21b4:	0e 5f       	subi	r16, 0xFE	; 254
    21b6:	1f 4f       	sbci	r17, 0xFF	; 255
    21b8:	c8 01       	movw	r24, r16
    21ba:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
    21be:	88 8d       	ldd	r24, Y+24	; 0x18
    21c0:	99 8d       	ldd	r25, Y+25	; 0x19
    21c2:	89 2b       	or	r24, r25
    21c4:	21 f0       	breq	.+8      	; 0x21ce <vTaskIncrementTick+0x1be>
    21c6:	ce 01       	movw	r24, r28
    21c8:	0e 96       	adiw	r24, 0x0e	; 14
    21ca:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
    21ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    21d0:	90 91 ba 30 	lds	r25, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    21d4:	98 17       	cp	r25, r24
    21d6:	10 f4       	brcc	.+4      	; 0x21dc <vTaskIncrementTick+0x1cc>
    21d8:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <uxTopReadyPriority>
    21dc:	f8 9e       	mul	r15, r24
    21de:	c0 01       	movw	r24, r0
    21e0:	11 24       	eor	r1, r1
    21e2:	b8 01       	movw	r22, r16
    21e4:	88 51       	subi	r24, 0x18	; 24
    21e6:	9f 4c       	sbci	r25, 0xCF	; 207
    21e8:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsertEnd>
    21ec:	e0 91 d0 30 	lds	r30, 0x30D0	; 0x8030d0 <pxDelayedTaskList>
    21f0:	f0 91 d1 30 	lds	r31, 0x30D1	; 0x8030d1 <pxDelayedTaskList+0x1>
    21f4:	80 81       	ld	r24, Z
    21f6:	81 11       	cpse	r24, r1
    21f8:	b9 cf       	rjmp	.-142    	; 0x216c <vTaskIncrementTick+0x15c>
    21fa:	ac cf       	rjmp	.-168    	; 0x2154 <vTaskIncrementTick+0x144>
=======
    222c:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    2230:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2234:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    2238:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    223c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2240:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2244:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2248:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    224c:	48 17       	cp	r20, r24
    224e:	59 07       	cpc	r21, r25
    2250:	6a 07       	cpc	r22, r26
    2252:	7b 07       	cpc	r23, r27
    2254:	08 f4       	brcc	.+2      	; 0x2258 <vTaskIncrementTick+0xf8>
    2256:	7f c0       	rjmp	.+254    	; 0x2356 <vTaskIncrementTick+0x1f6>
    2258:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    225c:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    2260:	80 81       	ld	r24, Z
    2262:	88 23       	and	r24, r24
    2264:	f9 f0       	breq	.+62     	; 0x22a4 <vTaskIncrementTick+0x144>
    2266:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    226a:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    226e:	07 80       	ldd	r0, Z+7	; 0x07
    2270:	f0 85       	ldd	r31, Z+8	; 0x08
    2272:	e0 2d       	mov	r30, r0
    2274:	c0 85       	ldd	r28, Z+8	; 0x08
    2276:	d1 85       	ldd	r29, Z+9	; 0x09
    2278:	8a 81       	ldd	r24, Y+2	; 0x02
    227a:	9b 81       	ldd	r25, Y+3	; 0x03
    227c:	ac 81       	ldd	r26, Y+4	; 0x04
    227e:	bd 81       	ldd	r27, Y+5	; 0x05
    2280:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    2284:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2288:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    228c:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2290:	48 17       	cp	r20, r24
    2292:	59 07       	cpc	r21, r25
    2294:	6a 07       	cpc	r22, r26
    2296:	7b 07       	cpc	r23, r27
    2298:	58 f1       	brcs	.+86     	; 0x22f0 <vTaskIncrementTick+0x190>
    229a:	0f 2e       	mov	r0, r31
    229c:	fb e0       	ldi	r31, 0x0B	; 11
    229e:	ff 2e       	mov	r15, r31
    22a0:	f0 2d       	mov	r31, r0
    22a2:	2f c0       	rjmp	.+94     	; 0x2302 <vTaskIncrementTick+0x1a2>
    22a4:	8f ef       	ldi	r24, 0xFF	; 255
    22a6:	9f ef       	ldi	r25, 0xFF	; 255
    22a8:	dc 01       	movw	r26, r24
    22aa:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22ae:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22b2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22b6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    22ba:	4d c0       	rjmp	.+154    	; 0x2356 <vTaskIncrementTick+0x1f6>
    22bc:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    22c0:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    22c4:	07 80       	ldd	r0, Z+7	; 0x07
    22c6:	f0 85       	ldd	r31, Z+8	; 0x08
    22c8:	e0 2d       	mov	r30, r0
    22ca:	c0 85       	ldd	r28, Z+8	; 0x08
    22cc:	d1 85       	ldd	r29, Z+9	; 0x09
    22ce:	8a 81       	ldd	r24, Y+2	; 0x02
    22d0:	9b 81       	ldd	r25, Y+3	; 0x03
    22d2:	ac 81       	ldd	r26, Y+4	; 0x04
    22d4:	bd 81       	ldd	r27, Y+5	; 0x05
    22d6:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    22da:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    22de:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    22e2:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    22e6:	48 17       	cp	r20, r24
    22e8:	59 07       	cpc	r21, r25
    22ea:	6a 07       	cpc	r22, r26
    22ec:	7b 07       	cpc	r23, r27
    22ee:	48 f4       	brcc	.+18     	; 0x2302 <vTaskIncrementTick+0x1a2>
    22f0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22f4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22f8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22fc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2300:	2a c0       	rjmp	.+84     	; 0x2356 <vTaskIncrementTick+0x1f6>
    2302:	8e 01       	movw	r16, r28
    2304:	0e 5f       	subi	r16, 0xFE	; 254
    2306:	1f 4f       	sbci	r17, 0xFF	; 255
    2308:	c8 01       	movw	r24, r16
    230a:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
    230e:	88 8d       	ldd	r24, Y+24	; 0x18
    2310:	99 8d       	ldd	r25, Y+25	; 0x19
    2312:	89 2b       	or	r24, r25
    2314:	21 f0       	breq	.+8      	; 0x231e <vTaskIncrementTick+0x1be>
    2316:	ce 01       	movw	r24, r28
    2318:	0e 96       	adiw	r24, 0x0e	; 14
    231a:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
    231e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2320:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    2324:	98 17       	cp	r25, r24
    2326:	10 f4       	brcc	.+4      	; 0x232c <vTaskIncrementTick+0x1cc>
    2328:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    232c:	f8 9e       	mul	r15, r24
    232e:	c0 01       	movw	r24, r0
    2330:	11 24       	eor	r1, r1
    2332:	b8 01       	movw	r22, r16
    2334:	82 5e       	subi	r24, 0xE2	; 226
    2336:	9e 4c       	sbci	r25, 0xCE	; 206
    2338:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
    233c:	e0 91 06 31 	lds	r30, 0x3106	; 0x803106 <pxDelayedTaskList>
    2340:	f0 91 07 31 	lds	r31, 0x3107	; 0x803107 <pxDelayedTaskList+0x1>
    2344:	80 81       	ld	r24, Z
    2346:	81 11       	cpse	r24, r1
    2348:	b9 cf       	rjmp	.-142    	; 0x22bc <vTaskIncrementTick+0x15c>
    234a:	ac cf       	rjmp	.-168    	; 0x22a4 <vTaskIncrementTick+0x144>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
	else
	{
		++uxMissedTicks;
<<<<<<< HEAD
    21fc:	80 91 b7 30 	lds	r24, 0x30B7	; 0x8030b7 <uxMissedTicks>
    2200:	8f 5f       	subi	r24, 0xFF	; 255
    2202:	80 93 b7 30 	sts	0x30B7, r24	; 0x8030b7 <uxMissedTicks>
=======
    234c:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    2350:	8f 5f       	subi	r24, 0xFF	; 255
    2352:	80 93 ed 30 	sts	0x30ED, r24	; 0x8030ed <uxMissedTicks>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
<<<<<<< HEAD
    2206:	df 91       	pop	r29
    2208:	cf 91       	pop	r28
    220a:	1f 91       	pop	r17
    220c:	0f 91       	pop	r16
    220e:	ff 90       	pop	r15
    2210:	08 95       	ret

00002212 <xTaskResumeAll>:
=======
    2356:	df 91       	pop	r29
    2358:	cf 91       	pop	r28
    235a:	1f 91       	pop	r17
    235c:	0f 91       	pop	r16
    235e:	ff 90       	pop	r15
    2360:	08 95       	ret

00002362 <xTaskResumeAll>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
<<<<<<< HEAD
    2212:	cf 92       	push	r12
    2214:	df 92       	push	r13
    2216:	ef 92       	push	r14
    2218:	ff 92       	push	r15
    221a:	0f 93       	push	r16
    221c:	1f 93       	push	r17
    221e:	cf 93       	push	r28
    2220:	df 93       	push	r29
=======
    2362:	cf 92       	push	r12
    2364:	df 92       	push	r13
    2366:	ef 92       	push	r14
    2368:	ff 92       	push	r15
    236a:	0f 93       	push	r16
    236c:	1f 93       	push	r17
    236e:	cf 93       	push	r28
    2370:	df 93       	push	r29
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
<<<<<<< HEAD
    2222:	0f b6       	in	r0, 0x3f	; 63
    2224:	f8 94       	cli
    2226:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2228:	80 91 b8 30 	lds	r24, 0x30B8	; 0x8030b8 <uxSchedulerSuspended>
    222c:	81 50       	subi	r24, 0x01	; 1
    222e:	80 93 b8 30 	sts	0x30B8, r24	; 0x8030b8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2232:	80 91 b8 30 	lds	r24, 0x30B8	; 0x8030b8 <uxSchedulerSuspended>
    2236:	81 11       	cpse	r24, r1
    2238:	60 c0       	rjmp	.+192    	; 0x22fa <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    223a:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <uxCurrentNumberOfTasks>
    223e:	81 11       	cpse	r24, r1
    2240:	2c c0       	rjmp	.+88     	; 0x229a <xTaskResumeAll+0x88>
    2242:	5e c0       	rjmp	.+188    	; 0x2300 <xTaskResumeAll+0xee>
=======
    2372:	0f b6       	in	r0, 0x3f	; 63
    2374:	f8 94       	cli
    2376:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2378:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    237c:	81 50       	subi	r24, 0x01	; 1
    237e:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2382:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    2386:	81 11       	cpse	r24, r1
    2388:	60 c0       	rjmp	.+192    	; 0x244a <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    238a:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxCurrentNumberOfTasks>
    238e:	81 11       	cpse	r24, r1
    2390:	2c c0       	rjmp	.+88     	; 0x23ea <xTaskResumeAll+0x88>
    2392:	5e c0       	rjmp	.+188    	; 0x2450 <xTaskResumeAll+0xee>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
<<<<<<< HEAD
    2244:	d7 01       	movw	r26, r14
    2246:	17 96       	adiw	r26, 0x07	; 7
    2248:	ed 91       	ld	r30, X+
    224a:	fc 91       	ld	r31, X
    224c:	18 97       	sbiw	r26, 0x08	; 8
    224e:	c0 85       	ldd	r28, Z+8	; 0x08
    2250:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2252:	ce 01       	movw	r24, r28
    2254:	0e 96       	adiw	r24, 0x0e	; 14
    2256:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    225a:	8e 01       	movw	r16, r28
    225c:	0e 5f       	subi	r16, 0xFE	; 254
    225e:	1f 4f       	sbci	r17, 0xFF	; 255
    2260:	c8 01       	movw	r24, r16
    2262:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2266:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2268:	90 91 ba 30 	lds	r25, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    226c:	98 17       	cp	r25, r24
    226e:	10 f4       	brcc	.+4      	; 0x2274 <xTaskResumeAll+0x62>
    2270:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <uxTopReadyPriority>
    2274:	d8 9e       	mul	r13, r24
    2276:	c0 01       	movw	r24, r0
    2278:	11 24       	eor	r1, r1
    227a:	b8 01       	movw	r22, r16
    227c:	88 51       	subi	r24, 0x18	; 24
    227e:	9f 4c       	sbci	r25, 0xCF	; 207
    2280:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsertEnd>
=======
    2394:	d7 01       	movw	r26, r14
    2396:	17 96       	adiw	r26, 0x07	; 7
    2398:	ed 91       	ld	r30, X+
    239a:	fc 91       	ld	r31, X
    239c:	18 97       	sbiw	r26, 0x08	; 8
    239e:	c0 85       	ldd	r28, Z+8	; 0x08
    23a0:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    23a2:	ce 01       	movw	r24, r28
    23a4:	0e 96       	adiw	r24, 0x0e	; 14
    23a6:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    23aa:	8e 01       	movw	r16, r28
    23ac:	0e 5f       	subi	r16, 0xFE	; 254
    23ae:	1f 4f       	sbci	r17, 0xFF	; 255
    23b0:	c8 01       	movw	r24, r16
    23b2:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    23b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23b8:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    23bc:	98 17       	cp	r25, r24
    23be:	10 f4       	brcc	.+4      	; 0x23c4 <xTaskResumeAll+0x62>
    23c0:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    23c4:	d8 9e       	mul	r13, r24
    23c6:	c0 01       	movw	r24, r0
    23c8:	11 24       	eor	r1, r1
    23ca:	b8 01       	movw	r22, r16
    23cc:	82 5e       	subi	r24, 0xE2	; 226
    23ce:	9e 4c       	sbci	r25, 0xCE	; 206
    23d0:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
<<<<<<< HEAD
    2284:	e0 91 14 31 	lds	r30, 0x3114	; 0x803114 <pxCurrentTCB>
    2288:	f0 91 15 31 	lds	r31, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    228c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    228e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2290:	98 17       	cp	r25, r24
    2292:	70 f0       	brcs	.+28     	; 0x22b0 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2294:	cc 24       	eor	r12, r12
    2296:	c3 94       	inc	r12
    2298:	0b c0       	rjmp	.+22     	; 0x22b0 <xTaskResumeAll+0x9e>
    229a:	c1 2c       	mov	r12, r1
=======
    23d4:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    23d8:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    23dc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    23de:	82 8d       	ldd	r24, Z+26	; 0x1a
    23e0:	98 17       	cp	r25, r24
    23e2:	70 f0       	brcs	.+28     	; 0x2400 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    23e4:	cc 24       	eor	r12, r12
    23e6:	c3 94       	inc	r12
    23e8:	0b c0       	rjmp	.+22     	; 0x2400 <xTaskResumeAll+0x9e>
    23ea:	c1 2c       	mov	r12, r1
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
<<<<<<< HEAD
    229c:	0f 2e       	mov	r0, r31
    229e:	f3 ec       	ldi	r31, 0xC3	; 195
    22a0:	ef 2e       	mov	r14, r31
    22a2:	f0 e3       	ldi	r31, 0x30	; 48
    22a4:	ff 2e       	mov	r15, r31
    22a6:	f0 2d       	mov	r31, r0
=======
    23ec:	0f 2e       	mov	r0, r31
    23ee:	f9 ef       	ldi	r31, 0xF9	; 249
    23f0:	ef 2e       	mov	r14, r31
    23f2:	f0 e3       	ldi	r31, 0x30	; 48
    23f4:	ff 2e       	mov	r15, r31
    23f6:	f0 2d       	mov	r31, r0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
<<<<<<< HEAD
    22a8:	0f 2e       	mov	r0, r31
    22aa:	fb e0       	ldi	r31, 0x0B	; 11
    22ac:	df 2e       	mov	r13, r31
    22ae:	f0 2d       	mov	r31, r0
=======
    23f8:	0f 2e       	mov	r0, r31
    23fa:	fb e0       	ldi	r31, 0x0B	; 11
    23fc:	df 2e       	mov	r13, r31
    23fe:	f0 2d       	mov	r31, r0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
<<<<<<< HEAD
    22b0:	f7 01       	movw	r30, r14
    22b2:	80 81       	ld	r24, Z
    22b4:	81 11       	cpse	r24, r1
    22b6:	c6 cf       	rjmp	.-116    	; 0x2244 <xTaskResumeAll+0x32>
=======
    2400:	f7 01       	movw	r30, r14
    2402:	80 81       	ld	r24, Z
    2404:	81 11       	cpse	r24, r1
    2406:	c6 cf       	rjmp	.-116    	; 0x2394 <xTaskResumeAll+0x32>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
<<<<<<< HEAD
    22b8:	80 91 b7 30 	lds	r24, 0x30B7	; 0x8030b7 <uxMissedTicks>
    22bc:	88 23       	and	r24, r24
    22be:	81 f0       	breq	.+32     	; 0x22e0 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    22c0:	80 91 b7 30 	lds	r24, 0x30B7	; 0x8030b7 <uxMissedTicks>
    22c4:	88 23       	and	r24, r24
    22c6:	99 f0       	breq	.+38     	; 0x22ee <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    22c8:	0e 94 08 10 	call	0x2010	; 0x2010 <vTaskIncrementTick>
						--uxMissedTicks;
    22cc:	80 91 b7 30 	lds	r24, 0x30B7	; 0x8030b7 <uxMissedTicks>
    22d0:	81 50       	subi	r24, 0x01	; 1
    22d2:	80 93 b7 30 	sts	0x30B7, r24	; 0x8030b7 <uxMissedTicks>
=======
    2408:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    240c:	88 23       	and	r24, r24
    240e:	81 f0       	breq	.+32     	; 0x2430 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2410:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    2414:	88 23       	and	r24, r24
    2416:	99 f0       	breq	.+38     	; 0x243e <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2418:	0e 94 b0 10 	call	0x2160	; 0x2160 <vTaskIncrementTick>
						--uxMissedTicks;
    241c:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    2420:	81 50       	subi	r24, 0x01	; 1
    2422:	80 93 ed 30 	sts	0x30ED, r24	; 0x8030ed <uxMissedTicks>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
<<<<<<< HEAD
    22d6:	80 91 b7 30 	lds	r24, 0x30B7	; 0x8030b7 <uxMissedTicks>
    22da:	81 11       	cpse	r24, r1
    22dc:	f5 cf       	rjmp	.-22     	; 0x22c8 <xTaskResumeAll+0xb6>
    22de:	07 c0       	rjmp	.+14     	; 0x22ee <xTaskResumeAll+0xdc>
=======
    2426:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <uxMissedTicks>
    242a:	81 11       	cpse	r24, r1
    242c:	f5 cf       	rjmp	.-22     	; 0x2418 <xTaskResumeAll+0xb6>
    242e:	07 c0       	rjmp	.+14     	; 0x243e <xTaskResumeAll+0xdc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
<<<<<<< HEAD
    22e0:	f1 e0       	ldi	r31, 0x01	; 1
    22e2:	cf 16       	cp	r12, r31
    22e4:	21 f0       	breq	.+8      	; 0x22ee <xTaskResumeAll+0xdc>
    22e6:	80 91 b6 30 	lds	r24, 0x30B6	; 0x8030b6 <xMissedYield>
    22ea:	81 30       	cpi	r24, 0x01	; 1
    22ec:	41 f4       	brne	.+16     	; 0x22fe <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    22ee:	10 92 b6 30 	sts	0x30B6, r1	; 0x8030b6 <xMissedYield>
					portYIELD_WITHIN_API();
    22f2:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
=======
    2430:	f1 e0       	ldi	r31, 0x01	; 1
    2432:	cf 16       	cp	r12, r31
    2434:	21 f0       	breq	.+8      	; 0x243e <xTaskResumeAll+0xdc>
    2436:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <xMissedYield>
    243a:	81 30       	cpi	r24, 0x01	; 1
    243c:	41 f4       	brne	.+16     	; 0x244e <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    243e:	10 92 ec 30 	sts	0x30EC, r1	; 0x8030ec <xMissedYield>
					portYIELD_WITHIN_API();
    2442:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
<<<<<<< HEAD
    22f6:	81 e0       	ldi	r24, 0x01	; 1
    22f8:	03 c0       	rjmp	.+6      	; 0x2300 <xTaskResumeAll+0xee>
=======
    2446:	81 e0       	ldi	r24, 0x01	; 1
    2448:	03 c0       	rjmp	.+6      	; 0x2450 <xTaskResumeAll+0xee>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
<<<<<<< HEAD
    22fa:	80 e0       	ldi	r24, 0x00	; 0
    22fc:	01 c0       	rjmp	.+2      	; 0x2300 <xTaskResumeAll+0xee>
    22fe:	80 e0       	ldi	r24, 0x00	; 0
=======
    244a:	80 e0       	ldi	r24, 0x00	; 0
    244c:	01 c0       	rjmp	.+2      	; 0x2450 <xTaskResumeAll+0xee>
    244e:	80 e0       	ldi	r24, 0x00	; 0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
<<<<<<< HEAD
    2300:	0f 90       	pop	r0
    2302:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2304:	df 91       	pop	r29
    2306:	cf 91       	pop	r28
    2308:	1f 91       	pop	r17
    230a:	0f 91       	pop	r16
    230c:	ff 90       	pop	r15
    230e:	ef 90       	pop	r14
    2310:	df 90       	pop	r13
    2312:	cf 90       	pop	r12
    2314:	08 95       	ret

00002316 <vTaskDelayUntil>:
=======
    2450:	0f 90       	pop	r0
    2452:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2454:	df 91       	pop	r29
    2456:	cf 91       	pop	r28
    2458:	1f 91       	pop	r17
    245a:	0f 91       	pop	r16
    245c:	ff 90       	pop	r15
    245e:	ef 90       	pop	r14
    2460:	df 90       	pop	r13
    2462:	cf 90       	pop	r12
    2464:	08 95       	ret

00002466 <vTaskDelayUntil>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
<<<<<<< HEAD
    2316:	cf 92       	push	r12
    2318:	df 92       	push	r13
    231a:	ef 92       	push	r14
    231c:	ff 92       	push	r15
    231e:	cf 93       	push	r28
    2320:	df 93       	push	r29
    2322:	ec 01       	movw	r28, r24
    2324:	6a 01       	movw	r12, r20
    2326:	7b 01       	movw	r14, r22
=======
    2466:	cf 92       	push	r12
    2468:	df 92       	push	r13
    246a:	ef 92       	push	r14
    246c:	ff 92       	push	r15
    246e:	cf 93       	push	r28
    2470:	df 93       	push	r29
    2472:	ec 01       	movw	r28, r24
    2474:	6a 01       	movw	r12, r20
    2476:	7b 01       	movw	r14, r22
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
<<<<<<< HEAD
    2328:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    232c:	88 81       	ld	r24, Y
    232e:	99 81       	ldd	r25, Y+1	; 0x01
    2330:	aa 81       	ldd	r26, Y+2	; 0x02
    2332:	bb 81       	ldd	r27, Y+3	; 0x03
    2334:	c8 0e       	add	r12, r24
    2336:	d9 1e       	adc	r13, r25
    2338:	ea 1e       	adc	r14, r26
    233a:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    233c:	40 91 bc 30 	lds	r20, 0x30BC	; 0x8030bc <xTickCount>
    2340:	50 91 bd 30 	lds	r21, 0x30BD	; 0x8030bd <xTickCount+0x1>
    2344:	60 91 be 30 	lds	r22, 0x30BE	; 0x8030be <xTickCount+0x2>
    2348:	70 91 bf 30 	lds	r23, 0x30BF	; 0x8030bf <xTickCount+0x3>
    234c:	48 17       	cp	r20, r24
    234e:	59 07       	cpc	r21, r25
    2350:	6a 07       	cpc	r22, r26
    2352:	7b 07       	cpc	r23, r27
    2354:	b8 f4       	brcc	.+46     	; 0x2384 <vTaskDelayUntil+0x6e>
=======
    2478:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    247c:	88 81       	ld	r24, Y
    247e:	99 81       	ldd	r25, Y+1	; 0x01
    2480:	aa 81       	ldd	r26, Y+2	; 0x02
    2482:	bb 81       	ldd	r27, Y+3	; 0x03
    2484:	c8 0e       	add	r12, r24
    2486:	d9 1e       	adc	r13, r25
    2488:	ea 1e       	adc	r14, r26
    248a:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    248c:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    2490:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2494:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    2498:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    249c:	48 17       	cp	r20, r24
    249e:	59 07       	cpc	r21, r25
    24a0:	6a 07       	cpc	r22, r26
    24a2:	7b 07       	cpc	r23, r27
    24a4:	b8 f4       	brcc	.+46     	; 0x24d4 <vTaskDelayUntil+0x6e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
<<<<<<< HEAD
    2356:	c8 16       	cp	r12, r24
    2358:	d9 06       	cpc	r13, r25
    235a:	ea 06       	cpc	r14, r26
    235c:	fb 06       	cpc	r15, r27
    235e:	e0 f5       	brcc	.+120    	; 0x23d8 <vTaskDelayUntil+0xc2>
    2360:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    2364:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    2368:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    236c:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
=======
    24a6:	c8 16       	cp	r12, r24
    24a8:	d9 06       	cpc	r13, r25
    24aa:	ea 06       	cpc	r14, r26
    24ac:	fb 06       	cpc	r15, r27
    24ae:	e0 f5       	brcc	.+120    	; 0x2528 <vTaskDelayUntil+0xc2>
    24b0:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    24b4:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    24b8:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    24bc:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
<<<<<<< HEAD
    2370:	c8 82       	st	Y, r12
    2372:	d9 82       	std	Y+1, r13	; 0x01
    2374:	ea 82       	std	Y+2, r14	; 0x02
    2376:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2378:	8c 15       	cp	r24, r12
    237a:	9d 05       	cpc	r25, r13
    237c:	ae 05       	cpc	r26, r14
    237e:	bf 05       	cpc	r27, r15
    2380:	f8 f4       	brcc	.+62     	; 0x23c0 <vTaskDelayUntil+0xaa>
    2382:	13 c0       	rjmp	.+38     	; 0x23aa <vTaskDelayUntil+0x94>
=======
    24c0:	c8 82       	st	Y, r12
    24c2:	d9 82       	std	Y+1, r13	; 0x01
    24c4:	ea 82       	std	Y+2, r14	; 0x02
    24c6:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    24c8:	8c 15       	cp	r24, r12
    24ca:	9d 05       	cpc	r25, r13
    24cc:	ae 05       	cpc	r26, r14
    24ce:	bf 05       	cpc	r27, r15
    24d0:	f8 f4       	brcc	.+62     	; 0x2510 <vTaskDelayUntil+0xaa>
    24d2:	13 c0       	rjmp	.+38     	; 0x24fa <vTaskDelayUntil+0x94>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
<<<<<<< HEAD
    2384:	c8 16       	cp	r12, r24
    2386:	d9 06       	cpc	r13, r25
    2388:	ea 06       	cpc	r14, r26
    238a:	fb 06       	cpc	r15, r27
    238c:	00 f1       	brcs	.+64     	; 0x23ce <vTaskDelayUntil+0xb8>
    238e:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    2392:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    2396:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    239a:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
    239e:	8c 15       	cp	r24, r12
    23a0:	9d 05       	cpc	r25, r13
    23a2:	ae 05       	cpc	r26, r14
    23a4:	bf 05       	cpc	r27, r15
    23a6:	98 f0       	brcs	.+38     	; 0x23ce <vTaskDelayUntil+0xb8>
    23a8:	17 c0       	rjmp	.+46     	; 0x23d8 <vTaskDelayUntil+0xc2>
=======
    24d4:	c8 16       	cp	r12, r24
    24d6:	d9 06       	cpc	r13, r25
    24d8:	ea 06       	cpc	r14, r26
    24da:	fb 06       	cpc	r15, r27
    24dc:	00 f1       	brcs	.+64     	; 0x251e <vTaskDelayUntil+0xb8>
    24de:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    24e2:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    24e6:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    24ea:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    24ee:	8c 15       	cp	r24, r12
    24f0:	9d 05       	cpc	r25, r13
    24f2:	ae 05       	cpc	r26, r14
    24f4:	bf 05       	cpc	r27, r15
    24f6:	98 f0       	brcs	.+38     	; 0x251e <vTaskDelayUntil+0xb8>
    24f8:	17 c0       	rjmp	.+46     	; 0x2528 <vTaskDelayUntil+0xc2>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
<<<<<<< HEAD
    23aa:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxCurrentTCB>
    23ae:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    23b2:	02 96       	adiw	r24, 0x02	; 2
    23b4:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    23b8:	c7 01       	movw	r24, r14
    23ba:	b6 01       	movw	r22, r12
    23bc:	0e 94 56 0e 	call	0x1cac	; 0x1cac <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    23c0:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
=======
    24fa:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    24fe:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    2502:	02 96       	adiw	r24, 0x02	; 2
    2504:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2508:	c7 01       	movw	r24, r14
    250a:	b6 01       	movw	r22, r12
    250c:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2510:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
<<<<<<< HEAD
    23c4:	81 11       	cpse	r24, r1
    23c6:	0d c0       	rjmp	.+26     	; 0x23e2 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    23c8:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
		}
	}
    23cc:	0a c0       	rjmp	.+20     	; 0x23e2 <vTaskDelayUntil+0xcc>
=======
    2514:	81 11       	cpse	r24, r1
    2516:	0d c0       	rjmp	.+26     	; 0x2532 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2518:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
		}
	}
    251c:	0a c0       	rjmp	.+20     	; 0x2532 <vTaskDelayUntil+0xcc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
<<<<<<< HEAD
    23ce:	c8 82       	st	Y, r12
    23d0:	d9 82       	std	Y+1, r13	; 0x01
    23d2:	ea 82       	std	Y+2, r14	; 0x02
    23d4:	fb 82       	std	Y+3, r15	; 0x03
    23d6:	e9 cf       	rjmp	.-46     	; 0x23aa <vTaskDelayUntil+0x94>
    23d8:	c8 82       	st	Y, r12
    23da:	d9 82       	std	Y+1, r13	; 0x01
    23dc:	ea 82       	std	Y+2, r14	; 0x02
    23de:	fb 82       	std	Y+3, r15	; 0x03
    23e0:	ef cf       	rjmp	.-34     	; 0x23c0 <vTaskDelayUntil+0xaa>
=======
    251e:	c8 82       	st	Y, r12
    2520:	d9 82       	std	Y+1, r13	; 0x01
    2522:	ea 82       	std	Y+2, r14	; 0x02
    2524:	fb 82       	std	Y+3, r15	; 0x03
    2526:	e9 cf       	rjmp	.-46     	; 0x24fa <vTaskDelayUntil+0x94>
    2528:	c8 82       	st	Y, r12
    252a:	d9 82       	std	Y+1, r13	; 0x01
    252c:	ea 82       	std	Y+2, r14	; 0x02
    252e:	fb 82       	std	Y+3, r15	; 0x03
    2530:	ef cf       	rjmp	.-34     	; 0x2510 <vTaskDelayUntil+0xaa>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
<<<<<<< HEAD
    23e2:	df 91       	pop	r29
    23e4:	cf 91       	pop	r28
    23e6:	ff 90       	pop	r15
    23e8:	ef 90       	pop	r14
    23ea:	df 90       	pop	r13
    23ec:	cf 90       	pop	r12
    23ee:	08 95       	ret

000023f0 <vTaskDelay>:
=======
    2532:	df 91       	pop	r29
    2534:	cf 91       	pop	r28
    2536:	ff 90       	pop	r15
    2538:	ef 90       	pop	r14
    253a:	df 90       	pop	r13
    253c:	cf 90       	pop	r12
    253e:	08 95       	ret

00002540 <vTaskDelay>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
<<<<<<< HEAD
    23f0:	cf 92       	push	r12
    23f2:	df 92       	push	r13
    23f4:	ef 92       	push	r14
    23f6:	ff 92       	push	r15
    23f8:	6b 01       	movw	r12, r22
    23fa:	7c 01       	movw	r14, r24
=======
    2540:	cf 92       	push	r12
    2542:	df 92       	push	r13
    2544:	ef 92       	push	r14
    2546:	ff 92       	push	r15
    2548:	6b 01       	movw	r12, r22
    254a:	7c 01       	movw	r14, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
<<<<<<< HEAD
    23fc:	67 2b       	or	r22, r23
    23fe:	68 2b       	or	r22, r24
    2400:	69 2b       	or	r22, r25
    2402:	e9 f0       	breq	.+58     	; 0x243e <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2404:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskSuspendAll>
=======
    254c:	67 2b       	or	r22, r23
    254e:	68 2b       	or	r22, r24
    2550:	69 2b       	or	r22, r25
    2552:	e9 f0       	breq	.+58     	; 0x258e <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2554:	0e 94 8f 10 	call	0x211e	; 0x211e <vTaskSuspendAll>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
<<<<<<< HEAD
    2408:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    240c:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    2410:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    2414:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
    2418:	c8 0e       	add	r12, r24
    241a:	d9 1e       	adc	r13, r25
    241c:	ea 1e       	adc	r14, r26
    241e:	fb 1e       	adc	r15, r27
=======
    2558:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    255c:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2560:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    2564:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2568:	c8 0e       	add	r12, r24
    256a:	d9 1e       	adc	r13, r25
    256c:	ea 1e       	adc	r14, r26
    256e:	fb 1e       	adc	r15, r27
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
<<<<<<< HEAD
    2420:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxCurrentTCB>
    2424:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    2428:	02 96       	adiw	r24, 0x02	; 2
    242a:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    242e:	c7 01       	movw	r24, r14
    2430:	b6 01       	movw	r22, r12
    2432:	0e 94 56 0e 	call	0x1cac	; 0x1cac <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2436:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskResumeAll>
=======
    2570:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    2574:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    2578:	02 96       	adiw	r24, 0x02	; 2
    257a:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    257e:	c7 01       	movw	r24, r14
    2580:	b6 01       	movw	r22, r12
    2582:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2586:	0e 94 b1 11 	call	0x2362	; 0x2362 <xTaskResumeAll>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
<<<<<<< HEAD
    243a:	81 11       	cpse	r24, r1
    243c:	02 c0       	rjmp	.+4      	; 0x2442 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    243e:	0e 94 06 0b 	call	0x160c	; 0x160c <vPortYield>
		}
	}
    2442:	ff 90       	pop	r15
    2444:	ef 90       	pop	r14
    2446:	df 90       	pop	r13
    2448:	cf 90       	pop	r12
    244a:	08 95       	ret

0000244c <vTaskSwitchContext>:
=======
    258a:	81 11       	cpse	r24, r1
    258c:	02 c0       	rjmp	.+4      	; 0x2592 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    258e:	0e 94 ae 0b 	call	0x175c	; 0x175c <vPortYield>
		}
	}
    2592:	ff 90       	pop	r15
    2594:	ef 90       	pop	r14
    2596:	df 90       	pop	r13
    2598:	cf 90       	pop	r12
    259a:	08 95       	ret

0000259c <vTaskSwitchContext>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
<<<<<<< HEAD
    244c:	80 91 b8 30 	lds	r24, 0x30B8	; 0x8030b8 <uxSchedulerSuspended>
    2450:	81 11       	cpse	r24, r1
    2452:	0c c0       	rjmp	.+24     	; 0x246c <vTaskSwitchContext+0x20>
=======
    259c:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    25a0:	81 11       	cpse	r24, r1
    25a2:	0c c0       	rjmp	.+24     	; 0x25bc <vTaskSwitchContext+0x20>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
<<<<<<< HEAD
    2454:	e0 91 ba 30 	lds	r30, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    2458:	4b e0       	ldi	r20, 0x0B	; 11
    245a:	e4 9f       	mul	r30, r20
    245c:	f0 01       	movw	r30, r0
    245e:	11 24       	eor	r1, r1
    2460:	e8 51       	subi	r30, 0x18	; 24
    2462:	ff 4c       	sbci	r31, 0xCF	; 207
    2464:	80 81       	ld	r24, Z
    2466:	88 23       	and	r24, r24
    2468:	29 f0       	breq	.+10     	; 0x2474 <vTaskSwitchContext+0x28>
    246a:	14 c0       	rjmp	.+40     	; 0x2494 <vTaskSwitchContext+0x48>
=======
    25a4:	e0 91 f0 30 	lds	r30, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    25a8:	4b e0       	ldi	r20, 0x0B	; 11
    25aa:	e4 9f       	mul	r30, r20
    25ac:	f0 01       	movw	r30, r0
    25ae:	11 24       	eor	r1, r1
    25b0:	e2 5e       	subi	r30, 0xE2	; 226
    25b2:	fe 4c       	sbci	r31, 0xCE	; 206
    25b4:	80 81       	ld	r24, Z
    25b6:	88 23       	and	r24, r24
    25b8:	29 f0       	breq	.+10     	; 0x25c4 <vTaskSwitchContext+0x28>
    25ba:	14 c0       	rjmp	.+40     	; 0x25e4 <vTaskSwitchContext+0x48>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
<<<<<<< HEAD
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	80 93 b6 30 	sts	0x30B6, r24	; 0x8030b6 <xMissedYield>
    2472:	08 95       	ret
=======
    25bc:	81 e0       	ldi	r24, 0x01	; 1
    25be:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <xMissedYield>
    25c2:	08 95       	ret
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
<<<<<<< HEAD
    2474:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2476:	80 91 ba 30 	lds	r24, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    247a:	81 50       	subi	r24, 0x01	; 1
    247c:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <uxTopReadyPriority>
=======
    25c4:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    25c6:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    25ca:	81 50       	subi	r24, 0x01	; 1
    25cc:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
<<<<<<< HEAD
    2480:	e0 91 ba 30 	lds	r30, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    2484:	9e 9f       	mul	r25, r30
    2486:	f0 01       	movw	r30, r0
    2488:	11 24       	eor	r1, r1
    248a:	e8 51       	subi	r30, 0x18	; 24
    248c:	ff 4c       	sbci	r31, 0xCF	; 207
    248e:	80 81       	ld	r24, Z
    2490:	88 23       	and	r24, r24
    2492:	89 f3       	breq	.-30     	; 0x2476 <vTaskSwitchContext+0x2a>
=======
    25d0:	e0 91 f0 30 	lds	r30, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    25d4:	9e 9f       	mul	r25, r30
    25d6:	f0 01       	movw	r30, r0
    25d8:	11 24       	eor	r1, r1
    25da:	e2 5e       	subi	r30, 0xE2	; 226
    25dc:	fe 4c       	sbci	r31, 0xCE	; 206
    25de:	80 81       	ld	r24, Z
    25e0:	88 23       	and	r24, r24
    25e2:	89 f3       	breq	.-30     	; 0x25c6 <vTaskSwitchContext+0x2a>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
<<<<<<< HEAD
    2494:	80 91 ba 30 	lds	r24, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    2498:	28 2f       	mov	r18, r24
    249a:	30 e0       	ldi	r19, 0x00	; 0
    249c:	4b e0       	ldi	r20, 0x0B	; 11
    249e:	84 9f       	mul	r24, r20
    24a0:	c0 01       	movw	r24, r0
    24a2:	11 24       	eor	r1, r1
    24a4:	dc 01       	movw	r26, r24
    24a6:	a8 51       	subi	r26, 0x18	; 24
    24a8:	bf 4c       	sbci	r27, 0xCF	; 207
    24aa:	11 96       	adiw	r26, 0x01	; 1
    24ac:	ed 91       	ld	r30, X+
    24ae:	fc 91       	ld	r31, X
    24b0:	12 97       	sbiw	r26, 0x02	; 2
    24b2:	04 80       	ldd	r0, Z+4	; 0x04
    24b4:	f5 81       	ldd	r31, Z+5	; 0x05
    24b6:	e0 2d       	mov	r30, r0
    24b8:	11 96       	adiw	r26, 0x01	; 1
    24ba:	ed 93       	st	X+, r30
    24bc:	fc 93       	st	X, r31
    24be:	12 97       	sbiw	r26, 0x02	; 2
    24c0:	85 51       	subi	r24, 0x15	; 21
    24c2:	9f 4c       	sbci	r25, 0xCF	; 207
    24c4:	e8 17       	cp	r30, r24
    24c6:	f9 07       	cpc	r31, r25
    24c8:	61 f4       	brne	.+24     	; 0x24e2 <vTaskSwitchContext+0x96>
    24ca:	84 81       	ldd	r24, Z+4	; 0x04
    24cc:	95 81       	ldd	r25, Z+5	; 0x05
    24ce:	4b e0       	ldi	r20, 0x0B	; 11
    24d0:	42 9f       	mul	r20, r18
    24d2:	f0 01       	movw	r30, r0
    24d4:	43 9f       	mul	r20, r19
    24d6:	f0 0d       	add	r31, r0
    24d8:	11 24       	eor	r1, r1
    24da:	e8 51       	subi	r30, 0x18	; 24
    24dc:	ff 4c       	sbci	r31, 0xCF	; 207
    24de:	81 83       	std	Z+1, r24	; 0x01
    24e0:	92 83       	std	Z+2, r25	; 0x02
    24e2:	8b e0       	ldi	r24, 0x0B	; 11
    24e4:	82 9f       	mul	r24, r18
    24e6:	f0 01       	movw	r30, r0
    24e8:	83 9f       	mul	r24, r19
    24ea:	f0 0d       	add	r31, r0
    24ec:	11 24       	eor	r1, r1
    24ee:	e8 51       	subi	r30, 0x18	; 24
    24f0:	ff 4c       	sbci	r31, 0xCF	; 207
    24f2:	01 80       	ldd	r0, Z+1	; 0x01
    24f4:	f2 81       	ldd	r31, Z+2	; 0x02
    24f6:	e0 2d       	mov	r30, r0
    24f8:	80 85       	ldd	r24, Z+8	; 0x08
    24fa:	91 85       	ldd	r25, Z+9	; 0x09
    24fc:	80 93 14 31 	sts	0x3114, r24	; 0x803114 <pxCurrentTCB>
    2500:	90 93 15 31 	sts	0x3115, r25	; 0x803115 <pxCurrentTCB+0x1>
    2504:	08 95       	ret

00002506 <vTaskPlaceOnEventList>:
=======
    25e4:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    25e8:	28 2f       	mov	r18, r24
    25ea:	30 e0       	ldi	r19, 0x00	; 0
    25ec:	4b e0       	ldi	r20, 0x0B	; 11
    25ee:	84 9f       	mul	r24, r20
    25f0:	c0 01       	movw	r24, r0
    25f2:	11 24       	eor	r1, r1
    25f4:	dc 01       	movw	r26, r24
    25f6:	a2 5e       	subi	r26, 0xE2	; 226
    25f8:	be 4c       	sbci	r27, 0xCE	; 206
    25fa:	11 96       	adiw	r26, 0x01	; 1
    25fc:	ed 91       	ld	r30, X+
    25fe:	fc 91       	ld	r31, X
    2600:	12 97       	sbiw	r26, 0x02	; 2
    2602:	04 80       	ldd	r0, Z+4	; 0x04
    2604:	f5 81       	ldd	r31, Z+5	; 0x05
    2606:	e0 2d       	mov	r30, r0
    2608:	11 96       	adiw	r26, 0x01	; 1
    260a:	ed 93       	st	X+, r30
    260c:	fc 93       	st	X, r31
    260e:	12 97       	sbiw	r26, 0x02	; 2
    2610:	8f 5d       	subi	r24, 0xDF	; 223
    2612:	9e 4c       	sbci	r25, 0xCE	; 206
    2614:	e8 17       	cp	r30, r24
    2616:	f9 07       	cpc	r31, r25
    2618:	61 f4       	brne	.+24     	; 0x2632 <vTaskSwitchContext+0x96>
    261a:	84 81       	ldd	r24, Z+4	; 0x04
    261c:	95 81       	ldd	r25, Z+5	; 0x05
    261e:	4b e0       	ldi	r20, 0x0B	; 11
    2620:	42 9f       	mul	r20, r18
    2622:	f0 01       	movw	r30, r0
    2624:	43 9f       	mul	r20, r19
    2626:	f0 0d       	add	r31, r0
    2628:	11 24       	eor	r1, r1
    262a:	e2 5e       	subi	r30, 0xE2	; 226
    262c:	fe 4c       	sbci	r31, 0xCE	; 206
    262e:	81 83       	std	Z+1, r24	; 0x01
    2630:	92 83       	std	Z+2, r25	; 0x02
    2632:	8b e0       	ldi	r24, 0x0B	; 11
    2634:	82 9f       	mul	r24, r18
    2636:	f0 01       	movw	r30, r0
    2638:	83 9f       	mul	r24, r19
    263a:	f0 0d       	add	r31, r0
    263c:	11 24       	eor	r1, r1
    263e:	e2 5e       	subi	r30, 0xE2	; 226
    2640:	fe 4c       	sbci	r31, 0xCE	; 206
    2642:	01 80       	ldd	r0, Z+1	; 0x01
    2644:	f2 81       	ldd	r31, Z+2	; 0x02
    2646:	e0 2d       	mov	r30, r0
    2648:	80 85       	ldd	r24, Z+8	; 0x08
    264a:	91 85       	ldd	r25, Z+9	; 0x09
    264c:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <pxCurrentTCB>
    2650:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <pxCurrentTCB+0x1>
    2654:	08 95       	ret

00002656 <vTaskPlaceOnEventList>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
<<<<<<< HEAD
    2506:	cf 92       	push	r12
    2508:	df 92       	push	r13
    250a:	ef 92       	push	r14
    250c:	ff 92       	push	r15
    250e:	6a 01       	movw	r12, r20
    2510:	7b 01       	movw	r14, r22
=======
    2656:	cf 92       	push	r12
    2658:	df 92       	push	r13
    265a:	ef 92       	push	r14
    265c:	ff 92       	push	r15
    265e:	6a 01       	movw	r12, r20
    2660:	7b 01       	movw	r14, r22
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
<<<<<<< HEAD
    2512:	60 91 14 31 	lds	r22, 0x3114	; 0x803114 <pxCurrentTCB>
    2516:	70 91 15 31 	lds	r23, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    251a:	62 5f       	subi	r22, 0xF2	; 242
    251c:	7f 4f       	sbci	r23, 0xFF	; 255
    251e:	0e 94 e1 09 	call	0x13c2	; 0x13c2 <vListInsert>
=======
    2662:	60 91 4a 31 	lds	r22, 0x314A	; 0x80314a <pxCurrentTCB>
    2666:	70 91 4b 31 	lds	r23, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    266a:	62 5f       	subi	r22, 0xF2	; 242
    266c:	7f 4f       	sbci	r23, 0xFF	; 255
    266e:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInsert>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
<<<<<<< HEAD
    2522:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxCurrentTCB>
    2526:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    252a:	02 96       	adiw	r24, 0x02	; 2
    252c:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
=======
    2672:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    2676:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    267a:	02 96       	adiw	r24, 0x02	; 2
    267c:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
<<<<<<< HEAD
    2530:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    2534:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    2538:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    253c:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2540:	bc 01       	movw	r22, r24
    2542:	cd 01       	movw	r24, r26
    2544:	6c 0d       	add	r22, r12
    2546:	7d 1d       	adc	r23, r13
    2548:	8e 1d       	adc	r24, r14
    254a:	9f 1d       	adc	r25, r15
    254c:	0e 94 56 0e 	call	0x1cac	; 0x1cac <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2550:	ff 90       	pop	r15
    2552:	ef 90       	pop	r14
    2554:	df 90       	pop	r13
    2556:	cf 90       	pop	r12
    2558:	08 95       	ret

0000255a <xTaskRemoveFromEventList>:
=======
    2680:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    2684:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2688:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    268c:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2690:	bc 01       	movw	r22, r24
    2692:	cd 01       	movw	r24, r26
    2694:	6c 0d       	add	r22, r12
    2696:	7d 1d       	adc	r23, r13
    2698:	8e 1d       	adc	r24, r14
    269a:	9f 1d       	adc	r25, r15
    269c:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    26a0:	ff 90       	pop	r15
    26a2:	ef 90       	pop	r14
    26a4:	df 90       	pop	r13
    26a6:	cf 90       	pop	r12
    26a8:	08 95       	ret

000026aa <xTaskRemoveFromEventList>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
<<<<<<< HEAD
    255a:	0f 93       	push	r16
    255c:	1f 93       	push	r17
    255e:	cf 93       	push	r28
    2560:	df 93       	push	r29
=======
    26aa:	0f 93       	push	r16
    26ac:	1f 93       	push	r17
    26ae:	cf 93       	push	r28
    26b0:	df 93       	push	r29
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
<<<<<<< HEAD
    2562:	dc 01       	movw	r26, r24
    2564:	17 96       	adiw	r26, 0x07	; 7
    2566:	ed 91       	ld	r30, X+
    2568:	fc 91       	ld	r31, X
    256a:	18 97       	sbiw	r26, 0x08	; 8
    256c:	c0 85       	ldd	r28, Z+8	; 0x08
    256e:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2570:	8e 01       	movw	r16, r28
    2572:	02 5f       	subi	r16, 0xF2	; 242
    2574:	1f 4f       	sbci	r17, 0xFF	; 255
    2576:	c8 01       	movw	r24, r16
    2578:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    257c:	80 91 b8 30 	lds	r24, 0x30B8	; 0x8030b8 <uxSchedulerSuspended>
    2580:	81 11       	cpse	r24, r1
    2582:	16 c0       	rjmp	.+44     	; 0x25b0 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2584:	0c 50       	subi	r16, 0x0C	; 12
    2586:	11 09       	sbc	r17, r1
    2588:	c8 01       	movw	r24, r16
    258a:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    258e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2590:	90 91 ba 30 	lds	r25, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    2594:	98 17       	cp	r25, r24
    2596:	10 f4       	brcc	.+4      	; 0x259c <xTaskRemoveFromEventList+0x42>
    2598:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <uxTopReadyPriority>
    259c:	bb e0       	ldi	r27, 0x0B	; 11
    259e:	8b 9f       	mul	r24, r27
    25a0:	c0 01       	movw	r24, r0
    25a2:	11 24       	eor	r1, r1
    25a4:	b8 01       	movw	r22, r16
    25a6:	88 51       	subi	r24, 0x18	; 24
    25a8:	9f 4c       	sbci	r25, 0xCF	; 207
    25aa:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsertEnd>
    25ae:	05 c0       	rjmp	.+10     	; 0x25ba <xTaskRemoveFromEventList+0x60>
=======
    26b2:	dc 01       	movw	r26, r24
    26b4:	17 96       	adiw	r26, 0x07	; 7
    26b6:	ed 91       	ld	r30, X+
    26b8:	fc 91       	ld	r31, X
    26ba:	18 97       	sbiw	r26, 0x08	; 8
    26bc:	c0 85       	ldd	r28, Z+8	; 0x08
    26be:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    26c0:	8e 01       	movw	r16, r28
    26c2:	02 5f       	subi	r16, 0xF2	; 242
    26c4:	1f 4f       	sbci	r17, 0xFF	; 255
    26c6:	c8 01       	movw	r24, r16
    26c8:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    26cc:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxSchedulerSuspended>
    26d0:	81 11       	cpse	r24, r1
    26d2:	16 c0       	rjmp	.+44     	; 0x2700 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    26d4:	0c 50       	subi	r16, 0x0C	; 12
    26d6:	11 09       	sbc	r17, r1
    26d8:	c8 01       	movw	r24, r16
    26da:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    26de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    26e0:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    26e4:	98 17       	cp	r25, r24
    26e6:	10 f4       	brcc	.+4      	; 0x26ec <xTaskRemoveFromEventList+0x42>
    26e8:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    26ec:	bb e0       	ldi	r27, 0x0B	; 11
    26ee:	8b 9f       	mul	r24, r27
    26f0:	c0 01       	movw	r24, r0
    26f2:	11 24       	eor	r1, r1
    26f4:	b8 01       	movw	r22, r16
    26f6:	82 5e       	subi	r24, 0xE2	; 226
    26f8:	9e 4c       	sbci	r25, 0xCE	; 206
    26fa:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
    26fe:	05 c0       	rjmp	.+10     	; 0x270a <xTaskRemoveFromEventList+0x60>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
<<<<<<< HEAD
    25b0:	b8 01       	movw	r22, r16
    25b2:	83 ec       	ldi	r24, 0xC3	; 195
    25b4:	90 e3       	ldi	r25, 0x30	; 48
    25b6:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    25ba:	e0 91 14 31 	lds	r30, 0x3114	; 0x803114 <pxCurrentTCB>
    25be:	f0 91 15 31 	lds	r31, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
=======
    2700:	b8 01       	movw	r22, r16
    2702:	89 ef       	ldi	r24, 0xF9	; 249
    2704:	90 e3       	ldi	r25, 0x30	; 48
    2706:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    270a:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    270e:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
<<<<<<< HEAD
    25c2:	81 e0       	ldi	r24, 0x01	; 1
    25c4:	2a 8d       	ldd	r18, Y+26	; 0x1a
    25c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    25c8:	29 17       	cp	r18, r25
    25ca:	08 f4       	brcc	.+2      	; 0x25ce <xTaskRemoveFromEventList+0x74>
    25cc:	80 e0       	ldi	r24, 0x00	; 0
}
    25ce:	df 91       	pop	r29
    25d0:	cf 91       	pop	r28
    25d2:	1f 91       	pop	r17
    25d4:	0f 91       	pop	r16
    25d6:	08 95       	ret

000025d8 <vTaskSetTimeOutState>:
=======
    2712:	81 e0       	ldi	r24, 0x01	; 1
    2714:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2716:	92 8d       	ldd	r25, Z+26	; 0x1a
    2718:	29 17       	cp	r18, r25
    271a:	08 f4       	brcc	.+2      	; 0x271e <xTaskRemoveFromEventList+0x74>
    271c:	80 e0       	ldi	r24, 0x00	; 0
}
    271e:	df 91       	pop	r29
    2720:	cf 91       	pop	r28
    2722:	1f 91       	pop	r17
    2724:	0f 91       	pop	r16
    2726:	08 95       	ret

00002728 <vTaskSetTimeOutState>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
<<<<<<< HEAD
    25d8:	20 91 b5 30 	lds	r18, 0x30B5	; 0x8030b5 <xNumOfOverflows>
    25dc:	fc 01       	movw	r30, r24
    25de:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    25e0:	40 91 bc 30 	lds	r20, 0x30BC	; 0x8030bc <xTickCount>
    25e4:	50 91 bd 30 	lds	r21, 0x30BD	; 0x8030bd <xTickCount+0x1>
    25e8:	60 91 be 30 	lds	r22, 0x30BE	; 0x8030be <xTickCount+0x2>
    25ec:	70 91 bf 30 	lds	r23, 0x30BF	; 0x8030bf <xTickCount+0x3>
    25f0:	41 83       	std	Z+1, r20	; 0x01
    25f2:	52 83       	std	Z+2, r21	; 0x02
    25f4:	63 83       	std	Z+3, r22	; 0x03
    25f6:	74 83       	std	Z+4, r23	; 0x04
    25f8:	08 95       	ret

000025fa <xTaskCheckForTimeOut>:
=======
    2728:	20 91 eb 30 	lds	r18, 0x30EB	; 0x8030eb <xNumOfOverflows>
    272c:	fc 01       	movw	r30, r24
    272e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2730:	40 91 f2 30 	lds	r20, 0x30F2	; 0x8030f2 <xTickCount>
    2734:	50 91 f3 30 	lds	r21, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    2738:	60 91 f4 30 	lds	r22, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    273c:	70 91 f5 30 	lds	r23, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2740:	41 83       	std	Z+1, r20	; 0x01
    2742:	52 83       	std	Z+2, r21	; 0x02
    2744:	63 83       	std	Z+3, r22	; 0x03
    2746:	74 83       	std	Z+4, r23	; 0x04
    2748:	08 95       	ret

0000274a <xTaskCheckForTimeOut>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
<<<<<<< HEAD
    25fa:	8f 92       	push	r8
    25fc:	9f 92       	push	r9
    25fe:	af 92       	push	r10
    2600:	bf 92       	push	r11
    2602:	cf 92       	push	r12
    2604:	df 92       	push	r13
    2606:	ef 92       	push	r14
    2608:	ff 92       	push	r15
    260a:	0f 93       	push	r16
    260c:	1f 93       	push	r17
    260e:	cf 93       	push	r28
    2610:	df 93       	push	r29
    2612:	fc 01       	movw	r30, r24
=======
    274a:	8f 92       	push	r8
    274c:	9f 92       	push	r9
    274e:	af 92       	push	r10
    2750:	bf 92       	push	r11
    2752:	cf 92       	push	r12
    2754:	df 92       	push	r13
    2756:	ef 92       	push	r14
    2758:	ff 92       	push	r15
    275a:	0f 93       	push	r16
    275c:	1f 93       	push	r17
    275e:	cf 93       	push	r28
    2760:	df 93       	push	r29
    2762:	fc 01       	movw	r30, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
<<<<<<< HEAD
    2614:	0f b6       	in	r0, 0x3f	; 63
    2616:	f8 94       	cli
    2618:	0f 92       	push	r0
=======
    2764:	0f b6       	in	r0, 0x3f	; 63
    2766:	f8 94       	cli
    2768:	0f 92       	push	r0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
<<<<<<< HEAD
    261a:	80 91 b5 30 	lds	r24, 0x30B5	; 0x8030b5 <xNumOfOverflows>
    261e:	90 81       	ld	r25, Z
    2620:	98 17       	cp	r25, r24
    2622:	89 f0       	breq	.+34     	; 0x2646 <xTaskCheckForTimeOut+0x4c>
    2624:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    2628:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    262c:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    2630:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
    2634:	01 81       	ldd	r16, Z+1	; 0x01
    2636:	12 81       	ldd	r17, Z+2	; 0x02
    2638:	23 81       	ldd	r18, Z+3	; 0x03
    263a:	34 81       	ldd	r19, Z+4	; 0x04
    263c:	80 17       	cp	r24, r16
    263e:	91 07       	cpc	r25, r17
    2640:	a2 07       	cpc	r26, r18
    2642:	b3 07       	cpc	r27, r19
    2644:	a8 f5       	brcc	.+106    	; 0x26b0 <xTaskCheckForTimeOut+0xb6>
=======
    276a:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <xNumOfOverflows>
    276e:	90 81       	ld	r25, Z
    2770:	98 17       	cp	r25, r24
    2772:	89 f0       	breq	.+34     	; 0x2796 <xTaskCheckForTimeOut+0x4c>
    2774:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    2778:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    277c:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    2780:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    2784:	01 81       	ldd	r16, Z+1	; 0x01
    2786:	12 81       	ldd	r17, Z+2	; 0x02
    2788:	23 81       	ldd	r18, Z+3	; 0x03
    278a:	34 81       	ldd	r19, Z+4	; 0x04
    278c:	80 17       	cp	r24, r16
    278e:	91 07       	cpc	r25, r17
    2790:	a2 07       	cpc	r26, r18
    2792:	b3 07       	cpc	r27, r19
    2794:	a8 f5       	brcc	.+106    	; 0x2800 <xTaskCheckForTimeOut+0xb6>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
<<<<<<< HEAD
    2646:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <xTickCount>
    264a:	90 91 bd 30 	lds	r25, 0x30BD	; 0x8030bd <xTickCount+0x1>
    264e:	a0 91 be 30 	lds	r26, 0x30BE	; 0x8030be <xTickCount+0x2>
    2652:	b0 91 bf 30 	lds	r27, 0x30BF	; 0x8030bf <xTickCount+0x3>
    2656:	c1 80       	ldd	r12, Z+1	; 0x01
    2658:	d2 80       	ldd	r13, Z+2	; 0x02
    265a:	e3 80       	ldd	r14, Z+3	; 0x03
    265c:	f4 80       	ldd	r15, Z+4	; 0x04
    265e:	eb 01       	movw	r28, r22
    2660:	08 81       	ld	r16, Y
    2662:	19 81       	ldd	r17, Y+1	; 0x01
    2664:	2a 81       	ldd	r18, Y+2	; 0x02
    2666:	3b 81       	ldd	r19, Y+3	; 0x03
    2668:	8c 19       	sub	r24, r12
    266a:	9d 09       	sbc	r25, r13
    266c:	ae 09       	sbc	r26, r14
    266e:	bf 09       	sbc	r27, r15
    2670:	80 17       	cp	r24, r16
    2672:	91 07       	cpc	r25, r17
    2674:	a2 07       	cpc	r26, r18
    2676:	b3 07       	cpc	r27, r19
    2678:	e8 f4       	brcc	.+58     	; 0x26b4 <xTaskCheckForTimeOut+0xba>
    267a:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    267c:	80 90 bc 30 	lds	r8, 0x30BC	; 0x8030bc <xTickCount>
    2680:	90 90 bd 30 	lds	r9, 0x30BD	; 0x8030bd <xTickCount+0x1>
    2684:	a0 90 be 30 	lds	r10, 0x30BE	; 0x8030be <xTickCount+0x2>
    2688:	b0 90 bf 30 	lds	r11, 0x30BF	; 0x8030bf <xTickCount+0x3>
    268c:	b5 01       	movw	r22, r10
    268e:	a4 01       	movw	r20, r8
    2690:	4c 19       	sub	r20, r12
    2692:	5d 09       	sbc	r21, r13
    2694:	6e 09       	sbc	r22, r14
    2696:	7f 09       	sbc	r23, r15
    2698:	04 1b       	sub	r16, r20
    269a:	15 0b       	sbc	r17, r21
    269c:	26 0b       	sbc	r18, r22
    269e:	37 0b       	sbc	r19, r23
    26a0:	08 83       	st	Y, r16
    26a2:	19 83       	std	Y+1, r17	; 0x01
    26a4:	2a 83       	std	Y+2, r18	; 0x02
    26a6:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    26a8:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    26ac:	80 e0       	ldi	r24, 0x00	; 0
    26ae:	03 c0       	rjmp	.+6      	; 0x26b6 <xTaskCheckForTimeOut+0xbc>
=======
    2796:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount>
    279a:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    279e:	a0 91 f4 30 	lds	r26, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    27a2:	b0 91 f5 30 	lds	r27, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    27a6:	c1 80       	ldd	r12, Z+1	; 0x01
    27a8:	d2 80       	ldd	r13, Z+2	; 0x02
    27aa:	e3 80       	ldd	r14, Z+3	; 0x03
    27ac:	f4 80       	ldd	r15, Z+4	; 0x04
    27ae:	eb 01       	movw	r28, r22
    27b0:	08 81       	ld	r16, Y
    27b2:	19 81       	ldd	r17, Y+1	; 0x01
    27b4:	2a 81       	ldd	r18, Y+2	; 0x02
    27b6:	3b 81       	ldd	r19, Y+3	; 0x03
    27b8:	8c 19       	sub	r24, r12
    27ba:	9d 09       	sbc	r25, r13
    27bc:	ae 09       	sbc	r26, r14
    27be:	bf 09       	sbc	r27, r15
    27c0:	80 17       	cp	r24, r16
    27c2:	91 07       	cpc	r25, r17
    27c4:	a2 07       	cpc	r26, r18
    27c6:	b3 07       	cpc	r27, r19
    27c8:	e8 f4       	brcc	.+58     	; 0x2804 <xTaskCheckForTimeOut+0xba>
    27ca:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    27cc:	80 90 f2 30 	lds	r8, 0x30F2	; 0x8030f2 <xTickCount>
    27d0:	90 90 f3 30 	lds	r9, 0x30F3	; 0x8030f3 <xTickCount+0x1>
    27d4:	a0 90 f4 30 	lds	r10, 0x30F4	; 0x8030f4 <xTickCount+0x2>
    27d8:	b0 90 f5 30 	lds	r11, 0x30F5	; 0x8030f5 <xTickCount+0x3>
    27dc:	b5 01       	movw	r22, r10
    27de:	a4 01       	movw	r20, r8
    27e0:	4c 19       	sub	r20, r12
    27e2:	5d 09       	sbc	r21, r13
    27e4:	6e 09       	sbc	r22, r14
    27e6:	7f 09       	sbc	r23, r15
    27e8:	04 1b       	sub	r16, r20
    27ea:	15 0b       	sbc	r17, r21
    27ec:	26 0b       	sbc	r18, r22
    27ee:	37 0b       	sbc	r19, r23
    27f0:	08 83       	st	Y, r16
    27f2:	19 83       	std	Y+1, r17	; 0x01
    27f4:	2a 83       	std	Y+2, r18	; 0x02
    27f6:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    27f8:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    27fc:	80 e0       	ldi	r24, 0x00	; 0
    27fe:	03 c0       	rjmp	.+6      	; 0x2806 <xTaskCheckForTimeOut+0xbc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
<<<<<<< HEAD
    26b0:	81 e0       	ldi	r24, 0x01	; 1
    26b2:	01 c0       	rjmp	.+2      	; 0x26b6 <xTaskCheckForTimeOut+0xbc>
=======
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	01 c0       	rjmp	.+2      	; 0x2806 <xTaskCheckForTimeOut+0xbc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
<<<<<<< HEAD
    26b4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    26b6:	0f 90       	pop	r0
    26b8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    26ba:	df 91       	pop	r29
    26bc:	cf 91       	pop	r28
    26be:	1f 91       	pop	r17
    26c0:	0f 91       	pop	r16
    26c2:	ff 90       	pop	r15
    26c4:	ef 90       	pop	r14
    26c6:	df 90       	pop	r13
    26c8:	cf 90       	pop	r12
    26ca:	bf 90       	pop	r11
    26cc:	af 90       	pop	r10
    26ce:	9f 90       	pop	r9
    26d0:	8f 90       	pop	r8
    26d2:	08 95       	ret

000026d4 <vTaskMissedYield>:
=======
    2804:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2806:	0f 90       	pop	r0
    2808:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    280a:	df 91       	pop	r29
    280c:	cf 91       	pop	r28
    280e:	1f 91       	pop	r17
    2810:	0f 91       	pop	r16
    2812:	ff 90       	pop	r15
    2814:	ef 90       	pop	r14
    2816:	df 90       	pop	r13
    2818:	cf 90       	pop	r12
    281a:	bf 90       	pop	r11
    281c:	af 90       	pop	r10
    281e:	9f 90       	pop	r9
    2820:	8f 90       	pop	r8
    2822:	08 95       	ret

00002824 <vTaskMissedYield>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
<<<<<<< HEAD
    26d4:	81 e0       	ldi	r24, 0x01	; 1
    26d6:	80 93 b6 30 	sts	0x30B6, r24	; 0x8030b6 <xMissedYield>
    26da:	08 95       	ret

000026dc <uxTaskGetStackHighWaterMark>:
=======
    2824:	81 e0       	ldi	r24, 0x01	; 1
    2826:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <xMissedYield>
    282a:	08 95       	ret

0000282c <uxTaskGetStackHighWaterMark>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
<<<<<<< HEAD
    26dc:	00 97       	sbiw	r24, 0x00	; 0
    26de:	21 f4       	brne	.+8      	; 0x26e8 <uxTaskGetStackHighWaterMark+0xc>
    26e0:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxCurrentTCB>
    26e4:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
=======
    282c:	00 97       	sbiw	r24, 0x00	; 0
    282e:	21 f4       	brne	.+8      	; 0x2838 <uxTaskGetStackHighWaterMark+0xc>
    2830:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    2834:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
<<<<<<< HEAD
    26e8:	dc 01       	movw	r26, r24
    26ea:	5b 96       	adiw	r26, 0x1b	; 27
    26ec:	ed 91       	ld	r30, X+
    26ee:	fc 91       	ld	r31, X
    26f0:	5c 97       	sbiw	r26, 0x1c	; 28
=======
    2838:	dc 01       	movw	r26, r24
    283a:	5b 96       	adiw	r26, 0x1b	; 27
    283c:	ed 91       	ld	r30, X+
    283e:	fc 91       	ld	r31, X
    2840:	5c 97       	sbiw	r26, 0x1c	; 28
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
<<<<<<< HEAD
    26f2:	80 81       	ld	r24, Z
    26f4:	81 31       	cpi	r24, 0x11	; 17
    26f6:	41 f4       	brne	.+16     	; 0x2708 <uxTaskGetStackHighWaterMark+0x2c>
    26f8:	31 96       	adiw	r30, 0x01	; 1
    26fa:	80 e0       	ldi	r24, 0x00	; 0
    26fc:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    26fe:	01 96       	adiw	r24, 0x01	; 1
=======
    2842:	80 81       	ld	r24, Z
    2844:	81 31       	cpi	r24, 0x11	; 17
    2846:	41 f4       	brne	.+16     	; 0x2858 <uxTaskGetStackHighWaterMark+0x2c>
    2848:	31 96       	adiw	r30, 0x01	; 1
    284a:	80 e0       	ldi	r24, 0x00	; 0
    284c:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    284e:	01 96       	adiw	r24, 0x01	; 1
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
<<<<<<< HEAD
    2700:	21 91       	ld	r18, Z+
    2702:	21 31       	cpi	r18, 0x11	; 17
    2704:	e1 f3       	breq	.-8      	; 0x26fe <uxTaskGetStackHighWaterMark+0x22>
    2706:	08 95       	ret
=======
    2850:	21 91       	ld	r18, Z+
    2852:	21 31       	cpi	r18, 0x11	; 17
    2854:	e1 f3       	breq	.-8      	; 0x284e <uxTaskGetStackHighWaterMark+0x22>
    2856:	08 95       	ret
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
<<<<<<< HEAD
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	90 e0       	ldi	r25, 0x00	; 0
=======
    2858:	80 e0       	ldi	r24, 0x00	; 0
    285a:	90 e0       	ldi	r25, 0x00	; 0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
<<<<<<< HEAD
    270c:	08 95       	ret

0000270e <xTaskGetCurrentTaskHandle>:
=======
    285c:	08 95       	ret

0000285e <xTaskGetCurrentTaskHandle>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
<<<<<<< HEAD
    270e:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxCurrentTCB>
    2712:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2716:	08 95       	ret

00002718 <vTaskPriorityInherit>:
=======
    285e:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <pxCurrentTCB>
    2862:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <pxCurrentTCB+0x1>

		return xReturn;
	}
    2866:	08 95       	ret

00002868 <vTaskPriorityInherit>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
<<<<<<< HEAD
    2718:	0f 93       	push	r16
    271a:	1f 93       	push	r17
    271c:	cf 93       	push	r28
    271e:	df 93       	push	r29
    2720:	fc 01       	movw	r30, r24
=======
    2868:	0f 93       	push	r16
    286a:	1f 93       	push	r17
    286c:	cf 93       	push	r28
    286e:	df 93       	push	r29
    2870:	fc 01       	movw	r30, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
<<<<<<< HEAD
    2722:	22 8d       	ldd	r18, Z+26	; 0x1a
    2724:	a0 91 14 31 	lds	r26, 0x3114	; 0x803114 <pxCurrentTCB>
    2728:	b0 91 15 31 	lds	r27, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    272c:	5a 96       	adiw	r26, 0x1a	; 26
    272e:	8c 91       	ld	r24, X
    2730:	28 17       	cp	r18, r24
    2732:	08 f0       	brcs	.+2      	; 0x2736 <vTaskPriorityInherit+0x1e>
    2734:	41 c0       	rjmp	.+130    	; 0x27b8 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2736:	a0 91 14 31 	lds	r26, 0x3114	; 0x803114 <pxCurrentTCB>
    273a:	b0 91 15 31 	lds	r27, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    273e:	5a 96       	adiw	r26, 0x1a	; 26
    2740:	3c 91       	ld	r19, X
    2742:	84 e0       	ldi	r24, 0x04	; 4
    2744:	90 e0       	ldi	r25, 0x00	; 0
    2746:	a0 e0       	ldi	r26, 0x00	; 0
    2748:	b0 e0       	ldi	r27, 0x00	; 0
    274a:	83 1b       	sub	r24, r19
    274c:	91 09       	sbc	r25, r1
    274e:	a1 09       	sbc	r26, r1
    2750:	b1 09       	sbc	r27, r1
    2752:	86 87       	std	Z+14, r24	; 0x0e
    2754:	97 87       	std	Z+15, r25	; 0x0f
    2756:	a0 8b       	std	Z+16, r26	; 0x10
    2758:	b1 8b       	std	Z+17, r27	; 0x11
=======
    2872:	22 8d       	ldd	r18, Z+26	; 0x1a
    2874:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    2878:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    287c:	5a 96       	adiw	r26, 0x1a	; 26
    287e:	8c 91       	ld	r24, X
    2880:	28 17       	cp	r18, r24
    2882:	08 f0       	brcs	.+2      	; 0x2886 <vTaskPriorityInherit+0x1e>
    2884:	41 c0       	rjmp	.+130    	; 0x2908 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2886:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    288a:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    288e:	5a 96       	adiw	r26, 0x1a	; 26
    2890:	3c 91       	ld	r19, X
    2892:	84 e0       	ldi	r24, 0x04	; 4
    2894:	90 e0       	ldi	r25, 0x00	; 0
    2896:	a0 e0       	ldi	r26, 0x00	; 0
    2898:	b0 e0       	ldi	r27, 0x00	; 0
    289a:	83 1b       	sub	r24, r19
    289c:	91 09       	sbc	r25, r1
    289e:	a1 09       	sbc	r26, r1
    28a0:	b1 09       	sbc	r27, r1
    28a2:	86 87       	std	Z+14, r24	; 0x0e
    28a4:	97 87       	std	Z+15, r25	; 0x0f
    28a6:	a0 8b       	std	Z+16, r26	; 0x10
    28a8:	b1 8b       	std	Z+17, r27	; 0x11
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
<<<<<<< HEAD
    275a:	8b e0       	ldi	r24, 0x0B	; 11
    275c:	28 9f       	mul	r18, r24
    275e:	90 01       	movw	r18, r0
    2760:	11 24       	eor	r1, r1
    2762:	28 51       	subi	r18, 0x18	; 24
    2764:	3f 4c       	sbci	r19, 0xCF	; 207
    2766:	84 85       	ldd	r24, Z+12	; 0x0c
    2768:	95 85       	ldd	r25, Z+13	; 0x0d
    276a:	82 17       	cp	r24, r18
    276c:	93 07       	cpc	r25, r19
    276e:	e9 f4       	brne	.+58     	; 0x27aa <vTaskPriorityInherit+0x92>
    2770:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2772:	ef 01       	movw	r28, r30
    2774:	22 96       	adiw	r28, 0x02	; 2
    2776:	ce 01       	movw	r24, r28
    2778:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    277c:	e0 91 14 31 	lds	r30, 0x3114	; 0x803114 <pxCurrentTCB>
    2780:	f0 91 15 31 	lds	r31, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    2784:	82 8d       	ldd	r24, Z+26	; 0x1a
    2786:	f8 01       	movw	r30, r16
    2788:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    278a:	90 91 ba 30 	lds	r25, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    278e:	98 17       	cp	r25, r24
    2790:	10 f4       	brcc	.+4      	; 0x2796 <vTaskPriorityInherit+0x7e>
    2792:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <uxTopReadyPriority>
    2796:	fb e0       	ldi	r31, 0x0B	; 11
    2798:	8f 9f       	mul	r24, r31
    279a:	c0 01       	movw	r24, r0
    279c:	11 24       	eor	r1, r1
    279e:	be 01       	movw	r22, r28
    27a0:	88 51       	subi	r24, 0x18	; 24
    27a2:	9f 4c       	sbci	r25, 0xCF	; 207
    27a4:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsertEnd>
    27a8:	07 c0       	rjmp	.+14     	; 0x27b8 <vTaskPriorityInherit+0xa0>
=======
    28aa:	8b e0       	ldi	r24, 0x0B	; 11
    28ac:	28 9f       	mul	r18, r24
    28ae:	90 01       	movw	r18, r0
    28b0:	11 24       	eor	r1, r1
    28b2:	22 5e       	subi	r18, 0xE2	; 226
    28b4:	3e 4c       	sbci	r19, 0xCE	; 206
    28b6:	84 85       	ldd	r24, Z+12	; 0x0c
    28b8:	95 85       	ldd	r25, Z+13	; 0x0d
    28ba:	82 17       	cp	r24, r18
    28bc:	93 07       	cpc	r25, r19
    28be:	e9 f4       	brne	.+58     	; 0x28fa <vTaskPriorityInherit+0x92>
    28c0:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    28c2:	ef 01       	movw	r28, r30
    28c4:	22 96       	adiw	r28, 0x02	; 2
    28c6:	ce 01       	movw	r24, r28
    28c8:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    28cc:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <pxCurrentTCB>
    28d0:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    28d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    28d6:	f8 01       	movw	r30, r16
    28d8:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    28da:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    28de:	98 17       	cp	r25, r24
    28e0:	10 f4       	brcc	.+4      	; 0x28e6 <vTaskPriorityInherit+0x7e>
    28e2:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    28e6:	fb e0       	ldi	r31, 0x0B	; 11
    28e8:	8f 9f       	mul	r24, r31
    28ea:	c0 01       	movw	r24, r0
    28ec:	11 24       	eor	r1, r1
    28ee:	be 01       	movw	r22, r28
    28f0:	82 5e       	subi	r24, 0xE2	; 226
    28f2:	9e 4c       	sbci	r25, 0xCE	; 206
    28f4:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
    28f8:	07 c0       	rjmp	.+14     	; 0x2908 <vTaskPriorityInherit+0xa0>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
<<<<<<< HEAD
    27aa:	a0 91 14 31 	lds	r26, 0x3114	; 0x803114 <pxCurrentTCB>
    27ae:	b0 91 15 31 	lds	r27, 0x3115	; 0x803115 <pxCurrentTCB+0x1>
    27b2:	5a 96       	adiw	r26, 0x1a	; 26
    27b4:	8c 91       	ld	r24, X
    27b6:	82 8f       	std	Z+26, r24	; 0x1a
=======
    28fa:	a0 91 4a 31 	lds	r26, 0x314A	; 0x80314a <pxCurrentTCB>
    28fe:	b0 91 4b 31 	lds	r27, 0x314B	; 0x80314b <pxCurrentTCB+0x1>
    2902:	5a 96       	adiw	r26, 0x1a	; 26
    2904:	8c 91       	ld	r24, X
    2906:	82 8f       	std	Z+26, r24	; 0x1a
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
<<<<<<< HEAD
    27b8:	df 91       	pop	r29
    27ba:	cf 91       	pop	r28
    27bc:	1f 91       	pop	r17
    27be:	0f 91       	pop	r16
    27c0:	08 95       	ret

000027c2 <vTaskPriorityDisinherit>:
=======
    2908:	df 91       	pop	r29
    290a:	cf 91       	pop	r28
    290c:	1f 91       	pop	r17
    290e:	0f 91       	pop	r16
    2910:	08 95       	ret

00002912 <vTaskPriorityDisinherit>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
<<<<<<< HEAD
    27c2:	0f 93       	push	r16
    27c4:	1f 93       	push	r17
    27c6:	cf 93       	push	r28
    27c8:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    27ca:	00 97       	sbiw	r24, 0x00	; 0
    27cc:	49 f1       	breq	.+82     	; 0x2820 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    27ce:	fc 01       	movw	r30, r24
    27d0:	32 8d       	ldd	r19, Z+26	; 0x1a
    27d2:	27 a1       	ldd	r18, Z+39	; 0x27
    27d4:	32 17       	cp	r19, r18
    27d6:	21 f1       	breq	.+72     	; 0x2820 <vTaskPriorityDisinherit+0x5e>
    27d8:	ec 01       	movw	r28, r24
=======
    2912:	0f 93       	push	r16
    2914:	1f 93       	push	r17
    2916:	cf 93       	push	r28
    2918:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    291a:	00 97       	sbiw	r24, 0x00	; 0
    291c:	49 f1       	breq	.+82     	; 0x2970 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    291e:	fc 01       	movw	r30, r24
    2920:	32 8d       	ldd	r19, Z+26	; 0x1a
    2922:	27 a1       	ldd	r18, Z+39	; 0x27
    2924:	32 17       	cp	r19, r18
    2926:	21 f1       	breq	.+72     	; 0x2970 <vTaskPriorityDisinherit+0x5e>
    2928:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
<<<<<<< HEAD
    27da:	8c 01       	movw	r16, r24
    27dc:	0e 5f       	subi	r16, 0xFE	; 254
    27de:	1f 4f       	sbci	r17, 0xFF	; 255
    27e0:	c8 01       	movw	r24, r16
    27e2:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vListRemove>
=======
    292a:	8c 01       	movw	r16, r24
    292c:	0e 5f       	subi	r16, 0xFE	; 254
    292e:	1f 4f       	sbci	r17, 0xFF	; 255
    2930:	c8 01       	movw	r24, r16
    2932:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <vListRemove>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
<<<<<<< HEAD
    27e6:	8f a1       	ldd	r24, Y+39	; 0x27
    27e8:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    27ea:	44 e0       	ldi	r20, 0x04	; 4
    27ec:	50 e0       	ldi	r21, 0x00	; 0
    27ee:	60 e0       	ldi	r22, 0x00	; 0
    27f0:	70 e0       	ldi	r23, 0x00	; 0
    27f2:	48 1b       	sub	r20, r24
    27f4:	51 09       	sbc	r21, r1
    27f6:	61 09       	sbc	r22, r1
    27f8:	71 09       	sbc	r23, r1
    27fa:	4e 87       	std	Y+14, r20	; 0x0e
    27fc:	5f 87       	std	Y+15, r21	; 0x0f
    27fe:	68 8b       	std	Y+16, r22	; 0x10
    2800:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2802:	90 91 ba 30 	lds	r25, 0x30BA	; 0x8030ba <uxTopReadyPriority>
    2806:	98 17       	cp	r25, r24
    2808:	10 f4       	brcc	.+4      	; 0x280e <vTaskPriorityDisinherit+0x4c>
    280a:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <uxTopReadyPriority>
    280e:	fb e0       	ldi	r31, 0x0B	; 11
    2810:	8f 9f       	mul	r24, r31
    2812:	c0 01       	movw	r24, r0
    2814:	11 24       	eor	r1, r1
    2816:	b8 01       	movw	r22, r16
    2818:	88 51       	subi	r24, 0x18	; 24
    281a:	9f 4c       	sbci	r25, 0xCF	; 207
    281c:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListInsertEnd>
			}
		}
	}
    2820:	df 91       	pop	r29
    2822:	cf 91       	pop	r28
    2824:	1f 91       	pop	r17
    2826:	0f 91       	pop	r16
    2828:	08 95       	ret

0000282a <_ZN8frt_task22_call_users_run_methodEPS_>:
=======
    2936:	8f a1       	ldd	r24, Y+39	; 0x27
    2938:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    293a:	44 e0       	ldi	r20, 0x04	; 4
    293c:	50 e0       	ldi	r21, 0x00	; 0
    293e:	60 e0       	ldi	r22, 0x00	; 0
    2940:	70 e0       	ldi	r23, 0x00	; 0
    2942:	48 1b       	sub	r20, r24
    2944:	51 09       	sbc	r21, r1
    2946:	61 09       	sbc	r22, r1
    2948:	71 09       	sbc	r23, r1
    294a:	4e 87       	std	Y+14, r20	; 0x0e
    294c:	5f 87       	std	Y+15, r21	; 0x0f
    294e:	68 8b       	std	Y+16, r22	; 0x10
    2950:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2952:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTopReadyPriority>
    2956:	98 17       	cp	r25, r24
    2958:	10 f4       	brcc	.+4      	; 0x295e <vTaskPriorityDisinherit+0x4c>
    295a:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <uxTopReadyPriority>
    295e:	fb e0       	ldi	r31, 0x0B	; 11
    2960:	8f 9f       	mul	r24, r31
    2962:	c0 01       	movw	r24, r0
    2964:	11 24       	eor	r1, r1
    2966:	b8 01       	movw	r22, r16
    2968:	82 5e       	subi	r24, 0xE2	; 226
    296a:	9e 4c       	sbci	r25, 0xCE	; 206
    296c:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vListInsertEnd>
			}
		}
	}
    2970:	df 91       	pop	r29
    2972:	cf 91       	pop	r28
    2974:	1f 91       	pop	r17
    2976:	0f 91       	pop	r16
    2978:	08 95       	ret

0000297a <_ZN8frt_task22_call_users_run_methodEPS_>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
<<<<<<< HEAD
    282a:	ec 01       	movw	r28, r24
=======
    297a:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
<<<<<<< HEAD
    282c:	e8 81       	ld	r30, Y
    282e:	f9 81       	ldd	r31, Y+1	; 0x01
    2830:	01 90       	ld	r0, Z+
    2832:	f0 81       	ld	r31, Z
    2834:	e0 2d       	mov	r30, r0
    2836:	19 95       	eicall
=======
    297c:	e8 81       	ld	r30, Y
    297e:	f9 81       	ldd	r31, Y+1	; 0x01
    2980:	01 90       	ld	r0, Z+
    2982:	f0 81       	ld	r31, Z
    2984:	e0 2d       	mov	r30, r0
    2986:	19 95       	eicall
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
<<<<<<< HEAD
    2838:	1a 82       	std	Y+2, r1	; 0x02
    283a:	1b 82       	std	Y+3, r1	; 0x03
=======
    2988:	1a 82       	std	Y+2, r1	; 0x02
    298a:	1b 82       	std	Y+3, r1	; 0x03
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
<<<<<<< HEAD
    283c:	6f ef       	ldi	r22, 0xFF	; 255
    283e:	7f ef       	ldi	r23, 0xFF	; 255
    2840:	cb 01       	movw	r24, r22
    2842:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskDelay>
    2846:	fa cf       	rjmp	.-12     	; 0x283c <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002848 <_ZN8frt_task13transition_toEh>:
=======
    298c:	6f ef       	ldi	r22, 0xFF	; 255
    298e:	7f ef       	ldi	r23, 0xFF	; 255
    2990:	cb 01       	movw	r24, r22
    2992:	0e 94 a0 12 	call	0x2540	; 0x2540 <vTaskDelay>
    2996:	fa cf       	rjmp	.-12     	; 0x298c <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002998 <_ZN8frt_task13transition_toEh>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
<<<<<<< HEAD
    2848:	fc 01       	movw	r30, r24
    284a:	64 87       	std	Z+12, r22	; 0x0c
=======
    2998:	fc 01       	movw	r30, r24
    299a:	64 87       	std	Z+12, r22	; 0x0c
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
<<<<<<< HEAD
    284c:	65 87       	std	Z+13, r22	; 0x0d
    284e:	08 95       	ret

00002850 <_ZN8frt_taskC1EPKchjP8emstream>:
=======
    299c:	65 87       	std	Z+13, r22	; 0x0d
    299e:	08 95       	ret

000029a0 <_ZN8frt_taskC1EPKchjP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
<<<<<<< HEAD
    2850:	4f 92       	push	r4
    2852:	5f 92       	push	r5
    2854:	6f 92       	push	r6
    2856:	7f 92       	push	r7
    2858:	8f 92       	push	r8
    285a:	9f 92       	push	r9
    285c:	af 92       	push	r10
    285e:	bf 92       	push	r11
    2860:	cf 92       	push	r12
    2862:	df 92       	push	r13
    2864:	ef 92       	push	r14
    2866:	ff 92       	push	r15
    2868:	0f 93       	push	r16
    286a:	1f 93       	push	r17
    286c:	cf 93       	push	r28
    286e:	df 93       	push	r29
    2870:	cd b7       	in	r28, 0x3d	; 61
    2872:	de b7       	in	r29, 0x3e	; 62
    2874:	2a 97       	sbiw	r28, 0x0a	; 10
    2876:	cd bf       	out	0x3d, r28	; 61
    2878:	de bf       	out	0x3e, r29	; 62
    287a:	4c 01       	movw	r8, r24
    287c:	29 01       	movw	r4, r18
    287e:	38 01       	movw	r6, r16
=======
    29a0:	4f 92       	push	r4
    29a2:	5f 92       	push	r5
    29a4:	6f 92       	push	r6
    29a6:	7f 92       	push	r7
    29a8:	8f 92       	push	r8
    29aa:	9f 92       	push	r9
    29ac:	af 92       	push	r10
    29ae:	bf 92       	push	r11
    29b0:	cf 92       	push	r12
    29b2:	df 92       	push	r13
    29b4:	ef 92       	push	r14
    29b6:	ff 92       	push	r15
    29b8:	0f 93       	push	r16
    29ba:	1f 93       	push	r17
    29bc:	cf 93       	push	r28
    29be:	df 93       	push	r29
    29c0:	cd b7       	in	r28, 0x3d	; 61
    29c2:	de b7       	in	r29, 0x3e	; 62
    29c4:	2a 97       	sbiw	r28, 0x0a	; 10
    29c6:	cd bf       	out	0x3d, r28	; 61
    29c8:	de bf       	out	0x3e, r29	; 62
    29ca:	4c 01       	movw	r8, r24
    29cc:	29 01       	movw	r4, r18
    29ce:	38 01       	movw	r6, r16
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
<<<<<<< HEAD
    2880:	87 e3       	ldi	r24, 0x37	; 55
    2882:	90 e2       	ldi	r25, 0x20	; 32
    2884:	f4 01       	movw	r30, r8
    2886:	80 83       	st	Z, r24
    2888:	91 83       	std	Z+1, r25	; 0x01
=======
    29d0:	85 e6       	ldi	r24, 0x65	; 101
    29d2:	90 e2       	ldi	r25, 0x20	; 32
    29d4:	f4 01       	movw	r30, r8
    29d6:	80 83       	st	Z, r24
    29d8:	91 83       	std	Z+1, r25	; 0x01
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
<<<<<<< HEAD
    288a:	fb 01       	movw	r30, r22
    288c:	80 81       	ld	r24, Z
    288e:	88 23       	and	r24, r24
    2890:	69 f0       	breq	.+26     	; 0x28ac <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2892:	de 01       	movw	r26, r28
    2894:	11 96       	adiw	r26, 0x01	; 1
    2896:	31 96       	adiw	r30, 0x01	; 1
    2898:	90 e0       	ldi	r25, 0x00	; 0
    289a:	02 c0       	rjmp	.+4      	; 0x28a0 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    289c:	99 30       	cpi	r25, 0x09	; 9
    289e:	39 f0       	breq	.+14     	; 0x28ae <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    28a0:	9f 5f       	subi	r25, 0xFF	; 255
    28a2:	8d 93       	st	X+, r24
=======
    29da:	fb 01       	movw	r30, r22
    29dc:	80 81       	ld	r24, Z
    29de:	88 23       	and	r24, r24
    29e0:	69 f0       	breq	.+26     	; 0x29fc <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    29e2:	de 01       	movw	r26, r28
    29e4:	11 96       	adiw	r26, 0x01	; 1
    29e6:	31 96       	adiw	r30, 0x01	; 1
    29e8:	90 e0       	ldi	r25, 0x00	; 0
    29ea:	02 c0       	rjmp	.+4      	; 0x29f0 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    29ec:	99 30       	cpi	r25, 0x09	; 9
    29ee:	39 f0       	breq	.+14     	; 0x29fe <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    29f0:	9f 5f       	subi	r25, 0xFF	; 255
    29f2:	8d 93       	st	X+, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
<<<<<<< HEAD
    28a4:	81 91       	ld	r24, Z+
    28a6:	81 11       	cpse	r24, r1
    28a8:	f9 cf       	rjmp	.-14     	; 0x289c <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    28aa:	01 c0       	rjmp	.+2      	; 0x28ae <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
=======
    29f4:	81 91       	ld	r24, Z+
    29f6:	81 11       	cpse	r24, r1
    29f8:	f9 cf       	rjmp	.-14     	; 0x29ec <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    29fa:	01 c0       	rjmp	.+2      	; 0x29fe <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
<<<<<<< HEAD
    28ac:	90 e0       	ldi	r25, 0x00	; 0
=======
    29fc:	90 e0       	ldi	r25, 0x00	; 0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
<<<<<<< HEAD
    28ae:	e1 e0       	ldi	r30, 0x01	; 1
    28b0:	f0 e0       	ldi	r31, 0x00	; 0
    28b2:	ec 0f       	add	r30, r28
    28b4:	fd 1f       	adc	r31, r29
    28b6:	e9 0f       	add	r30, r25
    28b8:	f1 1d       	adc	r31, r1
    28ba:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    28bc:	74 01       	movw	r14, r8
    28be:	f2 e0       	ldi	r31, 0x02	; 2
    28c0:	ef 0e       	add	r14, r31
    28c2:	f1 1c       	adc	r15, r1
    28c4:	a1 2c       	mov	r10, r1
    28c6:	b1 2c       	mov	r11, r1
    28c8:	c1 2c       	mov	r12, r1
    28ca:	d1 2c       	mov	r13, r1
    28cc:	04 2f       	mov	r16, r20
    28ce:	94 01       	movw	r18, r8
    28d0:	a2 01       	movw	r20, r4
    28d2:	be 01       	movw	r22, r28
    28d4:	6f 5f       	subi	r22, 0xFF	; 255
    28d6:	7f 4f       	sbci	r23, 0xFF	; 255
    28d8:	84 ea       	ldi	r24, 0xA4	; 164
    28da:	92 e0       	ldi	r25, 0x02	; 2
    28dc:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <xTaskGenericCreate>
=======
    29fe:	e1 e0       	ldi	r30, 0x01	; 1
    2a00:	f0 e0       	ldi	r31, 0x00	; 0
    2a02:	ec 0f       	add	r30, r28
    2a04:	fd 1f       	adc	r31, r29
    2a06:	e9 0f       	add	r30, r25
    2a08:	f1 1d       	adc	r31, r1
    2a0a:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2a0c:	74 01       	movw	r14, r8
    2a0e:	f2 e0       	ldi	r31, 0x02	; 2
    2a10:	ef 0e       	add	r14, r31
    2a12:	f1 1c       	adc	r15, r1
    2a14:	a1 2c       	mov	r10, r1
    2a16:	b1 2c       	mov	r11, r1
    2a18:	c1 2c       	mov	r12, r1
    2a1a:	d1 2c       	mov	r13, r1
    2a1c:	04 2f       	mov	r16, r20
    2a1e:	94 01       	movw	r18, r8
    2a20:	a2 01       	movw	r20, r4
    2a22:	be 01       	movw	r22, r28
    2a24:	6f 5f       	subi	r22, 0xFF	; 255
    2a26:	7f 4f       	sbci	r23, 0xFF	; 255
    2a28:	86 ea       	ldi	r24, 0xA6	; 166
    2a2a:	92 e0       	ldi	r25, 0x02	; 2
    2a2c:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <xTaskGenericCreate>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
<<<<<<< HEAD
    28e0:	f4 01       	movw	r30, r8
    28e2:	66 82       	std	Z+6, r6	; 0x06
    28e4:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    28e6:	40 86       	std	Z+8, r4	; 0x08
    28e8:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    28ea:	20 91 16 31 	lds	r18, 0x3116	; 0x803116 <last_created_task_pointer>
    28ee:	30 91 17 31 	lds	r19, 0x3117	; 0x803117 <last_created_task_pointer+0x1>
    28f2:	24 83       	std	Z+4, r18	; 0x04
    28f4:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    28f6:	80 92 16 31 	sts	0x3116, r8	; 0x803116 <last_created_task_pointer>
    28fa:	90 92 17 31 	sts	0x3117, r9	; 0x803117 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    28fe:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2900:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2902:	40 90 4e 31 	lds	r4, 0x314E	; 0x80314e <portStackTopForTask>
    2906:	50 90 4f 31 	lds	r5, 0x314F	; 0x80314f <portStackTopForTask+0x1>
    290a:	ff ef       	ldi	r31, 0xFF	; 255
    290c:	4f 1a       	sub	r4, r31
    290e:	5f 0a       	sbc	r5, r31
    2910:	40 92 4e 31 	sts	0x314E, r4	; 0x80314e <portStackTopForTask>
    2914:	50 92 4f 31 	sts	0x314F, r5	; 0x80314f <portStackTopForTask+0x1>
    2918:	f4 01       	movw	r30, r8
    291a:	42 86       	std	Z+10, r4	; 0x0a
    291c:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    291e:	16 86       	std	Z+14, r1	; 0x0e
    2920:	17 86       	std	Z+15, r1	; 0x0f
    2922:	10 8a       	std	Z+16, r1	; 0x10
    2924:	11 8a       	std	Z+17, r1	; 0x11
=======
    2a30:	f4 01       	movw	r30, r8
    2a32:	66 82       	std	Z+6, r6	; 0x06
    2a34:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2a36:	40 86       	std	Z+8, r4	; 0x08
    2a38:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2a3a:	20 91 4c 31 	lds	r18, 0x314C	; 0x80314c <last_created_task_pointer>
    2a3e:	30 91 4d 31 	lds	r19, 0x314D	; 0x80314d <last_created_task_pointer+0x1>
    2a42:	24 83       	std	Z+4, r18	; 0x04
    2a44:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2a46:	80 92 4c 31 	sts	0x314C, r8	; 0x80314c <last_created_task_pointer>
    2a4a:	90 92 4d 31 	sts	0x314D, r9	; 0x80314d <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2a4e:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2a50:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2a52:	40 90 86 31 	lds	r4, 0x3186	; 0x803186 <portStackTopForTask>
    2a56:	50 90 87 31 	lds	r5, 0x3187	; 0x803187 <portStackTopForTask+0x1>
    2a5a:	ff ef       	ldi	r31, 0xFF	; 255
    2a5c:	4f 1a       	sub	r4, r31
    2a5e:	5f 0a       	sbc	r5, r31
    2a60:	40 92 86 31 	sts	0x3186, r4	; 0x803186 <portStackTopForTask>
    2a64:	50 92 87 31 	sts	0x3187, r5	; 0x803187 <portStackTopForTask+0x1>
    2a68:	f4 01       	movw	r30, r8
    2a6a:	42 86       	std	Z+10, r4	; 0x0a
    2a6c:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2a6e:	16 86       	std	Z+14, r1	; 0x0e
    2a70:	17 86       	std	Z+15, r1	; 0x0f
    2a72:	10 8a       	std	Z+16, r1	; 0x10
    2a74:	11 8a       	std	Z+17, r1	; 0x11
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
<<<<<<< HEAD
    2926:	61 14       	cp	r6, r1
    2928:	71 04       	cpc	r7, r1
    292a:	09 f4       	brne	.+2      	; 0x292e <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    292c:	44 c0       	rjmp	.+136    	; 0x29b6 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    292e:	81 30       	cpi	r24, 0x01	; 1
    2930:	79 f5       	brne	.+94     	; 0x2990 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2932:	6a e0       	ldi	r22, 0x0A	; 10
    2934:	c3 01       	movw	r24, r6
    2936:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    293a:	7c 01       	movw	r14, r24
    293c:	65 e9       	ldi	r22, 0x95	; 149
    293e:	74 e0       	ldi	r23, 0x04	; 4
    2940:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2944:	be 01       	movw	r22, r28
    2946:	6f 5f       	subi	r22, 0xFF	; 255
    2948:	7f 4f       	sbci	r23, 0xFF	; 255
    294a:	c7 01       	movw	r24, r14
    294c:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2950:	6a e0       	ldi	r22, 0x0A	; 10
    2952:	c7 01       	movw	r24, r14
    2954:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2958:	7c 01       	movw	r14, r24
    295a:	6c e8       	ldi	r22, 0x8C	; 140
    295c:	74 e0       	ldi	r23, 0x04	; 4
    295e:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2962:	6a e0       	ldi	r22, 0x0A	; 10
    2964:	c7 01       	movw	r24, r14
    2966:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    296a:	7c 01       	movw	r14, r24
    296c:	6e e7       	ldi	r22, 0x7E	; 126
    296e:	74 e0       	ldi	r23, 0x04	; 4
    2970:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2974:	63 e0       	ldi	r22, 0x03	; 3
    2976:	c7 01       	movw	r24, r14
    2978:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    297c:	b2 01       	movw	r22, r4
    297e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsEj>
    2982:	62 e0       	ldi	r22, 0x02	; 2
    2984:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2988:	66 e0       	ldi	r22, 0x06	; 6
    298a:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    298e:	13 c0       	rjmp	.+38     	; 0x29b6 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
=======
    2a76:	61 14       	cp	r6, r1
    2a78:	71 04       	cpc	r7, r1
    2a7a:	09 f4       	brne	.+2      	; 0x2a7e <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a7c:	44 c0       	rjmp	.+136    	; 0x2b06 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a7e:	81 30       	cpi	r24, 0x01	; 1
    2a80:	79 f5       	brne	.+94     	; 0x2ae0 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a82:	6a e0       	ldi	r22, 0x0A	; 10
    2a84:	c3 01       	movw	r24, r6
    2a86:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2a8a:	7c 01       	movw	r14, r24
    2a8c:	69 e9       	ldi	r22, 0x99	; 153
    2a8e:	74 e0       	ldi	r23, 0x04	; 4
    2a90:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2a94:	be 01       	movw	r22, r28
    2a96:	6f 5f       	subi	r22, 0xFF	; 255
    2a98:	7f 4f       	sbci	r23, 0xFF	; 255
    2a9a:	c7 01       	movw	r24, r14
    2a9c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2aa0:	6a e0       	ldi	r22, 0x0A	; 10
    2aa2:	c7 01       	movw	r24, r14
    2aa4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2aa8:	7c 01       	movw	r14, r24
    2aaa:	60 e9       	ldi	r22, 0x90	; 144
    2aac:	74 e0       	ldi	r23, 0x04	; 4
    2aae:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2ab2:	6a e0       	ldi	r22, 0x0A	; 10
    2ab4:	c7 01       	movw	r24, r14
    2ab6:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2aba:	7c 01       	movw	r14, r24
    2abc:	62 e8       	ldi	r22, 0x82	; 130
    2abe:	74 e0       	ldi	r23, 0x04	; 4
    2ac0:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2ac4:	63 e0       	ldi	r22, 0x03	; 3
    2ac6:	c7 01       	movw	r24, r14
    2ac8:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2acc:	b2 01       	movw	r22, r4
    2ace:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    2ad2:	62 e0       	ldi	r22, 0x02	; 2
    2ad4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ad8:	66 e0       	ldi	r22, 0x06	; 6
    2ada:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ade:	13 c0       	rjmp	.+38     	; 0x2b06 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
<<<<<<< HEAD
    2990:	6a e0       	ldi	r22, 0x0A	; 10
    2992:	c3 01       	movw	r24, r6
    2994:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2998:	4c 01       	movw	r8, r24
    299a:	69 e6       	ldi	r22, 0x69	; 105
    299c:	74 e0       	ldi	r23, 0x04	; 4
    299e:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    29a2:	be 01       	movw	r22, r28
    29a4:	6f 5f       	subi	r22, 0xFF	; 255
    29a6:	7f 4f       	sbci	r23, 0xFF	; 255
    29a8:	c4 01       	movw	r24, r8
    29aa:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    29ae:	66 e0       	ldi	r22, 0x06	; 6
    29b0:	c4 01       	movw	r24, r8
    29b2:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    29b6:	2a 96       	adiw	r28, 0x0a	; 10
    29b8:	cd bf       	out	0x3d, r28	; 61
    29ba:	de bf       	out	0x3e, r29	; 62
    29bc:	df 91       	pop	r29
    29be:	cf 91       	pop	r28
    29c0:	1f 91       	pop	r17
    29c2:	0f 91       	pop	r16
    29c4:	ff 90       	pop	r15
    29c6:	ef 90       	pop	r14
    29c8:	df 90       	pop	r13
    29ca:	cf 90       	pop	r12
    29cc:	bf 90       	pop	r11
    29ce:	af 90       	pop	r10
    29d0:	9f 90       	pop	r9
    29d2:	8f 90       	pop	r8
    29d4:	7f 90       	pop	r7
    29d6:	6f 90       	pop	r6
    29d8:	5f 90       	pop	r5
    29da:	4f 90       	pop	r4
    29dc:	08 95       	ret

000029de <_ZN8frt_task19print_stack_in_listEP8emstream>:
=======
    2ae0:	6a e0       	ldi	r22, 0x0A	; 10
    2ae2:	c3 01       	movw	r24, r6
    2ae4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ae8:	4c 01       	movw	r8, r24
    2aea:	6d e6       	ldi	r22, 0x6D	; 109
    2aec:	74 e0       	ldi	r23, 0x04	; 4
    2aee:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2af2:	be 01       	movw	r22, r28
    2af4:	6f 5f       	subi	r22, 0xFF	; 255
    2af6:	7f 4f       	sbci	r23, 0xFF	; 255
    2af8:	c4 01       	movw	r24, r8
    2afa:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2afe:	66 e0       	ldi	r22, 0x06	; 6
    2b00:	c4 01       	movw	r24, r8
    2b02:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2b06:	2a 96       	adiw	r28, 0x0a	; 10
    2b08:	cd bf       	out	0x3d, r28	; 61
    2b0a:	de bf       	out	0x3e, r29	; 62
    2b0c:	df 91       	pop	r29
    2b0e:	cf 91       	pop	r28
    2b10:	1f 91       	pop	r17
    2b12:	0f 91       	pop	r16
    2b14:	ff 90       	pop	r15
    2b16:	ef 90       	pop	r14
    2b18:	df 90       	pop	r13
    2b1a:	cf 90       	pop	r12
    2b1c:	bf 90       	pop	r11
    2b1e:	af 90       	pop	r10
    2b20:	9f 90       	pop	r9
    2b22:	8f 90       	pop	r8
    2b24:	7f 90       	pop	r7
    2b26:	6f 90       	pop	r6
    2b28:	5f 90       	pop	r5
    2b2a:	4f 90       	pop	r4
    2b2c:	08 95       	ret

00002b2e <_ZN8frt_task19print_stack_in_listEP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
<<<<<<< HEAD
    29de:	cf 92       	push	r12
    29e0:	df 92       	push	r13
    29e2:	ef 92       	push	r14
    29e4:	ff 92       	push	r15
    29e6:	0f 93       	push	r16
    29e8:	1f 93       	push	r17
    29ea:	cf 93       	push	r28
    29ec:	df 93       	push	r29
    29ee:	ec 01       	movw	r28, r24
    29f0:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    29f2:	8a 81       	ldd	r24, Y+2	; 0x02
    29f4:	9b 81       	ldd	r25, Y+3	; 0x03
    29f6:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <pcTaskGetTaskName>
    29fa:	6c 01       	movw	r12, r24
=======
    2b2e:	cf 92       	push	r12
    2b30:	df 92       	push	r13
    2b32:	ef 92       	push	r14
    2b34:	ff 92       	push	r15
    2b36:	0f 93       	push	r16
    2b38:	1f 93       	push	r17
    2b3a:	cf 93       	push	r28
    2b3c:	df 93       	push	r29
    2b3e:	ec 01       	movw	r28, r24
    2b40:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2b42:	8a 81       	ldd	r24, Y+2	; 0x02
    2b44:	9b 81       	ldd	r25, Y+3	; 0x03
    2b46:	0e 94 a3 10 	call	0x2146	; 0x2146 <pcTaskGetTaskName>
    2b4a:	6c 01       	movw	r12, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
<<<<<<< HEAD
    29fc:	6a e0       	ldi	r22, 0x0A	; 10
    29fe:	c7 01       	movw	r24, r14
    2a00:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2a04:	8c 01       	movw	r16, r24
    2a06:	68 ea       	ldi	r22, 0xA8	; 168
    2a08:	74 e0       	ldi	r23, 0x04	; 4
    2a0a:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2a0e:	6a e0       	ldi	r22, 0x0A	; 10
    2a10:	c8 01       	movw	r24, r16
    2a12:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2a16:	8c 01       	movw	r16, r24
    2a18:	61 ea       	ldi	r22, 0xA1	; 161
    2a1a:	74 e0       	ldi	r23, 0x04	; 4
    2a1c:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2a20:	b6 01       	movw	r22, r12
    2a22:	c8 01       	movw	r24, r16
    2a24:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2a28:	6a e0       	ldi	r22, 0x0A	; 10
    2a2a:	c8 01       	movw	r24, r16
    2a2c:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2a30:	8c 01       	movw	r16, r24
    2a32:	6b e9       	ldi	r22, 0x9B	; 155
    2a34:	74 e0       	ldi	r23, 0x04	; 4
    2a36:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2a3a:	66 e0       	ldi	r22, 0x06	; 6
    2a3c:	c8 01       	movw	r24, r16
    2a3e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
=======
    2b4c:	6a e0       	ldi	r22, 0x0A	; 10
    2b4e:	c7 01       	movw	r24, r14
    2b50:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2b54:	8c 01       	movw	r16, r24
    2b56:	6c ea       	ldi	r22, 0xAC	; 172
    2b58:	74 e0       	ldi	r23, 0x04	; 4
    2b5a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2b5e:	6a e0       	ldi	r22, 0x0A	; 10
    2b60:	c8 01       	movw	r24, r16
    2b62:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2b66:	8c 01       	movw	r16, r24
    2b68:	65 ea       	ldi	r22, 0xA5	; 165
    2b6a:	74 e0       	ldi	r23, 0x04	; 4
    2b6c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2b70:	b6 01       	movw	r22, r12
    2b72:	c8 01       	movw	r24, r16
    2b74:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2b78:	6a e0       	ldi	r22, 0x0A	; 10
    2b7a:	c8 01       	movw	r24, r16
    2b7c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2b80:	8c 01       	movw	r16, r24
    2b82:	6f e9       	ldi	r22, 0x9F	; 159
    2b84:	74 e0       	ldi	r23, 0x04	; 4
    2b86:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2b8a:	66 e0       	ldi	r22, 0x06	; 6
    2b8c:	c8 01       	movw	r24, r16
    2b8e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
<<<<<<< HEAD
    2a42:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a44:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a46:	e8 85       	ldd	r30, Y+8	; 0x08
    2a48:	f9 85       	ldd	r31, Y+9	; 0x09
    2a4a:	01 e1       	ldi	r16, 0x11	; 17
    2a4c:	21 e0       	ldi	r18, 0x01	; 1
    2a4e:	a7 01       	movw	r20, r14
    2a50:	bc 01       	movw	r22, r24
    2a52:	8e 1b       	sub	r24, r30
    2a54:	9f 0b       	sbc	r25, r31
    2a56:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Z15hex_dump_memoryPhS_P8emstreambh>
=======
    2b92:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b94:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b96:	e8 85       	ldd	r30, Y+8	; 0x08
    2b98:	f9 85       	ldd	r31, Y+9	; 0x09
    2b9a:	01 e1       	ldi	r16, 0x11	; 17
    2b9c:	21 e0       	ldi	r18, 0x01	; 1
    2b9e:	a7 01       	movw	r20, r14
    2ba0:	bc 01       	movw	r22, r24
    2ba2:	8e 1b       	sub	r24, r30
    2ba4:	9f 0b       	sbc	r25, r31
    2ba6:	0e 94 99 18 	call	0x3132	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
<<<<<<< HEAD
    2a5a:	8c 81       	ldd	r24, Y+4	; 0x04
    2a5c:	9d 81       	ldd	r25, Y+5	; 0x05
    2a5e:	00 97       	sbiw	r24, 0x00	; 0
    2a60:	19 f0       	breq	.+6      	; 0x2a68 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2a62:	b7 01       	movw	r22, r14
    2a64:	0e 94 ef 14 	call	0x29de	; 0x29de <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2a68:	df 91       	pop	r29
    2a6a:	cf 91       	pop	r28
    2a6c:	1f 91       	pop	r17
    2a6e:	0f 91       	pop	r16
    2a70:	ff 90       	pop	r15
    2a72:	ef 90       	pop	r14
    2a74:	df 90       	pop	r13
    2a76:	cf 90       	pop	r12
    2a78:	08 95       	ret

00002a7a <_Z17print_task_stacksP8emstream>:
=======
    2baa:	8c 81       	ldd	r24, Y+4	; 0x04
    2bac:	9d 81       	ldd	r25, Y+5	; 0x05
    2bae:	00 97       	sbiw	r24, 0x00	; 0
    2bb0:	19 f0       	breq	.+6      	; 0x2bb8 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2bb2:	b7 01       	movw	r22, r14
    2bb4:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2bb8:	df 91       	pop	r29
    2bba:	cf 91       	pop	r28
    2bbc:	1f 91       	pop	r17
    2bbe:	0f 91       	pop	r16
    2bc0:	ff 90       	pop	r15
    2bc2:	ef 90       	pop	r14
    2bc4:	df 90       	pop	r13
    2bc6:	cf 90       	pop	r12
    2bc8:	08 95       	ret

00002bca <_Z17print_task_stacksP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
<<<<<<< HEAD
    2a7a:	0f 93       	push	r16
    2a7c:	1f 93       	push	r17
    2a7e:	cf 93       	push	r28
    2a80:	df 93       	push	r29
    2a82:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2a84:	80 91 16 31 	lds	r24, 0x3116	; 0x803116 <last_created_task_pointer>
    2a88:	90 91 17 31 	lds	r25, 0x3117	; 0x803117 <last_created_task_pointer+0x1>
    2a8c:	00 97       	sbiw	r24, 0x00	; 0
    2a8e:	19 f0       	breq	.+6      	; 0x2a96 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2a90:	be 01       	movw	r22, r28
    2a92:	0e 94 ef 14 	call	0x29de	; 0x29de <_ZN8frt_task19print_stack_in_listEP8emstream>
=======
    2bca:	0f 93       	push	r16
    2bcc:	1f 93       	push	r17
    2bce:	cf 93       	push	r28
    2bd0:	df 93       	push	r29
    2bd2:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2bd4:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <last_created_task_pointer>
    2bd8:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <last_created_task_pointer+0x1>
    2bdc:	00 97       	sbiw	r24, 0x00	; 0
    2bde:	19 f0       	breq	.+6      	; 0x2be6 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2be0:	be 01       	movw	r22, r28
    2be2:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <_ZN8frt_task19print_stack_in_listEP8emstream>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
<<<<<<< HEAD
    2a96:	6a e0       	ldi	r22, 0x0A	; 10
    2a98:	ce 01       	movw	r24, r28
    2a9a:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2a9e:	8c 01       	movw	r16, r24
    2aa0:	6e eb       	ldi	r22, 0xBE	; 190
    2aa2:	74 e0       	ldi	r23, 0x04	; 4
    2aa4:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2aa8:	6a e0       	ldi	r22, 0x0A	; 10
    2aaa:	c8 01       	movw	r24, r16
    2aac:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2ab0:	8c 01       	movw	r16, r24
    2ab2:	63 eb       	ldi	r22, 0xB3	; 179
    2ab4:	74 e0       	ldi	r23, 0x04	; 4
    2ab6:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2aba:	6a e0       	ldi	r22, 0x0A	; 10
    2abc:	c8 01       	movw	r24, r16
    2abe:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2ac2:	8c 01       	movw	r16, r24
    2ac4:	6d ea       	ldi	r22, 0xAD	; 173
    2ac6:	74 e0       	ldi	r23, 0x04	; 4
    2ac8:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2acc:	66 e0       	ldi	r22, 0x06	; 6
    2ace:	c8 01       	movw	r24, r16
    2ad0:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2ad4:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <portStackTopForTask>
    2ad8:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <portStackTopForTask+0x1>
    2adc:	bc 01       	movw	r22, r24
    2ade:	6f 5f       	subi	r22, 0xFF	; 255
    2ae0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae2:	01 e1       	ldi	r16, 0x11	; 17
    2ae4:	21 e0       	ldi	r18, 0x01	; 1
    2ae6:	ae 01       	movw	r20, r28
    2ae8:	83 56       	subi	r24, 0x63	; 99
    2aea:	91 09       	sbc	r25, r1
    2aec:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2af0:	df 91       	pop	r29
    2af2:	cf 91       	pop	r28
    2af4:	1f 91       	pop	r17
    2af6:	0f 91       	pop	r16
    2af8:	08 95       	ret

00002afa <_ZN8frt_task12print_statusER8emstream>:
=======
    2be6:	6a e0       	ldi	r22, 0x0A	; 10
    2be8:	ce 01       	movw	r24, r28
    2bea:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2bee:	8c 01       	movw	r16, r24
    2bf0:	62 ec       	ldi	r22, 0xC2	; 194
    2bf2:	74 e0       	ldi	r23, 0x04	; 4
    2bf4:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2bf8:	6a e0       	ldi	r22, 0x0A	; 10
    2bfa:	c8 01       	movw	r24, r16
    2bfc:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2c00:	8c 01       	movw	r16, r24
    2c02:	67 eb       	ldi	r22, 0xB7	; 183
    2c04:	74 e0       	ldi	r23, 0x04	; 4
    2c06:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2c0a:	6a e0       	ldi	r22, 0x0A	; 10
    2c0c:	c8 01       	movw	r24, r16
    2c0e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2c12:	8c 01       	movw	r16, r24
    2c14:	61 eb       	ldi	r22, 0xB1	; 177
    2c16:	74 e0       	ldi	r23, 0x04	; 4
    2c18:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2c1c:	66 e0       	ldi	r22, 0x06	; 6
    2c1e:	c8 01       	movw	r24, r16
    2c20:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2c24:	80 91 86 31 	lds	r24, 0x3186	; 0x803186 <portStackTopForTask>
    2c28:	90 91 87 31 	lds	r25, 0x3187	; 0x803187 <portStackTopForTask+0x1>
    2c2c:	bc 01       	movw	r22, r24
    2c2e:	6f 5f       	subi	r22, 0xFF	; 255
    2c30:	7f 4f       	sbci	r23, 0xFF	; 255
    2c32:	01 e1       	ldi	r16, 0x11	; 17
    2c34:	21 e0       	ldi	r18, 0x01	; 1
    2c36:	ae 01       	movw	r20, r28
    2c38:	83 56       	subi	r24, 0x63	; 99
    2c3a:	91 09       	sbc	r25, r1
    2c3c:	0e 94 99 18 	call	0x3132	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2c40:	df 91       	pop	r29
    2c42:	cf 91       	pop	r28
    2c44:	1f 91       	pop	r17
    2c46:	0f 91       	pop	r16
    2c48:	08 95       	ret

00002c4a <_ZN8frt_task12print_statusER8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
<<<<<<< HEAD
    2afa:	8f 92       	push	r8
    2afc:	9f 92       	push	r9
    2afe:	af 92       	push	r10
    2b00:	bf 92       	push	r11
    2b02:	cf 92       	push	r12
    2b04:	df 92       	push	r13
    2b06:	ef 92       	push	r14
    2b08:	ff 92       	push	r15
    2b0a:	0f 93       	push	r16
    2b0c:	1f 93       	push	r17
    2b0e:	cf 93       	push	r28
    2b10:	df 93       	push	r29
    2b12:	ec 01       	movw	r28, r24
    2b14:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2b16:	8a 81       	ldd	r24, Y+2	; 0x02
    2b18:	9b 81       	ldd	r25, Y+3	; 0x03
    2b1a:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <pcTaskGetTaskName>
    2b1e:	bc 01       	movw	r22, r24
    2b20:	c8 01       	movw	r24, r16
    2b22:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2b26:	d8 01       	movw	r26, r16
    2b28:	ed 91       	ld	r30, X+
    2b2a:	fc 91       	ld	r31, X
    2b2c:	02 80       	ldd	r0, Z+2	; 0x02
    2b2e:	f3 81       	ldd	r31, Z+3	; 0x03
    2b30:	e0 2d       	mov	r30, r0
    2b32:	69 e0       	ldi	r22, 0x09	; 9
    2b34:	c8 01       	movw	r24, r16
    2b36:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2b38:	8a 81       	ldd	r24, Y+2	; 0x02
    2b3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b3c:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <pcTaskGetTaskName>
    2b40:	fc 01       	movw	r30, r24
    2b42:	01 90       	ld	r0, Z+
    2b44:	00 20       	and	r0, r0
    2b46:	e9 f7       	brne	.-6      	; 0x2b42 <_ZN8frt_task12print_statusER8emstream+0x48>
    2b48:	31 97       	sbiw	r30, 0x01	; 1
    2b4a:	e8 1b       	sub	r30, r24
    2b4c:	f9 0b       	sbc	r31, r25
    2b4e:	38 97       	sbiw	r30, 0x08	; 8
    2b50:	48 f4       	brcc	.+18     	; 0x2b64 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2b52:	d8 01       	movw	r26, r16
    2b54:	ed 91       	ld	r30, X+
    2b56:	fc 91       	ld	r31, X
    2b58:	02 80       	ldd	r0, Z+2	; 0x02
    2b5a:	f3 81       	ldd	r31, Z+3	; 0x03
    2b5c:	e0 2d       	mov	r30, r0
    2b5e:	69 e0       	ldi	r22, 0x09	; 9
    2b60:	c8 01       	movw	r24, r16
    2b62:	19 95       	eicall
=======
    2c4a:	8f 92       	push	r8
    2c4c:	9f 92       	push	r9
    2c4e:	af 92       	push	r10
    2c50:	bf 92       	push	r11
    2c52:	cf 92       	push	r12
    2c54:	df 92       	push	r13
    2c56:	ef 92       	push	r14
    2c58:	ff 92       	push	r15
    2c5a:	0f 93       	push	r16
    2c5c:	1f 93       	push	r17
    2c5e:	cf 93       	push	r28
    2c60:	df 93       	push	r29
    2c62:	ec 01       	movw	r28, r24
    2c64:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2c66:	8a 81       	ldd	r24, Y+2	; 0x02
    2c68:	9b 81       	ldd	r25, Y+3	; 0x03
    2c6a:	0e 94 a3 10 	call	0x2146	; 0x2146 <pcTaskGetTaskName>
    2c6e:	bc 01       	movw	r22, r24
    2c70:	c8 01       	movw	r24, r16
    2c72:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2c76:	d8 01       	movw	r26, r16
    2c78:	ed 91       	ld	r30, X+
    2c7a:	fc 91       	ld	r31, X
    2c7c:	02 80       	ldd	r0, Z+2	; 0x02
    2c7e:	f3 81       	ldd	r31, Z+3	; 0x03
    2c80:	e0 2d       	mov	r30, r0
    2c82:	69 e0       	ldi	r22, 0x09	; 9
    2c84:	c8 01       	movw	r24, r16
    2c86:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c88:	8a 81       	ldd	r24, Y+2	; 0x02
    2c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c8c:	0e 94 a3 10 	call	0x2146	; 0x2146 <pcTaskGetTaskName>
    2c90:	fc 01       	movw	r30, r24
    2c92:	01 90       	ld	r0, Z+
    2c94:	00 20       	and	r0, r0
    2c96:	e9 f7       	brne	.-6      	; 0x2c92 <_ZN8frt_task12print_statusER8emstream+0x48>
    2c98:	31 97       	sbiw	r30, 0x01	; 1
    2c9a:	e8 1b       	sub	r30, r24
    2c9c:	f9 0b       	sbc	r31, r25
    2c9e:	38 97       	sbiw	r30, 0x08	; 8
    2ca0:	48 f4       	brcc	.+18     	; 0x2cb4 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2ca2:	d8 01       	movw	r26, r16
    2ca4:	ed 91       	ld	r30, X+
    2ca6:	fc 91       	ld	r31, X
    2ca8:	02 80       	ldd	r0, Z+2	; 0x02
    2caa:	f3 81       	ldd	r31, Z+3	; 0x03
    2cac:	e0 2d       	mov	r30, r0
    2cae:	69 e0       	ldi	r22, 0x09	; 9
    2cb0:	c8 01       	movw	r24, r16
    2cb2:	19 95       	eicall
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
<<<<<<< HEAD
    2b64:	ce 84       	ldd	r12, Y+14	; 0x0e
    2b66:	df 84       	ldd	r13, Y+15	; 0x0f
    2b68:	e8 88       	ldd	r14, Y+16	; 0x10
    2b6a:	f9 88       	ldd	r15, Y+17	; 0x11
=======
    2cb4:	ce 84       	ldd	r12, Y+14	; 0x0e
    2cb6:	df 84       	ldd	r13, Y+15	; 0x0f
    2cb8:	e8 88       	ldd	r14, Y+16	; 0x10
    2cba:	f9 88       	ldd	r15, Y+17	; 0x11
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
<<<<<<< HEAD
    2b6c:	a8 84       	ldd	r10, Y+8	; 0x08
    2b6e:	b9 84       	ldd	r11, Y+9	; 0x09
=======
    2cbc:	a8 84       	ldd	r10, Y+8	; 0x08
    2cbe:	b9 84       	ldd	r11, Y+9	; 0x09
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
<<<<<<< HEAD
    2b70:	8a 81       	ldd	r24, Y+2	; 0x02
    2b72:	9b 81       	ldd	r25, Y+3	; 0x03
    2b74:	0e 94 6e 13 	call	0x26dc	; 0x26dc <uxTaskGetStackHighWaterMark>
    2b78:	98 2e       	mov	r9, r24
=======
    2cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    2cc4:	0e 94 16 14 	call	0x282c	; 0x282c <uxTaskGetStackHighWaterMark>
    2cc8:	98 2e       	mov	r9, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
<<<<<<< HEAD
    2b7a:	8c 84       	ldd	r8, Y+12	; 0x0c
=======
    2cca:	8c 84       	ldd	r8, Y+12	; 0x0c
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
<<<<<<< HEAD
    2b7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b80:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <uxTaskPriorityGet>
    2b84:	68 2f       	mov	r22, r24
    2b86:	c8 01       	movw	r24, r16
    2b88:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
    2b8c:	6a e0       	ldi	r22, 0x0A	; 10
    2b8e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2b92:	ec 01       	movw	r28, r24
    2b94:	63 e3       	ldi	r22, 0x33	; 51
    2b96:	75 e0       	ldi	r23, 0x05	; 5
    2b98:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
			<< get_state ()
    2b9c:	68 2d       	mov	r22, r8
    2b9e:	ce 01       	movw	r24, r28
    2ba0:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2ba4:	6a e0       	ldi	r22, 0x0A	; 10
    2ba6:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2baa:	ec 01       	movw	r28, r24
    2bac:	61 e3       	ldi	r22, 0x31	; 49
    2bae:	75 e0       	ldi	r23, 0x05	; 5
    2bb0:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2bb4:	69 2d       	mov	r22, r9
    2bb6:	ce 01       	movw	r24, r28
    2bb8:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
    2bbc:	6a e0       	ldi	r22, 0x0A	; 10
    2bbe:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2bc2:	ec 01       	movw	r28, r24
    2bc4:	6f e2       	ldi	r22, 0x2F	; 47
    2bc6:	75 e0       	ldi	r23, 0x05	; 5
    2bc8:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2bcc:	b5 01       	movw	r22, r10
    2bce:	ce 01       	movw	r24, r28
    2bd0:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsEj>
    2bd4:	6a e0       	ldi	r22, 0x0A	; 10
    2bd6:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2bda:	ec 01       	movw	r28, r24
    2bdc:	6d e2       	ldi	r22, 0x2D	; 45
    2bde:	75 e0       	ldi	r23, 0x05	; 5
    2be0:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2be4:	6a e0       	ldi	r22, 0x0A	; 10
    2be6:	ce 01       	movw	r24, r28
    2be8:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2bec:	ec 01       	movw	r28, r24
    2bee:	6b e2       	ldi	r22, 0x2B	; 43
    2bf0:	75 e0       	ldi	r23, 0x05	; 5
    2bf2:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2bf6:	b7 01       	movw	r22, r14
    2bf8:	a6 01       	movw	r20, r12
    2bfa:	ce 01       	movw	r24, r28
    2bfc:	0e 94 31 1a 	call	0x3462	; 0x3462 <_ZN8emstreamlsEm>
}
    2c00:	df 91       	pop	r29
    2c02:	cf 91       	pop	r28
    2c04:	1f 91       	pop	r17
    2c06:	0f 91       	pop	r16
    2c08:	ff 90       	pop	r15
    2c0a:	ef 90       	pop	r14
    2c0c:	df 90       	pop	r13
    2c0e:	cf 90       	pop	r12
    2c10:	bf 90       	pop	r11
    2c12:	af 90       	pop	r10
    2c14:	9f 90       	pop	r9
    2c16:	8f 90       	pop	r8
    2c18:	08 95       	ret

00002c1a <_ZlsR8emstreamR8frt_task>:
=======
    2ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    2cce:	9b 81       	ldd	r25, Y+3	; 0x03
    2cd0:	0e 94 4e 10 	call	0x209c	; 0x209c <uxTaskPriorityGet>
    2cd4:	68 2f       	mov	r22, r24
    2cd6:	c8 01       	movw	r24, r16
    2cd8:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    2cdc:	6a e0       	ldi	r22, 0x0A	; 10
    2cde:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ce2:	ec 01       	movw	r28, r24
    2ce4:	67 e3       	ldi	r22, 0x37	; 55
    2ce6:	75 e0       	ldi	r23, 0x05	; 5
    2ce8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
			<< get_state ()
    2cec:	68 2d       	mov	r22, r8
    2cee:	ce 01       	movw	r24, r28
    2cf0:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2cf4:	6a e0       	ldi	r22, 0x0A	; 10
    2cf6:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2cfa:	ec 01       	movw	r28, r24
    2cfc:	65 e3       	ldi	r22, 0x35	; 53
    2cfe:	75 e0       	ldi	r23, 0x05	; 5
    2d00:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2d04:	69 2d       	mov	r22, r9
    2d06:	ce 01       	movw	r24, r28
    2d08:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    2d0c:	6a e0       	ldi	r22, 0x0A	; 10
    2d0e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2d12:	ec 01       	movw	r28, r24
    2d14:	63 e3       	ldi	r22, 0x33	; 51
    2d16:	75 e0       	ldi	r23, 0x05	; 5
    2d18:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2d1c:	b5 01       	movw	r22, r10
    2d1e:	ce 01       	movw	r24, r28
    2d20:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    2d24:	6a e0       	ldi	r22, 0x0A	; 10
    2d26:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2d2a:	ec 01       	movw	r28, r24
    2d2c:	61 e3       	ldi	r22, 0x31	; 49
    2d2e:	75 e0       	ldi	r23, 0x05	; 5
    2d30:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2d34:	6a e0       	ldi	r22, 0x0A	; 10
    2d36:	ce 01       	movw	r24, r28
    2d38:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2d3c:	ec 01       	movw	r28, r24
    2d3e:	6f e2       	ldi	r22, 0x2F	; 47
    2d40:	75 e0       	ldi	r23, 0x05	; 5
    2d42:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2d46:	b7 01       	movw	r22, r14
    2d48:	a6 01       	movw	r20, r12
    2d4a:	ce 01       	movw	r24, r28
    2d4c:	0e 94 04 1b 	call	0x3608	; 0x3608 <_ZN8emstreamlsEm>
}
    2d50:	df 91       	pop	r29
    2d52:	cf 91       	pop	r28
    2d54:	1f 91       	pop	r17
    2d56:	0f 91       	pop	r16
    2d58:	ff 90       	pop	r15
    2d5a:	ef 90       	pop	r14
    2d5c:	df 90       	pop	r13
    2d5e:	cf 90       	pop	r12
    2d60:	bf 90       	pop	r11
    2d62:	af 90       	pop	r10
    2d64:	9f 90       	pop	r9
    2d66:	8f 90       	pop	r8
    2d68:	08 95       	ret

00002d6a <_ZlsR8emstreamR8frt_task>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
<<<<<<< HEAD
    2c1a:	cf 93       	push	r28
    2c1c:	df 93       	push	r29
    2c1e:	ec 01       	movw	r28, r24
    2c20:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2c22:	db 01       	movw	r26, r22
    2c24:	ed 91       	ld	r30, X+
    2c26:	fc 91       	ld	r31, X
    2c28:	02 80       	ldd	r0, Z+2	; 0x02
    2c2a:	f3 81       	ldd	r31, Z+3	; 0x03
    2c2c:	e0 2d       	mov	r30, r0
    2c2e:	be 01       	movw	r22, r28
    2c30:	19 95       	eicall
	return (ser_dev);
}
    2c32:	ce 01       	movw	r24, r28
    2c34:	df 91       	pop	r29
    2c36:	cf 91       	pop	r28
    2c38:	08 95       	ret

00002c3a <_ZN8frt_task20print_status_in_listEP8emstream>:
=======
    2d6a:	cf 93       	push	r28
    2d6c:	df 93       	push	r29
    2d6e:	ec 01       	movw	r28, r24
    2d70:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2d72:	db 01       	movw	r26, r22
    2d74:	ed 91       	ld	r30, X+
    2d76:	fc 91       	ld	r31, X
    2d78:	02 80       	ldd	r0, Z+2	; 0x02
    2d7a:	f3 81       	ldd	r31, Z+3	; 0x03
    2d7c:	e0 2d       	mov	r30, r0
    2d7e:	be 01       	movw	r22, r28
    2d80:	19 95       	eicall
	return (ser_dev);
}
    2d82:	ce 01       	movw	r24, r28
    2d84:	df 91       	pop	r29
    2d86:	cf 91       	pop	r28
    2d88:	08 95       	ret

00002d8a <_ZN8frt_task20print_status_in_listEP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
<<<<<<< HEAD
    2c3a:	0f 93       	push	r16
    2c3c:	1f 93       	push	r17
    2c3e:	cf 93       	push	r28
    2c40:	df 93       	push	r29
    2c42:	ec 01       	movw	r28, r24
    2c44:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2c46:	bc 01       	movw	r22, r24
    2c48:	c8 01       	movw	r24, r16
    2c4a:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <_ZlsR8emstreamR8frt_task>
    2c4e:	66 e0       	ldi	r22, 0x06	; 6
    2c50:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2c54:	8c 81       	ldd	r24, Y+4	; 0x04
    2c56:	9d 81       	ldd	r25, Y+5	; 0x05
    2c58:	00 97       	sbiw	r24, 0x00	; 0
    2c5a:	19 f0       	breq	.+6      	; 0x2c62 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2c5c:	b8 01       	movw	r22, r16
    2c5e:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2c62:	df 91       	pop	r29
    2c64:	cf 91       	pop	r28
    2c66:	1f 91       	pop	r17
    2c68:	0f 91       	pop	r16
    2c6a:	08 95       	ret

00002c6c <_Z15print_task_listP8emstream>:
=======
    2d8a:	0f 93       	push	r16
    2d8c:	1f 93       	push	r17
    2d8e:	cf 93       	push	r28
    2d90:	df 93       	push	r29
    2d92:	ec 01       	movw	r28, r24
    2d94:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d96:	bc 01       	movw	r22, r24
    2d98:	c8 01       	movw	r24, r16
    2d9a:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <_ZlsR8emstreamR8frt_task>
    2d9e:	66 e0       	ldi	r22, 0x06	; 6
    2da0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2da4:	8c 81       	ldd	r24, Y+4	; 0x04
    2da6:	9d 81       	ldd	r25, Y+5	; 0x05
    2da8:	00 97       	sbiw	r24, 0x00	; 0
    2daa:	19 f0       	breq	.+6      	; 0x2db2 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2dac:	b8 01       	movw	r22, r16
    2dae:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2db2:	df 91       	pop	r29
    2db4:	cf 91       	pop	r28
    2db6:	1f 91       	pop	r17
    2db8:	0f 91       	pop	r16
    2dba:	08 95       	ret

00002dbc <_Z15print_task_listP8emstream>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
<<<<<<< HEAD
    2c6c:	0f 93       	push	r16
    2c6e:	1f 93       	push	r17
    2c70:	cf 93       	push	r28
    2c72:	df 93       	push	r29
    2c74:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2c76:	6a e0       	ldi	r22, 0x0A	; 10
    2c78:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2c7c:	8c 01       	movw	r16, r24
    2c7e:	60 e2       	ldi	r22, 0x20	; 32
    2c80:	75 e0       	ldi	r23, 0x05	; 5
    2c82:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2c86:	6a e0       	ldi	r22, 0x0A	; 10
    2c88:	c8 01       	movw	r24, r16
    2c8a:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2c8e:	8c 01       	movw	r16, r24
    2c90:	69 e1       	ldi	r22, 0x19	; 25
    2c92:	75 e0       	ldi	r23, 0x05	; 5
    2c94:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2c98:	66 e0       	ldi	r22, 0x06	; 6
    2c9a:	c8 01       	movw	r24, r16
    2c9c:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2ca0:	6a e0       	ldi	r22, 0x0A	; 10
    2ca2:	ce 01       	movw	r24, r28
    2ca4:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2ca8:	8c 01       	movw	r16, r24
    2caa:	68 e0       	ldi	r22, 0x08	; 8
    2cac:	75 e0       	ldi	r23, 0x05	; 5
    2cae:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2cb2:	6a e0       	ldi	r22, 0x0A	; 10
    2cb4:	c8 01       	movw	r24, r16
    2cb6:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2cba:	8c 01       	movw	r16, r24
    2cbc:	6c ef       	ldi	r22, 0xFC	; 252
    2cbe:	74 e0       	ldi	r23, 0x04	; 4
    2cc0:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2cc4:	6a e0       	ldi	r22, 0x0A	; 10
    2cc6:	c8 01       	movw	r24, r16
    2cc8:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2ccc:	8c 01       	movw	r16, r24
    2cce:	66 ef       	ldi	r22, 0xF6	; 246
    2cd0:	74 e0       	ldi	r23, 0x04	; 4
    2cd2:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2cd6:	66 e0       	ldi	r22, 0x06	; 6
    2cd8:	c8 01       	movw	r24, r16
    2cda:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2cde:	6a e0       	ldi	r22, 0x0A	; 10
    2ce0:	ce 01       	movw	r24, r28
    2ce2:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2ce6:	8c 01       	movw	r16, r24
    2ce8:	65 ee       	ldi	r22, 0xE5	; 229
    2cea:	74 e0       	ldi	r23, 0x04	; 4
    2cec:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2cf0:	6a e0       	ldi	r22, 0x0A	; 10
    2cf2:	c8 01       	movw	r24, r16
    2cf4:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2cf8:	8c 01       	movw	r16, r24
    2cfa:	69 ed       	ldi	r22, 0xD9	; 217
    2cfc:	74 e0       	ldi	r23, 0x04	; 4
    2cfe:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2d02:	6a e0       	ldi	r22, 0x0A	; 10
    2d04:	c8 01       	movw	r24, r16
    2d06:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2d0a:	8c 01       	movw	r16, r24
    2d0c:	63 ed       	ldi	r22, 0xD3	; 211
    2d0e:	74 e0       	ldi	r23, 0x04	; 4
    2d10:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2d14:	66 e0       	ldi	r22, 0x06	; 6
    2d16:	c8 01       	movw	r24, r16
    2d18:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
=======
    2dbc:	0f 93       	push	r16
    2dbe:	1f 93       	push	r17
    2dc0:	cf 93       	push	r28
    2dc2:	df 93       	push	r29
    2dc4:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2dc6:	6a e0       	ldi	r22, 0x0A	; 10
    2dc8:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2dcc:	8c 01       	movw	r16, r24
    2dce:	64 e2       	ldi	r22, 0x24	; 36
    2dd0:	75 e0       	ldi	r23, 0x05	; 5
    2dd2:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2dd6:	6a e0       	ldi	r22, 0x0A	; 10
    2dd8:	c8 01       	movw	r24, r16
    2dda:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2dde:	8c 01       	movw	r16, r24
    2de0:	6d e1       	ldi	r22, 0x1D	; 29
    2de2:	75 e0       	ldi	r23, 0x05	; 5
    2de4:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2de8:	66 e0       	ldi	r22, 0x06	; 6
    2dea:	c8 01       	movw	r24, r16
    2dec:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2df0:	6a e0       	ldi	r22, 0x0A	; 10
    2df2:	ce 01       	movw	r24, r28
    2df4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2df8:	8c 01       	movw	r16, r24
    2dfa:	6c e0       	ldi	r22, 0x0C	; 12
    2dfc:	75 e0       	ldi	r23, 0x05	; 5
    2dfe:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2e02:	6a e0       	ldi	r22, 0x0A	; 10
    2e04:	c8 01       	movw	r24, r16
    2e06:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e0a:	8c 01       	movw	r16, r24
    2e0c:	60 e0       	ldi	r22, 0x00	; 0
    2e0e:	75 e0       	ldi	r23, 0x05	; 5
    2e10:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2e14:	6a e0       	ldi	r22, 0x0A	; 10
    2e16:	c8 01       	movw	r24, r16
    2e18:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e1c:	8c 01       	movw	r16, r24
    2e1e:	6a ef       	ldi	r22, 0xFA	; 250
    2e20:	74 e0       	ldi	r23, 0x04	; 4
    2e22:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2e26:	66 e0       	ldi	r22, 0x06	; 6
    2e28:	c8 01       	movw	r24, r16
    2e2a:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2e2e:	6a e0       	ldi	r22, 0x0A	; 10
    2e30:	ce 01       	movw	r24, r28
    2e32:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e36:	8c 01       	movw	r16, r24
    2e38:	69 ee       	ldi	r22, 0xE9	; 233
    2e3a:	74 e0       	ldi	r23, 0x04	; 4
    2e3c:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2e40:	6a e0       	ldi	r22, 0x0A	; 10
    2e42:	c8 01       	movw	r24, r16
    2e44:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e48:	8c 01       	movw	r16, r24
    2e4a:	6d ed       	ldi	r22, 0xDD	; 221
    2e4c:	74 e0       	ldi	r23, 0x04	; 4
    2e4e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2e52:	6a e0       	ldi	r22, 0x0A	; 10
    2e54:	c8 01       	movw	r24, r16
    2e56:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e5a:	8c 01       	movw	r16, r24
    2e5c:	67 ed       	ldi	r22, 0xD7	; 215
    2e5e:	74 e0       	ldi	r23, 0x04	; 4
    2e60:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2e64:	66 e0       	ldi	r22, 0x06	; 6
    2e66:	c8 01       	movw	r24, r16
    2e68:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
<<<<<<< HEAD
    2d1c:	80 91 16 31 	lds	r24, 0x3116	; 0x803116 <last_created_task_pointer>
    2d20:	90 91 17 31 	lds	r25, 0x3117	; 0x803117 <last_created_task_pointer+0x1>
    2d24:	00 97       	sbiw	r24, 0x00	; 0
    2d26:	19 f0       	breq	.+6      	; 0x2d2e <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2d28:	be 01       	movw	r22, r28
    2d2a:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <_ZN8frt_task20print_status_in_listEP8emstream>
=======
    2e6c:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <last_created_task_pointer>
    2e70:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <last_created_task_pointer+0x1>
    2e74:	00 97       	sbiw	r24, 0x00	; 0
    2e76:	19 f0       	breq	.+6      	; 0x2e7e <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2e78:	be 01       	movw	r22, r28
    2e7a:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <_ZN8frt_task20print_status_in_listEP8emstream>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
<<<<<<< HEAD
    2d2e:	0e 94 03 10 	call	0x2006	; 0x2006 <xTaskGetIdleTaskHandle>
    2d32:	0e 94 6e 13 	call	0x26dc	; 0x26dc <uxTaskGetStackHighWaterMark>
    2d36:	18 2f       	mov	r17, r24
=======
    2e7e:	0e 94 ab 10 	call	0x2156	; 0x2156 <xTaskGetIdleTaskHandle>
    2e82:	0e 94 16 14 	call	0x282c	; 0x282c <uxTaskGetStackHighWaterMark>
    2e86:	18 2f       	mov	r17, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
<<<<<<< HEAD
    2d38:	6a e0       	ldi	r22, 0x0A	; 10
    2d3a:	ce 01       	movw	r24, r28
    2d3c:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2d40:	ec 01       	movw	r28, r24
    2d42:	68 ec       	ldi	r22, 0xC8	; 200
    2d44:	74 e0       	ldi	r23, 0x04	; 4
    2d46:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2d4a:	61 2f       	mov	r22, r17
    2d4c:	ce 01       	movw	r24, r28
    2d4e:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2d52:	6a e0       	ldi	r22, 0x0A	; 10
    2d54:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2d58:	ec 01       	movw	r28, r24
    2d5a:	66 ec       	ldi	r22, 0xC6	; 198
    2d5c:	74 e0       	ldi	r23, 0x04	; 4
    2d5e:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    2d62:	64 e6       	ldi	r22, 0x64	; 100
    2d64:	70 e0       	ldi	r23, 0x00	; 0
    2d66:	ce 01       	movw	r24, r28
    2d68:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsEj>
    2d6c:	6a e0       	ldi	r22, 0x0A	; 10
    2d6e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    2d72:	ec 01       	movw	r28, r24
    2d74:	63 ec       	ldi	r22, 0xC3	; 195
    2d76:	74 e0       	ldi	r23, 0x04	; 4
    2d78:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
=======
    2e88:	6a e0       	ldi	r22, 0x0A	; 10
    2e8a:	ce 01       	movw	r24, r28
    2e8c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2e90:	ec 01       	movw	r28, r24
    2e92:	6c ec       	ldi	r22, 0xCC	; 204
    2e94:	74 e0       	ldi	r23, 0x04	; 4
    2e96:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e9a:	61 2f       	mov	r22, r17
    2e9c:	ce 01       	movw	r24, r28
    2e9e:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2ea2:	6a e0       	ldi	r22, 0x0A	; 10
    2ea4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ea8:	ec 01       	movw	r28, r24
    2eaa:	6a ec       	ldi	r22, 0xCA	; 202
    2eac:	74 e0       	ldi	r23, 0x04	; 4
    2eae:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    2eb2:	64 e6       	ldi	r22, 0x64	; 100
    2eb4:	70 e0       	ldi	r23, 0x00	; 0
    2eb6:	ce 01       	movw	r24, r28
    2eb8:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    2ebc:	6a e0       	ldi	r22, 0x0A	; 10
    2ebe:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    2ec2:	ec 01       	movw	r28, r24
    2ec4:	67 ec       	ldi	r22, 0xC7	; 199
    2ec6:	74 e0       	ldi	r23, 0x04	; 4
    2ec8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
<<<<<<< HEAD
    2d7c:	66 e0       	ldi	r22, 0x06	; 6
    2d7e:	ce 01       	movw	r24, r28
    2d80:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
}
    2d84:	df 91       	pop	r29
    2d86:	cf 91       	pop	r28
    2d88:	1f 91       	pop	r17
    2d8a:	0f 91       	pop	r16
    2d8c:	08 95       	ret

00002d8e <_ZN14frt_text_queue7getcharEv>:
=======
    2ecc:	66 e0       	ldi	r22, 0x06	; 6
    2ece:	ce 01       	movw	r24, r28
    2ed0:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
}
    2ed4:	df 91       	pop	r29
    2ed6:	cf 91       	pop	r28
    2ed8:	1f 91       	pop	r17
    2eda:	0f 91       	pop	r16
    2edc:	08 95       	ret

00002ede <_ZN14frt_text_queue7getcharEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
<<<<<<< HEAD
    2d8e:	0f 93       	push	r16
    2d90:	cf 93       	push	r28
    2d92:	df 93       	push	r29
    2d94:	1f 92       	push	r1
    2d96:	cd b7       	in	r28, 0x3d	; 61
    2d98:	de b7       	in	r29, 0x3e	; 62
=======
    2ede:	0f 93       	push	r16
    2ee0:	cf 93       	push	r28
    2ee2:	df 93       	push	r29
    2ee4:	1f 92       	push	r1
    2ee6:	cd b7       	in	r28, 0x3d	; 61
    2ee8:	de b7       	in	r29, 0x3e	; 62
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
<<<<<<< HEAD
    2d9a:	00 e0       	ldi	r16, 0x00	; 0
    2d9c:	2f ef       	ldi	r18, 0xFF	; 255
    2d9e:	3f ef       	ldi	r19, 0xFF	; 255
    2da0:	a9 01       	movw	r20, r18
    2da2:	be 01       	movw	r22, r28
    2da4:	6f 5f       	subi	r22, 0xFF	; 255
    2da6:	7f 4f       	sbci	r23, 0xFF	; 255
    2da8:	fc 01       	movw	r30, r24
    2daa:	80 85       	ldd	r24, Z+8	; 0x08
    2dac:	91 85       	ldd	r25, Z+9	; 0x09
    2dae:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <xQueueGenericReceive>
    2db2:	81 30       	cpi	r24, 0x01	; 1
    2db4:	19 f4       	brne	.+6      	; 0x2dbc <_ZN14frt_text_queue7getcharEv+0x2e>
=======
    2eea:	00 e0       	ldi	r16, 0x00	; 0
    2eec:	2f ef       	ldi	r18, 0xFF	; 255
    2eee:	3f ef       	ldi	r19, 0xFF	; 255
    2ef0:	a9 01       	movw	r20, r18
    2ef2:	be 01       	movw	r22, r28
    2ef4:	6f 5f       	subi	r22, 0xFF	; 255
    2ef6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ef8:	fc 01       	movw	r30, r24
    2efa:	80 85       	ldd	r24, Z+8	; 0x08
    2efc:	91 85       	ldd	r25, Z+9	; 0x09
    2efe:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <xQueueGenericReceive>
    2f02:	81 30       	cpi	r24, 0x01	; 1
    2f04:	19 f4       	brne	.+6      	; 0x2f0c <_ZN14frt_text_queue7getcharEv+0x2e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
<<<<<<< HEAD
    2db6:	89 81       	ldd	r24, Y+1	; 0x01
    2db8:	90 e0       	ldi	r25, 0x00	; 0
    2dba:	02 c0       	rjmp	.+4      	; 0x2dc0 <_ZN14frt_text_queue7getcharEv+0x32>
=======
    2f06:	89 81       	ldd	r24, Y+1	; 0x01
    2f08:	90 e0       	ldi	r25, 0x00	; 0
    2f0a:	02 c0       	rjmp	.+4      	; 0x2f10 <_ZN14frt_text_queue7getcharEv+0x32>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
<<<<<<< HEAD
    2dbc:	8f ef       	ldi	r24, 0xFF	; 255
    2dbe:	9f ef       	ldi	r25, 0xFF	; 255
=======
    2f0c:	8f ef       	ldi	r24, 0xFF	; 255
    2f0e:	9f ef       	ldi	r25, 0xFF	; 255
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
<<<<<<< HEAD
    2dc0:	0f 90       	pop	r0
    2dc2:	df 91       	pop	r29
    2dc4:	cf 91       	pop	r28
    2dc6:	0f 91       	pop	r16
    2dc8:	08 95       	ret

00002dca <_ZN14frt_text_queue14check_for_charEv>:
=======
    2f10:	0f 90       	pop	r0
    2f12:	df 91       	pop	r29
    2f14:	cf 91       	pop	r28
    2f16:	0f 91       	pop	r16
    2f18:	08 95       	ret

00002f1a <_ZN14frt_text_queue14check_for_charEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
<<<<<<< HEAD
    2dca:	fc 01       	movw	r30, r24
    2dcc:	80 85       	ldd	r24, Z+8	; 0x08
    2dce:	91 85       	ldd	r25, Z+9	; 0x09
    2dd0:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <uxQueueMessagesWaiting>
    2dd4:	91 e0       	ldi	r25, 0x01	; 1
    2dd6:	81 11       	cpse	r24, r1
    2dd8:	01 c0       	rjmp	.+2      	; 0x2ddc <_ZN14frt_text_queue14check_for_charEv+0x12>
    2dda:	90 e0       	ldi	r25, 0x00	; 0
=======
    2f1a:	fc 01       	movw	r30, r24
    2f1c:	80 85       	ldd	r24, Z+8	; 0x08
    2f1e:	91 85       	ldd	r25, Z+9	; 0x09
    2f20:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <uxQueueMessagesWaiting>
    2f24:	91 e0       	ldi	r25, 0x01	; 1
    2f26:	81 11       	cpse	r24, r1
    2f28:	01 c0       	rjmp	.+2      	; 0x2f2c <_ZN14frt_text_queue14check_for_charEv+0x12>
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
		return (false);
	}
	return (true);
}
<<<<<<< HEAD
    2ddc:	89 2f       	mov	r24, r25
    2dde:	08 95       	ret

00002de0 <_ZN14frt_text_queue7putcharEc>:
=======
    2f2c:	89 2f       	mov	r24, r25
    2f2e:	08 95       	ret

00002f30 <_ZN14frt_text_queue7putcharEc>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
<<<<<<< HEAD
    2de0:	0f 93       	push	r16
    2de2:	cf 93       	push	r28
    2de4:	df 93       	push	r29
    2de6:	1f 92       	push	r1
    2de8:	cd b7       	in	r28, 0x3d	; 61
    2dea:	de b7       	in	r29, 0x3e	; 62
    2dec:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2dee:	fc 01       	movw	r30, r24
    2df0:	22 85       	ldd	r18, Z+10	; 0x0a
    2df2:	33 85       	ldd	r19, Z+11	; 0x0b
    2df4:	44 85       	ldd	r20, Z+12	; 0x0c
    2df6:	55 85       	ldd	r21, Z+13	; 0x0d
    2df8:	00 e0       	ldi	r16, 0x00	; 0
    2dfa:	be 01       	movw	r22, r28
    2dfc:	6f 5f       	subi	r22, 0xFF	; 255
    2dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    2e00:	80 85       	ldd	r24, Z+8	; 0x08
    2e02:	91 85       	ldd	r25, Z+9	; 0x09
    2e04:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xQueueGenericSend>
    2e08:	91 e0       	ldi	r25, 0x01	; 1
    2e0a:	81 11       	cpse	r24, r1
    2e0c:	01 c0       	rjmp	.+2      	; 0x2e10 <_ZN14frt_text_queue7putcharEc+0x30>
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
=======
    2f30:	0f 93       	push	r16
    2f32:	cf 93       	push	r28
    2f34:	df 93       	push	r29
    2f36:	1f 92       	push	r1
    2f38:	cd b7       	in	r28, 0x3d	; 61
    2f3a:	de b7       	in	r29, 0x3e	; 62
    2f3c:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2f3e:	fc 01       	movw	r30, r24
    2f40:	22 85       	ldd	r18, Z+10	; 0x0a
    2f42:	33 85       	ldd	r19, Z+11	; 0x0b
    2f44:	44 85       	ldd	r20, Z+12	; 0x0c
    2f46:	55 85       	ldd	r21, Z+13	; 0x0d
    2f48:	00 e0       	ldi	r16, 0x00	; 0
    2f4a:	be 01       	movw	r22, r28
    2f4c:	6f 5f       	subi	r22, 0xFF	; 255
    2f4e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f50:	80 85       	ldd	r24, Z+8	; 0x08
    2f52:	91 85       	ldd	r25, Z+9	; 0x09
    2f54:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <xQueueGenericSend>
    2f58:	91 e0       	ldi	r25, 0x01	; 1
    2f5a:	81 11       	cpse	r24, r1
    2f5c:	01 c0       	rjmp	.+2      	; 0x2f60 <_ZN14frt_text_queue7putcharEc+0x30>
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
<<<<<<< HEAD
    2e10:	89 2f       	mov	r24, r25
    2e12:	0f 90       	pop	r0
    2e14:	df 91       	pop	r29
    2e16:	cf 91       	pop	r28
    2e18:	0f 91       	pop	r16
    2e1a:	08 95       	ret

00002e1c <_ZN14frt_text_queueC1EjP8emstreamm>:
=======
    2f60:	89 2f       	mov	r24, r25
    2f62:	0f 90       	pop	r0
    2f64:	df 91       	pop	r29
    2f66:	cf 91       	pop	r28
    2f68:	0f 91       	pop	r16
    2f6a:	08 95       	ret

00002f6c <_ZN14frt_text_queueC1EjP8emstreamm>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
<<<<<<< HEAD
    2e1c:	8f 92       	push	r8
    2e1e:	9f 92       	push	r9
    2e20:	bf 92       	push	r11
    2e22:	cf 92       	push	r12
    2e24:	df 92       	push	r13
    2e26:	ef 92       	push	r14
    2e28:	ff 92       	push	r15
    2e2a:	0f 93       	push	r16
    2e2c:	1f 93       	push	r17
    2e2e:	cf 93       	push	r28
    2e30:	df 93       	push	r29
    2e32:	ec 01       	movw	r28, r24
    2e34:	b6 2e       	mov	r11, r22
    2e36:	4a 01       	movw	r8, r20
    2e38:	68 01       	movw	r12, r16
    2e3a:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2e3c:	0e 94 48 19 	call	0x3290	; 0x3290 <_ZN8emstreamC1Ev>
    2e40:	8f e3       	ldi	r24, 0x3F	; 63
    2e42:	90 e2       	ldi	r25, 0x20	; 32
    2e44:	88 83       	st	Y, r24
    2e46:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2e48:	8e 86       	std	Y+14, r8	; 0x0e
    2e4a:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2e4c:	40 e0       	ldi	r20, 0x00	; 0
    2e4e:	61 e0       	ldi	r22, 0x01	; 1
    2e50:	8b 2d       	mov	r24, r11
    2e52:	0e 94 b9 0c 	call	0x1972	; 0x1972 <xQueueGenericCreate>
    2e56:	88 87       	std	Y+8, r24	; 0x08
    2e58:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2e5a:	ca 86       	std	Y+10, r12	; 0x0a
    2e5c:	db 86       	std	Y+11, r13	; 0x0b
    2e5e:	ec 86       	std	Y+12, r14	; 0x0c
    2e60:	fd 86       	std	Y+13, r15	; 0x0d
}
    2e62:	df 91       	pop	r29
    2e64:	cf 91       	pop	r28
    2e66:	1f 91       	pop	r17
    2e68:	0f 91       	pop	r16
    2e6a:	ff 90       	pop	r15
    2e6c:	ef 90       	pop	r14
    2e6e:	df 90       	pop	r13
    2e70:	cf 90       	pop	r12
    2e72:	bf 90       	pop	r11
    2e74:	9f 90       	pop	r9
    2e76:	8f 90       	pop	r8
    2e78:	08 95       	ret

00002e7a <_ZN10time_stamp12get_microsecEv>:
=======
    2f6c:	8f 92       	push	r8
    2f6e:	9f 92       	push	r9
    2f70:	bf 92       	push	r11
    2f72:	cf 92       	push	r12
    2f74:	df 92       	push	r13
    2f76:	ef 92       	push	r14
    2f78:	ff 92       	push	r15
    2f7a:	0f 93       	push	r16
    2f7c:	1f 93       	push	r17
    2f7e:	cf 93       	push	r28
    2f80:	df 93       	push	r29
    2f82:	ec 01       	movw	r28, r24
    2f84:	b6 2e       	mov	r11, r22
    2f86:	4a 01       	movw	r8, r20
    2f88:	68 01       	movw	r12, r16
    2f8a:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f8c:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <_ZN8emstreamC1Ev>
    2f90:	8d e6       	ldi	r24, 0x6D	; 109
    2f92:	90 e2       	ldi	r25, 0x20	; 32
    2f94:	88 83       	st	Y, r24
    2f96:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f98:	8e 86       	std	Y+14, r8	; 0x0e
    2f9a:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f9c:	40 e0       	ldi	r20, 0x00	; 0
    2f9e:	61 e0       	ldi	r22, 0x01	; 1
    2fa0:	8b 2d       	mov	r24, r11
    2fa2:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <xQueueGenericCreate>
    2fa6:	88 87       	std	Y+8, r24	; 0x08
    2fa8:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2faa:	ca 86       	std	Y+10, r12	; 0x0a
    2fac:	db 86       	std	Y+11, r13	; 0x0b
    2fae:	ec 86       	std	Y+12, r14	; 0x0c
    2fb0:	fd 86       	std	Y+13, r15	; 0x0d
}
    2fb2:	df 91       	pop	r29
    2fb4:	cf 91       	pop	r28
    2fb6:	1f 91       	pop	r17
    2fb8:	0f 91       	pop	r16
    2fba:	ff 90       	pop	r15
    2fbc:	ef 90       	pop	r14
    2fbe:	df 90       	pop	r13
    2fc0:	cf 90       	pop	r12
    2fc2:	bf 90       	pop	r11
    2fc4:	9f 90       	pop	r9
    2fc6:	8f 90       	pop	r8
    2fc8:	08 95       	ret

00002fca <_ZN10time_stamp12get_microsecEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
<<<<<<< HEAD
    2e7a:	cf 92       	push	r12
    2e7c:	df 92       	push	r13
    2e7e:	ef 92       	push	r14
    2e80:	ff 92       	push	r15
    2e82:	cf 93       	push	r28
    2e84:	df 93       	push	r29
    2e86:	ec 01       	movw	r28, r24
=======
    2fca:	cf 92       	push	r12
    2fcc:	df 92       	push	r13
    2fce:	ef 92       	push	r14
    2fd0:	ff 92       	push	r15
    2fd2:	cf 93       	push	r28
    2fd4:	df 93       	push	r29
    2fd6:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
<<<<<<< HEAD
    2e88:	68 81       	ld	r22, Y
    2e8a:	79 81       	ldd	r23, Y+1	; 0x01
    2e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e8e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e90:	0f 2e       	mov	r0, r31
    2e92:	f8 ee       	ldi	r31, 0xE8	; 232
    2e94:	cf 2e       	mov	r12, r31
    2e96:	f3 e0       	ldi	r31, 0x03	; 3
    2e98:	df 2e       	mov	r13, r31
    2e9a:	e1 2c       	mov	r14, r1
    2e9c:	f1 2c       	mov	r15, r1
    2e9e:	f0 2d       	mov	r31, r0
    2ea0:	a7 01       	movw	r20, r14
    2ea2:	96 01       	movw	r18, r12
    2ea4:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <__udivmodsi4>
    2ea8:	9b 01       	movw	r18, r22
    2eaa:	ac 01       	movw	r20, r24
    2eac:	60 e4       	ldi	r22, 0x40	; 64
    2eae:	72 e4       	ldi	r23, 0x42	; 66
    2eb0:	8f e0       	ldi	r24, 0x0F	; 15
    2eb2:	90 e0       	ldi	r25, 0x00	; 0
    2eb4:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <__mulsi3>
    2eb8:	a7 01       	movw	r20, r14
    2eba:	96 01       	movw	r18, r12
    2ebc:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <__udivmodsi4>
    2ec0:	69 01       	movw	r12, r18
    2ec2:	7a 01       	movw	r14, r20
    2ec4:	ac 81       	ldd	r26, Y+4	; 0x04
    2ec6:	bd 81       	ldd	r27, Y+5	; 0x05
    2ec8:	20 e4       	ldi	r18, 0x40	; 64
    2eca:	32 e4       	ldi	r19, 0x42	; 66
    2ecc:	4f e0       	ldi	r20, 0x0F	; 15
    2ece:	50 e0       	ldi	r21, 0x00	; 0
    2ed0:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <__muluhisi3>
    2ed4:	20 e0       	ldi	r18, 0x00	; 0
    2ed6:	38 e4       	ldi	r19, 0x48	; 72
    2ed8:	48 ee       	ldi	r20, 0xE8	; 232
    2eda:	51 e0       	ldi	r21, 0x01	; 1
    2edc:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <__udivmodsi4>
    2ee0:	c7 01       	movw	r24, r14
    2ee2:	b6 01       	movw	r22, r12
    2ee4:	62 0f       	add	r22, r18
    2ee6:	73 1f       	adc	r23, r19
    2ee8:	84 1f       	adc	r24, r20
    2eea:	95 1f       	adc	r25, r21
}
    2eec:	df 91       	pop	r29
    2eee:	cf 91       	pop	r28
    2ef0:	ff 90       	pop	r15
    2ef2:	ef 90       	pop	r14
    2ef4:	df 90       	pop	r13
    2ef6:	cf 90       	pop	r12
    2ef8:	08 95       	ret

00002efa <_ZlsR8emstreamR10time_stamp>:
=======
    2fd8:	68 81       	ld	r22, Y
    2fda:	79 81       	ldd	r23, Y+1	; 0x01
    2fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    2fde:	9b 81       	ldd	r25, Y+3	; 0x03
    2fe0:	0f 2e       	mov	r0, r31
    2fe2:	f8 ee       	ldi	r31, 0xE8	; 232
    2fe4:	cf 2e       	mov	r12, r31
    2fe6:	f3 e0       	ldi	r31, 0x03	; 3
    2fe8:	df 2e       	mov	r13, r31
    2fea:	e1 2c       	mov	r14, r1
    2fec:	f1 2c       	mov	r15, r1
    2fee:	f0 2d       	mov	r31, r0
    2ff0:	a7 01       	movw	r20, r14
    2ff2:	96 01       	movw	r18, r12
    2ff4:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    2ff8:	9b 01       	movw	r18, r22
    2ffa:	ac 01       	movw	r20, r24
    2ffc:	60 e4       	ldi	r22, 0x40	; 64
    2ffe:	72 e4       	ldi	r23, 0x42	; 66
    3000:	8f e0       	ldi	r24, 0x0F	; 15
    3002:	90 e0       	ldi	r25, 0x00	; 0
    3004:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <__mulsi3>
    3008:	a7 01       	movw	r20, r14
    300a:	96 01       	movw	r18, r12
    300c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    3010:	69 01       	movw	r12, r18
    3012:	7a 01       	movw	r14, r20
    3014:	ac 81       	ldd	r26, Y+4	; 0x04
    3016:	bd 81       	ldd	r27, Y+5	; 0x05
    3018:	20 e4       	ldi	r18, 0x40	; 64
    301a:	32 e4       	ldi	r19, 0x42	; 66
    301c:	4f e0       	ldi	r20, 0x0F	; 15
    301e:	50 e0       	ldi	r21, 0x00	; 0
    3020:	0e 94 39 20 	call	0x4072	; 0x4072 <__muluhisi3>
    3024:	20 e0       	ldi	r18, 0x00	; 0
    3026:	38 e4       	ldi	r19, 0x48	; 72
    3028:	48 ee       	ldi	r20, 0xE8	; 232
    302a:	51 e0       	ldi	r21, 0x01	; 1
    302c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    3030:	c7 01       	movw	r24, r14
    3032:	b6 01       	movw	r22, r12
    3034:	62 0f       	add	r22, r18
    3036:	73 1f       	adc	r23, r19
    3038:	84 1f       	adc	r24, r20
    303a:	95 1f       	adc	r25, r21
}
    303c:	df 91       	pop	r29
    303e:	cf 91       	pop	r28
    3040:	ff 90       	pop	r15
    3042:	ef 90       	pop	r14
    3044:	df 90       	pop	r13
    3046:	cf 90       	pop	r12
    3048:	08 95       	ret

0000304a <_ZlsR8emstreamR10time_stamp>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
<<<<<<< HEAD
    2efa:	cf 92       	push	r12
    2efc:	df 92       	push	r13
    2efe:	ef 92       	push	r14
    2f00:	ff 92       	push	r15
    2f02:	0f 93       	push	r16
    2f04:	1f 93       	push	r17
    2f06:	cf 93       	push	r28
    2f08:	df 93       	push	r29
    2f0a:	cd b7       	in	r28, 0x3d	; 61
    2f0c:	de b7       	in	r29, 0x3e	; 62
    2f0e:	2f 97       	sbiw	r28, 0x0f	; 15
    2f10:	cd bf       	out	0x3d, r28	; 61
    2f12:	de bf       	out	0x3e, r29	; 62
    2f14:	6c 01       	movw	r12, r24
    2f16:	8b 01       	movw	r16, r22
=======
    304a:	cf 92       	push	r12
    304c:	df 92       	push	r13
    304e:	ef 92       	push	r14
    3050:	ff 92       	push	r15
    3052:	0f 93       	push	r16
    3054:	1f 93       	push	r17
    3056:	cf 93       	push	r28
    3058:	df 93       	push	r29
    305a:	cd b7       	in	r28, 0x3d	; 61
    305c:	de b7       	in	r29, 0x3e	; 62
    305e:	2f 97       	sbiw	r28, 0x0f	; 15
    3060:	cd bf       	out	0x3d, r28	; 61
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	6c 01       	movw	r12, r24
    3066:	8b 01       	movw	r16, r22
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
<<<<<<< HEAD
    2f18:	db 01       	movw	r26, r22
    2f1a:	6d 91       	ld	r22, X+
    2f1c:	7d 91       	ld	r23, X+
    2f1e:	8d 91       	ld	r24, X+
    2f20:	9c 91       	ld	r25, X
    2f22:	28 ee       	ldi	r18, 0xE8	; 232
    2f24:	33 e0       	ldi	r19, 0x03	; 3
    2f26:	40 e0       	ldi	r20, 0x00	; 0
    2f28:	50 e0       	ldi	r21, 0x00	; 0
    2f2a:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <__udivmodsi4>
    2f2e:	ba 01       	movw	r22, r20
    2f30:	a9 01       	movw	r20, r18
    2f32:	c6 01       	movw	r24, r12
    2f34:	0e 94 31 1a 	call	0x3462	; 0x3462 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2f38:	d6 01       	movw	r26, r12
    2f3a:	ed 91       	ld	r30, X+
    2f3c:	fc 91       	ld	r31, X
    2f3e:	02 80       	ldd	r0, Z+2	; 0x02
    2f40:	f3 81       	ldd	r31, Z+3	; 0x03
    2f42:	e0 2d       	mov	r30, r0
    2f44:	6e e2       	ldi	r22, 0x2E	; 46
    2f46:	c6 01       	movw	r24, r12
    2f48:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2f4a:	c8 01       	movw	r24, r16
    2f4c:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <_ZN10time_stamp12get_microsecEv>
    2f50:	8e 01       	movw	r16, r28
    2f52:	09 5f       	subi	r16, 0xF9	; 249
    2f54:	1f 4f       	sbci	r17, 0xFF	; 255
    2f56:	fe 01       	movw	r30, r28
    2f58:	31 96       	adiw	r30, 0x01	; 1
    2f5a:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2f5c:	2a e0       	ldi	r18, 0x0A	; 10
    2f5e:	30 e0       	ldi	r19, 0x00	; 0
    2f60:	40 e0       	ldi	r20, 0x00	; 0
    2f62:	50 e0       	ldi	r21, 0x00	; 0
    2f64:	0e 94 15 1f 	call	0x3e2a	; 0x3e2a <__divmodsi4>
    2f68:	e6 2f       	mov	r30, r22
    2f6a:	28 87       	std	Y+8, r18	; 0x08
    2f6c:	39 87       	std	Y+9, r19	; 0x09
    2f6e:	4a 87       	std	Y+10, r20	; 0x0a
    2f70:	5b 87       	std	Y+11, r21	; 0x0b
    2f72:	68 85       	ldd	r22, Y+8	; 0x08
    2f74:	79 85       	ldd	r23, Y+9	; 0x09
    2f76:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f78:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2f7a:	20 e3       	ldi	r18, 0x30	; 48
    2f7c:	2e 0f       	add	r18, r30
    2f7e:	d8 01       	movw	r26, r16
    2f80:	2e 93       	st	-X, r18
    2f82:	8d 01       	movw	r16, r26
=======
    3068:	db 01       	movw	r26, r22
    306a:	6d 91       	ld	r22, X+
    306c:	7d 91       	ld	r23, X+
    306e:	8d 91       	ld	r24, X+
    3070:	9c 91       	ld	r25, X
    3072:	28 ee       	ldi	r18, 0xE8	; 232
    3074:	33 e0       	ldi	r19, 0x03	; 3
    3076:	40 e0       	ldi	r20, 0x00	; 0
    3078:	50 e0       	ldi	r21, 0x00	; 0
    307a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    307e:	ba 01       	movw	r22, r20
    3080:	a9 01       	movw	r20, r18
    3082:	c6 01       	movw	r24, r12
    3084:	0e 94 04 1b 	call	0x3608	; 0x3608 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3088:	d6 01       	movw	r26, r12
    308a:	ed 91       	ld	r30, X+
    308c:	fc 91       	ld	r31, X
    308e:	02 80       	ldd	r0, Z+2	; 0x02
    3090:	f3 81       	ldd	r31, Z+3	; 0x03
    3092:	e0 2d       	mov	r30, r0
    3094:	6e e2       	ldi	r22, 0x2E	; 46
    3096:	c6 01       	movw	r24, r12
    3098:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    309a:	c8 01       	movw	r24, r16
    309c:	0e 94 e5 17 	call	0x2fca	; 0x2fca <_ZN10time_stamp12get_microsecEv>
    30a0:	8e 01       	movw	r16, r28
    30a2:	09 5f       	subi	r16, 0xF9	; 249
    30a4:	1f 4f       	sbci	r17, 0xFF	; 255
    30a6:	fe 01       	movw	r30, r28
    30a8:	31 96       	adiw	r30, 0x01	; 1
    30aa:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    30ac:	2a e0       	ldi	r18, 0x0A	; 10
    30ae:	30 e0       	ldi	r19, 0x00	; 0
    30b0:	40 e0       	ldi	r20, 0x00	; 0
    30b2:	50 e0       	ldi	r21, 0x00	; 0
    30b4:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <__divmodsi4>
    30b8:	e6 2f       	mov	r30, r22
    30ba:	28 87       	std	Y+8, r18	; 0x08
    30bc:	39 87       	std	Y+9, r19	; 0x09
    30be:	4a 87       	std	Y+10, r20	; 0x0a
    30c0:	5b 87       	std	Y+11, r21	; 0x0b
    30c2:	68 85       	ldd	r22, Y+8	; 0x08
    30c4:	79 85       	ldd	r23, Y+9	; 0x09
    30c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    30c8:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    30ca:	20 e3       	ldi	r18, 0x30	; 48
    30cc:	2e 0f       	add	r18, r30
    30ce:	d8 01       	movw	r26, r16
    30d0:	2e 93       	st	-X, r18
    30d2:	8d 01       	movw	r16, r26
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
<<<<<<< HEAD
    2f84:	ae 15       	cp	r26, r14
    2f86:	bf 05       	cpc	r27, r15
    2f88:	49 f7       	brne	.-46     	; 0x2f5c <_ZlsR8emstreamR10time_stamp+0x62>
=======
    30d4:	ae 15       	cp	r26, r14
    30d6:	bf 05       	cpc	r27, r15
    30d8:	49 f7       	brne	.-46     	; 0x30ac <_ZlsR8emstreamR10time_stamp+0x62>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
<<<<<<< HEAD
    2f8a:	1f 82       	std	Y+7, r1	; 0x07
    2f8c:	be 01       	movw	r22, r28
    2f8e:	6f 5f       	subi	r22, 0xFF	; 255
    2f90:	7f 4f       	sbci	r23, 0xFF	; 255
    2f92:	c6 01       	movw	r24, r12
    2f94:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
=======
    30da:	1f 82       	std	Y+7, r1	; 0x07
    30dc:	be 01       	movw	r22, r28
    30de:	6f 5f       	subi	r22, 0xFF	; 255
    30e0:	7f 4f       	sbci	r23, 0xFF	; 255
    30e2:	c6 01       	movw	r24, r12
    30e4:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
<<<<<<< HEAD
    2f98:	c6 01       	movw	r24, r12
    2f9a:	2f 96       	adiw	r28, 0x0f	; 15
    2f9c:	cd bf       	out	0x3d, r28	; 61
    2f9e:	de bf       	out	0x3e, r29	; 62
    2fa0:	df 91       	pop	r29
    2fa2:	cf 91       	pop	r28
    2fa4:	1f 91       	pop	r17
    2fa6:	0f 91       	pop	r16
    2fa8:	ff 90       	pop	r15
    2faa:	ef 90       	pop	r14
    2fac:	df 90       	pop	r13
    2fae:	cf 90       	pop	r12
    2fb0:	08 95       	ret

00002fb2 <_ZN10time_stamp10set_to_nowEv>:
=======
    30e8:	c6 01       	movw	r24, r12
    30ea:	2f 96       	adiw	r28, 0x0f	; 15
    30ec:	cd bf       	out	0x3d, r28	; 61
    30ee:	de bf       	out	0x3e, r29	; 62
    30f0:	df 91       	pop	r29
    30f2:	cf 91       	pop	r28
    30f4:	1f 91       	pop	r17
    30f6:	0f 91       	pop	r16
    30f8:	ff 90       	pop	r15
    30fa:	ef 90       	pop	r14
    30fc:	df 90       	pop	r13
    30fe:	cf 90       	pop	r12
    3100:	08 95       	ret

00003102 <_ZN10time_stamp10set_to_nowEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
<<<<<<< HEAD
    2fb2:	cf 93       	push	r28
    2fb4:	df 93       	push	r29
    2fb6:	ec 01       	movw	r28, r24
=======
    3102:	cf 93       	push	r28
    3104:	df 93       	push	r29
    3106:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
<<<<<<< HEAD
    2fb8:	0f b6       	in	r0, 0x3f	; 63
    2fba:	f8 94       	cli
    2fbc:	0f 92       	push	r0
=======
    3108:	0f b6       	in	r0, 0x3f	; 63
    310a:	f8 94       	cli
    310c:	0f 92       	push	r0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
<<<<<<< HEAD
    2fbe:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2fc2:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2fc6:	8c 83       	std	Y+4, r24	; 0x04
    2fc8:	9d 83       	std	Y+5, r25	; 0x05
=======
    310e:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3112:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3116:	8c 83       	std	Y+4, r24	; 0x04
    3118:	9d 83       	std	Y+5, r25	; 0x05
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
<<<<<<< HEAD
    2fca:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <xTaskGetTickCount>
    2fce:	68 83       	st	Y, r22
    2fd0:	79 83       	std	Y+1, r23	; 0x01
    2fd2:	8a 83       	std	Y+2, r24	; 0x02
    2fd4:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2fd6:	0f 90       	pop	r0
    2fd8:	0f be       	out	0x3f, r0	; 63
=======
    311a:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskGetTickCount>
    311e:	68 83       	st	Y, r22
    3120:	79 83       	std	Y+1, r23	; 0x01
    3122:	8a 83       	std	Y+2, r24	; 0x02
    3124:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3126:	0f 90       	pop	r0
    3128:	0f be       	out	0x3f, r0	; 63
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// Return a reference to this object
	return (*this);
}
<<<<<<< HEAD
    2fda:	ce 01       	movw	r24, r28
    2fdc:	df 91       	pop	r29
    2fde:	cf 91       	pop	r28
    2fe0:	08 95       	ret

00002fe2 <_Z15hex_dump_memoryPhS_P8emstreambh>:
=======
    312a:	ce 01       	movw	r24, r28
    312c:	df 91       	pop	r29
    312e:	cf 91       	pop	r28
    3130:	08 95       	ret

00003132 <_Z15hex_dump_memoryPhS_P8emstreambh>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
<<<<<<< HEAD
    2fe2:	5f 92       	push	r5
    2fe4:	6f 92       	push	r6
    2fe6:	7f 92       	push	r7
    2fe8:	8f 92       	push	r8
    2fea:	9f 92       	push	r9
    2fec:	af 92       	push	r10
    2fee:	bf 92       	push	r11
    2ff0:	cf 92       	push	r12
    2ff2:	df 92       	push	r13
    2ff4:	ef 92       	push	r14
    2ff6:	ff 92       	push	r15
    2ff8:	0f 93       	push	r16
    2ffa:	1f 93       	push	r17
    2ffc:	cf 93       	push	r28
    2ffe:	df 93       	push	r29
    3000:	5c 01       	movw	r10, r24
    3002:	4b 01       	movw	r8, r22
    3004:	7a 01       	movw	r14, r20
    3006:	12 2f       	mov	r17, r18
    3008:	70 2e       	mov	r7, r16
=======
    3132:	5f 92       	push	r5
    3134:	6f 92       	push	r6
    3136:	7f 92       	push	r7
    3138:	8f 92       	push	r8
    313a:	9f 92       	push	r9
    313c:	af 92       	push	r10
    313e:	bf 92       	push	r11
    3140:	cf 92       	push	r12
    3142:	df 92       	push	r13
    3144:	ef 92       	push	r14
    3146:	ff 92       	push	r15
    3148:	0f 93       	push	r16
    314a:	1f 93       	push	r17
    314c:	cf 93       	push	r28
    314e:	df 93       	push	r29
    3150:	5c 01       	movw	r10, r24
    3152:	4b 01       	movw	r8, r22
    3154:	7a 01       	movw	r14, r20
    3156:	12 2f       	mov	r17, r18
    3158:	70 2e       	mov	r7, r16
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
<<<<<<< HEAD
    300a:	63 e0       	ldi	r22, 0x03	; 3
    300c:	ca 01       	movw	r24, r20
    300e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3012:	a8 14       	cp	r10, r8
    3014:	b9 04       	cpc	r11, r9
    3016:	08 f0       	brcs	.+2      	; 0x301a <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3018:	7d c0       	rjmp	.+250    	; 0x3114 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    301a:	65 01       	movw	r12, r10
    301c:	84 e1       	ldi	r24, 0x14	; 20
    301e:	c8 0e       	add	r12, r24
    3020:	d1 1c       	adc	r13, r1
    3022:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3024:	6a 2c       	mov	r6, r10
    3026:	5b 2c       	mov	r5, r11
    3028:	b5 01       	movw	r22, r10
    302a:	c7 01       	movw	r24, r14
    302c:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsEj>
    3030:	6a e0       	ldi	r22, 0x0A	; 10
    3032:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    3036:	65 e4       	ldi	r22, 0x45	; 69
    3038:	75 e0       	ldi	r23, 0x05	; 5
    303a:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
=======
    315a:	63 e0       	ldi	r22, 0x03	; 3
    315c:	ca 01       	movw	r24, r20
    315e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3162:	a8 14       	cp	r10, r8
    3164:	b9 04       	cpc	r11, r9
    3166:	08 f0       	brcs	.+2      	; 0x316a <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3168:	7d c0       	rjmp	.+250    	; 0x3264 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    316a:	65 01       	movw	r12, r10
    316c:	84 e1       	ldi	r24, 0x14	; 20
    316e:	c8 0e       	add	r12, r24
    3170:	d1 1c       	adc	r13, r1
    3172:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3174:	6a 2c       	mov	r6, r10
    3176:	5b 2c       	mov	r5, r11
    3178:	b5 01       	movw	r22, r10
    317a:	c7 01       	movw	r24, r14
    317c:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    3180:	6a e0       	ldi	r22, 0x0A	; 10
    3182:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    3186:	69 e4       	ldi	r22, 0x49	; 73
    3188:	75 e0       	ldi	r23, 0x05	; 5
    318a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
<<<<<<< HEAD
    303e:	11 23       	and	r17, r17
    3040:	09 f4       	brne	.+2      	; 0x3044 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3042:	6d c0       	rjmp	.+218    	; 0x311e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3044:	00 23       	and	r16, r16
    3046:	09 f4       	brne	.+2      	; 0x304a <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3048:	6a c0       	rjmp	.+212    	; 0x311e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    304a:	6a e0       	ldi	r22, 0x0A	; 10
    304c:	c7 01       	movw	r24, r14
    304e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    3052:	60 e4       	ldi	r22, 0x40	; 64
    3054:	75 e0       	ldi	r23, 0x05	; 5
    3056:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    305a:	61 c0       	rjmp	.+194    	; 0x311e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
=======
    318e:	11 23       	and	r17, r17
    3190:	09 f4       	brne	.+2      	; 0x3194 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3192:	6d c0       	rjmp	.+218    	; 0x326e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3194:	00 23       	and	r16, r16
    3196:	09 f4       	brne	.+2      	; 0x319a <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3198:	6a c0       	rjmp	.+212    	; 0x326e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    319a:	6a e0       	ldi	r22, 0x0A	; 10
    319c:	c7 01       	movw	r24, r14
    319e:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    31a2:	64 e4       	ldi	r22, 0x44	; 68
    31a4:	75 e0       	ldi	r23, 0x05	; 5
    31a6:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    31aa:	61 c0       	rjmp	.+194    	; 0x326e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
<<<<<<< HEAD
    305c:	11 23       	and	r17, r17
    305e:	71 f0       	breq	.+28     	; 0x307c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3060:	01 11       	cpse	r16, r1
    3062:	0c c0       	rjmp	.+24     	; 0x307c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3064:	88 81       	ld	r24, Y
    3066:	87 15       	cp	r24, r7
    3068:	49 f0       	breq	.+18     	; 0x307c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    306a:	6a e0       	ldi	r22, 0x0A	; 10
    306c:	c7 01       	movw	r24, r14
    306e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    3072:	6b e3       	ldi	r22, 0x3B	; 59
    3074:	75 e0       	ldi	r23, 0x05	; 5
    3076:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
=======
    31ac:	11 23       	and	r17, r17
    31ae:	71 f0       	breq	.+28     	; 0x31cc <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    31b0:	01 11       	cpse	r16, r1
    31b2:	0c c0       	rjmp	.+24     	; 0x31cc <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    31b4:	88 81       	ld	r24, Y
    31b6:	87 15       	cp	r24, r7
    31b8:	49 f0       	breq	.+18     	; 0x31cc <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    31ba:	6a e0       	ldi	r22, 0x0A	; 10
    31bc:	c7 01       	movw	r24, r14
    31be:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    31c2:	6f e3       	ldi	r22, 0x3F	; 63
    31c4:	75 e0       	ldi	r23, 0x05	; 5
    31c6:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
<<<<<<< HEAD
    307a:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    307c:	69 91       	ld	r22, Y+
    307e:	c7 01       	movw	r24, r14
    3080:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
=======
    31ca:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    31cc:	69 91       	ld	r22, Y+
    31ce:	c7 01       	movw	r24, r14
    31d0:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
<<<<<<< HEAD
    3084:	dc 01       	movw	r26, r24
    3086:	ed 91       	ld	r30, X+
    3088:	fc 91       	ld	r31, X
    308a:	02 80       	ldd	r0, Z+2	; 0x02
    308c:	f3 81       	ldd	r31, Z+3	; 0x03
    308e:	e0 2d       	mov	r30, r0
    3090:	60 e2       	ldi	r22, 0x20	; 32
    3092:	19 95       	eicall
=======
    31d4:	dc 01       	movw	r26, r24
    31d6:	ed 91       	ld	r30, X+
    31d8:	fc 91       	ld	r31, X
    31da:	02 80       	ldd	r0, Z+2	; 0x02
    31dc:	f3 81       	ldd	r31, Z+3	; 0x03
    31de:	e0 2d       	mov	r30, r0
    31e0:	60 e2       	ldi	r22, 0x20	; 32
    31e2:	19 95       	eicall
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
<<<<<<< HEAD
    3094:	cc 16       	cp	r12, r28
    3096:	dd 06       	cpc	r13, r29
    3098:	09 f7       	brne	.-62     	; 0x305c <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
=======
    31e4:	cc 16       	cp	r12, r28
    31e6:	dd 06       	cpc	r13, r29
    31e8:	09 f7       	brne	.-62     	; 0x31ac <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
<<<<<<< HEAD
    309a:	11 23       	and	r17, r17
    309c:	89 f0       	breq	.+34     	; 0x30c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    309e:	6a e0       	ldi	r22, 0x0A	; 10
    30a0:	c7 01       	movw	r24, r14
    30a2:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    30a6:	ec 01       	movw	r28, r24
=======
    31ea:	11 23       	and	r17, r17
    31ec:	89 f0       	breq	.+34     	; 0x3210 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    31ee:	6a e0       	ldi	r22, 0x0A	; 10
    31f0:	c7 01       	movw	r24, r14
    31f2:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    31f6:	ec 01       	movw	r28, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
<<<<<<< HEAD
    30a8:	65 e3       	ldi	r22, 0x35	; 53
    30aa:	75 e0       	ldi	r23, 0x05	; 5
    30ac:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
=======
    31f8:	69 e3       	ldi	r22, 0x39	; 57
    31fa:	75 e0       	ldi	r23, 0x05	; 5
    31fc:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
<<<<<<< HEAD
    30b0:	e8 81       	ld	r30, Y
    30b2:	f9 81       	ldd	r31, Y+1	; 0x01
    30b4:	02 80       	ldd	r0, Z+2	; 0x02
    30b6:	f3 81       	ldd	r31, Z+3	; 0x03
    30b8:	e0 2d       	mov	r30, r0
    30ba:	60 e2       	ldi	r22, 0x20	; 32
    30bc:	ce 01       	movw	r24, r28
    30be:	19 95       	eicall
=======
    3200:	e8 81       	ld	r30, Y
    3202:	f9 81       	ldd	r31, Y+1	; 0x01
    3204:	02 80       	ldd	r0, Z+2	; 0x02
    3206:	f3 81       	ldd	r31, Z+3	; 0x03
    3208:	e0 2d       	mov	r30, r0
    320a:	60 e2       	ldi	r22, 0x20	; 32
    320c:	ce 01       	movw	r24, r28
    320e:	19 95       	eicall
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
<<<<<<< HEAD
    30c0:	c6 2d       	mov	r28, r6
    30c2:	d5 2d       	mov	r29, r5
=======
    3210:	c6 2d       	mov	r28, r6
    3212:	d5 2d       	mov	r29, r5
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
<<<<<<< HEAD
    30c4:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    30c6:	80 ee       	ldi	r24, 0xE0	; 224
    30c8:	86 0f       	add	r24, r22
    30ca:	8f 35       	cpi	r24, 0x5F	; 95
    30cc:	48 f4       	brcc	.+18     	; 0x30e0 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    30ce:	d7 01       	movw	r26, r14
    30d0:	ed 91       	ld	r30, X+
    30d2:	fc 91       	ld	r31, X
    30d4:	02 80       	ldd	r0, Z+2	; 0x02
    30d6:	f3 81       	ldd	r31, Z+3	; 0x03
    30d8:	e0 2d       	mov	r30, r0
    30da:	c7 01       	movw	r24, r14
    30dc:	19 95       	eicall
    30de:	09 c0       	rjmp	.+18     	; 0x30f2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    30e0:	d7 01       	movw	r26, r14
    30e2:	ed 91       	ld	r30, X+
    30e4:	fc 91       	ld	r31, X
    30e6:	02 80       	ldd	r0, Z+2	; 0x02
    30e8:	f3 81       	ldd	r31, Z+3	; 0x03
    30ea:	e0 2d       	mov	r30, r0
    30ec:	6e e2       	ldi	r22, 0x2E	; 46
    30ee:	c7 01       	movw	r24, r14
    30f0:	19 95       	eicall
=======
    3214:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3216:	80 ee       	ldi	r24, 0xE0	; 224
    3218:	86 0f       	add	r24, r22
    321a:	8f 35       	cpi	r24, 0x5F	; 95
    321c:	48 f4       	brcc	.+18     	; 0x3230 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    321e:	d7 01       	movw	r26, r14
    3220:	ed 91       	ld	r30, X+
    3222:	fc 91       	ld	r31, X
    3224:	02 80       	ldd	r0, Z+2	; 0x02
    3226:	f3 81       	ldd	r31, Z+3	; 0x03
    3228:	e0 2d       	mov	r30, r0
    322a:	c7 01       	movw	r24, r14
    322c:	19 95       	eicall
    322e:	09 c0       	rjmp	.+18     	; 0x3242 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3230:	d7 01       	movw	r26, r14
    3232:	ed 91       	ld	r30, X+
    3234:	fc 91       	ld	r31, X
    3236:	02 80       	ldd	r0, Z+2	; 0x02
    3238:	f3 81       	ldd	r31, Z+3	; 0x03
    323a:	e0 2d       	mov	r30, r0
    323c:	6e e2       	ldi	r22, 0x2E	; 46
    323e:	c7 01       	movw	r24, r14
    3240:	19 95       	eicall
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
<<<<<<< HEAD
    30f2:	cc 16       	cp	r12, r28
    30f4:	dd 06       	cpc	r13, r29
    30f6:	31 f7       	brne	.-52     	; 0x30c4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    30f8:	b4 e1       	ldi	r27, 0x14	; 20
    30fa:	ab 0e       	add	r10, r27
    30fc:	b1 1c       	adc	r11, r1
=======
    3242:	cc 16       	cp	r12, r28
    3244:	dd 06       	cpc	r13, r29
    3246:	31 f7       	brne	.-52     	; 0x3214 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3248:	b4 e1       	ldi	r27, 0x14	; 20
    324a:	ab 0e       	add	r10, r27
    324c:	b1 1c       	adc	r11, r1
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
<<<<<<< HEAD
    30fe:	66 e0       	ldi	r22, 0x06	; 6
    3100:	c7 01       	movw	r24, r14
    3102:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    3106:	84 e1       	ldi	r24, 0x14	; 20
    3108:	c8 0e       	add	r12, r24
    310a:	d1 1c       	adc	r13, r1
=======
    324e:	66 e0       	ldi	r22, 0x06	; 6
    3250:	c7 01       	movw	r24, r14
    3252:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    3256:	84 e1       	ldi	r24, 0x14	; 20
    3258:	c8 0e       	add	r12, r24
    325a:	d1 1c       	adc	r13, r1
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
<<<<<<< HEAD
    310c:	a8 14       	cp	r10, r8
    310e:	b9 04       	cpc	r11, r9
    3110:	08 f4       	brcc	.+2      	; 0x3114 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3112:	88 cf       	rjmp	.-240    	; 0x3024 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
=======
    325c:	a8 14       	cp	r10, r8
    325e:	b9 04       	cpc	r11, r9
    3260:	08 f4       	brcc	.+2      	; 0x3264 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3262:	88 cf       	rjmp	.-240    	; 0x3174 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
<<<<<<< HEAD
    3114:	62 e0       	ldi	r22, 0x02	; 2
    3116:	c7 01       	movw	r24, r14
    3118:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
}
    311c:	03 c0       	rjmp	.+6      	; 0x3124 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
=======
    3264:	62 e0       	ldi	r22, 0x02	; 2
    3266:	c7 01       	movw	r24, r14
    3268:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
}
    326c:	03 c0       	rjmp	.+6      	; 0x3274 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
<<<<<<< HEAD
    311e:	c6 2d       	mov	r28, r6
    3120:	d5 2d       	mov	r29, r5
    3122:	9c cf       	rjmp	.-200    	; 0x305c <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
=======
    326e:	c6 2d       	mov	r28, r6
    3270:	d5 2d       	mov	r29, r5
    3272:	9c cf       	rjmp	.-200    	; 0x31ac <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
<<<<<<< HEAD
    3124:	df 91       	pop	r29
    3126:	cf 91       	pop	r28
    3128:	1f 91       	pop	r17
    312a:	0f 91       	pop	r16
    312c:	ff 90       	pop	r15
    312e:	ef 90       	pop	r14
    3130:	df 90       	pop	r13
    3132:	cf 90       	pop	r12
    3134:	bf 90       	pop	r11
    3136:	af 90       	pop	r10
    3138:	9f 90       	pop	r9
    313a:	8f 90       	pop	r8
    313c:	7f 90       	pop	r7
    313e:	6f 90       	pop	r6
    3140:	5f 90       	pop	r5
    3142:	08 95       	ret

00003144 <_Znwj>:
=======
    3274:	df 91       	pop	r29
    3276:	cf 91       	pop	r28
    3278:	1f 91       	pop	r17
    327a:	0f 91       	pop	r16
    327c:	ff 90       	pop	r15
    327e:	ef 90       	pop	r14
    3280:	df 90       	pop	r13
    3282:	cf 90       	pop	r12
    3284:	bf 90       	pop	r11
    3286:	af 90       	pop	r10
    3288:	9f 90       	pop	r9
    328a:	8f 90       	pop	r8
    328c:	7f 90       	pop	r7
    328e:	6f 90       	pop	r6
    3290:	5f 90       	pop	r5
    3292:	08 95       	ret

00003294 <_Znwj>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
<<<<<<< HEAD
    3144:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <pvPortMalloc>
    3148:	08 95       	ret

0000314a <_Znaj>:
    314a:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <pvPortMalloc>
    314e:	08 95       	ret

00003150 <__cxa_pure_virtual>:
=======
    3294:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    3298:	08 95       	ret

0000329a <_Znaj>:
    329a:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <pvPortMalloc>
    329e:	08 95       	ret

000032a0 <__cxa_pure_virtual>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
<<<<<<< HEAD
    3150:	08 95       	ret

00003152 <_ZN7base232C1EjP12USART_struct>:
=======
    32a0:	08 95       	ret

000032a2 <_ZN7base232C1EjP12USART_struct>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
<<<<<<< HEAD
    3152:	cf 93       	push	r28
    3154:	df 93       	push	r29
    3156:	fc 01       	movw	r30, r24
    3158:	da 01       	movw	r26, r20
=======
    32a2:	cf 93       	push	r28
    32a4:	df 93       	push	r29
    32a6:	fc 01       	movw	r30, r24
    32a8:	da 01       	movw	r26, r20
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
<<<<<<< HEAD
    315a:	40 3a       	cpi	r20, 0xA0	; 160
    315c:	68 e0       	ldi	r22, 0x08	; 8
    315e:	56 07       	cpc	r21, r22
    3160:	49 f4       	brne	.+18     	; 0x3174 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3162:	80 e4       	ldi	r24, 0x40	; 64
    3164:	96 e0       	ldi	r25, 0x06	; 6
    3166:	82 83       	std	Z+2, r24	; 0x02
    3168:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    316a:	82 e0       	ldi	r24, 0x02	; 2
    316c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    316e:	83 e0       	ldi	r24, 0x03	; 3
    3170:	85 83       	std	Z+5, r24	; 0x05
    3172:	32 c0       	rjmp	.+100    	; 0x31d8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3174:	40 3b       	cpi	r20, 0xB0	; 176
    3176:	78 e0       	ldi	r23, 0x08	; 8
    3178:	57 07       	cpc	r21, r23
    317a:	49 f4       	brne	.+18     	; 0x318e <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    317c:	80 e4       	ldi	r24, 0x40	; 64
    317e:	96 e0       	ldi	r25, 0x06	; 6
    3180:	82 83       	std	Z+2, r24	; 0x02
    3182:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3184:	86 e0       	ldi	r24, 0x06	; 6
    3186:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3188:	87 e0       	ldi	r24, 0x07	; 7
    318a:	85 83       	std	Z+5, r24	; 0x05
    318c:	25 c0       	rjmp	.+74     	; 0x31d8 <_ZN7base232C1EjP12USART_struct+0x86>
=======
    32aa:	40 3a       	cpi	r20, 0xA0	; 160
    32ac:	68 e0       	ldi	r22, 0x08	; 8
    32ae:	56 07       	cpc	r21, r22
    32b0:	49 f4       	brne	.+18     	; 0x32c4 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    32b2:	80 e4       	ldi	r24, 0x40	; 64
    32b4:	96 e0       	ldi	r25, 0x06	; 6
    32b6:	82 83       	std	Z+2, r24	; 0x02
    32b8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32ba:	82 e0       	ldi	r24, 0x02	; 2
    32bc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32be:	83 e0       	ldi	r24, 0x03	; 3
    32c0:	85 83       	std	Z+5, r24	; 0x05
    32c2:	32 c0       	rjmp	.+100    	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    32c4:	40 3b       	cpi	r20, 0xB0	; 176
    32c6:	78 e0       	ldi	r23, 0x08	; 8
    32c8:	57 07       	cpc	r21, r23
    32ca:	49 f4       	brne	.+18     	; 0x32de <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    32cc:	80 e4       	ldi	r24, 0x40	; 64
    32ce:	96 e0       	ldi	r25, 0x06	; 6
    32d0:	82 83       	std	Z+2, r24	; 0x02
    32d2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    32d4:	86 e0       	ldi	r24, 0x06	; 6
    32d6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32d8:	87 e0       	ldi	r24, 0x07	; 7
    32da:	85 83       	std	Z+5, r24	; 0x05
    32dc:	25 c0       	rjmp	.+74     	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
<<<<<<< HEAD
    318e:	40 3a       	cpi	r20, 0xA0	; 160
    3190:	89 e0       	ldi	r24, 0x09	; 9
    3192:	58 07       	cpc	r21, r24
    3194:	49 f4       	brne	.+18     	; 0x31a8 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3196:	80 e6       	ldi	r24, 0x60	; 96
    3198:	96 e0       	ldi	r25, 0x06	; 6
    319a:	82 83       	std	Z+2, r24	; 0x02
    319c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    319e:	82 e0       	ldi	r24, 0x02	; 2
    31a0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    31a2:	83 e0       	ldi	r24, 0x03	; 3
    31a4:	85 83       	std	Z+5, r24	; 0x05
    31a6:	18 c0       	rjmp	.+48     	; 0x31d8 <_ZN7base232C1EjP12USART_struct+0x86>
=======
    32de:	40 3a       	cpi	r20, 0xA0	; 160
    32e0:	89 e0       	ldi	r24, 0x09	; 9
    32e2:	58 07       	cpc	r21, r24
    32e4:	49 f4       	brne	.+18     	; 0x32f8 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    32e6:	80 e6       	ldi	r24, 0x60	; 96
    32e8:	96 e0       	ldi	r25, 0x06	; 6
    32ea:	82 83       	std	Z+2, r24	; 0x02
    32ec:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32ee:	82 e0       	ldi	r24, 0x02	; 2
    32f0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32f2:	83 e0       	ldi	r24, 0x03	; 3
    32f4:	85 83       	std	Z+5, r24	; 0x05
    32f6:	18 c0       	rjmp	.+48     	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
<<<<<<< HEAD
    31a8:	40 3b       	cpi	r20, 0xB0	; 176
    31aa:	69 e0       	ldi	r22, 0x09	; 9
    31ac:	56 07       	cpc	r21, r22
    31ae:	49 f4       	brne	.+18     	; 0x31c2 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    31b0:	80 e6       	ldi	r24, 0x60	; 96
    31b2:	96 e0       	ldi	r25, 0x06	; 6
    31b4:	82 83       	std	Z+2, r24	; 0x02
    31b6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    31b8:	86 e0       	ldi	r24, 0x06	; 6
    31ba:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    31bc:	87 e0       	ldi	r24, 0x07	; 7
    31be:	85 83       	std	Z+5, r24	; 0x05
    31c0:	0b c0       	rjmp	.+22     	; 0x31d8 <_ZN7base232C1EjP12USART_struct+0x86>
=======
    32f8:	40 3b       	cpi	r20, 0xB0	; 176
    32fa:	69 e0       	ldi	r22, 0x09	; 9
    32fc:	56 07       	cpc	r21, r22
    32fe:	49 f4       	brne	.+18     	; 0x3312 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3300:	80 e6       	ldi	r24, 0x60	; 96
    3302:	96 e0       	ldi	r25, 0x06	; 6
    3304:	82 83       	std	Z+2, r24	; 0x02
    3306:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3308:	86 e0       	ldi	r24, 0x06	; 6
    330a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    330c:	87 e0       	ldi	r24, 0x07	; 7
    330e:	85 83       	std	Z+5, r24	; 0x05
    3310:	0b c0       	rjmp	.+22     	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
<<<<<<< HEAD
    31c2:	40 3a       	cpi	r20, 0xA0	; 160
    31c4:	5a 40       	sbci	r21, 0x0A	; 10
    31c6:	41 f4       	brne	.+16     	; 0x31d8 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    31c8:	80 e8       	ldi	r24, 0x80	; 128
    31ca:	96 e0       	ldi	r25, 0x06	; 6
    31cc:	82 83       	std	Z+2, r24	; 0x02
    31ce:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    31d0:	82 e0       	ldi	r24, 0x02	; 2
    31d2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    31d4:	83 e0       	ldi	r24, 0x03	; 3
    31d6:	85 83       	std	Z+5, r24	; 0x05
=======
    3312:	40 3a       	cpi	r20, 0xA0	; 160
    3314:	5a 40       	sbci	r21, 0x0A	; 10
    3316:	41 f4       	brne	.+16     	; 0x3328 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3318:	80 e8       	ldi	r24, 0x80	; 128
    331a:	96 e0       	ldi	r25, 0x06	; 6
    331c:	82 83       	std	Z+2, r24	; 0x02
    331e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3320:	82 e0       	ldi	r24, 0x02	; 2
    3322:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3324:	83 e0       	ldi	r24, 0x03	; 3
    3326:	85 83       	std	Z+5, r24	; 0x05
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
<<<<<<< HEAD
    31d8:	a6 83       	std	Z+6, r26	; 0x06
    31da:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    31dc:	cd 01       	movw	r24, r26
    31de:	01 96       	adiw	r24, 0x01	; 1
    31e0:	80 87       	std	Z+8, r24	; 0x08
    31e2:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    31e4:	03 96       	adiw	r24, 0x03	; 3
    31e6:	82 87       	std	Z+10, r24	; 0x0a
    31e8:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    31ea:	25 81       	ldd	r18, Z+5	; 0x05
    31ec:	c2 81       	ldd	r28, Z+2	; 0x02
    31ee:	d3 81       	ldd	r29, Z+3	; 0x03
    31f0:	4c 81       	ldd	r20, Y+4	; 0x04
    31f2:	81 e0       	ldi	r24, 0x01	; 1
    31f4:	90 e0       	ldi	r25, 0x00	; 0
    31f6:	bc 01       	movw	r22, r24
    31f8:	02 c0       	rjmp	.+4      	; 0x31fe <_ZN7base232C1EjP12USART_struct+0xac>
    31fa:	66 0f       	add	r22, r22
    31fc:	77 1f       	adc	r23, r23
    31fe:	2a 95       	dec	r18
    3200:	e2 f7       	brpl	.-8      	; 0x31fa <_ZN7base232C1EjP12USART_struct+0xa8>
    3202:	9b 01       	movw	r18, r22
    3204:	24 2b       	or	r18, r20
    3206:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3208:	25 81       	ldd	r18, Z+5	; 0x05
    320a:	c2 81       	ldd	r28, Z+2	; 0x02
    320c:	d3 81       	ldd	r29, Z+3	; 0x03
    320e:	48 81       	ld	r20, Y
    3210:	bc 01       	movw	r22, r24
    3212:	02 c0       	rjmp	.+4      	; 0x3218 <_ZN7base232C1EjP12USART_struct+0xc6>
    3214:	66 0f       	add	r22, r22
    3216:	77 1f       	adc	r23, r23
    3218:	2a 95       	dec	r18
    321a:	e2 f7       	brpl	.-8      	; 0x3214 <_ZN7base232C1EjP12USART_struct+0xc2>
    321c:	9b 01       	movw	r18, r22
    321e:	24 2b       	or	r18, r20
    3220:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3222:	34 81       	ldd	r19, Z+4	; 0x04
    3224:	c2 81       	ldd	r28, Z+2	; 0x02
    3226:	d3 81       	ldd	r29, Z+3	; 0x03
    3228:	28 81       	ld	r18, Y
    322a:	02 c0       	rjmp	.+4      	; 0x3230 <_ZN7base232C1EjP12USART_struct+0xde>
    322c:	88 0f       	add	r24, r24
    322e:	99 1f       	adc	r25, r25
    3230:	3a 95       	dec	r19
    3232:	e2 f7       	brpl	.-8      	; 0x322c <_ZN7base232C1EjP12USART_struct+0xda>
    3234:	80 95       	com	r24
    3236:	90 95       	com	r25
    3238:	82 23       	and	r24, r18
    323a:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    323c:	80 e1       	ldi	r24, 0x10	; 16
    323e:	13 96       	adiw	r26, 0x03	; 3
    3240:	8c 93       	st	X, r24
    3242:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3244:	83 e0       	ldi	r24, 0x03	; 3
    3246:	15 96       	adiw	r26, 0x05	; 5
    3248:	8c 93       	st	X, r24
    324a:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    324c:	80 ef       	ldi	r24, 0xF0	; 240
    324e:	17 96       	adiw	r26, 0x07	; 7
    3250:	8c 93       	st	X, r24
    3252:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3254:	81 e2       	ldi	r24, 0x21	; 33
    3256:	16 96       	adiw	r26, 0x06	; 6
    3258:	8c 93       	st	X, r24
    325a:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    325c:	88 e1       	ldi	r24, 0x18	; 24
    325e:	14 96       	adiw	r26, 0x04	; 4
    3260:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3262:	80 e8       	ldi	r24, 0x80	; 128
    3264:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3266:	80 e4       	ldi	r24, 0x40	; 64
    3268:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    326a:	80 e2       	ldi	r24, 0x20	; 32
    326c:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    326e:	06 80       	ldd	r0, Z+6	; 0x06
    3270:	f7 81       	ldd	r31, Z+7	; 0x07
    3272:	e0 2d       	mov	r30, r0
    3274:	80 81       	ld	r24, Z
    3276:	80 81       	ld	r24, Z
}
    3278:	df 91       	pop	r29
    327a:	cf 91       	pop	r28
    327c:	08 95       	ret

0000327e <_ZN8emstream13ready_to_sendEv>:
=======
    3328:	a6 83       	std	Z+6, r26	; 0x06
    332a:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    332c:	cd 01       	movw	r24, r26
    332e:	01 96       	adiw	r24, 0x01	; 1
    3330:	80 87       	std	Z+8, r24	; 0x08
    3332:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3334:	03 96       	adiw	r24, 0x03	; 3
    3336:	82 87       	std	Z+10, r24	; 0x0a
    3338:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    333a:	25 81       	ldd	r18, Z+5	; 0x05
    333c:	c2 81       	ldd	r28, Z+2	; 0x02
    333e:	d3 81       	ldd	r29, Z+3	; 0x03
    3340:	4c 81       	ldd	r20, Y+4	; 0x04
    3342:	81 e0       	ldi	r24, 0x01	; 1
    3344:	90 e0       	ldi	r25, 0x00	; 0
    3346:	bc 01       	movw	r22, r24
    3348:	02 c0       	rjmp	.+4      	; 0x334e <_ZN7base232C1EjP12USART_struct+0xac>
    334a:	66 0f       	add	r22, r22
    334c:	77 1f       	adc	r23, r23
    334e:	2a 95       	dec	r18
    3350:	e2 f7       	brpl	.-8      	; 0x334a <_ZN7base232C1EjP12USART_struct+0xa8>
    3352:	9b 01       	movw	r18, r22
    3354:	24 2b       	or	r18, r20
    3356:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3358:	25 81       	ldd	r18, Z+5	; 0x05
    335a:	c2 81       	ldd	r28, Z+2	; 0x02
    335c:	d3 81       	ldd	r29, Z+3	; 0x03
    335e:	48 81       	ld	r20, Y
    3360:	bc 01       	movw	r22, r24
    3362:	02 c0       	rjmp	.+4      	; 0x3368 <_ZN7base232C1EjP12USART_struct+0xc6>
    3364:	66 0f       	add	r22, r22
    3366:	77 1f       	adc	r23, r23
    3368:	2a 95       	dec	r18
    336a:	e2 f7       	brpl	.-8      	; 0x3364 <_ZN7base232C1EjP12USART_struct+0xc2>
    336c:	9b 01       	movw	r18, r22
    336e:	24 2b       	or	r18, r20
    3370:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3372:	34 81       	ldd	r19, Z+4	; 0x04
    3374:	c2 81       	ldd	r28, Z+2	; 0x02
    3376:	d3 81       	ldd	r29, Z+3	; 0x03
    3378:	28 81       	ld	r18, Y
    337a:	02 c0       	rjmp	.+4      	; 0x3380 <_ZN7base232C1EjP12USART_struct+0xde>
    337c:	88 0f       	add	r24, r24
    337e:	99 1f       	adc	r25, r25
    3380:	3a 95       	dec	r19
    3382:	e2 f7       	brpl	.-8      	; 0x337c <_ZN7base232C1EjP12USART_struct+0xda>
    3384:	80 95       	com	r24
    3386:	90 95       	com	r25
    3388:	82 23       	and	r24, r18
    338a:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    338c:	80 e1       	ldi	r24, 0x10	; 16
    338e:	13 96       	adiw	r26, 0x03	; 3
    3390:	8c 93       	st	X, r24
    3392:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3394:	83 e0       	ldi	r24, 0x03	; 3
    3396:	15 96       	adiw	r26, 0x05	; 5
    3398:	8c 93       	st	X, r24
    339a:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    339c:	80 ef       	ldi	r24, 0xF0	; 240
    339e:	17 96       	adiw	r26, 0x07	; 7
    33a0:	8c 93       	st	X, r24
    33a2:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    33a4:	81 e2       	ldi	r24, 0x21	; 33
    33a6:	16 96       	adiw	r26, 0x06	; 6
    33a8:	8c 93       	st	X, r24
    33aa:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    33ac:	88 e1       	ldi	r24, 0x18	; 24
    33ae:	14 96       	adiw	r26, 0x04	; 4
    33b0:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    33b2:	80 e8       	ldi	r24, 0x80	; 128
    33b4:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    33b6:	80 e4       	ldi	r24, 0x40	; 64
    33b8:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    33ba:	80 e2       	ldi	r24, 0x20	; 32
    33bc:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    33be:	06 80       	ldd	r0, Z+6	; 0x06
    33c0:	f7 81       	ldd	r31, Z+7	; 0x07
    33c2:	e0 2d       	mov	r30, r0
    33c4:	80 81       	ld	r24, Z
    33c6:	80 81       	ld	r24, Z
}
    33c8:	df 91       	pop	r29
    33ca:	cf 91       	pop	r28
    33cc:	08 95       	ret

000033ce <_ZN8emstream13ready_to_sendEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
<<<<<<< HEAD
    327e:	81 e0       	ldi	r24, 0x01	; 1
    3280:	08 95       	ret

00003282 <_ZN8emstream7getcharEv>:
    3282:	80 e0       	ldi	r24, 0x00	; 0
    3284:	90 e0       	ldi	r25, 0x00	; 0
    3286:	08 95       	ret

00003288 <_ZN8emstream14check_for_charEv>:
    3288:	80 e0       	ldi	r24, 0x00	; 0
    328a:	08 95       	ret

0000328c <_ZN8emstream12transmit_nowEv>:
    328c:	08 95       	ret

0000328e <_ZN8emstream12clear_screenEv>:
    328e:	08 95       	ret

00003290 <_ZN8emstreamC1Ev>:
    3290:	fc 01       	movw	r30, r24
    3292:	8f e4       	ldi	r24, 0x4F	; 79
    3294:	90 e2       	ldi	r25, 0x20	; 32
    3296:	80 83       	st	Z, r24
    3298:	91 83       	std	Z+1, r25	; 0x01
    329a:	8a e0       	ldi	r24, 0x0A	; 10
    329c:	82 83       	std	Z+2, r24	; 0x02
    329e:	13 82       	std	Z+3, r1	; 0x03
    32a0:	83 e0       	ldi	r24, 0x03	; 3
    32a2:	85 83       	std	Z+5, r24	; 0x05
    32a4:	14 82       	std	Z+4, r1	; 0x04
    32a6:	16 82       	std	Z+6, r1	; 0x06
    32a8:	17 82       	std	Z+7, r1	; 0x07
    32aa:	08 95       	ret

000032ac <_ZN8emstream4putsEPKc>:
    32ac:	0f 93       	push	r16
    32ae:	1f 93       	push	r17
    32b0:	cf 93       	push	r28
    32b2:	df 93       	push	r29
    32b4:	8c 01       	movw	r16, r24
    32b6:	fb 01       	movw	r30, r22
    32b8:	dc 01       	movw	r26, r24
    32ba:	14 96       	adiw	r26, 0x04	; 4
    32bc:	8c 91       	ld	r24, X
    32be:	81 11       	cpse	r24, r1
    32c0:	04 c0       	rjmp	.+8      	; 0x32ca <_ZN8emstream4putsEPKc+0x1e>
    32c2:	60 81       	ld	r22, Z
    32c4:	61 11       	cpse	r22, r1
    32c6:	17 c0       	rjmp	.+46     	; 0x32f6 <_ZN8emstream4putsEPKc+0x4a>
    32c8:	23 c0       	rjmp	.+70     	; 0x3310 <_ZN8emstream4putsEPKc+0x64>
    32ca:	d8 01       	movw	r26, r16
    32cc:	14 96       	adiw	r26, 0x04	; 4
    32ce:	1c 92       	st	X, r1
    32d0:	eb 01       	movw	r28, r22
    32d2:	21 96       	adiw	r28, 0x01	; 1
    32d4:	64 91       	lpm	r22, Z
    32d6:	66 23       	and	r22, r22
    32d8:	d9 f0       	breq	.+54     	; 0x3310 <_ZN8emstream4putsEPKc+0x64>
    32da:	d8 01       	movw	r26, r16
    32dc:	ed 91       	ld	r30, X+
    32de:	fc 91       	ld	r31, X
    32e0:	02 80       	ldd	r0, Z+2	; 0x02
    32e2:	f3 81       	ldd	r31, Z+3	; 0x03
    32e4:	e0 2d       	mov	r30, r0
    32e6:	c8 01       	movw	r24, r16
    32e8:	19 95       	eicall
    32ea:	fe 01       	movw	r30, r28
    32ec:	64 91       	lpm	r22, Z
    32ee:	21 96       	adiw	r28, 0x01	; 1
    32f0:	61 11       	cpse	r22, r1
    32f2:	f3 cf       	rjmp	.-26     	; 0x32da <_ZN8emstream4putsEPKc+0x2e>
    32f4:	0d c0       	rjmp	.+26     	; 0x3310 <_ZN8emstream4putsEPKc+0x64>
    32f6:	ef 01       	movw	r28, r30
    32f8:	21 96       	adiw	r28, 0x01	; 1
    32fa:	d8 01       	movw	r26, r16
    32fc:	ed 91       	ld	r30, X+
    32fe:	fc 91       	ld	r31, X
    3300:	02 80       	ldd	r0, Z+2	; 0x02
    3302:	f3 81       	ldd	r31, Z+3	; 0x03
    3304:	e0 2d       	mov	r30, r0
    3306:	c8 01       	movw	r24, r16
    3308:	19 95       	eicall
    330a:	69 91       	ld	r22, Y+
    330c:	61 11       	cpse	r22, r1
    330e:	f5 cf       	rjmp	.-22     	; 0x32fa <_ZN8emstream4putsEPKc+0x4e>
    3310:	df 91       	pop	r29
    3312:	cf 91       	pop	r28
    3314:	1f 91       	pop	r17
    3316:	0f 91       	pop	r16
    3318:	08 95       	ret

0000331a <_ZN8emstreamlsE15ser_manipulator>:
=======
    33ce:	81 e0       	ldi	r24, 0x01	; 1
    33d0:	08 95       	ret

000033d2 <_ZN8emstream7getcharEv>:
    33d2:	80 e0       	ldi	r24, 0x00	; 0
    33d4:	90 e0       	ldi	r25, 0x00	; 0
    33d6:	08 95       	ret

000033d8 <_ZN8emstream14check_for_charEv>:
    33d8:	80 e0       	ldi	r24, 0x00	; 0
    33da:	08 95       	ret

000033dc <_ZN8emstream12transmit_nowEv>:
    33dc:	08 95       	ret

000033de <_ZN8emstream12clear_screenEv>:
    33de:	08 95       	ret

000033e0 <_ZN8emstreamC1Ev>:
    33e0:	fc 01       	movw	r30, r24
    33e2:	8d e7       	ldi	r24, 0x7D	; 125
    33e4:	90 e2       	ldi	r25, 0x20	; 32
    33e6:	80 83       	st	Z, r24
    33e8:	91 83       	std	Z+1, r25	; 0x01
    33ea:	8a e0       	ldi	r24, 0x0A	; 10
    33ec:	82 83       	std	Z+2, r24	; 0x02
    33ee:	13 82       	std	Z+3, r1	; 0x03
    33f0:	83 e0       	ldi	r24, 0x03	; 3
    33f2:	85 83       	std	Z+5, r24	; 0x05
    33f4:	14 82       	std	Z+4, r1	; 0x04
    33f6:	16 82       	std	Z+6, r1	; 0x06
    33f8:	17 82       	std	Z+7, r1	; 0x07
    33fa:	08 95       	ret

000033fc <_ZN8emstream4putsEPKc>:
    33fc:	0f 93       	push	r16
    33fe:	1f 93       	push	r17
    3400:	cf 93       	push	r28
    3402:	df 93       	push	r29
    3404:	8c 01       	movw	r16, r24
    3406:	fb 01       	movw	r30, r22
    3408:	dc 01       	movw	r26, r24
    340a:	14 96       	adiw	r26, 0x04	; 4
    340c:	8c 91       	ld	r24, X
    340e:	81 11       	cpse	r24, r1
    3410:	04 c0       	rjmp	.+8      	; 0x341a <_ZN8emstream4putsEPKc+0x1e>
    3412:	60 81       	ld	r22, Z
    3414:	61 11       	cpse	r22, r1
    3416:	17 c0       	rjmp	.+46     	; 0x3446 <_ZN8emstream4putsEPKc+0x4a>
    3418:	23 c0       	rjmp	.+70     	; 0x3460 <_ZN8emstream4putsEPKc+0x64>
    341a:	d8 01       	movw	r26, r16
    341c:	14 96       	adiw	r26, 0x04	; 4
    341e:	1c 92       	st	X, r1
    3420:	eb 01       	movw	r28, r22
    3422:	21 96       	adiw	r28, 0x01	; 1
    3424:	64 91       	lpm	r22, Z
    3426:	66 23       	and	r22, r22
    3428:	d9 f0       	breq	.+54     	; 0x3460 <_ZN8emstream4putsEPKc+0x64>
    342a:	d8 01       	movw	r26, r16
    342c:	ed 91       	ld	r30, X+
    342e:	fc 91       	ld	r31, X
    3430:	02 80       	ldd	r0, Z+2	; 0x02
    3432:	f3 81       	ldd	r31, Z+3	; 0x03
    3434:	e0 2d       	mov	r30, r0
    3436:	c8 01       	movw	r24, r16
    3438:	19 95       	eicall
    343a:	fe 01       	movw	r30, r28
    343c:	64 91       	lpm	r22, Z
    343e:	21 96       	adiw	r28, 0x01	; 1
    3440:	61 11       	cpse	r22, r1
    3442:	f3 cf       	rjmp	.-26     	; 0x342a <_ZN8emstream4putsEPKc+0x2e>
    3444:	0d c0       	rjmp	.+26     	; 0x3460 <_ZN8emstream4putsEPKc+0x64>
    3446:	ef 01       	movw	r28, r30
    3448:	21 96       	adiw	r28, 0x01	; 1
    344a:	d8 01       	movw	r26, r16
    344c:	ed 91       	ld	r30, X+
    344e:	fc 91       	ld	r31, X
    3450:	02 80       	ldd	r0, Z+2	; 0x02
    3452:	f3 81       	ldd	r31, Z+3	; 0x03
    3454:	e0 2d       	mov	r30, r0
    3456:	c8 01       	movw	r24, r16
    3458:	19 95       	eicall
    345a:	69 91       	ld	r22, Y+
    345c:	61 11       	cpse	r22, r1
    345e:	f5 cf       	rjmp	.-22     	; 0x344a <_ZN8emstream4putsEPKc+0x4e>
    3460:	df 91       	pop	r29
    3462:	cf 91       	pop	r28
    3464:	1f 91       	pop	r17
    3466:	0f 91       	pop	r16
    3468:	08 95       	ret

0000346a <_ZN8emstreamlsE15ser_manipulator>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
<<<<<<< HEAD
    331a:	cf 93       	push	r28
    331c:	df 93       	push	r29
    331e:	ec 01       	movw	r28, r24
	switch (new_manip)
    3320:	86 2f       	mov	r24, r22
    3322:	90 e0       	ldi	r25, 0x00	; 0
    3324:	8b 30       	cpi	r24, 0x0B	; 11
    3326:	91 05       	cpc	r25, r1
    3328:	d8 f5       	brcc	.+118    	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
    332a:	fc 01       	movw	r30, r24
    332c:	88 27       	eor	r24, r24
    332e:	e2 50       	subi	r30, 0x02	; 2
    3330:	ff 4f       	sbci	r31, 0xFF	; 255
    3332:	8f 4f       	sbci	r24, 0xFF	; 255
    3334:	0c 94 34 1f 	jmp	0x3e68	; 0x3e68 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3338:	82 e0       	ldi	r24, 0x02	; 2
    333a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    333c:	31 c0       	rjmp	.+98     	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    333e:	88 e0       	ldi	r24, 0x08	; 8
    3340:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3342:	2e c0       	rjmp	.+92     	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3344:	8a e0       	ldi	r24, 0x0A	; 10
    3346:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3348:	2b c0       	rjmp	.+86     	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    334a:	80 e1       	ldi	r24, 0x10	; 16
    334c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    334e:	28 c0       	rjmp	.+80     	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3350:	81 e0       	ldi	r24, 0x01	; 1
    3352:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3354:	25 c0       	rjmp	.+74     	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3356:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3358:	23 c0       	rjmp	.+70     	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    335a:	e8 81       	ld	r30, Y
    335c:	f9 81       	ldd	r31, Y+1	; 0x01
    335e:	02 80       	ldd	r0, Z+2	; 0x02
    3360:	f3 81       	ldd	r31, Z+3	; 0x03
    3362:	e0 2d       	mov	r30, r0
    3364:	6d e0       	ldi	r22, 0x0D	; 13
    3366:	ce 01       	movw	r24, r28
    3368:	19 95       	eicall
    336a:	e8 81       	ld	r30, Y
    336c:	f9 81       	ldd	r31, Y+1	; 0x01
    336e:	02 80       	ldd	r0, Z+2	; 0x02
    3370:	f3 81       	ldd	r31, Z+3	; 0x03
    3372:	e0 2d       	mov	r30, r0
    3374:	6a e0       	ldi	r22, 0x0A	; 10
    3376:	ce 01       	movw	r24, r28
    3378:	19 95       	eicall
			break;
    337a:	12 c0       	rjmp	.+36     	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    337c:	e8 81       	ld	r30, Y
    337e:	f9 81       	ldd	r31, Y+1	; 0x01
    3380:	02 84       	ldd	r0, Z+10	; 0x0a
    3382:	f3 85       	ldd	r31, Z+11	; 0x0b
    3384:	e0 2d       	mov	r30, r0
    3386:	ce 01       	movw	r24, r28
    3388:	19 95       	eicall
			break;
    338a:	0a c0       	rjmp	.+20     	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    338c:	e8 81       	ld	r30, Y
    338e:	f9 81       	ldd	r31, Y+1	; 0x01
    3390:	00 84       	ldd	r0, Z+8	; 0x08
    3392:	f1 85       	ldd	r31, Z+9	; 0x09
    3394:	e0 2d       	mov	r30, r0
    3396:	ce 01       	movw	r24, r28
    3398:	19 95       	eicall
			break;
    339a:	02 c0       	rjmp	.+4      	; 0x33a0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    339c:	81 e0       	ldi	r24, 0x01	; 1
    339e:	8c 83       	std	Y+4, r24	; 0x04
=======
    346a:	cf 93       	push	r28
    346c:	df 93       	push	r29
    346e:	ec 01       	movw	r28, r24
	switch (new_manip)
    3470:	86 2f       	mov	r24, r22
    3472:	90 e0       	ldi	r25, 0x00	; 0
    3474:	8b 30       	cpi	r24, 0x0B	; 11
    3476:	91 05       	cpc	r25, r1
    3478:	d8 f5       	brcc	.+118    	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
    347a:	fc 01       	movw	r30, r24
    347c:	88 27       	eor	r24, r24
    347e:	e2 50       	subi	r30, 0x02	; 2
    3480:	ff 4f       	sbci	r31, 0xFF	; 255
    3482:	8f 4f       	sbci	r24, 0xFF	; 255
    3484:	0c 94 12 20 	jmp	0x4024	; 0x4024 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3488:	82 e0       	ldi	r24, 0x02	; 2
    348a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    348c:	31 c0       	rjmp	.+98     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    348e:	88 e0       	ldi	r24, 0x08	; 8
    3490:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3492:	2e c0       	rjmp	.+92     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3494:	8a e0       	ldi	r24, 0x0A	; 10
    3496:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3498:	2b c0       	rjmp	.+86     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    349a:	80 e1       	ldi	r24, 0x10	; 16
    349c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    349e:	28 c0       	rjmp	.+80     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    34a0:	81 e0       	ldi	r24, 0x01	; 1
    34a2:	8b 83       	std	Y+3, r24	; 0x03
			break;
    34a4:	25 c0       	rjmp	.+74     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    34a6:	1b 82       	std	Y+3, r1	; 0x03
			break;
    34a8:	23 c0       	rjmp	.+70     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    34aa:	e8 81       	ld	r30, Y
    34ac:	f9 81       	ldd	r31, Y+1	; 0x01
    34ae:	02 80       	ldd	r0, Z+2	; 0x02
    34b0:	f3 81       	ldd	r31, Z+3	; 0x03
    34b2:	e0 2d       	mov	r30, r0
    34b4:	6d e0       	ldi	r22, 0x0D	; 13
    34b6:	ce 01       	movw	r24, r28
    34b8:	19 95       	eicall
    34ba:	e8 81       	ld	r30, Y
    34bc:	f9 81       	ldd	r31, Y+1	; 0x01
    34be:	02 80       	ldd	r0, Z+2	; 0x02
    34c0:	f3 81       	ldd	r31, Z+3	; 0x03
    34c2:	e0 2d       	mov	r30, r0
    34c4:	6a e0       	ldi	r22, 0x0A	; 10
    34c6:	ce 01       	movw	r24, r28
    34c8:	19 95       	eicall
			break;
    34ca:	12 c0       	rjmp	.+36     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    34cc:	e8 81       	ld	r30, Y
    34ce:	f9 81       	ldd	r31, Y+1	; 0x01
    34d0:	02 84       	ldd	r0, Z+10	; 0x0a
    34d2:	f3 85       	ldd	r31, Z+11	; 0x0b
    34d4:	e0 2d       	mov	r30, r0
    34d6:	ce 01       	movw	r24, r28
    34d8:	19 95       	eicall
			break;
    34da:	0a c0       	rjmp	.+20     	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    34dc:	e8 81       	ld	r30, Y
    34de:	f9 81       	ldd	r31, Y+1	; 0x01
    34e0:	00 84       	ldd	r0, Z+8	; 0x08
    34e2:	f1 85       	ldd	r31, Z+9	; 0x09
    34e4:	e0 2d       	mov	r30, r0
    34e6:	ce 01       	movw	r24, r28
    34e8:	19 95       	eicall
			break;
    34ea:	02 c0       	rjmp	.+4      	; 0x34f0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    34ec:	81 e0       	ldi	r24, 0x01	; 1
    34ee:	8c 83       	std	Y+4, r24	; 0x04
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
<<<<<<< HEAD
    33a0:	ce 01       	movw	r24, r28
    33a2:	df 91       	pop	r29
    33a4:	cf 91       	pop	r28
    33a6:	08 95       	ret

000033a8 <_ZN8emstreamlsEi>:
=======
    34f0:	ce 01       	movw	r24, r28
    34f2:	df 91       	pop	r29
    34f4:	cf 91       	pop	r28
    34f6:	08 95       	ret

000034f8 <_ZN8emstreamlsEi>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
<<<<<<< HEAD
    33a8:	0f 93       	push	r16
    33aa:	1f 93       	push	r17
    33ac:	cf 93       	push	r28
    33ae:	df 93       	push	r29
    33b0:	cd b7       	in	r28, 0x3d	; 61
    33b2:	de b7       	in	r29, 0x3e	; 62
    33b4:	61 97       	sbiw	r28, 0x11	; 17
    33b6:	cd bf       	out	0x3d, r28	; 61
    33b8:	de bf       	out	0x3e, r29	; 62
    33ba:	8c 01       	movw	r16, r24
    33bc:	9b 01       	movw	r18, r22
	if (base != 10)
    33be:	fc 01       	movw	r30, r24
    33c0:	92 81       	ldd	r25, Z+2	; 0x02
    33c2:	9a 30       	cpi	r25, 0x0A	; 10
    33c4:	21 f0       	breq	.+8      	; 0x33ce <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    33c6:	c8 01       	movw	r24, r16
    33c8:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_ZN8emstreamlsEj>
    33cc:	0d c0       	rjmp	.+26     	; 0x33e8 <_ZN8emstreamlsEi+0x40>
=======
    34f8:	0f 93       	push	r16
    34fa:	1f 93       	push	r17
    34fc:	cf 93       	push	r28
    34fe:	df 93       	push	r29
    3500:	cd b7       	in	r28, 0x3d	; 61
    3502:	de b7       	in	r29, 0x3e	; 62
    3504:	61 97       	sbiw	r28, 0x11	; 17
    3506:	cd bf       	out	0x3d, r28	; 61
    3508:	de bf       	out	0x3e, r29	; 62
    350a:	8c 01       	movw	r16, r24
    350c:	9b 01       	movw	r18, r22
	if (base != 10)
    350e:	fc 01       	movw	r30, r24
    3510:	92 81       	ldd	r25, Z+2	; 0x02
    3512:	9a 30       	cpi	r25, 0x0A	; 10
    3514:	21 f0       	breq	.+8      	; 0x351e <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    3516:	c8 01       	movw	r24, r16
    3518:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <_ZN8emstreamlsEj>
    351c:	0d c0       	rjmp	.+26     	; 0x3538 <_ZN8emstreamlsEi+0x40>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
<<<<<<< HEAD
    33ce:	4a e0       	ldi	r20, 0x0A	; 10
    33d0:	be 01       	movw	r22, r28
    33d2:	6f 5f       	subi	r22, 0xFF	; 255
    33d4:	7f 4f       	sbci	r23, 0xFF	; 255
    33d6:	c9 01       	movw	r24, r18
    33d8:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <__itoa_ncheck>
=======
    351e:	4a e0       	ldi	r20, 0x0A	; 10
    3520:	be 01       	movw	r22, r28
    3522:	6f 5f       	subi	r22, 0xFF	; 255
    3524:	7f 4f       	sbci	r23, 0xFF	; 255
    3526:	c9 01       	movw	r24, r18
    3528:	0e 94 7f 20 	call	0x40fe	; 0x40fe <__itoa_ncheck>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
<<<<<<< HEAD
    33dc:	be 01       	movw	r22, r28
    33de:	6f 5f       	subi	r22, 0xFF	; 255
    33e0:	7f 4f       	sbci	r23, 0xFF	; 255
    33e2:	c8 01       	movw	r24, r16
    33e4:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
=======
    352c:	be 01       	movw	r22, r28
    352e:	6f 5f       	subi	r22, 0xFF	; 255
    3530:	7f 4f       	sbci	r23, 0xFF	; 255
    3532:	c8 01       	movw	r24, r16
    3534:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3538:	c8 01       	movw	r24, r16
    353a:	61 96       	adiw	r28, 0x11	; 17
    353c:	cd bf       	out	0x3d, r28	; 61
    353e:	de bf       	out	0x3e, r29	; 62
    3540:	df 91       	pop	r29
    3542:	cf 91       	pop	r28
    3544:	1f 91       	pop	r17
    3546:	0f 91       	pop	r16
    3548:	08 95       	ret

0000354a <_ZN8emstreamlsEl>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (int32_t num)
{
    354a:	0f 93       	push	r16
    354c:	1f 93       	push	r17
    354e:	cf 93       	push	r28
    3550:	df 93       	push	r29
    3552:	cd b7       	in	r28, 0x3d	; 61
    3554:	de b7       	in	r29, 0x3e	; 62
    3556:	a2 97       	sbiw	r28, 0x22	; 34
    3558:	cd bf       	out	0x3d, r28	; 61
    355a:	de bf       	out	0x3e, r29	; 62
    355c:	8c 01       	movw	r16, r24
    355e:	cb 01       	movw	r24, r22
    3560:	ba 01       	movw	r22, r20
	if (base != 10)
    3562:	f8 01       	movw	r30, r16
    3564:	22 81       	ldd	r18, Z+2	; 0x02
    3566:	2a 30       	cpi	r18, 0x0A	; 10
    3568:	31 f0       	breq	.+12     	; 0x3576 <_ZN8emstreamlsEl+0x2c>
	{
		*this << (uint32_t)num;
    356a:	ab 01       	movw	r20, r22
    356c:	bc 01       	movw	r22, r24
    356e:	c8 01       	movw	r24, r16
    3570:	0e 94 04 1b 	call	0x3608	; 0x3608 <_ZN8emstreamlsEm>
    3574:	0c c0       	rjmp	.+24     	; 0x358e <_ZN8emstreamlsEl+0x44>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__ltoa_ncheck (long, char *, unsigned char);
	return __ltoa_ncheck (__val, __s, __radix);
    3576:	2a e0       	ldi	r18, 0x0A	; 10
    3578:	ae 01       	movw	r20, r28
    357a:	4f 5f       	subi	r20, 0xFF	; 255
    357c:	5f 4f       	sbci	r21, 0xFF	; 255
    357e:	0e 94 8a 20 	call	0x4114	; 0x4114 <__ltoa_ncheck>
	}
	else
	{
		char out_str[34];
		ltoa ((long)num, out_str, base);
		puts (out_str);
    3582:	be 01       	movw	r22, r28
    3584:	6f 5f       	subi	r22, 0xFF	; 255
    3586:	7f 4f       	sbci	r23, 0xFF	; 255
    3588:	c8 01       	movw	r24, r16
    358a:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}

	return (*this);
}
<<<<<<< HEAD
    33e8:	c8 01       	movw	r24, r16
    33ea:	61 96       	adiw	r28, 0x11	; 17
    33ec:	cd bf       	out	0x3d, r28	; 61
    33ee:	de bf       	out	0x3e, r29	; 62
    33f0:	df 91       	pop	r29
    33f2:	cf 91       	pop	r28
    33f4:	1f 91       	pop	r17
    33f6:	0f 91       	pop	r16
    33f8:	08 95       	ret

000033fa <_ZN8emstreamlsEj>:
=======
    358e:	c8 01       	movw	r24, r16
    3590:	a2 96       	adiw	r28, 0x22	; 34
    3592:	cd bf       	out	0x3d, r28	; 61
    3594:	de bf       	out	0x3e, r29	; 62
    3596:	df 91       	pop	r29
    3598:	cf 91       	pop	r28
    359a:	1f 91       	pop	r17
    359c:	0f 91       	pop	r16
    359e:	08 95       	ret

000035a0 <_ZN8emstreamlsEj>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
<<<<<<< HEAD
    33fa:	ff 92       	push	r15
    33fc:	0f 93       	push	r16
    33fe:	1f 93       	push	r17
    3400:	cf 93       	push	r28
    3402:	df 93       	push	r29
    3404:	cd b7       	in	r28, 0x3d	; 61
    3406:	de b7       	in	r29, 0x3e	; 62
    3408:	61 97       	sbiw	r28, 0x11	; 17
    340a:	cd bf       	out	0x3d, r28	; 61
    340c:	de bf       	out	0x3e, r29	; 62
    340e:	8c 01       	movw	r16, r24
    3410:	f6 2e       	mov	r15, r22
    3412:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3414:	f8 01       	movw	r30, r16
    3416:	42 81       	ldd	r20, Z+2	; 0x02
    3418:	40 31       	cpi	r20, 0x10	; 16
    341a:	21 f0       	breq	.+8      	; 0x3424 <_ZN8emstreamlsEj+0x2a>
    341c:	48 30       	cpi	r20, 0x08	; 8
    341e:	11 f0       	breq	.+4      	; 0x3424 <_ZN8emstreamlsEj+0x2a>
    3420:	42 30       	cpi	r20, 0x02	; 2
    3422:	41 f4       	brne	.+16     	; 0x3434 <_ZN8emstreamlsEj+0x3a>
=======
    35a0:	ff 92       	push	r15
    35a2:	0f 93       	push	r16
    35a4:	1f 93       	push	r17
    35a6:	cf 93       	push	r28
    35a8:	df 93       	push	r29
    35aa:	cd b7       	in	r28, 0x3d	; 61
    35ac:	de b7       	in	r29, 0x3e	; 62
    35ae:	61 97       	sbiw	r28, 0x11	; 17
    35b0:	cd bf       	out	0x3d, r28	; 61
    35b2:	de bf       	out	0x3e, r29	; 62
    35b4:	8c 01       	movw	r16, r24
    35b6:	f6 2e       	mov	r15, r22
    35b8:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    35ba:	f8 01       	movw	r30, r16
    35bc:	42 81       	ldd	r20, Z+2	; 0x02
    35be:	40 31       	cpi	r20, 0x10	; 16
    35c0:	21 f0       	breq	.+8      	; 0x35ca <_ZN8emstreamlsEj+0x2a>
    35c2:	48 30       	cpi	r20, 0x08	; 8
    35c4:	11 f0       	breq	.+4      	; 0x35ca <_ZN8emstreamlsEj+0x2a>
    35c6:	42 30       	cpi	r20, 0x02	; 2
    35c8:	41 f4       	brne	.+16     	; 0x35da <_ZN8emstreamlsEj+0x3a>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
<<<<<<< HEAD
    3424:	69 2f       	mov	r22, r25
    3426:	c8 01       	movw	r24, r16
    3428:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
    342c:	6f 2d       	mov	r22, r15
    342e:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
    3432:	0d c0       	rjmp	.+26     	; 0x344e <_ZN8emstreamlsEj+0x54>
=======
    35ca:	69 2f       	mov	r22, r25
    35cc:	c8 01       	movw	r24, r16
    35ce:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    35d2:	6f 2d       	mov	r22, r15
    35d4:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    35d8:	0d c0       	rjmp	.+26     	; 0x35f4 <_ZN8emstreamlsEj+0x54>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
<<<<<<< HEAD
    3434:	50 e0       	ldi	r21, 0x00	; 0
    3436:	be 01       	movw	r22, r28
    3438:	6f 5f       	subi	r22, 0xFF	; 255
    343a:	7f 4f       	sbci	r23, 0xFF	; 255
    343c:	8f 2d       	mov	r24, r15
    343e:	0e 94 d9 1f 	call	0x3fb2	; 0x3fb2 <utoa>
=======
    35da:	50 e0       	ldi	r21, 0x00	; 0
    35dc:	be 01       	movw	r22, r28
    35de:	6f 5f       	subi	r22, 0xFF	; 255
    35e0:	7f 4f       	sbci	r23, 0xFF	; 255
    35e2:	8f 2d       	mov	r24, r15
    35e4:	0e 94 c6 20 	call	0x418c	; 0x418c <utoa>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
<<<<<<< HEAD
    3442:	be 01       	movw	r22, r28
    3444:	6f 5f       	subi	r22, 0xFF	; 255
    3446:	7f 4f       	sbci	r23, 0xFF	; 255
    3448:	c8 01       	movw	r24, r16
    344a:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
=======
    35e8:	be 01       	movw	r22, r28
    35ea:	6f 5f       	subi	r22, 0xFF	; 255
    35ec:	7f 4f       	sbci	r23, 0xFF	; 255
    35ee:	c8 01       	movw	r24, r16
    35f0:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}

	return (*this);
}
<<<<<<< HEAD
    344e:	c8 01       	movw	r24, r16
    3450:	61 96       	adiw	r28, 0x11	; 17
    3452:	cd bf       	out	0x3d, r28	; 61
    3454:	de bf       	out	0x3e, r29	; 62
    3456:	df 91       	pop	r29
    3458:	cf 91       	pop	r28
    345a:	1f 91       	pop	r17
    345c:	0f 91       	pop	r16
    345e:	ff 90       	pop	r15
    3460:	08 95       	ret

00003462 <_ZN8emstreamlsEm>:
=======
    35f4:	c8 01       	movw	r24, r16
    35f6:	61 96       	adiw	r28, 0x11	; 17
    35f8:	cd bf       	out	0x3d, r28	; 61
    35fa:	de bf       	out	0x3e, r29	; 62
    35fc:	df 91       	pop	r29
    35fe:	cf 91       	pop	r28
    3600:	1f 91       	pop	r17
    3602:	0f 91       	pop	r16
    3604:	ff 90       	pop	r15
    3606:	08 95       	ret

00003608 <_ZN8emstreamlsEm>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
<<<<<<< HEAD
    3462:	df 92       	push	r13
    3464:	ef 92       	push	r14
    3466:	ff 92       	push	r15
    3468:	0f 93       	push	r16
    346a:	1f 93       	push	r17
    346c:	cf 93       	push	r28
    346e:	df 93       	push	r29
    3470:	cd b7       	in	r28, 0x3d	; 61
    3472:	de b7       	in	r29, 0x3e	; 62
    3474:	a1 97       	sbiw	r28, 0x21	; 33
    3476:	cd bf       	out	0x3d, r28	; 61
    3478:	de bf       	out	0x3e, r29	; 62
    347a:	8c 01       	movw	r16, r24
    347c:	d4 2e       	mov	r13, r20
    347e:	e5 2e       	mov	r14, r21
    3480:	f6 2e       	mov	r15, r22
    3482:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3484:	f8 01       	movw	r30, r16
    3486:	22 81       	ldd	r18, Z+2	; 0x02
    3488:	20 31       	cpi	r18, 0x10	; 16
    348a:	21 f0       	breq	.+8      	; 0x3494 <_ZN8emstreamlsEm+0x32>
    348c:	28 30       	cpi	r18, 0x08	; 8
    348e:	11 f0       	breq	.+4      	; 0x3494 <_ZN8emstreamlsEm+0x32>
    3490:	22 30       	cpi	r18, 0x02	; 2
    3492:	71 f4       	brne	.+28     	; 0x34b0 <_ZN8emstreamlsEm+0x4e>
=======
    3608:	df 92       	push	r13
    360a:	ef 92       	push	r14
    360c:	ff 92       	push	r15
    360e:	0f 93       	push	r16
    3610:	1f 93       	push	r17
    3612:	cf 93       	push	r28
    3614:	df 93       	push	r29
    3616:	cd b7       	in	r28, 0x3d	; 61
    3618:	de b7       	in	r29, 0x3e	; 62
    361a:	a1 97       	sbiw	r28, 0x21	; 33
    361c:	cd bf       	out	0x3d, r28	; 61
    361e:	de bf       	out	0x3e, r29	; 62
    3620:	8c 01       	movw	r16, r24
    3622:	d4 2e       	mov	r13, r20
    3624:	e5 2e       	mov	r14, r21
    3626:	f6 2e       	mov	r15, r22
    3628:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    362a:	f8 01       	movw	r30, r16
    362c:	22 81       	ldd	r18, Z+2	; 0x02
    362e:	20 31       	cpi	r18, 0x10	; 16
    3630:	21 f0       	breq	.+8      	; 0x363a <_ZN8emstreamlsEm+0x32>
    3632:	28 30       	cpi	r18, 0x08	; 8
    3634:	11 f0       	breq	.+4      	; 0x363a <_ZN8emstreamlsEm+0x32>
    3636:	22 30       	cpi	r18, 0x02	; 2
    3638:	71 f4       	brne	.+28     	; 0x3656 <_ZN8emstreamlsEm+0x4e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
<<<<<<< HEAD
    3494:	69 2f       	mov	r22, r25
    3496:	c8 01       	movw	r24, r16
    3498:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
    349c:	6f 2d       	mov	r22, r15
    349e:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
    34a2:	6e 2d       	mov	r22, r14
    34a4:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
    34a8:	6d 2d       	mov	r22, r13
    34aa:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <_ZN8emstreamlsEh>
    34ae:	0f c0       	rjmp	.+30     	; 0x34ce <_ZN8emstreamlsEm+0x6c>
=======
    363a:	69 2f       	mov	r22, r25
    363c:	c8 01       	movw	r24, r16
    363e:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    3642:	6f 2d       	mov	r22, r15
    3644:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    3648:	6e 2d       	mov	r22, r14
    364a:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    364e:	6d 2d       	mov	r22, r13
    3650:	0e 94 46 1b 	call	0x368c	; 0x368c <_ZN8emstreamlsEh>
    3654:	0f c0       	rjmp	.+30     	; 0x3674 <_ZN8emstreamlsEm+0x6c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
<<<<<<< HEAD
    34b0:	30 e0       	ldi	r19, 0x00	; 0
    34b2:	ae 01       	movw	r20, r28
    34b4:	4f 5f       	subi	r20, 0xFF	; 255
    34b6:	5f 4f       	sbci	r21, 0xFF	; 255
    34b8:	6d 2d       	mov	r22, r13
    34ba:	7e 2d       	mov	r23, r14
    34bc:	8f 2d       	mov	r24, r15
    34be:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <ultoa>
=======
    3656:	30 e0       	ldi	r19, 0x00	; 0
    3658:	ae 01       	movw	r20, r28
    365a:	4f 5f       	subi	r20, 0xFF	; 255
    365c:	5f 4f       	sbci	r21, 0xFF	; 255
    365e:	6d 2d       	mov	r22, r13
    3660:	7e 2d       	mov	r23, r14
    3662:	8f 2d       	mov	r24, r15
    3664:	0e 94 99 20 	call	0x4132	; 0x4132 <ultoa>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
<<<<<<< HEAD
    34c2:	be 01       	movw	r22, r28
    34c4:	6f 5f       	subi	r22, 0xFF	; 255
    34c6:	7f 4f       	sbci	r23, 0xFF	; 255
    34c8:	c8 01       	movw	r24, r16
    34ca:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
=======
    3668:	be 01       	movw	r22, r28
    366a:	6f 5f       	subi	r22, 0xFF	; 255
    366c:	7f 4f       	sbci	r23, 0xFF	; 255
    366e:	c8 01       	movw	r24, r16
    3670:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}

	return (*this);
}
<<<<<<< HEAD
    34ce:	c8 01       	movw	r24, r16
    34d0:	a1 96       	adiw	r28, 0x21	; 33
    34d2:	cd bf       	out	0x3d, r28	; 61
    34d4:	de bf       	out	0x3e, r29	; 62
    34d6:	df 91       	pop	r29
    34d8:	cf 91       	pop	r28
    34da:	1f 91       	pop	r17
    34dc:	0f 91       	pop	r16
    34de:	ff 90       	pop	r15
    34e0:	ef 90       	pop	r14
    34e2:	df 90       	pop	r13
    34e4:	08 95       	ret

000034e6 <_ZN8emstreamlsEh>:
=======
    3674:	c8 01       	movw	r24, r16
    3676:	a1 96       	adiw	r28, 0x21	; 33
    3678:	cd bf       	out	0x3d, r28	; 61
    367a:	de bf       	out	0x3e, r29	; 62
    367c:	df 91       	pop	r29
    367e:	cf 91       	pop	r28
    3680:	1f 91       	pop	r17
    3682:	0f 91       	pop	r16
    3684:	ff 90       	pop	r15
    3686:	ef 90       	pop	r14
    3688:	df 90       	pop	r13
    368a:	08 95       	ret

0000368c <_ZN8emstreamlsEh>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
<<<<<<< HEAD
    34e6:	cf 92       	push	r12
    34e8:	df 92       	push	r13
    34ea:	ef 92       	push	r14
    34ec:	ff 92       	push	r15
    34ee:	0f 93       	push	r16
    34f0:	1f 93       	push	r17
    34f2:	cf 93       	push	r28
    34f4:	df 93       	push	r29
    34f6:	cd b7       	in	r28, 0x3d	; 61
    34f8:	de b7       	in	r29, 0x3e	; 62
    34fa:	29 97       	sbiw	r28, 0x09	; 9
    34fc:	cd bf       	out	0x3d, r28	; 61
    34fe:	de bf       	out	0x3e, r29	; 62
    3500:	8c 01       	movw	r16, r24
    3502:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3504:	dc 01       	movw	r26, r24
    3506:	13 96       	adiw	r26, 0x03	; 3
    3508:	8c 91       	ld	r24, X
    350a:	13 97       	sbiw	r26, 0x03	; 3
    350c:	88 23       	and	r24, r24
    350e:	41 f0       	breq	.+16     	; 0x3520 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3510:	ed 91       	ld	r30, X+
    3512:	fc 91       	ld	r31, X
    3514:	02 80       	ldd	r0, Z+2	; 0x02
    3516:	f3 81       	ldd	r31, Z+3	; 0x03
    3518:	e0 2d       	mov	r30, r0
    351a:	c8 01       	movw	r24, r16
    351c:	19 95       	eicall
    351e:	56 c0       	rjmp	.+172    	; 0x35cc <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3520:	f8 01       	movw	r30, r16
    3522:	42 81       	ldd	r20, Z+2	; 0x02
    3524:	42 30       	cpi	r20, 0x02	; 2
    3526:	19 f5       	brne	.+70     	; 0x356e <_ZN8emstreamlsEh+0x88>
    3528:	68 94       	set
    352a:	cc 24       	eor	r12, r12
    352c:	c3 f8       	bld	r12, 3
    352e:	d1 2c       	mov	r13, r1
    3530:	68 94       	set
    3532:	ff 24       	eor	r15, r15
    3534:	f7 f8       	bld	r15, 7
=======
    368c:	cf 92       	push	r12
    368e:	df 92       	push	r13
    3690:	ef 92       	push	r14
    3692:	ff 92       	push	r15
    3694:	0f 93       	push	r16
    3696:	1f 93       	push	r17
    3698:	cf 93       	push	r28
    369a:	df 93       	push	r29
    369c:	cd b7       	in	r28, 0x3d	; 61
    369e:	de b7       	in	r29, 0x3e	; 62
    36a0:	29 97       	sbiw	r28, 0x09	; 9
    36a2:	cd bf       	out	0x3d, r28	; 61
    36a4:	de bf       	out	0x3e, r29	; 62
    36a6:	8c 01       	movw	r16, r24
    36a8:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    36aa:	dc 01       	movw	r26, r24
    36ac:	13 96       	adiw	r26, 0x03	; 3
    36ae:	8c 91       	ld	r24, X
    36b0:	13 97       	sbiw	r26, 0x03	; 3
    36b2:	88 23       	and	r24, r24
    36b4:	41 f0       	breq	.+16     	; 0x36c6 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    36b6:	ed 91       	ld	r30, X+
    36b8:	fc 91       	ld	r31, X
    36ba:	02 80       	ldd	r0, Z+2	; 0x02
    36bc:	f3 81       	ldd	r31, Z+3	; 0x03
    36be:	e0 2d       	mov	r30, r0
    36c0:	c8 01       	movw	r24, r16
    36c2:	19 95       	eicall
    36c4:	56 c0       	rjmp	.+172    	; 0x3772 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    36c6:	f8 01       	movw	r30, r16
    36c8:	42 81       	ldd	r20, Z+2	; 0x02
    36ca:	42 30       	cpi	r20, 0x02	; 2
    36cc:	19 f5       	brne	.+70     	; 0x3714 <_ZN8emstreamlsEh+0x88>
    36ce:	68 94       	set
    36d0:	cc 24       	eor	r12, r12
    36d2:	c3 f8       	bld	r12, 3
    36d4:	d1 2c       	mov	r13, r1
    36d6:	68 94       	set
    36d8:	ff 24       	eor	r15, r15
    36da:	f7 f8       	bld	r15, 7
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
<<<<<<< HEAD
    3536:	8e 2d       	mov	r24, r14
    3538:	8f 21       	and	r24, r15
    353a:	51 f0       	breq	.+20     	; 0x3550 <_ZN8emstreamlsEh+0x6a>
    353c:	d8 01       	movw	r26, r16
    353e:	ed 91       	ld	r30, X+
    3540:	fc 91       	ld	r31, X
    3542:	02 80       	ldd	r0, Z+2	; 0x02
    3544:	f3 81       	ldd	r31, Z+3	; 0x03
    3546:	e0 2d       	mov	r30, r0
    3548:	61 e3       	ldi	r22, 0x31	; 49
    354a:	c8 01       	movw	r24, r16
    354c:	19 95       	eicall
    354e:	09 c0       	rjmp	.+18     	; 0x3562 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3550:	d8 01       	movw	r26, r16
    3552:	ed 91       	ld	r30, X+
    3554:	fc 91       	ld	r31, X
    3556:	02 80       	ldd	r0, Z+2	; 0x02
    3558:	f3 81       	ldd	r31, Z+3	; 0x03
    355a:	e0 2d       	mov	r30, r0
    355c:	60 e3       	ldi	r22, 0x30	; 48
    355e:	c8 01       	movw	r24, r16
    3560:	19 95       	eicall
=======
    36dc:	8e 2d       	mov	r24, r14
    36de:	8f 21       	and	r24, r15
    36e0:	51 f0       	breq	.+20     	; 0x36f6 <_ZN8emstreamlsEh+0x6a>
    36e2:	d8 01       	movw	r26, r16
    36e4:	ed 91       	ld	r30, X+
    36e6:	fc 91       	ld	r31, X
    36e8:	02 80       	ldd	r0, Z+2	; 0x02
    36ea:	f3 81       	ldd	r31, Z+3	; 0x03
    36ec:	e0 2d       	mov	r30, r0
    36ee:	61 e3       	ldi	r22, 0x31	; 49
    36f0:	c8 01       	movw	r24, r16
    36f2:	19 95       	eicall
    36f4:	09 c0       	rjmp	.+18     	; 0x3708 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    36f6:	d8 01       	movw	r26, r16
    36f8:	ed 91       	ld	r30, X+
    36fa:	fc 91       	ld	r31, X
    36fc:	02 80       	ldd	r0, Z+2	; 0x02
    36fe:	f3 81       	ldd	r31, Z+3	; 0x03
    3700:	e0 2d       	mov	r30, r0
    3702:	60 e3       	ldi	r22, 0x30	; 48
    3704:	c8 01       	movw	r24, r16
    3706:	19 95       	eicall
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
<<<<<<< HEAD
    3562:	f6 94       	lsr	r15
    3564:	b1 e0       	ldi	r27, 0x01	; 1
    3566:	cb 1a       	sub	r12, r27
    3568:	d1 08       	sbc	r13, r1
    356a:	29 f7       	brne	.-54     	; 0x3536 <_ZN8emstreamlsEh+0x50>
    356c:	2f c0       	rjmp	.+94     	; 0x35cc <_ZN8emstreamlsEh+0xe6>
=======
    3708:	f6 94       	lsr	r15
    370a:	b1 e0       	ldi	r27, 0x01	; 1
    370c:	cb 1a       	sub	r12, r27
    370e:	d1 08       	sbc	r13, r1
    3710:	29 f7       	brne	.-54     	; 0x36dc <_ZN8emstreamlsEh+0x50>
    3712:	2f c0       	rjmp	.+94     	; 0x3772 <_ZN8emstreamlsEh+0xe6>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
<<<<<<< HEAD
    356e:	40 31       	cpi	r20, 0x10	; 16
    3570:	f9 f4       	brne	.+62     	; 0x35b0 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3572:	62 95       	swap	r22
    3574:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3576:	01 90       	ld	r0, Z+
    3578:	f0 81       	ld	r31, Z
    357a:	e0 2d       	mov	r30, r0
    357c:	02 80       	ldd	r0, Z+2	; 0x02
    357e:	f3 81       	ldd	r31, Z+3	; 0x03
    3580:	e0 2d       	mov	r30, r0
    3582:	6a 30       	cpi	r22, 0x0A	; 10
    3584:	10 f0       	brcs	.+4      	; 0x358a <_ZN8emstreamlsEh+0xa4>
    3586:	69 5c       	subi	r22, 0xC9	; 201
    3588:	01 c0       	rjmp	.+2      	; 0x358c <_ZN8emstreamlsEh+0xa6>
    358a:	60 5d       	subi	r22, 0xD0	; 208
    358c:	c8 01       	movw	r24, r16
    358e:	19 95       	eicall
		temp_char = num & 0x0F;
    3590:	6e 2d       	mov	r22, r14
    3592:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3594:	d8 01       	movw	r26, r16
    3596:	ed 91       	ld	r30, X+
    3598:	fc 91       	ld	r31, X
    359a:	02 80       	ldd	r0, Z+2	; 0x02
    359c:	f3 81       	ldd	r31, Z+3	; 0x03
    359e:	e0 2d       	mov	r30, r0
    35a0:	6a 30       	cpi	r22, 0x0A	; 10
    35a2:	10 f0       	brcs	.+4      	; 0x35a8 <_ZN8emstreamlsEh+0xc2>
    35a4:	69 5c       	subi	r22, 0xC9	; 201
    35a6:	01 c0       	rjmp	.+2      	; 0x35aa <_ZN8emstreamlsEh+0xc4>
    35a8:	60 5d       	subi	r22, 0xD0	; 208
    35aa:	c8 01       	movw	r24, r16
    35ac:	19 95       	eicall
    35ae:	0e c0       	rjmp	.+28     	; 0x35cc <_ZN8emstreamlsEh+0xe6>
=======
    3714:	40 31       	cpi	r20, 0x10	; 16
    3716:	f9 f4       	brne	.+62     	; 0x3756 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3718:	62 95       	swap	r22
    371a:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    371c:	01 90       	ld	r0, Z+
    371e:	f0 81       	ld	r31, Z
    3720:	e0 2d       	mov	r30, r0
    3722:	02 80       	ldd	r0, Z+2	; 0x02
    3724:	f3 81       	ldd	r31, Z+3	; 0x03
    3726:	e0 2d       	mov	r30, r0
    3728:	6a 30       	cpi	r22, 0x0A	; 10
    372a:	10 f0       	brcs	.+4      	; 0x3730 <_ZN8emstreamlsEh+0xa4>
    372c:	69 5c       	subi	r22, 0xC9	; 201
    372e:	01 c0       	rjmp	.+2      	; 0x3732 <_ZN8emstreamlsEh+0xa6>
    3730:	60 5d       	subi	r22, 0xD0	; 208
    3732:	c8 01       	movw	r24, r16
    3734:	19 95       	eicall
		temp_char = num & 0x0F;
    3736:	6e 2d       	mov	r22, r14
    3738:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    373a:	d8 01       	movw	r26, r16
    373c:	ed 91       	ld	r30, X+
    373e:	fc 91       	ld	r31, X
    3740:	02 80       	ldd	r0, Z+2	; 0x02
    3742:	f3 81       	ldd	r31, Z+3	; 0x03
    3744:	e0 2d       	mov	r30, r0
    3746:	6a 30       	cpi	r22, 0x0A	; 10
    3748:	10 f0       	brcs	.+4      	; 0x374e <_ZN8emstreamlsEh+0xc2>
    374a:	69 5c       	subi	r22, 0xC9	; 201
    374c:	01 c0       	rjmp	.+2      	; 0x3750 <_ZN8emstreamlsEh+0xc4>
    374e:	60 5d       	subi	r22, 0xD0	; 208
    3750:	c8 01       	movw	r24, r16
    3752:	19 95       	eicall
    3754:	0e c0       	rjmp	.+28     	; 0x3772 <_ZN8emstreamlsEh+0xe6>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
<<<<<<< HEAD
    35b0:	50 e0       	ldi	r21, 0x00	; 0
    35b2:	be 01       	movw	r22, r28
    35b4:	6f 5f       	subi	r22, 0xFF	; 255
    35b6:	7f 4f       	sbci	r23, 0xFF	; 255
    35b8:	8e 2d       	mov	r24, r14
    35ba:	90 e0       	ldi	r25, 0x00	; 0
    35bc:	0e 94 d9 1f 	call	0x3fb2	; 0x3fb2 <utoa>
=======
    3756:	50 e0       	ldi	r21, 0x00	; 0
    3758:	be 01       	movw	r22, r28
    375a:	6f 5f       	subi	r22, 0xFF	; 255
    375c:	7f 4f       	sbci	r23, 0xFF	; 255
    375e:	8e 2d       	mov	r24, r14
    3760:	90 e0       	ldi	r25, 0x00	; 0
    3762:	0e 94 c6 20 	call	0x418c	; 0x418c <utoa>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
<<<<<<< HEAD
    35c0:	be 01       	movw	r22, r28
    35c2:	6f 5f       	subi	r22, 0xFF	; 255
    35c4:	7f 4f       	sbci	r23, 0xFF	; 255
    35c6:	c8 01       	movw	r24, r16
    35c8:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    35cc:	c8 01       	movw	r24, r16
    35ce:	29 96       	adiw	r28, 0x09	; 9
    35d0:	cd bf       	out	0x3d, r28	; 61
    35d2:	de bf       	out	0x3e, r29	; 62
    35d4:	df 91       	pop	r29
    35d6:	cf 91       	pop	r28
    35d8:	1f 91       	pop	r17
    35da:	0f 91       	pop	r16
    35dc:	ff 90       	pop	r15
    35de:	ef 90       	pop	r14
    35e0:	df 90       	pop	r13
    35e2:	cf 90       	pop	r12
    35e4:	08 95       	ret

000035e6 <_ZN5rs2327putcharEc>:
=======
    3766:	be 01       	movw	r22, r28
    3768:	6f 5f       	subi	r22, 0xFF	; 255
    376a:	7f 4f       	sbci	r23, 0xFF	; 255
    376c:	c8 01       	movw	r24, r16
    376e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3772:	c8 01       	movw	r24, r16
    3774:	29 96       	adiw	r28, 0x09	; 9
    3776:	cd bf       	out	0x3d, r28	; 61
    3778:	de bf       	out	0x3e, r29	; 62
    377a:	df 91       	pop	r29
    377c:	cf 91       	pop	r28
    377e:	1f 91       	pop	r17
    3780:	0f 91       	pop	r16
    3782:	ff 90       	pop	r15
    3784:	ef 90       	pop	r14
    3786:	df 90       	pop	r13
    3788:	cf 90       	pop	r12
    378a:	08 95       	ret

0000378c <_ZN5rs2327putcharEc>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
<<<<<<< HEAD
    35e6:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    35e8:	50 96       	adiw	r26, 0x10	; 16
    35ea:	ed 91       	ld	r30, X+
    35ec:	fc 91       	ld	r31, X
    35ee:	51 97       	sbiw	r26, 0x11	; 17
    35f0:	80 81       	ld	r24, Z
    35f2:	54 96       	adiw	r26, 0x14	; 20
    35f4:	4c 91       	ld	r20, X
    35f6:	54 97       	sbiw	r26, 0x14	; 20
    35f8:	84 23       	and	r24, r20
    35fa:	29 f0       	breq	.+10     	; 0x3606 <_ZN5rs2327putcharEc+0x20>
    35fc:	09 c0       	rjmp	.+18     	; 0x3610 <_ZN5rs2327putcharEc+0x2a>
    35fe:	21 50       	subi	r18, 0x01	; 1
    3600:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3602:	19 f4       	brne	.+6      	; 0x360a <_ZN5rs2327putcharEc+0x24>
    3604:	12 c0       	rjmp	.+36     	; 0x362a <_ZN5rs2327putcharEc+0x44>
=======
    378c:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    378e:	50 96       	adiw	r26, 0x10	; 16
    3790:	ed 91       	ld	r30, X+
    3792:	fc 91       	ld	r31, X
    3794:	51 97       	sbiw	r26, 0x11	; 17
    3796:	80 81       	ld	r24, Z
    3798:	54 96       	adiw	r26, 0x14	; 20
    379a:	4c 91       	ld	r20, X
    379c:	54 97       	sbiw	r26, 0x14	; 20
    379e:	84 23       	and	r24, r20
    37a0:	29 f0       	breq	.+10     	; 0x37ac <_ZN5rs2327putcharEc+0x20>
    37a2:	09 c0       	rjmp	.+18     	; 0x37b6 <_ZN5rs2327putcharEc+0x2a>
    37a4:	21 50       	subi	r18, 0x01	; 1
    37a6:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    37a8:	19 f4       	brne	.+6      	; 0x37b0 <_ZN5rs2327putcharEc+0x24>
    37aa:	12 c0       	rjmp	.+36     	; 0x37d0 <_ZN5rs2327putcharEc+0x44>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
<<<<<<< HEAD
    3606:	21 e2       	ldi	r18, 0x21	; 33
    3608:	3e e4       	ldi	r19, 0x4E	; 78
    360a:	90 81       	ld	r25, Z
    360c:	94 23       	and	r25, r20
    360e:	b9 f3       	breq	.-18     	; 0x35fe <_ZN5rs2327putcharEc+0x18>
=======
    37ac:	21 e2       	ldi	r18, 0x21	; 33
    37ae:	3e e4       	ldi	r19, 0x4E	; 78
    37b0:	90 81       	ld	r25, Z
    37b2:	94 23       	and	r25, r20
    37b4:	b9 f3       	breq	.-18     	; 0x37a4 <_ZN5rs2327putcharEc+0x18>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
<<<<<<< HEAD
    3610:	90 81       	ld	r25, Z
    3612:	56 96       	adiw	r26, 0x16	; 22
    3614:	8c 91       	ld	r24, X
    3616:	56 97       	sbiw	r26, 0x16	; 22
    3618:	89 2b       	or	r24, r25
    361a:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    361c:	1e 96       	adiw	r26, 0x0e	; 14
    361e:	ed 91       	ld	r30, X+
    3620:	fc 91       	ld	r31, X
    3622:	1f 97       	sbiw	r26, 0x0f	; 15
    3624:	60 83       	st	Z, r22
	return (true);
    3626:	81 e0       	ldi	r24, 0x01	; 1
    3628:	08 95       	ret
=======
    37b6:	90 81       	ld	r25, Z
    37b8:	56 96       	adiw	r26, 0x16	; 22
    37ba:	8c 91       	ld	r24, X
    37bc:	56 97       	sbiw	r26, 0x16	; 22
    37be:	89 2b       	or	r24, r25
    37c0:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    37c2:	1e 96       	adiw	r26, 0x0e	; 14
    37c4:	ed 91       	ld	r30, X+
    37c6:	fc 91       	ld	r31, X
    37c8:	1f 97       	sbiw	r26, 0x0f	; 15
    37ca:	60 83       	st	Z, r22
	return (true);
    37cc:	81 e0       	ldi	r24, 0x01	; 1
    37ce:	08 95       	ret
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
<<<<<<< HEAD
    362a:	80 e0       	ldi	r24, 0x00	; 0
=======
    37d0:	80 e0       	ldi	r24, 0x00	; 0
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
<<<<<<< HEAD
    362c:	08 95       	ret

0000362e <_ZN5rs2327getcharEv>:
=======
    37d2:	08 95       	ret

000037d4 <_ZN5rs2327getcharEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
<<<<<<< HEAD
    362e:	cf 93       	push	r28
    3630:	df 93       	push	r29
    3632:	fc 01       	movw	r30, r24
=======
    37d4:	cf 93       	push	r28
    37d6:	df 93       	push	r29
    37d8:	fc 01       	movw	r30, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
<<<<<<< HEAD
    3634:	c1 8d       	ldd	r28, Z+25	; 0x19
    3636:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3638:	28 81       	ld	r18, Y
    363a:	39 81       	ldd	r19, Y+1	; 0x01
    363c:	a3 8d       	ldd	r26, Z+27	; 0x1b
    363e:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3640:	4d 91       	ld	r20, X+
    3642:	5c 91       	ld	r21, X
    3644:	24 17       	cp	r18, r20
    3646:	35 07       	cpc	r19, r21
    3648:	e9 f3       	breq	.-6      	; 0x3644 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    364a:	a7 89       	ldd	r26, Z+23	; 0x17
    364c:	b0 8d       	ldd	r27, Z+24	; 0x18
    364e:	0d 90       	ld	r0, X+
    3650:	bc 91       	ld	r27, X
    3652:	a0 2d       	mov	r26, r0
    3654:	a2 0f       	add	r26, r18
    3656:	b3 1f       	adc	r27, r19
    3658:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    365a:	2f 5f       	subi	r18, 0xFF	; 255
    365c:	3f 4f       	sbci	r19, 0xFF	; 255
    365e:	28 83       	st	Y, r18
    3660:	39 83       	std	Y+1, r19	; 0x01
    3662:	24 36       	cpi	r18, 0x64	; 100
    3664:	31 05       	cpc	r19, r1
    3666:	28 f0       	brcs	.+10     	; 0x3672 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3668:	01 8c       	ldd	r0, Z+25	; 0x19
    366a:	f2 8d       	ldd	r31, Z+26	; 0x1a
    366c:	e0 2d       	mov	r30, r0
    366e:	10 82       	st	Z, r1
    3670:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3672:	90 e0       	ldi	r25, 0x00	; 0
    3674:	df 91       	pop	r29
    3676:	cf 91       	pop	r28
    3678:	08 95       	ret

0000367a <_ZN5rs23214check_for_charEv>:
=======
    37da:	c1 8d       	ldd	r28, Z+25	; 0x19
    37dc:	d2 8d       	ldd	r29, Z+26	; 0x1a
    37de:	28 81       	ld	r18, Y
    37e0:	39 81       	ldd	r19, Y+1	; 0x01
    37e2:	a3 8d       	ldd	r26, Z+27	; 0x1b
    37e4:	b4 8d       	ldd	r27, Z+28	; 0x1c
    37e6:	4d 91       	ld	r20, X+
    37e8:	5c 91       	ld	r21, X
    37ea:	24 17       	cp	r18, r20
    37ec:	35 07       	cpc	r19, r21
    37ee:	e9 f3       	breq	.-6      	; 0x37ea <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    37f0:	a7 89       	ldd	r26, Z+23	; 0x17
    37f2:	b0 8d       	ldd	r27, Z+24	; 0x18
    37f4:	0d 90       	ld	r0, X+
    37f6:	bc 91       	ld	r27, X
    37f8:	a0 2d       	mov	r26, r0
    37fa:	a2 0f       	add	r26, r18
    37fc:	b3 1f       	adc	r27, r19
    37fe:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3800:	2f 5f       	subi	r18, 0xFF	; 255
    3802:	3f 4f       	sbci	r19, 0xFF	; 255
    3804:	28 83       	st	Y, r18
    3806:	39 83       	std	Y+1, r19	; 0x01
    3808:	24 36       	cpi	r18, 0x64	; 100
    380a:	31 05       	cpc	r19, r1
    380c:	28 f0       	brcs	.+10     	; 0x3818 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    380e:	01 8c       	ldd	r0, Z+25	; 0x19
    3810:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3812:	e0 2d       	mov	r30, r0
    3814:	10 82       	st	Z, r1
    3816:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3818:	90 e0       	ldi	r25, 0x00	; 0
    381a:	df 91       	pop	r29
    381c:	cf 91       	pop	r28
    381e:	08 95       	ret

00003820 <_ZN5rs23214check_for_charEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
<<<<<<< HEAD
    367a:	cf 93       	push	r28
    367c:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    367e:	ec 01       	movw	r28, r24
    3680:	a9 8d       	ldd	r26, Y+25	; 0x19
    3682:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3684:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3686:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3688:	81 e0       	ldi	r24, 0x01	; 1
    368a:	4d 91       	ld	r20, X+
    368c:	5c 91       	ld	r21, X
    368e:	20 81       	ld	r18, Z
    3690:	31 81       	ldd	r19, Z+1	; 0x01
    3692:	42 17       	cp	r20, r18
    3694:	53 07       	cpc	r21, r19
    3696:	09 f4       	brne	.+2      	; 0x369a <_ZN5rs23214check_for_charEv+0x20>
    3698:	80 e0       	ldi	r24, 0x00	; 0
}
    369a:	df 91       	pop	r29
    369c:	cf 91       	pop	r28
    369e:	08 95       	ret

000036a0 <_ZN5rs23212clear_screenEv>:
=======
    3820:	cf 93       	push	r28
    3822:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3824:	ec 01       	movw	r28, r24
    3826:	a9 8d       	ldd	r26, Y+25	; 0x19
    3828:	ba 8d       	ldd	r27, Y+26	; 0x1a
    382a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    382c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    382e:	81 e0       	ldi	r24, 0x01	; 1
    3830:	4d 91       	ld	r20, X+
    3832:	5c 91       	ld	r21, X
    3834:	20 81       	ld	r18, Z
    3836:	31 81       	ldd	r19, Z+1	; 0x01
    3838:	42 17       	cp	r20, r18
    383a:	53 07       	cpc	r21, r19
    383c:	09 f4       	brne	.+2      	; 0x3840 <_ZN5rs23214check_for_charEv+0x20>
    383e:	80 e0       	ldi	r24, 0x00	; 0
}
    3840:	df 91       	pop	r29
    3842:	cf 91       	pop	r28
    3844:	08 95       	ret

00003846 <_ZN5rs23212clear_screenEv>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
<<<<<<< HEAD
    36a0:	dc 01       	movw	r26, r24
    36a2:	ed 91       	ld	r30, X+
    36a4:	fc 91       	ld	r31, X
    36a6:	02 80       	ldd	r0, Z+2	; 0x02
    36a8:	f3 81       	ldd	r31, Z+3	; 0x03
    36aa:	e0 2d       	mov	r30, r0
    36ac:	6c e0       	ldi	r22, 0x0C	; 12
    36ae:	19 95       	eicall
    36b0:	08 95       	ret

000036b2 <_ZN5rs232C1EjP12USART_struct>:
=======
    3846:	dc 01       	movw	r26, r24
    3848:	ed 91       	ld	r30, X+
    384a:	fc 91       	ld	r31, X
    384c:	02 80       	ldd	r0, Z+2	; 0x02
    384e:	f3 81       	ldd	r31, Z+3	; 0x03
    3850:	e0 2d       	mov	r30, r0
    3852:	6c e0       	ldi	r22, 0x0C	; 12
    3854:	19 95       	eicall
    3856:	08 95       	ret

00003858 <_ZN5rs232C1EjP12USART_struct>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
<<<<<<< HEAD
    36b2:	ef 92       	push	r14
    36b4:	ff 92       	push	r15
    36b6:	0f 93       	push	r16
    36b8:	1f 93       	push	r17
    36ba:	cf 93       	push	r28
    36bc:	df 93       	push	r29
    36be:	ec 01       	movw	r28, r24
    36c0:	7b 01       	movw	r14, r22
    36c2:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    36c4:	0e 94 48 19 	call	0x3290	; 0x3290 <_ZN8emstreamC1Ev>
    36c8:	a8 01       	movw	r20, r16
    36ca:	b7 01       	movw	r22, r14
    36cc:	ce 01       	movw	r24, r28
    36ce:	08 96       	adiw	r24, 0x08	; 8
    36d0:	0e 94 a9 18 	call	0x3152	; 0x3152 <_ZN7base232C1EjP12USART_struct>
    36d4:	8f e5       	ldi	r24, 0x5F	; 95
    36d6:	90 e2       	ldi	r25, 0x20	; 32
    36d8:	88 83       	st	Y, r24
    36da:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    36dc:	00 3a       	cpi	r16, 0xA0	; 160
    36de:	88 e0       	ldi	r24, 0x08	; 8
    36e0:	18 07       	cpc	r17, r24
    36e2:	69 f4       	brne	.+26     	; 0x36fe <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    36e4:	84 e3       	ldi	r24, 0x34	; 52
    36e6:	91 e3       	ldi	r25, 0x31	; 49
    36e8:	8f 8b       	std	Y+23, r24	; 0x17
    36ea:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    36ec:	8a e2       	ldi	r24, 0x2A	; 42
    36ee:	91 e3       	ldi	r25, 0x31	; 49
    36f0:	89 8f       	std	Y+25, r24	; 0x19
    36f2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    36f4:	80 e2       	ldi	r24, 0x20	; 32
    36f6:	91 e3       	ldi	r25, 0x31	; 49
    36f8:	8b 8f       	std	Y+27, r24	; 0x1b
    36fa:	9c 8f       	std	Y+28, r25	; 0x1c
    36fc:	42 c0       	rjmp	.+132    	; 0x3782 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    36fe:	00 3b       	cpi	r16, 0xB0	; 176
    3700:	e8 e0       	ldi	r30, 0x08	; 8
    3702:	1e 07       	cpc	r17, r30
    3704:	69 f4       	brne	.+26     	; 0x3720 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3706:	82 e3       	ldi	r24, 0x32	; 50
    3708:	91 e3       	ldi	r25, 0x31	; 49
    370a:	8f 8b       	std	Y+23, r24	; 0x17
    370c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    370e:	88 e2       	ldi	r24, 0x28	; 40
    3710:	91 e3       	ldi	r25, 0x31	; 49
    3712:	89 8f       	std	Y+25, r24	; 0x19
    3714:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3716:	8e e1       	ldi	r24, 0x1E	; 30
    3718:	91 e3       	ldi	r25, 0x31	; 49
    371a:	8b 8f       	std	Y+27, r24	; 0x1b
    371c:	9c 8f       	std	Y+28, r25	; 0x1c
    371e:	31 c0       	rjmp	.+98     	; 0x3782 <_ZN5rs232C1EjP12USART_struct+0xd0>
=======
    3858:	ef 92       	push	r14
    385a:	ff 92       	push	r15
    385c:	0f 93       	push	r16
    385e:	1f 93       	push	r17
    3860:	cf 93       	push	r28
    3862:	df 93       	push	r29
    3864:	ec 01       	movw	r28, r24
    3866:	7b 01       	movw	r14, r22
    3868:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    386a:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <_ZN8emstreamC1Ev>
    386e:	a8 01       	movw	r20, r16
    3870:	b7 01       	movw	r22, r14
    3872:	ce 01       	movw	r24, r28
    3874:	08 96       	adiw	r24, 0x08	; 8
    3876:	0e 94 51 19 	call	0x32a2	; 0x32a2 <_ZN7base232C1EjP12USART_struct>
    387a:	8d e8       	ldi	r24, 0x8D	; 141
    387c:	90 e2       	ldi	r25, 0x20	; 32
    387e:	88 83       	st	Y, r24
    3880:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3882:	00 3a       	cpi	r16, 0xA0	; 160
    3884:	88 e0       	ldi	r24, 0x08	; 8
    3886:	18 07       	cpc	r17, r24
    3888:	69 f4       	brne	.+26     	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    388a:	8a e6       	ldi	r24, 0x6A	; 106
    388c:	91 e3       	ldi	r25, 0x31	; 49
    388e:	8f 8b       	std	Y+23, r24	; 0x17
    3890:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3892:	80 e6       	ldi	r24, 0x60	; 96
    3894:	91 e3       	ldi	r25, 0x31	; 49
    3896:	89 8f       	std	Y+25, r24	; 0x19
    3898:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    389a:	86 e5       	ldi	r24, 0x56	; 86
    389c:	91 e3       	ldi	r25, 0x31	; 49
    389e:	8b 8f       	std	Y+27, r24	; 0x1b
    38a0:	9c 8f       	std	Y+28, r25	; 0x1c
    38a2:	42 c0       	rjmp	.+132    	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    38a4:	00 3b       	cpi	r16, 0xB0	; 176
    38a6:	e8 e0       	ldi	r30, 0x08	; 8
    38a8:	1e 07       	cpc	r17, r30
    38aa:	69 f4       	brne	.+26     	; 0x38c6 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    38ac:	88 e6       	ldi	r24, 0x68	; 104
    38ae:	91 e3       	ldi	r25, 0x31	; 49
    38b0:	8f 8b       	std	Y+23, r24	; 0x17
    38b2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    38b4:	8e e5       	ldi	r24, 0x5E	; 94
    38b6:	91 e3       	ldi	r25, 0x31	; 49
    38b8:	89 8f       	std	Y+25, r24	; 0x19
    38ba:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    38bc:	84 e5       	ldi	r24, 0x54	; 84
    38be:	91 e3       	ldi	r25, 0x31	; 49
    38c0:	8b 8f       	std	Y+27, r24	; 0x1b
    38c2:	9c 8f       	std	Y+28, r25	; 0x1c
    38c4:	31 c0       	rjmp	.+98     	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
<<<<<<< HEAD
    3720:	00 3a       	cpi	r16, 0xA0	; 160
    3722:	f9 e0       	ldi	r31, 0x09	; 9
    3724:	1f 07       	cpc	r17, r31
    3726:	69 f4       	brne	.+26     	; 0x3742 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3728:	80 e3       	ldi	r24, 0x30	; 48
    372a:	91 e3       	ldi	r25, 0x31	; 49
    372c:	8f 8b       	std	Y+23, r24	; 0x17
    372e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3730:	86 e2       	ldi	r24, 0x26	; 38
    3732:	91 e3       	ldi	r25, 0x31	; 49
    3734:	89 8f       	std	Y+25, r24	; 0x19
    3736:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3738:	8c e1       	ldi	r24, 0x1C	; 28
    373a:	91 e3       	ldi	r25, 0x31	; 49
    373c:	8b 8f       	std	Y+27, r24	; 0x1b
    373e:	9c 8f       	std	Y+28, r25	; 0x1c
    3740:	20 c0       	rjmp	.+64     	; 0x3782 <_ZN5rs232C1EjP12USART_struct+0xd0>
=======
    38c6:	00 3a       	cpi	r16, 0xA0	; 160
    38c8:	f9 e0       	ldi	r31, 0x09	; 9
    38ca:	1f 07       	cpc	r17, r31
    38cc:	69 f4       	brne	.+26     	; 0x38e8 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    38ce:	86 e6       	ldi	r24, 0x66	; 102
    38d0:	91 e3       	ldi	r25, 0x31	; 49
    38d2:	8f 8b       	std	Y+23, r24	; 0x17
    38d4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    38d6:	8c e5       	ldi	r24, 0x5C	; 92
    38d8:	91 e3       	ldi	r25, 0x31	; 49
    38da:	89 8f       	std	Y+25, r24	; 0x19
    38dc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    38de:	82 e5       	ldi	r24, 0x52	; 82
    38e0:	91 e3       	ldi	r25, 0x31	; 49
    38e2:	8b 8f       	std	Y+27, r24	; 0x1b
    38e4:	9c 8f       	std	Y+28, r25	; 0x1c
    38e6:	20 c0       	rjmp	.+64     	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
<<<<<<< HEAD
    3742:	00 3b       	cpi	r16, 0xB0	; 176
    3744:	89 e0       	ldi	r24, 0x09	; 9
    3746:	18 07       	cpc	r17, r24
    3748:	69 f4       	brne	.+26     	; 0x3764 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    374a:	8e e2       	ldi	r24, 0x2E	; 46
    374c:	91 e3       	ldi	r25, 0x31	; 49
    374e:	8f 8b       	std	Y+23, r24	; 0x17
    3750:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3752:	84 e2       	ldi	r24, 0x24	; 36
    3754:	91 e3       	ldi	r25, 0x31	; 49
    3756:	89 8f       	std	Y+25, r24	; 0x19
    3758:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    375a:	8a e1       	ldi	r24, 0x1A	; 26
    375c:	91 e3       	ldi	r25, 0x31	; 49
    375e:	8b 8f       	std	Y+27, r24	; 0x1b
    3760:	9c 8f       	std	Y+28, r25	; 0x1c
    3762:	0f c0       	rjmp	.+30     	; 0x3782 <_ZN5rs232C1EjP12USART_struct+0xd0>
=======
    38e8:	00 3b       	cpi	r16, 0xB0	; 176
    38ea:	89 e0       	ldi	r24, 0x09	; 9
    38ec:	18 07       	cpc	r17, r24
    38ee:	69 f4       	brne	.+26     	; 0x390a <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    38f0:	84 e6       	ldi	r24, 0x64	; 100
    38f2:	91 e3       	ldi	r25, 0x31	; 49
    38f4:	8f 8b       	std	Y+23, r24	; 0x17
    38f6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    38f8:	8a e5       	ldi	r24, 0x5A	; 90
    38fa:	91 e3       	ldi	r25, 0x31	; 49
    38fc:	89 8f       	std	Y+25, r24	; 0x19
    38fe:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3900:	80 e5       	ldi	r24, 0x50	; 80
    3902:	91 e3       	ldi	r25, 0x31	; 49
    3904:	8b 8f       	std	Y+27, r24	; 0x1b
    3906:	9c 8f       	std	Y+28, r25	; 0x1c
    3908:	0f c0       	rjmp	.+30     	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
<<<<<<< HEAD
    3764:	00 3a       	cpi	r16, 0xA0	; 160
    3766:	1a 40       	sbci	r17, 0x0A	; 10
    3768:	61 f4       	brne	.+24     	; 0x3782 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    376a:	8c e2       	ldi	r24, 0x2C	; 44
    376c:	91 e3       	ldi	r25, 0x31	; 49
    376e:	8f 8b       	std	Y+23, r24	; 0x17
    3770:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3772:	82 e2       	ldi	r24, 0x22	; 34
    3774:	91 e3       	ldi	r25, 0x31	; 49
    3776:	89 8f       	std	Y+25, r24	; 0x19
    3778:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    377a:	88 e1       	ldi	r24, 0x18	; 24
    377c:	91 e3       	ldi	r25, 0x31	; 49
    377e:	8b 8f       	std	Y+27, r24	; 0x1b
    3780:	9c 8f       	std	Y+28, r25	; 0x1c
=======
    390a:	00 3a       	cpi	r16, 0xA0	; 160
    390c:	1a 40       	sbci	r17, 0x0A	; 10
    390e:	61 f4       	brne	.+24     	; 0x3928 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3910:	82 e6       	ldi	r24, 0x62	; 98
    3912:	91 e3       	ldi	r25, 0x31	; 49
    3914:	8f 8b       	std	Y+23, r24	; 0x17
    3916:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3918:	88 e5       	ldi	r24, 0x58	; 88
    391a:	91 e3       	ldi	r25, 0x31	; 49
    391c:	89 8f       	std	Y+25, r24	; 0x19
    391e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3920:	8e e4       	ldi	r24, 0x4E	; 78
    3922:	91 e3       	ldi	r25, 0x31	; 49
    3924:	8b 8f       	std	Y+27, r24	; 0x1b
    3926:	9c 8f       	std	Y+28, r25	; 0x1c
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
<<<<<<< HEAD
    3782:	0f 89       	ldd	r16, Y+23	; 0x17
    3784:	18 8d       	ldd	r17, Y+24	; 0x18
    3786:	84 e6       	ldi	r24, 0x64	; 100
    3788:	90 e0       	ldi	r25, 0x00	; 0
    378a:	0e 94 a5 18 	call	0x314a	; 0x314a <_Znaj>
    378e:	f8 01       	movw	r30, r16
    3790:	80 83       	st	Z, r24
    3792:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3794:	e9 8d       	ldd	r30, Y+25	; 0x19
    3796:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3798:	10 82       	st	Z, r1
    379a:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    379c:	eb 8d       	ldd	r30, Y+27	; 0x1b
    379e:	fc 8d       	ldd	r31, Y+28	; 0x1c
    37a0:	10 82       	st	Z, r1
    37a2:	11 82       	std	Z+1, r1	; 0x01
}
    37a4:	df 91       	pop	r29
    37a6:	cf 91       	pop	r28
    37a8:	1f 91       	pop	r17
    37aa:	0f 91       	pop	r16
    37ac:	ff 90       	pop	r15
    37ae:	ef 90       	pop	r14
    37b0:	08 95       	ret

000037b2 <__vector_25>:
=======
    3928:	0f 89       	ldd	r16, Y+23	; 0x17
    392a:	18 8d       	ldd	r17, Y+24	; 0x18
    392c:	84 e6       	ldi	r24, 0x64	; 100
    392e:	90 e0       	ldi	r25, 0x00	; 0
    3930:	0e 94 4d 19 	call	0x329a	; 0x329a <_Znaj>
    3934:	f8 01       	movw	r30, r16
    3936:	80 83       	st	Z, r24
    3938:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    393a:	e9 8d       	ldd	r30, Y+25	; 0x19
    393c:	fa 8d       	ldd	r31, Y+26	; 0x1a
    393e:	10 82       	st	Z, r1
    3940:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3942:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3944:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3946:	10 82       	st	Z, r1
    3948:	11 82       	std	Z+1, r1	; 0x01
}
    394a:	df 91       	pop	r29
    394c:	cf 91       	pop	r28
    394e:	1f 91       	pop	r17
    3950:	0f 91       	pop	r16
    3952:	ff 90       	pop	r15
    3954:	ef 90       	pop	r14
    3956:	08 95       	ret

00003958 <__vector_25>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
<<<<<<< HEAD
    37b2:	1f 92       	push	r1
    37b4:	0f 92       	push	r0
    37b6:	0f b6       	in	r0, 0x3f	; 63
    37b8:	0f 92       	push	r0
    37ba:	11 24       	eor	r1, r1
    37bc:	08 b6       	in	r0, 0x38	; 56
    37be:	0f 92       	push	r0
    37c0:	18 be       	out	0x38, r1	; 56
    37c2:	0b b6       	in	r0, 0x3b	; 59
    37c4:	0f 92       	push	r0
    37c6:	1b be       	out	0x3b, r1	; 59
    37c8:	2f 93       	push	r18
    37ca:	3f 93       	push	r19
    37cc:	8f 93       	push	r24
    37ce:	9f 93       	push	r25
    37d0:	ef 93       	push	r30
    37d2:	ff 93       	push	r31
=======
    3958:	1f 92       	push	r1
    395a:	0f 92       	push	r0
    395c:	0f b6       	in	r0, 0x3f	; 63
    395e:	0f 92       	push	r0
    3960:	11 24       	eor	r1, r1
    3962:	08 b6       	in	r0, 0x38	; 56
    3964:	0f 92       	push	r0
    3966:	18 be       	out	0x38, r1	; 56
    3968:	0b b6       	in	r0, 0x3b	; 59
    396a:	0f 92       	push	r0
    396c:	1b be       	out	0x3b, r1	; 59
    396e:	2f 93       	push	r18
    3970:	3f 93       	push	r19
    3972:	8f 93       	push	r24
    3974:	9f 93       	push	r25
    3976:	ef 93       	push	r30
    3978:	ff 93       	push	r31
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
<<<<<<< HEAD
    37d4:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    37d8:	e0 91 34 31 	lds	r30, 0x3134	; 0x803134 <rcvC0_buffer>
    37dc:	f0 91 35 31 	lds	r31, 0x3135	; 0x803135 <rcvC0_buffer+0x1>
    37e0:	80 91 20 31 	lds	r24, 0x3120	; 0x803120 <rcvC0_write_index>
    37e4:	90 91 21 31 	lds	r25, 0x3121	; 0x803121 <rcvC0_write_index+0x1>
    37e8:	e8 0f       	add	r30, r24
    37ea:	f9 1f       	adc	r31, r25
    37ec:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    37ee:	80 91 20 31 	lds	r24, 0x3120	; 0x803120 <rcvC0_write_index>
    37f2:	90 91 21 31 	lds	r25, 0x3121	; 0x803121 <rcvC0_write_index+0x1>
    37f6:	01 96       	adiw	r24, 0x01	; 1
    37f8:	84 36       	cpi	r24, 0x64	; 100
    37fa:	91 05       	cpc	r25, r1
    37fc:	60 f4       	brcc	.+24     	; 0x3816 <__vector_25+0x64>
    37fe:	80 93 20 31 	sts	0x3120, r24	; 0x803120 <rcvC0_write_index>
    3802:	90 93 21 31 	sts	0x3121, r25	; 0x803121 <rcvC0_write_index+0x1>
=======
    397a:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    397e:	e0 91 6a 31 	lds	r30, 0x316A	; 0x80316a <rcvC0_buffer>
    3982:	f0 91 6b 31 	lds	r31, 0x316B	; 0x80316b <rcvC0_buffer+0x1>
    3986:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvC0_write_index>
    398a:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvC0_write_index+0x1>
    398e:	e8 0f       	add	r30, r24
    3990:	f9 1f       	adc	r31, r25
    3992:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3994:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvC0_write_index>
    3998:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvC0_write_index+0x1>
    399c:	01 96       	adiw	r24, 0x01	; 1
    399e:	84 36       	cpi	r24, 0x64	; 100
    39a0:	91 05       	cpc	r25, r1
    39a2:	60 f4       	brcc	.+24     	; 0x39bc <__vector_25+0x64>
    39a4:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvC0_write_index>
    39a8:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvC0_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
<<<<<<< HEAD
    3806:	20 91 2a 31 	lds	r18, 0x312A	; 0x80312a <rcvC0_read_index>
    380a:	30 91 2b 31 	lds	r19, 0x312B	; 0x80312b <rcvC0_read_index+0x1>
    380e:	82 17       	cp	r24, r18
    3810:	93 07       	cpc	r25, r19
    3812:	f1 f4       	brne	.+60     	; 0x3850 <__vector_25+0x9e>
    3814:	0c c0       	rjmp	.+24     	; 0x382e <__vector_25+0x7c>
=======
    39ac:	20 91 60 31 	lds	r18, 0x3160	; 0x803160 <rcvC0_read_index>
    39b0:	30 91 61 31 	lds	r19, 0x3161	; 0x803161 <rcvC0_read_index+0x1>
    39b4:	82 17       	cp	r24, r18
    39b6:	93 07       	cpc	r25, r19
    39b8:	f1 f4       	brne	.+60     	; 0x39f6 <__vector_25+0x9e>
    39ba:	0c c0       	rjmp	.+24     	; 0x39d4 <__vector_25+0x7c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
<<<<<<< HEAD
    3816:	10 92 20 31 	sts	0x3120, r1	; 0x803120 <rcvC0_write_index>
    381a:	10 92 21 31 	sts	0x3121, r1	; 0x803121 <rcvC0_write_index+0x1>
=======
    39bc:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvC0_write_index>
    39c0:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvC0_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
<<<<<<< HEAD
    381e:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvC0_read_index>
    3822:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvC0_read_index+0x1>
    3826:	18 16       	cp	r1, r24
    3828:	19 06       	cpc	r1, r25
    382a:	91 f4       	brne	.+36     	; 0x3850 <__vector_25+0x9e>
    382c:	0e c0       	rjmp	.+28     	; 0x384a <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    382e:	01 96       	adiw	r24, 0x01	; 1
    3830:	84 36       	cpi	r24, 0x64	; 100
    3832:	91 05       	cpc	r25, r1
    3834:	28 f4       	brcc	.+10     	; 0x3840 <__vector_25+0x8e>
    3836:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvC0_read_index>
    383a:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvC0_read_index+0x1>
    383e:	08 c0       	rjmp	.+16     	; 0x3850 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3840:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvC0_read_index>
    3844:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvC0_read_index+0x1>
}
    3848:	03 c0       	rjmp	.+6      	; 0x3850 <__vector_25+0x9e>
=======
    39c4:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvC0_read_index>
    39c8:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvC0_read_index+0x1>
    39cc:	18 16       	cp	r1, r24
    39ce:	19 06       	cpc	r1, r25
    39d0:	91 f4       	brne	.+36     	; 0x39f6 <__vector_25+0x9e>
    39d2:	0e c0       	rjmp	.+28     	; 0x39f0 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    39d4:	01 96       	adiw	r24, 0x01	; 1
    39d6:	84 36       	cpi	r24, 0x64	; 100
    39d8:	91 05       	cpc	r25, r1
    39da:	28 f4       	brcc	.+10     	; 0x39e6 <__vector_25+0x8e>
    39dc:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <rcvC0_read_index>
    39e0:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <rcvC0_read_index+0x1>
    39e4:	08 c0       	rjmp	.+16     	; 0x39f6 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    39e6:	10 92 60 31 	sts	0x3160, r1	; 0x803160 <rcvC0_read_index>
    39ea:	10 92 61 31 	sts	0x3161, r1	; 0x803161 <rcvC0_read_index+0x1>
}
    39ee:	03 c0       	rjmp	.+6      	; 0x39f6 <__vector_25+0x9e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
<<<<<<< HEAD
    384a:	81 e0       	ldi	r24, 0x01	; 1
    384c:	90 e0       	ldi	r25, 0x00	; 0
    384e:	f3 cf       	rjmp	.-26     	; 0x3836 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3850:	ff 91       	pop	r31
    3852:	ef 91       	pop	r30
    3854:	9f 91       	pop	r25
    3856:	8f 91       	pop	r24
    3858:	3f 91       	pop	r19
    385a:	2f 91       	pop	r18
    385c:	0f 90       	pop	r0
    385e:	0b be       	out	0x3b, r0	; 59
    3860:	0f 90       	pop	r0
    3862:	08 be       	out	0x38, r0	; 56
    3864:	0f 90       	pop	r0
    3866:	0f be       	out	0x3f, r0	; 63
    3868:	0f 90       	pop	r0
    386a:	1f 90       	pop	r1
    386c:	18 95       	reti

0000386e <__vector_28>:
=======
    39f0:	81 e0       	ldi	r24, 0x01	; 1
    39f2:	90 e0       	ldi	r25, 0x00	; 0
    39f4:	f3 cf       	rjmp	.-26     	; 0x39dc <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    39f6:	ff 91       	pop	r31
    39f8:	ef 91       	pop	r30
    39fa:	9f 91       	pop	r25
    39fc:	8f 91       	pop	r24
    39fe:	3f 91       	pop	r19
    3a00:	2f 91       	pop	r18
    3a02:	0f 90       	pop	r0
    3a04:	0b be       	out	0x3b, r0	; 59
    3a06:	0f 90       	pop	r0
    3a08:	08 be       	out	0x38, r0	; 56
    3a0a:	0f 90       	pop	r0
    3a0c:	0f be       	out	0x3f, r0	; 63
    3a0e:	0f 90       	pop	r0
    3a10:	1f 90       	pop	r1
    3a12:	18 95       	reti

00003a14 <__vector_28>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
<<<<<<< HEAD
    386e:	1f 92       	push	r1
    3870:	0f 92       	push	r0
    3872:	0f b6       	in	r0, 0x3f	; 63
    3874:	0f 92       	push	r0
    3876:	11 24       	eor	r1, r1
    3878:	08 b6       	in	r0, 0x38	; 56
    387a:	0f 92       	push	r0
    387c:	18 be       	out	0x38, r1	; 56
    387e:	0b b6       	in	r0, 0x3b	; 59
    3880:	0f 92       	push	r0
    3882:	1b be       	out	0x3b, r1	; 59
    3884:	2f 93       	push	r18
    3886:	3f 93       	push	r19
    3888:	8f 93       	push	r24
    388a:	9f 93       	push	r25
    388c:	ef 93       	push	r30
    388e:	ff 93       	push	r31
=======
    3a14:	1f 92       	push	r1
    3a16:	0f 92       	push	r0
    3a18:	0f b6       	in	r0, 0x3f	; 63
    3a1a:	0f 92       	push	r0
    3a1c:	11 24       	eor	r1, r1
    3a1e:	08 b6       	in	r0, 0x38	; 56
    3a20:	0f 92       	push	r0
    3a22:	18 be       	out	0x38, r1	; 56
    3a24:	0b b6       	in	r0, 0x3b	; 59
    3a26:	0f 92       	push	r0
    3a28:	1b be       	out	0x3b, r1	; 59
    3a2a:	2f 93       	push	r18
    3a2c:	3f 93       	push	r19
    3a2e:	8f 93       	push	r24
    3a30:	9f 93       	push	r25
    3a32:	ef 93       	push	r30
    3a34:	ff 93       	push	r31
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
<<<<<<< HEAD
    3890:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3894:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <rcvC1_buffer>
    3898:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <rcvC1_buffer+0x1>
    389c:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvC1_write_index>
    38a0:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvC1_write_index+0x1>
    38a4:	e8 0f       	add	r30, r24
    38a6:	f9 1f       	adc	r31, r25
    38a8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    38aa:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvC1_write_index>
    38ae:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvC1_write_index+0x1>
    38b2:	01 96       	adiw	r24, 0x01	; 1
    38b4:	84 36       	cpi	r24, 0x64	; 100
    38b6:	91 05       	cpc	r25, r1
    38b8:	60 f4       	brcc	.+24     	; 0x38d2 <__vector_28+0x64>
    38ba:	80 93 1e 31 	sts	0x311E, r24	; 0x80311e <rcvC1_write_index>
    38be:	90 93 1f 31 	sts	0x311F, r25	; 0x80311f <rcvC1_write_index+0x1>
=======
    3a36:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3a3a:	e0 91 68 31 	lds	r30, 0x3168	; 0x803168 <rcvC1_buffer>
    3a3e:	f0 91 69 31 	lds	r31, 0x3169	; 0x803169 <rcvC1_buffer+0x1>
    3a42:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC1_write_index>
    3a46:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC1_write_index+0x1>
    3a4a:	e8 0f       	add	r30, r24
    3a4c:	f9 1f       	adc	r31, r25
    3a4e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3a50:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC1_write_index>
    3a54:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC1_write_index+0x1>
    3a58:	01 96       	adiw	r24, 0x01	; 1
    3a5a:	84 36       	cpi	r24, 0x64	; 100
    3a5c:	91 05       	cpc	r25, r1
    3a5e:	60 f4       	brcc	.+24     	; 0x3a78 <__vector_28+0x64>
    3a60:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvC1_write_index>
    3a64:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvC1_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
<<<<<<< HEAD
    38c2:	20 91 28 31 	lds	r18, 0x3128	; 0x803128 <rcvC1_read_index>
    38c6:	30 91 29 31 	lds	r19, 0x3129	; 0x803129 <rcvC1_read_index+0x1>
    38ca:	82 17       	cp	r24, r18
    38cc:	93 07       	cpc	r25, r19
    38ce:	f1 f4       	brne	.+60     	; 0x390c <__vector_28+0x9e>
    38d0:	0c c0       	rjmp	.+24     	; 0x38ea <__vector_28+0x7c>
=======
    3a68:	20 91 5e 31 	lds	r18, 0x315E	; 0x80315e <rcvC1_read_index>
    3a6c:	30 91 5f 31 	lds	r19, 0x315F	; 0x80315f <rcvC1_read_index+0x1>
    3a70:	82 17       	cp	r24, r18
    3a72:	93 07       	cpc	r25, r19
    3a74:	f1 f4       	brne	.+60     	; 0x3ab2 <__vector_28+0x9e>
    3a76:	0c c0       	rjmp	.+24     	; 0x3a90 <__vector_28+0x7c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
<<<<<<< HEAD
    38d2:	10 92 1e 31 	sts	0x311E, r1	; 0x80311e <rcvC1_write_index>
    38d6:	10 92 1f 31 	sts	0x311F, r1	; 0x80311f <rcvC1_write_index+0x1>
=======
    3a78:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvC1_write_index>
    3a7c:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvC1_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
<<<<<<< HEAD
    38da:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvC1_read_index>
    38de:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvC1_read_index+0x1>
    38e2:	18 16       	cp	r1, r24
    38e4:	19 06       	cpc	r1, r25
    38e6:	91 f4       	brne	.+36     	; 0x390c <__vector_28+0x9e>
    38e8:	0e c0       	rjmp	.+28     	; 0x3906 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    38ea:	01 96       	adiw	r24, 0x01	; 1
    38ec:	84 36       	cpi	r24, 0x64	; 100
    38ee:	91 05       	cpc	r25, r1
    38f0:	28 f4       	brcc	.+10     	; 0x38fc <__vector_28+0x8e>
    38f2:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvC1_read_index>
    38f6:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvC1_read_index+0x1>
    38fa:	08 c0       	rjmp	.+16     	; 0x390c <__vector_28+0x9e>
	rcvC1_read_index = 0;
    38fc:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvC1_read_index>
    3900:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvC1_read_index+0x1>
}
    3904:	03 c0       	rjmp	.+6      	; 0x390c <__vector_28+0x9e>
=======
    3a80:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvC1_read_index>
    3a84:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvC1_read_index+0x1>
    3a88:	18 16       	cp	r1, r24
    3a8a:	19 06       	cpc	r1, r25
    3a8c:	91 f4       	brne	.+36     	; 0x3ab2 <__vector_28+0x9e>
    3a8e:	0e c0       	rjmp	.+28     	; 0x3aac <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a90:	01 96       	adiw	r24, 0x01	; 1
    3a92:	84 36       	cpi	r24, 0x64	; 100
    3a94:	91 05       	cpc	r25, r1
    3a96:	28 f4       	brcc	.+10     	; 0x3aa2 <__vector_28+0x8e>
    3a98:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <rcvC1_read_index>
    3a9c:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <rcvC1_read_index+0x1>
    3aa0:	08 c0       	rjmp	.+16     	; 0x3ab2 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3aa2:	10 92 5e 31 	sts	0x315E, r1	; 0x80315e <rcvC1_read_index>
    3aa6:	10 92 5f 31 	sts	0x315F, r1	; 0x80315f <rcvC1_read_index+0x1>
}
    3aaa:	03 c0       	rjmp	.+6      	; 0x3ab2 <__vector_28+0x9e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
<<<<<<< HEAD
    3906:	81 e0       	ldi	r24, 0x01	; 1
    3908:	90 e0       	ldi	r25, 0x00	; 0
    390a:	f3 cf       	rjmp	.-26     	; 0x38f2 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    390c:	ff 91       	pop	r31
    390e:	ef 91       	pop	r30
    3910:	9f 91       	pop	r25
    3912:	8f 91       	pop	r24
    3914:	3f 91       	pop	r19
    3916:	2f 91       	pop	r18
    3918:	0f 90       	pop	r0
    391a:	0b be       	out	0x3b, r0	; 59
    391c:	0f 90       	pop	r0
    391e:	08 be       	out	0x38, r0	; 56
    3920:	0f 90       	pop	r0
    3922:	0f be       	out	0x3f, r0	; 63
    3924:	0f 90       	pop	r0
    3926:	1f 90       	pop	r1
    3928:	18 95       	reti

0000392a <__vector_88>:
=======
    3aac:	81 e0       	ldi	r24, 0x01	; 1
    3aae:	90 e0       	ldi	r25, 0x00	; 0
    3ab0:	f3 cf       	rjmp	.-26     	; 0x3a98 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3ab2:	ff 91       	pop	r31
    3ab4:	ef 91       	pop	r30
    3ab6:	9f 91       	pop	r25
    3ab8:	8f 91       	pop	r24
    3aba:	3f 91       	pop	r19
    3abc:	2f 91       	pop	r18
    3abe:	0f 90       	pop	r0
    3ac0:	0b be       	out	0x3b, r0	; 59
    3ac2:	0f 90       	pop	r0
    3ac4:	08 be       	out	0x38, r0	; 56
    3ac6:	0f 90       	pop	r0
    3ac8:	0f be       	out	0x3f, r0	; 63
    3aca:	0f 90       	pop	r0
    3acc:	1f 90       	pop	r1
    3ace:	18 95       	reti

00003ad0 <__vector_88>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
<<<<<<< HEAD
    392a:	1f 92       	push	r1
    392c:	0f 92       	push	r0
    392e:	0f b6       	in	r0, 0x3f	; 63
    3930:	0f 92       	push	r0
    3932:	11 24       	eor	r1, r1
    3934:	08 b6       	in	r0, 0x38	; 56
    3936:	0f 92       	push	r0
    3938:	18 be       	out	0x38, r1	; 56
    393a:	0b b6       	in	r0, 0x3b	; 59
    393c:	0f 92       	push	r0
    393e:	1b be       	out	0x3b, r1	; 59
    3940:	2f 93       	push	r18
    3942:	3f 93       	push	r19
    3944:	8f 93       	push	r24
    3946:	9f 93       	push	r25
    3948:	ef 93       	push	r30
    394a:	ff 93       	push	r31
=======
    3ad0:	1f 92       	push	r1
    3ad2:	0f 92       	push	r0
    3ad4:	0f b6       	in	r0, 0x3f	; 63
    3ad6:	0f 92       	push	r0
    3ad8:	11 24       	eor	r1, r1
    3ada:	08 b6       	in	r0, 0x38	; 56
    3adc:	0f 92       	push	r0
    3ade:	18 be       	out	0x38, r1	; 56
    3ae0:	0b b6       	in	r0, 0x3b	; 59
    3ae2:	0f 92       	push	r0
    3ae4:	1b be       	out	0x3b, r1	; 59
    3ae6:	2f 93       	push	r18
    3ae8:	3f 93       	push	r19
    3aea:	8f 93       	push	r24
    3aec:	9f 93       	push	r25
    3aee:	ef 93       	push	r30
    3af0:	ff 93       	push	r31
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
<<<<<<< HEAD
    394c:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3950:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <rcvD0_buffer>
    3954:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <rcvD0_buffer+0x1>
    3958:	80 91 20 31 	lds	r24, 0x3120	; 0x803120 <rcvC0_write_index>
    395c:	90 91 21 31 	lds	r25, 0x3121	; 0x803121 <rcvC0_write_index+0x1>
    3960:	e8 0f       	add	r30, r24
    3962:	f9 1f       	adc	r31, r25
    3964:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3966:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvD0_write_index>
    396a:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvD0_write_index+0x1>
    396e:	01 96       	adiw	r24, 0x01	; 1
    3970:	84 36       	cpi	r24, 0x64	; 100
    3972:	91 05       	cpc	r25, r1
    3974:	60 f4       	brcc	.+24     	; 0x398e <__vector_88+0x64>
    3976:	80 93 1c 31 	sts	0x311C, r24	; 0x80311c <rcvD0_write_index>
    397a:	90 93 1d 31 	sts	0x311D, r25	; 0x80311d <rcvD0_write_index+0x1>
=======
    3af2:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3af6:	e0 91 66 31 	lds	r30, 0x3166	; 0x803166 <rcvD0_buffer>
    3afa:	f0 91 67 31 	lds	r31, 0x3167	; 0x803167 <rcvD0_buffer+0x1>
    3afe:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvC0_write_index>
    3b02:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvC0_write_index+0x1>
    3b06:	e8 0f       	add	r30, r24
    3b08:	f9 1f       	adc	r31, r25
    3b0a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3b0c:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvD0_write_index>
    3b10:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvD0_write_index+0x1>
    3b14:	01 96       	adiw	r24, 0x01	; 1
    3b16:	84 36       	cpi	r24, 0x64	; 100
    3b18:	91 05       	cpc	r25, r1
    3b1a:	60 f4       	brcc	.+24     	; 0x3b34 <__vector_88+0x64>
    3b1c:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <rcvD0_write_index>
    3b20:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <rcvD0_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
<<<<<<< HEAD
    397e:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <rcvD0_read_index>
    3982:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <rcvD0_read_index+0x1>
    3986:	82 17       	cp	r24, r18
    3988:	93 07       	cpc	r25, r19
    398a:	f1 f4       	brne	.+60     	; 0x39c8 <__vector_88+0x9e>
    398c:	0c c0       	rjmp	.+24     	; 0x39a6 <__vector_88+0x7c>
=======
    3b24:	20 91 5c 31 	lds	r18, 0x315C	; 0x80315c <rcvD0_read_index>
    3b28:	30 91 5d 31 	lds	r19, 0x315D	; 0x80315d <rcvD0_read_index+0x1>
    3b2c:	82 17       	cp	r24, r18
    3b2e:	93 07       	cpc	r25, r19
    3b30:	f1 f4       	brne	.+60     	; 0x3b6e <__vector_88+0x9e>
    3b32:	0c c0       	rjmp	.+24     	; 0x3b4c <__vector_88+0x7c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
<<<<<<< HEAD
    398e:	10 92 1c 31 	sts	0x311C, r1	; 0x80311c <rcvD0_write_index>
    3992:	10 92 1d 31 	sts	0x311D, r1	; 0x80311d <rcvD0_write_index+0x1>
=======
    3b34:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <rcvD0_write_index>
    3b38:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <rcvD0_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
<<<<<<< HEAD
    3996:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <rcvD0_read_index>
    399a:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <rcvD0_read_index+0x1>
    399e:	18 16       	cp	r1, r24
    39a0:	19 06       	cpc	r1, r25
    39a2:	91 f4       	brne	.+36     	; 0x39c8 <__vector_88+0x9e>
    39a4:	0e c0       	rjmp	.+28     	; 0x39c2 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    39a6:	01 96       	adiw	r24, 0x01	; 1
    39a8:	84 36       	cpi	r24, 0x64	; 100
    39aa:	91 05       	cpc	r25, r1
    39ac:	28 f4       	brcc	.+10     	; 0x39b8 <__vector_88+0x8e>
    39ae:	80 93 26 31 	sts	0x3126, r24	; 0x803126 <rcvD0_read_index>
    39b2:	90 93 27 31 	sts	0x3127, r25	; 0x803127 <rcvD0_read_index+0x1>
    39b6:	08 c0       	rjmp	.+16     	; 0x39c8 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    39b8:	10 92 26 31 	sts	0x3126, r1	; 0x803126 <rcvD0_read_index>
    39bc:	10 92 27 31 	sts	0x3127, r1	; 0x803127 <rcvD0_read_index+0x1>
}
    39c0:	03 c0       	rjmp	.+6      	; 0x39c8 <__vector_88+0x9e>
=======
    3b3c:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvD0_read_index>
    3b40:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvD0_read_index+0x1>
    3b44:	18 16       	cp	r1, r24
    3b46:	19 06       	cpc	r1, r25
    3b48:	91 f4       	brne	.+36     	; 0x3b6e <__vector_88+0x9e>
    3b4a:	0e c0       	rjmp	.+28     	; 0x3b68 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3b4c:	01 96       	adiw	r24, 0x01	; 1
    3b4e:	84 36       	cpi	r24, 0x64	; 100
    3b50:	91 05       	cpc	r25, r1
    3b52:	28 f4       	brcc	.+10     	; 0x3b5e <__vector_88+0x8e>
    3b54:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvD0_read_index>
    3b58:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvD0_read_index+0x1>
    3b5c:	08 c0       	rjmp	.+16     	; 0x3b6e <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3b5e:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvD0_read_index>
    3b62:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvD0_read_index+0x1>
}
    3b66:	03 c0       	rjmp	.+6      	; 0x3b6e <__vector_88+0x9e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
<<<<<<< HEAD
    39c2:	81 e0       	ldi	r24, 0x01	; 1
    39c4:	90 e0       	ldi	r25, 0x00	; 0
    39c6:	f3 cf       	rjmp	.-26     	; 0x39ae <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    39c8:	ff 91       	pop	r31
    39ca:	ef 91       	pop	r30
    39cc:	9f 91       	pop	r25
    39ce:	8f 91       	pop	r24
    39d0:	3f 91       	pop	r19
    39d2:	2f 91       	pop	r18
    39d4:	0f 90       	pop	r0
    39d6:	0b be       	out	0x3b, r0	; 59
    39d8:	0f 90       	pop	r0
    39da:	08 be       	out	0x38, r0	; 56
    39dc:	0f 90       	pop	r0
    39de:	0f be       	out	0x3f, r0	; 63
    39e0:	0f 90       	pop	r0
    39e2:	1f 90       	pop	r1
    39e4:	18 95       	reti

000039e6 <__vector_91>:
=======
    3b68:	81 e0       	ldi	r24, 0x01	; 1
    3b6a:	90 e0       	ldi	r25, 0x00	; 0
    3b6c:	f3 cf       	rjmp	.-26     	; 0x3b54 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3b6e:	ff 91       	pop	r31
    3b70:	ef 91       	pop	r30
    3b72:	9f 91       	pop	r25
    3b74:	8f 91       	pop	r24
    3b76:	3f 91       	pop	r19
    3b78:	2f 91       	pop	r18
    3b7a:	0f 90       	pop	r0
    3b7c:	0b be       	out	0x3b, r0	; 59
    3b7e:	0f 90       	pop	r0
    3b80:	08 be       	out	0x38, r0	; 56
    3b82:	0f 90       	pop	r0
    3b84:	0f be       	out	0x3f, r0	; 63
    3b86:	0f 90       	pop	r0
    3b88:	1f 90       	pop	r1
    3b8a:	18 95       	reti

00003b8c <__vector_91>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
<<<<<<< HEAD
    39e6:	1f 92       	push	r1
    39e8:	0f 92       	push	r0
    39ea:	0f b6       	in	r0, 0x3f	; 63
    39ec:	0f 92       	push	r0
    39ee:	11 24       	eor	r1, r1
    39f0:	08 b6       	in	r0, 0x38	; 56
    39f2:	0f 92       	push	r0
    39f4:	18 be       	out	0x38, r1	; 56
    39f6:	0b b6       	in	r0, 0x3b	; 59
    39f8:	0f 92       	push	r0
    39fa:	1b be       	out	0x3b, r1	; 59
    39fc:	2f 93       	push	r18
    39fe:	3f 93       	push	r19
    3a00:	8f 93       	push	r24
    3a02:	9f 93       	push	r25
    3a04:	ef 93       	push	r30
    3a06:	ff 93       	push	r31
=======
    3b8c:	1f 92       	push	r1
    3b8e:	0f 92       	push	r0
    3b90:	0f b6       	in	r0, 0x3f	; 63
    3b92:	0f 92       	push	r0
    3b94:	11 24       	eor	r1, r1
    3b96:	08 b6       	in	r0, 0x38	; 56
    3b98:	0f 92       	push	r0
    3b9a:	18 be       	out	0x38, r1	; 56
    3b9c:	0b b6       	in	r0, 0x3b	; 59
    3b9e:	0f 92       	push	r0
    3ba0:	1b be       	out	0x3b, r1	; 59
    3ba2:	2f 93       	push	r18
    3ba4:	3f 93       	push	r19
    3ba6:	8f 93       	push	r24
    3ba8:	9f 93       	push	r25
    3baa:	ef 93       	push	r30
    3bac:	ff 93       	push	r31
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
<<<<<<< HEAD
    3a08:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3a0c:	e0 91 2e 31 	lds	r30, 0x312E	; 0x80312e <rcvD1_buffer>
    3a10:	f0 91 2f 31 	lds	r31, 0x312F	; 0x80312f <rcvD1_buffer+0x1>
    3a14:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <rcvD1_write_index>
    3a18:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <rcvD1_write_index+0x1>
    3a1c:	e8 0f       	add	r30, r24
    3a1e:	f9 1f       	adc	r31, r25
    3a20:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3a22:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <rcvD1_write_index>
    3a26:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <rcvD1_write_index+0x1>
    3a2a:	01 96       	adiw	r24, 0x01	; 1
    3a2c:	84 36       	cpi	r24, 0x64	; 100
    3a2e:	91 05       	cpc	r25, r1
    3a30:	60 f4       	brcc	.+24     	; 0x3a4a <__vector_91+0x64>
    3a32:	80 93 1a 31 	sts	0x311A, r24	; 0x80311a <rcvD1_write_index>
    3a36:	90 93 1b 31 	sts	0x311B, r25	; 0x80311b <rcvD1_write_index+0x1>
=======
    3bae:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3bb2:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <rcvD1_buffer>
    3bb6:	f0 91 65 31 	lds	r31, 0x3165	; 0x803165 <rcvD1_buffer+0x1>
    3bba:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvD1_write_index>
    3bbe:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvD1_write_index+0x1>
    3bc2:	e8 0f       	add	r30, r24
    3bc4:	f9 1f       	adc	r31, r25
    3bc6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3bc8:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvD1_write_index>
    3bcc:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvD1_write_index+0x1>
    3bd0:	01 96       	adiw	r24, 0x01	; 1
    3bd2:	84 36       	cpi	r24, 0x64	; 100
    3bd4:	91 05       	cpc	r25, r1
    3bd6:	60 f4       	brcc	.+24     	; 0x3bf0 <__vector_91+0x64>
    3bd8:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvD1_write_index>
    3bdc:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvD1_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
<<<<<<< HEAD
    3a3a:	20 91 24 31 	lds	r18, 0x3124	; 0x803124 <rcvD1_read_index>
    3a3e:	30 91 25 31 	lds	r19, 0x3125	; 0x803125 <rcvD1_read_index+0x1>
    3a42:	82 17       	cp	r24, r18
    3a44:	93 07       	cpc	r25, r19
    3a46:	f1 f4       	brne	.+60     	; 0x3a84 <__vector_91+0x9e>
    3a48:	0c c0       	rjmp	.+24     	; 0x3a62 <__vector_91+0x7c>
=======
    3be0:	20 91 5a 31 	lds	r18, 0x315A	; 0x80315a <rcvD1_read_index>
    3be4:	30 91 5b 31 	lds	r19, 0x315B	; 0x80315b <rcvD1_read_index+0x1>
    3be8:	82 17       	cp	r24, r18
    3bea:	93 07       	cpc	r25, r19
    3bec:	f1 f4       	brne	.+60     	; 0x3c2a <__vector_91+0x9e>
    3bee:	0c c0       	rjmp	.+24     	; 0x3c08 <__vector_91+0x7c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
<<<<<<< HEAD
    3a4a:	10 92 1a 31 	sts	0x311A, r1	; 0x80311a <rcvD1_write_index>
    3a4e:	10 92 1b 31 	sts	0x311B, r1	; 0x80311b <rcvD1_write_index+0x1>
=======
    3bf0:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvD1_write_index>
    3bf4:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvD1_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
<<<<<<< HEAD
    3a52:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvD1_read_index>
    3a56:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvD1_read_index+0x1>
    3a5a:	18 16       	cp	r1, r24
    3a5c:	19 06       	cpc	r1, r25
    3a5e:	91 f4       	brne	.+36     	; 0x3a84 <__vector_91+0x9e>
    3a60:	0e c0       	rjmp	.+28     	; 0x3a7e <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3a62:	01 96       	adiw	r24, 0x01	; 1
    3a64:	84 36       	cpi	r24, 0x64	; 100
    3a66:	91 05       	cpc	r25, r1
    3a68:	28 f4       	brcc	.+10     	; 0x3a74 <__vector_91+0x8e>
    3a6a:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <rcvD1_read_index>
    3a6e:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <rcvD1_read_index+0x1>
    3a72:	08 c0       	rjmp	.+16     	; 0x3a84 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3a74:	10 92 24 31 	sts	0x3124, r1	; 0x803124 <rcvD1_read_index>
    3a78:	10 92 25 31 	sts	0x3125, r1	; 0x803125 <rcvD1_read_index+0x1>
}
    3a7c:	03 c0       	rjmp	.+6      	; 0x3a84 <__vector_91+0x9e>
=======
    3bf8:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvD1_read_index>
    3bfc:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvD1_read_index+0x1>
    3c00:	18 16       	cp	r1, r24
    3c02:	19 06       	cpc	r1, r25
    3c04:	91 f4       	brne	.+36     	; 0x3c2a <__vector_91+0x9e>
    3c06:	0e c0       	rjmp	.+28     	; 0x3c24 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3c08:	01 96       	adiw	r24, 0x01	; 1
    3c0a:	84 36       	cpi	r24, 0x64	; 100
    3c0c:	91 05       	cpc	r25, r1
    3c0e:	28 f4       	brcc	.+10     	; 0x3c1a <__vector_91+0x8e>
    3c10:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvD1_read_index>
    3c14:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvD1_read_index+0x1>
    3c18:	08 c0       	rjmp	.+16     	; 0x3c2a <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3c1a:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvD1_read_index>
    3c1e:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvD1_read_index+0x1>
}
    3c22:	03 c0       	rjmp	.+6      	; 0x3c2a <__vector_91+0x9e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
<<<<<<< HEAD
    3a7e:	81 e0       	ldi	r24, 0x01	; 1
    3a80:	90 e0       	ldi	r25, 0x00	; 0
    3a82:	f3 cf       	rjmp	.-26     	; 0x3a6a <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3a84:	ff 91       	pop	r31
    3a86:	ef 91       	pop	r30
    3a88:	9f 91       	pop	r25
    3a8a:	8f 91       	pop	r24
    3a8c:	3f 91       	pop	r19
    3a8e:	2f 91       	pop	r18
    3a90:	0f 90       	pop	r0
    3a92:	0b be       	out	0x3b, r0	; 59
    3a94:	0f 90       	pop	r0
    3a96:	08 be       	out	0x38, r0	; 56
    3a98:	0f 90       	pop	r0
    3a9a:	0f be       	out	0x3f, r0	; 63
    3a9c:	0f 90       	pop	r0
    3a9e:	1f 90       	pop	r1
    3aa0:	18 95       	reti

00003aa2 <__vector_58>:
=======
    3c24:	81 e0       	ldi	r24, 0x01	; 1
    3c26:	90 e0       	ldi	r25, 0x00	; 0
    3c28:	f3 cf       	rjmp	.-26     	; 0x3c10 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3c2a:	ff 91       	pop	r31
    3c2c:	ef 91       	pop	r30
    3c2e:	9f 91       	pop	r25
    3c30:	8f 91       	pop	r24
    3c32:	3f 91       	pop	r19
    3c34:	2f 91       	pop	r18
    3c36:	0f 90       	pop	r0
    3c38:	0b be       	out	0x3b, r0	; 59
    3c3a:	0f 90       	pop	r0
    3c3c:	08 be       	out	0x38, r0	; 56
    3c3e:	0f 90       	pop	r0
    3c40:	0f be       	out	0x3f, r0	; 63
    3c42:	0f 90       	pop	r0
    3c44:	1f 90       	pop	r1
    3c46:	18 95       	reti

00003c48 <__vector_58>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
<<<<<<< HEAD
    3aa2:	1f 92       	push	r1
    3aa4:	0f 92       	push	r0
    3aa6:	0f b6       	in	r0, 0x3f	; 63
    3aa8:	0f 92       	push	r0
    3aaa:	11 24       	eor	r1, r1
    3aac:	08 b6       	in	r0, 0x38	; 56
    3aae:	0f 92       	push	r0
    3ab0:	18 be       	out	0x38, r1	; 56
    3ab2:	0b b6       	in	r0, 0x3b	; 59
    3ab4:	0f 92       	push	r0
    3ab6:	1b be       	out	0x3b, r1	; 59
    3ab8:	2f 93       	push	r18
    3aba:	3f 93       	push	r19
    3abc:	8f 93       	push	r24
    3abe:	9f 93       	push	r25
    3ac0:	ef 93       	push	r30
    3ac2:	ff 93       	push	r31
=======
    3c48:	1f 92       	push	r1
    3c4a:	0f 92       	push	r0
    3c4c:	0f b6       	in	r0, 0x3f	; 63
    3c4e:	0f 92       	push	r0
    3c50:	11 24       	eor	r1, r1
    3c52:	08 b6       	in	r0, 0x38	; 56
    3c54:	0f 92       	push	r0
    3c56:	18 be       	out	0x38, r1	; 56
    3c58:	0b b6       	in	r0, 0x3b	; 59
    3c5a:	0f 92       	push	r0
    3c5c:	1b be       	out	0x3b, r1	; 59
    3c5e:	2f 93       	push	r18
    3c60:	3f 93       	push	r19
    3c62:	8f 93       	push	r24
    3c64:	9f 93       	push	r25
    3c66:	ef 93       	push	r30
    3c68:	ff 93       	push	r31
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
<<<<<<< HEAD
    3ac4:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3ac8:	e0 91 2c 31 	lds	r30, 0x312C	; 0x80312c <rcvE0_buffer>
    3acc:	f0 91 2d 31 	lds	r31, 0x312D	; 0x80312d <rcvE0_buffer+0x1>
    3ad0:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <rcvE0_write_index>
    3ad4:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <rcvE0_write_index+0x1>
    3ad8:	e8 0f       	add	r30, r24
    3ada:	f9 1f       	adc	r31, r25
    3adc:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3ade:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <rcvE0_write_index>
    3ae2:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <rcvE0_write_index+0x1>
    3ae6:	01 96       	adiw	r24, 0x01	; 1
    3ae8:	84 36       	cpi	r24, 0x64	; 100
    3aea:	91 05       	cpc	r25, r1
    3aec:	60 f4       	brcc	.+24     	; 0x3b06 <__vector_58+0x64>
    3aee:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <rcvE0_write_index>
    3af2:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <rcvE0_write_index+0x1>
=======
    3c6a:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3c6e:	e0 91 62 31 	lds	r30, 0x3162	; 0x803162 <rcvE0_buffer>
    3c72:	f0 91 63 31 	lds	r31, 0x3163	; 0x803163 <rcvE0_buffer+0x1>
    3c76:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvE0_write_index>
    3c7a:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvE0_write_index+0x1>
    3c7e:	e8 0f       	add	r30, r24
    3c80:	f9 1f       	adc	r31, r25
    3c82:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3c84:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvE0_write_index>
    3c88:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvE0_write_index+0x1>
    3c8c:	01 96       	adiw	r24, 0x01	; 1
    3c8e:	84 36       	cpi	r24, 0x64	; 100
    3c90:	91 05       	cpc	r25, r1
    3c92:	60 f4       	brcc	.+24     	; 0x3cac <__vector_58+0x64>
    3c94:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvE0_write_index>
    3c98:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvE0_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
<<<<<<< HEAD
    3af6:	20 91 22 31 	lds	r18, 0x3122	; 0x803122 <rcvE0_read_index>
    3afa:	30 91 23 31 	lds	r19, 0x3123	; 0x803123 <rcvE0_read_index+0x1>
    3afe:	82 17       	cp	r24, r18
    3b00:	93 07       	cpc	r25, r19
    3b02:	f1 f4       	brne	.+60     	; 0x3b40 <__vector_58+0x9e>
    3b04:	0c c0       	rjmp	.+24     	; 0x3b1e <__vector_58+0x7c>
=======
    3c9c:	20 91 58 31 	lds	r18, 0x3158	; 0x803158 <rcvE0_read_index>
    3ca0:	30 91 59 31 	lds	r19, 0x3159	; 0x803159 <rcvE0_read_index+0x1>
    3ca4:	82 17       	cp	r24, r18
    3ca6:	93 07       	cpc	r25, r19
    3ca8:	f1 f4       	brne	.+60     	; 0x3ce6 <__vector_58+0x9e>
    3caa:	0c c0       	rjmp	.+24     	; 0x3cc4 <__vector_58+0x7c>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
<<<<<<< HEAD
    3b06:	10 92 18 31 	sts	0x3118, r1	; 0x803118 <rcvE0_write_index>
    3b0a:	10 92 19 31 	sts	0x3119, r1	; 0x803119 <rcvE0_write_index+0x1>
=======
    3cac:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvE0_write_index>
    3cb0:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvE0_write_index+0x1>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
<<<<<<< HEAD
    3b0e:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvE0_read_index>
    3b12:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvE0_read_index+0x1>
    3b16:	18 16       	cp	r1, r24
    3b18:	19 06       	cpc	r1, r25
    3b1a:	91 f4       	brne	.+36     	; 0x3b40 <__vector_58+0x9e>
    3b1c:	0e c0       	rjmp	.+28     	; 0x3b3a <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3b1e:	01 96       	adiw	r24, 0x01	; 1
    3b20:	84 36       	cpi	r24, 0x64	; 100
    3b22:	91 05       	cpc	r25, r1
    3b24:	28 f4       	brcc	.+10     	; 0x3b30 <__vector_58+0x8e>
    3b26:	80 93 22 31 	sts	0x3122, r24	; 0x803122 <rcvE0_read_index>
    3b2a:	90 93 23 31 	sts	0x3123, r25	; 0x803123 <rcvE0_read_index+0x1>
    3b2e:	08 c0       	rjmp	.+16     	; 0x3b40 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3b30:	10 92 22 31 	sts	0x3122, r1	; 0x803122 <rcvE0_read_index>
    3b34:	10 92 23 31 	sts	0x3123, r1	; 0x803123 <rcvE0_read_index+0x1>
}
    3b38:	03 c0       	rjmp	.+6      	; 0x3b40 <__vector_58+0x9e>
=======
    3cb4:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvE0_read_index>
    3cb8:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvE0_read_index+0x1>
    3cbc:	18 16       	cp	r1, r24
    3cbe:	19 06       	cpc	r1, r25
    3cc0:	91 f4       	brne	.+36     	; 0x3ce6 <__vector_58+0x9e>
    3cc2:	0e c0       	rjmp	.+28     	; 0x3ce0 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3cc4:	01 96       	adiw	r24, 0x01	; 1
    3cc6:	84 36       	cpi	r24, 0x64	; 100
    3cc8:	91 05       	cpc	r25, r1
    3cca:	28 f4       	brcc	.+10     	; 0x3cd6 <__vector_58+0x8e>
    3ccc:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvE0_read_index>
    3cd0:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvE0_read_index+0x1>
    3cd4:	08 c0       	rjmp	.+16     	; 0x3ce6 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3cd6:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvE0_read_index>
    3cda:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvE0_read_index+0x1>
}
    3cde:	03 c0       	rjmp	.+6      	; 0x3ce6 <__vector_58+0x9e>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
<<<<<<< HEAD
    3b3a:	81 e0       	ldi	r24, 0x01	; 1
    3b3c:	90 e0       	ldi	r25, 0x00	; 0
    3b3e:	f3 cf       	rjmp	.-26     	; 0x3b26 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3b40:	ff 91       	pop	r31
    3b42:	ef 91       	pop	r30
    3b44:	9f 91       	pop	r25
    3b46:	8f 91       	pop	r24
    3b48:	3f 91       	pop	r19
    3b4a:	2f 91       	pop	r18
    3b4c:	0f 90       	pop	r0
    3b4e:	0b be       	out	0x3b, r0	; 59
    3b50:	0f 90       	pop	r0
    3b52:	08 be       	out	0x38, r0	; 56
    3b54:	0f 90       	pop	r0
    3b56:	0f be       	out	0x3f, r0	; 63
    3b58:	0f 90       	pop	r0
    3b5a:	1f 90       	pop	r1
    3b5c:	18 95       	reti

00003b5e <_Z8CCPWritePVhh>:
=======
    3ce0:	81 e0       	ldi	r24, 0x01	; 1
    3ce2:	90 e0       	ldi	r25, 0x00	; 0
    3ce4:	f3 cf       	rjmp	.-26     	; 0x3ccc <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3ce6:	ff 91       	pop	r31
    3ce8:	ef 91       	pop	r30
    3cea:	9f 91       	pop	r25
    3cec:	8f 91       	pop	r24
    3cee:	3f 91       	pop	r19
    3cf0:	2f 91       	pop	r18
    3cf2:	0f 90       	pop	r0
    3cf4:	0b be       	out	0x3b, r0	; 59
    3cf6:	0f 90       	pop	r0
    3cf8:	08 be       	out	0x38, r0	; 56
    3cfa:	0f 90       	pop	r0
    3cfc:	0f be       	out	0x3f, r0	; 63
    3cfe:	0f 90       	pop	r0
    3d00:	1f 90       	pop	r1
    3d02:	18 95       	reti

00003d04 <_Z8CCPWritePVhh>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
<<<<<<< HEAD
    3b5e:	0f 93       	push	r16
    3b60:	cf 93       	push	r28
    3b62:	df 93       	push	r29
    3b64:	1f 92       	push	r1
    3b66:	cd b7       	in	r28, 0x3d	; 61
    3b68:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3b6a:	2f b7       	in	r18, 0x3f	; 63
    3b6c:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3b6e:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3b70:	1b be       	out	0x3b, r1	; 59
=======
    3d04:	0f 93       	push	r16
    3d06:	cf 93       	push	r28
    3d08:	df 93       	push	r29
    3d0a:	1f 92       	push	r1
    3d0c:	cd b7       	in	r28, 0x3d	; 61
    3d0e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3d10:	2f b7       	in	r18, 0x3f	; 63
    3d12:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3d14:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3d16:	1b be       	out	0x3b, r1	; 59
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
<<<<<<< HEAD
    3b72:	fc 01       	movw	r30, r24
    3b74:	08 ed       	ldi	r16, 0xD8	; 216
    3b76:	04 bf       	out	0x34, r16	; 52
    3b78:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3b7a:	89 81       	ldd	r24, Y+1	; 0x01
    3b7c:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3b7e:	0f 90       	pop	r0
    3b80:	df 91       	pop	r29
    3b82:	cf 91       	pop	r28
    3b84:	0f 91       	pop	r16
    3b86:	08 95       	ret

00003b88 <main>:
=======
    3d18:	fc 01       	movw	r30, r24
    3d1a:	08 ed       	ldi	r16, 0xD8	; 216
    3d1c:	04 bf       	out	0x34, r16	; 52
    3d1e:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3d20:	89 81       	ldd	r24, Y+1	; 0x01
    3d22:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3d24:	0f 90       	pop	r0
    3d26:	df 91       	pop	r29
    3d28:	cf 91       	pop	r28
    3d2a:	0f 91       	pop	r16
    3d2c:	08 95       	ret

00003d2e <main>:
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
<<<<<<< HEAD
    3b88:	0f 93       	push	r16
    3b8a:	1f 93       	push	r17
    3b8c:	cf 93       	push	r28
    3b8e:	df 93       	push	r29
    3b90:	cd b7       	in	r28, 0x3d	; 61
    3b92:	de b7       	in	r29, 0x3e	; 62
    3b94:	6d 97       	sbiw	r28, 0x1d	; 29
    3b96:	cd bf       	out	0x3d, r28	; 61
    3b98:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3b9a:	e0 e6       	ldi	r30, 0x60	; 96
    3b9c:	f6 e0       	ldi	r31, 0x06	; 6
    3b9e:	80 e4       	ldi	r24, 0x40	; 64
    3ba0:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3ba2:	85 83       	std	Z+5, r24	; 0x05
=======
    3d2e:	0f 93       	push	r16
    3d30:	1f 93       	push	r17
    3d32:	cf 93       	push	r28
    3d34:	df 93       	push	r29
    3d36:	cd b7       	in	r28, 0x3d	; 61
    3d38:	de b7       	in	r29, 0x3e	; 62
    3d3a:	6d 97       	sbiw	r28, 0x1d	; 29
    3d3c:	cd bf       	out	0x3d, r28	; 61
    3d3e:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3d40:	e0 e6       	ldi	r30, 0x60	; 96
    3d42:	f6 e0       	ldi	r31, 0x06	; 6
    3d44:	80 e4       	ldi	r24, 0x40	; 64
    3d46:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3d48:	85 83       	std	Z+5, r24	; 0x05
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
<<<<<<< HEAD
    3ba4:	f8 94       	cli
=======
    3d4a:	f8 94       	cli
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
<<<<<<< HEAD
    3ba6:	e0 e5       	ldi	r30, 0x50	; 80
    3ba8:	f0 e0       	ldi	r31, 0x00	; 0
    3baa:	80 81       	ld	r24, Z
    3bac:	82 60       	ori	r24, 0x02	; 2
    3bae:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3bb0:	81 81       	ldd	r24, Z+1	; 0x01
    3bb2:	81 ff       	sbrs	r24, 1
    3bb4:	fd cf       	rjmp	.-6      	; 0x3bb0 <main+0x28>
=======
    3d4c:	e0 e5       	ldi	r30, 0x50	; 80
    3d4e:	f0 e0       	ldi	r31, 0x00	; 0
    3d50:	80 81       	ld	r24, Z
    3d52:	82 60       	ori	r24, 0x02	; 2
    3d54:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3d56:	81 81       	ldd	r24, Z+1	; 0x01
    3d58:	81 ff       	sbrs	r24, 1
    3d5a:	fd cf       	rjmp	.-6      	; 0x3d56 <main+0x28>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
<<<<<<< HEAD
    3bb6:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3bba:	68 7f       	andi	r22, 0xF8	; 248
    3bbc:	61 60       	ori	r22, 0x01	; 1
    3bbe:	80 e4       	ldi	r24, 0x40	; 64
    3bc0:	90 e0       	ldi	r25, 0x00	; 0
    3bc2:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3bc6:	e0 e5       	ldi	r30, 0x50	; 80
    3bc8:	f0 e0       	ldi	r31, 0x00	; 0
    3bca:	80 81       	ld	r24, Z
    3bcc:	8e 7f       	andi	r24, 0xFE	; 254
    3bce:	80 83       	st	Z, r24
=======
    3d5c:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3d60:	68 7f       	andi	r22, 0xF8	; 248
    3d62:	61 60       	ori	r22, 0x01	; 1
    3d64:	80 e4       	ldi	r24, 0x40	; 64
    3d66:	90 e0       	ldi	r25, 0x00	; 0
    3d68:	0e 94 82 1e 	call	0x3d04	; 0x3d04 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3d6c:	e0 e5       	ldi	r30, 0x50	; 80
    3d6e:	f0 e0       	ldi	r31, 0x00	; 0
    3d70:	80 81       	ld	r24, Z
    3d72:	8e 7f       	andi	r24, 0xFE	; 254
    3d74:	80 83       	st	Z, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
<<<<<<< HEAD
    3bd0:	9d ef       	ldi	r25, 0xFD	; 253
    3bd2:	88 ed       	ldi	r24, 0xD8	; 216
    3bd4:	08 b6       	in	r0, 0x38	; 56
    3bd6:	18 be       	out	0x38, r1	; 56
    3bd8:	84 bf       	out	0x34, r24	; 52
    3bda:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3bde:	08 be       	out	0x38, r0	; 56
=======
    3d76:	9d ef       	ldi	r25, 0xFD	; 253
    3d78:	88 ed       	ldi	r24, 0xD8	; 216
    3d7a:	08 b6       	in	r0, 0x38	; 56
    3d7c:	18 be       	out	0x38, r1	; 56
    3d7e:	84 bf       	out	0x34, r24	; 52
    3d80:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3d84:	08 be       	out	0x38, r0	; 56
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
<<<<<<< HEAD
    3be0:	40 eb       	ldi	r20, 0xB0	; 176
    3be2:	58 e0       	ldi	r21, 0x08	; 8
    3be4:	60 e0       	ldi	r22, 0x00	; 0
    3be6:	70 e0       	ldi	r23, 0x00	; 0
    3be8:	ce 01       	movw	r24, r28
    3bea:	01 96       	adiw	r24, 0x01	; 1
    3bec:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3bf0:	67 e0       	ldi	r22, 0x07	; 7
    3bf2:	ce 01       	movw	r24, r28
    3bf4:	01 96       	adiw	r24, 0x01	; 1
    3bf6:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    3bfa:	8c 01       	movw	r16, r24
=======
    3d86:	40 eb       	ldi	r20, 0xB0	; 176
    3d88:	58 e0       	ldi	r21, 0x08	; 8
    3d8a:	60 e0       	ldi	r22, 0x00	; 0
    3d8c:	70 e0       	ldi	r23, 0x00	; 0
    3d8e:	ce 01       	movw	r24, r28
    3d90:	01 96       	adiw	r24, 0x01	; 1
    3d92:	0e 94 2c 1c 	call	0x3858	; 0x3858 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3d96:	67 e0       	ldi	r22, 0x07	; 7
    3d98:	ce 01       	movw	r24, r28
    3d9a:	01 96       	adiw	r24, 0x01	; 1
    3d9c:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    3da0:	8c 01       	movw	r16, r24
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
<<<<<<< HEAD
    3bfc:	6b e6       	ldi	r22, 0x6B	; 107
    3bfe:	70 e2       	ldi	r23, 0x20	; 32
    3c00:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8emstream4putsEPKc>
    3c04:	66 e0       	ldi	r22, 0x06	; 6
    3c06:	c8 01       	movw	r24, r16
    3c08:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
    3c0c:	66 e0       	ldi	r22, 0x06	; 6
    3c0e:	0e 94 8d 19 	call	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator>
=======
    3da2:	69 e9       	ldi	r22, 0x99	; 153
    3da4:	70 e2       	ldi	r23, 0x20	; 32
    3da6:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8emstream4putsEPKc>
    3daa:	66 e0       	ldi	r22, 0x06	; 6
    3dac:	c8 01       	movw	r24, r16
    3dae:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
    3db2:	66 e0       	ldi	r22, 0x06	; 6
    3db4:	0e 94 35 1a 	call	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
<<<<<<< HEAD
    3c12:	82 e1       	ldi	r24, 0x12	; 18
    3c14:	90 e0       	ldi	r25, 0x00	; 0
    3c16:	0e 94 a2 18 	call	0x3144	; 0x3144 <_Znwj>
    3c1a:	8e 01       	movw	r16, r28
    3c1c:	0f 5f       	subi	r16, 0xFF	; 255
    3c1e:	1f 4f       	sbci	r17, 0xFF	; 255
    3c20:	24 e0       	ldi	r18, 0x04	; 4
    3c22:	31 e0       	ldi	r19, 0x01	; 1
    3c24:	40 e0       	ldi	r20, 0x00	; 0
    3c26:	6a e8       	ldi	r22, 0x8A	; 138
    3c28:	70 e2       	ldi	r23, 0x20	; 32
    3c2a:	0e 94 63 06 	call	0xcc6	; 0xcc6 <_ZN9task_userC1EPKchjP8emstream>
=======
    3db8:	82 e1       	ldi	r24, 0x12	; 18
    3dba:	90 e0       	ldi	r25, 0x00	; 0
    3dbc:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3dc0:	8e 01       	movw	r16, r28
    3dc2:	0f 5f       	subi	r16, 0xFF	; 255
    3dc4:	1f 4f       	sbci	r17, 0xFF	; 255
    3dc6:	24 e0       	ldi	r18, 0x04	; 4
    3dc8:	31 e0       	ldi	r19, 0x01	; 1
    3dca:	40 e0       	ldi	r20, 0x00	; 0
    3dcc:	68 eb       	ldi	r22, 0xB8	; 184
    3dce:	70 e2       	ldi	r23, 0x20	; 32
    3dd0:	0e 94 0b 07 	call	0xe16	; 0xe16 <_ZN9task_userC1EPKchjP8emstream>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
<<<<<<< HEAD
    3c2e:	82 e1       	ldi	r24, 0x12	; 18
    3c30:	90 e0       	ldi	r25, 0x00	; 0
    3c32:	0e 94 a2 18 	call	0x3144	; 0x3144 <_Znwj>
    3c36:	24 e0       	ldi	r18, 0x04	; 4
    3c38:	31 e0       	ldi	r19, 0x01	; 1
    3c3a:	42 e0       	ldi	r20, 0x02	; 2
    3c3c:	62 e9       	ldi	r22, 0x92	; 146
    3c3e:	70 e2       	ldi	r23, 0x20	; 32
    3c40:	0e 94 52 03 	call	0x6a4	; 0x6a4 <_ZN12EncoderMotorC1EPKchjP8emstream>
	//the pendulum
	//new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
=======
    3dd4:	82 e1       	ldi	r24, 0x12	; 18
    3dd6:	90 e0       	ldi	r25, 0x00	; 0
    3dd8:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3ddc:	24 e0       	ldi	r18, 0x04	; 4
    3dde:	31 e0       	ldi	r19, 0x01	; 1
    3de0:	42 e0       	ldi	r20, 0x02	; 2
    3de2:	60 ec       	ldi	r22, 0xC0	; 192
    3de4:	70 e2       	ldi	r23, 0x20	; 32
    3de6:	0e 94 54 03 	call	0x6a8	; 0x6a8 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3dea:	82 e1       	ldi	r24, 0x12	; 18
    3dec:	90 e0       	ldi	r25, 0x00	; 0
    3dee:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3df2:	24 e0       	ldi	r18, 0x04	; 4
    3df4:	31 e0       	ldi	r19, 0x01	; 1
    3df6:	43 e0       	ldi	r20, 0x03	; 3
    3df8:	67 ec       	ldi	r22, 0xC7	; 199
    3dfa:	70 e2       	ldi	r23, 0x20	; 32
    3dfc:	0e 94 c4 03 	call	0x788	; 0x788 <_ZN15EncoderPendulumC1EPKchjP8emstream>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
<<<<<<< HEAD
    3c44:	82 e1       	ldi	r24, 0x12	; 18
    3c46:	90 e0       	ldi	r25, 0x00	; 0
    3c48:	0e 94 a2 18 	call	0x3144	; 0x3144 <_Znwj>
    3c4c:	24 e0       	ldi	r18, 0x04	; 4
    3c4e:	31 e0       	ldi	r19, 0x01	; 1
    3c50:	44 e0       	ldi	r20, 0x04	; 4
    3c52:	69 e9       	ldi	r22, 0x99	; 153
    3c54:	70 e2       	ldi	r23, 0x20	; 32
    3c56:	0e 94 b7 03 	call	0x76e	; 0x76e <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3c5a:	8c e6       	ldi	r24, 0x6C	; 108
    3c5c:	90 e0       	ldi	r25, 0x00	; 0
    3c5e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_Znwj>
    3c62:	24 e0       	ldi	r18, 0x04	; 4
    3c64:	31 e0       	ldi	r19, 0x01	; 1
    3c66:	43 e0       	ldi	r20, 0x03	; 3
    3c68:	62 ea       	ldi	r22, 0xA2	; 162
    3c6a:	70 e2       	ldi	r23, 0x20	; 32
    3c6c:	0e 94 af 05 	call	0xb5e	; 0xb5e <_ZN5MotorC1EPKchjP8emstream>
	
	new PWMdriver ("PWM", task_priority(5), 260, &ser_dev);
    3c70:	82 e1       	ldi	r24, 0x12	; 18
    3c72:	90 e0       	ldi	r25, 0x00	; 0
    3c74:	0e 94 a2 18 	call	0x3144	; 0x3144 <_Znwj>
    3c78:	24 e0       	ldi	r18, 0x04	; 4
    3c7a:	31 e0       	ldi	r19, 0x01	; 1
    3c7c:	44 e0       	ldi	r20, 0x04	; 4
    3c7e:	68 ea       	ldi	r22, 0xA8	; 168
    3c80:	70 e2       	ldi	r23, 0x20	; 32
    3c82:	0e 94 25 06 	call	0xc4a	; 0xc4a <_ZN9PWMdriverC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3c86:	87 e0       	ldi	r24, 0x07	; 7
    3c88:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3c8c:	78 94       	sei
=======
    3e00:	82 e1       	ldi	r24, 0x12	; 18
    3e02:	90 e0       	ldi	r25, 0x00	; 0
    3e04:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3e08:	24 e0       	ldi	r18, 0x04	; 4
    3e0a:	31 e0       	ldi	r19, 0x01	; 1
    3e0c:	44 e0       	ldi	r20, 0x04	; 4
    3e0e:	6e ec       	ldi	r22, 0xCE	; 206
    3e10:	70 e2       	ldi	r23, 0x20	; 32
    3e12:	0e 94 29 04 	call	0x852	; 0x852 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3e16:	8e e5       	ldi	r24, 0x5E	; 94
    3e18:	90 e0       	ldi	r25, 0x00	; 0
    3e1a:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3e1e:	24 e0       	ldi	r18, 0x04	; 4
    3e20:	31 e0       	ldi	r19, 0x01	; 1
    3e22:	43 e0       	ldi	r20, 0x03	; 3
    3e24:	67 ed       	ldi	r22, 0xD7	; 215
    3e26:	70 e2       	ldi	r23, 0x20	; 32
    3e28:	0e 94 57 06 	call	0xcae	; 0xcae <_ZN5MotorC1EPKchjP8emstream>
	
	new PWMdriver ("PWM", task_priority(5), 260, &ser_dev);
    3e2c:	82 e1       	ldi	r24, 0x12	; 18
    3e2e:	90 e0       	ldi	r25, 0x00	; 0
    3e30:	0e 94 4a 19 	call	0x3294	; 0x3294 <_Znwj>
    3e34:	24 e0       	ldi	r18, 0x04	; 4
    3e36:	31 e0       	ldi	r19, 0x01	; 1
    3e38:	44 e0       	ldi	r20, 0x04	; 4
    3e3a:	6d ed       	ldi	r22, 0xDD	; 221
    3e3c:	70 e2       	ldi	r23, 0x20	; 32
    3e3e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <_ZN9PWMdriverC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3e42:	87 e0       	ldi	r24, 0x07	; 7
    3e44:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3e48:	78 94       	sei
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
<<<<<<< HEAD
    3c8e:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <vTaskStartScheduler>
	
	
	return 0;
    3c92:	80 e0       	ldi	r24, 0x00	; 0
    3c94:	90 e0       	ldi	r25, 0x00	; 0
    3c96:	6d 96       	adiw	r28, 0x1d	; 29
    3c98:	cd bf       	out	0x3d, r28	; 61
    3c9a:	de bf       	out	0x3e, r29	; 62
    3c9c:	df 91       	pop	r29
    3c9e:	cf 91       	pop	r28
    3ca0:	1f 91       	pop	r17
    3ca2:	0f 91       	pop	r16
    3ca4:	08 95       	ret

00003ca6 <_GLOBAL__sub_I_counter>:
    3ca6:	0f 93       	push	r16
    3ca8:	1f 93       	push	r17
=======
    3e4a:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <vTaskStartScheduler>
	
	
	return 0;
    3e4e:	80 e0       	ldi	r24, 0x00	; 0
    3e50:	90 e0       	ldi	r25, 0x00	; 0
    3e52:	6d 96       	adiw	r28, 0x1d	; 29
    3e54:	cd bf       	out	0x3d, r28	; 61
    3e56:	de bf       	out	0x3e, r29	; 62
    3e58:	df 91       	pop	r29
    3e5a:	cf 91       	pop	r28
    3e5c:	1f 91       	pop	r17
    3e5e:	0f 91       	pop	r16
    3e60:	08 95       	ret

00003e62 <_GLOBAL__sub_I_counter>:
    3e62:	0f 93       	push	r16
    3e64:	1f 93       	push	r17
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
<<<<<<< HEAD
    3caa:	0a e0       	ldi	r16, 0x0A	; 10
    3cac:	10 e0       	ldi	r17, 0x00	; 0
    3cae:	20 e0       	ldi	r18, 0x00	; 0
    3cb0:	30 e0       	ldi	r19, 0x00	; 0
    3cb2:	40 e0       	ldi	r20, 0x00	; 0
    3cb4:	50 e0       	ldi	r21, 0x00	; 0
    3cb6:	60 e2       	ldi	r22, 0x20	; 32
    3cb8:	70 e0       	ldi	r23, 0x00	; 0
    3cba:	8e e3       	ldi	r24, 0x3E	; 62
    3cbc:	91 e3       	ldi	r25, 0x31	; 49
    3cbe:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <_ZN14frt_text_queueC1EjP8emstreamm>
=======
    3e66:	0a e0       	ldi	r16, 0x0A	; 10
    3e68:	10 e0       	ldi	r17, 0x00	; 0
    3e6a:	20 e0       	ldi	r18, 0x00	; 0
    3e6c:	30 e0       	ldi	r19, 0x00	; 0
    3e6e:	40 e0       	ldi	r20, 0x00	; 0
    3e70:	50 e0       	ldi	r21, 0x00	; 0
    3e72:	60 e2       	ldi	r22, 0x20	; 32
    3e74:	70 e0       	ldi	r23, 0x00	; 0
    3e76:	86 e7       	ldi	r24, 0x76	; 118
    3e78:	91 e3       	ldi	r25, 0x31	; 49
    3e7a:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <_ZN14frt_text_queueC1EjP8emstreamm>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
<<<<<<< HEAD
    3cc2:	1f 91       	pop	r17
    3cc4:	0f 91       	pop	r16
    3cc6:	08 95       	ret

00003cc8 <__cmpsf2>:
    3cc8:	0e 94 a6 1e 	call	0x3d4c	; 0x3d4c <__fp_cmp>
    3ccc:	08 f4       	brcc	.+2      	; 0x3cd0 <__cmpsf2+0x8>
    3cce:	81 e0       	ldi	r24, 0x01	; 1
    3cd0:	08 95       	ret

00003cd2 <__floatunsisf>:
    3cd2:	e8 94       	clt
    3cd4:	09 c0       	rjmp	.+18     	; 0x3ce8 <__floatsisf+0x12>

00003cd6 <__floatsisf>:
    3cd6:	97 fb       	bst	r25, 7
    3cd8:	3e f4       	brtc	.+14     	; 0x3ce8 <__floatsisf+0x12>
    3cda:	90 95       	com	r25
    3cdc:	80 95       	com	r24
    3cde:	70 95       	com	r23
    3ce0:	61 95       	neg	r22
    3ce2:	7f 4f       	sbci	r23, 0xFF	; 255
    3ce4:	8f 4f       	sbci	r24, 0xFF	; 255
    3ce6:	9f 4f       	sbci	r25, 0xFF	; 255
    3ce8:	99 23       	and	r25, r25
    3cea:	a9 f0       	breq	.+42     	; 0x3d16 <__floatsisf+0x40>
    3cec:	f9 2f       	mov	r31, r25
    3cee:	96 e9       	ldi	r25, 0x96	; 150
    3cf0:	bb 27       	eor	r27, r27
    3cf2:	93 95       	inc	r25
    3cf4:	f6 95       	lsr	r31
    3cf6:	87 95       	ror	r24
    3cf8:	77 95       	ror	r23
    3cfa:	67 95       	ror	r22
    3cfc:	b7 95       	ror	r27
    3cfe:	f1 11       	cpse	r31, r1
    3d00:	f8 cf       	rjmp	.-16     	; 0x3cf2 <__floatsisf+0x1c>
    3d02:	fa f4       	brpl	.+62     	; 0x3d42 <__floatsisf+0x6c>
    3d04:	bb 0f       	add	r27, r27
    3d06:	11 f4       	brne	.+4      	; 0x3d0c <__floatsisf+0x36>
    3d08:	60 ff       	sbrs	r22, 0
    3d0a:	1b c0       	rjmp	.+54     	; 0x3d42 <__floatsisf+0x6c>
    3d0c:	6f 5f       	subi	r22, 0xFF	; 255
    3d0e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d10:	8f 4f       	sbci	r24, 0xFF	; 255
    3d12:	9f 4f       	sbci	r25, 0xFF	; 255
    3d14:	16 c0       	rjmp	.+44     	; 0x3d42 <__floatsisf+0x6c>
    3d16:	88 23       	and	r24, r24
    3d18:	11 f0       	breq	.+4      	; 0x3d1e <__floatsisf+0x48>
    3d1a:	96 e9       	ldi	r25, 0x96	; 150
    3d1c:	11 c0       	rjmp	.+34     	; 0x3d40 <__floatsisf+0x6a>
    3d1e:	77 23       	and	r23, r23
    3d20:	21 f0       	breq	.+8      	; 0x3d2a <__floatsisf+0x54>
    3d22:	9e e8       	ldi	r25, 0x8E	; 142
    3d24:	87 2f       	mov	r24, r23
    3d26:	76 2f       	mov	r23, r22
    3d28:	05 c0       	rjmp	.+10     	; 0x3d34 <__floatsisf+0x5e>
    3d2a:	66 23       	and	r22, r22
    3d2c:	71 f0       	breq	.+28     	; 0x3d4a <__floatsisf+0x74>
    3d2e:	96 e8       	ldi	r25, 0x86	; 134
    3d30:	86 2f       	mov	r24, r22
    3d32:	70 e0       	ldi	r23, 0x00	; 0
    3d34:	60 e0       	ldi	r22, 0x00	; 0
    3d36:	2a f0       	brmi	.+10     	; 0x3d42 <__floatsisf+0x6c>
    3d38:	9a 95       	dec	r25
    3d3a:	66 0f       	add	r22, r22
    3d3c:	77 1f       	adc	r23, r23
    3d3e:	88 1f       	adc	r24, r24
    3d40:	da f7       	brpl	.-10     	; 0x3d38 <__floatsisf+0x62>
    3d42:	88 0f       	add	r24, r24
    3d44:	96 95       	lsr	r25
    3d46:	87 95       	ror	r24
    3d48:	97 f9       	bld	r25, 7
    3d4a:	08 95       	ret

00003d4c <__fp_cmp>:
    3d4c:	99 0f       	add	r25, r25
    3d4e:	00 08       	sbc	r0, r0
    3d50:	55 0f       	add	r21, r21
    3d52:	aa 0b       	sbc	r26, r26
    3d54:	e0 e8       	ldi	r30, 0x80	; 128
    3d56:	fe ef       	ldi	r31, 0xFE	; 254
    3d58:	16 16       	cp	r1, r22
    3d5a:	17 06       	cpc	r1, r23
    3d5c:	e8 07       	cpc	r30, r24
    3d5e:	f9 07       	cpc	r31, r25
    3d60:	c0 f0       	brcs	.+48     	; 0x3d92 <__fp_cmp+0x46>
    3d62:	12 16       	cp	r1, r18
    3d64:	13 06       	cpc	r1, r19
    3d66:	e4 07       	cpc	r30, r20
    3d68:	f5 07       	cpc	r31, r21
    3d6a:	98 f0       	brcs	.+38     	; 0x3d92 <__fp_cmp+0x46>
    3d6c:	62 1b       	sub	r22, r18
    3d6e:	73 0b       	sbc	r23, r19
    3d70:	84 0b       	sbc	r24, r20
    3d72:	95 0b       	sbc	r25, r21
    3d74:	39 f4       	brne	.+14     	; 0x3d84 <__fp_cmp+0x38>
    3d76:	0a 26       	eor	r0, r26
    3d78:	61 f0       	breq	.+24     	; 0x3d92 <__fp_cmp+0x46>
    3d7a:	23 2b       	or	r18, r19
    3d7c:	24 2b       	or	r18, r20
    3d7e:	25 2b       	or	r18, r21
    3d80:	21 f4       	brne	.+8      	; 0x3d8a <__fp_cmp+0x3e>
    3d82:	08 95       	ret
    3d84:	0a 26       	eor	r0, r26
    3d86:	09 f4       	brne	.+2      	; 0x3d8a <__fp_cmp+0x3e>
    3d88:	a1 40       	sbci	r26, 0x01	; 1
    3d8a:	a6 95       	lsr	r26
    3d8c:	8f ef       	ldi	r24, 0xFF	; 255
    3d8e:	81 1d       	adc	r24, r1
    3d90:	81 1d       	adc	r24, r1
    3d92:	08 95       	ret

00003d94 <__gesf2>:
    3d94:	0e 94 a6 1e 	call	0x3d4c	; 0x3d4c <__fp_cmp>
    3d98:	08 f4       	brcc	.+2      	; 0x3d9c <__gesf2+0x8>
    3d9a:	8f ef       	ldi	r24, 0xFF	; 255
    3d9c:	08 95       	ret

00003d9e <__mulsi3>:
    3d9e:	db 01       	movw	r26, r22
    3da0:	8f 93       	push	r24
    3da2:	9f 93       	push	r25
    3da4:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <__muluhisi3>
    3da8:	bf 91       	pop	r27
    3daa:	af 91       	pop	r26
    3dac:	a2 9f       	mul	r26, r18
    3dae:	80 0d       	add	r24, r0
    3db0:	91 1d       	adc	r25, r1
    3db2:	a3 9f       	mul	r26, r19
    3db4:	90 0d       	add	r25, r0
    3db6:	b2 9f       	mul	r27, r18
    3db8:	90 0d       	add	r25, r0
    3dba:	11 24       	eor	r1, r1
    3dbc:	08 95       	ret

00003dbe <__divmodhi4>:
    3dbe:	97 fb       	bst	r25, 7
    3dc0:	07 2e       	mov	r0, r23
    3dc2:	16 f4       	brtc	.+4      	; 0x3dc8 <__divmodhi4+0xa>
    3dc4:	00 94       	com	r0
    3dc6:	07 d0       	rcall	.+14     	; 0x3dd6 <__divmodhi4_neg1>
    3dc8:	77 fd       	sbrc	r23, 7
    3dca:	09 d0       	rcall	.+18     	; 0x3dde <__divmodhi4_neg2>
    3dcc:	0e 94 6e 1f 	call	0x3edc	; 0x3edc <__udivmodhi4>
    3dd0:	07 fc       	sbrc	r0, 7
    3dd2:	05 d0       	rcall	.+10     	; 0x3dde <__divmodhi4_neg2>
    3dd4:	3e f4       	brtc	.+14     	; 0x3de4 <__divmodhi4_exit>

00003dd6 <__divmodhi4_neg1>:
    3dd6:	90 95       	com	r25
    3dd8:	81 95       	neg	r24
    3dda:	9f 4f       	sbci	r25, 0xFF	; 255
    3ddc:	08 95       	ret

00003dde <__divmodhi4_neg2>:
    3dde:	70 95       	com	r23
    3de0:	61 95       	neg	r22
    3de2:	7f 4f       	sbci	r23, 0xFF	; 255

00003de4 <__divmodhi4_exit>:
    3de4:	08 95       	ret

00003de6 <__udivmodsi4>:
    3de6:	a1 e2       	ldi	r26, 0x21	; 33
    3de8:	1a 2e       	mov	r1, r26
    3dea:	aa 1b       	sub	r26, r26
    3dec:	bb 1b       	sub	r27, r27
    3dee:	fd 01       	movw	r30, r26
    3df0:	0d c0       	rjmp	.+26     	; 0x3e0c <__udivmodsi4_ep>

00003df2 <__udivmodsi4_loop>:
    3df2:	aa 1f       	adc	r26, r26
    3df4:	bb 1f       	adc	r27, r27
    3df6:	ee 1f       	adc	r30, r30
    3df8:	ff 1f       	adc	r31, r31
    3dfa:	a2 17       	cp	r26, r18
    3dfc:	b3 07       	cpc	r27, r19
    3dfe:	e4 07       	cpc	r30, r20
    3e00:	f5 07       	cpc	r31, r21
    3e02:	20 f0       	brcs	.+8      	; 0x3e0c <__udivmodsi4_ep>
    3e04:	a2 1b       	sub	r26, r18
    3e06:	b3 0b       	sbc	r27, r19
    3e08:	e4 0b       	sbc	r30, r20
    3e0a:	f5 0b       	sbc	r31, r21

00003e0c <__udivmodsi4_ep>:
    3e0c:	66 1f       	adc	r22, r22
    3e0e:	77 1f       	adc	r23, r23
    3e10:	88 1f       	adc	r24, r24
    3e12:	99 1f       	adc	r25, r25
    3e14:	1a 94       	dec	r1
    3e16:	69 f7       	brne	.-38     	; 0x3df2 <__udivmodsi4_loop>
    3e18:	60 95       	com	r22
    3e1a:	70 95       	com	r23
    3e1c:	80 95       	com	r24
    3e1e:	90 95       	com	r25
    3e20:	9b 01       	movw	r18, r22
    3e22:	ac 01       	movw	r20, r24
    3e24:	bd 01       	movw	r22, r26
    3e26:	cf 01       	movw	r24, r30
    3e28:	08 95       	ret

00003e2a <__divmodsi4>:
    3e2a:	05 2e       	mov	r0, r21
    3e2c:	97 fb       	bst	r25, 7
    3e2e:	1e f4       	brtc	.+6      	; 0x3e36 <__divmodsi4+0xc>
    3e30:	00 94       	com	r0
    3e32:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__negsi2>
    3e36:	57 fd       	sbrc	r21, 7
    3e38:	07 d0       	rcall	.+14     	; 0x3e48 <__divmodsi4_neg2>
    3e3a:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <__udivmodsi4>
    3e3e:	07 fc       	sbrc	r0, 7
    3e40:	03 d0       	rcall	.+6      	; 0x3e48 <__divmodsi4_neg2>
    3e42:	4e f4       	brtc	.+18     	; 0x3e56 <__divmodsi4_exit>
    3e44:	0c 94 2c 1f 	jmp	0x3e58	; 0x3e58 <__negsi2>

00003e48 <__divmodsi4_neg2>:
    3e48:	50 95       	com	r21
    3e4a:	40 95       	com	r20
    3e4c:	30 95       	com	r19
    3e4e:	21 95       	neg	r18
    3e50:	3f 4f       	sbci	r19, 0xFF	; 255
    3e52:	4f 4f       	sbci	r20, 0xFF	; 255
    3e54:	5f 4f       	sbci	r21, 0xFF	; 255

00003e56 <__divmodsi4_exit>:
    3e56:	08 95       	ret

00003e58 <__negsi2>:
    3e58:	90 95       	com	r25
    3e5a:	80 95       	com	r24
    3e5c:	70 95       	com	r23
    3e5e:	61 95       	neg	r22
    3e60:	7f 4f       	sbci	r23, 0xFF	; 255
    3e62:	8f 4f       	sbci	r24, 0xFF	; 255
    3e64:	9f 4f       	sbci	r25, 0xFF	; 255
    3e66:	08 95       	ret

00003e68 <__tablejump2__>:
    3e68:	ee 0f       	add	r30, r30
    3e6a:	ff 1f       	adc	r31, r31
    3e6c:	88 1f       	adc	r24, r24
    3e6e:	8b bf       	out	0x3b, r24	; 59
    3e70:	07 90       	elpm	r0, Z+
    3e72:	f6 91       	elpm	r31, Z
    3e74:	e0 2d       	mov	r30, r0
    3e76:	1b be       	out	0x3b, r1	; 59
    3e78:	19 94       	eijmp

00003e7a <__mulhisi3>:
    3e7a:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <__umulhisi3>
    3e7e:	33 23       	and	r19, r19
    3e80:	12 f4       	brpl	.+4      	; 0x3e86 <__mulhisi3+0xc>
    3e82:	8a 1b       	sub	r24, r26
    3e84:	9b 0b       	sbc	r25, r27
    3e86:	0c 94 56 1f 	jmp	0x3eac	; 0x3eac <__usmulhisi3_tail>

00003e8a <__umulhisi3>:
    3e8a:	a2 9f       	mul	r26, r18
    3e8c:	b0 01       	movw	r22, r0
    3e8e:	b3 9f       	mul	r27, r19
    3e90:	c0 01       	movw	r24, r0
    3e92:	a3 9f       	mul	r26, r19
    3e94:	70 0d       	add	r23, r0
    3e96:	81 1d       	adc	r24, r1
    3e98:	11 24       	eor	r1, r1
    3e9a:	91 1d       	adc	r25, r1
    3e9c:	b2 9f       	mul	r27, r18
    3e9e:	70 0d       	add	r23, r0
    3ea0:	81 1d       	adc	r24, r1
    3ea2:	11 24       	eor	r1, r1
    3ea4:	91 1d       	adc	r25, r1
    3ea6:	08 95       	ret

00003ea8 <__usmulhisi3>:
    3ea8:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <__umulhisi3>

00003eac <__usmulhisi3_tail>:
    3eac:	b7 ff       	sbrs	r27, 7
    3eae:	08 95       	ret
    3eb0:	82 1b       	sub	r24, r18
    3eb2:	93 0b       	sbc	r25, r19
    3eb4:	08 95       	ret

00003eb6 <__muluhisi3>:
    3eb6:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <__umulhisi3>
    3eba:	a5 9f       	mul	r26, r21
    3ebc:	90 0d       	add	r25, r0
    3ebe:	b4 9f       	mul	r27, r20
    3ec0:	90 0d       	add	r25, r0
    3ec2:	a4 9f       	mul	r26, r20
    3ec4:	80 0d       	add	r24, r0
    3ec6:	91 1d       	adc	r25, r1
    3ec8:	11 24       	eor	r1, r1
    3eca:	08 95       	ret

00003ecc <__mulshisi3>:
    3ecc:	b7 ff       	sbrs	r27, 7
    3ece:	0c 94 5b 1f 	jmp	0x3eb6	; 0x3eb6 <__muluhisi3>

00003ed2 <__mulohisi3>:
    3ed2:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <__muluhisi3>
    3ed6:	82 1b       	sub	r24, r18
    3ed8:	93 0b       	sbc	r25, r19
    3eda:	08 95       	ret

00003edc <__udivmodhi4>:
    3edc:	aa 1b       	sub	r26, r26
    3ede:	bb 1b       	sub	r27, r27
    3ee0:	51 e1       	ldi	r21, 0x11	; 17
    3ee2:	07 c0       	rjmp	.+14     	; 0x3ef2 <__udivmodhi4_ep>

00003ee4 <__udivmodhi4_loop>:
    3ee4:	aa 1f       	adc	r26, r26
    3ee6:	bb 1f       	adc	r27, r27
    3ee8:	a6 17       	cp	r26, r22
    3eea:	b7 07       	cpc	r27, r23
    3eec:	10 f0       	brcs	.+4      	; 0x3ef2 <__udivmodhi4_ep>
    3eee:	a6 1b       	sub	r26, r22
    3ef0:	b7 0b       	sbc	r27, r23

00003ef2 <__udivmodhi4_ep>:
    3ef2:	88 1f       	adc	r24, r24
    3ef4:	99 1f       	adc	r25, r25
    3ef6:	5a 95       	dec	r21
    3ef8:	a9 f7       	brne	.-22     	; 0x3ee4 <__udivmodhi4_loop>
    3efa:	80 95       	com	r24
    3efc:	90 95       	com	r25
    3efe:	bc 01       	movw	r22, r24
    3f00:	cd 01       	movw	r24, r26
    3f02:	08 95       	ret

00003f04 <memcpy>:
    3f04:	fb 01       	movw	r30, r22
    3f06:	dc 01       	movw	r26, r24
    3f08:	02 c0       	rjmp	.+4      	; 0x3f0e <memcpy+0xa>
    3f0a:	01 90       	ld	r0, Z+
    3f0c:	0d 92       	st	X+, r0
    3f0e:	41 50       	subi	r20, 0x01	; 1
    3f10:	50 40       	sbci	r21, 0x00	; 0
    3f12:	d8 f7       	brcc	.-10     	; 0x3f0a <memcpy+0x6>
    3f14:	08 95       	ret

00003f16 <memset>:
    3f16:	dc 01       	movw	r26, r24
    3f18:	01 c0       	rjmp	.+2      	; 0x3f1c <memset+0x6>
    3f1a:	6d 93       	st	X+, r22
    3f1c:	41 50       	subi	r20, 0x01	; 1
    3f1e:	50 40       	sbci	r21, 0x00	; 0
    3f20:	e0 f7       	brcc	.-8      	; 0x3f1a <memset+0x4>
    3f22:	08 95       	ret

00003f24 <strncpy>:
    3f24:	fb 01       	movw	r30, r22
    3f26:	dc 01       	movw	r26, r24
    3f28:	41 50       	subi	r20, 0x01	; 1
    3f2a:	50 40       	sbci	r21, 0x00	; 0
    3f2c:	48 f0       	brcs	.+18     	; 0x3f40 <strncpy+0x1c>
    3f2e:	01 90       	ld	r0, Z+
    3f30:	0d 92       	st	X+, r0
    3f32:	00 20       	and	r0, r0
    3f34:	c9 f7       	brne	.-14     	; 0x3f28 <strncpy+0x4>
    3f36:	01 c0       	rjmp	.+2      	; 0x3f3a <strncpy+0x16>
    3f38:	1d 92       	st	X+, r1
    3f3a:	41 50       	subi	r20, 0x01	; 1
    3f3c:	50 40       	sbci	r21, 0x00	; 0
    3f3e:	e0 f7       	brcc	.-8      	; 0x3f38 <strncpy+0x14>
    3f40:	08 95       	ret

00003f42 <__itoa_ncheck>:
    3f42:	bb 27       	eor	r27, r27
    3f44:	4a 30       	cpi	r20, 0x0A	; 10
    3f46:	31 f4       	brne	.+12     	; 0x3f54 <__itoa_ncheck+0x12>
    3f48:	99 23       	and	r25, r25
    3f4a:	22 f4       	brpl	.+8      	; 0x3f54 <__itoa_ncheck+0x12>
    3f4c:	bd e2       	ldi	r27, 0x2D	; 45
    3f4e:	90 95       	com	r25
    3f50:	81 95       	neg	r24
    3f52:	9f 4f       	sbci	r25, 0xFF	; 255
    3f54:	0c 94 e5 1f 	jmp	0x3fca	; 0x3fca <__utoa_common>

00003f58 <ultoa>:
    3f58:	25 32       	cpi	r18, 0x25	; 37
    3f5a:	31 05       	cpc	r19, r1
    3f5c:	20 f4       	brcc	.+8      	; 0x3f66 <ultoa+0xe>
    3f5e:	22 30       	cpi	r18, 0x02	; 2
    3f60:	10 f0       	brcs	.+4      	; 0x3f66 <ultoa+0xe>
    3f62:	0c 94 b7 1f 	jmp	0x3f6e	; 0x3f6e <__ultoa_ncheck>
    3f66:	fa 01       	movw	r30, r20
    3f68:	10 82       	st	Z, r1
    3f6a:	ca 01       	movw	r24, r20
    3f6c:	08 95       	ret

00003f6e <__ultoa_ncheck>:
    3f6e:	bb 27       	eor	r27, r27

00003f70 <__ultoa_common>:
    3f70:	fa 01       	movw	r30, r20
    3f72:	a6 2f       	mov	r26, r22
    3f74:	62 17       	cp	r22, r18
    3f76:	71 05       	cpc	r23, r1
    3f78:	81 05       	cpc	r24, r1
    3f7a:	91 05       	cpc	r25, r1
    3f7c:	33 0b       	sbc	r19, r19
    3f7e:	30 fb       	bst	r19, 0
    3f80:	66 f0       	brts	.+24     	; 0x3f9a <__ultoa_common+0x2a>
    3f82:	aa 27       	eor	r26, r26
    3f84:	66 0f       	add	r22, r22
    3f86:	77 1f       	adc	r23, r23
    3f88:	88 1f       	adc	r24, r24
    3f8a:	99 1f       	adc	r25, r25
    3f8c:	aa 1f       	adc	r26, r26
    3f8e:	a2 17       	cp	r26, r18
    3f90:	10 f0       	brcs	.+4      	; 0x3f96 <__ultoa_common+0x26>
    3f92:	a2 1b       	sub	r26, r18
    3f94:	63 95       	inc	r22
    3f96:	38 50       	subi	r19, 0x08	; 8
    3f98:	a9 f7       	brne	.-22     	; 0x3f84 <__ultoa_common+0x14>
    3f9a:	a0 5d       	subi	r26, 0xD0	; 208
    3f9c:	aa 33       	cpi	r26, 0x3A	; 58
    3f9e:	08 f0       	brcs	.+2      	; 0x3fa2 <__ultoa_common+0x32>
    3fa0:	a9 5d       	subi	r26, 0xD9	; 217
    3fa2:	a1 93       	st	Z+, r26
    3fa4:	36 f7       	brtc	.-52     	; 0x3f72 <__ultoa_common+0x2>
    3fa6:	b1 11       	cpse	r27, r1
    3fa8:	b1 93       	st	Z+, r27
    3faa:	10 82       	st	Z, r1
    3fac:	ca 01       	movw	r24, r20
    3fae:	0c 94 fe 1f 	jmp	0x3ffc	; 0x3ffc <strrev>

00003fb2 <utoa>:
    3fb2:	45 32       	cpi	r20, 0x25	; 37
    3fb4:	51 05       	cpc	r21, r1
    3fb6:	20 f4       	brcc	.+8      	; 0x3fc0 <utoa+0xe>
    3fb8:	42 30       	cpi	r20, 0x02	; 2
    3fba:	10 f0       	brcs	.+4      	; 0x3fc0 <utoa+0xe>
    3fbc:	0c 94 e4 1f 	jmp	0x3fc8	; 0x3fc8 <__utoa_ncheck>
    3fc0:	fb 01       	movw	r30, r22
    3fc2:	10 82       	st	Z, r1
    3fc4:	cb 01       	movw	r24, r22
    3fc6:	08 95       	ret

00003fc8 <__utoa_ncheck>:
    3fc8:	bb 27       	eor	r27, r27

00003fca <__utoa_common>:
    3fca:	fb 01       	movw	r30, r22
    3fcc:	55 27       	eor	r21, r21
    3fce:	aa 27       	eor	r26, r26
    3fd0:	88 0f       	add	r24, r24
    3fd2:	99 1f       	adc	r25, r25
    3fd4:	aa 1f       	adc	r26, r26
    3fd6:	a4 17       	cp	r26, r20
    3fd8:	10 f0       	brcs	.+4      	; 0x3fde <__utoa_common+0x14>
    3fda:	a4 1b       	sub	r26, r20
    3fdc:	83 95       	inc	r24
    3fde:	50 51       	subi	r21, 0x10	; 16
    3fe0:	b9 f7       	brne	.-18     	; 0x3fd0 <__utoa_common+0x6>
    3fe2:	a0 5d       	subi	r26, 0xD0	; 208
    3fe4:	aa 33       	cpi	r26, 0x3A	; 58
    3fe6:	08 f0       	brcs	.+2      	; 0x3fea <__utoa_common+0x20>
    3fe8:	a9 5d       	subi	r26, 0xD9	; 217
    3fea:	a1 93       	st	Z+, r26
    3fec:	00 97       	sbiw	r24, 0x00	; 0
    3fee:	79 f7       	brne	.-34     	; 0x3fce <__utoa_common+0x4>
    3ff0:	b1 11       	cpse	r27, r1
    3ff2:	b1 93       	st	Z+, r27
    3ff4:	11 92       	st	Z+, r1
    3ff6:	cb 01       	movw	r24, r22
    3ff8:	0c 94 fe 1f 	jmp	0x3ffc	; 0x3ffc <strrev>

00003ffc <strrev>:
    3ffc:	dc 01       	movw	r26, r24
    3ffe:	fc 01       	movw	r30, r24
    4000:	67 2f       	mov	r22, r23
    4002:	71 91       	ld	r23, Z+
    4004:	77 23       	and	r23, r23
    4006:	e1 f7       	brne	.-8      	; 0x4000 <__stack+0x1>
    4008:	32 97       	sbiw	r30, 0x02	; 2
    400a:	04 c0       	rjmp	.+8      	; 0x4014 <__stack+0x15>
    400c:	7c 91       	ld	r23, X
    400e:	6d 93       	st	X+, r22
    4010:	70 83       	st	Z, r23
    4012:	62 91       	ld	r22, -Z
    4014:	ae 17       	cp	r26, r30
    4016:	bf 07       	cpc	r27, r31
    4018:	c8 f3       	brcs	.-14     	; 0x400c <__stack+0xd>
    401a:	08 95       	ret

0000401c <_exit>:
    401c:	f8 94       	cli

0000401e <__stop_program>:
    401e:	ff cf       	rjmp	.-2      	; 0x401e <__stop_program>
=======
    3e7e:	1f 91       	pop	r17
    3e80:	0f 91       	pop	r16
    3e82:	08 95       	ret

00003e84 <__cmpsf2>:
    3e84:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <__fp_cmp>
    3e88:	08 f4       	brcc	.+2      	; 0x3e8c <__cmpsf2+0x8>
    3e8a:	81 e0       	ldi	r24, 0x01	; 1
    3e8c:	08 95       	ret

00003e8e <__floatunsisf>:
    3e8e:	e8 94       	clt
    3e90:	09 c0       	rjmp	.+18     	; 0x3ea4 <__floatsisf+0x12>

00003e92 <__floatsisf>:
    3e92:	97 fb       	bst	r25, 7
    3e94:	3e f4       	brtc	.+14     	; 0x3ea4 <__floatsisf+0x12>
    3e96:	90 95       	com	r25
    3e98:	80 95       	com	r24
    3e9a:	70 95       	com	r23
    3e9c:	61 95       	neg	r22
    3e9e:	7f 4f       	sbci	r23, 0xFF	; 255
    3ea0:	8f 4f       	sbci	r24, 0xFF	; 255
    3ea2:	9f 4f       	sbci	r25, 0xFF	; 255
    3ea4:	99 23       	and	r25, r25
    3ea6:	a9 f0       	breq	.+42     	; 0x3ed2 <__floatsisf+0x40>
    3ea8:	f9 2f       	mov	r31, r25
    3eaa:	96 e9       	ldi	r25, 0x96	; 150
    3eac:	bb 27       	eor	r27, r27
    3eae:	93 95       	inc	r25
    3eb0:	f6 95       	lsr	r31
    3eb2:	87 95       	ror	r24
    3eb4:	77 95       	ror	r23
    3eb6:	67 95       	ror	r22
    3eb8:	b7 95       	ror	r27
    3eba:	f1 11       	cpse	r31, r1
    3ebc:	f8 cf       	rjmp	.-16     	; 0x3eae <__floatsisf+0x1c>
    3ebe:	fa f4       	brpl	.+62     	; 0x3efe <__floatsisf+0x6c>
    3ec0:	bb 0f       	add	r27, r27
    3ec2:	11 f4       	brne	.+4      	; 0x3ec8 <__floatsisf+0x36>
    3ec4:	60 ff       	sbrs	r22, 0
    3ec6:	1b c0       	rjmp	.+54     	; 0x3efe <__floatsisf+0x6c>
    3ec8:	6f 5f       	subi	r22, 0xFF	; 255
    3eca:	7f 4f       	sbci	r23, 0xFF	; 255
    3ecc:	8f 4f       	sbci	r24, 0xFF	; 255
    3ece:	9f 4f       	sbci	r25, 0xFF	; 255
    3ed0:	16 c0       	rjmp	.+44     	; 0x3efe <__floatsisf+0x6c>
    3ed2:	88 23       	and	r24, r24
    3ed4:	11 f0       	breq	.+4      	; 0x3eda <__floatsisf+0x48>
    3ed6:	96 e9       	ldi	r25, 0x96	; 150
    3ed8:	11 c0       	rjmp	.+34     	; 0x3efc <__floatsisf+0x6a>
    3eda:	77 23       	and	r23, r23
    3edc:	21 f0       	breq	.+8      	; 0x3ee6 <__floatsisf+0x54>
    3ede:	9e e8       	ldi	r25, 0x8E	; 142
    3ee0:	87 2f       	mov	r24, r23
    3ee2:	76 2f       	mov	r23, r22
    3ee4:	05 c0       	rjmp	.+10     	; 0x3ef0 <__floatsisf+0x5e>
    3ee6:	66 23       	and	r22, r22
    3ee8:	71 f0       	breq	.+28     	; 0x3f06 <__floatsisf+0x74>
    3eea:	96 e8       	ldi	r25, 0x86	; 134
    3eec:	86 2f       	mov	r24, r22
    3eee:	70 e0       	ldi	r23, 0x00	; 0
    3ef0:	60 e0       	ldi	r22, 0x00	; 0
    3ef2:	2a f0       	brmi	.+10     	; 0x3efe <__floatsisf+0x6c>
    3ef4:	9a 95       	dec	r25
    3ef6:	66 0f       	add	r22, r22
    3ef8:	77 1f       	adc	r23, r23
    3efa:	88 1f       	adc	r24, r24
    3efc:	da f7       	brpl	.-10     	; 0x3ef4 <__floatsisf+0x62>
    3efe:	88 0f       	add	r24, r24
    3f00:	96 95       	lsr	r25
    3f02:	87 95       	ror	r24
    3f04:	97 f9       	bld	r25, 7
    3f06:	08 95       	ret

00003f08 <__fp_cmp>:
    3f08:	99 0f       	add	r25, r25
    3f0a:	00 08       	sbc	r0, r0
    3f0c:	55 0f       	add	r21, r21
    3f0e:	aa 0b       	sbc	r26, r26
    3f10:	e0 e8       	ldi	r30, 0x80	; 128
    3f12:	fe ef       	ldi	r31, 0xFE	; 254
    3f14:	16 16       	cp	r1, r22
    3f16:	17 06       	cpc	r1, r23
    3f18:	e8 07       	cpc	r30, r24
    3f1a:	f9 07       	cpc	r31, r25
    3f1c:	c0 f0       	brcs	.+48     	; 0x3f4e <__fp_cmp+0x46>
    3f1e:	12 16       	cp	r1, r18
    3f20:	13 06       	cpc	r1, r19
    3f22:	e4 07       	cpc	r30, r20
    3f24:	f5 07       	cpc	r31, r21
    3f26:	98 f0       	brcs	.+38     	; 0x3f4e <__fp_cmp+0x46>
    3f28:	62 1b       	sub	r22, r18
    3f2a:	73 0b       	sbc	r23, r19
    3f2c:	84 0b       	sbc	r24, r20
    3f2e:	95 0b       	sbc	r25, r21
    3f30:	39 f4       	brne	.+14     	; 0x3f40 <__fp_cmp+0x38>
    3f32:	0a 26       	eor	r0, r26
    3f34:	61 f0       	breq	.+24     	; 0x3f4e <__fp_cmp+0x46>
    3f36:	23 2b       	or	r18, r19
    3f38:	24 2b       	or	r18, r20
    3f3a:	25 2b       	or	r18, r21
    3f3c:	21 f4       	brne	.+8      	; 0x3f46 <__fp_cmp+0x3e>
    3f3e:	08 95       	ret
    3f40:	0a 26       	eor	r0, r26
    3f42:	09 f4       	brne	.+2      	; 0x3f46 <__fp_cmp+0x3e>
    3f44:	a1 40       	sbci	r26, 0x01	; 1
    3f46:	a6 95       	lsr	r26
    3f48:	8f ef       	ldi	r24, 0xFF	; 255
    3f4a:	81 1d       	adc	r24, r1
    3f4c:	81 1d       	adc	r24, r1
    3f4e:	08 95       	ret

00003f50 <__gesf2>:
    3f50:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <__fp_cmp>
    3f54:	08 f4       	brcc	.+2      	; 0x3f58 <__gesf2+0x8>
    3f56:	8f ef       	ldi	r24, 0xFF	; 255
    3f58:	08 95       	ret

00003f5a <__mulsi3>:
    3f5a:	db 01       	movw	r26, r22
    3f5c:	8f 93       	push	r24
    3f5e:	9f 93       	push	r25
    3f60:	0e 94 39 20 	call	0x4072	; 0x4072 <__muluhisi3>
    3f64:	bf 91       	pop	r27
    3f66:	af 91       	pop	r26
    3f68:	a2 9f       	mul	r26, r18
    3f6a:	80 0d       	add	r24, r0
    3f6c:	91 1d       	adc	r25, r1
    3f6e:	a3 9f       	mul	r26, r19
    3f70:	90 0d       	add	r25, r0
    3f72:	b2 9f       	mul	r27, r18
    3f74:	90 0d       	add	r25, r0
    3f76:	11 24       	eor	r1, r1
    3f78:	08 95       	ret

00003f7a <__divmodhi4>:
    3f7a:	97 fb       	bst	r25, 7
    3f7c:	07 2e       	mov	r0, r23
    3f7e:	16 f4       	brtc	.+4      	; 0x3f84 <__divmodhi4+0xa>
    3f80:	00 94       	com	r0
    3f82:	07 d0       	rcall	.+14     	; 0x3f92 <__divmodhi4_neg1>
    3f84:	77 fd       	sbrc	r23, 7
    3f86:	09 d0       	rcall	.+18     	; 0x3f9a <__divmodhi4_neg2>
    3f88:	0e 94 4c 20 	call	0x4098	; 0x4098 <__udivmodhi4>
    3f8c:	07 fc       	sbrc	r0, 7
    3f8e:	05 d0       	rcall	.+10     	; 0x3f9a <__divmodhi4_neg2>
    3f90:	3e f4       	brtc	.+14     	; 0x3fa0 <__divmodhi4_exit>

00003f92 <__divmodhi4_neg1>:
    3f92:	90 95       	com	r25
    3f94:	81 95       	neg	r24
    3f96:	9f 4f       	sbci	r25, 0xFF	; 255
    3f98:	08 95       	ret

00003f9a <__divmodhi4_neg2>:
    3f9a:	70 95       	com	r23
    3f9c:	61 95       	neg	r22
    3f9e:	7f 4f       	sbci	r23, 0xFF	; 255

00003fa0 <__divmodhi4_exit>:
    3fa0:	08 95       	ret

00003fa2 <__udivmodsi4>:
    3fa2:	a1 e2       	ldi	r26, 0x21	; 33
    3fa4:	1a 2e       	mov	r1, r26
    3fa6:	aa 1b       	sub	r26, r26
    3fa8:	bb 1b       	sub	r27, r27
    3faa:	fd 01       	movw	r30, r26
    3fac:	0d c0       	rjmp	.+26     	; 0x3fc8 <__udivmodsi4_ep>

00003fae <__udivmodsi4_loop>:
    3fae:	aa 1f       	adc	r26, r26
    3fb0:	bb 1f       	adc	r27, r27
    3fb2:	ee 1f       	adc	r30, r30
    3fb4:	ff 1f       	adc	r31, r31
    3fb6:	a2 17       	cp	r26, r18
    3fb8:	b3 07       	cpc	r27, r19
    3fba:	e4 07       	cpc	r30, r20
    3fbc:	f5 07       	cpc	r31, r21
    3fbe:	20 f0       	brcs	.+8      	; 0x3fc8 <__udivmodsi4_ep>
    3fc0:	a2 1b       	sub	r26, r18
    3fc2:	b3 0b       	sbc	r27, r19
    3fc4:	e4 0b       	sbc	r30, r20
    3fc6:	f5 0b       	sbc	r31, r21

00003fc8 <__udivmodsi4_ep>:
    3fc8:	66 1f       	adc	r22, r22
    3fca:	77 1f       	adc	r23, r23
    3fcc:	88 1f       	adc	r24, r24
    3fce:	99 1f       	adc	r25, r25
    3fd0:	1a 94       	dec	r1
    3fd2:	69 f7       	brne	.-38     	; 0x3fae <__udivmodsi4_loop>
    3fd4:	60 95       	com	r22
    3fd6:	70 95       	com	r23
    3fd8:	80 95       	com	r24
    3fda:	90 95       	com	r25
    3fdc:	9b 01       	movw	r18, r22
    3fde:	ac 01       	movw	r20, r24
    3fe0:	bd 01       	movw	r22, r26
    3fe2:	cf 01       	movw	r24, r30
    3fe4:	08 95       	ret

00003fe6 <__divmodsi4>:
    3fe6:	05 2e       	mov	r0, r21
    3fe8:	97 fb       	bst	r25, 7
    3fea:	1e f4       	brtc	.+6      	; 0x3ff2 <__divmodsi4+0xc>
    3fec:	00 94       	com	r0
    3fee:	0e 94 0a 20 	call	0x4014	; 0x4014 <__negsi2>
    3ff2:	57 fd       	sbrc	r21, 7
    3ff4:	07 d0       	rcall	.+14     	; 0x4004 <__divmodsi4_neg2>
    3ff6:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <__udivmodsi4>
    3ffa:	07 fc       	sbrc	r0, 7
    3ffc:	03 d0       	rcall	.+6      	; 0x4004 <__divmodsi4_neg2>
    3ffe:	4e f4       	brtc	.+18     	; 0x4012 <__divmodsi4_exit>
    4000:	0c 94 0a 20 	jmp	0x4014	; 0x4014 <__negsi2>

00004004 <__divmodsi4_neg2>:
    4004:	50 95       	com	r21
    4006:	40 95       	com	r20
    4008:	30 95       	com	r19
    400a:	21 95       	neg	r18
    400c:	3f 4f       	sbci	r19, 0xFF	; 255
    400e:	4f 4f       	sbci	r20, 0xFF	; 255
    4010:	5f 4f       	sbci	r21, 0xFF	; 255

00004012 <__divmodsi4_exit>:
    4012:	08 95       	ret

00004014 <__negsi2>:
    4014:	90 95       	com	r25
    4016:	80 95       	com	r24
    4018:	70 95       	com	r23
    401a:	61 95       	neg	r22
    401c:	7f 4f       	sbci	r23, 0xFF	; 255
    401e:	8f 4f       	sbci	r24, 0xFF	; 255
    4020:	9f 4f       	sbci	r25, 0xFF	; 255
    4022:	08 95       	ret

00004024 <__tablejump2__>:
    4024:	ee 0f       	add	r30, r30
    4026:	ff 1f       	adc	r31, r31
    4028:	88 1f       	adc	r24, r24
    402a:	8b bf       	out	0x3b, r24	; 59
    402c:	07 90       	elpm	r0, Z+
    402e:	f6 91       	elpm	r31, Z
    4030:	e0 2d       	mov	r30, r0
    4032:	1b be       	out	0x3b, r1	; 59
    4034:	19 94       	eijmp

00004036 <__mulhisi3>:
    4036:	0e 94 23 20 	call	0x4046	; 0x4046 <__umulhisi3>
    403a:	33 23       	and	r19, r19
    403c:	12 f4       	brpl	.+4      	; 0x4042 <__mulhisi3+0xc>
    403e:	8a 1b       	sub	r24, r26
    4040:	9b 0b       	sbc	r25, r27
    4042:	0c 94 34 20 	jmp	0x4068	; 0x4068 <__usmulhisi3_tail>

00004046 <__umulhisi3>:
    4046:	a2 9f       	mul	r26, r18
    4048:	b0 01       	movw	r22, r0
    404a:	b3 9f       	mul	r27, r19
    404c:	c0 01       	movw	r24, r0
    404e:	a3 9f       	mul	r26, r19
    4050:	70 0d       	add	r23, r0
    4052:	81 1d       	adc	r24, r1
    4054:	11 24       	eor	r1, r1
    4056:	91 1d       	adc	r25, r1
    4058:	b2 9f       	mul	r27, r18
    405a:	70 0d       	add	r23, r0
    405c:	81 1d       	adc	r24, r1
    405e:	11 24       	eor	r1, r1
    4060:	91 1d       	adc	r25, r1
    4062:	08 95       	ret

00004064 <__usmulhisi3>:
    4064:	0e 94 23 20 	call	0x4046	; 0x4046 <__umulhisi3>

00004068 <__usmulhisi3_tail>:
    4068:	b7 ff       	sbrs	r27, 7
    406a:	08 95       	ret
    406c:	82 1b       	sub	r24, r18
    406e:	93 0b       	sbc	r25, r19
    4070:	08 95       	ret

00004072 <__muluhisi3>:
    4072:	0e 94 23 20 	call	0x4046	; 0x4046 <__umulhisi3>
    4076:	a5 9f       	mul	r26, r21
    4078:	90 0d       	add	r25, r0
    407a:	b4 9f       	mul	r27, r20
    407c:	90 0d       	add	r25, r0
    407e:	a4 9f       	mul	r26, r20
    4080:	80 0d       	add	r24, r0
    4082:	91 1d       	adc	r25, r1
    4084:	11 24       	eor	r1, r1
    4086:	08 95       	ret

00004088 <__mulshisi3>:
    4088:	b7 ff       	sbrs	r27, 7
    408a:	0c 94 39 20 	jmp	0x4072	; 0x4072 <__muluhisi3>

0000408e <__mulohisi3>:
    408e:	0e 94 39 20 	call	0x4072	; 0x4072 <__muluhisi3>
    4092:	82 1b       	sub	r24, r18
    4094:	93 0b       	sbc	r25, r19
    4096:	08 95       	ret

00004098 <__udivmodhi4>:
    4098:	aa 1b       	sub	r26, r26
    409a:	bb 1b       	sub	r27, r27
    409c:	51 e1       	ldi	r21, 0x11	; 17
    409e:	07 c0       	rjmp	.+14     	; 0x40ae <__udivmodhi4_ep>

000040a0 <__udivmodhi4_loop>:
    40a0:	aa 1f       	adc	r26, r26
    40a2:	bb 1f       	adc	r27, r27
    40a4:	a6 17       	cp	r26, r22
    40a6:	b7 07       	cpc	r27, r23
    40a8:	10 f0       	brcs	.+4      	; 0x40ae <__udivmodhi4_ep>
    40aa:	a6 1b       	sub	r26, r22
    40ac:	b7 0b       	sbc	r27, r23

000040ae <__udivmodhi4_ep>:
    40ae:	88 1f       	adc	r24, r24
    40b0:	99 1f       	adc	r25, r25
    40b2:	5a 95       	dec	r21
    40b4:	a9 f7       	brne	.-22     	; 0x40a0 <__udivmodhi4_loop>
    40b6:	80 95       	com	r24
    40b8:	90 95       	com	r25
    40ba:	bc 01       	movw	r22, r24
    40bc:	cd 01       	movw	r24, r26
    40be:	08 95       	ret

000040c0 <memcpy>:
    40c0:	fb 01       	movw	r30, r22
    40c2:	dc 01       	movw	r26, r24
    40c4:	02 c0       	rjmp	.+4      	; 0x40ca <memcpy+0xa>
    40c6:	01 90       	ld	r0, Z+
    40c8:	0d 92       	st	X+, r0
    40ca:	41 50       	subi	r20, 0x01	; 1
    40cc:	50 40       	sbci	r21, 0x00	; 0
    40ce:	d8 f7       	brcc	.-10     	; 0x40c6 <memcpy+0x6>
    40d0:	08 95       	ret

000040d2 <memset>:
    40d2:	dc 01       	movw	r26, r24
    40d4:	01 c0       	rjmp	.+2      	; 0x40d8 <memset+0x6>
    40d6:	6d 93       	st	X+, r22
    40d8:	41 50       	subi	r20, 0x01	; 1
    40da:	50 40       	sbci	r21, 0x00	; 0
    40dc:	e0 f7       	brcc	.-8      	; 0x40d6 <memset+0x4>
    40de:	08 95       	ret

000040e0 <strncpy>:
    40e0:	fb 01       	movw	r30, r22
    40e2:	dc 01       	movw	r26, r24
    40e4:	41 50       	subi	r20, 0x01	; 1
    40e6:	50 40       	sbci	r21, 0x00	; 0
    40e8:	48 f0       	brcs	.+18     	; 0x40fc <strncpy+0x1c>
    40ea:	01 90       	ld	r0, Z+
    40ec:	0d 92       	st	X+, r0
    40ee:	00 20       	and	r0, r0
    40f0:	c9 f7       	brne	.-14     	; 0x40e4 <strncpy+0x4>
    40f2:	01 c0       	rjmp	.+2      	; 0x40f6 <strncpy+0x16>
    40f4:	1d 92       	st	X+, r1
    40f6:	41 50       	subi	r20, 0x01	; 1
    40f8:	50 40       	sbci	r21, 0x00	; 0
    40fa:	e0 f7       	brcc	.-8      	; 0x40f4 <strncpy+0x14>
    40fc:	08 95       	ret

000040fe <__itoa_ncheck>:
    40fe:	bb 27       	eor	r27, r27
    4100:	4a 30       	cpi	r20, 0x0A	; 10
    4102:	31 f4       	brne	.+12     	; 0x4110 <__itoa_ncheck+0x12>
    4104:	99 23       	and	r25, r25
    4106:	22 f4       	brpl	.+8      	; 0x4110 <__itoa_ncheck+0x12>
    4108:	bd e2       	ldi	r27, 0x2D	; 45
    410a:	90 95       	com	r25
    410c:	81 95       	neg	r24
    410e:	9f 4f       	sbci	r25, 0xFF	; 255
    4110:	0c 94 d2 20 	jmp	0x41a4	; 0x41a4 <__utoa_common>

00004114 <__ltoa_ncheck>:
    4114:	bb 27       	eor	r27, r27
    4116:	2a 30       	cpi	r18, 0x0A	; 10
    4118:	51 f4       	brne	.+20     	; 0x412e <__ltoa_ncheck+0x1a>
    411a:	99 23       	and	r25, r25
    411c:	42 f4       	brpl	.+16     	; 0x412e <__ltoa_ncheck+0x1a>
    411e:	bd e2       	ldi	r27, 0x2D	; 45
    4120:	90 95       	com	r25
    4122:	80 95       	com	r24
    4124:	70 95       	com	r23
    4126:	61 95       	neg	r22
    4128:	7f 4f       	sbci	r23, 0xFF	; 255
    412a:	8f 4f       	sbci	r24, 0xFF	; 255
    412c:	9f 4f       	sbci	r25, 0xFF	; 255
    412e:	0c 94 a5 20 	jmp	0x414a	; 0x414a <__ultoa_common>

00004132 <ultoa>:
    4132:	25 32       	cpi	r18, 0x25	; 37
    4134:	31 05       	cpc	r19, r1
    4136:	20 f4       	brcc	.+8      	; 0x4140 <ultoa+0xe>
    4138:	22 30       	cpi	r18, 0x02	; 2
    413a:	10 f0       	brcs	.+4      	; 0x4140 <ultoa+0xe>
    413c:	0c 94 a4 20 	jmp	0x4148	; 0x4148 <__ultoa_ncheck>
    4140:	fa 01       	movw	r30, r20
    4142:	10 82       	st	Z, r1
    4144:	ca 01       	movw	r24, r20
    4146:	08 95       	ret

00004148 <__ultoa_ncheck>:
    4148:	bb 27       	eor	r27, r27

0000414a <__ultoa_common>:
    414a:	fa 01       	movw	r30, r20
    414c:	a6 2f       	mov	r26, r22
    414e:	62 17       	cp	r22, r18
    4150:	71 05       	cpc	r23, r1
    4152:	81 05       	cpc	r24, r1
    4154:	91 05       	cpc	r25, r1
    4156:	33 0b       	sbc	r19, r19
    4158:	30 fb       	bst	r19, 0
    415a:	66 f0       	brts	.+24     	; 0x4174 <__ultoa_common+0x2a>
    415c:	aa 27       	eor	r26, r26
    415e:	66 0f       	add	r22, r22
    4160:	77 1f       	adc	r23, r23
    4162:	88 1f       	adc	r24, r24
    4164:	99 1f       	adc	r25, r25
    4166:	aa 1f       	adc	r26, r26
    4168:	a2 17       	cp	r26, r18
    416a:	10 f0       	brcs	.+4      	; 0x4170 <__ultoa_common+0x26>
    416c:	a2 1b       	sub	r26, r18
    416e:	63 95       	inc	r22
    4170:	38 50       	subi	r19, 0x08	; 8
    4172:	a9 f7       	brne	.-22     	; 0x415e <__ultoa_common+0x14>
    4174:	a0 5d       	subi	r26, 0xD0	; 208
    4176:	aa 33       	cpi	r26, 0x3A	; 58
    4178:	08 f0       	brcs	.+2      	; 0x417c <__ultoa_common+0x32>
    417a:	a9 5d       	subi	r26, 0xD9	; 217
    417c:	a1 93       	st	Z+, r26
    417e:	36 f7       	brtc	.-52     	; 0x414c <__ultoa_common+0x2>
    4180:	b1 11       	cpse	r27, r1
    4182:	b1 93       	st	Z+, r27
    4184:	10 82       	st	Z, r1
    4186:	ca 01       	movw	r24, r20
    4188:	0c 94 eb 20 	jmp	0x41d6	; 0x41d6 <strrev>

0000418c <utoa>:
    418c:	45 32       	cpi	r20, 0x25	; 37
    418e:	51 05       	cpc	r21, r1
    4190:	20 f4       	brcc	.+8      	; 0x419a <utoa+0xe>
    4192:	42 30       	cpi	r20, 0x02	; 2
    4194:	10 f0       	brcs	.+4      	; 0x419a <utoa+0xe>
    4196:	0c 94 d1 20 	jmp	0x41a2	; 0x41a2 <__utoa_ncheck>
    419a:	fb 01       	movw	r30, r22
    419c:	10 82       	st	Z, r1
    419e:	cb 01       	movw	r24, r22
    41a0:	08 95       	ret

000041a2 <__utoa_ncheck>:
    41a2:	bb 27       	eor	r27, r27

000041a4 <__utoa_common>:
    41a4:	fb 01       	movw	r30, r22
    41a6:	55 27       	eor	r21, r21
    41a8:	aa 27       	eor	r26, r26
    41aa:	88 0f       	add	r24, r24
    41ac:	99 1f       	adc	r25, r25
    41ae:	aa 1f       	adc	r26, r26
    41b0:	a4 17       	cp	r26, r20
    41b2:	10 f0       	brcs	.+4      	; 0x41b8 <__utoa_common+0x14>
    41b4:	a4 1b       	sub	r26, r20
    41b6:	83 95       	inc	r24
    41b8:	50 51       	subi	r21, 0x10	; 16
    41ba:	b9 f7       	brne	.-18     	; 0x41aa <__utoa_common+0x6>
    41bc:	a0 5d       	subi	r26, 0xD0	; 208
    41be:	aa 33       	cpi	r26, 0x3A	; 58
    41c0:	08 f0       	brcs	.+2      	; 0x41c4 <__utoa_common+0x20>
    41c2:	a9 5d       	subi	r26, 0xD9	; 217
    41c4:	a1 93       	st	Z+, r26
    41c6:	00 97       	sbiw	r24, 0x00	; 0
    41c8:	79 f7       	brne	.-34     	; 0x41a8 <__utoa_common+0x4>
    41ca:	b1 11       	cpse	r27, r1
    41cc:	b1 93       	st	Z+, r27
    41ce:	11 92       	st	Z+, r1
    41d0:	cb 01       	movw	r24, r22
    41d2:	0c 94 eb 20 	jmp	0x41d6	; 0x41d6 <strrev>

000041d6 <strrev>:
    41d6:	dc 01       	movw	r26, r24
    41d8:	fc 01       	movw	r30, r24
    41da:	67 2f       	mov	r22, r23
    41dc:	71 91       	ld	r23, Z+
    41de:	77 23       	and	r23, r23
    41e0:	e1 f7       	brne	.-8      	; 0x41da <strrev+0x4>
    41e2:	32 97       	sbiw	r30, 0x02	; 2
    41e4:	04 c0       	rjmp	.+8      	; 0x41ee <strrev+0x18>
    41e6:	7c 91       	ld	r23, X
    41e8:	6d 93       	st	X+, r22
    41ea:	70 83       	st	Z, r23
    41ec:	62 91       	ld	r22, -Z
    41ee:	ae 17       	cp	r26, r30
    41f0:	bf 07       	cpc	r27, r31
    41f2:	c8 f3       	brcs	.-14     	; 0x41e6 <strrev+0x10>
    41f4:	08 95       	ret

000041f6 <_exit>:
    41f6:	f8 94       	cli

000041f8 <__stop_program>:
    41f8:	ff cf       	rjmp	.-2      	; 0x41f8 <__stop_program>
>>>>>>> 7c2d071828dcb5e5e53b50a3fee482a78737eed9
