
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004132  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  00004132  000041c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020bc  008020bc  00004282  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004282  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000042b4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006e8  00000000  00000000  000042f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001235e  00000000  00000000  000049dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000667a  00000000  00000000  00016d3a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005470  00000000  00000000  0001d3b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012dc  00000000  00000000  00022824  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000061ef  00000000  00000000  00023b00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e42  00000000  00000000  00029cef  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000590  00000000  00000000  0002fb31  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a9 02 	jmp	0x552	; 0x552 <__ctors_end>
       4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      10:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      14:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      18:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      1c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      20:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      24:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      28:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      2c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      30:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      34:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      38:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      3c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      40:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      44:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      48:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      4c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      50:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      54:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      58:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      5c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      60:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      64:	0c 94 57 1c 	jmp	0x38ae	; 0x38ae <__vector_25>
      68:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      6c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      70:	0c 94 b5 1c 	jmp	0x396a	; 0x396a <__vector_28>
      74:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      78:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      7c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      80:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      84:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      88:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      8c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      90:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      94:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      98:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      9c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c4:	0c 94 48 0c 	jmp	0x1890	; 0x1890 <__vector_49>
      c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e8:	0c 94 cf 1d 	jmp	0x3b9e	; 0x3b9e <__vector_58>
      ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      fc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     100:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     104:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     108:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     10c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     110:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     114:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     118:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     11c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     120:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     124:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     128:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     12c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     130:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     134:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     138:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     13c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     140:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     144:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     148:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     14c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     150:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     154:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     158:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     15c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     160:	0c 94 13 1d 	jmp	0x3a26	; 0x3a26 <__vector_88>
     164:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     168:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     16c:	0c 94 71 1d 	jmp	0x3ae2	; 0x3ae2 <__vector_91>
     170:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     174:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     178:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     17c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     180:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     184:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     188:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     18c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     190:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     194:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     198:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     19c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1fc:	1a 1a       	sub	r1, r26
     1fe:	1d 1a       	sub	r1, r29
     200:	20 1a       	sub	r2, r16
     202:	23 1a       	sub	r2, r19
     204:	26 1a       	sub	r2, r22
     206:	29 1a       	sub	r2, r25
     208:	2b 1a       	sub	r2, r27
     20a:	3c 1a       	sub	r3, r28
     20c:	44 1a       	sub	r4, r20
     20e:	4e 1a       	sub	r4, r30
     210:	4c 1a       	sub	r4, r28

00000212 <__trampolines_start>:
     212:	0c 94 bb 1b 	jmp	0x3776	; 0x3776 <_ZN5rs23214check_for_charEv>
     216:	0c 94 dc 1e 	jmp	0x3db8	; 0x3db8 <_GLOBAL__sub_I_counter>
     21a:	0c 94 1a 1a 	jmp	0x3434	; 0x3434 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21e:	0c 94 45 17 	jmp	0x2e8a	; 0x2e8a <_ZN14frt_text_queue7getcharEv>
     222:	0c 94 c5 19 	jmp	0x338a	; 0x338a <_ZN8emstream12clear_screenEv>
     226:	0c 94 bf 19 	jmp	0x337e	; 0x337e <_ZN8emstream7getcharEv>
     22a:	0c 94 24 08 	jmp	0x1048	; 0x1048 <_ZN9task_user3runEv>
     22e:	0c 94 1d 1a 	jmp	0x343a	; 0x343a <_ZN8emstreamlsE15ser_manipulator+0x24>
     232:	0c 94 c2 19 	jmp	0x3384	; 0x3384 <_ZN8emstream14check_for_charEv>
     236:	0c 94 c4 19 	jmp	0x3388	; 0x3388 <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 4e 1a 	jmp	0x349c	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
     23e:	0c 94 26 1a 	jmp	0x344c	; 0x344c <_ZN8emstreamlsE15ser_manipulator+0x36>
     242:	0c 94 22 04 	jmp	0x844	; 0x844 <_ZN5Motor3runEv>
     246:	0c 94 6e 17 	jmp	0x2edc	; 0x2edc <_ZN14frt_text_queue7putcharEc>
     24a:	0c 94 cc 0e 	jmp	0x1d98	; 0x1d98 <prvIdleTask>
     24e:	0c 94 26 19 	jmp	0x324c	; 0x324c <__cxa_pure_virtual>
     252:	0c 94 bd 03 	jmp	0x77a	; 0x77a <_ZN13LimitSwitches3runEv>
     256:	0c 94 64 03 	jmp	0x6c8	; 0x6c8 <_ZN15EncoderPendulum3runEv>
     25a:	0c 94 a6 02 	jmp	0x54c	; 0x54c <_call_static_run_method>
     25e:	0c 94 63 17 	jmp	0x2ec6	; 0x2ec6 <_ZN14frt_text_queue14check_for_charEv>
     262:	0c 94 2b 1a 	jmp	0x3456	; 0x3456 <_ZN8emstreamlsE15ser_manipulator+0x40>
     266:	0c 94 bd 19 	jmp	0x337a	; 0x337a <_ZN8emstream13ready_to_sendEv>
     26a:	0c 94 4c 1a 	jmp	0x3498	; 0x3498 <_ZN8emstreamlsE15ser_manipulator+0x82>
     26e:	0c 94 44 1a 	jmp	0x3488	; 0x3488 <_ZN8emstreamlsE15ser_manipulator+0x72>
     272:	0c 94 fb 15 	jmp	0x2bf6	; 0x2bf6 <_ZN8frt_task12print_statusER8emstream>
     276:	0c 94 23 1a 	jmp	0x3446	; 0x3446 <_ZN8emstreamlsE15ser_manipulator+0x30>
     27a:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_ZN12EncoderMotor3runEv>
     27e:	0c 94 71 1b 	jmp	0x36e2	; 0x36e2 <_ZN5rs2327putcharEc>
     282:	0c 94 29 1a 	jmp	0x3452	; 0x3452 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     286:	0c 94 3c 1a 	jmp	0x3478	; 0x3478 <_ZN8emstreamlsE15ser_manipulator+0x62>
     28a:	0c 94 ce 1b 	jmp	0x379c	; 0x379c <_ZN5rs23212clear_screenEv>
     28e:	0c 94 3d 06 	jmp	0xc7a	; 0xc7a <_ZN9PWMdriver3runEv>
     292:	0c 94 20 1a 	jmp	0x3440	; 0x3440 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     296:	0c 94 95 1b 	jmp	0x372a	; 0x372a <_ZN5rs2327getcharEv>

0000029a <__trampolines_end>:
     29a:	2c 20       	and	r2, r12
     29c:	54 43       	sbci	r21, 0x34	; 52
     29e:	43 30       	cpi	r20, 0x03	; 3
     2a0:	43 43       	sbci	r20, 0x33	; 51
     2a2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a5 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a5:	2f 00                                               /.

000002a7 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b5:	54 69 6d 65 3a 20 00                                Time: .

000002bc <_ZZN9task_user11show_statusEvE3__c_0>:
     2bc:	44 65 63 20 20 35 20 32 30 31 37 00                 Dec  5 2017.

000002c8 <_ZZN9task_user11show_statusEvE3__c>:
     2c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     306:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000311 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     311:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     321:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34f:	6d 61 74 69 6f 6e 00                                mation.

00000356 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     356:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     366:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000377 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     377:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     387:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003ab <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3ab:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bb:	68 65 20 41 56 52 00                                he AVR.

000003c2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c2:	20 68 65 6c 70 00                                    help.

000003c8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e7 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e7:	1b 5b 33 30 6d 00                                   .[30m.

000003ed <_ZZN9task_user18print_help_messageEvE3__c>:
     3ed:	1b 5b 34 36 6d 00                                   .[46m.

000003f3 <_ZZN9task_user3runEvE3__c_3>:
     3f3:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     403:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000410 <_ZZN9task_user3runEvE3__c_2>:
     410:	3a 57 54 46 3f 00                                   :WTF?.

00000416 <_ZZN9task_user3runEvE3__c_1>:
     416:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     426:	65 00                                               e.

00000428 <_ZZN9task_user3runEvE3__c_0>:
     428:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000436 <_ZZN9task_user3runEvE3__c>:
     436:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     446:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000454 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     454:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045e <_ZZN8frt_task15emergency_resetEvE3__c>:
     45e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000046d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     46d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     47d:	61 73 6b 20 00                                      ask .

00000482 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     482:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000490 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     490:	20 63 72 65 61 74 65 64 00                           created.

00000499 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     499:	54 61 73 6b 20 00                                   Task .

0000049f <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49f:	1b 5b 32 32 6d 00                                   .[22m.

000004a5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a5:	54 61 73 6b 3a 20 00                                Task: .

000004ac <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4ac:	1b 5b 31 6d 00                                      .[1m.

000004b1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b1:	1b 5b 32 32 6d 00                                   .[22m.

000004b7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c2:	1b 5b 31 6d 00                                      .[1m.

000004c7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c7:	09 09 00                                            ...

000004ca <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ca:	2f 00                                               /.

000004cc <_ZZ15print_task_listP8emstreamE3__c_7>:
     4cc:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d7:	09 2d 2d 2d 2d 00                                   .----.

000004dd <_ZZ15print_task_listP8emstreamE3__c_5>:
     4dd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e9 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e9:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fa <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fa:	09 52 75 6e 73 00                                   .Runs.

00000500 <_ZZ15print_task_listP8emstreamE3__c_2>:
     500:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000050c <_ZZ15print_task_listP8emstreamE3__c_1>:
     50c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000051d <_ZZ15print_task_listP8emstreamE3__c_0>:
     51d:	09 53 74 61 63 6b 00                                .Stack.

00000524 <_ZZ15print_task_listP8emstreamE3__c>:
     524:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52f:	09 00                                               ..

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     533:	2f 00                                               /.

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     537:	09 00                                               ..

00000539 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53f:	1b 5b 31 6d 00                                      .[1m.

00000544 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     544:	1b 5b 31 6d 00                                      .[1m.

00000549 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     549:	20 20 00                                              .

0000054c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     54c:	0e 94 93 14 	call	0x2926	; 0x2926 <_ZN8frt_task22_call_users_run_methodEPS_>

00000550 <__ctors_start>:
     550:	dc 1e       	adc	r13, r28

00000552 <__ctors_end>:
     552:	11 24       	eor	r1, r1
     554:	1f be       	out	0x3f, r1	; 63
     556:	cf ef       	ldi	r28, 0xFF	; 255
     558:	cd bf       	out	0x3d, r28	; 61
     55a:	df e3       	ldi	r29, 0x3F	; 63
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	00 e0       	ldi	r16, 0x00	; 0
     560:	0c bf       	out	0x3c, r16	; 60
     562:	18 be       	out	0x38, r1	; 56
     564:	19 be       	out	0x39, r1	; 57
     566:	1a be       	out	0x3a, r1	; 58
     568:	1b be       	out	0x3b, r1	; 59

0000056a <__do_copy_data>:
     56a:	10 e2       	ldi	r17, 0x20	; 32
     56c:	a0 e0       	ldi	r26, 0x00	; 0
     56e:	b0 e2       	ldi	r27, 0x20	; 32
     570:	e2 e3       	ldi	r30, 0x32	; 50
     572:	f1 e4       	ldi	r31, 0x41	; 65
     574:	00 e0       	ldi	r16, 0x00	; 0
     576:	0b bf       	out	0x3b, r16	; 59
     578:	02 c0       	rjmp	.+4      	; 0x57e <__do_copy_data+0x14>
     57a:	07 90       	elpm	r0, Z+
     57c:	0d 92       	st	X+, r0
     57e:	ac 3b       	cpi	r26, 0xBC	; 188
     580:	b1 07       	cpc	r27, r17
     582:	d9 f7       	brne	.-10     	; 0x57a <__do_copy_data+0x10>
     584:	1b be       	out	0x3b, r1	; 59

00000586 <__do_clear_bss>:
     586:	21 e3       	ldi	r18, 0x31	; 49
     588:	ac eb       	ldi	r26, 0xBC	; 188
     58a:	b0 e2       	ldi	r27, 0x20	; 32
     58c:	01 c0       	rjmp	.+2      	; 0x590 <.do_clear_bss_start>

0000058e <.do_clear_bss_loop>:
     58e:	1d 92       	st	X+, r1

00000590 <.do_clear_bss_start>:
     590:	a2 36       	cpi	r26, 0x62	; 98
     592:	b2 07       	cpc	r27, r18
     594:	e1 f7       	brne	.-8      	; 0x58e <.do_clear_bss_loop>

00000596 <__do_global_ctors>:
     596:	12 e0       	ldi	r17, 0x02	; 2
     598:	c9 ea       	ldi	r28, 0xA9	; 169
     59a:	d2 e0       	ldi	r29, 0x02	; 2
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	06 c0       	rjmp	.+12     	; 0x5ac <__do_global_ctors+0x16>
     5a0:	21 97       	sbiw	r28, 0x01	; 1
     5a2:	01 09       	sbc	r16, r1
     5a4:	80 2f       	mov	r24, r16
     5a6:	fe 01       	movw	r30, r28
     5a8:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <__tablejump2__>
     5ac:	c8 3a       	cpi	r28, 0xA8	; 168
     5ae:	d1 07       	cpc	r29, r17
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	08 07       	cpc	r16, r24
     5b4:	a9 f7       	brne	.-22     	; 0x5a0 <__do_global_ctors+0xa>
     5b6:	0e 94 42 1e 	call	0x3c84	; 0x3c84 <main>
     5ba:	0c 94 97 20 	jmp	0x412e	; 0x412e <_exit>

000005be <__bad_interrupt>:
     5be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c2 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	00 d0       	rcall	.+0      	; 0x5c8 <_ZN12EncoderMotor3runEv+0x6>
     5c8:	1f 92       	push	r1
     5ca:	cd b7       	in	r28, 0x3d	; 61
     5cc:	de b7       	in	r29, 0x3e	; 62
     5ce:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d0:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <xTaskGetTickCount>
     5d4:	69 83       	std	Y+1, r22	; 0x01
     5d6:	7a 83       	std	Y+2, r23	; 0x02
     5d8:	8b 83       	std	Y+3, r24	; 0x03
     5da:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5dc:	e0 e8       	ldi	r30, 0x80	; 128
     5de:	f6 e0       	ldi	r31, 0x06	; 6
     5e0:	8c e0       	ldi	r24, 0x0C	; 12
     5e2:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e4:	82 89       	ldd	r24, Z+18	; 0x12
     5e6:	83 60       	ori	r24, 0x03	; 3
     5e8:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ea:	83 89       	ldd	r24, Z+19	; 0x13
     5ec:	83 60       	ori	r24, 0x03	; 3
     5ee:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5f0:	e0 e8       	ldi	r30, 0x80	; 128
     5f2:	f1 e0       	ldi	r31, 0x01	; 1
     5f4:	82 e7       	ldi	r24, 0x72	; 114
     5f6:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f8:	89 e0       	ldi	r24, 0x09	; 9
     5fa:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5fc:	e0 e0       	ldi	r30, 0x00	; 0
     5fe:	f9 e0       	ldi	r31, 0x09	; 9
     600:	88 e6       	ldi	r24, 0x68	; 104
     602:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     604:	8f ef       	ldi	r24, 0xFF	; 255
     606:	9f ef       	ldi	r25, 0xFF	; 255
     608:	86 a3       	std	Z+38, r24	; 0x26
     60a:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     60c:	81 e0       	ldi	r24, 0x01	; 1
     60e:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     610:	0f 2e       	mov	r0, r31
     612:	a1 2c       	mov	r10, r1
     614:	f9 e0       	ldi	r31, 0x09	; 9
     616:	bf 2e       	mov	r11, r31
     618:	f0 2d       	mov	r31, r0
     61a:	f5 01       	movw	r30, r10
     61c:	00 a1       	ldd	r16, Z+32	; 0x20
     61e:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     620:	0f b6       	in	r0, 0x3f	; 63
     622:	f8 94       	cli
     624:	0f 92       	push	r0
			the_data = new_data;
     626:	c8 01       	movw	r24, r16
     628:	01 2e       	mov	r0, r17
     62a:	00 0c       	add	r0, r0
     62c:	aa 0b       	sbc	r26, r26
     62e:	bb 0b       	sbc	r27, r27
     630:	ac 01       	movw	r20, r24
     632:	bd 01       	movw	r22, r26
     634:	44 0f       	add	r20, r20
     636:	55 1f       	adc	r21, r21
     638:	66 1f       	adc	r22, r22
     63a:	77 1f       	adc	r23, r23
     63c:	3a 01       	movw	r6, r20
     63e:	4b 01       	movw	r8, r22
     640:	68 0e       	add	r6, r24
     642:	79 1e       	adc	r7, r25
     644:	8a 1e       	adc	r8, r26
     646:	9b 1e       	adc	r9, r27
     648:	c4 01       	movw	r24, r8
     64a:	b3 01       	movw	r22, r6
     64c:	24 e6       	ldi	r18, 0x64	; 100
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	40 e0       	ldi	r20, 0x00	; 0
     652:	50 e0       	ldi	r21, 0x00	; 0
     654:	0e 94 9e 1f 	call	0x3f3c	; 0x3f3c <__divmodsi4>
     658:	20 93 4e 31 	sts	0x314E, r18	; 0x80314e <linear_position>
     65c:	30 93 4f 31 	sts	0x314F, r19	; 0x80314f <linear_position+0x1>
			portEXIT_CRITICAL ();
     660:	0f 90       	pop	r0
     662:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     664:	0f b6       	in	r0, 0x3f	; 63
     666:	f8 94       	cli
     668:	0f 92       	push	r0
			the_data = new_data;
     66a:	c8 01       	movw	r24, r16
     66c:	8c 19       	sub	r24, r12
     66e:	9d 09       	sbc	r25, r13
     670:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <thdMotor>
     674:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     678:	0f 90       	pop	r0
     67a:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     67c:	f7 01       	movw	r30, r14
     67e:	86 85       	ldd	r24, Z+14	; 0x0e
     680:	97 85       	ldd	r25, Z+15	; 0x0f
     682:	a0 89       	ldd	r26, Z+16	; 0x10
     684:	b1 89       	ldd	r27, Z+17	; 0x11
     686:	01 96       	adiw	r24, 0x01	; 1
     688:	a1 1d       	adc	r26, r1
     68a:	b1 1d       	adc	r27, r1
     68c:	86 87       	std	Z+14, r24	; 0x0e
     68e:	97 87       	std	Z+15, r25	; 0x0f
     690:	a0 8b       	std	Z+16, r26	; 0x10
     692:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     694:	41 e0       	ldi	r20, 0x01	; 1
     696:	50 e0       	ldi	r21, 0x00	; 0
     698:	60 e0       	ldi	r22, 0x00	; 0
     69a:	70 e0       	ldi	r23, 0x00	; 0
     69c:	ce 01       	movw	r24, r28
     69e:	01 96       	adiw	r24, 0x01	; 1
     6a0:	0e 94 09 12 	call	0x2412	; 0x2412 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6a4:	68 01       	movw	r12, r16
     6a6:	b9 cf       	rjmp	.-142    	; 0x61a <_ZN12EncoderMotor3runEv+0x58>

000006a8 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     6a8:	0f 93       	push	r16
     6aa:	1f 93       	push	r17
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
     6b0:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6b2:	0e 94 a6 14 	call	0x294c	; 0x294c <_ZN8frt_taskC1EPKchjP8emstream>
     6b6:	8a e0       	ldi	r24, 0x0A	; 10
     6b8:	90 e2       	ldi	r25, 0x20	; 32
     6ba:	88 83       	st	Y, r24
     6bc:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	1f 91       	pop	r17
     6c4:	0f 91       	pop	r16
     6c6:	08 95       	ret

000006c8 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	00 d0       	rcall	.+0      	; 0x6ce <_ZN15EncoderPendulum3runEv+0x6>
     6ce:	1f 92       	push	r1
     6d0:	cd b7       	in	r28, 0x3d	; 61
     6d2:	de b7       	in	r29, 0x3e	; 62
     6d4:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6d6:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <xTaskGetTickCount>
     6da:	69 83       	std	Y+1, r22	; 0x01
     6dc:	7a 83       	std	Y+2, r23	; 0x02
     6de:	8b 83       	std	Y+3, r24	; 0x03
     6e0:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     6e2:	e0 e8       	ldi	r30, 0x80	; 128
     6e4:	f6 e0       	ldi	r31, 0x06	; 6
     6e6:	83 e0       	ldi	r24, 0x03	; 3
     6e8:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     6ea:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     6ec:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     6ee:	e0 e8       	ldi	r30, 0x80	; 128
     6f0:	f1 e0       	ldi	r31, 0x01	; 1
     6f2:	80 e7       	ldi	r24, 0x70	; 112
     6f4:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     6f6:	89 e0       	ldi	r24, 0x09	; 9
     6f8:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     6fa:	e0 e4       	ldi	r30, 0x40	; 64
     6fc:	f8 e0       	ldi	r31, 0x08	; 8
     6fe:	8a e6       	ldi	r24, 0x6A	; 106
     700:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     702:	80 ea       	ldi	r24, 0xA0	; 160
     704:	95 e0       	ldi	r25, 0x05	; 5
     706:	86 a3       	std	Z+38, r24	; 0x26
     708:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     70e:	68 94       	set
     710:	ee 24       	eor	r14, r14
     712:	e6 f8       	bld	r14, 6
     714:	ff 24       	eor	r15, r15
     716:	f3 f8       	bld	r15, 3
     718:	f7 01       	movw	r30, r14
     71a:	80 a1       	ldd	r24, Z+32	; 0x20
     71c:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     71e:	0f b6       	in	r0, 0x3f	; 63
     720:	f8 94       	cli
     722:	0f 92       	push	r0
			the_data = new_data;
     724:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <thPendulum>
     728:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <thPendulum+0x1>
			portEXIT_CRITICAL ();
     72c:	0f 90       	pop	r0
     72e:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     730:	f8 01       	movw	r30, r16
     732:	86 85       	ldd	r24, Z+14	; 0x0e
     734:	97 85       	ldd	r25, Z+15	; 0x0f
     736:	a0 89       	ldd	r26, Z+16	; 0x10
     738:	b1 89       	ldd	r27, Z+17	; 0x11
     73a:	01 96       	adiw	r24, 0x01	; 1
     73c:	a1 1d       	adc	r26, r1
     73e:	b1 1d       	adc	r27, r1
     740:	86 87       	std	Z+14, r24	; 0x0e
     742:	97 87       	std	Z+15, r25	; 0x0f
     744:	a0 8b       	std	Z+16, r26	; 0x10
     746:	b1 8b       	std	Z+17, r27	; 0x11
     748:	41 e0       	ldi	r20, 0x01	; 1
     74a:	50 e0       	ldi	r21, 0x00	; 0
     74c:	60 e0       	ldi	r22, 0x00	; 0
     74e:	70 e0       	ldi	r23, 0x00	; 0
     750:	ce 01       	movw	r24, r28
     752:	01 96       	adiw	r24, 0x01	; 1
     754:	0e 94 09 12 	call	0x2412	; 0x2412 <vTaskDelayUntil>
     758:	df cf       	rjmp	.-66     	; 0x718 <_ZN15EncoderPendulum3runEv+0x50>

0000075a <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     75a:	0f 93       	push	r16
     75c:	1f 93       	push	r17
     75e:	cf 93       	push	r28
     760:	df 93       	push	r29
     762:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     764:	0e 94 a6 14 	call	0x294c	; 0x294c <_ZN8frt_taskC1EPKchjP8emstream>
     768:	82 e1       	ldi	r24, 0x12	; 18
     76a:	90 e2       	ldi	r25, 0x20	; 32
     76c:	88 83       	st	Y, r24
     76e:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	1f 91       	pop	r17
     776:	0f 91       	pop	r16
     778:	08 95       	ret

0000077a <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     77a:	cf 93       	push	r28
     77c:	df 93       	push	r29
     77e:	00 d0       	rcall	.+0      	; 0x780 <_ZN13LimitSwitches3runEv+0x6>
     780:	1f 92       	push	r1
     782:	cd b7       	in	r28, 0x3d	; 61
     784:	de b7       	in	r29, 0x3e	; 62
     786:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     788:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <xTaskGetTickCount>
     78c:	69 83       	std	Y+1, r22	; 0x01
     78e:	7a 83       	std	Y+2, r23	; 0x02
     790:	8b 83       	std	Y+3, r24	; 0x03
     792:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     794:	e0 e6       	ldi	r30, 0x60	; 96
     796:	f6 e0       	ldi	r31, 0x06	; 6
     798:	81 e0       	ldi	r24, 0x01	; 1
     79a:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     79c:	84 e0       	ldi	r24, 0x04	; 4
     79e:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     7a0:	88 e1       	ldi	r24, 0x18	; 24
     7a2:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     7a4:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     7a6:	08 e6       	ldi	r16, 0x68	; 104
     7a8:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     7aa:	dd 24       	eor	r13, r13
     7ac:	d3 94       	inc	r13
     7ae:	f8 01       	movw	r30, r16
     7b0:	80 81       	ld	r24, Z
     7b2:	80 fd       	sbrc	r24, 0
     7b4:	08 c0       	rjmp	.+16     	; 0x7c6 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7b6:	0f b6       	in	r0, 0x3f	; 63
     7b8:	f8 94       	cli
     7ba:	0f 92       	push	r0
			the_data = new_data;
     7bc:	d0 92 49 31 	sts	0x3149, r13	; 0x803149 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7c0:	0f 90       	pop	r0
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	07 c0       	rjmp	.+14     	; 0x7d4 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7c6:	0f b6       	in	r0, 0x3f	; 63
     7c8:	f8 94       	cli
     7ca:	0f 92       	push	r0
			the_data = new_data;
     7cc:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7d0:	0f 90       	pop	r0
     7d2:	0f be       	out	0x3f, r0	; 63
			*/

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     7d4:	f8 01       	movw	r30, r16
     7d6:	80 81       	ld	r24, Z
     7d8:	82 fd       	sbrc	r24, 2
     7da:	08 c0       	rjmp	.+16     	; 0x7ec <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7dc:	0f b6       	in	r0, 0x3f	; 63
     7de:	f8 94       	cli
     7e0:	0f 92       	push	r0
			the_data = new_data;
     7e2:	d0 92 48 31 	sts	0x3148, r13	; 0x803148 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     7e6:	0f 90       	pop	r0
     7e8:	0f be       	out	0x3f, r0	; 63
     7ea:	07 c0       	rjmp	.+14     	; 0x7fa <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7ec:	0f b6       	in	r0, 0x3f	; 63
     7ee:	f8 94       	cli
     7f0:	0f 92       	push	r0
			the_data = new_data;
     7f2:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     7f6:	0f 90       	pop	r0
     7f8:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     7fa:	f7 01       	movw	r30, r14
     7fc:	86 85       	ldd	r24, Z+14	; 0x0e
     7fe:	97 85       	ldd	r25, Z+15	; 0x0f
     800:	a0 89       	ldd	r26, Z+16	; 0x10
     802:	b1 89       	ldd	r27, Z+17	; 0x11
     804:	01 96       	adiw	r24, 0x01	; 1
     806:	a1 1d       	adc	r26, r1
     808:	b1 1d       	adc	r27, r1
     80a:	86 87       	std	Z+14, r24	; 0x0e
     80c:	97 87       	std	Z+15, r25	; 0x0f
     80e:	a0 8b       	std	Z+16, r26	; 0x10
     810:	b1 8b       	std	Z+17, r27	; 0x11
     812:	45 e0       	ldi	r20, 0x05	; 5
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	60 e0       	ldi	r22, 0x00	; 0
     818:	70 e0       	ldi	r23, 0x00	; 0
     81a:	ce 01       	movw	r24, r28
     81c:	01 96       	adiw	r24, 0x01	; 1
     81e:	0e 94 09 12 	call	0x2412	; 0x2412 <vTaskDelayUntil>
     822:	c5 cf       	rjmp	.-118    	; 0x7ae <_ZN13LimitSwitches3runEv+0x34>

00000824 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     824:	0f 93       	push	r16
     826:	1f 93       	push	r17
     828:	cf 93       	push	r28
     82a:	df 93       	push	r29
     82c:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     82e:	0e 94 a6 14 	call	0x294c	; 0x294c <_ZN8frt_taskC1EPKchjP8emstream>
     832:	8a e1       	ldi	r24, 0x1A	; 26
     834:	90 e2       	ldi	r25, 0x20	; 32
     836:	88 83       	st	Y, r24
     838:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     83a:	df 91       	pop	r29
     83c:	cf 91       	pop	r28
     83e:	1f 91       	pop	r17
     840:	0f 91       	pop	r16
     842:	08 95       	ret

00000844 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	cd b7       	in	r28, 0x3d	; 61
     84a:	de b7       	in	r29, 0x3e	; 62
     84c:	66 97       	sbiw	r28, 0x16	; 22
     84e:	cd bf       	out	0x3d, r28	; 61
     850:	de bf       	out	0x3e, r29	; 62
     852:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     854:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <xTaskGetTickCount>
     858:	69 83       	std	Y+1, r22	; 0x01
     85a:	7a 83       	std	Y+2, r23	; 0x02
     85c:	8b 83       	std	Y+3, r24	; 0x03
     85e:	9c 83       	std	Y+4, r25	; 0x04

	dt = 5; // [ms]
     860:	f8 01       	movw	r30, r16
     862:	fe 96       	adiw	r30, 0x3e	; 62
     864:	85 e0       	ldi	r24, 0x05	; 5
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	a0 e0       	ldi	r26, 0x00	; 0
     86a:	b0 e0       	ldi	r27, 0x00	; 0
     86c:	80 83       	st	Z, r24
     86e:	91 83       	std	Z+1, r25	; 0x01
     870:	a2 83       	std	Z+2, r26	; 0x02
     872:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	f8 01       	movw	r30, r16
     87a:	84 af       	std	Z+60, r24	; 0x3c
     87c:	95 af       	std	Z+61, r25	; 0x3d
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 6.5;
     87e:	98 01       	movw	r18, r16
     880:	28 5b       	subi	r18, 0xB8	; 184
     882:	3f 4f       	sbci	r19, 0xFF	; 255
     884:	2d 83       	std	Y+5, r18	; 0x05
     886:	3e 83       	std	Y+6, r19	; 0x06
     888:	36 e0       	ldi	r19, 0x06	; 6
     88a:	3d 8b       	std	Y+21, r19	; 0x15
     88c:	1e 8a       	std	Y+22, r1	; 0x16
		_Ki = .74*256;
     88e:	a8 01       	movw	r20, r16
     890:	44 5b       	subi	r20, 0xB4	; 180
     892:	5f 4f       	sbci	r21, 0xFF	; 255
     894:	4f 83       	std	Y+7, r20	; 0x07
     896:	58 87       	std	Y+8, r21	; 0x08
		_Kd = 0;
     898:	c8 01       	movw	r24, r16
     89a:	86 5b       	subi	r24, 0xB6	; 182
     89c:	9f 4f       	sbci	r25, 0xFF	; 255
     89e:	8f 87       	std	Y+15, r24	; 0x0f
     8a0:	98 8b       	std	Y+16, r25	; 0x10
		antiwind_gain = .93*256;
     8a2:	ec 59       	subi	r30, 0x9C	; 156
     8a4:	ff 4f       	sbci	r31, 0xFF	; 255
     8a6:	e9 87       	std	Y+9, r30	; 0x09
     8a8:	fa 87       	std	Y+10, r31	; 0x0a
		
		_max = 1600;
     8aa:	98 01       	movw	r18, r16
     8ac:	2c 5b       	subi	r18, 0xBC	; 188
     8ae:	3f 4f       	sbci	r19, 0xFF	; 255
     8b0:	2b 87       	std	Y+11, r18	; 0x0b
     8b2:	3c 87       	std	Y+12, r19	; 0x0c
		_min = -1600;
     8b4:	46 50       	subi	r20, 0x06	; 6
     8b6:	51 09       	sbc	r21, r1
     8b8:	4d 87       	std	Y+13, r20	; 0x0d
     8ba:	5e 87       	std	Y+14, r21	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     8bc:	42 96       	adiw	r24, 0x12	; 18
     8be:	89 8b       	std	Y+17, r24	; 0x11
     8c0:	9a 8b       	std	Y+18, r25	; 0x12

		// Integral term
		error_int = error - antiwind_correct;
     8c2:	18 01       	movw	r2, r16
     8c4:	96 e6       	ldi	r25, 0x66	; 102
     8c6:	29 0e       	add	r2, r25
     8c8:	31 1c       	adc	r3, r1
     8ca:	34 96       	adiw	r30, 0x04	; 4
     8cc:	eb 8b       	std	Y+19, r30	; 0x13
     8ce:	fc 8b       	std	Y+20, r31	; 0x14
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     8d0:	48 01       	movw	r8, r16
     8d2:	fe e3       	ldi	r31, 0x3E	; 62
     8d4:	8f 0e       	add	r8, r31
     8d6:	91 1c       	adc	r9, r1
     8d8:	58 01       	movw	r10, r16
     8da:	20 e5       	ldi	r18, 0x50	; 80
     8dc:	a2 0e       	add	r10, r18
     8de:	b1 1c       	adc	r11, r1

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);

		output_correct = output;
     8e0:	68 01       	movw	r12, r16
     8e2:	3e e5       	ldi	r19, 0x5E	; 94
     8e4:	c3 0e       	add	r12, r19
     8e6:	d1 1c       	adc	r13, r1
	dt = 5; // [ms]
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     8e8:	f8 01       	movw	r30, r16
     8ea:	86 85       	ldd	r24, Z+14	; 0x0e
     8ec:	97 85       	ldd	r25, Z+15	; 0x0f
     8ee:	a0 89       	ldd	r26, Z+16	; 0x10
     8f0:	b1 89       	ldd	r27, Z+17	; 0x11
     8f2:	01 96       	adiw	r24, 0x01	; 1
     8f4:	a1 1d       	adc	r26, r1
     8f6:	b1 1d       	adc	r27, r1
     8f8:	86 87       	std	Z+14, r24	; 0x0e
     8fa:	97 87       	std	Z+15, r25	; 0x0f
     8fc:	a0 8b       	std	Z+16, r26	; 0x10
     8fe:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
		omegam_set = 100; // [ticks/ms]
     900:	24 e6       	ldi	r18, 0x64	; 100
     902:	30 e0       	ldi	r19, 0x00	; 0
     904:	22 8f       	std	Z+26, r18	; 0x1a
     906:	33 8f       	std	Z+27, r19	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     908:	0f b6       	in	r0, 0x3f	; 63
     90a:	f8 94       	cli
     90c:	0f 92       	push	r0
			temporary_copy = the_data;
     90e:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <thdMotor>
     912:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     916:	0f 90       	pop	r0
     918:	0f be       	out	0x3f, r0	; 63

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     91a:	86 8f       	std	Z+30, r24	; 0x1e
     91c:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 6.5;
     91e:	4d 89       	ldd	r20, Y+21	; 0x15
     920:	ed 81       	ldd	r30, Y+5	; 0x05
     922:	fe 81       	ldd	r31, Y+6	; 0x06
     924:	40 83       	st	Z, r20
     926:	5e 89       	ldd	r21, Y+22	; 0x16
     928:	51 83       	std	Z+1, r21	; 0x01
		_Ki = .74*256;
     92a:	4d eb       	ldi	r20, 0xBD	; 189
     92c:	50 e0       	ldi	r21, 0x00	; 0
     92e:	ef 81       	ldd	r30, Y+7	; 0x07
     930:	f8 85       	ldd	r31, Y+8	; 0x08
     932:	40 83       	st	Z, r20
     934:	51 83       	std	Z+1, r21	; 0x01
		_Kd = 0;
     936:	ef 85       	ldd	r30, Y+15	; 0x0f
     938:	f8 89       	ldd	r31, Y+16	; 0x10
     93a:	10 82       	st	Z, r1
     93c:	11 82       	std	Z+1, r1	; 0x01
		antiwind_gain = .93*256;
     93e:	4e ee       	ldi	r20, 0xEE	; 238
     940:	50 e0       	ldi	r21, 0x00	; 0
     942:	e9 85       	ldd	r30, Y+9	; 0x09
     944:	fa 85       	ldd	r31, Y+10	; 0x0a
     946:	40 83       	st	Z, r20
     948:	51 83       	std	Z+1, r21	; 0x01
		
		_max = 1600;
     94a:	40 e4       	ldi	r20, 0x40	; 64
     94c:	56 e0       	ldi	r21, 0x06	; 6
     94e:	eb 85       	ldd	r30, Y+11	; 0x0b
     950:	fc 85       	ldd	r31, Y+12	; 0x0c
     952:	40 83       	st	Z, r20
     954:	51 83       	std	Z+1, r21	; 0x01
		_min = -1600;
     956:	40 ec       	ldi	r20, 0xC0	; 192
     958:	59 ef       	ldi	r21, 0xF9	; 249
     95a:	ed 85       	ldd	r30, Y+13	; 0x0d
     95c:	fe 85       	ldd	r31, Y+14	; 0x0e
     95e:	40 83       	st	Z, r20
     960:	51 83       	std	Z+1, r21	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     962:	79 01       	movw	r14, r18
     964:	e8 1a       	sub	r14, r24
     966:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     968:	b7 01       	movw	r22, r14
     96a:	86 e0       	ldi	r24, 0x06	; 6
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	0e 94 cf 06 	call	0xd9e	; 0xd9e <_ZN7satmath20signed_saturated_mulEii>
     972:	2b 01       	movw	r4, r22
     974:	3c 01       	movw	r6, r24
     976:	e9 89       	ldd	r30, Y+17	; 0x11
     978:	fa 89       	ldd	r31, Y+18	; 0x12
     97a:	60 83       	st	Z, r22
     97c:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     97e:	f1 01       	movw	r30, r2
     980:	80 81       	ld	r24, Z
     982:	91 81       	ldd	r25, Z+1	; 0x01
     984:	97 01       	movw	r18, r14
     986:	28 1b       	sub	r18, r24
     988:	39 0b       	sbc	r19, r25
     98a:	c9 01       	movw	r24, r18
     98c:	eb 89       	ldd	r30, Y+19	; 0x13
     98e:	fc 89       	ldd	r31, Y+20	; 0x14
     990:	20 83       	st	Z, r18
     992:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     994:	ef 81       	ldd	r30, Y+7	; 0x07
     996:	f8 85       	ldd	r31, Y+8	; 0x08
     998:	20 81       	ld	r18, Z
     99a:	31 81       	ldd	r19, Z+1	; 0x01
     99c:	82 9f       	mul	r24, r18
     99e:	d0 01       	movw	r26, r0
     9a0:	83 9f       	mul	r24, r19
     9a2:	b0 0d       	add	r27, r0
     9a4:	92 9f       	mul	r25, r18
     9a6:	b0 0d       	add	r27, r0
     9a8:	11 24       	eor	r1, r1
     9aa:	f8 01       	movw	r30, r16
     9ac:	e6 59       	subi	r30, 0x96	; 150
     9ae:	ff 4f       	sbci	r31, 0xFF	; 255
     9b0:	a0 83       	st	Z, r26
     9b2:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     9b4:	f4 01       	movw	r30, r8
     9b6:	20 81       	ld	r18, Z
     9b8:	31 81       	ldd	r19, Z+1	; 0x01
     9ba:	42 81       	ldd	r20, Z+2	; 0x02
     9bc:	53 81       	ldd	r21, Z+3	; 0x03
     9be:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <__mulshisi3>
     9c2:	9b 01       	movw	r18, r22
     9c4:	ac 01       	movw	r20, r24
     9c6:	99 23       	and	r25, r25
     9c8:	24 f4       	brge	.+8      	; 0x9d2 <_ZN5Motor3runEv+0x18e>
     9ca:	21 50       	subi	r18, 0x01	; 1
     9cc:	3f 4f       	sbci	r19, 0xFF	; 255
     9ce:	4f 4f       	sbci	r20, 0xFF	; 255
     9d0:	5f 4f       	sbci	r21, 0xFF	; 255
     9d2:	bb 27       	eor	r27, r27
     9d4:	57 fd       	sbrc	r21, 7
     9d6:	ba 95       	dec	r27
     9d8:	a5 2f       	mov	r26, r21
     9da:	94 2f       	mov	r25, r20
     9dc:	83 2f       	mov	r24, r19
     9de:	f5 01       	movw	r30, r10
     9e0:	40 81       	ld	r20, Z
     9e2:	51 81       	ldd	r21, Z+1	; 0x01
     9e4:	62 81       	ldd	r22, Z+2	; 0x02
     9e6:	73 81       	ldd	r23, Z+3	; 0x03
     9e8:	84 0f       	add	r24, r20
     9ea:	95 1f       	adc	r25, r21
     9ec:	a6 1f       	adc	r26, r22
     9ee:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     9f0:	81 30       	cpi	r24, 0x01	; 1
     9f2:	fa ec       	ldi	r31, 0xCA	; 202
     9f4:	9f 07       	cpc	r25, r31
     9f6:	fa e9       	ldi	r31, 0x9A	; 154
     9f8:	af 07       	cpc	r26, r31
     9fa:	fb e3       	ldi	r31, 0x3B	; 59
     9fc:	bf 07       	cpc	r27, r31
     9fe:	54 f0       	brlt	.+20     	; 0xa14 <_ZN5Motor3runEv+0x1d0>
		{
			_integral = 1000000000;
     a00:	80 e0       	ldi	r24, 0x00	; 0
     a02:	9a ec       	ldi	r25, 0xCA	; 202
     a04:	aa e9       	ldi	r26, 0x9A	; 154
     a06:	bb e3       	ldi	r27, 0x3B	; 59
     a08:	f5 01       	movw	r30, r10
     a0a:	80 83       	st	Z, r24
     a0c:	91 83       	std	Z+1, r25	; 0x01
     a0e:	a2 83       	std	Z+2, r26	; 0x02
     a10:	b3 83       	std	Z+3, r27	; 0x03
     a12:	17 c0       	rjmp	.+46     	; 0xa42 <_ZN5Motor3runEv+0x1fe>
		}
		else if(_integral < -1000000000)
     a14:	81 15       	cp	r24, r1
     a16:	f6 e3       	ldi	r31, 0x36	; 54
     a18:	9f 07       	cpc	r25, r31
     a1a:	f5 e6       	ldi	r31, 0x65	; 101
     a1c:	af 07       	cpc	r26, r31
     a1e:	f4 ec       	ldi	r31, 0xC4	; 196
     a20:	bf 07       	cpc	r27, r31
     a22:	34 f0       	brlt	.+12     	; 0xa30 <_ZN5Motor3runEv+0x1ec>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     a24:	f5 01       	movw	r30, r10
     a26:	80 83       	st	Z, r24
     a28:	91 83       	std	Z+1, r25	; 0x01
     a2a:	a2 83       	std	Z+2, r26	; 0x02
     a2c:	b3 83       	std	Z+3, r27	; 0x03
     a2e:	09 c0       	rjmp	.+18     	; 0xa42 <_ZN5Motor3runEv+0x1fe>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	96 e3       	ldi	r25, 0x36	; 54
     a34:	a5 e6       	ldi	r26, 0x65	; 101
     a36:	b4 ec       	ldi	r27, 0xC4	; 196
     a38:	f5 01       	movw	r30, r10
     a3a:	80 83       	st	Z, r24
     a3c:	91 83       	std	Z+1, r25	; 0x01
     a3e:	a2 83       	std	Z+2, r26	; 0x02
     a40:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     a42:	f5 01       	movw	r30, r10
     a44:	60 81       	ld	r22, Z
     a46:	71 81       	ldd	r23, Z+1	; 0x01
     a48:	c2 01       	movw	r24, r4
     a4a:	0e 94 b3 06 	call	0xd66	; 0xd66 <_ZN7satmath20signed_saturated_addEii>
     a4e:	f8 01       	movw	r30, r16
     a50:	e0 5a       	subi	r30, 0xA0	; 160
     a52:	ff 4f       	sbci	r31, 0xFF	; 255
     a54:	80 83       	st	Z, r24
     a56:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     a58:	f6 01       	movw	r30, r12
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     a5e:	eb 85       	ldd	r30, Y+11	; 0x0b
     a60:	fc 85       	ldd	r31, Y+12	; 0x0c
     a62:	20 81       	ld	r18, Z
     a64:	31 81       	ldd	r19, Z+1	; 0x01
     a66:	28 17       	cp	r18, r24
     a68:	39 07       	cpc	r19, r25
     a6a:	24 f4       	brge	.+8      	; 0xa74 <_ZN5Motor3runEv+0x230>
		output_correct = _max;
     a6c:	f6 01       	movw	r30, r12
     a6e:	20 83       	st	Z, r18
     a70:	31 83       	std	Z+1, r19	; 0x01
     a72:	0a c0       	rjmp	.+20     	; 0xa88 <_ZN5Motor3runEv+0x244>
		else if( output_correct < _min )
     a74:	ed 85       	ldd	r30, Y+13	; 0x0d
     a76:	fe 85       	ldd	r31, Y+14	; 0x0e
     a78:	20 81       	ld	r18, Z
     a7a:	31 81       	ldd	r19, Z+1	; 0x01
     a7c:	82 17       	cp	r24, r18
     a7e:	93 07       	cpc	r25, r19
     a80:	1c f4       	brge	.+6      	; 0xa88 <_ZN5Motor3runEv+0x244>
		output_correct = _min;
     a82:	f6 01       	movw	r30, r12
     a84:	20 83       	st	Z, r18
     a86:	31 83       	std	Z+1, r19	; 0x01

		// Save error to previous error
		_pre_error = error;
     a88:	f8 01       	movw	r30, r16
     a8a:	e2 5b       	subi	r30, 0xB2	; 178
     a8c:	ff 4f       	sbci	r31, 0xFF	; 255
     a8e:	e0 82       	st	Z, r14
     a90:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     a92:	f6 01       	movw	r30, r12
     a94:	20 81       	ld	r18, Z
     a96:	31 81       	ldd	r19, Z+1	; 0x01
     a98:	82 1b       	sub	r24, r18
     a9a:	93 0b       	sbc	r25, r19
     a9c:	f8 01       	movw	r30, r16
     a9e:	ee 59       	subi	r30, 0x9E	; 158
     aa0:	ff 4f       	sbci	r31, 0xFF	; 255
     aa2:	80 83       	st	Z, r24
     aa4:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     aa6:	e9 85       	ldd	r30, Y+9	; 0x09
     aa8:	fa 85       	ldd	r31, Y+10	; 0x0a
     aaa:	40 81       	ld	r20, Z
     aac:	51 81       	ldd	r21, Z+1	; 0x01
     aae:	84 9f       	mul	r24, r20
     ab0:	90 01       	movw	r18, r0
     ab2:	85 9f       	mul	r24, r21
     ab4:	30 0d       	add	r19, r0
     ab6:	94 9f       	mul	r25, r20
     ab8:	30 0d       	add	r19, r0
     aba:	11 24       	eor	r1, r1
     abc:	33 23       	and	r19, r19
     abe:	14 f4       	brge	.+4      	; 0xac4 <_ZN5Motor3runEv+0x280>
     ac0:	21 50       	subi	r18, 0x01	; 1
     ac2:	3f 4f       	sbci	r19, 0xFF	; 255
     ac4:	83 2f       	mov	r24, r19
     ac6:	88 0f       	add	r24, r24
     ac8:	88 0b       	sbc	r24, r24
     aca:	f1 01       	movw	r30, r2
     acc:	30 83       	st	Z, r19
     ace:	81 83       	std	Z+1, r24	; 0x01
		
		
			if(runs%5==0){
     ad0:	f8 01       	movw	r30, r16
     ad2:	66 85       	ldd	r22, Z+14	; 0x0e
     ad4:	77 85       	ldd	r23, Z+15	; 0x0f
     ad6:	80 89       	ldd	r24, Z+16	; 0x10
     ad8:	91 89       	ldd	r25, Z+17	; 0x11
     ada:	25 e0       	ldi	r18, 0x05	; 5
     adc:	30 e0       	ldi	r19, 0x00	; 0
     ade:	40 e0       	ldi	r20, 0x00	; 0
     ae0:	50 e0       	ldi	r21, 0x00	; 0
     ae2:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__udivmodsi4>
     ae6:	67 2b       	or	r22, r23
     ae8:	68 2b       	or	r22, r24
     aea:	69 2b       	or	r22, r25
     aec:	d9 f4       	brne	.+54     	; 0xb24 <_ZN5Motor3runEv+0x2e0>
				//*p_serial << "Pout: " << Pout << endl;
				//*p_serial << "error: " << error << endl;
				//*p_serial << "Integral: " << _integral << endl;
				//*p_serial << "Measured: " << omegam_measured << endl;
				//*p_serial << "PWM Signal: " << output_correct << endl;
				*p_serial << omegam_measured << endl;
     aee:	f8 01       	movw	r30, r16
     af0:	66 8d       	ldd	r22, Z+30	; 0x1e
     af2:	77 8d       	ldd	r23, Z+31	; 0x1f
     af4:	86 81       	ldd	r24, Z+6	; 0x06
     af6:	97 81       	ldd	r25, Z+7	; 0x07
     af8:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <_ZN8emstreamlsEi>
     afc:	66 e0       	ldi	r22, 0x06	; 6
     afe:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b08:	0f 90       	pop	r0
     b0a:	0f be       	out	0x3f, r0	; 63
				*p_serial << thPendulum.get() << endl;
     b0c:	60 91 4a 31 	lds	r22, 0x314A	; 0x80314a <thPendulum>
     b10:	70 91 4b 31 	lds	r23, 0x314B	; 0x80314b <thPendulum+0x1>
     b14:	f8 01       	movw	r30, r16
     b16:	86 81       	ldd	r24, Z+6	; 0x06
     b18:	97 81       	ldd	r25, Z+7	; 0x07
     b1a:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <_ZN8emstreamlsEi>
     b1e:	66 e0       	ldi	r22, 0x06	; 6
     b20:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b24:	0f b6       	in	r0, 0x3f	; 63
     b26:	f8 94       	cli
     b28:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b2a:	0f 90       	pop	r0
     b2c:	0f be       	out	0x3f, r0	; 63
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     b2e:	80 91 49 31 	lds	r24, 0x3149	; 0x803149 <leftLimitSwitch>
     b32:	81 11       	cpse	r24, r1
     b34:	09 c0       	rjmp	.+18     	; 0xb48 <_ZN5Motor3runEv+0x304>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b36:	0f b6       	in	r0, 0x3f	; 63
     b38:	f8 94       	cli
     b3a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b3c:	0f 90       	pop	r0
     b3e:	0f be       	out	0x3f, r0	; 63
     b40:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rightLimitSwitch>
     b44:	88 23       	and	r24, r24
     b46:	59 f0       	breq	.+22     	; 0xb5e <_ZN5Motor3runEv+0x31a>
		{
			omegam_set = 0; // [ticks/ms]
     b48:	f8 01       	movw	r30, r16
     b4a:	12 8e       	std	Z+26, r1	; 0x1a
     b4c:	13 8e       	std	Z+27, r1	; 0x1b
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     b4e:	f5 01       	movw	r30, r10
     b50:	10 82       	st	Z, r1
     b52:	11 82       	std	Z+1, r1	; 0x01
     b54:	12 82       	std	Z+2, r1	; 0x02
     b56:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;
     b58:	f6 01       	movw	r30, r12
     b5a:	10 82       	st	Z, r1
     b5c:	11 82       	std	Z+1, r1	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	f8 94       	cli
     b62:	0f 92       	push	r0
			the_data = new_data;
     b64:	f6 01       	movw	r30, r12
     b66:	80 81       	ld	r24, Z
     b68:	91 81       	ldd	r25, Z+1	; 0x01
     b6a:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <PWMvalue>
     b6e:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     b72:	0f 90       	pop	r0
     b74:	0f be       	out	0x3f, r0	; 63
			}
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     b76:	f8 01       	movw	r30, r16
     b78:	10 a6       	std	Z+40, r1	; 0x28
     b7a:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     b7c:	82 a1       	ldd	r24, Z+34	; 0x22
     b7e:	93 a1       	ldd	r25, Z+35	; 0x23
     b80:	60 e0       	ldi	r22, 0x00	; 0
     b82:	70 e0       	ldi	r23, 0x00	; 0
     b84:	0e 94 68 1f 	call	0x3ed0	; 0x3ed0 <__divmodhi4>
     b88:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     b8a:	07 2e       	mov	r0, r23
     b8c:	00 0c       	add	r0, r0
     b8e:	88 0b       	sbc	r24, r24
     b90:	99 0b       	sbc	r25, r25
     b92:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <__floatsisf>
     b96:	2b 01       	movw	r4, r22
     b98:	3c 01       	movw	r6, r24
     b9a:	23 e3       	ldi	r18, 0x33	; 51
     b9c:	33 e3       	ldi	r19, 0x33	; 51
     b9e:	4b e8       	ldi	r20, 0x8B	; 139
     ba0:	51 e4       	ldi	r21, 0x41	; 65
     ba2:	0e 94 53 1f 	call	0x3ea6	; 0x3ea6 <__gesf2>
     ba6:	18 16       	cp	r1, r24
     ba8:	34 f4       	brge	.+12     	; 0xbb6 <_ZN5Motor3runEv+0x372>
			Im_set = 17.4;
     baa:	81 e1       	ldi	r24, 0x11	; 17
     bac:	90 e0       	ldi	r25, 0x00	; 0
     bae:	f8 01       	movw	r30, r16
     bb0:	84 a3       	std	Z+36, r24	; 0x24
     bb2:	95 a3       	std	Z+37, r25	; 0x25
     bb4:	13 c0       	rjmp	.+38     	; 0xbdc <_ZN5Motor3runEv+0x398>
		} else if(Im_set < -17.4) {
     bb6:	23 e3       	ldi	r18, 0x33	; 51
     bb8:	33 e3       	ldi	r19, 0x33	; 51
     bba:	4b e8       	ldi	r20, 0x8B	; 139
     bbc:	51 ec       	ldi	r21, 0xC1	; 193
     bbe:	c3 01       	movw	r24, r6
     bc0:	b2 01       	movw	r22, r4
     bc2:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <__cmpsf2>
     bc6:	88 23       	and	r24, r24
     bc8:	24 f0       	brlt	.+8      	; 0xbd2 <_ZN5Motor3runEv+0x38e>
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     bca:	f8 01       	movw	r30, r16
     bcc:	e4 a2       	std	Z+36, r14	; 0x24
     bce:	f5 a2       	std	Z+37, r15	; 0x25
     bd0:	05 c0       	rjmp	.+10     	; 0xbdc <_ZN5Motor3runEv+0x398>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     bd2:	8f ee       	ldi	r24, 0xEF	; 239
     bd4:	9f ef       	ldi	r25, 0xFF	; 255
     bd6:	f8 01       	movw	r30, r16
     bd8:	84 a3       	std	Z+36, r24	; 0x24
     bda:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     bdc:	f8 01       	movw	r30, r16
     bde:	16 aa       	std	Z+54, r1	; 0x36
     be0:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     be2:	12 aa       	std	Z+50, r1	; 0x32
     be4:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     be6:	14 aa       	std	Z+52, r1	; 0x34
     be8:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
     bea:	80 a9       	ldd	r24, Z+48	; 0x30
     bec:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
     bee:	89 31       	cpi	r24, 0x19	; 25
     bf0:	91 05       	cpc	r25, r1
     bf2:	2c f0       	brlt	.+10     	; 0xbfe <_ZN5Motor3runEv+0x3ba>
			V_m = 24;
     bf4:	88 e1       	ldi	r24, 0x18	; 24
     bf6:	90 e0       	ldi	r25, 0x00	; 0
     bf8:	80 af       	std	Z+56, r24	; 0x38
     bfa:	91 af       	std	Z+57, r25	; 0x39
     bfc:	0d c0       	rjmp	.+26     	; 0xc18 <_ZN5Motor3runEv+0x3d4>
		} else if(V_m < -24) {
     bfe:	88 3e       	cpi	r24, 0xE8	; 232
     c00:	ff ef       	ldi	r31, 0xFF	; 255
     c02:	9f 07       	cpc	r25, r31
     c04:	24 f0       	brlt	.+8      	; 0xc0e <_ZN5Motor3runEv+0x3ca>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     c06:	f8 01       	movw	r30, r16
     c08:	80 af       	std	Z+56, r24	; 0x38
     c0a:	91 af       	std	Z+57, r25	; 0x39
     c0c:	05 c0       	rjmp	.+10     	; 0xc18 <_ZN5Motor3runEv+0x3d4>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     c0e:	88 ee       	ldi	r24, 0xE8	; 232
     c10:	9f ef       	ldi	r25, 0xFF	; 255
     c12:	f8 01       	movw	r30, r16
     c14:	80 af       	std	Z+56, r24	; 0x38
     c16:	91 af       	std	Z+57, r25	; 0x39

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
     c18:	f4 01       	movw	r30, r8
     c1a:	20 81       	ld	r18, Z
     c1c:	31 81       	ldd	r19, Z+1	; 0x01
     c1e:	42 81       	ldd	r20, Z+2	; 0x02
     c20:	53 81       	ldd	r21, Z+3	; 0x03
     c22:	a8 ee       	ldi	r26, 0xE8	; 232
     c24:	b3 e0       	ldi	r27, 0x03	; 3
     c26:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <__muluhisi3>
     c2a:	68 3e       	cpi	r22, 0xE8	; 232
     c2c:	f3 e0       	ldi	r31, 0x03	; 3
     c2e:	7f 07       	cpc	r23, r31
     c30:	81 05       	cpc	r24, r1
     c32:	91 05       	cpc	r25, r1
     c34:	48 f0       	brcs	.+18     	; 0xc48 <_ZN5Motor3runEv+0x404>
     c36:	28 ee       	ldi	r18, 0xE8	; 232
     c38:	33 e0       	ldi	r19, 0x03	; 3
     c3a:	40 e0       	ldi	r20, 0x00	; 0
     c3c:	50 e0       	ldi	r21, 0x00	; 0
     c3e:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__udivmodsi4>
     c42:	ba 01       	movw	r22, r20
     c44:	a9 01       	movw	r20, r18
     c46:	04 c0       	rjmp	.+8      	; 0xc50 <_ZN5Motor3runEv+0x40c>
     c48:	41 e0       	ldi	r20, 0x01	; 1
     c4a:	50 e0       	ldi	r21, 0x00	; 0
     c4c:	60 e0       	ldi	r22, 0x00	; 0
     c4e:	70 e0       	ldi	r23, 0x00	; 0
     c50:	ce 01       	movw	r24, r28
     c52:	01 96       	adiw	r24, 0x01	; 1
     c54:	0e 94 09 12 	call	0x2412	; 0x2412 <vTaskDelayUntil>
     c58:	47 ce       	rjmp	.-882    	; 0x8e8 <_ZN5Motor3runEv+0xa4>

00000c5a <_ZN5MotorC1EPKchjP8emstream>:
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
     c5a:	0f 93       	push	r16
     c5c:	1f 93       	push	r17
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
     c62:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     c64:	0e 94 a6 14 	call	0x294c	; 0x294c <_ZN8frt_taskC1EPKchjP8emstream>
     c68:	82 e2       	ldi	r24, 0x22	; 34
     c6a:	90 e2       	ldi	r25, 0x20	; 32
     c6c:	88 83       	st	Y, r24
     c6e:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     c70:	df 91       	pop	r29
     c72:	cf 91       	pop	r28
     c74:	1f 91       	pop	r17
     c76:	0f 91       	pop	r16
     c78:	08 95       	ret

00000c7a <_ZN9PWMdriver3runEv>:
		// Nothing to do in this constructor other than call the parent constructor
	}



void PWMdriver::run(void){
     c7a:	cf 93       	push	r28
     c7c:	df 93       	push	r29
     c7e:	00 d0       	rcall	.+0      	; 0xc80 <_ZN9PWMdriver3runEv+0x6>
     c80:	1f 92       	push	r1
     c82:	cd b7       	in	r28, 0x3d	; 61
     c84:	de b7       	in	r29, 0x3e	; 62
     c86:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     c88:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <xTaskGetTickCount>
     c8c:	69 83       	std	Y+1, r22	; 0x01
     c8e:	7a 83       	std	Y+2, r23	; 0x02
     c90:	8b 83       	std	Y+3, r24	; 0x03
     c92:	9c 83       	std	Y+4, r25	; 0x04
	//PC0 - MD0
	//PC1 - MD1
	
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     c94:	a0 e4       	ldi	r26, 0x40	; 64
     c96:	b6 e0       	ldi	r27, 0x06	; 6
     c98:	87 e0       	ldi	r24, 0x07	; 7
     c9a:	11 96       	adiw	r26, 0x01	; 1
     c9c:	8c 93       	st	X, r24
     c9e:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     ca0:	84 e0       	ldi	r24, 0x04	; 4
     ca2:	15 96       	adiw	r26, 0x05	; 5
     ca4:	8c 93       	st	X, r24
     ca6:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     ca8:	e0 e0       	ldi	r30, 0x00	; 0
     caa:	f8 e0       	ldi	r31, 0x08	; 8
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     cb0:	83 e0       	ldi	r24, 0x03	; 3
     cb2:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     cb4:	a6 a3       	std	Z+38, r26	; 0x26
     cb6:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     cb8:	10 a6       	std	Z+40, r1	; 0x28
     cba:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     cbc:	12 a6       	std	Z+42, r1	; 0x2a
     cbe:	13 a6       	std	Z+43, r1	; 0x2b
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     cc0:	81 81       	ldd	r24, Z+1	; 0x01
     cc2:	80 63       	ori	r24, 0x30	; 48
     cc4:	81 83       	std	Z+1, r24	; 0x01
	
	while(1){
		// Increment counter for debugging
		runs++;
		
		TCC0.CCA = PWMvalue.get();
     cc6:	00 e0       	ldi	r16, 0x00	; 0
     cc8:	18 e0       	ldi	r17, 0x08	; 8
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
	
	while(1){
		// Increment counter for debugging
		runs++;
     cca:	f7 01       	movw	r30, r14
     ccc:	86 85       	ldd	r24, Z+14	; 0x0e
     cce:	97 85       	ldd	r25, Z+15	; 0x0f
     cd0:	a0 89       	ldd	r26, Z+16	; 0x10
     cd2:	b1 89       	ldd	r27, Z+17	; 0x11
     cd4:	01 96       	adiw	r24, 0x01	; 1
     cd6:	a1 1d       	adc	r26, r1
     cd8:	b1 1d       	adc	r27, r1
     cda:	86 87       	std	Z+14, r24	; 0x0e
     cdc:	97 87       	std	Z+15, r25	; 0x0f
     cde:	a0 8b       	std	Z+16, r26	; 0x10
     ce0:	b1 8b       	std	Z+17, r27	; 0x11
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ce2:	0f b6       	in	r0, 0x3f	; 63
     ce4:	f8 94       	cli
     ce6:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     ce8:	0f 90       	pop	r0
     cea:	0f be       	out	0x3f, r0	; 63
		
		TCC0.CCA = PWMvalue.get();
     cec:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <PWMvalue>
     cf0:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <PWMvalue+0x1>
     cf4:	f8 01       	movw	r30, r16
     cf6:	80 a7       	std	Z+40, r24	; 0x28
     cf8:	91 a7       	std	Z+41, r25	; 0x29
		TCC0.CCB = 0;
     cfa:	12 a6       	std	Z+42, r1	; 0x2a
     cfc:	13 a6       	std	Z+43, r1	; 0x2b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cfe:	0f b6       	in	r0, 0x3f	; 63
     d00:	f8 94       	cli
     d02:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d04:	0f 90       	pop	r0
     d06:	0f be       	out	0x3f, r0	; 63
		if(runs%100==0){
			*p_serial << PWMvalue.get() << endl;
		}	
		*/
		
		if (!leftLimitSwitch.get() && !rightLimitSwitch.get())
     d08:	20 91 49 31 	lds	r18, 0x3149	; 0x803149 <leftLimitSwitch>
     d0c:	21 11       	cpse	r18, r1
     d0e:	12 c0       	rjmp	.+36     	; 0xd34 <_ZN9PWMdriver3runEv+0xba>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d10:	0f b6       	in	r0, 0x3f	; 63
     d12:	f8 94       	cli
     d14:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d16:	0f 90       	pop	r0
     d18:	0f be       	out	0x3f, r0	; 63
     d1a:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <rightLimitSwitch>
     d1e:	21 11       	cpse	r18, r1
     d20:	09 c0       	rjmp	.+18     	; 0xd34 <_ZN9PWMdriver3runEv+0xba>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d22:	0f b6       	in	r0, 0x3f	; 63
     d24:	f8 94       	cli
     d26:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d28:	0f 90       	pop	r0
     d2a:	0f be       	out	0x3f, r0	; 63
		{
			TCC0.CCA = PWMvalue.get();
     d2c:	80 a7       	std	Z+40, r24	; 0x28
     d2e:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
     d30:	12 a6       	std	Z+42, r1	; 0x2a
     d32:	13 a6       	std	Z+43, r1	; 0x2b
     d34:	44 e1       	ldi	r20, 0x14	; 20
     d36:	50 e0       	ldi	r21, 0x00	; 0
     d38:	60 e0       	ldi	r22, 0x00	; 0
     d3a:	70 e0       	ldi	r23, 0x00	; 0
     d3c:	ce 01       	movw	r24, r28
     d3e:	01 96       	adiw	r24, 0x01	; 1
     d40:	0e 94 09 12 	call	0x2412	; 0x2412 <vTaskDelayUntil>
     d44:	c2 cf       	rjmp	.-124    	; 0xcca <_ZN9PWMdriver3runEv+0x50>

00000d46 <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

PWMdriver::PWMdriver(const char* a_name,
     d46:	0f 93       	push	r16
     d48:	1f 93       	push	r17
     d4a:	cf 93       	push	r28
     d4c:	df 93       	push	r29
     d4e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d50:	0e 94 a6 14 	call	0x294c	; 0x294c <_ZN8frt_taskC1EPKchjP8emstream>
     d54:	8a e2       	ldi	r24, 0x2A	; 42
     d56:	90 e2       	ldi	r25, 0x20	; 32
     d58:	88 83       	st	Y, r24
     d5a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	1f 91       	pop	r17
     d62:	0f 91       	pop	r16
     d64:	08 95       	ret

00000d66 <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
     d66:	9c 01       	movw	r18, r24
     d68:	93 2f       	mov	r25, r19
     d6a:	99 1f       	adc	r25, r25
     d6c:	99 27       	eor	r25, r25
     d6e:	99 1f       	adc	r25, r25
     d70:	89 2f       	mov	r24, r25
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	81 50       	subi	r24, 0x01	; 1
     d76:	90 48       	sbci	r25, 0x80	; 128
     d78:	43 2f       	mov	r20, r19
     d7a:	40 95       	com	r20
     d7c:	44 1f       	adc	r20, r20
     d7e:	44 27       	eor	r20, r20
     d80:	44 1f       	adc	r20, r20
     d82:	fc 01       	movw	r30, r24
     d84:	e2 1b       	sub	r30, r18
     d86:	f3 0b       	sbc	r31, r19
     d88:	51 e0       	ldi	r21, 0x01	; 1
     d8a:	e6 17       	cp	r30, r22
     d8c:	f7 07       	cpc	r31, r23
     d8e:	0c f0       	brlt	.+2      	; 0xd92 <_ZN7satmath20signed_saturated_addEii+0x2c>
     d90:	50 e0       	ldi	r21, 0x00	; 0
     d92:	45 17       	cp	r20, r21
     d94:	19 f0       	breq	.+6      	; 0xd9c <_ZN7satmath20signed_saturated_addEii+0x36>
     d96:	c9 01       	movw	r24, r18
     d98:	86 0f       	add	r24, r22
     d9a:	97 1f       	adc	r25, r23
     d9c:	08 95       	ret

00000d9e <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     d9e:	81 15       	cp	r24, r1
     da0:	20 e8       	ldi	r18, 0x80	; 128
     da2:	92 07       	cpc	r25, r18
     da4:	21 f4       	brne	.+8      	; 0xdae <_ZN7satmath20signed_saturated_mulEii+0x10>
     da6:	61 15       	cp	r22, r1
     da8:	20 e8       	ldi	r18, 0x80	; 128
     daa:	72 07       	cpc	r23, r18
     dac:	29 f0       	breq	.+10     	; 0xdb8 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     dae:	9c 01       	movw	r18, r24
     db0:	db 01       	movw	r26, r22
     db2:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <__mulhisi3>
     db6:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     db8:	6f ef       	ldi	r22, 0xFF	; 255
     dba:	7f ef       	ldi	r23, 0xFF	; 255
     dbc:	8f ef       	ldi	r24, 0xFF	; 255
     dbe:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     dc0:	08 95       	ret

00000dc2 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     dc2:	0f 93       	push	r16
     dc4:	1f 93       	push	r17
     dc6:	cf 93       	push	r28
     dc8:	df 93       	push	r29
     dca:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     dcc:	0e 94 a6 14 	call	0x294c	; 0x294c <_ZN8frt_taskC1EPKchjP8emstream>
     dd0:	82 e3       	ldi	r24, 0x32	; 50
     dd2:	90 e2       	ldi	r25, 0x20	; 32
     dd4:	88 83       	st	Y, r24
     dd6:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	1f 91       	pop	r17
     dde:	0f 91       	pop	r16
     de0:	08 95       	ret

00000de2 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     de2:	0f 93       	push	r16
     de4:	1f 93       	push	r17
     de6:	cf 93       	push	r28
     de8:	df 93       	push	r29
     dea:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     dec:	6a e0       	ldi	r22, 0x0A	; 10
     dee:	8e 81       	ldd	r24, Y+6	; 0x06
     df0:	9f 81       	ldd	r25, Y+7	; 0x07
     df2:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     df6:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     df8:	6d ee       	ldi	r22, 0xED	; 237
     dfa:	73 e0       	ldi	r23, 0x03	; 3
     dfc:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     e00:	6a e0       	ldi	r22, 0x0A	; 10
     e02:	c8 01       	movw	r24, r16
     e04:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     e08:	8c 01       	movw	r16, r24
     e0a:	67 ee       	ldi	r22, 0xE7	; 231
     e0c:	73 e0       	ldi	r23, 0x03	; 3
     e0e:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     e12:	67 e0       	ldi	r22, 0x07	; 7
     e14:	c8 01       	movw	r24, r16
     e16:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     e1a:	6a e0       	ldi	r22, 0x0A	; 10
     e1c:	8e 81       	ldd	r24, Y+6	; 0x06
     e1e:	9f 81       	ldd	r25, Y+7	; 0x07
     e20:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     e24:	8c 01       	movw	r16, r24
     e26:	68 ec       	ldi	r22, 0xC8	; 200
     e28:	73 e0       	ldi	r23, 0x03	; 3
     e2a:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     e2e:	6a e0       	ldi	r22, 0x0A	; 10
     e30:	c8 01       	movw	r24, r16
     e32:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     e36:	8c 01       	movw	r16, r24
     e38:	62 ec       	ldi	r22, 0xC2	; 194
     e3a:	73 e0       	ldi	r23, 0x03	; 3
     e3c:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     e40:	66 e0       	ldi	r22, 0x06	; 6
     e42:	c8 01       	movw	r24, r16
     e44:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e48:	6a e0       	ldi	r22, 0x0A	; 10
     e4a:	8e 81       	ldd	r24, Y+6	; 0x06
     e4c:	9f 81       	ldd	r25, Y+7	; 0x07
     e4e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     e52:	8c 01       	movw	r16, r24
     e54:	6b ea       	ldi	r22, 0xAB	; 171
     e56:	73 e0       	ldi	r23, 0x03	; 3
     e58:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     e5c:	66 e0       	ldi	r22, 0x06	; 6
     e5e:	c8 01       	movw	r24, r16
     e60:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e64:	6a e0       	ldi	r22, 0x0A	; 10
     e66:	8e 81       	ldd	r24, Y+6	; 0x06
     e68:	9f 81       	ldd	r25, Y+7	; 0x07
     e6a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     e6e:	8c 01       	movw	r16, r24
     e70:	6f e8       	ldi	r22, 0x8F	; 143
     e72:	73 e0       	ldi	r23, 0x03	; 3
     e74:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     e78:	66 e0       	ldi	r22, 0x06	; 6
     e7a:	c8 01       	movw	r24, r16
     e7c:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e80:	6a e0       	ldi	r22, 0x0A	; 10
     e82:	8e 81       	ldd	r24, Y+6	; 0x06
     e84:	9f 81       	ldd	r25, Y+7	; 0x07
     e86:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     e8a:	8c 01       	movw	r16, r24
     e8c:	67 e7       	ldi	r22, 0x77	; 119
     e8e:	73 e0       	ldi	r23, 0x03	; 3
     e90:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     e94:	66 e0       	ldi	r22, 0x06	; 6
     e96:	c8 01       	movw	r24, r16
     e98:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e9c:	6a e0       	ldi	r22, 0x0A	; 10
     e9e:	8e 81       	ldd	r24, Y+6	; 0x06
     ea0:	9f 81       	ldd	r25, Y+7	; 0x07
     ea2:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     ea6:	8c 01       	movw	r16, r24
     ea8:	66 e5       	ldi	r22, 0x56	; 86
     eaa:	73 e0       	ldi	r23, 0x03	; 3
     eac:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     eb0:	66 e0       	ldi	r22, 0x06	; 6
     eb2:	c8 01       	movw	r24, r16
     eb4:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     eb8:	6a e0       	ldi	r22, 0x0A	; 10
     eba:	8e 81       	ldd	r24, Y+6	; 0x06
     ebc:	9f 81       	ldd	r25, Y+7	; 0x07
     ebe:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     ec2:	8c 01       	movw	r16, r24
     ec4:	6f e2       	ldi	r22, 0x2F	; 47
     ec6:	73 e0       	ldi	r23, 0x03	; 3
     ec8:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     ecc:	66 e0       	ldi	r22, 0x06	; 6
     ece:	c8 01       	movw	r24, r16
     ed0:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     ed4:	6a e0       	ldi	r22, 0x0A	; 10
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	9f 81       	ldd	r25, Y+7	; 0x07
     eda:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     ede:	8c 01       	movw	r16, r24
     ee0:	61 e1       	ldi	r22, 0x11	; 17
     ee2:	73 e0       	ldi	r23, 0x03	; 3
     ee4:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     ee8:	66 e0       	ldi	r22, 0x06	; 6
     eea:	c8 01       	movw	r24, r16
     eec:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     ef0:	6a e0       	ldi	r22, 0x0A	; 10
     ef2:	8e 81       	ldd	r24, Y+6	; 0x06
     ef4:	9f 81       	ldd	r25, Y+7	; 0x07
     ef6:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     efa:	8c 01       	movw	r16, r24
     efc:	66 ef       	ldi	r22, 0xF6	; 246
     efe:	72 e0       	ldi	r23, 0x02	; 2
     f00:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     f04:	66 e0       	ldi	r22, 0x06	; 6
     f06:	c8 01       	movw	r24, r16
     f08:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     f0c:	6a e0       	ldi	r22, 0x0A	; 10
     f0e:	8e 81       	ldd	r24, Y+6	; 0x06
     f10:	9f 81       	ldd	r25, Y+7	; 0x07
     f12:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     f16:	ec 01       	movw	r28, r24
     f18:	67 ee       	ldi	r22, 0xE7	; 231
     f1a:	72 e0       	ldi	r23, 0x02	; 2
     f1c:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     f20:	66 e0       	ldi	r22, 0x06	; 6
     f22:	ce 01       	movw	r24, r28
     f24:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
}
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	1f 91       	pop	r17
     f2e:	0f 91       	pop	r16
     f30:	08 95       	ret

00000f32 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     f32:	af 92       	push	r10
     f34:	bf 92       	push	r11
     f36:	cf 92       	push	r12
     f38:	df 92       	push	r13
     f3a:	ef 92       	push	r14
     f3c:	ff 92       	push	r15
     f3e:	0f 93       	push	r16
     f40:	1f 93       	push	r17
     f42:	cf 93       	push	r28
     f44:	df 93       	push	r29
     f46:	00 d0       	rcall	.+0      	; 0xf48 <_ZN9task_user11show_statusEv+0x16>
     f48:	00 d0       	rcall	.+0      	; 0xf4a <_ZN9task_user11show_statusEv+0x18>
     f4a:	cd b7       	in	r28, 0x3d	; 61
     f4c:	de b7       	in	r29, 0x3e	; 62
     f4e:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f50:	19 82       	std	Y+1, r1	; 0x01
     f52:	1a 82       	std	Y+2, r1	; 0x02
     f54:	1b 82       	std	Y+3, r1	; 0x03
     f56:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f58:	1d 82       	std	Y+5, r1	; 0x05
     f5a:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f5c:	0e 94 1e 0a 	call	0x143c	; 0x143c <xPortGetFreeHeapSize>
     f60:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f62:	ce 01       	movw	r24, r28
     f64:	01 96       	adiw	r24, 0x01	; 1
     f66:	0e 94 57 18 	call	0x30ae	; 0x30ae <_ZN10time_stamp10set_to_nowEv>
     f6a:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f6c:	66 e0       	ldi	r22, 0x06	; 6
     f6e:	f8 01       	movw	r30, r16
     f70:	86 81       	ldd	r24, Z+6	; 0x06
     f72:	97 81       	ldd	r25, Z+7	; 0x07
     f74:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     f78:	6a e0       	ldi	r22, 0x0A	; 10
     f7a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     f7e:	7c 01       	movw	r14, r24
     f80:	68 ec       	ldi	r22, 0xC8	; 200
     f82:	72 e0       	ldi	r23, 0x02	; 2
     f84:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     f88:	6a e0       	ldi	r22, 0x0A	; 10
     f8a:	c7 01       	movw	r24, r14
     f8c:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     f90:	7c 01       	movw	r14, r24
     f92:	6c eb       	ldi	r22, 0xBC	; 188
     f94:	72 e0       	ldi	r23, 0x02	; 2
     f96:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     f9a:	66 e0       	ldi	r22, 0x06	; 6
     f9c:	c7 01       	movw	r24, r14
     f9e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     fa2:	6a e0       	ldi	r22, 0x0A	; 10
     fa4:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     fa8:	7c 01       	movw	r14, r24
     faa:	65 eb       	ldi	r22, 0xB5	; 181
     fac:	72 e0       	ldi	r23, 0x02	; 2
     fae:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     fb2:	b5 01       	movw	r22, r10
     fb4:	c7 01       	movw	r24, r14
     fb6:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     fba:	6a e0       	ldi	r22, 0x0A	; 10
     fbc:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     fc0:	7c 01       	movw	r14, r24
     fc2:	67 ea       	ldi	r22, 0xA7	; 167
     fc4:	72 e0       	ldi	r23, 0x02	; 2
     fc6:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
     fca:	b6 01       	movw	r22, r12
     fcc:	c7 01       	movw	r24, r14
     fce:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <_ZN8emstreamlsEj>
     fd2:	6a e0       	ldi	r22, 0x0A	; 10
     fd4:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
     fd8:	7c 01       	movw	r14, r24
     fda:	65 ea       	ldi	r22, 0xA5	; 165
     fdc:	72 e0       	ldi	r23, 0x02	; 2
     fde:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     fe2:	4f ef       	ldi	r20, 0xFF	; 255
     fe4:	5f e0       	ldi	r21, 0x0F	; 15
     fe6:	60 e0       	ldi	r22, 0x00	; 0
     fe8:	70 e0       	ldi	r23, 0x00	; 0
     fea:	c7 01       	movw	r24, r14
     fec:	0e 94 af 1a 	call	0x355e	; 0x355e <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     ff0:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     ff4:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     ff8:	6a e0       	ldi	r22, 0x0A	; 10
     ffa:	f8 01       	movw	r30, r16
     ffc:	86 81       	ldd	r24, Z+6	; 0x06
     ffe:	97 81       	ldd	r25, Z+7	; 0x07
    1000:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    1004:	7c 01       	movw	r14, r24
    1006:	6a e9       	ldi	r22, 0x9A	; 154
    1008:	72 e0       	ldi	r23, 0x02	; 2
    100a:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    100e:	b6 01       	movw	r22, r12
    1010:	c7 01       	movw	r24, r14
    1012:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <_ZN8emstreamlsEj>
    1016:	66 e0       	ldi	r22, 0x06	; 6
    1018:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    101c:	66 e0       	ldi	r22, 0x06	; 6
    101e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1022:	f8 01       	movw	r30, r16
    1024:	86 81       	ldd	r24, Z+6	; 0x06
    1026:	97 81       	ldd	r25, Z+7	; 0x07
    1028:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <_Z15print_task_listP8emstream>
}
    102c:	26 96       	adiw	r28, 0x06	; 6
    102e:	cd bf       	out	0x3d, r28	; 61
    1030:	de bf       	out	0x3e, r29	; 62
    1032:	df 91       	pop	r29
    1034:	cf 91       	pop	r28
    1036:	1f 91       	pop	r17
    1038:	0f 91       	pop	r16
    103a:	ff 90       	pop	r15
    103c:	ef 90       	pop	r14
    103e:	df 90       	pop	r13
    1040:	cf 90       	pop	r12
    1042:	bf 90       	pop	r11
    1044:	af 90       	pop	r10
    1046:	08 95       	ret

00001048 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1048:	cf 93       	push	r28
    104a:	df 93       	push	r29
    104c:	00 d0       	rcall	.+0      	; 0x104e <_ZN9task_user3runEv+0x6>
    104e:	00 d0       	rcall	.+0      	; 0x1050 <_ZN9task_user3runEv+0x8>
    1050:	cd b7       	in	r28, 0x3d	; 61
    1052:	de b7       	in	r29, 0x3e	; 62
    1054:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1056:	19 82       	std	Y+1, r1	; 0x01
    1058:	1a 82       	std	Y+2, r1	; 0x02
    105a:	1b 82       	std	Y+3, r1	; 0x03
    105c:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    105e:	1d 82       	std	Y+5, r1	; 0x05
    1060:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1062:	6a e0       	ldi	r22, 0x0A	; 10
    1064:	dc 01       	movw	r26, r24
    1066:	16 96       	adiw	r26, 0x06	; 6
    1068:	8d 91       	ld	r24, X+
    106a:	9c 91       	ld	r25, X
    106c:	17 97       	sbiw	r26, 0x07	; 7
    106e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    1072:	7c 01       	movw	r14, r24
    1074:	66 e3       	ldi	r22, 0x36	; 54
    1076:	74 e0       	ldi	r23, 0x04	; 4
    1078:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    107c:	66 e0       	ldi	r22, 0x06	; 6
    107e:	c7 01       	movw	r24, r14
    1080:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1084:	f8 01       	movw	r30, r16
    1086:	84 85       	ldd	r24, Z+12	; 0x0c
    1088:	88 23       	and	r24, r24
    108a:	21 f0       	breq	.+8      	; 0x1094 <_ZN9task_user3runEv+0x4c>
    108c:	81 30       	cpi	r24, 0x01	; 1
    108e:	09 f4       	brne	.+2      	; 0x1092 <_ZN9task_user3runEv+0x4a>
    1090:	5d c0       	rjmp	.+186    	; 0x114c <_ZN9task_user3runEv+0x104>
    1092:	d8 c0       	rjmp	.+432    	; 0x1244 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1094:	86 81       	ldd	r24, Z+6	; 0x06
    1096:	97 81       	ldd	r25, Z+7	; 0x07
    1098:	dc 01       	movw	r26, r24
    109a:	ed 91       	ld	r30, X+
    109c:	fc 91       	ld	r31, X
    109e:	04 80       	ldd	r0, Z+4	; 0x04
    10a0:	f5 81       	ldd	r31, Z+5	; 0x05
    10a2:	e0 2d       	mov	r30, r0
    10a4:	19 95       	eicall
    10a6:	88 23       	and	r24, r24
    10a8:	a9 f1       	breq	.+106    	; 0x1114 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    10aa:	f8 01       	movw	r30, r16
    10ac:	86 81       	ldd	r24, Z+6	; 0x06
    10ae:	97 81       	ldd	r25, Z+7	; 0x07
    10b0:	dc 01       	movw	r26, r24
    10b2:	ed 91       	ld	r30, X+
    10b4:	fc 91       	ld	r31, X
    10b6:	06 80       	ldd	r0, Z+6	; 0x06
    10b8:	f7 81       	ldd	r31, Z+7	; 0x07
    10ba:	e0 2d       	mov	r30, r0
    10bc:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    10be:	99 27       	eor	r25, r25
    10c0:	81 30       	cpi	r24, 0x01	; 1
    10c2:	91 05       	cpc	r25, r1
    10c4:	f9 f0       	breq	.+62     	; 0x1104 <_ZN9task_user3runEv+0xbc>
    10c6:	03 97       	sbiw	r24, 0x03	; 3
    10c8:	09 f0       	breq	.+2      	; 0x10cc <_ZN9task_user3runEv+0x84>
    10ca:	d8 c0       	rjmp	.+432    	; 0x127c <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    10cc:	6a e0       	ldi	r22, 0x0A	; 10
    10ce:	f8 01       	movw	r30, r16
    10d0:	86 81       	ldd	r24, Z+6	; 0x06
    10d2:	97 81       	ldd	r25, Z+7	; 0x07
    10d4:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    10d8:	8c 01       	movw	r16, r24
    10da:	68 e2       	ldi	r22, 0x28	; 40
    10dc:	74 e0       	ldi	r23, 0x04	; 4
    10de:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    10e2:	66 e0       	ldi	r22, 0x06	; 6
    10e4:	c8 01       	movw	r24, r16
    10e6:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10ea:	93 e0       	ldi	r25, 0x03	; 3
    10ec:	88 ed       	ldi	r24, 0xD8	; 216
    10ee:	08 b6       	in	r0, 0x38	; 56
    10f0:	18 be       	out	0x38, r1	; 56
    10f2:	84 bf       	out	0x34, r24	; 52
    10f4:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10f8:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10fc:	81 fd       	sbrc	r24, 1
    10fe:	fc cf       	rjmp	.-8      	; 0x10f8 <_ZN9task_user3runEv+0xb0>
    1100:	08 be       	out	0x38, r0	; 56
    1102:	ff cf       	rjmp	.-2      	; 0x1102 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1104:	c8 01       	movw	r24, r16
    1106:	0e 94 f1 06 	call	0xde2	; 0xde2 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    110a:	61 e0       	ldi	r22, 0x01	; 1
    110c:	c8 01       	movw	r24, r16
    110e:	0e 94 a2 14 	call	0x2944	; 0x2944 <_ZN8frt_task13transition_toEh>
							break;
    1112:	b4 c0       	rjmp	.+360    	; 0x127c <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1114:	80 e5       	ldi	r24, 0x50	; 80
    1116:	91 e3       	ldi	r25, 0x31	; 49
    1118:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <_ZN14frt_text_queue14check_for_charEv>
    111c:	88 23       	and	r24, r24
    111e:	09 f4       	brne	.+2      	; 0x1122 <_ZN9task_user3runEv+0xda>
    1120:	ad c0       	rjmp	.+346    	; 0x127c <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1122:	d8 01       	movw	r26, r16
    1124:	16 96       	adiw	r26, 0x06	; 6
    1126:	ed 91       	ld	r30, X+
    1128:	fc 91       	ld	r31, X
    112a:	17 97       	sbiw	r26, 0x07	; 7
    112c:	01 90       	ld	r0, Z+
    112e:	f0 81       	ld	r31, Z
    1130:	e0 2d       	mov	r30, r0
    1132:	e2 80       	ldd	r14, Z+2	; 0x02
    1134:	f3 80       	ldd	r15, Z+3	; 0x03
    1136:	80 e5       	ldi	r24, 0x50	; 80
    1138:	91 e3       	ldi	r25, 0x31	; 49
    113a:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <_ZN14frt_text_queue7getcharEv>
    113e:	68 2f       	mov	r22, r24
    1140:	f8 01       	movw	r30, r16
    1142:	86 81       	ldd	r24, Z+6	; 0x06
    1144:	97 81       	ldd	r25, Z+7	; 0x07
    1146:	f7 01       	movw	r30, r14
    1148:	19 95       	eicall
    114a:	98 c0       	rjmp	.+304    	; 0x127c <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    114c:	86 81       	ldd	r24, Z+6	; 0x06
    114e:	97 81       	ldd	r25, Z+7	; 0x07
    1150:	dc 01       	movw	r26, r24
    1152:	ed 91       	ld	r30, X+
    1154:	fc 91       	ld	r31, X
    1156:	04 80       	ldd	r0, Z+4	; 0x04
    1158:	f5 81       	ldd	r31, Z+5	; 0x05
    115a:	e0 2d       	mov	r30, r0
    115c:	19 95       	eicall
    115e:	88 23       	and	r24, r24
    1160:	09 f4       	brne	.+2      	; 0x1164 <_ZN9task_user3runEv+0x11c>
    1162:	8c c0       	rjmp	.+280    	; 0x127c <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1164:	f8 01       	movw	r30, r16
    1166:	86 81       	ldd	r24, Z+6	; 0x06
    1168:	97 81       	ldd	r25, Z+7	; 0x07
    116a:	dc 01       	movw	r26, r24
    116c:	ed 91       	ld	r30, X+
    116e:	fc 91       	ld	r31, X
    1170:	06 80       	ldd	r0, Z+6	; 0x06
    1172:	f7 81       	ldd	r31, Z+7	; 0x07
    1174:	e0 2d       	mov	r30, r0
    1176:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1178:	9c 01       	movw	r18, r24
    117a:	33 27       	eor	r19, r19
    117c:	28 36       	cpi	r18, 0x68	; 104
    117e:	31 05       	cpc	r19, r1
    1180:	59 f1       	breq	.+86     	; 0x11d8 <_ZN9task_user3runEv+0x190>
    1182:	3c f4       	brge	.+14     	; 0x1192 <_ZN9task_user3runEv+0x14a>
    1184:	2b 31       	cpi	r18, 0x1B	; 27
    1186:	31 05       	cpc	r19, r1
    1188:	59 f1       	breq	.+86     	; 0x11e0 <_ZN9task_user3runEv+0x198>
    118a:	25 36       	cpi	r18, 0x65	; 101
    118c:	31 05       	cpc	r19, r1
    118e:	41 f1       	breq	.+80     	; 0x11e0 <_ZN9task_user3runEv+0x198>
    1190:	3b c0       	rjmp	.+118    	; 0x1208 <_ZN9task_user3runEv+0x1c0>
    1192:	23 37       	cpi	r18, 0x73	; 115
    1194:	31 05       	cpc	r19, r1
    1196:	c1 f0       	breq	.+48     	; 0x11c8 <_ZN9task_user3runEv+0x180>
    1198:	26 37       	cpi	r18, 0x76	; 118
    119a:	31 05       	cpc	r19, r1
    119c:	89 f0       	breq	.+34     	; 0x11c0 <_ZN9task_user3runEv+0x178>
    119e:	2e 36       	cpi	r18, 0x6E	; 110
    11a0:	31 05       	cpc	r19, r1
    11a2:	91 f5       	brne	.+100    	; 0x1208 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    11a4:	ce 01       	movw	r24, r28
    11a6:	01 96       	adiw	r24, 0x01	; 1
    11a8:	0e 94 57 18 	call	0x30ae	; 0x30ae <_ZN10time_stamp10set_to_nowEv>
    11ac:	bc 01       	movw	r22, r24
    11ae:	f8 01       	movw	r30, r16
    11b0:	86 81       	ldd	r24, Z+6	; 0x06
    11b2:	97 81       	ldd	r25, Z+7	; 0x07
    11b4:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <_ZlsR8emstreamR10time_stamp>
    11b8:	66 e0       	ldi	r22, 0x06	; 6
    11ba:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
							break;
    11be:	5e c0       	rjmp	.+188    	; 0x127c <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    11c0:	c8 01       	movw	r24, r16
    11c2:	0e 94 99 07 	call	0xf32	; 0xf32 <_ZN9task_user11show_statusEv>
							break;
    11c6:	5a c0       	rjmp	.+180    	; 0x127c <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    11c8:	d8 01       	movw	r26, r16
    11ca:	16 96       	adiw	r26, 0x06	; 6
    11cc:	8d 91       	ld	r24, X+
    11ce:	9c 91       	ld	r25, X
    11d0:	17 97       	sbiw	r26, 0x07	; 7
    11d2:	0e 94 bb 15 	call	0x2b76	; 0x2b76 <_Z17print_task_stacksP8emstream>
							break;
    11d6:	52 c0       	rjmp	.+164    	; 0x127c <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    11d8:	c8 01       	movw	r24, r16
    11da:	0e 94 f1 06 	call	0xde2	; 0xde2 <_ZN9task_user18print_help_messageEv>
							break;
    11de:	4e c0       	rjmp	.+156    	; 0x127c <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    11e0:	6a e0       	ldi	r22, 0x0A	; 10
    11e2:	f8 01       	movw	r30, r16
    11e4:	86 81       	ldd	r24, Z+6	; 0x06
    11e6:	97 81       	ldd	r25, Z+7	; 0x07
    11e8:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    11ec:	7c 01       	movw	r14, r24
    11ee:	66 e1       	ldi	r22, 0x16	; 22
    11f0:	74 e0       	ldi	r23, 0x04	; 4
    11f2:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    11f6:	66 e0       	ldi	r22, 0x06	; 6
    11f8:	c7 01       	movw	r24, r14
    11fa:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11fe:	60 e0       	ldi	r22, 0x00	; 0
    1200:	c8 01       	movw	r24, r16
    1202:	0e 94 a2 14 	call	0x2944	; 0x2944 <_ZN8frt_task13transition_toEh>
							break;
    1206:	3a c0       	rjmp	.+116    	; 0x127c <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1208:	f8 01       	movw	r30, r16
    120a:	a6 81       	ldd	r26, Z+6	; 0x06
    120c:	b7 81       	ldd	r27, Z+7	; 0x07
    120e:	ed 91       	ld	r30, X+
    1210:	fc 91       	ld	r31, X
    1212:	11 97       	sbiw	r26, 0x01	; 1
    1214:	02 80       	ldd	r0, Z+2	; 0x02
    1216:	f3 81       	ldd	r31, Z+3	; 0x03
    1218:	e0 2d       	mov	r30, r0
    121a:	68 2f       	mov	r22, r24
    121c:	cd 01       	movw	r24, r26
    121e:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1220:	6a e0       	ldi	r22, 0x0A	; 10
    1222:	d8 01       	movw	r26, r16
    1224:	16 96       	adiw	r26, 0x06	; 6
    1226:	8d 91       	ld	r24, X+
    1228:	9c 91       	ld	r25, X
    122a:	17 97       	sbiw	r26, 0x07	; 7
    122c:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    1230:	7c 01       	movw	r14, r24
    1232:	60 e1       	ldi	r22, 0x10	; 16
    1234:	74 e0       	ldi	r23, 0x04	; 4
    1236:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    123a:	66 e0       	ldi	r22, 0x06	; 6
    123c:	c7 01       	movw	r24, r14
    123e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1242:	1c c0       	rjmp	.+56     	; 0x127c <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1244:	6a e0       	ldi	r22, 0x0A	; 10
    1246:	f8 01       	movw	r30, r16
    1248:	86 81       	ldd	r24, Z+6	; 0x06
    124a:	97 81       	ldd	r25, Z+7	; 0x07
    124c:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    1250:	8c 01       	movw	r16, r24
    1252:	63 ef       	ldi	r22, 0xF3	; 243
    1254:	73 e0       	ldi	r23, 0x03	; 3
    1256:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    125a:	66 e0       	ldi	r22, 0x06	; 6
    125c:	c8 01       	movw	r24, r16
    125e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1262:	93 e0       	ldi	r25, 0x03	; 3
    1264:	88 ed       	ldi	r24, 0xD8	; 216
    1266:	08 b6       	in	r0, 0x38	; 56
    1268:	18 be       	out	0x38, r1	; 56
    126a:	84 bf       	out	0x34, r24	; 52
    126c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1270:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1274:	81 fd       	sbrc	r24, 1
    1276:	fc cf       	rjmp	.-8      	; 0x1270 <_ZN9task_user3runEv+0x228>
    1278:	08 be       	out	0x38, r0	; 56
    127a:	ff cf       	rjmp	.-2      	; 0x127a <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    127c:	f8 01       	movw	r30, r16
    127e:	86 85       	ldd	r24, Z+14	; 0x0e
    1280:	97 85       	ldd	r25, Z+15	; 0x0f
    1282:	a0 89       	ldd	r26, Z+16	; 0x10
    1284:	b1 89       	ldd	r27, Z+17	; 0x11
    1286:	01 96       	adiw	r24, 0x01	; 1
    1288:	a1 1d       	adc	r26, r1
    128a:	b1 1d       	adc	r27, r1
    128c:	86 87       	std	Z+14, r24	; 0x0e
    128e:	97 87       	std	Z+15, r25	; 0x0f
    1290:	a0 8b       	std	Z+16, r26	; 0x10
    1292:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1294:	61 e0       	ldi	r22, 0x01	; 1
    1296:	70 e0       	ldi	r23, 0x00	; 0
    1298:	80 e0       	ldi	r24, 0x00	; 0
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	0e 94 76 12 	call	0x24ec	; 0x24ec <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    12a0:	f1 ce       	rjmp	.-542    	; 0x1084 <_ZN9task_user3runEv+0x3c>

000012a2 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    12a2:	0f 93       	push	r16
    12a4:	1f 93       	push	r17
    12a6:	cf 93       	push	r28
    12a8:	df 93       	push	r29
    12aa:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    12ac:	0e 94 65 10 	call	0x20ca	; 0x20ca <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    12b0:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    12b4:	81 11       	cpse	r24, r1
    12b6:	1d c0       	rjmp	.+58     	; 0x12f2 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    12b8:	a1 ec       	ldi	r26, 0xC1	; 193
    12ba:	b0 e2       	ldi	r27, 0x20	; 32
    12bc:	e5 ec       	ldi	r30, 0xC5	; 197
    12be:	f0 e2       	ldi	r31, 0x20	; 32
    12c0:	ed 93       	st	X+, r30
    12c2:	fc 93       	st	X, r31
    12c4:	11 97       	sbiw	r26, 0x01	; 1
    12c6:	12 96       	adiw	r26, 0x02	; 2
    12c8:	1d 92       	st	X+, r1
    12ca:	1c 92       	st	X, r1
    12cc:	13 97       	sbiw	r26, 0x03	; 3
    12ce:	ad eb       	ldi	r26, 0xBD	; 189
    12d0:	b0 e2       	ldi	r27, 0x20	; 32
    12d2:	8f ef       	ldi	r24, 0xFF	; 255
    12d4:	9f e0       	ldi	r25, 0x0F	; 15
    12d6:	12 96       	adiw	r26, 0x02	; 2
    12d8:	8d 93       	st	X+, r24
    12da:	9c 93       	st	X, r25
    12dc:	13 97       	sbiw	r26, 0x03	; 3
    12de:	1d 92       	st	X+, r1
    12e0:	1c 92       	st	X, r1
    12e2:	11 97       	sbiw	r26, 0x01	; 1
    12e4:	82 83       	std	Z+2, r24	; 0x02
    12e6:	93 83       	std	Z+3, r25	; 0x03
    12e8:	a0 83       	st	Z, r26
    12ea:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    12ec:	81 e0       	ldi	r24, 0x01	; 1
    12ee:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12f2:	20 97       	sbiw	r28, 0x00	; 0
    12f4:	09 f4       	brne	.+2      	; 0x12f8 <pvPortMalloc+0x56>
    12f6:	5f c0       	rjmp	.+190    	; 0x13b6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12f8:	9e 01       	movw	r18, r28
    12fa:	2b 5f       	subi	r18, 0xFB	; 251
    12fc:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    12fe:	24 96       	adiw	r28, 0x04	; 4
    1300:	ce 3f       	cpi	r28, 0xFE	; 254
    1302:	df 40       	sbci	r29, 0x0F	; 15
    1304:	08 f0       	brcs	.+2      	; 0x1308 <pvPortMalloc+0x66>
    1306:	5a c0       	rjmp	.+180    	; 0x13bc <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1308:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    130c:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1310:	a1 ec       	ldi	r26, 0xC1	; 193
    1312:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1314:	02 c0       	rjmp	.+4      	; 0x131a <pvPortMalloc+0x78>
    1316:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1318:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    131a:	82 81       	ldd	r24, Z+2	; 0x02
    131c:	93 81       	ldd	r25, Z+3	; 0x03
    131e:	82 17       	cp	r24, r18
    1320:	93 07       	cpc	r25, r19
    1322:	20 f4       	brcc	.+8      	; 0x132c <pvPortMalloc+0x8a>
    1324:	80 81       	ld	r24, Z
    1326:	91 81       	ldd	r25, Z+1	; 0x01
    1328:	00 97       	sbiw	r24, 0x00	; 0
    132a:	a9 f7       	brne	.-22     	; 0x1316 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    132c:	c0 e2       	ldi	r28, 0x20	; 32
    132e:	ed 3b       	cpi	r30, 0xBD	; 189
    1330:	fc 07       	cpc	r31, r28
    1332:	09 f4       	brne	.+2      	; 0x1336 <pvPortMalloc+0x94>
    1334:	46 c0       	rjmp	.+140    	; 0x13c2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1336:	cd 91       	ld	r28, X+
    1338:	dc 91       	ld	r29, X
    133a:	11 97       	sbiw	r26, 0x01	; 1
    133c:	8e 01       	movw	r16, r28
    133e:	0b 5f       	subi	r16, 0xFB	; 251
    1340:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1342:	80 81       	ld	r24, Z
    1344:	91 81       	ldd	r25, Z+1	; 0x01
    1346:	8d 93       	st	X+, r24
    1348:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    134a:	82 81       	ldd	r24, Z+2	; 0x02
    134c:	93 81       	ldd	r25, Z+3	; 0x03
    134e:	82 1b       	sub	r24, r18
    1350:	93 0b       	sbc	r25, r19
    1352:	8b 30       	cpi	r24, 0x0B	; 11
    1354:	91 05       	cpc	r25, r1
    1356:	10 f1       	brcs	.+68     	; 0x139c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1358:	bf 01       	movw	r22, r30
    135a:	62 0f       	add	r22, r18
    135c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    135e:	db 01       	movw	r26, r22
    1360:	12 96       	adiw	r26, 0x02	; 2
    1362:	8d 93       	st	X+, r24
    1364:	9c 93       	st	X, r25
    1366:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1368:	22 83       	std	Z+2, r18	; 0x02
    136a:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    136c:	12 96       	adiw	r26, 0x02	; 2
    136e:	4d 91       	ld	r20, X+
    1370:	5c 91       	ld	r21, X
    1372:	13 97       	sbiw	r26, 0x03	; 3
    1374:	81 ec       	ldi	r24, 0xC1	; 193
    1376:	90 e2       	ldi	r25, 0x20	; 32
    1378:	01 c0       	rjmp	.+2      	; 0x137c <pvPortMalloc+0xda>
    137a:	cd 01       	movw	r24, r26
    137c:	ec 01       	movw	r28, r24
    137e:	a8 81       	ld	r26, Y
    1380:	b9 81       	ldd	r27, Y+1	; 0x01
    1382:	12 96       	adiw	r26, 0x02	; 2
    1384:	2d 91       	ld	r18, X+
    1386:	3c 91       	ld	r19, X
    1388:	13 97       	sbiw	r26, 0x03	; 3
    138a:	24 17       	cp	r18, r20
    138c:	35 07       	cpc	r19, r21
    138e:	a8 f3       	brcs	.-22     	; 0x137a <pvPortMalloc+0xd8>
    1390:	eb 01       	movw	r28, r22
    1392:	a8 83       	st	Y, r26
    1394:	b9 83       	std	Y+1, r27	; 0x01
    1396:	dc 01       	movw	r26, r24
    1398:	6d 93       	st	X+, r22
    139a:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    139c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    13a0:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    13a4:	22 81       	ldd	r18, Z+2	; 0x02
    13a6:	33 81       	ldd	r19, Z+3	; 0x03
    13a8:	82 1b       	sub	r24, r18
    13aa:	93 0b       	sbc	r25, r19
    13ac:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    13b0:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    13b4:	08 c0       	rjmp	.+16     	; 0x13c6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    13b6:	00 e0       	ldi	r16, 0x00	; 0
    13b8:	10 e0       	ldi	r17, 0x00	; 0
    13ba:	05 c0       	rjmp	.+10     	; 0x13c6 <pvPortMalloc+0x124>
    13bc:	00 e0       	ldi	r16, 0x00	; 0
    13be:	10 e0       	ldi	r17, 0x00	; 0
    13c0:	02 c0       	rjmp	.+4      	; 0x13c6 <pvPortMalloc+0x124>
    13c2:	00 e0       	ldi	r16, 0x00	; 0
    13c4:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    13c6:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    13ca:	c8 01       	movw	r24, r16
    13cc:	df 91       	pop	r29
    13ce:	cf 91       	pop	r28
    13d0:	1f 91       	pop	r17
    13d2:	0f 91       	pop	r16
    13d4:	08 95       	ret

000013d6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    13d6:	0f 93       	push	r16
    13d8:	1f 93       	push	r17
    13da:	cf 93       	push	r28
    13dc:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    13de:	00 97       	sbiw	r24, 0x00	; 0
    13e0:	41 f1       	breq	.+80     	; 0x1432 <vPortFree+0x5c>
    13e2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    13e4:	8c 01       	movw	r16, r24
    13e6:	05 50       	subi	r16, 0x05	; 5
    13e8:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    13ea:	0e 94 65 10 	call	0x20ca	; 0x20ca <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    13ee:	f8 01       	movw	r30, r16
    13f0:	42 81       	ldd	r20, Z+2	; 0x02
    13f2:	53 81       	ldd	r21, Z+3	; 0x03
    13f4:	a1 ec       	ldi	r26, 0xC1	; 193
    13f6:	b0 e2       	ldi	r27, 0x20	; 32
    13f8:	01 c0       	rjmp	.+2      	; 0x13fc <vPortFree+0x26>
    13fa:	df 01       	movw	r26, r30
    13fc:	ed 91       	ld	r30, X+
    13fe:	fc 91       	ld	r31, X
    1400:	11 97       	sbiw	r26, 0x01	; 1
    1402:	22 81       	ldd	r18, Z+2	; 0x02
    1404:	33 81       	ldd	r19, Z+3	; 0x03
    1406:	24 17       	cp	r18, r20
    1408:	35 07       	cpc	r19, r21
    140a:	b8 f3       	brcs	.-18     	; 0x13fa <vPortFree+0x24>
    140c:	25 97       	sbiw	r28, 0x05	; 5
    140e:	e8 83       	st	Y, r30
    1410:	f9 83       	std	Y+1, r31	; 0x01
    1412:	0d 93       	st	X+, r16
    1414:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1416:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    141a:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    141e:	8a 81       	ldd	r24, Y+2	; 0x02
    1420:	9b 81       	ldd	r25, Y+3	; 0x03
    1422:	82 0f       	add	r24, r18
    1424:	93 1f       	adc	r25, r19
    1426:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    142a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    142e:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
	}
}
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	1f 91       	pop	r17
    1438:	0f 91       	pop	r16
    143a:	08 95       	ret

0000143c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    143c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1440:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1444:	08 95       	ret

00001446 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1446:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1448:	03 96       	adiw	r24, 0x03	; 3
    144a:	81 83       	std	Z+1, r24	; 0x01
    144c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    144e:	4f ef       	ldi	r20, 0xFF	; 255
    1450:	5f ef       	ldi	r21, 0xFF	; 255
    1452:	ba 01       	movw	r22, r20
    1454:	43 83       	std	Z+3, r20	; 0x03
    1456:	54 83       	std	Z+4, r21	; 0x04
    1458:	65 83       	std	Z+5, r22	; 0x05
    145a:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    145c:	87 83       	std	Z+7, r24	; 0x07
    145e:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1460:	81 87       	std	Z+9, r24	; 0x09
    1462:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1464:	10 82       	st	Z, r1
    1466:	08 95       	ret

00001468 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1468:	fc 01       	movw	r30, r24
    146a:	12 86       	std	Z+10, r1	; 0x0a
    146c:	13 86       	std	Z+11, r1	; 0x0b
    146e:	08 95       	ret

00001470 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1470:	cf 93       	push	r28
    1472:	df 93       	push	r29
    1474:	fc 01       	movw	r30, r24
    1476:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1478:	21 81       	ldd	r18, Z+1	; 0x01
    147a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    147c:	e9 01       	movw	r28, r18
    147e:	8c 81       	ldd	r24, Y+4	; 0x04
    1480:	9d 81       	ldd	r25, Y+5	; 0x05
    1482:	14 96       	adiw	r26, 0x04	; 4
    1484:	8d 93       	st	X+, r24
    1486:	9c 93       	st	X, r25
    1488:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    148a:	81 81       	ldd	r24, Z+1	; 0x01
    148c:	92 81       	ldd	r25, Z+2	; 0x02
    148e:	16 96       	adiw	r26, 0x06	; 6
    1490:	8d 93       	st	X+, r24
    1492:	9c 93       	st	X, r25
    1494:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1496:	8c 81       	ldd	r24, Y+4	; 0x04
    1498:	9d 81       	ldd	r25, Y+5	; 0x05
    149a:	ec 01       	movw	r28, r24
    149c:	6e 83       	std	Y+6, r22	; 0x06
    149e:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    14a0:	e9 01       	movw	r28, r18
    14a2:	6c 83       	std	Y+4, r22	; 0x04
    14a4:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    14a6:	61 83       	std	Z+1, r22	; 0x01
    14a8:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14aa:	1a 96       	adiw	r26, 0x0a	; 10
    14ac:	ed 93       	st	X+, r30
    14ae:	fc 93       	st	X, r31
    14b0:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    14b2:	80 81       	ld	r24, Z
    14b4:	8f 5f       	subi	r24, 0xFF	; 255
    14b6:	80 83       	st	Z, r24
}
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	08 95       	ret

000014be <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    14be:	0f 93       	push	r16
    14c0:	1f 93       	push	r17
    14c2:	cf 93       	push	r28
    14c4:	df 93       	push	r29
    14c6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    14c8:	08 81       	ld	r16, Y
    14ca:	19 81       	ldd	r17, Y+1	; 0x01
    14cc:	2a 81       	ldd	r18, Y+2	; 0x02
    14ce:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14d0:	0f 3f       	cpi	r16, 0xFF	; 255
    14d2:	4f ef       	ldi	r20, 0xFF	; 255
    14d4:	14 07       	cpc	r17, r20
    14d6:	24 07       	cpc	r18, r20
    14d8:	34 07       	cpc	r19, r20
    14da:	31 f4       	brne	.+12     	; 0x14e8 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14dc:	dc 01       	movw	r26, r24
    14de:	19 96       	adiw	r26, 0x09	; 9
    14e0:	ed 91       	ld	r30, X+
    14e2:	fc 91       	ld	r31, X
    14e4:	1a 97       	sbiw	r26, 0x0a	; 10
    14e6:	1f c0       	rjmp	.+62     	; 0x1526 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14e8:	fc 01       	movw	r30, r24
    14ea:	33 96       	adiw	r30, 0x03	; 3
    14ec:	dc 01       	movw	r26, r24
    14ee:	17 96       	adiw	r26, 0x07	; 7
    14f0:	4d 91       	ld	r20, X+
    14f2:	5c 91       	ld	r21, X
    14f4:	18 97       	sbiw	r26, 0x08	; 8
    14f6:	da 01       	movw	r26, r20
    14f8:	4d 91       	ld	r20, X+
    14fa:	5d 91       	ld	r21, X+
    14fc:	6d 91       	ld	r22, X+
    14fe:	7c 91       	ld	r23, X
    1500:	04 17       	cp	r16, r20
    1502:	15 07       	cpc	r17, r21
    1504:	26 07       	cpc	r18, r22
    1506:	37 07       	cpc	r19, r23
    1508:	70 f0       	brcs	.+28     	; 0x1526 <vListInsert+0x68>
    150a:	04 80       	ldd	r0, Z+4	; 0x04
    150c:	f5 81       	ldd	r31, Z+5	; 0x05
    150e:	e0 2d       	mov	r30, r0
    1510:	a4 81       	ldd	r26, Z+4	; 0x04
    1512:	b5 81       	ldd	r27, Z+5	; 0x05
    1514:	4d 91       	ld	r20, X+
    1516:	5d 91       	ld	r21, X+
    1518:	6d 91       	ld	r22, X+
    151a:	7c 91       	ld	r23, X
    151c:	04 17       	cp	r16, r20
    151e:	15 07       	cpc	r17, r21
    1520:	26 07       	cpc	r18, r22
    1522:	37 07       	cpc	r19, r23
    1524:	90 f7       	brcc	.-28     	; 0x150a <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1526:	a4 81       	ldd	r26, Z+4	; 0x04
    1528:	b5 81       	ldd	r27, Z+5	; 0x05
    152a:	ac 83       	std	Y+4, r26	; 0x04
    152c:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    152e:	16 96       	adiw	r26, 0x06	; 6
    1530:	cd 93       	st	X+, r28
    1532:	dc 93       	st	X, r29
    1534:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1536:	ee 83       	std	Y+6, r30	; 0x06
    1538:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    153a:	c4 83       	std	Z+4, r28	; 0x04
    153c:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    153e:	8a 87       	std	Y+10, r24	; 0x0a
    1540:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1542:	fc 01       	movw	r30, r24
    1544:	20 81       	ld	r18, Z
    1546:	2f 5f       	subi	r18, 0xFF	; 255
    1548:	20 83       	st	Z, r18
}
    154a:	df 91       	pop	r29
    154c:	cf 91       	pop	r28
    154e:	1f 91       	pop	r17
    1550:	0f 91       	pop	r16
    1552:	08 95       	ret

00001554 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1554:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1556:	a4 81       	ldd	r26, Z+4	; 0x04
    1558:	b5 81       	ldd	r27, Z+5	; 0x05
    155a:	86 81       	ldd	r24, Z+6	; 0x06
    155c:	97 81       	ldd	r25, Z+7	; 0x07
    155e:	16 96       	adiw	r26, 0x06	; 6
    1560:	8d 93       	st	X+, r24
    1562:	9c 93       	st	X, r25
    1564:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1566:	a6 81       	ldd	r26, Z+6	; 0x06
    1568:	b7 81       	ldd	r27, Z+7	; 0x07
    156a:	84 81       	ldd	r24, Z+4	; 0x04
    156c:	95 81       	ldd	r25, Z+5	; 0x05
    156e:	14 96       	adiw	r26, 0x04	; 4
    1570:	8d 93       	st	X+, r24
    1572:	9c 93       	st	X, r25
    1574:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1576:	a2 85       	ldd	r26, Z+10	; 0x0a
    1578:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    157a:	11 96       	adiw	r26, 0x01	; 1
    157c:	8d 91       	ld	r24, X+
    157e:	9c 91       	ld	r25, X
    1580:	12 97       	sbiw	r26, 0x02	; 2
    1582:	e8 17       	cp	r30, r24
    1584:	f9 07       	cpc	r31, r25
    1586:	31 f4       	brne	.+12     	; 0x1594 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1588:	86 81       	ldd	r24, Z+6	; 0x06
    158a:	97 81       	ldd	r25, Z+7	; 0x07
    158c:	11 96       	adiw	r26, 0x01	; 1
    158e:	8d 93       	st	X+, r24
    1590:	9c 93       	st	X, r25
    1592:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1594:	12 86       	std	Z+10, r1	; 0x0a
    1596:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1598:	8c 91       	ld	r24, X
    159a:	81 50       	subi	r24, 0x01	; 1
    159c:	8c 93       	st	X, r24
    159e:	08 95       	ret

000015a0 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    15a0:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <portStackTopForTask>
    15a4:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <portStackTopForTask+0x1>
    15a8:	31 e1       	ldi	r19, 0x11	; 17
    15aa:	fc 01       	movw	r30, r24
    15ac:	30 83       	st	Z, r19
    15ae:	31 97       	sbiw	r30, 0x01	; 1
    15b0:	22 e2       	ldi	r18, 0x22	; 34
    15b2:	20 83       	st	Z, r18
    15b4:	31 97       	sbiw	r30, 0x01	; 1
    15b6:	a3 e3       	ldi	r26, 0x33	; 51
    15b8:	a0 83       	st	Z, r26
    15ba:	31 97       	sbiw	r30, 0x01	; 1
    15bc:	60 83       	st	Z, r22
    15be:	31 97       	sbiw	r30, 0x01	; 1
    15c0:	70 83       	st	Z, r23
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	10 82       	st	Z, r1
    15c6:	31 97       	sbiw	r30, 0x01	; 1
    15c8:	10 82       	st	Z, r1
    15ca:	31 97       	sbiw	r30, 0x01	; 1
    15cc:	60 e8       	ldi	r22, 0x80	; 128
    15ce:	60 83       	st	Z, r22
    15d0:	31 97       	sbiw	r30, 0x01	; 1
    15d2:	10 82       	st	Z, r1
    15d4:	31 97       	sbiw	r30, 0x01	; 1
    15d6:	10 82       	st	Z, r1
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	10 82       	st	Z, r1
    15dc:	31 97       	sbiw	r30, 0x01	; 1
    15de:	62 e0       	ldi	r22, 0x02	; 2
    15e0:	60 83       	st	Z, r22
    15e2:	31 97       	sbiw	r30, 0x01	; 1
    15e4:	63 e0       	ldi	r22, 0x03	; 3
    15e6:	60 83       	st	Z, r22
    15e8:	31 97       	sbiw	r30, 0x01	; 1
    15ea:	64 e0       	ldi	r22, 0x04	; 4
    15ec:	60 83       	st	Z, r22
    15ee:	31 97       	sbiw	r30, 0x01	; 1
    15f0:	65 e0       	ldi	r22, 0x05	; 5
    15f2:	60 83       	st	Z, r22
    15f4:	31 97       	sbiw	r30, 0x01	; 1
    15f6:	66 e0       	ldi	r22, 0x06	; 6
    15f8:	60 83       	st	Z, r22
    15fa:	31 97       	sbiw	r30, 0x01	; 1
    15fc:	67 e0       	ldi	r22, 0x07	; 7
    15fe:	60 83       	st	Z, r22
    1600:	31 97       	sbiw	r30, 0x01	; 1
    1602:	68 e0       	ldi	r22, 0x08	; 8
    1604:	60 83       	st	Z, r22
    1606:	31 97       	sbiw	r30, 0x01	; 1
    1608:	69 e0       	ldi	r22, 0x09	; 9
    160a:	60 83       	st	Z, r22
    160c:	31 97       	sbiw	r30, 0x01	; 1
    160e:	60 e1       	ldi	r22, 0x10	; 16
    1610:	60 83       	st	Z, r22
    1612:	31 97       	sbiw	r30, 0x01	; 1
    1614:	30 83       	st	Z, r19
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	32 e1       	ldi	r19, 0x12	; 18
    161a:	30 83       	st	Z, r19
    161c:	31 97       	sbiw	r30, 0x01	; 1
    161e:	33 e1       	ldi	r19, 0x13	; 19
    1620:	30 83       	st	Z, r19
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	34 e1       	ldi	r19, 0x14	; 20
    1626:	30 83       	st	Z, r19
    1628:	31 97       	sbiw	r30, 0x01	; 1
    162a:	35 e1       	ldi	r19, 0x15	; 21
    162c:	30 83       	st	Z, r19
    162e:	31 97       	sbiw	r30, 0x01	; 1
    1630:	36 e1       	ldi	r19, 0x16	; 22
    1632:	30 83       	st	Z, r19
    1634:	31 97       	sbiw	r30, 0x01	; 1
    1636:	37 e1       	ldi	r19, 0x17	; 23
    1638:	30 83       	st	Z, r19
    163a:	31 97       	sbiw	r30, 0x01	; 1
    163c:	38 e1       	ldi	r19, 0x18	; 24
    163e:	30 83       	st	Z, r19
    1640:	31 97       	sbiw	r30, 0x01	; 1
    1642:	39 e1       	ldi	r19, 0x19	; 25
    1644:	30 83       	st	Z, r19
    1646:	31 97       	sbiw	r30, 0x01	; 1
    1648:	30 e2       	ldi	r19, 0x20	; 32
    164a:	30 83       	st	Z, r19
    164c:	31 97       	sbiw	r30, 0x01	; 1
    164e:	31 e2       	ldi	r19, 0x21	; 33
    1650:	30 83       	st	Z, r19
    1652:	31 97       	sbiw	r30, 0x01	; 1
    1654:	20 83       	st	Z, r18
    1656:	31 97       	sbiw	r30, 0x01	; 1
    1658:	23 e2       	ldi	r18, 0x23	; 35
    165a:	20 83       	st	Z, r18
    165c:	31 97       	sbiw	r30, 0x01	; 1
    165e:	40 83       	st	Z, r20
    1660:	31 97       	sbiw	r30, 0x01	; 1
    1662:	50 83       	st	Z, r21
    1664:	31 97       	sbiw	r30, 0x01	; 1
    1666:	26 e2       	ldi	r18, 0x26	; 38
    1668:	20 83       	st	Z, r18
    166a:	31 97       	sbiw	r30, 0x01	; 1
    166c:	27 e2       	ldi	r18, 0x27	; 39
    166e:	20 83       	st	Z, r18
    1670:	31 97       	sbiw	r30, 0x01	; 1
    1672:	28 e2       	ldi	r18, 0x28	; 40
    1674:	20 83       	st	Z, r18
    1676:	31 97       	sbiw	r30, 0x01	; 1
    1678:	29 e2       	ldi	r18, 0x29	; 41
    167a:	20 83       	st	Z, r18
    167c:	31 97       	sbiw	r30, 0x01	; 1
    167e:	20 e3       	ldi	r18, 0x30	; 48
    1680:	20 83       	st	Z, r18
    1682:	31 97       	sbiw	r30, 0x01	; 1
    1684:	21 e3       	ldi	r18, 0x31	; 49
    1686:	20 83       	st	Z, r18
    1688:	89 97       	sbiw	r24, 0x29	; 41
    168a:	08 95       	ret

0000168c <xPortStartScheduler>:
    168c:	8c e7       	ldi	r24, 0x7C	; 124
    168e:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1692:	8f ef       	ldi	r24, 0xFF	; 255
    1694:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1698:	81 e0       	ldi	r24, 0x01	; 1
    169a:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    169e:	91 e1       	ldi	r25, 0x11	; 17
    16a0:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    16a4:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    16a8:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    16ac:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    16b0:	cd 91       	ld	r28, X+
    16b2:	cd bf       	out	0x3d, r28	; 61
    16b4:	dd 91       	ld	r29, X+
    16b6:	de bf       	out	0x3e, r29	; 62
    16b8:	ff 91       	pop	r31
    16ba:	ef 91       	pop	r30
    16bc:	df 91       	pop	r29
    16be:	cf 91       	pop	r28
    16c0:	bf 91       	pop	r27
    16c2:	af 91       	pop	r26
    16c4:	9f 91       	pop	r25
    16c6:	8f 91       	pop	r24
    16c8:	7f 91       	pop	r23
    16ca:	6f 91       	pop	r22
    16cc:	5f 91       	pop	r21
    16ce:	4f 91       	pop	r20
    16d0:	3f 91       	pop	r19
    16d2:	2f 91       	pop	r18
    16d4:	1f 91       	pop	r17
    16d6:	0f 91       	pop	r16
    16d8:	ff 90       	pop	r15
    16da:	ef 90       	pop	r14
    16dc:	df 90       	pop	r13
    16de:	cf 90       	pop	r12
    16e0:	bf 90       	pop	r11
    16e2:	af 90       	pop	r10
    16e4:	9f 90       	pop	r9
    16e6:	8f 90       	pop	r8
    16e8:	7f 90       	pop	r7
    16ea:	6f 90       	pop	r6
    16ec:	5f 90       	pop	r5
    16ee:	4f 90       	pop	r4
    16f0:	3f 90       	pop	r3
    16f2:	2f 90       	pop	r2
    16f4:	1f 90       	pop	r1
    16f6:	0f 90       	pop	r0
    16f8:	0c be       	out	0x3c, r0	; 60
    16fa:	0f 90       	pop	r0
    16fc:	0b be       	out	0x3b, r0	; 59
    16fe:	0f 90       	pop	r0
    1700:	0f be       	out	0x3f, r0	; 63
    1702:	0f 90       	pop	r0
    1704:	08 95       	ret
    1706:	08 95       	ret

00001708 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1708:	0f 92       	push	r0
    170a:	0f b6       	in	r0, 0x3f	; 63
    170c:	f8 94       	cli
    170e:	0f 92       	push	r0
    1710:	0b b6       	in	r0, 0x3b	; 59
    1712:	0f 92       	push	r0
    1714:	0c b6       	in	r0, 0x3c	; 60
    1716:	0f 92       	push	r0
    1718:	1f 92       	push	r1
    171a:	11 24       	eor	r1, r1
    171c:	2f 92       	push	r2
    171e:	3f 92       	push	r3
    1720:	4f 92       	push	r4
    1722:	5f 92       	push	r5
    1724:	6f 92       	push	r6
    1726:	7f 92       	push	r7
    1728:	8f 92       	push	r8
    172a:	9f 92       	push	r9
    172c:	af 92       	push	r10
    172e:	bf 92       	push	r11
    1730:	cf 92       	push	r12
    1732:	df 92       	push	r13
    1734:	ef 92       	push	r14
    1736:	ff 92       	push	r15
    1738:	0f 93       	push	r16
    173a:	1f 93       	push	r17
    173c:	2f 93       	push	r18
    173e:	3f 93       	push	r19
    1740:	4f 93       	push	r20
    1742:	5f 93       	push	r21
    1744:	6f 93       	push	r22
    1746:	7f 93       	push	r23
    1748:	8f 93       	push	r24
    174a:	9f 93       	push	r25
    174c:	af 93       	push	r26
    174e:	bf 93       	push	r27
    1750:	cf 93       	push	r28
    1752:	df 93       	push	r29
    1754:	ef 93       	push	r30
    1756:	ff 93       	push	r31
    1758:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    175c:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1760:	0d b6       	in	r0, 0x3d	; 61
    1762:	0d 92       	st	X+, r0
    1764:	0e b6       	in	r0, 0x3e	; 62
    1766:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1768:	0e 94 a4 12 	call	0x2548	; 0x2548 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    176c:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1770:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1774:	cd 91       	ld	r28, X+
    1776:	cd bf       	out	0x3d, r28	; 61
    1778:	dd 91       	ld	r29, X+
    177a:	de bf       	out	0x3e, r29	; 62
    177c:	ff 91       	pop	r31
    177e:	ef 91       	pop	r30
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	bf 91       	pop	r27
    1786:	af 91       	pop	r26
    1788:	9f 91       	pop	r25
    178a:	8f 91       	pop	r24
    178c:	7f 91       	pop	r23
    178e:	6f 91       	pop	r22
    1790:	5f 91       	pop	r21
    1792:	4f 91       	pop	r20
    1794:	3f 91       	pop	r19
    1796:	2f 91       	pop	r18
    1798:	1f 91       	pop	r17
    179a:	0f 91       	pop	r16
    179c:	ff 90       	pop	r15
    179e:	ef 90       	pop	r14
    17a0:	df 90       	pop	r13
    17a2:	cf 90       	pop	r12
    17a4:	bf 90       	pop	r11
    17a6:	af 90       	pop	r10
    17a8:	9f 90       	pop	r9
    17aa:	8f 90       	pop	r8
    17ac:	7f 90       	pop	r7
    17ae:	6f 90       	pop	r6
    17b0:	5f 90       	pop	r5
    17b2:	4f 90       	pop	r4
    17b4:	3f 90       	pop	r3
    17b6:	2f 90       	pop	r2
    17b8:	1f 90       	pop	r1
    17ba:	0f 90       	pop	r0
    17bc:	0c be       	out	0x3c, r0	; 60
    17be:	0f 90       	pop	r0
    17c0:	0b be       	out	0x3b, r0	; 59
    17c2:	0f 90       	pop	r0
    17c4:	0f be       	out	0x3f, r0	; 63
    17c6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17c8:	08 95       	ret

000017ca <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17ca:	0f 92       	push	r0
    17cc:	0f b6       	in	r0, 0x3f	; 63
    17ce:	f8 94       	cli
    17d0:	0f 92       	push	r0
    17d2:	0b b6       	in	r0, 0x3b	; 59
    17d4:	0f 92       	push	r0
    17d6:	0c b6       	in	r0, 0x3c	; 60
    17d8:	0f 92       	push	r0
    17da:	1f 92       	push	r1
    17dc:	11 24       	eor	r1, r1
    17de:	2f 92       	push	r2
    17e0:	3f 92       	push	r3
    17e2:	4f 92       	push	r4
    17e4:	5f 92       	push	r5
    17e6:	6f 92       	push	r6
    17e8:	7f 92       	push	r7
    17ea:	8f 92       	push	r8
    17ec:	9f 92       	push	r9
    17ee:	af 92       	push	r10
    17f0:	bf 92       	push	r11
    17f2:	cf 92       	push	r12
    17f4:	df 92       	push	r13
    17f6:	ef 92       	push	r14
    17f8:	ff 92       	push	r15
    17fa:	0f 93       	push	r16
    17fc:	1f 93       	push	r17
    17fe:	2f 93       	push	r18
    1800:	3f 93       	push	r19
    1802:	4f 93       	push	r20
    1804:	5f 93       	push	r21
    1806:	6f 93       	push	r22
    1808:	7f 93       	push	r23
    180a:	8f 93       	push	r24
    180c:	9f 93       	push	r25
    180e:	af 93       	push	r26
    1810:	bf 93       	push	r27
    1812:	cf 93       	push	r28
    1814:	df 93       	push	r29
    1816:	ef 93       	push	r30
    1818:	ff 93       	push	r31
    181a:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    181e:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1822:	0d b6       	in	r0, 0x3d	; 61
    1824:	0d 92       	st	X+, r0
    1826:	0e b6       	in	r0, 0x3e	; 62
    1828:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    182a:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskIncrementTick>
	vTaskSwitchContext();
    182e:	0e 94 a4 12 	call	0x2548	; 0x2548 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1832:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1836:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    183a:	cd 91       	ld	r28, X+
    183c:	cd bf       	out	0x3d, r28	; 61
    183e:	dd 91       	ld	r29, X+
    1840:	de bf       	out	0x3e, r29	; 62
    1842:	ff 91       	pop	r31
    1844:	ef 91       	pop	r30
    1846:	df 91       	pop	r29
    1848:	cf 91       	pop	r28
    184a:	bf 91       	pop	r27
    184c:	af 91       	pop	r26
    184e:	9f 91       	pop	r25
    1850:	8f 91       	pop	r24
    1852:	7f 91       	pop	r23
    1854:	6f 91       	pop	r22
    1856:	5f 91       	pop	r21
    1858:	4f 91       	pop	r20
    185a:	3f 91       	pop	r19
    185c:	2f 91       	pop	r18
    185e:	1f 91       	pop	r17
    1860:	0f 91       	pop	r16
    1862:	ff 90       	pop	r15
    1864:	ef 90       	pop	r14
    1866:	df 90       	pop	r13
    1868:	cf 90       	pop	r12
    186a:	bf 90       	pop	r11
    186c:	af 90       	pop	r10
    186e:	9f 90       	pop	r9
    1870:	8f 90       	pop	r8
    1872:	7f 90       	pop	r7
    1874:	6f 90       	pop	r6
    1876:	5f 90       	pop	r5
    1878:	4f 90       	pop	r4
    187a:	3f 90       	pop	r3
    187c:	2f 90       	pop	r2
    187e:	1f 90       	pop	r1
    1880:	0f 90       	pop	r0
    1882:	0c be       	out	0x3c, r0	; 60
    1884:	0f 90       	pop	r0
    1886:	0b be       	out	0x3b, r0	; 59
    1888:	0f 90       	pop	r0
    188a:	0f be       	out	0x3f, r0	; 63
    188c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    188e:	08 95       	ret

00001890 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1890:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <vPortYieldFromTick>
		asm volatile ( "reti" );
    1894:	18 95       	reti

00001896 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1896:	cf 93       	push	r28
    1898:	df 93       	push	r29
    189a:	ec 01       	movw	r28, r24
    189c:	88 a1       	ldd	r24, Y+32	; 0x20
    189e:	81 11       	cpse	r24, r1
    18a0:	0b c0       	rjmp	.+22     	; 0x18b8 <prvCopyDataToQueue+0x22>
    18a2:	88 81       	ld	r24, Y
    18a4:	99 81       	ldd	r25, Y+1	; 0x01
    18a6:	89 2b       	or	r24, r25
    18a8:	e1 f5       	brne	.+120    	; 0x1922 <prvCopyDataToQueue+0x8c>
    18aa:	8a 81       	ldd	r24, Y+2	; 0x02
    18ac:	9b 81       	ldd	r25, Y+3	; 0x03
    18ae:	0e 94 5f 14 	call	0x28be	; 0x28be <vTaskPriorityDisinherit>
    18b2:	1a 82       	std	Y+2, r1	; 0x02
    18b4:	1b 82       	std	Y+3, r1	; 0x03
    18b6:	35 c0       	rjmp	.+106    	; 0x1922 <prvCopyDataToQueue+0x8c>
    18b8:	41 11       	cpse	r20, r1
    18ba:	17 c0       	rjmp	.+46     	; 0x18ea <prvCopyDataToQueue+0x54>
    18bc:	48 2f       	mov	r20, r24
    18be:	50 e0       	ldi	r21, 0x00	; 0
    18c0:	8c 81       	ldd	r24, Y+4	; 0x04
    18c2:	9d 81       	ldd	r25, Y+5	; 0x05
    18c4:	0e 94 0b 20 	call	0x4016	; 0x4016 <memcpy>
    18c8:	28 a1       	ldd	r18, Y+32	; 0x20
    18ca:	8c 81       	ldd	r24, Y+4	; 0x04
    18cc:	9d 81       	ldd	r25, Y+5	; 0x05
    18ce:	82 0f       	add	r24, r18
    18d0:	91 1d       	adc	r25, r1
    18d2:	8c 83       	std	Y+4, r24	; 0x04
    18d4:	9d 83       	std	Y+5, r25	; 0x05
    18d6:	2a 81       	ldd	r18, Y+2	; 0x02
    18d8:	3b 81       	ldd	r19, Y+3	; 0x03
    18da:	82 17       	cp	r24, r18
    18dc:	93 07       	cpc	r25, r19
    18de:	08 f1       	brcs	.+66     	; 0x1922 <prvCopyDataToQueue+0x8c>
    18e0:	88 81       	ld	r24, Y
    18e2:	99 81       	ldd	r25, Y+1	; 0x01
    18e4:	8c 83       	std	Y+4, r24	; 0x04
    18e6:	9d 83       	std	Y+5, r25	; 0x05
    18e8:	1c c0       	rjmp	.+56     	; 0x1922 <prvCopyDataToQueue+0x8c>
    18ea:	48 2f       	mov	r20, r24
    18ec:	50 e0       	ldi	r21, 0x00	; 0
    18ee:	8e 81       	ldd	r24, Y+6	; 0x06
    18f0:	9f 81       	ldd	r25, Y+7	; 0x07
    18f2:	0e 94 0b 20 	call	0x4016	; 0x4016 <memcpy>
    18f6:	88 a1       	ldd	r24, Y+32	; 0x20
    18f8:	90 e0       	ldi	r25, 0x00	; 0
    18fa:	91 95       	neg	r25
    18fc:	81 95       	neg	r24
    18fe:	91 09       	sbc	r25, r1
    1900:	2e 81       	ldd	r18, Y+6	; 0x06
    1902:	3f 81       	ldd	r19, Y+7	; 0x07
    1904:	28 0f       	add	r18, r24
    1906:	39 1f       	adc	r19, r25
    1908:	2e 83       	std	Y+6, r18	; 0x06
    190a:	3f 83       	std	Y+7, r19	; 0x07
    190c:	48 81       	ld	r20, Y
    190e:	59 81       	ldd	r21, Y+1	; 0x01
    1910:	24 17       	cp	r18, r20
    1912:	35 07       	cpc	r19, r21
    1914:	30 f4       	brcc	.+12     	; 0x1922 <prvCopyDataToQueue+0x8c>
    1916:	2a 81       	ldd	r18, Y+2	; 0x02
    1918:	3b 81       	ldd	r19, Y+3	; 0x03
    191a:	82 0f       	add	r24, r18
    191c:	93 1f       	adc	r25, r19
    191e:	8e 83       	std	Y+6, r24	; 0x06
    1920:	9f 83       	std	Y+7, r25	; 0x07
    1922:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1924:	8f 5f       	subi	r24, 0xFF	; 255
    1926:	8e 8f       	std	Y+30, r24	; 0x1e
    1928:	df 91       	pop	r29
    192a:	cf 91       	pop	r28
    192c:	08 95       	ret

0000192e <prvCopyDataFromQueue>:
    192e:	fc 01       	movw	r30, r24
    1930:	80 81       	ld	r24, Z
    1932:	91 81       	ldd	r25, Z+1	; 0x01
    1934:	00 97       	sbiw	r24, 0x00	; 0
    1936:	a1 f0       	breq	.+40     	; 0x1960 <prvCopyDataFromQueue+0x32>
    1938:	40 a1       	ldd	r20, Z+32	; 0x20
    193a:	50 e0       	ldi	r21, 0x00	; 0
    193c:	26 81       	ldd	r18, Z+6	; 0x06
    193e:	37 81       	ldd	r19, Z+7	; 0x07
    1940:	24 0f       	add	r18, r20
    1942:	35 1f       	adc	r19, r21
    1944:	26 83       	std	Z+6, r18	; 0x06
    1946:	37 83       	std	Z+7, r19	; 0x07
    1948:	a2 81       	ldd	r26, Z+2	; 0x02
    194a:	b3 81       	ldd	r27, Z+3	; 0x03
    194c:	2a 17       	cp	r18, r26
    194e:	3b 07       	cpc	r19, r27
    1950:	10 f0       	brcs	.+4      	; 0x1956 <prvCopyDataFromQueue+0x28>
    1952:	86 83       	std	Z+6, r24	; 0x06
    1954:	97 83       	std	Z+7, r25	; 0x07
    1956:	cb 01       	movw	r24, r22
    1958:	66 81       	ldd	r22, Z+6	; 0x06
    195a:	77 81       	ldd	r23, Z+7	; 0x07
    195c:	0e 94 0b 20 	call	0x4016	; 0x4016 <memcpy>
    1960:	08 95       	ret

00001962 <prvUnlockQueue>:
    1962:	0f 93       	push	r16
    1964:	1f 93       	push	r17
    1966:	cf 93       	push	r28
    1968:	df 93       	push	r29
    196a:	ec 01       	movw	r28, r24
    196c:	0f b6       	in	r0, 0x3f	; 63
    196e:	f8 94       	cli
    1970:	0f 92       	push	r0
    1972:	8a a1       	ldd	r24, Y+34	; 0x22
    1974:	18 16       	cp	r1, r24
    1976:	b4 f4       	brge	.+44     	; 0x19a4 <prvUnlockQueue+0x42>
    1978:	8b 89       	ldd	r24, Y+19	; 0x13
    197a:	81 11       	cpse	r24, r1
    197c:	05 c0       	rjmp	.+10     	; 0x1988 <prvUnlockQueue+0x26>
    197e:	12 c0       	rjmp	.+36     	; 0x19a4 <prvUnlockQueue+0x42>
    1980:	8b 89       	ldd	r24, Y+19	; 0x13
    1982:	81 11       	cpse	r24, r1
    1984:	04 c0       	rjmp	.+8      	; 0x198e <prvUnlockQueue+0x2c>
    1986:	0e c0       	rjmp	.+28     	; 0x19a4 <prvUnlockQueue+0x42>
    1988:	8e 01       	movw	r16, r28
    198a:	0d 5e       	subi	r16, 0xED	; 237
    198c:	1f 4f       	sbci	r17, 0xFF	; 255
    198e:	c8 01       	movw	r24, r16
    1990:	0e 94 2b 13 	call	0x2656	; 0x2656 <xTaskRemoveFromEventList>
    1994:	81 11       	cpse	r24, r1
    1996:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <vTaskMissedYield>
    199a:	8a a1       	ldd	r24, Y+34	; 0x22
    199c:	81 50       	subi	r24, 0x01	; 1
    199e:	8a a3       	std	Y+34, r24	; 0x22
    19a0:	18 16       	cp	r1, r24
    19a2:	74 f3       	brlt	.-36     	; 0x1980 <prvUnlockQueue+0x1e>
    19a4:	8f ef       	ldi	r24, 0xFF	; 255
    19a6:	8a a3       	std	Y+34, r24	; 0x22
    19a8:	0f 90       	pop	r0
    19aa:	0f be       	out	0x3f, r0	; 63
    19ac:	0f b6       	in	r0, 0x3f	; 63
    19ae:	f8 94       	cli
    19b0:	0f 92       	push	r0
    19b2:	89 a1       	ldd	r24, Y+33	; 0x21
    19b4:	18 16       	cp	r1, r24
    19b6:	b4 f4       	brge	.+44     	; 0x19e4 <prvUnlockQueue+0x82>
    19b8:	88 85       	ldd	r24, Y+8	; 0x08
    19ba:	81 11       	cpse	r24, r1
    19bc:	05 c0       	rjmp	.+10     	; 0x19c8 <prvUnlockQueue+0x66>
    19be:	12 c0       	rjmp	.+36     	; 0x19e4 <prvUnlockQueue+0x82>
    19c0:	88 85       	ldd	r24, Y+8	; 0x08
    19c2:	81 11       	cpse	r24, r1
    19c4:	04 c0       	rjmp	.+8      	; 0x19ce <prvUnlockQueue+0x6c>
    19c6:	0e c0       	rjmp	.+28     	; 0x19e4 <prvUnlockQueue+0x82>
    19c8:	8e 01       	movw	r16, r28
    19ca:	08 5f       	subi	r16, 0xF8	; 248
    19cc:	1f 4f       	sbci	r17, 0xFF	; 255
    19ce:	c8 01       	movw	r24, r16
    19d0:	0e 94 2b 13 	call	0x2656	; 0x2656 <xTaskRemoveFromEventList>
    19d4:	81 11       	cpse	r24, r1
    19d6:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <vTaskMissedYield>
    19da:	89 a1       	ldd	r24, Y+33	; 0x21
    19dc:	81 50       	subi	r24, 0x01	; 1
    19de:	89 a3       	std	Y+33, r24	; 0x21
    19e0:	18 16       	cp	r1, r24
    19e2:	74 f3       	brlt	.-36     	; 0x19c0 <prvUnlockQueue+0x5e>
    19e4:	8f ef       	ldi	r24, 0xFF	; 255
    19e6:	89 a3       	std	Y+33, r24	; 0x21
    19e8:	0f 90       	pop	r0
    19ea:	0f be       	out	0x3f, r0	; 63
    19ec:	df 91       	pop	r29
    19ee:	cf 91       	pop	r28
    19f0:	1f 91       	pop	r17
    19f2:	0f 91       	pop	r16
    19f4:	08 95       	ret

000019f6 <xQueueGenericReset>:
    19f6:	1f 93       	push	r17
    19f8:	cf 93       	push	r28
    19fa:	df 93       	push	r29
    19fc:	61 30       	cpi	r22, 0x01	; 1
    19fe:	59 f0       	breq	.+22     	; 0x1a16 <xQueueGenericReset+0x20>
    1a00:	fc 01       	movw	r30, r24
    1a02:	23 89       	ldd	r18, Z+19	; 0x13
    1a04:	30 85       	ldd	r19, Z+8	; 0x08
    1a06:	31 11       	cpse	r19, r1
    1a08:	2c c0       	rjmp	.+88     	; 0x1a62 <xQueueGenericReset+0x6c>
    1a0a:	11 e0       	ldi	r17, 0x01	; 1
    1a0c:	21 11       	cpse	r18, r1
    1a0e:	10 e0       	ldi	r17, 0x00	; 0
    1a10:	21 11       	cpse	r18, r1
    1a12:	28 c0       	rjmp	.+80     	; 0x1a64 <xQueueGenericReset+0x6e>
    1a14:	01 c0       	rjmp	.+2      	; 0x1a18 <xQueueGenericReset+0x22>
    1a16:	11 e0       	ldi	r17, 0x01	; 1
    1a18:	ec 01       	movw	r28, r24
    1a1a:	48 81       	ld	r20, Y
    1a1c:	59 81       	ldd	r21, Y+1	; 0x01
    1a1e:	28 a1       	ldd	r18, Y+32	; 0x20
    1a20:	30 e0       	ldi	r19, 0x00	; 0
    1a22:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a24:	62 9f       	mul	r22, r18
    1a26:	c0 01       	movw	r24, r0
    1a28:	63 9f       	mul	r22, r19
    1a2a:	90 0d       	add	r25, r0
    1a2c:	11 24       	eor	r1, r1
    1a2e:	ba 01       	movw	r22, r20
    1a30:	68 0f       	add	r22, r24
    1a32:	79 1f       	adc	r23, r25
    1a34:	6a 83       	std	Y+2, r22	; 0x02
    1a36:	7b 83       	std	Y+3, r23	; 0x03
    1a38:	1e 8e       	std	Y+30, r1	; 0x1e
    1a3a:	4c 83       	std	Y+4, r20	; 0x04
    1a3c:	5d 83       	std	Y+5, r21	; 0x05
    1a3e:	82 1b       	sub	r24, r18
    1a40:	93 0b       	sbc	r25, r19
    1a42:	84 0f       	add	r24, r20
    1a44:	95 1f       	adc	r25, r21
    1a46:	8e 83       	std	Y+6, r24	; 0x06
    1a48:	9f 83       	std	Y+7, r25	; 0x07
    1a4a:	8f ef       	ldi	r24, 0xFF	; 255
    1a4c:	89 a3       	std	Y+33, r24	; 0x21
    1a4e:	8a a3       	std	Y+34, r24	; 0x22
    1a50:	ce 01       	movw	r24, r28
    1a52:	08 96       	adiw	r24, 0x08	; 8
    1a54:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1a58:	ce 01       	movw	r24, r28
    1a5a:	43 96       	adiw	r24, 0x13	; 19
    1a5c:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1a60:	01 c0       	rjmp	.+2      	; 0x1a64 <xQueueGenericReset+0x6e>
    1a62:	10 e0       	ldi	r17, 0x00	; 0
    1a64:	81 2f       	mov	r24, r17
    1a66:	df 91       	pop	r29
    1a68:	cf 91       	pop	r28
    1a6a:	1f 91       	pop	r17
    1a6c:	08 95       	ret

00001a6e <xQueueGenericCreate>:
    1a6e:	0f 93       	push	r16
    1a70:	1f 93       	push	r17
    1a72:	cf 93       	push	r28
    1a74:	df 93       	push	r29
    1a76:	88 23       	and	r24, r24
    1a78:	01 f1       	breq	.+64     	; 0x1aba <xQueueGenericCreate+0x4c>
    1a7a:	06 2f       	mov	r16, r22
    1a7c:	18 2f       	mov	r17, r24
    1a7e:	83 e2       	ldi	r24, 0x23	; 35
    1a80:	90 e0       	ldi	r25, 0x00	; 0
    1a82:	0e 94 51 09 	call	0x12a2	; 0x12a2 <pvPortMalloc>
    1a86:	ec 01       	movw	r28, r24
    1a88:	89 2b       	or	r24, r25
    1a8a:	c9 f0       	breq	.+50     	; 0x1abe <xQueueGenericCreate+0x50>
    1a8c:	10 9f       	mul	r17, r16
    1a8e:	c0 01       	movw	r24, r0
    1a90:	11 24       	eor	r1, r1
    1a92:	01 96       	adiw	r24, 0x01	; 1
    1a94:	0e 94 51 09 	call	0x12a2	; 0x12a2 <pvPortMalloc>
    1a98:	88 83       	st	Y, r24
    1a9a:	99 83       	std	Y+1, r25	; 0x01
    1a9c:	89 2b       	or	r24, r25
    1a9e:	39 f0       	breq	.+14     	; 0x1aae <xQueueGenericCreate+0x40>
    1aa0:	1f 8f       	std	Y+31, r17	; 0x1f
    1aa2:	08 a3       	std	Y+32, r16	; 0x20
    1aa4:	61 e0       	ldi	r22, 0x01	; 1
    1aa6:	ce 01       	movw	r24, r28
    1aa8:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <xQueueGenericReset>
    1aac:	08 c0       	rjmp	.+16     	; 0x1abe <xQueueGenericCreate+0x50>
    1aae:	ce 01       	movw	r24, r28
    1ab0:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vPortFree>
    1ab4:	c0 e0       	ldi	r28, 0x00	; 0
    1ab6:	d0 e0       	ldi	r29, 0x00	; 0
    1ab8:	02 c0       	rjmp	.+4      	; 0x1abe <xQueueGenericCreate+0x50>
    1aba:	c0 e0       	ldi	r28, 0x00	; 0
    1abc:	d0 e0       	ldi	r29, 0x00	; 0
    1abe:	ce 01       	movw	r24, r28
    1ac0:	df 91       	pop	r29
    1ac2:	cf 91       	pop	r28
    1ac4:	1f 91       	pop	r17
    1ac6:	0f 91       	pop	r16
    1ac8:	08 95       	ret

00001aca <xQueueGenericSend>:
    1aca:	af 92       	push	r10
    1acc:	bf 92       	push	r11
    1ace:	cf 92       	push	r12
    1ad0:	df 92       	push	r13
    1ad2:	ef 92       	push	r14
    1ad4:	ff 92       	push	r15
    1ad6:	0f 93       	push	r16
    1ad8:	1f 93       	push	r17
    1ada:	cf 93       	push	r28
    1adc:	df 93       	push	r29
    1ade:	cd b7       	in	r28, 0x3d	; 61
    1ae0:	de b7       	in	r29, 0x3e	; 62
    1ae2:	29 97       	sbiw	r28, 0x09	; 9
    1ae4:	cd bf       	out	0x3d, r28	; 61
    1ae6:	de bf       	out	0x3e, r29	; 62
    1ae8:	7c 01       	movw	r14, r24
    1aea:	5b 01       	movw	r10, r22
    1aec:	2e 83       	std	Y+6, r18	; 0x06
    1aee:	3f 83       	std	Y+7, r19	; 0x07
    1af0:	48 87       	std	Y+8, r20	; 0x08
    1af2:	59 87       	std	Y+9, r21	; 0x09
    1af4:	10 e0       	ldi	r17, 0x00	; 0
    1af6:	6c 01       	movw	r12, r24
    1af8:	88 e0       	ldi	r24, 0x08	; 8
    1afa:	c8 0e       	add	r12, r24
    1afc:	d1 1c       	adc	r13, r1
    1afe:	0f b6       	in	r0, 0x3f	; 63
    1b00:	f8 94       	cli
    1b02:	0f 92       	push	r0
    1b04:	f7 01       	movw	r30, r14
    1b06:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b08:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b0a:	98 17       	cp	r25, r24
    1b0c:	a8 f4       	brcc	.+42     	; 0x1b38 <xQueueGenericSend+0x6e>
    1b0e:	40 2f       	mov	r20, r16
    1b10:	b5 01       	movw	r22, r10
    1b12:	c7 01       	movw	r24, r14
    1b14:	0e 94 4b 0c 	call	0x1896	; 0x1896 <prvCopyDataToQueue>
    1b18:	f7 01       	movw	r30, r14
    1b1a:	83 89       	ldd	r24, Z+19	; 0x13
    1b1c:	88 23       	and	r24, r24
    1b1e:	41 f0       	breq	.+16     	; 0x1b30 <xQueueGenericSend+0x66>
    1b20:	c7 01       	movw	r24, r14
    1b22:	43 96       	adiw	r24, 0x13	; 19
    1b24:	0e 94 2b 13 	call	0x2656	; 0x2656 <xTaskRemoveFromEventList>
    1b28:	81 30       	cpi	r24, 0x01	; 1
    1b2a:	11 f4       	brne	.+4      	; 0x1b30 <xQueueGenericSend+0x66>
    1b2c:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
    1b30:	0f 90       	pop	r0
    1b32:	0f be       	out	0x3f, r0	; 63
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	56 c0       	rjmp	.+172    	; 0x1be4 <xQueueGenericSend+0x11a>
    1b38:	8e 81       	ldd	r24, Y+6	; 0x06
    1b3a:	9f 81       	ldd	r25, Y+7	; 0x07
    1b3c:	a8 85       	ldd	r26, Y+8	; 0x08
    1b3e:	b9 85       	ldd	r27, Y+9	; 0x09
    1b40:	89 2b       	or	r24, r25
    1b42:	8a 2b       	or	r24, r26
    1b44:	8b 2b       	or	r24, r27
    1b46:	21 f4       	brne	.+8      	; 0x1b50 <xQueueGenericSend+0x86>
    1b48:	0f 90       	pop	r0
    1b4a:	0f be       	out	0x3f, r0	; 63
    1b4c:	80 e0       	ldi	r24, 0x00	; 0
    1b4e:	4a c0       	rjmp	.+148    	; 0x1be4 <xQueueGenericSend+0x11a>
    1b50:	11 11       	cpse	r17, r1
    1b52:	05 c0       	rjmp	.+10     	; 0x1b5e <xQueueGenericSend+0x94>
    1b54:	ce 01       	movw	r24, r28
    1b56:	01 96       	adiw	r24, 0x01	; 1
    1b58:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <vTaskSetTimeOutState>
    1b5c:	11 e0       	ldi	r17, 0x01	; 1
    1b5e:	0f 90       	pop	r0
    1b60:	0f be       	out	0x3f, r0	; 63
    1b62:	0e 94 65 10 	call	0x20ca	; 0x20ca <vTaskSuspendAll>
    1b66:	0f b6       	in	r0, 0x3f	; 63
    1b68:	f8 94       	cli
    1b6a:	0f 92       	push	r0
    1b6c:	f7 01       	movw	r30, r14
    1b6e:	81 a1       	ldd	r24, Z+33	; 0x21
    1b70:	8f 3f       	cpi	r24, 0xFF	; 255
    1b72:	09 f4       	brne	.+2      	; 0x1b76 <xQueueGenericSend+0xac>
    1b74:	11 a2       	std	Z+33, r1	; 0x21
    1b76:	f7 01       	movw	r30, r14
    1b78:	82 a1       	ldd	r24, Z+34	; 0x22
    1b7a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b7c:	09 f4       	brne	.+2      	; 0x1b80 <xQueueGenericSend+0xb6>
    1b7e:	12 a2       	std	Z+34, r1	; 0x22
    1b80:	0f 90       	pop	r0
    1b82:	0f be       	out	0x3f, r0	; 63
    1b84:	be 01       	movw	r22, r28
    1b86:	6a 5f       	subi	r22, 0xFA	; 250
    1b88:	7f 4f       	sbci	r23, 0xFF	; 255
    1b8a:	ce 01       	movw	r24, r28
    1b8c:	01 96       	adiw	r24, 0x01	; 1
    1b8e:	0e 94 7b 13 	call	0x26f6	; 0x26f6 <xTaskCheckForTimeOut>
    1b92:	81 11       	cpse	r24, r1
    1b94:	21 c0       	rjmp	.+66     	; 0x1bd8 <xQueueGenericSend+0x10e>
    1b96:	0f b6       	in	r0, 0x3f	; 63
    1b98:	f8 94       	cli
    1b9a:	0f 92       	push	r0
    1b9c:	f7 01       	movw	r30, r14
    1b9e:	96 8d       	ldd	r25, Z+30	; 0x1e
    1ba0:	0f 90       	pop	r0
    1ba2:	0f be       	out	0x3f, r0	; 63
    1ba4:	87 8d       	ldd	r24, Z+31	; 0x1f
    1ba6:	98 13       	cpse	r25, r24
    1ba8:	11 c0       	rjmp	.+34     	; 0x1bcc <xQueueGenericSend+0x102>
    1baa:	4e 81       	ldd	r20, Y+6	; 0x06
    1bac:	5f 81       	ldd	r21, Y+7	; 0x07
    1bae:	68 85       	ldd	r22, Y+8	; 0x08
    1bb0:	79 85       	ldd	r23, Y+9	; 0x09
    1bb2:	c6 01       	movw	r24, r12
    1bb4:	0e 94 01 13 	call	0x2602	; 0x2602 <vTaskPlaceOnEventList>
    1bb8:	c7 01       	movw	r24, r14
    1bba:	0e 94 b1 0c 	call	0x1962	; 0x1962 <prvUnlockQueue>
    1bbe:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
    1bc2:	81 11       	cpse	r24, r1
    1bc4:	9c cf       	rjmp	.-200    	; 0x1afe <xQueueGenericSend+0x34>
    1bc6:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
    1bca:	99 cf       	rjmp	.-206    	; 0x1afe <xQueueGenericSend+0x34>
    1bcc:	c7 01       	movw	r24, r14
    1bce:	0e 94 b1 0c 	call	0x1962	; 0x1962 <prvUnlockQueue>
    1bd2:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
    1bd6:	93 cf       	rjmp	.-218    	; 0x1afe <xQueueGenericSend+0x34>
    1bd8:	c7 01       	movw	r24, r14
    1bda:	0e 94 b1 0c 	call	0x1962	; 0x1962 <prvUnlockQueue>
    1bde:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
    1be2:	80 e0       	ldi	r24, 0x00	; 0
    1be4:	29 96       	adiw	r28, 0x09	; 9
    1be6:	cd bf       	out	0x3d, r28	; 61
    1be8:	de bf       	out	0x3e, r29	; 62
    1bea:	df 91       	pop	r29
    1bec:	cf 91       	pop	r28
    1bee:	1f 91       	pop	r17
    1bf0:	0f 91       	pop	r16
    1bf2:	ff 90       	pop	r15
    1bf4:	ef 90       	pop	r14
    1bf6:	df 90       	pop	r13
    1bf8:	cf 90       	pop	r12
    1bfa:	bf 90       	pop	r11
    1bfc:	af 90       	pop	r10
    1bfe:	08 95       	ret

00001c00 <xQueueGenericReceive>:
    1c00:	af 92       	push	r10
    1c02:	bf 92       	push	r11
    1c04:	cf 92       	push	r12
    1c06:	df 92       	push	r13
    1c08:	ef 92       	push	r14
    1c0a:	ff 92       	push	r15
    1c0c:	0f 93       	push	r16
    1c0e:	1f 93       	push	r17
    1c10:	cf 93       	push	r28
    1c12:	df 93       	push	r29
    1c14:	cd b7       	in	r28, 0x3d	; 61
    1c16:	de b7       	in	r29, 0x3e	; 62
    1c18:	29 97       	sbiw	r28, 0x09	; 9
    1c1a:	cd bf       	out	0x3d, r28	; 61
    1c1c:	de bf       	out	0x3e, r29	; 62
    1c1e:	7c 01       	movw	r14, r24
    1c20:	5b 01       	movw	r10, r22
    1c22:	2e 83       	std	Y+6, r18	; 0x06
    1c24:	3f 83       	std	Y+7, r19	; 0x07
    1c26:	48 87       	std	Y+8, r20	; 0x08
    1c28:	59 87       	std	Y+9, r21	; 0x09
    1c2a:	10 e0       	ldi	r17, 0x00	; 0
    1c2c:	6c 01       	movw	r12, r24
    1c2e:	83 e1       	ldi	r24, 0x13	; 19
    1c30:	c8 0e       	add	r12, r24
    1c32:	d1 1c       	adc	r13, r1
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	f8 94       	cli
    1c38:	0f 92       	push	r0
    1c3a:	f7 01       	movw	r30, r14
    1c3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c3e:	88 23       	and	r24, r24
    1c40:	99 f1       	breq	.+102    	; 0x1ca8 <xQueueGenericReceive+0xa8>
    1c42:	c6 80       	ldd	r12, Z+6	; 0x06
    1c44:	d7 80       	ldd	r13, Z+7	; 0x07
    1c46:	b5 01       	movw	r22, r10
    1c48:	c7 01       	movw	r24, r14
    1c4a:	0e 94 97 0c 	call	0x192e	; 0x192e <prvCopyDataFromQueue>
    1c4e:	01 11       	cpse	r16, r1
    1c50:	1a c0       	rjmp	.+52     	; 0x1c86 <xQueueGenericReceive+0x86>
    1c52:	f7 01       	movw	r30, r14
    1c54:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c56:	81 50       	subi	r24, 0x01	; 1
    1c58:	86 8f       	std	Z+30, r24	; 0x1e
    1c5a:	80 81       	ld	r24, Z
    1c5c:	91 81       	ldd	r25, Z+1	; 0x01
    1c5e:	89 2b       	or	r24, r25
    1c60:	29 f4       	brne	.+10     	; 0x1c6c <xQueueGenericReceive+0x6c>
    1c62:	0e 94 05 14 	call	0x280a	; 0x280a <xTaskGetCurrentTaskHandle>
    1c66:	f7 01       	movw	r30, r14
    1c68:	82 83       	std	Z+2, r24	; 0x02
    1c6a:	93 83       	std	Z+3, r25	; 0x03
    1c6c:	f7 01       	movw	r30, r14
    1c6e:	80 85       	ldd	r24, Z+8	; 0x08
    1c70:	88 23       	and	r24, r24
    1c72:	b1 f0       	breq	.+44     	; 0x1ca0 <xQueueGenericReceive+0xa0>
    1c74:	c7 01       	movw	r24, r14
    1c76:	08 96       	adiw	r24, 0x08	; 8
    1c78:	0e 94 2b 13 	call	0x2656	; 0x2656 <xTaskRemoveFromEventList>
    1c7c:	81 30       	cpi	r24, 0x01	; 1
    1c7e:	81 f4       	brne	.+32     	; 0x1ca0 <xQueueGenericReceive+0xa0>
    1c80:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
    1c84:	0d c0       	rjmp	.+26     	; 0x1ca0 <xQueueGenericReceive+0xa0>
    1c86:	f7 01       	movw	r30, r14
    1c88:	c6 82       	std	Z+6, r12	; 0x06
    1c8a:	d7 82       	std	Z+7, r13	; 0x07
    1c8c:	83 89       	ldd	r24, Z+19	; 0x13
    1c8e:	88 23       	and	r24, r24
    1c90:	39 f0       	breq	.+14     	; 0x1ca0 <xQueueGenericReceive+0xa0>
    1c92:	c7 01       	movw	r24, r14
    1c94:	43 96       	adiw	r24, 0x13	; 19
    1c96:	0e 94 2b 13 	call	0x2656	; 0x2656 <xTaskRemoveFromEventList>
    1c9a:	81 11       	cpse	r24, r1
    1c9c:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
    1ca0:	0f 90       	pop	r0
    1ca2:	0f be       	out	0x3f, r0	; 63
    1ca4:	81 e0       	ldi	r24, 0x01	; 1
    1ca6:	62 c0       	rjmp	.+196    	; 0x1d6c <xQueueGenericReceive+0x16c>
    1ca8:	8e 81       	ldd	r24, Y+6	; 0x06
    1caa:	9f 81       	ldd	r25, Y+7	; 0x07
    1cac:	a8 85       	ldd	r26, Y+8	; 0x08
    1cae:	b9 85       	ldd	r27, Y+9	; 0x09
    1cb0:	89 2b       	or	r24, r25
    1cb2:	8a 2b       	or	r24, r26
    1cb4:	8b 2b       	or	r24, r27
    1cb6:	21 f4       	brne	.+8      	; 0x1cc0 <xQueueGenericReceive+0xc0>
    1cb8:	0f 90       	pop	r0
    1cba:	0f be       	out	0x3f, r0	; 63
    1cbc:	80 e0       	ldi	r24, 0x00	; 0
    1cbe:	56 c0       	rjmp	.+172    	; 0x1d6c <xQueueGenericReceive+0x16c>
    1cc0:	11 11       	cpse	r17, r1
    1cc2:	05 c0       	rjmp	.+10     	; 0x1cce <xQueueGenericReceive+0xce>
    1cc4:	ce 01       	movw	r24, r28
    1cc6:	01 96       	adiw	r24, 0x01	; 1
    1cc8:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <vTaskSetTimeOutState>
    1ccc:	11 e0       	ldi	r17, 0x01	; 1
    1cce:	0f 90       	pop	r0
    1cd0:	0f be       	out	0x3f, r0	; 63
    1cd2:	0e 94 65 10 	call	0x20ca	; 0x20ca <vTaskSuspendAll>
    1cd6:	0f b6       	in	r0, 0x3f	; 63
    1cd8:	f8 94       	cli
    1cda:	0f 92       	push	r0
    1cdc:	f7 01       	movw	r30, r14
    1cde:	81 a1       	ldd	r24, Z+33	; 0x21
    1ce0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce2:	09 f4       	brne	.+2      	; 0x1ce6 <xQueueGenericReceive+0xe6>
    1ce4:	11 a2       	std	Z+33, r1	; 0x21
    1ce6:	f7 01       	movw	r30, r14
    1ce8:	82 a1       	ldd	r24, Z+34	; 0x22
    1cea:	8f 3f       	cpi	r24, 0xFF	; 255
    1cec:	09 f4       	brne	.+2      	; 0x1cf0 <xQueueGenericReceive+0xf0>
    1cee:	12 a2       	std	Z+34, r1	; 0x22
    1cf0:	0f 90       	pop	r0
    1cf2:	0f be       	out	0x3f, r0	; 63
    1cf4:	be 01       	movw	r22, r28
    1cf6:	6a 5f       	subi	r22, 0xFA	; 250
    1cf8:	7f 4f       	sbci	r23, 0xFF	; 255
    1cfa:	ce 01       	movw	r24, r28
    1cfc:	01 96       	adiw	r24, 0x01	; 1
    1cfe:	0e 94 7b 13 	call	0x26f6	; 0x26f6 <xTaskCheckForTimeOut>
    1d02:	81 11       	cpse	r24, r1
    1d04:	2d c0       	rjmp	.+90     	; 0x1d60 <xQueueGenericReceive+0x160>
    1d06:	0f b6       	in	r0, 0x3f	; 63
    1d08:	f8 94       	cli
    1d0a:	0f 92       	push	r0
    1d0c:	f7 01       	movw	r30, r14
    1d0e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d10:	0f 90       	pop	r0
    1d12:	0f be       	out	0x3f, r0	; 63
    1d14:	81 11       	cpse	r24, r1
    1d16:	1e c0       	rjmp	.+60     	; 0x1d54 <xQueueGenericReceive+0x154>
    1d18:	80 81       	ld	r24, Z
    1d1a:	91 81       	ldd	r25, Z+1	; 0x01
    1d1c:	89 2b       	or	r24, r25
    1d1e:	49 f4       	brne	.+18     	; 0x1d32 <xQueueGenericReceive+0x132>
    1d20:	0f b6       	in	r0, 0x3f	; 63
    1d22:	f8 94       	cli
    1d24:	0f 92       	push	r0
    1d26:	82 81       	ldd	r24, Z+2	; 0x02
    1d28:	93 81       	ldd	r25, Z+3	; 0x03
    1d2a:	0e 94 0a 14 	call	0x2814	; 0x2814 <vTaskPriorityInherit>
    1d2e:	0f 90       	pop	r0
    1d30:	0f be       	out	0x3f, r0	; 63
    1d32:	4e 81       	ldd	r20, Y+6	; 0x06
    1d34:	5f 81       	ldd	r21, Y+7	; 0x07
    1d36:	68 85       	ldd	r22, Y+8	; 0x08
    1d38:	79 85       	ldd	r23, Y+9	; 0x09
    1d3a:	c6 01       	movw	r24, r12
    1d3c:	0e 94 01 13 	call	0x2602	; 0x2602 <vTaskPlaceOnEventList>
    1d40:	c7 01       	movw	r24, r14
    1d42:	0e 94 b1 0c 	call	0x1962	; 0x1962 <prvUnlockQueue>
    1d46:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
    1d4a:	81 11       	cpse	r24, r1
    1d4c:	73 cf       	rjmp	.-282    	; 0x1c34 <xQueueGenericReceive+0x34>
    1d4e:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
    1d52:	70 cf       	rjmp	.-288    	; 0x1c34 <xQueueGenericReceive+0x34>
    1d54:	c7 01       	movw	r24, r14
    1d56:	0e 94 b1 0c 	call	0x1962	; 0x1962 <prvUnlockQueue>
    1d5a:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
    1d5e:	6a cf       	rjmp	.-300    	; 0x1c34 <xQueueGenericReceive+0x34>
    1d60:	c7 01       	movw	r24, r14
    1d62:	0e 94 b1 0c 	call	0x1962	; 0x1962 <prvUnlockQueue>
    1d66:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
    1d6a:	80 e0       	ldi	r24, 0x00	; 0
    1d6c:	29 96       	adiw	r28, 0x09	; 9
    1d6e:	cd bf       	out	0x3d, r28	; 61
    1d70:	de bf       	out	0x3e, r29	; 62
    1d72:	df 91       	pop	r29
    1d74:	cf 91       	pop	r28
    1d76:	1f 91       	pop	r17
    1d78:	0f 91       	pop	r16
    1d7a:	ff 90       	pop	r15
    1d7c:	ef 90       	pop	r14
    1d7e:	df 90       	pop	r13
    1d80:	cf 90       	pop	r12
    1d82:	bf 90       	pop	r11
    1d84:	af 90       	pop	r10
    1d86:	08 95       	ret

00001d88 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d88:	0f b6       	in	r0, 0x3f	; 63
    1d8a:	f8 94       	cli
    1d8c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d8e:	fc 01       	movw	r30, r24
    1d90:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d92:	0f 90       	pop	r0
    1d94:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d96:	08 95       	ret

00001d98 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d98:	c8 ef       	ldi	r28, 0xF8	; 248
    1d9a:	d0 e3       	ldi	r29, 0x30	; 48
    1d9c:	88 81       	ld	r24, Y
    1d9e:	82 30       	cpi	r24, 0x02	; 2
    1da0:	e8 f3       	brcs	.-6      	; 0x1d9c <prvIdleTask+0x4>
    1da2:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
    1da6:	fa cf       	rjmp	.-12     	; 0x1d9c <prvIdleTask+0x4>

00001da8 <prvAddCurrentTaskToDelayedList>:
    1da8:	cf 92       	push	r12
    1daa:	df 92       	push	r13
    1dac:	ef 92       	push	r14
    1dae:	ff 92       	push	r15
    1db0:	6b 01       	movw	r12, r22
    1db2:	7c 01       	movw	r14, r24
    1db4:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1db8:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1dbc:	62 83       	std	Z+2, r22	; 0x02
    1dbe:	73 83       	std	Z+3, r23	; 0x03
    1dc0:	84 83       	std	Z+4, r24	; 0x04
    1dc2:	95 83       	std	Z+5, r25	; 0x05
    1dc4:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    1dc8:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    1dcc:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    1dd0:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    1dd4:	c8 16       	cp	r12, r24
    1dd6:	d9 06       	cpc	r13, r25
    1dd8:	ea 06       	cpc	r14, r26
    1dda:	fb 06       	cpc	r15, r27
    1ddc:	68 f4       	brcc	.+26     	; 0x1df8 <prvAddCurrentTaskToDelayedList+0x50>
    1dde:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1de2:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1de6:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    1dea:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    1dee:	6e 5f       	subi	r22, 0xFE	; 254
    1df0:	7f 4f       	sbci	r23, 0xFF	; 255
    1df2:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsert>
    1df6:	21 c0       	rjmp	.+66     	; 0x1e3a <prvAddCurrentTaskToDelayedList+0x92>
    1df8:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1dfc:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1e00:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    1e04:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    1e08:	6e 5f       	subi	r22, 0xFE	; 254
    1e0a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e0c:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsert>
    1e10:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e14:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e18:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e1c:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e20:	c8 16       	cp	r12, r24
    1e22:	d9 06       	cpc	r13, r25
    1e24:	ea 06       	cpc	r14, r26
    1e26:	fb 06       	cpc	r15, r27
    1e28:	40 f4       	brcc	.+16     	; 0x1e3a <prvAddCurrentTaskToDelayedList+0x92>
    1e2a:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e2e:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e32:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e36:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e3a:	ff 90       	pop	r15
    1e3c:	ef 90       	pop	r14
    1e3e:	df 90       	pop	r13
    1e40:	cf 90       	pop	r12
    1e42:	08 95       	ret

00001e44 <xTaskGenericCreate>:
    1e44:	4f 92       	push	r4
    1e46:	5f 92       	push	r5
    1e48:	6f 92       	push	r6
    1e4a:	7f 92       	push	r7
    1e4c:	8f 92       	push	r8
    1e4e:	9f 92       	push	r9
    1e50:	af 92       	push	r10
    1e52:	bf 92       	push	r11
    1e54:	cf 92       	push	r12
    1e56:	df 92       	push	r13
    1e58:	ef 92       	push	r14
    1e5a:	ff 92       	push	r15
    1e5c:	0f 93       	push	r16
    1e5e:	1f 93       	push	r17
    1e60:	cf 93       	push	r28
    1e62:	df 93       	push	r29
    1e64:	5c 01       	movw	r10, r24
    1e66:	4b 01       	movw	r8, r22
    1e68:	3a 01       	movw	r6, r20
    1e6a:	29 01       	movw	r4, r18
    1e6c:	88 e2       	ldi	r24, 0x28	; 40
    1e6e:	90 e0       	ldi	r25, 0x00	; 0
    1e70:	0e 94 51 09 	call	0x12a2	; 0x12a2 <pvPortMalloc>
    1e74:	ec 01       	movw	r28, r24
    1e76:	89 2b       	or	r24, r25
    1e78:	09 f4       	brne	.+2      	; 0x1e7c <xTaskGenericCreate+0x38>
    1e7a:	d4 c0       	rjmp	.+424    	; 0x2024 <xTaskGenericCreate+0x1e0>
    1e7c:	c1 14       	cp	r12, r1
    1e7e:	d1 04       	cpc	r13, r1
    1e80:	09 f0       	breq	.+2      	; 0x1e84 <xTaskGenericCreate+0x40>
    1e82:	cc c0       	rjmp	.+408    	; 0x201c <xTaskGenericCreate+0x1d8>
    1e84:	c3 01       	movw	r24, r6
    1e86:	0e 94 51 09 	call	0x12a2	; 0x12a2 <pvPortMalloc>
    1e8a:	8b 8f       	std	Y+27, r24	; 0x1b
    1e8c:	9c 8f       	std	Y+28, r25	; 0x1c
    1e8e:	00 97       	sbiw	r24, 0x00	; 0
    1e90:	21 f4       	brne	.+8      	; 0x1e9a <xTaskGenericCreate+0x56>
    1e92:	ce 01       	movw	r24, r28
    1e94:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vPortFree>
    1e98:	c5 c0       	rjmp	.+394    	; 0x2024 <xTaskGenericCreate+0x1e0>
    1e9a:	a3 01       	movw	r20, r6
    1e9c:	61 e1       	ldi	r22, 0x11	; 17
    1e9e:	70 e0       	ldi	r23, 0x00	; 0
    1ea0:	0e 94 14 20 	call	0x4028	; 0x4028 <memset>
    1ea4:	93 01       	movw	r18, r6
    1ea6:	21 50       	subi	r18, 0x01	; 1
    1ea8:	31 09       	sbc	r19, r1
    1eaa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1eac:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1eae:	3c 01       	movw	r6, r24
    1eb0:	62 0e       	add	r6, r18
    1eb2:	73 1e       	adc	r7, r19
    1eb4:	4a e0       	ldi	r20, 0x0A	; 10
    1eb6:	50 e0       	ldi	r21, 0x00	; 0
    1eb8:	b4 01       	movw	r22, r8
    1eba:	ce 01       	movw	r24, r28
    1ebc:	4d 96       	adiw	r24, 0x1d	; 29
    1ebe:	0e 94 1b 20 	call	0x4036	; 0x4036 <strncpy>
    1ec2:	1e a2       	std	Y+38, r1	; 0x26
    1ec4:	10 2f       	mov	r17, r16
    1ec6:	04 30       	cpi	r16, 0x04	; 4
    1ec8:	08 f0       	brcs	.+2      	; 0x1ecc <xTaskGenericCreate+0x88>
    1eca:	13 e0       	ldi	r17, 0x03	; 3
    1ecc:	1a 8f       	std	Y+26, r17	; 0x1a
    1ece:	1f a3       	std	Y+39, r17	; 0x27
    1ed0:	6e 01       	movw	r12, r28
    1ed2:	22 e0       	ldi	r18, 0x02	; 2
    1ed4:	c2 0e       	add	r12, r18
    1ed6:	d1 1c       	adc	r13, r1
    1ed8:	c6 01       	movw	r24, r12
    1eda:	0e 94 34 0a 	call	0x1468	; 0x1468 <vListInitialiseItem>
    1ede:	ce 01       	movw	r24, r28
    1ee0:	0e 96       	adiw	r24, 0x0e	; 14
    1ee2:	0e 94 34 0a 	call	0x1468	; 0x1468 <vListInitialiseItem>
    1ee6:	ca 87       	std	Y+10, r28	; 0x0a
    1ee8:	db 87       	std	Y+11, r29	; 0x0b
    1eea:	84 e0       	ldi	r24, 0x04	; 4
    1eec:	90 e0       	ldi	r25, 0x00	; 0
    1eee:	a0 e0       	ldi	r26, 0x00	; 0
    1ef0:	b0 e0       	ldi	r27, 0x00	; 0
    1ef2:	81 1b       	sub	r24, r17
    1ef4:	91 09       	sbc	r25, r1
    1ef6:	a1 09       	sbc	r26, r1
    1ef8:	b1 09       	sbc	r27, r1
    1efa:	8e 87       	std	Y+14, r24	; 0x0e
    1efc:	9f 87       	std	Y+15, r25	; 0x0f
    1efe:	a8 8b       	std	Y+16, r26	; 0x10
    1f00:	b9 8b       	std	Y+17, r27	; 0x11
    1f02:	ce 8b       	std	Y+22, r28	; 0x16
    1f04:	df 8b       	std	Y+23, r29	; 0x17
    1f06:	a2 01       	movw	r20, r4
    1f08:	b5 01       	movw	r22, r10
    1f0a:	c3 01       	movw	r24, r6
    1f0c:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <pxPortInitialiseStack>
    1f10:	88 83       	st	Y, r24
    1f12:	99 83       	std	Y+1, r25	; 0x01
    1f14:	e1 14       	cp	r14, r1
    1f16:	f1 04       	cpc	r15, r1
    1f18:	19 f0       	breq	.+6      	; 0x1f20 <xTaskGenericCreate+0xdc>
    1f1a:	f7 01       	movw	r30, r14
    1f1c:	c0 83       	st	Z, r28
    1f1e:	d1 83       	std	Z+1, r29	; 0x01
    1f20:	0f b6       	in	r0, 0x3f	; 63
    1f22:	f8 94       	cli
    1f24:	0f 92       	push	r0
    1f26:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f2a:	8f 5f       	subi	r24, 0xFF	; 255
    1f2c:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f30:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    1f34:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1f38:	89 2b       	or	r24, r25
    1f3a:	89 f5       	brne	.+98     	; 0x1f9e <xTaskGenericCreate+0x15a>
    1f3c:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    1f40:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    1f44:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f48:	81 30       	cpi	r24, 0x01	; 1
    1f4a:	c1 f5       	brne	.+112    	; 0x1fbc <xTaskGenericCreate+0x178>
    1f4c:	88 ef       	ldi	r24, 0xF8	; 248
    1f4e:	90 e3       	ldi	r25, 0x30	; 48
    1f50:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1f54:	83 e0       	ldi	r24, 0x03	; 3
    1f56:	91 e3       	ldi	r25, 0x31	; 49
    1f58:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1f5c:	8e e0       	ldi	r24, 0x0E	; 14
    1f5e:	91 e3       	ldi	r25, 0x31	; 49
    1f60:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1f64:	89 e1       	ldi	r24, 0x19	; 25
    1f66:	91 e3       	ldi	r25, 0x31	; 49
    1f68:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1f6c:	8d ee       	ldi	r24, 0xED	; 237
    1f6e:	90 e3       	ldi	r25, 0x30	; 48
    1f70:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1f74:	82 ee       	ldi	r24, 0xE2	; 226
    1f76:	90 e3       	ldi	r25, 0x30	; 48
    1f78:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1f7c:	83 ed       	ldi	r24, 0xD3	; 211
    1f7e:	90 e3       	ldi	r25, 0x30	; 48
    1f80:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialise>
    1f84:	8d ee       	ldi	r24, 0xED	; 237
    1f86:	90 e3       	ldi	r25, 0x30	; 48
    1f88:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    1f8c:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    1f90:	82 ee       	ldi	r24, 0xE2	; 226
    1f92:	90 e3       	ldi	r25, 0x30	; 48
    1f94:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    1f98:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    1f9c:	0f c0       	rjmp	.+30     	; 0x1fbc <xTaskGenericCreate+0x178>
    1f9e:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    1fa2:	81 11       	cpse	r24, r1
    1fa4:	0b c0       	rjmp	.+22     	; 0x1fbc <xTaskGenericCreate+0x178>
    1fa6:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1faa:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1fae:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb0:	08 17       	cp	r16, r24
    1fb2:	20 f0       	brcs	.+8      	; 0x1fbc <xTaskGenericCreate+0x178>
    1fb4:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    1fb8:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    1fbc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fbe:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    1fc2:	98 17       	cp	r25, r24
    1fc4:	10 f4       	brcc	.+4      	; 0x1fca <xTaskGenericCreate+0x186>
    1fc6:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    1fca:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    1fce:	9f 5f       	subi	r25, 0xFF	; 255
    1fd0:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    1fd4:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    1fd8:	98 17       	cp	r25, r24
    1fda:	10 f4       	brcc	.+4      	; 0x1fe0 <xTaskGenericCreate+0x19c>
    1fdc:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    1fe0:	fb e0       	ldi	r31, 0x0B	; 11
    1fe2:	8f 9f       	mul	r24, r31
    1fe4:	c0 01       	movw	r24, r0
    1fe6:	11 24       	eor	r1, r1
    1fe8:	b6 01       	movw	r22, r12
    1fea:	88 50       	subi	r24, 0x08	; 8
    1fec:	9f 4c       	sbci	r25, 0xCF	; 207
    1fee:	0e 94 38 0a 	call	0x1470	; 0x1470 <vListInsertEnd>
    1ff2:	0f 90       	pop	r0
    1ff4:	0f be       	out	0x3f, r0	; 63
    1ff6:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    1ffa:	88 23       	and	r24, r24
    1ffc:	59 f0       	breq	.+22     	; 0x2014 <xTaskGenericCreate+0x1d0>
    1ffe:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2002:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2006:	82 8d       	ldd	r24, Z+26	; 0x1a
    2008:	80 17       	cp	r24, r16
    200a:	30 f4       	brcc	.+12     	; 0x2018 <xTaskGenericCreate+0x1d4>
    200c:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
    2010:	81 e0       	ldi	r24, 0x01	; 1
    2012:	09 c0       	rjmp	.+18     	; 0x2026 <xTaskGenericCreate+0x1e2>
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	07 c0       	rjmp	.+14     	; 0x2026 <xTaskGenericCreate+0x1e2>
    2018:	81 e0       	ldi	r24, 0x01	; 1
    201a:	05 c0       	rjmp	.+10     	; 0x2026 <xTaskGenericCreate+0x1e2>
    201c:	cb 8e       	std	Y+27, r12	; 0x1b
    201e:	dc 8e       	std	Y+28, r13	; 0x1c
    2020:	c6 01       	movw	r24, r12
    2022:	3b cf       	rjmp	.-394    	; 0x1e9a <xTaskGenericCreate+0x56>
    2024:	8f ef       	ldi	r24, 0xFF	; 255
    2026:	df 91       	pop	r29
    2028:	cf 91       	pop	r28
    202a:	1f 91       	pop	r17
    202c:	0f 91       	pop	r16
    202e:	ff 90       	pop	r15
    2030:	ef 90       	pop	r14
    2032:	df 90       	pop	r13
    2034:	cf 90       	pop	r12
    2036:	bf 90       	pop	r11
    2038:	af 90       	pop	r10
    203a:	9f 90       	pop	r9
    203c:	8f 90       	pop	r8
    203e:	7f 90       	pop	r7
    2040:	6f 90       	pop	r6
    2042:	5f 90       	pop	r5
    2044:	4f 90       	pop	r4
    2046:	08 95       	ret

00002048 <uxTaskPriorityGet>:
    2048:	0f b6       	in	r0, 0x3f	; 63
    204a:	f8 94       	cli
    204c:	0f 92       	push	r0
    204e:	00 97       	sbiw	r24, 0x00	; 0
    2050:	21 f4       	brne	.+8      	; 0x205a <uxTaskPriorityGet+0x12>
    2052:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2056:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    205a:	0f 90       	pop	r0
    205c:	0f be       	out	0x3f, r0	; 63
    205e:	fc 01       	movw	r30, r24
    2060:	82 8d       	ldd	r24, Z+26	; 0x1a
    2062:	08 95       	ret

00002064 <vTaskStartScheduler>:
    2064:	af 92       	push	r10
    2066:	bf 92       	push	r11
    2068:	cf 92       	push	r12
    206a:	df 92       	push	r13
    206c:	ef 92       	push	r14
    206e:	ff 92       	push	r15
    2070:	0f 93       	push	r16
    2072:	a1 2c       	mov	r10, r1
    2074:	b1 2c       	mov	r11, r1
    2076:	c1 2c       	mov	r12, r1
    2078:	d1 2c       	mov	r13, r1
    207a:	0f 2e       	mov	r0, r31
    207c:	f1 ed       	ldi	r31, 0xD1	; 209
    207e:	ef 2e       	mov	r14, r31
    2080:	f0 e3       	ldi	r31, 0x30	; 48
    2082:	ff 2e       	mov	r15, r31
    2084:	f0 2d       	mov	r31, r0
    2086:	00 e0       	ldi	r16, 0x00	; 0
    2088:	20 e0       	ldi	r18, 0x00	; 0
    208a:	30 e0       	ldi	r19, 0x00	; 0
    208c:	44 e6       	ldi	r20, 0x64	; 100
    208e:	50 e0       	ldi	r21, 0x00	; 0
    2090:	66 e3       	ldi	r22, 0x36	; 54
    2092:	70 e2       	ldi	r23, 0x20	; 32
    2094:	8c ec       	ldi	r24, 0xCC	; 204
    2096:	9e e0       	ldi	r25, 0x0E	; 14
    2098:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <xTaskGenericCreate>
    209c:	81 30       	cpi	r24, 0x01	; 1
    209e:	69 f4       	brne	.+26     	; 0x20ba <vTaskStartScheduler+0x56>
    20a0:	f8 94       	cli
    20a2:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    20a6:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    20aa:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    20ae:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    20b2:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    20b6:	0e 94 46 0b 	call	0x168c	; 0x168c <xPortStartScheduler>
    20ba:	0f 91       	pop	r16
    20bc:	ff 90       	pop	r15
    20be:	ef 90       	pop	r14
    20c0:	df 90       	pop	r13
    20c2:	cf 90       	pop	r12
    20c4:	bf 90       	pop	r11
    20c6:	af 90       	pop	r10
    20c8:	08 95       	ret

000020ca <vTaskSuspendAll>:
    20ca:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    20ce:	8f 5f       	subi	r24, 0xFF	; 255
    20d0:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    20d4:	08 95       	ret

000020d6 <xTaskGetTickCount>:
    20d6:	0f b6       	in	r0, 0x3f	; 63
    20d8:	f8 94       	cli
    20da:	0f 92       	push	r0
    20dc:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    20e0:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    20e4:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    20e8:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    20ec:	0f 90       	pop	r0
    20ee:	0f be       	out	0x3f, r0	; 63
    20f0:	08 95       	ret

000020f2 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20f2:	00 97       	sbiw	r24, 0x00	; 0
    20f4:	21 f4       	brne	.+8      	; 0x20fe <pcTaskGetTaskName+0xc>
    20f6:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    20fa:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20fe:	4d 96       	adiw	r24, 0x1d	; 29
    2100:	08 95       	ret

00002102 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2102:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    2106:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    210a:	08 95       	ret

0000210c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    210c:	ff 92       	push	r15
    210e:	0f 93       	push	r16
    2110:	1f 93       	push	r17
    2112:	cf 93       	push	r28
    2114:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2116:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    211a:	81 11       	cpse	r24, r1
    211c:	ed c0       	rjmp	.+474    	; 0x22f8 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    211e:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2122:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2126:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    212a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    212e:	01 96       	adiw	r24, 0x01	; 1
    2130:	a1 1d       	adc	r26, r1
    2132:	b1 1d       	adc	r27, r1
    2134:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2138:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    213c:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    2140:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2144:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2148:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    214c:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2150:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2154:	89 2b       	or	r24, r25
    2156:	8a 2b       	or	r24, r26
    2158:	8b 2b       	or	r24, r27
    215a:	f1 f5       	brne	.+124    	; 0x21d8 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    215c:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2160:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2164:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2168:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    216c:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    2170:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2174:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    2178:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    217c:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2180:	8f 5f       	subi	r24, 0xFF	; 255
    2182:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2186:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    218a:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    218e:	80 81       	ld	r24, Z
    2190:	81 11       	cpse	r24, r1
    2192:	0c c0       	rjmp	.+24     	; 0x21ac <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2194:	8f ef       	ldi	r24, 0xFF	; 255
    2196:	9f ef       	ldi	r25, 0xFF	; 255
    2198:	dc 01       	movw	r26, r24
    219a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    219e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21a2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21a6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    21aa:	16 c0       	rjmp	.+44     	; 0x21d8 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    21ac:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    21b0:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    21b4:	07 80       	ldd	r0, Z+7	; 0x07
    21b6:	f0 85       	ldd	r31, Z+8	; 0x08
    21b8:	e0 2d       	mov	r30, r0
    21ba:	00 84       	ldd	r0, Z+8	; 0x08
    21bc:	f1 85       	ldd	r31, Z+9	; 0x09
    21be:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    21c0:	82 81       	ldd	r24, Z+2	; 0x02
    21c2:	93 81       	ldd	r25, Z+3	; 0x03
    21c4:	a4 81       	ldd	r26, Z+4	; 0x04
    21c6:	b5 81       	ldd	r27, Z+5	; 0x05
    21c8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21cc:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21d0:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21d4:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    21d8:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    21dc:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    21e0:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    21e4:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    21e8:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    21ec:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21f0:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21f4:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21f8:	48 17       	cp	r20, r24
    21fa:	59 07       	cpc	r21, r25
    21fc:	6a 07       	cpc	r22, r26
    21fe:	7b 07       	cpc	r23, r27
    2200:	08 f4       	brcc	.+2      	; 0x2204 <vTaskIncrementTick+0xf8>
    2202:	7f c0       	rjmp	.+254    	; 0x2302 <vTaskIncrementTick+0x1f6>
    2204:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2208:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    220c:	80 81       	ld	r24, Z
    220e:	88 23       	and	r24, r24
    2210:	f9 f0       	breq	.+62     	; 0x2250 <vTaskIncrementTick+0x144>
    2212:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2216:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    221a:	07 80       	ldd	r0, Z+7	; 0x07
    221c:	f0 85       	ldd	r31, Z+8	; 0x08
    221e:	e0 2d       	mov	r30, r0
    2220:	c0 85       	ldd	r28, Z+8	; 0x08
    2222:	d1 85       	ldd	r29, Z+9	; 0x09
    2224:	8a 81       	ldd	r24, Y+2	; 0x02
    2226:	9b 81       	ldd	r25, Y+3	; 0x03
    2228:	ac 81       	ldd	r26, Y+4	; 0x04
    222a:	bd 81       	ldd	r27, Y+5	; 0x05
    222c:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2230:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2234:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2238:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    223c:	48 17       	cp	r20, r24
    223e:	59 07       	cpc	r21, r25
    2240:	6a 07       	cpc	r22, r26
    2242:	7b 07       	cpc	r23, r27
    2244:	58 f1       	brcs	.+86     	; 0x229c <vTaskIncrementTick+0x190>
    2246:	0f 2e       	mov	r0, r31
    2248:	fb e0       	ldi	r31, 0x0B	; 11
    224a:	ff 2e       	mov	r15, r31
    224c:	f0 2d       	mov	r31, r0
    224e:	2f c0       	rjmp	.+94     	; 0x22ae <vTaskIncrementTick+0x1a2>
    2250:	8f ef       	ldi	r24, 0xFF	; 255
    2252:	9f ef       	ldi	r25, 0xFF	; 255
    2254:	dc 01       	movw	r26, r24
    2256:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    225a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    225e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2262:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2266:	4d c0       	rjmp	.+154    	; 0x2302 <vTaskIncrementTick+0x1f6>
    2268:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    226c:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2270:	07 80       	ldd	r0, Z+7	; 0x07
    2272:	f0 85       	ldd	r31, Z+8	; 0x08
    2274:	e0 2d       	mov	r30, r0
    2276:	c0 85       	ldd	r28, Z+8	; 0x08
    2278:	d1 85       	ldd	r29, Z+9	; 0x09
    227a:	8a 81       	ldd	r24, Y+2	; 0x02
    227c:	9b 81       	ldd	r25, Y+3	; 0x03
    227e:	ac 81       	ldd	r26, Y+4	; 0x04
    2280:	bd 81       	ldd	r27, Y+5	; 0x05
    2282:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2286:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    228a:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    228e:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2292:	48 17       	cp	r20, r24
    2294:	59 07       	cpc	r21, r25
    2296:	6a 07       	cpc	r22, r26
    2298:	7b 07       	cpc	r23, r27
    229a:	48 f4       	brcc	.+18     	; 0x22ae <vTaskIncrementTick+0x1a2>
    229c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22a0:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22a4:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22a8:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    22ac:	2a c0       	rjmp	.+84     	; 0x2302 <vTaskIncrementTick+0x1f6>
    22ae:	8e 01       	movw	r16, r28
    22b0:	0e 5f       	subi	r16, 0xFE	; 254
    22b2:	1f 4f       	sbci	r17, 0xFF	; 255
    22b4:	c8 01       	movw	r24, r16
    22b6:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>
    22ba:	88 8d       	ldd	r24, Y+24	; 0x18
    22bc:	99 8d       	ldd	r25, Y+25	; 0x19
    22be:	89 2b       	or	r24, r25
    22c0:	21 f0       	breq	.+8      	; 0x22ca <vTaskIncrementTick+0x1be>
    22c2:	ce 01       	movw	r24, r28
    22c4:	0e 96       	adiw	r24, 0x0e	; 14
    22c6:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>
    22ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22cc:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    22d0:	98 17       	cp	r25, r24
    22d2:	10 f4       	brcc	.+4      	; 0x22d8 <vTaskIncrementTick+0x1cc>
    22d4:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    22d8:	f8 9e       	mul	r15, r24
    22da:	c0 01       	movw	r24, r0
    22dc:	11 24       	eor	r1, r1
    22de:	b8 01       	movw	r22, r16
    22e0:	88 50       	subi	r24, 0x08	; 8
    22e2:	9f 4c       	sbci	r25, 0xCF	; 207
    22e4:	0e 94 38 0a 	call	0x1470	; 0x1470 <vListInsertEnd>
    22e8:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    22ec:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    22f0:	80 81       	ld	r24, Z
    22f2:	81 11       	cpse	r24, r1
    22f4:	b9 cf       	rjmp	.-142    	; 0x2268 <vTaskIncrementTick+0x15c>
    22f6:	ac cf       	rjmp	.-168    	; 0x2250 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22f8:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    22fc:	8f 5f       	subi	r24, 0xFF	; 255
    22fe:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2302:	df 91       	pop	r29
    2304:	cf 91       	pop	r28
    2306:	1f 91       	pop	r17
    2308:	0f 91       	pop	r16
    230a:	ff 90       	pop	r15
    230c:	08 95       	ret

0000230e <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    230e:	cf 92       	push	r12
    2310:	df 92       	push	r13
    2312:	ef 92       	push	r14
    2314:	ff 92       	push	r15
    2316:	0f 93       	push	r16
    2318:	1f 93       	push	r17
    231a:	cf 93       	push	r28
    231c:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	f8 94       	cli
    2322:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2324:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2328:	81 50       	subi	r24, 0x01	; 1
    232a:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    232e:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2332:	81 11       	cpse	r24, r1
    2334:	60 c0       	rjmp	.+192    	; 0x23f6 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2336:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    233a:	81 11       	cpse	r24, r1
    233c:	2c c0       	rjmp	.+88     	; 0x2396 <xTaskResumeAll+0x88>
    233e:	5e c0       	rjmp	.+188    	; 0x23fc <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2340:	d7 01       	movw	r26, r14
    2342:	17 96       	adiw	r26, 0x07	; 7
    2344:	ed 91       	ld	r30, X+
    2346:	fc 91       	ld	r31, X
    2348:	18 97       	sbiw	r26, 0x08	; 8
    234a:	c0 85       	ldd	r28, Z+8	; 0x08
    234c:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    234e:	ce 01       	movw	r24, r28
    2350:	0e 96       	adiw	r24, 0x0e	; 14
    2352:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2356:	8e 01       	movw	r16, r28
    2358:	0e 5f       	subi	r16, 0xFE	; 254
    235a:	1f 4f       	sbci	r17, 0xFF	; 255
    235c:	c8 01       	movw	r24, r16
    235e:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2362:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2364:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2368:	98 17       	cp	r25, r24
    236a:	10 f4       	brcc	.+4      	; 0x2370 <xTaskResumeAll+0x62>
    236c:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2370:	d8 9e       	mul	r13, r24
    2372:	c0 01       	movw	r24, r0
    2374:	11 24       	eor	r1, r1
    2376:	b8 01       	movw	r22, r16
    2378:	88 50       	subi	r24, 0x08	; 8
    237a:	9f 4c       	sbci	r25, 0xCF	; 207
    237c:	0e 94 38 0a 	call	0x1470	; 0x1470 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2380:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2384:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2388:	9a 8d       	ldd	r25, Y+26	; 0x1a
    238a:	82 8d       	ldd	r24, Z+26	; 0x1a
    238c:	98 17       	cp	r25, r24
    238e:	70 f0       	brcs	.+28     	; 0x23ac <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2390:	cc 24       	eor	r12, r12
    2392:	c3 94       	inc	r12
    2394:	0b c0       	rjmp	.+22     	; 0x23ac <xTaskResumeAll+0x9e>
    2396:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2398:	0f 2e       	mov	r0, r31
    239a:	f3 ed       	ldi	r31, 0xD3	; 211
    239c:	ef 2e       	mov	r14, r31
    239e:	f0 e3       	ldi	r31, 0x30	; 48
    23a0:	ff 2e       	mov	r15, r31
    23a2:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    23a4:	0f 2e       	mov	r0, r31
    23a6:	fb e0       	ldi	r31, 0x0B	; 11
    23a8:	df 2e       	mov	r13, r31
    23aa:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    23ac:	f7 01       	movw	r30, r14
    23ae:	80 81       	ld	r24, Z
    23b0:	81 11       	cpse	r24, r1
    23b2:	c6 cf       	rjmp	.-116    	; 0x2340 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23b4:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23b8:	88 23       	and	r24, r24
    23ba:	81 f0       	breq	.+32     	; 0x23dc <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23bc:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23c0:	88 23       	and	r24, r24
    23c2:	99 f0       	breq	.+38     	; 0x23ea <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    23c4:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskIncrementTick>
						--uxMissedTicks;
    23c8:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23cc:	81 50       	subi	r24, 0x01	; 1
    23ce:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23d2:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23d6:	81 11       	cpse	r24, r1
    23d8:	f5 cf       	rjmp	.-22     	; 0x23c4 <xTaskResumeAll+0xb6>
    23da:	07 c0       	rjmp	.+14     	; 0x23ea <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    23dc:	f1 e0       	ldi	r31, 0x01	; 1
    23de:	cf 16       	cp	r12, r31
    23e0:	21 f0       	breq	.+8      	; 0x23ea <xTaskResumeAll+0xdc>
    23e2:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    23e6:	81 30       	cpi	r24, 0x01	; 1
    23e8:	41 f4       	brne	.+16     	; 0x23fa <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23ea:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    23ee:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23f2:	81 e0       	ldi	r24, 0x01	; 1
    23f4:	03 c0       	rjmp	.+6      	; 0x23fc <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23f6:	80 e0       	ldi	r24, 0x00	; 0
    23f8:	01 c0       	rjmp	.+2      	; 0x23fc <xTaskResumeAll+0xee>
    23fa:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23fc:	0f 90       	pop	r0
    23fe:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2400:	df 91       	pop	r29
    2402:	cf 91       	pop	r28
    2404:	1f 91       	pop	r17
    2406:	0f 91       	pop	r16
    2408:	ff 90       	pop	r15
    240a:	ef 90       	pop	r14
    240c:	df 90       	pop	r13
    240e:	cf 90       	pop	r12
    2410:	08 95       	ret

00002412 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2412:	cf 92       	push	r12
    2414:	df 92       	push	r13
    2416:	ef 92       	push	r14
    2418:	ff 92       	push	r15
    241a:	cf 93       	push	r28
    241c:	df 93       	push	r29
    241e:	ec 01       	movw	r28, r24
    2420:	6a 01       	movw	r12, r20
    2422:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2424:	0e 94 65 10 	call	0x20ca	; 0x20ca <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2428:	88 81       	ld	r24, Y
    242a:	99 81       	ldd	r25, Y+1	; 0x01
    242c:	aa 81       	ldd	r26, Y+2	; 0x02
    242e:	bb 81       	ldd	r27, Y+3	; 0x03
    2430:	c8 0e       	add	r12, r24
    2432:	d9 1e       	adc	r13, r25
    2434:	ea 1e       	adc	r14, r26
    2436:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2438:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    243c:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2440:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2444:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2448:	48 17       	cp	r20, r24
    244a:	59 07       	cpc	r21, r25
    244c:	6a 07       	cpc	r22, r26
    244e:	7b 07       	cpc	r23, r27
    2450:	b8 f4       	brcc	.+46     	; 0x2480 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2452:	c8 16       	cp	r12, r24
    2454:	d9 06       	cpc	r13, r25
    2456:	ea 06       	cpc	r14, r26
    2458:	fb 06       	cpc	r15, r27
    245a:	e0 f5       	brcc	.+120    	; 0x24d4 <vTaskDelayUntil+0xc2>
    245c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2460:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2464:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2468:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    246c:	c8 82       	st	Y, r12
    246e:	d9 82       	std	Y+1, r13	; 0x01
    2470:	ea 82       	std	Y+2, r14	; 0x02
    2472:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2474:	8c 15       	cp	r24, r12
    2476:	9d 05       	cpc	r25, r13
    2478:	ae 05       	cpc	r26, r14
    247a:	bf 05       	cpc	r27, r15
    247c:	f8 f4       	brcc	.+62     	; 0x24bc <vTaskDelayUntil+0xaa>
    247e:	13 c0       	rjmp	.+38     	; 0x24a6 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2480:	c8 16       	cp	r12, r24
    2482:	d9 06       	cpc	r13, r25
    2484:	ea 06       	cpc	r14, r26
    2486:	fb 06       	cpc	r15, r27
    2488:	00 f1       	brcs	.+64     	; 0x24ca <vTaskDelayUntil+0xb8>
    248a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    248e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2492:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2496:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    249a:	8c 15       	cp	r24, r12
    249c:	9d 05       	cpc	r25, r13
    249e:	ae 05       	cpc	r26, r14
    24a0:	bf 05       	cpc	r27, r15
    24a2:	98 f0       	brcs	.+38     	; 0x24ca <vTaskDelayUntil+0xb8>
    24a4:	17 c0       	rjmp	.+46     	; 0x24d4 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24a6:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    24aa:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    24ae:	02 96       	adiw	r24, 0x02	; 2
    24b0:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24b4:	c7 01       	movw	r24, r14
    24b6:	b6 01       	movw	r22, r12
    24b8:	0e 94 d4 0e 	call	0x1da8	; 0x1da8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    24bc:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24c0:	81 11       	cpse	r24, r1
    24c2:	0d c0       	rjmp	.+26     	; 0x24de <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    24c4:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
		}
	}
    24c8:	0a c0       	rjmp	.+20     	; 0x24de <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24ca:	c8 82       	st	Y, r12
    24cc:	d9 82       	std	Y+1, r13	; 0x01
    24ce:	ea 82       	std	Y+2, r14	; 0x02
    24d0:	fb 82       	std	Y+3, r15	; 0x03
    24d2:	e9 cf       	rjmp	.-46     	; 0x24a6 <vTaskDelayUntil+0x94>
    24d4:	c8 82       	st	Y, r12
    24d6:	d9 82       	std	Y+1, r13	; 0x01
    24d8:	ea 82       	std	Y+2, r14	; 0x02
    24da:	fb 82       	std	Y+3, r15	; 0x03
    24dc:	ef cf       	rjmp	.-34     	; 0x24bc <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    24de:	df 91       	pop	r29
    24e0:	cf 91       	pop	r28
    24e2:	ff 90       	pop	r15
    24e4:	ef 90       	pop	r14
    24e6:	df 90       	pop	r13
    24e8:	cf 90       	pop	r12
    24ea:	08 95       	ret

000024ec <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    24ec:	cf 92       	push	r12
    24ee:	df 92       	push	r13
    24f0:	ef 92       	push	r14
    24f2:	ff 92       	push	r15
    24f4:	6b 01       	movw	r12, r22
    24f6:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24f8:	67 2b       	or	r22, r23
    24fa:	68 2b       	or	r22, r24
    24fc:	69 2b       	or	r22, r25
    24fe:	e9 f0       	breq	.+58     	; 0x253a <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2500:	0e 94 65 10 	call	0x20ca	; 0x20ca <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2504:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2508:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    250c:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2510:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2514:	c8 0e       	add	r12, r24
    2516:	d9 1e       	adc	r13, r25
    2518:	ea 1e       	adc	r14, r26
    251a:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    251c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2520:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2524:	02 96       	adiw	r24, 0x02	; 2
    2526:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    252a:	c7 01       	movw	r24, r14
    252c:	b6 01       	movw	r22, r12
    252e:	0e 94 d4 0e 	call	0x1da8	; 0x1da8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2532:	0e 94 87 11 	call	0x230e	; 0x230e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2536:	81 11       	cpse	r24, r1
    2538:	02 c0       	rjmp	.+4      	; 0x253e <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    253a:	0e 94 84 0b 	call	0x1708	; 0x1708 <vPortYield>
		}
	}
    253e:	ff 90       	pop	r15
    2540:	ef 90       	pop	r14
    2542:	df 90       	pop	r13
    2544:	cf 90       	pop	r12
    2546:	08 95       	ret

00002548 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2548:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    254c:	81 11       	cpse	r24, r1
    254e:	0c c0       	rjmp	.+24     	; 0x2568 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2550:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2554:	4b e0       	ldi	r20, 0x0B	; 11
    2556:	e4 9f       	mul	r30, r20
    2558:	f0 01       	movw	r30, r0
    255a:	11 24       	eor	r1, r1
    255c:	e8 50       	subi	r30, 0x08	; 8
    255e:	ff 4c       	sbci	r31, 0xCF	; 207
    2560:	80 81       	ld	r24, Z
    2562:	88 23       	and	r24, r24
    2564:	29 f0       	breq	.+10     	; 0x2570 <vTaskSwitchContext+0x28>
    2566:	14 c0       	rjmp	.+40     	; 0x2590 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2568:	81 e0       	ldi	r24, 0x01	; 1
    256a:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    256e:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2570:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2572:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2576:	81 50       	subi	r24, 0x01	; 1
    2578:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    257c:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2580:	9e 9f       	mul	r25, r30
    2582:	f0 01       	movw	r30, r0
    2584:	11 24       	eor	r1, r1
    2586:	e8 50       	subi	r30, 0x08	; 8
    2588:	ff 4c       	sbci	r31, 0xCF	; 207
    258a:	80 81       	ld	r24, Z
    258c:	88 23       	and	r24, r24
    258e:	89 f3       	breq	.-30     	; 0x2572 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2590:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2594:	28 2f       	mov	r18, r24
    2596:	30 e0       	ldi	r19, 0x00	; 0
    2598:	4b e0       	ldi	r20, 0x0B	; 11
    259a:	84 9f       	mul	r24, r20
    259c:	c0 01       	movw	r24, r0
    259e:	11 24       	eor	r1, r1
    25a0:	dc 01       	movw	r26, r24
    25a2:	a8 50       	subi	r26, 0x08	; 8
    25a4:	bf 4c       	sbci	r27, 0xCF	; 207
    25a6:	11 96       	adiw	r26, 0x01	; 1
    25a8:	ed 91       	ld	r30, X+
    25aa:	fc 91       	ld	r31, X
    25ac:	12 97       	sbiw	r26, 0x02	; 2
    25ae:	04 80       	ldd	r0, Z+4	; 0x04
    25b0:	f5 81       	ldd	r31, Z+5	; 0x05
    25b2:	e0 2d       	mov	r30, r0
    25b4:	11 96       	adiw	r26, 0x01	; 1
    25b6:	ed 93       	st	X+, r30
    25b8:	fc 93       	st	X, r31
    25ba:	12 97       	sbiw	r26, 0x02	; 2
    25bc:	85 50       	subi	r24, 0x05	; 5
    25be:	9f 4c       	sbci	r25, 0xCF	; 207
    25c0:	e8 17       	cp	r30, r24
    25c2:	f9 07       	cpc	r31, r25
    25c4:	61 f4       	brne	.+24     	; 0x25de <vTaskSwitchContext+0x96>
    25c6:	84 81       	ldd	r24, Z+4	; 0x04
    25c8:	95 81       	ldd	r25, Z+5	; 0x05
    25ca:	4b e0       	ldi	r20, 0x0B	; 11
    25cc:	42 9f       	mul	r20, r18
    25ce:	f0 01       	movw	r30, r0
    25d0:	43 9f       	mul	r20, r19
    25d2:	f0 0d       	add	r31, r0
    25d4:	11 24       	eor	r1, r1
    25d6:	e8 50       	subi	r30, 0x08	; 8
    25d8:	ff 4c       	sbci	r31, 0xCF	; 207
    25da:	81 83       	std	Z+1, r24	; 0x01
    25dc:	92 83       	std	Z+2, r25	; 0x02
    25de:	8b e0       	ldi	r24, 0x0B	; 11
    25e0:	82 9f       	mul	r24, r18
    25e2:	f0 01       	movw	r30, r0
    25e4:	83 9f       	mul	r24, r19
    25e6:	f0 0d       	add	r31, r0
    25e8:	11 24       	eor	r1, r1
    25ea:	e8 50       	subi	r30, 0x08	; 8
    25ec:	ff 4c       	sbci	r31, 0xCF	; 207
    25ee:	01 80       	ldd	r0, Z+1	; 0x01
    25f0:	f2 81       	ldd	r31, Z+2	; 0x02
    25f2:	e0 2d       	mov	r30, r0
    25f4:	80 85       	ldd	r24, Z+8	; 0x08
    25f6:	91 85       	ldd	r25, Z+9	; 0x09
    25f8:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    25fc:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    2600:	08 95       	ret

00002602 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2602:	cf 92       	push	r12
    2604:	df 92       	push	r13
    2606:	ef 92       	push	r14
    2608:	ff 92       	push	r15
    260a:	6a 01       	movw	r12, r20
    260c:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    260e:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2612:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2616:	62 5f       	subi	r22, 0xF2	; 242
    2618:	7f 4f       	sbci	r23, 0xFF	; 255
    261a:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    261e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2622:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2626:	02 96       	adiw	r24, 0x02	; 2
    2628:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    262c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2630:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2634:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2638:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    263c:	bc 01       	movw	r22, r24
    263e:	cd 01       	movw	r24, r26
    2640:	6c 0d       	add	r22, r12
    2642:	7d 1d       	adc	r23, r13
    2644:	8e 1d       	adc	r24, r14
    2646:	9f 1d       	adc	r25, r15
    2648:	0e 94 d4 0e 	call	0x1da8	; 0x1da8 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    264c:	ff 90       	pop	r15
    264e:	ef 90       	pop	r14
    2650:	df 90       	pop	r13
    2652:	cf 90       	pop	r12
    2654:	08 95       	ret

00002656 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2656:	0f 93       	push	r16
    2658:	1f 93       	push	r17
    265a:	cf 93       	push	r28
    265c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    265e:	dc 01       	movw	r26, r24
    2660:	17 96       	adiw	r26, 0x07	; 7
    2662:	ed 91       	ld	r30, X+
    2664:	fc 91       	ld	r31, X
    2666:	18 97       	sbiw	r26, 0x08	; 8
    2668:	c0 85       	ldd	r28, Z+8	; 0x08
    266a:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    266c:	8e 01       	movw	r16, r28
    266e:	02 5f       	subi	r16, 0xF2	; 242
    2670:	1f 4f       	sbci	r17, 0xFF	; 255
    2672:	c8 01       	movw	r24, r16
    2674:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2678:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    267c:	81 11       	cpse	r24, r1
    267e:	16 c0       	rjmp	.+44     	; 0x26ac <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2680:	0c 50       	subi	r16, 0x0C	; 12
    2682:	11 09       	sbc	r17, r1
    2684:	c8 01       	movw	r24, r16
    2686:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    268a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    268c:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2690:	98 17       	cp	r25, r24
    2692:	10 f4       	brcc	.+4      	; 0x2698 <xTaskRemoveFromEventList+0x42>
    2694:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2698:	bb e0       	ldi	r27, 0x0B	; 11
    269a:	8b 9f       	mul	r24, r27
    269c:	c0 01       	movw	r24, r0
    269e:	11 24       	eor	r1, r1
    26a0:	b8 01       	movw	r22, r16
    26a2:	88 50       	subi	r24, 0x08	; 8
    26a4:	9f 4c       	sbci	r25, 0xCF	; 207
    26a6:	0e 94 38 0a 	call	0x1470	; 0x1470 <vListInsertEnd>
    26aa:	05 c0       	rjmp	.+10     	; 0x26b6 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    26ac:	b8 01       	movw	r22, r16
    26ae:	83 ed       	ldi	r24, 0xD3	; 211
    26b0:	90 e3       	ldi	r25, 0x30	; 48
    26b2:	0e 94 38 0a 	call	0x1470	; 0x1470 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    26b6:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    26ba:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    26be:	81 e0       	ldi	r24, 0x01	; 1
    26c0:	2a 8d       	ldd	r18, Y+26	; 0x1a
    26c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    26c4:	29 17       	cp	r18, r25
    26c6:	08 f4       	brcc	.+2      	; 0x26ca <xTaskRemoveFromEventList+0x74>
    26c8:	80 e0       	ldi	r24, 0x00	; 0
}
    26ca:	df 91       	pop	r29
    26cc:	cf 91       	pop	r28
    26ce:	1f 91       	pop	r17
    26d0:	0f 91       	pop	r16
    26d2:	08 95       	ret

000026d4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    26d4:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    26d8:	fc 01       	movw	r30, r24
    26da:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    26dc:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    26e0:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    26e4:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    26e8:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    26ec:	41 83       	std	Z+1, r20	; 0x01
    26ee:	52 83       	std	Z+2, r21	; 0x02
    26f0:	63 83       	std	Z+3, r22	; 0x03
    26f2:	74 83       	std	Z+4, r23	; 0x04
    26f4:	08 95       	ret

000026f6 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26f6:	8f 92       	push	r8
    26f8:	9f 92       	push	r9
    26fa:	af 92       	push	r10
    26fc:	bf 92       	push	r11
    26fe:	cf 92       	push	r12
    2700:	df 92       	push	r13
    2702:	ef 92       	push	r14
    2704:	ff 92       	push	r15
    2706:	0f 93       	push	r16
    2708:	1f 93       	push	r17
    270a:	cf 93       	push	r28
    270c:	df 93       	push	r29
    270e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2710:	0f b6       	in	r0, 0x3f	; 63
    2712:	f8 94       	cli
    2714:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2716:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    271a:	90 81       	ld	r25, Z
    271c:	98 17       	cp	r25, r24
    271e:	89 f0       	breq	.+34     	; 0x2742 <xTaskCheckForTimeOut+0x4c>
    2720:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2724:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2728:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    272c:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2730:	01 81       	ldd	r16, Z+1	; 0x01
    2732:	12 81       	ldd	r17, Z+2	; 0x02
    2734:	23 81       	ldd	r18, Z+3	; 0x03
    2736:	34 81       	ldd	r19, Z+4	; 0x04
    2738:	80 17       	cp	r24, r16
    273a:	91 07       	cpc	r25, r17
    273c:	a2 07       	cpc	r26, r18
    273e:	b3 07       	cpc	r27, r19
    2740:	a8 f5       	brcc	.+106    	; 0x27ac <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2742:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2746:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    274a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    274e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2752:	c1 80       	ldd	r12, Z+1	; 0x01
    2754:	d2 80       	ldd	r13, Z+2	; 0x02
    2756:	e3 80       	ldd	r14, Z+3	; 0x03
    2758:	f4 80       	ldd	r15, Z+4	; 0x04
    275a:	eb 01       	movw	r28, r22
    275c:	08 81       	ld	r16, Y
    275e:	19 81       	ldd	r17, Y+1	; 0x01
    2760:	2a 81       	ldd	r18, Y+2	; 0x02
    2762:	3b 81       	ldd	r19, Y+3	; 0x03
    2764:	8c 19       	sub	r24, r12
    2766:	9d 09       	sbc	r25, r13
    2768:	ae 09       	sbc	r26, r14
    276a:	bf 09       	sbc	r27, r15
    276c:	80 17       	cp	r24, r16
    276e:	91 07       	cpc	r25, r17
    2770:	a2 07       	cpc	r26, r18
    2772:	b3 07       	cpc	r27, r19
    2774:	e8 f4       	brcc	.+58     	; 0x27b0 <xTaskCheckForTimeOut+0xba>
    2776:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2778:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    277c:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2780:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2784:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2788:	b5 01       	movw	r22, r10
    278a:	a4 01       	movw	r20, r8
    278c:	4c 19       	sub	r20, r12
    278e:	5d 09       	sbc	r21, r13
    2790:	6e 09       	sbc	r22, r14
    2792:	7f 09       	sbc	r23, r15
    2794:	04 1b       	sub	r16, r20
    2796:	15 0b       	sbc	r17, r21
    2798:	26 0b       	sbc	r18, r22
    279a:	37 0b       	sbc	r19, r23
    279c:	08 83       	st	Y, r16
    279e:	19 83       	std	Y+1, r17	; 0x01
    27a0:	2a 83       	std	Y+2, r18	; 0x02
    27a2:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    27a4:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    27a8:	80 e0       	ldi	r24, 0x00	; 0
    27aa:	03 c0       	rjmp	.+6      	; 0x27b2 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    27ac:	81 e0       	ldi	r24, 0x01	; 1
    27ae:	01 c0       	rjmp	.+2      	; 0x27b2 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    27b0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    27b2:	0f 90       	pop	r0
    27b4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    27b6:	df 91       	pop	r29
    27b8:	cf 91       	pop	r28
    27ba:	1f 91       	pop	r17
    27bc:	0f 91       	pop	r16
    27be:	ff 90       	pop	r15
    27c0:	ef 90       	pop	r14
    27c2:	df 90       	pop	r13
    27c4:	cf 90       	pop	r12
    27c6:	bf 90       	pop	r11
    27c8:	af 90       	pop	r10
    27ca:	9f 90       	pop	r9
    27cc:	8f 90       	pop	r8
    27ce:	08 95       	ret

000027d0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    27d0:	81 e0       	ldi	r24, 0x01	; 1
    27d2:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    27d6:	08 95       	ret

000027d8 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27d8:	00 97       	sbiw	r24, 0x00	; 0
    27da:	21 f4       	brne	.+8      	; 0x27e4 <uxTaskGetStackHighWaterMark+0xc>
    27dc:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    27e0:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    27e4:	dc 01       	movw	r26, r24
    27e6:	5b 96       	adiw	r26, 0x1b	; 27
    27e8:	ed 91       	ld	r30, X+
    27ea:	fc 91       	ld	r31, X
    27ec:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27ee:	80 81       	ld	r24, Z
    27f0:	81 31       	cpi	r24, 0x11	; 17
    27f2:	41 f4       	brne	.+16     	; 0x2804 <uxTaskGetStackHighWaterMark+0x2c>
    27f4:	31 96       	adiw	r30, 0x01	; 1
    27f6:	80 e0       	ldi	r24, 0x00	; 0
    27f8:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27fa:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27fc:	21 91       	ld	r18, Z+
    27fe:	21 31       	cpi	r18, 0x11	; 17
    2800:	e1 f3       	breq	.-8      	; 0x27fa <uxTaskGetStackHighWaterMark+0x22>
    2802:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2804:	80 e0       	ldi	r24, 0x00	; 0
    2806:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2808:	08 95       	ret

0000280a <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    280a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    280e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2812:	08 95       	ret

00002814 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2814:	0f 93       	push	r16
    2816:	1f 93       	push	r17
    2818:	cf 93       	push	r28
    281a:	df 93       	push	r29
    281c:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    281e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2820:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2824:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2828:	5a 96       	adiw	r26, 0x1a	; 26
    282a:	8c 91       	ld	r24, X
    282c:	28 17       	cp	r18, r24
    282e:	08 f0       	brcs	.+2      	; 0x2832 <vTaskPriorityInherit+0x1e>
    2830:	41 c0       	rjmp	.+130    	; 0x28b4 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2832:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2836:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    283a:	5a 96       	adiw	r26, 0x1a	; 26
    283c:	3c 91       	ld	r19, X
    283e:	84 e0       	ldi	r24, 0x04	; 4
    2840:	90 e0       	ldi	r25, 0x00	; 0
    2842:	a0 e0       	ldi	r26, 0x00	; 0
    2844:	b0 e0       	ldi	r27, 0x00	; 0
    2846:	83 1b       	sub	r24, r19
    2848:	91 09       	sbc	r25, r1
    284a:	a1 09       	sbc	r26, r1
    284c:	b1 09       	sbc	r27, r1
    284e:	86 87       	std	Z+14, r24	; 0x0e
    2850:	97 87       	std	Z+15, r25	; 0x0f
    2852:	a0 8b       	std	Z+16, r26	; 0x10
    2854:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2856:	8b e0       	ldi	r24, 0x0B	; 11
    2858:	28 9f       	mul	r18, r24
    285a:	90 01       	movw	r18, r0
    285c:	11 24       	eor	r1, r1
    285e:	28 50       	subi	r18, 0x08	; 8
    2860:	3f 4c       	sbci	r19, 0xCF	; 207
    2862:	84 85       	ldd	r24, Z+12	; 0x0c
    2864:	95 85       	ldd	r25, Z+13	; 0x0d
    2866:	82 17       	cp	r24, r18
    2868:	93 07       	cpc	r25, r19
    286a:	e9 f4       	brne	.+58     	; 0x28a6 <vTaskPriorityInherit+0x92>
    286c:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    286e:	ef 01       	movw	r28, r30
    2870:	22 96       	adiw	r28, 0x02	; 2
    2872:	ce 01       	movw	r24, r28
    2874:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2878:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    287c:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2880:	82 8d       	ldd	r24, Z+26	; 0x1a
    2882:	f8 01       	movw	r30, r16
    2884:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2886:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    288a:	98 17       	cp	r25, r24
    288c:	10 f4       	brcc	.+4      	; 0x2892 <vTaskPriorityInherit+0x7e>
    288e:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2892:	fb e0       	ldi	r31, 0x0B	; 11
    2894:	8f 9f       	mul	r24, r31
    2896:	c0 01       	movw	r24, r0
    2898:	11 24       	eor	r1, r1
    289a:	be 01       	movw	r22, r28
    289c:	88 50       	subi	r24, 0x08	; 8
    289e:	9f 4c       	sbci	r25, 0xCF	; 207
    28a0:	0e 94 38 0a 	call	0x1470	; 0x1470 <vListInsertEnd>
    28a4:	07 c0       	rjmp	.+14     	; 0x28b4 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    28a6:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    28aa:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    28ae:	5a 96       	adiw	r26, 0x1a	; 26
    28b0:	8c 91       	ld	r24, X
    28b2:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    28b4:	df 91       	pop	r29
    28b6:	cf 91       	pop	r28
    28b8:	1f 91       	pop	r17
    28ba:	0f 91       	pop	r16
    28bc:	08 95       	ret

000028be <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    28be:	0f 93       	push	r16
    28c0:	1f 93       	push	r17
    28c2:	cf 93       	push	r28
    28c4:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    28c6:	00 97       	sbiw	r24, 0x00	; 0
    28c8:	49 f1       	breq	.+82     	; 0x291c <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    28ca:	fc 01       	movw	r30, r24
    28cc:	32 8d       	ldd	r19, Z+26	; 0x1a
    28ce:	27 a1       	ldd	r18, Z+39	; 0x27
    28d0:	32 17       	cp	r19, r18
    28d2:	21 f1       	breq	.+72     	; 0x291c <vTaskPriorityDisinherit+0x5e>
    28d4:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    28d6:	8c 01       	movw	r16, r24
    28d8:	0e 5f       	subi	r16, 0xFE	; 254
    28da:	1f 4f       	sbci	r17, 0xFF	; 255
    28dc:	c8 01       	movw	r24, r16
    28de:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28e2:	8f a1       	ldd	r24, Y+39	; 0x27
    28e4:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28e6:	44 e0       	ldi	r20, 0x04	; 4
    28e8:	50 e0       	ldi	r21, 0x00	; 0
    28ea:	60 e0       	ldi	r22, 0x00	; 0
    28ec:	70 e0       	ldi	r23, 0x00	; 0
    28ee:	48 1b       	sub	r20, r24
    28f0:	51 09       	sbc	r21, r1
    28f2:	61 09       	sbc	r22, r1
    28f4:	71 09       	sbc	r23, r1
    28f6:	4e 87       	std	Y+14, r20	; 0x0e
    28f8:	5f 87       	std	Y+15, r21	; 0x0f
    28fa:	68 8b       	std	Y+16, r22	; 0x10
    28fc:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28fe:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2902:	98 17       	cp	r25, r24
    2904:	10 f4       	brcc	.+4      	; 0x290a <vTaskPriorityDisinherit+0x4c>
    2906:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    290a:	fb e0       	ldi	r31, 0x0B	; 11
    290c:	8f 9f       	mul	r24, r31
    290e:	c0 01       	movw	r24, r0
    2910:	11 24       	eor	r1, r1
    2912:	b8 01       	movw	r22, r16
    2914:	88 50       	subi	r24, 0x08	; 8
    2916:	9f 4c       	sbci	r25, 0xCF	; 207
    2918:	0e 94 38 0a 	call	0x1470	; 0x1470 <vListInsertEnd>
			}
		}
	}
    291c:	df 91       	pop	r29
    291e:	cf 91       	pop	r28
    2920:	1f 91       	pop	r17
    2922:	0f 91       	pop	r16
    2924:	08 95       	ret

00002926 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2926:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2928:	e8 81       	ld	r30, Y
    292a:	f9 81       	ldd	r31, Y+1	; 0x01
    292c:	01 90       	ld	r0, Z+
    292e:	f0 81       	ld	r31, Z
    2930:	e0 2d       	mov	r30, r0
    2932:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2934:	1a 82       	std	Y+2, r1	; 0x02
    2936:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2938:	6f ef       	ldi	r22, 0xFF	; 255
    293a:	7f ef       	ldi	r23, 0xFF	; 255
    293c:	cb 01       	movw	r24, r22
    293e:	0e 94 76 12 	call	0x24ec	; 0x24ec <vTaskDelay>
    2942:	fa cf       	rjmp	.-12     	; 0x2938 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002944 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2944:	fc 01       	movw	r30, r24
    2946:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2948:	65 87       	std	Z+13, r22	; 0x0d
    294a:	08 95       	ret

0000294c <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    294c:	4f 92       	push	r4
    294e:	5f 92       	push	r5
    2950:	6f 92       	push	r6
    2952:	7f 92       	push	r7
    2954:	8f 92       	push	r8
    2956:	9f 92       	push	r9
    2958:	af 92       	push	r10
    295a:	bf 92       	push	r11
    295c:	cf 92       	push	r12
    295e:	df 92       	push	r13
    2960:	ef 92       	push	r14
    2962:	ff 92       	push	r15
    2964:	0f 93       	push	r16
    2966:	1f 93       	push	r17
    2968:	cf 93       	push	r28
    296a:	df 93       	push	r29
    296c:	cd b7       	in	r28, 0x3d	; 61
    296e:	de b7       	in	r29, 0x3e	; 62
    2970:	2a 97       	sbiw	r28, 0x0a	; 10
    2972:	cd bf       	out	0x3d, r28	; 61
    2974:	de bf       	out	0x3e, r29	; 62
    2976:	4c 01       	movw	r8, r24
    2978:	29 01       	movw	r4, r18
    297a:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    297c:	8f e3       	ldi	r24, 0x3F	; 63
    297e:	90 e2       	ldi	r25, 0x20	; 32
    2980:	f4 01       	movw	r30, r8
    2982:	80 83       	st	Z, r24
    2984:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2986:	fb 01       	movw	r30, r22
    2988:	80 81       	ld	r24, Z
    298a:	88 23       	and	r24, r24
    298c:	69 f0       	breq	.+26     	; 0x29a8 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    298e:	de 01       	movw	r26, r28
    2990:	11 96       	adiw	r26, 0x01	; 1
    2992:	31 96       	adiw	r30, 0x01	; 1
    2994:	90 e0       	ldi	r25, 0x00	; 0
    2996:	02 c0       	rjmp	.+4      	; 0x299c <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2998:	99 30       	cpi	r25, 0x09	; 9
    299a:	39 f0       	breq	.+14     	; 0x29aa <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    299c:	9f 5f       	subi	r25, 0xFF	; 255
    299e:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    29a0:	81 91       	ld	r24, Z+
    29a2:	81 11       	cpse	r24, r1
    29a4:	f9 cf       	rjmp	.-14     	; 0x2998 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    29a6:	01 c0       	rjmp	.+2      	; 0x29aa <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    29a8:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    29aa:	e1 e0       	ldi	r30, 0x01	; 1
    29ac:	f0 e0       	ldi	r31, 0x00	; 0
    29ae:	ec 0f       	add	r30, r28
    29b0:	fd 1f       	adc	r31, r29
    29b2:	e9 0f       	add	r30, r25
    29b4:	f1 1d       	adc	r31, r1
    29b6:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    29b8:	74 01       	movw	r14, r8
    29ba:	f2 e0       	ldi	r31, 0x02	; 2
    29bc:	ef 0e       	add	r14, r31
    29be:	f1 1c       	adc	r15, r1
    29c0:	a1 2c       	mov	r10, r1
    29c2:	b1 2c       	mov	r11, r1
    29c4:	c1 2c       	mov	r12, r1
    29c6:	d1 2c       	mov	r13, r1
    29c8:	04 2f       	mov	r16, r20
    29ca:	94 01       	movw	r18, r8
    29cc:	a2 01       	movw	r20, r4
    29ce:	be 01       	movw	r22, r28
    29d0:	6f 5f       	subi	r22, 0xFF	; 255
    29d2:	7f 4f       	sbci	r23, 0xFF	; 255
    29d4:	86 ea       	ldi	r24, 0xA6	; 166
    29d6:	92 e0       	ldi	r25, 0x02	; 2
    29d8:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    29dc:	f4 01       	movw	r30, r8
    29de:	66 82       	std	Z+6, r6	; 0x06
    29e0:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    29e2:	40 86       	std	Z+8, r4	; 0x08
    29e4:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    29e6:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    29ea:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    29ee:	24 83       	std	Z+4, r18	; 0x04
    29f0:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29f2:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    29f6:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29fa:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29fc:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29fe:	40 90 60 31 	lds	r4, 0x3160	; 0x803160 <portStackTopForTask>
    2a02:	50 90 61 31 	lds	r5, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    2a06:	ff ef       	ldi	r31, 0xFF	; 255
    2a08:	4f 1a       	sub	r4, r31
    2a0a:	5f 0a       	sbc	r5, r31
    2a0c:	40 92 60 31 	sts	0x3160, r4	; 0x803160 <portStackTopForTask>
    2a10:	50 92 61 31 	sts	0x3161, r5	; 0x803161 <portStackTopForTask+0x1>
    2a14:	f4 01       	movw	r30, r8
    2a16:	42 86       	std	Z+10, r4	; 0x0a
    2a18:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2a1a:	16 86       	std	Z+14, r1	; 0x0e
    2a1c:	17 86       	std	Z+15, r1	; 0x0f
    2a1e:	10 8a       	std	Z+16, r1	; 0x10
    2a20:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2a22:	61 14       	cp	r6, r1
    2a24:	71 04       	cpc	r7, r1
    2a26:	09 f4       	brne	.+2      	; 0x2a2a <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a28:	44 c0       	rjmp	.+136    	; 0x2ab2 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a2a:	81 30       	cpi	r24, 0x01	; 1
    2a2c:	79 f5       	brne	.+94     	; 0x2a8c <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a2e:	6a e0       	ldi	r22, 0x0A	; 10
    2a30:	c3 01       	movw	r24, r6
    2a32:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2a36:	7c 01       	movw	r14, r24
    2a38:	69 e9       	ldi	r22, 0x99	; 153
    2a3a:	74 e0       	ldi	r23, 0x04	; 4
    2a3c:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2a40:	be 01       	movw	r22, r28
    2a42:	6f 5f       	subi	r22, 0xFF	; 255
    2a44:	7f 4f       	sbci	r23, 0xFF	; 255
    2a46:	c7 01       	movw	r24, r14
    2a48:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2a4c:	6a e0       	ldi	r22, 0x0A	; 10
    2a4e:	c7 01       	movw	r24, r14
    2a50:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2a54:	7c 01       	movw	r14, r24
    2a56:	60 e9       	ldi	r22, 0x90	; 144
    2a58:	74 e0       	ldi	r23, 0x04	; 4
    2a5a:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a5e:	6a e0       	ldi	r22, 0x0A	; 10
    2a60:	c7 01       	movw	r24, r14
    2a62:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2a66:	7c 01       	movw	r14, r24
    2a68:	62 e8       	ldi	r22, 0x82	; 130
    2a6a:	74 e0       	ldi	r23, 0x04	; 4
    2a6c:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2a70:	63 e0       	ldi	r22, 0x03	; 3
    2a72:	c7 01       	movw	r24, r14
    2a74:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2a78:	b2 01       	movw	r22, r4
    2a7a:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <_ZN8emstreamlsEj>
    2a7e:	62 e0       	ldi	r22, 0x02	; 2
    2a80:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2a84:	66 e0       	ldi	r22, 0x06	; 6
    2a86:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2a8a:	13 c0       	rjmp	.+38     	; 0x2ab2 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a8c:	6a e0       	ldi	r22, 0x0A	; 10
    2a8e:	c3 01       	movw	r24, r6
    2a90:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2a94:	4c 01       	movw	r8, r24
    2a96:	6d e6       	ldi	r22, 0x6D	; 109
    2a98:	74 e0       	ldi	r23, 0x04	; 4
    2a9a:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2a9e:	be 01       	movw	r22, r28
    2aa0:	6f 5f       	subi	r22, 0xFF	; 255
    2aa2:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa4:	c4 01       	movw	r24, r8
    2aa6:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2aaa:	66 e0       	ldi	r22, 0x06	; 6
    2aac:	c4 01       	movw	r24, r8
    2aae:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2ab2:	2a 96       	adiw	r28, 0x0a	; 10
    2ab4:	cd bf       	out	0x3d, r28	; 61
    2ab6:	de bf       	out	0x3e, r29	; 62
    2ab8:	df 91       	pop	r29
    2aba:	cf 91       	pop	r28
    2abc:	1f 91       	pop	r17
    2abe:	0f 91       	pop	r16
    2ac0:	ff 90       	pop	r15
    2ac2:	ef 90       	pop	r14
    2ac4:	df 90       	pop	r13
    2ac6:	cf 90       	pop	r12
    2ac8:	bf 90       	pop	r11
    2aca:	af 90       	pop	r10
    2acc:	9f 90       	pop	r9
    2ace:	8f 90       	pop	r8
    2ad0:	7f 90       	pop	r7
    2ad2:	6f 90       	pop	r6
    2ad4:	5f 90       	pop	r5
    2ad6:	4f 90       	pop	r4
    2ad8:	08 95       	ret

00002ada <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2ada:	cf 92       	push	r12
    2adc:	df 92       	push	r13
    2ade:	ef 92       	push	r14
    2ae0:	ff 92       	push	r15
    2ae2:	0f 93       	push	r16
    2ae4:	1f 93       	push	r17
    2ae6:	cf 93       	push	r28
    2ae8:	df 93       	push	r29
    2aea:	ec 01       	movw	r28, r24
    2aec:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2aee:	8a 81       	ldd	r24, Y+2	; 0x02
    2af0:	9b 81       	ldd	r25, Y+3	; 0x03
    2af2:	0e 94 79 10 	call	0x20f2	; 0x20f2 <pcTaskGetTaskName>
    2af6:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2af8:	6a e0       	ldi	r22, 0x0A	; 10
    2afa:	c7 01       	movw	r24, r14
    2afc:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2b00:	8c 01       	movw	r16, r24
    2b02:	6c ea       	ldi	r22, 0xAC	; 172
    2b04:	74 e0       	ldi	r23, 0x04	; 4
    2b06:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2b0a:	6a e0       	ldi	r22, 0x0A	; 10
    2b0c:	c8 01       	movw	r24, r16
    2b0e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2b12:	8c 01       	movw	r16, r24
    2b14:	65 ea       	ldi	r22, 0xA5	; 165
    2b16:	74 e0       	ldi	r23, 0x04	; 4
    2b18:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2b1c:	b6 01       	movw	r22, r12
    2b1e:	c8 01       	movw	r24, r16
    2b20:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2b24:	6a e0       	ldi	r22, 0x0A	; 10
    2b26:	c8 01       	movw	r24, r16
    2b28:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2b2c:	8c 01       	movw	r16, r24
    2b2e:	6f e9       	ldi	r22, 0x9F	; 159
    2b30:	74 e0       	ldi	r23, 0x04	; 4
    2b32:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2b36:	66 e0       	ldi	r22, 0x06	; 6
    2b38:	c8 01       	movw	r24, r16
    2b3a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b3e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b40:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b42:	e8 85       	ldd	r30, Y+8	; 0x08
    2b44:	f9 85       	ldd	r31, Y+9	; 0x09
    2b46:	01 e1       	ldi	r16, 0x11	; 17
    2b48:	21 e0       	ldi	r18, 0x01	; 1
    2b4a:	a7 01       	movw	r20, r14
    2b4c:	bc 01       	movw	r22, r24
    2b4e:	8e 1b       	sub	r24, r30
    2b50:	9f 0b       	sbc	r25, r31
    2b52:	0e 94 6f 18 	call	0x30de	; 0x30de <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b56:	8c 81       	ldd	r24, Y+4	; 0x04
    2b58:	9d 81       	ldd	r25, Y+5	; 0x05
    2b5a:	00 97       	sbiw	r24, 0x00	; 0
    2b5c:	19 f0       	breq	.+6      	; 0x2b64 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b5e:	b7 01       	movw	r22, r14
    2b60:	0e 94 6d 15 	call	0x2ada	; 0x2ada <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b64:	df 91       	pop	r29
    2b66:	cf 91       	pop	r28
    2b68:	1f 91       	pop	r17
    2b6a:	0f 91       	pop	r16
    2b6c:	ff 90       	pop	r15
    2b6e:	ef 90       	pop	r14
    2b70:	df 90       	pop	r13
    2b72:	cf 90       	pop	r12
    2b74:	08 95       	ret

00002b76 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b76:	0f 93       	push	r16
    2b78:	1f 93       	push	r17
    2b7a:	cf 93       	push	r28
    2b7c:	df 93       	push	r29
    2b7e:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b80:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2b84:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2b88:	00 97       	sbiw	r24, 0x00	; 0
    2b8a:	19 f0       	breq	.+6      	; 0x2b92 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b8c:	be 01       	movw	r22, r28
    2b8e:	0e 94 6d 15 	call	0x2ada	; 0x2ada <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b92:	6a e0       	ldi	r22, 0x0A	; 10
    2b94:	ce 01       	movw	r24, r28
    2b96:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2b9a:	8c 01       	movw	r16, r24
    2b9c:	62 ec       	ldi	r22, 0xC2	; 194
    2b9e:	74 e0       	ldi	r23, 0x04	; 4
    2ba0:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2ba4:	6a e0       	ldi	r22, 0x0A	; 10
    2ba6:	c8 01       	movw	r24, r16
    2ba8:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2bac:	8c 01       	movw	r16, r24
    2bae:	67 eb       	ldi	r22, 0xB7	; 183
    2bb0:	74 e0       	ldi	r23, 0x04	; 4
    2bb2:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2bb6:	6a e0       	ldi	r22, 0x0A	; 10
    2bb8:	c8 01       	movw	r24, r16
    2bba:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2bbe:	8c 01       	movw	r16, r24
    2bc0:	61 eb       	ldi	r22, 0xB1	; 177
    2bc2:	74 e0       	ldi	r23, 0x04	; 4
    2bc4:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2bc8:	66 e0       	ldi	r22, 0x06	; 6
    2bca:	c8 01       	movw	r24, r16
    2bcc:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2bd0:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <portStackTopForTask>
    2bd4:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    2bd8:	bc 01       	movw	r22, r24
    2bda:	6f 5f       	subi	r22, 0xFF	; 255
    2bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    2bde:	01 e1       	ldi	r16, 0x11	; 17
    2be0:	21 e0       	ldi	r18, 0x01	; 1
    2be2:	ae 01       	movw	r20, r28
    2be4:	83 56       	subi	r24, 0x63	; 99
    2be6:	91 09       	sbc	r25, r1
    2be8:	0e 94 6f 18 	call	0x30de	; 0x30de <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2bec:	df 91       	pop	r29
    2bee:	cf 91       	pop	r28
    2bf0:	1f 91       	pop	r17
    2bf2:	0f 91       	pop	r16
    2bf4:	08 95       	ret

00002bf6 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2bf6:	8f 92       	push	r8
    2bf8:	9f 92       	push	r9
    2bfa:	af 92       	push	r10
    2bfc:	bf 92       	push	r11
    2bfe:	cf 92       	push	r12
    2c00:	df 92       	push	r13
    2c02:	ef 92       	push	r14
    2c04:	ff 92       	push	r15
    2c06:	0f 93       	push	r16
    2c08:	1f 93       	push	r17
    2c0a:	cf 93       	push	r28
    2c0c:	df 93       	push	r29
    2c0e:	ec 01       	movw	r28, r24
    2c10:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2c12:	8a 81       	ldd	r24, Y+2	; 0x02
    2c14:	9b 81       	ldd	r25, Y+3	; 0x03
    2c16:	0e 94 79 10 	call	0x20f2	; 0x20f2 <pcTaskGetTaskName>
    2c1a:	bc 01       	movw	r22, r24
    2c1c:	c8 01       	movw	r24, r16
    2c1e:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2c22:	d8 01       	movw	r26, r16
    2c24:	ed 91       	ld	r30, X+
    2c26:	fc 91       	ld	r31, X
    2c28:	02 80       	ldd	r0, Z+2	; 0x02
    2c2a:	f3 81       	ldd	r31, Z+3	; 0x03
    2c2c:	e0 2d       	mov	r30, r0
    2c2e:	69 e0       	ldi	r22, 0x09	; 9
    2c30:	c8 01       	movw	r24, r16
    2c32:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c34:	8a 81       	ldd	r24, Y+2	; 0x02
    2c36:	9b 81       	ldd	r25, Y+3	; 0x03
    2c38:	0e 94 79 10 	call	0x20f2	; 0x20f2 <pcTaskGetTaskName>
    2c3c:	fc 01       	movw	r30, r24
    2c3e:	01 90       	ld	r0, Z+
    2c40:	00 20       	and	r0, r0
    2c42:	e9 f7       	brne	.-6      	; 0x2c3e <_ZN8frt_task12print_statusER8emstream+0x48>
    2c44:	31 97       	sbiw	r30, 0x01	; 1
    2c46:	e8 1b       	sub	r30, r24
    2c48:	f9 0b       	sbc	r31, r25
    2c4a:	38 97       	sbiw	r30, 0x08	; 8
    2c4c:	48 f4       	brcc	.+18     	; 0x2c60 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2c4e:	d8 01       	movw	r26, r16
    2c50:	ed 91       	ld	r30, X+
    2c52:	fc 91       	ld	r31, X
    2c54:	02 80       	ldd	r0, Z+2	; 0x02
    2c56:	f3 81       	ldd	r31, Z+3	; 0x03
    2c58:	e0 2d       	mov	r30, r0
    2c5a:	69 e0       	ldi	r22, 0x09	; 9
    2c5c:	c8 01       	movw	r24, r16
    2c5e:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c60:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c62:	df 84       	ldd	r13, Y+15	; 0x0f
    2c64:	e8 88       	ldd	r14, Y+16	; 0x10
    2c66:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c68:	a8 84       	ldd	r10, Y+8	; 0x08
    2c6a:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c6e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c70:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <uxTaskGetStackHighWaterMark>
    2c74:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c76:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c78:	8a 81       	ldd	r24, Y+2	; 0x02
    2c7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c7c:	0e 94 24 10 	call	0x2048	; 0x2048 <uxTaskPriorityGet>
    2c80:	68 2f       	mov	r22, r24
    2c82:	c8 01       	movw	r24, r16
    2c84:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
    2c88:	6a e0       	ldi	r22, 0x0A	; 10
    2c8a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2c8e:	ec 01       	movw	r28, r24
    2c90:	67 e3       	ldi	r22, 0x37	; 55
    2c92:	75 e0       	ldi	r23, 0x05	; 5
    2c94:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c98:	68 2d       	mov	r22, r8
    2c9a:	ce 01       	movw	r24, r28
    2c9c:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2ca0:	6a e0       	ldi	r22, 0x0A	; 10
    2ca2:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2ca6:	ec 01       	movw	r28, r24
    2ca8:	65 e3       	ldi	r22, 0x35	; 53
    2caa:	75 e0       	ldi	r23, 0x05	; 5
    2cac:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2cb0:	69 2d       	mov	r22, r9
    2cb2:	ce 01       	movw	r24, r28
    2cb4:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
    2cb8:	6a e0       	ldi	r22, 0x0A	; 10
    2cba:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2cbe:	ec 01       	movw	r28, r24
    2cc0:	63 e3       	ldi	r22, 0x33	; 51
    2cc2:	75 e0       	ldi	r23, 0x05	; 5
    2cc4:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2cc8:	b5 01       	movw	r22, r10
    2cca:	ce 01       	movw	r24, r28
    2ccc:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <_ZN8emstreamlsEj>
    2cd0:	6a e0       	ldi	r22, 0x0A	; 10
    2cd2:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2cd6:	ec 01       	movw	r28, r24
    2cd8:	61 e3       	ldi	r22, 0x31	; 49
    2cda:	75 e0       	ldi	r23, 0x05	; 5
    2cdc:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2ce0:	6a e0       	ldi	r22, 0x0A	; 10
    2ce2:	ce 01       	movw	r24, r28
    2ce4:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2ce8:	ec 01       	movw	r28, r24
    2cea:	6f e2       	ldi	r22, 0x2F	; 47
    2cec:	75 e0       	ldi	r23, 0x05	; 5
    2cee:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2cf2:	b7 01       	movw	r22, r14
    2cf4:	a6 01       	movw	r20, r12
    2cf6:	ce 01       	movw	r24, r28
    2cf8:	0e 94 af 1a 	call	0x355e	; 0x355e <_ZN8emstreamlsEm>
}
    2cfc:	df 91       	pop	r29
    2cfe:	cf 91       	pop	r28
    2d00:	1f 91       	pop	r17
    2d02:	0f 91       	pop	r16
    2d04:	ff 90       	pop	r15
    2d06:	ef 90       	pop	r14
    2d08:	df 90       	pop	r13
    2d0a:	cf 90       	pop	r12
    2d0c:	bf 90       	pop	r11
    2d0e:	af 90       	pop	r10
    2d10:	9f 90       	pop	r9
    2d12:	8f 90       	pop	r8
    2d14:	08 95       	ret

00002d16 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2d16:	cf 93       	push	r28
    2d18:	df 93       	push	r29
    2d1a:	ec 01       	movw	r28, r24
    2d1c:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2d1e:	db 01       	movw	r26, r22
    2d20:	ed 91       	ld	r30, X+
    2d22:	fc 91       	ld	r31, X
    2d24:	02 80       	ldd	r0, Z+2	; 0x02
    2d26:	f3 81       	ldd	r31, Z+3	; 0x03
    2d28:	e0 2d       	mov	r30, r0
    2d2a:	be 01       	movw	r22, r28
    2d2c:	19 95       	eicall
	return (ser_dev);
}
    2d2e:	ce 01       	movw	r24, r28
    2d30:	df 91       	pop	r29
    2d32:	cf 91       	pop	r28
    2d34:	08 95       	ret

00002d36 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2d36:	0f 93       	push	r16
    2d38:	1f 93       	push	r17
    2d3a:	cf 93       	push	r28
    2d3c:	df 93       	push	r29
    2d3e:	ec 01       	movw	r28, r24
    2d40:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d42:	bc 01       	movw	r22, r24
    2d44:	c8 01       	movw	r24, r16
    2d46:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <_ZlsR8emstreamR8frt_task>
    2d4a:	66 e0       	ldi	r22, 0x06	; 6
    2d4c:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d50:	8c 81       	ldd	r24, Y+4	; 0x04
    2d52:	9d 81       	ldd	r25, Y+5	; 0x05
    2d54:	00 97       	sbiw	r24, 0x00	; 0
    2d56:	19 f0       	breq	.+6      	; 0x2d5e <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d58:	b8 01       	movw	r22, r16
    2d5a:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d5e:	df 91       	pop	r29
    2d60:	cf 91       	pop	r28
    2d62:	1f 91       	pop	r17
    2d64:	0f 91       	pop	r16
    2d66:	08 95       	ret

00002d68 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d68:	0f 93       	push	r16
    2d6a:	1f 93       	push	r17
    2d6c:	cf 93       	push	r28
    2d6e:	df 93       	push	r29
    2d70:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d72:	6a e0       	ldi	r22, 0x0A	; 10
    2d74:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2d78:	8c 01       	movw	r16, r24
    2d7a:	64 e2       	ldi	r22, 0x24	; 36
    2d7c:	75 e0       	ldi	r23, 0x05	; 5
    2d7e:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d82:	6a e0       	ldi	r22, 0x0A	; 10
    2d84:	c8 01       	movw	r24, r16
    2d86:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2d8a:	8c 01       	movw	r16, r24
    2d8c:	6d e1       	ldi	r22, 0x1D	; 29
    2d8e:	75 e0       	ldi	r23, 0x05	; 5
    2d90:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d94:	66 e0       	ldi	r22, 0x06	; 6
    2d96:	c8 01       	movw	r24, r16
    2d98:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d9c:	6a e0       	ldi	r22, 0x0A	; 10
    2d9e:	ce 01       	movw	r24, r28
    2da0:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2da4:	8c 01       	movw	r16, r24
    2da6:	6c e0       	ldi	r22, 0x0C	; 12
    2da8:	75 e0       	ldi	r23, 0x05	; 5
    2daa:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2dae:	6a e0       	ldi	r22, 0x0A	; 10
    2db0:	c8 01       	movw	r24, r16
    2db2:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2db6:	8c 01       	movw	r16, r24
    2db8:	60 e0       	ldi	r22, 0x00	; 0
    2dba:	75 e0       	ldi	r23, 0x05	; 5
    2dbc:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2dc0:	6a e0       	ldi	r22, 0x0A	; 10
    2dc2:	c8 01       	movw	r24, r16
    2dc4:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2dc8:	8c 01       	movw	r16, r24
    2dca:	6a ef       	ldi	r22, 0xFA	; 250
    2dcc:	74 e0       	ldi	r23, 0x04	; 4
    2dce:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2dd2:	66 e0       	ldi	r22, 0x06	; 6
    2dd4:	c8 01       	movw	r24, r16
    2dd6:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2dda:	6a e0       	ldi	r22, 0x0A	; 10
    2ddc:	ce 01       	movw	r24, r28
    2dde:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2de2:	8c 01       	movw	r16, r24
    2de4:	69 ee       	ldi	r22, 0xE9	; 233
    2de6:	74 e0       	ldi	r23, 0x04	; 4
    2de8:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2dec:	6a e0       	ldi	r22, 0x0A	; 10
    2dee:	c8 01       	movw	r24, r16
    2df0:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2df4:	8c 01       	movw	r16, r24
    2df6:	6d ed       	ldi	r22, 0xDD	; 221
    2df8:	74 e0       	ldi	r23, 0x04	; 4
    2dfa:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2dfe:	6a e0       	ldi	r22, 0x0A	; 10
    2e00:	c8 01       	movw	r24, r16
    2e02:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2e06:	8c 01       	movw	r16, r24
    2e08:	67 ed       	ldi	r22, 0xD7	; 215
    2e0a:	74 e0       	ldi	r23, 0x04	; 4
    2e0c:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2e10:	66 e0       	ldi	r22, 0x06	; 6
    2e12:	c8 01       	movw	r24, r16
    2e14:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2e18:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2e1c:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2e20:	00 97       	sbiw	r24, 0x00	; 0
    2e22:	19 f0       	breq	.+6      	; 0x2e2a <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2e24:	be 01       	movw	r22, r28
    2e26:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e2a:	0e 94 81 10 	call	0x2102	; 0x2102 <xTaskGetIdleTaskHandle>
    2e2e:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <uxTaskGetStackHighWaterMark>
    2e32:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2e34:	6a e0       	ldi	r22, 0x0A	; 10
    2e36:	ce 01       	movw	r24, r28
    2e38:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2e3c:	ec 01       	movw	r28, r24
    2e3e:	6c ec       	ldi	r22, 0xCC	; 204
    2e40:	74 e0       	ldi	r23, 0x04	; 4
    2e42:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e46:	61 2f       	mov	r22, r17
    2e48:	ce 01       	movw	r24, r28
    2e4a:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2e4e:	6a e0       	ldi	r22, 0x0A	; 10
    2e50:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2e54:	ec 01       	movw	r28, r24
    2e56:	6a ec       	ldi	r22, 0xCA	; 202
    2e58:	74 e0       	ldi	r23, 0x04	; 4
    2e5a:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    2e5e:	64 e6       	ldi	r22, 0x64	; 100
    2e60:	70 e0       	ldi	r23, 0x00	; 0
    2e62:	ce 01       	movw	r24, r28
    2e64:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <_ZN8emstreamlsEj>
    2e68:	6a e0       	ldi	r22, 0x0A	; 10
    2e6a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    2e6e:	ec 01       	movw	r28, r24
    2e70:	67 ec       	ldi	r22, 0xC7	; 199
    2e72:	74 e0       	ldi	r23, 0x04	; 4
    2e74:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e78:	66 e0       	ldi	r22, 0x06	; 6
    2e7a:	ce 01       	movw	r24, r28
    2e7c:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
}
    2e80:	df 91       	pop	r29
    2e82:	cf 91       	pop	r28
    2e84:	1f 91       	pop	r17
    2e86:	0f 91       	pop	r16
    2e88:	08 95       	ret

00002e8a <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e8a:	0f 93       	push	r16
    2e8c:	cf 93       	push	r28
    2e8e:	df 93       	push	r29
    2e90:	1f 92       	push	r1
    2e92:	cd b7       	in	r28, 0x3d	; 61
    2e94:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e96:	00 e0       	ldi	r16, 0x00	; 0
    2e98:	2f ef       	ldi	r18, 0xFF	; 255
    2e9a:	3f ef       	ldi	r19, 0xFF	; 255
    2e9c:	a9 01       	movw	r20, r18
    2e9e:	be 01       	movw	r22, r28
    2ea0:	6f 5f       	subi	r22, 0xFF	; 255
    2ea2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ea4:	fc 01       	movw	r30, r24
    2ea6:	80 85       	ldd	r24, Z+8	; 0x08
    2ea8:	91 85       	ldd	r25, Z+9	; 0x09
    2eaa:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <xQueueGenericReceive>
    2eae:	81 30       	cpi	r24, 0x01	; 1
    2eb0:	19 f4       	brne	.+6      	; 0x2eb8 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2eb2:	89 81       	ldd	r24, Y+1	; 0x01
    2eb4:	90 e0       	ldi	r25, 0x00	; 0
    2eb6:	02 c0       	rjmp	.+4      	; 0x2ebc <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2eb8:	8f ef       	ldi	r24, 0xFF	; 255
    2eba:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2ebc:	0f 90       	pop	r0
    2ebe:	df 91       	pop	r29
    2ec0:	cf 91       	pop	r28
    2ec2:	0f 91       	pop	r16
    2ec4:	08 95       	ret

00002ec6 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2ec6:	fc 01       	movw	r30, r24
    2ec8:	80 85       	ldd	r24, Z+8	; 0x08
    2eca:	91 85       	ldd	r25, Z+9	; 0x09
    2ecc:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <uxQueueMessagesWaiting>
    2ed0:	91 e0       	ldi	r25, 0x01	; 1
    2ed2:	81 11       	cpse	r24, r1
    2ed4:	01 c0       	rjmp	.+2      	; 0x2ed8 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2ed6:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2ed8:	89 2f       	mov	r24, r25
    2eda:	08 95       	ret

00002edc <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2edc:	0f 93       	push	r16
    2ede:	cf 93       	push	r28
    2ee0:	df 93       	push	r29
    2ee2:	1f 92       	push	r1
    2ee4:	cd b7       	in	r28, 0x3d	; 61
    2ee6:	de b7       	in	r29, 0x3e	; 62
    2ee8:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2eea:	fc 01       	movw	r30, r24
    2eec:	22 85       	ldd	r18, Z+10	; 0x0a
    2eee:	33 85       	ldd	r19, Z+11	; 0x0b
    2ef0:	44 85       	ldd	r20, Z+12	; 0x0c
    2ef2:	55 85       	ldd	r21, Z+13	; 0x0d
    2ef4:	00 e0       	ldi	r16, 0x00	; 0
    2ef6:	be 01       	movw	r22, r28
    2ef8:	6f 5f       	subi	r22, 0xFF	; 255
    2efa:	7f 4f       	sbci	r23, 0xFF	; 255
    2efc:	80 85       	ldd	r24, Z+8	; 0x08
    2efe:	91 85       	ldd	r25, Z+9	; 0x09
    2f00:	0e 94 65 0d 	call	0x1aca	; 0x1aca <xQueueGenericSend>
    2f04:	91 e0       	ldi	r25, 0x01	; 1
    2f06:	81 11       	cpse	r24, r1
    2f08:	01 c0       	rjmp	.+2      	; 0x2f0c <_ZN14frt_text_queue7putcharEc+0x30>
    2f0a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2f0c:	89 2f       	mov	r24, r25
    2f0e:	0f 90       	pop	r0
    2f10:	df 91       	pop	r29
    2f12:	cf 91       	pop	r28
    2f14:	0f 91       	pop	r16
    2f16:	08 95       	ret

00002f18 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2f18:	8f 92       	push	r8
    2f1a:	9f 92       	push	r9
    2f1c:	bf 92       	push	r11
    2f1e:	cf 92       	push	r12
    2f20:	df 92       	push	r13
    2f22:	ef 92       	push	r14
    2f24:	ff 92       	push	r15
    2f26:	0f 93       	push	r16
    2f28:	1f 93       	push	r17
    2f2a:	cf 93       	push	r28
    2f2c:	df 93       	push	r29
    2f2e:	ec 01       	movw	r28, r24
    2f30:	b6 2e       	mov	r11, r22
    2f32:	4a 01       	movw	r8, r20
    2f34:	68 01       	movw	r12, r16
    2f36:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f38:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstreamC1Ev>
    2f3c:	87 e4       	ldi	r24, 0x47	; 71
    2f3e:	90 e2       	ldi	r25, 0x20	; 32
    2f40:	88 83       	st	Y, r24
    2f42:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f44:	8e 86       	std	Y+14, r8	; 0x0e
    2f46:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f48:	40 e0       	ldi	r20, 0x00	; 0
    2f4a:	61 e0       	ldi	r22, 0x01	; 1
    2f4c:	8b 2d       	mov	r24, r11
    2f4e:	0e 94 37 0d 	call	0x1a6e	; 0x1a6e <xQueueGenericCreate>
    2f52:	88 87       	std	Y+8, r24	; 0x08
    2f54:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f56:	ca 86       	std	Y+10, r12	; 0x0a
    2f58:	db 86       	std	Y+11, r13	; 0x0b
    2f5a:	ec 86       	std	Y+12, r14	; 0x0c
    2f5c:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f5e:	df 91       	pop	r29
    2f60:	cf 91       	pop	r28
    2f62:	1f 91       	pop	r17
    2f64:	0f 91       	pop	r16
    2f66:	ff 90       	pop	r15
    2f68:	ef 90       	pop	r14
    2f6a:	df 90       	pop	r13
    2f6c:	cf 90       	pop	r12
    2f6e:	bf 90       	pop	r11
    2f70:	9f 90       	pop	r9
    2f72:	8f 90       	pop	r8
    2f74:	08 95       	ret

00002f76 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f76:	cf 92       	push	r12
    2f78:	df 92       	push	r13
    2f7a:	ef 92       	push	r14
    2f7c:	ff 92       	push	r15
    2f7e:	cf 93       	push	r28
    2f80:	df 93       	push	r29
    2f82:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f84:	68 81       	ld	r22, Y
    2f86:	79 81       	ldd	r23, Y+1	; 0x01
    2f88:	8a 81       	ldd	r24, Y+2	; 0x02
    2f8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f8c:	0f 2e       	mov	r0, r31
    2f8e:	f8 ee       	ldi	r31, 0xE8	; 232
    2f90:	cf 2e       	mov	r12, r31
    2f92:	f3 e0       	ldi	r31, 0x03	; 3
    2f94:	df 2e       	mov	r13, r31
    2f96:	e1 2c       	mov	r14, r1
    2f98:	f1 2c       	mov	r15, r1
    2f9a:	f0 2d       	mov	r31, r0
    2f9c:	a7 01       	movw	r20, r14
    2f9e:	96 01       	movw	r18, r12
    2fa0:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__udivmodsi4>
    2fa4:	9b 01       	movw	r18, r22
    2fa6:	ac 01       	movw	r20, r24
    2fa8:	60 e4       	ldi	r22, 0x40	; 64
    2faa:	72 e4       	ldi	r23, 0x42	; 66
    2fac:	8f e0       	ldi	r24, 0x0F	; 15
    2fae:	90 e0       	ldi	r25, 0x00	; 0
    2fb0:	0e 94 58 1f 	call	0x3eb0	; 0x3eb0 <__mulsi3>
    2fb4:	a7 01       	movw	r20, r14
    2fb6:	96 01       	movw	r18, r12
    2fb8:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__udivmodsi4>
    2fbc:	69 01       	movw	r12, r18
    2fbe:	7a 01       	movw	r14, r20
    2fc0:	ac 81       	ldd	r26, Y+4	; 0x04
    2fc2:	bd 81       	ldd	r27, Y+5	; 0x05
    2fc4:	20 e4       	ldi	r18, 0x40	; 64
    2fc6:	32 e4       	ldi	r19, 0x42	; 66
    2fc8:	4f e0       	ldi	r20, 0x0F	; 15
    2fca:	50 e0       	ldi	r21, 0x00	; 0
    2fcc:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <__muluhisi3>
    2fd0:	20 e0       	ldi	r18, 0x00	; 0
    2fd2:	38 e4       	ldi	r19, 0x48	; 72
    2fd4:	48 ee       	ldi	r20, 0xE8	; 232
    2fd6:	51 e0       	ldi	r21, 0x01	; 1
    2fd8:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__udivmodsi4>
    2fdc:	c7 01       	movw	r24, r14
    2fde:	b6 01       	movw	r22, r12
    2fe0:	62 0f       	add	r22, r18
    2fe2:	73 1f       	adc	r23, r19
    2fe4:	84 1f       	adc	r24, r20
    2fe6:	95 1f       	adc	r25, r21
}
    2fe8:	df 91       	pop	r29
    2fea:	cf 91       	pop	r28
    2fec:	ff 90       	pop	r15
    2fee:	ef 90       	pop	r14
    2ff0:	df 90       	pop	r13
    2ff2:	cf 90       	pop	r12
    2ff4:	08 95       	ret

00002ff6 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2ff6:	cf 92       	push	r12
    2ff8:	df 92       	push	r13
    2ffa:	ef 92       	push	r14
    2ffc:	ff 92       	push	r15
    2ffe:	0f 93       	push	r16
    3000:	1f 93       	push	r17
    3002:	cf 93       	push	r28
    3004:	df 93       	push	r29
    3006:	cd b7       	in	r28, 0x3d	; 61
    3008:	de b7       	in	r29, 0x3e	; 62
    300a:	2f 97       	sbiw	r28, 0x0f	; 15
    300c:	cd bf       	out	0x3d, r28	; 61
    300e:	de bf       	out	0x3e, r29	; 62
    3010:	6c 01       	movw	r12, r24
    3012:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3014:	db 01       	movw	r26, r22
    3016:	6d 91       	ld	r22, X+
    3018:	7d 91       	ld	r23, X+
    301a:	8d 91       	ld	r24, X+
    301c:	9c 91       	ld	r25, X
    301e:	28 ee       	ldi	r18, 0xE8	; 232
    3020:	33 e0       	ldi	r19, 0x03	; 3
    3022:	40 e0       	ldi	r20, 0x00	; 0
    3024:	50 e0       	ldi	r21, 0x00	; 0
    3026:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__udivmodsi4>
    302a:	ba 01       	movw	r22, r20
    302c:	a9 01       	movw	r20, r18
    302e:	c6 01       	movw	r24, r12
    3030:	0e 94 af 1a 	call	0x355e	; 0x355e <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3034:	d6 01       	movw	r26, r12
    3036:	ed 91       	ld	r30, X+
    3038:	fc 91       	ld	r31, X
    303a:	02 80       	ldd	r0, Z+2	; 0x02
    303c:	f3 81       	ldd	r31, Z+3	; 0x03
    303e:	e0 2d       	mov	r30, r0
    3040:	6e e2       	ldi	r22, 0x2E	; 46
    3042:	c6 01       	movw	r24, r12
    3044:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3046:	c8 01       	movw	r24, r16
    3048:	0e 94 bb 17 	call	0x2f76	; 0x2f76 <_ZN10time_stamp12get_microsecEv>
    304c:	8e 01       	movw	r16, r28
    304e:	09 5f       	subi	r16, 0xF9	; 249
    3050:	1f 4f       	sbci	r17, 0xFF	; 255
    3052:	fe 01       	movw	r30, r28
    3054:	31 96       	adiw	r30, 0x01	; 1
    3056:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3058:	2a e0       	ldi	r18, 0x0A	; 10
    305a:	30 e0       	ldi	r19, 0x00	; 0
    305c:	40 e0       	ldi	r20, 0x00	; 0
    305e:	50 e0       	ldi	r21, 0x00	; 0
    3060:	0e 94 9e 1f 	call	0x3f3c	; 0x3f3c <__divmodsi4>
    3064:	e6 2f       	mov	r30, r22
    3066:	28 87       	std	Y+8, r18	; 0x08
    3068:	39 87       	std	Y+9, r19	; 0x09
    306a:	4a 87       	std	Y+10, r20	; 0x0a
    306c:	5b 87       	std	Y+11, r21	; 0x0b
    306e:	68 85       	ldd	r22, Y+8	; 0x08
    3070:	79 85       	ldd	r23, Y+9	; 0x09
    3072:	8a 85       	ldd	r24, Y+10	; 0x0a
    3074:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3076:	20 e3       	ldi	r18, 0x30	; 48
    3078:	2e 0f       	add	r18, r30
    307a:	d8 01       	movw	r26, r16
    307c:	2e 93       	st	-X, r18
    307e:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3080:	ae 15       	cp	r26, r14
    3082:	bf 05       	cpc	r27, r15
    3084:	49 f7       	brne	.-46     	; 0x3058 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3086:	1f 82       	std	Y+7, r1	; 0x07
    3088:	be 01       	movw	r22, r28
    308a:	6f 5f       	subi	r22, 0xFF	; 255
    308c:	7f 4f       	sbci	r23, 0xFF	; 255
    308e:	c6 01       	movw	r24, r12
    3090:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3094:	c6 01       	movw	r24, r12
    3096:	2f 96       	adiw	r28, 0x0f	; 15
    3098:	cd bf       	out	0x3d, r28	; 61
    309a:	de bf       	out	0x3e, r29	; 62
    309c:	df 91       	pop	r29
    309e:	cf 91       	pop	r28
    30a0:	1f 91       	pop	r17
    30a2:	0f 91       	pop	r16
    30a4:	ff 90       	pop	r15
    30a6:	ef 90       	pop	r14
    30a8:	df 90       	pop	r13
    30aa:	cf 90       	pop	r12
    30ac:	08 95       	ret

000030ae <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    30ae:	cf 93       	push	r28
    30b0:	df 93       	push	r29
    30b2:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    30b4:	0f b6       	in	r0, 0x3f	; 63
    30b6:	f8 94       	cli
    30b8:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    30ba:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    30be:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    30c2:	8c 83       	std	Y+4, r24	; 0x04
    30c4:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    30c6:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <xTaskGetTickCount>
    30ca:	68 83       	st	Y, r22
    30cc:	79 83       	std	Y+1, r23	; 0x01
    30ce:	8a 83       	std	Y+2, r24	; 0x02
    30d0:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    30d2:	0f 90       	pop	r0
    30d4:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    30d6:	ce 01       	movw	r24, r28
    30d8:	df 91       	pop	r29
    30da:	cf 91       	pop	r28
    30dc:	08 95       	ret

000030de <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    30de:	5f 92       	push	r5
    30e0:	6f 92       	push	r6
    30e2:	7f 92       	push	r7
    30e4:	8f 92       	push	r8
    30e6:	9f 92       	push	r9
    30e8:	af 92       	push	r10
    30ea:	bf 92       	push	r11
    30ec:	cf 92       	push	r12
    30ee:	df 92       	push	r13
    30f0:	ef 92       	push	r14
    30f2:	ff 92       	push	r15
    30f4:	0f 93       	push	r16
    30f6:	1f 93       	push	r17
    30f8:	cf 93       	push	r28
    30fa:	df 93       	push	r29
    30fc:	5c 01       	movw	r10, r24
    30fe:	4b 01       	movw	r8, r22
    3100:	7a 01       	movw	r14, r20
    3102:	12 2f       	mov	r17, r18
    3104:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3106:	63 e0       	ldi	r22, 0x03	; 3
    3108:	ca 01       	movw	r24, r20
    310a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    310e:	a8 14       	cp	r10, r8
    3110:	b9 04       	cpc	r11, r9
    3112:	08 f0       	brcs	.+2      	; 0x3116 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3114:	7d c0       	rjmp	.+250    	; 0x3210 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3116:	65 01       	movw	r12, r10
    3118:	84 e1       	ldi	r24, 0x14	; 20
    311a:	c8 0e       	add	r12, r24
    311c:	d1 1c       	adc	r13, r1
    311e:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3120:	6a 2c       	mov	r6, r10
    3122:	5b 2c       	mov	r5, r11
    3124:	b5 01       	movw	r22, r10
    3126:	c7 01       	movw	r24, r14
    3128:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <_ZN8emstreamlsEj>
    312c:	6a e0       	ldi	r22, 0x0A	; 10
    312e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    3132:	69 e4       	ldi	r22, 0x49	; 73
    3134:	75 e0       	ldi	r23, 0x05	; 5
    3136:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    313a:	11 23       	and	r17, r17
    313c:	09 f4       	brne	.+2      	; 0x3140 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    313e:	6d c0       	rjmp	.+218    	; 0x321a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3140:	00 23       	and	r16, r16
    3142:	09 f4       	brne	.+2      	; 0x3146 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3144:	6a c0       	rjmp	.+212    	; 0x321a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3146:	6a e0       	ldi	r22, 0x0A	; 10
    3148:	c7 01       	movw	r24, r14
    314a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    314e:	64 e4       	ldi	r22, 0x44	; 68
    3150:	75 e0       	ldi	r23, 0x05	; 5
    3152:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    3156:	61 c0       	rjmp	.+194    	; 0x321a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3158:	11 23       	and	r17, r17
    315a:	71 f0       	breq	.+28     	; 0x3178 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    315c:	01 11       	cpse	r16, r1
    315e:	0c c0       	rjmp	.+24     	; 0x3178 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3160:	88 81       	ld	r24, Y
    3162:	87 15       	cp	r24, r7
    3164:	49 f0       	breq	.+18     	; 0x3178 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3166:	6a e0       	ldi	r22, 0x0A	; 10
    3168:	c7 01       	movw	r24, r14
    316a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    316e:	6f e3       	ldi	r22, 0x3F	; 63
    3170:	75 e0       	ldi	r23, 0x05	; 5
    3172:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3176:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3178:	69 91       	ld	r22, Y+
    317a:	c7 01       	movw	r24, r14
    317c:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3180:	dc 01       	movw	r26, r24
    3182:	ed 91       	ld	r30, X+
    3184:	fc 91       	ld	r31, X
    3186:	02 80       	ldd	r0, Z+2	; 0x02
    3188:	f3 81       	ldd	r31, Z+3	; 0x03
    318a:	e0 2d       	mov	r30, r0
    318c:	60 e2       	ldi	r22, 0x20	; 32
    318e:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3190:	cc 16       	cp	r12, r28
    3192:	dd 06       	cpc	r13, r29
    3194:	09 f7       	brne	.-62     	; 0x3158 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3196:	11 23       	and	r17, r17
    3198:	89 f0       	breq	.+34     	; 0x31bc <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    319a:	6a e0       	ldi	r22, 0x0A	; 10
    319c:	c7 01       	movw	r24, r14
    319e:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    31a2:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    31a4:	69 e3       	ldi	r22, 0x39	; 57
    31a6:	75 e0       	ldi	r23, 0x05	; 5
    31a8:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    31ac:	e8 81       	ld	r30, Y
    31ae:	f9 81       	ldd	r31, Y+1	; 0x01
    31b0:	02 80       	ldd	r0, Z+2	; 0x02
    31b2:	f3 81       	ldd	r31, Z+3	; 0x03
    31b4:	e0 2d       	mov	r30, r0
    31b6:	60 e2       	ldi	r22, 0x20	; 32
    31b8:	ce 01       	movw	r24, r28
    31ba:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    31bc:	c6 2d       	mov	r28, r6
    31be:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    31c0:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    31c2:	80 ee       	ldi	r24, 0xE0	; 224
    31c4:	86 0f       	add	r24, r22
    31c6:	8f 35       	cpi	r24, 0x5F	; 95
    31c8:	48 f4       	brcc	.+18     	; 0x31dc <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    31ca:	d7 01       	movw	r26, r14
    31cc:	ed 91       	ld	r30, X+
    31ce:	fc 91       	ld	r31, X
    31d0:	02 80       	ldd	r0, Z+2	; 0x02
    31d2:	f3 81       	ldd	r31, Z+3	; 0x03
    31d4:	e0 2d       	mov	r30, r0
    31d6:	c7 01       	movw	r24, r14
    31d8:	19 95       	eicall
    31da:	09 c0       	rjmp	.+18     	; 0x31ee <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    31dc:	d7 01       	movw	r26, r14
    31de:	ed 91       	ld	r30, X+
    31e0:	fc 91       	ld	r31, X
    31e2:	02 80       	ldd	r0, Z+2	; 0x02
    31e4:	f3 81       	ldd	r31, Z+3	; 0x03
    31e6:	e0 2d       	mov	r30, r0
    31e8:	6e e2       	ldi	r22, 0x2E	; 46
    31ea:	c7 01       	movw	r24, r14
    31ec:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    31ee:	cc 16       	cp	r12, r28
    31f0:	dd 06       	cpc	r13, r29
    31f2:	31 f7       	brne	.-52     	; 0x31c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31f4:	b4 e1       	ldi	r27, 0x14	; 20
    31f6:	ab 0e       	add	r10, r27
    31f8:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31fa:	66 e0       	ldi	r22, 0x06	; 6
    31fc:	c7 01       	movw	r24, r14
    31fe:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    3202:	84 e1       	ldi	r24, 0x14	; 20
    3204:	c8 0e       	add	r12, r24
    3206:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3208:	a8 14       	cp	r10, r8
    320a:	b9 04       	cpc	r11, r9
    320c:	08 f4       	brcc	.+2      	; 0x3210 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    320e:	88 cf       	rjmp	.-240    	; 0x3120 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3210:	62 e0       	ldi	r22, 0x02	; 2
    3212:	c7 01       	movw	r24, r14
    3214:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
}
    3218:	03 c0       	rjmp	.+6      	; 0x3220 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    321a:	c6 2d       	mov	r28, r6
    321c:	d5 2d       	mov	r29, r5
    321e:	9c cf       	rjmp	.-200    	; 0x3158 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3220:	df 91       	pop	r29
    3222:	cf 91       	pop	r28
    3224:	1f 91       	pop	r17
    3226:	0f 91       	pop	r16
    3228:	ff 90       	pop	r15
    322a:	ef 90       	pop	r14
    322c:	df 90       	pop	r13
    322e:	cf 90       	pop	r12
    3230:	bf 90       	pop	r11
    3232:	af 90       	pop	r10
    3234:	9f 90       	pop	r9
    3236:	8f 90       	pop	r8
    3238:	7f 90       	pop	r7
    323a:	6f 90       	pop	r6
    323c:	5f 90       	pop	r5
    323e:	08 95       	ret

00003240 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3240:	0e 94 51 09 	call	0x12a2	; 0x12a2 <pvPortMalloc>
    3244:	08 95       	ret

00003246 <_Znaj>:
    3246:	0e 94 51 09 	call	0x12a2	; 0x12a2 <pvPortMalloc>
    324a:	08 95       	ret

0000324c <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    324c:	08 95       	ret

0000324e <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    324e:	cf 93       	push	r28
    3250:	df 93       	push	r29
    3252:	fc 01       	movw	r30, r24
    3254:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3256:	40 3a       	cpi	r20, 0xA0	; 160
    3258:	68 e0       	ldi	r22, 0x08	; 8
    325a:	56 07       	cpc	r21, r22
    325c:	49 f4       	brne	.+18     	; 0x3270 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    325e:	80 e4       	ldi	r24, 0x40	; 64
    3260:	96 e0       	ldi	r25, 0x06	; 6
    3262:	82 83       	std	Z+2, r24	; 0x02
    3264:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3266:	82 e0       	ldi	r24, 0x02	; 2
    3268:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    326a:	83 e0       	ldi	r24, 0x03	; 3
    326c:	85 83       	std	Z+5, r24	; 0x05
    326e:	32 c0       	rjmp	.+100    	; 0x32d4 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3270:	40 3b       	cpi	r20, 0xB0	; 176
    3272:	78 e0       	ldi	r23, 0x08	; 8
    3274:	57 07       	cpc	r21, r23
    3276:	49 f4       	brne	.+18     	; 0x328a <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3278:	80 e4       	ldi	r24, 0x40	; 64
    327a:	96 e0       	ldi	r25, 0x06	; 6
    327c:	82 83       	std	Z+2, r24	; 0x02
    327e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3280:	86 e0       	ldi	r24, 0x06	; 6
    3282:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3284:	87 e0       	ldi	r24, 0x07	; 7
    3286:	85 83       	std	Z+5, r24	; 0x05
    3288:	25 c0       	rjmp	.+74     	; 0x32d4 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    328a:	40 3a       	cpi	r20, 0xA0	; 160
    328c:	89 e0       	ldi	r24, 0x09	; 9
    328e:	58 07       	cpc	r21, r24
    3290:	49 f4       	brne	.+18     	; 0x32a4 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3292:	80 e6       	ldi	r24, 0x60	; 96
    3294:	96 e0       	ldi	r25, 0x06	; 6
    3296:	82 83       	std	Z+2, r24	; 0x02
    3298:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    329a:	82 e0       	ldi	r24, 0x02	; 2
    329c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    329e:	83 e0       	ldi	r24, 0x03	; 3
    32a0:	85 83       	std	Z+5, r24	; 0x05
    32a2:	18 c0       	rjmp	.+48     	; 0x32d4 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    32a4:	40 3b       	cpi	r20, 0xB0	; 176
    32a6:	69 e0       	ldi	r22, 0x09	; 9
    32a8:	56 07       	cpc	r21, r22
    32aa:	49 f4       	brne	.+18     	; 0x32be <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    32ac:	80 e6       	ldi	r24, 0x60	; 96
    32ae:	96 e0       	ldi	r25, 0x06	; 6
    32b0:	82 83       	std	Z+2, r24	; 0x02
    32b2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    32b4:	86 e0       	ldi	r24, 0x06	; 6
    32b6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32b8:	87 e0       	ldi	r24, 0x07	; 7
    32ba:	85 83       	std	Z+5, r24	; 0x05
    32bc:	0b c0       	rjmp	.+22     	; 0x32d4 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    32be:	40 3a       	cpi	r20, 0xA0	; 160
    32c0:	5a 40       	sbci	r21, 0x0A	; 10
    32c2:	41 f4       	brne	.+16     	; 0x32d4 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    32c4:	80 e8       	ldi	r24, 0x80	; 128
    32c6:	96 e0       	ldi	r25, 0x06	; 6
    32c8:	82 83       	std	Z+2, r24	; 0x02
    32ca:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32cc:	82 e0       	ldi	r24, 0x02	; 2
    32ce:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32d0:	83 e0       	ldi	r24, 0x03	; 3
    32d2:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    32d4:	a6 83       	std	Z+6, r26	; 0x06
    32d6:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    32d8:	cd 01       	movw	r24, r26
    32da:	01 96       	adiw	r24, 0x01	; 1
    32dc:	80 87       	std	Z+8, r24	; 0x08
    32de:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    32e0:	03 96       	adiw	r24, 0x03	; 3
    32e2:	82 87       	std	Z+10, r24	; 0x0a
    32e4:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    32e6:	25 81       	ldd	r18, Z+5	; 0x05
    32e8:	c2 81       	ldd	r28, Z+2	; 0x02
    32ea:	d3 81       	ldd	r29, Z+3	; 0x03
    32ec:	4c 81       	ldd	r20, Y+4	; 0x04
    32ee:	81 e0       	ldi	r24, 0x01	; 1
    32f0:	90 e0       	ldi	r25, 0x00	; 0
    32f2:	bc 01       	movw	r22, r24
    32f4:	02 c0       	rjmp	.+4      	; 0x32fa <_ZN7base232C1EjP12USART_struct+0xac>
    32f6:	66 0f       	add	r22, r22
    32f8:	77 1f       	adc	r23, r23
    32fa:	2a 95       	dec	r18
    32fc:	e2 f7       	brpl	.-8      	; 0x32f6 <_ZN7base232C1EjP12USART_struct+0xa8>
    32fe:	9b 01       	movw	r18, r22
    3300:	24 2b       	or	r18, r20
    3302:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3304:	25 81       	ldd	r18, Z+5	; 0x05
    3306:	c2 81       	ldd	r28, Z+2	; 0x02
    3308:	d3 81       	ldd	r29, Z+3	; 0x03
    330a:	48 81       	ld	r20, Y
    330c:	bc 01       	movw	r22, r24
    330e:	02 c0       	rjmp	.+4      	; 0x3314 <_ZN7base232C1EjP12USART_struct+0xc6>
    3310:	66 0f       	add	r22, r22
    3312:	77 1f       	adc	r23, r23
    3314:	2a 95       	dec	r18
    3316:	e2 f7       	brpl	.-8      	; 0x3310 <_ZN7base232C1EjP12USART_struct+0xc2>
    3318:	9b 01       	movw	r18, r22
    331a:	24 2b       	or	r18, r20
    331c:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    331e:	34 81       	ldd	r19, Z+4	; 0x04
    3320:	c2 81       	ldd	r28, Z+2	; 0x02
    3322:	d3 81       	ldd	r29, Z+3	; 0x03
    3324:	28 81       	ld	r18, Y
    3326:	02 c0       	rjmp	.+4      	; 0x332c <_ZN7base232C1EjP12USART_struct+0xde>
    3328:	88 0f       	add	r24, r24
    332a:	99 1f       	adc	r25, r25
    332c:	3a 95       	dec	r19
    332e:	e2 f7       	brpl	.-8      	; 0x3328 <_ZN7base232C1EjP12USART_struct+0xda>
    3330:	80 95       	com	r24
    3332:	90 95       	com	r25
    3334:	82 23       	and	r24, r18
    3336:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3338:	80 e1       	ldi	r24, 0x10	; 16
    333a:	13 96       	adiw	r26, 0x03	; 3
    333c:	8c 93       	st	X, r24
    333e:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3340:	83 e0       	ldi	r24, 0x03	; 3
    3342:	15 96       	adiw	r26, 0x05	; 5
    3344:	8c 93       	st	X, r24
    3346:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3348:	80 ef       	ldi	r24, 0xF0	; 240
    334a:	17 96       	adiw	r26, 0x07	; 7
    334c:	8c 93       	st	X, r24
    334e:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3350:	81 e2       	ldi	r24, 0x21	; 33
    3352:	16 96       	adiw	r26, 0x06	; 6
    3354:	8c 93       	st	X, r24
    3356:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3358:	88 e1       	ldi	r24, 0x18	; 24
    335a:	14 96       	adiw	r26, 0x04	; 4
    335c:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    335e:	80 e8       	ldi	r24, 0x80	; 128
    3360:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3362:	80 e4       	ldi	r24, 0x40	; 64
    3364:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3366:	80 e2       	ldi	r24, 0x20	; 32
    3368:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    336a:	06 80       	ldd	r0, Z+6	; 0x06
    336c:	f7 81       	ldd	r31, Z+7	; 0x07
    336e:	e0 2d       	mov	r30, r0
    3370:	80 81       	ld	r24, Z
    3372:	80 81       	ld	r24, Z
}
    3374:	df 91       	pop	r29
    3376:	cf 91       	pop	r28
    3378:	08 95       	ret

0000337a <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    337a:	81 e0       	ldi	r24, 0x01	; 1
    337c:	08 95       	ret

0000337e <_ZN8emstream7getcharEv>:
    337e:	80 e0       	ldi	r24, 0x00	; 0
    3380:	90 e0       	ldi	r25, 0x00	; 0
    3382:	08 95       	ret

00003384 <_ZN8emstream14check_for_charEv>:
    3384:	80 e0       	ldi	r24, 0x00	; 0
    3386:	08 95       	ret

00003388 <_ZN8emstream12transmit_nowEv>:
    3388:	08 95       	ret

0000338a <_ZN8emstream12clear_screenEv>:
    338a:	08 95       	ret

0000338c <_ZN8emstreamC1Ev>:
    338c:	fc 01       	movw	r30, r24
    338e:	87 e5       	ldi	r24, 0x57	; 87
    3390:	90 e2       	ldi	r25, 0x20	; 32
    3392:	80 83       	st	Z, r24
    3394:	91 83       	std	Z+1, r25	; 0x01
    3396:	8a e0       	ldi	r24, 0x0A	; 10
    3398:	82 83       	std	Z+2, r24	; 0x02
    339a:	13 82       	std	Z+3, r1	; 0x03
    339c:	83 e0       	ldi	r24, 0x03	; 3
    339e:	85 83       	std	Z+5, r24	; 0x05
    33a0:	14 82       	std	Z+4, r1	; 0x04
    33a2:	16 82       	std	Z+6, r1	; 0x06
    33a4:	17 82       	std	Z+7, r1	; 0x07
    33a6:	08 95       	ret

000033a8 <_ZN8emstream4putsEPKc>:
    33a8:	0f 93       	push	r16
    33aa:	1f 93       	push	r17
    33ac:	cf 93       	push	r28
    33ae:	df 93       	push	r29
    33b0:	8c 01       	movw	r16, r24
    33b2:	fb 01       	movw	r30, r22
    33b4:	dc 01       	movw	r26, r24
    33b6:	14 96       	adiw	r26, 0x04	; 4
    33b8:	8c 91       	ld	r24, X
    33ba:	81 11       	cpse	r24, r1
    33bc:	04 c0       	rjmp	.+8      	; 0x33c6 <_ZN8emstream4putsEPKc+0x1e>
    33be:	60 81       	ld	r22, Z
    33c0:	61 11       	cpse	r22, r1
    33c2:	17 c0       	rjmp	.+46     	; 0x33f2 <_ZN8emstream4putsEPKc+0x4a>
    33c4:	23 c0       	rjmp	.+70     	; 0x340c <_ZN8emstream4putsEPKc+0x64>
    33c6:	d8 01       	movw	r26, r16
    33c8:	14 96       	adiw	r26, 0x04	; 4
    33ca:	1c 92       	st	X, r1
    33cc:	eb 01       	movw	r28, r22
    33ce:	21 96       	adiw	r28, 0x01	; 1
    33d0:	64 91       	lpm	r22, Z
    33d2:	66 23       	and	r22, r22
    33d4:	d9 f0       	breq	.+54     	; 0x340c <_ZN8emstream4putsEPKc+0x64>
    33d6:	d8 01       	movw	r26, r16
    33d8:	ed 91       	ld	r30, X+
    33da:	fc 91       	ld	r31, X
    33dc:	02 80       	ldd	r0, Z+2	; 0x02
    33de:	f3 81       	ldd	r31, Z+3	; 0x03
    33e0:	e0 2d       	mov	r30, r0
    33e2:	c8 01       	movw	r24, r16
    33e4:	19 95       	eicall
    33e6:	fe 01       	movw	r30, r28
    33e8:	64 91       	lpm	r22, Z
    33ea:	21 96       	adiw	r28, 0x01	; 1
    33ec:	61 11       	cpse	r22, r1
    33ee:	f3 cf       	rjmp	.-26     	; 0x33d6 <_ZN8emstream4putsEPKc+0x2e>
    33f0:	0d c0       	rjmp	.+26     	; 0x340c <_ZN8emstream4putsEPKc+0x64>
    33f2:	ef 01       	movw	r28, r30
    33f4:	21 96       	adiw	r28, 0x01	; 1
    33f6:	d8 01       	movw	r26, r16
    33f8:	ed 91       	ld	r30, X+
    33fa:	fc 91       	ld	r31, X
    33fc:	02 80       	ldd	r0, Z+2	; 0x02
    33fe:	f3 81       	ldd	r31, Z+3	; 0x03
    3400:	e0 2d       	mov	r30, r0
    3402:	c8 01       	movw	r24, r16
    3404:	19 95       	eicall
    3406:	69 91       	ld	r22, Y+
    3408:	61 11       	cpse	r22, r1
    340a:	f5 cf       	rjmp	.-22     	; 0x33f6 <_ZN8emstream4putsEPKc+0x4e>
    340c:	df 91       	pop	r29
    340e:	cf 91       	pop	r28
    3410:	1f 91       	pop	r17
    3412:	0f 91       	pop	r16
    3414:	08 95       	ret

00003416 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3416:	cf 93       	push	r28
    3418:	df 93       	push	r29
    341a:	ec 01       	movw	r28, r24
	switch (new_manip)
    341c:	86 2f       	mov	r24, r22
    341e:	90 e0       	ldi	r25, 0x00	; 0
    3420:	8b 30       	cpi	r24, 0x0B	; 11
    3422:	91 05       	cpc	r25, r1
    3424:	d8 f5       	brcc	.+118    	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
    3426:	fc 01       	movw	r30, r24
    3428:	88 27       	eor	r24, r24
    342a:	e2 50       	subi	r30, 0x02	; 2
    342c:	ff 4f       	sbci	r31, 0xFF	; 255
    342e:	8f 4f       	sbci	r24, 0xFF	; 255
    3430:	0c 94 bd 1f 	jmp	0x3f7a	; 0x3f7a <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3434:	82 e0       	ldi	r24, 0x02	; 2
    3436:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3438:	31 c0       	rjmp	.+98     	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    343a:	88 e0       	ldi	r24, 0x08	; 8
    343c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    343e:	2e c0       	rjmp	.+92     	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3440:	8a e0       	ldi	r24, 0x0A	; 10
    3442:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3444:	2b c0       	rjmp	.+86     	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3446:	80 e1       	ldi	r24, 0x10	; 16
    3448:	8a 83       	std	Y+2, r24	; 0x02
			break;
    344a:	28 c0       	rjmp	.+80     	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    344c:	81 e0       	ldi	r24, 0x01	; 1
    344e:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3450:	25 c0       	rjmp	.+74     	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3452:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3454:	23 c0       	rjmp	.+70     	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3456:	e8 81       	ld	r30, Y
    3458:	f9 81       	ldd	r31, Y+1	; 0x01
    345a:	02 80       	ldd	r0, Z+2	; 0x02
    345c:	f3 81       	ldd	r31, Z+3	; 0x03
    345e:	e0 2d       	mov	r30, r0
    3460:	6d e0       	ldi	r22, 0x0D	; 13
    3462:	ce 01       	movw	r24, r28
    3464:	19 95       	eicall
    3466:	e8 81       	ld	r30, Y
    3468:	f9 81       	ldd	r31, Y+1	; 0x01
    346a:	02 80       	ldd	r0, Z+2	; 0x02
    346c:	f3 81       	ldd	r31, Z+3	; 0x03
    346e:	e0 2d       	mov	r30, r0
    3470:	6a e0       	ldi	r22, 0x0A	; 10
    3472:	ce 01       	movw	r24, r28
    3474:	19 95       	eicall
			break;
    3476:	12 c0       	rjmp	.+36     	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3478:	e8 81       	ld	r30, Y
    347a:	f9 81       	ldd	r31, Y+1	; 0x01
    347c:	02 84       	ldd	r0, Z+10	; 0x0a
    347e:	f3 85       	ldd	r31, Z+11	; 0x0b
    3480:	e0 2d       	mov	r30, r0
    3482:	ce 01       	movw	r24, r28
    3484:	19 95       	eicall
			break;
    3486:	0a c0       	rjmp	.+20     	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3488:	e8 81       	ld	r30, Y
    348a:	f9 81       	ldd	r31, Y+1	; 0x01
    348c:	00 84       	ldd	r0, Z+8	; 0x08
    348e:	f1 85       	ldd	r31, Z+9	; 0x09
    3490:	e0 2d       	mov	r30, r0
    3492:	ce 01       	movw	r24, r28
    3494:	19 95       	eicall
			break;
    3496:	02 c0       	rjmp	.+4      	; 0x349c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3498:	81 e0       	ldi	r24, 0x01	; 1
    349a:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    349c:	ce 01       	movw	r24, r28
    349e:	df 91       	pop	r29
    34a0:	cf 91       	pop	r28
    34a2:	08 95       	ret

000034a4 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    34a4:	0f 93       	push	r16
    34a6:	1f 93       	push	r17
    34a8:	cf 93       	push	r28
    34aa:	df 93       	push	r29
    34ac:	cd b7       	in	r28, 0x3d	; 61
    34ae:	de b7       	in	r29, 0x3e	; 62
    34b0:	61 97       	sbiw	r28, 0x11	; 17
    34b2:	cd bf       	out	0x3d, r28	; 61
    34b4:	de bf       	out	0x3e, r29	; 62
    34b6:	8c 01       	movw	r16, r24
    34b8:	9b 01       	movw	r18, r22
	if (base != 10)
    34ba:	fc 01       	movw	r30, r24
    34bc:	92 81       	ldd	r25, Z+2	; 0x02
    34be:	9a 30       	cpi	r25, 0x0A	; 10
    34c0:	21 f0       	breq	.+8      	; 0x34ca <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    34c2:	c8 01       	movw	r24, r16
    34c4:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <_ZN8emstreamlsEj>
    34c8:	0d c0       	rjmp	.+26     	; 0x34e4 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    34ca:	4a e0       	ldi	r20, 0x0A	; 10
    34cc:	be 01       	movw	r22, r28
    34ce:	6f 5f       	subi	r22, 0xFF	; 255
    34d0:	7f 4f       	sbci	r23, 0xFF	; 255
    34d2:	c9 01       	movw	r24, r18
    34d4:	0e 94 2a 20 	call	0x4054	; 0x4054 <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    34d8:	be 01       	movw	r22, r28
    34da:	6f 5f       	subi	r22, 0xFF	; 255
    34dc:	7f 4f       	sbci	r23, 0xFF	; 255
    34de:	c8 01       	movw	r24, r16
    34e0:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    34e4:	c8 01       	movw	r24, r16
    34e6:	61 96       	adiw	r28, 0x11	; 17
    34e8:	cd bf       	out	0x3d, r28	; 61
    34ea:	de bf       	out	0x3e, r29	; 62
    34ec:	df 91       	pop	r29
    34ee:	cf 91       	pop	r28
    34f0:	1f 91       	pop	r17
    34f2:	0f 91       	pop	r16
    34f4:	08 95       	ret

000034f6 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    34f6:	ff 92       	push	r15
    34f8:	0f 93       	push	r16
    34fa:	1f 93       	push	r17
    34fc:	cf 93       	push	r28
    34fe:	df 93       	push	r29
    3500:	cd b7       	in	r28, 0x3d	; 61
    3502:	de b7       	in	r29, 0x3e	; 62
    3504:	61 97       	sbiw	r28, 0x11	; 17
    3506:	cd bf       	out	0x3d, r28	; 61
    3508:	de bf       	out	0x3e, r29	; 62
    350a:	8c 01       	movw	r16, r24
    350c:	f6 2e       	mov	r15, r22
    350e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3510:	f8 01       	movw	r30, r16
    3512:	42 81       	ldd	r20, Z+2	; 0x02
    3514:	40 31       	cpi	r20, 0x10	; 16
    3516:	21 f0       	breq	.+8      	; 0x3520 <_ZN8emstreamlsEj+0x2a>
    3518:	48 30       	cpi	r20, 0x08	; 8
    351a:	11 f0       	breq	.+4      	; 0x3520 <_ZN8emstreamlsEj+0x2a>
    351c:	42 30       	cpi	r20, 0x02	; 2
    351e:	41 f4       	brne	.+16     	; 0x3530 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3520:	69 2f       	mov	r22, r25
    3522:	c8 01       	movw	r24, r16
    3524:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
    3528:	6f 2d       	mov	r22, r15
    352a:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
    352e:	0d c0       	rjmp	.+26     	; 0x354a <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3530:	50 e0       	ldi	r21, 0x00	; 0
    3532:	be 01       	movw	r22, r28
    3534:	6f 5f       	subi	r22, 0xFF	; 255
    3536:	7f 4f       	sbci	r23, 0xFF	; 255
    3538:	8f 2d       	mov	r24, r15
    353a:	0e 94 62 20 	call	0x40c4	; 0x40c4 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    353e:	be 01       	movw	r22, r28
    3540:	6f 5f       	subi	r22, 0xFF	; 255
    3542:	7f 4f       	sbci	r23, 0xFF	; 255
    3544:	c8 01       	movw	r24, r16
    3546:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    354a:	c8 01       	movw	r24, r16
    354c:	61 96       	adiw	r28, 0x11	; 17
    354e:	cd bf       	out	0x3d, r28	; 61
    3550:	de bf       	out	0x3e, r29	; 62
    3552:	df 91       	pop	r29
    3554:	cf 91       	pop	r28
    3556:	1f 91       	pop	r17
    3558:	0f 91       	pop	r16
    355a:	ff 90       	pop	r15
    355c:	08 95       	ret

0000355e <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    355e:	df 92       	push	r13
    3560:	ef 92       	push	r14
    3562:	ff 92       	push	r15
    3564:	0f 93       	push	r16
    3566:	1f 93       	push	r17
    3568:	cf 93       	push	r28
    356a:	df 93       	push	r29
    356c:	cd b7       	in	r28, 0x3d	; 61
    356e:	de b7       	in	r29, 0x3e	; 62
    3570:	a1 97       	sbiw	r28, 0x21	; 33
    3572:	cd bf       	out	0x3d, r28	; 61
    3574:	de bf       	out	0x3e, r29	; 62
    3576:	8c 01       	movw	r16, r24
    3578:	d4 2e       	mov	r13, r20
    357a:	e5 2e       	mov	r14, r21
    357c:	f6 2e       	mov	r15, r22
    357e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3580:	f8 01       	movw	r30, r16
    3582:	22 81       	ldd	r18, Z+2	; 0x02
    3584:	20 31       	cpi	r18, 0x10	; 16
    3586:	21 f0       	breq	.+8      	; 0x3590 <_ZN8emstreamlsEm+0x32>
    3588:	28 30       	cpi	r18, 0x08	; 8
    358a:	11 f0       	breq	.+4      	; 0x3590 <_ZN8emstreamlsEm+0x32>
    358c:	22 30       	cpi	r18, 0x02	; 2
    358e:	71 f4       	brne	.+28     	; 0x35ac <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3590:	69 2f       	mov	r22, r25
    3592:	c8 01       	movw	r24, r16
    3594:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
    3598:	6f 2d       	mov	r22, r15
    359a:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
    359e:	6e 2d       	mov	r22, r14
    35a0:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
    35a4:	6d 2d       	mov	r22, r13
    35a6:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_ZN8emstreamlsEh>
    35aa:	0f c0       	rjmp	.+30     	; 0x35ca <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    35ac:	30 e0       	ldi	r19, 0x00	; 0
    35ae:	ae 01       	movw	r20, r28
    35b0:	4f 5f       	subi	r20, 0xFF	; 255
    35b2:	5f 4f       	sbci	r21, 0xFF	; 255
    35b4:	6d 2d       	mov	r22, r13
    35b6:	7e 2d       	mov	r23, r14
    35b8:	8f 2d       	mov	r24, r15
    35ba:	0e 94 35 20 	call	0x406a	; 0x406a <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    35be:	be 01       	movw	r22, r28
    35c0:	6f 5f       	subi	r22, 0xFF	; 255
    35c2:	7f 4f       	sbci	r23, 0xFF	; 255
    35c4:	c8 01       	movw	r24, r16
    35c6:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35ca:	c8 01       	movw	r24, r16
    35cc:	a1 96       	adiw	r28, 0x21	; 33
    35ce:	cd bf       	out	0x3d, r28	; 61
    35d0:	de bf       	out	0x3e, r29	; 62
    35d2:	df 91       	pop	r29
    35d4:	cf 91       	pop	r28
    35d6:	1f 91       	pop	r17
    35d8:	0f 91       	pop	r16
    35da:	ff 90       	pop	r15
    35dc:	ef 90       	pop	r14
    35de:	df 90       	pop	r13
    35e0:	08 95       	ret

000035e2 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    35e2:	cf 92       	push	r12
    35e4:	df 92       	push	r13
    35e6:	ef 92       	push	r14
    35e8:	ff 92       	push	r15
    35ea:	0f 93       	push	r16
    35ec:	1f 93       	push	r17
    35ee:	cf 93       	push	r28
    35f0:	df 93       	push	r29
    35f2:	cd b7       	in	r28, 0x3d	; 61
    35f4:	de b7       	in	r29, 0x3e	; 62
    35f6:	29 97       	sbiw	r28, 0x09	; 9
    35f8:	cd bf       	out	0x3d, r28	; 61
    35fa:	de bf       	out	0x3e, r29	; 62
    35fc:	8c 01       	movw	r16, r24
    35fe:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3600:	dc 01       	movw	r26, r24
    3602:	13 96       	adiw	r26, 0x03	; 3
    3604:	8c 91       	ld	r24, X
    3606:	13 97       	sbiw	r26, 0x03	; 3
    3608:	88 23       	and	r24, r24
    360a:	41 f0       	breq	.+16     	; 0x361c <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    360c:	ed 91       	ld	r30, X+
    360e:	fc 91       	ld	r31, X
    3610:	02 80       	ldd	r0, Z+2	; 0x02
    3612:	f3 81       	ldd	r31, Z+3	; 0x03
    3614:	e0 2d       	mov	r30, r0
    3616:	c8 01       	movw	r24, r16
    3618:	19 95       	eicall
    361a:	56 c0       	rjmp	.+172    	; 0x36c8 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    361c:	f8 01       	movw	r30, r16
    361e:	42 81       	ldd	r20, Z+2	; 0x02
    3620:	42 30       	cpi	r20, 0x02	; 2
    3622:	19 f5       	brne	.+70     	; 0x366a <_ZN8emstreamlsEh+0x88>
    3624:	68 94       	set
    3626:	cc 24       	eor	r12, r12
    3628:	c3 f8       	bld	r12, 3
    362a:	d1 2c       	mov	r13, r1
    362c:	68 94       	set
    362e:	ff 24       	eor	r15, r15
    3630:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3632:	8e 2d       	mov	r24, r14
    3634:	8f 21       	and	r24, r15
    3636:	51 f0       	breq	.+20     	; 0x364c <_ZN8emstreamlsEh+0x6a>
    3638:	d8 01       	movw	r26, r16
    363a:	ed 91       	ld	r30, X+
    363c:	fc 91       	ld	r31, X
    363e:	02 80       	ldd	r0, Z+2	; 0x02
    3640:	f3 81       	ldd	r31, Z+3	; 0x03
    3642:	e0 2d       	mov	r30, r0
    3644:	61 e3       	ldi	r22, 0x31	; 49
    3646:	c8 01       	movw	r24, r16
    3648:	19 95       	eicall
    364a:	09 c0       	rjmp	.+18     	; 0x365e <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    364c:	d8 01       	movw	r26, r16
    364e:	ed 91       	ld	r30, X+
    3650:	fc 91       	ld	r31, X
    3652:	02 80       	ldd	r0, Z+2	; 0x02
    3654:	f3 81       	ldd	r31, Z+3	; 0x03
    3656:	e0 2d       	mov	r30, r0
    3658:	60 e3       	ldi	r22, 0x30	; 48
    365a:	c8 01       	movw	r24, r16
    365c:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    365e:	f6 94       	lsr	r15
    3660:	b1 e0       	ldi	r27, 0x01	; 1
    3662:	cb 1a       	sub	r12, r27
    3664:	d1 08       	sbc	r13, r1
    3666:	29 f7       	brne	.-54     	; 0x3632 <_ZN8emstreamlsEh+0x50>
    3668:	2f c0       	rjmp	.+94     	; 0x36c8 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    366a:	40 31       	cpi	r20, 0x10	; 16
    366c:	f9 f4       	brne	.+62     	; 0x36ac <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    366e:	62 95       	swap	r22
    3670:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3672:	01 90       	ld	r0, Z+
    3674:	f0 81       	ld	r31, Z
    3676:	e0 2d       	mov	r30, r0
    3678:	02 80       	ldd	r0, Z+2	; 0x02
    367a:	f3 81       	ldd	r31, Z+3	; 0x03
    367c:	e0 2d       	mov	r30, r0
    367e:	6a 30       	cpi	r22, 0x0A	; 10
    3680:	10 f0       	brcs	.+4      	; 0x3686 <_ZN8emstreamlsEh+0xa4>
    3682:	69 5c       	subi	r22, 0xC9	; 201
    3684:	01 c0       	rjmp	.+2      	; 0x3688 <_ZN8emstreamlsEh+0xa6>
    3686:	60 5d       	subi	r22, 0xD0	; 208
    3688:	c8 01       	movw	r24, r16
    368a:	19 95       	eicall
		temp_char = num & 0x0F;
    368c:	6e 2d       	mov	r22, r14
    368e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3690:	d8 01       	movw	r26, r16
    3692:	ed 91       	ld	r30, X+
    3694:	fc 91       	ld	r31, X
    3696:	02 80       	ldd	r0, Z+2	; 0x02
    3698:	f3 81       	ldd	r31, Z+3	; 0x03
    369a:	e0 2d       	mov	r30, r0
    369c:	6a 30       	cpi	r22, 0x0A	; 10
    369e:	10 f0       	brcs	.+4      	; 0x36a4 <_ZN8emstreamlsEh+0xc2>
    36a0:	69 5c       	subi	r22, 0xC9	; 201
    36a2:	01 c0       	rjmp	.+2      	; 0x36a6 <_ZN8emstreamlsEh+0xc4>
    36a4:	60 5d       	subi	r22, 0xD0	; 208
    36a6:	c8 01       	movw	r24, r16
    36a8:	19 95       	eicall
    36aa:	0e c0       	rjmp	.+28     	; 0x36c8 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    36ac:	50 e0       	ldi	r21, 0x00	; 0
    36ae:	be 01       	movw	r22, r28
    36b0:	6f 5f       	subi	r22, 0xFF	; 255
    36b2:	7f 4f       	sbci	r23, 0xFF	; 255
    36b4:	8e 2d       	mov	r24, r14
    36b6:	90 e0       	ldi	r25, 0x00	; 0
    36b8:	0e 94 62 20 	call	0x40c4	; 0x40c4 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    36bc:	be 01       	movw	r22, r28
    36be:	6f 5f       	subi	r22, 0xFF	; 255
    36c0:	7f 4f       	sbci	r23, 0xFF	; 255
    36c2:	c8 01       	movw	r24, r16
    36c4:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    36c8:	c8 01       	movw	r24, r16
    36ca:	29 96       	adiw	r28, 0x09	; 9
    36cc:	cd bf       	out	0x3d, r28	; 61
    36ce:	de bf       	out	0x3e, r29	; 62
    36d0:	df 91       	pop	r29
    36d2:	cf 91       	pop	r28
    36d4:	1f 91       	pop	r17
    36d6:	0f 91       	pop	r16
    36d8:	ff 90       	pop	r15
    36da:	ef 90       	pop	r14
    36dc:	df 90       	pop	r13
    36de:	cf 90       	pop	r12
    36e0:	08 95       	ret

000036e2 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    36e2:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36e4:	50 96       	adiw	r26, 0x10	; 16
    36e6:	ed 91       	ld	r30, X+
    36e8:	fc 91       	ld	r31, X
    36ea:	51 97       	sbiw	r26, 0x11	; 17
    36ec:	80 81       	ld	r24, Z
    36ee:	54 96       	adiw	r26, 0x14	; 20
    36f0:	4c 91       	ld	r20, X
    36f2:	54 97       	sbiw	r26, 0x14	; 20
    36f4:	84 23       	and	r24, r20
    36f6:	29 f0       	breq	.+10     	; 0x3702 <_ZN5rs2327putcharEc+0x20>
    36f8:	09 c0       	rjmp	.+18     	; 0x370c <_ZN5rs2327putcharEc+0x2a>
    36fa:	21 50       	subi	r18, 0x01	; 1
    36fc:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    36fe:	19 f4       	brne	.+6      	; 0x3706 <_ZN5rs2327putcharEc+0x24>
    3700:	12 c0       	rjmp	.+36     	; 0x3726 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3702:	21 e2       	ldi	r18, 0x21	; 33
    3704:	3e e4       	ldi	r19, 0x4E	; 78
    3706:	90 81       	ld	r25, Z
    3708:	94 23       	and	r25, r20
    370a:	b9 f3       	breq	.-18     	; 0x36fa <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    370c:	90 81       	ld	r25, Z
    370e:	56 96       	adiw	r26, 0x16	; 22
    3710:	8c 91       	ld	r24, X
    3712:	56 97       	sbiw	r26, 0x16	; 22
    3714:	89 2b       	or	r24, r25
    3716:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3718:	1e 96       	adiw	r26, 0x0e	; 14
    371a:	ed 91       	ld	r30, X+
    371c:	fc 91       	ld	r31, X
    371e:	1f 97       	sbiw	r26, 0x0f	; 15
    3720:	60 83       	st	Z, r22
	return (true);
    3722:	81 e0       	ldi	r24, 0x01	; 1
    3724:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3726:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3728:	08 95       	ret

0000372a <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    372a:	cf 93       	push	r28
    372c:	df 93       	push	r29
    372e:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3730:	c1 8d       	ldd	r28, Z+25	; 0x19
    3732:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3734:	28 81       	ld	r18, Y
    3736:	39 81       	ldd	r19, Y+1	; 0x01
    3738:	a3 8d       	ldd	r26, Z+27	; 0x1b
    373a:	b4 8d       	ldd	r27, Z+28	; 0x1c
    373c:	4d 91       	ld	r20, X+
    373e:	5c 91       	ld	r21, X
    3740:	24 17       	cp	r18, r20
    3742:	35 07       	cpc	r19, r21
    3744:	e9 f3       	breq	.-6      	; 0x3740 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3746:	a7 89       	ldd	r26, Z+23	; 0x17
    3748:	b0 8d       	ldd	r27, Z+24	; 0x18
    374a:	0d 90       	ld	r0, X+
    374c:	bc 91       	ld	r27, X
    374e:	a0 2d       	mov	r26, r0
    3750:	a2 0f       	add	r26, r18
    3752:	b3 1f       	adc	r27, r19
    3754:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3756:	2f 5f       	subi	r18, 0xFF	; 255
    3758:	3f 4f       	sbci	r19, 0xFF	; 255
    375a:	28 83       	st	Y, r18
    375c:	39 83       	std	Y+1, r19	; 0x01
    375e:	24 36       	cpi	r18, 0x64	; 100
    3760:	31 05       	cpc	r19, r1
    3762:	28 f0       	brcs	.+10     	; 0x376e <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3764:	01 8c       	ldd	r0, Z+25	; 0x19
    3766:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3768:	e0 2d       	mov	r30, r0
    376a:	10 82       	st	Z, r1
    376c:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    376e:	90 e0       	ldi	r25, 0x00	; 0
    3770:	df 91       	pop	r29
    3772:	cf 91       	pop	r28
    3774:	08 95       	ret

00003776 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3776:	cf 93       	push	r28
    3778:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    377a:	ec 01       	movw	r28, r24
    377c:	a9 8d       	ldd	r26, Y+25	; 0x19
    377e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3780:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3782:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3784:	81 e0       	ldi	r24, 0x01	; 1
    3786:	4d 91       	ld	r20, X+
    3788:	5c 91       	ld	r21, X
    378a:	20 81       	ld	r18, Z
    378c:	31 81       	ldd	r19, Z+1	; 0x01
    378e:	42 17       	cp	r20, r18
    3790:	53 07       	cpc	r21, r19
    3792:	09 f4       	brne	.+2      	; 0x3796 <_ZN5rs23214check_for_charEv+0x20>
    3794:	80 e0       	ldi	r24, 0x00	; 0
}
    3796:	df 91       	pop	r29
    3798:	cf 91       	pop	r28
    379a:	08 95       	ret

0000379c <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    379c:	dc 01       	movw	r26, r24
    379e:	ed 91       	ld	r30, X+
    37a0:	fc 91       	ld	r31, X
    37a2:	02 80       	ldd	r0, Z+2	; 0x02
    37a4:	f3 81       	ldd	r31, Z+3	; 0x03
    37a6:	e0 2d       	mov	r30, r0
    37a8:	6c e0       	ldi	r22, 0x0C	; 12
    37aa:	19 95       	eicall
    37ac:	08 95       	ret

000037ae <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    37ae:	ef 92       	push	r14
    37b0:	ff 92       	push	r15
    37b2:	0f 93       	push	r16
    37b4:	1f 93       	push	r17
    37b6:	cf 93       	push	r28
    37b8:	df 93       	push	r29
    37ba:	ec 01       	movw	r28, r24
    37bc:	7b 01       	movw	r14, r22
    37be:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    37c0:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN8emstreamC1Ev>
    37c4:	a8 01       	movw	r20, r16
    37c6:	b7 01       	movw	r22, r14
    37c8:	ce 01       	movw	r24, r28
    37ca:	08 96       	adiw	r24, 0x08	; 8
    37cc:	0e 94 27 19 	call	0x324e	; 0x324e <_ZN7base232C1EjP12USART_struct>
    37d0:	87 e6       	ldi	r24, 0x67	; 103
    37d2:	90 e2       	ldi	r25, 0x20	; 32
    37d4:	88 83       	st	Y, r24
    37d6:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    37d8:	00 3a       	cpi	r16, 0xA0	; 160
    37da:	88 e0       	ldi	r24, 0x08	; 8
    37dc:	18 07       	cpc	r17, r24
    37de:	69 f4       	brne	.+26     	; 0x37fa <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    37e0:	84 e4       	ldi	r24, 0x44	; 68
    37e2:	91 e3       	ldi	r25, 0x31	; 49
    37e4:	8f 8b       	std	Y+23, r24	; 0x17
    37e6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    37e8:	8a e3       	ldi	r24, 0x3A	; 58
    37ea:	91 e3       	ldi	r25, 0x31	; 49
    37ec:	89 8f       	std	Y+25, r24	; 0x19
    37ee:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    37f0:	80 e3       	ldi	r24, 0x30	; 48
    37f2:	91 e3       	ldi	r25, 0x31	; 49
    37f4:	8b 8f       	std	Y+27, r24	; 0x1b
    37f6:	9c 8f       	std	Y+28, r25	; 0x1c
    37f8:	42 c0       	rjmp	.+132    	; 0x387e <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    37fa:	00 3b       	cpi	r16, 0xB0	; 176
    37fc:	e8 e0       	ldi	r30, 0x08	; 8
    37fe:	1e 07       	cpc	r17, r30
    3800:	69 f4       	brne	.+26     	; 0x381c <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3802:	82 e4       	ldi	r24, 0x42	; 66
    3804:	91 e3       	ldi	r25, 0x31	; 49
    3806:	8f 8b       	std	Y+23, r24	; 0x17
    3808:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    380a:	88 e3       	ldi	r24, 0x38	; 56
    380c:	91 e3       	ldi	r25, 0x31	; 49
    380e:	89 8f       	std	Y+25, r24	; 0x19
    3810:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3812:	8e e2       	ldi	r24, 0x2E	; 46
    3814:	91 e3       	ldi	r25, 0x31	; 49
    3816:	8b 8f       	std	Y+27, r24	; 0x1b
    3818:	9c 8f       	std	Y+28, r25	; 0x1c
    381a:	31 c0       	rjmp	.+98     	; 0x387e <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    381c:	00 3a       	cpi	r16, 0xA0	; 160
    381e:	f9 e0       	ldi	r31, 0x09	; 9
    3820:	1f 07       	cpc	r17, r31
    3822:	69 f4       	brne	.+26     	; 0x383e <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3824:	80 e4       	ldi	r24, 0x40	; 64
    3826:	91 e3       	ldi	r25, 0x31	; 49
    3828:	8f 8b       	std	Y+23, r24	; 0x17
    382a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    382c:	86 e3       	ldi	r24, 0x36	; 54
    382e:	91 e3       	ldi	r25, 0x31	; 49
    3830:	89 8f       	std	Y+25, r24	; 0x19
    3832:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3834:	8c e2       	ldi	r24, 0x2C	; 44
    3836:	91 e3       	ldi	r25, 0x31	; 49
    3838:	8b 8f       	std	Y+27, r24	; 0x1b
    383a:	9c 8f       	std	Y+28, r25	; 0x1c
    383c:	20 c0       	rjmp	.+64     	; 0x387e <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    383e:	00 3b       	cpi	r16, 0xB0	; 176
    3840:	89 e0       	ldi	r24, 0x09	; 9
    3842:	18 07       	cpc	r17, r24
    3844:	69 f4       	brne	.+26     	; 0x3860 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3846:	8e e3       	ldi	r24, 0x3E	; 62
    3848:	91 e3       	ldi	r25, 0x31	; 49
    384a:	8f 8b       	std	Y+23, r24	; 0x17
    384c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    384e:	84 e3       	ldi	r24, 0x34	; 52
    3850:	91 e3       	ldi	r25, 0x31	; 49
    3852:	89 8f       	std	Y+25, r24	; 0x19
    3854:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3856:	8a e2       	ldi	r24, 0x2A	; 42
    3858:	91 e3       	ldi	r25, 0x31	; 49
    385a:	8b 8f       	std	Y+27, r24	; 0x1b
    385c:	9c 8f       	std	Y+28, r25	; 0x1c
    385e:	0f c0       	rjmp	.+30     	; 0x387e <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3860:	00 3a       	cpi	r16, 0xA0	; 160
    3862:	1a 40       	sbci	r17, 0x0A	; 10
    3864:	61 f4       	brne	.+24     	; 0x387e <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3866:	8c e3       	ldi	r24, 0x3C	; 60
    3868:	91 e3       	ldi	r25, 0x31	; 49
    386a:	8f 8b       	std	Y+23, r24	; 0x17
    386c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    386e:	82 e3       	ldi	r24, 0x32	; 50
    3870:	91 e3       	ldi	r25, 0x31	; 49
    3872:	89 8f       	std	Y+25, r24	; 0x19
    3874:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3876:	88 e2       	ldi	r24, 0x28	; 40
    3878:	91 e3       	ldi	r25, 0x31	; 49
    387a:	8b 8f       	std	Y+27, r24	; 0x1b
    387c:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    387e:	0f 89       	ldd	r16, Y+23	; 0x17
    3880:	18 8d       	ldd	r17, Y+24	; 0x18
    3882:	84 e6       	ldi	r24, 0x64	; 100
    3884:	90 e0       	ldi	r25, 0x00	; 0
    3886:	0e 94 23 19 	call	0x3246	; 0x3246 <_Znaj>
    388a:	f8 01       	movw	r30, r16
    388c:	80 83       	st	Z, r24
    388e:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3890:	e9 8d       	ldd	r30, Y+25	; 0x19
    3892:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3894:	10 82       	st	Z, r1
    3896:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3898:	eb 8d       	ldd	r30, Y+27	; 0x1b
    389a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    389c:	10 82       	st	Z, r1
    389e:	11 82       	std	Z+1, r1	; 0x01
}
    38a0:	df 91       	pop	r29
    38a2:	cf 91       	pop	r28
    38a4:	1f 91       	pop	r17
    38a6:	0f 91       	pop	r16
    38a8:	ff 90       	pop	r15
    38aa:	ef 90       	pop	r14
    38ac:	08 95       	ret

000038ae <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    38ae:	1f 92       	push	r1
    38b0:	0f 92       	push	r0
    38b2:	0f b6       	in	r0, 0x3f	; 63
    38b4:	0f 92       	push	r0
    38b6:	11 24       	eor	r1, r1
    38b8:	08 b6       	in	r0, 0x38	; 56
    38ba:	0f 92       	push	r0
    38bc:	18 be       	out	0x38, r1	; 56
    38be:	0b b6       	in	r0, 0x3b	; 59
    38c0:	0f 92       	push	r0
    38c2:	1b be       	out	0x3b, r1	; 59
    38c4:	2f 93       	push	r18
    38c6:	3f 93       	push	r19
    38c8:	8f 93       	push	r24
    38ca:	9f 93       	push	r25
    38cc:	ef 93       	push	r30
    38ce:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    38d0:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    38d4:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    38d8:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    38dc:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    38e0:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    38e4:	e8 0f       	add	r30, r24
    38e6:	f9 1f       	adc	r31, r25
    38e8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    38ea:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    38ee:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    38f2:	01 96       	adiw	r24, 0x01	; 1
    38f4:	84 36       	cpi	r24, 0x64	; 100
    38f6:	91 05       	cpc	r25, r1
    38f8:	60 f4       	brcc	.+24     	; 0x3912 <__vector_25+0x64>
    38fa:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    38fe:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3902:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    3906:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    390a:	82 17       	cp	r24, r18
    390c:	93 07       	cpc	r25, r19
    390e:	f1 f4       	brne	.+60     	; 0x394c <__vector_25+0x9e>
    3910:	0c c0       	rjmp	.+24     	; 0x392a <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3912:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    3916:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    391a:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    391e:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3922:	18 16       	cp	r1, r24
    3924:	19 06       	cpc	r1, r25
    3926:	91 f4       	brne	.+36     	; 0x394c <__vector_25+0x9e>
    3928:	0e c0       	rjmp	.+28     	; 0x3946 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    392a:	01 96       	adiw	r24, 0x01	; 1
    392c:	84 36       	cpi	r24, 0x64	; 100
    392e:	91 05       	cpc	r25, r1
    3930:	28 f4       	brcc	.+10     	; 0x393c <__vector_25+0x8e>
    3932:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    3936:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    393a:	08 c0       	rjmp	.+16     	; 0x394c <__vector_25+0x9e>
			rcvC0_read_index = 0;
    393c:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    3940:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    3944:	03 c0       	rjmp	.+6      	; 0x394c <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3946:	81 e0       	ldi	r24, 0x01	; 1
    3948:	90 e0       	ldi	r25, 0x00	; 0
    394a:	f3 cf       	rjmp	.-26     	; 0x3932 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    394c:	ff 91       	pop	r31
    394e:	ef 91       	pop	r30
    3950:	9f 91       	pop	r25
    3952:	8f 91       	pop	r24
    3954:	3f 91       	pop	r19
    3956:	2f 91       	pop	r18
    3958:	0f 90       	pop	r0
    395a:	0b be       	out	0x3b, r0	; 59
    395c:	0f 90       	pop	r0
    395e:	08 be       	out	0x38, r0	; 56
    3960:	0f 90       	pop	r0
    3962:	0f be       	out	0x3f, r0	; 63
    3964:	0f 90       	pop	r0
    3966:	1f 90       	pop	r1
    3968:	18 95       	reti

0000396a <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    396a:	1f 92       	push	r1
    396c:	0f 92       	push	r0
    396e:	0f b6       	in	r0, 0x3f	; 63
    3970:	0f 92       	push	r0
    3972:	11 24       	eor	r1, r1
    3974:	08 b6       	in	r0, 0x38	; 56
    3976:	0f 92       	push	r0
    3978:	18 be       	out	0x38, r1	; 56
    397a:	0b b6       	in	r0, 0x3b	; 59
    397c:	0f 92       	push	r0
    397e:	1b be       	out	0x3b, r1	; 59
    3980:	2f 93       	push	r18
    3982:	3f 93       	push	r19
    3984:	8f 93       	push	r24
    3986:	9f 93       	push	r25
    3988:	ef 93       	push	r30
    398a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    398c:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3990:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    3994:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3998:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    399c:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    39a0:	e8 0f       	add	r30, r24
    39a2:	f9 1f       	adc	r31, r25
    39a4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    39a6:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    39aa:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    39ae:	01 96       	adiw	r24, 0x01	; 1
    39b0:	84 36       	cpi	r24, 0x64	; 100
    39b2:	91 05       	cpc	r25, r1
    39b4:	60 f4       	brcc	.+24     	; 0x39ce <__vector_28+0x64>
    39b6:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    39ba:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39be:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    39c2:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    39c6:	82 17       	cp	r24, r18
    39c8:	93 07       	cpc	r25, r19
    39ca:	f1 f4       	brne	.+60     	; 0x3a08 <__vector_28+0x9e>
    39cc:	0c c0       	rjmp	.+24     	; 0x39e6 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    39ce:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    39d2:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39d6:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    39da:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    39de:	18 16       	cp	r1, r24
    39e0:	19 06       	cpc	r1, r25
    39e2:	91 f4       	brne	.+36     	; 0x3a08 <__vector_28+0x9e>
    39e4:	0e c0       	rjmp	.+28     	; 0x3a02 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    39e6:	01 96       	adiw	r24, 0x01	; 1
    39e8:	84 36       	cpi	r24, 0x64	; 100
    39ea:	91 05       	cpc	r25, r1
    39ec:	28 f4       	brcc	.+10     	; 0x39f8 <__vector_28+0x8e>
    39ee:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    39f2:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    39f6:	08 c0       	rjmp	.+16     	; 0x3a08 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    39f8:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    39fc:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    3a00:	03 c0       	rjmp	.+6      	; 0x3a08 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a02:	81 e0       	ldi	r24, 0x01	; 1
    3a04:	90 e0       	ldi	r25, 0x00	; 0
    3a06:	f3 cf       	rjmp	.-26     	; 0x39ee <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3a08:	ff 91       	pop	r31
    3a0a:	ef 91       	pop	r30
    3a0c:	9f 91       	pop	r25
    3a0e:	8f 91       	pop	r24
    3a10:	3f 91       	pop	r19
    3a12:	2f 91       	pop	r18
    3a14:	0f 90       	pop	r0
    3a16:	0b be       	out	0x3b, r0	; 59
    3a18:	0f 90       	pop	r0
    3a1a:	08 be       	out	0x38, r0	; 56
    3a1c:	0f 90       	pop	r0
    3a1e:	0f be       	out	0x3f, r0	; 63
    3a20:	0f 90       	pop	r0
    3a22:	1f 90       	pop	r1
    3a24:	18 95       	reti

00003a26 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3a26:	1f 92       	push	r1
    3a28:	0f 92       	push	r0
    3a2a:	0f b6       	in	r0, 0x3f	; 63
    3a2c:	0f 92       	push	r0
    3a2e:	11 24       	eor	r1, r1
    3a30:	08 b6       	in	r0, 0x38	; 56
    3a32:	0f 92       	push	r0
    3a34:	18 be       	out	0x38, r1	; 56
    3a36:	0b b6       	in	r0, 0x3b	; 59
    3a38:	0f 92       	push	r0
    3a3a:	1b be       	out	0x3b, r1	; 59
    3a3c:	2f 93       	push	r18
    3a3e:	3f 93       	push	r19
    3a40:	8f 93       	push	r24
    3a42:	9f 93       	push	r25
    3a44:	ef 93       	push	r30
    3a46:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3a48:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3a4c:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    3a50:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    3a54:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3a58:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3a5c:	e8 0f       	add	r30, r24
    3a5e:	f9 1f       	adc	r31, r25
    3a60:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3a62:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    3a66:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    3a6a:	01 96       	adiw	r24, 0x01	; 1
    3a6c:	84 36       	cpi	r24, 0x64	; 100
    3a6e:	91 05       	cpc	r25, r1
    3a70:	60 f4       	brcc	.+24     	; 0x3a8a <__vector_88+0x64>
    3a72:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    3a76:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a7a:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    3a7e:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3a82:	82 17       	cp	r24, r18
    3a84:	93 07       	cpc	r25, r19
    3a86:	f1 f4       	brne	.+60     	; 0x3ac4 <__vector_88+0x9e>
    3a88:	0c c0       	rjmp	.+24     	; 0x3aa2 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3a8a:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    3a8e:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a92:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    3a96:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3a9a:	18 16       	cp	r1, r24
    3a9c:	19 06       	cpc	r1, r25
    3a9e:	91 f4       	brne	.+36     	; 0x3ac4 <__vector_88+0x9e>
    3aa0:	0e c0       	rjmp	.+28     	; 0x3abe <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3aa2:	01 96       	adiw	r24, 0x01	; 1
    3aa4:	84 36       	cpi	r24, 0x64	; 100
    3aa6:	91 05       	cpc	r25, r1
    3aa8:	28 f4       	brcc	.+10     	; 0x3ab4 <__vector_88+0x8e>
    3aaa:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    3aae:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    3ab2:	08 c0       	rjmp	.+16     	; 0x3ac4 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3ab4:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    3ab8:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    3abc:	03 c0       	rjmp	.+6      	; 0x3ac4 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3abe:	81 e0       	ldi	r24, 0x01	; 1
    3ac0:	90 e0       	ldi	r25, 0x00	; 0
    3ac2:	f3 cf       	rjmp	.-26     	; 0x3aaa <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3ac4:	ff 91       	pop	r31
    3ac6:	ef 91       	pop	r30
    3ac8:	9f 91       	pop	r25
    3aca:	8f 91       	pop	r24
    3acc:	3f 91       	pop	r19
    3ace:	2f 91       	pop	r18
    3ad0:	0f 90       	pop	r0
    3ad2:	0b be       	out	0x3b, r0	; 59
    3ad4:	0f 90       	pop	r0
    3ad6:	08 be       	out	0x38, r0	; 56
    3ad8:	0f 90       	pop	r0
    3ada:	0f be       	out	0x3f, r0	; 63
    3adc:	0f 90       	pop	r0
    3ade:	1f 90       	pop	r1
    3ae0:	18 95       	reti

00003ae2 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3ae2:	1f 92       	push	r1
    3ae4:	0f 92       	push	r0
    3ae6:	0f b6       	in	r0, 0x3f	; 63
    3ae8:	0f 92       	push	r0
    3aea:	11 24       	eor	r1, r1
    3aec:	08 b6       	in	r0, 0x38	; 56
    3aee:	0f 92       	push	r0
    3af0:	18 be       	out	0x38, r1	; 56
    3af2:	0b b6       	in	r0, 0x3b	; 59
    3af4:	0f 92       	push	r0
    3af6:	1b be       	out	0x3b, r1	; 59
    3af8:	2f 93       	push	r18
    3afa:	3f 93       	push	r19
    3afc:	8f 93       	push	r24
    3afe:	9f 93       	push	r25
    3b00:	ef 93       	push	r30
    3b02:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3b04:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3b08:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    3b0c:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    3b10:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3b14:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3b18:	e8 0f       	add	r30, r24
    3b1a:	f9 1f       	adc	r31, r25
    3b1c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3b1e:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3b22:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3b26:	01 96       	adiw	r24, 0x01	; 1
    3b28:	84 36       	cpi	r24, 0x64	; 100
    3b2a:	91 05       	cpc	r25, r1
    3b2c:	60 f4       	brcc	.+24     	; 0x3b46 <__vector_91+0x64>
    3b2e:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    3b32:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b36:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    3b3a:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3b3e:	82 17       	cp	r24, r18
    3b40:	93 07       	cpc	r25, r19
    3b42:	f1 f4       	brne	.+60     	; 0x3b80 <__vector_91+0x9e>
    3b44:	0c c0       	rjmp	.+24     	; 0x3b5e <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3b46:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    3b4a:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b4e:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    3b52:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3b56:	18 16       	cp	r1, r24
    3b58:	19 06       	cpc	r1, r25
    3b5a:	91 f4       	brne	.+36     	; 0x3b80 <__vector_91+0x9e>
    3b5c:	0e c0       	rjmp	.+28     	; 0x3b7a <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b5e:	01 96       	adiw	r24, 0x01	; 1
    3b60:	84 36       	cpi	r24, 0x64	; 100
    3b62:	91 05       	cpc	r25, r1
    3b64:	28 f4       	brcc	.+10     	; 0x3b70 <__vector_91+0x8e>
    3b66:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    3b6a:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    3b6e:	08 c0       	rjmp	.+16     	; 0x3b80 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3b70:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    3b74:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    3b78:	03 c0       	rjmp	.+6      	; 0x3b80 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b7a:	81 e0       	ldi	r24, 0x01	; 1
    3b7c:	90 e0       	ldi	r25, 0x00	; 0
    3b7e:	f3 cf       	rjmp	.-26     	; 0x3b66 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3b80:	ff 91       	pop	r31
    3b82:	ef 91       	pop	r30
    3b84:	9f 91       	pop	r25
    3b86:	8f 91       	pop	r24
    3b88:	3f 91       	pop	r19
    3b8a:	2f 91       	pop	r18
    3b8c:	0f 90       	pop	r0
    3b8e:	0b be       	out	0x3b, r0	; 59
    3b90:	0f 90       	pop	r0
    3b92:	08 be       	out	0x38, r0	; 56
    3b94:	0f 90       	pop	r0
    3b96:	0f be       	out	0x3f, r0	; 63
    3b98:	0f 90       	pop	r0
    3b9a:	1f 90       	pop	r1
    3b9c:	18 95       	reti

00003b9e <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3b9e:	1f 92       	push	r1
    3ba0:	0f 92       	push	r0
    3ba2:	0f b6       	in	r0, 0x3f	; 63
    3ba4:	0f 92       	push	r0
    3ba6:	11 24       	eor	r1, r1
    3ba8:	08 b6       	in	r0, 0x38	; 56
    3baa:	0f 92       	push	r0
    3bac:	18 be       	out	0x38, r1	; 56
    3bae:	0b b6       	in	r0, 0x3b	; 59
    3bb0:	0f 92       	push	r0
    3bb2:	1b be       	out	0x3b, r1	; 59
    3bb4:	2f 93       	push	r18
    3bb6:	3f 93       	push	r19
    3bb8:	8f 93       	push	r24
    3bba:	9f 93       	push	r25
    3bbc:	ef 93       	push	r30
    3bbe:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3bc0:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3bc4:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    3bc8:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    3bcc:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3bd0:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3bd4:	e8 0f       	add	r30, r24
    3bd6:	f9 1f       	adc	r31, r25
    3bd8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3bda:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3bde:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3be2:	01 96       	adiw	r24, 0x01	; 1
    3be4:	84 36       	cpi	r24, 0x64	; 100
    3be6:	91 05       	cpc	r25, r1
    3be8:	60 f4       	brcc	.+24     	; 0x3c02 <__vector_58+0x64>
    3bea:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    3bee:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3bf2:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    3bf6:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3bfa:	82 17       	cp	r24, r18
    3bfc:	93 07       	cpc	r25, r19
    3bfe:	f1 f4       	brne	.+60     	; 0x3c3c <__vector_58+0x9e>
    3c00:	0c c0       	rjmp	.+24     	; 0x3c1a <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3c02:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    3c06:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c0a:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    3c0e:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3c12:	18 16       	cp	r1, r24
    3c14:	19 06       	cpc	r1, r25
    3c16:	91 f4       	brne	.+36     	; 0x3c3c <__vector_58+0x9e>
    3c18:	0e c0       	rjmp	.+28     	; 0x3c36 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c1a:	01 96       	adiw	r24, 0x01	; 1
    3c1c:	84 36       	cpi	r24, 0x64	; 100
    3c1e:	91 05       	cpc	r25, r1
    3c20:	28 f4       	brcc	.+10     	; 0x3c2c <__vector_58+0x8e>
    3c22:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    3c26:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    3c2a:	08 c0       	rjmp	.+16     	; 0x3c3c <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3c2c:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    3c30:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    3c34:	03 c0       	rjmp	.+6      	; 0x3c3c <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c36:	81 e0       	ldi	r24, 0x01	; 1
    3c38:	90 e0       	ldi	r25, 0x00	; 0
    3c3a:	f3 cf       	rjmp	.-26     	; 0x3c22 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3c3c:	ff 91       	pop	r31
    3c3e:	ef 91       	pop	r30
    3c40:	9f 91       	pop	r25
    3c42:	8f 91       	pop	r24
    3c44:	3f 91       	pop	r19
    3c46:	2f 91       	pop	r18
    3c48:	0f 90       	pop	r0
    3c4a:	0b be       	out	0x3b, r0	; 59
    3c4c:	0f 90       	pop	r0
    3c4e:	08 be       	out	0x38, r0	; 56
    3c50:	0f 90       	pop	r0
    3c52:	0f be       	out	0x3f, r0	; 63
    3c54:	0f 90       	pop	r0
    3c56:	1f 90       	pop	r1
    3c58:	18 95       	reti

00003c5a <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3c5a:	0f 93       	push	r16
    3c5c:	cf 93       	push	r28
    3c5e:	df 93       	push	r29
    3c60:	1f 92       	push	r1
    3c62:	cd b7       	in	r28, 0x3d	; 61
    3c64:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3c66:	2f b7       	in	r18, 0x3f	; 63
    3c68:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3c6a:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3c6c:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3c6e:	fc 01       	movw	r30, r24
    3c70:	08 ed       	ldi	r16, 0xD8	; 216
    3c72:	04 bf       	out	0x34, r16	; 52
    3c74:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3c76:	89 81       	ldd	r24, Y+1	; 0x01
    3c78:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3c7a:	0f 90       	pop	r0
    3c7c:	df 91       	pop	r29
    3c7e:	cf 91       	pop	r28
    3c80:	0f 91       	pop	r16
    3c82:	08 95       	ret

00003c84 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3c84:	0f 93       	push	r16
    3c86:	1f 93       	push	r17
    3c88:	cf 93       	push	r28
    3c8a:	df 93       	push	r29
    3c8c:	cd b7       	in	r28, 0x3d	; 61
    3c8e:	de b7       	in	r29, 0x3e	; 62
    3c90:	6d 97       	sbiw	r28, 0x1d	; 29
    3c92:	cd bf       	out	0x3d, r28	; 61
    3c94:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3c96:	e0 e6       	ldi	r30, 0x60	; 96
    3c98:	f6 e0       	ldi	r31, 0x06	; 6
    3c9a:	80 e4       	ldi	r24, 0x40	; 64
    3c9c:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3c9e:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3ca0:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3ca2:	e0 e5       	ldi	r30, 0x50	; 80
    3ca4:	f0 e0       	ldi	r31, 0x00	; 0
    3ca6:	80 81       	ld	r24, Z
    3ca8:	82 60       	ori	r24, 0x02	; 2
    3caa:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3cac:	81 81       	ldd	r24, Z+1	; 0x01
    3cae:	81 ff       	sbrs	r24, 1
    3cb0:	fd cf       	rjmp	.-6      	; 0x3cac <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3cb2:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3cb6:	68 7f       	andi	r22, 0xF8	; 248
    3cb8:	61 60       	ori	r22, 0x01	; 1
    3cba:	80 e4       	ldi	r24, 0x40	; 64
    3cbc:	90 e0       	ldi	r25, 0x00	; 0
    3cbe:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3cc2:	e0 e5       	ldi	r30, 0x50	; 80
    3cc4:	f0 e0       	ldi	r31, 0x00	; 0
    3cc6:	80 81       	ld	r24, Z
    3cc8:	8e 7f       	andi	r24, 0xFE	; 254
    3cca:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3ccc:	9d ef       	ldi	r25, 0xFD	; 253
    3cce:	88 ed       	ldi	r24, 0xD8	; 216
    3cd0:	08 b6       	in	r0, 0x38	; 56
    3cd2:	18 be       	out	0x38, r1	; 56
    3cd4:	84 bf       	out	0x34, r24	; 52
    3cd6:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3cda:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3cdc:	40 eb       	ldi	r20, 0xB0	; 176
    3cde:	58 e0       	ldi	r21, 0x08	; 8
    3ce0:	60 e0       	ldi	r22, 0x00	; 0
    3ce2:	70 e0       	ldi	r23, 0x00	; 0
    3ce4:	ce 01       	movw	r24, r28
    3ce6:	01 96       	adiw	r24, 0x01	; 1
    3ce8:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3cec:	67 e0       	ldi	r22, 0x07	; 7
    3cee:	ce 01       	movw	r24, r28
    3cf0:	01 96       	adiw	r24, 0x01	; 1
    3cf2:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    3cf6:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3cf8:	63 e7       	ldi	r22, 0x73	; 115
    3cfa:	70 e2       	ldi	r23, 0x20	; 32
    3cfc:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN8emstream4putsEPKc>
    3d00:	66 e0       	ldi	r22, 0x06	; 6
    3d02:	c8 01       	movw	r24, r16
    3d04:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
    3d08:	66 e0       	ldi	r22, 0x06	; 6
    3d0a:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3d0e:	82 e1       	ldi	r24, 0x12	; 18
    3d10:	90 e0       	ldi	r25, 0x00	; 0
    3d12:	0e 94 20 19 	call	0x3240	; 0x3240 <_Znwj>
    3d16:	8e 01       	movw	r16, r28
    3d18:	0f 5f       	subi	r16, 0xFF	; 255
    3d1a:	1f 4f       	sbci	r17, 0xFF	; 255
    3d1c:	24 e0       	ldi	r18, 0x04	; 4
    3d1e:	31 e0       	ldi	r19, 0x01	; 1
    3d20:	40 e0       	ldi	r20, 0x00	; 0
    3d22:	62 e9       	ldi	r22, 0x92	; 146
    3d24:	70 e2       	ldi	r23, 0x20	; 32
    3d26:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3d2a:	82 e1       	ldi	r24, 0x12	; 18
    3d2c:	90 e0       	ldi	r25, 0x00	; 0
    3d2e:	0e 94 20 19 	call	0x3240	; 0x3240 <_Znwj>
    3d32:	24 e0       	ldi	r18, 0x04	; 4
    3d34:	31 e0       	ldi	r19, 0x01	; 1
    3d36:	42 e0       	ldi	r20, 0x02	; 2
    3d38:	6a e9       	ldi	r22, 0x9A	; 154
    3d3a:	70 e2       	ldi	r23, 0x20	; 32
    3d3c:	0e 94 54 03 	call	0x6a8	; 0x6a8 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3d40:	82 e1       	ldi	r24, 0x12	; 18
    3d42:	90 e0       	ldi	r25, 0x00	; 0
    3d44:	0e 94 20 19 	call	0x3240	; 0x3240 <_Znwj>
    3d48:	24 e0       	ldi	r18, 0x04	; 4
    3d4a:	31 e0       	ldi	r19, 0x01	; 1
    3d4c:	43 e0       	ldi	r20, 0x03	; 3
    3d4e:	61 ea       	ldi	r22, 0xA1	; 161
    3d50:	70 e2       	ldi	r23, 0x20	; 32
    3d52:	0e 94 ad 03 	call	0x75a	; 0x75a <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3d56:	82 e1       	ldi	r24, 0x12	; 18
    3d58:	90 e0       	ldi	r25, 0x00	; 0
    3d5a:	0e 94 20 19 	call	0x3240	; 0x3240 <_Znwj>
    3d5e:	24 e0       	ldi	r18, 0x04	; 4
    3d60:	31 e0       	ldi	r19, 0x01	; 1
    3d62:	44 e0       	ldi	r20, 0x04	; 4
    3d64:	68 ea       	ldi	r22, 0xA8	; 168
    3d66:	70 e2       	ldi	r23, 0x20	; 32
    3d68:	0e 94 12 04 	call	0x824	; 0x824 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3d6c:	8c e6       	ldi	r24, 0x6C	; 108
    3d6e:	90 e0       	ldi	r25, 0x00	; 0
    3d70:	0e 94 20 19 	call	0x3240	; 0x3240 <_Znwj>
    3d74:	24 e0       	ldi	r18, 0x04	; 4
    3d76:	31 e0       	ldi	r19, 0x01	; 1
    3d78:	43 e0       	ldi	r20, 0x03	; 3
    3d7a:	61 eb       	ldi	r22, 0xB1	; 177
    3d7c:	70 e2       	ldi	r23, 0x20	; 32
    3d7e:	0e 94 2d 06 	call	0xc5a	; 0xc5a <_ZN5MotorC1EPKchjP8emstream>
	
	new PWMdriver ("PWM", task_priority(5), 260, &ser_dev);
    3d82:	82 e1       	ldi	r24, 0x12	; 18
    3d84:	90 e0       	ldi	r25, 0x00	; 0
    3d86:	0e 94 20 19 	call	0x3240	; 0x3240 <_Znwj>
    3d8a:	24 e0       	ldi	r18, 0x04	; 4
    3d8c:	31 e0       	ldi	r19, 0x01	; 1
    3d8e:	44 e0       	ldi	r20, 0x04	; 4
    3d90:	67 eb       	ldi	r22, 0xB7	; 183
    3d92:	70 e2       	ldi	r23, 0x20	; 32
    3d94:	0e 94 a3 06 	call	0xd46	; 0xd46 <_ZN9PWMdriverC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3d98:	87 e0       	ldi	r24, 0x07	; 7
    3d9a:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3d9e:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3da0:	0e 94 32 10 	call	0x2064	; 0x2064 <vTaskStartScheduler>
	
	
	return 0;
    3da4:	80 e0       	ldi	r24, 0x00	; 0
    3da6:	90 e0       	ldi	r25, 0x00	; 0
    3da8:	6d 96       	adiw	r28, 0x1d	; 29
    3daa:	cd bf       	out	0x3d, r28	; 61
    3dac:	de bf       	out	0x3e, r29	; 62
    3dae:	df 91       	pop	r29
    3db0:	cf 91       	pop	r28
    3db2:	1f 91       	pop	r17
    3db4:	0f 91       	pop	r16
    3db6:	08 95       	ret

00003db8 <_GLOBAL__sub_I_counter>:
    3db8:	0f 93       	push	r16
    3dba:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3dbc:	0a e0       	ldi	r16, 0x0A	; 10
    3dbe:	10 e0       	ldi	r17, 0x00	; 0
    3dc0:	20 e0       	ldi	r18, 0x00	; 0
    3dc2:	30 e0       	ldi	r19, 0x00	; 0
    3dc4:	40 e0       	ldi	r20, 0x00	; 0
    3dc6:	50 e0       	ldi	r21, 0x00	; 0
    3dc8:	60 e2       	ldi	r22, 0x20	; 32
    3dca:	70 e0       	ldi	r23, 0x00	; 0
    3dcc:	80 e5       	ldi	r24, 0x50	; 80
    3dce:	91 e3       	ldi	r25, 0x31	; 49
    3dd0:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3dd4:	1f 91       	pop	r17
    3dd6:	0f 91       	pop	r16
    3dd8:	08 95       	ret

00003dda <__cmpsf2>:
    3dda:	0e 94 2f 1f 	call	0x3e5e	; 0x3e5e <__fp_cmp>
    3dde:	08 f4       	brcc	.+2      	; 0x3de2 <__cmpsf2+0x8>
    3de0:	81 e0       	ldi	r24, 0x01	; 1
    3de2:	08 95       	ret

00003de4 <__floatunsisf>:
    3de4:	e8 94       	clt
    3de6:	09 c0       	rjmp	.+18     	; 0x3dfa <__floatsisf+0x12>

00003de8 <__floatsisf>:
    3de8:	97 fb       	bst	r25, 7
    3dea:	3e f4       	brtc	.+14     	; 0x3dfa <__floatsisf+0x12>
    3dec:	90 95       	com	r25
    3dee:	80 95       	com	r24
    3df0:	70 95       	com	r23
    3df2:	61 95       	neg	r22
    3df4:	7f 4f       	sbci	r23, 0xFF	; 255
    3df6:	8f 4f       	sbci	r24, 0xFF	; 255
    3df8:	9f 4f       	sbci	r25, 0xFF	; 255
    3dfa:	99 23       	and	r25, r25
    3dfc:	a9 f0       	breq	.+42     	; 0x3e28 <__floatsisf+0x40>
    3dfe:	f9 2f       	mov	r31, r25
    3e00:	96 e9       	ldi	r25, 0x96	; 150
    3e02:	bb 27       	eor	r27, r27
    3e04:	93 95       	inc	r25
    3e06:	f6 95       	lsr	r31
    3e08:	87 95       	ror	r24
    3e0a:	77 95       	ror	r23
    3e0c:	67 95       	ror	r22
    3e0e:	b7 95       	ror	r27
    3e10:	f1 11       	cpse	r31, r1
    3e12:	f8 cf       	rjmp	.-16     	; 0x3e04 <__floatsisf+0x1c>
    3e14:	fa f4       	brpl	.+62     	; 0x3e54 <__floatsisf+0x6c>
    3e16:	bb 0f       	add	r27, r27
    3e18:	11 f4       	brne	.+4      	; 0x3e1e <__floatsisf+0x36>
    3e1a:	60 ff       	sbrs	r22, 0
    3e1c:	1b c0       	rjmp	.+54     	; 0x3e54 <__floatsisf+0x6c>
    3e1e:	6f 5f       	subi	r22, 0xFF	; 255
    3e20:	7f 4f       	sbci	r23, 0xFF	; 255
    3e22:	8f 4f       	sbci	r24, 0xFF	; 255
    3e24:	9f 4f       	sbci	r25, 0xFF	; 255
    3e26:	16 c0       	rjmp	.+44     	; 0x3e54 <__floatsisf+0x6c>
    3e28:	88 23       	and	r24, r24
    3e2a:	11 f0       	breq	.+4      	; 0x3e30 <__floatsisf+0x48>
    3e2c:	96 e9       	ldi	r25, 0x96	; 150
    3e2e:	11 c0       	rjmp	.+34     	; 0x3e52 <__floatsisf+0x6a>
    3e30:	77 23       	and	r23, r23
    3e32:	21 f0       	breq	.+8      	; 0x3e3c <__floatsisf+0x54>
    3e34:	9e e8       	ldi	r25, 0x8E	; 142
    3e36:	87 2f       	mov	r24, r23
    3e38:	76 2f       	mov	r23, r22
    3e3a:	05 c0       	rjmp	.+10     	; 0x3e46 <__floatsisf+0x5e>
    3e3c:	66 23       	and	r22, r22
    3e3e:	71 f0       	breq	.+28     	; 0x3e5c <__floatsisf+0x74>
    3e40:	96 e8       	ldi	r25, 0x86	; 134
    3e42:	86 2f       	mov	r24, r22
    3e44:	70 e0       	ldi	r23, 0x00	; 0
    3e46:	60 e0       	ldi	r22, 0x00	; 0
    3e48:	2a f0       	brmi	.+10     	; 0x3e54 <__floatsisf+0x6c>
    3e4a:	9a 95       	dec	r25
    3e4c:	66 0f       	add	r22, r22
    3e4e:	77 1f       	adc	r23, r23
    3e50:	88 1f       	adc	r24, r24
    3e52:	da f7       	brpl	.-10     	; 0x3e4a <__floatsisf+0x62>
    3e54:	88 0f       	add	r24, r24
    3e56:	96 95       	lsr	r25
    3e58:	87 95       	ror	r24
    3e5a:	97 f9       	bld	r25, 7
    3e5c:	08 95       	ret

00003e5e <__fp_cmp>:
    3e5e:	99 0f       	add	r25, r25
    3e60:	00 08       	sbc	r0, r0
    3e62:	55 0f       	add	r21, r21
    3e64:	aa 0b       	sbc	r26, r26
    3e66:	e0 e8       	ldi	r30, 0x80	; 128
    3e68:	fe ef       	ldi	r31, 0xFE	; 254
    3e6a:	16 16       	cp	r1, r22
    3e6c:	17 06       	cpc	r1, r23
    3e6e:	e8 07       	cpc	r30, r24
    3e70:	f9 07       	cpc	r31, r25
    3e72:	c0 f0       	brcs	.+48     	; 0x3ea4 <__fp_cmp+0x46>
    3e74:	12 16       	cp	r1, r18
    3e76:	13 06       	cpc	r1, r19
    3e78:	e4 07       	cpc	r30, r20
    3e7a:	f5 07       	cpc	r31, r21
    3e7c:	98 f0       	brcs	.+38     	; 0x3ea4 <__fp_cmp+0x46>
    3e7e:	62 1b       	sub	r22, r18
    3e80:	73 0b       	sbc	r23, r19
    3e82:	84 0b       	sbc	r24, r20
    3e84:	95 0b       	sbc	r25, r21
    3e86:	39 f4       	brne	.+14     	; 0x3e96 <__fp_cmp+0x38>
    3e88:	0a 26       	eor	r0, r26
    3e8a:	61 f0       	breq	.+24     	; 0x3ea4 <__fp_cmp+0x46>
    3e8c:	23 2b       	or	r18, r19
    3e8e:	24 2b       	or	r18, r20
    3e90:	25 2b       	or	r18, r21
    3e92:	21 f4       	brne	.+8      	; 0x3e9c <__fp_cmp+0x3e>
    3e94:	08 95       	ret
    3e96:	0a 26       	eor	r0, r26
    3e98:	09 f4       	brne	.+2      	; 0x3e9c <__fp_cmp+0x3e>
    3e9a:	a1 40       	sbci	r26, 0x01	; 1
    3e9c:	a6 95       	lsr	r26
    3e9e:	8f ef       	ldi	r24, 0xFF	; 255
    3ea0:	81 1d       	adc	r24, r1
    3ea2:	81 1d       	adc	r24, r1
    3ea4:	08 95       	ret

00003ea6 <__gesf2>:
    3ea6:	0e 94 2f 1f 	call	0x3e5e	; 0x3e5e <__fp_cmp>
    3eaa:	08 f4       	brcc	.+2      	; 0x3eae <__gesf2+0x8>
    3eac:	8f ef       	ldi	r24, 0xFF	; 255
    3eae:	08 95       	ret

00003eb0 <__mulsi3>:
    3eb0:	db 01       	movw	r26, r22
    3eb2:	8f 93       	push	r24
    3eb4:	9f 93       	push	r25
    3eb6:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <__muluhisi3>
    3eba:	bf 91       	pop	r27
    3ebc:	af 91       	pop	r26
    3ebe:	a2 9f       	mul	r26, r18
    3ec0:	80 0d       	add	r24, r0
    3ec2:	91 1d       	adc	r25, r1
    3ec4:	a3 9f       	mul	r26, r19
    3ec6:	90 0d       	add	r25, r0
    3ec8:	b2 9f       	mul	r27, r18
    3eca:	90 0d       	add	r25, r0
    3ecc:	11 24       	eor	r1, r1
    3ece:	08 95       	ret

00003ed0 <__divmodhi4>:
    3ed0:	97 fb       	bst	r25, 7
    3ed2:	07 2e       	mov	r0, r23
    3ed4:	16 f4       	brtc	.+4      	; 0x3eda <__divmodhi4+0xa>
    3ed6:	00 94       	com	r0
    3ed8:	07 d0       	rcall	.+14     	; 0x3ee8 <__divmodhi4_neg1>
    3eda:	77 fd       	sbrc	r23, 7
    3edc:	09 d0       	rcall	.+18     	; 0x3ef0 <__divmodhi4_neg2>
    3ede:	0e 94 f7 1f 	call	0x3fee	; 0x3fee <__udivmodhi4>
    3ee2:	07 fc       	sbrc	r0, 7
    3ee4:	05 d0       	rcall	.+10     	; 0x3ef0 <__divmodhi4_neg2>
    3ee6:	3e f4       	brtc	.+14     	; 0x3ef6 <__divmodhi4_exit>

00003ee8 <__divmodhi4_neg1>:
    3ee8:	90 95       	com	r25
    3eea:	81 95       	neg	r24
    3eec:	9f 4f       	sbci	r25, 0xFF	; 255
    3eee:	08 95       	ret

00003ef0 <__divmodhi4_neg2>:
    3ef0:	70 95       	com	r23
    3ef2:	61 95       	neg	r22
    3ef4:	7f 4f       	sbci	r23, 0xFF	; 255

00003ef6 <__divmodhi4_exit>:
    3ef6:	08 95       	ret

00003ef8 <__udivmodsi4>:
    3ef8:	a1 e2       	ldi	r26, 0x21	; 33
    3efa:	1a 2e       	mov	r1, r26
    3efc:	aa 1b       	sub	r26, r26
    3efe:	bb 1b       	sub	r27, r27
    3f00:	fd 01       	movw	r30, r26
    3f02:	0d c0       	rjmp	.+26     	; 0x3f1e <__udivmodsi4_ep>

00003f04 <__udivmodsi4_loop>:
    3f04:	aa 1f       	adc	r26, r26
    3f06:	bb 1f       	adc	r27, r27
    3f08:	ee 1f       	adc	r30, r30
    3f0a:	ff 1f       	adc	r31, r31
    3f0c:	a2 17       	cp	r26, r18
    3f0e:	b3 07       	cpc	r27, r19
    3f10:	e4 07       	cpc	r30, r20
    3f12:	f5 07       	cpc	r31, r21
    3f14:	20 f0       	brcs	.+8      	; 0x3f1e <__udivmodsi4_ep>
    3f16:	a2 1b       	sub	r26, r18
    3f18:	b3 0b       	sbc	r27, r19
    3f1a:	e4 0b       	sbc	r30, r20
    3f1c:	f5 0b       	sbc	r31, r21

00003f1e <__udivmodsi4_ep>:
    3f1e:	66 1f       	adc	r22, r22
    3f20:	77 1f       	adc	r23, r23
    3f22:	88 1f       	adc	r24, r24
    3f24:	99 1f       	adc	r25, r25
    3f26:	1a 94       	dec	r1
    3f28:	69 f7       	brne	.-38     	; 0x3f04 <__udivmodsi4_loop>
    3f2a:	60 95       	com	r22
    3f2c:	70 95       	com	r23
    3f2e:	80 95       	com	r24
    3f30:	90 95       	com	r25
    3f32:	9b 01       	movw	r18, r22
    3f34:	ac 01       	movw	r20, r24
    3f36:	bd 01       	movw	r22, r26
    3f38:	cf 01       	movw	r24, r30
    3f3a:	08 95       	ret

00003f3c <__divmodsi4>:
    3f3c:	05 2e       	mov	r0, r21
    3f3e:	97 fb       	bst	r25, 7
    3f40:	1e f4       	brtc	.+6      	; 0x3f48 <__divmodsi4+0xc>
    3f42:	00 94       	com	r0
    3f44:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <__negsi2>
    3f48:	57 fd       	sbrc	r21, 7
    3f4a:	07 d0       	rcall	.+14     	; 0x3f5a <__divmodsi4_neg2>
    3f4c:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__udivmodsi4>
    3f50:	07 fc       	sbrc	r0, 7
    3f52:	03 d0       	rcall	.+6      	; 0x3f5a <__divmodsi4_neg2>
    3f54:	4e f4       	brtc	.+18     	; 0x3f68 <__divmodsi4_exit>
    3f56:	0c 94 b5 1f 	jmp	0x3f6a	; 0x3f6a <__negsi2>

00003f5a <__divmodsi4_neg2>:
    3f5a:	50 95       	com	r21
    3f5c:	40 95       	com	r20
    3f5e:	30 95       	com	r19
    3f60:	21 95       	neg	r18
    3f62:	3f 4f       	sbci	r19, 0xFF	; 255
    3f64:	4f 4f       	sbci	r20, 0xFF	; 255
    3f66:	5f 4f       	sbci	r21, 0xFF	; 255

00003f68 <__divmodsi4_exit>:
    3f68:	08 95       	ret

00003f6a <__negsi2>:
    3f6a:	90 95       	com	r25
    3f6c:	80 95       	com	r24
    3f6e:	70 95       	com	r23
    3f70:	61 95       	neg	r22
    3f72:	7f 4f       	sbci	r23, 0xFF	; 255
    3f74:	8f 4f       	sbci	r24, 0xFF	; 255
    3f76:	9f 4f       	sbci	r25, 0xFF	; 255
    3f78:	08 95       	ret

00003f7a <__tablejump2__>:
    3f7a:	ee 0f       	add	r30, r30
    3f7c:	ff 1f       	adc	r31, r31
    3f7e:	88 1f       	adc	r24, r24
    3f80:	8b bf       	out	0x3b, r24	; 59
    3f82:	07 90       	elpm	r0, Z+
    3f84:	f6 91       	elpm	r31, Z
    3f86:	e0 2d       	mov	r30, r0
    3f88:	1b be       	out	0x3b, r1	; 59
    3f8a:	19 94       	eijmp

00003f8c <__mulhisi3>:
    3f8c:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <__umulhisi3>
    3f90:	33 23       	and	r19, r19
    3f92:	12 f4       	brpl	.+4      	; 0x3f98 <__mulhisi3+0xc>
    3f94:	8a 1b       	sub	r24, r26
    3f96:	9b 0b       	sbc	r25, r27
    3f98:	0c 94 df 1f 	jmp	0x3fbe	; 0x3fbe <__usmulhisi3_tail>

00003f9c <__umulhisi3>:
    3f9c:	a2 9f       	mul	r26, r18
    3f9e:	b0 01       	movw	r22, r0
    3fa0:	b3 9f       	mul	r27, r19
    3fa2:	c0 01       	movw	r24, r0
    3fa4:	a3 9f       	mul	r26, r19
    3fa6:	70 0d       	add	r23, r0
    3fa8:	81 1d       	adc	r24, r1
    3faa:	11 24       	eor	r1, r1
    3fac:	91 1d       	adc	r25, r1
    3fae:	b2 9f       	mul	r27, r18
    3fb0:	70 0d       	add	r23, r0
    3fb2:	81 1d       	adc	r24, r1
    3fb4:	11 24       	eor	r1, r1
    3fb6:	91 1d       	adc	r25, r1
    3fb8:	08 95       	ret

00003fba <__usmulhisi3>:
    3fba:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <__umulhisi3>

00003fbe <__usmulhisi3_tail>:
    3fbe:	b7 ff       	sbrs	r27, 7
    3fc0:	08 95       	ret
    3fc2:	82 1b       	sub	r24, r18
    3fc4:	93 0b       	sbc	r25, r19
    3fc6:	08 95       	ret

00003fc8 <__muluhisi3>:
    3fc8:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <__umulhisi3>
    3fcc:	a5 9f       	mul	r26, r21
    3fce:	90 0d       	add	r25, r0
    3fd0:	b4 9f       	mul	r27, r20
    3fd2:	90 0d       	add	r25, r0
    3fd4:	a4 9f       	mul	r26, r20
    3fd6:	80 0d       	add	r24, r0
    3fd8:	91 1d       	adc	r25, r1
    3fda:	11 24       	eor	r1, r1
    3fdc:	08 95       	ret

00003fde <__mulshisi3>:
    3fde:	b7 ff       	sbrs	r27, 7
    3fe0:	0c 94 e4 1f 	jmp	0x3fc8	; 0x3fc8 <__muluhisi3>

00003fe4 <__mulohisi3>:
    3fe4:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <__muluhisi3>
    3fe8:	82 1b       	sub	r24, r18
    3fea:	93 0b       	sbc	r25, r19
    3fec:	08 95       	ret

00003fee <__udivmodhi4>:
    3fee:	aa 1b       	sub	r26, r26
    3ff0:	bb 1b       	sub	r27, r27
    3ff2:	51 e1       	ldi	r21, 0x11	; 17
    3ff4:	07 c0       	rjmp	.+14     	; 0x4004 <__udivmodhi4_ep>

00003ff6 <__udivmodhi4_loop>:
    3ff6:	aa 1f       	adc	r26, r26
    3ff8:	bb 1f       	adc	r27, r27
    3ffa:	a6 17       	cp	r26, r22
    3ffc:	b7 07       	cpc	r27, r23
    3ffe:	10 f0       	brcs	.+4      	; 0x4004 <__udivmodhi4_ep>
    4000:	a6 1b       	sub	r26, r22
    4002:	b7 0b       	sbc	r27, r23

00004004 <__udivmodhi4_ep>:
    4004:	88 1f       	adc	r24, r24
    4006:	99 1f       	adc	r25, r25
    4008:	5a 95       	dec	r21
    400a:	a9 f7       	brne	.-22     	; 0x3ff6 <__udivmodhi4_loop>
    400c:	80 95       	com	r24
    400e:	90 95       	com	r25
    4010:	bc 01       	movw	r22, r24
    4012:	cd 01       	movw	r24, r26
    4014:	08 95       	ret

00004016 <memcpy>:
    4016:	fb 01       	movw	r30, r22
    4018:	dc 01       	movw	r26, r24
    401a:	02 c0       	rjmp	.+4      	; 0x4020 <memcpy+0xa>
    401c:	01 90       	ld	r0, Z+
    401e:	0d 92       	st	X+, r0
    4020:	41 50       	subi	r20, 0x01	; 1
    4022:	50 40       	sbci	r21, 0x00	; 0
    4024:	d8 f7       	brcc	.-10     	; 0x401c <memcpy+0x6>
    4026:	08 95       	ret

00004028 <memset>:
    4028:	dc 01       	movw	r26, r24
    402a:	01 c0       	rjmp	.+2      	; 0x402e <memset+0x6>
    402c:	6d 93       	st	X+, r22
    402e:	41 50       	subi	r20, 0x01	; 1
    4030:	50 40       	sbci	r21, 0x00	; 0
    4032:	e0 f7       	brcc	.-8      	; 0x402c <memset+0x4>
    4034:	08 95       	ret

00004036 <strncpy>:
    4036:	fb 01       	movw	r30, r22
    4038:	dc 01       	movw	r26, r24
    403a:	41 50       	subi	r20, 0x01	; 1
    403c:	50 40       	sbci	r21, 0x00	; 0
    403e:	48 f0       	brcs	.+18     	; 0x4052 <strncpy+0x1c>
    4040:	01 90       	ld	r0, Z+
    4042:	0d 92       	st	X+, r0
    4044:	00 20       	and	r0, r0
    4046:	c9 f7       	brne	.-14     	; 0x403a <strncpy+0x4>
    4048:	01 c0       	rjmp	.+2      	; 0x404c <strncpy+0x16>
    404a:	1d 92       	st	X+, r1
    404c:	41 50       	subi	r20, 0x01	; 1
    404e:	50 40       	sbci	r21, 0x00	; 0
    4050:	e0 f7       	brcc	.-8      	; 0x404a <strncpy+0x14>
    4052:	08 95       	ret

00004054 <__itoa_ncheck>:
    4054:	bb 27       	eor	r27, r27
    4056:	4a 30       	cpi	r20, 0x0A	; 10
    4058:	31 f4       	brne	.+12     	; 0x4066 <__itoa_ncheck+0x12>
    405a:	99 23       	and	r25, r25
    405c:	22 f4       	brpl	.+8      	; 0x4066 <__itoa_ncheck+0x12>
    405e:	bd e2       	ldi	r27, 0x2D	; 45
    4060:	90 95       	com	r25
    4062:	81 95       	neg	r24
    4064:	9f 4f       	sbci	r25, 0xFF	; 255
    4066:	0c 94 6e 20 	jmp	0x40dc	; 0x40dc <__utoa_common>

0000406a <ultoa>:
    406a:	25 32       	cpi	r18, 0x25	; 37
    406c:	31 05       	cpc	r19, r1
    406e:	20 f4       	brcc	.+8      	; 0x4078 <ultoa+0xe>
    4070:	22 30       	cpi	r18, 0x02	; 2
    4072:	10 f0       	brcs	.+4      	; 0x4078 <ultoa+0xe>
    4074:	0c 94 40 20 	jmp	0x4080	; 0x4080 <__ultoa_ncheck>
    4078:	fa 01       	movw	r30, r20
    407a:	10 82       	st	Z, r1
    407c:	ca 01       	movw	r24, r20
    407e:	08 95       	ret

00004080 <__ultoa_ncheck>:
    4080:	bb 27       	eor	r27, r27

00004082 <__ultoa_common>:
    4082:	fa 01       	movw	r30, r20
    4084:	a6 2f       	mov	r26, r22
    4086:	62 17       	cp	r22, r18
    4088:	71 05       	cpc	r23, r1
    408a:	81 05       	cpc	r24, r1
    408c:	91 05       	cpc	r25, r1
    408e:	33 0b       	sbc	r19, r19
    4090:	30 fb       	bst	r19, 0
    4092:	66 f0       	brts	.+24     	; 0x40ac <__ultoa_common+0x2a>
    4094:	aa 27       	eor	r26, r26
    4096:	66 0f       	add	r22, r22
    4098:	77 1f       	adc	r23, r23
    409a:	88 1f       	adc	r24, r24
    409c:	99 1f       	adc	r25, r25
    409e:	aa 1f       	adc	r26, r26
    40a0:	a2 17       	cp	r26, r18
    40a2:	10 f0       	brcs	.+4      	; 0x40a8 <__ultoa_common+0x26>
    40a4:	a2 1b       	sub	r26, r18
    40a6:	63 95       	inc	r22
    40a8:	38 50       	subi	r19, 0x08	; 8
    40aa:	a9 f7       	brne	.-22     	; 0x4096 <__ultoa_common+0x14>
    40ac:	a0 5d       	subi	r26, 0xD0	; 208
    40ae:	aa 33       	cpi	r26, 0x3A	; 58
    40b0:	08 f0       	brcs	.+2      	; 0x40b4 <__ultoa_common+0x32>
    40b2:	a9 5d       	subi	r26, 0xD9	; 217
    40b4:	a1 93       	st	Z+, r26
    40b6:	36 f7       	brtc	.-52     	; 0x4084 <__ultoa_common+0x2>
    40b8:	b1 11       	cpse	r27, r1
    40ba:	b1 93       	st	Z+, r27
    40bc:	10 82       	st	Z, r1
    40be:	ca 01       	movw	r24, r20
    40c0:	0c 94 87 20 	jmp	0x410e	; 0x410e <strrev>

000040c4 <utoa>:
    40c4:	45 32       	cpi	r20, 0x25	; 37
    40c6:	51 05       	cpc	r21, r1
    40c8:	20 f4       	brcc	.+8      	; 0x40d2 <utoa+0xe>
    40ca:	42 30       	cpi	r20, 0x02	; 2
    40cc:	10 f0       	brcs	.+4      	; 0x40d2 <utoa+0xe>
    40ce:	0c 94 6d 20 	jmp	0x40da	; 0x40da <__utoa_ncheck>
    40d2:	fb 01       	movw	r30, r22
    40d4:	10 82       	st	Z, r1
    40d6:	cb 01       	movw	r24, r22
    40d8:	08 95       	ret

000040da <__utoa_ncheck>:
    40da:	bb 27       	eor	r27, r27

000040dc <__utoa_common>:
    40dc:	fb 01       	movw	r30, r22
    40de:	55 27       	eor	r21, r21
    40e0:	aa 27       	eor	r26, r26
    40e2:	88 0f       	add	r24, r24
    40e4:	99 1f       	adc	r25, r25
    40e6:	aa 1f       	adc	r26, r26
    40e8:	a4 17       	cp	r26, r20
    40ea:	10 f0       	brcs	.+4      	; 0x40f0 <__utoa_common+0x14>
    40ec:	a4 1b       	sub	r26, r20
    40ee:	83 95       	inc	r24
    40f0:	50 51       	subi	r21, 0x10	; 16
    40f2:	b9 f7       	brne	.-18     	; 0x40e2 <__utoa_common+0x6>
    40f4:	a0 5d       	subi	r26, 0xD0	; 208
    40f6:	aa 33       	cpi	r26, 0x3A	; 58
    40f8:	08 f0       	brcs	.+2      	; 0x40fc <__utoa_common+0x20>
    40fa:	a9 5d       	subi	r26, 0xD9	; 217
    40fc:	a1 93       	st	Z+, r26
    40fe:	00 97       	sbiw	r24, 0x00	; 0
    4100:	79 f7       	brne	.-34     	; 0x40e0 <__utoa_common+0x4>
    4102:	b1 11       	cpse	r27, r1
    4104:	b1 93       	st	Z+, r27
    4106:	11 92       	st	Z+, r1
    4108:	cb 01       	movw	r24, r22
    410a:	0c 94 87 20 	jmp	0x410e	; 0x410e <strrev>

0000410e <strrev>:
    410e:	dc 01       	movw	r26, r24
    4110:	fc 01       	movw	r30, r24
    4112:	67 2f       	mov	r22, r23
    4114:	71 91       	ld	r23, Z+
    4116:	77 23       	and	r23, r23
    4118:	e1 f7       	brne	.-8      	; 0x4112 <strrev+0x4>
    411a:	32 97       	sbiw	r30, 0x02	; 2
    411c:	04 c0       	rjmp	.+8      	; 0x4126 <strrev+0x18>
    411e:	7c 91       	ld	r23, X
    4120:	6d 93       	st	X+, r22
    4122:	70 83       	st	Z, r23
    4124:	62 91       	ld	r22, -Z
    4126:	ae 17       	cp	r26, r30
    4128:	bf 07       	cpc	r27, r31
    412a:	c8 f3       	brcs	.-14     	; 0x411e <strrev+0x10>
    412c:	08 95       	ret

0000412e <_exit>:
    412e:	f8 94       	cli

00004130 <__stop_program>:
    4130:	ff cf       	rjmp	.-2      	; 0x4130 <__stop_program>
