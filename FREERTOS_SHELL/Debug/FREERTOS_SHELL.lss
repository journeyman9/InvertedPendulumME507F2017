
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000407c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b0  00802000  0000407c  00004110  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020b0  008020b0  000041c0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000041c0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000041f0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006a0  00000000  00000000  00004230  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000119f7  00000000  00000000  000048d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006261  00000000  00000000  000162c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000517b  00000000  00000000  0001c528  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001244  00000000  00000000  000216a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006134  00000000  00000000  000228e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005b5d  00000000  00000000  00028a1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000598  00000000  00000000  0002e579  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a7 02 	jmp	0x54e	; 0x54e <__ctors_end>
       4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      10:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      14:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      18:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      1c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      20:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      24:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      28:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      2c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      30:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      34:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      38:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      3c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      40:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      44:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      4c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      50:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      54:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      58:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      5c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      60:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      64:	0c 94 12 1c 	jmp	0x3824	; 0x3824 <__vector_25>
      68:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      6c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      70:	0c 94 70 1c 	jmp	0x38e0	; 0x38e0 <__vector_28>
      74:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      78:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      7c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      80:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      84:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      88:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      8c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      90:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      94:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      98:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      9c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c4:	0c 94 2c 0c 	jmp	0x1858	; 0x1858 <__vector_49>
      c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e8:	0c 94 8a 1d 	jmp	0x3b14	; 0x3b14 <__vector_58>
      ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      fc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     100:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     104:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     108:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     10c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     110:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     114:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     118:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     11c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     120:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     124:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     128:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     12c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     130:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     134:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     138:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     13c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     140:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     144:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     148:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     14c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     150:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     154:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     158:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     15c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     160:	0c 94 ce 1c 	jmp	0x399c	; 0x399c <__vector_88>
     164:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     168:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     16c:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__vector_91>
     170:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     174:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     178:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     17c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     180:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     184:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     188:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     18c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     190:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     194:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     198:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     19c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1fc:	fe 19       	sub	r31, r14
     1fe:	01 1a       	sub	r0, r17
     200:	04 1a       	sub	r0, r20
     202:	07 1a       	sub	r0, r23
     204:	0a 1a       	sub	r0, r26
     206:	0d 1a       	sub	r0, r29
     208:	0f 1a       	sub	r0, r31
     20a:	20 1a       	sub	r2, r16
     20c:	28 1a       	sub	r2, r24
     20e:	32 1a       	sub	r3, r18
     210:	30 1a       	sub	r3, r16

00000212 <__trampolines_start>:
     212:	0c 94 a9 19 	jmp	0x3352	; 0x3352 <_ZN8emstream12clear_screenEv>
     216:	0c 94 08 08 	jmp	0x1010	; 0x1010 <_ZN9task_user3runEv>
     21a:	0c 94 df 15 	jmp	0x2bbe	; 0x2bbe <_ZN8frt_task12print_statusER8emstream>
     21e:	0c 94 a8 19 	jmp	0x3350	; 0x3350 <_ZN8emstream12transmit_nowEv>
     222:	0c 94 a3 19 	jmp	0x3346	; 0x3346 <_ZN8emstream7getcharEv>
     226:	0c 94 2b 04 	jmp	0x856	; 0x856 <_ZN5Motor3runEv>
     22a:	0c 94 28 1a 	jmp	0x3450	; 0x3450 <_ZN8emstreamlsE15ser_manipulator+0x72>
     22e:	0c 94 8c 1e 	jmp	0x3d18	; 0x3d18 <_GLOBAL__sub_I_counter>
     232:	0c 94 c6 03 	jmp	0x78c	; 0x78c <_ZN13LimitSwitches3runEv>
     236:	0c 94 04 1a 	jmp	0x3408	; 0x3408 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     23a:	0c 94 29 17 	jmp	0x2e52	; 0x2e52 <_ZN14frt_text_queue7getcharEv>
     23e:	0c 94 01 1a 	jmp	0x3402	; 0x3402 <_ZN8emstreamlsE15ser_manipulator+0x24>
     242:	0c 94 76 1b 	jmp	0x36ec	; 0x36ec <_ZN5rs23214check_for_charEv>
     246:	0c 94 6d 03 	jmp	0x6da	; 0x6da <_ZN15EncoderPendulum3runEv>
     24a:	0c 94 a4 02 	jmp	0x548	; 0x548 <_call_static_run_method>
     24e:	0c 94 0a 19 	jmp	0x3214	; 0x3214 <__cxa_pure_virtual>
     252:	0c 94 20 1a 	jmp	0x3440	; 0x3440 <_ZN8emstreamlsE15ser_manipulator+0x62>
     256:	0c 94 fe 19 	jmp	0x33fc	; 0x33fc <_ZN8emstreamlsE15ser_manipulator+0x1e>
     25a:	0c 94 47 17 	jmp	0x2e8e	; 0x2e8e <_ZN14frt_text_queue14check_for_charEv>
     25e:	0c 94 0f 1a 	jmp	0x341e	; 0x341e <_ZN8emstreamlsE15ser_manipulator+0x40>
     262:	0c 94 52 17 	jmp	0x2ea4	; 0x2ea4 <_ZN14frt_text_queue7putcharEc>
     266:	0c 94 b0 0e 	jmp	0x1d60	; 0x1d60 <prvIdleTask>
     26a:	0c 94 32 1a 	jmp	0x3464	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
     26e:	0c 94 df 02 	jmp	0x5be	; 0x5be <_ZN12EncoderMotor3runEv>
     272:	0c 94 89 1b 	jmp	0x3712	; 0x3712 <_ZN5rs23212clear_screenEv>
     276:	0c 94 30 1a 	jmp	0x3460	; 0x3460 <_ZN8emstreamlsE15ser_manipulator+0x82>
     27a:	0c 94 07 1a 	jmp	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator+0x30>
     27e:	0c 94 0d 1a 	jmp	0x341a	; 0x341a <_ZN8emstreamlsE15ser_manipulator+0x3c>
     282:	0c 94 a6 19 	jmp	0x334c	; 0x334c <_ZN8emstream14check_for_charEv>
     286:	0c 94 2c 1b 	jmp	0x3658	; 0x3658 <_ZN5rs2327putcharEc>
     28a:	0c 94 a1 19 	jmp	0x3342	; 0x3342 <_ZN8emstream13ready_to_sendEv>
     28e:	0c 94 0a 1a 	jmp	0x3414	; 0x3414 <_ZN8emstreamlsE15ser_manipulator+0x36>
     292:	0c 94 50 1b 	jmp	0x36a0	; 0x36a0 <_ZN5rs2327getcharEv>

00000296 <__trampolines_end>:
     296:	2c 20       	and	r2, r12
     298:	54 43       	sbci	r21, 0x34	; 52
     29a:	43 30       	cpi	r20, 0x03	; 3
     29c:	43 43       	sbci	r20, 0x33	; 51
     29e:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a1 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a1:	2f 00                                               /.

000002a3 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b1 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b1:	54 69 6d 65 3a 20 00                                Time: .

000002b8 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b8:	44 65 63 20 20 36 20 32 30 31 37 00                 Dec  6 2017.

000002c4 <_ZZN9task_user11show_statusEvE3__c>:
     2c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     302:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000030d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     30d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     31d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34b:	6d 61 74 69 6f 6e 00                                mation.

00000352 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     352:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     362:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000373 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     373:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     383:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3a7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3b7:	68 65 20 41 56 52 00                                he AVR.

000003be <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3be:	20 68 65 6c 70 00                                    help.

000003c4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e3:	1b 5b 33 30 6d 00                                   .[30m.

000003e9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e9:	1b 5b 34 36 6d 00                                   .[46m.

000003ef <_ZZN9task_user3runEvE3__c_3>:
     3ef:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ff:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000040c <_ZZN9task_user3runEvE3__c_2>:
     40c:	3a 57 54 46 3f 00                                   :WTF?.

00000412 <_ZZN9task_user3runEvE3__c_1>:
     412:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     422:	65 00                                               e.

00000424 <_ZZN9task_user3runEvE3__c_0>:
     424:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000432 <_ZZN9task_user3runEvE3__c>:
     432:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     442:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000450 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     450:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045a <_ZZN8frt_task15emergency_resetEvE3__c>:
     45a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000469 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     469:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     479:	61 73 6b 20 00                                      ask .

0000047e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     47e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000048c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     48c:	20 63 72 65 61 74 65 64 00                           created.

00000495 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     495:	54 61 73 6b 20 00                                   Task .

0000049b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49b:	1b 5b 32 32 6d 00                                   .[22m.

000004a1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a1:	54 61 73 6b 3a 20 00                                Task: .

000004a8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a8:	1b 5b 31 6d 00                                      .[1m.

000004ad <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4ad:	1b 5b 32 32 6d 00                                   .[22m.

000004b3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004be <_ZZ17print_task_stacksP8emstreamE3__c>:
     4be:	1b 5b 31 6d 00                                      .[1m.

000004c3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c3:	09 09 00                                            ...

000004c6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4c6:	2f 00                                               /.

000004c8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d3:	09 2d 2d 2d 2d 00                                   .----.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004f6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4f6:	09 52 75 6e 73 00                                   .Runs.

000004fc <_ZZ15print_task_listP8emstreamE3__c_2>:
     4fc:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000508 <_ZZ15print_task_listP8emstreamE3__c_1>:
     508:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000519 <_ZZ15print_task_listP8emstreamE3__c_0>:
     519:	09 53 74 61 63 6b 00                                .Stack.

00000520 <_ZZ15print_task_listP8emstreamE3__c>:
     520:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52b:	09 00                                               ..

0000052d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     52d:	09 00                                               ..

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     52f:	2f 00                                               /.

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     533:	09 00                                               ..

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53b:	1b 5b 31 6d 00                                      .[1m.

00000540 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     545:	20 20 00                                              .

00000548 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     548:	0e 94 77 14 	call	0x28ee	; 0x28ee <_ZN8frt_task22_call_users_run_methodEPS_>

0000054c <__ctors_start>:
     54c:	8c 1e       	adc	r8, r28

0000054e <__ctors_end>:
     54e:	11 24       	eor	r1, r1
     550:	1f be       	out	0x3f, r1	; 63
     552:	cf ef       	ldi	r28, 0xFF	; 255
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df e3       	ldi	r29, 0x3F	; 63
     558:	de bf       	out	0x3e, r29	; 62
     55a:	00 e0       	ldi	r16, 0x00	; 0
     55c:	0c bf       	out	0x3c, r16	; 60
     55e:	18 be       	out	0x38, r1	; 56
     560:	19 be       	out	0x39, r1	; 57
     562:	1a be       	out	0x3a, r1	; 58
     564:	1b be       	out	0x3b, r1	; 59

00000566 <__do_copy_data>:
     566:	10 e2       	ldi	r17, 0x20	; 32
     568:	a0 e0       	ldi	r26, 0x00	; 0
     56a:	b0 e2       	ldi	r27, 0x20	; 32
     56c:	ec e7       	ldi	r30, 0x7C	; 124
     56e:	f0 e4       	ldi	r31, 0x40	; 64
     570:	00 e0       	ldi	r16, 0x00	; 0
     572:	0b bf       	out	0x3b, r16	; 59
     574:	02 c0       	rjmp	.+4      	; 0x57a <__do_copy_data+0x14>
     576:	07 90       	elpm	r0, Z+
     578:	0d 92       	st	X+, r0
     57a:	a0 3b       	cpi	r26, 0xB0	; 176
     57c:	b1 07       	cpc	r27, r17
     57e:	d9 f7       	brne	.-10     	; 0x576 <__do_copy_data+0x10>
     580:	1b be       	out	0x3b, r1	; 59

00000582 <__do_clear_bss>:
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	a0 eb       	ldi	r26, 0xB0	; 176
     586:	b0 e2       	ldi	r27, 0x20	; 32
     588:	01 c0       	rjmp	.+2      	; 0x58c <.do_clear_bss_start>

0000058a <.do_clear_bss_loop>:
     58a:	1d 92       	st	X+, r1

0000058c <.do_clear_bss_start>:
     58c:	a6 35       	cpi	r26, 0x56	; 86
     58e:	b2 07       	cpc	r27, r18
     590:	e1 f7       	brne	.-8      	; 0x58a <.do_clear_bss_loop>

00000592 <__do_global_ctors>:
     592:	12 e0       	ldi	r17, 0x02	; 2
     594:	c7 ea       	ldi	r28, 0xA7	; 167
     596:	d2 e0       	ldi	r29, 0x02	; 2
     598:	00 e0       	ldi	r16, 0x00	; 0
     59a:	06 c0       	rjmp	.+12     	; 0x5a8 <__do_global_ctors+0x16>
     59c:	21 97       	sbiw	r28, 0x01	; 1
     59e:	01 09       	sbc	r16, r1
     5a0:	80 2f       	mov	r24, r16
     5a2:	fe 01       	movw	r30, r28
     5a4:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <__tablejump2__>
     5a8:	c6 3a       	cpi	r28, 0xA6	; 166
     5aa:	d1 07       	cpc	r29, r17
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 07       	cpc	r16, r24
     5b0:	a9 f7       	brne	.-22     	; 0x59c <__do_global_ctors+0xa>
     5b2:	0e 94 fd 1d 	call	0x3bfa	; 0x3bfa <main>
     5b6:	0c 94 3c 20 	jmp	0x4078	; 0x4078 <_exit>

000005ba <__bad_interrupt>:
     5ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005be <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN12EncoderMotor3runEv+0x6>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5cc:	0e 94 4f 10 	call	0x209e	; 0x209e <xTaskGetTickCount>
     5d0:	69 83       	std	Y+1, r22	; 0x01
     5d2:	7a 83       	std	Y+2, r23	; 0x02
     5d4:	8b 83       	std	Y+3, r24	; 0x03
     5d6:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5d8:	e0 e8       	ldi	r30, 0x80	; 128
     5da:	f6 e0       	ldi	r31, 0x06	; 6
     5dc:	8c e0       	ldi	r24, 0x0C	; 12
     5de:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e0:	82 89       	ldd	r24, Z+18	; 0x12
     5e2:	83 60       	ori	r24, 0x03	; 3
     5e4:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5e6:	83 89       	ldd	r24, Z+19	; 0x13
     5e8:	83 60       	ori	r24, 0x03	; 3
     5ea:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	82 e7       	ldi	r24, 0x72	; 114
     5f2:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f4:	89 e0       	ldi	r24, 0x09	; 9
     5f6:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f8:	e0 e0       	ldi	r30, 0x00	; 0
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	88 e6       	ldi	r24, 0x68	; 104
     5fe:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	86 a3       	std	Z+38, r24	; 0x26
     606:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     60c:	0f 2e       	mov	r0, r31
     60e:	a1 2c       	mov	r10, r1
     610:	f9 e0       	ldi	r31, 0x09	; 9
     612:	bf 2e       	mov	r11, r31
     614:	f0 2d       	mov	r31, r0
     616:	f5 01       	movw	r30, r10
     618:	00 a1       	ldd	r16, Z+32	; 0x20
     61a:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     61c:	0f b6       	in	r0, 0x3f	; 63
     61e:	f8 94       	cli
     620:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     622:	0f 90       	pop	r0
     624:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     626:	0f b6       	in	r0, 0x3f	; 63
     628:	f8 94       	cli
     62a:	0f 92       	push	r0
			the_data = new_data;
     62c:	c8 01       	movw	r24, r16
     62e:	01 2e       	mov	r0, r17
     630:	00 0c       	add	r0, r0
     632:	aa 0b       	sbc	r26, r26
     634:	bb 0b       	sbc	r27, r27
     636:	ac 01       	movw	r20, r24
     638:	bd 01       	movw	r22, r26
     63a:	44 0f       	add	r20, r20
     63c:	55 1f       	adc	r21, r21
     63e:	66 1f       	adc	r22, r22
     640:	77 1f       	adc	r23, r23
     642:	3a 01       	movw	r6, r20
     644:	4b 01       	movw	r8, r22
     646:	68 0e       	add	r6, r24
     648:	79 1e       	adc	r7, r25
     64a:	8a 1e       	adc	r8, r26
     64c:	9b 1e       	adc	r9, r27
     64e:	c4 01       	movw	r24, r8
     650:	b3 01       	movw	r22, r6
     652:	24 e6       	ldi	r18, 0x64	; 100
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	40 e0       	ldi	r20, 0x00	; 0
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <__divmodsi4>
     65e:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <linear_offset>
     662:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <linear_offset+0x1>
     666:	28 1b       	sub	r18, r24
     668:	39 0b       	sbc	r19, r25
     66a:	20 93 42 31 	sts	0x3142, r18	; 0x803142 <linear_position>
     66e:	30 93 43 31 	sts	0x3143, r19	; 0x803143 <linear_position+0x1>
			portEXIT_CRITICAL ();
     672:	0f 90       	pop	r0
     674:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     676:	0f b6       	in	r0, 0x3f	; 63
     678:	f8 94       	cli
     67a:	0f 92       	push	r0
			the_data = new_data;
     67c:	c8 01       	movw	r24, r16
     67e:	8c 19       	sub	r24, r12
     680:	9d 09       	sbc	r25, r13
     682:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <thdMotor>
     686:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     68a:	0f 90       	pop	r0
     68c:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     68e:	f7 01       	movw	r30, r14
     690:	86 85       	ldd	r24, Z+14	; 0x0e
     692:	97 85       	ldd	r25, Z+15	; 0x0f
     694:	a0 89       	ldd	r26, Z+16	; 0x10
     696:	b1 89       	ldd	r27, Z+17	; 0x11
     698:	01 96       	adiw	r24, 0x01	; 1
     69a:	a1 1d       	adc	r26, r1
     69c:	b1 1d       	adc	r27, r1
     69e:	86 87       	std	Z+14, r24	; 0x0e
     6a0:	97 87       	std	Z+15, r25	; 0x0f
     6a2:	a0 8b       	std	Z+16, r26	; 0x10
     6a4:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     6a6:	41 e0       	ldi	r20, 0x01	; 1
     6a8:	50 e0       	ldi	r21, 0x00	; 0
     6aa:	60 e0       	ldi	r22, 0x00	; 0
     6ac:	70 e0       	ldi	r23, 0x00	; 0
     6ae:	ce 01       	movw	r24, r28
     6b0:	01 96       	adiw	r24, 0x01	; 1
     6b2:	0e 94 ed 11 	call	0x23da	; 0x23da <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6b6:	68 01       	movw	r12, r16
     6b8:	ae cf       	rjmp	.-164    	; 0x616 <_ZN12EncoderMotor3runEv+0x58>

000006ba <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     6ba:	0f 93       	push	r16
     6bc:	1f 93       	push	r17
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6c4:	0e 94 8a 14 	call	0x2914	; 0x2914 <_ZN8frt_taskC1EPKchjP8emstream>
     6c8:	8a e0       	ldi	r24, 0x0A	; 10
     6ca:	90 e2       	ldi	r25, 0x20	; 32
     6cc:	88 83       	st	Y, r24
     6ce:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	08 95       	ret

000006da <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	00 d0       	rcall	.+0      	; 0x6e0 <_ZN15EncoderPendulum3runEv+0x6>
     6e0:	1f 92       	push	r1
     6e2:	cd b7       	in	r28, 0x3d	; 61
     6e4:	de b7       	in	r29, 0x3e	; 62
     6e6:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6e8:	0e 94 4f 10 	call	0x209e	; 0x209e <xTaskGetTickCount>
     6ec:	69 83       	std	Y+1, r22	; 0x01
     6ee:	7a 83       	std	Y+2, r23	; 0x02
     6f0:	8b 83       	std	Y+3, r24	; 0x03
     6f2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     6f4:	e0 e8       	ldi	r30, 0x80	; 128
     6f6:	f6 e0       	ldi	r31, 0x06	; 6
     6f8:	83 e0       	ldi	r24, 0x03	; 3
     6fa:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     6fc:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     6fe:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     700:	e0 e8       	ldi	r30, 0x80	; 128
     702:	f1 e0       	ldi	r31, 0x01	; 1
     704:	80 e7       	ldi	r24, 0x70	; 112
     706:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     708:	89 e0       	ldi	r24, 0x09	; 9
     70a:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     70c:	e0 e4       	ldi	r30, 0x40	; 64
     70e:	f8 e0       	ldi	r31, 0x08	; 8
     710:	8a e6       	ldi	r24, 0x6A	; 106
     712:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     714:	80 ea       	ldi	r24, 0xA0	; 160
     716:	95 e0       	ldi	r25, 0x05	; 5
     718:	86 a3       	std	Z+38, r24	; 0x26
     71a:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     71c:	81 e0       	ldi	r24, 0x01	; 1
     71e:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     720:	68 94       	set
     722:	ee 24       	eor	r14, r14
     724:	e6 f8       	bld	r14, 6
     726:	ff 24       	eor	r15, r15
     728:	f3 f8       	bld	r15, 3
     72a:	f7 01       	movw	r30, r14
     72c:	80 a1       	ldd	r24, Z+32	; 0x20
     72e:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     730:	0f b6       	in	r0, 0x3f	; 63
     732:	f8 94       	cli
     734:	0f 92       	push	r0
			the_data = new_data;
     736:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <thPendulum>
     73a:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <thPendulum+0x1>
			portEXIT_CRITICAL ();
     73e:	0f 90       	pop	r0
     740:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     742:	f8 01       	movw	r30, r16
     744:	86 85       	ldd	r24, Z+14	; 0x0e
     746:	97 85       	ldd	r25, Z+15	; 0x0f
     748:	a0 89       	ldd	r26, Z+16	; 0x10
     74a:	b1 89       	ldd	r27, Z+17	; 0x11
     74c:	01 96       	adiw	r24, 0x01	; 1
     74e:	a1 1d       	adc	r26, r1
     750:	b1 1d       	adc	r27, r1
     752:	86 87       	std	Z+14, r24	; 0x0e
     754:	97 87       	std	Z+15, r25	; 0x0f
     756:	a0 8b       	std	Z+16, r26	; 0x10
     758:	b1 8b       	std	Z+17, r27	; 0x11
     75a:	41 e0       	ldi	r20, 0x01	; 1
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	60 e0       	ldi	r22, 0x00	; 0
     760:	70 e0       	ldi	r23, 0x00	; 0
     762:	ce 01       	movw	r24, r28
     764:	01 96       	adiw	r24, 0x01	; 1
     766:	0e 94 ed 11 	call	0x23da	; 0x23da <vTaskDelayUntil>
     76a:	df cf       	rjmp	.-66     	; 0x72a <_ZN15EncoderPendulum3runEv+0x50>

0000076c <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     76c:	0f 93       	push	r16
     76e:	1f 93       	push	r17
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     776:	0e 94 8a 14 	call	0x2914	; 0x2914 <_ZN8frt_taskC1EPKchjP8emstream>
     77a:	82 e1       	ldi	r24, 0x12	; 18
     77c:	90 e2       	ldi	r25, 0x20	; 32
     77e:	88 83       	st	Y, r24
     780:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     782:	df 91       	pop	r29
     784:	cf 91       	pop	r28
     786:	1f 91       	pop	r17
     788:	0f 91       	pop	r16
     78a:	08 95       	ret

0000078c <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	00 d0       	rcall	.+0      	; 0x792 <_ZN13LimitSwitches3runEv+0x6>
     792:	1f 92       	push	r1
     794:	cd b7       	in	r28, 0x3d	; 61
     796:	de b7       	in	r29, 0x3e	; 62
     798:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     79a:	0e 94 4f 10 	call	0x209e	; 0x209e <xTaskGetTickCount>
     79e:	69 83       	std	Y+1, r22	; 0x01
     7a0:	7a 83       	std	Y+2, r23	; 0x02
     7a2:	8b 83       	std	Y+3, r24	; 0x03
     7a4:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     7a6:	e0 e6       	ldi	r30, 0x60	; 96
     7a8:	f6 e0       	ldi	r31, 0x06	; 6
     7aa:	81 e0       	ldi	r24, 0x01	; 1
     7ac:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     7ae:	84 e0       	ldi	r24, 0x04	; 4
     7b0:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     7b2:	88 e1       	ldi	r24, 0x18	; 24
     7b4:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     7b6:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     7b8:	08 e6       	ldi	r16, 0x68	; 104
     7ba:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     7bc:	dd 24       	eor	r13, r13
     7be:	d3 94       	inc	r13
     7c0:	f8 01       	movw	r30, r16
     7c2:	80 81       	ld	r24, Z
     7c4:	80 fd       	sbrc	r24, 0
     7c6:	08 c0       	rjmp	.+16     	; 0x7d8 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7c8:	0f b6       	in	r0, 0x3f	; 63
     7ca:	f8 94       	cli
     7cc:	0f 92       	push	r0
			the_data = new_data;
     7ce:	d0 92 3d 31 	sts	0x313D, r13	; 0x80313d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7d2:	0f 90       	pop	r0
     7d4:	0f be       	out	0x3f, r0	; 63
     7d6:	07 c0       	rjmp	.+14     	; 0x7e6 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7d8:	0f b6       	in	r0, 0x3f	; 63
     7da:	f8 94       	cli
     7dc:	0f 92       	push	r0
			the_data = new_data;
     7de:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7e2:	0f 90       	pop	r0
     7e4:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     7e6:	f8 01       	movw	r30, r16
     7e8:	80 81       	ld	r24, Z
     7ea:	82 fd       	sbrc	r24, 2
     7ec:	08 c0       	rjmp	.+16     	; 0x7fe <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7ee:	0f b6       	in	r0, 0x3f	; 63
     7f0:	f8 94       	cli
     7f2:	0f 92       	push	r0
			the_data = new_data;
     7f4:	d0 92 3c 31 	sts	0x313C, r13	; 0x80313c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     7f8:	0f 90       	pop	r0
     7fa:	0f be       	out	0x3f, r0	; 63
     7fc:	07 c0       	rjmp	.+14     	; 0x80c <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7fe:	0f b6       	in	r0, 0x3f	; 63
     800:	f8 94       	cli
     802:	0f 92       	push	r0
			the_data = new_data;
     804:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     808:	0f 90       	pop	r0
     80a:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     80c:	f7 01       	movw	r30, r14
     80e:	86 85       	ldd	r24, Z+14	; 0x0e
     810:	97 85       	ldd	r25, Z+15	; 0x0f
     812:	a0 89       	ldd	r26, Z+16	; 0x10
     814:	b1 89       	ldd	r27, Z+17	; 0x11
     816:	01 96       	adiw	r24, 0x01	; 1
     818:	a1 1d       	adc	r26, r1
     81a:	b1 1d       	adc	r27, r1
     81c:	86 87       	std	Z+14, r24	; 0x0e
     81e:	97 87       	std	Z+15, r25	; 0x0f
     820:	a0 8b       	std	Z+16, r26	; 0x10
     822:	b1 8b       	std	Z+17, r27	; 0x11
     824:	41 e0       	ldi	r20, 0x01	; 1
     826:	50 e0       	ldi	r21, 0x00	; 0
     828:	60 e0       	ldi	r22, 0x00	; 0
     82a:	70 e0       	ldi	r23, 0x00	; 0
     82c:	ce 01       	movw	r24, r28
     82e:	01 96       	adiw	r24, 0x01	; 1
     830:	0e 94 ed 11 	call	0x23da	; 0x23da <vTaskDelayUntil>
     834:	c5 cf       	rjmp	.-118    	; 0x7c0 <_ZN13LimitSwitches3runEv+0x34>

00000836 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     840:	0e 94 8a 14 	call	0x2914	; 0x2914 <_ZN8frt_taskC1EPKchjP8emstream>
     844:	8a e1       	ldi	r24, 0x1A	; 26
     846:	90 e2       	ldi	r25, 0x20	; 32
     848:	88 83       	st	Y, r24
     84a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	08 95       	ret

00000856 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	cd b7       	in	r28, 0x3d	; 61
     85c:	de b7       	in	r29, 0x3e	; 62
     85e:	6a 97       	sbiw	r28, 0x1a	; 26
     860:	cd bf       	out	0x3d, r28	; 61
     862:	de bf       	out	0x3e, r29	; 62
     864:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     866:	0e 94 4f 10 	call	0x209e	; 0x209e <xTaskGetTickCount>
     86a:	69 83       	std	Y+1, r22	; 0x01
     86c:	7a 83       	std	Y+2, r23	; 0x02
     86e:	8b 83       	std	Y+3, r24	; 0x03
     870:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     872:	f8 01       	movw	r30, r16
     874:	fe 96       	adiw	r30, 0x3e	; 62
     876:	81 e0       	ldi	r24, 0x01	; 1
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	a0 e0       	ldi	r26, 0x00	; 0
     87c:	b0 e0       	ldi	r27, 0x00	; 0
     87e:	80 83       	st	Z, r24
     880:	91 83       	std	Z+1, r25	; 0x01
     882:	a2 83       	std	Z+2, r26	; 0x02
     884:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     886:	d8 01       	movw	r26, r16
     888:	dc 96       	adiw	r26, 0x3c	; 60
     88a:	8d 93       	st	X+, r24
     88c:	9c 93       	st	X, r25
     88e:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     890:	a0 e4       	ldi	r26, 0x40	; 64
     892:	b6 e0       	ldi	r27, 0x06	; 6
     894:	87 e0       	ldi	r24, 0x07	; 7
     896:	11 96       	adiw	r26, 0x01	; 1
     898:	8c 93       	st	X, r24
     89a:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     89c:	84 e0       	ldi	r24, 0x04	; 4
     89e:	15 96       	adiw	r26, 0x05	; 5
     8a0:	8c 93       	st	X, r24
     8a2:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     8a4:	e0 e0       	ldi	r30, 0x00	; 0
     8a6:	f8 e0       	ldi	r31, 0x08	; 8
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     8ac:	83 e0       	ldi	r24, 0x03	; 3
     8ae:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     8b0:	a6 a3       	std	Z+38, r26	; 0x26
     8b2:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     8b4:	10 a6       	std	Z+40, r1	; 0x28
     8b6:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     8b8:	12 a6       	std	Z+42, r1	; 0x2a
     8ba:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     8bc:	81 81       	ldd	r24, Z+1	; 0x01
     8be:	80 63       	ori	r24, 0x30	; 48
     8c0:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8c2:	0f b6       	in	r0, 0x3f	; 63
     8c4:	f8 94       	cli
     8c6:	0f 92       	push	r0
			the_data = new_data;
     8c8:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <linear_offset>
     8cc:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     8d0:	0f 90       	pop	r0
     8d2:	0f be       	out	0x3f, r0	; 63
				omegam_set = -10;	// [ticks/ms]
			
				if (leftLimitSwitch.get())
				{
					int16_t left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     8d4:	68 01       	movw	r12, r16
     8d6:	b0 e5       	ldi	r27, 0x50	; 80
     8d8:	cb 0e       	add	r12, r27
     8da:	d1 1c       	adc	r13, r1
					output_correct = 0;
     8dc:	48 01       	movw	r8, r16
     8de:	ee e5       	ldi	r30, 0x5E	; 94
     8e0:	8e 0e       	add	r8, r30
     8e2:	91 1c       	adc	r9, r1
		
		switch (state)
		{
			// Home right
			case(0) :
				omegam_set = 10;	// [ticks/ms]
     8e4:	0f 2e       	mov	r0, r31
     8e6:	fa e0       	ldi	r31, 0x0A	; 10
     8e8:	af 2e       	mov	r10, r31
     8ea:	b1 2c       	mov	r11, r1
     8ec:	f0 2d       	mov	r31, r0
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     8ee:	98 01       	movw	r18, r16
     8f0:	28 5b       	subi	r18, 0xB8	; 184
     8f2:	3f 4f       	sbci	r19, 0xFF	; 255
     8f4:	2b 8b       	std	Y+19, r18	; 0x13
     8f6:	3c 8b       	std	Y+20, r19	; 0x14
		_Ki = .7*256;
     8f8:	c8 01       	movw	r24, r16
     8fa:	84 5b       	subi	r24, 0xB4	; 180
     8fc:	9f 4f       	sbci	r25, 0xFF	; 255
     8fe:	89 87       	std	Y+9, r24	; 0x09
     900:	9a 87       	std	Y+10, r25	; 0x0a
		_Kd = 0;
     902:	d8 01       	movw	r26, r16
     904:	a6 5b       	subi	r26, 0xB6	; 182
     906:	bf 4f       	sbci	r27, 0xFF	; 255
     908:	ad 8b       	std	Y+21, r26	; 0x15
     90a:	be 8b       	std	Y+22, r27	; 0x16
		antiwind_gain = .75*256;
     90c:	f8 01       	movw	r30, r16
     90e:	ec 59       	subi	r30, 0x9C	; 156
     910:	ff 4f       	sbci	r31, 0xFF	; 255
     912:	eb 87       	std	Y+11, r30	; 0x0b
     914:	fc 87       	std	Y+12, r31	; 0x0c
		
		_max = 1600;
     916:	24 50       	subi	r18, 0x04	; 4
     918:	31 09       	sbc	r19, r1
     91a:	2d 87       	std	Y+13, r18	; 0x0d
     91c:	3e 87       	std	Y+14, r19	; 0x0e
		_min = -1600;
     91e:	06 97       	sbiw	r24, 0x06	; 6
     920:	89 8b       	std	Y+17, r24	; 0x11
     922:	9a 8b       	std	Y+18, r25	; 0x12
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     924:	52 96       	adiw	r26, 0x12	; 18
     926:	af 8b       	std	Y+23, r26	; 0x17
     928:	b8 8f       	std	Y+24, r27	; 0x18

		// Integral term
		error_int = error - antiwind_correct;
     92a:	18 01       	movw	r2, r16
     92c:	b6 e6       	ldi	r27, 0x66	; 102
     92e:	2b 0e       	add	r2, r27
     930:	31 1c       	adc	r3, r1
     932:	34 96       	adiw	r30, 0x04	; 4
     934:	e9 8f       	std	Y+25, r30	; 0x19
     936:	fa 8f       	std	Y+26, r31	; 0x1a
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     938:	26 50       	subi	r18, 0x06	; 6
     93a:	31 09       	sbc	r19, r1
     93c:	2f 87       	std	Y+15, r18	; 0x0f
     93e:	38 8b       	std	Y+16, r19	; 0x10
	
	linear_offset.put(0);								// Initialize motor offset						
	
	while(1){
		// Increment counter for debugging
		runs++;
     940:	f8 01       	movw	r30, r16
     942:	86 85       	ldd	r24, Z+14	; 0x0e
     944:	97 85       	ldd	r25, Z+15	; 0x0f
     946:	a0 89       	ldd	r26, Z+16	; 0x10
     948:	b1 89       	ldd	r27, Z+17	; 0x11
     94a:	01 96       	adiw	r24, 0x01	; 1
     94c:	a1 1d       	adc	r26, r1
     94e:	b1 1d       	adc	r27, r1
     950:	86 87       	std	Z+14, r24	; 0x0e
     952:	97 87       	std	Z+15, r25	; 0x0f
     954:	a0 8b       	std	Z+16, r26	; 0x10
     956:	b1 8b       	std	Z+17, r27	; 0x11
		
		switch (state)
     958:	84 85       	ldd	r24, Z+12	; 0x0c
     95a:	81 30       	cpi	r24, 0x01	; 1
     95c:	09 f4       	brne	.+2      	; 0x960 <_ZN5Motor3runEv+0x10a>
     95e:	30 c0       	rjmp	.+96     	; 0x9c0 <_ZN5Motor3runEv+0x16a>
     960:	20 f0       	brcs	.+8      	; 0x96a <_ZN5Motor3runEv+0x114>
     962:	82 30       	cpi	r24, 0x02	; 2
     964:	09 f4       	brne	.+2      	; 0x968 <_ZN5Motor3runEv+0x112>
     966:	4d c0       	rjmp	.+154    	; 0xa02 <_ZN5Motor3runEv+0x1ac>
     968:	4e c0       	rjmp	.+156    	; 0xa06 <_ZN5Motor3runEv+0x1b0>
		{
			// Home right
			case(0) :
				omegam_set = 10;	// [ticks/ms]
     96a:	a2 8e       	std	Z+26, r10	; 0x1a
     96c:	b3 8e       	std	Z+27, r11	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     96e:	0f b6       	in	r0, 0x3f	; 63
     970:	f8 94       	cli
     972:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     974:	0f 90       	pop	r0
     976:	0f be       	out	0x3f, r0	; 63

				if (rightLimitSwitch.get())
     978:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rightLimitSwitch>
     97c:	88 23       	and	r24, r24
     97e:	09 f4       	brne	.+2      	; 0x982 <_ZN5Motor3runEv+0x12c>
     980:	42 c0       	rjmp	.+132    	; 0xa06 <_ZN5Motor3runEv+0x1b0>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     982:	0f b6       	in	r0, 0x3f	; 63
     984:	f8 94       	cli
     986:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     988:	0f 90       	pop	r0
     98a:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     98c:	0f b6       	in	r0, 0x3f	; 63
     98e:	f8 94       	cli
     990:	0f 92       	push	r0
			the_data = new_data;
     992:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <linear_position>
     996:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <linear_position+0x1>
     99a:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <linear_offset>
     99e:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     9a2:	0f 90       	pop	r0
     9a4:	0f be       	out	0x3f, r0	; 63
				{
					linear_offset.put(linear_position.get());					// set the offset
					_integral = 0;
     9a6:	f6 01       	movw	r30, r12
     9a8:	10 82       	st	Z, r1
     9aa:	11 82       	std	Z+1, r1	; 0x01
     9ac:	12 82       	std	Z+2, r1	; 0x02
     9ae:	13 82       	std	Z+3, r1	; 0x03
					output_correct = 0;
     9b0:	d4 01       	movw	r26, r8
     9b2:	1d 92       	st	X+, r1
     9b4:	1c 92       	st	X, r1
					transition_to(1);									// if right Limit Switch is triggered 
     9b6:	61 e0       	ldi	r22, 0x01	; 1
     9b8:	c8 01       	movw	r24, r16
     9ba:	0e 94 86 14 	call	0x290c	; 0x290c <_ZN8frt_task13transition_toEh>
     9be:	23 c0       	rjmp	.+70     	; 0xa06 <_ZN5Motor3runEv+0x1b0>
				}
				break;
				
			// Home left
			case(1) :
				omegam_set = -10;	// [ticks/ms]
     9c0:	86 ef       	ldi	r24, 0xF6	; 246
     9c2:	9f ef       	ldi	r25, 0xFF	; 255
     9c4:	f8 01       	movw	r30, r16
     9c6:	82 8f       	std	Z+26, r24	; 0x1a
     9c8:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     9d0:	0f 90       	pop	r0
     9d2:	0f be       	out	0x3f, r0	; 63
			
				if (leftLimitSwitch.get())
     9d4:	80 91 3d 31 	lds	r24, 0x313D	; 0x80313d <leftLimitSwitch>
     9d8:	88 23       	and	r24, r24
     9da:	a9 f0       	breq	.+42     	; 0xa06 <_ZN5Motor3runEv+0x1b0>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     9dc:	0f b6       	in	r0, 0x3f	; 63
     9de:	f8 94       	cli
     9e0:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63
				{
					int16_t left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     9e6:	d6 01       	movw	r26, r12
     9e8:	1d 92       	st	X+, r1
     9ea:	1d 92       	st	X+, r1
     9ec:	1d 92       	st	X+, r1
     9ee:	1c 92       	st	X, r1
     9f0:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     9f2:	f4 01       	movw	r30, r8
     9f4:	10 82       	st	Z, r1
     9f6:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     9f8:	62 e0       	ldi	r22, 0x02	; 2
     9fa:	c8 01       	movw	r24, r16
     9fc:	0e 94 86 14 	call	0x290c	; 0x290c <_ZN8frt_task13transition_toEh>
     a00:	02 c0       	rjmp	.+4      	; 0xa06 <_ZN5Motor3runEv+0x1b0>
				}					
				break;
			
			// Center Cart - Position Loop included
			case(2) :
				omegam_set = 0;											// Set velocity zero for now
     a02:	12 8e       	std	Z+26, r1	; 0x1a
     a04:	13 8e       	std	Z+27, r1	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     a06:	0f b6       	in	r0, 0x3f	; 63
     a08:	f8 94       	cli
     a0a:	0f 92       	push	r0
			temporary_copy = the_data;
     a0c:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <thdMotor>
     a10:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     a14:	0f 90       	pop	r0
     a16:	0f be       	out	0x3f, r0	; 63
				//break;													// PWM  = 0
		
		};

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     a18:	f8 01       	movw	r30, r16
     a1a:	86 8f       	std	Z+30, r24	; 0x1e
     a1c:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     a1e:	ab 89       	ldd	r26, Y+19	; 0x13
     a20:	bc 89       	ldd	r27, Y+20	; 0x14
     a22:	ad 92       	st	X+, r10
     a24:	bc 92       	st	X, r11
		_Ki = .7*256;
     a26:	23 eb       	ldi	r18, 0xB3	; 179
     a28:	30 e0       	ldi	r19, 0x00	; 0
     a2a:	e9 85       	ldd	r30, Y+9	; 0x09
     a2c:	fa 85       	ldd	r31, Y+10	; 0x0a
     a2e:	20 83       	st	Z, r18
     a30:	31 83       	std	Z+1, r19	; 0x01
		_Kd = 0;
     a32:	ad 89       	ldd	r26, Y+21	; 0x15
     a34:	be 89       	ldd	r27, Y+22	; 0x16
     a36:	1d 92       	st	X+, r1
     a38:	1c 92       	st	X, r1
		antiwind_gain = .75*256;
     a3a:	20 ec       	ldi	r18, 0xC0	; 192
     a3c:	30 e0       	ldi	r19, 0x00	; 0
     a3e:	eb 85       	ldd	r30, Y+11	; 0x0b
     a40:	fc 85       	ldd	r31, Y+12	; 0x0c
     a42:	20 83       	st	Z, r18
     a44:	31 83       	std	Z+1, r19	; 0x01
		
		_max = 1600;
     a46:	20 e4       	ldi	r18, 0x40	; 64
     a48:	36 e0       	ldi	r19, 0x06	; 6
     a4a:	ad 85       	ldd	r26, Y+13	; 0x0d
     a4c:	be 85       	ldd	r27, Y+14	; 0x0e
     a4e:	2d 93       	st	X+, r18
     a50:	3c 93       	st	X, r19
		_min = -1600;
     a52:	20 ec       	ldi	r18, 0xC0	; 192
     a54:	39 ef       	ldi	r19, 0xF9	; 249
     a56:	e9 89       	ldd	r30, Y+17	; 0x11
     a58:	fa 89       	ldd	r31, Y+18	; 0x12
     a5a:	20 83       	st	Z, r18
     a5c:	31 83       	std	Z+1, r19	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     a5e:	d8 01       	movw	r26, r16
     a60:	5a 96       	adiw	r26, 0x1a	; 26
     a62:	ed 90       	ld	r14, X+
     a64:	fc 90       	ld	r15, X
     a66:	5b 97       	sbiw	r26, 0x1b	; 27
     a68:	e8 1a       	sub	r14, r24
     a6a:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     a6c:	b7 01       	movw	r22, r14
     a6e:	c5 01       	movw	r24, r10
     a70:	0e 94 b3 06 	call	0xd66	; 0xd66 <_ZN7satmath20signed_saturated_mulEii>
     a74:	2b 01       	movw	r4, r22
     a76:	3c 01       	movw	r6, r24
     a78:	ef 89       	ldd	r30, Y+23	; 0x17
     a7a:	f8 8d       	ldd	r31, Y+24	; 0x18
     a7c:	60 83       	st	Z, r22
     a7e:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     a80:	d1 01       	movw	r26, r2
     a82:	8d 91       	ld	r24, X+
     a84:	9c 91       	ld	r25, X
     a86:	f7 01       	movw	r30, r14
     a88:	e8 1b       	sub	r30, r24
     a8a:	f9 0b       	sbc	r31, r25
     a8c:	cf 01       	movw	r24, r30
     a8e:	a9 8d       	ldd	r26, Y+25	; 0x19
     a90:	ba 8d       	ldd	r27, Y+26	; 0x1a
     a92:	ed 93       	st	X+, r30
     a94:	fc 93       	st	X, r31
		error_int_gain = (_Ki * error_int);
     a96:	e9 85       	ldd	r30, Y+9	; 0x09
     a98:	fa 85       	ldd	r31, Y+10	; 0x0a
     a9a:	20 81       	ld	r18, Z
     a9c:	31 81       	ldd	r19, Z+1	; 0x01
     a9e:	82 9f       	mul	r24, r18
     aa0:	d0 01       	movw	r26, r0
     aa2:	83 9f       	mul	r24, r19
     aa4:	b0 0d       	add	r27, r0
     aa6:	92 9f       	mul	r25, r18
     aa8:	b0 0d       	add	r27, r0
     aaa:	11 24       	eor	r1, r1
     aac:	f8 01       	movw	r30, r16
     aae:	e6 59       	subi	r30, 0x96	; 150
     ab0:	ff 4f       	sbci	r31, 0xFF	; 255
     ab2:	a0 83       	st	Z, r26
     ab4:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     ab6:	ef 85       	ldd	r30, Y+15	; 0x0f
     ab8:	f8 89       	ldd	r31, Y+16	; 0x10
     aba:	20 81       	ld	r18, Z
     abc:	31 81       	ldd	r19, Z+1	; 0x01
     abe:	42 81       	ldd	r20, Z+2	; 0x02
     ac0:	53 81       	ldd	r21, Z+3	; 0x03
     ac2:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <__mulshisi3>
     ac6:	9b 01       	movw	r18, r22
     ac8:	ac 01       	movw	r20, r24
     aca:	99 23       	and	r25, r25
     acc:	24 f4       	brge	.+8      	; 0xad6 <_ZN5Motor3runEv+0x280>
     ace:	21 50       	subi	r18, 0x01	; 1
     ad0:	3f 4f       	sbci	r19, 0xFF	; 255
     ad2:	4f 4f       	sbci	r20, 0xFF	; 255
     ad4:	5f 4f       	sbci	r21, 0xFF	; 255
     ad6:	bb 27       	eor	r27, r27
     ad8:	57 fd       	sbrc	r21, 7
     ada:	ba 95       	dec	r27
     adc:	a5 2f       	mov	r26, r21
     ade:	94 2f       	mov	r25, r20
     ae0:	83 2f       	mov	r24, r19
     ae2:	f6 01       	movw	r30, r12
     ae4:	40 81       	ld	r20, Z
     ae6:	51 81       	ldd	r21, Z+1	; 0x01
     ae8:	62 81       	ldd	r22, Z+2	; 0x02
     aea:	73 81       	ldd	r23, Z+3	; 0x03
     aec:	84 0f       	add	r24, r20
     aee:	95 1f       	adc	r25, r21
     af0:	a6 1f       	adc	r26, r22
     af2:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     af4:	81 30       	cpi	r24, 0x01	; 1
     af6:	fa ec       	ldi	r31, 0xCA	; 202
     af8:	9f 07       	cpc	r25, r31
     afa:	fa e9       	ldi	r31, 0x9A	; 154
     afc:	af 07       	cpc	r26, r31
     afe:	fb e3       	ldi	r31, 0x3B	; 59
     b00:	bf 07       	cpc	r27, r31
     b02:	54 f0       	brlt	.+20     	; 0xb18 <_ZN5Motor3runEv+0x2c2>
		{
			_integral = 1000000000;
     b04:	80 e0       	ldi	r24, 0x00	; 0
     b06:	9a ec       	ldi	r25, 0xCA	; 202
     b08:	aa e9       	ldi	r26, 0x9A	; 154
     b0a:	bb e3       	ldi	r27, 0x3B	; 59
     b0c:	f6 01       	movw	r30, r12
     b0e:	80 83       	st	Z, r24
     b10:	91 83       	std	Z+1, r25	; 0x01
     b12:	a2 83       	std	Z+2, r26	; 0x02
     b14:	b3 83       	std	Z+3, r27	; 0x03
     b16:	17 c0       	rjmp	.+46     	; 0xb46 <_ZN5Motor3runEv+0x2f0>
		}
		else if(_integral < -1000000000)
     b18:	81 15       	cp	r24, r1
     b1a:	f6 e3       	ldi	r31, 0x36	; 54
     b1c:	9f 07       	cpc	r25, r31
     b1e:	f5 e6       	ldi	r31, 0x65	; 101
     b20:	af 07       	cpc	r26, r31
     b22:	f4 ec       	ldi	r31, 0xC4	; 196
     b24:	bf 07       	cpc	r27, r31
     b26:	34 f0       	brlt	.+12     	; 0xb34 <_ZN5Motor3runEv+0x2de>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     b28:	f6 01       	movw	r30, r12
     b2a:	80 83       	st	Z, r24
     b2c:	91 83       	std	Z+1, r25	; 0x01
     b2e:	a2 83       	std	Z+2, r26	; 0x02
     b30:	b3 83       	std	Z+3, r27	; 0x03
     b32:	09 c0       	rjmp	.+18     	; 0xb46 <_ZN5Motor3runEv+0x2f0>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
     b34:	80 e0       	ldi	r24, 0x00	; 0
     b36:	96 e3       	ldi	r25, 0x36	; 54
     b38:	a5 e6       	ldi	r26, 0x65	; 101
     b3a:	b4 ec       	ldi	r27, 0xC4	; 196
     b3c:	f6 01       	movw	r30, r12
     b3e:	80 83       	st	Z, r24
     b40:	91 83       	std	Z+1, r25	; 0x01
     b42:	a2 83       	std	Z+2, r26	; 0x02
     b44:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     b46:	d6 01       	movw	r26, r12
     b48:	6d 91       	ld	r22, X+
     b4a:	7c 91       	ld	r23, X
     b4c:	c2 01       	movw	r24, r4
     b4e:	0e 94 97 06 	call	0xd2e	; 0xd2e <_ZN7satmath20signed_saturated_addEii>
     b52:	f8 01       	movw	r30, r16
     b54:	e0 5a       	subi	r30, 0xA0	; 160
     b56:	ff 4f       	sbci	r31, 0xFF	; 255
     b58:	80 83       	st	Z, r24
     b5a:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     b5c:	f4 01       	movw	r30, r8
     b5e:	80 83       	st	Z, r24
     b60:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     b62:	ad 85       	ldd	r26, Y+13	; 0x0d
     b64:	be 85       	ldd	r27, Y+14	; 0x0e
     b66:	2d 91       	ld	r18, X+
     b68:	3c 91       	ld	r19, X
     b6a:	28 17       	cp	r18, r24
     b6c:	39 07       	cpc	r19, r25
     b6e:	1c f4       	brge	.+6      	; 0xb76 <_ZN5Motor3runEv+0x320>
		output_correct = _max;
     b70:	20 83       	st	Z, r18
     b72:	31 83       	std	Z+1, r19	; 0x01
     b74:	0a c0       	rjmp	.+20     	; 0xb8a <_ZN5Motor3runEv+0x334>
		else if( output_correct < _min )
     b76:	e9 89       	ldd	r30, Y+17	; 0x11
     b78:	fa 89       	ldd	r31, Y+18	; 0x12
     b7a:	20 81       	ld	r18, Z
     b7c:	31 81       	ldd	r19, Z+1	; 0x01
     b7e:	82 17       	cp	r24, r18
     b80:	93 07       	cpc	r25, r19
     b82:	1c f4       	brge	.+6      	; 0xb8a <_ZN5Motor3runEv+0x334>
		output_correct = _min;
     b84:	d4 01       	movw	r26, r8
     b86:	2d 93       	st	X+, r18
     b88:	3c 93       	st	X, r19

		// Save error to previous error
		_pre_error = error;
     b8a:	f8 01       	movw	r30, r16
     b8c:	e2 5b       	subi	r30, 0xB2	; 178
     b8e:	ff 4f       	sbci	r31, 0xFF	; 255
     b90:	e0 82       	st	Z, r14
     b92:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     b94:	f4 01       	movw	r30, r8
     b96:	e0 80       	ld	r14, Z
     b98:	f1 80       	ldd	r15, Z+1	; 0x01
     b9a:	8e 19       	sub	r24, r14
     b9c:	9f 09       	sbc	r25, r15
     b9e:	f8 01       	movw	r30, r16
     ba0:	ee 59       	subi	r30, 0x9E	; 158
     ba2:	ff 4f       	sbci	r31, 0xFF	; 255
     ba4:	80 83       	st	Z, r24
     ba6:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     ba8:	ab 85       	ldd	r26, Y+11	; 0x0b
     baa:	bc 85       	ldd	r27, Y+12	; 0x0c
     bac:	4d 91       	ld	r20, X+
     bae:	5c 91       	ld	r21, X
     bb0:	84 9f       	mul	r24, r20
     bb2:	90 01       	movw	r18, r0
     bb4:	85 9f       	mul	r24, r21
     bb6:	30 0d       	add	r19, r0
     bb8:	94 9f       	mul	r25, r20
     bba:	30 0d       	add	r19, r0
     bbc:	11 24       	eor	r1, r1
     bbe:	33 23       	and	r19, r19
     bc0:	14 f4       	brge	.+4      	; 0xbc6 <_ZN5Motor3runEv+0x370>
     bc2:	21 50       	subi	r18, 0x01	; 1
     bc4:	3f 4f       	sbci	r19, 0xFF	; 255
     bc6:	83 2f       	mov	r24, r19
     bc8:	88 0f       	add	r24, r24
     bca:	88 0b       	sbc	r24, r24
     bcc:	f1 01       	movw	r30, r2
     bce:	30 83       	st	Z, r19
     bd0:	81 83       	std	Z+1, r24	; 0x01
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		*/
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     bd2:	d8 01       	movw	r26, r16
     bd4:	98 96       	adiw	r26, 0x28	; 40
     bd6:	1d 92       	st	X+, r1
     bd8:	1c 92       	st	X, r1
     bda:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
     bdc:	92 96       	adiw	r26, 0x22	; 34
     bde:	8d 91       	ld	r24, X+
     be0:	9c 91       	ld	r25, X
     be2:	93 97       	sbiw	r26, 0x23	; 35
     be4:	60 e0       	ldi	r22, 0x00	; 0
     be6:	70 e0       	ldi	r23, 0x00	; 0
     be8:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__divmodhi4>
     bec:	3b 01       	movw	r6, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     bee:	07 2e       	mov	r0, r23
     bf0:	00 0c       	add	r0, r0
     bf2:	88 0b       	sbc	r24, r24
     bf4:	99 0b       	sbc	r25, r25
     bf6:	0e 94 a4 1e 	call	0x3d48	; 0x3d48 <__floatsisf>
     bfa:	6d 83       	std	Y+5, r22	; 0x05
     bfc:	7e 83       	std	Y+6, r23	; 0x06
     bfe:	8f 83       	std	Y+7, r24	; 0x07
     c00:	98 87       	std	Y+8, r25	; 0x08
     c02:	23 e3       	ldi	r18, 0x33	; 51
     c04:	33 e3       	ldi	r19, 0x33	; 51
     c06:	4b e8       	ldi	r20, 0x8B	; 139
     c08:	51 e4       	ldi	r21, 0x41	; 65
     c0a:	0e 94 03 1f 	call	0x3e06	; 0x3e06 <__gesf2>
     c0e:	18 16       	cp	r1, r24
     c10:	34 f4       	brge	.+12     	; 0xc1e <_ZN5Motor3runEv+0x3c8>
			Im_set = 17.4;
     c12:	81 e1       	ldi	r24, 0x11	; 17
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	f8 01       	movw	r30, r16
     c18:	84 a3       	std	Z+36, r24	; 0x24
     c1a:	95 a3       	std	Z+37, r25	; 0x25
     c1c:	17 c0       	rjmp	.+46     	; 0xc4c <_ZN5Motor3runEv+0x3f6>
		} else if(Im_set < -17.4) {
     c1e:	23 e3       	ldi	r18, 0x33	; 51
     c20:	33 e3       	ldi	r19, 0x33	; 51
     c22:	4b e8       	ldi	r20, 0x8B	; 139
     c24:	51 ec       	ldi	r21, 0xC1	; 193
     c26:	6d 81       	ldd	r22, Y+5	; 0x05
     c28:	7e 81       	ldd	r23, Y+6	; 0x06
     c2a:	8f 81       	ldd	r24, Y+7	; 0x07
     c2c:	98 85       	ldd	r25, Y+8	; 0x08
     c2e:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <__cmpsf2>
     c32:	88 23       	and	r24, r24
     c34:	34 f0       	brlt	.+12     	; 0xc42 <_ZN5Motor3runEv+0x3ec>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		*/
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     c36:	d8 01       	movw	r26, r16
     c38:	94 96       	adiw	r26, 0x24	; 36
     c3a:	6d 92       	st	X+, r6
     c3c:	7c 92       	st	X, r7
     c3e:	95 97       	sbiw	r26, 0x25	; 37
     c40:	05 c0       	rjmp	.+10     	; 0xc4c <_ZN5Motor3runEv+0x3f6>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     c42:	8f ee       	ldi	r24, 0xEF	; 239
     c44:	9f ef       	ldi	r25, 0xFF	; 255
     c46:	f8 01       	movw	r30, r16
     c48:	84 a3       	std	Z+36, r24	; 0x24
     c4a:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     c4c:	d8 01       	movw	r26, r16
     c4e:	d6 96       	adiw	r26, 0x36	; 54
     c50:	1d 92       	st	X+, r1
     c52:	1c 92       	st	X, r1
     c54:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     c56:	d2 96       	adiw	r26, 0x32	; 50
     c58:	1d 92       	st	X+, r1
     c5a:	1c 92       	st	X, r1
     c5c:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     c5e:	d4 96       	adiw	r26, 0x34	; 52
     c60:	1d 92       	st	X+, r1
     c62:	1c 92       	st	X, r1
     c64:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
     c66:	d0 96       	adiw	r26, 0x30	; 48
     c68:	8d 91       	ld	r24, X+
     c6a:	9c 91       	ld	r25, X
     c6c:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
     c6e:	89 31       	cpi	r24, 0x19	; 25
     c70:	91 05       	cpc	r25, r1
     c72:	3c f0       	brlt	.+14     	; 0xc82 <_ZN5Motor3runEv+0x42c>
			V_m = 24;
     c74:	88 e1       	ldi	r24, 0x18	; 24
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	d8 96       	adiw	r26, 0x38	; 56
     c7a:	8d 93       	st	X+, r24
     c7c:	9c 93       	st	X, r25
     c7e:	d9 97       	sbiw	r26, 0x39	; 57
     c80:	0f c0       	rjmp	.+30     	; 0xca0 <_ZN5Motor3runEv+0x44a>
		} else if(V_m < -24) {
     c82:	88 3e       	cpi	r24, 0xE8	; 232
     c84:	bf ef       	ldi	r27, 0xFF	; 255
     c86:	9b 07       	cpc	r25, r27
     c88:	24 f0       	brlt	.+8      	; 0xc92 <_ZN5Motor3runEv+0x43c>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     c8a:	f8 01       	movw	r30, r16
     c8c:	80 af       	std	Z+56, r24	; 0x38
     c8e:	91 af       	std	Z+57, r25	; 0x39
     c90:	07 c0       	rjmp	.+14     	; 0xca0 <_ZN5Motor3runEv+0x44a>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     c92:	88 ee       	ldi	r24, 0xE8	; 232
     c94:	9f ef       	ldi	r25, 0xFF	; 255
     c96:	d8 01       	movw	r26, r16
     c98:	d8 96       	adiw	r26, 0x38	; 56
     c9a:	8d 93       	st	X+, r24
     c9c:	9c 93       	st	X, r25
     c9e:	d9 97       	sbiw	r26, 0x39	; 57
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
     ca0:	ff 20       	and	r15, r15
     ca2:	3c f0       	brlt	.+14     	; 0xcb2 <_ZN5Motor3runEv+0x45c>
		{
			TCC0.CCA = output_correct;
     ca4:	e0 e0       	ldi	r30, 0x00	; 0
     ca6:	f8 e0       	ldi	r31, 0x08	; 8
     ca8:	e0 a6       	std	Z+40, r14	; 0x28
     caa:	f1 a6       	std	Z+41, r15	; 0x29
			TCC0.CCB = 0;
     cac:	12 a6       	std	Z+42, r1	; 0x2a
     cae:	13 a6       	std	Z+43, r1	; 0x2b
     cb0:	0c c0       	rjmp	.+24     	; 0xcca <_ZN5Motor3runEv+0x474>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
     cb2:	e0 e0       	ldi	r30, 0x00	; 0
     cb4:	f8 e0       	ldi	r31, 0x08	; 8
     cb6:	10 a6       	std	Z+40, r1	; 0x28
     cb8:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
     cba:	d4 01       	movw	r26, r8
     cbc:	8d 91       	ld	r24, X+
     cbe:	9c 91       	ld	r25, X
     cc0:	91 95       	neg	r25
     cc2:	81 95       	neg	r24
     cc4:	91 09       	sbc	r25, r1
     cc6:	82 a7       	std	Z+42, r24	; 0x2a
     cc8:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
     cca:	ef 85       	ldd	r30, Y+15	; 0x0f
     ccc:	f8 89       	ldd	r31, Y+16	; 0x10
     cce:	20 81       	ld	r18, Z
     cd0:	31 81       	ldd	r19, Z+1	; 0x01
     cd2:	42 81       	ldd	r20, Z+2	; 0x02
     cd4:	53 81       	ldd	r21, Z+3	; 0x03
     cd6:	a8 ee       	ldi	r26, 0xE8	; 232
     cd8:	b3 e0       	ldi	r27, 0x03	; 3
     cda:	0e 94 94 1f 	call	0x3f28	; 0x3f28 <__muluhisi3>
     cde:	68 3e       	cpi	r22, 0xE8	; 232
     ce0:	f3 e0       	ldi	r31, 0x03	; 3
     ce2:	7f 07       	cpc	r23, r31
     ce4:	81 05       	cpc	r24, r1
     ce6:	91 05       	cpc	r25, r1
     ce8:	48 f0       	brcs	.+18     	; 0xcfc <_ZN5Motor3runEv+0x4a6>
     cea:	28 ee       	ldi	r18, 0xE8	; 232
     cec:	33 e0       	ldi	r19, 0x03	; 3
     cee:	40 e0       	ldi	r20, 0x00	; 0
     cf0:	50 e0       	ldi	r21, 0x00	; 0
     cf2:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__udivmodsi4>
     cf6:	ba 01       	movw	r22, r20
     cf8:	a9 01       	movw	r20, r18
     cfa:	04 c0       	rjmp	.+8      	; 0xd04 <_ZN5Motor3runEv+0x4ae>
     cfc:	41 e0       	ldi	r20, 0x01	; 1
     cfe:	50 e0       	ldi	r21, 0x00	; 0
     d00:	60 e0       	ldi	r22, 0x00	; 0
     d02:	70 e0       	ldi	r23, 0x00	; 0
     d04:	ce 01       	movw	r24, r28
     d06:	01 96       	adiw	r24, 0x01	; 1
     d08:	0e 94 ed 11 	call	0x23da	; 0x23da <vTaskDelayUntil>
     d0c:	19 ce       	rjmp	.-974    	; 0x940 <_ZN5Motor3runEv+0xea>

00000d0e <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
     d0e:	0f 93       	push	r16
     d10:	1f 93       	push	r17
     d12:	cf 93       	push	r28
     d14:	df 93       	push	r29
     d16:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d18:	0e 94 8a 14 	call	0x2914	; 0x2914 <_ZN8frt_taskC1EPKchjP8emstream>
     d1c:	82 e2       	ldi	r24, 0x22	; 34
     d1e:	90 e2       	ldi	r25, 0x20	; 32
     d20:	88 83       	st	Y, r24
     d22:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     d24:	df 91       	pop	r29
     d26:	cf 91       	pop	r28
     d28:	1f 91       	pop	r17
     d2a:	0f 91       	pop	r16
     d2c:	08 95       	ret

00000d2e <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
     d2e:	9c 01       	movw	r18, r24
     d30:	93 2f       	mov	r25, r19
     d32:	99 1f       	adc	r25, r25
     d34:	99 27       	eor	r25, r25
     d36:	99 1f       	adc	r25, r25
     d38:	89 2f       	mov	r24, r25
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	81 50       	subi	r24, 0x01	; 1
     d3e:	90 48       	sbci	r25, 0x80	; 128
     d40:	43 2f       	mov	r20, r19
     d42:	40 95       	com	r20
     d44:	44 1f       	adc	r20, r20
     d46:	44 27       	eor	r20, r20
     d48:	44 1f       	adc	r20, r20
     d4a:	fc 01       	movw	r30, r24
     d4c:	e2 1b       	sub	r30, r18
     d4e:	f3 0b       	sbc	r31, r19
     d50:	51 e0       	ldi	r21, 0x01	; 1
     d52:	e6 17       	cp	r30, r22
     d54:	f7 07       	cpc	r31, r23
     d56:	0c f0       	brlt	.+2      	; 0xd5a <_ZN7satmath20signed_saturated_addEii+0x2c>
     d58:	50 e0       	ldi	r21, 0x00	; 0
     d5a:	45 17       	cp	r20, r21
     d5c:	19 f0       	breq	.+6      	; 0xd64 <_ZN7satmath20signed_saturated_addEii+0x36>
     d5e:	c9 01       	movw	r24, r18
     d60:	86 0f       	add	r24, r22
     d62:	97 1f       	adc	r25, r23
     d64:	08 95       	ret

00000d66 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     d66:	81 15       	cp	r24, r1
     d68:	20 e8       	ldi	r18, 0x80	; 128
     d6a:	92 07       	cpc	r25, r18
     d6c:	21 f4       	brne	.+8      	; 0xd76 <_ZN7satmath20signed_saturated_mulEii+0x10>
     d6e:	61 15       	cp	r22, r1
     d70:	20 e8       	ldi	r18, 0x80	; 128
     d72:	72 07       	cpc	r23, r18
     d74:	29 f0       	breq	.+10     	; 0xd80 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     d76:	9c 01       	movw	r18, r24
     d78:	db 01       	movw	r26, r22
     d7a:	0e 94 76 1f 	call	0x3eec	; 0x3eec <__mulhisi3>
     d7e:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     d80:	6f ef       	ldi	r22, 0xFF	; 255
     d82:	7f ef       	ldi	r23, 0xFF	; 255
     d84:	8f ef       	ldi	r24, 0xFF	; 255
     d86:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     d88:	08 95       	ret

00000d8a <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     d8a:	0f 93       	push	r16
     d8c:	1f 93       	push	r17
     d8e:	cf 93       	push	r28
     d90:	df 93       	push	r29
     d92:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d94:	0e 94 8a 14 	call	0x2914	; 0x2914 <_ZN8frt_taskC1EPKchjP8emstream>
     d98:	8a e2       	ldi	r24, 0x2A	; 42
     d9a:	90 e2       	ldi	r25, 0x20	; 32
     d9c:	88 83       	st	Y, r24
     d9e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     da0:	df 91       	pop	r29
     da2:	cf 91       	pop	r28
     da4:	1f 91       	pop	r17
     da6:	0f 91       	pop	r16
     da8:	08 95       	ret

00000daa <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     db4:	6a e0       	ldi	r22, 0x0A	; 10
     db6:	8e 81       	ldd	r24, Y+6	; 0x06
     db8:	9f 81       	ldd	r25, Y+7	; 0x07
     dba:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     dbe:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     dc0:	69 ee       	ldi	r22, 0xE9	; 233
     dc2:	73 e0       	ldi	r23, 0x03	; 3
     dc4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     dc8:	6a e0       	ldi	r22, 0x0A	; 10
     dca:	c8 01       	movw	r24, r16
     dcc:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     dd0:	8c 01       	movw	r16, r24
     dd2:	63 ee       	ldi	r22, 0xE3	; 227
     dd4:	73 e0       	ldi	r23, 0x03	; 3
     dd6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     dda:	67 e0       	ldi	r22, 0x07	; 7
     ddc:	c8 01       	movw	r24, r16
     dde:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     de2:	6a e0       	ldi	r22, 0x0A	; 10
     de4:	8e 81       	ldd	r24, Y+6	; 0x06
     de6:	9f 81       	ldd	r25, Y+7	; 0x07
     de8:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     dec:	8c 01       	movw	r16, r24
     dee:	64 ec       	ldi	r22, 0xC4	; 196
     df0:	73 e0       	ldi	r23, 0x03	; 3
     df2:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     df6:	6a e0       	ldi	r22, 0x0A	; 10
     df8:	c8 01       	movw	r24, r16
     dfa:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     dfe:	8c 01       	movw	r16, r24
     e00:	6e eb       	ldi	r22, 0xBE	; 190
     e02:	73 e0       	ldi	r23, 0x03	; 3
     e04:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     e08:	66 e0       	ldi	r22, 0x06	; 6
     e0a:	c8 01       	movw	r24, r16
     e0c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e10:	6a e0       	ldi	r22, 0x0A	; 10
     e12:	8e 81       	ldd	r24, Y+6	; 0x06
     e14:	9f 81       	ldd	r25, Y+7	; 0x07
     e16:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     e1a:	8c 01       	movw	r16, r24
     e1c:	67 ea       	ldi	r22, 0xA7	; 167
     e1e:	73 e0       	ldi	r23, 0x03	; 3
     e20:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     e24:	66 e0       	ldi	r22, 0x06	; 6
     e26:	c8 01       	movw	r24, r16
     e28:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e2c:	6a e0       	ldi	r22, 0x0A	; 10
     e2e:	8e 81       	ldd	r24, Y+6	; 0x06
     e30:	9f 81       	ldd	r25, Y+7	; 0x07
     e32:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     e36:	8c 01       	movw	r16, r24
     e38:	6b e8       	ldi	r22, 0x8B	; 139
     e3a:	73 e0       	ldi	r23, 0x03	; 3
     e3c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     e40:	66 e0       	ldi	r22, 0x06	; 6
     e42:	c8 01       	movw	r24, r16
     e44:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e48:	6a e0       	ldi	r22, 0x0A	; 10
     e4a:	8e 81       	ldd	r24, Y+6	; 0x06
     e4c:	9f 81       	ldd	r25, Y+7	; 0x07
     e4e:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     e52:	8c 01       	movw	r16, r24
     e54:	63 e7       	ldi	r22, 0x73	; 115
     e56:	73 e0       	ldi	r23, 0x03	; 3
     e58:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     e5c:	66 e0       	ldi	r22, 0x06	; 6
     e5e:	c8 01       	movw	r24, r16
     e60:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e64:	6a e0       	ldi	r22, 0x0A	; 10
     e66:	8e 81       	ldd	r24, Y+6	; 0x06
     e68:	9f 81       	ldd	r25, Y+7	; 0x07
     e6a:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     e6e:	8c 01       	movw	r16, r24
     e70:	62 e5       	ldi	r22, 0x52	; 82
     e72:	73 e0       	ldi	r23, 0x03	; 3
     e74:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     e78:	66 e0       	ldi	r22, 0x06	; 6
     e7a:	c8 01       	movw	r24, r16
     e7c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e80:	6a e0       	ldi	r22, 0x0A	; 10
     e82:	8e 81       	ldd	r24, Y+6	; 0x06
     e84:	9f 81       	ldd	r25, Y+7	; 0x07
     e86:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     e8a:	8c 01       	movw	r16, r24
     e8c:	6b e2       	ldi	r22, 0x2B	; 43
     e8e:	73 e0       	ldi	r23, 0x03	; 3
     e90:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     e94:	66 e0       	ldi	r22, 0x06	; 6
     e96:	c8 01       	movw	r24, r16
     e98:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     e9c:	6a e0       	ldi	r22, 0x0A	; 10
     e9e:	8e 81       	ldd	r24, Y+6	; 0x06
     ea0:	9f 81       	ldd	r25, Y+7	; 0x07
     ea2:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     ea6:	8c 01       	movw	r16, r24
     ea8:	6d e0       	ldi	r22, 0x0D	; 13
     eaa:	73 e0       	ldi	r23, 0x03	; 3
     eac:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     eb0:	66 e0       	ldi	r22, 0x06	; 6
     eb2:	c8 01       	movw	r24, r16
     eb4:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     eb8:	6a e0       	ldi	r22, 0x0A	; 10
     eba:	8e 81       	ldd	r24, Y+6	; 0x06
     ebc:	9f 81       	ldd	r25, Y+7	; 0x07
     ebe:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     ec2:	8c 01       	movw	r16, r24
     ec4:	62 ef       	ldi	r22, 0xF2	; 242
     ec6:	72 e0       	ldi	r23, 0x02	; 2
     ec8:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     ecc:	66 e0       	ldi	r22, 0x06	; 6
     ece:	c8 01       	movw	r24, r16
     ed0:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     ed4:	6a e0       	ldi	r22, 0x0A	; 10
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	9f 81       	ldd	r25, Y+7	; 0x07
     eda:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     ede:	ec 01       	movw	r28, r24
     ee0:	63 ee       	ldi	r22, 0xE3	; 227
     ee2:	72 e0       	ldi	r23, 0x02	; 2
     ee4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     ee8:	66 e0       	ldi	r22, 0x06	; 6
     eea:	ce 01       	movw	r24, r28
     eec:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
}
     ef0:	df 91       	pop	r29
     ef2:	cf 91       	pop	r28
     ef4:	1f 91       	pop	r17
     ef6:	0f 91       	pop	r16
     ef8:	08 95       	ret

00000efa <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     efa:	af 92       	push	r10
     efc:	bf 92       	push	r11
     efe:	cf 92       	push	r12
     f00:	df 92       	push	r13
     f02:	ef 92       	push	r14
     f04:	ff 92       	push	r15
     f06:	0f 93       	push	r16
     f08:	1f 93       	push	r17
     f0a:	cf 93       	push	r28
     f0c:	df 93       	push	r29
     f0e:	00 d0       	rcall	.+0      	; 0xf10 <_ZN9task_user11show_statusEv+0x16>
     f10:	00 d0       	rcall	.+0      	; 0xf12 <_ZN9task_user11show_statusEv+0x18>
     f12:	cd b7       	in	r28, 0x3d	; 61
     f14:	de b7       	in	r29, 0x3e	; 62
     f16:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f18:	19 82       	std	Y+1, r1	; 0x01
     f1a:	1a 82       	std	Y+2, r1	; 0x02
     f1c:	1b 82       	std	Y+3, r1	; 0x03
     f1e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f20:	1d 82       	std	Y+5, r1	; 0x05
     f22:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f24:	0e 94 02 0a 	call	0x1404	; 0x1404 <xPortGetFreeHeapSize>
     f28:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f2a:	ce 01       	movw	r24, r28
     f2c:	01 96       	adiw	r24, 0x01	; 1
     f2e:	0e 94 3b 18 	call	0x3076	; 0x3076 <_ZN10time_stamp10set_to_nowEv>
     f32:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f34:	66 e0       	ldi	r22, 0x06	; 6
     f36:	f8 01       	movw	r30, r16
     f38:	86 81       	ldd	r24, Z+6	; 0x06
     f3a:	97 81       	ldd	r25, Z+7	; 0x07
     f3c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     f40:	6a e0       	ldi	r22, 0x0A	; 10
     f42:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     f46:	7c 01       	movw	r14, r24
     f48:	64 ec       	ldi	r22, 0xC4	; 196
     f4a:	72 e0       	ldi	r23, 0x02	; 2
     f4c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     f50:	6a e0       	ldi	r22, 0x0A	; 10
     f52:	c7 01       	movw	r24, r14
     f54:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     f58:	7c 01       	movw	r14, r24
     f5a:	68 eb       	ldi	r22, 0xB8	; 184
     f5c:	72 e0       	ldi	r23, 0x02	; 2
     f5e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     f62:	66 e0       	ldi	r22, 0x06	; 6
     f64:	c7 01       	movw	r24, r14
     f66:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f6a:	6a e0       	ldi	r22, 0x0A	; 10
     f6c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     f70:	7c 01       	movw	r14, r24
     f72:	61 eb       	ldi	r22, 0xB1	; 177
     f74:	72 e0       	ldi	r23, 0x02	; 2
     f76:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     f7a:	b5 01       	movw	r22, r10
     f7c:	c7 01       	movw	r24, r14
     f7e:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f82:	6a e0       	ldi	r22, 0x0A	; 10
     f84:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     f88:	7c 01       	movw	r14, r24
     f8a:	63 ea       	ldi	r22, 0xA3	; 163
     f8c:	72 e0       	ldi	r23, 0x02	; 2
     f8e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     f92:	b6 01       	movw	r22, r12
     f94:	c7 01       	movw	r24, r14
     f96:	0e 94 36 1a 	call	0x346c	; 0x346c <_ZN8emstreamlsEj>
     f9a:	6a e0       	ldi	r22, 0x0A	; 10
     f9c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     fa0:	7c 01       	movw	r14, r24
     fa2:	61 ea       	ldi	r22, 0xA1	; 161
     fa4:	72 e0       	ldi	r23, 0x02	; 2
     fa6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     faa:	4f ef       	ldi	r20, 0xFF	; 255
     fac:	5f e0       	ldi	r21, 0x0F	; 15
     fae:	60 e0       	ldi	r22, 0x00	; 0
     fb0:	70 e0       	ldi	r23, 0x00	; 0
     fb2:	c7 01       	movw	r24, r14
     fb4:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     fb8:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     fbc:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     fc0:	6a e0       	ldi	r22, 0x0A	; 10
     fc2:	f8 01       	movw	r30, r16
     fc4:	86 81       	ldd	r24, Z+6	; 0x06
     fc6:	97 81       	ldd	r25, Z+7	; 0x07
     fc8:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     fcc:	7c 01       	movw	r14, r24
     fce:	66 e9       	ldi	r22, 0x96	; 150
     fd0:	72 e0       	ldi	r23, 0x02	; 2
     fd2:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
     fd6:	b6 01       	movw	r22, r12
     fd8:	c7 01       	movw	r24, r14
     fda:	0e 94 36 1a 	call	0x346c	; 0x346c <_ZN8emstreamlsEj>
     fde:	66 e0       	ldi	r22, 0x06	; 6
     fe0:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
     fe4:	66 e0       	ldi	r22, 0x06	; 6
     fe6:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     fea:	f8 01       	movw	r30, r16
     fec:	86 81       	ldd	r24, Z+6	; 0x06
     fee:	97 81       	ldd	r25, Z+7	; 0x07
     ff0:	0e 94 98 16 	call	0x2d30	; 0x2d30 <_Z15print_task_listP8emstream>
}
     ff4:	26 96       	adiw	r28, 0x06	; 6
     ff6:	cd bf       	out	0x3d, r28	; 61
     ff8:	de bf       	out	0x3e, r29	; 62
     ffa:	df 91       	pop	r29
     ffc:	cf 91       	pop	r28
     ffe:	1f 91       	pop	r17
    1000:	0f 91       	pop	r16
    1002:	ff 90       	pop	r15
    1004:	ef 90       	pop	r14
    1006:	df 90       	pop	r13
    1008:	cf 90       	pop	r12
    100a:	bf 90       	pop	r11
    100c:	af 90       	pop	r10
    100e:	08 95       	ret

00001010 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	00 d0       	rcall	.+0      	; 0x1016 <_ZN9task_user3runEv+0x6>
    1016:	00 d0       	rcall	.+0      	; 0x1018 <_ZN9task_user3runEv+0x8>
    1018:	cd b7       	in	r28, 0x3d	; 61
    101a:	de b7       	in	r29, 0x3e	; 62
    101c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    101e:	19 82       	std	Y+1, r1	; 0x01
    1020:	1a 82       	std	Y+2, r1	; 0x02
    1022:	1b 82       	std	Y+3, r1	; 0x03
    1024:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1026:	1d 82       	std	Y+5, r1	; 0x05
    1028:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    102a:	6a e0       	ldi	r22, 0x0A	; 10
    102c:	dc 01       	movw	r26, r24
    102e:	16 96       	adiw	r26, 0x06	; 6
    1030:	8d 91       	ld	r24, X+
    1032:	9c 91       	ld	r25, X
    1034:	17 97       	sbiw	r26, 0x07	; 7
    1036:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    103a:	7c 01       	movw	r14, r24
    103c:	62 e3       	ldi	r22, 0x32	; 50
    103e:	74 e0       	ldi	r23, 0x04	; 4
    1040:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    1044:	66 e0       	ldi	r22, 0x06	; 6
    1046:	c7 01       	movw	r24, r14
    1048:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    104c:	f8 01       	movw	r30, r16
    104e:	84 85       	ldd	r24, Z+12	; 0x0c
    1050:	88 23       	and	r24, r24
    1052:	21 f0       	breq	.+8      	; 0x105c <_ZN9task_user3runEv+0x4c>
    1054:	81 30       	cpi	r24, 0x01	; 1
    1056:	09 f4       	brne	.+2      	; 0x105a <_ZN9task_user3runEv+0x4a>
    1058:	5d c0       	rjmp	.+186    	; 0x1114 <_ZN9task_user3runEv+0x104>
    105a:	d8 c0       	rjmp	.+432    	; 0x120c <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    105c:	86 81       	ldd	r24, Z+6	; 0x06
    105e:	97 81       	ldd	r25, Z+7	; 0x07
    1060:	dc 01       	movw	r26, r24
    1062:	ed 91       	ld	r30, X+
    1064:	fc 91       	ld	r31, X
    1066:	04 80       	ldd	r0, Z+4	; 0x04
    1068:	f5 81       	ldd	r31, Z+5	; 0x05
    106a:	e0 2d       	mov	r30, r0
    106c:	19 95       	eicall
    106e:	88 23       	and	r24, r24
    1070:	a9 f1       	breq	.+106    	; 0x10dc <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1072:	f8 01       	movw	r30, r16
    1074:	86 81       	ldd	r24, Z+6	; 0x06
    1076:	97 81       	ldd	r25, Z+7	; 0x07
    1078:	dc 01       	movw	r26, r24
    107a:	ed 91       	ld	r30, X+
    107c:	fc 91       	ld	r31, X
    107e:	06 80       	ldd	r0, Z+6	; 0x06
    1080:	f7 81       	ldd	r31, Z+7	; 0x07
    1082:	e0 2d       	mov	r30, r0
    1084:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1086:	99 27       	eor	r25, r25
    1088:	81 30       	cpi	r24, 0x01	; 1
    108a:	91 05       	cpc	r25, r1
    108c:	f9 f0       	breq	.+62     	; 0x10cc <_ZN9task_user3runEv+0xbc>
    108e:	03 97       	sbiw	r24, 0x03	; 3
    1090:	09 f0       	breq	.+2      	; 0x1094 <_ZN9task_user3runEv+0x84>
    1092:	d8 c0       	rjmp	.+432    	; 0x1244 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1094:	6a e0       	ldi	r22, 0x0A	; 10
    1096:	f8 01       	movw	r30, r16
    1098:	86 81       	ldd	r24, Z+6	; 0x06
    109a:	97 81       	ldd	r25, Z+7	; 0x07
    109c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    10a0:	8c 01       	movw	r16, r24
    10a2:	64 e2       	ldi	r22, 0x24	; 36
    10a4:	74 e0       	ldi	r23, 0x04	; 4
    10a6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    10aa:	66 e0       	ldi	r22, 0x06	; 6
    10ac:	c8 01       	movw	r24, r16
    10ae:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10b2:	93 e0       	ldi	r25, 0x03	; 3
    10b4:	88 ed       	ldi	r24, 0xD8	; 216
    10b6:	08 b6       	in	r0, 0x38	; 56
    10b8:	18 be       	out	0x38, r1	; 56
    10ba:	84 bf       	out	0x34, r24	; 52
    10bc:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10c0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10c4:	81 fd       	sbrc	r24, 1
    10c6:	fc cf       	rjmp	.-8      	; 0x10c0 <_ZN9task_user3runEv+0xb0>
    10c8:	08 be       	out	0x38, r0	; 56
    10ca:	ff cf       	rjmp	.-2      	; 0x10ca <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10cc:	c8 01       	movw	r24, r16
    10ce:	0e 94 d5 06 	call	0xdaa	; 0xdaa <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10d2:	61 e0       	ldi	r22, 0x01	; 1
    10d4:	c8 01       	movw	r24, r16
    10d6:	0e 94 86 14 	call	0x290c	; 0x290c <_ZN8frt_task13transition_toEh>
							break;
    10da:	b4 c0       	rjmp	.+360    	; 0x1244 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10dc:	84 e4       	ldi	r24, 0x44	; 68
    10de:	91 e3       	ldi	r25, 0x31	; 49
    10e0:	0e 94 47 17 	call	0x2e8e	; 0x2e8e <_ZN14frt_text_queue14check_for_charEv>
    10e4:	88 23       	and	r24, r24
    10e6:	09 f4       	brne	.+2      	; 0x10ea <_ZN9task_user3runEv+0xda>
    10e8:	ad c0       	rjmp	.+346    	; 0x1244 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    10ea:	d8 01       	movw	r26, r16
    10ec:	16 96       	adiw	r26, 0x06	; 6
    10ee:	ed 91       	ld	r30, X+
    10f0:	fc 91       	ld	r31, X
    10f2:	17 97       	sbiw	r26, 0x07	; 7
    10f4:	01 90       	ld	r0, Z+
    10f6:	f0 81       	ld	r31, Z
    10f8:	e0 2d       	mov	r30, r0
    10fa:	e2 80       	ldd	r14, Z+2	; 0x02
    10fc:	f3 80       	ldd	r15, Z+3	; 0x03
    10fe:	84 e4       	ldi	r24, 0x44	; 68
    1100:	91 e3       	ldi	r25, 0x31	; 49
    1102:	0e 94 29 17 	call	0x2e52	; 0x2e52 <_ZN14frt_text_queue7getcharEv>
    1106:	68 2f       	mov	r22, r24
    1108:	f8 01       	movw	r30, r16
    110a:	86 81       	ldd	r24, Z+6	; 0x06
    110c:	97 81       	ldd	r25, Z+7	; 0x07
    110e:	f7 01       	movw	r30, r14
    1110:	19 95       	eicall
    1112:	98 c0       	rjmp	.+304    	; 0x1244 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1114:	86 81       	ldd	r24, Z+6	; 0x06
    1116:	97 81       	ldd	r25, Z+7	; 0x07
    1118:	dc 01       	movw	r26, r24
    111a:	ed 91       	ld	r30, X+
    111c:	fc 91       	ld	r31, X
    111e:	04 80       	ldd	r0, Z+4	; 0x04
    1120:	f5 81       	ldd	r31, Z+5	; 0x05
    1122:	e0 2d       	mov	r30, r0
    1124:	19 95       	eicall
    1126:	88 23       	and	r24, r24
    1128:	09 f4       	brne	.+2      	; 0x112c <_ZN9task_user3runEv+0x11c>
    112a:	8c c0       	rjmp	.+280    	; 0x1244 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    112c:	f8 01       	movw	r30, r16
    112e:	86 81       	ldd	r24, Z+6	; 0x06
    1130:	97 81       	ldd	r25, Z+7	; 0x07
    1132:	dc 01       	movw	r26, r24
    1134:	ed 91       	ld	r30, X+
    1136:	fc 91       	ld	r31, X
    1138:	06 80       	ldd	r0, Z+6	; 0x06
    113a:	f7 81       	ldd	r31, Z+7	; 0x07
    113c:	e0 2d       	mov	r30, r0
    113e:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1140:	9c 01       	movw	r18, r24
    1142:	33 27       	eor	r19, r19
    1144:	28 36       	cpi	r18, 0x68	; 104
    1146:	31 05       	cpc	r19, r1
    1148:	59 f1       	breq	.+86     	; 0x11a0 <_ZN9task_user3runEv+0x190>
    114a:	3c f4       	brge	.+14     	; 0x115a <_ZN9task_user3runEv+0x14a>
    114c:	2b 31       	cpi	r18, 0x1B	; 27
    114e:	31 05       	cpc	r19, r1
    1150:	59 f1       	breq	.+86     	; 0x11a8 <_ZN9task_user3runEv+0x198>
    1152:	25 36       	cpi	r18, 0x65	; 101
    1154:	31 05       	cpc	r19, r1
    1156:	41 f1       	breq	.+80     	; 0x11a8 <_ZN9task_user3runEv+0x198>
    1158:	3b c0       	rjmp	.+118    	; 0x11d0 <_ZN9task_user3runEv+0x1c0>
    115a:	23 37       	cpi	r18, 0x73	; 115
    115c:	31 05       	cpc	r19, r1
    115e:	c1 f0       	breq	.+48     	; 0x1190 <_ZN9task_user3runEv+0x180>
    1160:	26 37       	cpi	r18, 0x76	; 118
    1162:	31 05       	cpc	r19, r1
    1164:	89 f0       	breq	.+34     	; 0x1188 <_ZN9task_user3runEv+0x178>
    1166:	2e 36       	cpi	r18, 0x6E	; 110
    1168:	31 05       	cpc	r19, r1
    116a:	91 f5       	brne	.+100    	; 0x11d0 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    116c:	ce 01       	movw	r24, r28
    116e:	01 96       	adiw	r24, 0x01	; 1
    1170:	0e 94 3b 18 	call	0x3076	; 0x3076 <_ZN10time_stamp10set_to_nowEv>
    1174:	bc 01       	movw	r22, r24
    1176:	f8 01       	movw	r30, r16
    1178:	86 81       	ldd	r24, Z+6	; 0x06
    117a:	97 81       	ldd	r25, Z+7	; 0x07
    117c:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_ZlsR8emstreamR10time_stamp>
    1180:	66 e0       	ldi	r22, 0x06	; 6
    1182:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
							break;
    1186:	5e c0       	rjmp	.+188    	; 0x1244 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1188:	c8 01       	movw	r24, r16
    118a:	0e 94 7d 07 	call	0xefa	; 0xefa <_ZN9task_user11show_statusEv>
							break;
    118e:	5a c0       	rjmp	.+180    	; 0x1244 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1190:	d8 01       	movw	r26, r16
    1192:	16 96       	adiw	r26, 0x06	; 6
    1194:	8d 91       	ld	r24, X+
    1196:	9c 91       	ld	r25, X
    1198:	17 97       	sbiw	r26, 0x07	; 7
    119a:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <_Z17print_task_stacksP8emstream>
							break;
    119e:	52 c0       	rjmp	.+164    	; 0x1244 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    11a0:	c8 01       	movw	r24, r16
    11a2:	0e 94 d5 06 	call	0xdaa	; 0xdaa <_ZN9task_user18print_help_messageEv>
							break;
    11a6:	4e c0       	rjmp	.+156    	; 0x1244 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    11a8:	6a e0       	ldi	r22, 0x0A	; 10
    11aa:	f8 01       	movw	r30, r16
    11ac:	86 81       	ldd	r24, Z+6	; 0x06
    11ae:	97 81       	ldd	r25, Z+7	; 0x07
    11b0:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    11b4:	7c 01       	movw	r14, r24
    11b6:	62 e1       	ldi	r22, 0x12	; 18
    11b8:	74 e0       	ldi	r23, 0x04	; 4
    11ba:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    11be:	66 e0       	ldi	r22, 0x06	; 6
    11c0:	c7 01       	movw	r24, r14
    11c2:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11c6:	60 e0       	ldi	r22, 0x00	; 0
    11c8:	c8 01       	movw	r24, r16
    11ca:	0e 94 86 14 	call	0x290c	; 0x290c <_ZN8frt_task13transition_toEh>
							break;
    11ce:	3a c0       	rjmp	.+116    	; 0x1244 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11d0:	f8 01       	movw	r30, r16
    11d2:	a6 81       	ldd	r26, Z+6	; 0x06
    11d4:	b7 81       	ldd	r27, Z+7	; 0x07
    11d6:	ed 91       	ld	r30, X+
    11d8:	fc 91       	ld	r31, X
    11da:	11 97       	sbiw	r26, 0x01	; 1
    11dc:	02 80       	ldd	r0, Z+2	; 0x02
    11de:	f3 81       	ldd	r31, Z+3	; 0x03
    11e0:	e0 2d       	mov	r30, r0
    11e2:	68 2f       	mov	r22, r24
    11e4:	cd 01       	movw	r24, r26
    11e6:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    11e8:	6a e0       	ldi	r22, 0x0A	; 10
    11ea:	d8 01       	movw	r26, r16
    11ec:	16 96       	adiw	r26, 0x06	; 6
    11ee:	8d 91       	ld	r24, X+
    11f0:	9c 91       	ld	r25, X
    11f2:	17 97       	sbiw	r26, 0x07	; 7
    11f4:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    11f8:	7c 01       	movw	r14, r24
    11fa:	6c e0       	ldi	r22, 0x0C	; 12
    11fc:	74 e0       	ldi	r23, 0x04	; 4
    11fe:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    1202:	66 e0       	ldi	r22, 0x06	; 6
    1204:	c7 01       	movw	r24, r14
    1206:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
							break;
    120a:	1c c0       	rjmp	.+56     	; 0x1244 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    120c:	6a e0       	ldi	r22, 0x0A	; 10
    120e:	f8 01       	movw	r30, r16
    1210:	86 81       	ldd	r24, Z+6	; 0x06
    1212:	97 81       	ldd	r25, Z+7	; 0x07
    1214:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    1218:	8c 01       	movw	r16, r24
    121a:	6f ee       	ldi	r22, 0xEF	; 239
    121c:	73 e0       	ldi	r23, 0x03	; 3
    121e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    1222:	66 e0       	ldi	r22, 0x06	; 6
    1224:	c8 01       	movw	r24, r16
    1226:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    122a:	93 e0       	ldi	r25, 0x03	; 3
    122c:	88 ed       	ldi	r24, 0xD8	; 216
    122e:	08 b6       	in	r0, 0x38	; 56
    1230:	18 be       	out	0x38, r1	; 56
    1232:	84 bf       	out	0x34, r24	; 52
    1234:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1238:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    123c:	81 fd       	sbrc	r24, 1
    123e:	fc cf       	rjmp	.-8      	; 0x1238 <_ZN9task_user3runEv+0x228>
    1240:	08 be       	out	0x38, r0	; 56
    1242:	ff cf       	rjmp	.-2      	; 0x1242 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1244:	f8 01       	movw	r30, r16
    1246:	86 85       	ldd	r24, Z+14	; 0x0e
    1248:	97 85       	ldd	r25, Z+15	; 0x0f
    124a:	a0 89       	ldd	r26, Z+16	; 0x10
    124c:	b1 89       	ldd	r27, Z+17	; 0x11
    124e:	01 96       	adiw	r24, 0x01	; 1
    1250:	a1 1d       	adc	r26, r1
    1252:	b1 1d       	adc	r27, r1
    1254:	86 87       	std	Z+14, r24	; 0x0e
    1256:	97 87       	std	Z+15, r25	; 0x0f
    1258:	a0 8b       	std	Z+16, r26	; 0x10
    125a:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    125c:	61 e0       	ldi	r22, 0x01	; 1
    125e:	70 e0       	ldi	r23, 0x00	; 0
    1260:	80 e0       	ldi	r24, 0x00	; 0
    1262:	90 e0       	ldi	r25, 0x00	; 0
    1264:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1268:	f1 ce       	rjmp	.-542    	; 0x104c <_ZN9task_user3runEv+0x3c>

0000126a <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    126a:	0f 93       	push	r16
    126c:	1f 93       	push	r17
    126e:	cf 93       	push	r28
    1270:	df 93       	push	r29
    1272:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1274:	0e 94 49 10 	call	0x2092	; 0x2092 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1278:	80 91 b0 20 	lds	r24, 0x20B0	; 0x8020b0 <__data_end>
    127c:	81 11       	cpse	r24, r1
    127e:	1d c0       	rjmp	.+58     	; 0x12ba <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1280:	a5 eb       	ldi	r26, 0xB5	; 181
    1282:	b0 e2       	ldi	r27, 0x20	; 32
    1284:	e9 eb       	ldi	r30, 0xB9	; 185
    1286:	f0 e2       	ldi	r31, 0x20	; 32
    1288:	ed 93       	st	X+, r30
    128a:	fc 93       	st	X, r31
    128c:	11 97       	sbiw	r26, 0x01	; 1
    128e:	12 96       	adiw	r26, 0x02	; 2
    1290:	1d 92       	st	X+, r1
    1292:	1c 92       	st	X, r1
    1294:	13 97       	sbiw	r26, 0x03	; 3
    1296:	a1 eb       	ldi	r26, 0xB1	; 177
    1298:	b0 e2       	ldi	r27, 0x20	; 32
    129a:	8f ef       	ldi	r24, 0xFF	; 255
    129c:	9f e0       	ldi	r25, 0x0F	; 15
    129e:	12 96       	adiw	r26, 0x02	; 2
    12a0:	8d 93       	st	X+, r24
    12a2:	9c 93       	st	X, r25
    12a4:	13 97       	sbiw	r26, 0x03	; 3
    12a6:	1d 92       	st	X+, r1
    12a8:	1c 92       	st	X, r1
    12aa:	11 97       	sbiw	r26, 0x01	; 1
    12ac:	82 83       	std	Z+2, r24	; 0x02
    12ae:	93 83       	std	Z+3, r25	; 0x03
    12b0:	a0 83       	st	Z, r26
    12b2:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    12b4:	81 e0       	ldi	r24, 0x01	; 1
    12b6:	80 93 b0 20 	sts	0x20B0, r24	; 0x8020b0 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12ba:	20 97       	sbiw	r28, 0x00	; 0
    12bc:	09 f4       	brne	.+2      	; 0x12c0 <pvPortMalloc+0x56>
    12be:	5f c0       	rjmp	.+190    	; 0x137e <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12c0:	9e 01       	movw	r18, r28
    12c2:	2b 5f       	subi	r18, 0xFB	; 251
    12c4:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    12c6:	24 96       	adiw	r28, 0x04	; 4
    12c8:	ce 3f       	cpi	r28, 0xFE	; 254
    12ca:	df 40       	sbci	r29, 0x0F	; 15
    12cc:	08 f0       	brcs	.+2      	; 0x12d0 <pvPortMalloc+0x66>
    12ce:	5a c0       	rjmp	.+180    	; 0x1384 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    12d0:	e0 91 b5 20 	lds	r30, 0x20B5	; 0x8020b5 <xStart>
    12d4:	f0 91 b6 20 	lds	r31, 0x20B6	; 0x8020b6 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    12d8:	a5 eb       	ldi	r26, 0xB5	; 181
    12da:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12dc:	02 c0       	rjmp	.+4      	; 0x12e2 <pvPortMalloc+0x78>
    12de:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    12e0:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12e2:	82 81       	ldd	r24, Z+2	; 0x02
    12e4:	93 81       	ldd	r25, Z+3	; 0x03
    12e6:	82 17       	cp	r24, r18
    12e8:	93 07       	cpc	r25, r19
    12ea:	20 f4       	brcc	.+8      	; 0x12f4 <pvPortMalloc+0x8a>
    12ec:	80 81       	ld	r24, Z
    12ee:	91 81       	ldd	r25, Z+1	; 0x01
    12f0:	00 97       	sbiw	r24, 0x00	; 0
    12f2:	a9 f7       	brne	.-22     	; 0x12de <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    12f4:	c0 e2       	ldi	r28, 0x20	; 32
    12f6:	e1 3b       	cpi	r30, 0xB1	; 177
    12f8:	fc 07       	cpc	r31, r28
    12fa:	09 f4       	brne	.+2      	; 0x12fe <pvPortMalloc+0x94>
    12fc:	46 c0       	rjmp	.+140    	; 0x138a <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    12fe:	cd 91       	ld	r28, X+
    1300:	dc 91       	ld	r29, X
    1302:	11 97       	sbiw	r26, 0x01	; 1
    1304:	8e 01       	movw	r16, r28
    1306:	0b 5f       	subi	r16, 0xFB	; 251
    1308:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    130a:	80 81       	ld	r24, Z
    130c:	91 81       	ldd	r25, Z+1	; 0x01
    130e:	8d 93       	st	X+, r24
    1310:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1312:	82 81       	ldd	r24, Z+2	; 0x02
    1314:	93 81       	ldd	r25, Z+3	; 0x03
    1316:	82 1b       	sub	r24, r18
    1318:	93 0b       	sbc	r25, r19
    131a:	8b 30       	cpi	r24, 0x0B	; 11
    131c:	91 05       	cpc	r25, r1
    131e:	10 f1       	brcs	.+68     	; 0x1364 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1320:	bf 01       	movw	r22, r30
    1322:	62 0f       	add	r22, r18
    1324:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1326:	db 01       	movw	r26, r22
    1328:	12 96       	adiw	r26, 0x02	; 2
    132a:	8d 93       	st	X+, r24
    132c:	9c 93       	st	X, r25
    132e:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1330:	22 83       	std	Z+2, r18	; 0x02
    1332:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1334:	12 96       	adiw	r26, 0x02	; 2
    1336:	4d 91       	ld	r20, X+
    1338:	5c 91       	ld	r21, X
    133a:	13 97       	sbiw	r26, 0x03	; 3
    133c:	85 eb       	ldi	r24, 0xB5	; 181
    133e:	90 e2       	ldi	r25, 0x20	; 32
    1340:	01 c0       	rjmp	.+2      	; 0x1344 <pvPortMalloc+0xda>
    1342:	cd 01       	movw	r24, r26
    1344:	ec 01       	movw	r28, r24
    1346:	a8 81       	ld	r26, Y
    1348:	b9 81       	ldd	r27, Y+1	; 0x01
    134a:	12 96       	adiw	r26, 0x02	; 2
    134c:	2d 91       	ld	r18, X+
    134e:	3c 91       	ld	r19, X
    1350:	13 97       	sbiw	r26, 0x03	; 3
    1352:	24 17       	cp	r18, r20
    1354:	35 07       	cpc	r19, r21
    1356:	a8 f3       	brcs	.-22     	; 0x1342 <pvPortMalloc+0xd8>
    1358:	eb 01       	movw	r28, r22
    135a:	a8 83       	st	Y, r26
    135c:	b9 83       	std	Y+1, r27	; 0x01
    135e:	dc 01       	movw	r26, r24
    1360:	6d 93       	st	X+, r22
    1362:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1364:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1368:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    136c:	22 81       	ldd	r18, Z+2	; 0x02
    136e:	33 81       	ldd	r19, Z+3	; 0x03
    1370:	82 1b       	sub	r24, r18
    1372:	93 0b       	sbc	r25, r19
    1374:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1378:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    137c:	08 c0       	rjmp	.+16     	; 0x138e <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    137e:	00 e0       	ldi	r16, 0x00	; 0
    1380:	10 e0       	ldi	r17, 0x00	; 0
    1382:	05 c0       	rjmp	.+10     	; 0x138e <pvPortMalloc+0x124>
    1384:	00 e0       	ldi	r16, 0x00	; 0
    1386:	10 e0       	ldi	r17, 0x00	; 0
    1388:	02 c0       	rjmp	.+4      	; 0x138e <pvPortMalloc+0x124>
    138a:	00 e0       	ldi	r16, 0x00	; 0
    138c:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    138e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1392:	c8 01       	movw	r24, r16
    1394:	df 91       	pop	r29
    1396:	cf 91       	pop	r28
    1398:	1f 91       	pop	r17
    139a:	0f 91       	pop	r16
    139c:	08 95       	ret

0000139e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    139e:	0f 93       	push	r16
    13a0:	1f 93       	push	r17
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    13a6:	00 97       	sbiw	r24, 0x00	; 0
    13a8:	41 f1       	breq	.+80     	; 0x13fa <vPortFree+0x5c>
    13aa:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    13ac:	8c 01       	movw	r16, r24
    13ae:	05 50       	subi	r16, 0x05	; 5
    13b0:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    13b2:	0e 94 49 10 	call	0x2092	; 0x2092 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    13b6:	f8 01       	movw	r30, r16
    13b8:	42 81       	ldd	r20, Z+2	; 0x02
    13ba:	53 81       	ldd	r21, Z+3	; 0x03
    13bc:	a5 eb       	ldi	r26, 0xB5	; 181
    13be:	b0 e2       	ldi	r27, 0x20	; 32
    13c0:	01 c0       	rjmp	.+2      	; 0x13c4 <vPortFree+0x26>
    13c2:	df 01       	movw	r26, r30
    13c4:	ed 91       	ld	r30, X+
    13c6:	fc 91       	ld	r31, X
    13c8:	11 97       	sbiw	r26, 0x01	; 1
    13ca:	22 81       	ldd	r18, Z+2	; 0x02
    13cc:	33 81       	ldd	r19, Z+3	; 0x03
    13ce:	24 17       	cp	r18, r20
    13d0:	35 07       	cpc	r19, r21
    13d2:	b8 f3       	brcs	.-18     	; 0x13c2 <vPortFree+0x24>
    13d4:	25 97       	sbiw	r28, 0x05	; 5
    13d6:	e8 83       	st	Y, r30
    13d8:	f9 83       	std	Y+1, r31	; 0x01
    13da:	0d 93       	st	X+, r16
    13dc:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    13de:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    13e2:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    13e6:	8a 81       	ldd	r24, Y+2	; 0x02
    13e8:	9b 81       	ldd	r25, Y+3	; 0x03
    13ea:	82 0f       	add	r24, r18
    13ec:	93 1f       	adc	r25, r19
    13ee:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    13f2:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    13f6:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
	}
}
    13fa:	df 91       	pop	r29
    13fc:	cf 91       	pop	r28
    13fe:	1f 91       	pop	r17
    1400:	0f 91       	pop	r16
    1402:	08 95       	ret

00001404 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1404:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1408:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    140c:	08 95       	ret

0000140e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    140e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1410:	03 96       	adiw	r24, 0x03	; 3
    1412:	81 83       	std	Z+1, r24	; 0x01
    1414:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1416:	4f ef       	ldi	r20, 0xFF	; 255
    1418:	5f ef       	ldi	r21, 0xFF	; 255
    141a:	ba 01       	movw	r22, r20
    141c:	43 83       	std	Z+3, r20	; 0x03
    141e:	54 83       	std	Z+4, r21	; 0x04
    1420:	65 83       	std	Z+5, r22	; 0x05
    1422:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1424:	87 83       	std	Z+7, r24	; 0x07
    1426:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1428:	81 87       	std	Z+9, r24	; 0x09
    142a:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    142c:	10 82       	st	Z, r1
    142e:	08 95       	ret

00001430 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1430:	fc 01       	movw	r30, r24
    1432:	12 86       	std	Z+10, r1	; 0x0a
    1434:	13 86       	std	Z+11, r1	; 0x0b
    1436:	08 95       	ret

00001438 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
    143c:	fc 01       	movw	r30, r24
    143e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1440:	21 81       	ldd	r18, Z+1	; 0x01
    1442:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1444:	e9 01       	movw	r28, r18
    1446:	8c 81       	ldd	r24, Y+4	; 0x04
    1448:	9d 81       	ldd	r25, Y+5	; 0x05
    144a:	14 96       	adiw	r26, 0x04	; 4
    144c:	8d 93       	st	X+, r24
    144e:	9c 93       	st	X, r25
    1450:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1452:	81 81       	ldd	r24, Z+1	; 0x01
    1454:	92 81       	ldd	r25, Z+2	; 0x02
    1456:	16 96       	adiw	r26, 0x06	; 6
    1458:	8d 93       	st	X+, r24
    145a:	9c 93       	st	X, r25
    145c:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    145e:	8c 81       	ldd	r24, Y+4	; 0x04
    1460:	9d 81       	ldd	r25, Y+5	; 0x05
    1462:	ec 01       	movw	r28, r24
    1464:	6e 83       	std	Y+6, r22	; 0x06
    1466:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1468:	e9 01       	movw	r28, r18
    146a:	6c 83       	std	Y+4, r22	; 0x04
    146c:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    146e:	61 83       	std	Z+1, r22	; 0x01
    1470:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1472:	1a 96       	adiw	r26, 0x0a	; 10
    1474:	ed 93       	st	X+, r30
    1476:	fc 93       	st	X, r31
    1478:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    147a:	80 81       	ld	r24, Z
    147c:	8f 5f       	subi	r24, 0xFF	; 255
    147e:	80 83       	st	Z, r24
}
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	08 95       	ret

00001486 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1486:	0f 93       	push	r16
    1488:	1f 93       	push	r17
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1490:	08 81       	ld	r16, Y
    1492:	19 81       	ldd	r17, Y+1	; 0x01
    1494:	2a 81       	ldd	r18, Y+2	; 0x02
    1496:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1498:	0f 3f       	cpi	r16, 0xFF	; 255
    149a:	4f ef       	ldi	r20, 0xFF	; 255
    149c:	14 07       	cpc	r17, r20
    149e:	24 07       	cpc	r18, r20
    14a0:	34 07       	cpc	r19, r20
    14a2:	31 f4       	brne	.+12     	; 0x14b0 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14a4:	dc 01       	movw	r26, r24
    14a6:	19 96       	adiw	r26, 0x09	; 9
    14a8:	ed 91       	ld	r30, X+
    14aa:	fc 91       	ld	r31, X
    14ac:	1a 97       	sbiw	r26, 0x0a	; 10
    14ae:	1f c0       	rjmp	.+62     	; 0x14ee <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14b0:	fc 01       	movw	r30, r24
    14b2:	33 96       	adiw	r30, 0x03	; 3
    14b4:	dc 01       	movw	r26, r24
    14b6:	17 96       	adiw	r26, 0x07	; 7
    14b8:	4d 91       	ld	r20, X+
    14ba:	5c 91       	ld	r21, X
    14bc:	18 97       	sbiw	r26, 0x08	; 8
    14be:	da 01       	movw	r26, r20
    14c0:	4d 91       	ld	r20, X+
    14c2:	5d 91       	ld	r21, X+
    14c4:	6d 91       	ld	r22, X+
    14c6:	7c 91       	ld	r23, X
    14c8:	04 17       	cp	r16, r20
    14ca:	15 07       	cpc	r17, r21
    14cc:	26 07       	cpc	r18, r22
    14ce:	37 07       	cpc	r19, r23
    14d0:	70 f0       	brcs	.+28     	; 0x14ee <vListInsert+0x68>
    14d2:	04 80       	ldd	r0, Z+4	; 0x04
    14d4:	f5 81       	ldd	r31, Z+5	; 0x05
    14d6:	e0 2d       	mov	r30, r0
    14d8:	a4 81       	ldd	r26, Z+4	; 0x04
    14da:	b5 81       	ldd	r27, Z+5	; 0x05
    14dc:	4d 91       	ld	r20, X+
    14de:	5d 91       	ld	r21, X+
    14e0:	6d 91       	ld	r22, X+
    14e2:	7c 91       	ld	r23, X
    14e4:	04 17       	cp	r16, r20
    14e6:	15 07       	cpc	r17, r21
    14e8:	26 07       	cpc	r18, r22
    14ea:	37 07       	cpc	r19, r23
    14ec:	90 f7       	brcc	.-28     	; 0x14d2 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    14ee:	a4 81       	ldd	r26, Z+4	; 0x04
    14f0:	b5 81       	ldd	r27, Z+5	; 0x05
    14f2:	ac 83       	std	Y+4, r26	; 0x04
    14f4:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    14f6:	16 96       	adiw	r26, 0x06	; 6
    14f8:	cd 93       	st	X+, r28
    14fa:	dc 93       	st	X, r29
    14fc:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    14fe:	ee 83       	std	Y+6, r30	; 0x06
    1500:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1502:	c4 83       	std	Z+4, r28	; 0x04
    1504:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1506:	8a 87       	std	Y+10, r24	; 0x0a
    1508:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    150a:	fc 01       	movw	r30, r24
    150c:	20 81       	ld	r18, Z
    150e:	2f 5f       	subi	r18, 0xFF	; 255
    1510:	20 83       	st	Z, r18
}
    1512:	df 91       	pop	r29
    1514:	cf 91       	pop	r28
    1516:	1f 91       	pop	r17
    1518:	0f 91       	pop	r16
    151a:	08 95       	ret

0000151c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    151c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    151e:	a4 81       	ldd	r26, Z+4	; 0x04
    1520:	b5 81       	ldd	r27, Z+5	; 0x05
    1522:	86 81       	ldd	r24, Z+6	; 0x06
    1524:	97 81       	ldd	r25, Z+7	; 0x07
    1526:	16 96       	adiw	r26, 0x06	; 6
    1528:	8d 93       	st	X+, r24
    152a:	9c 93       	st	X, r25
    152c:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    152e:	a6 81       	ldd	r26, Z+6	; 0x06
    1530:	b7 81       	ldd	r27, Z+7	; 0x07
    1532:	84 81       	ldd	r24, Z+4	; 0x04
    1534:	95 81       	ldd	r25, Z+5	; 0x05
    1536:	14 96       	adiw	r26, 0x04	; 4
    1538:	8d 93       	st	X+, r24
    153a:	9c 93       	st	X, r25
    153c:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    153e:	a2 85       	ldd	r26, Z+10	; 0x0a
    1540:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1542:	11 96       	adiw	r26, 0x01	; 1
    1544:	8d 91       	ld	r24, X+
    1546:	9c 91       	ld	r25, X
    1548:	12 97       	sbiw	r26, 0x02	; 2
    154a:	e8 17       	cp	r30, r24
    154c:	f9 07       	cpc	r31, r25
    154e:	31 f4       	brne	.+12     	; 0x155c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1550:	86 81       	ldd	r24, Z+6	; 0x06
    1552:	97 81       	ldd	r25, Z+7	; 0x07
    1554:	11 96       	adiw	r26, 0x01	; 1
    1556:	8d 93       	st	X+, r24
    1558:	9c 93       	st	X, r25
    155a:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    155c:	12 86       	std	Z+10, r1	; 0x0a
    155e:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1560:	8c 91       	ld	r24, X
    1562:	81 50       	subi	r24, 0x01	; 1
    1564:	8c 93       	st	X, r24
    1566:	08 95       	ret

00001568 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1568:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <portStackTopForTask>
    156c:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <portStackTopForTask+0x1>
    1570:	31 e1       	ldi	r19, 0x11	; 17
    1572:	fc 01       	movw	r30, r24
    1574:	30 83       	st	Z, r19
    1576:	31 97       	sbiw	r30, 0x01	; 1
    1578:	22 e2       	ldi	r18, 0x22	; 34
    157a:	20 83       	st	Z, r18
    157c:	31 97       	sbiw	r30, 0x01	; 1
    157e:	a3 e3       	ldi	r26, 0x33	; 51
    1580:	a0 83       	st	Z, r26
    1582:	31 97       	sbiw	r30, 0x01	; 1
    1584:	60 83       	st	Z, r22
    1586:	31 97       	sbiw	r30, 0x01	; 1
    1588:	70 83       	st	Z, r23
    158a:	31 97       	sbiw	r30, 0x01	; 1
    158c:	10 82       	st	Z, r1
    158e:	31 97       	sbiw	r30, 0x01	; 1
    1590:	10 82       	st	Z, r1
    1592:	31 97       	sbiw	r30, 0x01	; 1
    1594:	60 e8       	ldi	r22, 0x80	; 128
    1596:	60 83       	st	Z, r22
    1598:	31 97       	sbiw	r30, 0x01	; 1
    159a:	10 82       	st	Z, r1
    159c:	31 97       	sbiw	r30, 0x01	; 1
    159e:	10 82       	st	Z, r1
    15a0:	31 97       	sbiw	r30, 0x01	; 1
    15a2:	10 82       	st	Z, r1
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	62 e0       	ldi	r22, 0x02	; 2
    15a8:	60 83       	st	Z, r22
    15aa:	31 97       	sbiw	r30, 0x01	; 1
    15ac:	63 e0       	ldi	r22, 0x03	; 3
    15ae:	60 83       	st	Z, r22
    15b0:	31 97       	sbiw	r30, 0x01	; 1
    15b2:	64 e0       	ldi	r22, 0x04	; 4
    15b4:	60 83       	st	Z, r22
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	65 e0       	ldi	r22, 0x05	; 5
    15ba:	60 83       	st	Z, r22
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	66 e0       	ldi	r22, 0x06	; 6
    15c0:	60 83       	st	Z, r22
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	67 e0       	ldi	r22, 0x07	; 7
    15c6:	60 83       	st	Z, r22
    15c8:	31 97       	sbiw	r30, 0x01	; 1
    15ca:	68 e0       	ldi	r22, 0x08	; 8
    15cc:	60 83       	st	Z, r22
    15ce:	31 97       	sbiw	r30, 0x01	; 1
    15d0:	69 e0       	ldi	r22, 0x09	; 9
    15d2:	60 83       	st	Z, r22
    15d4:	31 97       	sbiw	r30, 0x01	; 1
    15d6:	60 e1       	ldi	r22, 0x10	; 16
    15d8:	60 83       	st	Z, r22
    15da:	31 97       	sbiw	r30, 0x01	; 1
    15dc:	30 83       	st	Z, r19
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	32 e1       	ldi	r19, 0x12	; 18
    15e2:	30 83       	st	Z, r19
    15e4:	31 97       	sbiw	r30, 0x01	; 1
    15e6:	33 e1       	ldi	r19, 0x13	; 19
    15e8:	30 83       	st	Z, r19
    15ea:	31 97       	sbiw	r30, 0x01	; 1
    15ec:	34 e1       	ldi	r19, 0x14	; 20
    15ee:	30 83       	st	Z, r19
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	35 e1       	ldi	r19, 0x15	; 21
    15f4:	30 83       	st	Z, r19
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	36 e1       	ldi	r19, 0x16	; 22
    15fa:	30 83       	st	Z, r19
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	37 e1       	ldi	r19, 0x17	; 23
    1600:	30 83       	st	Z, r19
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	38 e1       	ldi	r19, 0x18	; 24
    1606:	30 83       	st	Z, r19
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	39 e1       	ldi	r19, 0x19	; 25
    160c:	30 83       	st	Z, r19
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	30 e2       	ldi	r19, 0x20	; 32
    1612:	30 83       	st	Z, r19
    1614:	31 97       	sbiw	r30, 0x01	; 1
    1616:	31 e2       	ldi	r19, 0x21	; 33
    1618:	30 83       	st	Z, r19
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	20 83       	st	Z, r18
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	23 e2       	ldi	r18, 0x23	; 35
    1622:	20 83       	st	Z, r18
    1624:	31 97       	sbiw	r30, 0x01	; 1
    1626:	40 83       	st	Z, r20
    1628:	31 97       	sbiw	r30, 0x01	; 1
    162a:	50 83       	st	Z, r21
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	26 e2       	ldi	r18, 0x26	; 38
    1630:	20 83       	st	Z, r18
    1632:	31 97       	sbiw	r30, 0x01	; 1
    1634:	27 e2       	ldi	r18, 0x27	; 39
    1636:	20 83       	st	Z, r18
    1638:	31 97       	sbiw	r30, 0x01	; 1
    163a:	28 e2       	ldi	r18, 0x28	; 40
    163c:	20 83       	st	Z, r18
    163e:	31 97       	sbiw	r30, 0x01	; 1
    1640:	29 e2       	ldi	r18, 0x29	; 41
    1642:	20 83       	st	Z, r18
    1644:	31 97       	sbiw	r30, 0x01	; 1
    1646:	20 e3       	ldi	r18, 0x30	; 48
    1648:	20 83       	st	Z, r18
    164a:	31 97       	sbiw	r30, 0x01	; 1
    164c:	21 e3       	ldi	r18, 0x31	; 49
    164e:	20 83       	st	Z, r18
    1650:	89 97       	sbiw	r24, 0x29	; 41
    1652:	08 95       	ret

00001654 <xPortStartScheduler>:
    1654:	8c e7       	ldi	r24, 0x7C	; 124
    1656:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    165a:	8f ef       	ldi	r24, 0xFF	; 255
    165c:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1660:	81 e0       	ldi	r24, 0x01	; 1
    1662:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1666:	91 e1       	ldi	r25, 0x11	; 17
    1668:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    166c:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1670:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1674:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1678:	cd 91       	ld	r28, X+
    167a:	cd bf       	out	0x3d, r28	; 61
    167c:	dd 91       	ld	r29, X+
    167e:	de bf       	out	0x3e, r29	; 62
    1680:	ff 91       	pop	r31
    1682:	ef 91       	pop	r30
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
    1688:	bf 91       	pop	r27
    168a:	af 91       	pop	r26
    168c:	9f 91       	pop	r25
    168e:	8f 91       	pop	r24
    1690:	7f 91       	pop	r23
    1692:	6f 91       	pop	r22
    1694:	5f 91       	pop	r21
    1696:	4f 91       	pop	r20
    1698:	3f 91       	pop	r19
    169a:	2f 91       	pop	r18
    169c:	1f 91       	pop	r17
    169e:	0f 91       	pop	r16
    16a0:	ff 90       	pop	r15
    16a2:	ef 90       	pop	r14
    16a4:	df 90       	pop	r13
    16a6:	cf 90       	pop	r12
    16a8:	bf 90       	pop	r11
    16aa:	af 90       	pop	r10
    16ac:	9f 90       	pop	r9
    16ae:	8f 90       	pop	r8
    16b0:	7f 90       	pop	r7
    16b2:	6f 90       	pop	r6
    16b4:	5f 90       	pop	r5
    16b6:	4f 90       	pop	r4
    16b8:	3f 90       	pop	r3
    16ba:	2f 90       	pop	r2
    16bc:	1f 90       	pop	r1
    16be:	0f 90       	pop	r0
    16c0:	0c be       	out	0x3c, r0	; 60
    16c2:	0f 90       	pop	r0
    16c4:	0b be       	out	0x3b, r0	; 59
    16c6:	0f 90       	pop	r0
    16c8:	0f be       	out	0x3f, r0	; 63
    16ca:	0f 90       	pop	r0
    16cc:	08 95       	ret
    16ce:	08 95       	ret

000016d0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16d0:	0f 92       	push	r0
    16d2:	0f b6       	in	r0, 0x3f	; 63
    16d4:	f8 94       	cli
    16d6:	0f 92       	push	r0
    16d8:	0b b6       	in	r0, 0x3b	; 59
    16da:	0f 92       	push	r0
    16dc:	0c b6       	in	r0, 0x3c	; 60
    16de:	0f 92       	push	r0
    16e0:	1f 92       	push	r1
    16e2:	11 24       	eor	r1, r1
    16e4:	2f 92       	push	r2
    16e6:	3f 92       	push	r3
    16e8:	4f 92       	push	r4
    16ea:	5f 92       	push	r5
    16ec:	6f 92       	push	r6
    16ee:	7f 92       	push	r7
    16f0:	8f 92       	push	r8
    16f2:	9f 92       	push	r9
    16f4:	af 92       	push	r10
    16f6:	bf 92       	push	r11
    16f8:	cf 92       	push	r12
    16fa:	df 92       	push	r13
    16fc:	ef 92       	push	r14
    16fe:	ff 92       	push	r15
    1700:	0f 93       	push	r16
    1702:	1f 93       	push	r17
    1704:	2f 93       	push	r18
    1706:	3f 93       	push	r19
    1708:	4f 93       	push	r20
    170a:	5f 93       	push	r21
    170c:	6f 93       	push	r22
    170e:	7f 93       	push	r23
    1710:	8f 93       	push	r24
    1712:	9f 93       	push	r25
    1714:	af 93       	push	r26
    1716:	bf 93       	push	r27
    1718:	cf 93       	push	r28
    171a:	df 93       	push	r29
    171c:	ef 93       	push	r30
    171e:	ff 93       	push	r31
    1720:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1724:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1728:	0d b6       	in	r0, 0x3d	; 61
    172a:	0d 92       	st	X+, r0
    172c:	0e b6       	in	r0, 0x3e	; 62
    172e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1730:	0e 94 88 12 	call	0x2510	; 0x2510 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1734:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1738:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    173c:	cd 91       	ld	r28, X+
    173e:	cd bf       	out	0x3d, r28	; 61
    1740:	dd 91       	ld	r29, X+
    1742:	de bf       	out	0x3e, r29	; 62
    1744:	ff 91       	pop	r31
    1746:	ef 91       	pop	r30
    1748:	df 91       	pop	r29
    174a:	cf 91       	pop	r28
    174c:	bf 91       	pop	r27
    174e:	af 91       	pop	r26
    1750:	9f 91       	pop	r25
    1752:	8f 91       	pop	r24
    1754:	7f 91       	pop	r23
    1756:	6f 91       	pop	r22
    1758:	5f 91       	pop	r21
    175a:	4f 91       	pop	r20
    175c:	3f 91       	pop	r19
    175e:	2f 91       	pop	r18
    1760:	1f 91       	pop	r17
    1762:	0f 91       	pop	r16
    1764:	ff 90       	pop	r15
    1766:	ef 90       	pop	r14
    1768:	df 90       	pop	r13
    176a:	cf 90       	pop	r12
    176c:	bf 90       	pop	r11
    176e:	af 90       	pop	r10
    1770:	9f 90       	pop	r9
    1772:	8f 90       	pop	r8
    1774:	7f 90       	pop	r7
    1776:	6f 90       	pop	r6
    1778:	5f 90       	pop	r5
    177a:	4f 90       	pop	r4
    177c:	3f 90       	pop	r3
    177e:	2f 90       	pop	r2
    1780:	1f 90       	pop	r1
    1782:	0f 90       	pop	r0
    1784:	0c be       	out	0x3c, r0	; 60
    1786:	0f 90       	pop	r0
    1788:	0b be       	out	0x3b, r0	; 59
    178a:	0f 90       	pop	r0
    178c:	0f be       	out	0x3f, r0	; 63
    178e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1790:	08 95       	ret

00001792 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1792:	0f 92       	push	r0
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	0f 92       	push	r0
    179a:	0b b6       	in	r0, 0x3b	; 59
    179c:	0f 92       	push	r0
    179e:	0c b6       	in	r0, 0x3c	; 60
    17a0:	0f 92       	push	r0
    17a2:	1f 92       	push	r1
    17a4:	11 24       	eor	r1, r1
    17a6:	2f 92       	push	r2
    17a8:	3f 92       	push	r3
    17aa:	4f 92       	push	r4
    17ac:	5f 92       	push	r5
    17ae:	6f 92       	push	r6
    17b0:	7f 92       	push	r7
    17b2:	8f 92       	push	r8
    17b4:	9f 92       	push	r9
    17b6:	af 92       	push	r10
    17b8:	bf 92       	push	r11
    17ba:	cf 92       	push	r12
    17bc:	df 92       	push	r13
    17be:	ef 92       	push	r14
    17c0:	ff 92       	push	r15
    17c2:	0f 93       	push	r16
    17c4:	1f 93       	push	r17
    17c6:	2f 93       	push	r18
    17c8:	3f 93       	push	r19
    17ca:	4f 93       	push	r20
    17cc:	5f 93       	push	r21
    17ce:	6f 93       	push	r22
    17d0:	7f 93       	push	r23
    17d2:	8f 93       	push	r24
    17d4:	9f 93       	push	r25
    17d6:	af 93       	push	r26
    17d8:	bf 93       	push	r27
    17da:	cf 93       	push	r28
    17dc:	df 93       	push	r29
    17de:	ef 93       	push	r30
    17e0:	ff 93       	push	r31
    17e2:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    17e6:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    17ea:	0d b6       	in	r0, 0x3d	; 61
    17ec:	0d 92       	st	X+, r0
    17ee:	0e b6       	in	r0, 0x3e	; 62
    17f0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    17f2:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <vTaskIncrementTick>
	vTaskSwitchContext();
    17f6:	0e 94 88 12 	call	0x2510	; 0x2510 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17fa:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    17fe:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1802:	cd 91       	ld	r28, X+
    1804:	cd bf       	out	0x3d, r28	; 61
    1806:	dd 91       	ld	r29, X+
    1808:	de bf       	out	0x3e, r29	; 62
    180a:	ff 91       	pop	r31
    180c:	ef 91       	pop	r30
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	bf 91       	pop	r27
    1814:	af 91       	pop	r26
    1816:	9f 91       	pop	r25
    1818:	8f 91       	pop	r24
    181a:	7f 91       	pop	r23
    181c:	6f 91       	pop	r22
    181e:	5f 91       	pop	r21
    1820:	4f 91       	pop	r20
    1822:	3f 91       	pop	r19
    1824:	2f 91       	pop	r18
    1826:	1f 91       	pop	r17
    1828:	0f 91       	pop	r16
    182a:	ff 90       	pop	r15
    182c:	ef 90       	pop	r14
    182e:	df 90       	pop	r13
    1830:	cf 90       	pop	r12
    1832:	bf 90       	pop	r11
    1834:	af 90       	pop	r10
    1836:	9f 90       	pop	r9
    1838:	8f 90       	pop	r8
    183a:	7f 90       	pop	r7
    183c:	6f 90       	pop	r6
    183e:	5f 90       	pop	r5
    1840:	4f 90       	pop	r4
    1842:	3f 90       	pop	r3
    1844:	2f 90       	pop	r2
    1846:	1f 90       	pop	r1
    1848:	0f 90       	pop	r0
    184a:	0c be       	out	0x3c, r0	; 60
    184c:	0f 90       	pop	r0
    184e:	0b be       	out	0x3b, r0	; 59
    1850:	0f 90       	pop	r0
    1852:	0f be       	out	0x3f, r0	; 63
    1854:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1856:	08 95       	ret

00001858 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1858:	0e 94 c9 0b 	call	0x1792	; 0x1792 <vPortYieldFromTick>
		asm volatile ( "reti" );
    185c:	18 95       	reti

0000185e <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    185e:	cf 93       	push	r28
    1860:	df 93       	push	r29
    1862:	ec 01       	movw	r28, r24
    1864:	88 a1       	ldd	r24, Y+32	; 0x20
    1866:	81 11       	cpse	r24, r1
    1868:	0b c0       	rjmp	.+22     	; 0x1880 <prvCopyDataToQueue+0x22>
    186a:	88 81       	ld	r24, Y
    186c:	99 81       	ldd	r25, Y+1	; 0x01
    186e:	89 2b       	or	r24, r25
    1870:	e1 f5       	brne	.+120    	; 0x18ea <prvCopyDataToQueue+0x8c>
    1872:	8a 81       	ldd	r24, Y+2	; 0x02
    1874:	9b 81       	ldd	r25, Y+3	; 0x03
    1876:	0e 94 43 14 	call	0x2886	; 0x2886 <vTaskPriorityDisinherit>
    187a:	1a 82       	std	Y+2, r1	; 0x02
    187c:	1b 82       	std	Y+3, r1	; 0x03
    187e:	35 c0       	rjmp	.+106    	; 0x18ea <prvCopyDataToQueue+0x8c>
    1880:	41 11       	cpse	r20, r1
    1882:	17 c0       	rjmp	.+46     	; 0x18b2 <prvCopyDataToQueue+0x54>
    1884:	48 2f       	mov	r20, r24
    1886:	50 e0       	ldi	r21, 0x00	; 0
    1888:	8c 81       	ldd	r24, Y+4	; 0x04
    188a:	9d 81       	ldd	r25, Y+5	; 0x05
    188c:	0e 94 bb 1f 	call	0x3f76	; 0x3f76 <memcpy>
    1890:	28 a1       	ldd	r18, Y+32	; 0x20
    1892:	8c 81       	ldd	r24, Y+4	; 0x04
    1894:	9d 81       	ldd	r25, Y+5	; 0x05
    1896:	82 0f       	add	r24, r18
    1898:	91 1d       	adc	r25, r1
    189a:	8c 83       	std	Y+4, r24	; 0x04
    189c:	9d 83       	std	Y+5, r25	; 0x05
    189e:	2a 81       	ldd	r18, Y+2	; 0x02
    18a0:	3b 81       	ldd	r19, Y+3	; 0x03
    18a2:	82 17       	cp	r24, r18
    18a4:	93 07       	cpc	r25, r19
    18a6:	08 f1       	brcs	.+66     	; 0x18ea <prvCopyDataToQueue+0x8c>
    18a8:	88 81       	ld	r24, Y
    18aa:	99 81       	ldd	r25, Y+1	; 0x01
    18ac:	8c 83       	std	Y+4, r24	; 0x04
    18ae:	9d 83       	std	Y+5, r25	; 0x05
    18b0:	1c c0       	rjmp	.+56     	; 0x18ea <prvCopyDataToQueue+0x8c>
    18b2:	48 2f       	mov	r20, r24
    18b4:	50 e0       	ldi	r21, 0x00	; 0
    18b6:	8e 81       	ldd	r24, Y+6	; 0x06
    18b8:	9f 81       	ldd	r25, Y+7	; 0x07
    18ba:	0e 94 bb 1f 	call	0x3f76	; 0x3f76 <memcpy>
    18be:	88 a1       	ldd	r24, Y+32	; 0x20
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	91 95       	neg	r25
    18c4:	81 95       	neg	r24
    18c6:	91 09       	sbc	r25, r1
    18c8:	2e 81       	ldd	r18, Y+6	; 0x06
    18ca:	3f 81       	ldd	r19, Y+7	; 0x07
    18cc:	28 0f       	add	r18, r24
    18ce:	39 1f       	adc	r19, r25
    18d0:	2e 83       	std	Y+6, r18	; 0x06
    18d2:	3f 83       	std	Y+7, r19	; 0x07
    18d4:	48 81       	ld	r20, Y
    18d6:	59 81       	ldd	r21, Y+1	; 0x01
    18d8:	24 17       	cp	r18, r20
    18da:	35 07       	cpc	r19, r21
    18dc:	30 f4       	brcc	.+12     	; 0x18ea <prvCopyDataToQueue+0x8c>
    18de:	2a 81       	ldd	r18, Y+2	; 0x02
    18e0:	3b 81       	ldd	r19, Y+3	; 0x03
    18e2:	82 0f       	add	r24, r18
    18e4:	93 1f       	adc	r25, r19
    18e6:	8e 83       	std	Y+6, r24	; 0x06
    18e8:	9f 83       	std	Y+7, r25	; 0x07
    18ea:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18ec:	8f 5f       	subi	r24, 0xFF	; 255
    18ee:	8e 8f       	std	Y+30, r24	; 0x1e
    18f0:	df 91       	pop	r29
    18f2:	cf 91       	pop	r28
    18f4:	08 95       	ret

000018f6 <prvCopyDataFromQueue>:
    18f6:	fc 01       	movw	r30, r24
    18f8:	80 81       	ld	r24, Z
    18fa:	91 81       	ldd	r25, Z+1	; 0x01
    18fc:	00 97       	sbiw	r24, 0x00	; 0
    18fe:	a1 f0       	breq	.+40     	; 0x1928 <prvCopyDataFromQueue+0x32>
    1900:	40 a1       	ldd	r20, Z+32	; 0x20
    1902:	50 e0       	ldi	r21, 0x00	; 0
    1904:	26 81       	ldd	r18, Z+6	; 0x06
    1906:	37 81       	ldd	r19, Z+7	; 0x07
    1908:	24 0f       	add	r18, r20
    190a:	35 1f       	adc	r19, r21
    190c:	26 83       	std	Z+6, r18	; 0x06
    190e:	37 83       	std	Z+7, r19	; 0x07
    1910:	a2 81       	ldd	r26, Z+2	; 0x02
    1912:	b3 81       	ldd	r27, Z+3	; 0x03
    1914:	2a 17       	cp	r18, r26
    1916:	3b 07       	cpc	r19, r27
    1918:	10 f0       	brcs	.+4      	; 0x191e <prvCopyDataFromQueue+0x28>
    191a:	86 83       	std	Z+6, r24	; 0x06
    191c:	97 83       	std	Z+7, r25	; 0x07
    191e:	cb 01       	movw	r24, r22
    1920:	66 81       	ldd	r22, Z+6	; 0x06
    1922:	77 81       	ldd	r23, Z+7	; 0x07
    1924:	0e 94 bb 1f 	call	0x3f76	; 0x3f76 <memcpy>
    1928:	08 95       	ret

0000192a <prvUnlockQueue>:
    192a:	0f 93       	push	r16
    192c:	1f 93       	push	r17
    192e:	cf 93       	push	r28
    1930:	df 93       	push	r29
    1932:	ec 01       	movw	r28, r24
    1934:	0f b6       	in	r0, 0x3f	; 63
    1936:	f8 94       	cli
    1938:	0f 92       	push	r0
    193a:	8a a1       	ldd	r24, Y+34	; 0x22
    193c:	18 16       	cp	r1, r24
    193e:	b4 f4       	brge	.+44     	; 0x196c <prvUnlockQueue+0x42>
    1940:	8b 89       	ldd	r24, Y+19	; 0x13
    1942:	81 11       	cpse	r24, r1
    1944:	05 c0       	rjmp	.+10     	; 0x1950 <prvUnlockQueue+0x26>
    1946:	12 c0       	rjmp	.+36     	; 0x196c <prvUnlockQueue+0x42>
    1948:	8b 89       	ldd	r24, Y+19	; 0x13
    194a:	81 11       	cpse	r24, r1
    194c:	04 c0       	rjmp	.+8      	; 0x1956 <prvUnlockQueue+0x2c>
    194e:	0e c0       	rjmp	.+28     	; 0x196c <prvUnlockQueue+0x42>
    1950:	8e 01       	movw	r16, r28
    1952:	0d 5e       	subi	r16, 0xED	; 237
    1954:	1f 4f       	sbci	r17, 0xFF	; 255
    1956:	c8 01       	movw	r24, r16
    1958:	0e 94 0f 13 	call	0x261e	; 0x261e <xTaskRemoveFromEventList>
    195c:	81 11       	cpse	r24, r1
    195e:	0e 94 cc 13 	call	0x2798	; 0x2798 <vTaskMissedYield>
    1962:	8a a1       	ldd	r24, Y+34	; 0x22
    1964:	81 50       	subi	r24, 0x01	; 1
    1966:	8a a3       	std	Y+34, r24	; 0x22
    1968:	18 16       	cp	r1, r24
    196a:	74 f3       	brlt	.-36     	; 0x1948 <prvUnlockQueue+0x1e>
    196c:	8f ef       	ldi	r24, 0xFF	; 255
    196e:	8a a3       	std	Y+34, r24	; 0x22
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	0f b6       	in	r0, 0x3f	; 63
    1976:	f8 94       	cli
    1978:	0f 92       	push	r0
    197a:	89 a1       	ldd	r24, Y+33	; 0x21
    197c:	18 16       	cp	r1, r24
    197e:	b4 f4       	brge	.+44     	; 0x19ac <prvUnlockQueue+0x82>
    1980:	88 85       	ldd	r24, Y+8	; 0x08
    1982:	81 11       	cpse	r24, r1
    1984:	05 c0       	rjmp	.+10     	; 0x1990 <prvUnlockQueue+0x66>
    1986:	12 c0       	rjmp	.+36     	; 0x19ac <prvUnlockQueue+0x82>
    1988:	88 85       	ldd	r24, Y+8	; 0x08
    198a:	81 11       	cpse	r24, r1
    198c:	04 c0       	rjmp	.+8      	; 0x1996 <prvUnlockQueue+0x6c>
    198e:	0e c0       	rjmp	.+28     	; 0x19ac <prvUnlockQueue+0x82>
    1990:	8e 01       	movw	r16, r28
    1992:	08 5f       	subi	r16, 0xF8	; 248
    1994:	1f 4f       	sbci	r17, 0xFF	; 255
    1996:	c8 01       	movw	r24, r16
    1998:	0e 94 0f 13 	call	0x261e	; 0x261e <xTaskRemoveFromEventList>
    199c:	81 11       	cpse	r24, r1
    199e:	0e 94 cc 13 	call	0x2798	; 0x2798 <vTaskMissedYield>
    19a2:	89 a1       	ldd	r24, Y+33	; 0x21
    19a4:	81 50       	subi	r24, 0x01	; 1
    19a6:	89 a3       	std	Y+33, r24	; 0x21
    19a8:	18 16       	cp	r1, r24
    19aa:	74 f3       	brlt	.-36     	; 0x1988 <prvUnlockQueue+0x5e>
    19ac:	8f ef       	ldi	r24, 0xFF	; 255
    19ae:	89 a3       	std	Y+33, r24	; 0x21
    19b0:	0f 90       	pop	r0
    19b2:	0f be       	out	0x3f, r0	; 63
    19b4:	df 91       	pop	r29
    19b6:	cf 91       	pop	r28
    19b8:	1f 91       	pop	r17
    19ba:	0f 91       	pop	r16
    19bc:	08 95       	ret

000019be <xQueueGenericReset>:
    19be:	1f 93       	push	r17
    19c0:	cf 93       	push	r28
    19c2:	df 93       	push	r29
    19c4:	61 30       	cpi	r22, 0x01	; 1
    19c6:	59 f0       	breq	.+22     	; 0x19de <xQueueGenericReset+0x20>
    19c8:	fc 01       	movw	r30, r24
    19ca:	23 89       	ldd	r18, Z+19	; 0x13
    19cc:	30 85       	ldd	r19, Z+8	; 0x08
    19ce:	31 11       	cpse	r19, r1
    19d0:	2c c0       	rjmp	.+88     	; 0x1a2a <xQueueGenericReset+0x6c>
    19d2:	11 e0       	ldi	r17, 0x01	; 1
    19d4:	21 11       	cpse	r18, r1
    19d6:	10 e0       	ldi	r17, 0x00	; 0
    19d8:	21 11       	cpse	r18, r1
    19da:	28 c0       	rjmp	.+80     	; 0x1a2c <xQueueGenericReset+0x6e>
    19dc:	01 c0       	rjmp	.+2      	; 0x19e0 <xQueueGenericReset+0x22>
    19de:	11 e0       	ldi	r17, 0x01	; 1
    19e0:	ec 01       	movw	r28, r24
    19e2:	48 81       	ld	r20, Y
    19e4:	59 81       	ldd	r21, Y+1	; 0x01
    19e6:	28 a1       	ldd	r18, Y+32	; 0x20
    19e8:	30 e0       	ldi	r19, 0x00	; 0
    19ea:	6f 8d       	ldd	r22, Y+31	; 0x1f
    19ec:	62 9f       	mul	r22, r18
    19ee:	c0 01       	movw	r24, r0
    19f0:	63 9f       	mul	r22, r19
    19f2:	90 0d       	add	r25, r0
    19f4:	11 24       	eor	r1, r1
    19f6:	ba 01       	movw	r22, r20
    19f8:	68 0f       	add	r22, r24
    19fa:	79 1f       	adc	r23, r25
    19fc:	6a 83       	std	Y+2, r22	; 0x02
    19fe:	7b 83       	std	Y+3, r23	; 0x03
    1a00:	1e 8e       	std	Y+30, r1	; 0x1e
    1a02:	4c 83       	std	Y+4, r20	; 0x04
    1a04:	5d 83       	std	Y+5, r21	; 0x05
    1a06:	82 1b       	sub	r24, r18
    1a08:	93 0b       	sbc	r25, r19
    1a0a:	84 0f       	add	r24, r20
    1a0c:	95 1f       	adc	r25, r21
    1a0e:	8e 83       	std	Y+6, r24	; 0x06
    1a10:	9f 83       	std	Y+7, r25	; 0x07
    1a12:	8f ef       	ldi	r24, 0xFF	; 255
    1a14:	89 a3       	std	Y+33, r24	; 0x21
    1a16:	8a a3       	std	Y+34, r24	; 0x22
    1a18:	ce 01       	movw	r24, r28
    1a1a:	08 96       	adiw	r24, 0x08	; 8
    1a1c:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1a20:	ce 01       	movw	r24, r28
    1a22:	43 96       	adiw	r24, 0x13	; 19
    1a24:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1a28:	01 c0       	rjmp	.+2      	; 0x1a2c <xQueueGenericReset+0x6e>
    1a2a:	10 e0       	ldi	r17, 0x00	; 0
    1a2c:	81 2f       	mov	r24, r17
    1a2e:	df 91       	pop	r29
    1a30:	cf 91       	pop	r28
    1a32:	1f 91       	pop	r17
    1a34:	08 95       	ret

00001a36 <xQueueGenericCreate>:
    1a36:	0f 93       	push	r16
    1a38:	1f 93       	push	r17
    1a3a:	cf 93       	push	r28
    1a3c:	df 93       	push	r29
    1a3e:	88 23       	and	r24, r24
    1a40:	01 f1       	breq	.+64     	; 0x1a82 <xQueueGenericCreate+0x4c>
    1a42:	06 2f       	mov	r16, r22
    1a44:	18 2f       	mov	r17, r24
    1a46:	83 e2       	ldi	r24, 0x23	; 35
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	0e 94 35 09 	call	0x126a	; 0x126a <pvPortMalloc>
    1a4e:	ec 01       	movw	r28, r24
    1a50:	89 2b       	or	r24, r25
    1a52:	c9 f0       	breq	.+50     	; 0x1a86 <xQueueGenericCreate+0x50>
    1a54:	10 9f       	mul	r17, r16
    1a56:	c0 01       	movw	r24, r0
    1a58:	11 24       	eor	r1, r1
    1a5a:	01 96       	adiw	r24, 0x01	; 1
    1a5c:	0e 94 35 09 	call	0x126a	; 0x126a <pvPortMalloc>
    1a60:	88 83       	st	Y, r24
    1a62:	99 83       	std	Y+1, r25	; 0x01
    1a64:	89 2b       	or	r24, r25
    1a66:	39 f0       	breq	.+14     	; 0x1a76 <xQueueGenericCreate+0x40>
    1a68:	1f 8f       	std	Y+31, r17	; 0x1f
    1a6a:	08 a3       	std	Y+32, r16	; 0x20
    1a6c:	61 e0       	ldi	r22, 0x01	; 1
    1a6e:	ce 01       	movw	r24, r28
    1a70:	0e 94 df 0c 	call	0x19be	; 0x19be <xQueueGenericReset>
    1a74:	08 c0       	rjmp	.+16     	; 0x1a86 <xQueueGenericCreate+0x50>
    1a76:	ce 01       	movw	r24, r28
    1a78:	0e 94 cf 09 	call	0x139e	; 0x139e <vPortFree>
    1a7c:	c0 e0       	ldi	r28, 0x00	; 0
    1a7e:	d0 e0       	ldi	r29, 0x00	; 0
    1a80:	02 c0       	rjmp	.+4      	; 0x1a86 <xQueueGenericCreate+0x50>
    1a82:	c0 e0       	ldi	r28, 0x00	; 0
    1a84:	d0 e0       	ldi	r29, 0x00	; 0
    1a86:	ce 01       	movw	r24, r28
    1a88:	df 91       	pop	r29
    1a8a:	cf 91       	pop	r28
    1a8c:	1f 91       	pop	r17
    1a8e:	0f 91       	pop	r16
    1a90:	08 95       	ret

00001a92 <xQueueGenericSend>:
    1a92:	af 92       	push	r10
    1a94:	bf 92       	push	r11
    1a96:	cf 92       	push	r12
    1a98:	df 92       	push	r13
    1a9a:	ef 92       	push	r14
    1a9c:	ff 92       	push	r15
    1a9e:	0f 93       	push	r16
    1aa0:	1f 93       	push	r17
    1aa2:	cf 93       	push	r28
    1aa4:	df 93       	push	r29
    1aa6:	cd b7       	in	r28, 0x3d	; 61
    1aa8:	de b7       	in	r29, 0x3e	; 62
    1aaa:	29 97       	sbiw	r28, 0x09	; 9
    1aac:	cd bf       	out	0x3d, r28	; 61
    1aae:	de bf       	out	0x3e, r29	; 62
    1ab0:	7c 01       	movw	r14, r24
    1ab2:	5b 01       	movw	r10, r22
    1ab4:	2e 83       	std	Y+6, r18	; 0x06
    1ab6:	3f 83       	std	Y+7, r19	; 0x07
    1ab8:	48 87       	std	Y+8, r20	; 0x08
    1aba:	59 87       	std	Y+9, r21	; 0x09
    1abc:	10 e0       	ldi	r17, 0x00	; 0
    1abe:	6c 01       	movw	r12, r24
    1ac0:	88 e0       	ldi	r24, 0x08	; 8
    1ac2:	c8 0e       	add	r12, r24
    1ac4:	d1 1c       	adc	r13, r1
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	f8 94       	cli
    1aca:	0f 92       	push	r0
    1acc:	f7 01       	movw	r30, r14
    1ace:	96 8d       	ldd	r25, Z+30	; 0x1e
    1ad0:	87 8d       	ldd	r24, Z+31	; 0x1f
    1ad2:	98 17       	cp	r25, r24
    1ad4:	a8 f4       	brcc	.+42     	; 0x1b00 <xQueueGenericSend+0x6e>
    1ad6:	40 2f       	mov	r20, r16
    1ad8:	b5 01       	movw	r22, r10
    1ada:	c7 01       	movw	r24, r14
    1adc:	0e 94 2f 0c 	call	0x185e	; 0x185e <prvCopyDataToQueue>
    1ae0:	f7 01       	movw	r30, r14
    1ae2:	83 89       	ldd	r24, Z+19	; 0x13
    1ae4:	88 23       	and	r24, r24
    1ae6:	41 f0       	breq	.+16     	; 0x1af8 <xQueueGenericSend+0x66>
    1ae8:	c7 01       	movw	r24, r14
    1aea:	43 96       	adiw	r24, 0x13	; 19
    1aec:	0e 94 0f 13 	call	0x261e	; 0x261e <xTaskRemoveFromEventList>
    1af0:	81 30       	cpi	r24, 0x01	; 1
    1af2:	11 f4       	brne	.+4      	; 0x1af8 <xQueueGenericSend+0x66>
    1af4:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
    1af8:	0f 90       	pop	r0
    1afa:	0f be       	out	0x3f, r0	; 63
    1afc:	81 e0       	ldi	r24, 0x01	; 1
    1afe:	56 c0       	rjmp	.+172    	; 0x1bac <xQueueGenericSend+0x11a>
    1b00:	8e 81       	ldd	r24, Y+6	; 0x06
    1b02:	9f 81       	ldd	r25, Y+7	; 0x07
    1b04:	a8 85       	ldd	r26, Y+8	; 0x08
    1b06:	b9 85       	ldd	r27, Y+9	; 0x09
    1b08:	89 2b       	or	r24, r25
    1b0a:	8a 2b       	or	r24, r26
    1b0c:	8b 2b       	or	r24, r27
    1b0e:	21 f4       	brne	.+8      	; 0x1b18 <xQueueGenericSend+0x86>
    1b10:	0f 90       	pop	r0
    1b12:	0f be       	out	0x3f, r0	; 63
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	4a c0       	rjmp	.+148    	; 0x1bac <xQueueGenericSend+0x11a>
    1b18:	11 11       	cpse	r17, r1
    1b1a:	05 c0       	rjmp	.+10     	; 0x1b26 <xQueueGenericSend+0x94>
    1b1c:	ce 01       	movw	r24, r28
    1b1e:	01 96       	adiw	r24, 0x01	; 1
    1b20:	0e 94 4e 13 	call	0x269c	; 0x269c <vTaskSetTimeOutState>
    1b24:	11 e0       	ldi	r17, 0x01	; 1
    1b26:	0f 90       	pop	r0
    1b28:	0f be       	out	0x3f, r0	; 63
    1b2a:	0e 94 49 10 	call	0x2092	; 0x2092 <vTaskSuspendAll>
    1b2e:	0f b6       	in	r0, 0x3f	; 63
    1b30:	f8 94       	cli
    1b32:	0f 92       	push	r0
    1b34:	f7 01       	movw	r30, r14
    1b36:	81 a1       	ldd	r24, Z+33	; 0x21
    1b38:	8f 3f       	cpi	r24, 0xFF	; 255
    1b3a:	09 f4       	brne	.+2      	; 0x1b3e <xQueueGenericSend+0xac>
    1b3c:	11 a2       	std	Z+33, r1	; 0x21
    1b3e:	f7 01       	movw	r30, r14
    1b40:	82 a1       	ldd	r24, Z+34	; 0x22
    1b42:	8f 3f       	cpi	r24, 0xFF	; 255
    1b44:	09 f4       	brne	.+2      	; 0x1b48 <xQueueGenericSend+0xb6>
    1b46:	12 a2       	std	Z+34, r1	; 0x22
    1b48:	0f 90       	pop	r0
    1b4a:	0f be       	out	0x3f, r0	; 63
    1b4c:	be 01       	movw	r22, r28
    1b4e:	6a 5f       	subi	r22, 0xFA	; 250
    1b50:	7f 4f       	sbci	r23, 0xFF	; 255
    1b52:	ce 01       	movw	r24, r28
    1b54:	01 96       	adiw	r24, 0x01	; 1
    1b56:	0e 94 5f 13 	call	0x26be	; 0x26be <xTaskCheckForTimeOut>
    1b5a:	81 11       	cpse	r24, r1
    1b5c:	21 c0       	rjmp	.+66     	; 0x1ba0 <xQueueGenericSend+0x10e>
    1b5e:	0f b6       	in	r0, 0x3f	; 63
    1b60:	f8 94       	cli
    1b62:	0f 92       	push	r0
    1b64:	f7 01       	movw	r30, r14
    1b66:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b68:	0f 90       	pop	r0
    1b6a:	0f be       	out	0x3f, r0	; 63
    1b6c:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b6e:	98 13       	cpse	r25, r24
    1b70:	11 c0       	rjmp	.+34     	; 0x1b94 <xQueueGenericSend+0x102>
    1b72:	4e 81       	ldd	r20, Y+6	; 0x06
    1b74:	5f 81       	ldd	r21, Y+7	; 0x07
    1b76:	68 85       	ldd	r22, Y+8	; 0x08
    1b78:	79 85       	ldd	r23, Y+9	; 0x09
    1b7a:	c6 01       	movw	r24, r12
    1b7c:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vTaskPlaceOnEventList>
    1b80:	c7 01       	movw	r24, r14
    1b82:	0e 94 95 0c 	call	0x192a	; 0x192a <prvUnlockQueue>
    1b86:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
    1b8a:	81 11       	cpse	r24, r1
    1b8c:	9c cf       	rjmp	.-200    	; 0x1ac6 <xQueueGenericSend+0x34>
    1b8e:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
    1b92:	99 cf       	rjmp	.-206    	; 0x1ac6 <xQueueGenericSend+0x34>
    1b94:	c7 01       	movw	r24, r14
    1b96:	0e 94 95 0c 	call	0x192a	; 0x192a <prvUnlockQueue>
    1b9a:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
    1b9e:	93 cf       	rjmp	.-218    	; 0x1ac6 <xQueueGenericSend+0x34>
    1ba0:	c7 01       	movw	r24, r14
    1ba2:	0e 94 95 0c 	call	0x192a	; 0x192a <prvUnlockQueue>
    1ba6:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
    1baa:	80 e0       	ldi	r24, 0x00	; 0
    1bac:	29 96       	adiw	r28, 0x09	; 9
    1bae:	cd bf       	out	0x3d, r28	; 61
    1bb0:	de bf       	out	0x3e, r29	; 62
    1bb2:	df 91       	pop	r29
    1bb4:	cf 91       	pop	r28
    1bb6:	1f 91       	pop	r17
    1bb8:	0f 91       	pop	r16
    1bba:	ff 90       	pop	r15
    1bbc:	ef 90       	pop	r14
    1bbe:	df 90       	pop	r13
    1bc0:	cf 90       	pop	r12
    1bc2:	bf 90       	pop	r11
    1bc4:	af 90       	pop	r10
    1bc6:	08 95       	ret

00001bc8 <xQueueGenericReceive>:
    1bc8:	af 92       	push	r10
    1bca:	bf 92       	push	r11
    1bcc:	cf 92       	push	r12
    1bce:	df 92       	push	r13
    1bd0:	ef 92       	push	r14
    1bd2:	ff 92       	push	r15
    1bd4:	0f 93       	push	r16
    1bd6:	1f 93       	push	r17
    1bd8:	cf 93       	push	r28
    1bda:	df 93       	push	r29
    1bdc:	cd b7       	in	r28, 0x3d	; 61
    1bde:	de b7       	in	r29, 0x3e	; 62
    1be0:	29 97       	sbiw	r28, 0x09	; 9
    1be2:	cd bf       	out	0x3d, r28	; 61
    1be4:	de bf       	out	0x3e, r29	; 62
    1be6:	7c 01       	movw	r14, r24
    1be8:	5b 01       	movw	r10, r22
    1bea:	2e 83       	std	Y+6, r18	; 0x06
    1bec:	3f 83       	std	Y+7, r19	; 0x07
    1bee:	48 87       	std	Y+8, r20	; 0x08
    1bf0:	59 87       	std	Y+9, r21	; 0x09
    1bf2:	10 e0       	ldi	r17, 0x00	; 0
    1bf4:	6c 01       	movw	r12, r24
    1bf6:	83 e1       	ldi	r24, 0x13	; 19
    1bf8:	c8 0e       	add	r12, r24
    1bfa:	d1 1c       	adc	r13, r1
    1bfc:	0f b6       	in	r0, 0x3f	; 63
    1bfe:	f8 94       	cli
    1c00:	0f 92       	push	r0
    1c02:	f7 01       	movw	r30, r14
    1c04:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c06:	88 23       	and	r24, r24
    1c08:	99 f1       	breq	.+102    	; 0x1c70 <xQueueGenericReceive+0xa8>
    1c0a:	c6 80       	ldd	r12, Z+6	; 0x06
    1c0c:	d7 80       	ldd	r13, Z+7	; 0x07
    1c0e:	b5 01       	movw	r22, r10
    1c10:	c7 01       	movw	r24, r14
    1c12:	0e 94 7b 0c 	call	0x18f6	; 0x18f6 <prvCopyDataFromQueue>
    1c16:	01 11       	cpse	r16, r1
    1c18:	1a c0       	rjmp	.+52     	; 0x1c4e <xQueueGenericReceive+0x86>
    1c1a:	f7 01       	movw	r30, r14
    1c1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c1e:	81 50       	subi	r24, 0x01	; 1
    1c20:	86 8f       	std	Z+30, r24	; 0x1e
    1c22:	80 81       	ld	r24, Z
    1c24:	91 81       	ldd	r25, Z+1	; 0x01
    1c26:	89 2b       	or	r24, r25
    1c28:	29 f4       	brne	.+10     	; 0x1c34 <xQueueGenericReceive+0x6c>
    1c2a:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <xTaskGetCurrentTaskHandle>
    1c2e:	f7 01       	movw	r30, r14
    1c30:	82 83       	std	Z+2, r24	; 0x02
    1c32:	93 83       	std	Z+3, r25	; 0x03
    1c34:	f7 01       	movw	r30, r14
    1c36:	80 85       	ldd	r24, Z+8	; 0x08
    1c38:	88 23       	and	r24, r24
    1c3a:	b1 f0       	breq	.+44     	; 0x1c68 <xQueueGenericReceive+0xa0>
    1c3c:	c7 01       	movw	r24, r14
    1c3e:	08 96       	adiw	r24, 0x08	; 8
    1c40:	0e 94 0f 13 	call	0x261e	; 0x261e <xTaskRemoveFromEventList>
    1c44:	81 30       	cpi	r24, 0x01	; 1
    1c46:	81 f4       	brne	.+32     	; 0x1c68 <xQueueGenericReceive+0xa0>
    1c48:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
    1c4c:	0d c0       	rjmp	.+26     	; 0x1c68 <xQueueGenericReceive+0xa0>
    1c4e:	f7 01       	movw	r30, r14
    1c50:	c6 82       	std	Z+6, r12	; 0x06
    1c52:	d7 82       	std	Z+7, r13	; 0x07
    1c54:	83 89       	ldd	r24, Z+19	; 0x13
    1c56:	88 23       	and	r24, r24
    1c58:	39 f0       	breq	.+14     	; 0x1c68 <xQueueGenericReceive+0xa0>
    1c5a:	c7 01       	movw	r24, r14
    1c5c:	43 96       	adiw	r24, 0x13	; 19
    1c5e:	0e 94 0f 13 	call	0x261e	; 0x261e <xTaskRemoveFromEventList>
    1c62:	81 11       	cpse	r24, r1
    1c64:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
    1c68:	0f 90       	pop	r0
    1c6a:	0f be       	out	0x3f, r0	; 63
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	62 c0       	rjmp	.+196    	; 0x1d34 <xQueueGenericReceive+0x16c>
    1c70:	8e 81       	ldd	r24, Y+6	; 0x06
    1c72:	9f 81       	ldd	r25, Y+7	; 0x07
    1c74:	a8 85       	ldd	r26, Y+8	; 0x08
    1c76:	b9 85       	ldd	r27, Y+9	; 0x09
    1c78:	89 2b       	or	r24, r25
    1c7a:	8a 2b       	or	r24, r26
    1c7c:	8b 2b       	or	r24, r27
    1c7e:	21 f4       	brne	.+8      	; 0x1c88 <xQueueGenericReceive+0xc0>
    1c80:	0f 90       	pop	r0
    1c82:	0f be       	out	0x3f, r0	; 63
    1c84:	80 e0       	ldi	r24, 0x00	; 0
    1c86:	56 c0       	rjmp	.+172    	; 0x1d34 <xQueueGenericReceive+0x16c>
    1c88:	11 11       	cpse	r17, r1
    1c8a:	05 c0       	rjmp	.+10     	; 0x1c96 <xQueueGenericReceive+0xce>
    1c8c:	ce 01       	movw	r24, r28
    1c8e:	01 96       	adiw	r24, 0x01	; 1
    1c90:	0e 94 4e 13 	call	0x269c	; 0x269c <vTaskSetTimeOutState>
    1c94:	11 e0       	ldi	r17, 0x01	; 1
    1c96:	0f 90       	pop	r0
    1c98:	0f be       	out	0x3f, r0	; 63
    1c9a:	0e 94 49 10 	call	0x2092	; 0x2092 <vTaskSuspendAll>
    1c9e:	0f b6       	in	r0, 0x3f	; 63
    1ca0:	f8 94       	cli
    1ca2:	0f 92       	push	r0
    1ca4:	f7 01       	movw	r30, r14
    1ca6:	81 a1       	ldd	r24, Z+33	; 0x21
    1ca8:	8f 3f       	cpi	r24, 0xFF	; 255
    1caa:	09 f4       	brne	.+2      	; 0x1cae <xQueueGenericReceive+0xe6>
    1cac:	11 a2       	std	Z+33, r1	; 0x21
    1cae:	f7 01       	movw	r30, r14
    1cb0:	82 a1       	ldd	r24, Z+34	; 0x22
    1cb2:	8f 3f       	cpi	r24, 0xFF	; 255
    1cb4:	09 f4       	brne	.+2      	; 0x1cb8 <xQueueGenericReceive+0xf0>
    1cb6:	12 a2       	std	Z+34, r1	; 0x22
    1cb8:	0f 90       	pop	r0
    1cba:	0f be       	out	0x3f, r0	; 63
    1cbc:	be 01       	movw	r22, r28
    1cbe:	6a 5f       	subi	r22, 0xFA	; 250
    1cc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1cc2:	ce 01       	movw	r24, r28
    1cc4:	01 96       	adiw	r24, 0x01	; 1
    1cc6:	0e 94 5f 13 	call	0x26be	; 0x26be <xTaskCheckForTimeOut>
    1cca:	81 11       	cpse	r24, r1
    1ccc:	2d c0       	rjmp	.+90     	; 0x1d28 <xQueueGenericReceive+0x160>
    1cce:	0f b6       	in	r0, 0x3f	; 63
    1cd0:	f8 94       	cli
    1cd2:	0f 92       	push	r0
    1cd4:	f7 01       	movw	r30, r14
    1cd6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cd8:	0f 90       	pop	r0
    1cda:	0f be       	out	0x3f, r0	; 63
    1cdc:	81 11       	cpse	r24, r1
    1cde:	1e c0       	rjmp	.+60     	; 0x1d1c <xQueueGenericReceive+0x154>
    1ce0:	80 81       	ld	r24, Z
    1ce2:	91 81       	ldd	r25, Z+1	; 0x01
    1ce4:	89 2b       	or	r24, r25
    1ce6:	49 f4       	brne	.+18     	; 0x1cfa <xQueueGenericReceive+0x132>
    1ce8:	0f b6       	in	r0, 0x3f	; 63
    1cea:	f8 94       	cli
    1cec:	0f 92       	push	r0
    1cee:	82 81       	ldd	r24, Z+2	; 0x02
    1cf0:	93 81       	ldd	r25, Z+3	; 0x03
    1cf2:	0e 94 ee 13 	call	0x27dc	; 0x27dc <vTaskPriorityInherit>
    1cf6:	0f 90       	pop	r0
    1cf8:	0f be       	out	0x3f, r0	; 63
    1cfa:	4e 81       	ldd	r20, Y+6	; 0x06
    1cfc:	5f 81       	ldd	r21, Y+7	; 0x07
    1cfe:	68 85       	ldd	r22, Y+8	; 0x08
    1d00:	79 85       	ldd	r23, Y+9	; 0x09
    1d02:	c6 01       	movw	r24, r12
    1d04:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vTaskPlaceOnEventList>
    1d08:	c7 01       	movw	r24, r14
    1d0a:	0e 94 95 0c 	call	0x192a	; 0x192a <prvUnlockQueue>
    1d0e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
    1d12:	81 11       	cpse	r24, r1
    1d14:	73 cf       	rjmp	.-282    	; 0x1bfc <xQueueGenericReceive+0x34>
    1d16:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
    1d1a:	70 cf       	rjmp	.-288    	; 0x1bfc <xQueueGenericReceive+0x34>
    1d1c:	c7 01       	movw	r24, r14
    1d1e:	0e 94 95 0c 	call	0x192a	; 0x192a <prvUnlockQueue>
    1d22:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
    1d26:	6a cf       	rjmp	.-300    	; 0x1bfc <xQueueGenericReceive+0x34>
    1d28:	c7 01       	movw	r24, r14
    1d2a:	0e 94 95 0c 	call	0x192a	; 0x192a <prvUnlockQueue>
    1d2e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
    1d32:	80 e0       	ldi	r24, 0x00	; 0
    1d34:	29 96       	adiw	r28, 0x09	; 9
    1d36:	cd bf       	out	0x3d, r28	; 61
    1d38:	de bf       	out	0x3e, r29	; 62
    1d3a:	df 91       	pop	r29
    1d3c:	cf 91       	pop	r28
    1d3e:	1f 91       	pop	r17
    1d40:	0f 91       	pop	r16
    1d42:	ff 90       	pop	r15
    1d44:	ef 90       	pop	r14
    1d46:	df 90       	pop	r13
    1d48:	cf 90       	pop	r12
    1d4a:	bf 90       	pop	r11
    1d4c:	af 90       	pop	r10
    1d4e:	08 95       	ret

00001d50 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d50:	0f b6       	in	r0, 0x3f	; 63
    1d52:	f8 94       	cli
    1d54:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d56:	fc 01       	movw	r30, r24
    1d58:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d5a:	0f 90       	pop	r0
    1d5c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d5e:	08 95       	ret

00001d60 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d60:	cc ee       	ldi	r28, 0xEC	; 236
    1d62:	d0 e3       	ldi	r29, 0x30	; 48
    1d64:	88 81       	ld	r24, Y
    1d66:	82 30       	cpi	r24, 0x02	; 2
    1d68:	e8 f3       	brcs	.-6      	; 0x1d64 <prvIdleTask+0x4>
    1d6a:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
    1d6e:	fa cf       	rjmp	.-12     	; 0x1d64 <prvIdleTask+0x4>

00001d70 <prvAddCurrentTaskToDelayedList>:
    1d70:	cf 92       	push	r12
    1d72:	df 92       	push	r13
    1d74:	ef 92       	push	r14
    1d76:	ff 92       	push	r15
    1d78:	6b 01       	movw	r12, r22
    1d7a:	7c 01       	movw	r14, r24
    1d7c:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    1d80:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1d84:	62 83       	std	Z+2, r22	; 0x02
    1d86:	73 83       	std	Z+3, r23	; 0x03
    1d88:	84 83       	std	Z+4, r24	; 0x04
    1d8a:	95 83       	std	Z+5, r25	; 0x05
    1d8c:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    1d90:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    1d94:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    1d98:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    1d9c:	c8 16       	cp	r12, r24
    1d9e:	d9 06       	cpc	r13, r25
    1da0:	ea 06       	cpc	r14, r26
    1da2:	fb 06       	cpc	r15, r27
    1da4:	68 f4       	brcc	.+26     	; 0x1dc0 <prvAddCurrentTaskToDelayedList+0x50>
    1da6:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    1daa:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1dae:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    1db2:	90 91 d3 30 	lds	r25, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    1db6:	6e 5f       	subi	r22, 0xFE	; 254
    1db8:	7f 4f       	sbci	r23, 0xFF	; 255
    1dba:	0e 94 43 0a 	call	0x1486	; 0x1486 <vListInsert>
    1dbe:	21 c0       	rjmp	.+66     	; 0x1e02 <prvAddCurrentTaskToDelayedList+0x92>
    1dc0:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    1dc4:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1dc8:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    1dcc:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    1dd0:	6e 5f       	subi	r22, 0xFE	; 254
    1dd2:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd4:	0e 94 43 0a 	call	0x1486	; 0x1486 <vListInsert>
    1dd8:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1ddc:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1de0:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1de4:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1de8:	c8 16       	cp	r12, r24
    1dea:	d9 06       	cpc	r13, r25
    1dec:	ea 06       	cpc	r14, r26
    1dee:	fb 06       	cpc	r15, r27
    1df0:	40 f4       	brcc	.+16     	; 0x1e02 <prvAddCurrentTaskToDelayedList+0x92>
    1df2:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1df6:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dfa:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dfe:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e02:	ff 90       	pop	r15
    1e04:	ef 90       	pop	r14
    1e06:	df 90       	pop	r13
    1e08:	cf 90       	pop	r12
    1e0a:	08 95       	ret

00001e0c <xTaskGenericCreate>:
    1e0c:	4f 92       	push	r4
    1e0e:	5f 92       	push	r5
    1e10:	6f 92       	push	r6
    1e12:	7f 92       	push	r7
    1e14:	8f 92       	push	r8
    1e16:	9f 92       	push	r9
    1e18:	af 92       	push	r10
    1e1a:	bf 92       	push	r11
    1e1c:	cf 92       	push	r12
    1e1e:	df 92       	push	r13
    1e20:	ef 92       	push	r14
    1e22:	ff 92       	push	r15
    1e24:	0f 93       	push	r16
    1e26:	1f 93       	push	r17
    1e28:	cf 93       	push	r28
    1e2a:	df 93       	push	r29
    1e2c:	5c 01       	movw	r10, r24
    1e2e:	4b 01       	movw	r8, r22
    1e30:	3a 01       	movw	r6, r20
    1e32:	29 01       	movw	r4, r18
    1e34:	88 e2       	ldi	r24, 0x28	; 40
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	0e 94 35 09 	call	0x126a	; 0x126a <pvPortMalloc>
    1e3c:	ec 01       	movw	r28, r24
    1e3e:	89 2b       	or	r24, r25
    1e40:	09 f4       	brne	.+2      	; 0x1e44 <xTaskGenericCreate+0x38>
    1e42:	d4 c0       	rjmp	.+424    	; 0x1fec <xTaskGenericCreate+0x1e0>
    1e44:	c1 14       	cp	r12, r1
    1e46:	d1 04       	cpc	r13, r1
    1e48:	09 f0       	breq	.+2      	; 0x1e4c <xTaskGenericCreate+0x40>
    1e4a:	cc c0       	rjmp	.+408    	; 0x1fe4 <xTaskGenericCreate+0x1d8>
    1e4c:	c3 01       	movw	r24, r6
    1e4e:	0e 94 35 09 	call	0x126a	; 0x126a <pvPortMalloc>
    1e52:	8b 8f       	std	Y+27, r24	; 0x1b
    1e54:	9c 8f       	std	Y+28, r25	; 0x1c
    1e56:	00 97       	sbiw	r24, 0x00	; 0
    1e58:	21 f4       	brne	.+8      	; 0x1e62 <xTaskGenericCreate+0x56>
    1e5a:	ce 01       	movw	r24, r28
    1e5c:	0e 94 cf 09 	call	0x139e	; 0x139e <vPortFree>
    1e60:	c5 c0       	rjmp	.+394    	; 0x1fec <xTaskGenericCreate+0x1e0>
    1e62:	a3 01       	movw	r20, r6
    1e64:	61 e1       	ldi	r22, 0x11	; 17
    1e66:	70 e0       	ldi	r23, 0x00	; 0
    1e68:	0e 94 c4 1f 	call	0x3f88	; 0x3f88 <memset>
    1e6c:	93 01       	movw	r18, r6
    1e6e:	21 50       	subi	r18, 0x01	; 1
    1e70:	31 09       	sbc	r19, r1
    1e72:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e74:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e76:	3c 01       	movw	r6, r24
    1e78:	62 0e       	add	r6, r18
    1e7a:	73 1e       	adc	r7, r19
    1e7c:	4a e0       	ldi	r20, 0x0A	; 10
    1e7e:	50 e0       	ldi	r21, 0x00	; 0
    1e80:	b4 01       	movw	r22, r8
    1e82:	ce 01       	movw	r24, r28
    1e84:	4d 96       	adiw	r24, 0x1d	; 29
    1e86:	0e 94 cb 1f 	call	0x3f96	; 0x3f96 <strncpy>
    1e8a:	1e a2       	std	Y+38, r1	; 0x26
    1e8c:	10 2f       	mov	r17, r16
    1e8e:	04 30       	cpi	r16, 0x04	; 4
    1e90:	08 f0       	brcs	.+2      	; 0x1e94 <xTaskGenericCreate+0x88>
    1e92:	13 e0       	ldi	r17, 0x03	; 3
    1e94:	1a 8f       	std	Y+26, r17	; 0x1a
    1e96:	1f a3       	std	Y+39, r17	; 0x27
    1e98:	6e 01       	movw	r12, r28
    1e9a:	22 e0       	ldi	r18, 0x02	; 2
    1e9c:	c2 0e       	add	r12, r18
    1e9e:	d1 1c       	adc	r13, r1
    1ea0:	c6 01       	movw	r24, r12
    1ea2:	0e 94 18 0a 	call	0x1430	; 0x1430 <vListInitialiseItem>
    1ea6:	ce 01       	movw	r24, r28
    1ea8:	0e 96       	adiw	r24, 0x0e	; 14
    1eaa:	0e 94 18 0a 	call	0x1430	; 0x1430 <vListInitialiseItem>
    1eae:	ca 87       	std	Y+10, r28	; 0x0a
    1eb0:	db 87       	std	Y+11, r29	; 0x0b
    1eb2:	84 e0       	ldi	r24, 0x04	; 4
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	a0 e0       	ldi	r26, 0x00	; 0
    1eb8:	b0 e0       	ldi	r27, 0x00	; 0
    1eba:	81 1b       	sub	r24, r17
    1ebc:	91 09       	sbc	r25, r1
    1ebe:	a1 09       	sbc	r26, r1
    1ec0:	b1 09       	sbc	r27, r1
    1ec2:	8e 87       	std	Y+14, r24	; 0x0e
    1ec4:	9f 87       	std	Y+15, r25	; 0x0f
    1ec6:	a8 8b       	std	Y+16, r26	; 0x10
    1ec8:	b9 8b       	std	Y+17, r27	; 0x11
    1eca:	ce 8b       	std	Y+22, r28	; 0x16
    1ecc:	df 8b       	std	Y+23, r29	; 0x17
    1ece:	a2 01       	movw	r20, r4
    1ed0:	b5 01       	movw	r22, r10
    1ed2:	c3 01       	movw	r24, r6
    1ed4:	0e 94 b4 0a 	call	0x1568	; 0x1568 <pxPortInitialiseStack>
    1ed8:	88 83       	st	Y, r24
    1eda:	99 83       	std	Y+1, r25	; 0x01
    1edc:	e1 14       	cp	r14, r1
    1ede:	f1 04       	cpc	r15, r1
    1ee0:	19 f0       	breq	.+6      	; 0x1ee8 <xTaskGenericCreate+0xdc>
    1ee2:	f7 01       	movw	r30, r14
    1ee4:	c0 83       	st	Z, r28
    1ee6:	d1 83       	std	Z+1, r29	; 0x01
    1ee8:	0f b6       	in	r0, 0x3f	; 63
    1eea:	f8 94       	cli
    1eec:	0f 92       	push	r0
    1eee:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    1ef2:	8f 5f       	subi	r24, 0xFF	; 255
    1ef4:	80 93 c4 30 	sts	0x30C4, r24	; 0x8030c4 <uxCurrentNumberOfTasks>
    1ef8:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    1efc:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1f00:	89 2b       	or	r24, r25
    1f02:	89 f5       	brne	.+98     	; 0x1f66 <xTaskGenericCreate+0x15a>
    1f04:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    1f08:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    1f0c:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    1f10:	81 30       	cpi	r24, 0x01	; 1
    1f12:	c1 f5       	brne	.+112    	; 0x1f84 <xTaskGenericCreate+0x178>
    1f14:	8c ee       	ldi	r24, 0xEC	; 236
    1f16:	90 e3       	ldi	r25, 0x30	; 48
    1f18:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1f1c:	87 ef       	ldi	r24, 0xF7	; 247
    1f1e:	90 e3       	ldi	r25, 0x30	; 48
    1f20:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1f24:	82 e0       	ldi	r24, 0x02	; 2
    1f26:	91 e3       	ldi	r25, 0x31	; 49
    1f28:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1f2c:	8d e0       	ldi	r24, 0x0D	; 13
    1f2e:	91 e3       	ldi	r25, 0x31	; 49
    1f30:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1f34:	81 ee       	ldi	r24, 0xE1	; 225
    1f36:	90 e3       	ldi	r25, 0x30	; 48
    1f38:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1f3c:	86 ed       	ldi	r24, 0xD6	; 214
    1f3e:	90 e3       	ldi	r25, 0x30	; 48
    1f40:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1f44:	87 ec       	ldi	r24, 0xC7	; 199
    1f46:	90 e3       	ldi	r25, 0x30	; 48
    1f48:	0e 94 07 0a 	call	0x140e	; 0x140e <vListInitialise>
    1f4c:	81 ee       	ldi	r24, 0xE1	; 225
    1f4e:	90 e3       	ldi	r25, 0x30	; 48
    1f50:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <pxDelayedTaskList>
    1f54:	90 93 d5 30 	sts	0x30D5, r25	; 0x8030d5 <pxDelayedTaskList+0x1>
    1f58:	86 ed       	ldi	r24, 0xD6	; 214
    1f5a:	90 e3       	ldi	r25, 0x30	; 48
    1f5c:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    1f60:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    1f64:	0f c0       	rjmp	.+30     	; 0x1f84 <xTaskGenericCreate+0x178>
    1f66:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    1f6a:	81 11       	cpse	r24, r1
    1f6c:	0b c0       	rjmp	.+22     	; 0x1f84 <xTaskGenericCreate+0x178>
    1f6e:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    1f72:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1f76:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f78:	08 17       	cp	r16, r24
    1f7a:	20 f0       	brcs	.+8      	; 0x1f84 <xTaskGenericCreate+0x178>
    1f7c:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    1f80:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    1f84:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f86:	90 91 bf 30 	lds	r25, 0x30BF	; 0x8030bf <uxTopUsedPriority>
    1f8a:	98 17       	cp	r25, r24
    1f8c:	10 f4       	brcc	.+4      	; 0x1f92 <xTaskGenericCreate+0x186>
    1f8e:	80 93 bf 30 	sts	0x30BF, r24	; 0x8030bf <uxTopUsedPriority>
    1f92:	90 91 b8 30 	lds	r25, 0x30B8	; 0x8030b8 <uxTaskNumber>
    1f96:	9f 5f       	subi	r25, 0xFF	; 255
    1f98:	90 93 b8 30 	sts	0x30B8, r25	; 0x8030b8 <uxTaskNumber>
    1f9c:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    1fa0:	98 17       	cp	r25, r24
    1fa2:	10 f4       	brcc	.+4      	; 0x1fa8 <xTaskGenericCreate+0x19c>
    1fa4:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    1fa8:	fb e0       	ldi	r31, 0x0B	; 11
    1faa:	8f 9f       	mul	r24, r31
    1fac:	c0 01       	movw	r24, r0
    1fae:	11 24       	eor	r1, r1
    1fb0:	b6 01       	movw	r22, r12
    1fb2:	84 51       	subi	r24, 0x14	; 20
    1fb4:	9f 4c       	sbci	r25, 0xCF	; 207
    1fb6:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vListInsertEnd>
    1fba:	0f 90       	pop	r0
    1fbc:	0f be       	out	0x3f, r0	; 63
    1fbe:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    1fc2:	88 23       	and	r24, r24
    1fc4:	59 f0       	breq	.+22     	; 0x1fdc <xTaskGenericCreate+0x1d0>
    1fc6:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    1fca:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1fce:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fd0:	80 17       	cp	r24, r16
    1fd2:	30 f4       	brcc	.+12     	; 0x1fe0 <xTaskGenericCreate+0x1d4>
    1fd4:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	09 c0       	rjmp	.+18     	; 0x1fee <xTaskGenericCreate+0x1e2>
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	07 c0       	rjmp	.+14     	; 0x1fee <xTaskGenericCreate+0x1e2>
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	05 c0       	rjmp	.+10     	; 0x1fee <xTaskGenericCreate+0x1e2>
    1fe4:	cb 8e       	std	Y+27, r12	; 0x1b
    1fe6:	dc 8e       	std	Y+28, r13	; 0x1c
    1fe8:	c6 01       	movw	r24, r12
    1fea:	3b cf       	rjmp	.-394    	; 0x1e62 <xTaskGenericCreate+0x56>
    1fec:	8f ef       	ldi	r24, 0xFF	; 255
    1fee:	df 91       	pop	r29
    1ff0:	cf 91       	pop	r28
    1ff2:	1f 91       	pop	r17
    1ff4:	0f 91       	pop	r16
    1ff6:	ff 90       	pop	r15
    1ff8:	ef 90       	pop	r14
    1ffa:	df 90       	pop	r13
    1ffc:	cf 90       	pop	r12
    1ffe:	bf 90       	pop	r11
    2000:	af 90       	pop	r10
    2002:	9f 90       	pop	r9
    2004:	8f 90       	pop	r8
    2006:	7f 90       	pop	r7
    2008:	6f 90       	pop	r6
    200a:	5f 90       	pop	r5
    200c:	4f 90       	pop	r4
    200e:	08 95       	ret

00002010 <uxTaskPriorityGet>:
    2010:	0f b6       	in	r0, 0x3f	; 63
    2012:	f8 94       	cli
    2014:	0f 92       	push	r0
    2016:	00 97       	sbiw	r24, 0x00	; 0
    2018:	21 f4       	brne	.+8      	; 0x2022 <uxTaskPriorityGet+0x12>
    201a:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    201e:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2022:	0f 90       	pop	r0
    2024:	0f be       	out	0x3f, r0	; 63
    2026:	fc 01       	movw	r30, r24
    2028:	82 8d       	ldd	r24, Z+26	; 0x1a
    202a:	08 95       	ret

0000202c <vTaskStartScheduler>:
    202c:	af 92       	push	r10
    202e:	bf 92       	push	r11
    2030:	cf 92       	push	r12
    2032:	df 92       	push	r13
    2034:	ef 92       	push	r14
    2036:	ff 92       	push	r15
    2038:	0f 93       	push	r16
    203a:	a1 2c       	mov	r10, r1
    203c:	b1 2c       	mov	r11, r1
    203e:	c1 2c       	mov	r12, r1
    2040:	d1 2c       	mov	r13, r1
    2042:	0f 2e       	mov	r0, r31
    2044:	f5 ec       	ldi	r31, 0xC5	; 197
    2046:	ef 2e       	mov	r14, r31
    2048:	f0 e3       	ldi	r31, 0x30	; 48
    204a:	ff 2e       	mov	r15, r31
    204c:	f0 2d       	mov	r31, r0
    204e:	00 e0       	ldi	r16, 0x00	; 0
    2050:	20 e0       	ldi	r18, 0x00	; 0
    2052:	30 e0       	ldi	r19, 0x00	; 0
    2054:	44 e6       	ldi	r20, 0x64	; 100
    2056:	50 e0       	ldi	r21, 0x00	; 0
    2058:	6e e2       	ldi	r22, 0x2E	; 46
    205a:	70 e2       	ldi	r23, 0x20	; 32
    205c:	80 eb       	ldi	r24, 0xB0	; 176
    205e:	9e e0       	ldi	r25, 0x0E	; 14
    2060:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <xTaskGenericCreate>
    2064:	81 30       	cpi	r24, 0x01	; 1
    2066:	69 f4       	brne	.+26     	; 0x2082 <vTaskStartScheduler+0x56>
    2068:	f8 94       	cli
    206a:	80 93 bd 30 	sts	0x30BD, r24	; 0x8030bd <xSchedulerRunning>
    206e:	10 92 c0 30 	sts	0x30C0, r1	; 0x8030c0 <xTickCount>
    2072:	10 92 c1 30 	sts	0x30C1, r1	; 0x8030c1 <xTickCount+0x1>
    2076:	10 92 c2 30 	sts	0x30C2, r1	; 0x8030c2 <xTickCount+0x2>
    207a:	10 92 c3 30 	sts	0x30C3, r1	; 0x8030c3 <xTickCount+0x3>
    207e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xPortStartScheduler>
    2082:	0f 91       	pop	r16
    2084:	ff 90       	pop	r15
    2086:	ef 90       	pop	r14
    2088:	df 90       	pop	r13
    208a:	cf 90       	pop	r12
    208c:	bf 90       	pop	r11
    208e:	af 90       	pop	r10
    2090:	08 95       	ret

00002092 <vTaskSuspendAll>:
    2092:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2096:	8f 5f       	subi	r24, 0xFF	; 255
    2098:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>
    209c:	08 95       	ret

0000209e <xTaskGetTickCount>:
    209e:	0f b6       	in	r0, 0x3f	; 63
    20a0:	f8 94       	cli
    20a2:	0f 92       	push	r0
    20a4:	60 91 c0 30 	lds	r22, 0x30C0	; 0x8030c0 <xTickCount>
    20a8:	70 91 c1 30 	lds	r23, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    20ac:	80 91 c2 30 	lds	r24, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    20b0:	90 91 c3 30 	lds	r25, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    20b4:	0f 90       	pop	r0
    20b6:	0f be       	out	0x3f, r0	; 63
    20b8:	08 95       	ret

000020ba <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20ba:	00 97       	sbiw	r24, 0x00	; 0
    20bc:	21 f4       	brne	.+8      	; 0x20c6 <pcTaskGetTaskName+0xc>
    20be:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    20c2:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20c6:	4d 96       	adiw	r24, 0x1d	; 29
    20c8:	08 95       	ret

000020ca <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20ca:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xIdleTaskHandle>
    20ce:	90 91 c6 30 	lds	r25, 0x30C6	; 0x8030c6 <xIdleTaskHandle+0x1>
    20d2:	08 95       	ret

000020d4 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20d4:	ff 92       	push	r15
    20d6:	0f 93       	push	r16
    20d8:	1f 93       	push	r17
    20da:	cf 93       	push	r28
    20dc:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20de:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    20e2:	81 11       	cpse	r24, r1
    20e4:	ed c0       	rjmp	.+474    	; 0x22c0 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    20e6:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    20ea:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    20ee:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    20f2:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    20f6:	01 96       	adiw	r24, 0x01	; 1
    20f8:	a1 1d       	adc	r26, r1
    20fa:	b1 1d       	adc	r27, r1
    20fc:	80 93 c0 30 	sts	0x30C0, r24	; 0x8030c0 <xTickCount>
    2100:	90 93 c1 30 	sts	0x30C1, r25	; 0x8030c1 <xTickCount+0x1>
    2104:	a0 93 c2 30 	sts	0x30C2, r26	; 0x8030c2 <xTickCount+0x2>
    2108:	b0 93 c3 30 	sts	0x30C3, r27	; 0x8030c3 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    210c:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2110:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2114:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2118:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    211c:	89 2b       	or	r24, r25
    211e:	8a 2b       	or	r24, r26
    2120:	8b 2b       	or	r24, r27
    2122:	f1 f5       	brne	.+124    	; 0x21a0 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2124:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2128:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    212c:	20 91 d2 30 	lds	r18, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    2130:	30 91 d3 30 	lds	r19, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    2134:	20 93 d4 30 	sts	0x30D4, r18	; 0x8030d4 <pxDelayedTaskList>
    2138:	30 93 d5 30 	sts	0x30D5, r19	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    213c:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    2140:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2144:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2148:	8f 5f       	subi	r24, 0xFF	; 255
    214a:	80 93 b9 30 	sts	0x30B9, r24	; 0x8030b9 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    214e:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2152:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2156:	80 81       	ld	r24, Z
    2158:	81 11       	cpse	r24, r1
    215a:	0c c0       	rjmp	.+24     	; 0x2174 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    215c:	8f ef       	ldi	r24, 0xFF	; 255
    215e:	9f ef       	ldi	r25, 0xFF	; 255
    2160:	dc 01       	movw	r26, r24
    2162:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2166:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    216a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    216e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2172:	16 c0       	rjmp	.+44     	; 0x21a0 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2174:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2178:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    217c:	07 80       	ldd	r0, Z+7	; 0x07
    217e:	f0 85       	ldd	r31, Z+8	; 0x08
    2180:	e0 2d       	mov	r30, r0
    2182:	00 84       	ldd	r0, Z+8	; 0x08
    2184:	f1 85       	ldd	r31, Z+9	; 0x09
    2186:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2188:	82 81       	ldd	r24, Z+2	; 0x02
    218a:	93 81       	ldd	r25, Z+3	; 0x03
    218c:	a4 81       	ldd	r26, Z+4	; 0x04
    218e:	b5 81       	ldd	r27, Z+5	; 0x05
    2190:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2194:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2198:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    219c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    21a0:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    21a4:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    21a8:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    21ac:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    21b0:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    21b4:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21b8:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21bc:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21c0:	48 17       	cp	r20, r24
    21c2:	59 07       	cpc	r21, r25
    21c4:	6a 07       	cpc	r22, r26
    21c6:	7b 07       	cpc	r23, r27
    21c8:	08 f4       	brcc	.+2      	; 0x21cc <vTaskIncrementTick+0xf8>
    21ca:	7f c0       	rjmp	.+254    	; 0x22ca <vTaskIncrementTick+0x1f6>
    21cc:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    21d0:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    21d4:	80 81       	ld	r24, Z
    21d6:	88 23       	and	r24, r24
    21d8:	f9 f0       	breq	.+62     	; 0x2218 <vTaskIncrementTick+0x144>
    21da:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    21de:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    21e2:	07 80       	ldd	r0, Z+7	; 0x07
    21e4:	f0 85       	ldd	r31, Z+8	; 0x08
    21e6:	e0 2d       	mov	r30, r0
    21e8:	c0 85       	ldd	r28, Z+8	; 0x08
    21ea:	d1 85       	ldd	r29, Z+9	; 0x09
    21ec:	8a 81       	ldd	r24, Y+2	; 0x02
    21ee:	9b 81       	ldd	r25, Y+3	; 0x03
    21f0:	ac 81       	ldd	r26, Y+4	; 0x04
    21f2:	bd 81       	ldd	r27, Y+5	; 0x05
    21f4:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    21f8:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    21fc:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2200:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2204:	48 17       	cp	r20, r24
    2206:	59 07       	cpc	r21, r25
    2208:	6a 07       	cpc	r22, r26
    220a:	7b 07       	cpc	r23, r27
    220c:	58 f1       	brcs	.+86     	; 0x2264 <vTaskIncrementTick+0x190>
    220e:	0f 2e       	mov	r0, r31
    2210:	fb e0       	ldi	r31, 0x0B	; 11
    2212:	ff 2e       	mov	r15, r31
    2214:	f0 2d       	mov	r31, r0
    2216:	2f c0       	rjmp	.+94     	; 0x2276 <vTaskIncrementTick+0x1a2>
    2218:	8f ef       	ldi	r24, 0xFF	; 255
    221a:	9f ef       	ldi	r25, 0xFF	; 255
    221c:	dc 01       	movw	r26, r24
    221e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2222:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2226:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    222a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    222e:	4d c0       	rjmp	.+154    	; 0x22ca <vTaskIncrementTick+0x1f6>
    2230:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2234:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2238:	07 80       	ldd	r0, Z+7	; 0x07
    223a:	f0 85       	ldd	r31, Z+8	; 0x08
    223c:	e0 2d       	mov	r30, r0
    223e:	c0 85       	ldd	r28, Z+8	; 0x08
    2240:	d1 85       	ldd	r29, Z+9	; 0x09
    2242:	8a 81       	ldd	r24, Y+2	; 0x02
    2244:	9b 81       	ldd	r25, Y+3	; 0x03
    2246:	ac 81       	ldd	r26, Y+4	; 0x04
    2248:	bd 81       	ldd	r27, Y+5	; 0x05
    224a:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    224e:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2252:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2256:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    225a:	48 17       	cp	r20, r24
    225c:	59 07       	cpc	r21, r25
    225e:	6a 07       	cpc	r22, r26
    2260:	7b 07       	cpc	r23, r27
    2262:	48 f4       	brcc	.+18     	; 0x2276 <vTaskIncrementTick+0x1a2>
    2264:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2268:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    226c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2270:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2274:	2a c0       	rjmp	.+84     	; 0x22ca <vTaskIncrementTick+0x1f6>
    2276:	8e 01       	movw	r16, r28
    2278:	0e 5f       	subi	r16, 0xFE	; 254
    227a:	1f 4f       	sbci	r17, 0xFF	; 255
    227c:	c8 01       	movw	r24, r16
    227e:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>
    2282:	88 8d       	ldd	r24, Y+24	; 0x18
    2284:	99 8d       	ldd	r25, Y+25	; 0x19
    2286:	89 2b       	or	r24, r25
    2288:	21 f0       	breq	.+8      	; 0x2292 <vTaskIncrementTick+0x1be>
    228a:	ce 01       	movw	r24, r28
    228c:	0e 96       	adiw	r24, 0x0e	; 14
    228e:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>
    2292:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2294:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2298:	98 17       	cp	r25, r24
    229a:	10 f4       	brcc	.+4      	; 0x22a0 <vTaskIncrementTick+0x1cc>
    229c:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    22a0:	f8 9e       	mul	r15, r24
    22a2:	c0 01       	movw	r24, r0
    22a4:	11 24       	eor	r1, r1
    22a6:	b8 01       	movw	r22, r16
    22a8:	84 51       	subi	r24, 0x14	; 20
    22aa:	9f 4c       	sbci	r25, 0xCF	; 207
    22ac:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vListInsertEnd>
    22b0:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    22b4:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    22b8:	80 81       	ld	r24, Z
    22ba:	81 11       	cpse	r24, r1
    22bc:	b9 cf       	rjmp	.-142    	; 0x2230 <vTaskIncrementTick+0x15c>
    22be:	ac cf       	rjmp	.-168    	; 0x2218 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22c0:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    22c4:	8f 5f       	subi	r24, 0xFF	; 255
    22c6:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22ca:	df 91       	pop	r29
    22cc:	cf 91       	pop	r28
    22ce:	1f 91       	pop	r17
    22d0:	0f 91       	pop	r16
    22d2:	ff 90       	pop	r15
    22d4:	08 95       	ret

000022d6 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22d6:	cf 92       	push	r12
    22d8:	df 92       	push	r13
    22da:	ef 92       	push	r14
    22dc:	ff 92       	push	r15
    22de:	0f 93       	push	r16
    22e0:	1f 93       	push	r17
    22e2:	cf 93       	push	r28
    22e4:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    22e6:	0f b6       	in	r0, 0x3f	; 63
    22e8:	f8 94       	cli
    22ea:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    22ec:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    22f0:	81 50       	subi	r24, 0x01	; 1
    22f2:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22f6:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    22fa:	81 11       	cpse	r24, r1
    22fc:	60 c0       	rjmp	.+192    	; 0x23be <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    22fe:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    2302:	81 11       	cpse	r24, r1
    2304:	2c c0       	rjmp	.+88     	; 0x235e <xTaskResumeAll+0x88>
    2306:	5e c0       	rjmp	.+188    	; 0x23c4 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2308:	d7 01       	movw	r26, r14
    230a:	17 96       	adiw	r26, 0x07	; 7
    230c:	ed 91       	ld	r30, X+
    230e:	fc 91       	ld	r31, X
    2310:	18 97       	sbiw	r26, 0x08	; 8
    2312:	c0 85       	ldd	r28, Z+8	; 0x08
    2314:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2316:	ce 01       	movw	r24, r28
    2318:	0e 96       	adiw	r24, 0x0e	; 14
    231a:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    231e:	8e 01       	movw	r16, r28
    2320:	0e 5f       	subi	r16, 0xFE	; 254
    2322:	1f 4f       	sbci	r17, 0xFF	; 255
    2324:	c8 01       	movw	r24, r16
    2326:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    232a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    232c:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2330:	98 17       	cp	r25, r24
    2332:	10 f4       	brcc	.+4      	; 0x2338 <xTaskResumeAll+0x62>
    2334:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2338:	d8 9e       	mul	r13, r24
    233a:	c0 01       	movw	r24, r0
    233c:	11 24       	eor	r1, r1
    233e:	b8 01       	movw	r22, r16
    2340:	84 51       	subi	r24, 0x14	; 20
    2342:	9f 4c       	sbci	r25, 0xCF	; 207
    2344:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2348:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    234c:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2350:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2352:	82 8d       	ldd	r24, Z+26	; 0x1a
    2354:	98 17       	cp	r25, r24
    2356:	70 f0       	brcs	.+28     	; 0x2374 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2358:	cc 24       	eor	r12, r12
    235a:	c3 94       	inc	r12
    235c:	0b c0       	rjmp	.+22     	; 0x2374 <xTaskResumeAll+0x9e>
    235e:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2360:	0f 2e       	mov	r0, r31
    2362:	f7 ec       	ldi	r31, 0xC7	; 199
    2364:	ef 2e       	mov	r14, r31
    2366:	f0 e3       	ldi	r31, 0x30	; 48
    2368:	ff 2e       	mov	r15, r31
    236a:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    236c:	0f 2e       	mov	r0, r31
    236e:	fb e0       	ldi	r31, 0x0B	; 11
    2370:	df 2e       	mov	r13, r31
    2372:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2374:	f7 01       	movw	r30, r14
    2376:	80 81       	ld	r24, Z
    2378:	81 11       	cpse	r24, r1
    237a:	c6 cf       	rjmp	.-116    	; 0x2308 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    237c:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2380:	88 23       	and	r24, r24
    2382:	81 f0       	breq	.+32     	; 0x23a4 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2384:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2388:	88 23       	and	r24, r24
    238a:	99 f0       	breq	.+38     	; 0x23b2 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    238c:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <vTaskIncrementTick>
						--uxMissedTicks;
    2390:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2394:	81 50       	subi	r24, 0x01	; 1
    2396:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    239a:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    239e:	81 11       	cpse	r24, r1
    23a0:	f5 cf       	rjmp	.-22     	; 0x238c <xTaskResumeAll+0xb6>
    23a2:	07 c0       	rjmp	.+14     	; 0x23b2 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    23a4:	f1 e0       	ldi	r31, 0x01	; 1
    23a6:	cf 16       	cp	r12, r31
    23a8:	21 f0       	breq	.+8      	; 0x23b2 <xTaskResumeAll+0xdc>
    23aa:	80 91 ba 30 	lds	r24, 0x30BA	; 0x8030ba <xMissedYield>
    23ae:	81 30       	cpi	r24, 0x01	; 1
    23b0:	41 f4       	brne	.+16     	; 0x23c2 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23b2:	10 92 ba 30 	sts	0x30BA, r1	; 0x8030ba <xMissedYield>
					portYIELD_WITHIN_API();
    23b6:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23ba:	81 e0       	ldi	r24, 0x01	; 1
    23bc:	03 c0       	rjmp	.+6      	; 0x23c4 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23be:	80 e0       	ldi	r24, 0x00	; 0
    23c0:	01 c0       	rjmp	.+2      	; 0x23c4 <xTaskResumeAll+0xee>
    23c2:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23c4:	0f 90       	pop	r0
    23c6:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23c8:	df 91       	pop	r29
    23ca:	cf 91       	pop	r28
    23cc:	1f 91       	pop	r17
    23ce:	0f 91       	pop	r16
    23d0:	ff 90       	pop	r15
    23d2:	ef 90       	pop	r14
    23d4:	df 90       	pop	r13
    23d6:	cf 90       	pop	r12
    23d8:	08 95       	ret

000023da <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    23da:	cf 92       	push	r12
    23dc:	df 92       	push	r13
    23de:	ef 92       	push	r14
    23e0:	ff 92       	push	r15
    23e2:	cf 93       	push	r28
    23e4:	df 93       	push	r29
    23e6:	ec 01       	movw	r28, r24
    23e8:	6a 01       	movw	r12, r20
    23ea:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    23ec:	0e 94 49 10 	call	0x2092	; 0x2092 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    23f0:	88 81       	ld	r24, Y
    23f2:	99 81       	ldd	r25, Y+1	; 0x01
    23f4:	aa 81       	ldd	r26, Y+2	; 0x02
    23f6:	bb 81       	ldd	r27, Y+3	; 0x03
    23f8:	c8 0e       	add	r12, r24
    23fa:	d9 1e       	adc	r13, r25
    23fc:	ea 1e       	adc	r14, r26
    23fe:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2400:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    2404:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2408:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    240c:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2410:	48 17       	cp	r20, r24
    2412:	59 07       	cpc	r21, r25
    2414:	6a 07       	cpc	r22, r26
    2416:	7b 07       	cpc	r23, r27
    2418:	b8 f4       	brcc	.+46     	; 0x2448 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    241a:	c8 16       	cp	r12, r24
    241c:	d9 06       	cpc	r13, r25
    241e:	ea 06       	cpc	r14, r26
    2420:	fb 06       	cpc	r15, r27
    2422:	e0 f5       	brcc	.+120    	; 0x249c <vTaskDelayUntil+0xc2>
    2424:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2428:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    242c:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2430:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2434:	c8 82       	st	Y, r12
    2436:	d9 82       	std	Y+1, r13	; 0x01
    2438:	ea 82       	std	Y+2, r14	; 0x02
    243a:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    243c:	8c 15       	cp	r24, r12
    243e:	9d 05       	cpc	r25, r13
    2440:	ae 05       	cpc	r26, r14
    2442:	bf 05       	cpc	r27, r15
    2444:	f8 f4       	brcc	.+62     	; 0x2484 <vTaskDelayUntil+0xaa>
    2446:	13 c0       	rjmp	.+38     	; 0x246e <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2448:	c8 16       	cp	r12, r24
    244a:	d9 06       	cpc	r13, r25
    244c:	ea 06       	cpc	r14, r26
    244e:	fb 06       	cpc	r15, r27
    2450:	00 f1       	brcs	.+64     	; 0x2492 <vTaskDelayUntil+0xb8>
    2452:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2456:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    245a:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    245e:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2462:	8c 15       	cp	r24, r12
    2464:	9d 05       	cpc	r25, r13
    2466:	ae 05       	cpc	r26, r14
    2468:	bf 05       	cpc	r27, r15
    246a:	98 f0       	brcs	.+38     	; 0x2492 <vTaskDelayUntil+0xb8>
    246c:	17 c0       	rjmp	.+46     	; 0x249c <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    246e:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2472:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2476:	02 96       	adiw	r24, 0x02	; 2
    2478:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    247c:	c7 01       	movw	r24, r14
    247e:	b6 01       	movw	r22, r12
    2480:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2484:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2488:	81 11       	cpse	r24, r1
    248a:	0d c0       	rjmp	.+26     	; 0x24a6 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    248c:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
		}
	}
    2490:	0a c0       	rjmp	.+20     	; 0x24a6 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2492:	c8 82       	st	Y, r12
    2494:	d9 82       	std	Y+1, r13	; 0x01
    2496:	ea 82       	std	Y+2, r14	; 0x02
    2498:	fb 82       	std	Y+3, r15	; 0x03
    249a:	e9 cf       	rjmp	.-46     	; 0x246e <vTaskDelayUntil+0x94>
    249c:	c8 82       	st	Y, r12
    249e:	d9 82       	std	Y+1, r13	; 0x01
    24a0:	ea 82       	std	Y+2, r14	; 0x02
    24a2:	fb 82       	std	Y+3, r15	; 0x03
    24a4:	ef cf       	rjmp	.-34     	; 0x2484 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    24a6:	df 91       	pop	r29
    24a8:	cf 91       	pop	r28
    24aa:	ff 90       	pop	r15
    24ac:	ef 90       	pop	r14
    24ae:	df 90       	pop	r13
    24b0:	cf 90       	pop	r12
    24b2:	08 95       	ret

000024b4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    24b4:	cf 92       	push	r12
    24b6:	df 92       	push	r13
    24b8:	ef 92       	push	r14
    24ba:	ff 92       	push	r15
    24bc:	6b 01       	movw	r12, r22
    24be:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24c0:	67 2b       	or	r22, r23
    24c2:	68 2b       	or	r22, r24
    24c4:	69 2b       	or	r22, r25
    24c6:	e9 f0       	breq	.+58     	; 0x2502 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    24c8:	0e 94 49 10 	call	0x2092	; 0x2092 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24cc:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    24d0:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    24d4:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    24d8:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    24dc:	c8 0e       	add	r12, r24
    24de:	d9 1e       	adc	r13, r25
    24e0:	ea 1e       	adc	r14, r26
    24e2:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24e4:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    24e8:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    24ec:	02 96       	adiw	r24, 0x02	; 2
    24ee:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24f2:	c7 01       	movw	r24, r14
    24f4:	b6 01       	movw	r22, r12
    24f6:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    24fa:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24fe:	81 11       	cpse	r24, r1
    2500:	02 c0       	rjmp	.+4      	; 0x2506 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2502:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <vPortYield>
		}
	}
    2506:	ff 90       	pop	r15
    2508:	ef 90       	pop	r14
    250a:	df 90       	pop	r13
    250c:	cf 90       	pop	r12
    250e:	08 95       	ret

00002510 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2510:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2514:	81 11       	cpse	r24, r1
    2516:	0c c0       	rjmp	.+24     	; 0x2530 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2518:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    251c:	4b e0       	ldi	r20, 0x0B	; 11
    251e:	e4 9f       	mul	r30, r20
    2520:	f0 01       	movw	r30, r0
    2522:	11 24       	eor	r1, r1
    2524:	e4 51       	subi	r30, 0x14	; 20
    2526:	ff 4c       	sbci	r31, 0xCF	; 207
    2528:	80 81       	ld	r24, Z
    252a:	88 23       	and	r24, r24
    252c:	29 f0       	breq	.+10     	; 0x2538 <vTaskSwitchContext+0x28>
    252e:	14 c0       	rjmp	.+40     	; 0x2558 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2530:	81 e0       	ldi	r24, 0x01	; 1
    2532:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    2536:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2538:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    253a:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    253e:	81 50       	subi	r24, 0x01	; 1
    2540:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2544:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2548:	9e 9f       	mul	r25, r30
    254a:	f0 01       	movw	r30, r0
    254c:	11 24       	eor	r1, r1
    254e:	e4 51       	subi	r30, 0x14	; 20
    2550:	ff 4c       	sbci	r31, 0xCF	; 207
    2552:	80 81       	ld	r24, Z
    2554:	88 23       	and	r24, r24
    2556:	89 f3       	breq	.-30     	; 0x253a <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2558:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    255c:	28 2f       	mov	r18, r24
    255e:	30 e0       	ldi	r19, 0x00	; 0
    2560:	4b e0       	ldi	r20, 0x0B	; 11
    2562:	84 9f       	mul	r24, r20
    2564:	c0 01       	movw	r24, r0
    2566:	11 24       	eor	r1, r1
    2568:	dc 01       	movw	r26, r24
    256a:	a4 51       	subi	r26, 0x14	; 20
    256c:	bf 4c       	sbci	r27, 0xCF	; 207
    256e:	11 96       	adiw	r26, 0x01	; 1
    2570:	ed 91       	ld	r30, X+
    2572:	fc 91       	ld	r31, X
    2574:	12 97       	sbiw	r26, 0x02	; 2
    2576:	04 80       	ldd	r0, Z+4	; 0x04
    2578:	f5 81       	ldd	r31, Z+5	; 0x05
    257a:	e0 2d       	mov	r30, r0
    257c:	11 96       	adiw	r26, 0x01	; 1
    257e:	ed 93       	st	X+, r30
    2580:	fc 93       	st	X, r31
    2582:	12 97       	sbiw	r26, 0x02	; 2
    2584:	81 51       	subi	r24, 0x11	; 17
    2586:	9f 4c       	sbci	r25, 0xCF	; 207
    2588:	e8 17       	cp	r30, r24
    258a:	f9 07       	cpc	r31, r25
    258c:	61 f4       	brne	.+24     	; 0x25a6 <vTaskSwitchContext+0x96>
    258e:	84 81       	ldd	r24, Z+4	; 0x04
    2590:	95 81       	ldd	r25, Z+5	; 0x05
    2592:	4b e0       	ldi	r20, 0x0B	; 11
    2594:	42 9f       	mul	r20, r18
    2596:	f0 01       	movw	r30, r0
    2598:	43 9f       	mul	r20, r19
    259a:	f0 0d       	add	r31, r0
    259c:	11 24       	eor	r1, r1
    259e:	e4 51       	subi	r30, 0x14	; 20
    25a0:	ff 4c       	sbci	r31, 0xCF	; 207
    25a2:	81 83       	std	Z+1, r24	; 0x01
    25a4:	92 83       	std	Z+2, r25	; 0x02
    25a6:	8b e0       	ldi	r24, 0x0B	; 11
    25a8:	82 9f       	mul	r24, r18
    25aa:	f0 01       	movw	r30, r0
    25ac:	83 9f       	mul	r24, r19
    25ae:	f0 0d       	add	r31, r0
    25b0:	11 24       	eor	r1, r1
    25b2:	e4 51       	subi	r30, 0x14	; 20
    25b4:	ff 4c       	sbci	r31, 0xCF	; 207
    25b6:	01 80       	ldd	r0, Z+1	; 0x01
    25b8:	f2 81       	ldd	r31, Z+2	; 0x02
    25ba:	e0 2d       	mov	r30, r0
    25bc:	80 85       	ldd	r24, Z+8	; 0x08
    25be:	91 85       	ldd	r25, Z+9	; 0x09
    25c0:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <pxCurrentTCB>
    25c4:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <pxCurrentTCB+0x1>
    25c8:	08 95       	ret

000025ca <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25ca:	cf 92       	push	r12
    25cc:	df 92       	push	r13
    25ce:	ef 92       	push	r14
    25d0:	ff 92       	push	r15
    25d2:	6a 01       	movw	r12, r20
    25d4:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25d6:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    25da:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    25de:	62 5f       	subi	r22, 0xF2	; 242
    25e0:	7f 4f       	sbci	r23, 0xFF	; 255
    25e2:	0e 94 43 0a 	call	0x1486	; 0x1486 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25e6:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    25ea:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    25ee:	02 96       	adiw	r24, 0x02	; 2
    25f0:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    25f4:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    25f8:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    25fc:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2600:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2604:	bc 01       	movw	r22, r24
    2606:	cd 01       	movw	r24, r26
    2608:	6c 0d       	add	r22, r12
    260a:	7d 1d       	adc	r23, r13
    260c:	8e 1d       	adc	r24, r14
    260e:	9f 1d       	adc	r25, r15
    2610:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2614:	ff 90       	pop	r15
    2616:	ef 90       	pop	r14
    2618:	df 90       	pop	r13
    261a:	cf 90       	pop	r12
    261c:	08 95       	ret

0000261e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    261e:	0f 93       	push	r16
    2620:	1f 93       	push	r17
    2622:	cf 93       	push	r28
    2624:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2626:	dc 01       	movw	r26, r24
    2628:	17 96       	adiw	r26, 0x07	; 7
    262a:	ed 91       	ld	r30, X+
    262c:	fc 91       	ld	r31, X
    262e:	18 97       	sbiw	r26, 0x08	; 8
    2630:	c0 85       	ldd	r28, Z+8	; 0x08
    2632:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2634:	8e 01       	movw	r16, r28
    2636:	02 5f       	subi	r16, 0xF2	; 242
    2638:	1f 4f       	sbci	r17, 0xFF	; 255
    263a:	c8 01       	movw	r24, r16
    263c:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2640:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2644:	81 11       	cpse	r24, r1
    2646:	16 c0       	rjmp	.+44     	; 0x2674 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2648:	0c 50       	subi	r16, 0x0C	; 12
    264a:	11 09       	sbc	r17, r1
    264c:	c8 01       	movw	r24, r16
    264e:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2652:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2654:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2658:	98 17       	cp	r25, r24
    265a:	10 f4       	brcc	.+4      	; 0x2660 <xTaskRemoveFromEventList+0x42>
    265c:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2660:	bb e0       	ldi	r27, 0x0B	; 11
    2662:	8b 9f       	mul	r24, r27
    2664:	c0 01       	movw	r24, r0
    2666:	11 24       	eor	r1, r1
    2668:	b8 01       	movw	r22, r16
    266a:	84 51       	subi	r24, 0x14	; 20
    266c:	9f 4c       	sbci	r25, 0xCF	; 207
    266e:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vListInsertEnd>
    2672:	05 c0       	rjmp	.+10     	; 0x267e <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2674:	b8 01       	movw	r22, r16
    2676:	87 ec       	ldi	r24, 0xC7	; 199
    2678:	90 e3       	ldi	r25, 0x30	; 48
    267a:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    267e:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2682:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2686:	81 e0       	ldi	r24, 0x01	; 1
    2688:	2a 8d       	ldd	r18, Y+26	; 0x1a
    268a:	92 8d       	ldd	r25, Z+26	; 0x1a
    268c:	29 17       	cp	r18, r25
    268e:	08 f4       	brcc	.+2      	; 0x2692 <xTaskRemoveFromEventList+0x74>
    2690:	80 e0       	ldi	r24, 0x00	; 0
}
    2692:	df 91       	pop	r29
    2694:	cf 91       	pop	r28
    2696:	1f 91       	pop	r17
    2698:	0f 91       	pop	r16
    269a:	08 95       	ret

0000269c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    269c:	20 91 b9 30 	lds	r18, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    26a0:	fc 01       	movw	r30, r24
    26a2:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    26a4:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    26a8:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    26ac:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    26b0:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    26b4:	41 83       	std	Z+1, r20	; 0x01
    26b6:	52 83       	std	Z+2, r21	; 0x02
    26b8:	63 83       	std	Z+3, r22	; 0x03
    26ba:	74 83       	std	Z+4, r23	; 0x04
    26bc:	08 95       	ret

000026be <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26be:	8f 92       	push	r8
    26c0:	9f 92       	push	r9
    26c2:	af 92       	push	r10
    26c4:	bf 92       	push	r11
    26c6:	cf 92       	push	r12
    26c8:	df 92       	push	r13
    26ca:	ef 92       	push	r14
    26cc:	ff 92       	push	r15
    26ce:	0f 93       	push	r16
    26d0:	1f 93       	push	r17
    26d2:	cf 93       	push	r28
    26d4:	df 93       	push	r29
    26d6:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26d8:	0f b6       	in	r0, 0x3f	; 63
    26da:	f8 94       	cli
    26dc:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26de:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    26e2:	90 81       	ld	r25, Z
    26e4:	98 17       	cp	r25, r24
    26e6:	89 f0       	breq	.+34     	; 0x270a <xTaskCheckForTimeOut+0x4c>
    26e8:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    26ec:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    26f0:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    26f4:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    26f8:	01 81       	ldd	r16, Z+1	; 0x01
    26fa:	12 81       	ldd	r17, Z+2	; 0x02
    26fc:	23 81       	ldd	r18, Z+3	; 0x03
    26fe:	34 81       	ldd	r19, Z+4	; 0x04
    2700:	80 17       	cp	r24, r16
    2702:	91 07       	cpc	r25, r17
    2704:	a2 07       	cpc	r26, r18
    2706:	b3 07       	cpc	r27, r19
    2708:	a8 f5       	brcc	.+106    	; 0x2774 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    270a:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    270e:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2712:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2716:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    271a:	c1 80       	ldd	r12, Z+1	; 0x01
    271c:	d2 80       	ldd	r13, Z+2	; 0x02
    271e:	e3 80       	ldd	r14, Z+3	; 0x03
    2720:	f4 80       	ldd	r15, Z+4	; 0x04
    2722:	eb 01       	movw	r28, r22
    2724:	08 81       	ld	r16, Y
    2726:	19 81       	ldd	r17, Y+1	; 0x01
    2728:	2a 81       	ldd	r18, Y+2	; 0x02
    272a:	3b 81       	ldd	r19, Y+3	; 0x03
    272c:	8c 19       	sub	r24, r12
    272e:	9d 09       	sbc	r25, r13
    2730:	ae 09       	sbc	r26, r14
    2732:	bf 09       	sbc	r27, r15
    2734:	80 17       	cp	r24, r16
    2736:	91 07       	cpc	r25, r17
    2738:	a2 07       	cpc	r26, r18
    273a:	b3 07       	cpc	r27, r19
    273c:	e8 f4       	brcc	.+58     	; 0x2778 <xTaskCheckForTimeOut+0xba>
    273e:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2740:	80 90 c0 30 	lds	r8, 0x30C0	; 0x8030c0 <xTickCount>
    2744:	90 90 c1 30 	lds	r9, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2748:	a0 90 c2 30 	lds	r10, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    274c:	b0 90 c3 30 	lds	r11, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2750:	b5 01       	movw	r22, r10
    2752:	a4 01       	movw	r20, r8
    2754:	4c 19       	sub	r20, r12
    2756:	5d 09       	sbc	r21, r13
    2758:	6e 09       	sbc	r22, r14
    275a:	7f 09       	sbc	r23, r15
    275c:	04 1b       	sub	r16, r20
    275e:	15 0b       	sbc	r17, r21
    2760:	26 0b       	sbc	r18, r22
    2762:	37 0b       	sbc	r19, r23
    2764:	08 83       	st	Y, r16
    2766:	19 83       	std	Y+1, r17	; 0x01
    2768:	2a 83       	std	Y+2, r18	; 0x02
    276a:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    276c:	0e 94 4e 13 	call	0x269c	; 0x269c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2770:	80 e0       	ldi	r24, 0x00	; 0
    2772:	03 c0       	rjmp	.+6      	; 0x277a <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2774:	81 e0       	ldi	r24, 0x01	; 1
    2776:	01 c0       	rjmp	.+2      	; 0x277a <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2778:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    277a:	0f 90       	pop	r0
    277c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    277e:	df 91       	pop	r29
    2780:	cf 91       	pop	r28
    2782:	1f 91       	pop	r17
    2784:	0f 91       	pop	r16
    2786:	ff 90       	pop	r15
    2788:	ef 90       	pop	r14
    278a:	df 90       	pop	r13
    278c:	cf 90       	pop	r12
    278e:	bf 90       	pop	r11
    2790:	af 90       	pop	r10
    2792:	9f 90       	pop	r9
    2794:	8f 90       	pop	r8
    2796:	08 95       	ret

00002798 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2798:	81 e0       	ldi	r24, 0x01	; 1
    279a:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    279e:	08 95       	ret

000027a0 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27a0:	00 97       	sbiw	r24, 0x00	; 0
    27a2:	21 f4       	brne	.+8      	; 0x27ac <uxTaskGetStackHighWaterMark+0xc>
    27a4:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    27a8:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    27ac:	dc 01       	movw	r26, r24
    27ae:	5b 96       	adiw	r26, 0x1b	; 27
    27b0:	ed 91       	ld	r30, X+
    27b2:	fc 91       	ld	r31, X
    27b4:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27b6:	80 81       	ld	r24, Z
    27b8:	81 31       	cpi	r24, 0x11	; 17
    27ba:	41 f4       	brne	.+16     	; 0x27cc <uxTaskGetStackHighWaterMark+0x2c>
    27bc:	31 96       	adiw	r30, 0x01	; 1
    27be:	80 e0       	ldi	r24, 0x00	; 0
    27c0:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27c2:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27c4:	21 91       	ld	r18, Z+
    27c6:	21 31       	cpi	r18, 0x11	; 17
    27c8:	e1 f3       	breq	.-8      	; 0x27c2 <uxTaskGetStackHighWaterMark+0x22>
    27ca:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27cc:	80 e0       	ldi	r24, 0x00	; 0
    27ce:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27d0:	08 95       	ret

000027d2 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27d2:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    27d6:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		return xReturn;
	}
    27da:	08 95       	ret

000027dc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27dc:	0f 93       	push	r16
    27de:	1f 93       	push	r17
    27e0:	cf 93       	push	r28
    27e2:	df 93       	push	r29
    27e4:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    27e6:	22 8d       	ldd	r18, Z+26	; 0x1a
    27e8:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    27ec:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    27f0:	5a 96       	adiw	r26, 0x1a	; 26
    27f2:	8c 91       	ld	r24, X
    27f4:	28 17       	cp	r18, r24
    27f6:	08 f0       	brcs	.+2      	; 0x27fa <vTaskPriorityInherit+0x1e>
    27f8:	41 c0       	rjmp	.+130    	; 0x287c <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    27fa:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    27fe:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2802:	5a 96       	adiw	r26, 0x1a	; 26
    2804:	3c 91       	ld	r19, X
    2806:	84 e0       	ldi	r24, 0x04	; 4
    2808:	90 e0       	ldi	r25, 0x00	; 0
    280a:	a0 e0       	ldi	r26, 0x00	; 0
    280c:	b0 e0       	ldi	r27, 0x00	; 0
    280e:	83 1b       	sub	r24, r19
    2810:	91 09       	sbc	r25, r1
    2812:	a1 09       	sbc	r26, r1
    2814:	b1 09       	sbc	r27, r1
    2816:	86 87       	std	Z+14, r24	; 0x0e
    2818:	97 87       	std	Z+15, r25	; 0x0f
    281a:	a0 8b       	std	Z+16, r26	; 0x10
    281c:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    281e:	8b e0       	ldi	r24, 0x0B	; 11
    2820:	28 9f       	mul	r18, r24
    2822:	90 01       	movw	r18, r0
    2824:	11 24       	eor	r1, r1
    2826:	24 51       	subi	r18, 0x14	; 20
    2828:	3f 4c       	sbci	r19, 0xCF	; 207
    282a:	84 85       	ldd	r24, Z+12	; 0x0c
    282c:	95 85       	ldd	r25, Z+13	; 0x0d
    282e:	82 17       	cp	r24, r18
    2830:	93 07       	cpc	r25, r19
    2832:	e9 f4       	brne	.+58     	; 0x286e <vTaskPriorityInherit+0x92>
    2834:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2836:	ef 01       	movw	r28, r30
    2838:	22 96       	adiw	r28, 0x02	; 2
    283a:	ce 01       	movw	r24, r28
    283c:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2840:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2844:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2848:	82 8d       	ldd	r24, Z+26	; 0x1a
    284a:	f8 01       	movw	r30, r16
    284c:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    284e:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2852:	98 17       	cp	r25, r24
    2854:	10 f4       	brcc	.+4      	; 0x285a <vTaskPriorityInherit+0x7e>
    2856:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    285a:	fb e0       	ldi	r31, 0x0B	; 11
    285c:	8f 9f       	mul	r24, r31
    285e:	c0 01       	movw	r24, r0
    2860:	11 24       	eor	r1, r1
    2862:	be 01       	movw	r22, r28
    2864:	84 51       	subi	r24, 0x14	; 20
    2866:	9f 4c       	sbci	r25, 0xCF	; 207
    2868:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vListInsertEnd>
    286c:	07 c0       	rjmp	.+14     	; 0x287c <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    286e:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2872:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2876:	5a 96       	adiw	r26, 0x1a	; 26
    2878:	8c 91       	ld	r24, X
    287a:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    287c:	df 91       	pop	r29
    287e:	cf 91       	pop	r28
    2880:	1f 91       	pop	r17
    2882:	0f 91       	pop	r16
    2884:	08 95       	ret

00002886 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2886:	0f 93       	push	r16
    2888:	1f 93       	push	r17
    288a:	cf 93       	push	r28
    288c:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    288e:	00 97       	sbiw	r24, 0x00	; 0
    2890:	49 f1       	breq	.+82     	; 0x28e4 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2892:	fc 01       	movw	r30, r24
    2894:	32 8d       	ldd	r19, Z+26	; 0x1a
    2896:	27 a1       	ldd	r18, Z+39	; 0x27
    2898:	32 17       	cp	r19, r18
    289a:	21 f1       	breq	.+72     	; 0x28e4 <vTaskPriorityDisinherit+0x5e>
    289c:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    289e:	8c 01       	movw	r16, r24
    28a0:	0e 5f       	subi	r16, 0xFE	; 254
    28a2:	1f 4f       	sbci	r17, 0xFF	; 255
    28a4:	c8 01       	movw	r24, r16
    28a6:	0e 94 8e 0a 	call	0x151c	; 0x151c <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28aa:	8f a1       	ldd	r24, Y+39	; 0x27
    28ac:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28ae:	44 e0       	ldi	r20, 0x04	; 4
    28b0:	50 e0       	ldi	r21, 0x00	; 0
    28b2:	60 e0       	ldi	r22, 0x00	; 0
    28b4:	70 e0       	ldi	r23, 0x00	; 0
    28b6:	48 1b       	sub	r20, r24
    28b8:	51 09       	sbc	r21, r1
    28ba:	61 09       	sbc	r22, r1
    28bc:	71 09       	sbc	r23, r1
    28be:	4e 87       	std	Y+14, r20	; 0x0e
    28c0:	5f 87       	std	Y+15, r21	; 0x0f
    28c2:	68 8b       	std	Y+16, r22	; 0x10
    28c4:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28c6:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    28ca:	98 17       	cp	r25, r24
    28cc:	10 f4       	brcc	.+4      	; 0x28d2 <vTaskPriorityDisinherit+0x4c>
    28ce:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    28d2:	fb e0       	ldi	r31, 0x0B	; 11
    28d4:	8f 9f       	mul	r24, r31
    28d6:	c0 01       	movw	r24, r0
    28d8:	11 24       	eor	r1, r1
    28da:	b8 01       	movw	r22, r16
    28dc:	84 51       	subi	r24, 0x14	; 20
    28de:	9f 4c       	sbci	r25, 0xCF	; 207
    28e0:	0e 94 1c 0a 	call	0x1438	; 0x1438 <vListInsertEnd>
			}
		}
	}
    28e4:	df 91       	pop	r29
    28e6:	cf 91       	pop	r28
    28e8:	1f 91       	pop	r17
    28ea:	0f 91       	pop	r16
    28ec:	08 95       	ret

000028ee <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    28ee:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    28f0:	e8 81       	ld	r30, Y
    28f2:	f9 81       	ldd	r31, Y+1	; 0x01
    28f4:	01 90       	ld	r0, Z+
    28f6:	f0 81       	ld	r31, Z
    28f8:	e0 2d       	mov	r30, r0
    28fa:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    28fc:	1a 82       	std	Y+2, r1	; 0x02
    28fe:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2900:	6f ef       	ldi	r22, 0xFF	; 255
    2902:	7f ef       	ldi	r23, 0xFF	; 255
    2904:	cb 01       	movw	r24, r22
    2906:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <vTaskDelay>
    290a:	fa cf       	rjmp	.-12     	; 0x2900 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000290c <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    290c:	fc 01       	movw	r30, r24
    290e:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2910:	65 87       	std	Z+13, r22	; 0x0d
    2912:	08 95       	ret

00002914 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2914:	4f 92       	push	r4
    2916:	5f 92       	push	r5
    2918:	6f 92       	push	r6
    291a:	7f 92       	push	r7
    291c:	8f 92       	push	r8
    291e:	9f 92       	push	r9
    2920:	af 92       	push	r10
    2922:	bf 92       	push	r11
    2924:	cf 92       	push	r12
    2926:	df 92       	push	r13
    2928:	ef 92       	push	r14
    292a:	ff 92       	push	r15
    292c:	0f 93       	push	r16
    292e:	1f 93       	push	r17
    2930:	cf 93       	push	r28
    2932:	df 93       	push	r29
    2934:	cd b7       	in	r28, 0x3d	; 61
    2936:	de b7       	in	r29, 0x3e	; 62
    2938:	2a 97       	sbiw	r28, 0x0a	; 10
    293a:	cd bf       	out	0x3d, r28	; 61
    293c:	de bf       	out	0x3e, r29	; 62
    293e:	4c 01       	movw	r8, r24
    2940:	29 01       	movw	r4, r18
    2942:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2944:	87 e3       	ldi	r24, 0x37	; 55
    2946:	90 e2       	ldi	r25, 0x20	; 32
    2948:	f4 01       	movw	r30, r8
    294a:	80 83       	st	Z, r24
    294c:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    294e:	fb 01       	movw	r30, r22
    2950:	80 81       	ld	r24, Z
    2952:	88 23       	and	r24, r24
    2954:	69 f0       	breq	.+26     	; 0x2970 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2956:	de 01       	movw	r26, r28
    2958:	11 96       	adiw	r26, 0x01	; 1
    295a:	31 96       	adiw	r30, 0x01	; 1
    295c:	90 e0       	ldi	r25, 0x00	; 0
    295e:	02 c0       	rjmp	.+4      	; 0x2964 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2960:	99 30       	cpi	r25, 0x09	; 9
    2962:	39 f0       	breq	.+14     	; 0x2972 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2964:	9f 5f       	subi	r25, 0xFF	; 255
    2966:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2968:	81 91       	ld	r24, Z+
    296a:	81 11       	cpse	r24, r1
    296c:	f9 cf       	rjmp	.-14     	; 0x2960 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    296e:	01 c0       	rjmp	.+2      	; 0x2972 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2970:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2972:	e1 e0       	ldi	r30, 0x01	; 1
    2974:	f0 e0       	ldi	r31, 0x00	; 0
    2976:	ec 0f       	add	r30, r28
    2978:	fd 1f       	adc	r31, r29
    297a:	e9 0f       	add	r30, r25
    297c:	f1 1d       	adc	r31, r1
    297e:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2980:	74 01       	movw	r14, r8
    2982:	f2 e0       	ldi	r31, 0x02	; 2
    2984:	ef 0e       	add	r14, r31
    2986:	f1 1c       	adc	r15, r1
    2988:	a1 2c       	mov	r10, r1
    298a:	b1 2c       	mov	r11, r1
    298c:	c1 2c       	mov	r12, r1
    298e:	d1 2c       	mov	r13, r1
    2990:	04 2f       	mov	r16, r20
    2992:	94 01       	movw	r18, r8
    2994:	a2 01       	movw	r20, r4
    2996:	be 01       	movw	r22, r28
    2998:	6f 5f       	subi	r22, 0xFF	; 255
    299a:	7f 4f       	sbci	r23, 0xFF	; 255
    299c:	84 ea       	ldi	r24, 0xA4	; 164
    299e:	92 e0       	ldi	r25, 0x02	; 2
    29a0:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    29a4:	f4 01       	movw	r30, r8
    29a6:	66 82       	std	Z+6, r6	; 0x06
    29a8:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    29aa:	40 86       	std	Z+8, r4	; 0x08
    29ac:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    29ae:	20 91 1a 31 	lds	r18, 0x311A	; 0x80311a <last_created_task_pointer>
    29b2:	30 91 1b 31 	lds	r19, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    29b6:	24 83       	std	Z+4, r18	; 0x04
    29b8:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29ba:	80 92 1a 31 	sts	0x311A, r8	; 0x80311a <last_created_task_pointer>
    29be:	90 92 1b 31 	sts	0x311B, r9	; 0x80311b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29c2:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29c4:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29c6:	40 90 54 31 	lds	r4, 0x3154	; 0x803154 <portStackTopForTask>
    29ca:	50 90 55 31 	lds	r5, 0x3155	; 0x803155 <portStackTopForTask+0x1>
    29ce:	ff ef       	ldi	r31, 0xFF	; 255
    29d0:	4f 1a       	sub	r4, r31
    29d2:	5f 0a       	sbc	r5, r31
    29d4:	40 92 54 31 	sts	0x3154, r4	; 0x803154 <portStackTopForTask>
    29d8:	50 92 55 31 	sts	0x3155, r5	; 0x803155 <portStackTopForTask+0x1>
    29dc:	f4 01       	movw	r30, r8
    29de:	42 86       	std	Z+10, r4	; 0x0a
    29e0:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    29e2:	16 86       	std	Z+14, r1	; 0x0e
    29e4:	17 86       	std	Z+15, r1	; 0x0f
    29e6:	10 8a       	std	Z+16, r1	; 0x10
    29e8:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    29ea:	61 14       	cp	r6, r1
    29ec:	71 04       	cpc	r7, r1
    29ee:	09 f4       	brne	.+2      	; 0x29f2 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    29f0:	44 c0       	rjmp	.+136    	; 0x2a7a <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    29f2:	81 30       	cpi	r24, 0x01	; 1
    29f4:	79 f5       	brne	.+94     	; 0x2a54 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    29f6:	6a e0       	ldi	r22, 0x0A	; 10
    29f8:	c3 01       	movw	r24, r6
    29fa:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    29fe:	7c 01       	movw	r14, r24
    2a00:	65 e9       	ldi	r22, 0x95	; 149
    2a02:	74 e0       	ldi	r23, 0x04	; 4
    2a04:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2a08:	be 01       	movw	r22, r28
    2a0a:	6f 5f       	subi	r22, 0xFF	; 255
    2a0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a0e:	c7 01       	movw	r24, r14
    2a10:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2a14:	6a e0       	ldi	r22, 0x0A	; 10
    2a16:	c7 01       	movw	r24, r14
    2a18:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2a1c:	7c 01       	movw	r14, r24
    2a1e:	6c e8       	ldi	r22, 0x8C	; 140
    2a20:	74 e0       	ldi	r23, 0x04	; 4
    2a22:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a26:	6a e0       	ldi	r22, 0x0A	; 10
    2a28:	c7 01       	movw	r24, r14
    2a2a:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2a2e:	7c 01       	movw	r14, r24
    2a30:	6e e7       	ldi	r22, 0x7E	; 126
    2a32:	74 e0       	ldi	r23, 0x04	; 4
    2a34:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2a38:	63 e0       	ldi	r22, 0x03	; 3
    2a3a:	c7 01       	movw	r24, r14
    2a3c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2a40:	b2 01       	movw	r22, r4
    2a42:	0e 94 36 1a 	call	0x346c	; 0x346c <_ZN8emstreamlsEj>
    2a46:	62 e0       	ldi	r22, 0x02	; 2
    2a48:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2a4c:	66 e0       	ldi	r22, 0x06	; 6
    2a4e:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2a52:	13 c0       	rjmp	.+38     	; 0x2a7a <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a54:	6a e0       	ldi	r22, 0x0A	; 10
    2a56:	c3 01       	movw	r24, r6
    2a58:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2a5c:	4c 01       	movw	r8, r24
    2a5e:	69 e6       	ldi	r22, 0x69	; 105
    2a60:	74 e0       	ldi	r23, 0x04	; 4
    2a62:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2a66:	be 01       	movw	r22, r28
    2a68:	6f 5f       	subi	r22, 0xFF	; 255
    2a6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a6c:	c4 01       	movw	r24, r8
    2a6e:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2a72:	66 e0       	ldi	r22, 0x06	; 6
    2a74:	c4 01       	movw	r24, r8
    2a76:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a7a:	2a 96       	adiw	r28, 0x0a	; 10
    2a7c:	cd bf       	out	0x3d, r28	; 61
    2a7e:	de bf       	out	0x3e, r29	; 62
    2a80:	df 91       	pop	r29
    2a82:	cf 91       	pop	r28
    2a84:	1f 91       	pop	r17
    2a86:	0f 91       	pop	r16
    2a88:	ff 90       	pop	r15
    2a8a:	ef 90       	pop	r14
    2a8c:	df 90       	pop	r13
    2a8e:	cf 90       	pop	r12
    2a90:	bf 90       	pop	r11
    2a92:	af 90       	pop	r10
    2a94:	9f 90       	pop	r9
    2a96:	8f 90       	pop	r8
    2a98:	7f 90       	pop	r7
    2a9a:	6f 90       	pop	r6
    2a9c:	5f 90       	pop	r5
    2a9e:	4f 90       	pop	r4
    2aa0:	08 95       	ret

00002aa2 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2aa2:	cf 92       	push	r12
    2aa4:	df 92       	push	r13
    2aa6:	ef 92       	push	r14
    2aa8:	ff 92       	push	r15
    2aaa:	0f 93       	push	r16
    2aac:	1f 93       	push	r17
    2aae:	cf 93       	push	r28
    2ab0:	df 93       	push	r29
    2ab2:	ec 01       	movw	r28, r24
    2ab4:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ab8:	9b 81       	ldd	r25, Y+3	; 0x03
    2aba:	0e 94 5d 10 	call	0x20ba	; 0x20ba <pcTaskGetTaskName>
    2abe:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2ac0:	6a e0       	ldi	r22, 0x0A	; 10
    2ac2:	c7 01       	movw	r24, r14
    2ac4:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2ac8:	8c 01       	movw	r16, r24
    2aca:	68 ea       	ldi	r22, 0xA8	; 168
    2acc:	74 e0       	ldi	r23, 0x04	; 4
    2ace:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2ad2:	6a e0       	ldi	r22, 0x0A	; 10
    2ad4:	c8 01       	movw	r24, r16
    2ad6:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2ada:	8c 01       	movw	r16, r24
    2adc:	61 ea       	ldi	r22, 0xA1	; 161
    2ade:	74 e0       	ldi	r23, 0x04	; 4
    2ae0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2ae4:	b6 01       	movw	r22, r12
    2ae6:	c8 01       	movw	r24, r16
    2ae8:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2aec:	6a e0       	ldi	r22, 0x0A	; 10
    2aee:	c8 01       	movw	r24, r16
    2af0:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2af4:	8c 01       	movw	r16, r24
    2af6:	6b e9       	ldi	r22, 0x9B	; 155
    2af8:	74 e0       	ldi	r23, 0x04	; 4
    2afa:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2afe:	66 e0       	ldi	r22, 0x06	; 6
    2b00:	c8 01       	movw	r24, r16
    2b02:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b06:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b08:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b0a:	e8 85       	ldd	r30, Y+8	; 0x08
    2b0c:	f9 85       	ldd	r31, Y+9	; 0x09
    2b0e:	01 e1       	ldi	r16, 0x11	; 17
    2b10:	21 e0       	ldi	r18, 0x01	; 1
    2b12:	a7 01       	movw	r20, r14
    2b14:	bc 01       	movw	r22, r24
    2b16:	8e 1b       	sub	r24, r30
    2b18:	9f 0b       	sbc	r25, r31
    2b1a:	0e 94 53 18 	call	0x30a6	; 0x30a6 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b1e:	8c 81       	ldd	r24, Y+4	; 0x04
    2b20:	9d 81       	ldd	r25, Y+5	; 0x05
    2b22:	00 97       	sbiw	r24, 0x00	; 0
    2b24:	19 f0       	breq	.+6      	; 0x2b2c <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b26:	b7 01       	movw	r22, r14
    2b28:	0e 94 51 15 	call	0x2aa2	; 0x2aa2 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b2c:	df 91       	pop	r29
    2b2e:	cf 91       	pop	r28
    2b30:	1f 91       	pop	r17
    2b32:	0f 91       	pop	r16
    2b34:	ff 90       	pop	r15
    2b36:	ef 90       	pop	r14
    2b38:	df 90       	pop	r13
    2b3a:	cf 90       	pop	r12
    2b3c:	08 95       	ret

00002b3e <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b3e:	0f 93       	push	r16
    2b40:	1f 93       	push	r17
    2b42:	cf 93       	push	r28
    2b44:	df 93       	push	r29
    2b46:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b48:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    2b4c:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2b50:	00 97       	sbiw	r24, 0x00	; 0
    2b52:	19 f0       	breq	.+6      	; 0x2b5a <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b54:	be 01       	movw	r22, r28
    2b56:	0e 94 51 15 	call	0x2aa2	; 0x2aa2 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b5a:	6a e0       	ldi	r22, 0x0A	; 10
    2b5c:	ce 01       	movw	r24, r28
    2b5e:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2b62:	8c 01       	movw	r16, r24
    2b64:	6e eb       	ldi	r22, 0xBE	; 190
    2b66:	74 e0       	ldi	r23, 0x04	; 4
    2b68:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2b6c:	6a e0       	ldi	r22, 0x0A	; 10
    2b6e:	c8 01       	movw	r24, r16
    2b70:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2b74:	8c 01       	movw	r16, r24
    2b76:	63 eb       	ldi	r22, 0xB3	; 179
    2b78:	74 e0       	ldi	r23, 0x04	; 4
    2b7a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2b7e:	6a e0       	ldi	r22, 0x0A	; 10
    2b80:	c8 01       	movw	r24, r16
    2b82:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2b86:	8c 01       	movw	r16, r24
    2b88:	6d ea       	ldi	r22, 0xAD	; 173
    2b8a:	74 e0       	ldi	r23, 0x04	; 4
    2b8c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2b90:	66 e0       	ldi	r22, 0x06	; 6
    2b92:	c8 01       	movw	r24, r16
    2b94:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2b98:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <portStackTopForTask>
    2b9c:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <portStackTopForTask+0x1>
    2ba0:	bc 01       	movw	r22, r24
    2ba2:	6f 5f       	subi	r22, 0xFF	; 255
    2ba4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ba6:	01 e1       	ldi	r16, 0x11	; 17
    2ba8:	21 e0       	ldi	r18, 0x01	; 1
    2baa:	ae 01       	movw	r20, r28
    2bac:	83 56       	subi	r24, 0x63	; 99
    2bae:	91 09       	sbc	r25, r1
    2bb0:	0e 94 53 18 	call	0x30a6	; 0x30a6 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2bb4:	df 91       	pop	r29
    2bb6:	cf 91       	pop	r28
    2bb8:	1f 91       	pop	r17
    2bba:	0f 91       	pop	r16
    2bbc:	08 95       	ret

00002bbe <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2bbe:	8f 92       	push	r8
    2bc0:	9f 92       	push	r9
    2bc2:	af 92       	push	r10
    2bc4:	bf 92       	push	r11
    2bc6:	cf 92       	push	r12
    2bc8:	df 92       	push	r13
    2bca:	ef 92       	push	r14
    2bcc:	ff 92       	push	r15
    2bce:	0f 93       	push	r16
    2bd0:	1f 93       	push	r17
    2bd2:	cf 93       	push	r28
    2bd4:	df 93       	push	r29
    2bd6:	ec 01       	movw	r28, r24
    2bd8:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2bda:	8a 81       	ldd	r24, Y+2	; 0x02
    2bdc:	9b 81       	ldd	r25, Y+3	; 0x03
    2bde:	0e 94 5d 10 	call	0x20ba	; 0x20ba <pcTaskGetTaskName>
    2be2:	bc 01       	movw	r22, r24
    2be4:	c8 01       	movw	r24, r16
    2be6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2bea:	d8 01       	movw	r26, r16
    2bec:	ed 91       	ld	r30, X+
    2bee:	fc 91       	ld	r31, X
    2bf0:	02 80       	ldd	r0, Z+2	; 0x02
    2bf2:	f3 81       	ldd	r31, Z+3	; 0x03
    2bf4:	e0 2d       	mov	r30, r0
    2bf6:	69 e0       	ldi	r22, 0x09	; 9
    2bf8:	c8 01       	movw	r24, r16
    2bfa:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    2c00:	0e 94 5d 10 	call	0x20ba	; 0x20ba <pcTaskGetTaskName>
    2c04:	fc 01       	movw	r30, r24
    2c06:	01 90       	ld	r0, Z+
    2c08:	00 20       	and	r0, r0
    2c0a:	e9 f7       	brne	.-6      	; 0x2c06 <_ZN8frt_task12print_statusER8emstream+0x48>
    2c0c:	31 97       	sbiw	r30, 0x01	; 1
    2c0e:	e8 1b       	sub	r30, r24
    2c10:	f9 0b       	sbc	r31, r25
    2c12:	38 97       	sbiw	r30, 0x08	; 8
    2c14:	48 f4       	brcc	.+18     	; 0x2c28 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2c16:	d8 01       	movw	r26, r16
    2c18:	ed 91       	ld	r30, X+
    2c1a:	fc 91       	ld	r31, X
    2c1c:	02 80       	ldd	r0, Z+2	; 0x02
    2c1e:	f3 81       	ldd	r31, Z+3	; 0x03
    2c20:	e0 2d       	mov	r30, r0
    2c22:	69 e0       	ldi	r22, 0x09	; 9
    2c24:	c8 01       	movw	r24, r16
    2c26:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c28:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c2a:	df 84       	ldd	r13, Y+15	; 0x0f
    2c2c:	e8 88       	ldd	r14, Y+16	; 0x10
    2c2e:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c30:	a8 84       	ldd	r10, Y+8	; 0x08
    2c32:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c34:	8a 81       	ldd	r24, Y+2	; 0x02
    2c36:	9b 81       	ldd	r25, Y+3	; 0x03
    2c38:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxTaskGetStackHighWaterMark>
    2c3c:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c3e:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c40:	8a 81       	ldd	r24, Y+2	; 0x02
    2c42:	9b 81       	ldd	r25, Y+3	; 0x03
    2c44:	0e 94 08 10 	call	0x2010	; 0x2010 <uxTaskPriorityGet>
    2c48:	68 2f       	mov	r22, r24
    2c4a:	c8 01       	movw	r24, r16
    2c4c:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
    2c50:	6a e0       	ldi	r22, 0x0A	; 10
    2c52:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2c56:	ec 01       	movw	r28, r24
    2c58:	63 e3       	ldi	r22, 0x33	; 51
    2c5a:	75 e0       	ldi	r23, 0x05	; 5
    2c5c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c60:	68 2d       	mov	r22, r8
    2c62:	ce 01       	movw	r24, r28
    2c64:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c68:	6a e0       	ldi	r22, 0x0A	; 10
    2c6a:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2c6e:	ec 01       	movw	r28, r24
    2c70:	61 e3       	ldi	r22, 0x31	; 49
    2c72:	75 e0       	ldi	r23, 0x05	; 5
    2c74:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2c78:	69 2d       	mov	r22, r9
    2c7a:	ce 01       	movw	r24, r28
    2c7c:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
    2c80:	6a e0       	ldi	r22, 0x0A	; 10
    2c82:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2c86:	ec 01       	movw	r28, r24
    2c88:	6f e2       	ldi	r22, 0x2F	; 47
    2c8a:	75 e0       	ldi	r23, 0x05	; 5
    2c8c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2c90:	b5 01       	movw	r22, r10
    2c92:	ce 01       	movw	r24, r28
    2c94:	0e 94 36 1a 	call	0x346c	; 0x346c <_ZN8emstreamlsEj>
    2c98:	6a e0       	ldi	r22, 0x0A	; 10
    2c9a:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2c9e:	ec 01       	movw	r28, r24
    2ca0:	6d e2       	ldi	r22, 0x2D	; 45
    2ca2:	75 e0       	ldi	r23, 0x05	; 5
    2ca4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2ca8:	6a e0       	ldi	r22, 0x0A	; 10
    2caa:	ce 01       	movw	r24, r28
    2cac:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2cb0:	ec 01       	movw	r28, r24
    2cb2:	6b e2       	ldi	r22, 0x2B	; 43
    2cb4:	75 e0       	ldi	r23, 0x05	; 5
    2cb6:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2cba:	b7 01       	movw	r22, r14
    2cbc:	a6 01       	movw	r20, r12
    2cbe:	ce 01       	movw	r24, r28
    2cc0:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEm>
}
    2cc4:	df 91       	pop	r29
    2cc6:	cf 91       	pop	r28
    2cc8:	1f 91       	pop	r17
    2cca:	0f 91       	pop	r16
    2ccc:	ff 90       	pop	r15
    2cce:	ef 90       	pop	r14
    2cd0:	df 90       	pop	r13
    2cd2:	cf 90       	pop	r12
    2cd4:	bf 90       	pop	r11
    2cd6:	af 90       	pop	r10
    2cd8:	9f 90       	pop	r9
    2cda:	8f 90       	pop	r8
    2cdc:	08 95       	ret

00002cde <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2cde:	cf 93       	push	r28
    2ce0:	df 93       	push	r29
    2ce2:	ec 01       	movw	r28, r24
    2ce4:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2ce6:	db 01       	movw	r26, r22
    2ce8:	ed 91       	ld	r30, X+
    2cea:	fc 91       	ld	r31, X
    2cec:	02 80       	ldd	r0, Z+2	; 0x02
    2cee:	f3 81       	ldd	r31, Z+3	; 0x03
    2cf0:	e0 2d       	mov	r30, r0
    2cf2:	be 01       	movw	r22, r28
    2cf4:	19 95       	eicall
	return (ser_dev);
}
    2cf6:	ce 01       	movw	r24, r28
    2cf8:	df 91       	pop	r29
    2cfa:	cf 91       	pop	r28
    2cfc:	08 95       	ret

00002cfe <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2cfe:	0f 93       	push	r16
    2d00:	1f 93       	push	r17
    2d02:	cf 93       	push	r28
    2d04:	df 93       	push	r29
    2d06:	ec 01       	movw	r28, r24
    2d08:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d0a:	bc 01       	movw	r22, r24
    2d0c:	c8 01       	movw	r24, r16
    2d0e:	0e 94 6f 16 	call	0x2cde	; 0x2cde <_ZlsR8emstreamR8frt_task>
    2d12:	66 e0       	ldi	r22, 0x06	; 6
    2d14:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d18:	8c 81       	ldd	r24, Y+4	; 0x04
    2d1a:	9d 81       	ldd	r25, Y+5	; 0x05
    2d1c:	00 97       	sbiw	r24, 0x00	; 0
    2d1e:	19 f0       	breq	.+6      	; 0x2d26 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d20:	b8 01       	movw	r22, r16
    2d22:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d26:	df 91       	pop	r29
    2d28:	cf 91       	pop	r28
    2d2a:	1f 91       	pop	r17
    2d2c:	0f 91       	pop	r16
    2d2e:	08 95       	ret

00002d30 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d30:	0f 93       	push	r16
    2d32:	1f 93       	push	r17
    2d34:	cf 93       	push	r28
    2d36:	df 93       	push	r29
    2d38:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d3a:	6a e0       	ldi	r22, 0x0A	; 10
    2d3c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2d40:	8c 01       	movw	r16, r24
    2d42:	60 e2       	ldi	r22, 0x20	; 32
    2d44:	75 e0       	ldi	r23, 0x05	; 5
    2d46:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d4a:	6a e0       	ldi	r22, 0x0A	; 10
    2d4c:	c8 01       	movw	r24, r16
    2d4e:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2d52:	8c 01       	movw	r16, r24
    2d54:	69 e1       	ldi	r22, 0x19	; 25
    2d56:	75 e0       	ldi	r23, 0x05	; 5
    2d58:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d5c:	66 e0       	ldi	r22, 0x06	; 6
    2d5e:	c8 01       	movw	r24, r16
    2d60:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d64:	6a e0       	ldi	r22, 0x0A	; 10
    2d66:	ce 01       	movw	r24, r28
    2d68:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2d6c:	8c 01       	movw	r16, r24
    2d6e:	68 e0       	ldi	r22, 0x08	; 8
    2d70:	75 e0       	ldi	r23, 0x05	; 5
    2d72:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2d76:	6a e0       	ldi	r22, 0x0A	; 10
    2d78:	c8 01       	movw	r24, r16
    2d7a:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2d7e:	8c 01       	movw	r16, r24
    2d80:	6c ef       	ldi	r22, 0xFC	; 252
    2d82:	74 e0       	ldi	r23, 0x04	; 4
    2d84:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2d88:	6a e0       	ldi	r22, 0x0A	; 10
    2d8a:	c8 01       	movw	r24, r16
    2d8c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2d90:	8c 01       	movw	r16, r24
    2d92:	66 ef       	ldi	r22, 0xF6	; 246
    2d94:	74 e0       	ldi	r23, 0x04	; 4
    2d96:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2d9a:	66 e0       	ldi	r22, 0x06	; 6
    2d9c:	c8 01       	movw	r24, r16
    2d9e:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2da2:	6a e0       	ldi	r22, 0x0A	; 10
    2da4:	ce 01       	movw	r24, r28
    2da6:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2daa:	8c 01       	movw	r16, r24
    2dac:	65 ee       	ldi	r22, 0xE5	; 229
    2dae:	74 e0       	ldi	r23, 0x04	; 4
    2db0:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2db4:	6a e0       	ldi	r22, 0x0A	; 10
    2db6:	c8 01       	movw	r24, r16
    2db8:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2dbc:	8c 01       	movw	r16, r24
    2dbe:	69 ed       	ldi	r22, 0xD9	; 217
    2dc0:	74 e0       	ldi	r23, 0x04	; 4
    2dc2:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2dc6:	6a e0       	ldi	r22, 0x0A	; 10
    2dc8:	c8 01       	movw	r24, r16
    2dca:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2dce:	8c 01       	movw	r16, r24
    2dd0:	63 ed       	ldi	r22, 0xD3	; 211
    2dd2:	74 e0       	ldi	r23, 0x04	; 4
    2dd4:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2dd8:	66 e0       	ldi	r22, 0x06	; 6
    2dda:	c8 01       	movw	r24, r16
    2ddc:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2de0:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    2de4:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2de8:	00 97       	sbiw	r24, 0x00	; 0
    2dea:	19 f0       	breq	.+6      	; 0x2df2 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2dec:	be 01       	movw	r22, r28
    2dee:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2df2:	0e 94 65 10 	call	0x20ca	; 0x20ca <xTaskGetIdleTaskHandle>
    2df6:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <uxTaskGetStackHighWaterMark>
    2dfa:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2dfc:	6a e0       	ldi	r22, 0x0A	; 10
    2dfe:	ce 01       	movw	r24, r28
    2e00:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2e04:	ec 01       	movw	r28, r24
    2e06:	68 ec       	ldi	r22, 0xC8	; 200
    2e08:	74 e0       	ldi	r23, 0x04	; 4
    2e0a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e0e:	61 2f       	mov	r22, r17
    2e10:	ce 01       	movw	r24, r28
    2e12:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2e16:	6a e0       	ldi	r22, 0x0A	; 10
    2e18:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2e1c:	ec 01       	movw	r28, r24
    2e1e:	66 ec       	ldi	r22, 0xC6	; 198
    2e20:	74 e0       	ldi	r23, 0x04	; 4
    2e22:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    2e26:	64 e6       	ldi	r22, 0x64	; 100
    2e28:	70 e0       	ldi	r23, 0x00	; 0
    2e2a:	ce 01       	movw	r24, r28
    2e2c:	0e 94 36 1a 	call	0x346c	; 0x346c <_ZN8emstreamlsEj>
    2e30:	6a e0       	ldi	r22, 0x0A	; 10
    2e32:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    2e36:	ec 01       	movw	r28, r24
    2e38:	63 ec       	ldi	r22, 0xC3	; 195
    2e3a:	74 e0       	ldi	r23, 0x04	; 4
    2e3c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e40:	66 e0       	ldi	r22, 0x06	; 6
    2e42:	ce 01       	movw	r24, r28
    2e44:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
}
    2e48:	df 91       	pop	r29
    2e4a:	cf 91       	pop	r28
    2e4c:	1f 91       	pop	r17
    2e4e:	0f 91       	pop	r16
    2e50:	08 95       	ret

00002e52 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e52:	0f 93       	push	r16
    2e54:	cf 93       	push	r28
    2e56:	df 93       	push	r29
    2e58:	1f 92       	push	r1
    2e5a:	cd b7       	in	r28, 0x3d	; 61
    2e5c:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e5e:	00 e0       	ldi	r16, 0x00	; 0
    2e60:	2f ef       	ldi	r18, 0xFF	; 255
    2e62:	3f ef       	ldi	r19, 0xFF	; 255
    2e64:	a9 01       	movw	r20, r18
    2e66:	be 01       	movw	r22, r28
    2e68:	6f 5f       	subi	r22, 0xFF	; 255
    2e6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e6c:	fc 01       	movw	r30, r24
    2e6e:	80 85       	ldd	r24, Z+8	; 0x08
    2e70:	91 85       	ldd	r25, Z+9	; 0x09
    2e72:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <xQueueGenericReceive>
    2e76:	81 30       	cpi	r24, 0x01	; 1
    2e78:	19 f4       	brne	.+6      	; 0x2e80 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e7a:	89 81       	ldd	r24, Y+1	; 0x01
    2e7c:	90 e0       	ldi	r25, 0x00	; 0
    2e7e:	02 c0       	rjmp	.+4      	; 0x2e84 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2e80:	8f ef       	ldi	r24, 0xFF	; 255
    2e82:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2e84:	0f 90       	pop	r0
    2e86:	df 91       	pop	r29
    2e88:	cf 91       	pop	r28
    2e8a:	0f 91       	pop	r16
    2e8c:	08 95       	ret

00002e8e <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2e8e:	fc 01       	movw	r30, r24
    2e90:	80 85       	ldd	r24, Z+8	; 0x08
    2e92:	91 85       	ldd	r25, Z+9	; 0x09
    2e94:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <uxQueueMessagesWaiting>
    2e98:	91 e0       	ldi	r25, 0x01	; 1
    2e9a:	81 11       	cpse	r24, r1
    2e9c:	01 c0       	rjmp	.+2      	; 0x2ea0 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2ea0:	89 2f       	mov	r24, r25
    2ea2:	08 95       	ret

00002ea4 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2ea4:	0f 93       	push	r16
    2ea6:	cf 93       	push	r28
    2ea8:	df 93       	push	r29
    2eaa:	1f 92       	push	r1
    2eac:	cd b7       	in	r28, 0x3d	; 61
    2eae:	de b7       	in	r29, 0x3e	; 62
    2eb0:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2eb2:	fc 01       	movw	r30, r24
    2eb4:	22 85       	ldd	r18, Z+10	; 0x0a
    2eb6:	33 85       	ldd	r19, Z+11	; 0x0b
    2eb8:	44 85       	ldd	r20, Z+12	; 0x0c
    2eba:	55 85       	ldd	r21, Z+13	; 0x0d
    2ebc:	00 e0       	ldi	r16, 0x00	; 0
    2ebe:	be 01       	movw	r22, r28
    2ec0:	6f 5f       	subi	r22, 0xFF	; 255
    2ec2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ec4:	80 85       	ldd	r24, Z+8	; 0x08
    2ec6:	91 85       	ldd	r25, Z+9	; 0x09
    2ec8:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <xQueueGenericSend>
    2ecc:	91 e0       	ldi	r25, 0x01	; 1
    2ece:	81 11       	cpse	r24, r1
    2ed0:	01 c0       	rjmp	.+2      	; 0x2ed4 <_ZN14frt_text_queue7putcharEc+0x30>
    2ed2:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2ed4:	89 2f       	mov	r24, r25
    2ed6:	0f 90       	pop	r0
    2ed8:	df 91       	pop	r29
    2eda:	cf 91       	pop	r28
    2edc:	0f 91       	pop	r16
    2ede:	08 95       	ret

00002ee0 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ee0:	8f 92       	push	r8
    2ee2:	9f 92       	push	r9
    2ee4:	bf 92       	push	r11
    2ee6:	cf 92       	push	r12
    2ee8:	df 92       	push	r13
    2eea:	ef 92       	push	r14
    2eec:	ff 92       	push	r15
    2eee:	0f 93       	push	r16
    2ef0:	1f 93       	push	r17
    2ef2:	cf 93       	push	r28
    2ef4:	df 93       	push	r29
    2ef6:	ec 01       	movw	r28, r24
    2ef8:	b6 2e       	mov	r11, r22
    2efa:	4a 01       	movw	r8, r20
    2efc:	68 01       	movw	r12, r16
    2efe:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f00:	0e 94 aa 19 	call	0x3354	; 0x3354 <_ZN8emstreamC1Ev>
    2f04:	8f e3       	ldi	r24, 0x3F	; 63
    2f06:	90 e2       	ldi	r25, 0x20	; 32
    2f08:	88 83       	st	Y, r24
    2f0a:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f0c:	8e 86       	std	Y+14, r8	; 0x0e
    2f0e:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f10:	40 e0       	ldi	r20, 0x00	; 0
    2f12:	61 e0       	ldi	r22, 0x01	; 1
    2f14:	8b 2d       	mov	r24, r11
    2f16:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <xQueueGenericCreate>
    2f1a:	88 87       	std	Y+8, r24	; 0x08
    2f1c:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f1e:	ca 86       	std	Y+10, r12	; 0x0a
    2f20:	db 86       	std	Y+11, r13	; 0x0b
    2f22:	ec 86       	std	Y+12, r14	; 0x0c
    2f24:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f26:	df 91       	pop	r29
    2f28:	cf 91       	pop	r28
    2f2a:	1f 91       	pop	r17
    2f2c:	0f 91       	pop	r16
    2f2e:	ff 90       	pop	r15
    2f30:	ef 90       	pop	r14
    2f32:	df 90       	pop	r13
    2f34:	cf 90       	pop	r12
    2f36:	bf 90       	pop	r11
    2f38:	9f 90       	pop	r9
    2f3a:	8f 90       	pop	r8
    2f3c:	08 95       	ret

00002f3e <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f3e:	cf 92       	push	r12
    2f40:	df 92       	push	r13
    2f42:	ef 92       	push	r14
    2f44:	ff 92       	push	r15
    2f46:	cf 93       	push	r28
    2f48:	df 93       	push	r29
    2f4a:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f4c:	68 81       	ld	r22, Y
    2f4e:	79 81       	ldd	r23, Y+1	; 0x01
    2f50:	8a 81       	ldd	r24, Y+2	; 0x02
    2f52:	9b 81       	ldd	r25, Y+3	; 0x03
    2f54:	0f 2e       	mov	r0, r31
    2f56:	f8 ee       	ldi	r31, 0xE8	; 232
    2f58:	cf 2e       	mov	r12, r31
    2f5a:	f3 e0       	ldi	r31, 0x03	; 3
    2f5c:	df 2e       	mov	r13, r31
    2f5e:	e1 2c       	mov	r14, r1
    2f60:	f1 2c       	mov	r15, r1
    2f62:	f0 2d       	mov	r31, r0
    2f64:	a7 01       	movw	r20, r14
    2f66:	96 01       	movw	r18, r12
    2f68:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__udivmodsi4>
    2f6c:	9b 01       	movw	r18, r22
    2f6e:	ac 01       	movw	r20, r24
    2f70:	60 e4       	ldi	r22, 0x40	; 64
    2f72:	72 e4       	ldi	r23, 0x42	; 66
    2f74:	8f e0       	ldi	r24, 0x0F	; 15
    2f76:	90 e0       	ldi	r25, 0x00	; 0
    2f78:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__mulsi3>
    2f7c:	a7 01       	movw	r20, r14
    2f7e:	96 01       	movw	r18, r12
    2f80:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__udivmodsi4>
    2f84:	69 01       	movw	r12, r18
    2f86:	7a 01       	movw	r14, r20
    2f88:	ac 81       	ldd	r26, Y+4	; 0x04
    2f8a:	bd 81       	ldd	r27, Y+5	; 0x05
    2f8c:	20 e4       	ldi	r18, 0x40	; 64
    2f8e:	32 e4       	ldi	r19, 0x42	; 66
    2f90:	4f e0       	ldi	r20, 0x0F	; 15
    2f92:	50 e0       	ldi	r21, 0x00	; 0
    2f94:	0e 94 94 1f 	call	0x3f28	; 0x3f28 <__muluhisi3>
    2f98:	20 e0       	ldi	r18, 0x00	; 0
    2f9a:	38 e4       	ldi	r19, 0x48	; 72
    2f9c:	48 ee       	ldi	r20, 0xE8	; 232
    2f9e:	51 e0       	ldi	r21, 0x01	; 1
    2fa0:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__udivmodsi4>
    2fa4:	c7 01       	movw	r24, r14
    2fa6:	b6 01       	movw	r22, r12
    2fa8:	62 0f       	add	r22, r18
    2faa:	73 1f       	adc	r23, r19
    2fac:	84 1f       	adc	r24, r20
    2fae:	95 1f       	adc	r25, r21
}
    2fb0:	df 91       	pop	r29
    2fb2:	cf 91       	pop	r28
    2fb4:	ff 90       	pop	r15
    2fb6:	ef 90       	pop	r14
    2fb8:	df 90       	pop	r13
    2fba:	cf 90       	pop	r12
    2fbc:	08 95       	ret

00002fbe <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2fbe:	cf 92       	push	r12
    2fc0:	df 92       	push	r13
    2fc2:	ef 92       	push	r14
    2fc4:	ff 92       	push	r15
    2fc6:	0f 93       	push	r16
    2fc8:	1f 93       	push	r17
    2fca:	cf 93       	push	r28
    2fcc:	df 93       	push	r29
    2fce:	cd b7       	in	r28, 0x3d	; 61
    2fd0:	de b7       	in	r29, 0x3e	; 62
    2fd2:	2f 97       	sbiw	r28, 0x0f	; 15
    2fd4:	cd bf       	out	0x3d, r28	; 61
    2fd6:	de bf       	out	0x3e, r29	; 62
    2fd8:	6c 01       	movw	r12, r24
    2fda:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2fdc:	db 01       	movw	r26, r22
    2fde:	6d 91       	ld	r22, X+
    2fe0:	7d 91       	ld	r23, X+
    2fe2:	8d 91       	ld	r24, X+
    2fe4:	9c 91       	ld	r25, X
    2fe6:	28 ee       	ldi	r18, 0xE8	; 232
    2fe8:	33 e0       	ldi	r19, 0x03	; 3
    2fea:	40 e0       	ldi	r20, 0x00	; 0
    2fec:	50 e0       	ldi	r21, 0x00	; 0
    2fee:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__udivmodsi4>
    2ff2:	ba 01       	movw	r22, r20
    2ff4:	a9 01       	movw	r20, r18
    2ff6:	c6 01       	movw	r24, r12
    2ff8:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2ffc:	d6 01       	movw	r26, r12
    2ffe:	ed 91       	ld	r30, X+
    3000:	fc 91       	ld	r31, X
    3002:	02 80       	ldd	r0, Z+2	; 0x02
    3004:	f3 81       	ldd	r31, Z+3	; 0x03
    3006:	e0 2d       	mov	r30, r0
    3008:	6e e2       	ldi	r22, 0x2E	; 46
    300a:	c6 01       	movw	r24, r12
    300c:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    300e:	c8 01       	movw	r24, r16
    3010:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN10time_stamp12get_microsecEv>
    3014:	8e 01       	movw	r16, r28
    3016:	09 5f       	subi	r16, 0xF9	; 249
    3018:	1f 4f       	sbci	r17, 0xFF	; 255
    301a:	fe 01       	movw	r30, r28
    301c:	31 96       	adiw	r30, 0x01	; 1
    301e:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3020:	2a e0       	ldi	r18, 0x0A	; 10
    3022:	30 e0       	ldi	r19, 0x00	; 0
    3024:	40 e0       	ldi	r20, 0x00	; 0
    3026:	50 e0       	ldi	r21, 0x00	; 0
    3028:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <__divmodsi4>
    302c:	e6 2f       	mov	r30, r22
    302e:	28 87       	std	Y+8, r18	; 0x08
    3030:	39 87       	std	Y+9, r19	; 0x09
    3032:	4a 87       	std	Y+10, r20	; 0x0a
    3034:	5b 87       	std	Y+11, r21	; 0x0b
    3036:	68 85       	ldd	r22, Y+8	; 0x08
    3038:	79 85       	ldd	r23, Y+9	; 0x09
    303a:	8a 85       	ldd	r24, Y+10	; 0x0a
    303c:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    303e:	20 e3       	ldi	r18, 0x30	; 48
    3040:	2e 0f       	add	r18, r30
    3042:	d8 01       	movw	r26, r16
    3044:	2e 93       	st	-X, r18
    3046:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3048:	ae 15       	cp	r26, r14
    304a:	bf 05       	cpc	r27, r15
    304c:	49 f7       	brne	.-46     	; 0x3020 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    304e:	1f 82       	std	Y+7, r1	; 0x07
    3050:	be 01       	movw	r22, r28
    3052:	6f 5f       	subi	r22, 0xFF	; 255
    3054:	7f 4f       	sbci	r23, 0xFF	; 255
    3056:	c6 01       	movw	r24, r12
    3058:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    305c:	c6 01       	movw	r24, r12
    305e:	2f 96       	adiw	r28, 0x0f	; 15
    3060:	cd bf       	out	0x3d, r28	; 61
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	df 91       	pop	r29
    3066:	cf 91       	pop	r28
    3068:	1f 91       	pop	r17
    306a:	0f 91       	pop	r16
    306c:	ff 90       	pop	r15
    306e:	ef 90       	pop	r14
    3070:	df 90       	pop	r13
    3072:	cf 90       	pop	r12
    3074:	08 95       	ret

00003076 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3076:	cf 93       	push	r28
    3078:	df 93       	push	r29
    307a:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    307c:	0f b6       	in	r0, 0x3f	; 63
    307e:	f8 94       	cli
    3080:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3082:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3086:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    308a:	8c 83       	std	Y+4, r24	; 0x04
    308c:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    308e:	0e 94 4f 10 	call	0x209e	; 0x209e <xTaskGetTickCount>
    3092:	68 83       	st	Y, r22
    3094:	79 83       	std	Y+1, r23	; 0x01
    3096:	8a 83       	std	Y+2, r24	; 0x02
    3098:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    309a:	0f 90       	pop	r0
    309c:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    309e:	ce 01       	movw	r24, r28
    30a0:	df 91       	pop	r29
    30a2:	cf 91       	pop	r28
    30a4:	08 95       	ret

000030a6 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    30a6:	5f 92       	push	r5
    30a8:	6f 92       	push	r6
    30aa:	7f 92       	push	r7
    30ac:	8f 92       	push	r8
    30ae:	9f 92       	push	r9
    30b0:	af 92       	push	r10
    30b2:	bf 92       	push	r11
    30b4:	cf 92       	push	r12
    30b6:	df 92       	push	r13
    30b8:	ef 92       	push	r14
    30ba:	ff 92       	push	r15
    30bc:	0f 93       	push	r16
    30be:	1f 93       	push	r17
    30c0:	cf 93       	push	r28
    30c2:	df 93       	push	r29
    30c4:	5c 01       	movw	r10, r24
    30c6:	4b 01       	movw	r8, r22
    30c8:	7a 01       	movw	r14, r20
    30ca:	12 2f       	mov	r17, r18
    30cc:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    30ce:	63 e0       	ldi	r22, 0x03	; 3
    30d0:	ca 01       	movw	r24, r20
    30d2:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    30d6:	a8 14       	cp	r10, r8
    30d8:	b9 04       	cpc	r11, r9
    30da:	08 f0       	brcs	.+2      	; 0x30de <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    30dc:	7d c0       	rjmp	.+250    	; 0x31d8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30de:	65 01       	movw	r12, r10
    30e0:	84 e1       	ldi	r24, 0x14	; 20
    30e2:	c8 0e       	add	r12, r24
    30e4:	d1 1c       	adc	r13, r1
    30e6:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    30e8:	6a 2c       	mov	r6, r10
    30ea:	5b 2c       	mov	r5, r11
    30ec:	b5 01       	movw	r22, r10
    30ee:	c7 01       	movw	r24, r14
    30f0:	0e 94 36 1a 	call	0x346c	; 0x346c <_ZN8emstreamlsEj>
    30f4:	6a e0       	ldi	r22, 0x0A	; 10
    30f6:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    30fa:	65 e4       	ldi	r22, 0x45	; 69
    30fc:	75 e0       	ldi	r23, 0x05	; 5
    30fe:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3102:	11 23       	and	r17, r17
    3104:	09 f4       	brne	.+2      	; 0x3108 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3106:	6d c0       	rjmp	.+218    	; 0x31e2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3108:	00 23       	and	r16, r16
    310a:	09 f4       	brne	.+2      	; 0x310e <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    310c:	6a c0       	rjmp	.+212    	; 0x31e2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    310e:	6a e0       	ldi	r22, 0x0A	; 10
    3110:	c7 01       	movw	r24, r14
    3112:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    3116:	60 e4       	ldi	r22, 0x40	; 64
    3118:	75 e0       	ldi	r23, 0x05	; 5
    311a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    311e:	61 c0       	rjmp	.+194    	; 0x31e2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3120:	11 23       	and	r17, r17
    3122:	71 f0       	breq	.+28     	; 0x3140 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3124:	01 11       	cpse	r16, r1
    3126:	0c c0       	rjmp	.+24     	; 0x3140 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3128:	88 81       	ld	r24, Y
    312a:	87 15       	cp	r24, r7
    312c:	49 f0       	breq	.+18     	; 0x3140 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    312e:	6a e0       	ldi	r22, 0x0A	; 10
    3130:	c7 01       	movw	r24, r14
    3132:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    3136:	6b e3       	ldi	r22, 0x3B	; 59
    3138:	75 e0       	ldi	r23, 0x05	; 5
    313a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    313e:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3140:	69 91       	ld	r22, Y+
    3142:	c7 01       	movw	r24, r14
    3144:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3148:	dc 01       	movw	r26, r24
    314a:	ed 91       	ld	r30, X+
    314c:	fc 91       	ld	r31, X
    314e:	02 80       	ldd	r0, Z+2	; 0x02
    3150:	f3 81       	ldd	r31, Z+3	; 0x03
    3152:	e0 2d       	mov	r30, r0
    3154:	60 e2       	ldi	r22, 0x20	; 32
    3156:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3158:	cc 16       	cp	r12, r28
    315a:	dd 06       	cpc	r13, r29
    315c:	09 f7       	brne	.-62     	; 0x3120 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    315e:	11 23       	and	r17, r17
    3160:	89 f0       	breq	.+34     	; 0x3184 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3162:	6a e0       	ldi	r22, 0x0A	; 10
    3164:	c7 01       	movw	r24, r14
    3166:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    316a:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    316c:	65 e3       	ldi	r22, 0x35	; 53
    316e:	75 e0       	ldi	r23, 0x05	; 5
    3170:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3174:	e8 81       	ld	r30, Y
    3176:	f9 81       	ldd	r31, Y+1	; 0x01
    3178:	02 80       	ldd	r0, Z+2	; 0x02
    317a:	f3 81       	ldd	r31, Z+3	; 0x03
    317c:	e0 2d       	mov	r30, r0
    317e:	60 e2       	ldi	r22, 0x20	; 32
    3180:	ce 01       	movw	r24, r28
    3182:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3184:	c6 2d       	mov	r28, r6
    3186:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3188:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    318a:	80 ee       	ldi	r24, 0xE0	; 224
    318c:	86 0f       	add	r24, r22
    318e:	8f 35       	cpi	r24, 0x5F	; 95
    3190:	48 f4       	brcc	.+18     	; 0x31a4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3192:	d7 01       	movw	r26, r14
    3194:	ed 91       	ld	r30, X+
    3196:	fc 91       	ld	r31, X
    3198:	02 80       	ldd	r0, Z+2	; 0x02
    319a:	f3 81       	ldd	r31, Z+3	; 0x03
    319c:	e0 2d       	mov	r30, r0
    319e:	c7 01       	movw	r24, r14
    31a0:	19 95       	eicall
    31a2:	09 c0       	rjmp	.+18     	; 0x31b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    31a4:	d7 01       	movw	r26, r14
    31a6:	ed 91       	ld	r30, X+
    31a8:	fc 91       	ld	r31, X
    31aa:	02 80       	ldd	r0, Z+2	; 0x02
    31ac:	f3 81       	ldd	r31, Z+3	; 0x03
    31ae:	e0 2d       	mov	r30, r0
    31b0:	6e e2       	ldi	r22, 0x2E	; 46
    31b2:	c7 01       	movw	r24, r14
    31b4:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    31b6:	cc 16       	cp	r12, r28
    31b8:	dd 06       	cpc	r13, r29
    31ba:	31 f7       	brne	.-52     	; 0x3188 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31bc:	b4 e1       	ldi	r27, 0x14	; 20
    31be:	ab 0e       	add	r10, r27
    31c0:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31c2:	66 e0       	ldi	r22, 0x06	; 6
    31c4:	c7 01       	movw	r24, r14
    31c6:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    31ca:	84 e1       	ldi	r24, 0x14	; 20
    31cc:	c8 0e       	add	r12, r24
    31ce:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31d0:	a8 14       	cp	r10, r8
    31d2:	b9 04       	cpc	r11, r9
    31d4:	08 f4       	brcc	.+2      	; 0x31d8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31d6:	88 cf       	rjmp	.-240    	; 0x30e8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    31d8:	62 e0       	ldi	r22, 0x02	; 2
    31da:	c7 01       	movw	r24, r14
    31dc:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
}
    31e0:	03 c0       	rjmp	.+6      	; 0x31e8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31e2:	c6 2d       	mov	r28, r6
    31e4:	d5 2d       	mov	r29, r5
    31e6:	9c cf       	rjmp	.-200    	; 0x3120 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    31e8:	df 91       	pop	r29
    31ea:	cf 91       	pop	r28
    31ec:	1f 91       	pop	r17
    31ee:	0f 91       	pop	r16
    31f0:	ff 90       	pop	r15
    31f2:	ef 90       	pop	r14
    31f4:	df 90       	pop	r13
    31f6:	cf 90       	pop	r12
    31f8:	bf 90       	pop	r11
    31fa:	af 90       	pop	r10
    31fc:	9f 90       	pop	r9
    31fe:	8f 90       	pop	r8
    3200:	7f 90       	pop	r7
    3202:	6f 90       	pop	r6
    3204:	5f 90       	pop	r5
    3206:	08 95       	ret

00003208 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3208:	0e 94 35 09 	call	0x126a	; 0x126a <pvPortMalloc>
    320c:	08 95       	ret

0000320e <_Znaj>:
    320e:	0e 94 35 09 	call	0x126a	; 0x126a <pvPortMalloc>
    3212:	08 95       	ret

00003214 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3214:	08 95       	ret

00003216 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3216:	cf 93       	push	r28
    3218:	df 93       	push	r29
    321a:	fc 01       	movw	r30, r24
    321c:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    321e:	40 3a       	cpi	r20, 0xA0	; 160
    3220:	68 e0       	ldi	r22, 0x08	; 8
    3222:	56 07       	cpc	r21, r22
    3224:	49 f4       	brne	.+18     	; 0x3238 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3226:	80 e4       	ldi	r24, 0x40	; 64
    3228:	96 e0       	ldi	r25, 0x06	; 6
    322a:	82 83       	std	Z+2, r24	; 0x02
    322c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    322e:	82 e0       	ldi	r24, 0x02	; 2
    3230:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3232:	83 e0       	ldi	r24, 0x03	; 3
    3234:	85 83       	std	Z+5, r24	; 0x05
    3236:	32 c0       	rjmp	.+100    	; 0x329c <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3238:	40 3b       	cpi	r20, 0xB0	; 176
    323a:	78 e0       	ldi	r23, 0x08	; 8
    323c:	57 07       	cpc	r21, r23
    323e:	49 f4       	brne	.+18     	; 0x3252 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3240:	80 e4       	ldi	r24, 0x40	; 64
    3242:	96 e0       	ldi	r25, 0x06	; 6
    3244:	82 83       	std	Z+2, r24	; 0x02
    3246:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3248:	86 e0       	ldi	r24, 0x06	; 6
    324a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    324c:	87 e0       	ldi	r24, 0x07	; 7
    324e:	85 83       	std	Z+5, r24	; 0x05
    3250:	25 c0       	rjmp	.+74     	; 0x329c <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3252:	40 3a       	cpi	r20, 0xA0	; 160
    3254:	89 e0       	ldi	r24, 0x09	; 9
    3256:	58 07       	cpc	r21, r24
    3258:	49 f4       	brne	.+18     	; 0x326c <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    325a:	80 e6       	ldi	r24, 0x60	; 96
    325c:	96 e0       	ldi	r25, 0x06	; 6
    325e:	82 83       	std	Z+2, r24	; 0x02
    3260:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3262:	82 e0       	ldi	r24, 0x02	; 2
    3264:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3266:	83 e0       	ldi	r24, 0x03	; 3
    3268:	85 83       	std	Z+5, r24	; 0x05
    326a:	18 c0       	rjmp	.+48     	; 0x329c <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    326c:	40 3b       	cpi	r20, 0xB0	; 176
    326e:	69 e0       	ldi	r22, 0x09	; 9
    3270:	56 07       	cpc	r21, r22
    3272:	49 f4       	brne	.+18     	; 0x3286 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3274:	80 e6       	ldi	r24, 0x60	; 96
    3276:	96 e0       	ldi	r25, 0x06	; 6
    3278:	82 83       	std	Z+2, r24	; 0x02
    327a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    327c:	86 e0       	ldi	r24, 0x06	; 6
    327e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3280:	87 e0       	ldi	r24, 0x07	; 7
    3282:	85 83       	std	Z+5, r24	; 0x05
    3284:	0b c0       	rjmp	.+22     	; 0x329c <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3286:	40 3a       	cpi	r20, 0xA0	; 160
    3288:	5a 40       	sbci	r21, 0x0A	; 10
    328a:	41 f4       	brne	.+16     	; 0x329c <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    328c:	80 e8       	ldi	r24, 0x80	; 128
    328e:	96 e0       	ldi	r25, 0x06	; 6
    3290:	82 83       	std	Z+2, r24	; 0x02
    3292:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3294:	82 e0       	ldi	r24, 0x02	; 2
    3296:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3298:	83 e0       	ldi	r24, 0x03	; 3
    329a:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    329c:	a6 83       	std	Z+6, r26	; 0x06
    329e:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    32a0:	cd 01       	movw	r24, r26
    32a2:	01 96       	adiw	r24, 0x01	; 1
    32a4:	80 87       	std	Z+8, r24	; 0x08
    32a6:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    32a8:	03 96       	adiw	r24, 0x03	; 3
    32aa:	82 87       	std	Z+10, r24	; 0x0a
    32ac:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    32ae:	25 81       	ldd	r18, Z+5	; 0x05
    32b0:	c2 81       	ldd	r28, Z+2	; 0x02
    32b2:	d3 81       	ldd	r29, Z+3	; 0x03
    32b4:	4c 81       	ldd	r20, Y+4	; 0x04
    32b6:	81 e0       	ldi	r24, 0x01	; 1
    32b8:	90 e0       	ldi	r25, 0x00	; 0
    32ba:	bc 01       	movw	r22, r24
    32bc:	02 c0       	rjmp	.+4      	; 0x32c2 <_ZN7base232C1EjP12USART_struct+0xac>
    32be:	66 0f       	add	r22, r22
    32c0:	77 1f       	adc	r23, r23
    32c2:	2a 95       	dec	r18
    32c4:	e2 f7       	brpl	.-8      	; 0x32be <_ZN7base232C1EjP12USART_struct+0xa8>
    32c6:	9b 01       	movw	r18, r22
    32c8:	24 2b       	or	r18, r20
    32ca:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    32cc:	25 81       	ldd	r18, Z+5	; 0x05
    32ce:	c2 81       	ldd	r28, Z+2	; 0x02
    32d0:	d3 81       	ldd	r29, Z+3	; 0x03
    32d2:	48 81       	ld	r20, Y
    32d4:	bc 01       	movw	r22, r24
    32d6:	02 c0       	rjmp	.+4      	; 0x32dc <_ZN7base232C1EjP12USART_struct+0xc6>
    32d8:	66 0f       	add	r22, r22
    32da:	77 1f       	adc	r23, r23
    32dc:	2a 95       	dec	r18
    32de:	e2 f7       	brpl	.-8      	; 0x32d8 <_ZN7base232C1EjP12USART_struct+0xc2>
    32e0:	9b 01       	movw	r18, r22
    32e2:	24 2b       	or	r18, r20
    32e4:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    32e6:	34 81       	ldd	r19, Z+4	; 0x04
    32e8:	c2 81       	ldd	r28, Z+2	; 0x02
    32ea:	d3 81       	ldd	r29, Z+3	; 0x03
    32ec:	28 81       	ld	r18, Y
    32ee:	02 c0       	rjmp	.+4      	; 0x32f4 <_ZN7base232C1EjP12USART_struct+0xde>
    32f0:	88 0f       	add	r24, r24
    32f2:	99 1f       	adc	r25, r25
    32f4:	3a 95       	dec	r19
    32f6:	e2 f7       	brpl	.-8      	; 0x32f0 <_ZN7base232C1EjP12USART_struct+0xda>
    32f8:	80 95       	com	r24
    32fa:	90 95       	com	r25
    32fc:	82 23       	and	r24, r18
    32fe:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3300:	80 e1       	ldi	r24, 0x10	; 16
    3302:	13 96       	adiw	r26, 0x03	; 3
    3304:	8c 93       	st	X, r24
    3306:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3308:	83 e0       	ldi	r24, 0x03	; 3
    330a:	15 96       	adiw	r26, 0x05	; 5
    330c:	8c 93       	st	X, r24
    330e:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3310:	80 ef       	ldi	r24, 0xF0	; 240
    3312:	17 96       	adiw	r26, 0x07	; 7
    3314:	8c 93       	st	X, r24
    3316:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3318:	81 e2       	ldi	r24, 0x21	; 33
    331a:	16 96       	adiw	r26, 0x06	; 6
    331c:	8c 93       	st	X, r24
    331e:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3320:	88 e1       	ldi	r24, 0x18	; 24
    3322:	14 96       	adiw	r26, 0x04	; 4
    3324:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3326:	80 e8       	ldi	r24, 0x80	; 128
    3328:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    332a:	80 e4       	ldi	r24, 0x40	; 64
    332c:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    332e:	80 e2       	ldi	r24, 0x20	; 32
    3330:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3332:	06 80       	ldd	r0, Z+6	; 0x06
    3334:	f7 81       	ldd	r31, Z+7	; 0x07
    3336:	e0 2d       	mov	r30, r0
    3338:	80 81       	ld	r24, Z
    333a:	80 81       	ld	r24, Z
}
    333c:	df 91       	pop	r29
    333e:	cf 91       	pop	r28
    3340:	08 95       	ret

00003342 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3342:	81 e0       	ldi	r24, 0x01	; 1
    3344:	08 95       	ret

00003346 <_ZN8emstream7getcharEv>:
    3346:	80 e0       	ldi	r24, 0x00	; 0
    3348:	90 e0       	ldi	r25, 0x00	; 0
    334a:	08 95       	ret

0000334c <_ZN8emstream14check_for_charEv>:
    334c:	80 e0       	ldi	r24, 0x00	; 0
    334e:	08 95       	ret

00003350 <_ZN8emstream12transmit_nowEv>:
    3350:	08 95       	ret

00003352 <_ZN8emstream12clear_screenEv>:
    3352:	08 95       	ret

00003354 <_ZN8emstreamC1Ev>:
    3354:	fc 01       	movw	r30, r24
    3356:	8f e4       	ldi	r24, 0x4F	; 79
    3358:	90 e2       	ldi	r25, 0x20	; 32
    335a:	80 83       	st	Z, r24
    335c:	91 83       	std	Z+1, r25	; 0x01
    335e:	8a e0       	ldi	r24, 0x0A	; 10
    3360:	82 83       	std	Z+2, r24	; 0x02
    3362:	13 82       	std	Z+3, r1	; 0x03
    3364:	83 e0       	ldi	r24, 0x03	; 3
    3366:	85 83       	std	Z+5, r24	; 0x05
    3368:	14 82       	std	Z+4, r1	; 0x04
    336a:	16 82       	std	Z+6, r1	; 0x06
    336c:	17 82       	std	Z+7, r1	; 0x07
    336e:	08 95       	ret

00003370 <_ZN8emstream4putsEPKc>:
    3370:	0f 93       	push	r16
    3372:	1f 93       	push	r17
    3374:	cf 93       	push	r28
    3376:	df 93       	push	r29
    3378:	8c 01       	movw	r16, r24
    337a:	fb 01       	movw	r30, r22
    337c:	dc 01       	movw	r26, r24
    337e:	14 96       	adiw	r26, 0x04	; 4
    3380:	8c 91       	ld	r24, X
    3382:	81 11       	cpse	r24, r1
    3384:	04 c0       	rjmp	.+8      	; 0x338e <_ZN8emstream4putsEPKc+0x1e>
    3386:	60 81       	ld	r22, Z
    3388:	61 11       	cpse	r22, r1
    338a:	17 c0       	rjmp	.+46     	; 0x33ba <_ZN8emstream4putsEPKc+0x4a>
    338c:	23 c0       	rjmp	.+70     	; 0x33d4 <_ZN8emstream4putsEPKc+0x64>
    338e:	d8 01       	movw	r26, r16
    3390:	14 96       	adiw	r26, 0x04	; 4
    3392:	1c 92       	st	X, r1
    3394:	eb 01       	movw	r28, r22
    3396:	21 96       	adiw	r28, 0x01	; 1
    3398:	64 91       	lpm	r22, Z
    339a:	66 23       	and	r22, r22
    339c:	d9 f0       	breq	.+54     	; 0x33d4 <_ZN8emstream4putsEPKc+0x64>
    339e:	d8 01       	movw	r26, r16
    33a0:	ed 91       	ld	r30, X+
    33a2:	fc 91       	ld	r31, X
    33a4:	02 80       	ldd	r0, Z+2	; 0x02
    33a6:	f3 81       	ldd	r31, Z+3	; 0x03
    33a8:	e0 2d       	mov	r30, r0
    33aa:	c8 01       	movw	r24, r16
    33ac:	19 95       	eicall
    33ae:	fe 01       	movw	r30, r28
    33b0:	64 91       	lpm	r22, Z
    33b2:	21 96       	adiw	r28, 0x01	; 1
    33b4:	61 11       	cpse	r22, r1
    33b6:	f3 cf       	rjmp	.-26     	; 0x339e <_ZN8emstream4putsEPKc+0x2e>
    33b8:	0d c0       	rjmp	.+26     	; 0x33d4 <_ZN8emstream4putsEPKc+0x64>
    33ba:	ef 01       	movw	r28, r30
    33bc:	21 96       	adiw	r28, 0x01	; 1
    33be:	d8 01       	movw	r26, r16
    33c0:	ed 91       	ld	r30, X+
    33c2:	fc 91       	ld	r31, X
    33c4:	02 80       	ldd	r0, Z+2	; 0x02
    33c6:	f3 81       	ldd	r31, Z+3	; 0x03
    33c8:	e0 2d       	mov	r30, r0
    33ca:	c8 01       	movw	r24, r16
    33cc:	19 95       	eicall
    33ce:	69 91       	ld	r22, Y+
    33d0:	61 11       	cpse	r22, r1
    33d2:	f5 cf       	rjmp	.-22     	; 0x33be <_ZN8emstream4putsEPKc+0x4e>
    33d4:	df 91       	pop	r29
    33d6:	cf 91       	pop	r28
    33d8:	1f 91       	pop	r17
    33da:	0f 91       	pop	r16
    33dc:	08 95       	ret

000033de <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    33de:	cf 93       	push	r28
    33e0:	df 93       	push	r29
    33e2:	ec 01       	movw	r28, r24
	switch (new_manip)
    33e4:	86 2f       	mov	r24, r22
    33e6:	90 e0       	ldi	r25, 0x00	; 0
    33e8:	8b 30       	cpi	r24, 0x0B	; 11
    33ea:	91 05       	cpc	r25, r1
    33ec:	d8 f5       	brcc	.+118    	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
    33ee:	fc 01       	movw	r30, r24
    33f0:	88 27       	eor	r24, r24
    33f2:	e2 50       	subi	r30, 0x02	; 2
    33f4:	ff 4f       	sbci	r31, 0xFF	; 255
    33f6:	8f 4f       	sbci	r24, 0xFF	; 255
    33f8:	0c 94 6d 1f 	jmp	0x3eda	; 0x3eda <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    33fc:	82 e0       	ldi	r24, 0x02	; 2
    33fe:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3400:	31 c0       	rjmp	.+98     	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3402:	88 e0       	ldi	r24, 0x08	; 8
    3404:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3406:	2e c0       	rjmp	.+92     	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3408:	8a e0       	ldi	r24, 0x0A	; 10
    340a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    340c:	2b c0       	rjmp	.+86     	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    340e:	80 e1       	ldi	r24, 0x10	; 16
    3410:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3412:	28 c0       	rjmp	.+80     	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3414:	81 e0       	ldi	r24, 0x01	; 1
    3416:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3418:	25 c0       	rjmp	.+74     	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    341a:	1b 82       	std	Y+3, r1	; 0x03
			break;
    341c:	23 c0       	rjmp	.+70     	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    341e:	e8 81       	ld	r30, Y
    3420:	f9 81       	ldd	r31, Y+1	; 0x01
    3422:	02 80       	ldd	r0, Z+2	; 0x02
    3424:	f3 81       	ldd	r31, Z+3	; 0x03
    3426:	e0 2d       	mov	r30, r0
    3428:	6d e0       	ldi	r22, 0x0D	; 13
    342a:	ce 01       	movw	r24, r28
    342c:	19 95       	eicall
    342e:	e8 81       	ld	r30, Y
    3430:	f9 81       	ldd	r31, Y+1	; 0x01
    3432:	02 80       	ldd	r0, Z+2	; 0x02
    3434:	f3 81       	ldd	r31, Z+3	; 0x03
    3436:	e0 2d       	mov	r30, r0
    3438:	6a e0       	ldi	r22, 0x0A	; 10
    343a:	ce 01       	movw	r24, r28
    343c:	19 95       	eicall
			break;
    343e:	12 c0       	rjmp	.+36     	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3440:	e8 81       	ld	r30, Y
    3442:	f9 81       	ldd	r31, Y+1	; 0x01
    3444:	02 84       	ldd	r0, Z+10	; 0x0a
    3446:	f3 85       	ldd	r31, Z+11	; 0x0b
    3448:	e0 2d       	mov	r30, r0
    344a:	ce 01       	movw	r24, r28
    344c:	19 95       	eicall
			break;
    344e:	0a c0       	rjmp	.+20     	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3450:	e8 81       	ld	r30, Y
    3452:	f9 81       	ldd	r31, Y+1	; 0x01
    3454:	00 84       	ldd	r0, Z+8	; 0x08
    3456:	f1 85       	ldd	r31, Z+9	; 0x09
    3458:	e0 2d       	mov	r30, r0
    345a:	ce 01       	movw	r24, r28
    345c:	19 95       	eicall
			break;
    345e:	02 c0       	rjmp	.+4      	; 0x3464 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3460:	81 e0       	ldi	r24, 0x01	; 1
    3462:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3464:	ce 01       	movw	r24, r28
    3466:	df 91       	pop	r29
    3468:	cf 91       	pop	r28
    346a:	08 95       	ret

0000346c <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    346c:	ff 92       	push	r15
    346e:	0f 93       	push	r16
    3470:	1f 93       	push	r17
    3472:	cf 93       	push	r28
    3474:	df 93       	push	r29
    3476:	cd b7       	in	r28, 0x3d	; 61
    3478:	de b7       	in	r29, 0x3e	; 62
    347a:	61 97       	sbiw	r28, 0x11	; 17
    347c:	cd bf       	out	0x3d, r28	; 61
    347e:	de bf       	out	0x3e, r29	; 62
    3480:	8c 01       	movw	r16, r24
    3482:	f6 2e       	mov	r15, r22
    3484:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3486:	f8 01       	movw	r30, r16
    3488:	42 81       	ldd	r20, Z+2	; 0x02
    348a:	40 31       	cpi	r20, 0x10	; 16
    348c:	21 f0       	breq	.+8      	; 0x3496 <_ZN8emstreamlsEj+0x2a>
    348e:	48 30       	cpi	r20, 0x08	; 8
    3490:	11 f0       	breq	.+4      	; 0x3496 <_ZN8emstreamlsEj+0x2a>
    3492:	42 30       	cpi	r20, 0x02	; 2
    3494:	41 f4       	brne	.+16     	; 0x34a6 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3496:	69 2f       	mov	r22, r25
    3498:	c8 01       	movw	r24, r16
    349a:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
    349e:	6f 2d       	mov	r22, r15
    34a0:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
    34a4:	0d c0       	rjmp	.+26     	; 0x34c0 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    34a6:	50 e0       	ldi	r21, 0x00	; 0
    34a8:	be 01       	movw	r22, r28
    34aa:	6f 5f       	subi	r22, 0xFF	; 255
    34ac:	7f 4f       	sbci	r23, 0xFF	; 255
    34ae:	8f 2d       	mov	r24, r15
    34b0:	0e 94 07 20 	call	0x400e	; 0x400e <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    34b4:	be 01       	movw	r22, r28
    34b6:	6f 5f       	subi	r22, 0xFF	; 255
    34b8:	7f 4f       	sbci	r23, 0xFF	; 255
    34ba:	c8 01       	movw	r24, r16
    34bc:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    34c0:	c8 01       	movw	r24, r16
    34c2:	61 96       	adiw	r28, 0x11	; 17
    34c4:	cd bf       	out	0x3d, r28	; 61
    34c6:	de bf       	out	0x3e, r29	; 62
    34c8:	df 91       	pop	r29
    34ca:	cf 91       	pop	r28
    34cc:	1f 91       	pop	r17
    34ce:	0f 91       	pop	r16
    34d0:	ff 90       	pop	r15
    34d2:	08 95       	ret

000034d4 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    34d4:	df 92       	push	r13
    34d6:	ef 92       	push	r14
    34d8:	ff 92       	push	r15
    34da:	0f 93       	push	r16
    34dc:	1f 93       	push	r17
    34de:	cf 93       	push	r28
    34e0:	df 93       	push	r29
    34e2:	cd b7       	in	r28, 0x3d	; 61
    34e4:	de b7       	in	r29, 0x3e	; 62
    34e6:	a1 97       	sbiw	r28, 0x21	; 33
    34e8:	cd bf       	out	0x3d, r28	; 61
    34ea:	de bf       	out	0x3e, r29	; 62
    34ec:	8c 01       	movw	r16, r24
    34ee:	d4 2e       	mov	r13, r20
    34f0:	e5 2e       	mov	r14, r21
    34f2:	f6 2e       	mov	r15, r22
    34f4:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    34f6:	f8 01       	movw	r30, r16
    34f8:	22 81       	ldd	r18, Z+2	; 0x02
    34fa:	20 31       	cpi	r18, 0x10	; 16
    34fc:	21 f0       	breq	.+8      	; 0x3506 <_ZN8emstreamlsEm+0x32>
    34fe:	28 30       	cpi	r18, 0x08	; 8
    3500:	11 f0       	breq	.+4      	; 0x3506 <_ZN8emstreamlsEm+0x32>
    3502:	22 30       	cpi	r18, 0x02	; 2
    3504:	71 f4       	brne	.+28     	; 0x3522 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3506:	69 2f       	mov	r22, r25
    3508:	c8 01       	movw	r24, r16
    350a:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
    350e:	6f 2d       	mov	r22, r15
    3510:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
    3514:	6e 2d       	mov	r22, r14
    3516:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
    351a:	6d 2d       	mov	r22, r13
    351c:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_ZN8emstreamlsEh>
    3520:	0f c0       	rjmp	.+30     	; 0x3540 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3522:	30 e0       	ldi	r19, 0x00	; 0
    3524:	ae 01       	movw	r20, r28
    3526:	4f 5f       	subi	r20, 0xFF	; 255
    3528:	5f 4f       	sbci	r21, 0xFF	; 255
    352a:	6d 2d       	mov	r22, r13
    352c:	7e 2d       	mov	r23, r14
    352e:	8f 2d       	mov	r24, r15
    3530:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3534:	be 01       	movw	r22, r28
    3536:	6f 5f       	subi	r22, 0xFF	; 255
    3538:	7f 4f       	sbci	r23, 0xFF	; 255
    353a:	c8 01       	movw	r24, r16
    353c:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3540:	c8 01       	movw	r24, r16
    3542:	a1 96       	adiw	r28, 0x21	; 33
    3544:	cd bf       	out	0x3d, r28	; 61
    3546:	de bf       	out	0x3e, r29	; 62
    3548:	df 91       	pop	r29
    354a:	cf 91       	pop	r28
    354c:	1f 91       	pop	r17
    354e:	0f 91       	pop	r16
    3550:	ff 90       	pop	r15
    3552:	ef 90       	pop	r14
    3554:	df 90       	pop	r13
    3556:	08 95       	ret

00003558 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3558:	cf 92       	push	r12
    355a:	df 92       	push	r13
    355c:	ef 92       	push	r14
    355e:	ff 92       	push	r15
    3560:	0f 93       	push	r16
    3562:	1f 93       	push	r17
    3564:	cf 93       	push	r28
    3566:	df 93       	push	r29
    3568:	cd b7       	in	r28, 0x3d	; 61
    356a:	de b7       	in	r29, 0x3e	; 62
    356c:	29 97       	sbiw	r28, 0x09	; 9
    356e:	cd bf       	out	0x3d, r28	; 61
    3570:	de bf       	out	0x3e, r29	; 62
    3572:	8c 01       	movw	r16, r24
    3574:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3576:	dc 01       	movw	r26, r24
    3578:	13 96       	adiw	r26, 0x03	; 3
    357a:	8c 91       	ld	r24, X
    357c:	13 97       	sbiw	r26, 0x03	; 3
    357e:	88 23       	and	r24, r24
    3580:	41 f0       	breq	.+16     	; 0x3592 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3582:	ed 91       	ld	r30, X+
    3584:	fc 91       	ld	r31, X
    3586:	02 80       	ldd	r0, Z+2	; 0x02
    3588:	f3 81       	ldd	r31, Z+3	; 0x03
    358a:	e0 2d       	mov	r30, r0
    358c:	c8 01       	movw	r24, r16
    358e:	19 95       	eicall
    3590:	56 c0       	rjmp	.+172    	; 0x363e <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3592:	f8 01       	movw	r30, r16
    3594:	42 81       	ldd	r20, Z+2	; 0x02
    3596:	42 30       	cpi	r20, 0x02	; 2
    3598:	19 f5       	brne	.+70     	; 0x35e0 <_ZN8emstreamlsEh+0x88>
    359a:	68 94       	set
    359c:	cc 24       	eor	r12, r12
    359e:	c3 f8       	bld	r12, 3
    35a0:	d1 2c       	mov	r13, r1
    35a2:	68 94       	set
    35a4:	ff 24       	eor	r15, r15
    35a6:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    35a8:	8e 2d       	mov	r24, r14
    35aa:	8f 21       	and	r24, r15
    35ac:	51 f0       	breq	.+20     	; 0x35c2 <_ZN8emstreamlsEh+0x6a>
    35ae:	d8 01       	movw	r26, r16
    35b0:	ed 91       	ld	r30, X+
    35b2:	fc 91       	ld	r31, X
    35b4:	02 80       	ldd	r0, Z+2	; 0x02
    35b6:	f3 81       	ldd	r31, Z+3	; 0x03
    35b8:	e0 2d       	mov	r30, r0
    35ba:	61 e3       	ldi	r22, 0x31	; 49
    35bc:	c8 01       	movw	r24, r16
    35be:	19 95       	eicall
    35c0:	09 c0       	rjmp	.+18     	; 0x35d4 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    35c2:	d8 01       	movw	r26, r16
    35c4:	ed 91       	ld	r30, X+
    35c6:	fc 91       	ld	r31, X
    35c8:	02 80       	ldd	r0, Z+2	; 0x02
    35ca:	f3 81       	ldd	r31, Z+3	; 0x03
    35cc:	e0 2d       	mov	r30, r0
    35ce:	60 e3       	ldi	r22, 0x30	; 48
    35d0:	c8 01       	movw	r24, r16
    35d2:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    35d4:	f6 94       	lsr	r15
    35d6:	b1 e0       	ldi	r27, 0x01	; 1
    35d8:	cb 1a       	sub	r12, r27
    35da:	d1 08       	sbc	r13, r1
    35dc:	29 f7       	brne	.-54     	; 0x35a8 <_ZN8emstreamlsEh+0x50>
    35de:	2f c0       	rjmp	.+94     	; 0x363e <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    35e0:	40 31       	cpi	r20, 0x10	; 16
    35e2:	f9 f4       	brne	.+62     	; 0x3622 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    35e4:	62 95       	swap	r22
    35e6:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    35e8:	01 90       	ld	r0, Z+
    35ea:	f0 81       	ld	r31, Z
    35ec:	e0 2d       	mov	r30, r0
    35ee:	02 80       	ldd	r0, Z+2	; 0x02
    35f0:	f3 81       	ldd	r31, Z+3	; 0x03
    35f2:	e0 2d       	mov	r30, r0
    35f4:	6a 30       	cpi	r22, 0x0A	; 10
    35f6:	10 f0       	brcs	.+4      	; 0x35fc <_ZN8emstreamlsEh+0xa4>
    35f8:	69 5c       	subi	r22, 0xC9	; 201
    35fa:	01 c0       	rjmp	.+2      	; 0x35fe <_ZN8emstreamlsEh+0xa6>
    35fc:	60 5d       	subi	r22, 0xD0	; 208
    35fe:	c8 01       	movw	r24, r16
    3600:	19 95       	eicall
		temp_char = num & 0x0F;
    3602:	6e 2d       	mov	r22, r14
    3604:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3606:	d8 01       	movw	r26, r16
    3608:	ed 91       	ld	r30, X+
    360a:	fc 91       	ld	r31, X
    360c:	02 80       	ldd	r0, Z+2	; 0x02
    360e:	f3 81       	ldd	r31, Z+3	; 0x03
    3610:	e0 2d       	mov	r30, r0
    3612:	6a 30       	cpi	r22, 0x0A	; 10
    3614:	10 f0       	brcs	.+4      	; 0x361a <_ZN8emstreamlsEh+0xc2>
    3616:	69 5c       	subi	r22, 0xC9	; 201
    3618:	01 c0       	rjmp	.+2      	; 0x361c <_ZN8emstreamlsEh+0xc4>
    361a:	60 5d       	subi	r22, 0xD0	; 208
    361c:	c8 01       	movw	r24, r16
    361e:	19 95       	eicall
    3620:	0e c0       	rjmp	.+28     	; 0x363e <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3622:	50 e0       	ldi	r21, 0x00	; 0
    3624:	be 01       	movw	r22, r28
    3626:	6f 5f       	subi	r22, 0xFF	; 255
    3628:	7f 4f       	sbci	r23, 0xFF	; 255
    362a:	8e 2d       	mov	r24, r14
    362c:	90 e0       	ldi	r25, 0x00	; 0
    362e:	0e 94 07 20 	call	0x400e	; 0x400e <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3632:	be 01       	movw	r22, r28
    3634:	6f 5f       	subi	r22, 0xFF	; 255
    3636:	7f 4f       	sbci	r23, 0xFF	; 255
    3638:	c8 01       	movw	r24, r16
    363a:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    363e:	c8 01       	movw	r24, r16
    3640:	29 96       	adiw	r28, 0x09	; 9
    3642:	cd bf       	out	0x3d, r28	; 61
    3644:	de bf       	out	0x3e, r29	; 62
    3646:	df 91       	pop	r29
    3648:	cf 91       	pop	r28
    364a:	1f 91       	pop	r17
    364c:	0f 91       	pop	r16
    364e:	ff 90       	pop	r15
    3650:	ef 90       	pop	r14
    3652:	df 90       	pop	r13
    3654:	cf 90       	pop	r12
    3656:	08 95       	ret

00003658 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3658:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    365a:	50 96       	adiw	r26, 0x10	; 16
    365c:	ed 91       	ld	r30, X+
    365e:	fc 91       	ld	r31, X
    3660:	51 97       	sbiw	r26, 0x11	; 17
    3662:	80 81       	ld	r24, Z
    3664:	54 96       	adiw	r26, 0x14	; 20
    3666:	4c 91       	ld	r20, X
    3668:	54 97       	sbiw	r26, 0x14	; 20
    366a:	84 23       	and	r24, r20
    366c:	29 f0       	breq	.+10     	; 0x3678 <_ZN5rs2327putcharEc+0x20>
    366e:	09 c0       	rjmp	.+18     	; 0x3682 <_ZN5rs2327putcharEc+0x2a>
    3670:	21 50       	subi	r18, 0x01	; 1
    3672:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3674:	19 f4       	brne	.+6      	; 0x367c <_ZN5rs2327putcharEc+0x24>
    3676:	12 c0       	rjmp	.+36     	; 0x369c <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3678:	21 e2       	ldi	r18, 0x21	; 33
    367a:	3e e4       	ldi	r19, 0x4E	; 78
    367c:	90 81       	ld	r25, Z
    367e:	94 23       	and	r25, r20
    3680:	b9 f3       	breq	.-18     	; 0x3670 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3682:	90 81       	ld	r25, Z
    3684:	56 96       	adiw	r26, 0x16	; 22
    3686:	8c 91       	ld	r24, X
    3688:	56 97       	sbiw	r26, 0x16	; 22
    368a:	89 2b       	or	r24, r25
    368c:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    368e:	1e 96       	adiw	r26, 0x0e	; 14
    3690:	ed 91       	ld	r30, X+
    3692:	fc 91       	ld	r31, X
    3694:	1f 97       	sbiw	r26, 0x0f	; 15
    3696:	60 83       	st	Z, r22
	return (true);
    3698:	81 e0       	ldi	r24, 0x01	; 1
    369a:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    369c:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    369e:	08 95       	ret

000036a0 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    36a0:	cf 93       	push	r28
    36a2:	df 93       	push	r29
    36a4:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    36a6:	c1 8d       	ldd	r28, Z+25	; 0x19
    36a8:	d2 8d       	ldd	r29, Z+26	; 0x1a
    36aa:	28 81       	ld	r18, Y
    36ac:	39 81       	ldd	r19, Y+1	; 0x01
    36ae:	a3 8d       	ldd	r26, Z+27	; 0x1b
    36b0:	b4 8d       	ldd	r27, Z+28	; 0x1c
    36b2:	4d 91       	ld	r20, X+
    36b4:	5c 91       	ld	r21, X
    36b6:	24 17       	cp	r18, r20
    36b8:	35 07       	cpc	r19, r21
    36ba:	e9 f3       	breq	.-6      	; 0x36b6 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    36bc:	a7 89       	ldd	r26, Z+23	; 0x17
    36be:	b0 8d       	ldd	r27, Z+24	; 0x18
    36c0:	0d 90       	ld	r0, X+
    36c2:	bc 91       	ld	r27, X
    36c4:	a0 2d       	mov	r26, r0
    36c6:	a2 0f       	add	r26, r18
    36c8:	b3 1f       	adc	r27, r19
    36ca:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    36cc:	2f 5f       	subi	r18, 0xFF	; 255
    36ce:	3f 4f       	sbci	r19, 0xFF	; 255
    36d0:	28 83       	st	Y, r18
    36d2:	39 83       	std	Y+1, r19	; 0x01
    36d4:	24 36       	cpi	r18, 0x64	; 100
    36d6:	31 05       	cpc	r19, r1
    36d8:	28 f0       	brcs	.+10     	; 0x36e4 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    36da:	01 8c       	ldd	r0, Z+25	; 0x19
    36dc:	f2 8d       	ldd	r31, Z+26	; 0x1a
    36de:	e0 2d       	mov	r30, r0
    36e0:	10 82       	st	Z, r1
    36e2:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    36e4:	90 e0       	ldi	r25, 0x00	; 0
    36e6:	df 91       	pop	r29
    36e8:	cf 91       	pop	r28
    36ea:	08 95       	ret

000036ec <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    36ec:	cf 93       	push	r28
    36ee:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    36f0:	ec 01       	movw	r28, r24
    36f2:	a9 8d       	ldd	r26, Y+25	; 0x19
    36f4:	ba 8d       	ldd	r27, Y+26	; 0x1a
    36f6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    36f8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    36fa:	81 e0       	ldi	r24, 0x01	; 1
    36fc:	4d 91       	ld	r20, X+
    36fe:	5c 91       	ld	r21, X
    3700:	20 81       	ld	r18, Z
    3702:	31 81       	ldd	r19, Z+1	; 0x01
    3704:	42 17       	cp	r20, r18
    3706:	53 07       	cpc	r21, r19
    3708:	09 f4       	brne	.+2      	; 0x370c <_ZN5rs23214check_for_charEv+0x20>
    370a:	80 e0       	ldi	r24, 0x00	; 0
}
    370c:	df 91       	pop	r29
    370e:	cf 91       	pop	r28
    3710:	08 95       	ret

00003712 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3712:	dc 01       	movw	r26, r24
    3714:	ed 91       	ld	r30, X+
    3716:	fc 91       	ld	r31, X
    3718:	02 80       	ldd	r0, Z+2	; 0x02
    371a:	f3 81       	ldd	r31, Z+3	; 0x03
    371c:	e0 2d       	mov	r30, r0
    371e:	6c e0       	ldi	r22, 0x0C	; 12
    3720:	19 95       	eicall
    3722:	08 95       	ret

00003724 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3724:	ef 92       	push	r14
    3726:	ff 92       	push	r15
    3728:	0f 93       	push	r16
    372a:	1f 93       	push	r17
    372c:	cf 93       	push	r28
    372e:	df 93       	push	r29
    3730:	ec 01       	movw	r28, r24
    3732:	7b 01       	movw	r14, r22
    3734:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3736:	0e 94 aa 19 	call	0x3354	; 0x3354 <_ZN8emstreamC1Ev>
    373a:	a8 01       	movw	r20, r16
    373c:	b7 01       	movw	r22, r14
    373e:	ce 01       	movw	r24, r28
    3740:	08 96       	adiw	r24, 0x08	; 8
    3742:	0e 94 0b 19 	call	0x3216	; 0x3216 <_ZN7base232C1EjP12USART_struct>
    3746:	8f e5       	ldi	r24, 0x5F	; 95
    3748:	90 e2       	ldi	r25, 0x20	; 32
    374a:	88 83       	st	Y, r24
    374c:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    374e:	00 3a       	cpi	r16, 0xA0	; 160
    3750:	88 e0       	ldi	r24, 0x08	; 8
    3752:	18 07       	cpc	r17, r24
    3754:	69 f4       	brne	.+26     	; 0x3770 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3756:	88 e3       	ldi	r24, 0x38	; 56
    3758:	91 e3       	ldi	r25, 0x31	; 49
    375a:	8f 8b       	std	Y+23, r24	; 0x17
    375c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    375e:	8e e2       	ldi	r24, 0x2E	; 46
    3760:	91 e3       	ldi	r25, 0x31	; 49
    3762:	89 8f       	std	Y+25, r24	; 0x19
    3764:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3766:	84 e2       	ldi	r24, 0x24	; 36
    3768:	91 e3       	ldi	r25, 0x31	; 49
    376a:	8b 8f       	std	Y+27, r24	; 0x1b
    376c:	9c 8f       	std	Y+28, r25	; 0x1c
    376e:	42 c0       	rjmp	.+132    	; 0x37f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3770:	00 3b       	cpi	r16, 0xB0	; 176
    3772:	e8 e0       	ldi	r30, 0x08	; 8
    3774:	1e 07       	cpc	r17, r30
    3776:	69 f4       	brne	.+26     	; 0x3792 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3778:	86 e3       	ldi	r24, 0x36	; 54
    377a:	91 e3       	ldi	r25, 0x31	; 49
    377c:	8f 8b       	std	Y+23, r24	; 0x17
    377e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3780:	8c e2       	ldi	r24, 0x2C	; 44
    3782:	91 e3       	ldi	r25, 0x31	; 49
    3784:	89 8f       	std	Y+25, r24	; 0x19
    3786:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3788:	82 e2       	ldi	r24, 0x22	; 34
    378a:	91 e3       	ldi	r25, 0x31	; 49
    378c:	8b 8f       	std	Y+27, r24	; 0x1b
    378e:	9c 8f       	std	Y+28, r25	; 0x1c
    3790:	31 c0       	rjmp	.+98     	; 0x37f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3792:	00 3a       	cpi	r16, 0xA0	; 160
    3794:	f9 e0       	ldi	r31, 0x09	; 9
    3796:	1f 07       	cpc	r17, r31
    3798:	69 f4       	brne	.+26     	; 0x37b4 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    379a:	84 e3       	ldi	r24, 0x34	; 52
    379c:	91 e3       	ldi	r25, 0x31	; 49
    379e:	8f 8b       	std	Y+23, r24	; 0x17
    37a0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    37a2:	8a e2       	ldi	r24, 0x2A	; 42
    37a4:	91 e3       	ldi	r25, 0x31	; 49
    37a6:	89 8f       	std	Y+25, r24	; 0x19
    37a8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    37aa:	80 e2       	ldi	r24, 0x20	; 32
    37ac:	91 e3       	ldi	r25, 0x31	; 49
    37ae:	8b 8f       	std	Y+27, r24	; 0x1b
    37b0:	9c 8f       	std	Y+28, r25	; 0x1c
    37b2:	20 c0       	rjmp	.+64     	; 0x37f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    37b4:	00 3b       	cpi	r16, 0xB0	; 176
    37b6:	89 e0       	ldi	r24, 0x09	; 9
    37b8:	18 07       	cpc	r17, r24
    37ba:	69 f4       	brne	.+26     	; 0x37d6 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    37bc:	82 e3       	ldi	r24, 0x32	; 50
    37be:	91 e3       	ldi	r25, 0x31	; 49
    37c0:	8f 8b       	std	Y+23, r24	; 0x17
    37c2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    37c4:	88 e2       	ldi	r24, 0x28	; 40
    37c6:	91 e3       	ldi	r25, 0x31	; 49
    37c8:	89 8f       	std	Y+25, r24	; 0x19
    37ca:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    37cc:	8e e1       	ldi	r24, 0x1E	; 30
    37ce:	91 e3       	ldi	r25, 0x31	; 49
    37d0:	8b 8f       	std	Y+27, r24	; 0x1b
    37d2:	9c 8f       	std	Y+28, r25	; 0x1c
    37d4:	0f c0       	rjmp	.+30     	; 0x37f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    37d6:	00 3a       	cpi	r16, 0xA0	; 160
    37d8:	1a 40       	sbci	r17, 0x0A	; 10
    37da:	61 f4       	brne	.+24     	; 0x37f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    37dc:	80 e3       	ldi	r24, 0x30	; 48
    37de:	91 e3       	ldi	r25, 0x31	; 49
    37e0:	8f 8b       	std	Y+23, r24	; 0x17
    37e2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    37e4:	86 e2       	ldi	r24, 0x26	; 38
    37e6:	91 e3       	ldi	r25, 0x31	; 49
    37e8:	89 8f       	std	Y+25, r24	; 0x19
    37ea:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    37ec:	8c e1       	ldi	r24, 0x1C	; 28
    37ee:	91 e3       	ldi	r25, 0x31	; 49
    37f0:	8b 8f       	std	Y+27, r24	; 0x1b
    37f2:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    37f4:	0f 89       	ldd	r16, Y+23	; 0x17
    37f6:	18 8d       	ldd	r17, Y+24	; 0x18
    37f8:	84 e6       	ldi	r24, 0x64	; 100
    37fa:	90 e0       	ldi	r25, 0x00	; 0
    37fc:	0e 94 07 19 	call	0x320e	; 0x320e <_Znaj>
    3800:	f8 01       	movw	r30, r16
    3802:	80 83       	st	Z, r24
    3804:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3806:	e9 8d       	ldd	r30, Y+25	; 0x19
    3808:	fa 8d       	ldd	r31, Y+26	; 0x1a
    380a:	10 82       	st	Z, r1
    380c:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    380e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3810:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3812:	10 82       	st	Z, r1
    3814:	11 82       	std	Z+1, r1	; 0x01
}
    3816:	df 91       	pop	r29
    3818:	cf 91       	pop	r28
    381a:	1f 91       	pop	r17
    381c:	0f 91       	pop	r16
    381e:	ff 90       	pop	r15
    3820:	ef 90       	pop	r14
    3822:	08 95       	ret

00003824 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3824:	1f 92       	push	r1
    3826:	0f 92       	push	r0
    3828:	0f b6       	in	r0, 0x3f	; 63
    382a:	0f 92       	push	r0
    382c:	11 24       	eor	r1, r1
    382e:	08 b6       	in	r0, 0x38	; 56
    3830:	0f 92       	push	r0
    3832:	18 be       	out	0x38, r1	; 56
    3834:	0b b6       	in	r0, 0x3b	; 59
    3836:	0f 92       	push	r0
    3838:	1b be       	out	0x3b, r1	; 59
    383a:	2f 93       	push	r18
    383c:	3f 93       	push	r19
    383e:	8f 93       	push	r24
    3840:	9f 93       	push	r25
    3842:	ef 93       	push	r30
    3844:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3846:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    384a:	e0 91 38 31 	lds	r30, 0x3138	; 0x803138 <rcvC0_buffer>
    384e:	f0 91 39 31 	lds	r31, 0x3139	; 0x803139 <rcvC0_buffer+0x1>
    3852:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3856:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    385a:	e8 0f       	add	r30, r24
    385c:	f9 1f       	adc	r31, r25
    385e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3860:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3864:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    3868:	01 96       	adiw	r24, 0x01	; 1
    386a:	84 36       	cpi	r24, 0x64	; 100
    386c:	91 05       	cpc	r25, r1
    386e:	60 f4       	brcc	.+24     	; 0x3888 <__vector_25+0x64>
    3870:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <rcvC0_write_index>
    3874:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3878:	20 91 2e 31 	lds	r18, 0x312E	; 0x80312e <rcvC0_read_index>
    387c:	30 91 2f 31 	lds	r19, 0x312F	; 0x80312f <rcvC0_read_index+0x1>
    3880:	82 17       	cp	r24, r18
    3882:	93 07       	cpc	r25, r19
    3884:	f1 f4       	brne	.+60     	; 0x38c2 <__vector_25+0x9e>
    3886:	0c c0       	rjmp	.+24     	; 0x38a0 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3888:	10 92 24 31 	sts	0x3124, r1	; 0x803124 <rcvC0_write_index>
    388c:	10 92 25 31 	sts	0x3125, r1	; 0x803125 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3890:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC0_read_index>
    3894:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC0_read_index+0x1>
    3898:	18 16       	cp	r1, r24
    389a:	19 06       	cpc	r1, r25
    389c:	91 f4       	brne	.+36     	; 0x38c2 <__vector_25+0x9e>
    389e:	0e c0       	rjmp	.+28     	; 0x38bc <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    38a0:	01 96       	adiw	r24, 0x01	; 1
    38a2:	84 36       	cpi	r24, 0x64	; 100
    38a4:	91 05       	cpc	r25, r1
    38a6:	28 f4       	brcc	.+10     	; 0x38b2 <__vector_25+0x8e>
    38a8:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC0_read_index>
    38ac:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC0_read_index+0x1>
    38b0:	08 c0       	rjmp	.+16     	; 0x38c2 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    38b2:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC0_read_index>
    38b6:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC0_read_index+0x1>
}
    38ba:	03 c0       	rjmp	.+6      	; 0x38c2 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    38bc:	81 e0       	ldi	r24, 0x01	; 1
    38be:	90 e0       	ldi	r25, 0x00	; 0
    38c0:	f3 cf       	rjmp	.-26     	; 0x38a8 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    38c2:	ff 91       	pop	r31
    38c4:	ef 91       	pop	r30
    38c6:	9f 91       	pop	r25
    38c8:	8f 91       	pop	r24
    38ca:	3f 91       	pop	r19
    38cc:	2f 91       	pop	r18
    38ce:	0f 90       	pop	r0
    38d0:	0b be       	out	0x3b, r0	; 59
    38d2:	0f 90       	pop	r0
    38d4:	08 be       	out	0x38, r0	; 56
    38d6:	0f 90       	pop	r0
    38d8:	0f be       	out	0x3f, r0	; 63
    38da:	0f 90       	pop	r0
    38dc:	1f 90       	pop	r1
    38de:	18 95       	reti

000038e0 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    38e0:	1f 92       	push	r1
    38e2:	0f 92       	push	r0
    38e4:	0f b6       	in	r0, 0x3f	; 63
    38e6:	0f 92       	push	r0
    38e8:	11 24       	eor	r1, r1
    38ea:	08 b6       	in	r0, 0x38	; 56
    38ec:	0f 92       	push	r0
    38ee:	18 be       	out	0x38, r1	; 56
    38f0:	0b b6       	in	r0, 0x3b	; 59
    38f2:	0f 92       	push	r0
    38f4:	1b be       	out	0x3b, r1	; 59
    38f6:	2f 93       	push	r18
    38f8:	3f 93       	push	r19
    38fa:	8f 93       	push	r24
    38fc:	9f 93       	push	r25
    38fe:	ef 93       	push	r30
    3900:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3902:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3906:	e0 91 36 31 	lds	r30, 0x3136	; 0x803136 <rcvC1_buffer>
    390a:	f0 91 37 31 	lds	r31, 0x3137	; 0x803137 <rcvC1_buffer+0x1>
    390e:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvC1_write_index>
    3912:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvC1_write_index+0x1>
    3916:	e8 0f       	add	r30, r24
    3918:	f9 1f       	adc	r31, r25
    391a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    391c:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvC1_write_index>
    3920:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvC1_write_index+0x1>
    3924:	01 96       	adiw	r24, 0x01	; 1
    3926:	84 36       	cpi	r24, 0x64	; 100
    3928:	91 05       	cpc	r25, r1
    392a:	60 f4       	brcc	.+24     	; 0x3944 <__vector_28+0x64>
    392c:	80 93 22 31 	sts	0x3122, r24	; 0x803122 <rcvC1_write_index>
    3930:	90 93 23 31 	sts	0x3123, r25	; 0x803123 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3934:	20 91 2c 31 	lds	r18, 0x312C	; 0x80312c <rcvC1_read_index>
    3938:	30 91 2d 31 	lds	r19, 0x312D	; 0x80312d <rcvC1_read_index+0x1>
    393c:	82 17       	cp	r24, r18
    393e:	93 07       	cpc	r25, r19
    3940:	f1 f4       	brne	.+60     	; 0x397e <__vector_28+0x9e>
    3942:	0c c0       	rjmp	.+24     	; 0x395c <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3944:	10 92 22 31 	sts	0x3122, r1	; 0x803122 <rcvC1_write_index>
    3948:	10 92 23 31 	sts	0x3123, r1	; 0x803123 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    394c:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvC1_read_index>
    3950:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvC1_read_index+0x1>
    3954:	18 16       	cp	r1, r24
    3956:	19 06       	cpc	r1, r25
    3958:	91 f4       	brne	.+36     	; 0x397e <__vector_28+0x9e>
    395a:	0e c0       	rjmp	.+28     	; 0x3978 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    395c:	01 96       	adiw	r24, 0x01	; 1
    395e:	84 36       	cpi	r24, 0x64	; 100
    3960:	91 05       	cpc	r25, r1
    3962:	28 f4       	brcc	.+10     	; 0x396e <__vector_28+0x8e>
    3964:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvC1_read_index>
    3968:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvC1_read_index+0x1>
    396c:	08 c0       	rjmp	.+16     	; 0x397e <__vector_28+0x9e>
	rcvC1_read_index = 0;
    396e:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvC1_read_index>
    3972:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvC1_read_index+0x1>
}
    3976:	03 c0       	rjmp	.+6      	; 0x397e <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3978:	81 e0       	ldi	r24, 0x01	; 1
    397a:	90 e0       	ldi	r25, 0x00	; 0
    397c:	f3 cf       	rjmp	.-26     	; 0x3964 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    397e:	ff 91       	pop	r31
    3980:	ef 91       	pop	r30
    3982:	9f 91       	pop	r25
    3984:	8f 91       	pop	r24
    3986:	3f 91       	pop	r19
    3988:	2f 91       	pop	r18
    398a:	0f 90       	pop	r0
    398c:	0b be       	out	0x3b, r0	; 59
    398e:	0f 90       	pop	r0
    3990:	08 be       	out	0x38, r0	; 56
    3992:	0f 90       	pop	r0
    3994:	0f be       	out	0x3f, r0	; 63
    3996:	0f 90       	pop	r0
    3998:	1f 90       	pop	r1
    399a:	18 95       	reti

0000399c <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    399c:	1f 92       	push	r1
    399e:	0f 92       	push	r0
    39a0:	0f b6       	in	r0, 0x3f	; 63
    39a2:	0f 92       	push	r0
    39a4:	11 24       	eor	r1, r1
    39a6:	08 b6       	in	r0, 0x38	; 56
    39a8:	0f 92       	push	r0
    39aa:	18 be       	out	0x38, r1	; 56
    39ac:	0b b6       	in	r0, 0x3b	; 59
    39ae:	0f 92       	push	r0
    39b0:	1b be       	out	0x3b, r1	; 59
    39b2:	2f 93       	push	r18
    39b4:	3f 93       	push	r19
    39b6:	8f 93       	push	r24
    39b8:	9f 93       	push	r25
    39ba:	ef 93       	push	r30
    39bc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    39be:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    39c2:	e0 91 34 31 	lds	r30, 0x3134	; 0x803134 <rcvD0_buffer>
    39c6:	f0 91 35 31 	lds	r31, 0x3135	; 0x803135 <rcvD0_buffer+0x1>
    39ca:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    39ce:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    39d2:	e8 0f       	add	r30, r24
    39d4:	f9 1f       	adc	r31, r25
    39d6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    39d8:	80 91 20 31 	lds	r24, 0x3120	; 0x803120 <rcvD0_write_index>
    39dc:	90 91 21 31 	lds	r25, 0x3121	; 0x803121 <rcvD0_write_index+0x1>
    39e0:	01 96       	adiw	r24, 0x01	; 1
    39e2:	84 36       	cpi	r24, 0x64	; 100
    39e4:	91 05       	cpc	r25, r1
    39e6:	60 f4       	brcc	.+24     	; 0x3a00 <__vector_88+0x64>
    39e8:	80 93 20 31 	sts	0x3120, r24	; 0x803120 <rcvD0_write_index>
    39ec:	90 93 21 31 	sts	0x3121, r25	; 0x803121 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    39f0:	20 91 2a 31 	lds	r18, 0x312A	; 0x80312a <rcvD0_read_index>
    39f4:	30 91 2b 31 	lds	r19, 0x312B	; 0x80312b <rcvD0_read_index+0x1>
    39f8:	82 17       	cp	r24, r18
    39fa:	93 07       	cpc	r25, r19
    39fc:	f1 f4       	brne	.+60     	; 0x3a3a <__vector_88+0x9e>
    39fe:	0c c0       	rjmp	.+24     	; 0x3a18 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3a00:	10 92 20 31 	sts	0x3120, r1	; 0x803120 <rcvD0_write_index>
    3a04:	10 92 21 31 	sts	0x3121, r1	; 0x803121 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a08:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD0_read_index>
    3a0c:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD0_read_index+0x1>
    3a10:	18 16       	cp	r1, r24
    3a12:	19 06       	cpc	r1, r25
    3a14:	91 f4       	brne	.+36     	; 0x3a3a <__vector_88+0x9e>
    3a16:	0e c0       	rjmp	.+28     	; 0x3a34 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a18:	01 96       	adiw	r24, 0x01	; 1
    3a1a:	84 36       	cpi	r24, 0x64	; 100
    3a1c:	91 05       	cpc	r25, r1
    3a1e:	28 f4       	brcc	.+10     	; 0x3a2a <__vector_88+0x8e>
    3a20:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD0_read_index>
    3a24:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD0_read_index+0x1>
    3a28:	08 c0       	rjmp	.+16     	; 0x3a3a <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3a2a:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD0_read_index>
    3a2e:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD0_read_index+0x1>
}
    3a32:	03 c0       	rjmp	.+6      	; 0x3a3a <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a34:	81 e0       	ldi	r24, 0x01	; 1
    3a36:	90 e0       	ldi	r25, 0x00	; 0
    3a38:	f3 cf       	rjmp	.-26     	; 0x3a20 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3a3a:	ff 91       	pop	r31
    3a3c:	ef 91       	pop	r30
    3a3e:	9f 91       	pop	r25
    3a40:	8f 91       	pop	r24
    3a42:	3f 91       	pop	r19
    3a44:	2f 91       	pop	r18
    3a46:	0f 90       	pop	r0
    3a48:	0b be       	out	0x3b, r0	; 59
    3a4a:	0f 90       	pop	r0
    3a4c:	08 be       	out	0x38, r0	; 56
    3a4e:	0f 90       	pop	r0
    3a50:	0f be       	out	0x3f, r0	; 63
    3a52:	0f 90       	pop	r0
    3a54:	1f 90       	pop	r1
    3a56:	18 95       	reti

00003a58 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3a58:	1f 92       	push	r1
    3a5a:	0f 92       	push	r0
    3a5c:	0f b6       	in	r0, 0x3f	; 63
    3a5e:	0f 92       	push	r0
    3a60:	11 24       	eor	r1, r1
    3a62:	08 b6       	in	r0, 0x38	; 56
    3a64:	0f 92       	push	r0
    3a66:	18 be       	out	0x38, r1	; 56
    3a68:	0b b6       	in	r0, 0x3b	; 59
    3a6a:	0f 92       	push	r0
    3a6c:	1b be       	out	0x3b, r1	; 59
    3a6e:	2f 93       	push	r18
    3a70:	3f 93       	push	r19
    3a72:	8f 93       	push	r24
    3a74:	9f 93       	push	r25
    3a76:	ef 93       	push	r30
    3a78:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3a7a:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3a7e:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <rcvD1_buffer>
    3a82:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <rcvD1_buffer+0x1>
    3a86:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvD1_write_index>
    3a8a:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvD1_write_index+0x1>
    3a8e:	e8 0f       	add	r30, r24
    3a90:	f9 1f       	adc	r31, r25
    3a92:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3a94:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvD1_write_index>
    3a98:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvD1_write_index+0x1>
    3a9c:	01 96       	adiw	r24, 0x01	; 1
    3a9e:	84 36       	cpi	r24, 0x64	; 100
    3aa0:	91 05       	cpc	r25, r1
    3aa2:	60 f4       	brcc	.+24     	; 0x3abc <__vector_91+0x64>
    3aa4:	80 93 1e 31 	sts	0x311E, r24	; 0x80311e <rcvD1_write_index>
    3aa8:	90 93 1f 31 	sts	0x311F, r25	; 0x80311f <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3aac:	20 91 28 31 	lds	r18, 0x3128	; 0x803128 <rcvD1_read_index>
    3ab0:	30 91 29 31 	lds	r19, 0x3129	; 0x803129 <rcvD1_read_index+0x1>
    3ab4:	82 17       	cp	r24, r18
    3ab6:	93 07       	cpc	r25, r19
    3ab8:	f1 f4       	brne	.+60     	; 0x3af6 <__vector_91+0x9e>
    3aba:	0c c0       	rjmp	.+24     	; 0x3ad4 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3abc:	10 92 1e 31 	sts	0x311E, r1	; 0x80311e <rcvD1_write_index>
    3ac0:	10 92 1f 31 	sts	0x311F, r1	; 0x80311f <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3ac4:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvD1_read_index>
    3ac8:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvD1_read_index+0x1>
    3acc:	18 16       	cp	r1, r24
    3ace:	19 06       	cpc	r1, r25
    3ad0:	91 f4       	brne	.+36     	; 0x3af6 <__vector_91+0x9e>
    3ad2:	0e c0       	rjmp	.+28     	; 0x3af0 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3ad4:	01 96       	adiw	r24, 0x01	; 1
    3ad6:	84 36       	cpi	r24, 0x64	; 100
    3ad8:	91 05       	cpc	r25, r1
    3ada:	28 f4       	brcc	.+10     	; 0x3ae6 <__vector_91+0x8e>
    3adc:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvD1_read_index>
    3ae0:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvD1_read_index+0x1>
    3ae4:	08 c0       	rjmp	.+16     	; 0x3af6 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3ae6:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvD1_read_index>
    3aea:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvD1_read_index+0x1>
}
    3aee:	03 c0       	rjmp	.+6      	; 0x3af6 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3af0:	81 e0       	ldi	r24, 0x01	; 1
    3af2:	90 e0       	ldi	r25, 0x00	; 0
    3af4:	f3 cf       	rjmp	.-26     	; 0x3adc <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3af6:	ff 91       	pop	r31
    3af8:	ef 91       	pop	r30
    3afa:	9f 91       	pop	r25
    3afc:	8f 91       	pop	r24
    3afe:	3f 91       	pop	r19
    3b00:	2f 91       	pop	r18
    3b02:	0f 90       	pop	r0
    3b04:	0b be       	out	0x3b, r0	; 59
    3b06:	0f 90       	pop	r0
    3b08:	08 be       	out	0x38, r0	; 56
    3b0a:	0f 90       	pop	r0
    3b0c:	0f be       	out	0x3f, r0	; 63
    3b0e:	0f 90       	pop	r0
    3b10:	1f 90       	pop	r1
    3b12:	18 95       	reti

00003b14 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3b14:	1f 92       	push	r1
    3b16:	0f 92       	push	r0
    3b18:	0f b6       	in	r0, 0x3f	; 63
    3b1a:	0f 92       	push	r0
    3b1c:	11 24       	eor	r1, r1
    3b1e:	08 b6       	in	r0, 0x38	; 56
    3b20:	0f 92       	push	r0
    3b22:	18 be       	out	0x38, r1	; 56
    3b24:	0b b6       	in	r0, 0x3b	; 59
    3b26:	0f 92       	push	r0
    3b28:	1b be       	out	0x3b, r1	; 59
    3b2a:	2f 93       	push	r18
    3b2c:	3f 93       	push	r19
    3b2e:	8f 93       	push	r24
    3b30:	9f 93       	push	r25
    3b32:	ef 93       	push	r30
    3b34:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3b36:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3b3a:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <rcvE0_buffer>
    3b3e:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <rcvE0_buffer+0x1>
    3b42:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvE0_write_index>
    3b46:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvE0_write_index+0x1>
    3b4a:	e8 0f       	add	r30, r24
    3b4c:	f9 1f       	adc	r31, r25
    3b4e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3b50:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvE0_write_index>
    3b54:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvE0_write_index+0x1>
    3b58:	01 96       	adiw	r24, 0x01	; 1
    3b5a:	84 36       	cpi	r24, 0x64	; 100
    3b5c:	91 05       	cpc	r25, r1
    3b5e:	60 f4       	brcc	.+24     	; 0x3b78 <__vector_58+0x64>
    3b60:	80 93 1c 31 	sts	0x311C, r24	; 0x80311c <rcvE0_write_index>
    3b64:	90 93 1d 31 	sts	0x311D, r25	; 0x80311d <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3b68:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <rcvE0_read_index>
    3b6c:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <rcvE0_read_index+0x1>
    3b70:	82 17       	cp	r24, r18
    3b72:	93 07       	cpc	r25, r19
    3b74:	f1 f4       	brne	.+60     	; 0x3bb2 <__vector_58+0x9e>
    3b76:	0c c0       	rjmp	.+24     	; 0x3b90 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3b78:	10 92 1c 31 	sts	0x311C, r1	; 0x80311c <rcvE0_write_index>
    3b7c:	10 92 1d 31 	sts	0x311D, r1	; 0x80311d <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3b80:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <rcvE0_read_index>
    3b84:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <rcvE0_read_index+0x1>
    3b88:	18 16       	cp	r1, r24
    3b8a:	19 06       	cpc	r1, r25
    3b8c:	91 f4       	brne	.+36     	; 0x3bb2 <__vector_58+0x9e>
    3b8e:	0e c0       	rjmp	.+28     	; 0x3bac <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3b90:	01 96       	adiw	r24, 0x01	; 1
    3b92:	84 36       	cpi	r24, 0x64	; 100
    3b94:	91 05       	cpc	r25, r1
    3b96:	28 f4       	brcc	.+10     	; 0x3ba2 <__vector_58+0x8e>
    3b98:	80 93 26 31 	sts	0x3126, r24	; 0x803126 <rcvE0_read_index>
    3b9c:	90 93 27 31 	sts	0x3127, r25	; 0x803127 <rcvE0_read_index+0x1>
    3ba0:	08 c0       	rjmp	.+16     	; 0x3bb2 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3ba2:	10 92 26 31 	sts	0x3126, r1	; 0x803126 <rcvE0_read_index>
    3ba6:	10 92 27 31 	sts	0x3127, r1	; 0x803127 <rcvE0_read_index+0x1>
}
    3baa:	03 c0       	rjmp	.+6      	; 0x3bb2 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3bac:	81 e0       	ldi	r24, 0x01	; 1
    3bae:	90 e0       	ldi	r25, 0x00	; 0
    3bb0:	f3 cf       	rjmp	.-26     	; 0x3b98 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3bb2:	ff 91       	pop	r31
    3bb4:	ef 91       	pop	r30
    3bb6:	9f 91       	pop	r25
    3bb8:	8f 91       	pop	r24
    3bba:	3f 91       	pop	r19
    3bbc:	2f 91       	pop	r18
    3bbe:	0f 90       	pop	r0
    3bc0:	0b be       	out	0x3b, r0	; 59
    3bc2:	0f 90       	pop	r0
    3bc4:	08 be       	out	0x38, r0	; 56
    3bc6:	0f 90       	pop	r0
    3bc8:	0f be       	out	0x3f, r0	; 63
    3bca:	0f 90       	pop	r0
    3bcc:	1f 90       	pop	r1
    3bce:	18 95       	reti

00003bd0 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3bd0:	0f 93       	push	r16
    3bd2:	cf 93       	push	r28
    3bd4:	df 93       	push	r29
    3bd6:	1f 92       	push	r1
    3bd8:	cd b7       	in	r28, 0x3d	; 61
    3bda:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3bdc:	2f b7       	in	r18, 0x3f	; 63
    3bde:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3be0:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3be2:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3be4:	fc 01       	movw	r30, r24
    3be6:	08 ed       	ldi	r16, 0xD8	; 216
    3be8:	04 bf       	out	0x34, r16	; 52
    3bea:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3bec:	89 81       	ldd	r24, Y+1	; 0x01
    3bee:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3bf0:	0f 90       	pop	r0
    3bf2:	df 91       	pop	r29
    3bf4:	cf 91       	pop	r28
    3bf6:	0f 91       	pop	r16
    3bf8:	08 95       	ret

00003bfa <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3bfa:	0f 93       	push	r16
    3bfc:	1f 93       	push	r17
    3bfe:	cf 93       	push	r28
    3c00:	df 93       	push	r29
    3c02:	cd b7       	in	r28, 0x3d	; 61
    3c04:	de b7       	in	r29, 0x3e	; 62
    3c06:	6d 97       	sbiw	r28, 0x1d	; 29
    3c08:	cd bf       	out	0x3d, r28	; 61
    3c0a:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3c0c:	e0 e6       	ldi	r30, 0x60	; 96
    3c0e:	f6 e0       	ldi	r31, 0x06	; 6
    3c10:	80 e4       	ldi	r24, 0x40	; 64
    3c12:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3c14:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3c16:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3c18:	e0 e5       	ldi	r30, 0x50	; 80
    3c1a:	f0 e0       	ldi	r31, 0x00	; 0
    3c1c:	80 81       	ld	r24, Z
    3c1e:	82 60       	ori	r24, 0x02	; 2
    3c20:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3c22:	81 81       	ldd	r24, Z+1	; 0x01
    3c24:	81 ff       	sbrs	r24, 1
    3c26:	fd cf       	rjmp	.-6      	; 0x3c22 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3c28:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3c2c:	68 7f       	andi	r22, 0xF8	; 248
    3c2e:	61 60       	ori	r22, 0x01	; 1
    3c30:	80 e4       	ldi	r24, 0x40	; 64
    3c32:	90 e0       	ldi	r25, 0x00	; 0
    3c34:	0e 94 e8 1d 	call	0x3bd0	; 0x3bd0 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3c38:	e0 e5       	ldi	r30, 0x50	; 80
    3c3a:	f0 e0       	ldi	r31, 0x00	; 0
    3c3c:	80 81       	ld	r24, Z
    3c3e:	8e 7f       	andi	r24, 0xFE	; 254
    3c40:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3c42:	9d ef       	ldi	r25, 0xFD	; 253
    3c44:	88 ed       	ldi	r24, 0xD8	; 216
    3c46:	08 b6       	in	r0, 0x38	; 56
    3c48:	18 be       	out	0x38, r1	; 56
    3c4a:	84 bf       	out	0x34, r24	; 52
    3c4c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3c50:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3c52:	40 eb       	ldi	r20, 0xB0	; 176
    3c54:	58 e0       	ldi	r21, 0x08	; 8
    3c56:	60 e0       	ldi	r22, 0x00	; 0
    3c58:	70 e0       	ldi	r23, 0x00	; 0
    3c5a:	ce 01       	movw	r24, r28
    3c5c:	01 96       	adiw	r24, 0x01	; 1
    3c5e:	0e 94 92 1b 	call	0x3724	; 0x3724 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3c62:	67 e0       	ldi	r22, 0x07	; 7
    3c64:	ce 01       	movw	r24, r28
    3c66:	01 96       	adiw	r24, 0x01	; 1
    3c68:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    3c6c:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c6e:	6b e6       	ldi	r22, 0x6B	; 107
    3c70:	70 e2       	ldi	r23, 0x20	; 32
    3c72:	0e 94 b8 19 	call	0x3370	; 0x3370 <_ZN8emstream4putsEPKc>
    3c76:	66 e0       	ldi	r22, 0x06	; 6
    3c78:	c8 01       	movw	r24, r16
    3c7a:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
    3c7e:	66 e0       	ldi	r22, 0x06	; 6
    3c80:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3c84:	82 e1       	ldi	r24, 0x12	; 18
    3c86:	90 e0       	ldi	r25, 0x00	; 0
    3c88:	0e 94 04 19 	call	0x3208	; 0x3208 <_Znwj>
    3c8c:	8e 01       	movw	r16, r28
    3c8e:	0f 5f       	subi	r16, 0xFF	; 255
    3c90:	1f 4f       	sbci	r17, 0xFF	; 255
    3c92:	24 e0       	ldi	r18, 0x04	; 4
    3c94:	31 e0       	ldi	r19, 0x01	; 1
    3c96:	40 e0       	ldi	r20, 0x00	; 0
    3c98:	6a e8       	ldi	r22, 0x8A	; 138
    3c9a:	70 e2       	ldi	r23, 0x20	; 32
    3c9c:	0e 94 c5 06 	call	0xd8a	; 0xd8a <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3ca0:	82 e1       	ldi	r24, 0x12	; 18
    3ca2:	90 e0       	ldi	r25, 0x00	; 0
    3ca4:	0e 94 04 19 	call	0x3208	; 0x3208 <_Znwj>
    3ca8:	24 e0       	ldi	r18, 0x04	; 4
    3caa:	31 e0       	ldi	r19, 0x01	; 1
    3cac:	42 e0       	ldi	r20, 0x02	; 2
    3cae:	62 e9       	ldi	r22, 0x92	; 146
    3cb0:	70 e2       	ldi	r23, 0x20	; 32
    3cb2:	0e 94 5d 03 	call	0x6ba	; 0x6ba <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3cb6:	82 e1       	ldi	r24, 0x12	; 18
    3cb8:	90 e0       	ldi	r25, 0x00	; 0
    3cba:	0e 94 04 19 	call	0x3208	; 0x3208 <_Znwj>
    3cbe:	24 e0       	ldi	r18, 0x04	; 4
    3cc0:	31 e0       	ldi	r19, 0x01	; 1
    3cc2:	43 e0       	ldi	r20, 0x03	; 3
    3cc4:	69 e9       	ldi	r22, 0x99	; 153
    3cc6:	70 e2       	ldi	r23, 0x20	; 32
    3cc8:	0e 94 b6 03 	call	0x76c	; 0x76c <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3ccc:	82 e1       	ldi	r24, 0x12	; 18
    3cce:	90 e0       	ldi	r25, 0x00	; 0
    3cd0:	0e 94 04 19 	call	0x3208	; 0x3208 <_Znwj>
    3cd4:	24 e0       	ldi	r18, 0x04	; 4
    3cd6:	31 e0       	ldi	r19, 0x01	; 1
    3cd8:	44 e0       	ldi	r20, 0x04	; 4
    3cda:	60 ea       	ldi	r22, 0xA0	; 160
    3cdc:	70 e2       	ldi	r23, 0x20	; 32
    3cde:	0e 94 1b 04 	call	0x836	; 0x836 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3ce2:	8c e6       	ldi	r24, 0x6C	; 108
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	0e 94 04 19 	call	0x3208	; 0x3208 <_Znwj>
    3cea:	24 e0       	ldi	r18, 0x04	; 4
    3cec:	31 e0       	ldi	r19, 0x01	; 1
    3cee:	43 e0       	ldi	r20, 0x03	; 3
    3cf0:	69 ea       	ldi	r22, 0xA9	; 169
    3cf2:	70 e2       	ldi	r23, 0x20	; 32
    3cf4:	0e 94 87 06 	call	0xd0e	; 0xd0e <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3cf8:	87 e0       	ldi	r24, 0x07	; 7
    3cfa:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3cfe:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3d00:	0e 94 16 10 	call	0x202c	; 0x202c <vTaskStartScheduler>
	
	
	return 0;
    3d04:	80 e0       	ldi	r24, 0x00	; 0
    3d06:	90 e0       	ldi	r25, 0x00	; 0
    3d08:	6d 96       	adiw	r28, 0x1d	; 29
    3d0a:	cd bf       	out	0x3d, r28	; 61
    3d0c:	de bf       	out	0x3e, r29	; 62
    3d0e:	df 91       	pop	r29
    3d10:	cf 91       	pop	r28
    3d12:	1f 91       	pop	r17
    3d14:	0f 91       	pop	r16
    3d16:	08 95       	ret

00003d18 <_GLOBAL__sub_I_counter>:
    3d18:	0f 93       	push	r16
    3d1a:	1f 93       	push	r17
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3d1c:	0a e0       	ldi	r16, 0x0A	; 10
    3d1e:	10 e0       	ldi	r17, 0x00	; 0
    3d20:	20 e0       	ldi	r18, 0x00	; 0
    3d22:	30 e0       	ldi	r19, 0x00	; 0
    3d24:	40 e0       	ldi	r20, 0x00	; 0
    3d26:	50 e0       	ldi	r21, 0x00	; 0
    3d28:	60 e2       	ldi	r22, 0x20	; 32
    3d2a:	70 e0       	ldi	r23, 0x00	; 0
    3d2c:	84 e4       	ldi	r24, 0x44	; 68
    3d2e:	91 e3       	ldi	r25, 0x31	; 49
    3d30:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3d34:	1f 91       	pop	r17
    3d36:	0f 91       	pop	r16
    3d38:	08 95       	ret

00003d3a <__cmpsf2>:
    3d3a:	0e 94 df 1e 	call	0x3dbe	; 0x3dbe <__fp_cmp>
    3d3e:	08 f4       	brcc	.+2      	; 0x3d42 <__cmpsf2+0x8>
    3d40:	81 e0       	ldi	r24, 0x01	; 1
    3d42:	08 95       	ret

00003d44 <__floatunsisf>:
    3d44:	e8 94       	clt
    3d46:	09 c0       	rjmp	.+18     	; 0x3d5a <__floatsisf+0x12>

00003d48 <__floatsisf>:
    3d48:	97 fb       	bst	r25, 7
    3d4a:	3e f4       	brtc	.+14     	; 0x3d5a <__floatsisf+0x12>
    3d4c:	90 95       	com	r25
    3d4e:	80 95       	com	r24
    3d50:	70 95       	com	r23
    3d52:	61 95       	neg	r22
    3d54:	7f 4f       	sbci	r23, 0xFF	; 255
    3d56:	8f 4f       	sbci	r24, 0xFF	; 255
    3d58:	9f 4f       	sbci	r25, 0xFF	; 255
    3d5a:	99 23       	and	r25, r25
    3d5c:	a9 f0       	breq	.+42     	; 0x3d88 <__floatsisf+0x40>
    3d5e:	f9 2f       	mov	r31, r25
    3d60:	96 e9       	ldi	r25, 0x96	; 150
    3d62:	bb 27       	eor	r27, r27
    3d64:	93 95       	inc	r25
    3d66:	f6 95       	lsr	r31
    3d68:	87 95       	ror	r24
    3d6a:	77 95       	ror	r23
    3d6c:	67 95       	ror	r22
    3d6e:	b7 95       	ror	r27
    3d70:	f1 11       	cpse	r31, r1
    3d72:	f8 cf       	rjmp	.-16     	; 0x3d64 <__floatsisf+0x1c>
    3d74:	fa f4       	brpl	.+62     	; 0x3db4 <__floatsisf+0x6c>
    3d76:	bb 0f       	add	r27, r27
    3d78:	11 f4       	brne	.+4      	; 0x3d7e <__floatsisf+0x36>
    3d7a:	60 ff       	sbrs	r22, 0
    3d7c:	1b c0       	rjmp	.+54     	; 0x3db4 <__floatsisf+0x6c>
    3d7e:	6f 5f       	subi	r22, 0xFF	; 255
    3d80:	7f 4f       	sbci	r23, 0xFF	; 255
    3d82:	8f 4f       	sbci	r24, 0xFF	; 255
    3d84:	9f 4f       	sbci	r25, 0xFF	; 255
    3d86:	16 c0       	rjmp	.+44     	; 0x3db4 <__floatsisf+0x6c>
    3d88:	88 23       	and	r24, r24
    3d8a:	11 f0       	breq	.+4      	; 0x3d90 <__floatsisf+0x48>
    3d8c:	96 e9       	ldi	r25, 0x96	; 150
    3d8e:	11 c0       	rjmp	.+34     	; 0x3db2 <__floatsisf+0x6a>
    3d90:	77 23       	and	r23, r23
    3d92:	21 f0       	breq	.+8      	; 0x3d9c <__floatsisf+0x54>
    3d94:	9e e8       	ldi	r25, 0x8E	; 142
    3d96:	87 2f       	mov	r24, r23
    3d98:	76 2f       	mov	r23, r22
    3d9a:	05 c0       	rjmp	.+10     	; 0x3da6 <__floatsisf+0x5e>
    3d9c:	66 23       	and	r22, r22
    3d9e:	71 f0       	breq	.+28     	; 0x3dbc <__floatsisf+0x74>
    3da0:	96 e8       	ldi	r25, 0x86	; 134
    3da2:	86 2f       	mov	r24, r22
    3da4:	70 e0       	ldi	r23, 0x00	; 0
    3da6:	60 e0       	ldi	r22, 0x00	; 0
    3da8:	2a f0       	brmi	.+10     	; 0x3db4 <__floatsisf+0x6c>
    3daa:	9a 95       	dec	r25
    3dac:	66 0f       	add	r22, r22
    3dae:	77 1f       	adc	r23, r23
    3db0:	88 1f       	adc	r24, r24
    3db2:	da f7       	brpl	.-10     	; 0x3daa <__floatsisf+0x62>
    3db4:	88 0f       	add	r24, r24
    3db6:	96 95       	lsr	r25
    3db8:	87 95       	ror	r24
    3dba:	97 f9       	bld	r25, 7
    3dbc:	08 95       	ret

00003dbe <__fp_cmp>:
    3dbe:	99 0f       	add	r25, r25
    3dc0:	00 08       	sbc	r0, r0
    3dc2:	55 0f       	add	r21, r21
    3dc4:	aa 0b       	sbc	r26, r26
    3dc6:	e0 e8       	ldi	r30, 0x80	; 128
    3dc8:	fe ef       	ldi	r31, 0xFE	; 254
    3dca:	16 16       	cp	r1, r22
    3dcc:	17 06       	cpc	r1, r23
    3dce:	e8 07       	cpc	r30, r24
    3dd0:	f9 07       	cpc	r31, r25
    3dd2:	c0 f0       	brcs	.+48     	; 0x3e04 <__fp_cmp+0x46>
    3dd4:	12 16       	cp	r1, r18
    3dd6:	13 06       	cpc	r1, r19
    3dd8:	e4 07       	cpc	r30, r20
    3dda:	f5 07       	cpc	r31, r21
    3ddc:	98 f0       	brcs	.+38     	; 0x3e04 <__fp_cmp+0x46>
    3dde:	62 1b       	sub	r22, r18
    3de0:	73 0b       	sbc	r23, r19
    3de2:	84 0b       	sbc	r24, r20
    3de4:	95 0b       	sbc	r25, r21
    3de6:	39 f4       	brne	.+14     	; 0x3df6 <__fp_cmp+0x38>
    3de8:	0a 26       	eor	r0, r26
    3dea:	61 f0       	breq	.+24     	; 0x3e04 <__fp_cmp+0x46>
    3dec:	23 2b       	or	r18, r19
    3dee:	24 2b       	or	r18, r20
    3df0:	25 2b       	or	r18, r21
    3df2:	21 f4       	brne	.+8      	; 0x3dfc <__fp_cmp+0x3e>
    3df4:	08 95       	ret
    3df6:	0a 26       	eor	r0, r26
    3df8:	09 f4       	brne	.+2      	; 0x3dfc <__fp_cmp+0x3e>
    3dfa:	a1 40       	sbci	r26, 0x01	; 1
    3dfc:	a6 95       	lsr	r26
    3dfe:	8f ef       	ldi	r24, 0xFF	; 255
    3e00:	81 1d       	adc	r24, r1
    3e02:	81 1d       	adc	r24, r1
    3e04:	08 95       	ret

00003e06 <__gesf2>:
    3e06:	0e 94 df 1e 	call	0x3dbe	; 0x3dbe <__fp_cmp>
    3e0a:	08 f4       	brcc	.+2      	; 0x3e0e <__gesf2+0x8>
    3e0c:	8f ef       	ldi	r24, 0xFF	; 255
    3e0e:	08 95       	ret

00003e10 <__mulsi3>:
    3e10:	db 01       	movw	r26, r22
    3e12:	8f 93       	push	r24
    3e14:	9f 93       	push	r25
    3e16:	0e 94 94 1f 	call	0x3f28	; 0x3f28 <__muluhisi3>
    3e1a:	bf 91       	pop	r27
    3e1c:	af 91       	pop	r26
    3e1e:	a2 9f       	mul	r26, r18
    3e20:	80 0d       	add	r24, r0
    3e22:	91 1d       	adc	r25, r1
    3e24:	a3 9f       	mul	r26, r19
    3e26:	90 0d       	add	r25, r0
    3e28:	b2 9f       	mul	r27, r18
    3e2a:	90 0d       	add	r25, r0
    3e2c:	11 24       	eor	r1, r1
    3e2e:	08 95       	ret

00003e30 <__divmodhi4>:
    3e30:	97 fb       	bst	r25, 7
    3e32:	07 2e       	mov	r0, r23
    3e34:	16 f4       	brtc	.+4      	; 0x3e3a <__divmodhi4+0xa>
    3e36:	00 94       	com	r0
    3e38:	07 d0       	rcall	.+14     	; 0x3e48 <__divmodhi4_neg1>
    3e3a:	77 fd       	sbrc	r23, 7
    3e3c:	09 d0       	rcall	.+18     	; 0x3e50 <__divmodhi4_neg2>
    3e3e:	0e 94 a7 1f 	call	0x3f4e	; 0x3f4e <__udivmodhi4>
    3e42:	07 fc       	sbrc	r0, 7
    3e44:	05 d0       	rcall	.+10     	; 0x3e50 <__divmodhi4_neg2>
    3e46:	3e f4       	brtc	.+14     	; 0x3e56 <__divmodhi4_exit>

00003e48 <__divmodhi4_neg1>:
    3e48:	90 95       	com	r25
    3e4a:	81 95       	neg	r24
    3e4c:	9f 4f       	sbci	r25, 0xFF	; 255
    3e4e:	08 95       	ret

00003e50 <__divmodhi4_neg2>:
    3e50:	70 95       	com	r23
    3e52:	61 95       	neg	r22
    3e54:	7f 4f       	sbci	r23, 0xFF	; 255

00003e56 <__divmodhi4_exit>:
    3e56:	08 95       	ret

00003e58 <__udivmodsi4>:
    3e58:	a1 e2       	ldi	r26, 0x21	; 33
    3e5a:	1a 2e       	mov	r1, r26
    3e5c:	aa 1b       	sub	r26, r26
    3e5e:	bb 1b       	sub	r27, r27
    3e60:	fd 01       	movw	r30, r26
    3e62:	0d c0       	rjmp	.+26     	; 0x3e7e <__udivmodsi4_ep>

00003e64 <__udivmodsi4_loop>:
    3e64:	aa 1f       	adc	r26, r26
    3e66:	bb 1f       	adc	r27, r27
    3e68:	ee 1f       	adc	r30, r30
    3e6a:	ff 1f       	adc	r31, r31
    3e6c:	a2 17       	cp	r26, r18
    3e6e:	b3 07       	cpc	r27, r19
    3e70:	e4 07       	cpc	r30, r20
    3e72:	f5 07       	cpc	r31, r21
    3e74:	20 f0       	brcs	.+8      	; 0x3e7e <__udivmodsi4_ep>
    3e76:	a2 1b       	sub	r26, r18
    3e78:	b3 0b       	sbc	r27, r19
    3e7a:	e4 0b       	sbc	r30, r20
    3e7c:	f5 0b       	sbc	r31, r21

00003e7e <__udivmodsi4_ep>:
    3e7e:	66 1f       	adc	r22, r22
    3e80:	77 1f       	adc	r23, r23
    3e82:	88 1f       	adc	r24, r24
    3e84:	99 1f       	adc	r25, r25
    3e86:	1a 94       	dec	r1
    3e88:	69 f7       	brne	.-38     	; 0x3e64 <__udivmodsi4_loop>
    3e8a:	60 95       	com	r22
    3e8c:	70 95       	com	r23
    3e8e:	80 95       	com	r24
    3e90:	90 95       	com	r25
    3e92:	9b 01       	movw	r18, r22
    3e94:	ac 01       	movw	r20, r24
    3e96:	bd 01       	movw	r22, r26
    3e98:	cf 01       	movw	r24, r30
    3e9a:	08 95       	ret

00003e9c <__divmodsi4>:
    3e9c:	05 2e       	mov	r0, r21
    3e9e:	97 fb       	bst	r25, 7
    3ea0:	1e f4       	brtc	.+6      	; 0x3ea8 <__divmodsi4+0xc>
    3ea2:	00 94       	com	r0
    3ea4:	0e 94 65 1f 	call	0x3eca	; 0x3eca <__negsi2>
    3ea8:	57 fd       	sbrc	r21, 7
    3eaa:	07 d0       	rcall	.+14     	; 0x3eba <__divmodsi4_neg2>
    3eac:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <__udivmodsi4>
    3eb0:	07 fc       	sbrc	r0, 7
    3eb2:	03 d0       	rcall	.+6      	; 0x3eba <__divmodsi4_neg2>
    3eb4:	4e f4       	brtc	.+18     	; 0x3ec8 <__divmodsi4_exit>
    3eb6:	0c 94 65 1f 	jmp	0x3eca	; 0x3eca <__negsi2>

00003eba <__divmodsi4_neg2>:
    3eba:	50 95       	com	r21
    3ebc:	40 95       	com	r20
    3ebe:	30 95       	com	r19
    3ec0:	21 95       	neg	r18
    3ec2:	3f 4f       	sbci	r19, 0xFF	; 255
    3ec4:	4f 4f       	sbci	r20, 0xFF	; 255
    3ec6:	5f 4f       	sbci	r21, 0xFF	; 255

00003ec8 <__divmodsi4_exit>:
    3ec8:	08 95       	ret

00003eca <__negsi2>:
    3eca:	90 95       	com	r25
    3ecc:	80 95       	com	r24
    3ece:	70 95       	com	r23
    3ed0:	61 95       	neg	r22
    3ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    3ed4:	8f 4f       	sbci	r24, 0xFF	; 255
    3ed6:	9f 4f       	sbci	r25, 0xFF	; 255
    3ed8:	08 95       	ret

00003eda <__tablejump2__>:
    3eda:	ee 0f       	add	r30, r30
    3edc:	ff 1f       	adc	r31, r31
    3ede:	88 1f       	adc	r24, r24
    3ee0:	8b bf       	out	0x3b, r24	; 59
    3ee2:	07 90       	elpm	r0, Z+
    3ee4:	f6 91       	elpm	r31, Z
    3ee6:	e0 2d       	mov	r30, r0
    3ee8:	1b be       	out	0x3b, r1	; 59
    3eea:	19 94       	eijmp

00003eec <__mulhisi3>:
    3eec:	0e 94 7e 1f 	call	0x3efc	; 0x3efc <__umulhisi3>
    3ef0:	33 23       	and	r19, r19
    3ef2:	12 f4       	brpl	.+4      	; 0x3ef8 <__mulhisi3+0xc>
    3ef4:	8a 1b       	sub	r24, r26
    3ef6:	9b 0b       	sbc	r25, r27
    3ef8:	0c 94 8f 1f 	jmp	0x3f1e	; 0x3f1e <__usmulhisi3_tail>

00003efc <__umulhisi3>:
    3efc:	a2 9f       	mul	r26, r18
    3efe:	b0 01       	movw	r22, r0
    3f00:	b3 9f       	mul	r27, r19
    3f02:	c0 01       	movw	r24, r0
    3f04:	a3 9f       	mul	r26, r19
    3f06:	70 0d       	add	r23, r0
    3f08:	81 1d       	adc	r24, r1
    3f0a:	11 24       	eor	r1, r1
    3f0c:	91 1d       	adc	r25, r1
    3f0e:	b2 9f       	mul	r27, r18
    3f10:	70 0d       	add	r23, r0
    3f12:	81 1d       	adc	r24, r1
    3f14:	11 24       	eor	r1, r1
    3f16:	91 1d       	adc	r25, r1
    3f18:	08 95       	ret

00003f1a <__usmulhisi3>:
    3f1a:	0e 94 7e 1f 	call	0x3efc	; 0x3efc <__umulhisi3>

00003f1e <__usmulhisi3_tail>:
    3f1e:	b7 ff       	sbrs	r27, 7
    3f20:	08 95       	ret
    3f22:	82 1b       	sub	r24, r18
    3f24:	93 0b       	sbc	r25, r19
    3f26:	08 95       	ret

00003f28 <__muluhisi3>:
    3f28:	0e 94 7e 1f 	call	0x3efc	; 0x3efc <__umulhisi3>
    3f2c:	a5 9f       	mul	r26, r21
    3f2e:	90 0d       	add	r25, r0
    3f30:	b4 9f       	mul	r27, r20
    3f32:	90 0d       	add	r25, r0
    3f34:	a4 9f       	mul	r26, r20
    3f36:	80 0d       	add	r24, r0
    3f38:	91 1d       	adc	r25, r1
    3f3a:	11 24       	eor	r1, r1
    3f3c:	08 95       	ret

00003f3e <__mulshisi3>:
    3f3e:	b7 ff       	sbrs	r27, 7
    3f40:	0c 94 94 1f 	jmp	0x3f28	; 0x3f28 <__muluhisi3>

00003f44 <__mulohisi3>:
    3f44:	0e 94 94 1f 	call	0x3f28	; 0x3f28 <__muluhisi3>
    3f48:	82 1b       	sub	r24, r18
    3f4a:	93 0b       	sbc	r25, r19
    3f4c:	08 95       	ret

00003f4e <__udivmodhi4>:
    3f4e:	aa 1b       	sub	r26, r26
    3f50:	bb 1b       	sub	r27, r27
    3f52:	51 e1       	ldi	r21, 0x11	; 17
    3f54:	07 c0       	rjmp	.+14     	; 0x3f64 <__udivmodhi4_ep>

00003f56 <__udivmodhi4_loop>:
    3f56:	aa 1f       	adc	r26, r26
    3f58:	bb 1f       	adc	r27, r27
    3f5a:	a6 17       	cp	r26, r22
    3f5c:	b7 07       	cpc	r27, r23
    3f5e:	10 f0       	brcs	.+4      	; 0x3f64 <__udivmodhi4_ep>
    3f60:	a6 1b       	sub	r26, r22
    3f62:	b7 0b       	sbc	r27, r23

00003f64 <__udivmodhi4_ep>:
    3f64:	88 1f       	adc	r24, r24
    3f66:	99 1f       	adc	r25, r25
    3f68:	5a 95       	dec	r21
    3f6a:	a9 f7       	brne	.-22     	; 0x3f56 <__udivmodhi4_loop>
    3f6c:	80 95       	com	r24
    3f6e:	90 95       	com	r25
    3f70:	bc 01       	movw	r22, r24
    3f72:	cd 01       	movw	r24, r26
    3f74:	08 95       	ret

00003f76 <memcpy>:
    3f76:	fb 01       	movw	r30, r22
    3f78:	dc 01       	movw	r26, r24
    3f7a:	02 c0       	rjmp	.+4      	; 0x3f80 <memcpy+0xa>
    3f7c:	01 90       	ld	r0, Z+
    3f7e:	0d 92       	st	X+, r0
    3f80:	41 50       	subi	r20, 0x01	; 1
    3f82:	50 40       	sbci	r21, 0x00	; 0
    3f84:	d8 f7       	brcc	.-10     	; 0x3f7c <memcpy+0x6>
    3f86:	08 95       	ret

00003f88 <memset>:
    3f88:	dc 01       	movw	r26, r24
    3f8a:	01 c0       	rjmp	.+2      	; 0x3f8e <memset+0x6>
    3f8c:	6d 93       	st	X+, r22
    3f8e:	41 50       	subi	r20, 0x01	; 1
    3f90:	50 40       	sbci	r21, 0x00	; 0
    3f92:	e0 f7       	brcc	.-8      	; 0x3f8c <memset+0x4>
    3f94:	08 95       	ret

00003f96 <strncpy>:
    3f96:	fb 01       	movw	r30, r22
    3f98:	dc 01       	movw	r26, r24
    3f9a:	41 50       	subi	r20, 0x01	; 1
    3f9c:	50 40       	sbci	r21, 0x00	; 0
    3f9e:	48 f0       	brcs	.+18     	; 0x3fb2 <strncpy+0x1c>
    3fa0:	01 90       	ld	r0, Z+
    3fa2:	0d 92       	st	X+, r0
    3fa4:	00 20       	and	r0, r0
    3fa6:	c9 f7       	brne	.-14     	; 0x3f9a <strncpy+0x4>
    3fa8:	01 c0       	rjmp	.+2      	; 0x3fac <strncpy+0x16>
    3faa:	1d 92       	st	X+, r1
    3fac:	41 50       	subi	r20, 0x01	; 1
    3fae:	50 40       	sbci	r21, 0x00	; 0
    3fb0:	e0 f7       	brcc	.-8      	; 0x3faa <strncpy+0x14>
    3fb2:	08 95       	ret

00003fb4 <ultoa>:
    3fb4:	25 32       	cpi	r18, 0x25	; 37
    3fb6:	31 05       	cpc	r19, r1
    3fb8:	20 f4       	brcc	.+8      	; 0x3fc2 <ultoa+0xe>
    3fba:	22 30       	cpi	r18, 0x02	; 2
    3fbc:	10 f0       	brcs	.+4      	; 0x3fc2 <ultoa+0xe>
    3fbe:	0c 94 e5 1f 	jmp	0x3fca	; 0x3fca <__ultoa_ncheck>
    3fc2:	fa 01       	movw	r30, r20
    3fc4:	10 82       	st	Z, r1
    3fc6:	ca 01       	movw	r24, r20
    3fc8:	08 95       	ret

00003fca <__ultoa_ncheck>:
    3fca:	bb 27       	eor	r27, r27

00003fcc <__ultoa_common>:
    3fcc:	fa 01       	movw	r30, r20
    3fce:	a6 2f       	mov	r26, r22
    3fd0:	62 17       	cp	r22, r18
    3fd2:	71 05       	cpc	r23, r1
    3fd4:	81 05       	cpc	r24, r1
    3fd6:	91 05       	cpc	r25, r1
    3fd8:	33 0b       	sbc	r19, r19
    3fda:	30 fb       	bst	r19, 0
    3fdc:	66 f0       	brts	.+24     	; 0x3ff6 <__ultoa_common+0x2a>
    3fde:	aa 27       	eor	r26, r26
    3fe0:	66 0f       	add	r22, r22
    3fe2:	77 1f       	adc	r23, r23
    3fe4:	88 1f       	adc	r24, r24
    3fe6:	99 1f       	adc	r25, r25
    3fe8:	aa 1f       	adc	r26, r26
    3fea:	a2 17       	cp	r26, r18
    3fec:	10 f0       	brcs	.+4      	; 0x3ff2 <__ultoa_common+0x26>
    3fee:	a2 1b       	sub	r26, r18
    3ff0:	63 95       	inc	r22
    3ff2:	38 50       	subi	r19, 0x08	; 8
    3ff4:	a9 f7       	brne	.-22     	; 0x3fe0 <__ultoa_common+0x14>
    3ff6:	a0 5d       	subi	r26, 0xD0	; 208
    3ff8:	aa 33       	cpi	r26, 0x3A	; 58
    3ffa:	08 f0       	brcs	.+2      	; 0x3ffe <__ultoa_common+0x32>
    3ffc:	a9 5d       	subi	r26, 0xD9	; 217
    3ffe:	a1 93       	st	Z+, r26
    4000:	36 f7       	brtc	.-52     	; 0x3fce <__ultoa_common+0x2>
    4002:	b1 11       	cpse	r27, r1
    4004:	b1 93       	st	Z+, r27
    4006:	10 82       	st	Z, r1
    4008:	ca 01       	movw	r24, r20
    400a:	0c 94 2c 20 	jmp	0x4058	; 0x4058 <strrev>

0000400e <utoa>:
    400e:	45 32       	cpi	r20, 0x25	; 37
    4010:	51 05       	cpc	r21, r1
    4012:	20 f4       	brcc	.+8      	; 0x401c <utoa+0xe>
    4014:	42 30       	cpi	r20, 0x02	; 2
    4016:	10 f0       	brcs	.+4      	; 0x401c <utoa+0xe>
    4018:	0c 94 12 20 	jmp	0x4024	; 0x4024 <__utoa_ncheck>
    401c:	fb 01       	movw	r30, r22
    401e:	10 82       	st	Z, r1
    4020:	cb 01       	movw	r24, r22
    4022:	08 95       	ret

00004024 <__utoa_ncheck>:
    4024:	bb 27       	eor	r27, r27

00004026 <__utoa_common>:
    4026:	fb 01       	movw	r30, r22
    4028:	55 27       	eor	r21, r21
    402a:	aa 27       	eor	r26, r26
    402c:	88 0f       	add	r24, r24
    402e:	99 1f       	adc	r25, r25
    4030:	aa 1f       	adc	r26, r26
    4032:	a4 17       	cp	r26, r20
    4034:	10 f0       	brcs	.+4      	; 0x403a <__utoa_common+0x14>
    4036:	a4 1b       	sub	r26, r20
    4038:	83 95       	inc	r24
    403a:	50 51       	subi	r21, 0x10	; 16
    403c:	b9 f7       	brne	.-18     	; 0x402c <__utoa_common+0x6>
    403e:	a0 5d       	subi	r26, 0xD0	; 208
    4040:	aa 33       	cpi	r26, 0x3A	; 58
    4042:	08 f0       	brcs	.+2      	; 0x4046 <__utoa_common+0x20>
    4044:	a9 5d       	subi	r26, 0xD9	; 217
    4046:	a1 93       	st	Z+, r26
    4048:	00 97       	sbiw	r24, 0x00	; 0
    404a:	79 f7       	brne	.-34     	; 0x402a <__utoa_common+0x4>
    404c:	b1 11       	cpse	r27, r1
    404e:	b1 93       	st	Z+, r27
    4050:	11 92       	st	Z+, r1
    4052:	cb 01       	movw	r24, r22
    4054:	0c 94 2c 20 	jmp	0x4058	; 0x4058 <strrev>

00004058 <strrev>:
    4058:	dc 01       	movw	r26, r24
    405a:	fc 01       	movw	r30, r24
    405c:	67 2f       	mov	r22, r23
    405e:	71 91       	ld	r23, Z+
    4060:	77 23       	and	r23, r23
    4062:	e1 f7       	brne	.-8      	; 0x405c <strrev+0x4>
    4064:	32 97       	sbiw	r30, 0x02	; 2
    4066:	04 c0       	rjmp	.+8      	; 0x4070 <strrev+0x18>
    4068:	7c 91       	ld	r23, X
    406a:	6d 93       	st	X+, r22
    406c:	70 83       	st	Z, r23
    406e:	62 91       	ld	r22, -Z
    4070:	ae 17       	cp	r26, r30
    4072:	bf 07       	cpc	r27, r31
    4074:	c8 f3       	brcs	.-14     	; 0x4068 <strrev+0x10>
    4076:	08 95       	ret

00004078 <_exit>:
    4078:	f8 94       	cli

0000407a <__stop_program>:
    407a:	ff cf       	rjmp	.-2      	; 0x407a <__stop_program>
