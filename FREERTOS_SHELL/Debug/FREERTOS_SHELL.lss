
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000044e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  000044e6  0000457a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020bc  008020bc  00004636  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004636  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004668  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006d0  00000000  00000000  000046a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011c99  00000000  00000000  00004d78  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006550  00000000  00000000  00016a11  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005246  00000000  00000000  0001cf61  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000013b0  00000000  00000000  000221a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006040  00000000  00000000  00023558  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000062ad  00000000  00000000  00029598  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000588  00000000  00000000  0002f845  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a9 02 	jmp	0x552	; 0x552 <__ctors_end>
       4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      10:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      14:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      18:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      1c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      20:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      24:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      28:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      2c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      30:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      34:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      38:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      3c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      40:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      44:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      48:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      4c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      50:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      54:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      58:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      5c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      60:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      64:	0c 94 a1 1c 	jmp	0x3942	; 0x3942 <__vector_25>
      68:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      6c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      70:	0c 94 ff 1c 	jmp	0x39fe	; 0x39fe <__vector_28>
      74:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      78:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      7c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      80:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      84:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      88:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      8c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      90:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      94:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      98:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      9c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c4:	0c 94 b6 0c 	jmp	0x196c	; 0x196c <__vector_49>
      c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e8:	0c 94 19 1e 	jmp	0x3c32	; 0x3c32 <__vector_58>
      ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      fc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     100:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     104:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     108:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     10c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     110:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     114:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     118:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     11c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     120:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     124:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     128:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     12c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     130:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     134:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     138:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     13c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     140:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     144:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     148:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     14c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     150:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     154:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     158:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     15c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     160:	0c 94 5d 1d 	jmp	0x3aba	; 0x3aba <__vector_88>
     164:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     168:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     16c:	0c 94 bb 1d 	jmp	0x3b76	; 0x3b76 <__vector_91>
     170:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     174:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     178:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     17c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     180:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     184:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     188:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     18c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     190:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     194:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     198:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     19c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1fc:	8d 1a       	sub	r8, r29
     1fe:	90 1a       	sub	r9, r16
     200:	93 1a       	sub	r9, r19
     202:	96 1a       	sub	r9, r22
     204:	99 1a       	sub	r9, r25
     206:	9c 1a       	sub	r9, r28
     208:	9e 1a       	sub	r9, r30
     20a:	af 1a       	sub	r10, r31
     20c:	b7 1a       	sub	r11, r23
     20e:	c1 1a       	sub	r12, r17
     210:	bf 1a       	sub	r11, r31

00000212 <__trampolines_start>:
     212:	0c 94 c1 1a 	jmp	0x3582	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
     216:	0c 94 92 08 	jmp	0x1124	; 0x1124 <_ZN9task_user3runEv>
     21a:	0c 94 38 1a 	jmp	0x3470	; 0x3470 <_ZN8emstream12clear_screenEv>
     21e:	0c 94 35 1a 	jmp	0x346a	; 0x346a <_ZN8emstream14check_for_charEv>
     222:	0c 94 26 1f 	jmp	0x3e4c	; 0x3e4c <_GLOBAL__sub_I_counter>
     226:	0c 94 af 1a 	jmp	0x355e	; 0x355e <_ZN8emstreamlsE15ser_manipulator+0x62>
     22a:	0c 94 9e 1a 	jmp	0x353c	; 0x353c <_ZN8emstreamlsE15ser_manipulator+0x40>
     22e:	0c 94 30 1a 	jmp	0x3460	; 0x3460 <_ZN8emstream13ready_to_sendEv>
     232:	0c 94 a6 02 	jmp	0x54c	; 0x54c <_call_static_run_method>
     236:	0c 94 90 1a 	jmp	0x3520	; 0x3520 <_ZN8emstreamlsE15ser_manipulator+0x24>
     23a:	0c 94 67 04 	jmp	0x8ce	; 0x8ce <_ZN5Motor3runEv>
     23e:	0c 94 99 1a 	jmp	0x3532	; 0x3532 <_ZN8emstreamlsE15ser_manipulator+0x36>
     242:	0c 94 02 04 	jmp	0x804	; 0x804 <_ZN13LimitSwitches3runEv>
     246:	0c 94 99 19 	jmp	0x3332	; 0x3332 <__cxa_pure_virtual>
     24a:	0c 94 9c 1a 	jmp	0x3538	; 0x3538 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     24e:	0c 94 d1 17 	jmp	0x2fa2	; 0x2fa2 <_ZN14frt_text_queue14check_for_charEv>
     252:	0c 94 8d 1a 	jmp	0x351a	; 0x351a <_ZN8emstreamlsE15ser_manipulator+0x1e>
     256:	0c 94 69 16 	jmp	0x2cd2	; 0x2cd2 <_ZN8frt_task12print_statusER8emstream>
     25a:	0c 94 18 1c 	jmp	0x3830	; 0x3830 <_ZN5rs23212clear_screenEv>
     25e:	0c 94 92 03 	jmp	0x724	; 0x724 <_ZN15EncoderPendulum3runEv>
     262:	0c 94 bf 1a 	jmp	0x357e	; 0x357e <_ZN8emstreamlsE15ser_manipulator+0x82>
     266:	0c 94 b7 1a 	jmp	0x356e	; 0x356e <_ZN8emstreamlsE15ser_manipulator+0x72>
     26a:	0c 94 bb 1b 	jmp	0x3776	; 0x3776 <_ZN5rs2327putcharEc>
     26e:	0c 94 dc 17 	jmp	0x2fb8	; 0x2fb8 <_ZN14frt_text_queue7putcharEc>
     272:	0c 94 3a 0f 	jmp	0x1e74	; 0x1e74 <prvIdleTask>
     276:	0c 94 b3 17 	jmp	0x2f66	; 0x2f66 <_ZN14frt_text_queue7getcharEv>
     27a:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_ZN12EncoderMotor3runEv>
     27e:	0c 94 37 1a 	jmp	0x346e	; 0x346e <_ZN8emstream12transmit_nowEv>
     282:	0c 94 df 1b 	jmp	0x37be	; 0x37be <_ZN5rs2327getcharEv>
     286:	0c 94 32 1a 	jmp	0x3464	; 0x3464 <_ZN8emstream7getcharEv>
     28a:	0c 94 93 1a 	jmp	0x3526	; 0x3526 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     28e:	0c 94 96 1a 	jmp	0x352c	; 0x352c <_ZN8emstreamlsE15ser_manipulator+0x30>
     292:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <_ZN9PWMdriver3runEv>
     296:	0c 94 05 1c 	jmp	0x380a	; 0x380a <_ZN5rs23214check_for_charEv>

0000029a <__trampolines_end>:
     29a:	2c 20       	and	r2, r12
     29c:	54 43       	sbci	r21, 0x34	; 52
     29e:	43 30       	cpi	r20, 0x03	; 3
     2a0:	43 43       	sbci	r20, 0x33	; 51
     2a2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a5 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a5:	2f 00                                               /.

000002a7 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b5:	54 69 6d 65 3a 20 00                                Time: .

000002bc <_ZZN9task_user11show_statusEvE3__c_0>:
     2bc:	44 65 63 20 20 33 20 32 30 31 37 00                 Dec  3 2017.

000002c8 <_ZZN9task_user11show_statusEvE3__c>:
     2c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     306:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000311 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     311:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     321:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34f:	6d 61 74 69 6f 6e 00                                mation.

00000356 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     356:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     366:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000377 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     377:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     387:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003ab <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3ab:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bb:	68 65 20 41 56 52 00                                he AVR.

000003c2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c2:	20 68 65 6c 70 00                                    help.

000003c8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e7 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e7:	1b 5b 33 30 6d 00                                   .[30m.

000003ed <_ZZN9task_user18print_help_messageEvE3__c>:
     3ed:	1b 5b 34 36 6d 00                                   .[46m.

000003f3 <_ZZN9task_user3runEvE3__c_3>:
     3f3:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     403:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000410 <_ZZN9task_user3runEvE3__c_2>:
     410:	3a 57 54 46 3f 00                                   :WTF?.

00000416 <_ZZN9task_user3runEvE3__c_1>:
     416:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     426:	65 00                                               e.

00000428 <_ZZN9task_user3runEvE3__c_0>:
     428:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000436 <_ZZN9task_user3runEvE3__c>:
     436:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     446:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000454 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     454:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045e <_ZZN8frt_task15emergency_resetEvE3__c>:
     45e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000046d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     46d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     47d:	61 73 6b 20 00                                      ask .

00000482 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     482:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000490 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     490:	20 63 72 65 61 74 65 64 00                           created.

00000499 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     499:	54 61 73 6b 20 00                                   Task .

0000049f <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49f:	1b 5b 32 32 6d 00                                   .[22m.

000004a5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a5:	54 61 73 6b 3a 20 00                                Task: .

000004ac <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4ac:	1b 5b 31 6d 00                                      .[1m.

000004b1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b1:	1b 5b 32 32 6d 00                                   .[22m.

000004b7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c2:	1b 5b 31 6d 00                                      .[1m.

000004c7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c7:	09 09 00                                            ...

000004ca <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ca:	2f 00                                               /.

000004cc <_ZZ15print_task_listP8emstreamE3__c_7>:
     4cc:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d7:	09 2d 2d 2d 2d 00                                   .----.

000004dd <_ZZ15print_task_listP8emstreamE3__c_5>:
     4dd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e9 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e9:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fa <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fa:	09 52 75 6e 73 00                                   .Runs.

00000500 <_ZZ15print_task_listP8emstreamE3__c_2>:
     500:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000050c <_ZZ15print_task_listP8emstreamE3__c_1>:
     50c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000051d <_ZZ15print_task_listP8emstreamE3__c_0>:
     51d:	09 53 74 61 63 6b 00                                .Stack.

00000524 <_ZZ15print_task_listP8emstreamE3__c>:
     524:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52f:	09 00                                               ..

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     533:	2f 00                                               /.

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     537:	09 00                                               ..

00000539 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53f:	1b 5b 31 6d 00                                      .[1m.

00000544 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     544:	1b 5b 31 6d 00                                      .[1m.

00000549 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     549:	20 20 00                                              .

0000054c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     54c:	0e 94 01 15 	call	0x2a02	; 0x2a02 <_ZN8frt_task22_call_users_run_methodEPS_>

00000550 <__ctors_start>:
     550:	26 1f       	adc	r18, r22

00000552 <__ctors_end>:
     552:	11 24       	eor	r1, r1
     554:	1f be       	out	0x3f, r1	; 63
     556:	cf ef       	ldi	r28, 0xFF	; 255
     558:	cd bf       	out	0x3d, r28	; 61
     55a:	df e3       	ldi	r29, 0x3F	; 63
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	00 e0       	ldi	r16, 0x00	; 0
     560:	0c bf       	out	0x3c, r16	; 60
     562:	18 be       	out	0x38, r1	; 56
     564:	19 be       	out	0x39, r1	; 57
     566:	1a be       	out	0x3a, r1	; 58
     568:	1b be       	out	0x3b, r1	; 59

0000056a <__do_copy_data>:
     56a:	10 e2       	ldi	r17, 0x20	; 32
     56c:	a0 e0       	ldi	r26, 0x00	; 0
     56e:	b0 e2       	ldi	r27, 0x20	; 32
     570:	e6 ee       	ldi	r30, 0xE6	; 230
     572:	f4 e4       	ldi	r31, 0x44	; 68
     574:	00 e0       	ldi	r16, 0x00	; 0
     576:	0b bf       	out	0x3b, r16	; 59
     578:	02 c0       	rjmp	.+4      	; 0x57e <__do_copy_data+0x14>
     57a:	07 90       	elpm	r0, Z+
     57c:	0d 92       	st	X+, r0
     57e:	ac 3b       	cpi	r26, 0xBC	; 188
     580:	b1 07       	cpc	r27, r17
     582:	d9 f7       	brne	.-10     	; 0x57a <__do_copy_data+0x10>
     584:	1b be       	out	0x3b, r1	; 59

00000586 <__do_clear_bss>:
     586:	21 e3       	ldi	r18, 0x31	; 49
     588:	ac eb       	ldi	r26, 0xBC	; 188
     58a:	b0 e2       	ldi	r27, 0x20	; 32
     58c:	01 c0       	rjmp	.+2      	; 0x590 <.do_clear_bss_start>

0000058e <.do_clear_bss_loop>:
     58e:	1d 92       	st	X+, r1

00000590 <.do_clear_bss_start>:
     590:	a2 36       	cpi	r26, 0x62	; 98
     592:	b2 07       	cpc	r27, r18
     594:	e1 f7       	brne	.-8      	; 0x58e <.do_clear_bss_loop>

00000596 <__do_global_ctors>:
     596:	12 e0       	ldi	r17, 0x02	; 2
     598:	c9 ea       	ldi	r28, 0xA9	; 169
     59a:	d2 e0       	ldi	r29, 0x02	; 2
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	06 c0       	rjmp	.+12     	; 0x5ac <__do_global_ctors+0x16>
     5a0:	21 97       	sbiw	r28, 0x01	; 1
     5a2:	01 09       	sbc	r16, r1
     5a4:	80 2f       	mov	r24, r16
     5a6:	fe 01       	movw	r30, r28
     5a8:	0e 94 c6 21 	call	0x438c	; 0x438c <__tablejump2__>
     5ac:	c8 3a       	cpi	r28, 0xA8	; 168
     5ae:	d1 07       	cpc	r29, r17
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	08 07       	cpc	r16, r24
     5b4:	a9 f7       	brne	.-22     	; 0x5a0 <__do_global_ctors+0xa>
     5b6:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <main>
     5ba:	0c 94 71 22 	jmp	0x44e2	; 0x44e2 <_exit>

000005be <__bad_interrupt>:
     5be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c2 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	00 d0       	rcall	.+0      	; 0x5c8 <_ZN12EncoderMotor3runEv+0x6>
     5c8:	1f 92       	push	r1
     5ca:	cd b7       	in	r28, 0x3d	; 61
     5cc:	de b7       	in	r29, 0x3e	; 62
     5ce:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d0:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <xTaskGetTickCount>
     5d4:	69 83       	std	Y+1, r22	; 0x01
     5d6:	7a 83       	std	Y+2, r23	; 0x02
     5d8:	8b 83       	std	Y+3, r24	; 0x03
     5da:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5dc:	e0 e8       	ldi	r30, 0x80	; 128
     5de:	f6 e0       	ldi	r31, 0x06	; 6
     5e0:	8c e0       	ldi	r24, 0x0C	; 12
     5e2:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e4:	82 89       	ldd	r24, Z+18	; 0x12
     5e6:	83 60       	ori	r24, 0x03	; 3
     5e8:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ea:	83 89       	ldd	r24, Z+19	; 0x13
     5ec:	83 60       	ori	r24, 0x03	; 3
     5ee:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5f0:	e0 e8       	ldi	r30, 0x80	; 128
     5f2:	f1 e0       	ldi	r31, 0x01	; 1
     5f4:	82 e7       	ldi	r24, 0x72	; 114
     5f6:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f8:	89 e0       	ldi	r24, 0x09	; 9
     5fa:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5fc:	e0 e0       	ldi	r30, 0x00	; 0
     5fe:	f9 e0       	ldi	r31, 0x09	; 9
     600:	88 e6       	ldi	r24, 0x68	; 104
     602:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     604:	8f ef       	ldi	r24, 0xFF	; 255
     606:	9f ef       	ldi	r25, 0xFF	; 255
     608:	86 a3       	std	Z+38, r24	; 0x26
     60a:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     60c:	81 e0       	ldi	r24, 0x01	; 1
     60e:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     610:	0f 2e       	mov	r0, r31
     612:	a1 2c       	mov	r10, r1
     614:	f9 e0       	ldi	r31, 0x09	; 9
     616:	bf 2e       	mov	r11, r31
     618:	f0 2d       	mov	r31, r0
     61a:	f5 01       	movw	r30, r10
     61c:	00 a1       	ldd	r16, Z+32	; 0x20
     61e:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     620:	0f b6       	in	r0, 0x3f	; 63
     622:	f8 94       	cli
     624:	0f 92       	push	r0
			the_data = new_data;
     626:	c8 01       	movw	r24, r16
     628:	88 0f       	add	r24, r24
     62a:	99 1f       	adc	r25, r25
     62c:	88 0f       	add	r24, r24
     62e:	99 1f       	adc	r25, r25
     630:	88 0f       	add	r24, r24
     632:	99 1f       	adc	r25, r25
     634:	80 0f       	add	r24, r16
     636:	91 1f       	adc	r25, r17
     638:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <thMotor>
     63c:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <thMotor+0x1>
			portEXIT_CRITICAL ();
     640:	0f 90       	pop	r0
     642:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     644:	0f b6       	in	r0, 0x3f	; 63
     646:	f8 94       	cli
     648:	0f 92       	push	r0
			the_data = new_data;
     64a:	c8 01       	movw	r24, r16
     64c:	01 2e       	mov	r0, r17
     64e:	00 0c       	add	r0, r0
     650:	aa 0b       	sbc	r26, r26
     652:	bb 0b       	sbc	r27, r27
     654:	ac 01       	movw	r20, r24
     656:	bd 01       	movw	r22, r26
     658:	44 0f       	add	r20, r20
     65a:	55 1f       	adc	r21, r21
     65c:	66 1f       	adc	r22, r22
     65e:	77 1f       	adc	r23, r23
     660:	3a 01       	movw	r6, r20
     662:	4b 01       	movw	r8, r22
     664:	68 0e       	add	r6, r24
     666:	79 1e       	adc	r7, r25
     668:	8a 1e       	adc	r8, r26
     66a:	9b 1e       	adc	r9, r27
     66c:	c4 01       	movw	r24, r8
     66e:	b3 01       	movw	r22, r6
     670:	24 e6       	ldi	r18, 0x64	; 100
     672:	30 e0       	ldi	r19, 0x00	; 0
     674:	40 e0       	ldi	r20, 0x00	; 0
     676:	50 e0       	ldi	r21, 0x00	; 0
     678:	0e 94 a7 21 	call	0x434e	; 0x434e <__divmodsi4>
     67c:	20 93 4e 31 	sts	0x314E, r18	; 0x80314e <linear_position>
     680:	30 93 4f 31 	sts	0x314F, r19	; 0x80314f <linear_position+0x1>
			portEXIT_CRITICAL ();
     684:	0f 90       	pop	r0
     686:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     688:	0f b6       	in	r0, 0x3f	; 63
     68a:	f8 94       	cli
     68c:	0f 92       	push	r0
			the_data = new_data;
     68e:	c8 01       	movw	r24, r16
     690:	8c 19       	sub	r24, r12
     692:	9d 09       	sbc	r25, r13
     694:	09 2e       	mov	r0, r25
     696:	00 0c       	add	r0, r0
     698:	aa 0b       	sbc	r26, r26
     69a:	bb 0b       	sbc	r27, r27
     69c:	ac 01       	movw	r20, r24
     69e:	bd 01       	movw	r22, r26
     6a0:	44 0f       	add	r20, r20
     6a2:	55 1f       	adc	r21, r21
     6a4:	66 1f       	adc	r22, r22
     6a6:	77 1f       	adc	r23, r23
     6a8:	84 0f       	add	r24, r20
     6aa:	95 1f       	adc	r25, r21
     6ac:	a6 1f       	adc	r26, r22
     6ae:	b7 1f       	adc	r27, r23
     6b0:	ac 01       	movw	r20, r24
     6b2:	bd 01       	movw	r22, r26
     6b4:	44 0f       	add	r20, r20
     6b6:	55 1f       	adc	r21, r21
     6b8:	66 1f       	adc	r22, r22
     6ba:	77 1f       	adc	r23, r23
     6bc:	44 0f       	add	r20, r20
     6be:	55 1f       	adc	r21, r21
     6c0:	66 1f       	adc	r22, r22
     6c2:	77 1f       	adc	r23, r23
     6c4:	84 0f       	add	r24, r20
     6c6:	95 1f       	adc	r25, r21
     6c8:	a6 1f       	adc	r26, r22
     6ca:	b7 1f       	adc	r27, r23
     6cc:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <thdMotor>
     6d0:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <thdMotor+0x1>
			portEXIT_CRITICAL ();
     6d4:	0f 90       	pop	r0
     6d6:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     6d8:	f7 01       	movw	r30, r14
     6da:	86 85       	ldd	r24, Z+14	; 0x0e
     6dc:	97 85       	ldd	r25, Z+15	; 0x0f
     6de:	a0 89       	ldd	r26, Z+16	; 0x10
     6e0:	b1 89       	ldd	r27, Z+17	; 0x11
     6e2:	01 96       	adiw	r24, 0x01	; 1
     6e4:	a1 1d       	adc	r26, r1
     6e6:	b1 1d       	adc	r27, r1
     6e8:	86 87       	std	Z+14, r24	; 0x0e
     6ea:	97 87       	std	Z+15, r25	; 0x0f
     6ec:	a0 8b       	std	Z+16, r26	; 0x10
     6ee:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     6f0:	41 e0       	ldi	r20, 0x01	; 1
     6f2:	50 e0       	ldi	r21, 0x00	; 0
     6f4:	60 e0       	ldi	r22, 0x00	; 0
     6f6:	70 e0       	ldi	r23, 0x00	; 0
     6f8:	ce 01       	movw	r24, r28
     6fa:	01 96       	adiw	r24, 0x01	; 1
     6fc:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskDelayUntil>
		
		angularVelocity = ((int32_t) (encoder_count-last_encoder_count)*15)/dt;	// d_ec*60/(4*1000)/dt where dt is in ms so * 1000
		//*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     700:	68 01       	movw	r12, r16
     702:	8b cf       	rjmp	.-234    	; 0x61a <_ZN12EncoderMotor3runEv+0x58>

00000704 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     704:	0f 93       	push	r16
     706:	1f 93       	push	r17
     708:	cf 93       	push	r28
     70a:	df 93       	push	r29
     70c:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     70e:	0e 94 14 15 	call	0x2a28	; 0x2a28 <_ZN8frt_taskC1EPKchjP8emstream>
     712:	8a e0       	ldi	r24, 0x0A	; 10
     714:	90 e2       	ldi	r25, 0x20	; 32
     716:	88 83       	st	Y, r24
     718:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	1f 91       	pop	r17
     720:	0f 91       	pop	r16
     722:	08 95       	ret

00000724 <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     724:	cf 93       	push	r28
     726:	df 93       	push	r29
     728:	00 d0       	rcall	.+0      	; 0x72a <_ZN15EncoderPendulum3runEv+0x6>
     72a:	1f 92       	push	r1
     72c:	cd b7       	in	r28, 0x3d	; 61
     72e:	de b7       	in	r29, 0x3e	; 62
     730:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     732:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <xTaskGetTickCount>
     736:	69 83       	std	Y+1, r22	; 0x01
     738:	7a 83       	std	Y+2, r23	; 0x02
     73a:	8b 83       	std	Y+3, r24	; 0x03
     73c:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     73e:	e0 e8       	ldi	r30, 0x80	; 128
     740:	f6 e0       	ldi	r31, 0x06	; 6
     742:	83 e0       	ldi	r24, 0x03	; 3
     744:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     746:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     748:	81 8b       	std	Z+17, r24	; 0x11
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     74a:	e0 e8       	ldi	r30, 0x80	; 128
     74c:	f1 e0       	ldi	r31, 0x01	; 1
     74e:	80 e7       	ldi	r24, 0x70	; 112
     750:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     752:	89 e0       	ldi	r24, 0x09	; 9
     754:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     756:	e0 e4       	ldi	r30, 0x40	; 64
     758:	f8 e0       	ldi	r31, 0x08	; 8
     75a:	8a e6       	ldi	r24, 0x6A	; 106
     75c:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     75e:	80 ea       	ldi	r24, 0xA0	; 160
     760:	95 e0       	ldi	r25, 0x05	; 5
     762:	86 a3       	std	Z+38, r24	; 0x26
     764:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     76a:	68 94       	set
     76c:	ee 24       	eor	r14, r14
     76e:	e6 f8       	bld	r14, 6
     770:	ff 24       	eor	r15, r15
     772:	f3 f8       	bld	r15, 3
     774:	f7 01       	movw	r30, r14
     776:	a0 a1       	ldd	r26, Z+32	; 0x20
     778:	b1 a1       	ldd	r27, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     77a:	0f b6       	in	r0, 0x3f	; 63
     77c:	f8 94       	cli
     77e:	0f 92       	push	r0
			the_data = new_data;
     780:	24 e6       	ldi	r18, 0x64	; 100
     782:	30 e0       	ldi	r19, 0x00	; 0
     784:	0e 94 cf 21 	call	0x439e	; 0x439e <__usmulhisi3>
     788:	4b 01       	movw	r8, r22
     78a:	5c 01       	movw	r10, r24
     78c:	99 23       	and	r25, r25
     78e:	2c f4       	brge	.+10     	; 0x79a <_ZN15EncoderPendulum3runEv+0x76>
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	8f 0e       	add	r8, r31
     794:	91 1c       	adc	r9, r1
     796:	a1 1c       	adc	r10, r1
     798:	b1 1c       	adc	r11, r1
     79a:	d5 01       	movw	r26, r10
     79c:	c4 01       	movw	r24, r8
     79e:	b5 95       	asr	r27
     7a0:	a7 95       	ror	r26
     7a2:	97 95       	ror	r25
     7a4:	87 95       	ror	r24
     7a6:	b5 95       	asr	r27
     7a8:	a7 95       	ror	r26
     7aa:	97 95       	ror	r25
     7ac:	87 95       	ror	r24
     7ae:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <thPendulum>
     7b2:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     7b6:	0f 90       	pop	r0
     7b8:	0f be       	out	0x3f, r0	; 63
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     7ba:	f8 01       	movw	r30, r16
     7bc:	86 85       	ldd	r24, Z+14	; 0x0e
     7be:	97 85       	ldd	r25, Z+15	; 0x0f
     7c0:	a0 89       	ldd	r26, Z+16	; 0x10
     7c2:	b1 89       	ldd	r27, Z+17	; 0x11
     7c4:	01 96       	adiw	r24, 0x01	; 1
     7c6:	a1 1d       	adc	r26, r1
     7c8:	b1 1d       	adc	r27, r1
     7ca:	86 87       	std	Z+14, r24	; 0x0e
     7cc:	97 87       	std	Z+15, r25	; 0x0f
     7ce:	a0 8b       	std	Z+16, r26	; 0x10
     7d0:	b1 8b       	std	Z+17, r27	; 0x11
     7d2:	45 e0       	ldi	r20, 0x05	; 5
     7d4:	50 e0       	ldi	r21, 0x00	; 0
     7d6:	60 e0       	ldi	r22, 0x00	; 0
     7d8:	70 e0       	ldi	r23, 0x00	; 0
     7da:	ce 01       	movw	r24, r28
     7dc:	01 96       	adiw	r24, 0x01	; 1
     7de:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskDelayUntil>
     7e2:	c8 cf       	rjmp	.-112    	; 0x774 <_ZN15EncoderPendulum3runEv+0x50>

000007e4 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     7e4:	0f 93       	push	r16
     7e6:	1f 93       	push	r17
     7e8:	cf 93       	push	r28
     7ea:	df 93       	push	r29
     7ec:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7ee:	0e 94 14 15 	call	0x2a28	; 0x2a28 <_ZN8frt_taskC1EPKchjP8emstream>
     7f2:	82 e1       	ldi	r24, 0x12	; 18
     7f4:	90 e2       	ldi	r25, 0x20	; 32
     7f6:	88 83       	st	Y, r24
     7f8:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     7fa:	df 91       	pop	r29
     7fc:	cf 91       	pop	r28
     7fe:	1f 91       	pop	r17
     800:	0f 91       	pop	r16
     802:	08 95       	ret

00000804 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     804:	cf 93       	push	r28
     806:	df 93       	push	r29
     808:	00 d0       	rcall	.+0      	; 0x80a <_ZN13LimitSwitches3runEv+0x6>
     80a:	1f 92       	push	r1
     80c:	cd b7       	in	r28, 0x3d	; 61
     80e:	de b7       	in	r29, 0x3e	; 62
     810:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     812:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <xTaskGetTickCount>
     816:	69 83       	std	Y+1, r22	; 0x01
     818:	7a 83       	std	Y+2, r23	; 0x02
     81a:	8b 83       	std	Y+3, r24	; 0x03
     81c:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     81e:	e0 e6       	ldi	r30, 0x60	; 96
     820:	f6 e0       	ldi	r31, 0x06	; 6
     822:	81 e0       	ldi	r24, 0x01	; 1
     824:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     826:	84 e0       	ldi	r24, 0x04	; 4
     828:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     82a:	88 e1       	ldi	r24, 0x18	; 24
     82c:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     82e:	82 8b       	std	Z+18, r24	; 0x12
	bool rightLimit = false;
	bool leftLimit = false;
		
	while(1){
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     830:	08 e6       	ldi	r16, 0x68	; 104
     832:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     834:	dd 24       	eor	r13, r13
     836:	d3 94       	inc	r13
     838:	f8 01       	movw	r30, r16
     83a:	80 81       	ld	r24, Z
     83c:	80 fd       	sbrc	r24, 0
     83e:	08 c0       	rjmp	.+16     	; 0x850 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     840:	0f b6       	in	r0, 0x3f	; 63
     842:	f8 94       	cli
     844:	0f 92       	push	r0
			the_data = new_data;
     846:	d0 92 47 31 	sts	0x3147, r13	; 0x803147 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     84a:	0f 90       	pop	r0
     84c:	0f be       	out	0x3f, r0	; 63
     84e:	07 c0       	rjmp	.+14     	; 0x85e <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     850:	0f b6       	in	r0, 0x3f	; 63
     852:	f8 94       	cli
     854:	0f 92       	push	r0
			the_data = new_data;
     856:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     85a:	0f 90       	pop	r0
     85c:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);
			//*p_serial << "limits: " << rightLimit << leftLimit << endl;
		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     85e:	f8 01       	movw	r30, r16
     860:	80 81       	ld	r24, Z
     862:	82 fd       	sbrc	r24, 2
     864:	08 c0       	rjmp	.+16     	; 0x876 <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     866:	0f b6       	in	r0, 0x3f	; 63
     868:	f8 94       	cli
     86a:	0f 92       	push	r0
			the_data = new_data;
     86c:	d0 92 46 31 	sts	0x3146, r13	; 0x803146 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     870:	0f 90       	pop	r0
     872:	0f be       	out	0x3f, r0	; 63
     874:	07 c0       	rjmp	.+14     	; 0x884 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     876:	0f b6       	in	r0, 0x3f	; 63
     878:	f8 94       	cli
     87a:	0f 92       	push	r0
			the_data = new_data;
     87c:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     880:	0f 90       	pop	r0
     882:	0f be       	out	0x3f, r0	; 63
		
		//*p_serial << "Left" << leftLimitSwitch.get() << "\t";
		//*p_serial << "Right" << rightLimitSwitch.get() << endl;
		
		// Increment counter for debugging
		runs++;
     884:	f7 01       	movw	r30, r14
     886:	86 85       	ldd	r24, Z+14	; 0x0e
     888:	97 85       	ldd	r25, Z+15	; 0x0f
     88a:	a0 89       	ldd	r26, Z+16	; 0x10
     88c:	b1 89       	ldd	r27, Z+17	; 0x11
     88e:	01 96       	adiw	r24, 0x01	; 1
     890:	a1 1d       	adc	r26, r1
     892:	b1 1d       	adc	r27, r1
     894:	86 87       	std	Z+14, r24	; 0x0e
     896:	97 87       	std	Z+15, r25	; 0x0f
     898:	a0 8b       	std	Z+16, r26	; 0x10
     89a:	b1 8b       	std	Z+17, r27	; 0x11
     89c:	45 e0       	ldi	r20, 0x05	; 5
     89e:	50 e0       	ldi	r21, 0x00	; 0
     8a0:	60 e0       	ldi	r22, 0x00	; 0
     8a2:	70 e0       	ldi	r23, 0x00	; 0
     8a4:	ce 01       	movw	r24, r28
     8a6:	01 96       	adiw	r24, 0x01	; 1
     8a8:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskDelayUntil>
     8ac:	c5 cf       	rjmp	.-118    	; 0x838 <_ZN13LimitSwitches3runEv+0x34>

000008ae <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8b8:	0e 94 14 15 	call	0x2a28	; 0x2a28 <_ZN8frt_taskC1EPKchjP8emstream>
     8bc:	8a e1       	ldi	r24, 0x1A	; 26
     8be:	90 e2       	ldi	r25, 0x20	; 32
     8c0:	88 83       	st	Y, r24
     8c2:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     8c4:	df 91       	pop	r29
     8c6:	cf 91       	pop	r28
     8c8:	1f 91       	pop	r17
     8ca:	0f 91       	pop	r16
     8cc:	08 95       	ret

000008ce <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     8ce:	cf 93       	push	r28
     8d0:	df 93       	push	r29
     8d2:	00 d0       	rcall	.+0      	; 0x8d4 <_ZN5Motor3runEv+0x6>
     8d4:	00 d0       	rcall	.+0      	; 0x8d6 <_ZN5Motor3runEv+0x8>
     8d6:	cd b7       	in	r28, 0x3d	; 61
     8d8:	de b7       	in	r29, 0x3e	; 62
     8da:	3c 01       	movw	r6, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8dc:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <xTaskGetTickCount>
     8e0:	69 83       	std	Y+1, r22	; 0x01
     8e2:	7a 83       	std	Y+2, r23	; 0x02
     8e4:	8b 83       	std	Y+3, r24	; 0x03
     8e6:	9c 83       	std	Y+4, r25	; 0x04

	dt = .008;
     8e8:	f3 01       	movw	r30, r6
     8ea:	fe 96       	adiw	r30, 0x3e	; 62
     8ec:	8f e6       	ldi	r24, 0x6F	; 111
     8ee:	92 e1       	ldi	r25, 0x12	; 18
     8f0:	a3 e0       	ldi	r26, 0x03	; 3
     8f2:	bc e3       	ldi	r27, 0x3C	; 60
     8f4:	80 83       	st	Z, r24
     8f6:	91 83       	std	Z+1, r25	; 0x01
     8f8:	a2 83       	std	Z+2, r26	; 0x02
     8fa:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	90 e0       	ldi	r25, 0x00	; 0
     900:	f3 01       	movw	r30, r6
     902:	84 af       	std	Z+60, r24	; 0x3c
     904:	95 af       	std	Z+61, r25	; 0x3d
		runs++;
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     906:	68 94       	set
     908:	44 24       	eor	r4, r4
     90a:	41 f8       	bld	r4, 1
     90c:	51 2c       	mov	r5, r1
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     90e:	0f 2e       	mov	r0, r31
     910:	ff e3       	ldi	r31, 0x3F	; 63
     912:	2f 2e       	mov	r2, r31
     914:	f0 2d       	mov	r31, r0
     916:	0f 2e       	mov	r0, r31
     918:	fc e3       	ldi	r31, 0x3C	; 60
     91a:	3f 2e       	mov	r3, r31
     91c:	f0 2d       	mov	r31, r0
	dt = .008;
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     91e:	f3 01       	movw	r30, r6
     920:	86 85       	ldd	r24, Z+14	; 0x0e
     922:	97 85       	ldd	r25, Z+15	; 0x0f
     924:	a0 89       	ldd	r26, Z+16	; 0x10
     926:	b1 89       	ldd	r27, Z+17	; 0x11
     928:	01 96       	adiw	r24, 0x01	; 1
     92a:	a1 1d       	adc	r26, r1
     92c:	b1 1d       	adc	r27, r1
     92e:	86 87       	std	Z+14, r24	; 0x0e
     930:	97 87       	std	Z+15, r25	; 0x0f
     932:	a0 8b       	std	Z+16, r26	; 0x10
     934:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     936:	42 8e       	std	Z+26, r4	; 0x1a
     938:	53 8e       	std	Z+27, r5	; 0x1b

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
     93a:	16 8e       	std	Z+30, r1	; 0x1e
     93c:	17 8e       	std	Z+31, r1	; 0x1f
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     93e:	2f 92       	push	r2
     940:	1f 92       	push	r1
     942:	1f 92       	push	r1
     944:	1f 92       	push	r1
     946:	3f 92       	push	r3
     948:	f3 e2       	ldi	r31, 0x23	; 35
     94a:	ff 93       	push	r31
     94c:	27 ed       	ldi	r18, 0xD7	; 215
     94e:	2f 93       	push	r18
     950:	3a e0       	ldi	r19, 0x0A	; 10
     952:	3f 93       	push	r19
     954:	0f 2e       	mov	r0, r31
     956:	fd ec       	ldi	r31, 0xCD	; 205
     958:	8f 2e       	mov	r8, r31
     95a:	fc ec       	ldi	r31, 0xCC	; 204
     95c:	9f 2e       	mov	r9, r31
     95e:	a9 2c       	mov	r10, r9
     960:	fd e3       	ldi	r31, 0x3D	; 61
     962:	bf 2e       	mov	r11, r31
     964:	f0 2d       	mov	r31, r0
     966:	0f 2e       	mov	r0, r31
     968:	f4 e1       	ldi	r31, 0x14	; 20
     96a:	cf 2e       	mov	r12, r31
     96c:	fe ea       	ldi	r31, 0xAE	; 174
     96e:	df 2e       	mov	r13, r31
     970:	ff e8       	ldi	r31, 0x8F	; 143
     972:	ef 2e       	mov	r14, r31
     974:	ff eb       	ldi	r31, 0xBF	; 191
     976:	ff 2e       	mov	r15, r31
     978:	f0 2d       	mov	r31, r0
     97a:	04 e1       	ldi	r16, 0x14	; 20
     97c:	1e ea       	ldi	r17, 0xAE	; 174
     97e:	2f e8       	ldi	r18, 0x8F	; 143
     980:	3f e3       	ldi	r19, 0x3F	; 63
     982:	b5 01       	movw	r22, r10
     984:	a4 01       	movw	r20, r8
     986:	ce 01       	movw	r24, r28
     988:	05 96       	adiw	r24, 0x05	; 5
     98a:	0e 94 9c 05 	call	0xb38	; 0xb38 <_ZN3PIDC1Edddddd>
		double Tset = pidTorque.calculate(omegam_set, omegam_measured);
     98e:	f3 01       	movw	r30, r6
     990:	66 8d       	ldd	r22, Z+30	; 0x1e
     992:	77 8d       	ldd	r23, Z+31	; 0x1f
     994:	02 8d       	ldd	r16, Z+26	; 0x1a
     996:	13 8d       	ldd	r17, Z+27	; 0x1b
     998:	07 2e       	mov	r0, r23
     99a:	00 0c       	add	r0, r0
     99c:	88 0b       	sbc	r24, r24
     99e:	99 0b       	sbc	r25, r25
     9a0:	0e 94 53 20 	call	0x40a6	; 0x40a6 <__floatsisf>
     9a4:	6b 01       	movw	r12, r22
     9a6:	7c 01       	movw	r14, r24
     9a8:	b8 01       	movw	r22, r16
     9aa:	11 0f       	add	r17, r17
     9ac:	88 0b       	sbc	r24, r24
     9ae:	99 0b       	sbc	r25, r25
     9b0:	0e 94 53 20 	call	0x40a6	; 0x40a6 <__floatsisf>
     9b4:	ab 01       	movw	r20, r22
     9b6:	bc 01       	movw	r22, r24
     9b8:	97 01       	movw	r18, r14
     9ba:	86 01       	movw	r16, r12
     9bc:	ce 01       	movw	r24, r28
     9be:	05 96       	adiw	r24, 0x05	; 5
     9c0:	0e 94 c3 06 	call	0xd86	; 0xd86 <_ZN3PID9calculateEdd>
     9c4:	6b 01       	movw	r12, r22
     9c6:	7c 01       	movw	r14, r24
		//printf("val:% 7.3f inc:% 7.3f\n", omegam_measured, inc);
		omegam_measured += inc;
     9c8:	f3 01       	movw	r30, r6
     9ca:	24 ad       	ldd	r18, Z+60	; 0x3c
     9cc:	35 ad       	ldd	r19, Z+61	; 0x3d
     9ce:	86 8d       	ldd	r24, Z+30	; 0x1e
     9d0:	97 8d       	ldd	r25, Z+31	; 0x1f
     9d2:	82 0f       	add	r24, r18
     9d4:	93 1f       	adc	r25, r19
     9d6:	86 8f       	std	Z+30, r24	; 0x1e
     9d8:	97 8f       	std	Z+31, r25	; 0x1f

		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     9da:	10 a6       	std	Z+40, r1	; 0x28
     9dc:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     9de:	60 a5       	ldd	r22, Z+40	; 0x28
     9e0:	71 a5       	ldd	r23, Z+41	; 0x29
     9e2:	07 2e       	mov	r0, r23
     9e4:	00 0c       	add	r0, r0
     9e6:	88 0b       	sbc	r24, r24
     9e8:	99 0b       	sbc	r25, r25
     9ea:	0e 94 53 20 	call	0x40a6	; 0x40a6 <__floatsisf>
     9ee:	9b 01       	movw	r18, r22
     9f0:	ac 01       	movw	r20, r24
     9f2:	c7 01       	movw	r24, r14
     9f4:	b6 01       	movw	r22, r12
     9f6:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <__divsf3>
     9fa:	0e 94 1b 20 	call	0x4036	; 0x4036 <__fixsfsi>
     9fe:	f3 01       	movw	r30, r6
     a00:	64 a3       	std	Z+36, r22	; 0x24
     a02:	75 a3       	std	Z+37, r23	; 0x25

		// Saturater for current
		
		if(Im_set > 17.4) {
     a04:	64 a1       	ldd	r22, Z+36	; 0x24
     a06:	75 a1       	ldd	r23, Z+37	; 0x25
     a08:	07 2e       	mov	r0, r23
     a0a:	00 0c       	add	r0, r0
     a0c:	88 0b       	sbc	r24, r24
     a0e:	99 0b       	sbc	r25, r25
     a10:	0e 94 53 20 	call	0x40a6	; 0x40a6 <__floatsisf>
     a14:	cd bf       	out	0x3d, r28	; 61
     a16:	de bf       	out	0x3e, r29	; 62
     a18:	23 e3       	ldi	r18, 0x33	; 51
     a1a:	33 e3       	ldi	r19, 0x33	; 51
     a1c:	4b e8       	ldi	r20, 0x8B	; 139
     a1e:	51 e4       	ldi	r21, 0x41	; 65
     a20:	0e 94 03 21 	call	0x4206	; 0x4206 <__gesf2>
     a24:	18 16       	cp	r1, r24
     a26:	34 f4       	brge	.+12     	; 0xa34 <_ZN5Motor3runEv+0x166>
			Im_set = 17.4;
     a28:	21 e1       	ldi	r18, 0x11	; 17
     a2a:	30 e0       	ldi	r19, 0x00	; 0
     a2c:	f3 01       	movw	r30, r6
     a2e:	24 a3       	std	Z+36, r18	; 0x24
     a30:	35 a3       	std	Z+37, r19	; 0x25
     a32:	16 c0       	rjmp	.+44     	; 0xa60 <_ZN5Motor3runEv+0x192>
		} else if(Im_set < -17.4) {
     a34:	f3 01       	movw	r30, r6
     a36:	64 a1       	ldd	r22, Z+36	; 0x24
     a38:	75 a1       	ldd	r23, Z+37	; 0x25
     a3a:	07 2e       	mov	r0, r23
     a3c:	00 0c       	add	r0, r0
     a3e:	88 0b       	sbc	r24, r24
     a40:	99 0b       	sbc	r25, r25
     a42:	0e 94 53 20 	call	0x40a6	; 0x40a6 <__floatsisf>
     a46:	23 e3       	ldi	r18, 0x33	; 51
     a48:	33 e3       	ldi	r19, 0x33	; 51
     a4a:	4b e8       	ldi	r20, 0x8B	; 139
     a4c:	51 ec       	ldi	r21, 0xC1	; 193
     a4e:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <__cmpsf2>
     a52:	88 23       	and	r24, r24
     a54:	2c f4       	brge	.+10     	; 0xa60 <_ZN5Motor3runEv+0x192>
			Im_set = -17.4;
     a56:	2f ee       	ldi	r18, 0xEF	; 239
     a58:	3f ef       	ldi	r19, 0xFF	; 255
     a5a:	f3 01       	movw	r30, r6
     a5c:	24 a3       	std	Z+36, r18	; 0x24
     a5e:	35 a3       	std	Z+37, r19	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     a60:	f3 01       	movw	r30, r6
     a62:	16 aa       	std	Z+54, r1	; 0x36
     a64:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     a66:	60 a5       	ldd	r22, Z+40	; 0x28
     a68:	71 a5       	ldd	r23, Z+41	; 0x29
     a6a:	06 a9       	ldd	r16, Z+54	; 0x36
     a6c:	17 a9       	ldd	r17, Z+55	; 0x37
     a6e:	07 2e       	mov	r0, r23
     a70:	00 0c       	add	r0, r0
     a72:	88 0b       	sbc	r24, r24
     a74:	99 0b       	sbc	r25, r25
     a76:	0e 94 53 20 	call	0x40a6	; 0x40a6 <__floatsisf>
     a7a:	20 e5       	ldi	r18, 0x50	; 80
     a7c:	3a e6       	ldi	r19, 0x6A	; 106
     a7e:	41 ea       	ldi	r20, 0xA1	; 161
     a80:	57 e4       	ldi	r21, 0x47	; 71
     a82:	0e 94 08 21 	call	0x4210	; 0x4210 <__mulsf3>
     a86:	6b 01       	movw	r12, r22
     a88:	7c 01       	movw	r14, r24
     a8a:	b8 01       	movw	r22, r16
     a8c:	11 0f       	add	r17, r17
     a8e:	88 0b       	sbc	r24, r24
     a90:	99 0b       	sbc	r25, r25
     a92:	0e 94 53 20 	call	0x40a6	; 0x40a6 <__floatsisf>
     a96:	9b 01       	movw	r18, r22
     a98:	ac 01       	movw	r20, r24
     a9a:	c7 01       	movw	r24, r14
     a9c:	b6 01       	movw	r22, r12
     a9e:	0e 94 08 21 	call	0x4210	; 0x4210 <__mulsf3>
     aa2:	0e 94 1b 20 	call	0x4036	; 0x4036 <__fixsfsi>
     aa6:	f3 01       	movw	r30, r6
     aa8:	62 ab       	std	Z+50, r22	; 0x32
     aaa:	73 ab       	std	Z+51, r23	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     aac:	46 a9       	ldd	r20, Z+54	; 0x36
     aae:	57 a9       	ldd	r21, Z+55	; 0x37
     ab0:	26 8d       	ldd	r18, Z+30	; 0x1e
     ab2:	37 8d       	ldd	r19, Z+31	; 0x1f
     ab4:	42 9f       	mul	r20, r18
     ab6:	c0 01       	movw	r24, r0
     ab8:	43 9f       	mul	r20, r19
     aba:	90 0d       	add	r25, r0
     abc:	52 9f       	mul	r21, r18
     abe:	90 0d       	add	r25, r0
     ac0:	11 24       	eor	r1, r1
     ac2:	84 ab       	std	Z+52, r24	; 0x34
     ac4:	95 ab       	std	Z+53, r25	; 0x35

		V_m = V_R + V_E;
     ac6:	20 a9       	ldd	r18, Z+48	; 0x30
     ac8:	31 a9       	ldd	r19, Z+49	; 0x31
     aca:	84 a9       	ldd	r24, Z+52	; 0x34
     acc:	95 a9       	ldd	r25, Z+53	; 0x35
     ace:	82 0f       	add	r24, r18
     ad0:	93 1f       	adc	r25, r19
     ad2:	80 af       	std	Z+56, r24	; 0x38
     ad4:	91 af       	std	Z+57, r25	; 0x39

		// Saturater for voltage
		if (V_m > 24) {
     ad6:	80 ad       	ldd	r24, Z+56	; 0x38
     ad8:	91 ad       	ldd	r25, Z+57	; 0x39
     ada:	49 97       	sbiw	r24, 0x19	; 25
     adc:	2c f0       	brlt	.+10     	; 0xae8 <_ZN5Motor3runEv+0x21a>
			V_m = 24;
     ade:	28 e1       	ldi	r18, 0x18	; 24
     ae0:	30 e0       	ldi	r19, 0x00	; 0
     ae2:	20 af       	std	Z+56, r18	; 0x38
     ae4:	31 af       	std	Z+57, r19	; 0x39
     ae6:	0b c0       	rjmp	.+22     	; 0xafe <_ZN5Motor3runEv+0x230>
		} else if(V_m < -24) {
     ae8:	f3 01       	movw	r30, r6
     aea:	80 ad       	ldd	r24, Z+56	; 0x38
     aec:	91 ad       	ldd	r25, Z+57	; 0x39
     aee:	88 3e       	cpi	r24, 0xE8	; 232
     af0:	9f 4f       	sbci	r25, 0xFF	; 255
     af2:	2c f4       	brge	.+10     	; 0xafe <_ZN5Motor3runEv+0x230>
			V_m = -24;
     af4:	28 ee       	ldi	r18, 0xE8	; 232
     af6:	3f ef       	ldi	r19, 0xFF	; 255
     af8:	f3 01       	movw	r30, r6
     afa:	20 af       	std	Z+56, r18	; 0x38
     afc:	31 af       	std	Z+57, r19	; 0x39
     afe:	41 e0       	ldi	r20, 0x01	; 1
     b00:	50 e0       	ldi	r21, 0x00	; 0
     b02:	60 e0       	ldi	r22, 0x00	; 0
     b04:	70 e0       	ldi	r23, 0x00	; 0
     b06:	ce 01       	movw	r24, r28
     b08:	01 96       	adiw	r24, 0x01	; 1
     b0a:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskDelayUntil>
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     b0e:	ce 01       	movw	r24, r28
     b10:	05 96       	adiw	r24, 0x05	; 5
     b12:	0e 94 03 06 	call	0xc06	; 0xc06 <_ZN3PIDD1Ev>
	portTickType previousTicks = xTaskGetTickCount ();

	dt = .008;
	inc = 1;
	
	while(1){
     b16:	03 cf       	rjmp	.-506    	; 0x91e <_ZN5Motor3runEv+0x50>

00000b18 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     b18:	0f 93       	push	r16
     b1a:	1f 93       	push	r17
     b1c:	cf 93       	push	r28
     b1e:	df 93       	push	r29
     b20:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     b22:	0e 94 14 15 	call	0x2a28	; 0x2a28 <_ZN8frt_taskC1EPKchjP8emstream>
     b26:	82 e2       	ldi	r24, 0x22	; 34
     b28:	90 e2       	ldi	r25, 0x20	; 32
     b2a:	88 83       	st	Y, r24
     b2c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     b2e:	df 91       	pop	r29
     b30:	cf 91       	pop	r28
     b32:	1f 91       	pop	r17
     b34:	0f 91       	pop	r16
     b36:	08 95       	ret

00000b38 <_ZN3PIDC1Edddddd>:
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}
     b38:	2f 92       	push	r2
     b3a:	3f 92       	push	r3
     b3c:	4f 92       	push	r4
     b3e:	5f 92       	push	r5
     b40:	6f 92       	push	r6
     b42:	7f 92       	push	r7
     b44:	8f 92       	push	r8
     b46:	9f 92       	push	r9
     b48:	af 92       	push	r10
     b4a:	bf 92       	push	r11
     b4c:	cf 92       	push	r12
     b4e:	df 92       	push	r13
     b50:	ef 92       	push	r14
     b52:	ff 92       	push	r15
     b54:	0f 93       	push	r16
     b56:	1f 93       	push	r17
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	00 d0       	rcall	.+0      	; 0xb5e <_ZN3PIDC1Edddddd+0x26>
     b5e:	1f 92       	push	r1
     b60:	cd b7       	in	r28, 0x3d	; 61
     b62:	de b7       	in	r29, 0x3e	; 62
     b64:	1c 01       	movw	r2, r24
     b66:	2a 01       	movw	r4, r20
     b68:	3b 01       	movw	r6, r22
     b6a:	09 83       	std	Y+1, r16	; 0x01
     b6c:	1a 83       	std	Y+2, r17	; 0x02
     b6e:	2b 83       	std	Y+3, r18	; 0x03
     b70:	3c 83       	std	Y+4, r19	; 0x04
     b72:	80 e2       	ldi	r24, 0x20	; 32
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	0e 94 8e 19 	call	0x331c	; 0x331c <_Znwj>
     b7a:	fc 01       	movw	r30, r24
     b7c:	40 82       	st	Z, r4
     b7e:	51 82       	std	Z+1, r5	; 0x01
     b80:	62 82       	std	Z+2, r6	; 0x02
     b82:	73 82       	std	Z+3, r7	; 0x03
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	ab 81       	ldd	r26, Y+3	; 0x03
     b8a:	bc 81       	ldd	r27, Y+4	; 0x04
     b8c:	84 83       	std	Z+4, r24	; 0x04
     b8e:	95 83       	std	Z+5, r25	; 0x05
     b90:	a6 83       	std	Z+6, r26	; 0x06
     b92:	b7 83       	std	Z+7, r27	; 0x07
     b94:	c0 86       	std	Z+8, r12	; 0x08
     b96:	d1 86       	std	Z+9, r13	; 0x09
     b98:	e2 86       	std	Z+10, r14	; 0x0a
     b9a:	f3 86       	std	Z+11, r15	; 0x0b
     b9c:	84 86       	std	Z+12, r8	; 0x0c
     b9e:	95 86       	std	Z+13, r9	; 0x0d
     ba0:	a6 86       	std	Z+14, r10	; 0x0e
     ba2:	b7 86       	std	Z+15, r11	; 0x0f
     ba4:	4a 8d       	ldd	r20, Y+26	; 0x1a
     ba6:	5b 8d       	ldd	r21, Y+27	; 0x1b
     ba8:	6c 8d       	ldd	r22, Y+28	; 0x1c
     baa:	7d 8d       	ldd	r23, Y+29	; 0x1d
     bac:	40 8b       	std	Z+16, r20	; 0x10
     bae:	51 8b       	std	Z+17, r21	; 0x11
     bb0:	62 8b       	std	Z+18, r22	; 0x12
     bb2:	73 8b       	std	Z+19, r23	; 0x13
     bb4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bb6:	9f 8d       	ldd	r25, Y+31	; 0x1f
     bb8:	a8 a1       	ldd	r26, Y+32	; 0x20
     bba:	b9 a1       	ldd	r27, Y+33	; 0x21
     bbc:	84 8b       	std	Z+20, r24	; 0x14
     bbe:	95 8b       	std	Z+21, r25	; 0x15
     bc0:	a6 8b       	std	Z+22, r26	; 0x16
     bc2:	b7 8b       	std	Z+23, r27	; 0x17
     bc4:	10 8e       	std	Z+24, r1	; 0x18
     bc6:	11 8e       	std	Z+25, r1	; 0x19
     bc8:	12 8e       	std	Z+26, r1	; 0x1a
     bca:	13 8e       	std	Z+27, r1	; 0x1b
     bcc:	14 8e       	std	Z+28, r1	; 0x1c
     bce:	15 8e       	std	Z+29, r1	; 0x1d
     bd0:	16 8e       	std	Z+30, r1	; 0x1e
     bd2:	17 8e       	std	Z+31, r1	; 0x1f
     bd4:	d1 01       	movw	r26, r2
     bd6:	ed 93       	st	X+, r30
     bd8:	fc 93       	st	X, r31
     bda:	24 96       	adiw	r28, 0x04	; 4
     bdc:	cd bf       	out	0x3d, r28	; 61
     bde:	de bf       	out	0x3e, r29	; 62
     be0:	df 91       	pop	r29
     be2:	cf 91       	pop	r28
     be4:	1f 91       	pop	r17
     be6:	0f 91       	pop	r16
     be8:	ff 90       	pop	r15
     bea:	ef 90       	pop	r14
     bec:	df 90       	pop	r13
     bee:	cf 90       	pop	r12
     bf0:	bf 90       	pop	r11
     bf2:	af 90       	pop	r10
     bf4:	9f 90       	pop	r9
     bf6:	8f 90       	pop	r8
     bf8:	7f 90       	pop	r7
     bfa:	6f 90       	pop	r6
     bfc:	5f 90       	pop	r5
     bfe:	4f 90       	pop	r4
     c00:	3f 90       	pop	r3
     c02:	2f 90       	pop	r2
     c04:	08 95       	ret

00000c06 <_ZN3PIDD1Ev>:
     c06:	fc 01       	movw	r30, r24
     c08:	80 81       	ld	r24, Z
     c0a:	91 81       	ldd	r25, Z+1	; 0x01
     c0c:	00 97       	sbiw	r24, 0x00	; 0
     c0e:	11 f0       	breq	.+4      	; 0xc14 <_ZN3PIDD1Ev+0xe>
     c10:	0e 94 91 19 	call	0x3322	; 0x3322 <_ZdlPv>
     c14:	08 95       	ret

00000c16 <_ZN7PIDImpl9calculateEdd>:

double PIDImpl::calculate( double setpoint, double pv )
{
     c16:	4f 92       	push	r4
     c18:	5f 92       	push	r5
     c1a:	6f 92       	push	r6
     c1c:	7f 92       	push	r7
     c1e:	8f 92       	push	r8
     c20:	9f 92       	push	r9
     c22:	af 92       	push	r10
     c24:	bf 92       	push	r11
     c26:	cf 92       	push	r12
     c28:	df 92       	push	r13
     c2a:	ef 92       	push	r14
     c2c:	ff 92       	push	r15
     c2e:	0f 93       	push	r16
     c30:	1f 93       	push	r17
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
     c36:	00 d0       	rcall	.+0      	; 0xc38 <_ZN7PIDImpl9calculateEdd+0x22>
     c38:	00 d0       	rcall	.+0      	; 0xc3a <_ZN7PIDImpl9calculateEdd+0x24>
     c3a:	cd b7       	in	r28, 0x3d	; 61
     c3c:	de b7       	in	r29, 0x3e	; 62
     c3e:	8d 83       	std	Y+5, r24	; 0x05
     c40:	9e 83       	std	Y+6, r25	; 0x06
     c42:	cb 01       	movw	r24, r22
     c44:	ba 01       	movw	r22, r20
    
    // Calculate error
    double error = setpoint - pv;
     c46:	a9 01       	movw	r20, r18
     c48:	98 01       	movw	r18, r16
     c4a:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <__subsf3>
     c4e:	6b 01       	movw	r12, r22
     c50:	7c 01       	movw	r14, r24

    // Proportional term
    double Pout = _Kp * error;
     c52:	ed 81       	ldd	r30, Y+5	; 0x05
     c54:	fe 81       	ldd	r31, Y+6	; 0x06
     c56:	24 85       	ldd	r18, Z+12	; 0x0c
     c58:	35 85       	ldd	r19, Z+13	; 0x0d
     c5a:	46 85       	ldd	r20, Z+14	; 0x0e
     c5c:	57 85       	ldd	r21, Z+15	; 0x0f
     c5e:	0e 94 08 21 	call	0x4210	; 0x4210 <__mulsf3>
     c62:	69 83       	std	Y+1, r22	; 0x01
     c64:	7a 83       	std	Y+2, r23	; 0x02
     c66:	8b 83       	std	Y+3, r24	; 0x03
     c68:	9c 83       	std	Y+4, r25	; 0x04

    // Integral term
    _integral += error * _dt;
     c6a:	ed 81       	ldd	r30, Y+5	; 0x05
     c6c:	fe 81       	ldd	r31, Y+6	; 0x06
     c6e:	40 80       	ld	r4, Z
     c70:	51 80       	ldd	r5, Z+1	; 0x01
     c72:	62 80       	ldd	r6, Z+2	; 0x02
     c74:	73 80       	ldd	r7, Z+3	; 0x03
     c76:	a3 01       	movw	r20, r6
     c78:	92 01       	movw	r18, r4
     c7a:	c7 01       	movw	r24, r14
     c7c:	b6 01       	movw	r22, r12
     c7e:	0e 94 08 21 	call	0x4210	; 0x4210 <__mulsf3>
     c82:	ed 81       	ldd	r30, Y+5	; 0x05
     c84:	fe 81       	ldd	r31, Y+6	; 0x06
     c86:	24 8d       	ldd	r18, Z+28	; 0x1c
     c88:	35 8d       	ldd	r19, Z+29	; 0x1d
     c8a:	46 8d       	ldd	r20, Z+30	; 0x1e
     c8c:	57 8d       	ldd	r21, Z+31	; 0x1f
     c8e:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <__addsf3>
     c92:	4b 01       	movw	r8, r22
     c94:	5c 01       	movw	r10, r24
     c96:	ed 81       	ldd	r30, Y+5	; 0x05
     c98:	fe 81       	ldd	r31, Y+6	; 0x06
     c9a:	64 8f       	std	Z+28, r22	; 0x1c
     c9c:	75 8f       	std	Z+29, r23	; 0x1d
     c9e:	86 8f       	std	Z+30, r24	; 0x1e
     ca0:	97 8f       	std	Z+31, r25	; 0x1f
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     ca2:	20 8d       	ldd	r18, Z+24	; 0x18
     ca4:	31 8d       	ldd	r19, Z+25	; 0x19
     ca6:	42 8d       	ldd	r20, Z+26	; 0x1a
     ca8:	53 8d       	ldd	r21, Z+27	; 0x1b
     caa:	c7 01       	movw	r24, r14
     cac:	b6 01       	movw	r22, r12
     cae:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <__subsf3>
     cb2:	a3 01       	movw	r20, r6
     cb4:	92 01       	movw	r18, r4
     cb6:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <__divsf3>
     cba:	ed 81       	ldd	r30, Y+5	; 0x05
     cbc:	fe 81       	ldd	r31, Y+6	; 0x06
     cbe:	20 89       	ldd	r18, Z+16	; 0x10
     cc0:	31 89       	ldd	r19, Z+17	; 0x11
     cc2:	42 89       	ldd	r20, Z+18	; 0x12
     cc4:	53 89       	ldd	r21, Z+19	; 0x13
     cc6:	0e 94 08 21 	call	0x4210	; 0x4210 <__mulsf3>
     cca:	2b 01       	movw	r4, r22
     ccc:	3c 01       	movw	r6, r24
     cce:	ed 81       	ldd	r30, Y+5	; 0x05
     cd0:	fe 81       	ldd	r31, Y+6	; 0x06
     cd2:	24 89       	ldd	r18, Z+20	; 0x14
     cd4:	35 89       	ldd	r19, Z+21	; 0x15
     cd6:	46 89       	ldd	r20, Z+22	; 0x16
     cd8:	57 89       	ldd	r21, Z+23	; 0x17
     cda:	c5 01       	movw	r24, r10
     cdc:	b4 01       	movw	r22, r8
     cde:	0e 94 08 21 	call	0x4210	; 0x4210 <__mulsf3>
     ce2:	29 81       	ldd	r18, Y+1	; 0x01
     ce4:	3a 81       	ldd	r19, Y+2	; 0x02
     ce6:	4b 81       	ldd	r20, Y+3	; 0x03
     ce8:	5c 81       	ldd	r21, Y+4	; 0x04
     cea:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <__addsf3>
     cee:	9b 01       	movw	r18, r22
     cf0:	ac 01       	movw	r20, r24
     cf2:	c3 01       	movw	r24, r6
     cf4:	b2 01       	movw	r22, r4
     cf6:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <__addsf3>
     cfa:	b6 2e       	mov	r11, r22
     cfc:	a7 2e       	mov	r10, r23
     cfe:	98 2e       	mov	r9, r24
     d00:	89 2e       	mov	r8, r25

    // Restrict to max/min
    if( output > _max )
     d02:	ed 81       	ldd	r30, Y+5	; 0x05
     d04:	fe 81       	ldd	r31, Y+6	; 0x06
     d06:	74 80       	ldd	r7, Z+4	; 0x04
     d08:	65 80       	ldd	r6, Z+5	; 0x05
     d0a:	56 80       	ldd	r5, Z+6	; 0x06
     d0c:	47 80       	ldd	r4, Z+7	; 0x07
     d0e:	27 2d       	mov	r18, r7
     d10:	36 2d       	mov	r19, r6
     d12:	45 2d       	mov	r20, r5
     d14:	54 2d       	mov	r21, r4
     d16:	0e 94 03 21 	call	0x4206	; 0x4206 <__gesf2>
     d1a:	18 16       	cp	r1, r24
     d1c:	b4 f0       	brlt	.+44     	; 0xd4a <_ZN7PIDImpl9calculateEdd+0x134>
        output = _max;
    else if( output < _min )
     d1e:	ed 81       	ldd	r30, Y+5	; 0x05
     d20:	fe 81       	ldd	r31, Y+6	; 0x06
     d22:	70 84       	ldd	r7, Z+8	; 0x08
     d24:	61 84       	ldd	r6, Z+9	; 0x09
     d26:	52 84       	ldd	r5, Z+10	; 0x0a
     d28:	43 84       	ldd	r4, Z+11	; 0x0b
     d2a:	27 2d       	mov	r18, r7
     d2c:	36 2d       	mov	r19, r6
     d2e:	45 2d       	mov	r20, r5
     d30:	54 2d       	mov	r21, r4
     d32:	6b 2d       	mov	r22, r11
     d34:	7a 2d       	mov	r23, r10
     d36:	89 2d       	mov	r24, r9
     d38:	98 2d       	mov	r25, r8
     d3a:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <__cmpsf2>
     d3e:	88 23       	and	r24, r24
     d40:	24 f0       	brlt	.+8      	; 0xd4a <_ZN7PIDImpl9calculateEdd+0x134>
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     d42:	7b 2c       	mov	r7, r11
     d44:	6a 2c       	mov	r6, r10
     d46:	59 2c       	mov	r5, r9
     d48:	48 2c       	mov	r4, r8
        output = _max;
    else if( output < _min )
        output = _min;

    // Save error to previous error
    _pre_error = error;
     d4a:	ed 81       	ldd	r30, Y+5	; 0x05
     d4c:	fe 81       	ldd	r31, Y+6	; 0x06
     d4e:	c0 8e       	std	Z+24, r12	; 0x18
     d50:	d1 8e       	std	Z+25, r13	; 0x19
     d52:	e2 8e       	std	Z+26, r14	; 0x1a
     d54:	f3 8e       	std	Z+27, r15	; 0x1b

    return output;
}
     d56:	67 2d       	mov	r22, r7
     d58:	76 2d       	mov	r23, r6
     d5a:	85 2d       	mov	r24, r5
     d5c:	94 2d       	mov	r25, r4
     d5e:	26 96       	adiw	r28, 0x06	; 6
     d60:	cd bf       	out	0x3d, r28	; 61
     d62:	de bf       	out	0x3e, r29	; 62
     d64:	df 91       	pop	r29
     d66:	cf 91       	pop	r28
     d68:	1f 91       	pop	r17
     d6a:	0f 91       	pop	r16
     d6c:	ff 90       	pop	r15
     d6e:	ef 90       	pop	r14
     d70:	df 90       	pop	r13
     d72:	cf 90       	pop	r12
     d74:	bf 90       	pop	r11
     d76:	af 90       	pop	r10
     d78:	9f 90       	pop	r9
     d7a:	8f 90       	pop	r8
     d7c:	7f 90       	pop	r7
     d7e:	6f 90       	pop	r6
     d80:	5f 90       	pop	r5
     d82:	4f 90       	pop	r4
     d84:	08 95       	ret

00000d86 <_ZN3PID9calculateEdd>:
PID::PID( double dt, double max, double min, double Kp, double Kd, double Ki )
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
double PID::calculate( double setpoint, double pv )
{
     d86:	0f 93       	push	r16
     d88:	1f 93       	push	r17
    return pimpl->calculate(setpoint,pv);
     d8a:	fc 01       	movw	r30, r24
     d8c:	80 81       	ld	r24, Z
     d8e:	91 81       	ldd	r25, Z+1	; 0x01
     d90:	0e 94 0b 06 	call	0xc16	; 0xc16 <_ZN7PIDImpl9calculateEdd>
}
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	08 95       	ret

00000d9a <_ZN9PWMdriver3runEv>:
		// Nothing to do in this constructor other than call the parent constructor
	}



void PWMdriver::run(void){
     d9a:	cf 93       	push	r28
     d9c:	df 93       	push	r29
     d9e:	00 d0       	rcall	.+0      	; 0xda0 <_ZN9PWMdriver3runEv+0x6>
     da0:	1f 92       	push	r1
     da2:	cd b7       	in	r28, 0x3d	; 61
     da4:	de b7       	in	r29, 0x3e	; 62
     da6:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     da8:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <xTaskGetTickCount>
     dac:	69 83       	std	Y+1, r22	; 0x01
     dae:	7a 83       	std	Y+2, r23	; 0x02
     db0:	8b 83       	std	Y+3, r24	; 0x03
     db2:	9c 83       	std	Y+4, r25	; 0x04
	//PC0 - MD0
	//PC1 - MD1
	
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     db4:	a0 e4       	ldi	r26, 0x40	; 64
     db6:	b6 e0       	ldi	r27, 0x06	; 6
     db8:	87 e0       	ldi	r24, 0x07	; 7
     dba:	11 96       	adiw	r26, 0x01	; 1
     dbc:	8c 93       	st	X, r24
     dbe:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     dc0:	84 e0       	ldi	r24, 0x04	; 4
     dc2:	15 96       	adiw	r26, 0x05	; 5
     dc4:	8c 93       	st	X, r24
     dc6:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     dc8:	e0 e0       	ldi	r30, 0x00	; 0
     dca:	f8 e0       	ldi	r31, 0x08	; 8
     dcc:	81 e0       	ldi	r24, 0x01	; 1
     dce:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     dd0:	83 e0       	ldi	r24, 0x03	; 3
     dd2:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     dd4:	a6 a3       	std	Z+38, r26	; 0x26
     dd6:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     dd8:	10 a6       	std	Z+40, r1	; 0x28
     dda:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     ddc:	12 a6       	std	Z+42, r1	; 0x2a
     dde:	13 a6       	std	Z+43, r1	; 0x2b
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     de0:	81 81       	ldd	r24, Z+1	; 0x01
     de2:	80 63       	ori	r24, 0x30	; 48
     de4:	81 83       	std	Z+1, r24	; 0x01
			TCC0.CCA = 800;
			TCC0.CCB = 0;
		}
		else if (leftLimitSwitch.get() || rightLimitSwitch.get())
		{
			TCC0.CCA = 0;
     de6:	e1 2c       	mov	r14, r1
     de8:	68 94       	set
     dea:	ff 24       	eor	r15, r15
     dec:	f3 f8       	bld	r15, 3
		// Increment counter for debugging
		runs++;
		
		if (!leftLimitSwitch.get() && !rightLimitSwitch.get())
		{
			TCC0.CCA = 800;
     dee:	0f 2e       	mov	r0, r31
     df0:	f0 e2       	ldi	r31, 0x20	; 32
     df2:	cf 2e       	mov	r12, r31
     df4:	f3 e0       	ldi	r31, 0x03	; 3
     df6:	df 2e       	mov	r13, r31
     df8:	f0 2d       	mov	r31, r0
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
	
	while(1){
		// Increment counter for debugging
		runs++;
     dfa:	f8 01       	movw	r30, r16
     dfc:	86 85       	ldd	r24, Z+14	; 0x0e
     dfe:	97 85       	ldd	r25, Z+15	; 0x0f
     e00:	a0 89       	ldd	r26, Z+16	; 0x10
     e02:	b1 89       	ldd	r27, Z+17	; 0x11
     e04:	01 96       	adiw	r24, 0x01	; 1
     e06:	a1 1d       	adc	r26, r1
     e08:	b1 1d       	adc	r27, r1
     e0a:	86 87       	std	Z+14, r24	; 0x0e
     e0c:	97 87       	std	Z+15, r25	; 0x0f
     e0e:	a0 8b       	std	Z+16, r26	; 0x10
     e10:	b1 8b       	std	Z+17, r27	; 0x11
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e12:	0f b6       	in	r0, 0x3f	; 63
     e14:	f8 94       	cli
     e16:	0f 92       	push	r0
			temporary_copy = the_data;
     e18:	80 91 47 31 	lds	r24, 0x3147	; 0x803147 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     e1c:	0f 90       	pop	r0
     e1e:	0f be       	out	0x3f, r0	; 63
		
		if (!leftLimitSwitch.get() && !rightLimitSwitch.get())
     e20:	81 11       	cpse	r24, r1
     e22:	0f c0       	rjmp	.+30     	; 0xe42 <_ZN9PWMdriver3runEv+0xa8>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e24:	0f b6       	in	r0, 0x3f	; 63
     e26:	f8 94       	cli
     e28:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e2a:	0f 90       	pop	r0
     e2c:	0f be       	out	0x3f, r0	; 63
     e2e:	90 91 46 31 	lds	r25, 0x3146	; 0x803146 <rightLimitSwitch>
     e32:	91 11       	cpse	r25, r1
     e34:	06 c0       	rjmp	.+12     	; 0xe42 <_ZN9PWMdriver3runEv+0xa8>
		{
			TCC0.CCA = 800;
     e36:	f7 01       	movw	r30, r14
     e38:	c0 a6       	std	Z+40, r12	; 0x28
     e3a:	d1 a6       	std	Z+41, r13	; 0x29
			TCC0.CCB = 0;
     e3c:	12 a6       	std	Z+42, r1	; 0x2a
     e3e:	13 a6       	std	Z+43, r1	; 0x2b
     e40:	15 c0       	rjmp	.+42     	; 0xe6c <_ZN9PWMdriver3runEv+0xd2>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e42:	0f b6       	in	r0, 0x3f	; 63
     e44:	f8 94       	cli
     e46:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e48:	0f 90       	pop	r0
     e4a:	0f be       	out	0x3f, r0	; 63
		}
		else if (leftLimitSwitch.get() || rightLimitSwitch.get())
     e4c:	81 11       	cpse	r24, r1
     e4e:	09 c0       	rjmp	.+18     	; 0xe62 <_ZN9PWMdriver3runEv+0xc8>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e50:	0f b6       	in	r0, 0x3f	; 63
     e52:	f8 94       	cli
     e54:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e56:	0f 90       	pop	r0
     e58:	0f be       	out	0x3f, r0	; 63
     e5a:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rightLimitSwitch>
     e5e:	88 23       	and	r24, r24
     e60:	29 f0       	breq	.+10     	; 0xe6c <_ZN9PWMdriver3runEv+0xd2>
		{
			TCC0.CCA = 0;
     e62:	f7 01       	movw	r30, r14
     e64:	10 a6       	std	Z+40, r1	; 0x28
     e66:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = 0;
     e68:	12 a6       	std	Z+42, r1	; 0x2a
     e6a:	13 a6       	std	Z+43, r1	; 0x2b
     e6c:	4c e1       	ldi	r20, 0x1C	; 28
     e6e:	50 e0       	ldi	r21, 0x00	; 0
     e70:	60 e0       	ldi	r22, 0x00	; 0
     e72:	70 e0       	ldi	r23, 0x00	; 0
     e74:	ce 01       	movw	r24, r28
     e76:	01 96       	adiw	r24, 0x01	; 1
     e78:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskDelayUntil>
     e7c:	be cf       	rjmp	.-132    	; 0xdfa <_ZN9PWMdriver3runEv+0x60>

00000e7e <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

PWMdriver::PWMdriver(const char* a_name,
     e7e:	0f 93       	push	r16
     e80:	1f 93       	push	r17
     e82:	cf 93       	push	r28
     e84:	df 93       	push	r29
     e86:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     e88:	0e 94 14 15 	call	0x2a28	; 0x2a28 <_ZN8frt_taskC1EPKchjP8emstream>
     e8c:	8a e2       	ldi	r24, 0x2A	; 42
     e8e:	90 e2       	ldi	r25, 0x20	; 32
     e90:	88 83       	st	Y, r24
     e92:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     e94:	df 91       	pop	r29
     e96:	cf 91       	pop	r28
     e98:	1f 91       	pop	r17
     e9a:	0f 91       	pop	r16
     e9c:	08 95       	ret

00000e9e <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     e9e:	0f 93       	push	r16
     ea0:	1f 93       	push	r17
     ea2:	cf 93       	push	r28
     ea4:	df 93       	push	r29
     ea6:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     ea8:	0e 94 14 15 	call	0x2a28	; 0x2a28 <_ZN8frt_taskC1EPKchjP8emstream>
     eac:	82 e3       	ldi	r24, 0x32	; 50
     eae:	90 e2       	ldi	r25, 0x20	; 32
     eb0:	88 83       	st	Y, r24
     eb2:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     eb4:	df 91       	pop	r29
     eb6:	cf 91       	pop	r28
     eb8:	1f 91       	pop	r17
     eba:	0f 91       	pop	r16
     ebc:	08 95       	ret

00000ebe <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     ebe:	0f 93       	push	r16
     ec0:	1f 93       	push	r17
     ec2:	cf 93       	push	r28
     ec4:	df 93       	push	r29
     ec6:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     ec8:	6a e0       	ldi	r22, 0x0A	; 10
     eca:	8e 81       	ldd	r24, Y+6	; 0x06
     ecc:	9f 81       	ldd	r25, Y+7	; 0x07
     ece:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     ed2:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     ed4:	6d ee       	ldi	r22, 0xED	; 237
     ed6:	73 e0       	ldi	r23, 0x03	; 3
     ed8:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     edc:	6a e0       	ldi	r22, 0x0A	; 10
     ede:	c8 01       	movw	r24, r16
     ee0:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     ee4:	8c 01       	movw	r16, r24
     ee6:	67 ee       	ldi	r22, 0xE7	; 231
     ee8:	73 e0       	ldi	r23, 0x03	; 3
     eea:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     eee:	67 e0       	ldi	r22, 0x07	; 7
     ef0:	c8 01       	movw	r24, r16
     ef2:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     ef6:	6a e0       	ldi	r22, 0x0A	; 10
     ef8:	8e 81       	ldd	r24, Y+6	; 0x06
     efa:	9f 81       	ldd	r25, Y+7	; 0x07
     efc:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     f00:	8c 01       	movw	r16, r24
     f02:	68 ec       	ldi	r22, 0xC8	; 200
     f04:	73 e0       	ldi	r23, 0x03	; 3
     f06:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     f0a:	6a e0       	ldi	r22, 0x0A	; 10
     f0c:	c8 01       	movw	r24, r16
     f0e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     f12:	8c 01       	movw	r16, r24
     f14:	62 ec       	ldi	r22, 0xC2	; 194
     f16:	73 e0       	ldi	r23, 0x03	; 3
     f18:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     f1c:	66 e0       	ldi	r22, 0x06	; 6
     f1e:	c8 01       	movw	r24, r16
     f20:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     f24:	6a e0       	ldi	r22, 0x0A	; 10
     f26:	8e 81       	ldd	r24, Y+6	; 0x06
     f28:	9f 81       	ldd	r25, Y+7	; 0x07
     f2a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     f2e:	8c 01       	movw	r16, r24
     f30:	6b ea       	ldi	r22, 0xAB	; 171
     f32:	73 e0       	ldi	r23, 0x03	; 3
     f34:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     f38:	66 e0       	ldi	r22, 0x06	; 6
     f3a:	c8 01       	movw	r24, r16
     f3c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     f40:	6a e0       	ldi	r22, 0x0A	; 10
     f42:	8e 81       	ldd	r24, Y+6	; 0x06
     f44:	9f 81       	ldd	r25, Y+7	; 0x07
     f46:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     f4a:	8c 01       	movw	r16, r24
     f4c:	6f e8       	ldi	r22, 0x8F	; 143
     f4e:	73 e0       	ldi	r23, 0x03	; 3
     f50:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     f54:	66 e0       	ldi	r22, 0x06	; 6
     f56:	c8 01       	movw	r24, r16
     f58:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     f5c:	6a e0       	ldi	r22, 0x0A	; 10
     f5e:	8e 81       	ldd	r24, Y+6	; 0x06
     f60:	9f 81       	ldd	r25, Y+7	; 0x07
     f62:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     f66:	8c 01       	movw	r16, r24
     f68:	67 e7       	ldi	r22, 0x77	; 119
     f6a:	73 e0       	ldi	r23, 0x03	; 3
     f6c:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     f70:	66 e0       	ldi	r22, 0x06	; 6
     f72:	c8 01       	movw	r24, r16
     f74:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     f78:	6a e0       	ldi	r22, 0x0A	; 10
     f7a:	8e 81       	ldd	r24, Y+6	; 0x06
     f7c:	9f 81       	ldd	r25, Y+7	; 0x07
     f7e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     f82:	8c 01       	movw	r16, r24
     f84:	66 e5       	ldi	r22, 0x56	; 86
     f86:	73 e0       	ldi	r23, 0x03	; 3
     f88:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     f8c:	66 e0       	ldi	r22, 0x06	; 6
     f8e:	c8 01       	movw	r24, r16
     f90:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     f94:	6a e0       	ldi	r22, 0x0A	; 10
     f96:	8e 81       	ldd	r24, Y+6	; 0x06
     f98:	9f 81       	ldd	r25, Y+7	; 0x07
     f9a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     f9e:	8c 01       	movw	r16, r24
     fa0:	6f e2       	ldi	r22, 0x2F	; 47
     fa2:	73 e0       	ldi	r23, 0x03	; 3
     fa4:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     fa8:	66 e0       	ldi	r22, 0x06	; 6
     faa:	c8 01       	movw	r24, r16
     fac:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     fb0:	6a e0       	ldi	r22, 0x0A	; 10
     fb2:	8e 81       	ldd	r24, Y+6	; 0x06
     fb4:	9f 81       	ldd	r25, Y+7	; 0x07
     fb6:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     fba:	8c 01       	movw	r16, r24
     fbc:	61 e1       	ldi	r22, 0x11	; 17
     fbe:	73 e0       	ldi	r23, 0x03	; 3
     fc0:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     fc4:	66 e0       	ldi	r22, 0x06	; 6
     fc6:	c8 01       	movw	r24, r16
     fc8:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     fcc:	6a e0       	ldi	r22, 0x0A	; 10
     fce:	8e 81       	ldd	r24, Y+6	; 0x06
     fd0:	9f 81       	ldd	r25, Y+7	; 0x07
     fd2:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     fd6:	8c 01       	movw	r16, r24
     fd8:	66 ef       	ldi	r22, 0xF6	; 246
     fda:	72 e0       	ldi	r23, 0x02	; 2
     fdc:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     fe0:	66 e0       	ldi	r22, 0x06	; 6
     fe2:	c8 01       	movw	r24, r16
     fe4:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     fe8:	6a e0       	ldi	r22, 0x0A	; 10
     fea:	8e 81       	ldd	r24, Y+6	; 0x06
     fec:	9f 81       	ldd	r25, Y+7	; 0x07
     fee:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
     ff2:	ec 01       	movw	r28, r24
     ff4:	67 ee       	ldi	r22, 0xE7	; 231
     ff6:	72 e0       	ldi	r23, 0x02	; 2
     ff8:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
     ffc:	66 e0       	ldi	r22, 0x06	; 6
     ffe:	ce 01       	movw	r24, r28
    1000:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
}
    1004:	df 91       	pop	r29
    1006:	cf 91       	pop	r28
    1008:	1f 91       	pop	r17
    100a:	0f 91       	pop	r16
    100c:	08 95       	ret

0000100e <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    100e:	af 92       	push	r10
    1010:	bf 92       	push	r11
    1012:	cf 92       	push	r12
    1014:	df 92       	push	r13
    1016:	ef 92       	push	r14
    1018:	ff 92       	push	r15
    101a:	0f 93       	push	r16
    101c:	1f 93       	push	r17
    101e:	cf 93       	push	r28
    1020:	df 93       	push	r29
    1022:	00 d0       	rcall	.+0      	; 0x1024 <_ZN9task_user11show_statusEv+0x16>
    1024:	00 d0       	rcall	.+0      	; 0x1026 <_ZN9task_user11show_statusEv+0x18>
    1026:	cd b7       	in	r28, 0x3d	; 61
    1028:	de b7       	in	r29, 0x3e	; 62
    102a:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    102c:	19 82       	std	Y+1, r1	; 0x01
    102e:	1a 82       	std	Y+2, r1	; 0x02
    1030:	1b 82       	std	Y+3, r1	; 0x03
    1032:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1034:	1d 82       	std	Y+5, r1	; 0x05
    1036:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1038:	0e 94 8c 0a 	call	0x1518	; 0x1518 <xPortGetFreeHeapSize>
    103c:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    103e:	ce 01       	movw	r24, r28
    1040:	01 96       	adiw	r24, 0x01	; 1
    1042:	0e 94 c5 18 	call	0x318a	; 0x318a <_ZN10time_stamp10set_to_nowEv>
    1046:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1048:	66 e0       	ldi	r22, 0x06	; 6
    104a:	f8 01       	movw	r30, r16
    104c:	86 81       	ldd	r24, Z+6	; 0x06
    104e:	97 81       	ldd	r25, Z+7	; 0x07
    1050:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    1054:	6a e0       	ldi	r22, 0x0A	; 10
    1056:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    105a:	7c 01       	movw	r14, r24
    105c:	68 ec       	ldi	r22, 0xC8	; 200
    105e:	72 e0       	ldi	r23, 0x02	; 2
    1060:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    1064:	6a e0       	ldi	r22, 0x0A	; 10
    1066:	c7 01       	movw	r24, r14
    1068:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    106c:	7c 01       	movw	r14, r24
    106e:	6c eb       	ldi	r22, 0xBC	; 188
    1070:	72 e0       	ldi	r23, 0x02	; 2
    1072:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    1076:	66 e0       	ldi	r22, 0x06	; 6
    1078:	c7 01       	movw	r24, r14
    107a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    107e:	6a e0       	ldi	r22, 0x0A	; 10
    1080:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    1084:	7c 01       	movw	r14, r24
    1086:	65 eb       	ldi	r22, 0xB5	; 181
    1088:	72 e0       	ldi	r23, 0x02	; 2
    108a:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    108e:	b5 01       	movw	r22, r10
    1090:	c7 01       	movw	r24, r14
    1092:	0e 94 69 18 	call	0x30d2	; 0x30d2 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1096:	6a e0       	ldi	r22, 0x0A	; 10
    1098:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    109c:	7c 01       	movw	r14, r24
    109e:	67 ea       	ldi	r22, 0xA7	; 167
    10a0:	72 e0       	ldi	r23, 0x02	; 2
    10a2:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    10a6:	b6 01       	movw	r22, r12
    10a8:	c7 01       	movw	r24, r14
    10aa:	0e 94 c5 1a 	call	0x358a	; 0x358a <_ZN8emstreamlsEj>
    10ae:	6a e0       	ldi	r22, 0x0A	; 10
    10b0:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    10b4:	7c 01       	movw	r14, r24
    10b6:	65 ea       	ldi	r22, 0xA5	; 165
    10b8:	72 e0       	ldi	r23, 0x02	; 2
    10ba:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    10be:	4f ef       	ldi	r20, 0xFF	; 255
    10c0:	5f e0       	ldi	r21, 0x0F	; 15
    10c2:	60 e0       	ldi	r22, 0x00	; 0
    10c4:	70 e0       	ldi	r23, 0x00	; 0
    10c6:	c7 01       	movw	r24, r14
    10c8:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    10cc:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    10d0:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    10d4:	6a e0       	ldi	r22, 0x0A	; 10
    10d6:	f8 01       	movw	r30, r16
    10d8:	86 81       	ldd	r24, Z+6	; 0x06
    10da:	97 81       	ldd	r25, Z+7	; 0x07
    10dc:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    10e0:	7c 01       	movw	r14, r24
    10e2:	6a e9       	ldi	r22, 0x9A	; 154
    10e4:	72 e0       	ldi	r23, 0x02	; 2
    10e6:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    10ea:	b6 01       	movw	r22, r12
    10ec:	c7 01       	movw	r24, r14
    10ee:	0e 94 c5 1a 	call	0x358a	; 0x358a <_ZN8emstreamlsEj>
    10f2:	66 e0       	ldi	r22, 0x06	; 6
    10f4:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    10f8:	66 e0       	ldi	r22, 0x06	; 6
    10fa:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    10fe:	f8 01       	movw	r30, r16
    1100:	86 81       	ldd	r24, Z+6	; 0x06
    1102:	97 81       	ldd	r25, Z+7	; 0x07
    1104:	0e 94 22 17 	call	0x2e44	; 0x2e44 <_Z15print_task_listP8emstream>
}
    1108:	26 96       	adiw	r28, 0x06	; 6
    110a:	cd bf       	out	0x3d, r28	; 61
    110c:	de bf       	out	0x3e, r29	; 62
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	1f 91       	pop	r17
    1114:	0f 91       	pop	r16
    1116:	ff 90       	pop	r15
    1118:	ef 90       	pop	r14
    111a:	df 90       	pop	r13
    111c:	cf 90       	pop	r12
    111e:	bf 90       	pop	r11
    1120:	af 90       	pop	r10
    1122:	08 95       	ret

00001124 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1124:	cf 93       	push	r28
    1126:	df 93       	push	r29
    1128:	00 d0       	rcall	.+0      	; 0x112a <_ZN9task_user3runEv+0x6>
    112a:	00 d0       	rcall	.+0      	; 0x112c <_ZN9task_user3runEv+0x8>
    112c:	cd b7       	in	r28, 0x3d	; 61
    112e:	de b7       	in	r29, 0x3e	; 62
    1130:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1132:	19 82       	std	Y+1, r1	; 0x01
    1134:	1a 82       	std	Y+2, r1	; 0x02
    1136:	1b 82       	std	Y+3, r1	; 0x03
    1138:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    113a:	1d 82       	std	Y+5, r1	; 0x05
    113c:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    113e:	6a e0       	ldi	r22, 0x0A	; 10
    1140:	dc 01       	movw	r26, r24
    1142:	16 96       	adiw	r26, 0x06	; 6
    1144:	8d 91       	ld	r24, X+
    1146:	9c 91       	ld	r25, X
    1148:	17 97       	sbiw	r26, 0x07	; 7
    114a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    114e:	7c 01       	movw	r14, r24
    1150:	66 e3       	ldi	r22, 0x36	; 54
    1152:	74 e0       	ldi	r23, 0x04	; 4
    1154:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    1158:	66 e0       	ldi	r22, 0x06	; 6
    115a:	c7 01       	movw	r24, r14
    115c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1160:	f8 01       	movw	r30, r16
    1162:	84 85       	ldd	r24, Z+12	; 0x0c
    1164:	88 23       	and	r24, r24
    1166:	21 f0       	breq	.+8      	; 0x1170 <_ZN9task_user3runEv+0x4c>
    1168:	81 30       	cpi	r24, 0x01	; 1
    116a:	09 f4       	brne	.+2      	; 0x116e <_ZN9task_user3runEv+0x4a>
    116c:	5d c0       	rjmp	.+186    	; 0x1228 <_ZN9task_user3runEv+0x104>
    116e:	d8 c0       	rjmp	.+432    	; 0x1320 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1170:	86 81       	ldd	r24, Z+6	; 0x06
    1172:	97 81       	ldd	r25, Z+7	; 0x07
    1174:	dc 01       	movw	r26, r24
    1176:	ed 91       	ld	r30, X+
    1178:	fc 91       	ld	r31, X
    117a:	04 80       	ldd	r0, Z+4	; 0x04
    117c:	f5 81       	ldd	r31, Z+5	; 0x05
    117e:	e0 2d       	mov	r30, r0
    1180:	19 95       	eicall
    1182:	88 23       	and	r24, r24
    1184:	a9 f1       	breq	.+106    	; 0x11f0 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1186:	f8 01       	movw	r30, r16
    1188:	86 81       	ldd	r24, Z+6	; 0x06
    118a:	97 81       	ldd	r25, Z+7	; 0x07
    118c:	dc 01       	movw	r26, r24
    118e:	ed 91       	ld	r30, X+
    1190:	fc 91       	ld	r31, X
    1192:	06 80       	ldd	r0, Z+6	; 0x06
    1194:	f7 81       	ldd	r31, Z+7	; 0x07
    1196:	e0 2d       	mov	r30, r0
    1198:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    119a:	99 27       	eor	r25, r25
    119c:	81 30       	cpi	r24, 0x01	; 1
    119e:	91 05       	cpc	r25, r1
    11a0:	f9 f0       	breq	.+62     	; 0x11e0 <_ZN9task_user3runEv+0xbc>
    11a2:	03 97       	sbiw	r24, 0x03	; 3
    11a4:	09 f0       	breq	.+2      	; 0x11a8 <_ZN9task_user3runEv+0x84>
    11a6:	d8 c0       	rjmp	.+432    	; 0x1358 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    11a8:	6a e0       	ldi	r22, 0x0A	; 10
    11aa:	f8 01       	movw	r30, r16
    11ac:	86 81       	ldd	r24, Z+6	; 0x06
    11ae:	97 81       	ldd	r25, Z+7	; 0x07
    11b0:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    11b4:	8c 01       	movw	r16, r24
    11b6:	68 e2       	ldi	r22, 0x28	; 40
    11b8:	74 e0       	ldi	r23, 0x04	; 4
    11ba:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    11be:	66 e0       	ldi	r22, 0x06	; 6
    11c0:	c8 01       	movw	r24, r16
    11c2:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    11c6:	93 e0       	ldi	r25, 0x03	; 3
    11c8:	88 ed       	ldi	r24, 0xD8	; 216
    11ca:	08 b6       	in	r0, 0x38	; 56
    11cc:	18 be       	out	0x38, r1	; 56
    11ce:	84 bf       	out	0x34, r24	; 52
    11d0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    11d4:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    11d8:	81 fd       	sbrc	r24, 1
    11da:	fc cf       	rjmp	.-8      	; 0x11d4 <_ZN9task_user3runEv+0xb0>
    11dc:	08 be       	out	0x38, r0	; 56
    11de:	ff cf       	rjmp	.-2      	; 0x11de <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    11e0:	c8 01       	movw	r24, r16
    11e2:	0e 94 5f 07 	call	0xebe	; 0xebe <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    11e6:	61 e0       	ldi	r22, 0x01	; 1
    11e8:	c8 01       	movw	r24, r16
    11ea:	0e 94 10 15 	call	0x2a20	; 0x2a20 <_ZN8frt_task13transition_toEh>
							break;
    11ee:	b4 c0       	rjmp	.+360    	; 0x1358 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    11f0:	80 e5       	ldi	r24, 0x50	; 80
    11f2:	91 e3       	ldi	r25, 0x31	; 49
    11f4:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN14frt_text_queue14check_for_charEv>
    11f8:	88 23       	and	r24, r24
    11fa:	09 f4       	brne	.+2      	; 0x11fe <_ZN9task_user3runEv+0xda>
    11fc:	ad c0       	rjmp	.+346    	; 0x1358 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    11fe:	d8 01       	movw	r26, r16
    1200:	16 96       	adiw	r26, 0x06	; 6
    1202:	ed 91       	ld	r30, X+
    1204:	fc 91       	ld	r31, X
    1206:	17 97       	sbiw	r26, 0x07	; 7
    1208:	01 90       	ld	r0, Z+
    120a:	f0 81       	ld	r31, Z
    120c:	e0 2d       	mov	r30, r0
    120e:	e2 80       	ldd	r14, Z+2	; 0x02
    1210:	f3 80       	ldd	r15, Z+3	; 0x03
    1212:	80 e5       	ldi	r24, 0x50	; 80
    1214:	91 e3       	ldi	r25, 0x31	; 49
    1216:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <_ZN14frt_text_queue7getcharEv>
    121a:	68 2f       	mov	r22, r24
    121c:	f8 01       	movw	r30, r16
    121e:	86 81       	ldd	r24, Z+6	; 0x06
    1220:	97 81       	ldd	r25, Z+7	; 0x07
    1222:	f7 01       	movw	r30, r14
    1224:	19 95       	eicall
    1226:	98 c0       	rjmp	.+304    	; 0x1358 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1228:	86 81       	ldd	r24, Z+6	; 0x06
    122a:	97 81       	ldd	r25, Z+7	; 0x07
    122c:	dc 01       	movw	r26, r24
    122e:	ed 91       	ld	r30, X+
    1230:	fc 91       	ld	r31, X
    1232:	04 80       	ldd	r0, Z+4	; 0x04
    1234:	f5 81       	ldd	r31, Z+5	; 0x05
    1236:	e0 2d       	mov	r30, r0
    1238:	19 95       	eicall
    123a:	88 23       	and	r24, r24
    123c:	09 f4       	brne	.+2      	; 0x1240 <_ZN9task_user3runEv+0x11c>
    123e:	8c c0       	rjmp	.+280    	; 0x1358 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1240:	f8 01       	movw	r30, r16
    1242:	86 81       	ldd	r24, Z+6	; 0x06
    1244:	97 81       	ldd	r25, Z+7	; 0x07
    1246:	dc 01       	movw	r26, r24
    1248:	ed 91       	ld	r30, X+
    124a:	fc 91       	ld	r31, X
    124c:	06 80       	ldd	r0, Z+6	; 0x06
    124e:	f7 81       	ldd	r31, Z+7	; 0x07
    1250:	e0 2d       	mov	r30, r0
    1252:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1254:	9c 01       	movw	r18, r24
    1256:	33 27       	eor	r19, r19
    1258:	28 36       	cpi	r18, 0x68	; 104
    125a:	31 05       	cpc	r19, r1
    125c:	59 f1       	breq	.+86     	; 0x12b4 <_ZN9task_user3runEv+0x190>
    125e:	3c f4       	brge	.+14     	; 0x126e <_ZN9task_user3runEv+0x14a>
    1260:	2b 31       	cpi	r18, 0x1B	; 27
    1262:	31 05       	cpc	r19, r1
    1264:	59 f1       	breq	.+86     	; 0x12bc <_ZN9task_user3runEv+0x198>
    1266:	25 36       	cpi	r18, 0x65	; 101
    1268:	31 05       	cpc	r19, r1
    126a:	41 f1       	breq	.+80     	; 0x12bc <_ZN9task_user3runEv+0x198>
    126c:	3b c0       	rjmp	.+118    	; 0x12e4 <_ZN9task_user3runEv+0x1c0>
    126e:	23 37       	cpi	r18, 0x73	; 115
    1270:	31 05       	cpc	r19, r1
    1272:	c1 f0       	breq	.+48     	; 0x12a4 <_ZN9task_user3runEv+0x180>
    1274:	26 37       	cpi	r18, 0x76	; 118
    1276:	31 05       	cpc	r19, r1
    1278:	89 f0       	breq	.+34     	; 0x129c <_ZN9task_user3runEv+0x178>
    127a:	2e 36       	cpi	r18, 0x6E	; 110
    127c:	31 05       	cpc	r19, r1
    127e:	91 f5       	brne	.+100    	; 0x12e4 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1280:	ce 01       	movw	r24, r28
    1282:	01 96       	adiw	r24, 0x01	; 1
    1284:	0e 94 c5 18 	call	0x318a	; 0x318a <_ZN10time_stamp10set_to_nowEv>
    1288:	bc 01       	movw	r22, r24
    128a:	f8 01       	movw	r30, r16
    128c:	86 81       	ldd	r24, Z+6	; 0x06
    128e:	97 81       	ldd	r25, Z+7	; 0x07
    1290:	0e 94 69 18 	call	0x30d2	; 0x30d2 <_ZlsR8emstreamR10time_stamp>
    1294:	66 e0       	ldi	r22, 0x06	; 6
    1296:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
							break;
    129a:	5e c0       	rjmp	.+188    	; 0x1358 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    129c:	c8 01       	movw	r24, r16
    129e:	0e 94 07 08 	call	0x100e	; 0x100e <_ZN9task_user11show_statusEv>
							break;
    12a2:	5a c0       	rjmp	.+180    	; 0x1358 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    12a4:	d8 01       	movw	r26, r16
    12a6:	16 96       	adiw	r26, 0x06	; 6
    12a8:	8d 91       	ld	r24, X+
    12aa:	9c 91       	ld	r25, X
    12ac:	17 97       	sbiw	r26, 0x07	; 7
    12ae:	0e 94 29 16 	call	0x2c52	; 0x2c52 <_Z17print_task_stacksP8emstream>
							break;
    12b2:	52 c0       	rjmp	.+164    	; 0x1358 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    12b4:	c8 01       	movw	r24, r16
    12b6:	0e 94 5f 07 	call	0xebe	; 0xebe <_ZN9task_user18print_help_messageEv>
							break;
    12ba:	4e c0       	rjmp	.+156    	; 0x1358 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    12bc:	6a e0       	ldi	r22, 0x0A	; 10
    12be:	f8 01       	movw	r30, r16
    12c0:	86 81       	ldd	r24, Z+6	; 0x06
    12c2:	97 81       	ldd	r25, Z+7	; 0x07
    12c4:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    12c8:	7c 01       	movw	r14, r24
    12ca:	66 e1       	ldi	r22, 0x16	; 22
    12cc:	74 e0       	ldi	r23, 0x04	; 4
    12ce:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    12d2:	66 e0       	ldi	r22, 0x06	; 6
    12d4:	c7 01       	movw	r24, r14
    12d6:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    12da:	60 e0       	ldi	r22, 0x00	; 0
    12dc:	c8 01       	movw	r24, r16
    12de:	0e 94 10 15 	call	0x2a20	; 0x2a20 <_ZN8frt_task13transition_toEh>
							break;
    12e2:	3a c0       	rjmp	.+116    	; 0x1358 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    12e4:	f8 01       	movw	r30, r16
    12e6:	a6 81       	ldd	r26, Z+6	; 0x06
    12e8:	b7 81       	ldd	r27, Z+7	; 0x07
    12ea:	ed 91       	ld	r30, X+
    12ec:	fc 91       	ld	r31, X
    12ee:	11 97       	sbiw	r26, 0x01	; 1
    12f0:	02 80       	ldd	r0, Z+2	; 0x02
    12f2:	f3 81       	ldd	r31, Z+3	; 0x03
    12f4:	e0 2d       	mov	r30, r0
    12f6:	68 2f       	mov	r22, r24
    12f8:	cd 01       	movw	r24, r26
    12fa:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    12fc:	6a e0       	ldi	r22, 0x0A	; 10
    12fe:	d8 01       	movw	r26, r16
    1300:	16 96       	adiw	r26, 0x06	; 6
    1302:	8d 91       	ld	r24, X+
    1304:	9c 91       	ld	r25, X
    1306:	17 97       	sbiw	r26, 0x07	; 7
    1308:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    130c:	7c 01       	movw	r14, r24
    130e:	60 e1       	ldi	r22, 0x10	; 16
    1310:	74 e0       	ldi	r23, 0x04	; 4
    1312:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    1316:	66 e0       	ldi	r22, 0x06	; 6
    1318:	c7 01       	movw	r24, r14
    131a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
							break;
    131e:	1c c0       	rjmp	.+56     	; 0x1358 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1320:	6a e0       	ldi	r22, 0x0A	; 10
    1322:	f8 01       	movw	r30, r16
    1324:	86 81       	ldd	r24, Z+6	; 0x06
    1326:	97 81       	ldd	r25, Z+7	; 0x07
    1328:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    132c:	8c 01       	movw	r16, r24
    132e:	63 ef       	ldi	r22, 0xF3	; 243
    1330:	73 e0       	ldi	r23, 0x03	; 3
    1332:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    1336:	66 e0       	ldi	r22, 0x06	; 6
    1338:	c8 01       	movw	r24, r16
    133a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    133e:	93 e0       	ldi	r25, 0x03	; 3
    1340:	88 ed       	ldi	r24, 0xD8	; 216
    1342:	08 b6       	in	r0, 0x38	; 56
    1344:	18 be       	out	0x38, r1	; 56
    1346:	84 bf       	out	0x34, r24	; 52
    1348:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    134c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1350:	81 fd       	sbrc	r24, 1
    1352:	fc cf       	rjmp	.-8      	; 0x134c <_ZN9task_user3runEv+0x228>
    1354:	08 be       	out	0x38, r0	; 56
    1356:	ff cf       	rjmp	.-2      	; 0x1356 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1358:	f8 01       	movw	r30, r16
    135a:	86 85       	ldd	r24, Z+14	; 0x0e
    135c:	97 85       	ldd	r25, Z+15	; 0x0f
    135e:	a0 89       	ldd	r26, Z+16	; 0x10
    1360:	b1 89       	ldd	r27, Z+17	; 0x11
    1362:	01 96       	adiw	r24, 0x01	; 1
    1364:	a1 1d       	adc	r26, r1
    1366:	b1 1d       	adc	r27, r1
    1368:	86 87       	std	Z+14, r24	; 0x0e
    136a:	97 87       	std	Z+15, r25	; 0x0f
    136c:	a0 8b       	std	Z+16, r26	; 0x10
    136e:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1370:	61 e0       	ldi	r22, 0x01	; 1
    1372:	70 e0       	ldi	r23, 0x00	; 0
    1374:	80 e0       	ldi	r24, 0x00	; 0
    1376:	90 e0       	ldi	r25, 0x00	; 0
    1378:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    137c:	f1 ce       	rjmp	.-542    	; 0x1160 <_ZN9task_user3runEv+0x3c>

0000137e <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    137e:	0f 93       	push	r16
    1380:	1f 93       	push	r17
    1382:	cf 93       	push	r28
    1384:	df 93       	push	r29
    1386:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1388:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    138c:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    1390:	81 11       	cpse	r24, r1
    1392:	1d c0       	rjmp	.+58     	; 0x13ce <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1394:	a1 ec       	ldi	r26, 0xC1	; 193
    1396:	b0 e2       	ldi	r27, 0x20	; 32
    1398:	e5 ec       	ldi	r30, 0xC5	; 197
    139a:	f0 e2       	ldi	r31, 0x20	; 32
    139c:	ed 93       	st	X+, r30
    139e:	fc 93       	st	X, r31
    13a0:	11 97       	sbiw	r26, 0x01	; 1
    13a2:	12 96       	adiw	r26, 0x02	; 2
    13a4:	1d 92       	st	X+, r1
    13a6:	1c 92       	st	X, r1
    13a8:	13 97       	sbiw	r26, 0x03	; 3
    13aa:	ad eb       	ldi	r26, 0xBD	; 189
    13ac:	b0 e2       	ldi	r27, 0x20	; 32
    13ae:	8f ef       	ldi	r24, 0xFF	; 255
    13b0:	9f e0       	ldi	r25, 0x0F	; 15
    13b2:	12 96       	adiw	r26, 0x02	; 2
    13b4:	8d 93       	st	X+, r24
    13b6:	9c 93       	st	X, r25
    13b8:	13 97       	sbiw	r26, 0x03	; 3
    13ba:	1d 92       	st	X+, r1
    13bc:	1c 92       	st	X, r1
    13be:	11 97       	sbiw	r26, 0x01	; 1
    13c0:	82 83       	std	Z+2, r24	; 0x02
    13c2:	93 83       	std	Z+3, r25	; 0x03
    13c4:	a0 83       	st	Z, r26
    13c6:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    13c8:	81 e0       	ldi	r24, 0x01	; 1
    13ca:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    13ce:	20 97       	sbiw	r28, 0x00	; 0
    13d0:	09 f4       	brne	.+2      	; 0x13d4 <pvPortMalloc+0x56>
    13d2:	5f c0       	rjmp	.+190    	; 0x1492 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    13d4:	9e 01       	movw	r18, r28
    13d6:	2b 5f       	subi	r18, 0xFB	; 251
    13d8:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    13da:	24 96       	adiw	r28, 0x04	; 4
    13dc:	ce 3f       	cpi	r28, 0xFE	; 254
    13de:	df 40       	sbci	r29, 0x0F	; 15
    13e0:	08 f0       	brcs	.+2      	; 0x13e4 <pvPortMalloc+0x66>
    13e2:	5a c0       	rjmp	.+180    	; 0x1498 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    13e4:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    13e8:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    13ec:	a1 ec       	ldi	r26, 0xC1	; 193
    13ee:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    13f0:	02 c0       	rjmp	.+4      	; 0x13f6 <pvPortMalloc+0x78>
    13f2:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    13f4:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    13f6:	82 81       	ldd	r24, Z+2	; 0x02
    13f8:	93 81       	ldd	r25, Z+3	; 0x03
    13fa:	82 17       	cp	r24, r18
    13fc:	93 07       	cpc	r25, r19
    13fe:	20 f4       	brcc	.+8      	; 0x1408 <pvPortMalloc+0x8a>
    1400:	80 81       	ld	r24, Z
    1402:	91 81       	ldd	r25, Z+1	; 0x01
    1404:	00 97       	sbiw	r24, 0x00	; 0
    1406:	a9 f7       	brne	.-22     	; 0x13f2 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1408:	c0 e2       	ldi	r28, 0x20	; 32
    140a:	ed 3b       	cpi	r30, 0xBD	; 189
    140c:	fc 07       	cpc	r31, r28
    140e:	09 f4       	brne	.+2      	; 0x1412 <pvPortMalloc+0x94>
    1410:	46 c0       	rjmp	.+140    	; 0x149e <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1412:	cd 91       	ld	r28, X+
    1414:	dc 91       	ld	r29, X
    1416:	11 97       	sbiw	r26, 0x01	; 1
    1418:	8e 01       	movw	r16, r28
    141a:	0b 5f       	subi	r16, 0xFB	; 251
    141c:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    141e:	80 81       	ld	r24, Z
    1420:	91 81       	ldd	r25, Z+1	; 0x01
    1422:	8d 93       	st	X+, r24
    1424:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1426:	82 81       	ldd	r24, Z+2	; 0x02
    1428:	93 81       	ldd	r25, Z+3	; 0x03
    142a:	82 1b       	sub	r24, r18
    142c:	93 0b       	sbc	r25, r19
    142e:	8b 30       	cpi	r24, 0x0B	; 11
    1430:	91 05       	cpc	r25, r1
    1432:	10 f1       	brcs	.+68     	; 0x1478 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1434:	bf 01       	movw	r22, r30
    1436:	62 0f       	add	r22, r18
    1438:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    143a:	db 01       	movw	r26, r22
    143c:	12 96       	adiw	r26, 0x02	; 2
    143e:	8d 93       	st	X+, r24
    1440:	9c 93       	st	X, r25
    1442:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1444:	22 83       	std	Z+2, r18	; 0x02
    1446:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1448:	12 96       	adiw	r26, 0x02	; 2
    144a:	4d 91       	ld	r20, X+
    144c:	5c 91       	ld	r21, X
    144e:	13 97       	sbiw	r26, 0x03	; 3
    1450:	81 ec       	ldi	r24, 0xC1	; 193
    1452:	90 e2       	ldi	r25, 0x20	; 32
    1454:	01 c0       	rjmp	.+2      	; 0x1458 <pvPortMalloc+0xda>
    1456:	cd 01       	movw	r24, r26
    1458:	ec 01       	movw	r28, r24
    145a:	a8 81       	ld	r26, Y
    145c:	b9 81       	ldd	r27, Y+1	; 0x01
    145e:	12 96       	adiw	r26, 0x02	; 2
    1460:	2d 91       	ld	r18, X+
    1462:	3c 91       	ld	r19, X
    1464:	13 97       	sbiw	r26, 0x03	; 3
    1466:	24 17       	cp	r18, r20
    1468:	35 07       	cpc	r19, r21
    146a:	a8 f3       	brcs	.-22     	; 0x1456 <pvPortMalloc+0xd8>
    146c:	eb 01       	movw	r28, r22
    146e:	a8 83       	st	Y, r26
    1470:	b9 83       	std	Y+1, r27	; 0x01
    1472:	dc 01       	movw	r26, r24
    1474:	6d 93       	st	X+, r22
    1476:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1478:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    147c:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1480:	22 81       	ldd	r18, Z+2	; 0x02
    1482:	33 81       	ldd	r19, Z+3	; 0x03
    1484:	82 1b       	sub	r24, r18
    1486:	93 0b       	sbc	r25, r19
    1488:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    148c:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1490:	08 c0       	rjmp	.+16     	; 0x14a2 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1492:	00 e0       	ldi	r16, 0x00	; 0
    1494:	10 e0       	ldi	r17, 0x00	; 0
    1496:	05 c0       	rjmp	.+10     	; 0x14a2 <pvPortMalloc+0x124>
    1498:	00 e0       	ldi	r16, 0x00	; 0
    149a:	10 e0       	ldi	r17, 0x00	; 0
    149c:	02 c0       	rjmp	.+4      	; 0x14a2 <pvPortMalloc+0x124>
    149e:	00 e0       	ldi	r16, 0x00	; 0
    14a0:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    14a2:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    14a6:	c8 01       	movw	r24, r16
    14a8:	df 91       	pop	r29
    14aa:	cf 91       	pop	r28
    14ac:	1f 91       	pop	r17
    14ae:	0f 91       	pop	r16
    14b0:	08 95       	ret

000014b2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    14b2:	0f 93       	push	r16
    14b4:	1f 93       	push	r17
    14b6:	cf 93       	push	r28
    14b8:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    14ba:	00 97       	sbiw	r24, 0x00	; 0
    14bc:	41 f1       	breq	.+80     	; 0x150e <vPortFree+0x5c>
    14be:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    14c0:	8c 01       	movw	r16, r24
    14c2:	05 50       	subi	r16, 0x05	; 5
    14c4:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    14c6:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    14ca:	f8 01       	movw	r30, r16
    14cc:	42 81       	ldd	r20, Z+2	; 0x02
    14ce:	53 81       	ldd	r21, Z+3	; 0x03
    14d0:	a1 ec       	ldi	r26, 0xC1	; 193
    14d2:	b0 e2       	ldi	r27, 0x20	; 32
    14d4:	01 c0       	rjmp	.+2      	; 0x14d8 <vPortFree+0x26>
    14d6:	df 01       	movw	r26, r30
    14d8:	ed 91       	ld	r30, X+
    14da:	fc 91       	ld	r31, X
    14dc:	11 97       	sbiw	r26, 0x01	; 1
    14de:	22 81       	ldd	r18, Z+2	; 0x02
    14e0:	33 81       	ldd	r19, Z+3	; 0x03
    14e2:	24 17       	cp	r18, r20
    14e4:	35 07       	cpc	r19, r21
    14e6:	b8 f3       	brcs	.-18     	; 0x14d6 <vPortFree+0x24>
    14e8:	25 97       	sbiw	r28, 0x05	; 5
    14ea:	e8 83       	st	Y, r30
    14ec:	f9 83       	std	Y+1, r31	; 0x01
    14ee:	0d 93       	st	X+, r16
    14f0:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    14f2:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    14f6:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    14fa:	8a 81       	ldd	r24, Y+2	; 0x02
    14fc:	9b 81       	ldd	r25, Y+3	; 0x03
    14fe:	82 0f       	add	r24, r18
    1500:	93 1f       	adc	r25, r19
    1502:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1506:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    150a:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
	}
}
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	1f 91       	pop	r17
    1514:	0f 91       	pop	r16
    1516:	08 95       	ret

00001518 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1518:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    151c:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1520:	08 95       	ret

00001522 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1522:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1524:	03 96       	adiw	r24, 0x03	; 3
    1526:	81 83       	std	Z+1, r24	; 0x01
    1528:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    152a:	4f ef       	ldi	r20, 0xFF	; 255
    152c:	5f ef       	ldi	r21, 0xFF	; 255
    152e:	ba 01       	movw	r22, r20
    1530:	43 83       	std	Z+3, r20	; 0x03
    1532:	54 83       	std	Z+4, r21	; 0x04
    1534:	65 83       	std	Z+5, r22	; 0x05
    1536:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1538:	87 83       	std	Z+7, r24	; 0x07
    153a:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    153c:	81 87       	std	Z+9, r24	; 0x09
    153e:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1540:	10 82       	st	Z, r1
    1542:	08 95       	ret

00001544 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1544:	fc 01       	movw	r30, r24
    1546:	12 86       	std	Z+10, r1	; 0x0a
    1548:	13 86       	std	Z+11, r1	; 0x0b
    154a:	08 95       	ret

0000154c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    154c:	cf 93       	push	r28
    154e:	df 93       	push	r29
    1550:	fc 01       	movw	r30, r24
    1552:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1554:	21 81       	ldd	r18, Z+1	; 0x01
    1556:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1558:	e9 01       	movw	r28, r18
    155a:	8c 81       	ldd	r24, Y+4	; 0x04
    155c:	9d 81       	ldd	r25, Y+5	; 0x05
    155e:	14 96       	adiw	r26, 0x04	; 4
    1560:	8d 93       	st	X+, r24
    1562:	9c 93       	st	X, r25
    1564:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1566:	81 81       	ldd	r24, Z+1	; 0x01
    1568:	92 81       	ldd	r25, Z+2	; 0x02
    156a:	16 96       	adiw	r26, 0x06	; 6
    156c:	8d 93       	st	X+, r24
    156e:	9c 93       	st	X, r25
    1570:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1572:	8c 81       	ldd	r24, Y+4	; 0x04
    1574:	9d 81       	ldd	r25, Y+5	; 0x05
    1576:	ec 01       	movw	r28, r24
    1578:	6e 83       	std	Y+6, r22	; 0x06
    157a:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    157c:	e9 01       	movw	r28, r18
    157e:	6c 83       	std	Y+4, r22	; 0x04
    1580:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1582:	61 83       	std	Z+1, r22	; 0x01
    1584:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1586:	1a 96       	adiw	r26, 0x0a	; 10
    1588:	ed 93       	st	X+, r30
    158a:	fc 93       	st	X, r31
    158c:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    158e:	80 81       	ld	r24, Z
    1590:	8f 5f       	subi	r24, 0xFF	; 255
    1592:	80 83       	st	Z, r24
}
    1594:	df 91       	pop	r29
    1596:	cf 91       	pop	r28
    1598:	08 95       	ret

0000159a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    159a:	0f 93       	push	r16
    159c:	1f 93       	push	r17
    159e:	cf 93       	push	r28
    15a0:	df 93       	push	r29
    15a2:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    15a4:	08 81       	ld	r16, Y
    15a6:	19 81       	ldd	r17, Y+1	; 0x01
    15a8:	2a 81       	ldd	r18, Y+2	; 0x02
    15aa:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15ac:	0f 3f       	cpi	r16, 0xFF	; 255
    15ae:	4f ef       	ldi	r20, 0xFF	; 255
    15b0:	14 07       	cpc	r17, r20
    15b2:	24 07       	cpc	r18, r20
    15b4:	34 07       	cpc	r19, r20
    15b6:	31 f4       	brne	.+12     	; 0x15c4 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15b8:	dc 01       	movw	r26, r24
    15ba:	19 96       	adiw	r26, 0x09	; 9
    15bc:	ed 91       	ld	r30, X+
    15be:	fc 91       	ld	r31, X
    15c0:	1a 97       	sbiw	r26, 0x0a	; 10
    15c2:	1f c0       	rjmp	.+62     	; 0x1602 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    15c4:	fc 01       	movw	r30, r24
    15c6:	33 96       	adiw	r30, 0x03	; 3
    15c8:	dc 01       	movw	r26, r24
    15ca:	17 96       	adiw	r26, 0x07	; 7
    15cc:	4d 91       	ld	r20, X+
    15ce:	5c 91       	ld	r21, X
    15d0:	18 97       	sbiw	r26, 0x08	; 8
    15d2:	da 01       	movw	r26, r20
    15d4:	4d 91       	ld	r20, X+
    15d6:	5d 91       	ld	r21, X+
    15d8:	6d 91       	ld	r22, X+
    15da:	7c 91       	ld	r23, X
    15dc:	04 17       	cp	r16, r20
    15de:	15 07       	cpc	r17, r21
    15e0:	26 07       	cpc	r18, r22
    15e2:	37 07       	cpc	r19, r23
    15e4:	70 f0       	brcs	.+28     	; 0x1602 <vListInsert+0x68>
    15e6:	04 80       	ldd	r0, Z+4	; 0x04
    15e8:	f5 81       	ldd	r31, Z+5	; 0x05
    15ea:	e0 2d       	mov	r30, r0
    15ec:	a4 81       	ldd	r26, Z+4	; 0x04
    15ee:	b5 81       	ldd	r27, Z+5	; 0x05
    15f0:	4d 91       	ld	r20, X+
    15f2:	5d 91       	ld	r21, X+
    15f4:	6d 91       	ld	r22, X+
    15f6:	7c 91       	ld	r23, X
    15f8:	04 17       	cp	r16, r20
    15fa:	15 07       	cpc	r17, r21
    15fc:	26 07       	cpc	r18, r22
    15fe:	37 07       	cpc	r19, r23
    1600:	90 f7       	brcc	.-28     	; 0x15e6 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1602:	a4 81       	ldd	r26, Z+4	; 0x04
    1604:	b5 81       	ldd	r27, Z+5	; 0x05
    1606:	ac 83       	std	Y+4, r26	; 0x04
    1608:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    160a:	16 96       	adiw	r26, 0x06	; 6
    160c:	cd 93       	st	X+, r28
    160e:	dc 93       	st	X, r29
    1610:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1612:	ee 83       	std	Y+6, r30	; 0x06
    1614:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1616:	c4 83       	std	Z+4, r28	; 0x04
    1618:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    161a:	8a 87       	std	Y+10, r24	; 0x0a
    161c:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    161e:	fc 01       	movw	r30, r24
    1620:	20 81       	ld	r18, Z
    1622:	2f 5f       	subi	r18, 0xFF	; 255
    1624:	20 83       	st	Z, r18
}
    1626:	df 91       	pop	r29
    1628:	cf 91       	pop	r28
    162a:	1f 91       	pop	r17
    162c:	0f 91       	pop	r16
    162e:	08 95       	ret

00001630 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1630:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1632:	a4 81       	ldd	r26, Z+4	; 0x04
    1634:	b5 81       	ldd	r27, Z+5	; 0x05
    1636:	86 81       	ldd	r24, Z+6	; 0x06
    1638:	97 81       	ldd	r25, Z+7	; 0x07
    163a:	16 96       	adiw	r26, 0x06	; 6
    163c:	8d 93       	st	X+, r24
    163e:	9c 93       	st	X, r25
    1640:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1642:	a6 81       	ldd	r26, Z+6	; 0x06
    1644:	b7 81       	ldd	r27, Z+7	; 0x07
    1646:	84 81       	ldd	r24, Z+4	; 0x04
    1648:	95 81       	ldd	r25, Z+5	; 0x05
    164a:	14 96       	adiw	r26, 0x04	; 4
    164c:	8d 93       	st	X+, r24
    164e:	9c 93       	st	X, r25
    1650:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1652:	a2 85       	ldd	r26, Z+10	; 0x0a
    1654:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1656:	11 96       	adiw	r26, 0x01	; 1
    1658:	8d 91       	ld	r24, X+
    165a:	9c 91       	ld	r25, X
    165c:	12 97       	sbiw	r26, 0x02	; 2
    165e:	e8 17       	cp	r30, r24
    1660:	f9 07       	cpc	r31, r25
    1662:	31 f4       	brne	.+12     	; 0x1670 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1664:	86 81       	ldd	r24, Z+6	; 0x06
    1666:	97 81       	ldd	r25, Z+7	; 0x07
    1668:	11 96       	adiw	r26, 0x01	; 1
    166a:	8d 93       	st	X+, r24
    166c:	9c 93       	st	X, r25
    166e:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1670:	12 86       	std	Z+10, r1	; 0x0a
    1672:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1674:	8c 91       	ld	r24, X
    1676:	81 50       	subi	r24, 0x01	; 1
    1678:	8c 93       	st	X, r24
    167a:	08 95       	ret

0000167c <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    167c:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <portStackTopForTask>
    1680:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <portStackTopForTask+0x1>
    1684:	31 e1       	ldi	r19, 0x11	; 17
    1686:	fc 01       	movw	r30, r24
    1688:	30 83       	st	Z, r19
    168a:	31 97       	sbiw	r30, 0x01	; 1
    168c:	22 e2       	ldi	r18, 0x22	; 34
    168e:	20 83       	st	Z, r18
    1690:	31 97       	sbiw	r30, 0x01	; 1
    1692:	a3 e3       	ldi	r26, 0x33	; 51
    1694:	a0 83       	st	Z, r26
    1696:	31 97       	sbiw	r30, 0x01	; 1
    1698:	60 83       	st	Z, r22
    169a:	31 97       	sbiw	r30, 0x01	; 1
    169c:	70 83       	st	Z, r23
    169e:	31 97       	sbiw	r30, 0x01	; 1
    16a0:	10 82       	st	Z, r1
    16a2:	31 97       	sbiw	r30, 0x01	; 1
    16a4:	10 82       	st	Z, r1
    16a6:	31 97       	sbiw	r30, 0x01	; 1
    16a8:	60 e8       	ldi	r22, 0x80	; 128
    16aa:	60 83       	st	Z, r22
    16ac:	31 97       	sbiw	r30, 0x01	; 1
    16ae:	10 82       	st	Z, r1
    16b0:	31 97       	sbiw	r30, 0x01	; 1
    16b2:	10 82       	st	Z, r1
    16b4:	31 97       	sbiw	r30, 0x01	; 1
    16b6:	10 82       	st	Z, r1
    16b8:	31 97       	sbiw	r30, 0x01	; 1
    16ba:	62 e0       	ldi	r22, 0x02	; 2
    16bc:	60 83       	st	Z, r22
    16be:	31 97       	sbiw	r30, 0x01	; 1
    16c0:	63 e0       	ldi	r22, 0x03	; 3
    16c2:	60 83       	st	Z, r22
    16c4:	31 97       	sbiw	r30, 0x01	; 1
    16c6:	64 e0       	ldi	r22, 0x04	; 4
    16c8:	60 83       	st	Z, r22
    16ca:	31 97       	sbiw	r30, 0x01	; 1
    16cc:	65 e0       	ldi	r22, 0x05	; 5
    16ce:	60 83       	st	Z, r22
    16d0:	31 97       	sbiw	r30, 0x01	; 1
    16d2:	66 e0       	ldi	r22, 0x06	; 6
    16d4:	60 83       	st	Z, r22
    16d6:	31 97       	sbiw	r30, 0x01	; 1
    16d8:	67 e0       	ldi	r22, 0x07	; 7
    16da:	60 83       	st	Z, r22
    16dc:	31 97       	sbiw	r30, 0x01	; 1
    16de:	68 e0       	ldi	r22, 0x08	; 8
    16e0:	60 83       	st	Z, r22
    16e2:	31 97       	sbiw	r30, 0x01	; 1
    16e4:	69 e0       	ldi	r22, 0x09	; 9
    16e6:	60 83       	st	Z, r22
    16e8:	31 97       	sbiw	r30, 0x01	; 1
    16ea:	60 e1       	ldi	r22, 0x10	; 16
    16ec:	60 83       	st	Z, r22
    16ee:	31 97       	sbiw	r30, 0x01	; 1
    16f0:	30 83       	st	Z, r19
    16f2:	31 97       	sbiw	r30, 0x01	; 1
    16f4:	32 e1       	ldi	r19, 0x12	; 18
    16f6:	30 83       	st	Z, r19
    16f8:	31 97       	sbiw	r30, 0x01	; 1
    16fa:	33 e1       	ldi	r19, 0x13	; 19
    16fc:	30 83       	st	Z, r19
    16fe:	31 97       	sbiw	r30, 0x01	; 1
    1700:	34 e1       	ldi	r19, 0x14	; 20
    1702:	30 83       	st	Z, r19
    1704:	31 97       	sbiw	r30, 0x01	; 1
    1706:	35 e1       	ldi	r19, 0x15	; 21
    1708:	30 83       	st	Z, r19
    170a:	31 97       	sbiw	r30, 0x01	; 1
    170c:	36 e1       	ldi	r19, 0x16	; 22
    170e:	30 83       	st	Z, r19
    1710:	31 97       	sbiw	r30, 0x01	; 1
    1712:	37 e1       	ldi	r19, 0x17	; 23
    1714:	30 83       	st	Z, r19
    1716:	31 97       	sbiw	r30, 0x01	; 1
    1718:	38 e1       	ldi	r19, 0x18	; 24
    171a:	30 83       	st	Z, r19
    171c:	31 97       	sbiw	r30, 0x01	; 1
    171e:	39 e1       	ldi	r19, 0x19	; 25
    1720:	30 83       	st	Z, r19
    1722:	31 97       	sbiw	r30, 0x01	; 1
    1724:	30 e2       	ldi	r19, 0x20	; 32
    1726:	30 83       	st	Z, r19
    1728:	31 97       	sbiw	r30, 0x01	; 1
    172a:	31 e2       	ldi	r19, 0x21	; 33
    172c:	30 83       	st	Z, r19
    172e:	31 97       	sbiw	r30, 0x01	; 1
    1730:	20 83       	st	Z, r18
    1732:	31 97       	sbiw	r30, 0x01	; 1
    1734:	23 e2       	ldi	r18, 0x23	; 35
    1736:	20 83       	st	Z, r18
    1738:	31 97       	sbiw	r30, 0x01	; 1
    173a:	40 83       	st	Z, r20
    173c:	31 97       	sbiw	r30, 0x01	; 1
    173e:	50 83       	st	Z, r21
    1740:	31 97       	sbiw	r30, 0x01	; 1
    1742:	26 e2       	ldi	r18, 0x26	; 38
    1744:	20 83       	st	Z, r18
    1746:	31 97       	sbiw	r30, 0x01	; 1
    1748:	27 e2       	ldi	r18, 0x27	; 39
    174a:	20 83       	st	Z, r18
    174c:	31 97       	sbiw	r30, 0x01	; 1
    174e:	28 e2       	ldi	r18, 0x28	; 40
    1750:	20 83       	st	Z, r18
    1752:	31 97       	sbiw	r30, 0x01	; 1
    1754:	29 e2       	ldi	r18, 0x29	; 41
    1756:	20 83       	st	Z, r18
    1758:	31 97       	sbiw	r30, 0x01	; 1
    175a:	20 e3       	ldi	r18, 0x30	; 48
    175c:	20 83       	st	Z, r18
    175e:	31 97       	sbiw	r30, 0x01	; 1
    1760:	21 e3       	ldi	r18, 0x31	; 49
    1762:	20 83       	st	Z, r18
    1764:	89 97       	sbiw	r24, 0x29	; 41
    1766:	08 95       	ret

00001768 <xPortStartScheduler>:
    1768:	8c e7       	ldi	r24, 0x7C	; 124
    176a:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    176e:	8f ef       	ldi	r24, 0xFF	; 255
    1770:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1774:	81 e0       	ldi	r24, 0x01	; 1
    1776:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    177a:	91 e1       	ldi	r25, 0x11	; 17
    177c:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1780:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1784:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1788:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    178c:	cd 91       	ld	r28, X+
    178e:	cd bf       	out	0x3d, r28	; 61
    1790:	dd 91       	ld	r29, X+
    1792:	de bf       	out	0x3e, r29	; 62
    1794:	ff 91       	pop	r31
    1796:	ef 91       	pop	r30
    1798:	df 91       	pop	r29
    179a:	cf 91       	pop	r28
    179c:	bf 91       	pop	r27
    179e:	af 91       	pop	r26
    17a0:	9f 91       	pop	r25
    17a2:	8f 91       	pop	r24
    17a4:	7f 91       	pop	r23
    17a6:	6f 91       	pop	r22
    17a8:	5f 91       	pop	r21
    17aa:	4f 91       	pop	r20
    17ac:	3f 91       	pop	r19
    17ae:	2f 91       	pop	r18
    17b0:	1f 91       	pop	r17
    17b2:	0f 91       	pop	r16
    17b4:	ff 90       	pop	r15
    17b6:	ef 90       	pop	r14
    17b8:	df 90       	pop	r13
    17ba:	cf 90       	pop	r12
    17bc:	bf 90       	pop	r11
    17be:	af 90       	pop	r10
    17c0:	9f 90       	pop	r9
    17c2:	8f 90       	pop	r8
    17c4:	7f 90       	pop	r7
    17c6:	6f 90       	pop	r6
    17c8:	5f 90       	pop	r5
    17ca:	4f 90       	pop	r4
    17cc:	3f 90       	pop	r3
    17ce:	2f 90       	pop	r2
    17d0:	1f 90       	pop	r1
    17d2:	0f 90       	pop	r0
    17d4:	0c be       	out	0x3c, r0	; 60
    17d6:	0f 90       	pop	r0
    17d8:	0b be       	out	0x3b, r0	; 59
    17da:	0f 90       	pop	r0
    17dc:	0f be       	out	0x3f, r0	; 63
    17de:	0f 90       	pop	r0
    17e0:	08 95       	ret
    17e2:	08 95       	ret

000017e4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    17e4:	0f 92       	push	r0
    17e6:	0f b6       	in	r0, 0x3f	; 63
    17e8:	f8 94       	cli
    17ea:	0f 92       	push	r0
    17ec:	0b b6       	in	r0, 0x3b	; 59
    17ee:	0f 92       	push	r0
    17f0:	0c b6       	in	r0, 0x3c	; 60
    17f2:	0f 92       	push	r0
    17f4:	1f 92       	push	r1
    17f6:	11 24       	eor	r1, r1
    17f8:	2f 92       	push	r2
    17fa:	3f 92       	push	r3
    17fc:	4f 92       	push	r4
    17fe:	5f 92       	push	r5
    1800:	6f 92       	push	r6
    1802:	7f 92       	push	r7
    1804:	8f 92       	push	r8
    1806:	9f 92       	push	r9
    1808:	af 92       	push	r10
    180a:	bf 92       	push	r11
    180c:	cf 92       	push	r12
    180e:	df 92       	push	r13
    1810:	ef 92       	push	r14
    1812:	ff 92       	push	r15
    1814:	0f 93       	push	r16
    1816:	1f 93       	push	r17
    1818:	2f 93       	push	r18
    181a:	3f 93       	push	r19
    181c:	4f 93       	push	r20
    181e:	5f 93       	push	r21
    1820:	6f 93       	push	r22
    1822:	7f 93       	push	r23
    1824:	8f 93       	push	r24
    1826:	9f 93       	push	r25
    1828:	af 93       	push	r26
    182a:	bf 93       	push	r27
    182c:	cf 93       	push	r28
    182e:	df 93       	push	r29
    1830:	ef 93       	push	r30
    1832:	ff 93       	push	r31
    1834:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1838:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    183c:	0d b6       	in	r0, 0x3d	; 61
    183e:	0d 92       	st	X+, r0
    1840:	0e b6       	in	r0, 0x3e	; 62
    1842:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1844:	0e 94 12 13 	call	0x2624	; 0x2624 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1848:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    184c:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1850:	cd 91       	ld	r28, X+
    1852:	cd bf       	out	0x3d, r28	; 61
    1854:	dd 91       	ld	r29, X+
    1856:	de bf       	out	0x3e, r29	; 62
    1858:	ff 91       	pop	r31
    185a:	ef 91       	pop	r30
    185c:	df 91       	pop	r29
    185e:	cf 91       	pop	r28
    1860:	bf 91       	pop	r27
    1862:	af 91       	pop	r26
    1864:	9f 91       	pop	r25
    1866:	8f 91       	pop	r24
    1868:	7f 91       	pop	r23
    186a:	6f 91       	pop	r22
    186c:	5f 91       	pop	r21
    186e:	4f 91       	pop	r20
    1870:	3f 91       	pop	r19
    1872:	2f 91       	pop	r18
    1874:	1f 91       	pop	r17
    1876:	0f 91       	pop	r16
    1878:	ff 90       	pop	r15
    187a:	ef 90       	pop	r14
    187c:	df 90       	pop	r13
    187e:	cf 90       	pop	r12
    1880:	bf 90       	pop	r11
    1882:	af 90       	pop	r10
    1884:	9f 90       	pop	r9
    1886:	8f 90       	pop	r8
    1888:	7f 90       	pop	r7
    188a:	6f 90       	pop	r6
    188c:	5f 90       	pop	r5
    188e:	4f 90       	pop	r4
    1890:	3f 90       	pop	r3
    1892:	2f 90       	pop	r2
    1894:	1f 90       	pop	r1
    1896:	0f 90       	pop	r0
    1898:	0c be       	out	0x3c, r0	; 60
    189a:	0f 90       	pop	r0
    189c:	0b be       	out	0x3b, r0	; 59
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63
    18a2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18a4:	08 95       	ret

000018a6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    18a6:	0f 92       	push	r0
    18a8:	0f b6       	in	r0, 0x3f	; 63
    18aa:	f8 94       	cli
    18ac:	0f 92       	push	r0
    18ae:	0b b6       	in	r0, 0x3b	; 59
    18b0:	0f 92       	push	r0
    18b2:	0c b6       	in	r0, 0x3c	; 60
    18b4:	0f 92       	push	r0
    18b6:	1f 92       	push	r1
    18b8:	11 24       	eor	r1, r1
    18ba:	2f 92       	push	r2
    18bc:	3f 92       	push	r3
    18be:	4f 92       	push	r4
    18c0:	5f 92       	push	r5
    18c2:	6f 92       	push	r6
    18c4:	7f 92       	push	r7
    18c6:	8f 92       	push	r8
    18c8:	9f 92       	push	r9
    18ca:	af 92       	push	r10
    18cc:	bf 92       	push	r11
    18ce:	cf 92       	push	r12
    18d0:	df 92       	push	r13
    18d2:	ef 92       	push	r14
    18d4:	ff 92       	push	r15
    18d6:	0f 93       	push	r16
    18d8:	1f 93       	push	r17
    18da:	2f 93       	push	r18
    18dc:	3f 93       	push	r19
    18de:	4f 93       	push	r20
    18e0:	5f 93       	push	r21
    18e2:	6f 93       	push	r22
    18e4:	7f 93       	push	r23
    18e6:	8f 93       	push	r24
    18e8:	9f 93       	push	r25
    18ea:	af 93       	push	r26
    18ec:	bf 93       	push	r27
    18ee:	cf 93       	push	r28
    18f0:	df 93       	push	r29
    18f2:	ef 93       	push	r30
    18f4:	ff 93       	push	r31
    18f6:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    18fa:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    18fe:	0d b6       	in	r0, 0x3d	; 61
    1900:	0d 92       	st	X+, r0
    1902:	0e b6       	in	r0, 0x3e	; 62
    1904:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1906:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vTaskIncrementTick>
	vTaskSwitchContext();
    190a:	0e 94 12 13 	call	0x2624	; 0x2624 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    190e:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1912:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1916:	cd 91       	ld	r28, X+
    1918:	cd bf       	out	0x3d, r28	; 61
    191a:	dd 91       	ld	r29, X+
    191c:	de bf       	out	0x3e, r29	; 62
    191e:	ff 91       	pop	r31
    1920:	ef 91       	pop	r30
    1922:	df 91       	pop	r29
    1924:	cf 91       	pop	r28
    1926:	bf 91       	pop	r27
    1928:	af 91       	pop	r26
    192a:	9f 91       	pop	r25
    192c:	8f 91       	pop	r24
    192e:	7f 91       	pop	r23
    1930:	6f 91       	pop	r22
    1932:	5f 91       	pop	r21
    1934:	4f 91       	pop	r20
    1936:	3f 91       	pop	r19
    1938:	2f 91       	pop	r18
    193a:	1f 91       	pop	r17
    193c:	0f 91       	pop	r16
    193e:	ff 90       	pop	r15
    1940:	ef 90       	pop	r14
    1942:	df 90       	pop	r13
    1944:	cf 90       	pop	r12
    1946:	bf 90       	pop	r11
    1948:	af 90       	pop	r10
    194a:	9f 90       	pop	r9
    194c:	8f 90       	pop	r8
    194e:	7f 90       	pop	r7
    1950:	6f 90       	pop	r6
    1952:	5f 90       	pop	r5
    1954:	4f 90       	pop	r4
    1956:	3f 90       	pop	r3
    1958:	2f 90       	pop	r2
    195a:	1f 90       	pop	r1
    195c:	0f 90       	pop	r0
    195e:	0c be       	out	0x3c, r0	; 60
    1960:	0f 90       	pop	r0
    1962:	0b be       	out	0x3b, r0	; 59
    1964:	0f 90       	pop	r0
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	0f 90       	pop	r0

	asm volatile ( "ret" );
    196a:	08 95       	ret

0000196c <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    196c:	0e 94 53 0c 	call	0x18a6	; 0x18a6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1970:	18 95       	reti

00001972 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1972:	cf 93       	push	r28
    1974:	df 93       	push	r29
    1976:	ec 01       	movw	r28, r24
    1978:	88 a1       	ldd	r24, Y+32	; 0x20
    197a:	81 11       	cpse	r24, r1
    197c:	0b c0       	rjmp	.+22     	; 0x1994 <prvCopyDataToQueue+0x22>
    197e:	88 81       	ld	r24, Y
    1980:	99 81       	ldd	r25, Y+1	; 0x01
    1982:	89 2b       	or	r24, r25
    1984:	e1 f5       	brne	.+120    	; 0x19fe <prvCopyDataToQueue+0x8c>
    1986:	8a 81       	ldd	r24, Y+2	; 0x02
    1988:	9b 81       	ldd	r25, Y+3	; 0x03
    198a:	0e 94 cd 14 	call	0x299a	; 0x299a <vTaskPriorityDisinherit>
    198e:	1a 82       	std	Y+2, r1	; 0x02
    1990:	1b 82       	std	Y+3, r1	; 0x03
    1992:	35 c0       	rjmp	.+106    	; 0x19fe <prvCopyDataToQueue+0x8c>
    1994:	41 11       	cpse	r20, r1
    1996:	17 c0       	rjmp	.+46     	; 0x19c6 <prvCopyDataToQueue+0x54>
    1998:	48 2f       	mov	r20, r24
    199a:	50 e0       	ldi	r21, 0x00	; 0
    199c:	8c 81       	ldd	r24, Y+4	; 0x04
    199e:	9d 81       	ldd	r25, Y+5	; 0x05
    19a0:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <memcpy>
    19a4:	28 a1       	ldd	r18, Y+32	; 0x20
    19a6:	8c 81       	ldd	r24, Y+4	; 0x04
    19a8:	9d 81       	ldd	r25, Y+5	; 0x05
    19aa:	82 0f       	add	r24, r18
    19ac:	91 1d       	adc	r25, r1
    19ae:	8c 83       	std	Y+4, r24	; 0x04
    19b0:	9d 83       	std	Y+5, r25	; 0x05
    19b2:	2a 81       	ldd	r18, Y+2	; 0x02
    19b4:	3b 81       	ldd	r19, Y+3	; 0x03
    19b6:	82 17       	cp	r24, r18
    19b8:	93 07       	cpc	r25, r19
    19ba:	08 f1       	brcs	.+66     	; 0x19fe <prvCopyDataToQueue+0x8c>
    19bc:	88 81       	ld	r24, Y
    19be:	99 81       	ldd	r25, Y+1	; 0x01
    19c0:	8c 83       	std	Y+4, r24	; 0x04
    19c2:	9d 83       	std	Y+5, r25	; 0x05
    19c4:	1c c0       	rjmp	.+56     	; 0x19fe <prvCopyDataToQueue+0x8c>
    19c6:	48 2f       	mov	r20, r24
    19c8:	50 e0       	ldi	r21, 0x00	; 0
    19ca:	8e 81       	ldd	r24, Y+6	; 0x06
    19cc:	9f 81       	ldd	r25, Y+7	; 0x07
    19ce:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <memcpy>
    19d2:	88 a1       	ldd	r24, Y+32	; 0x20
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	91 95       	neg	r25
    19d8:	81 95       	neg	r24
    19da:	91 09       	sbc	r25, r1
    19dc:	2e 81       	ldd	r18, Y+6	; 0x06
    19de:	3f 81       	ldd	r19, Y+7	; 0x07
    19e0:	28 0f       	add	r18, r24
    19e2:	39 1f       	adc	r19, r25
    19e4:	2e 83       	std	Y+6, r18	; 0x06
    19e6:	3f 83       	std	Y+7, r19	; 0x07
    19e8:	48 81       	ld	r20, Y
    19ea:	59 81       	ldd	r21, Y+1	; 0x01
    19ec:	24 17       	cp	r18, r20
    19ee:	35 07       	cpc	r19, r21
    19f0:	30 f4       	brcc	.+12     	; 0x19fe <prvCopyDataToQueue+0x8c>
    19f2:	2a 81       	ldd	r18, Y+2	; 0x02
    19f4:	3b 81       	ldd	r19, Y+3	; 0x03
    19f6:	82 0f       	add	r24, r18
    19f8:	93 1f       	adc	r25, r19
    19fa:	8e 83       	std	Y+6, r24	; 0x06
    19fc:	9f 83       	std	Y+7, r25	; 0x07
    19fe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a00:	8f 5f       	subi	r24, 0xFF	; 255
    1a02:	8e 8f       	std	Y+30, r24	; 0x1e
    1a04:	df 91       	pop	r29
    1a06:	cf 91       	pop	r28
    1a08:	08 95       	ret

00001a0a <prvCopyDataFromQueue>:
    1a0a:	fc 01       	movw	r30, r24
    1a0c:	80 81       	ld	r24, Z
    1a0e:	91 81       	ldd	r25, Z+1	; 0x01
    1a10:	00 97       	sbiw	r24, 0x00	; 0
    1a12:	a1 f0       	breq	.+40     	; 0x1a3c <prvCopyDataFromQueue+0x32>
    1a14:	40 a1       	ldd	r20, Z+32	; 0x20
    1a16:	50 e0       	ldi	r21, 0x00	; 0
    1a18:	26 81       	ldd	r18, Z+6	; 0x06
    1a1a:	37 81       	ldd	r19, Z+7	; 0x07
    1a1c:	24 0f       	add	r18, r20
    1a1e:	35 1f       	adc	r19, r21
    1a20:	26 83       	std	Z+6, r18	; 0x06
    1a22:	37 83       	std	Z+7, r19	; 0x07
    1a24:	a2 81       	ldd	r26, Z+2	; 0x02
    1a26:	b3 81       	ldd	r27, Z+3	; 0x03
    1a28:	2a 17       	cp	r18, r26
    1a2a:	3b 07       	cpc	r19, r27
    1a2c:	10 f0       	brcs	.+4      	; 0x1a32 <prvCopyDataFromQueue+0x28>
    1a2e:	86 83       	std	Z+6, r24	; 0x06
    1a30:	97 83       	std	Z+7, r25	; 0x07
    1a32:	cb 01       	movw	r24, r22
    1a34:	66 81       	ldd	r22, Z+6	; 0x06
    1a36:	77 81       	ldd	r23, Z+7	; 0x07
    1a38:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <memcpy>
    1a3c:	08 95       	ret

00001a3e <prvUnlockQueue>:
    1a3e:	0f 93       	push	r16
    1a40:	1f 93       	push	r17
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
    1a46:	ec 01       	movw	r28, r24
    1a48:	0f b6       	in	r0, 0x3f	; 63
    1a4a:	f8 94       	cli
    1a4c:	0f 92       	push	r0
    1a4e:	8a a1       	ldd	r24, Y+34	; 0x22
    1a50:	18 16       	cp	r1, r24
    1a52:	b4 f4       	brge	.+44     	; 0x1a80 <prvUnlockQueue+0x42>
    1a54:	8b 89       	ldd	r24, Y+19	; 0x13
    1a56:	81 11       	cpse	r24, r1
    1a58:	05 c0       	rjmp	.+10     	; 0x1a64 <prvUnlockQueue+0x26>
    1a5a:	12 c0       	rjmp	.+36     	; 0x1a80 <prvUnlockQueue+0x42>
    1a5c:	8b 89       	ldd	r24, Y+19	; 0x13
    1a5e:	81 11       	cpse	r24, r1
    1a60:	04 c0       	rjmp	.+8      	; 0x1a6a <prvUnlockQueue+0x2c>
    1a62:	0e c0       	rjmp	.+28     	; 0x1a80 <prvUnlockQueue+0x42>
    1a64:	8e 01       	movw	r16, r28
    1a66:	0d 5e       	subi	r16, 0xED	; 237
    1a68:	1f 4f       	sbci	r17, 0xFF	; 255
    1a6a:	c8 01       	movw	r24, r16
    1a6c:	0e 94 99 13 	call	0x2732	; 0x2732 <xTaskRemoveFromEventList>
    1a70:	81 11       	cpse	r24, r1
    1a72:	0e 94 56 14 	call	0x28ac	; 0x28ac <vTaskMissedYield>
    1a76:	8a a1       	ldd	r24, Y+34	; 0x22
    1a78:	81 50       	subi	r24, 0x01	; 1
    1a7a:	8a a3       	std	Y+34, r24	; 0x22
    1a7c:	18 16       	cp	r1, r24
    1a7e:	74 f3       	brlt	.-36     	; 0x1a5c <prvUnlockQueue+0x1e>
    1a80:	8f ef       	ldi	r24, 0xFF	; 255
    1a82:	8a a3       	std	Y+34, r24	; 0x22
    1a84:	0f 90       	pop	r0
    1a86:	0f be       	out	0x3f, r0	; 63
    1a88:	0f b6       	in	r0, 0x3f	; 63
    1a8a:	f8 94       	cli
    1a8c:	0f 92       	push	r0
    1a8e:	89 a1       	ldd	r24, Y+33	; 0x21
    1a90:	18 16       	cp	r1, r24
    1a92:	b4 f4       	brge	.+44     	; 0x1ac0 <prvUnlockQueue+0x82>
    1a94:	88 85       	ldd	r24, Y+8	; 0x08
    1a96:	81 11       	cpse	r24, r1
    1a98:	05 c0       	rjmp	.+10     	; 0x1aa4 <prvUnlockQueue+0x66>
    1a9a:	12 c0       	rjmp	.+36     	; 0x1ac0 <prvUnlockQueue+0x82>
    1a9c:	88 85       	ldd	r24, Y+8	; 0x08
    1a9e:	81 11       	cpse	r24, r1
    1aa0:	04 c0       	rjmp	.+8      	; 0x1aaa <prvUnlockQueue+0x6c>
    1aa2:	0e c0       	rjmp	.+28     	; 0x1ac0 <prvUnlockQueue+0x82>
    1aa4:	8e 01       	movw	r16, r28
    1aa6:	08 5f       	subi	r16, 0xF8	; 248
    1aa8:	1f 4f       	sbci	r17, 0xFF	; 255
    1aaa:	c8 01       	movw	r24, r16
    1aac:	0e 94 99 13 	call	0x2732	; 0x2732 <xTaskRemoveFromEventList>
    1ab0:	81 11       	cpse	r24, r1
    1ab2:	0e 94 56 14 	call	0x28ac	; 0x28ac <vTaskMissedYield>
    1ab6:	89 a1       	ldd	r24, Y+33	; 0x21
    1ab8:	81 50       	subi	r24, 0x01	; 1
    1aba:	89 a3       	std	Y+33, r24	; 0x21
    1abc:	18 16       	cp	r1, r24
    1abe:	74 f3       	brlt	.-36     	; 0x1a9c <prvUnlockQueue+0x5e>
    1ac0:	8f ef       	ldi	r24, 0xFF	; 255
    1ac2:	89 a3       	std	Y+33, r24	; 0x21
    1ac4:	0f 90       	pop	r0
    1ac6:	0f be       	out	0x3f, r0	; 63
    1ac8:	df 91       	pop	r29
    1aca:	cf 91       	pop	r28
    1acc:	1f 91       	pop	r17
    1ace:	0f 91       	pop	r16
    1ad0:	08 95       	ret

00001ad2 <xQueueGenericReset>:
    1ad2:	1f 93       	push	r17
    1ad4:	cf 93       	push	r28
    1ad6:	df 93       	push	r29
    1ad8:	61 30       	cpi	r22, 0x01	; 1
    1ada:	59 f0       	breq	.+22     	; 0x1af2 <xQueueGenericReset+0x20>
    1adc:	fc 01       	movw	r30, r24
    1ade:	23 89       	ldd	r18, Z+19	; 0x13
    1ae0:	30 85       	ldd	r19, Z+8	; 0x08
    1ae2:	31 11       	cpse	r19, r1
    1ae4:	2c c0       	rjmp	.+88     	; 0x1b3e <xQueueGenericReset+0x6c>
    1ae6:	11 e0       	ldi	r17, 0x01	; 1
    1ae8:	21 11       	cpse	r18, r1
    1aea:	10 e0       	ldi	r17, 0x00	; 0
    1aec:	21 11       	cpse	r18, r1
    1aee:	28 c0       	rjmp	.+80     	; 0x1b40 <xQueueGenericReset+0x6e>
    1af0:	01 c0       	rjmp	.+2      	; 0x1af4 <xQueueGenericReset+0x22>
    1af2:	11 e0       	ldi	r17, 0x01	; 1
    1af4:	ec 01       	movw	r28, r24
    1af6:	48 81       	ld	r20, Y
    1af8:	59 81       	ldd	r21, Y+1	; 0x01
    1afa:	28 a1       	ldd	r18, Y+32	; 0x20
    1afc:	30 e0       	ldi	r19, 0x00	; 0
    1afe:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1b00:	62 9f       	mul	r22, r18
    1b02:	c0 01       	movw	r24, r0
    1b04:	63 9f       	mul	r22, r19
    1b06:	90 0d       	add	r25, r0
    1b08:	11 24       	eor	r1, r1
    1b0a:	ba 01       	movw	r22, r20
    1b0c:	68 0f       	add	r22, r24
    1b0e:	79 1f       	adc	r23, r25
    1b10:	6a 83       	std	Y+2, r22	; 0x02
    1b12:	7b 83       	std	Y+3, r23	; 0x03
    1b14:	1e 8e       	std	Y+30, r1	; 0x1e
    1b16:	4c 83       	std	Y+4, r20	; 0x04
    1b18:	5d 83       	std	Y+5, r21	; 0x05
    1b1a:	82 1b       	sub	r24, r18
    1b1c:	93 0b       	sbc	r25, r19
    1b1e:	84 0f       	add	r24, r20
    1b20:	95 1f       	adc	r25, r21
    1b22:	8e 83       	std	Y+6, r24	; 0x06
    1b24:	9f 83       	std	Y+7, r25	; 0x07
    1b26:	8f ef       	ldi	r24, 0xFF	; 255
    1b28:	89 a3       	std	Y+33, r24	; 0x21
    1b2a:	8a a3       	std	Y+34, r24	; 0x22
    1b2c:	ce 01       	movw	r24, r28
    1b2e:	08 96       	adiw	r24, 0x08	; 8
    1b30:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    1b34:	ce 01       	movw	r24, r28
    1b36:	43 96       	adiw	r24, 0x13	; 19
    1b38:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    1b3c:	01 c0       	rjmp	.+2      	; 0x1b40 <xQueueGenericReset+0x6e>
    1b3e:	10 e0       	ldi	r17, 0x00	; 0
    1b40:	81 2f       	mov	r24, r17
    1b42:	df 91       	pop	r29
    1b44:	cf 91       	pop	r28
    1b46:	1f 91       	pop	r17
    1b48:	08 95       	ret

00001b4a <xQueueGenericCreate>:
    1b4a:	0f 93       	push	r16
    1b4c:	1f 93       	push	r17
    1b4e:	cf 93       	push	r28
    1b50:	df 93       	push	r29
    1b52:	88 23       	and	r24, r24
    1b54:	01 f1       	breq	.+64     	; 0x1b96 <xQueueGenericCreate+0x4c>
    1b56:	06 2f       	mov	r16, r22
    1b58:	18 2f       	mov	r17, r24
    1b5a:	83 e2       	ldi	r24, 0x23	; 35
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	0e 94 bf 09 	call	0x137e	; 0x137e <pvPortMalloc>
    1b62:	ec 01       	movw	r28, r24
    1b64:	89 2b       	or	r24, r25
    1b66:	c9 f0       	breq	.+50     	; 0x1b9a <xQueueGenericCreate+0x50>
    1b68:	10 9f       	mul	r17, r16
    1b6a:	c0 01       	movw	r24, r0
    1b6c:	11 24       	eor	r1, r1
    1b6e:	01 96       	adiw	r24, 0x01	; 1
    1b70:	0e 94 bf 09 	call	0x137e	; 0x137e <pvPortMalloc>
    1b74:	88 83       	st	Y, r24
    1b76:	99 83       	std	Y+1, r25	; 0x01
    1b78:	89 2b       	or	r24, r25
    1b7a:	39 f0       	breq	.+14     	; 0x1b8a <xQueueGenericCreate+0x40>
    1b7c:	1f 8f       	std	Y+31, r17	; 0x1f
    1b7e:	08 a3       	std	Y+32, r16	; 0x20
    1b80:	61 e0       	ldi	r22, 0x01	; 1
    1b82:	ce 01       	movw	r24, r28
    1b84:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <xQueueGenericReset>
    1b88:	08 c0       	rjmp	.+16     	; 0x1b9a <xQueueGenericCreate+0x50>
    1b8a:	ce 01       	movw	r24, r28
    1b8c:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <vPortFree>
    1b90:	c0 e0       	ldi	r28, 0x00	; 0
    1b92:	d0 e0       	ldi	r29, 0x00	; 0
    1b94:	02 c0       	rjmp	.+4      	; 0x1b9a <xQueueGenericCreate+0x50>
    1b96:	c0 e0       	ldi	r28, 0x00	; 0
    1b98:	d0 e0       	ldi	r29, 0x00	; 0
    1b9a:	ce 01       	movw	r24, r28
    1b9c:	df 91       	pop	r29
    1b9e:	cf 91       	pop	r28
    1ba0:	1f 91       	pop	r17
    1ba2:	0f 91       	pop	r16
    1ba4:	08 95       	ret

00001ba6 <xQueueGenericSend>:
    1ba6:	af 92       	push	r10
    1ba8:	bf 92       	push	r11
    1baa:	cf 92       	push	r12
    1bac:	df 92       	push	r13
    1bae:	ef 92       	push	r14
    1bb0:	ff 92       	push	r15
    1bb2:	0f 93       	push	r16
    1bb4:	1f 93       	push	r17
    1bb6:	cf 93       	push	r28
    1bb8:	df 93       	push	r29
    1bba:	cd b7       	in	r28, 0x3d	; 61
    1bbc:	de b7       	in	r29, 0x3e	; 62
    1bbe:	29 97       	sbiw	r28, 0x09	; 9
    1bc0:	cd bf       	out	0x3d, r28	; 61
    1bc2:	de bf       	out	0x3e, r29	; 62
    1bc4:	7c 01       	movw	r14, r24
    1bc6:	5b 01       	movw	r10, r22
    1bc8:	2e 83       	std	Y+6, r18	; 0x06
    1bca:	3f 83       	std	Y+7, r19	; 0x07
    1bcc:	48 87       	std	Y+8, r20	; 0x08
    1bce:	59 87       	std	Y+9, r21	; 0x09
    1bd0:	10 e0       	ldi	r17, 0x00	; 0
    1bd2:	6c 01       	movw	r12, r24
    1bd4:	88 e0       	ldi	r24, 0x08	; 8
    1bd6:	c8 0e       	add	r12, r24
    1bd8:	d1 1c       	adc	r13, r1
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
    1be0:	f7 01       	movw	r30, r14
    1be2:	96 8d       	ldd	r25, Z+30	; 0x1e
    1be4:	87 8d       	ldd	r24, Z+31	; 0x1f
    1be6:	98 17       	cp	r25, r24
    1be8:	a8 f4       	brcc	.+42     	; 0x1c14 <xQueueGenericSend+0x6e>
    1bea:	40 2f       	mov	r20, r16
    1bec:	b5 01       	movw	r22, r10
    1bee:	c7 01       	movw	r24, r14
    1bf0:	0e 94 b9 0c 	call	0x1972	; 0x1972 <prvCopyDataToQueue>
    1bf4:	f7 01       	movw	r30, r14
    1bf6:	83 89       	ldd	r24, Z+19	; 0x13
    1bf8:	88 23       	and	r24, r24
    1bfa:	41 f0       	breq	.+16     	; 0x1c0c <xQueueGenericSend+0x66>
    1bfc:	c7 01       	movw	r24, r14
    1bfe:	43 96       	adiw	r24, 0x13	; 19
    1c00:	0e 94 99 13 	call	0x2732	; 0x2732 <xTaskRemoveFromEventList>
    1c04:	81 30       	cpi	r24, 0x01	; 1
    1c06:	11 f4       	brne	.+4      	; 0x1c0c <xQueueGenericSend+0x66>
    1c08:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
    1c0c:	0f 90       	pop	r0
    1c0e:	0f be       	out	0x3f, r0	; 63
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	56 c0       	rjmp	.+172    	; 0x1cc0 <xQueueGenericSend+0x11a>
    1c14:	8e 81       	ldd	r24, Y+6	; 0x06
    1c16:	9f 81       	ldd	r25, Y+7	; 0x07
    1c18:	a8 85       	ldd	r26, Y+8	; 0x08
    1c1a:	b9 85       	ldd	r27, Y+9	; 0x09
    1c1c:	89 2b       	or	r24, r25
    1c1e:	8a 2b       	or	r24, r26
    1c20:	8b 2b       	or	r24, r27
    1c22:	21 f4       	brne	.+8      	; 0x1c2c <xQueueGenericSend+0x86>
    1c24:	0f 90       	pop	r0
    1c26:	0f be       	out	0x3f, r0	; 63
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	4a c0       	rjmp	.+148    	; 0x1cc0 <xQueueGenericSend+0x11a>
    1c2c:	11 11       	cpse	r17, r1
    1c2e:	05 c0       	rjmp	.+10     	; 0x1c3a <xQueueGenericSend+0x94>
    1c30:	ce 01       	movw	r24, r28
    1c32:	01 96       	adiw	r24, 0x01	; 1
    1c34:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <vTaskSetTimeOutState>
    1c38:	11 e0       	ldi	r17, 0x01	; 1
    1c3a:	0f 90       	pop	r0
    1c3c:	0f be       	out	0x3f, r0	; 63
    1c3e:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <vTaskSuspendAll>
    1c42:	0f b6       	in	r0, 0x3f	; 63
    1c44:	f8 94       	cli
    1c46:	0f 92       	push	r0
    1c48:	f7 01       	movw	r30, r14
    1c4a:	81 a1       	ldd	r24, Z+33	; 0x21
    1c4c:	8f 3f       	cpi	r24, 0xFF	; 255
    1c4e:	09 f4       	brne	.+2      	; 0x1c52 <xQueueGenericSend+0xac>
    1c50:	11 a2       	std	Z+33, r1	; 0x21
    1c52:	f7 01       	movw	r30, r14
    1c54:	82 a1       	ldd	r24, Z+34	; 0x22
    1c56:	8f 3f       	cpi	r24, 0xFF	; 255
    1c58:	09 f4       	brne	.+2      	; 0x1c5c <xQueueGenericSend+0xb6>
    1c5a:	12 a2       	std	Z+34, r1	; 0x22
    1c5c:	0f 90       	pop	r0
    1c5e:	0f be       	out	0x3f, r0	; 63
    1c60:	be 01       	movw	r22, r28
    1c62:	6a 5f       	subi	r22, 0xFA	; 250
    1c64:	7f 4f       	sbci	r23, 0xFF	; 255
    1c66:	ce 01       	movw	r24, r28
    1c68:	01 96       	adiw	r24, 0x01	; 1
    1c6a:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <xTaskCheckForTimeOut>
    1c6e:	81 11       	cpse	r24, r1
    1c70:	21 c0       	rjmp	.+66     	; 0x1cb4 <xQueueGenericSend+0x10e>
    1c72:	0f b6       	in	r0, 0x3f	; 63
    1c74:	f8 94       	cli
    1c76:	0f 92       	push	r0
    1c78:	f7 01       	movw	r30, r14
    1c7a:	96 8d       	ldd	r25, Z+30	; 0x1e
    1c7c:	0f 90       	pop	r0
    1c7e:	0f be       	out	0x3f, r0	; 63
    1c80:	87 8d       	ldd	r24, Z+31	; 0x1f
    1c82:	98 13       	cpse	r25, r24
    1c84:	11 c0       	rjmp	.+34     	; 0x1ca8 <xQueueGenericSend+0x102>
    1c86:	4e 81       	ldd	r20, Y+6	; 0x06
    1c88:	5f 81       	ldd	r21, Y+7	; 0x07
    1c8a:	68 85       	ldd	r22, Y+8	; 0x08
    1c8c:	79 85       	ldd	r23, Y+9	; 0x09
    1c8e:	c6 01       	movw	r24, r12
    1c90:	0e 94 6f 13 	call	0x26de	; 0x26de <vTaskPlaceOnEventList>
    1c94:	c7 01       	movw	r24, r14
    1c96:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvUnlockQueue>
    1c9a:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
    1c9e:	81 11       	cpse	r24, r1
    1ca0:	9c cf       	rjmp	.-200    	; 0x1bda <xQueueGenericSend+0x34>
    1ca2:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
    1ca6:	99 cf       	rjmp	.-206    	; 0x1bda <xQueueGenericSend+0x34>
    1ca8:	c7 01       	movw	r24, r14
    1caa:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvUnlockQueue>
    1cae:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
    1cb2:	93 cf       	rjmp	.-218    	; 0x1bda <xQueueGenericSend+0x34>
    1cb4:	c7 01       	movw	r24, r14
    1cb6:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvUnlockQueue>
    1cba:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
    1cbe:	80 e0       	ldi	r24, 0x00	; 0
    1cc0:	29 96       	adiw	r28, 0x09	; 9
    1cc2:	cd bf       	out	0x3d, r28	; 61
    1cc4:	de bf       	out	0x3e, r29	; 62
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	1f 91       	pop	r17
    1ccc:	0f 91       	pop	r16
    1cce:	ff 90       	pop	r15
    1cd0:	ef 90       	pop	r14
    1cd2:	df 90       	pop	r13
    1cd4:	cf 90       	pop	r12
    1cd6:	bf 90       	pop	r11
    1cd8:	af 90       	pop	r10
    1cda:	08 95       	ret

00001cdc <xQueueGenericReceive>:
    1cdc:	af 92       	push	r10
    1cde:	bf 92       	push	r11
    1ce0:	cf 92       	push	r12
    1ce2:	df 92       	push	r13
    1ce4:	ef 92       	push	r14
    1ce6:	ff 92       	push	r15
    1ce8:	0f 93       	push	r16
    1cea:	1f 93       	push	r17
    1cec:	cf 93       	push	r28
    1cee:	df 93       	push	r29
    1cf0:	cd b7       	in	r28, 0x3d	; 61
    1cf2:	de b7       	in	r29, 0x3e	; 62
    1cf4:	29 97       	sbiw	r28, 0x09	; 9
    1cf6:	cd bf       	out	0x3d, r28	; 61
    1cf8:	de bf       	out	0x3e, r29	; 62
    1cfa:	7c 01       	movw	r14, r24
    1cfc:	5b 01       	movw	r10, r22
    1cfe:	2e 83       	std	Y+6, r18	; 0x06
    1d00:	3f 83       	std	Y+7, r19	; 0x07
    1d02:	48 87       	std	Y+8, r20	; 0x08
    1d04:	59 87       	std	Y+9, r21	; 0x09
    1d06:	10 e0       	ldi	r17, 0x00	; 0
    1d08:	6c 01       	movw	r12, r24
    1d0a:	83 e1       	ldi	r24, 0x13	; 19
    1d0c:	c8 0e       	add	r12, r24
    1d0e:	d1 1c       	adc	r13, r1
    1d10:	0f b6       	in	r0, 0x3f	; 63
    1d12:	f8 94       	cli
    1d14:	0f 92       	push	r0
    1d16:	f7 01       	movw	r30, r14
    1d18:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d1a:	88 23       	and	r24, r24
    1d1c:	99 f1       	breq	.+102    	; 0x1d84 <xQueueGenericReceive+0xa8>
    1d1e:	c6 80       	ldd	r12, Z+6	; 0x06
    1d20:	d7 80       	ldd	r13, Z+7	; 0x07
    1d22:	b5 01       	movw	r22, r10
    1d24:	c7 01       	movw	r24, r14
    1d26:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <prvCopyDataFromQueue>
    1d2a:	01 11       	cpse	r16, r1
    1d2c:	1a c0       	rjmp	.+52     	; 0x1d62 <xQueueGenericReceive+0x86>
    1d2e:	f7 01       	movw	r30, r14
    1d30:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d32:	81 50       	subi	r24, 0x01	; 1
    1d34:	86 8f       	std	Z+30, r24	; 0x1e
    1d36:	80 81       	ld	r24, Z
    1d38:	91 81       	ldd	r25, Z+1	; 0x01
    1d3a:	89 2b       	or	r24, r25
    1d3c:	29 f4       	brne	.+10     	; 0x1d48 <xQueueGenericReceive+0x6c>
    1d3e:	0e 94 73 14 	call	0x28e6	; 0x28e6 <xTaskGetCurrentTaskHandle>
    1d42:	f7 01       	movw	r30, r14
    1d44:	82 83       	std	Z+2, r24	; 0x02
    1d46:	93 83       	std	Z+3, r25	; 0x03
    1d48:	f7 01       	movw	r30, r14
    1d4a:	80 85       	ldd	r24, Z+8	; 0x08
    1d4c:	88 23       	and	r24, r24
    1d4e:	b1 f0       	breq	.+44     	; 0x1d7c <xQueueGenericReceive+0xa0>
    1d50:	c7 01       	movw	r24, r14
    1d52:	08 96       	adiw	r24, 0x08	; 8
    1d54:	0e 94 99 13 	call	0x2732	; 0x2732 <xTaskRemoveFromEventList>
    1d58:	81 30       	cpi	r24, 0x01	; 1
    1d5a:	81 f4       	brne	.+32     	; 0x1d7c <xQueueGenericReceive+0xa0>
    1d5c:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
    1d60:	0d c0       	rjmp	.+26     	; 0x1d7c <xQueueGenericReceive+0xa0>
    1d62:	f7 01       	movw	r30, r14
    1d64:	c6 82       	std	Z+6, r12	; 0x06
    1d66:	d7 82       	std	Z+7, r13	; 0x07
    1d68:	83 89       	ldd	r24, Z+19	; 0x13
    1d6a:	88 23       	and	r24, r24
    1d6c:	39 f0       	breq	.+14     	; 0x1d7c <xQueueGenericReceive+0xa0>
    1d6e:	c7 01       	movw	r24, r14
    1d70:	43 96       	adiw	r24, 0x13	; 19
    1d72:	0e 94 99 13 	call	0x2732	; 0x2732 <xTaskRemoveFromEventList>
    1d76:	81 11       	cpse	r24, r1
    1d78:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
    1d7c:	0f 90       	pop	r0
    1d7e:	0f be       	out	0x3f, r0	; 63
    1d80:	81 e0       	ldi	r24, 0x01	; 1
    1d82:	62 c0       	rjmp	.+196    	; 0x1e48 <xQueueGenericReceive+0x16c>
    1d84:	8e 81       	ldd	r24, Y+6	; 0x06
    1d86:	9f 81       	ldd	r25, Y+7	; 0x07
    1d88:	a8 85       	ldd	r26, Y+8	; 0x08
    1d8a:	b9 85       	ldd	r27, Y+9	; 0x09
    1d8c:	89 2b       	or	r24, r25
    1d8e:	8a 2b       	or	r24, r26
    1d90:	8b 2b       	or	r24, r27
    1d92:	21 f4       	brne	.+8      	; 0x1d9c <xQueueGenericReceive+0xc0>
    1d94:	0f 90       	pop	r0
    1d96:	0f be       	out	0x3f, r0	; 63
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	56 c0       	rjmp	.+172    	; 0x1e48 <xQueueGenericReceive+0x16c>
    1d9c:	11 11       	cpse	r17, r1
    1d9e:	05 c0       	rjmp	.+10     	; 0x1daa <xQueueGenericReceive+0xce>
    1da0:	ce 01       	movw	r24, r28
    1da2:	01 96       	adiw	r24, 0x01	; 1
    1da4:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <vTaskSetTimeOutState>
    1da8:	11 e0       	ldi	r17, 0x01	; 1
    1daa:	0f 90       	pop	r0
    1dac:	0f be       	out	0x3f, r0	; 63
    1dae:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <vTaskSuspendAll>
    1db2:	0f b6       	in	r0, 0x3f	; 63
    1db4:	f8 94       	cli
    1db6:	0f 92       	push	r0
    1db8:	f7 01       	movw	r30, r14
    1dba:	81 a1       	ldd	r24, Z+33	; 0x21
    1dbc:	8f 3f       	cpi	r24, 0xFF	; 255
    1dbe:	09 f4       	brne	.+2      	; 0x1dc2 <xQueueGenericReceive+0xe6>
    1dc0:	11 a2       	std	Z+33, r1	; 0x21
    1dc2:	f7 01       	movw	r30, r14
    1dc4:	82 a1       	ldd	r24, Z+34	; 0x22
    1dc6:	8f 3f       	cpi	r24, 0xFF	; 255
    1dc8:	09 f4       	brne	.+2      	; 0x1dcc <xQueueGenericReceive+0xf0>
    1dca:	12 a2       	std	Z+34, r1	; 0x22
    1dcc:	0f 90       	pop	r0
    1dce:	0f be       	out	0x3f, r0	; 63
    1dd0:	be 01       	movw	r22, r28
    1dd2:	6a 5f       	subi	r22, 0xFA	; 250
    1dd4:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd6:	ce 01       	movw	r24, r28
    1dd8:	01 96       	adiw	r24, 0x01	; 1
    1dda:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <xTaskCheckForTimeOut>
    1dde:	81 11       	cpse	r24, r1
    1de0:	2d c0       	rjmp	.+90     	; 0x1e3c <xQueueGenericReceive+0x160>
    1de2:	0f b6       	in	r0, 0x3f	; 63
    1de4:	f8 94       	cli
    1de6:	0f 92       	push	r0
    1de8:	f7 01       	movw	r30, r14
    1dea:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dec:	0f 90       	pop	r0
    1dee:	0f be       	out	0x3f, r0	; 63
    1df0:	81 11       	cpse	r24, r1
    1df2:	1e c0       	rjmp	.+60     	; 0x1e30 <xQueueGenericReceive+0x154>
    1df4:	80 81       	ld	r24, Z
    1df6:	91 81       	ldd	r25, Z+1	; 0x01
    1df8:	89 2b       	or	r24, r25
    1dfa:	49 f4       	brne	.+18     	; 0x1e0e <xQueueGenericReceive+0x132>
    1dfc:	0f b6       	in	r0, 0x3f	; 63
    1dfe:	f8 94       	cli
    1e00:	0f 92       	push	r0
    1e02:	82 81       	ldd	r24, Z+2	; 0x02
    1e04:	93 81       	ldd	r25, Z+3	; 0x03
    1e06:	0e 94 78 14 	call	0x28f0	; 0x28f0 <vTaskPriorityInherit>
    1e0a:	0f 90       	pop	r0
    1e0c:	0f be       	out	0x3f, r0	; 63
    1e0e:	4e 81       	ldd	r20, Y+6	; 0x06
    1e10:	5f 81       	ldd	r21, Y+7	; 0x07
    1e12:	68 85       	ldd	r22, Y+8	; 0x08
    1e14:	79 85       	ldd	r23, Y+9	; 0x09
    1e16:	c6 01       	movw	r24, r12
    1e18:	0e 94 6f 13 	call	0x26de	; 0x26de <vTaskPlaceOnEventList>
    1e1c:	c7 01       	movw	r24, r14
    1e1e:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvUnlockQueue>
    1e22:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
    1e26:	81 11       	cpse	r24, r1
    1e28:	73 cf       	rjmp	.-282    	; 0x1d10 <xQueueGenericReceive+0x34>
    1e2a:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
    1e2e:	70 cf       	rjmp	.-288    	; 0x1d10 <xQueueGenericReceive+0x34>
    1e30:	c7 01       	movw	r24, r14
    1e32:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvUnlockQueue>
    1e36:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
    1e3a:	6a cf       	rjmp	.-300    	; 0x1d10 <xQueueGenericReceive+0x34>
    1e3c:	c7 01       	movw	r24, r14
    1e3e:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <prvUnlockQueue>
    1e42:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
    1e46:	80 e0       	ldi	r24, 0x00	; 0
    1e48:	29 96       	adiw	r28, 0x09	; 9
    1e4a:	cd bf       	out	0x3d, r28	; 61
    1e4c:	de bf       	out	0x3e, r29	; 62
    1e4e:	df 91       	pop	r29
    1e50:	cf 91       	pop	r28
    1e52:	1f 91       	pop	r17
    1e54:	0f 91       	pop	r16
    1e56:	ff 90       	pop	r15
    1e58:	ef 90       	pop	r14
    1e5a:	df 90       	pop	r13
    1e5c:	cf 90       	pop	r12
    1e5e:	bf 90       	pop	r11
    1e60:	af 90       	pop	r10
    1e62:	08 95       	ret

00001e64 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1e64:	0f b6       	in	r0, 0x3f	; 63
    1e66:	f8 94       	cli
    1e68:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1e6a:	fc 01       	movw	r30, r24
    1e6c:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1e72:	08 95       	ret

00001e74 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1e74:	c8 ef       	ldi	r28, 0xF8	; 248
    1e76:	d0 e3       	ldi	r29, 0x30	; 48
    1e78:	88 81       	ld	r24, Y
    1e7a:	82 30       	cpi	r24, 0x02	; 2
    1e7c:	e8 f3       	brcs	.-6      	; 0x1e78 <prvIdleTask+0x4>
    1e7e:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
    1e82:	fa cf       	rjmp	.-12     	; 0x1e78 <prvIdleTask+0x4>

00001e84 <prvAddCurrentTaskToDelayedList>:
    1e84:	cf 92       	push	r12
    1e86:	df 92       	push	r13
    1e88:	ef 92       	push	r14
    1e8a:	ff 92       	push	r15
    1e8c:	6b 01       	movw	r12, r22
    1e8e:	7c 01       	movw	r14, r24
    1e90:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1e94:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1e98:	62 83       	std	Z+2, r22	; 0x02
    1e9a:	73 83       	std	Z+3, r23	; 0x03
    1e9c:	84 83       	std	Z+4, r24	; 0x04
    1e9e:	95 83       	std	Z+5, r25	; 0x05
    1ea0:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    1ea4:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    1ea8:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    1eac:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    1eb0:	c8 16       	cp	r12, r24
    1eb2:	d9 06       	cpc	r13, r25
    1eb4:	ea 06       	cpc	r14, r26
    1eb6:	fb 06       	cpc	r15, r27
    1eb8:	68 f4       	brcc	.+26     	; 0x1ed4 <prvAddCurrentTaskToDelayedList+0x50>
    1eba:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1ebe:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1ec2:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    1ec6:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    1eca:	6e 5f       	subi	r22, 0xFE	; 254
    1ecc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ece:	0e 94 cd 0a 	call	0x159a	; 0x159a <vListInsert>
    1ed2:	21 c0       	rjmp	.+66     	; 0x1f16 <prvAddCurrentTaskToDelayedList+0x92>
    1ed4:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1ed8:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1edc:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    1ee0:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    1ee4:	6e 5f       	subi	r22, 0xFE	; 254
    1ee6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ee8:	0e 94 cd 0a 	call	0x159a	; 0x159a <vListInsert>
    1eec:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1ef0:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ef4:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ef8:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1efc:	c8 16       	cp	r12, r24
    1efe:	d9 06       	cpc	r13, r25
    1f00:	ea 06       	cpc	r14, r26
    1f02:	fb 06       	cpc	r15, r27
    1f04:	40 f4       	brcc	.+16     	; 0x1f16 <prvAddCurrentTaskToDelayedList+0x92>
    1f06:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1f0a:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1f0e:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f12:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1f16:	ff 90       	pop	r15
    1f18:	ef 90       	pop	r14
    1f1a:	df 90       	pop	r13
    1f1c:	cf 90       	pop	r12
    1f1e:	08 95       	ret

00001f20 <xTaskGenericCreate>:
    1f20:	4f 92       	push	r4
    1f22:	5f 92       	push	r5
    1f24:	6f 92       	push	r6
    1f26:	7f 92       	push	r7
    1f28:	8f 92       	push	r8
    1f2a:	9f 92       	push	r9
    1f2c:	af 92       	push	r10
    1f2e:	bf 92       	push	r11
    1f30:	cf 92       	push	r12
    1f32:	df 92       	push	r13
    1f34:	ef 92       	push	r14
    1f36:	ff 92       	push	r15
    1f38:	0f 93       	push	r16
    1f3a:	1f 93       	push	r17
    1f3c:	cf 93       	push	r28
    1f3e:	df 93       	push	r29
    1f40:	5c 01       	movw	r10, r24
    1f42:	4b 01       	movw	r8, r22
    1f44:	3a 01       	movw	r6, r20
    1f46:	29 01       	movw	r4, r18
    1f48:	88 e2       	ldi	r24, 0x28	; 40
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	0e 94 bf 09 	call	0x137e	; 0x137e <pvPortMalloc>
    1f50:	ec 01       	movw	r28, r24
    1f52:	89 2b       	or	r24, r25
    1f54:	09 f4       	brne	.+2      	; 0x1f58 <xTaskGenericCreate+0x38>
    1f56:	d4 c0       	rjmp	.+424    	; 0x2100 <xTaskGenericCreate+0x1e0>
    1f58:	c1 14       	cp	r12, r1
    1f5a:	d1 04       	cpc	r13, r1
    1f5c:	09 f0       	breq	.+2      	; 0x1f60 <xTaskGenericCreate+0x40>
    1f5e:	cc c0       	rjmp	.+408    	; 0x20f8 <xTaskGenericCreate+0x1d8>
    1f60:	c3 01       	movw	r24, r6
    1f62:	0e 94 bf 09 	call	0x137e	; 0x137e <pvPortMalloc>
    1f66:	8b 8f       	std	Y+27, r24	; 0x1b
    1f68:	9c 8f       	std	Y+28, r25	; 0x1c
    1f6a:	00 97       	sbiw	r24, 0x00	; 0
    1f6c:	21 f4       	brne	.+8      	; 0x1f76 <xTaskGenericCreate+0x56>
    1f6e:	ce 01       	movw	r24, r28
    1f70:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <vPortFree>
    1f74:	c5 c0       	rjmp	.+394    	; 0x2100 <xTaskGenericCreate+0x1e0>
    1f76:	a3 01       	movw	r20, r6
    1f78:	61 e1       	ldi	r22, 0x11	; 17
    1f7a:	70 e0       	ldi	r23, 0x00	; 0
    1f7c:	0e 94 f9 21 	call	0x43f2	; 0x43f2 <memset>
    1f80:	93 01       	movw	r18, r6
    1f82:	21 50       	subi	r18, 0x01	; 1
    1f84:	31 09       	sbc	r19, r1
    1f86:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f88:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1f8a:	3c 01       	movw	r6, r24
    1f8c:	62 0e       	add	r6, r18
    1f8e:	73 1e       	adc	r7, r19
    1f90:	4a e0       	ldi	r20, 0x0A	; 10
    1f92:	50 e0       	ldi	r21, 0x00	; 0
    1f94:	b4 01       	movw	r22, r8
    1f96:	ce 01       	movw	r24, r28
    1f98:	4d 96       	adiw	r24, 0x1d	; 29
    1f9a:	0e 94 00 22 	call	0x4400	; 0x4400 <strncpy>
    1f9e:	1e a2       	std	Y+38, r1	; 0x26
    1fa0:	10 2f       	mov	r17, r16
    1fa2:	04 30       	cpi	r16, 0x04	; 4
    1fa4:	08 f0       	brcs	.+2      	; 0x1fa8 <xTaskGenericCreate+0x88>
    1fa6:	13 e0       	ldi	r17, 0x03	; 3
    1fa8:	1a 8f       	std	Y+26, r17	; 0x1a
    1faa:	1f a3       	std	Y+39, r17	; 0x27
    1fac:	6e 01       	movw	r12, r28
    1fae:	22 e0       	ldi	r18, 0x02	; 2
    1fb0:	c2 0e       	add	r12, r18
    1fb2:	d1 1c       	adc	r13, r1
    1fb4:	c6 01       	movw	r24, r12
    1fb6:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialiseItem>
    1fba:	ce 01       	movw	r24, r28
    1fbc:	0e 96       	adiw	r24, 0x0e	; 14
    1fbe:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialiseItem>
    1fc2:	ca 87       	std	Y+10, r28	; 0x0a
    1fc4:	db 87       	std	Y+11, r29	; 0x0b
    1fc6:	84 e0       	ldi	r24, 0x04	; 4
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	a0 e0       	ldi	r26, 0x00	; 0
    1fcc:	b0 e0       	ldi	r27, 0x00	; 0
    1fce:	81 1b       	sub	r24, r17
    1fd0:	91 09       	sbc	r25, r1
    1fd2:	a1 09       	sbc	r26, r1
    1fd4:	b1 09       	sbc	r27, r1
    1fd6:	8e 87       	std	Y+14, r24	; 0x0e
    1fd8:	9f 87       	std	Y+15, r25	; 0x0f
    1fda:	a8 8b       	std	Y+16, r26	; 0x10
    1fdc:	b9 8b       	std	Y+17, r27	; 0x11
    1fde:	ce 8b       	std	Y+22, r28	; 0x16
    1fe0:	df 8b       	std	Y+23, r29	; 0x17
    1fe2:	a2 01       	movw	r20, r4
    1fe4:	b5 01       	movw	r22, r10
    1fe6:	c3 01       	movw	r24, r6
    1fe8:	0e 94 3e 0b 	call	0x167c	; 0x167c <pxPortInitialiseStack>
    1fec:	88 83       	st	Y, r24
    1fee:	99 83       	std	Y+1, r25	; 0x01
    1ff0:	e1 14       	cp	r14, r1
    1ff2:	f1 04       	cpc	r15, r1
    1ff4:	19 f0       	breq	.+6      	; 0x1ffc <xTaskGenericCreate+0xdc>
    1ff6:	f7 01       	movw	r30, r14
    1ff8:	c0 83       	st	Z, r28
    1ffa:	d1 83       	std	Z+1, r29	; 0x01
    1ffc:	0f b6       	in	r0, 0x3f	; 63
    1ffe:	f8 94       	cli
    2000:	0f 92       	push	r0
    2002:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2006:	8f 5f       	subi	r24, 0xFF	; 255
    2008:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    200c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2010:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2014:	89 2b       	or	r24, r25
    2016:	89 f5       	brne	.+98     	; 0x207a <xTaskGenericCreate+0x15a>
    2018:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    201c:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    2020:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2024:	81 30       	cpi	r24, 0x01	; 1
    2026:	c1 f5       	brne	.+112    	; 0x2098 <xTaskGenericCreate+0x178>
    2028:	88 ef       	ldi	r24, 0xF8	; 248
    202a:	90 e3       	ldi	r25, 0x30	; 48
    202c:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    2030:	83 e0       	ldi	r24, 0x03	; 3
    2032:	91 e3       	ldi	r25, 0x31	; 49
    2034:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    2038:	8e e0       	ldi	r24, 0x0E	; 14
    203a:	91 e3       	ldi	r25, 0x31	; 49
    203c:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    2040:	89 e1       	ldi	r24, 0x19	; 25
    2042:	91 e3       	ldi	r25, 0x31	; 49
    2044:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    2048:	8d ee       	ldi	r24, 0xED	; 237
    204a:	90 e3       	ldi	r25, 0x30	; 48
    204c:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    2050:	82 ee       	ldi	r24, 0xE2	; 226
    2052:	90 e3       	ldi	r25, 0x30	; 48
    2054:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    2058:	83 ed       	ldi	r24, 0xD3	; 211
    205a:	90 e3       	ldi	r25, 0x30	; 48
    205c:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInitialise>
    2060:	8d ee       	ldi	r24, 0xED	; 237
    2062:	90 e3       	ldi	r25, 0x30	; 48
    2064:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    2068:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    206c:	82 ee       	ldi	r24, 0xE2	; 226
    206e:	90 e3       	ldi	r25, 0x30	; 48
    2070:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    2074:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    2078:	0f c0       	rjmp	.+30     	; 0x2098 <xTaskGenericCreate+0x178>
    207a:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    207e:	81 11       	cpse	r24, r1
    2080:	0b c0       	rjmp	.+22     	; 0x2098 <xTaskGenericCreate+0x178>
    2082:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2086:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    208a:	82 8d       	ldd	r24, Z+26	; 0x1a
    208c:	08 17       	cp	r16, r24
    208e:	20 f0       	brcs	.+8      	; 0x2098 <xTaskGenericCreate+0x178>
    2090:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    2094:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    2098:	8a 8d       	ldd	r24, Y+26	; 0x1a
    209a:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    209e:	98 17       	cp	r25, r24
    20a0:	10 f4       	brcc	.+4      	; 0x20a6 <xTaskGenericCreate+0x186>
    20a2:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    20a6:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    20aa:	9f 5f       	subi	r25, 0xFF	; 255
    20ac:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    20b0:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    20b4:	98 17       	cp	r25, r24
    20b6:	10 f4       	brcc	.+4      	; 0x20bc <xTaskGenericCreate+0x19c>
    20b8:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    20bc:	fb e0       	ldi	r31, 0x0B	; 11
    20be:	8f 9f       	mul	r24, r31
    20c0:	c0 01       	movw	r24, r0
    20c2:	11 24       	eor	r1, r1
    20c4:	b6 01       	movw	r22, r12
    20c6:	88 50       	subi	r24, 0x08	; 8
    20c8:	9f 4c       	sbci	r25, 0xCF	; 207
    20ca:	0e 94 a6 0a 	call	0x154c	; 0x154c <vListInsertEnd>
    20ce:	0f 90       	pop	r0
    20d0:	0f be       	out	0x3f, r0	; 63
    20d2:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    20d6:	88 23       	and	r24, r24
    20d8:	59 f0       	breq	.+22     	; 0x20f0 <xTaskGenericCreate+0x1d0>
    20da:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    20de:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    20e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    20e4:	80 17       	cp	r24, r16
    20e6:	30 f4       	brcc	.+12     	; 0x20f4 <xTaskGenericCreate+0x1d4>
    20e8:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
    20ec:	81 e0       	ldi	r24, 0x01	; 1
    20ee:	09 c0       	rjmp	.+18     	; 0x2102 <xTaskGenericCreate+0x1e2>
    20f0:	81 e0       	ldi	r24, 0x01	; 1
    20f2:	07 c0       	rjmp	.+14     	; 0x2102 <xTaskGenericCreate+0x1e2>
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	05 c0       	rjmp	.+10     	; 0x2102 <xTaskGenericCreate+0x1e2>
    20f8:	cb 8e       	std	Y+27, r12	; 0x1b
    20fa:	dc 8e       	std	Y+28, r13	; 0x1c
    20fc:	c6 01       	movw	r24, r12
    20fe:	3b cf       	rjmp	.-394    	; 0x1f76 <xTaskGenericCreate+0x56>
    2100:	8f ef       	ldi	r24, 0xFF	; 255
    2102:	df 91       	pop	r29
    2104:	cf 91       	pop	r28
    2106:	1f 91       	pop	r17
    2108:	0f 91       	pop	r16
    210a:	ff 90       	pop	r15
    210c:	ef 90       	pop	r14
    210e:	df 90       	pop	r13
    2110:	cf 90       	pop	r12
    2112:	bf 90       	pop	r11
    2114:	af 90       	pop	r10
    2116:	9f 90       	pop	r9
    2118:	8f 90       	pop	r8
    211a:	7f 90       	pop	r7
    211c:	6f 90       	pop	r6
    211e:	5f 90       	pop	r5
    2120:	4f 90       	pop	r4
    2122:	08 95       	ret

00002124 <uxTaskPriorityGet>:
    2124:	0f b6       	in	r0, 0x3f	; 63
    2126:	f8 94       	cli
    2128:	0f 92       	push	r0
    212a:	00 97       	sbiw	r24, 0x00	; 0
    212c:	21 f4       	brne	.+8      	; 0x2136 <uxTaskPriorityGet+0x12>
    212e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2132:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2136:	0f 90       	pop	r0
    2138:	0f be       	out	0x3f, r0	; 63
    213a:	fc 01       	movw	r30, r24
    213c:	82 8d       	ldd	r24, Z+26	; 0x1a
    213e:	08 95       	ret

00002140 <vTaskStartScheduler>:
    2140:	af 92       	push	r10
    2142:	bf 92       	push	r11
    2144:	cf 92       	push	r12
    2146:	df 92       	push	r13
    2148:	ef 92       	push	r14
    214a:	ff 92       	push	r15
    214c:	0f 93       	push	r16
    214e:	a1 2c       	mov	r10, r1
    2150:	b1 2c       	mov	r11, r1
    2152:	c1 2c       	mov	r12, r1
    2154:	d1 2c       	mov	r13, r1
    2156:	0f 2e       	mov	r0, r31
    2158:	f1 ed       	ldi	r31, 0xD1	; 209
    215a:	ef 2e       	mov	r14, r31
    215c:	f0 e3       	ldi	r31, 0x30	; 48
    215e:	ff 2e       	mov	r15, r31
    2160:	f0 2d       	mov	r31, r0
    2162:	00 e0       	ldi	r16, 0x00	; 0
    2164:	20 e0       	ldi	r18, 0x00	; 0
    2166:	30 e0       	ldi	r19, 0x00	; 0
    2168:	44 e6       	ldi	r20, 0x64	; 100
    216a:	50 e0       	ldi	r21, 0x00	; 0
    216c:	66 e3       	ldi	r22, 0x36	; 54
    216e:	70 e2       	ldi	r23, 0x20	; 32
    2170:	8a e3       	ldi	r24, 0x3A	; 58
    2172:	9f e0       	ldi	r25, 0x0F	; 15
    2174:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskGenericCreate>
    2178:	81 30       	cpi	r24, 0x01	; 1
    217a:	69 f4       	brne	.+26     	; 0x2196 <vTaskStartScheduler+0x56>
    217c:	f8 94       	cli
    217e:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    2182:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    2186:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    218a:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    218e:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    2192:	0e 94 b4 0b 	call	0x1768	; 0x1768 <xPortStartScheduler>
    2196:	0f 91       	pop	r16
    2198:	ff 90       	pop	r15
    219a:	ef 90       	pop	r14
    219c:	df 90       	pop	r13
    219e:	cf 90       	pop	r12
    21a0:	bf 90       	pop	r11
    21a2:	af 90       	pop	r10
    21a4:	08 95       	ret

000021a6 <vTaskSuspendAll>:
    21a6:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    21aa:	8f 5f       	subi	r24, 0xFF	; 255
    21ac:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    21b0:	08 95       	ret

000021b2 <xTaskGetTickCount>:
    21b2:	0f b6       	in	r0, 0x3f	; 63
    21b4:	f8 94       	cli
    21b6:	0f 92       	push	r0
    21b8:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    21bc:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    21c0:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    21c4:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    21c8:	0f 90       	pop	r0
    21ca:	0f be       	out	0x3f, r0	; 63
    21cc:	08 95       	ret

000021ce <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    21ce:	00 97       	sbiw	r24, 0x00	; 0
    21d0:	21 f4       	brne	.+8      	; 0x21da <pcTaskGetTaskName+0xc>
    21d2:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    21d6:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    21da:	4d 96       	adiw	r24, 0x1d	; 29
    21dc:	08 95       	ret

000021de <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    21de:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    21e2:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    21e6:	08 95       	ret

000021e8 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    21e8:	ff 92       	push	r15
    21ea:	0f 93       	push	r16
    21ec:	1f 93       	push	r17
    21ee:	cf 93       	push	r28
    21f0:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21f2:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    21f6:	81 11       	cpse	r24, r1
    21f8:	ed c0       	rjmp	.+474    	; 0x23d4 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    21fa:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    21fe:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2202:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2206:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    220a:	01 96       	adiw	r24, 0x01	; 1
    220c:	a1 1d       	adc	r26, r1
    220e:	b1 1d       	adc	r27, r1
    2210:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2214:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    2218:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    221c:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2220:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2224:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2228:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    222c:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2230:	89 2b       	or	r24, r25
    2232:	8a 2b       	or	r24, r26
    2234:	8b 2b       	or	r24, r27
    2236:	f1 f5       	brne	.+124    	; 0x22b4 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2238:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    223c:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2240:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2244:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    2248:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    224c:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2250:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    2254:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2258:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    225c:	8f 5f       	subi	r24, 0xFF	; 255
    225e:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2262:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2266:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    226a:	80 81       	ld	r24, Z
    226c:	81 11       	cpse	r24, r1
    226e:	0c c0       	rjmp	.+24     	; 0x2288 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2270:	8f ef       	ldi	r24, 0xFF	; 255
    2272:	9f ef       	ldi	r25, 0xFF	; 255
    2274:	dc 01       	movw	r26, r24
    2276:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    227a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    227e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2282:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2286:	16 c0       	rjmp	.+44     	; 0x22b4 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2288:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    228c:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2290:	07 80       	ldd	r0, Z+7	; 0x07
    2292:	f0 85       	ldd	r31, Z+8	; 0x08
    2294:	e0 2d       	mov	r30, r0
    2296:	00 84       	ldd	r0, Z+8	; 0x08
    2298:	f1 85       	ldd	r31, Z+9	; 0x09
    229a:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    229c:	82 81       	ldd	r24, Z+2	; 0x02
    229e:	93 81       	ldd	r25, Z+3	; 0x03
    22a0:	a4 81       	ldd	r26, Z+4	; 0x04
    22a2:	b5 81       	ldd	r27, Z+5	; 0x05
    22a4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22a8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22ac:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22b0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    22b4:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    22b8:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    22bc:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    22c0:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    22c4:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    22c8:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    22cc:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    22d0:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    22d4:	48 17       	cp	r20, r24
    22d6:	59 07       	cpc	r21, r25
    22d8:	6a 07       	cpc	r22, r26
    22da:	7b 07       	cpc	r23, r27
    22dc:	08 f4       	brcc	.+2      	; 0x22e0 <vTaskIncrementTick+0xf8>
    22de:	7f c0       	rjmp	.+254    	; 0x23de <vTaskIncrementTick+0x1f6>
    22e0:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    22e4:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    22e8:	80 81       	ld	r24, Z
    22ea:	88 23       	and	r24, r24
    22ec:	f9 f0       	breq	.+62     	; 0x232c <vTaskIncrementTick+0x144>
    22ee:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    22f2:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    22f6:	07 80       	ldd	r0, Z+7	; 0x07
    22f8:	f0 85       	ldd	r31, Z+8	; 0x08
    22fa:	e0 2d       	mov	r30, r0
    22fc:	c0 85       	ldd	r28, Z+8	; 0x08
    22fe:	d1 85       	ldd	r29, Z+9	; 0x09
    2300:	8a 81       	ldd	r24, Y+2	; 0x02
    2302:	9b 81       	ldd	r25, Y+3	; 0x03
    2304:	ac 81       	ldd	r26, Y+4	; 0x04
    2306:	bd 81       	ldd	r27, Y+5	; 0x05
    2308:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    230c:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2310:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2314:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2318:	48 17       	cp	r20, r24
    231a:	59 07       	cpc	r21, r25
    231c:	6a 07       	cpc	r22, r26
    231e:	7b 07       	cpc	r23, r27
    2320:	58 f1       	brcs	.+86     	; 0x2378 <vTaskIncrementTick+0x190>
    2322:	0f 2e       	mov	r0, r31
    2324:	fb e0       	ldi	r31, 0x0B	; 11
    2326:	ff 2e       	mov	r15, r31
    2328:	f0 2d       	mov	r31, r0
    232a:	2f c0       	rjmp	.+94     	; 0x238a <vTaskIncrementTick+0x1a2>
    232c:	8f ef       	ldi	r24, 0xFF	; 255
    232e:	9f ef       	ldi	r25, 0xFF	; 255
    2330:	dc 01       	movw	r26, r24
    2332:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2336:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    233a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    233e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2342:	4d c0       	rjmp	.+154    	; 0x23de <vTaskIncrementTick+0x1f6>
    2344:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2348:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    234c:	07 80       	ldd	r0, Z+7	; 0x07
    234e:	f0 85       	ldd	r31, Z+8	; 0x08
    2350:	e0 2d       	mov	r30, r0
    2352:	c0 85       	ldd	r28, Z+8	; 0x08
    2354:	d1 85       	ldd	r29, Z+9	; 0x09
    2356:	8a 81       	ldd	r24, Y+2	; 0x02
    2358:	9b 81       	ldd	r25, Y+3	; 0x03
    235a:	ac 81       	ldd	r26, Y+4	; 0x04
    235c:	bd 81       	ldd	r27, Y+5	; 0x05
    235e:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2362:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2366:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    236a:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    236e:	48 17       	cp	r20, r24
    2370:	59 07       	cpc	r21, r25
    2372:	6a 07       	cpc	r22, r26
    2374:	7b 07       	cpc	r23, r27
    2376:	48 f4       	brcc	.+18     	; 0x238a <vTaskIncrementTick+0x1a2>
    2378:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    237c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2380:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2384:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2388:	2a c0       	rjmp	.+84     	; 0x23de <vTaskIncrementTick+0x1f6>
    238a:	8e 01       	movw	r16, r28
    238c:	0e 5f       	subi	r16, 0xFE	; 254
    238e:	1f 4f       	sbci	r17, 0xFF	; 255
    2390:	c8 01       	movw	r24, r16
    2392:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>
    2396:	88 8d       	ldd	r24, Y+24	; 0x18
    2398:	99 8d       	ldd	r25, Y+25	; 0x19
    239a:	89 2b       	or	r24, r25
    239c:	21 f0       	breq	.+8      	; 0x23a6 <vTaskIncrementTick+0x1be>
    239e:	ce 01       	movw	r24, r28
    23a0:	0e 96       	adiw	r24, 0x0e	; 14
    23a2:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>
    23a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23a8:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    23ac:	98 17       	cp	r25, r24
    23ae:	10 f4       	brcc	.+4      	; 0x23b4 <vTaskIncrementTick+0x1cc>
    23b0:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    23b4:	f8 9e       	mul	r15, r24
    23b6:	c0 01       	movw	r24, r0
    23b8:	11 24       	eor	r1, r1
    23ba:	b8 01       	movw	r22, r16
    23bc:	88 50       	subi	r24, 0x08	; 8
    23be:	9f 4c       	sbci	r25, 0xCF	; 207
    23c0:	0e 94 a6 0a 	call	0x154c	; 0x154c <vListInsertEnd>
    23c4:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    23c8:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    23cc:	80 81       	ld	r24, Z
    23ce:	81 11       	cpse	r24, r1
    23d0:	b9 cf       	rjmp	.-142    	; 0x2344 <vTaskIncrementTick+0x15c>
    23d2:	ac cf       	rjmp	.-168    	; 0x232c <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    23d4:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23d8:	8f 5f       	subi	r24, 0xFF	; 255
    23da:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    23de:	df 91       	pop	r29
    23e0:	cf 91       	pop	r28
    23e2:	1f 91       	pop	r17
    23e4:	0f 91       	pop	r16
    23e6:	ff 90       	pop	r15
    23e8:	08 95       	ret

000023ea <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    23ea:	cf 92       	push	r12
    23ec:	df 92       	push	r13
    23ee:	ef 92       	push	r14
    23f0:	ff 92       	push	r15
    23f2:	0f 93       	push	r16
    23f4:	1f 93       	push	r17
    23f6:	cf 93       	push	r28
    23f8:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    23fa:	0f b6       	in	r0, 0x3f	; 63
    23fc:	f8 94       	cli
    23fe:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2400:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2404:	81 50       	subi	r24, 0x01	; 1
    2406:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    240a:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    240e:	81 11       	cpse	r24, r1
    2410:	60 c0       	rjmp	.+192    	; 0x24d2 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2412:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2416:	81 11       	cpse	r24, r1
    2418:	2c c0       	rjmp	.+88     	; 0x2472 <xTaskResumeAll+0x88>
    241a:	5e c0       	rjmp	.+188    	; 0x24d8 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    241c:	d7 01       	movw	r26, r14
    241e:	17 96       	adiw	r26, 0x07	; 7
    2420:	ed 91       	ld	r30, X+
    2422:	fc 91       	ld	r31, X
    2424:	18 97       	sbiw	r26, 0x08	; 8
    2426:	c0 85       	ldd	r28, Z+8	; 0x08
    2428:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    242a:	ce 01       	movw	r24, r28
    242c:	0e 96       	adiw	r24, 0x0e	; 14
    242e:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2432:	8e 01       	movw	r16, r28
    2434:	0e 5f       	subi	r16, 0xFE	; 254
    2436:	1f 4f       	sbci	r17, 0xFF	; 255
    2438:	c8 01       	movw	r24, r16
    243a:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    243e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2440:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2444:	98 17       	cp	r25, r24
    2446:	10 f4       	brcc	.+4      	; 0x244c <xTaskResumeAll+0x62>
    2448:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    244c:	d8 9e       	mul	r13, r24
    244e:	c0 01       	movw	r24, r0
    2450:	11 24       	eor	r1, r1
    2452:	b8 01       	movw	r22, r16
    2454:	88 50       	subi	r24, 0x08	; 8
    2456:	9f 4c       	sbci	r25, 0xCF	; 207
    2458:	0e 94 a6 0a 	call	0x154c	; 0x154c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    245c:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2460:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2464:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2466:	82 8d       	ldd	r24, Z+26	; 0x1a
    2468:	98 17       	cp	r25, r24
    246a:	70 f0       	brcs	.+28     	; 0x2488 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    246c:	cc 24       	eor	r12, r12
    246e:	c3 94       	inc	r12
    2470:	0b c0       	rjmp	.+22     	; 0x2488 <xTaskResumeAll+0x9e>
    2472:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2474:	0f 2e       	mov	r0, r31
    2476:	f3 ed       	ldi	r31, 0xD3	; 211
    2478:	ef 2e       	mov	r14, r31
    247a:	f0 e3       	ldi	r31, 0x30	; 48
    247c:	ff 2e       	mov	r15, r31
    247e:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2480:	0f 2e       	mov	r0, r31
    2482:	fb e0       	ldi	r31, 0x0B	; 11
    2484:	df 2e       	mov	r13, r31
    2486:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2488:	f7 01       	movw	r30, r14
    248a:	80 81       	ld	r24, Z
    248c:	81 11       	cpse	r24, r1
    248e:	c6 cf       	rjmp	.-116    	; 0x241c <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2490:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2494:	88 23       	and	r24, r24
    2496:	81 f0       	breq	.+32     	; 0x24b8 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2498:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    249c:	88 23       	and	r24, r24
    249e:	99 f0       	breq	.+38     	; 0x24c6 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    24a0:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vTaskIncrementTick>
						--uxMissedTicks;
    24a4:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    24a8:	81 50       	subi	r24, 0x01	; 1
    24aa:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    24ae:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    24b2:	81 11       	cpse	r24, r1
    24b4:	f5 cf       	rjmp	.-22     	; 0x24a0 <xTaskResumeAll+0xb6>
    24b6:	07 c0       	rjmp	.+14     	; 0x24c6 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    24b8:	f1 e0       	ldi	r31, 0x01	; 1
    24ba:	cf 16       	cp	r12, r31
    24bc:	21 f0       	breq	.+8      	; 0x24c6 <xTaskResumeAll+0xdc>
    24be:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    24c2:	81 30       	cpi	r24, 0x01	; 1
    24c4:	41 f4       	brne	.+16     	; 0x24d6 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    24c6:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    24ca:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    24ce:	81 e0       	ldi	r24, 0x01	; 1
    24d0:	03 c0       	rjmp	.+6      	; 0x24d8 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    24d2:	80 e0       	ldi	r24, 0x00	; 0
    24d4:	01 c0       	rjmp	.+2      	; 0x24d8 <xTaskResumeAll+0xee>
    24d6:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    24d8:	0f 90       	pop	r0
    24da:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    24dc:	df 91       	pop	r29
    24de:	cf 91       	pop	r28
    24e0:	1f 91       	pop	r17
    24e2:	0f 91       	pop	r16
    24e4:	ff 90       	pop	r15
    24e6:	ef 90       	pop	r14
    24e8:	df 90       	pop	r13
    24ea:	cf 90       	pop	r12
    24ec:	08 95       	ret

000024ee <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    24ee:	cf 92       	push	r12
    24f0:	df 92       	push	r13
    24f2:	ef 92       	push	r14
    24f4:	ff 92       	push	r15
    24f6:	cf 93       	push	r28
    24f8:	df 93       	push	r29
    24fa:	ec 01       	movw	r28, r24
    24fc:	6a 01       	movw	r12, r20
    24fe:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2500:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2504:	88 81       	ld	r24, Y
    2506:	99 81       	ldd	r25, Y+1	; 0x01
    2508:	aa 81       	ldd	r26, Y+2	; 0x02
    250a:	bb 81       	ldd	r27, Y+3	; 0x03
    250c:	c8 0e       	add	r12, r24
    250e:	d9 1e       	adc	r13, r25
    2510:	ea 1e       	adc	r14, r26
    2512:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2514:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2518:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    251c:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2520:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2524:	48 17       	cp	r20, r24
    2526:	59 07       	cpc	r21, r25
    2528:	6a 07       	cpc	r22, r26
    252a:	7b 07       	cpc	r23, r27
    252c:	b8 f4       	brcc	.+46     	; 0x255c <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    252e:	c8 16       	cp	r12, r24
    2530:	d9 06       	cpc	r13, r25
    2532:	ea 06       	cpc	r14, r26
    2534:	fb 06       	cpc	r15, r27
    2536:	e0 f5       	brcc	.+120    	; 0x25b0 <vTaskDelayUntil+0xc2>
    2538:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    253c:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2540:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2544:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2548:	c8 82       	st	Y, r12
    254a:	d9 82       	std	Y+1, r13	; 0x01
    254c:	ea 82       	std	Y+2, r14	; 0x02
    254e:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2550:	8c 15       	cp	r24, r12
    2552:	9d 05       	cpc	r25, r13
    2554:	ae 05       	cpc	r26, r14
    2556:	bf 05       	cpc	r27, r15
    2558:	f8 f4       	brcc	.+62     	; 0x2598 <vTaskDelayUntil+0xaa>
    255a:	13 c0       	rjmp	.+38     	; 0x2582 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    255c:	c8 16       	cp	r12, r24
    255e:	d9 06       	cpc	r13, r25
    2560:	ea 06       	cpc	r14, r26
    2562:	fb 06       	cpc	r15, r27
    2564:	00 f1       	brcs	.+64     	; 0x25a6 <vTaskDelayUntil+0xb8>
    2566:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    256a:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    256e:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2572:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2576:	8c 15       	cp	r24, r12
    2578:	9d 05       	cpc	r25, r13
    257a:	ae 05       	cpc	r26, r14
    257c:	bf 05       	cpc	r27, r15
    257e:	98 f0       	brcs	.+38     	; 0x25a6 <vTaskDelayUntil+0xb8>
    2580:	17 c0       	rjmp	.+46     	; 0x25b0 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2582:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2586:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    258a:	02 96       	adiw	r24, 0x02	; 2
    258c:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2590:	c7 01       	movw	r24, r14
    2592:	b6 01       	movw	r22, r12
    2594:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2598:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    259c:	81 11       	cpse	r24, r1
    259e:	0d c0       	rjmp	.+26     	; 0x25ba <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    25a0:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
		}
	}
    25a4:	0a c0       	rjmp	.+20     	; 0x25ba <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    25a6:	c8 82       	st	Y, r12
    25a8:	d9 82       	std	Y+1, r13	; 0x01
    25aa:	ea 82       	std	Y+2, r14	; 0x02
    25ac:	fb 82       	std	Y+3, r15	; 0x03
    25ae:	e9 cf       	rjmp	.-46     	; 0x2582 <vTaskDelayUntil+0x94>
    25b0:	c8 82       	st	Y, r12
    25b2:	d9 82       	std	Y+1, r13	; 0x01
    25b4:	ea 82       	std	Y+2, r14	; 0x02
    25b6:	fb 82       	std	Y+3, r15	; 0x03
    25b8:	ef cf       	rjmp	.-34     	; 0x2598 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    25ba:	df 91       	pop	r29
    25bc:	cf 91       	pop	r28
    25be:	ff 90       	pop	r15
    25c0:	ef 90       	pop	r14
    25c2:	df 90       	pop	r13
    25c4:	cf 90       	pop	r12
    25c6:	08 95       	ret

000025c8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    25c8:	cf 92       	push	r12
    25ca:	df 92       	push	r13
    25cc:	ef 92       	push	r14
    25ce:	ff 92       	push	r15
    25d0:	6b 01       	movw	r12, r22
    25d2:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    25d4:	67 2b       	or	r22, r23
    25d6:	68 2b       	or	r22, r24
    25d8:	69 2b       	or	r22, r25
    25da:	e9 f0       	breq	.+58     	; 0x2616 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    25dc:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    25e0:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    25e4:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    25e8:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    25ec:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    25f0:	c8 0e       	add	r12, r24
    25f2:	d9 1e       	adc	r13, r25
    25f4:	ea 1e       	adc	r14, r26
    25f6:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25f8:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    25fc:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2600:	02 96       	adiw	r24, 0x02	; 2
    2602:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2606:	c7 01       	movw	r24, r14
    2608:	b6 01       	movw	r22, r12
    260a:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    260e:	0e 94 f5 11 	call	0x23ea	; 0x23ea <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2612:	81 11       	cpse	r24, r1
    2614:	02 c0       	rjmp	.+4      	; 0x261a <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2616:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vPortYield>
		}
	}
    261a:	ff 90       	pop	r15
    261c:	ef 90       	pop	r14
    261e:	df 90       	pop	r13
    2620:	cf 90       	pop	r12
    2622:	08 95       	ret

00002624 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2624:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2628:	81 11       	cpse	r24, r1
    262a:	0c c0       	rjmp	.+24     	; 0x2644 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    262c:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2630:	4b e0       	ldi	r20, 0x0B	; 11
    2632:	e4 9f       	mul	r30, r20
    2634:	f0 01       	movw	r30, r0
    2636:	11 24       	eor	r1, r1
    2638:	e8 50       	subi	r30, 0x08	; 8
    263a:	ff 4c       	sbci	r31, 0xCF	; 207
    263c:	80 81       	ld	r24, Z
    263e:	88 23       	and	r24, r24
    2640:	29 f0       	breq	.+10     	; 0x264c <vTaskSwitchContext+0x28>
    2642:	14 c0       	rjmp	.+40     	; 0x266c <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    264a:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    264c:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    264e:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2652:	81 50       	subi	r24, 0x01	; 1
    2654:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2658:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    265c:	9e 9f       	mul	r25, r30
    265e:	f0 01       	movw	r30, r0
    2660:	11 24       	eor	r1, r1
    2662:	e8 50       	subi	r30, 0x08	; 8
    2664:	ff 4c       	sbci	r31, 0xCF	; 207
    2666:	80 81       	ld	r24, Z
    2668:	88 23       	and	r24, r24
    266a:	89 f3       	breq	.-30     	; 0x264e <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    266c:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2670:	28 2f       	mov	r18, r24
    2672:	30 e0       	ldi	r19, 0x00	; 0
    2674:	4b e0       	ldi	r20, 0x0B	; 11
    2676:	84 9f       	mul	r24, r20
    2678:	c0 01       	movw	r24, r0
    267a:	11 24       	eor	r1, r1
    267c:	dc 01       	movw	r26, r24
    267e:	a8 50       	subi	r26, 0x08	; 8
    2680:	bf 4c       	sbci	r27, 0xCF	; 207
    2682:	11 96       	adiw	r26, 0x01	; 1
    2684:	ed 91       	ld	r30, X+
    2686:	fc 91       	ld	r31, X
    2688:	12 97       	sbiw	r26, 0x02	; 2
    268a:	04 80       	ldd	r0, Z+4	; 0x04
    268c:	f5 81       	ldd	r31, Z+5	; 0x05
    268e:	e0 2d       	mov	r30, r0
    2690:	11 96       	adiw	r26, 0x01	; 1
    2692:	ed 93       	st	X+, r30
    2694:	fc 93       	st	X, r31
    2696:	12 97       	sbiw	r26, 0x02	; 2
    2698:	85 50       	subi	r24, 0x05	; 5
    269a:	9f 4c       	sbci	r25, 0xCF	; 207
    269c:	e8 17       	cp	r30, r24
    269e:	f9 07       	cpc	r31, r25
    26a0:	61 f4       	brne	.+24     	; 0x26ba <vTaskSwitchContext+0x96>
    26a2:	84 81       	ldd	r24, Z+4	; 0x04
    26a4:	95 81       	ldd	r25, Z+5	; 0x05
    26a6:	4b e0       	ldi	r20, 0x0B	; 11
    26a8:	42 9f       	mul	r20, r18
    26aa:	f0 01       	movw	r30, r0
    26ac:	43 9f       	mul	r20, r19
    26ae:	f0 0d       	add	r31, r0
    26b0:	11 24       	eor	r1, r1
    26b2:	e8 50       	subi	r30, 0x08	; 8
    26b4:	ff 4c       	sbci	r31, 0xCF	; 207
    26b6:	81 83       	std	Z+1, r24	; 0x01
    26b8:	92 83       	std	Z+2, r25	; 0x02
    26ba:	8b e0       	ldi	r24, 0x0B	; 11
    26bc:	82 9f       	mul	r24, r18
    26be:	f0 01       	movw	r30, r0
    26c0:	83 9f       	mul	r24, r19
    26c2:	f0 0d       	add	r31, r0
    26c4:	11 24       	eor	r1, r1
    26c6:	e8 50       	subi	r30, 0x08	; 8
    26c8:	ff 4c       	sbci	r31, 0xCF	; 207
    26ca:	01 80       	ldd	r0, Z+1	; 0x01
    26cc:	f2 81       	ldd	r31, Z+2	; 0x02
    26ce:	e0 2d       	mov	r30, r0
    26d0:	80 85       	ldd	r24, Z+8	; 0x08
    26d2:	91 85       	ldd	r25, Z+9	; 0x09
    26d4:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    26d8:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    26dc:	08 95       	ret

000026de <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    26de:	cf 92       	push	r12
    26e0:	df 92       	push	r13
    26e2:	ef 92       	push	r14
    26e4:	ff 92       	push	r15
    26e6:	6a 01       	movw	r12, r20
    26e8:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    26ea:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    26ee:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    26f2:	62 5f       	subi	r22, 0xF2	; 242
    26f4:	7f 4f       	sbci	r23, 0xFF	; 255
    26f6:	0e 94 cd 0a 	call	0x159a	; 0x159a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    26fa:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    26fe:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2702:	02 96       	adiw	r24, 0x02	; 2
    2704:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2708:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    270c:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2710:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2714:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2718:	bc 01       	movw	r22, r24
    271a:	cd 01       	movw	r24, r26
    271c:	6c 0d       	add	r22, r12
    271e:	7d 1d       	adc	r23, r13
    2720:	8e 1d       	adc	r24, r14
    2722:	9f 1d       	adc	r25, r15
    2724:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2728:	ff 90       	pop	r15
    272a:	ef 90       	pop	r14
    272c:	df 90       	pop	r13
    272e:	cf 90       	pop	r12
    2730:	08 95       	ret

00002732 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2732:	0f 93       	push	r16
    2734:	1f 93       	push	r17
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    273a:	dc 01       	movw	r26, r24
    273c:	17 96       	adiw	r26, 0x07	; 7
    273e:	ed 91       	ld	r30, X+
    2740:	fc 91       	ld	r31, X
    2742:	18 97       	sbiw	r26, 0x08	; 8
    2744:	c0 85       	ldd	r28, Z+8	; 0x08
    2746:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2748:	8e 01       	movw	r16, r28
    274a:	02 5f       	subi	r16, 0xF2	; 242
    274c:	1f 4f       	sbci	r17, 0xFF	; 255
    274e:	c8 01       	movw	r24, r16
    2750:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2754:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2758:	81 11       	cpse	r24, r1
    275a:	16 c0       	rjmp	.+44     	; 0x2788 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    275c:	0c 50       	subi	r16, 0x0C	; 12
    275e:	11 09       	sbc	r17, r1
    2760:	c8 01       	movw	r24, r16
    2762:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2766:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2768:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    276c:	98 17       	cp	r25, r24
    276e:	10 f4       	brcc	.+4      	; 0x2774 <xTaskRemoveFromEventList+0x42>
    2770:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2774:	bb e0       	ldi	r27, 0x0B	; 11
    2776:	8b 9f       	mul	r24, r27
    2778:	c0 01       	movw	r24, r0
    277a:	11 24       	eor	r1, r1
    277c:	b8 01       	movw	r22, r16
    277e:	88 50       	subi	r24, 0x08	; 8
    2780:	9f 4c       	sbci	r25, 0xCF	; 207
    2782:	0e 94 a6 0a 	call	0x154c	; 0x154c <vListInsertEnd>
    2786:	05 c0       	rjmp	.+10     	; 0x2792 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2788:	b8 01       	movw	r22, r16
    278a:	83 ed       	ldi	r24, 0xD3	; 211
    278c:	90 e3       	ldi	r25, 0x30	; 48
    278e:	0e 94 a6 0a 	call	0x154c	; 0x154c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2792:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2796:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    279a:	81 e0       	ldi	r24, 0x01	; 1
    279c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    279e:	92 8d       	ldd	r25, Z+26	; 0x1a
    27a0:	29 17       	cp	r18, r25
    27a2:	08 f4       	brcc	.+2      	; 0x27a6 <xTaskRemoveFromEventList+0x74>
    27a4:	80 e0       	ldi	r24, 0x00	; 0
}
    27a6:	df 91       	pop	r29
    27a8:	cf 91       	pop	r28
    27aa:	1f 91       	pop	r17
    27ac:	0f 91       	pop	r16
    27ae:	08 95       	ret

000027b0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    27b0:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    27b4:	fc 01       	movw	r30, r24
    27b6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    27b8:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    27bc:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    27c0:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    27c4:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    27c8:	41 83       	std	Z+1, r20	; 0x01
    27ca:	52 83       	std	Z+2, r21	; 0x02
    27cc:	63 83       	std	Z+3, r22	; 0x03
    27ce:	74 83       	std	Z+4, r23	; 0x04
    27d0:	08 95       	ret

000027d2 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    27d2:	8f 92       	push	r8
    27d4:	9f 92       	push	r9
    27d6:	af 92       	push	r10
    27d8:	bf 92       	push	r11
    27da:	cf 92       	push	r12
    27dc:	df 92       	push	r13
    27de:	ef 92       	push	r14
    27e0:	ff 92       	push	r15
    27e2:	0f 93       	push	r16
    27e4:	1f 93       	push	r17
    27e6:	cf 93       	push	r28
    27e8:	df 93       	push	r29
    27ea:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    27ec:	0f b6       	in	r0, 0x3f	; 63
    27ee:	f8 94       	cli
    27f0:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    27f2:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    27f6:	90 81       	ld	r25, Z
    27f8:	98 17       	cp	r25, r24
    27fa:	89 f0       	breq	.+34     	; 0x281e <xTaskCheckForTimeOut+0x4c>
    27fc:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2800:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2804:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2808:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    280c:	01 81       	ldd	r16, Z+1	; 0x01
    280e:	12 81       	ldd	r17, Z+2	; 0x02
    2810:	23 81       	ldd	r18, Z+3	; 0x03
    2812:	34 81       	ldd	r19, Z+4	; 0x04
    2814:	80 17       	cp	r24, r16
    2816:	91 07       	cpc	r25, r17
    2818:	a2 07       	cpc	r26, r18
    281a:	b3 07       	cpc	r27, r19
    281c:	a8 f5       	brcc	.+106    	; 0x2888 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    281e:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2822:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2826:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    282a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    282e:	c1 80       	ldd	r12, Z+1	; 0x01
    2830:	d2 80       	ldd	r13, Z+2	; 0x02
    2832:	e3 80       	ldd	r14, Z+3	; 0x03
    2834:	f4 80       	ldd	r15, Z+4	; 0x04
    2836:	eb 01       	movw	r28, r22
    2838:	08 81       	ld	r16, Y
    283a:	19 81       	ldd	r17, Y+1	; 0x01
    283c:	2a 81       	ldd	r18, Y+2	; 0x02
    283e:	3b 81       	ldd	r19, Y+3	; 0x03
    2840:	8c 19       	sub	r24, r12
    2842:	9d 09       	sbc	r25, r13
    2844:	ae 09       	sbc	r26, r14
    2846:	bf 09       	sbc	r27, r15
    2848:	80 17       	cp	r24, r16
    284a:	91 07       	cpc	r25, r17
    284c:	a2 07       	cpc	r26, r18
    284e:	b3 07       	cpc	r27, r19
    2850:	e8 f4       	brcc	.+58     	; 0x288c <xTaskCheckForTimeOut+0xba>
    2852:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2854:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    2858:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    285c:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2860:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2864:	b5 01       	movw	r22, r10
    2866:	a4 01       	movw	r20, r8
    2868:	4c 19       	sub	r20, r12
    286a:	5d 09       	sbc	r21, r13
    286c:	6e 09       	sbc	r22, r14
    286e:	7f 09       	sbc	r23, r15
    2870:	04 1b       	sub	r16, r20
    2872:	15 0b       	sbc	r17, r21
    2874:	26 0b       	sbc	r18, r22
    2876:	37 0b       	sbc	r19, r23
    2878:	08 83       	st	Y, r16
    287a:	19 83       	std	Y+1, r17	; 0x01
    287c:	2a 83       	std	Y+2, r18	; 0x02
    287e:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2880:	0e 94 d8 13 	call	0x27b0	; 0x27b0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2884:	80 e0       	ldi	r24, 0x00	; 0
    2886:	03 c0       	rjmp	.+6      	; 0x288e <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2888:	81 e0       	ldi	r24, 0x01	; 1
    288a:	01 c0       	rjmp	.+2      	; 0x288e <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    288c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    288e:	0f 90       	pop	r0
    2890:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2892:	df 91       	pop	r29
    2894:	cf 91       	pop	r28
    2896:	1f 91       	pop	r17
    2898:	0f 91       	pop	r16
    289a:	ff 90       	pop	r15
    289c:	ef 90       	pop	r14
    289e:	df 90       	pop	r13
    28a0:	cf 90       	pop	r12
    28a2:	bf 90       	pop	r11
    28a4:	af 90       	pop	r10
    28a6:	9f 90       	pop	r9
    28a8:	8f 90       	pop	r8
    28aa:	08 95       	ret

000028ac <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    28ac:	81 e0       	ldi	r24, 0x01	; 1
    28ae:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    28b2:	08 95       	ret

000028b4 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    28b4:	00 97       	sbiw	r24, 0x00	; 0
    28b6:	21 f4       	brne	.+8      	; 0x28c0 <uxTaskGetStackHighWaterMark+0xc>
    28b8:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    28bc:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    28c0:	dc 01       	movw	r26, r24
    28c2:	5b 96       	adiw	r26, 0x1b	; 27
    28c4:	ed 91       	ld	r30, X+
    28c6:	fc 91       	ld	r31, X
    28c8:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    28ca:	80 81       	ld	r24, Z
    28cc:	81 31       	cpi	r24, 0x11	; 17
    28ce:	41 f4       	brne	.+16     	; 0x28e0 <uxTaskGetStackHighWaterMark+0x2c>
    28d0:	31 96       	adiw	r30, 0x01	; 1
    28d2:	80 e0       	ldi	r24, 0x00	; 0
    28d4:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    28d6:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    28d8:	21 91       	ld	r18, Z+
    28da:	21 31       	cpi	r18, 0x11	; 17
    28dc:	e1 f3       	breq	.-8      	; 0x28d6 <uxTaskGetStackHighWaterMark+0x22>
    28de:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    28e0:	80 e0       	ldi	r24, 0x00	; 0
    28e2:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    28e4:	08 95       	ret

000028e6 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    28e6:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    28ea:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    28ee:	08 95       	ret

000028f0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    28f0:	0f 93       	push	r16
    28f2:	1f 93       	push	r17
    28f4:	cf 93       	push	r28
    28f6:	df 93       	push	r29
    28f8:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    28fa:	22 8d       	ldd	r18, Z+26	; 0x1a
    28fc:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2900:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2904:	5a 96       	adiw	r26, 0x1a	; 26
    2906:	8c 91       	ld	r24, X
    2908:	28 17       	cp	r18, r24
    290a:	08 f0       	brcs	.+2      	; 0x290e <vTaskPriorityInherit+0x1e>
    290c:	41 c0       	rjmp	.+130    	; 0x2990 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    290e:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2912:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2916:	5a 96       	adiw	r26, 0x1a	; 26
    2918:	3c 91       	ld	r19, X
    291a:	84 e0       	ldi	r24, 0x04	; 4
    291c:	90 e0       	ldi	r25, 0x00	; 0
    291e:	a0 e0       	ldi	r26, 0x00	; 0
    2920:	b0 e0       	ldi	r27, 0x00	; 0
    2922:	83 1b       	sub	r24, r19
    2924:	91 09       	sbc	r25, r1
    2926:	a1 09       	sbc	r26, r1
    2928:	b1 09       	sbc	r27, r1
    292a:	86 87       	std	Z+14, r24	; 0x0e
    292c:	97 87       	std	Z+15, r25	; 0x0f
    292e:	a0 8b       	std	Z+16, r26	; 0x10
    2930:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2932:	8b e0       	ldi	r24, 0x0B	; 11
    2934:	28 9f       	mul	r18, r24
    2936:	90 01       	movw	r18, r0
    2938:	11 24       	eor	r1, r1
    293a:	28 50       	subi	r18, 0x08	; 8
    293c:	3f 4c       	sbci	r19, 0xCF	; 207
    293e:	84 85       	ldd	r24, Z+12	; 0x0c
    2940:	95 85       	ldd	r25, Z+13	; 0x0d
    2942:	82 17       	cp	r24, r18
    2944:	93 07       	cpc	r25, r19
    2946:	e9 f4       	brne	.+58     	; 0x2982 <vTaskPriorityInherit+0x92>
    2948:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    294a:	ef 01       	movw	r28, r30
    294c:	22 96       	adiw	r28, 0x02	; 2
    294e:	ce 01       	movw	r24, r28
    2950:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2954:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2958:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    295c:	82 8d       	ldd	r24, Z+26	; 0x1a
    295e:	f8 01       	movw	r30, r16
    2960:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2962:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2966:	98 17       	cp	r25, r24
    2968:	10 f4       	brcc	.+4      	; 0x296e <vTaskPriorityInherit+0x7e>
    296a:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    296e:	fb e0       	ldi	r31, 0x0B	; 11
    2970:	8f 9f       	mul	r24, r31
    2972:	c0 01       	movw	r24, r0
    2974:	11 24       	eor	r1, r1
    2976:	be 01       	movw	r22, r28
    2978:	88 50       	subi	r24, 0x08	; 8
    297a:	9f 4c       	sbci	r25, 0xCF	; 207
    297c:	0e 94 a6 0a 	call	0x154c	; 0x154c <vListInsertEnd>
    2980:	07 c0       	rjmp	.+14     	; 0x2990 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2982:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2986:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    298a:	5a 96       	adiw	r26, 0x1a	; 26
    298c:	8c 91       	ld	r24, X
    298e:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2990:	df 91       	pop	r29
    2992:	cf 91       	pop	r28
    2994:	1f 91       	pop	r17
    2996:	0f 91       	pop	r16
    2998:	08 95       	ret

0000299a <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    299a:	0f 93       	push	r16
    299c:	1f 93       	push	r17
    299e:	cf 93       	push	r28
    29a0:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    29a2:	00 97       	sbiw	r24, 0x00	; 0
    29a4:	49 f1       	breq	.+82     	; 0x29f8 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    29a6:	fc 01       	movw	r30, r24
    29a8:	32 8d       	ldd	r19, Z+26	; 0x1a
    29aa:	27 a1       	ldd	r18, Z+39	; 0x27
    29ac:	32 17       	cp	r19, r18
    29ae:	21 f1       	breq	.+72     	; 0x29f8 <vTaskPriorityDisinherit+0x5e>
    29b0:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    29b2:	8c 01       	movw	r16, r24
    29b4:	0e 5f       	subi	r16, 0xFE	; 254
    29b6:	1f 4f       	sbci	r17, 0xFF	; 255
    29b8:	c8 01       	movw	r24, r16
    29ba:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    29be:	8f a1       	ldd	r24, Y+39	; 0x27
    29c0:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    29c2:	44 e0       	ldi	r20, 0x04	; 4
    29c4:	50 e0       	ldi	r21, 0x00	; 0
    29c6:	60 e0       	ldi	r22, 0x00	; 0
    29c8:	70 e0       	ldi	r23, 0x00	; 0
    29ca:	48 1b       	sub	r20, r24
    29cc:	51 09       	sbc	r21, r1
    29ce:	61 09       	sbc	r22, r1
    29d0:	71 09       	sbc	r23, r1
    29d2:	4e 87       	std	Y+14, r20	; 0x0e
    29d4:	5f 87       	std	Y+15, r21	; 0x0f
    29d6:	68 8b       	std	Y+16, r22	; 0x10
    29d8:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    29da:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    29de:	98 17       	cp	r25, r24
    29e0:	10 f4       	brcc	.+4      	; 0x29e6 <vTaskPriorityDisinherit+0x4c>
    29e2:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    29e6:	fb e0       	ldi	r31, 0x0B	; 11
    29e8:	8f 9f       	mul	r24, r31
    29ea:	c0 01       	movw	r24, r0
    29ec:	11 24       	eor	r1, r1
    29ee:	b8 01       	movw	r22, r16
    29f0:	88 50       	subi	r24, 0x08	; 8
    29f2:	9f 4c       	sbci	r25, 0xCF	; 207
    29f4:	0e 94 a6 0a 	call	0x154c	; 0x154c <vListInsertEnd>
			}
		}
	}
    29f8:	df 91       	pop	r29
    29fa:	cf 91       	pop	r28
    29fc:	1f 91       	pop	r17
    29fe:	0f 91       	pop	r16
    2a00:	08 95       	ret

00002a02 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2a02:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2a04:	e8 81       	ld	r30, Y
    2a06:	f9 81       	ldd	r31, Y+1	; 0x01
    2a08:	01 90       	ld	r0, Z+
    2a0a:	f0 81       	ld	r31, Z
    2a0c:	e0 2d       	mov	r30, r0
    2a0e:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2a10:	1a 82       	std	Y+2, r1	; 0x02
    2a12:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2a14:	6f ef       	ldi	r22, 0xFF	; 255
    2a16:	7f ef       	ldi	r23, 0xFF	; 255
    2a18:	cb 01       	movw	r24, r22
    2a1a:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <vTaskDelay>
    2a1e:	fa cf       	rjmp	.-12     	; 0x2a14 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002a20 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2a20:	fc 01       	movw	r30, r24
    2a22:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2a24:	65 87       	std	Z+13, r22	; 0x0d
    2a26:	08 95       	ret

00002a28 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2a28:	4f 92       	push	r4
    2a2a:	5f 92       	push	r5
    2a2c:	6f 92       	push	r6
    2a2e:	7f 92       	push	r7
    2a30:	8f 92       	push	r8
    2a32:	9f 92       	push	r9
    2a34:	af 92       	push	r10
    2a36:	bf 92       	push	r11
    2a38:	cf 92       	push	r12
    2a3a:	df 92       	push	r13
    2a3c:	ef 92       	push	r14
    2a3e:	ff 92       	push	r15
    2a40:	0f 93       	push	r16
    2a42:	1f 93       	push	r17
    2a44:	cf 93       	push	r28
    2a46:	df 93       	push	r29
    2a48:	cd b7       	in	r28, 0x3d	; 61
    2a4a:	de b7       	in	r29, 0x3e	; 62
    2a4c:	2a 97       	sbiw	r28, 0x0a	; 10
    2a4e:	cd bf       	out	0x3d, r28	; 61
    2a50:	de bf       	out	0x3e, r29	; 62
    2a52:	4c 01       	movw	r8, r24
    2a54:	29 01       	movw	r4, r18
    2a56:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2a58:	8f e3       	ldi	r24, 0x3F	; 63
    2a5a:	90 e2       	ldi	r25, 0x20	; 32
    2a5c:	f4 01       	movw	r30, r8
    2a5e:	80 83       	st	Z, r24
    2a60:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2a62:	fb 01       	movw	r30, r22
    2a64:	80 81       	ld	r24, Z
    2a66:	88 23       	and	r24, r24
    2a68:	69 f0       	breq	.+26     	; 0x2a84 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2a6a:	de 01       	movw	r26, r28
    2a6c:	11 96       	adiw	r26, 0x01	; 1
    2a6e:	31 96       	adiw	r30, 0x01	; 1
    2a70:	90 e0       	ldi	r25, 0x00	; 0
    2a72:	02 c0       	rjmp	.+4      	; 0x2a78 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2a74:	99 30       	cpi	r25, 0x09	; 9
    2a76:	39 f0       	breq	.+14     	; 0x2a86 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2a78:	9f 5f       	subi	r25, 0xFF	; 255
    2a7a:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2a7c:	81 91       	ld	r24, Z+
    2a7e:	81 11       	cpse	r24, r1
    2a80:	f9 cf       	rjmp	.-14     	; 0x2a74 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2a82:	01 c0       	rjmp	.+2      	; 0x2a86 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2a84:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2a86:	e1 e0       	ldi	r30, 0x01	; 1
    2a88:	f0 e0       	ldi	r31, 0x00	; 0
    2a8a:	ec 0f       	add	r30, r28
    2a8c:	fd 1f       	adc	r31, r29
    2a8e:	e9 0f       	add	r30, r25
    2a90:	f1 1d       	adc	r31, r1
    2a92:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2a94:	74 01       	movw	r14, r8
    2a96:	f2 e0       	ldi	r31, 0x02	; 2
    2a98:	ef 0e       	add	r14, r31
    2a9a:	f1 1c       	adc	r15, r1
    2a9c:	a1 2c       	mov	r10, r1
    2a9e:	b1 2c       	mov	r11, r1
    2aa0:	c1 2c       	mov	r12, r1
    2aa2:	d1 2c       	mov	r13, r1
    2aa4:	04 2f       	mov	r16, r20
    2aa6:	94 01       	movw	r18, r8
    2aa8:	a2 01       	movw	r20, r4
    2aaa:	be 01       	movw	r22, r28
    2aac:	6f 5f       	subi	r22, 0xFF	; 255
    2aae:	7f 4f       	sbci	r23, 0xFF	; 255
    2ab0:	86 ea       	ldi	r24, 0xA6	; 166
    2ab2:	92 e0       	ldi	r25, 0x02	; 2
    2ab4:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2ab8:	f4 01       	movw	r30, r8
    2aba:	66 82       	std	Z+6, r6	; 0x06
    2abc:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2abe:	40 86       	std	Z+8, r4	; 0x08
    2ac0:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2ac2:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    2ac6:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2aca:	24 83       	std	Z+4, r18	; 0x04
    2acc:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2ace:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    2ad2:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2ad6:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2ad8:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2ada:	40 90 60 31 	lds	r4, 0x3160	; 0x803160 <portStackTopForTask>
    2ade:	50 90 61 31 	lds	r5, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    2ae2:	ff ef       	ldi	r31, 0xFF	; 255
    2ae4:	4f 1a       	sub	r4, r31
    2ae6:	5f 0a       	sbc	r5, r31
    2ae8:	40 92 60 31 	sts	0x3160, r4	; 0x803160 <portStackTopForTask>
    2aec:	50 92 61 31 	sts	0x3161, r5	; 0x803161 <portStackTopForTask+0x1>
    2af0:	f4 01       	movw	r30, r8
    2af2:	42 86       	std	Z+10, r4	; 0x0a
    2af4:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2af6:	16 86       	std	Z+14, r1	; 0x0e
    2af8:	17 86       	std	Z+15, r1	; 0x0f
    2afa:	10 8a       	std	Z+16, r1	; 0x10
    2afc:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2afe:	61 14       	cp	r6, r1
    2b00:	71 04       	cpc	r7, r1
    2b02:	09 f4       	brne	.+2      	; 0x2b06 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2b04:	44 c0       	rjmp	.+136    	; 0x2b8e <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2b06:	81 30       	cpi	r24, 0x01	; 1
    2b08:	79 f5       	brne	.+94     	; 0x2b68 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2b0a:	6a e0       	ldi	r22, 0x0A	; 10
    2b0c:	c3 01       	movw	r24, r6
    2b0e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2b12:	7c 01       	movw	r14, r24
    2b14:	69 e9       	ldi	r22, 0x99	; 153
    2b16:	74 e0       	ldi	r23, 0x04	; 4
    2b18:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2b1c:	be 01       	movw	r22, r28
    2b1e:	6f 5f       	subi	r22, 0xFF	; 255
    2b20:	7f 4f       	sbci	r23, 0xFF	; 255
    2b22:	c7 01       	movw	r24, r14
    2b24:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2b28:	6a e0       	ldi	r22, 0x0A	; 10
    2b2a:	c7 01       	movw	r24, r14
    2b2c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2b30:	7c 01       	movw	r14, r24
    2b32:	60 e9       	ldi	r22, 0x90	; 144
    2b34:	74 e0       	ldi	r23, 0x04	; 4
    2b36:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2b3a:	6a e0       	ldi	r22, 0x0A	; 10
    2b3c:	c7 01       	movw	r24, r14
    2b3e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2b42:	7c 01       	movw	r14, r24
    2b44:	62 e8       	ldi	r22, 0x82	; 130
    2b46:	74 e0       	ldi	r23, 0x04	; 4
    2b48:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2b4c:	63 e0       	ldi	r22, 0x03	; 3
    2b4e:	c7 01       	movw	r24, r14
    2b50:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2b54:	b2 01       	movw	r22, r4
    2b56:	0e 94 c5 1a 	call	0x358a	; 0x358a <_ZN8emstreamlsEj>
    2b5a:	62 e0       	ldi	r22, 0x02	; 2
    2b5c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2b60:	66 e0       	ldi	r22, 0x06	; 6
    2b62:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2b66:	13 c0       	rjmp	.+38     	; 0x2b8e <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2b68:	6a e0       	ldi	r22, 0x0A	; 10
    2b6a:	c3 01       	movw	r24, r6
    2b6c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2b70:	4c 01       	movw	r8, r24
    2b72:	6d e6       	ldi	r22, 0x6D	; 109
    2b74:	74 e0       	ldi	r23, 0x04	; 4
    2b76:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2b7a:	be 01       	movw	r22, r28
    2b7c:	6f 5f       	subi	r22, 0xFF	; 255
    2b7e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b80:	c4 01       	movw	r24, r8
    2b82:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2b86:	66 e0       	ldi	r22, 0x06	; 6
    2b88:	c4 01       	movw	r24, r8
    2b8a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2b8e:	2a 96       	adiw	r28, 0x0a	; 10
    2b90:	cd bf       	out	0x3d, r28	; 61
    2b92:	de bf       	out	0x3e, r29	; 62
    2b94:	df 91       	pop	r29
    2b96:	cf 91       	pop	r28
    2b98:	1f 91       	pop	r17
    2b9a:	0f 91       	pop	r16
    2b9c:	ff 90       	pop	r15
    2b9e:	ef 90       	pop	r14
    2ba0:	df 90       	pop	r13
    2ba2:	cf 90       	pop	r12
    2ba4:	bf 90       	pop	r11
    2ba6:	af 90       	pop	r10
    2ba8:	9f 90       	pop	r9
    2baa:	8f 90       	pop	r8
    2bac:	7f 90       	pop	r7
    2bae:	6f 90       	pop	r6
    2bb0:	5f 90       	pop	r5
    2bb2:	4f 90       	pop	r4
    2bb4:	08 95       	ret

00002bb6 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2bb6:	cf 92       	push	r12
    2bb8:	df 92       	push	r13
    2bba:	ef 92       	push	r14
    2bbc:	ff 92       	push	r15
    2bbe:	0f 93       	push	r16
    2bc0:	1f 93       	push	r17
    2bc2:	cf 93       	push	r28
    2bc4:	df 93       	push	r29
    2bc6:	ec 01       	movw	r28, r24
    2bc8:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2bca:	8a 81       	ldd	r24, Y+2	; 0x02
    2bcc:	9b 81       	ldd	r25, Y+3	; 0x03
    2bce:	0e 94 e7 10 	call	0x21ce	; 0x21ce <pcTaskGetTaskName>
    2bd2:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2bd4:	6a e0       	ldi	r22, 0x0A	; 10
    2bd6:	c7 01       	movw	r24, r14
    2bd8:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2bdc:	8c 01       	movw	r16, r24
    2bde:	6c ea       	ldi	r22, 0xAC	; 172
    2be0:	74 e0       	ldi	r23, 0x04	; 4
    2be2:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2be6:	6a e0       	ldi	r22, 0x0A	; 10
    2be8:	c8 01       	movw	r24, r16
    2bea:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2bee:	8c 01       	movw	r16, r24
    2bf0:	65 ea       	ldi	r22, 0xA5	; 165
    2bf2:	74 e0       	ldi	r23, 0x04	; 4
    2bf4:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2bf8:	b6 01       	movw	r22, r12
    2bfa:	c8 01       	movw	r24, r16
    2bfc:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2c00:	6a e0       	ldi	r22, 0x0A	; 10
    2c02:	c8 01       	movw	r24, r16
    2c04:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2c08:	8c 01       	movw	r16, r24
    2c0a:	6f e9       	ldi	r22, 0x9F	; 159
    2c0c:	74 e0       	ldi	r23, 0x04	; 4
    2c0e:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2c12:	66 e0       	ldi	r22, 0x06	; 6
    2c14:	c8 01       	movw	r24, r16
    2c16:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2c1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c1e:	e8 85       	ldd	r30, Y+8	; 0x08
    2c20:	f9 85       	ldd	r31, Y+9	; 0x09
    2c22:	01 e1       	ldi	r16, 0x11	; 17
    2c24:	21 e0       	ldi	r18, 0x01	; 1
    2c26:	a7 01       	movw	r20, r14
    2c28:	bc 01       	movw	r22, r24
    2c2a:	8e 1b       	sub	r24, r30
    2c2c:	9f 0b       	sbc	r25, r31
    2c2e:	0e 94 dd 18 	call	0x31ba	; 0x31ba <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2c32:	8c 81       	ldd	r24, Y+4	; 0x04
    2c34:	9d 81       	ldd	r25, Y+5	; 0x05
    2c36:	00 97       	sbiw	r24, 0x00	; 0
    2c38:	19 f0       	breq	.+6      	; 0x2c40 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2c3a:	b7 01       	movw	r22, r14
    2c3c:	0e 94 db 15 	call	0x2bb6	; 0x2bb6 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2c40:	df 91       	pop	r29
    2c42:	cf 91       	pop	r28
    2c44:	1f 91       	pop	r17
    2c46:	0f 91       	pop	r16
    2c48:	ff 90       	pop	r15
    2c4a:	ef 90       	pop	r14
    2c4c:	df 90       	pop	r13
    2c4e:	cf 90       	pop	r12
    2c50:	08 95       	ret

00002c52 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2c52:	0f 93       	push	r16
    2c54:	1f 93       	push	r17
    2c56:	cf 93       	push	r28
    2c58:	df 93       	push	r29
    2c5a:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2c5c:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2c60:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2c64:	00 97       	sbiw	r24, 0x00	; 0
    2c66:	19 f0       	breq	.+6      	; 0x2c6e <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2c68:	be 01       	movw	r22, r28
    2c6a:	0e 94 db 15 	call	0x2bb6	; 0x2bb6 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2c6e:	6a e0       	ldi	r22, 0x0A	; 10
    2c70:	ce 01       	movw	r24, r28
    2c72:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2c76:	8c 01       	movw	r16, r24
    2c78:	62 ec       	ldi	r22, 0xC2	; 194
    2c7a:	74 e0       	ldi	r23, 0x04	; 4
    2c7c:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2c80:	6a e0       	ldi	r22, 0x0A	; 10
    2c82:	c8 01       	movw	r24, r16
    2c84:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2c88:	8c 01       	movw	r16, r24
    2c8a:	67 eb       	ldi	r22, 0xB7	; 183
    2c8c:	74 e0       	ldi	r23, 0x04	; 4
    2c8e:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2c92:	6a e0       	ldi	r22, 0x0A	; 10
    2c94:	c8 01       	movw	r24, r16
    2c96:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2c9a:	8c 01       	movw	r16, r24
    2c9c:	61 eb       	ldi	r22, 0xB1	; 177
    2c9e:	74 e0       	ldi	r23, 0x04	; 4
    2ca0:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2ca4:	66 e0       	ldi	r22, 0x06	; 6
    2ca6:	c8 01       	movw	r24, r16
    2ca8:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2cac:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <portStackTopForTask>
    2cb0:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    2cb4:	bc 01       	movw	r22, r24
    2cb6:	6f 5f       	subi	r22, 0xFF	; 255
    2cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2cba:	01 e1       	ldi	r16, 0x11	; 17
    2cbc:	21 e0       	ldi	r18, 0x01	; 1
    2cbe:	ae 01       	movw	r20, r28
    2cc0:	83 56       	subi	r24, 0x63	; 99
    2cc2:	91 09       	sbc	r25, r1
    2cc4:	0e 94 dd 18 	call	0x31ba	; 0x31ba <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2cc8:	df 91       	pop	r29
    2cca:	cf 91       	pop	r28
    2ccc:	1f 91       	pop	r17
    2cce:	0f 91       	pop	r16
    2cd0:	08 95       	ret

00002cd2 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2cd2:	8f 92       	push	r8
    2cd4:	9f 92       	push	r9
    2cd6:	af 92       	push	r10
    2cd8:	bf 92       	push	r11
    2cda:	cf 92       	push	r12
    2cdc:	df 92       	push	r13
    2cde:	ef 92       	push	r14
    2ce0:	ff 92       	push	r15
    2ce2:	0f 93       	push	r16
    2ce4:	1f 93       	push	r17
    2ce6:	cf 93       	push	r28
    2ce8:	df 93       	push	r29
    2cea:	ec 01       	movw	r28, r24
    2cec:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2cee:	8a 81       	ldd	r24, Y+2	; 0x02
    2cf0:	9b 81       	ldd	r25, Y+3	; 0x03
    2cf2:	0e 94 e7 10 	call	0x21ce	; 0x21ce <pcTaskGetTaskName>
    2cf6:	bc 01       	movw	r22, r24
    2cf8:	c8 01       	movw	r24, r16
    2cfa:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2cfe:	d8 01       	movw	r26, r16
    2d00:	ed 91       	ld	r30, X+
    2d02:	fc 91       	ld	r31, X
    2d04:	02 80       	ldd	r0, Z+2	; 0x02
    2d06:	f3 81       	ldd	r31, Z+3	; 0x03
    2d08:	e0 2d       	mov	r30, r0
    2d0a:	69 e0       	ldi	r22, 0x09	; 9
    2d0c:	c8 01       	movw	r24, r16
    2d0e:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2d10:	8a 81       	ldd	r24, Y+2	; 0x02
    2d12:	9b 81       	ldd	r25, Y+3	; 0x03
    2d14:	0e 94 e7 10 	call	0x21ce	; 0x21ce <pcTaskGetTaskName>
    2d18:	fc 01       	movw	r30, r24
    2d1a:	01 90       	ld	r0, Z+
    2d1c:	00 20       	and	r0, r0
    2d1e:	e9 f7       	brne	.-6      	; 0x2d1a <_ZN8frt_task12print_statusER8emstream+0x48>
    2d20:	31 97       	sbiw	r30, 0x01	; 1
    2d22:	e8 1b       	sub	r30, r24
    2d24:	f9 0b       	sbc	r31, r25
    2d26:	38 97       	sbiw	r30, 0x08	; 8
    2d28:	48 f4       	brcc	.+18     	; 0x2d3c <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2d2a:	d8 01       	movw	r26, r16
    2d2c:	ed 91       	ld	r30, X+
    2d2e:	fc 91       	ld	r31, X
    2d30:	02 80       	ldd	r0, Z+2	; 0x02
    2d32:	f3 81       	ldd	r31, Z+3	; 0x03
    2d34:	e0 2d       	mov	r30, r0
    2d36:	69 e0       	ldi	r22, 0x09	; 9
    2d38:	c8 01       	movw	r24, r16
    2d3a:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2d3c:	ce 84       	ldd	r12, Y+14	; 0x0e
    2d3e:	df 84       	ldd	r13, Y+15	; 0x0f
    2d40:	e8 88       	ldd	r14, Y+16	; 0x10
    2d42:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2d44:	a8 84       	ldd	r10, Y+8	; 0x08
    2d46:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2d48:	8a 81       	ldd	r24, Y+2	; 0x02
    2d4a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d4c:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <uxTaskGetStackHighWaterMark>
    2d50:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2d52:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2d54:	8a 81       	ldd	r24, Y+2	; 0x02
    2d56:	9b 81       	ldd	r25, Y+3	; 0x03
    2d58:	0e 94 92 10 	call	0x2124	; 0x2124 <uxTaskPriorityGet>
    2d5c:	68 2f       	mov	r22, r24
    2d5e:	c8 01       	movw	r24, r16
    2d60:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
    2d64:	6a e0       	ldi	r22, 0x0A	; 10
    2d66:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2d6a:	ec 01       	movw	r28, r24
    2d6c:	67 e3       	ldi	r22, 0x37	; 55
    2d6e:	75 e0       	ldi	r23, 0x05	; 5
    2d70:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
			<< get_state ()
    2d74:	68 2d       	mov	r22, r8
    2d76:	ce 01       	movw	r24, r28
    2d78:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2d7c:	6a e0       	ldi	r22, 0x0A	; 10
    2d7e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2d82:	ec 01       	movw	r28, r24
    2d84:	65 e3       	ldi	r22, 0x35	; 53
    2d86:	75 e0       	ldi	r23, 0x05	; 5
    2d88:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2d8c:	69 2d       	mov	r22, r9
    2d8e:	ce 01       	movw	r24, r28
    2d90:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
    2d94:	6a e0       	ldi	r22, 0x0A	; 10
    2d96:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2d9a:	ec 01       	movw	r28, r24
    2d9c:	63 e3       	ldi	r22, 0x33	; 51
    2d9e:	75 e0       	ldi	r23, 0x05	; 5
    2da0:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2da4:	b5 01       	movw	r22, r10
    2da6:	ce 01       	movw	r24, r28
    2da8:	0e 94 c5 1a 	call	0x358a	; 0x358a <_ZN8emstreamlsEj>
    2dac:	6a e0       	ldi	r22, 0x0A	; 10
    2dae:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2db2:	ec 01       	movw	r28, r24
    2db4:	61 e3       	ldi	r22, 0x31	; 49
    2db6:	75 e0       	ldi	r23, 0x05	; 5
    2db8:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2dbc:	6a e0       	ldi	r22, 0x0A	; 10
    2dbe:	ce 01       	movw	r24, r28
    2dc0:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2dc4:	ec 01       	movw	r28, r24
    2dc6:	6f e2       	ldi	r22, 0x2F	; 47
    2dc8:	75 e0       	ldi	r23, 0x05	; 5
    2dca:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2dce:	b7 01       	movw	r22, r14
    2dd0:	a6 01       	movw	r20, r12
    2dd2:	ce 01       	movw	r24, r28
    2dd4:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <_ZN8emstreamlsEm>
}
    2dd8:	df 91       	pop	r29
    2dda:	cf 91       	pop	r28
    2ddc:	1f 91       	pop	r17
    2dde:	0f 91       	pop	r16
    2de0:	ff 90       	pop	r15
    2de2:	ef 90       	pop	r14
    2de4:	df 90       	pop	r13
    2de6:	cf 90       	pop	r12
    2de8:	bf 90       	pop	r11
    2dea:	af 90       	pop	r10
    2dec:	9f 90       	pop	r9
    2dee:	8f 90       	pop	r8
    2df0:	08 95       	ret

00002df2 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2df2:	cf 93       	push	r28
    2df4:	df 93       	push	r29
    2df6:	ec 01       	movw	r28, r24
    2df8:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2dfa:	db 01       	movw	r26, r22
    2dfc:	ed 91       	ld	r30, X+
    2dfe:	fc 91       	ld	r31, X
    2e00:	02 80       	ldd	r0, Z+2	; 0x02
    2e02:	f3 81       	ldd	r31, Z+3	; 0x03
    2e04:	e0 2d       	mov	r30, r0
    2e06:	be 01       	movw	r22, r28
    2e08:	19 95       	eicall
	return (ser_dev);
}
    2e0a:	ce 01       	movw	r24, r28
    2e0c:	df 91       	pop	r29
    2e0e:	cf 91       	pop	r28
    2e10:	08 95       	ret

00002e12 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2e12:	0f 93       	push	r16
    2e14:	1f 93       	push	r17
    2e16:	cf 93       	push	r28
    2e18:	df 93       	push	r29
    2e1a:	ec 01       	movw	r28, r24
    2e1c:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2e1e:	bc 01       	movw	r22, r24
    2e20:	c8 01       	movw	r24, r16
    2e22:	0e 94 f9 16 	call	0x2df2	; 0x2df2 <_ZlsR8emstreamR8frt_task>
    2e26:	66 e0       	ldi	r22, 0x06	; 6
    2e28:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2e2c:	8c 81       	ldd	r24, Y+4	; 0x04
    2e2e:	9d 81       	ldd	r25, Y+5	; 0x05
    2e30:	00 97       	sbiw	r24, 0x00	; 0
    2e32:	19 f0       	breq	.+6      	; 0x2e3a <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2e34:	b8 01       	movw	r22, r16
    2e36:	0e 94 09 17 	call	0x2e12	; 0x2e12 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2e3a:	df 91       	pop	r29
    2e3c:	cf 91       	pop	r28
    2e3e:	1f 91       	pop	r17
    2e40:	0f 91       	pop	r16
    2e42:	08 95       	ret

00002e44 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2e44:	0f 93       	push	r16
    2e46:	1f 93       	push	r17
    2e48:	cf 93       	push	r28
    2e4a:	df 93       	push	r29
    2e4c:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2e4e:	6a e0       	ldi	r22, 0x0A	; 10
    2e50:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2e54:	8c 01       	movw	r16, r24
    2e56:	64 e2       	ldi	r22, 0x24	; 36
    2e58:	75 e0       	ldi	r23, 0x05	; 5
    2e5a:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2e5e:	6a e0       	ldi	r22, 0x0A	; 10
    2e60:	c8 01       	movw	r24, r16
    2e62:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2e66:	8c 01       	movw	r16, r24
    2e68:	6d e1       	ldi	r22, 0x1D	; 29
    2e6a:	75 e0       	ldi	r23, 0x05	; 5
    2e6c:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2e70:	66 e0       	ldi	r22, 0x06	; 6
    2e72:	c8 01       	movw	r24, r16
    2e74:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2e78:	6a e0       	ldi	r22, 0x0A	; 10
    2e7a:	ce 01       	movw	r24, r28
    2e7c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2e80:	8c 01       	movw	r16, r24
    2e82:	6c e0       	ldi	r22, 0x0C	; 12
    2e84:	75 e0       	ldi	r23, 0x05	; 5
    2e86:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2e8a:	6a e0       	ldi	r22, 0x0A	; 10
    2e8c:	c8 01       	movw	r24, r16
    2e8e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2e92:	8c 01       	movw	r16, r24
    2e94:	60 e0       	ldi	r22, 0x00	; 0
    2e96:	75 e0       	ldi	r23, 0x05	; 5
    2e98:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2e9c:	6a e0       	ldi	r22, 0x0A	; 10
    2e9e:	c8 01       	movw	r24, r16
    2ea0:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2ea4:	8c 01       	movw	r16, r24
    2ea6:	6a ef       	ldi	r22, 0xFA	; 250
    2ea8:	74 e0       	ldi	r23, 0x04	; 4
    2eaa:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2eae:	66 e0       	ldi	r22, 0x06	; 6
    2eb0:	c8 01       	movw	r24, r16
    2eb2:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2eb6:	6a e0       	ldi	r22, 0x0A	; 10
    2eb8:	ce 01       	movw	r24, r28
    2eba:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2ebe:	8c 01       	movw	r16, r24
    2ec0:	69 ee       	ldi	r22, 0xE9	; 233
    2ec2:	74 e0       	ldi	r23, 0x04	; 4
    2ec4:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2ec8:	6a e0       	ldi	r22, 0x0A	; 10
    2eca:	c8 01       	movw	r24, r16
    2ecc:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2ed0:	8c 01       	movw	r16, r24
    2ed2:	6d ed       	ldi	r22, 0xDD	; 221
    2ed4:	74 e0       	ldi	r23, 0x04	; 4
    2ed6:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2eda:	6a e0       	ldi	r22, 0x0A	; 10
    2edc:	c8 01       	movw	r24, r16
    2ede:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2ee2:	8c 01       	movw	r16, r24
    2ee4:	67 ed       	ldi	r22, 0xD7	; 215
    2ee6:	74 e0       	ldi	r23, 0x04	; 4
    2ee8:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2eec:	66 e0       	ldi	r22, 0x06	; 6
    2eee:	c8 01       	movw	r24, r16
    2ef0:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2ef4:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2ef8:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2efc:	00 97       	sbiw	r24, 0x00	; 0
    2efe:	19 f0       	breq	.+6      	; 0x2f06 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2f00:	be 01       	movw	r22, r28
    2f02:	0e 94 09 17 	call	0x2e12	; 0x2e12 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2f06:	0e 94 ef 10 	call	0x21de	; 0x21de <xTaskGetIdleTaskHandle>
    2f0a:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <uxTaskGetStackHighWaterMark>
    2f0e:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2f10:	6a e0       	ldi	r22, 0x0A	; 10
    2f12:	ce 01       	movw	r24, r28
    2f14:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2f18:	ec 01       	movw	r28, r24
    2f1a:	6c ec       	ldi	r22, 0xCC	; 204
    2f1c:	74 e0       	ldi	r23, 0x04	; 4
    2f1e:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2f22:	61 2f       	mov	r22, r17
    2f24:	ce 01       	movw	r24, r28
    2f26:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2f2a:	6a e0       	ldi	r22, 0x0A	; 10
    2f2c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2f30:	ec 01       	movw	r28, r24
    2f32:	6a ec       	ldi	r22, 0xCA	; 202
    2f34:	74 e0       	ldi	r23, 0x04	; 4
    2f36:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    2f3a:	64 e6       	ldi	r22, 0x64	; 100
    2f3c:	70 e0       	ldi	r23, 0x00	; 0
    2f3e:	ce 01       	movw	r24, r28
    2f40:	0e 94 c5 1a 	call	0x358a	; 0x358a <_ZN8emstreamlsEj>
    2f44:	6a e0       	ldi	r22, 0x0A	; 10
    2f46:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    2f4a:	ec 01       	movw	r28, r24
    2f4c:	67 ec       	ldi	r22, 0xC7	; 199
    2f4e:	74 e0       	ldi	r23, 0x04	; 4
    2f50:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2f54:	66 e0       	ldi	r22, 0x06	; 6
    2f56:	ce 01       	movw	r24, r28
    2f58:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
}
    2f5c:	df 91       	pop	r29
    2f5e:	cf 91       	pop	r28
    2f60:	1f 91       	pop	r17
    2f62:	0f 91       	pop	r16
    2f64:	08 95       	ret

00002f66 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2f66:	0f 93       	push	r16
    2f68:	cf 93       	push	r28
    2f6a:	df 93       	push	r29
    2f6c:	1f 92       	push	r1
    2f6e:	cd b7       	in	r28, 0x3d	; 61
    2f70:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2f72:	00 e0       	ldi	r16, 0x00	; 0
    2f74:	2f ef       	ldi	r18, 0xFF	; 255
    2f76:	3f ef       	ldi	r19, 0xFF	; 255
    2f78:	a9 01       	movw	r20, r18
    2f7a:	be 01       	movw	r22, r28
    2f7c:	6f 5f       	subi	r22, 0xFF	; 255
    2f7e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f80:	fc 01       	movw	r30, r24
    2f82:	80 85       	ldd	r24, Z+8	; 0x08
    2f84:	91 85       	ldd	r25, Z+9	; 0x09
    2f86:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <xQueueGenericReceive>
    2f8a:	81 30       	cpi	r24, 0x01	; 1
    2f8c:	19 f4       	brne	.+6      	; 0x2f94 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2f8e:	89 81       	ldd	r24, Y+1	; 0x01
    2f90:	90 e0       	ldi	r25, 0x00	; 0
    2f92:	02 c0       	rjmp	.+4      	; 0x2f98 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2f94:	8f ef       	ldi	r24, 0xFF	; 255
    2f96:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2f98:	0f 90       	pop	r0
    2f9a:	df 91       	pop	r29
    2f9c:	cf 91       	pop	r28
    2f9e:	0f 91       	pop	r16
    2fa0:	08 95       	ret

00002fa2 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2fa2:	fc 01       	movw	r30, r24
    2fa4:	80 85       	ldd	r24, Z+8	; 0x08
    2fa6:	91 85       	ldd	r25, Z+9	; 0x09
    2fa8:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <uxQueueMessagesWaiting>
    2fac:	91 e0       	ldi	r25, 0x01	; 1
    2fae:	81 11       	cpse	r24, r1
    2fb0:	01 c0       	rjmp	.+2      	; 0x2fb4 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2fb2:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2fb4:	89 2f       	mov	r24, r25
    2fb6:	08 95       	ret

00002fb8 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2fb8:	0f 93       	push	r16
    2fba:	cf 93       	push	r28
    2fbc:	df 93       	push	r29
    2fbe:	1f 92       	push	r1
    2fc0:	cd b7       	in	r28, 0x3d	; 61
    2fc2:	de b7       	in	r29, 0x3e	; 62
    2fc4:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2fc6:	fc 01       	movw	r30, r24
    2fc8:	22 85       	ldd	r18, Z+10	; 0x0a
    2fca:	33 85       	ldd	r19, Z+11	; 0x0b
    2fcc:	44 85       	ldd	r20, Z+12	; 0x0c
    2fce:	55 85       	ldd	r21, Z+13	; 0x0d
    2fd0:	00 e0       	ldi	r16, 0x00	; 0
    2fd2:	be 01       	movw	r22, r28
    2fd4:	6f 5f       	subi	r22, 0xFF	; 255
    2fd6:	7f 4f       	sbci	r23, 0xFF	; 255
    2fd8:	80 85       	ldd	r24, Z+8	; 0x08
    2fda:	91 85       	ldd	r25, Z+9	; 0x09
    2fdc:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <xQueueGenericSend>
    2fe0:	91 e0       	ldi	r25, 0x01	; 1
    2fe2:	81 11       	cpse	r24, r1
    2fe4:	01 c0       	rjmp	.+2      	; 0x2fe8 <_ZN14frt_text_queue7putcharEc+0x30>
    2fe6:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2fe8:	89 2f       	mov	r24, r25
    2fea:	0f 90       	pop	r0
    2fec:	df 91       	pop	r29
    2fee:	cf 91       	pop	r28
    2ff0:	0f 91       	pop	r16
    2ff2:	08 95       	ret

00002ff4 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ff4:	8f 92       	push	r8
    2ff6:	9f 92       	push	r9
    2ff8:	bf 92       	push	r11
    2ffa:	cf 92       	push	r12
    2ffc:	df 92       	push	r13
    2ffe:	ef 92       	push	r14
    3000:	ff 92       	push	r15
    3002:	0f 93       	push	r16
    3004:	1f 93       	push	r17
    3006:	cf 93       	push	r28
    3008:	df 93       	push	r29
    300a:	ec 01       	movw	r28, r24
    300c:	b6 2e       	mov	r11, r22
    300e:	4a 01       	movw	r8, r20
    3010:	68 01       	movw	r12, r16
    3012:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3014:	0e 94 39 1a 	call	0x3472	; 0x3472 <_ZN8emstreamC1Ev>
    3018:	87 e4       	ldi	r24, 0x47	; 71
    301a:	90 e2       	ldi	r25, 0x20	; 32
    301c:	88 83       	st	Y, r24
    301e:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3020:	8e 86       	std	Y+14, r8	; 0x0e
    3022:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3024:	40 e0       	ldi	r20, 0x00	; 0
    3026:	61 e0       	ldi	r22, 0x01	; 1
    3028:	8b 2d       	mov	r24, r11
    302a:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xQueueGenericCreate>
    302e:	88 87       	std	Y+8, r24	; 0x08
    3030:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3032:	ca 86       	std	Y+10, r12	; 0x0a
    3034:	db 86       	std	Y+11, r13	; 0x0b
    3036:	ec 86       	std	Y+12, r14	; 0x0c
    3038:	fd 86       	std	Y+13, r15	; 0x0d
}
    303a:	df 91       	pop	r29
    303c:	cf 91       	pop	r28
    303e:	1f 91       	pop	r17
    3040:	0f 91       	pop	r16
    3042:	ff 90       	pop	r15
    3044:	ef 90       	pop	r14
    3046:	df 90       	pop	r13
    3048:	cf 90       	pop	r12
    304a:	bf 90       	pop	r11
    304c:	9f 90       	pop	r9
    304e:	8f 90       	pop	r8
    3050:	08 95       	ret

00003052 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3052:	cf 92       	push	r12
    3054:	df 92       	push	r13
    3056:	ef 92       	push	r14
    3058:	ff 92       	push	r15
    305a:	cf 93       	push	r28
    305c:	df 93       	push	r29
    305e:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3060:	68 81       	ld	r22, Y
    3062:	79 81       	ldd	r23, Y+1	; 0x01
    3064:	8a 81       	ldd	r24, Y+2	; 0x02
    3066:	9b 81       	ldd	r25, Y+3	; 0x03
    3068:	0f 2e       	mov	r0, r31
    306a:	f8 ee       	ldi	r31, 0xE8	; 232
    306c:	cf 2e       	mov	r12, r31
    306e:	f3 e0       	ldi	r31, 0x03	; 3
    3070:	df 2e       	mov	r13, r31
    3072:	e1 2c       	mov	r14, r1
    3074:	f1 2c       	mov	r15, r1
    3076:	f0 2d       	mov	r31, r0
    3078:	a7 01       	movw	r20, r14
    307a:	96 01       	movw	r18, r12
    307c:	0e 94 85 21 	call	0x430a	; 0x430a <__udivmodsi4>
    3080:	9b 01       	movw	r18, r22
    3082:	ac 01       	movw	r20, r24
    3084:	60 e4       	ldi	r22, 0x40	; 64
    3086:	72 e4       	ldi	r23, 0x42	; 66
    3088:	8f e0       	ldi	r24, 0x0F	; 15
    308a:	90 e0       	ldi	r25, 0x00	; 0
    308c:	0e 94 75 21 	call	0x42ea	; 0x42ea <__mulsi3>
    3090:	a7 01       	movw	r20, r14
    3092:	96 01       	movw	r18, r12
    3094:	0e 94 85 21 	call	0x430a	; 0x430a <__udivmodsi4>
    3098:	69 01       	movw	r12, r18
    309a:	7a 01       	movw	r14, r20
    309c:	ac 81       	ldd	r26, Y+4	; 0x04
    309e:	bd 81       	ldd	r27, Y+5	; 0x05
    30a0:	20 e4       	ldi	r18, 0x40	; 64
    30a2:	32 e4       	ldi	r19, 0x42	; 66
    30a4:	4f e0       	ldi	r20, 0x0F	; 15
    30a6:	50 e0       	ldi	r21, 0x00	; 0
    30a8:	0e 94 d6 21 	call	0x43ac	; 0x43ac <__muluhisi3>
    30ac:	20 e0       	ldi	r18, 0x00	; 0
    30ae:	38 e4       	ldi	r19, 0x48	; 72
    30b0:	48 ee       	ldi	r20, 0xE8	; 232
    30b2:	51 e0       	ldi	r21, 0x01	; 1
    30b4:	0e 94 85 21 	call	0x430a	; 0x430a <__udivmodsi4>
    30b8:	c7 01       	movw	r24, r14
    30ba:	b6 01       	movw	r22, r12
    30bc:	62 0f       	add	r22, r18
    30be:	73 1f       	adc	r23, r19
    30c0:	84 1f       	adc	r24, r20
    30c2:	95 1f       	adc	r25, r21
}
    30c4:	df 91       	pop	r29
    30c6:	cf 91       	pop	r28
    30c8:	ff 90       	pop	r15
    30ca:	ef 90       	pop	r14
    30cc:	df 90       	pop	r13
    30ce:	cf 90       	pop	r12
    30d0:	08 95       	ret

000030d2 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    30d2:	cf 92       	push	r12
    30d4:	df 92       	push	r13
    30d6:	ef 92       	push	r14
    30d8:	ff 92       	push	r15
    30da:	0f 93       	push	r16
    30dc:	1f 93       	push	r17
    30de:	cf 93       	push	r28
    30e0:	df 93       	push	r29
    30e2:	cd b7       	in	r28, 0x3d	; 61
    30e4:	de b7       	in	r29, 0x3e	; 62
    30e6:	2f 97       	sbiw	r28, 0x0f	; 15
    30e8:	cd bf       	out	0x3d, r28	; 61
    30ea:	de bf       	out	0x3e, r29	; 62
    30ec:	6c 01       	movw	r12, r24
    30ee:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    30f0:	db 01       	movw	r26, r22
    30f2:	6d 91       	ld	r22, X+
    30f4:	7d 91       	ld	r23, X+
    30f6:	8d 91       	ld	r24, X+
    30f8:	9c 91       	ld	r25, X
    30fa:	28 ee       	ldi	r18, 0xE8	; 232
    30fc:	33 e0       	ldi	r19, 0x03	; 3
    30fe:	40 e0       	ldi	r20, 0x00	; 0
    3100:	50 e0       	ldi	r21, 0x00	; 0
    3102:	0e 94 85 21 	call	0x430a	; 0x430a <__udivmodsi4>
    3106:	ba 01       	movw	r22, r20
    3108:	a9 01       	movw	r20, r18
    310a:	c6 01       	movw	r24, r12
    310c:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3110:	d6 01       	movw	r26, r12
    3112:	ed 91       	ld	r30, X+
    3114:	fc 91       	ld	r31, X
    3116:	02 80       	ldd	r0, Z+2	; 0x02
    3118:	f3 81       	ldd	r31, Z+3	; 0x03
    311a:	e0 2d       	mov	r30, r0
    311c:	6e e2       	ldi	r22, 0x2E	; 46
    311e:	c6 01       	movw	r24, r12
    3120:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3122:	c8 01       	movw	r24, r16
    3124:	0e 94 29 18 	call	0x3052	; 0x3052 <_ZN10time_stamp12get_microsecEv>
    3128:	8e 01       	movw	r16, r28
    312a:	09 5f       	subi	r16, 0xF9	; 249
    312c:	1f 4f       	sbci	r17, 0xFF	; 255
    312e:	fe 01       	movw	r30, r28
    3130:	31 96       	adiw	r30, 0x01	; 1
    3132:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3134:	2a e0       	ldi	r18, 0x0A	; 10
    3136:	30 e0       	ldi	r19, 0x00	; 0
    3138:	40 e0       	ldi	r20, 0x00	; 0
    313a:	50 e0       	ldi	r21, 0x00	; 0
    313c:	0e 94 a7 21 	call	0x434e	; 0x434e <__divmodsi4>
    3140:	e6 2f       	mov	r30, r22
    3142:	28 87       	std	Y+8, r18	; 0x08
    3144:	39 87       	std	Y+9, r19	; 0x09
    3146:	4a 87       	std	Y+10, r20	; 0x0a
    3148:	5b 87       	std	Y+11, r21	; 0x0b
    314a:	68 85       	ldd	r22, Y+8	; 0x08
    314c:	79 85       	ldd	r23, Y+9	; 0x09
    314e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3150:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3152:	20 e3       	ldi	r18, 0x30	; 48
    3154:	2e 0f       	add	r18, r30
    3156:	d8 01       	movw	r26, r16
    3158:	2e 93       	st	-X, r18
    315a:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    315c:	ae 15       	cp	r26, r14
    315e:	bf 05       	cpc	r27, r15
    3160:	49 f7       	brne	.-46     	; 0x3134 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3162:	1f 82       	std	Y+7, r1	; 0x07
    3164:	be 01       	movw	r22, r28
    3166:	6f 5f       	subi	r22, 0xFF	; 255
    3168:	7f 4f       	sbci	r23, 0xFF	; 255
    316a:	c6 01       	movw	r24, r12
    316c:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3170:	c6 01       	movw	r24, r12
    3172:	2f 96       	adiw	r28, 0x0f	; 15
    3174:	cd bf       	out	0x3d, r28	; 61
    3176:	de bf       	out	0x3e, r29	; 62
    3178:	df 91       	pop	r29
    317a:	cf 91       	pop	r28
    317c:	1f 91       	pop	r17
    317e:	0f 91       	pop	r16
    3180:	ff 90       	pop	r15
    3182:	ef 90       	pop	r14
    3184:	df 90       	pop	r13
    3186:	cf 90       	pop	r12
    3188:	08 95       	ret

0000318a <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    318a:	cf 93       	push	r28
    318c:	df 93       	push	r29
    318e:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3190:	0f b6       	in	r0, 0x3f	; 63
    3192:	f8 94       	cli
    3194:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3196:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    319a:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    319e:	8c 83       	std	Y+4, r24	; 0x04
    31a0:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    31a2:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <xTaskGetTickCount>
    31a6:	68 83       	st	Y, r22
    31a8:	79 83       	std	Y+1, r23	; 0x01
    31aa:	8a 83       	std	Y+2, r24	; 0x02
    31ac:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    31ae:	0f 90       	pop	r0
    31b0:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    31b2:	ce 01       	movw	r24, r28
    31b4:	df 91       	pop	r29
    31b6:	cf 91       	pop	r28
    31b8:	08 95       	ret

000031ba <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    31ba:	5f 92       	push	r5
    31bc:	6f 92       	push	r6
    31be:	7f 92       	push	r7
    31c0:	8f 92       	push	r8
    31c2:	9f 92       	push	r9
    31c4:	af 92       	push	r10
    31c6:	bf 92       	push	r11
    31c8:	cf 92       	push	r12
    31ca:	df 92       	push	r13
    31cc:	ef 92       	push	r14
    31ce:	ff 92       	push	r15
    31d0:	0f 93       	push	r16
    31d2:	1f 93       	push	r17
    31d4:	cf 93       	push	r28
    31d6:	df 93       	push	r29
    31d8:	5c 01       	movw	r10, r24
    31da:	4b 01       	movw	r8, r22
    31dc:	7a 01       	movw	r14, r20
    31de:	12 2f       	mov	r17, r18
    31e0:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    31e2:	63 e0       	ldi	r22, 0x03	; 3
    31e4:	ca 01       	movw	r24, r20
    31e6:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    31ea:	a8 14       	cp	r10, r8
    31ec:	b9 04       	cpc	r11, r9
    31ee:	08 f0       	brcs	.+2      	; 0x31f2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    31f0:	7d c0       	rjmp	.+250    	; 0x32ec <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31f2:	65 01       	movw	r12, r10
    31f4:	84 e1       	ldi	r24, 0x14	; 20
    31f6:	c8 0e       	add	r12, r24
    31f8:	d1 1c       	adc	r13, r1
    31fa:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    31fc:	6a 2c       	mov	r6, r10
    31fe:	5b 2c       	mov	r5, r11
    3200:	b5 01       	movw	r22, r10
    3202:	c7 01       	movw	r24, r14
    3204:	0e 94 c5 1a 	call	0x358a	; 0x358a <_ZN8emstreamlsEj>
    3208:	6a e0       	ldi	r22, 0x0A	; 10
    320a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    320e:	69 e4       	ldi	r22, 0x49	; 73
    3210:	75 e0       	ldi	r23, 0x05	; 5
    3212:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3216:	11 23       	and	r17, r17
    3218:	09 f4       	brne	.+2      	; 0x321c <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    321a:	6d c0       	rjmp	.+218    	; 0x32f6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    321c:	00 23       	and	r16, r16
    321e:	09 f4       	brne	.+2      	; 0x3222 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3220:	6a c0       	rjmp	.+212    	; 0x32f6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3222:	6a e0       	ldi	r22, 0x0A	; 10
    3224:	c7 01       	movw	r24, r14
    3226:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    322a:	64 e4       	ldi	r22, 0x44	; 68
    322c:	75 e0       	ldi	r23, 0x05	; 5
    322e:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    3232:	61 c0       	rjmp	.+194    	; 0x32f6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3234:	11 23       	and	r17, r17
    3236:	71 f0       	breq	.+28     	; 0x3254 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3238:	01 11       	cpse	r16, r1
    323a:	0c c0       	rjmp	.+24     	; 0x3254 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    323c:	88 81       	ld	r24, Y
    323e:	87 15       	cp	r24, r7
    3240:	49 f0       	breq	.+18     	; 0x3254 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3242:	6a e0       	ldi	r22, 0x0A	; 10
    3244:	c7 01       	movw	r24, r14
    3246:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    324a:	6f e3       	ldi	r22, 0x3F	; 63
    324c:	75 e0       	ldi	r23, 0x05	; 5
    324e:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3252:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3254:	69 91       	ld	r22, Y+
    3256:	c7 01       	movw	r24, r14
    3258:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    325c:	dc 01       	movw	r26, r24
    325e:	ed 91       	ld	r30, X+
    3260:	fc 91       	ld	r31, X
    3262:	02 80       	ldd	r0, Z+2	; 0x02
    3264:	f3 81       	ldd	r31, Z+3	; 0x03
    3266:	e0 2d       	mov	r30, r0
    3268:	60 e2       	ldi	r22, 0x20	; 32
    326a:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    326c:	cc 16       	cp	r12, r28
    326e:	dd 06       	cpc	r13, r29
    3270:	09 f7       	brne	.-62     	; 0x3234 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3272:	11 23       	and	r17, r17
    3274:	89 f0       	breq	.+34     	; 0x3298 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3276:	6a e0       	ldi	r22, 0x0A	; 10
    3278:	c7 01       	movw	r24, r14
    327a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    327e:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3280:	69 e3       	ldi	r22, 0x39	; 57
    3282:	75 e0       	ldi	r23, 0x05	; 5
    3284:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3288:	e8 81       	ld	r30, Y
    328a:	f9 81       	ldd	r31, Y+1	; 0x01
    328c:	02 80       	ldd	r0, Z+2	; 0x02
    328e:	f3 81       	ldd	r31, Z+3	; 0x03
    3290:	e0 2d       	mov	r30, r0
    3292:	60 e2       	ldi	r22, 0x20	; 32
    3294:	ce 01       	movw	r24, r28
    3296:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3298:	c6 2d       	mov	r28, r6
    329a:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    329c:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    329e:	80 ee       	ldi	r24, 0xE0	; 224
    32a0:	86 0f       	add	r24, r22
    32a2:	8f 35       	cpi	r24, 0x5F	; 95
    32a4:	48 f4       	brcc	.+18     	; 0x32b8 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    32a6:	d7 01       	movw	r26, r14
    32a8:	ed 91       	ld	r30, X+
    32aa:	fc 91       	ld	r31, X
    32ac:	02 80       	ldd	r0, Z+2	; 0x02
    32ae:	f3 81       	ldd	r31, Z+3	; 0x03
    32b0:	e0 2d       	mov	r30, r0
    32b2:	c7 01       	movw	r24, r14
    32b4:	19 95       	eicall
    32b6:	09 c0       	rjmp	.+18     	; 0x32ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    32b8:	d7 01       	movw	r26, r14
    32ba:	ed 91       	ld	r30, X+
    32bc:	fc 91       	ld	r31, X
    32be:	02 80       	ldd	r0, Z+2	; 0x02
    32c0:	f3 81       	ldd	r31, Z+3	; 0x03
    32c2:	e0 2d       	mov	r30, r0
    32c4:	6e e2       	ldi	r22, 0x2E	; 46
    32c6:	c7 01       	movw	r24, r14
    32c8:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    32ca:	cc 16       	cp	r12, r28
    32cc:	dd 06       	cpc	r13, r29
    32ce:	31 f7       	brne	.-52     	; 0x329c <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    32d0:	b4 e1       	ldi	r27, 0x14	; 20
    32d2:	ab 0e       	add	r10, r27
    32d4:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    32d6:	66 e0       	ldi	r22, 0x06	; 6
    32d8:	c7 01       	movw	r24, r14
    32da:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    32de:	84 e1       	ldi	r24, 0x14	; 20
    32e0:	c8 0e       	add	r12, r24
    32e2:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    32e4:	a8 14       	cp	r10, r8
    32e6:	b9 04       	cpc	r11, r9
    32e8:	08 f4       	brcc	.+2      	; 0x32ec <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    32ea:	88 cf       	rjmp	.-240    	; 0x31fc <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    32ec:	62 e0       	ldi	r22, 0x02	; 2
    32ee:	c7 01       	movw	r24, r14
    32f0:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
}
    32f4:	03 c0       	rjmp	.+6      	; 0x32fc <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    32f6:	c6 2d       	mov	r28, r6
    32f8:	d5 2d       	mov	r29, r5
    32fa:	9c cf       	rjmp	.-200    	; 0x3234 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    32fc:	df 91       	pop	r29
    32fe:	cf 91       	pop	r28
    3300:	1f 91       	pop	r17
    3302:	0f 91       	pop	r16
    3304:	ff 90       	pop	r15
    3306:	ef 90       	pop	r14
    3308:	df 90       	pop	r13
    330a:	cf 90       	pop	r12
    330c:	bf 90       	pop	r11
    330e:	af 90       	pop	r10
    3310:	9f 90       	pop	r9
    3312:	8f 90       	pop	r8
    3314:	7f 90       	pop	r7
    3316:	6f 90       	pop	r6
    3318:	5f 90       	pop	r5
    331a:	08 95       	ret

0000331c <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    331c:	0e 94 bf 09 	call	0x137e	; 0x137e <pvPortMalloc>
    3320:	08 95       	ret

00003322 <_ZdlPv>:
    3322:	00 97       	sbiw	r24, 0x00	; 0
    3324:	11 f0       	breq	.+4      	; 0x332a <_ZdlPv+0x8>
    3326:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <vPortFree>
    332a:	08 95       	ret

0000332c <_Znaj>:
    332c:	0e 94 bf 09 	call	0x137e	; 0x137e <pvPortMalloc>
    3330:	08 95       	ret

00003332 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3332:	08 95       	ret

00003334 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3334:	cf 93       	push	r28
    3336:	df 93       	push	r29
    3338:	fc 01       	movw	r30, r24
    333a:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    333c:	40 3a       	cpi	r20, 0xA0	; 160
    333e:	68 e0       	ldi	r22, 0x08	; 8
    3340:	56 07       	cpc	r21, r22
    3342:	49 f4       	brne	.+18     	; 0x3356 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3344:	80 e4       	ldi	r24, 0x40	; 64
    3346:	96 e0       	ldi	r25, 0x06	; 6
    3348:	82 83       	std	Z+2, r24	; 0x02
    334a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    334c:	82 e0       	ldi	r24, 0x02	; 2
    334e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3350:	83 e0       	ldi	r24, 0x03	; 3
    3352:	85 83       	std	Z+5, r24	; 0x05
    3354:	32 c0       	rjmp	.+100    	; 0x33ba <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3356:	40 3b       	cpi	r20, 0xB0	; 176
    3358:	78 e0       	ldi	r23, 0x08	; 8
    335a:	57 07       	cpc	r21, r23
    335c:	49 f4       	brne	.+18     	; 0x3370 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    335e:	80 e4       	ldi	r24, 0x40	; 64
    3360:	96 e0       	ldi	r25, 0x06	; 6
    3362:	82 83       	std	Z+2, r24	; 0x02
    3364:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3366:	86 e0       	ldi	r24, 0x06	; 6
    3368:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    336a:	87 e0       	ldi	r24, 0x07	; 7
    336c:	85 83       	std	Z+5, r24	; 0x05
    336e:	25 c0       	rjmp	.+74     	; 0x33ba <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3370:	40 3a       	cpi	r20, 0xA0	; 160
    3372:	89 e0       	ldi	r24, 0x09	; 9
    3374:	58 07       	cpc	r21, r24
    3376:	49 f4       	brne	.+18     	; 0x338a <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3378:	80 e6       	ldi	r24, 0x60	; 96
    337a:	96 e0       	ldi	r25, 0x06	; 6
    337c:	82 83       	std	Z+2, r24	; 0x02
    337e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3380:	82 e0       	ldi	r24, 0x02	; 2
    3382:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3384:	83 e0       	ldi	r24, 0x03	; 3
    3386:	85 83       	std	Z+5, r24	; 0x05
    3388:	18 c0       	rjmp	.+48     	; 0x33ba <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    338a:	40 3b       	cpi	r20, 0xB0	; 176
    338c:	69 e0       	ldi	r22, 0x09	; 9
    338e:	56 07       	cpc	r21, r22
    3390:	49 f4       	brne	.+18     	; 0x33a4 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3392:	80 e6       	ldi	r24, 0x60	; 96
    3394:	96 e0       	ldi	r25, 0x06	; 6
    3396:	82 83       	std	Z+2, r24	; 0x02
    3398:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    339a:	86 e0       	ldi	r24, 0x06	; 6
    339c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    339e:	87 e0       	ldi	r24, 0x07	; 7
    33a0:	85 83       	std	Z+5, r24	; 0x05
    33a2:	0b c0       	rjmp	.+22     	; 0x33ba <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    33a4:	40 3a       	cpi	r20, 0xA0	; 160
    33a6:	5a 40       	sbci	r21, 0x0A	; 10
    33a8:	41 f4       	brne	.+16     	; 0x33ba <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    33aa:	80 e8       	ldi	r24, 0x80	; 128
    33ac:	96 e0       	ldi	r25, 0x06	; 6
    33ae:	82 83       	std	Z+2, r24	; 0x02
    33b0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    33b2:	82 e0       	ldi	r24, 0x02	; 2
    33b4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    33b6:	83 e0       	ldi	r24, 0x03	; 3
    33b8:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    33ba:	a6 83       	std	Z+6, r26	; 0x06
    33bc:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    33be:	cd 01       	movw	r24, r26
    33c0:	01 96       	adiw	r24, 0x01	; 1
    33c2:	80 87       	std	Z+8, r24	; 0x08
    33c4:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    33c6:	03 96       	adiw	r24, 0x03	; 3
    33c8:	82 87       	std	Z+10, r24	; 0x0a
    33ca:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    33cc:	25 81       	ldd	r18, Z+5	; 0x05
    33ce:	c2 81       	ldd	r28, Z+2	; 0x02
    33d0:	d3 81       	ldd	r29, Z+3	; 0x03
    33d2:	4c 81       	ldd	r20, Y+4	; 0x04
    33d4:	81 e0       	ldi	r24, 0x01	; 1
    33d6:	90 e0       	ldi	r25, 0x00	; 0
    33d8:	bc 01       	movw	r22, r24
    33da:	02 c0       	rjmp	.+4      	; 0x33e0 <_ZN7base232C1EjP12USART_struct+0xac>
    33dc:	66 0f       	add	r22, r22
    33de:	77 1f       	adc	r23, r23
    33e0:	2a 95       	dec	r18
    33e2:	e2 f7       	brpl	.-8      	; 0x33dc <_ZN7base232C1EjP12USART_struct+0xa8>
    33e4:	9b 01       	movw	r18, r22
    33e6:	24 2b       	or	r18, r20
    33e8:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    33ea:	25 81       	ldd	r18, Z+5	; 0x05
    33ec:	c2 81       	ldd	r28, Z+2	; 0x02
    33ee:	d3 81       	ldd	r29, Z+3	; 0x03
    33f0:	48 81       	ld	r20, Y
    33f2:	bc 01       	movw	r22, r24
    33f4:	02 c0       	rjmp	.+4      	; 0x33fa <_ZN7base232C1EjP12USART_struct+0xc6>
    33f6:	66 0f       	add	r22, r22
    33f8:	77 1f       	adc	r23, r23
    33fa:	2a 95       	dec	r18
    33fc:	e2 f7       	brpl	.-8      	; 0x33f6 <_ZN7base232C1EjP12USART_struct+0xc2>
    33fe:	9b 01       	movw	r18, r22
    3400:	24 2b       	or	r18, r20
    3402:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3404:	34 81       	ldd	r19, Z+4	; 0x04
    3406:	c2 81       	ldd	r28, Z+2	; 0x02
    3408:	d3 81       	ldd	r29, Z+3	; 0x03
    340a:	28 81       	ld	r18, Y
    340c:	02 c0       	rjmp	.+4      	; 0x3412 <_ZN7base232C1EjP12USART_struct+0xde>
    340e:	88 0f       	add	r24, r24
    3410:	99 1f       	adc	r25, r25
    3412:	3a 95       	dec	r19
    3414:	e2 f7       	brpl	.-8      	; 0x340e <_ZN7base232C1EjP12USART_struct+0xda>
    3416:	80 95       	com	r24
    3418:	90 95       	com	r25
    341a:	82 23       	and	r24, r18
    341c:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    341e:	80 e1       	ldi	r24, 0x10	; 16
    3420:	13 96       	adiw	r26, 0x03	; 3
    3422:	8c 93       	st	X, r24
    3424:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3426:	83 e0       	ldi	r24, 0x03	; 3
    3428:	15 96       	adiw	r26, 0x05	; 5
    342a:	8c 93       	st	X, r24
    342c:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    342e:	80 ef       	ldi	r24, 0xF0	; 240
    3430:	17 96       	adiw	r26, 0x07	; 7
    3432:	8c 93       	st	X, r24
    3434:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3436:	81 e2       	ldi	r24, 0x21	; 33
    3438:	16 96       	adiw	r26, 0x06	; 6
    343a:	8c 93       	st	X, r24
    343c:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    343e:	88 e1       	ldi	r24, 0x18	; 24
    3440:	14 96       	adiw	r26, 0x04	; 4
    3442:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3444:	80 e8       	ldi	r24, 0x80	; 128
    3446:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3448:	80 e4       	ldi	r24, 0x40	; 64
    344a:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    344c:	80 e2       	ldi	r24, 0x20	; 32
    344e:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3450:	06 80       	ldd	r0, Z+6	; 0x06
    3452:	f7 81       	ldd	r31, Z+7	; 0x07
    3454:	e0 2d       	mov	r30, r0
    3456:	80 81       	ld	r24, Z
    3458:	80 81       	ld	r24, Z
}
    345a:	df 91       	pop	r29
    345c:	cf 91       	pop	r28
    345e:	08 95       	ret

00003460 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3460:	81 e0       	ldi	r24, 0x01	; 1
    3462:	08 95       	ret

00003464 <_ZN8emstream7getcharEv>:
    3464:	80 e0       	ldi	r24, 0x00	; 0
    3466:	90 e0       	ldi	r25, 0x00	; 0
    3468:	08 95       	ret

0000346a <_ZN8emstream14check_for_charEv>:
    346a:	80 e0       	ldi	r24, 0x00	; 0
    346c:	08 95       	ret

0000346e <_ZN8emstream12transmit_nowEv>:
    346e:	08 95       	ret

00003470 <_ZN8emstream12clear_screenEv>:
    3470:	08 95       	ret

00003472 <_ZN8emstreamC1Ev>:
    3472:	fc 01       	movw	r30, r24
    3474:	87 e5       	ldi	r24, 0x57	; 87
    3476:	90 e2       	ldi	r25, 0x20	; 32
    3478:	80 83       	st	Z, r24
    347a:	91 83       	std	Z+1, r25	; 0x01
    347c:	8a e0       	ldi	r24, 0x0A	; 10
    347e:	82 83       	std	Z+2, r24	; 0x02
    3480:	13 82       	std	Z+3, r1	; 0x03
    3482:	83 e0       	ldi	r24, 0x03	; 3
    3484:	85 83       	std	Z+5, r24	; 0x05
    3486:	14 82       	std	Z+4, r1	; 0x04
    3488:	16 82       	std	Z+6, r1	; 0x06
    348a:	17 82       	std	Z+7, r1	; 0x07
    348c:	08 95       	ret

0000348e <_ZN8emstream4putsEPKc>:
    348e:	0f 93       	push	r16
    3490:	1f 93       	push	r17
    3492:	cf 93       	push	r28
    3494:	df 93       	push	r29
    3496:	8c 01       	movw	r16, r24
    3498:	fb 01       	movw	r30, r22
    349a:	dc 01       	movw	r26, r24
    349c:	14 96       	adiw	r26, 0x04	; 4
    349e:	8c 91       	ld	r24, X
    34a0:	81 11       	cpse	r24, r1
    34a2:	04 c0       	rjmp	.+8      	; 0x34ac <_ZN8emstream4putsEPKc+0x1e>
    34a4:	60 81       	ld	r22, Z
    34a6:	61 11       	cpse	r22, r1
    34a8:	17 c0       	rjmp	.+46     	; 0x34d8 <_ZN8emstream4putsEPKc+0x4a>
    34aa:	23 c0       	rjmp	.+70     	; 0x34f2 <_ZN8emstream4putsEPKc+0x64>
    34ac:	d8 01       	movw	r26, r16
    34ae:	14 96       	adiw	r26, 0x04	; 4
    34b0:	1c 92       	st	X, r1
    34b2:	eb 01       	movw	r28, r22
    34b4:	21 96       	adiw	r28, 0x01	; 1
    34b6:	64 91       	lpm	r22, Z
    34b8:	66 23       	and	r22, r22
    34ba:	d9 f0       	breq	.+54     	; 0x34f2 <_ZN8emstream4putsEPKc+0x64>
    34bc:	d8 01       	movw	r26, r16
    34be:	ed 91       	ld	r30, X+
    34c0:	fc 91       	ld	r31, X
    34c2:	02 80       	ldd	r0, Z+2	; 0x02
    34c4:	f3 81       	ldd	r31, Z+3	; 0x03
    34c6:	e0 2d       	mov	r30, r0
    34c8:	c8 01       	movw	r24, r16
    34ca:	19 95       	eicall
    34cc:	fe 01       	movw	r30, r28
    34ce:	64 91       	lpm	r22, Z
    34d0:	21 96       	adiw	r28, 0x01	; 1
    34d2:	61 11       	cpse	r22, r1
    34d4:	f3 cf       	rjmp	.-26     	; 0x34bc <_ZN8emstream4putsEPKc+0x2e>
    34d6:	0d c0       	rjmp	.+26     	; 0x34f2 <_ZN8emstream4putsEPKc+0x64>
    34d8:	ef 01       	movw	r28, r30
    34da:	21 96       	adiw	r28, 0x01	; 1
    34dc:	d8 01       	movw	r26, r16
    34de:	ed 91       	ld	r30, X+
    34e0:	fc 91       	ld	r31, X
    34e2:	02 80       	ldd	r0, Z+2	; 0x02
    34e4:	f3 81       	ldd	r31, Z+3	; 0x03
    34e6:	e0 2d       	mov	r30, r0
    34e8:	c8 01       	movw	r24, r16
    34ea:	19 95       	eicall
    34ec:	69 91       	ld	r22, Y+
    34ee:	61 11       	cpse	r22, r1
    34f0:	f5 cf       	rjmp	.-22     	; 0x34dc <_ZN8emstream4putsEPKc+0x4e>
    34f2:	df 91       	pop	r29
    34f4:	cf 91       	pop	r28
    34f6:	1f 91       	pop	r17
    34f8:	0f 91       	pop	r16
    34fa:	08 95       	ret

000034fc <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    34fc:	cf 93       	push	r28
    34fe:	df 93       	push	r29
    3500:	ec 01       	movw	r28, r24
	switch (new_manip)
    3502:	86 2f       	mov	r24, r22
    3504:	90 e0       	ldi	r25, 0x00	; 0
    3506:	8b 30       	cpi	r24, 0x0B	; 11
    3508:	91 05       	cpc	r25, r1
    350a:	d8 f5       	brcc	.+118    	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
    350c:	fc 01       	movw	r30, r24
    350e:	88 27       	eor	r24, r24
    3510:	e2 50       	subi	r30, 0x02	; 2
    3512:	ff 4f       	sbci	r31, 0xFF	; 255
    3514:	8f 4f       	sbci	r24, 0xFF	; 255
    3516:	0c 94 c6 21 	jmp	0x438c	; 0x438c <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    351a:	82 e0       	ldi	r24, 0x02	; 2
    351c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    351e:	31 c0       	rjmp	.+98     	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3520:	88 e0       	ldi	r24, 0x08	; 8
    3522:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3524:	2e c0       	rjmp	.+92     	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3526:	8a e0       	ldi	r24, 0x0A	; 10
    3528:	8a 83       	std	Y+2, r24	; 0x02
			break;
    352a:	2b c0       	rjmp	.+86     	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    352c:	80 e1       	ldi	r24, 0x10	; 16
    352e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3530:	28 c0       	rjmp	.+80     	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3532:	81 e0       	ldi	r24, 0x01	; 1
    3534:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3536:	25 c0       	rjmp	.+74     	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3538:	1b 82       	std	Y+3, r1	; 0x03
			break;
    353a:	23 c0       	rjmp	.+70     	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    353c:	e8 81       	ld	r30, Y
    353e:	f9 81       	ldd	r31, Y+1	; 0x01
    3540:	02 80       	ldd	r0, Z+2	; 0x02
    3542:	f3 81       	ldd	r31, Z+3	; 0x03
    3544:	e0 2d       	mov	r30, r0
    3546:	6d e0       	ldi	r22, 0x0D	; 13
    3548:	ce 01       	movw	r24, r28
    354a:	19 95       	eicall
    354c:	e8 81       	ld	r30, Y
    354e:	f9 81       	ldd	r31, Y+1	; 0x01
    3550:	02 80       	ldd	r0, Z+2	; 0x02
    3552:	f3 81       	ldd	r31, Z+3	; 0x03
    3554:	e0 2d       	mov	r30, r0
    3556:	6a e0       	ldi	r22, 0x0A	; 10
    3558:	ce 01       	movw	r24, r28
    355a:	19 95       	eicall
			break;
    355c:	12 c0       	rjmp	.+36     	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    355e:	e8 81       	ld	r30, Y
    3560:	f9 81       	ldd	r31, Y+1	; 0x01
    3562:	02 84       	ldd	r0, Z+10	; 0x0a
    3564:	f3 85       	ldd	r31, Z+11	; 0x0b
    3566:	e0 2d       	mov	r30, r0
    3568:	ce 01       	movw	r24, r28
    356a:	19 95       	eicall
			break;
    356c:	0a c0       	rjmp	.+20     	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    356e:	e8 81       	ld	r30, Y
    3570:	f9 81       	ldd	r31, Y+1	; 0x01
    3572:	00 84       	ldd	r0, Z+8	; 0x08
    3574:	f1 85       	ldd	r31, Z+9	; 0x09
    3576:	e0 2d       	mov	r30, r0
    3578:	ce 01       	movw	r24, r28
    357a:	19 95       	eicall
			break;
    357c:	02 c0       	rjmp	.+4      	; 0x3582 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    357e:	81 e0       	ldi	r24, 0x01	; 1
    3580:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3582:	ce 01       	movw	r24, r28
    3584:	df 91       	pop	r29
    3586:	cf 91       	pop	r28
    3588:	08 95       	ret

0000358a <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    358a:	ff 92       	push	r15
    358c:	0f 93       	push	r16
    358e:	1f 93       	push	r17
    3590:	cf 93       	push	r28
    3592:	df 93       	push	r29
    3594:	cd b7       	in	r28, 0x3d	; 61
    3596:	de b7       	in	r29, 0x3e	; 62
    3598:	61 97       	sbiw	r28, 0x11	; 17
    359a:	cd bf       	out	0x3d, r28	; 61
    359c:	de bf       	out	0x3e, r29	; 62
    359e:	8c 01       	movw	r16, r24
    35a0:	f6 2e       	mov	r15, r22
    35a2:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    35a4:	f8 01       	movw	r30, r16
    35a6:	42 81       	ldd	r20, Z+2	; 0x02
    35a8:	40 31       	cpi	r20, 0x10	; 16
    35aa:	21 f0       	breq	.+8      	; 0x35b4 <_ZN8emstreamlsEj+0x2a>
    35ac:	48 30       	cpi	r20, 0x08	; 8
    35ae:	11 f0       	breq	.+4      	; 0x35b4 <_ZN8emstreamlsEj+0x2a>
    35b0:	42 30       	cpi	r20, 0x02	; 2
    35b2:	41 f4       	brne	.+16     	; 0x35c4 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    35b4:	69 2f       	mov	r22, r25
    35b6:	c8 01       	movw	r24, r16
    35b8:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
    35bc:	6f 2d       	mov	r22, r15
    35be:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
    35c2:	0d c0       	rjmp	.+26     	; 0x35de <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    35c4:	50 e0       	ldi	r21, 0x00	; 0
    35c6:	be 01       	movw	r22, r28
    35c8:	6f 5f       	subi	r22, 0xFF	; 255
    35ca:	7f 4f       	sbci	r23, 0xFF	; 255
    35cc:	8f 2d       	mov	r24, r15
    35ce:	0e 94 3c 22 	call	0x4478	; 0x4478 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    35d2:	be 01       	movw	r22, r28
    35d4:	6f 5f       	subi	r22, 0xFF	; 255
    35d6:	7f 4f       	sbci	r23, 0xFF	; 255
    35d8:	c8 01       	movw	r24, r16
    35da:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35de:	c8 01       	movw	r24, r16
    35e0:	61 96       	adiw	r28, 0x11	; 17
    35e2:	cd bf       	out	0x3d, r28	; 61
    35e4:	de bf       	out	0x3e, r29	; 62
    35e6:	df 91       	pop	r29
    35e8:	cf 91       	pop	r28
    35ea:	1f 91       	pop	r17
    35ec:	0f 91       	pop	r16
    35ee:	ff 90       	pop	r15
    35f0:	08 95       	ret

000035f2 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    35f2:	df 92       	push	r13
    35f4:	ef 92       	push	r14
    35f6:	ff 92       	push	r15
    35f8:	0f 93       	push	r16
    35fa:	1f 93       	push	r17
    35fc:	cf 93       	push	r28
    35fe:	df 93       	push	r29
    3600:	cd b7       	in	r28, 0x3d	; 61
    3602:	de b7       	in	r29, 0x3e	; 62
    3604:	a1 97       	sbiw	r28, 0x21	; 33
    3606:	cd bf       	out	0x3d, r28	; 61
    3608:	de bf       	out	0x3e, r29	; 62
    360a:	8c 01       	movw	r16, r24
    360c:	d4 2e       	mov	r13, r20
    360e:	e5 2e       	mov	r14, r21
    3610:	f6 2e       	mov	r15, r22
    3612:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3614:	f8 01       	movw	r30, r16
    3616:	22 81       	ldd	r18, Z+2	; 0x02
    3618:	20 31       	cpi	r18, 0x10	; 16
    361a:	21 f0       	breq	.+8      	; 0x3624 <_ZN8emstreamlsEm+0x32>
    361c:	28 30       	cpi	r18, 0x08	; 8
    361e:	11 f0       	breq	.+4      	; 0x3624 <_ZN8emstreamlsEm+0x32>
    3620:	22 30       	cpi	r18, 0x02	; 2
    3622:	71 f4       	brne	.+28     	; 0x3640 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3624:	69 2f       	mov	r22, r25
    3626:	c8 01       	movw	r24, r16
    3628:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
    362c:	6f 2d       	mov	r22, r15
    362e:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
    3632:	6e 2d       	mov	r22, r14
    3634:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
    3638:	6d 2d       	mov	r22, r13
    363a:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZN8emstreamlsEh>
    363e:	0f c0       	rjmp	.+30     	; 0x365e <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3640:	30 e0       	ldi	r19, 0x00	; 0
    3642:	ae 01       	movw	r20, r28
    3644:	4f 5f       	subi	r20, 0xFF	; 255
    3646:	5f 4f       	sbci	r21, 0xFF	; 255
    3648:	6d 2d       	mov	r22, r13
    364a:	7e 2d       	mov	r23, r14
    364c:	8f 2d       	mov	r24, r15
    364e:	0e 94 0f 22 	call	0x441e	; 0x441e <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3652:	be 01       	movw	r22, r28
    3654:	6f 5f       	subi	r22, 0xFF	; 255
    3656:	7f 4f       	sbci	r23, 0xFF	; 255
    3658:	c8 01       	movw	r24, r16
    365a:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    365e:	c8 01       	movw	r24, r16
    3660:	a1 96       	adiw	r28, 0x21	; 33
    3662:	cd bf       	out	0x3d, r28	; 61
    3664:	de bf       	out	0x3e, r29	; 62
    3666:	df 91       	pop	r29
    3668:	cf 91       	pop	r28
    366a:	1f 91       	pop	r17
    366c:	0f 91       	pop	r16
    366e:	ff 90       	pop	r15
    3670:	ef 90       	pop	r14
    3672:	df 90       	pop	r13
    3674:	08 95       	ret

00003676 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3676:	cf 92       	push	r12
    3678:	df 92       	push	r13
    367a:	ef 92       	push	r14
    367c:	ff 92       	push	r15
    367e:	0f 93       	push	r16
    3680:	1f 93       	push	r17
    3682:	cf 93       	push	r28
    3684:	df 93       	push	r29
    3686:	cd b7       	in	r28, 0x3d	; 61
    3688:	de b7       	in	r29, 0x3e	; 62
    368a:	29 97       	sbiw	r28, 0x09	; 9
    368c:	cd bf       	out	0x3d, r28	; 61
    368e:	de bf       	out	0x3e, r29	; 62
    3690:	8c 01       	movw	r16, r24
    3692:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3694:	dc 01       	movw	r26, r24
    3696:	13 96       	adiw	r26, 0x03	; 3
    3698:	8c 91       	ld	r24, X
    369a:	13 97       	sbiw	r26, 0x03	; 3
    369c:	88 23       	and	r24, r24
    369e:	41 f0       	breq	.+16     	; 0x36b0 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    36a0:	ed 91       	ld	r30, X+
    36a2:	fc 91       	ld	r31, X
    36a4:	02 80       	ldd	r0, Z+2	; 0x02
    36a6:	f3 81       	ldd	r31, Z+3	; 0x03
    36a8:	e0 2d       	mov	r30, r0
    36aa:	c8 01       	movw	r24, r16
    36ac:	19 95       	eicall
    36ae:	56 c0       	rjmp	.+172    	; 0x375c <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    36b0:	f8 01       	movw	r30, r16
    36b2:	42 81       	ldd	r20, Z+2	; 0x02
    36b4:	42 30       	cpi	r20, 0x02	; 2
    36b6:	19 f5       	brne	.+70     	; 0x36fe <_ZN8emstreamlsEh+0x88>
    36b8:	68 94       	set
    36ba:	cc 24       	eor	r12, r12
    36bc:	c3 f8       	bld	r12, 3
    36be:	d1 2c       	mov	r13, r1
    36c0:	68 94       	set
    36c2:	ff 24       	eor	r15, r15
    36c4:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    36c6:	8e 2d       	mov	r24, r14
    36c8:	8f 21       	and	r24, r15
    36ca:	51 f0       	breq	.+20     	; 0x36e0 <_ZN8emstreamlsEh+0x6a>
    36cc:	d8 01       	movw	r26, r16
    36ce:	ed 91       	ld	r30, X+
    36d0:	fc 91       	ld	r31, X
    36d2:	02 80       	ldd	r0, Z+2	; 0x02
    36d4:	f3 81       	ldd	r31, Z+3	; 0x03
    36d6:	e0 2d       	mov	r30, r0
    36d8:	61 e3       	ldi	r22, 0x31	; 49
    36da:	c8 01       	movw	r24, r16
    36dc:	19 95       	eicall
    36de:	09 c0       	rjmp	.+18     	; 0x36f2 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    36e0:	d8 01       	movw	r26, r16
    36e2:	ed 91       	ld	r30, X+
    36e4:	fc 91       	ld	r31, X
    36e6:	02 80       	ldd	r0, Z+2	; 0x02
    36e8:	f3 81       	ldd	r31, Z+3	; 0x03
    36ea:	e0 2d       	mov	r30, r0
    36ec:	60 e3       	ldi	r22, 0x30	; 48
    36ee:	c8 01       	movw	r24, r16
    36f0:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    36f2:	f6 94       	lsr	r15
    36f4:	b1 e0       	ldi	r27, 0x01	; 1
    36f6:	cb 1a       	sub	r12, r27
    36f8:	d1 08       	sbc	r13, r1
    36fa:	29 f7       	brne	.-54     	; 0x36c6 <_ZN8emstreamlsEh+0x50>
    36fc:	2f c0       	rjmp	.+94     	; 0x375c <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    36fe:	40 31       	cpi	r20, 0x10	; 16
    3700:	f9 f4       	brne	.+62     	; 0x3740 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3702:	62 95       	swap	r22
    3704:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3706:	01 90       	ld	r0, Z+
    3708:	f0 81       	ld	r31, Z
    370a:	e0 2d       	mov	r30, r0
    370c:	02 80       	ldd	r0, Z+2	; 0x02
    370e:	f3 81       	ldd	r31, Z+3	; 0x03
    3710:	e0 2d       	mov	r30, r0
    3712:	6a 30       	cpi	r22, 0x0A	; 10
    3714:	10 f0       	brcs	.+4      	; 0x371a <_ZN8emstreamlsEh+0xa4>
    3716:	69 5c       	subi	r22, 0xC9	; 201
    3718:	01 c0       	rjmp	.+2      	; 0x371c <_ZN8emstreamlsEh+0xa6>
    371a:	60 5d       	subi	r22, 0xD0	; 208
    371c:	c8 01       	movw	r24, r16
    371e:	19 95       	eicall
		temp_char = num & 0x0F;
    3720:	6e 2d       	mov	r22, r14
    3722:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3724:	d8 01       	movw	r26, r16
    3726:	ed 91       	ld	r30, X+
    3728:	fc 91       	ld	r31, X
    372a:	02 80       	ldd	r0, Z+2	; 0x02
    372c:	f3 81       	ldd	r31, Z+3	; 0x03
    372e:	e0 2d       	mov	r30, r0
    3730:	6a 30       	cpi	r22, 0x0A	; 10
    3732:	10 f0       	brcs	.+4      	; 0x3738 <_ZN8emstreamlsEh+0xc2>
    3734:	69 5c       	subi	r22, 0xC9	; 201
    3736:	01 c0       	rjmp	.+2      	; 0x373a <_ZN8emstreamlsEh+0xc4>
    3738:	60 5d       	subi	r22, 0xD0	; 208
    373a:	c8 01       	movw	r24, r16
    373c:	19 95       	eicall
    373e:	0e c0       	rjmp	.+28     	; 0x375c <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3740:	50 e0       	ldi	r21, 0x00	; 0
    3742:	be 01       	movw	r22, r28
    3744:	6f 5f       	subi	r22, 0xFF	; 255
    3746:	7f 4f       	sbci	r23, 0xFF	; 255
    3748:	8e 2d       	mov	r24, r14
    374a:	90 e0       	ldi	r25, 0x00	; 0
    374c:	0e 94 3c 22 	call	0x4478	; 0x4478 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3750:	be 01       	movw	r22, r28
    3752:	6f 5f       	subi	r22, 0xFF	; 255
    3754:	7f 4f       	sbci	r23, 0xFF	; 255
    3756:	c8 01       	movw	r24, r16
    3758:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    375c:	c8 01       	movw	r24, r16
    375e:	29 96       	adiw	r28, 0x09	; 9
    3760:	cd bf       	out	0x3d, r28	; 61
    3762:	de bf       	out	0x3e, r29	; 62
    3764:	df 91       	pop	r29
    3766:	cf 91       	pop	r28
    3768:	1f 91       	pop	r17
    376a:	0f 91       	pop	r16
    376c:	ff 90       	pop	r15
    376e:	ef 90       	pop	r14
    3770:	df 90       	pop	r13
    3772:	cf 90       	pop	r12
    3774:	08 95       	ret

00003776 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3776:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3778:	50 96       	adiw	r26, 0x10	; 16
    377a:	ed 91       	ld	r30, X+
    377c:	fc 91       	ld	r31, X
    377e:	51 97       	sbiw	r26, 0x11	; 17
    3780:	80 81       	ld	r24, Z
    3782:	54 96       	adiw	r26, 0x14	; 20
    3784:	4c 91       	ld	r20, X
    3786:	54 97       	sbiw	r26, 0x14	; 20
    3788:	84 23       	and	r24, r20
    378a:	29 f0       	breq	.+10     	; 0x3796 <_ZN5rs2327putcharEc+0x20>
    378c:	09 c0       	rjmp	.+18     	; 0x37a0 <_ZN5rs2327putcharEc+0x2a>
    378e:	21 50       	subi	r18, 0x01	; 1
    3790:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3792:	19 f4       	brne	.+6      	; 0x379a <_ZN5rs2327putcharEc+0x24>
    3794:	12 c0       	rjmp	.+36     	; 0x37ba <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3796:	21 e2       	ldi	r18, 0x21	; 33
    3798:	3e e4       	ldi	r19, 0x4E	; 78
    379a:	90 81       	ld	r25, Z
    379c:	94 23       	and	r25, r20
    379e:	b9 f3       	breq	.-18     	; 0x378e <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    37a0:	90 81       	ld	r25, Z
    37a2:	56 96       	adiw	r26, 0x16	; 22
    37a4:	8c 91       	ld	r24, X
    37a6:	56 97       	sbiw	r26, 0x16	; 22
    37a8:	89 2b       	or	r24, r25
    37aa:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    37ac:	1e 96       	adiw	r26, 0x0e	; 14
    37ae:	ed 91       	ld	r30, X+
    37b0:	fc 91       	ld	r31, X
    37b2:	1f 97       	sbiw	r26, 0x0f	; 15
    37b4:	60 83       	st	Z, r22
	return (true);
    37b6:	81 e0       	ldi	r24, 0x01	; 1
    37b8:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    37ba:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    37bc:	08 95       	ret

000037be <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    37be:	cf 93       	push	r28
    37c0:	df 93       	push	r29
    37c2:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    37c4:	c1 8d       	ldd	r28, Z+25	; 0x19
    37c6:	d2 8d       	ldd	r29, Z+26	; 0x1a
    37c8:	28 81       	ld	r18, Y
    37ca:	39 81       	ldd	r19, Y+1	; 0x01
    37cc:	a3 8d       	ldd	r26, Z+27	; 0x1b
    37ce:	b4 8d       	ldd	r27, Z+28	; 0x1c
    37d0:	4d 91       	ld	r20, X+
    37d2:	5c 91       	ld	r21, X
    37d4:	24 17       	cp	r18, r20
    37d6:	35 07       	cpc	r19, r21
    37d8:	e9 f3       	breq	.-6      	; 0x37d4 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    37da:	a7 89       	ldd	r26, Z+23	; 0x17
    37dc:	b0 8d       	ldd	r27, Z+24	; 0x18
    37de:	0d 90       	ld	r0, X+
    37e0:	bc 91       	ld	r27, X
    37e2:	a0 2d       	mov	r26, r0
    37e4:	a2 0f       	add	r26, r18
    37e6:	b3 1f       	adc	r27, r19
    37e8:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    37ea:	2f 5f       	subi	r18, 0xFF	; 255
    37ec:	3f 4f       	sbci	r19, 0xFF	; 255
    37ee:	28 83       	st	Y, r18
    37f0:	39 83       	std	Y+1, r19	; 0x01
    37f2:	24 36       	cpi	r18, 0x64	; 100
    37f4:	31 05       	cpc	r19, r1
    37f6:	28 f0       	brcs	.+10     	; 0x3802 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    37f8:	01 8c       	ldd	r0, Z+25	; 0x19
    37fa:	f2 8d       	ldd	r31, Z+26	; 0x1a
    37fc:	e0 2d       	mov	r30, r0
    37fe:	10 82       	st	Z, r1
    3800:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3802:	90 e0       	ldi	r25, 0x00	; 0
    3804:	df 91       	pop	r29
    3806:	cf 91       	pop	r28
    3808:	08 95       	ret

0000380a <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    380a:	cf 93       	push	r28
    380c:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    380e:	ec 01       	movw	r28, r24
    3810:	a9 8d       	ldd	r26, Y+25	; 0x19
    3812:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3814:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3816:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3818:	81 e0       	ldi	r24, 0x01	; 1
    381a:	4d 91       	ld	r20, X+
    381c:	5c 91       	ld	r21, X
    381e:	20 81       	ld	r18, Z
    3820:	31 81       	ldd	r19, Z+1	; 0x01
    3822:	42 17       	cp	r20, r18
    3824:	53 07       	cpc	r21, r19
    3826:	09 f4       	brne	.+2      	; 0x382a <_ZN5rs23214check_for_charEv+0x20>
    3828:	80 e0       	ldi	r24, 0x00	; 0
}
    382a:	df 91       	pop	r29
    382c:	cf 91       	pop	r28
    382e:	08 95       	ret

00003830 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3830:	dc 01       	movw	r26, r24
    3832:	ed 91       	ld	r30, X+
    3834:	fc 91       	ld	r31, X
    3836:	02 80       	ldd	r0, Z+2	; 0x02
    3838:	f3 81       	ldd	r31, Z+3	; 0x03
    383a:	e0 2d       	mov	r30, r0
    383c:	6c e0       	ldi	r22, 0x0C	; 12
    383e:	19 95       	eicall
    3840:	08 95       	ret

00003842 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3842:	ef 92       	push	r14
    3844:	ff 92       	push	r15
    3846:	0f 93       	push	r16
    3848:	1f 93       	push	r17
    384a:	cf 93       	push	r28
    384c:	df 93       	push	r29
    384e:	ec 01       	movw	r28, r24
    3850:	7b 01       	movw	r14, r22
    3852:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3854:	0e 94 39 1a 	call	0x3472	; 0x3472 <_ZN8emstreamC1Ev>
    3858:	a8 01       	movw	r20, r16
    385a:	b7 01       	movw	r22, r14
    385c:	ce 01       	movw	r24, r28
    385e:	08 96       	adiw	r24, 0x08	; 8
    3860:	0e 94 9a 19 	call	0x3334	; 0x3334 <_ZN7base232C1EjP12USART_struct>
    3864:	87 e6       	ldi	r24, 0x67	; 103
    3866:	90 e2       	ldi	r25, 0x20	; 32
    3868:	88 83       	st	Y, r24
    386a:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    386c:	00 3a       	cpi	r16, 0xA0	; 160
    386e:	88 e0       	ldi	r24, 0x08	; 8
    3870:	18 07       	cpc	r17, r24
    3872:	69 f4       	brne	.+26     	; 0x388e <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3874:	84 e4       	ldi	r24, 0x44	; 68
    3876:	91 e3       	ldi	r25, 0x31	; 49
    3878:	8f 8b       	std	Y+23, r24	; 0x17
    387a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    387c:	8a e3       	ldi	r24, 0x3A	; 58
    387e:	91 e3       	ldi	r25, 0x31	; 49
    3880:	89 8f       	std	Y+25, r24	; 0x19
    3882:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3884:	80 e3       	ldi	r24, 0x30	; 48
    3886:	91 e3       	ldi	r25, 0x31	; 49
    3888:	8b 8f       	std	Y+27, r24	; 0x1b
    388a:	9c 8f       	std	Y+28, r25	; 0x1c
    388c:	42 c0       	rjmp	.+132    	; 0x3912 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    388e:	00 3b       	cpi	r16, 0xB0	; 176
    3890:	e8 e0       	ldi	r30, 0x08	; 8
    3892:	1e 07       	cpc	r17, r30
    3894:	69 f4       	brne	.+26     	; 0x38b0 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3896:	82 e4       	ldi	r24, 0x42	; 66
    3898:	91 e3       	ldi	r25, 0x31	; 49
    389a:	8f 8b       	std	Y+23, r24	; 0x17
    389c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    389e:	88 e3       	ldi	r24, 0x38	; 56
    38a0:	91 e3       	ldi	r25, 0x31	; 49
    38a2:	89 8f       	std	Y+25, r24	; 0x19
    38a4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    38a6:	8e e2       	ldi	r24, 0x2E	; 46
    38a8:	91 e3       	ldi	r25, 0x31	; 49
    38aa:	8b 8f       	std	Y+27, r24	; 0x1b
    38ac:	9c 8f       	std	Y+28, r25	; 0x1c
    38ae:	31 c0       	rjmp	.+98     	; 0x3912 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    38b0:	00 3a       	cpi	r16, 0xA0	; 160
    38b2:	f9 e0       	ldi	r31, 0x09	; 9
    38b4:	1f 07       	cpc	r17, r31
    38b6:	69 f4       	brne	.+26     	; 0x38d2 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    38b8:	80 e4       	ldi	r24, 0x40	; 64
    38ba:	91 e3       	ldi	r25, 0x31	; 49
    38bc:	8f 8b       	std	Y+23, r24	; 0x17
    38be:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    38c0:	86 e3       	ldi	r24, 0x36	; 54
    38c2:	91 e3       	ldi	r25, 0x31	; 49
    38c4:	89 8f       	std	Y+25, r24	; 0x19
    38c6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    38c8:	8c e2       	ldi	r24, 0x2C	; 44
    38ca:	91 e3       	ldi	r25, 0x31	; 49
    38cc:	8b 8f       	std	Y+27, r24	; 0x1b
    38ce:	9c 8f       	std	Y+28, r25	; 0x1c
    38d0:	20 c0       	rjmp	.+64     	; 0x3912 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    38d2:	00 3b       	cpi	r16, 0xB0	; 176
    38d4:	89 e0       	ldi	r24, 0x09	; 9
    38d6:	18 07       	cpc	r17, r24
    38d8:	69 f4       	brne	.+26     	; 0x38f4 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    38da:	8e e3       	ldi	r24, 0x3E	; 62
    38dc:	91 e3       	ldi	r25, 0x31	; 49
    38de:	8f 8b       	std	Y+23, r24	; 0x17
    38e0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    38e2:	84 e3       	ldi	r24, 0x34	; 52
    38e4:	91 e3       	ldi	r25, 0x31	; 49
    38e6:	89 8f       	std	Y+25, r24	; 0x19
    38e8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    38ea:	8a e2       	ldi	r24, 0x2A	; 42
    38ec:	91 e3       	ldi	r25, 0x31	; 49
    38ee:	8b 8f       	std	Y+27, r24	; 0x1b
    38f0:	9c 8f       	std	Y+28, r25	; 0x1c
    38f2:	0f c0       	rjmp	.+30     	; 0x3912 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    38f4:	00 3a       	cpi	r16, 0xA0	; 160
    38f6:	1a 40       	sbci	r17, 0x0A	; 10
    38f8:	61 f4       	brne	.+24     	; 0x3912 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    38fa:	8c e3       	ldi	r24, 0x3C	; 60
    38fc:	91 e3       	ldi	r25, 0x31	; 49
    38fe:	8f 8b       	std	Y+23, r24	; 0x17
    3900:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3902:	82 e3       	ldi	r24, 0x32	; 50
    3904:	91 e3       	ldi	r25, 0x31	; 49
    3906:	89 8f       	std	Y+25, r24	; 0x19
    3908:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    390a:	88 e2       	ldi	r24, 0x28	; 40
    390c:	91 e3       	ldi	r25, 0x31	; 49
    390e:	8b 8f       	std	Y+27, r24	; 0x1b
    3910:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3912:	0f 89       	ldd	r16, Y+23	; 0x17
    3914:	18 8d       	ldd	r17, Y+24	; 0x18
    3916:	84 e6       	ldi	r24, 0x64	; 100
    3918:	90 e0       	ldi	r25, 0x00	; 0
    391a:	0e 94 96 19 	call	0x332c	; 0x332c <_Znaj>
    391e:	f8 01       	movw	r30, r16
    3920:	80 83       	st	Z, r24
    3922:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3924:	e9 8d       	ldd	r30, Y+25	; 0x19
    3926:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3928:	10 82       	st	Z, r1
    392a:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    392c:	eb 8d       	ldd	r30, Y+27	; 0x1b
    392e:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3930:	10 82       	st	Z, r1
    3932:	11 82       	std	Z+1, r1	; 0x01
}
    3934:	df 91       	pop	r29
    3936:	cf 91       	pop	r28
    3938:	1f 91       	pop	r17
    393a:	0f 91       	pop	r16
    393c:	ff 90       	pop	r15
    393e:	ef 90       	pop	r14
    3940:	08 95       	ret

00003942 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3942:	1f 92       	push	r1
    3944:	0f 92       	push	r0
    3946:	0f b6       	in	r0, 0x3f	; 63
    3948:	0f 92       	push	r0
    394a:	11 24       	eor	r1, r1
    394c:	08 b6       	in	r0, 0x38	; 56
    394e:	0f 92       	push	r0
    3950:	18 be       	out	0x38, r1	; 56
    3952:	0b b6       	in	r0, 0x3b	; 59
    3954:	0f 92       	push	r0
    3956:	1b be       	out	0x3b, r1	; 59
    3958:	2f 93       	push	r18
    395a:	3f 93       	push	r19
    395c:	8f 93       	push	r24
    395e:	9f 93       	push	r25
    3960:	ef 93       	push	r30
    3962:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3964:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3968:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    396c:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    3970:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3974:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3978:	e8 0f       	add	r30, r24
    397a:	f9 1f       	adc	r31, r25
    397c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    397e:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3982:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3986:	01 96       	adiw	r24, 0x01	; 1
    3988:	84 36       	cpi	r24, 0x64	; 100
    398a:	91 05       	cpc	r25, r1
    398c:	60 f4       	brcc	.+24     	; 0x39a6 <__vector_25+0x64>
    398e:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    3992:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3996:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    399a:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    399e:	82 17       	cp	r24, r18
    39a0:	93 07       	cpc	r25, r19
    39a2:	f1 f4       	brne	.+60     	; 0x39e0 <__vector_25+0x9e>
    39a4:	0c c0       	rjmp	.+24     	; 0x39be <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    39a6:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    39aa:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    39ae:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    39b2:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    39b6:	18 16       	cp	r1, r24
    39b8:	19 06       	cpc	r1, r25
    39ba:	91 f4       	brne	.+36     	; 0x39e0 <__vector_25+0x9e>
    39bc:	0e c0       	rjmp	.+28     	; 0x39da <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    39be:	01 96       	adiw	r24, 0x01	; 1
    39c0:	84 36       	cpi	r24, 0x64	; 100
    39c2:	91 05       	cpc	r25, r1
    39c4:	28 f4       	brcc	.+10     	; 0x39d0 <__vector_25+0x8e>
    39c6:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    39ca:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    39ce:	08 c0       	rjmp	.+16     	; 0x39e0 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    39d0:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    39d4:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    39d8:	03 c0       	rjmp	.+6      	; 0x39e0 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    39da:	81 e0       	ldi	r24, 0x01	; 1
    39dc:	90 e0       	ldi	r25, 0x00	; 0
    39de:	f3 cf       	rjmp	.-26     	; 0x39c6 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    39e0:	ff 91       	pop	r31
    39e2:	ef 91       	pop	r30
    39e4:	9f 91       	pop	r25
    39e6:	8f 91       	pop	r24
    39e8:	3f 91       	pop	r19
    39ea:	2f 91       	pop	r18
    39ec:	0f 90       	pop	r0
    39ee:	0b be       	out	0x3b, r0	; 59
    39f0:	0f 90       	pop	r0
    39f2:	08 be       	out	0x38, r0	; 56
    39f4:	0f 90       	pop	r0
    39f6:	0f be       	out	0x3f, r0	; 63
    39f8:	0f 90       	pop	r0
    39fa:	1f 90       	pop	r1
    39fc:	18 95       	reti

000039fe <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    39fe:	1f 92       	push	r1
    3a00:	0f 92       	push	r0
    3a02:	0f b6       	in	r0, 0x3f	; 63
    3a04:	0f 92       	push	r0
    3a06:	11 24       	eor	r1, r1
    3a08:	08 b6       	in	r0, 0x38	; 56
    3a0a:	0f 92       	push	r0
    3a0c:	18 be       	out	0x38, r1	; 56
    3a0e:	0b b6       	in	r0, 0x3b	; 59
    3a10:	0f 92       	push	r0
    3a12:	1b be       	out	0x3b, r1	; 59
    3a14:	2f 93       	push	r18
    3a16:	3f 93       	push	r19
    3a18:	8f 93       	push	r24
    3a1a:	9f 93       	push	r25
    3a1c:	ef 93       	push	r30
    3a1e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3a20:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3a24:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    3a28:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3a2c:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3a30:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3a34:	e8 0f       	add	r30, r24
    3a36:	f9 1f       	adc	r31, r25
    3a38:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3a3a:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3a3e:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3a42:	01 96       	adiw	r24, 0x01	; 1
    3a44:	84 36       	cpi	r24, 0x64	; 100
    3a46:	91 05       	cpc	r25, r1
    3a48:	60 f4       	brcc	.+24     	; 0x3a62 <__vector_28+0x64>
    3a4a:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    3a4e:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3a52:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    3a56:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    3a5a:	82 17       	cp	r24, r18
    3a5c:	93 07       	cpc	r25, r19
    3a5e:	f1 f4       	brne	.+60     	; 0x3a9c <__vector_28+0x9e>
    3a60:	0c c0       	rjmp	.+24     	; 0x3a7a <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3a62:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    3a66:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3a6a:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    3a6e:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    3a72:	18 16       	cp	r1, r24
    3a74:	19 06       	cpc	r1, r25
    3a76:	91 f4       	brne	.+36     	; 0x3a9c <__vector_28+0x9e>
    3a78:	0e c0       	rjmp	.+28     	; 0x3a96 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a7a:	01 96       	adiw	r24, 0x01	; 1
    3a7c:	84 36       	cpi	r24, 0x64	; 100
    3a7e:	91 05       	cpc	r25, r1
    3a80:	28 f4       	brcc	.+10     	; 0x3a8c <__vector_28+0x8e>
    3a82:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    3a86:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    3a8a:	08 c0       	rjmp	.+16     	; 0x3a9c <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3a8c:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    3a90:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    3a94:	03 c0       	rjmp	.+6      	; 0x3a9c <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a96:	81 e0       	ldi	r24, 0x01	; 1
    3a98:	90 e0       	ldi	r25, 0x00	; 0
    3a9a:	f3 cf       	rjmp	.-26     	; 0x3a82 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3a9c:	ff 91       	pop	r31
    3a9e:	ef 91       	pop	r30
    3aa0:	9f 91       	pop	r25
    3aa2:	8f 91       	pop	r24
    3aa4:	3f 91       	pop	r19
    3aa6:	2f 91       	pop	r18
    3aa8:	0f 90       	pop	r0
    3aaa:	0b be       	out	0x3b, r0	; 59
    3aac:	0f 90       	pop	r0
    3aae:	08 be       	out	0x38, r0	; 56
    3ab0:	0f 90       	pop	r0
    3ab2:	0f be       	out	0x3f, r0	; 63
    3ab4:	0f 90       	pop	r0
    3ab6:	1f 90       	pop	r1
    3ab8:	18 95       	reti

00003aba <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3aba:	1f 92       	push	r1
    3abc:	0f 92       	push	r0
    3abe:	0f b6       	in	r0, 0x3f	; 63
    3ac0:	0f 92       	push	r0
    3ac2:	11 24       	eor	r1, r1
    3ac4:	08 b6       	in	r0, 0x38	; 56
    3ac6:	0f 92       	push	r0
    3ac8:	18 be       	out	0x38, r1	; 56
    3aca:	0b b6       	in	r0, 0x3b	; 59
    3acc:	0f 92       	push	r0
    3ace:	1b be       	out	0x3b, r1	; 59
    3ad0:	2f 93       	push	r18
    3ad2:	3f 93       	push	r19
    3ad4:	8f 93       	push	r24
    3ad6:	9f 93       	push	r25
    3ad8:	ef 93       	push	r30
    3ada:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3adc:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3ae0:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    3ae4:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    3ae8:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3aec:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3af0:	e8 0f       	add	r30, r24
    3af2:	f9 1f       	adc	r31, r25
    3af4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3af6:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    3afa:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    3afe:	01 96       	adiw	r24, 0x01	; 1
    3b00:	84 36       	cpi	r24, 0x64	; 100
    3b02:	91 05       	cpc	r25, r1
    3b04:	60 f4       	brcc	.+24     	; 0x3b1e <__vector_88+0x64>
    3b06:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    3b0a:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3b0e:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    3b12:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3b16:	82 17       	cp	r24, r18
    3b18:	93 07       	cpc	r25, r19
    3b1a:	f1 f4       	brne	.+60     	; 0x3b58 <__vector_88+0x9e>
    3b1c:	0c c0       	rjmp	.+24     	; 0x3b36 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3b1e:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    3b22:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3b26:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    3b2a:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3b2e:	18 16       	cp	r1, r24
    3b30:	19 06       	cpc	r1, r25
    3b32:	91 f4       	brne	.+36     	; 0x3b58 <__vector_88+0x9e>
    3b34:	0e c0       	rjmp	.+28     	; 0x3b52 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3b36:	01 96       	adiw	r24, 0x01	; 1
    3b38:	84 36       	cpi	r24, 0x64	; 100
    3b3a:	91 05       	cpc	r25, r1
    3b3c:	28 f4       	brcc	.+10     	; 0x3b48 <__vector_88+0x8e>
    3b3e:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    3b42:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    3b46:	08 c0       	rjmp	.+16     	; 0x3b58 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3b48:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    3b4c:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    3b50:	03 c0       	rjmp	.+6      	; 0x3b58 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3b52:	81 e0       	ldi	r24, 0x01	; 1
    3b54:	90 e0       	ldi	r25, 0x00	; 0
    3b56:	f3 cf       	rjmp	.-26     	; 0x3b3e <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3b58:	ff 91       	pop	r31
    3b5a:	ef 91       	pop	r30
    3b5c:	9f 91       	pop	r25
    3b5e:	8f 91       	pop	r24
    3b60:	3f 91       	pop	r19
    3b62:	2f 91       	pop	r18
    3b64:	0f 90       	pop	r0
    3b66:	0b be       	out	0x3b, r0	; 59
    3b68:	0f 90       	pop	r0
    3b6a:	08 be       	out	0x38, r0	; 56
    3b6c:	0f 90       	pop	r0
    3b6e:	0f be       	out	0x3f, r0	; 63
    3b70:	0f 90       	pop	r0
    3b72:	1f 90       	pop	r1
    3b74:	18 95       	reti

00003b76 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3b76:	1f 92       	push	r1
    3b78:	0f 92       	push	r0
    3b7a:	0f b6       	in	r0, 0x3f	; 63
    3b7c:	0f 92       	push	r0
    3b7e:	11 24       	eor	r1, r1
    3b80:	08 b6       	in	r0, 0x38	; 56
    3b82:	0f 92       	push	r0
    3b84:	18 be       	out	0x38, r1	; 56
    3b86:	0b b6       	in	r0, 0x3b	; 59
    3b88:	0f 92       	push	r0
    3b8a:	1b be       	out	0x3b, r1	; 59
    3b8c:	2f 93       	push	r18
    3b8e:	3f 93       	push	r19
    3b90:	8f 93       	push	r24
    3b92:	9f 93       	push	r25
    3b94:	ef 93       	push	r30
    3b96:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3b98:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3b9c:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    3ba0:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    3ba4:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3ba8:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3bac:	e8 0f       	add	r30, r24
    3bae:	f9 1f       	adc	r31, r25
    3bb0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3bb2:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3bb6:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3bba:	01 96       	adiw	r24, 0x01	; 1
    3bbc:	84 36       	cpi	r24, 0x64	; 100
    3bbe:	91 05       	cpc	r25, r1
    3bc0:	60 f4       	brcc	.+24     	; 0x3bda <__vector_91+0x64>
    3bc2:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    3bc6:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3bca:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    3bce:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3bd2:	82 17       	cp	r24, r18
    3bd4:	93 07       	cpc	r25, r19
    3bd6:	f1 f4       	brne	.+60     	; 0x3c14 <__vector_91+0x9e>
    3bd8:	0c c0       	rjmp	.+24     	; 0x3bf2 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3bda:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    3bde:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3be2:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    3be6:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3bea:	18 16       	cp	r1, r24
    3bec:	19 06       	cpc	r1, r25
    3bee:	91 f4       	brne	.+36     	; 0x3c14 <__vector_91+0x9e>
    3bf0:	0e c0       	rjmp	.+28     	; 0x3c0e <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3bf2:	01 96       	adiw	r24, 0x01	; 1
    3bf4:	84 36       	cpi	r24, 0x64	; 100
    3bf6:	91 05       	cpc	r25, r1
    3bf8:	28 f4       	brcc	.+10     	; 0x3c04 <__vector_91+0x8e>
    3bfa:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    3bfe:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    3c02:	08 c0       	rjmp	.+16     	; 0x3c14 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3c04:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    3c08:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    3c0c:	03 c0       	rjmp	.+6      	; 0x3c14 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3c0e:	81 e0       	ldi	r24, 0x01	; 1
    3c10:	90 e0       	ldi	r25, 0x00	; 0
    3c12:	f3 cf       	rjmp	.-26     	; 0x3bfa <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3c14:	ff 91       	pop	r31
    3c16:	ef 91       	pop	r30
    3c18:	9f 91       	pop	r25
    3c1a:	8f 91       	pop	r24
    3c1c:	3f 91       	pop	r19
    3c1e:	2f 91       	pop	r18
    3c20:	0f 90       	pop	r0
    3c22:	0b be       	out	0x3b, r0	; 59
    3c24:	0f 90       	pop	r0
    3c26:	08 be       	out	0x38, r0	; 56
    3c28:	0f 90       	pop	r0
    3c2a:	0f be       	out	0x3f, r0	; 63
    3c2c:	0f 90       	pop	r0
    3c2e:	1f 90       	pop	r1
    3c30:	18 95       	reti

00003c32 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3c32:	1f 92       	push	r1
    3c34:	0f 92       	push	r0
    3c36:	0f b6       	in	r0, 0x3f	; 63
    3c38:	0f 92       	push	r0
    3c3a:	11 24       	eor	r1, r1
    3c3c:	08 b6       	in	r0, 0x38	; 56
    3c3e:	0f 92       	push	r0
    3c40:	18 be       	out	0x38, r1	; 56
    3c42:	0b b6       	in	r0, 0x3b	; 59
    3c44:	0f 92       	push	r0
    3c46:	1b be       	out	0x3b, r1	; 59
    3c48:	2f 93       	push	r18
    3c4a:	3f 93       	push	r19
    3c4c:	8f 93       	push	r24
    3c4e:	9f 93       	push	r25
    3c50:	ef 93       	push	r30
    3c52:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3c54:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3c58:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    3c5c:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    3c60:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3c64:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3c68:	e8 0f       	add	r30, r24
    3c6a:	f9 1f       	adc	r31, r25
    3c6c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3c6e:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3c72:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3c76:	01 96       	adiw	r24, 0x01	; 1
    3c78:	84 36       	cpi	r24, 0x64	; 100
    3c7a:	91 05       	cpc	r25, r1
    3c7c:	60 f4       	brcc	.+24     	; 0x3c96 <__vector_58+0x64>
    3c7e:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    3c82:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c86:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    3c8a:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3c8e:	82 17       	cp	r24, r18
    3c90:	93 07       	cpc	r25, r19
    3c92:	f1 f4       	brne	.+60     	; 0x3cd0 <__vector_58+0x9e>
    3c94:	0c c0       	rjmp	.+24     	; 0x3cae <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3c96:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    3c9a:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c9e:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    3ca2:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3ca6:	18 16       	cp	r1, r24
    3ca8:	19 06       	cpc	r1, r25
    3caa:	91 f4       	brne	.+36     	; 0x3cd0 <__vector_58+0x9e>
    3cac:	0e c0       	rjmp	.+28     	; 0x3cca <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3cae:	01 96       	adiw	r24, 0x01	; 1
    3cb0:	84 36       	cpi	r24, 0x64	; 100
    3cb2:	91 05       	cpc	r25, r1
    3cb4:	28 f4       	brcc	.+10     	; 0x3cc0 <__vector_58+0x8e>
    3cb6:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    3cba:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    3cbe:	08 c0       	rjmp	.+16     	; 0x3cd0 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3cc0:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    3cc4:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    3cc8:	03 c0       	rjmp	.+6      	; 0x3cd0 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3cca:	81 e0       	ldi	r24, 0x01	; 1
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	f3 cf       	rjmp	.-26     	; 0x3cb6 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3cd0:	ff 91       	pop	r31
    3cd2:	ef 91       	pop	r30
    3cd4:	9f 91       	pop	r25
    3cd6:	8f 91       	pop	r24
    3cd8:	3f 91       	pop	r19
    3cda:	2f 91       	pop	r18
    3cdc:	0f 90       	pop	r0
    3cde:	0b be       	out	0x3b, r0	; 59
    3ce0:	0f 90       	pop	r0
    3ce2:	08 be       	out	0x38, r0	; 56
    3ce4:	0f 90       	pop	r0
    3ce6:	0f be       	out	0x3f, r0	; 63
    3ce8:	0f 90       	pop	r0
    3cea:	1f 90       	pop	r1
    3cec:	18 95       	reti

00003cee <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3cee:	0f 93       	push	r16
    3cf0:	cf 93       	push	r28
    3cf2:	df 93       	push	r29
    3cf4:	1f 92       	push	r1
    3cf6:	cd b7       	in	r28, 0x3d	; 61
    3cf8:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3cfa:	2f b7       	in	r18, 0x3f	; 63
    3cfc:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3cfe:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3d00:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3d02:	fc 01       	movw	r30, r24
    3d04:	08 ed       	ldi	r16, 0xD8	; 216
    3d06:	04 bf       	out	0x34, r16	; 52
    3d08:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3d0a:	89 81       	ldd	r24, Y+1	; 0x01
    3d0c:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3d0e:	0f 90       	pop	r0
    3d10:	df 91       	pop	r29
    3d12:	cf 91       	pop	r28
    3d14:	0f 91       	pop	r16
    3d16:	08 95       	ret

00003d18 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3d18:	0f 93       	push	r16
    3d1a:	1f 93       	push	r17
    3d1c:	cf 93       	push	r28
    3d1e:	df 93       	push	r29
    3d20:	cd b7       	in	r28, 0x3d	; 61
    3d22:	de b7       	in	r29, 0x3e	; 62
    3d24:	6d 97       	sbiw	r28, 0x1d	; 29
    3d26:	cd bf       	out	0x3d, r28	; 61
    3d28:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3d2a:	e0 e6       	ldi	r30, 0x60	; 96
    3d2c:	f6 e0       	ldi	r31, 0x06	; 6
    3d2e:	80 e4       	ldi	r24, 0x40	; 64
    3d30:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3d32:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3d34:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3d36:	e0 e5       	ldi	r30, 0x50	; 80
    3d38:	f0 e0       	ldi	r31, 0x00	; 0
    3d3a:	80 81       	ld	r24, Z
    3d3c:	82 60       	ori	r24, 0x02	; 2
    3d3e:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3d40:	81 81       	ldd	r24, Z+1	; 0x01
    3d42:	81 ff       	sbrs	r24, 1
    3d44:	fd cf       	rjmp	.-6      	; 0x3d40 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3d46:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3d4a:	68 7f       	andi	r22, 0xF8	; 248
    3d4c:	61 60       	ori	r22, 0x01	; 1
    3d4e:	80 e4       	ldi	r24, 0x40	; 64
    3d50:	90 e0       	ldi	r25, 0x00	; 0
    3d52:	0e 94 77 1e 	call	0x3cee	; 0x3cee <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3d56:	e0 e5       	ldi	r30, 0x50	; 80
    3d58:	f0 e0       	ldi	r31, 0x00	; 0
    3d5a:	80 81       	ld	r24, Z
    3d5c:	8e 7f       	andi	r24, 0xFE	; 254
    3d5e:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3d60:	9d ef       	ldi	r25, 0xFD	; 253
    3d62:	88 ed       	ldi	r24, 0xD8	; 216
    3d64:	08 b6       	in	r0, 0x38	; 56
    3d66:	18 be       	out	0x38, r1	; 56
    3d68:	84 bf       	out	0x34, r24	; 52
    3d6a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3d6e:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3d70:	40 eb       	ldi	r20, 0xB0	; 176
    3d72:	58 e0       	ldi	r21, 0x08	; 8
    3d74:	60 e0       	ldi	r22, 0x00	; 0
    3d76:	70 e0       	ldi	r23, 0x00	; 0
    3d78:	ce 01       	movw	r24, r28
    3d7a:	01 96       	adiw	r24, 0x01	; 1
    3d7c:	0e 94 21 1c 	call	0x3842	; 0x3842 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3d80:	67 e0       	ldi	r22, 0x07	; 7
    3d82:	ce 01       	movw	r24, r28
    3d84:	01 96       	adiw	r24, 0x01	; 1
    3d86:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    3d8a:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3d8c:	63 e7       	ldi	r22, 0x73	; 115
    3d8e:	70 e2       	ldi	r23, 0x20	; 32
    3d90:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN8emstream4putsEPKc>
    3d94:	66 e0       	ldi	r22, 0x06	; 6
    3d96:	c8 01       	movw	r24, r16
    3d98:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
    3d9c:	66 e0       	ldi	r22, 0x06	; 6
    3d9e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3da2:	82 e1       	ldi	r24, 0x12	; 18
    3da4:	90 e0       	ldi	r25, 0x00	; 0
    3da6:	0e 94 8e 19 	call	0x331c	; 0x331c <_Znwj>
    3daa:	8e 01       	movw	r16, r28
    3dac:	0f 5f       	subi	r16, 0xFF	; 255
    3dae:	1f 4f       	sbci	r17, 0xFF	; 255
    3db0:	24 e0       	ldi	r18, 0x04	; 4
    3db2:	31 e0       	ldi	r19, 0x01	; 1
    3db4:	40 e0       	ldi	r20, 0x00	; 0
    3db6:	62 e9       	ldi	r22, 0x92	; 146
    3db8:	70 e2       	ldi	r23, 0x20	; 32
    3dba:	0e 94 4f 07 	call	0xe9e	; 0xe9e <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3dbe:	82 e1       	ldi	r24, 0x12	; 18
    3dc0:	90 e0       	ldi	r25, 0x00	; 0
    3dc2:	0e 94 8e 19 	call	0x331c	; 0x331c <_Znwj>
    3dc6:	24 e0       	ldi	r18, 0x04	; 4
    3dc8:	31 e0       	ldi	r19, 0x01	; 1
    3dca:	42 e0       	ldi	r20, 0x02	; 2
    3dcc:	6a e9       	ldi	r22, 0x9A	; 154
    3dce:	70 e2       	ldi	r23, 0x20	; 32
    3dd0:	0e 94 82 03 	call	0x704	; 0x704 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3dd4:	82 e1       	ldi	r24, 0x12	; 18
    3dd6:	90 e0       	ldi	r25, 0x00	; 0
    3dd8:	0e 94 8e 19 	call	0x331c	; 0x331c <_Znwj>
    3ddc:	24 e0       	ldi	r18, 0x04	; 4
    3dde:	31 e0       	ldi	r19, 0x01	; 1
    3de0:	43 e0       	ldi	r20, 0x03	; 3
    3de2:	61 ea       	ldi	r22, 0xA1	; 161
    3de4:	70 e2       	ldi	r23, 0x20	; 32
    3de6:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3dea:	82 e1       	ldi	r24, 0x12	; 18
    3dec:	90 e0       	ldi	r25, 0x00	; 0
    3dee:	0e 94 8e 19 	call	0x331c	; 0x331c <_Znwj>
    3df2:	24 e0       	ldi	r18, 0x04	; 4
    3df4:	31 e0       	ldi	r19, 0x01	; 1
    3df6:	44 e0       	ldi	r20, 0x04	; 4
    3df8:	68 ea       	ldi	r22, 0xA8	; 168
    3dfa:	70 e2       	ldi	r23, 0x20	; 32
    3dfc:	0e 94 57 04 	call	0x8ae	; 0x8ae <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(1), 260, &ser_dev);
    3e00:	82 e4       	ldi	r24, 0x42	; 66
    3e02:	90 e0       	ldi	r25, 0x00	; 0
    3e04:	0e 94 8e 19 	call	0x331c	; 0x331c <_Znwj>
    3e08:	24 e0       	ldi	r18, 0x04	; 4
    3e0a:	31 e0       	ldi	r19, 0x01	; 1
    3e0c:	41 e0       	ldi	r20, 0x01	; 1
    3e0e:	61 eb       	ldi	r22, 0xB1	; 177
    3e10:	70 e2       	ldi	r23, 0x20	; 32
    3e12:	0e 94 8c 05 	call	0xb18	; 0xb18 <_ZN5MotorC1EPKchjP8emstream>
	
	new PWMdriver ("PWM", task_priority(5), 260, &ser_dev);
    3e16:	82 e1       	ldi	r24, 0x12	; 18
    3e18:	90 e0       	ldi	r25, 0x00	; 0
    3e1a:	0e 94 8e 19 	call	0x331c	; 0x331c <_Znwj>
    3e1e:	24 e0       	ldi	r18, 0x04	; 4
    3e20:	31 e0       	ldi	r19, 0x01	; 1
    3e22:	44 e0       	ldi	r20, 0x04	; 4
    3e24:	67 eb       	ldi	r22, 0xB7	; 183
    3e26:	70 e2       	ldi	r23, 0x20	; 32
    3e28:	0e 94 3f 07 	call	0xe7e	; 0xe7e <_ZN9PWMdriverC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3e2c:	87 e0       	ldi	r24, 0x07	; 7
    3e2e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3e32:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3e34:	0e 94 a0 10 	call	0x2140	; 0x2140 <vTaskStartScheduler>
	
	
	return 0;
    3e38:	80 e0       	ldi	r24, 0x00	; 0
    3e3a:	90 e0       	ldi	r25, 0x00	; 0
    3e3c:	6d 96       	adiw	r28, 0x1d	; 29
    3e3e:	cd bf       	out	0x3d, r28	; 61
    3e40:	de bf       	out	0x3e, r29	; 62
    3e42:	df 91       	pop	r29
    3e44:	cf 91       	pop	r28
    3e46:	1f 91       	pop	r17
    3e48:	0f 91       	pop	r16
    3e4a:	08 95       	ret

00003e4c <_GLOBAL__sub_I_counter>:
    3e4c:	0f 93       	push	r16
    3e4e:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3e50:	0a e0       	ldi	r16, 0x0A	; 10
    3e52:	10 e0       	ldi	r17, 0x00	; 0
    3e54:	20 e0       	ldi	r18, 0x00	; 0
    3e56:	30 e0       	ldi	r19, 0x00	; 0
    3e58:	40 e0       	ldi	r20, 0x00	; 0
    3e5a:	50 e0       	ldi	r21, 0x00	; 0
    3e5c:	60 e2       	ldi	r22, 0x20	; 32
    3e5e:	70 e0       	ldi	r23, 0x00	; 0
    3e60:	80 e5       	ldi	r24, 0x50	; 80
    3e62:	91 e3       	ldi	r25, 0x31	; 49
    3e64:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3e68:	1f 91       	pop	r17
    3e6a:	0f 91       	pop	r16
    3e6c:	08 95       	ret

00003e6e <__subsf3>:
    3e6e:	50 58       	subi	r21, 0x80	; 128

00003e70 <__addsf3>:
    3e70:	bb 27       	eor	r27, r27
    3e72:	aa 27       	eor	r26, r26
    3e74:	0e 94 4f 1f 	call	0x3e9e	; 0x3e9e <__addsf3x>
    3e78:	0c 94 c9 20 	jmp	0x4192	; 0x4192 <__fp_round>
    3e7c:	0e 94 bb 20 	call	0x4176	; 0x4176 <__fp_pscA>
    3e80:	38 f0       	brcs	.+14     	; 0x3e90 <__addsf3+0x20>
    3e82:	0e 94 c2 20 	call	0x4184	; 0x4184 <__fp_pscB>
    3e86:	20 f0       	brcs	.+8      	; 0x3e90 <__addsf3+0x20>
    3e88:	39 f4       	brne	.+14     	; 0x3e98 <__addsf3+0x28>
    3e8a:	9f 3f       	cpi	r25, 0xFF	; 255
    3e8c:	19 f4       	brne	.+6      	; 0x3e94 <__addsf3+0x24>
    3e8e:	26 f4       	brtc	.+8      	; 0x3e98 <__addsf3+0x28>
    3e90:	0c 94 b8 20 	jmp	0x4170	; 0x4170 <__fp_nan>
    3e94:	0e f4       	brtc	.+2      	; 0x3e98 <__addsf3+0x28>
    3e96:	e0 95       	com	r30
    3e98:	e7 fb       	bst	r30, 7
    3e9a:	0c 94 b2 20 	jmp	0x4164	; 0x4164 <__fp_inf>

00003e9e <__addsf3x>:
    3e9e:	e9 2f       	mov	r30, r25
    3ea0:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__fp_split3>
    3ea4:	58 f3       	brcs	.-42     	; 0x3e7c <__addsf3+0xc>
    3ea6:	ba 17       	cp	r27, r26
    3ea8:	62 07       	cpc	r22, r18
    3eaa:	73 07       	cpc	r23, r19
    3eac:	84 07       	cpc	r24, r20
    3eae:	95 07       	cpc	r25, r21
    3eb0:	20 f0       	brcs	.+8      	; 0x3eba <__addsf3x+0x1c>
    3eb2:	79 f4       	brne	.+30     	; 0x3ed2 <__addsf3x+0x34>
    3eb4:	a6 f5       	brtc	.+104    	; 0x3f1e <__addsf3x+0x80>
    3eb6:	0c 94 fc 20 	jmp	0x41f8	; 0x41f8 <__fp_zero>
    3eba:	0e f4       	brtc	.+2      	; 0x3ebe <__addsf3x+0x20>
    3ebc:	e0 95       	com	r30
    3ebe:	0b 2e       	mov	r0, r27
    3ec0:	ba 2f       	mov	r27, r26
    3ec2:	a0 2d       	mov	r26, r0
    3ec4:	0b 01       	movw	r0, r22
    3ec6:	b9 01       	movw	r22, r18
    3ec8:	90 01       	movw	r18, r0
    3eca:	0c 01       	movw	r0, r24
    3ecc:	ca 01       	movw	r24, r20
    3ece:	a0 01       	movw	r20, r0
    3ed0:	11 24       	eor	r1, r1
    3ed2:	ff 27       	eor	r31, r31
    3ed4:	59 1b       	sub	r21, r25
    3ed6:	99 f0       	breq	.+38     	; 0x3efe <__addsf3x+0x60>
    3ed8:	59 3f       	cpi	r21, 0xF9	; 249
    3eda:	50 f4       	brcc	.+20     	; 0x3ef0 <__addsf3x+0x52>
    3edc:	50 3e       	cpi	r21, 0xE0	; 224
    3ede:	68 f1       	brcs	.+90     	; 0x3f3a <__addsf3x+0x9c>
    3ee0:	1a 16       	cp	r1, r26
    3ee2:	f0 40       	sbci	r31, 0x00	; 0
    3ee4:	a2 2f       	mov	r26, r18
    3ee6:	23 2f       	mov	r18, r19
    3ee8:	34 2f       	mov	r19, r20
    3eea:	44 27       	eor	r20, r20
    3eec:	58 5f       	subi	r21, 0xF8	; 248
    3eee:	f3 cf       	rjmp	.-26     	; 0x3ed6 <__addsf3x+0x38>
    3ef0:	46 95       	lsr	r20
    3ef2:	37 95       	ror	r19
    3ef4:	27 95       	ror	r18
    3ef6:	a7 95       	ror	r26
    3ef8:	f0 40       	sbci	r31, 0x00	; 0
    3efa:	53 95       	inc	r21
    3efc:	c9 f7       	brne	.-14     	; 0x3ef0 <__addsf3x+0x52>
    3efe:	7e f4       	brtc	.+30     	; 0x3f1e <__addsf3x+0x80>
    3f00:	1f 16       	cp	r1, r31
    3f02:	ba 0b       	sbc	r27, r26
    3f04:	62 0b       	sbc	r22, r18
    3f06:	73 0b       	sbc	r23, r19
    3f08:	84 0b       	sbc	r24, r20
    3f0a:	ba f0       	brmi	.+46     	; 0x3f3a <__addsf3x+0x9c>
    3f0c:	91 50       	subi	r25, 0x01	; 1
    3f0e:	a1 f0       	breq	.+40     	; 0x3f38 <__addsf3x+0x9a>
    3f10:	ff 0f       	add	r31, r31
    3f12:	bb 1f       	adc	r27, r27
    3f14:	66 1f       	adc	r22, r22
    3f16:	77 1f       	adc	r23, r23
    3f18:	88 1f       	adc	r24, r24
    3f1a:	c2 f7       	brpl	.-16     	; 0x3f0c <__addsf3x+0x6e>
    3f1c:	0e c0       	rjmp	.+28     	; 0x3f3a <__addsf3x+0x9c>
    3f1e:	ba 0f       	add	r27, r26
    3f20:	62 1f       	adc	r22, r18
    3f22:	73 1f       	adc	r23, r19
    3f24:	84 1f       	adc	r24, r20
    3f26:	48 f4       	brcc	.+18     	; 0x3f3a <__addsf3x+0x9c>
    3f28:	87 95       	ror	r24
    3f2a:	77 95       	ror	r23
    3f2c:	67 95       	ror	r22
    3f2e:	b7 95       	ror	r27
    3f30:	f7 95       	ror	r31
    3f32:	9e 3f       	cpi	r25, 0xFE	; 254
    3f34:	08 f0       	brcs	.+2      	; 0x3f38 <__addsf3x+0x9a>
    3f36:	b0 cf       	rjmp	.-160    	; 0x3e98 <__addsf3+0x28>
    3f38:	93 95       	inc	r25
    3f3a:	88 0f       	add	r24, r24
    3f3c:	08 f0       	brcs	.+2      	; 0x3f40 <__addsf3x+0xa2>
    3f3e:	99 27       	eor	r25, r25
    3f40:	ee 0f       	add	r30, r30
    3f42:	97 95       	ror	r25
    3f44:	87 95       	ror	r24
    3f46:	08 95       	ret

00003f48 <__cmpsf2>:
    3f48:	0e 94 8e 20 	call	0x411c	; 0x411c <__fp_cmp>
    3f4c:	08 f4       	brcc	.+2      	; 0x3f50 <__cmpsf2+0x8>
    3f4e:	81 e0       	ldi	r24, 0x01	; 1
    3f50:	08 95       	ret

00003f52 <__divsf3>:
    3f52:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <__divsf3x>
    3f56:	0c 94 c9 20 	jmp	0x4192	; 0x4192 <__fp_round>
    3f5a:	0e 94 c2 20 	call	0x4184	; 0x4184 <__fp_pscB>
    3f5e:	58 f0       	brcs	.+22     	; 0x3f76 <__divsf3+0x24>
    3f60:	0e 94 bb 20 	call	0x4176	; 0x4176 <__fp_pscA>
    3f64:	40 f0       	brcs	.+16     	; 0x3f76 <__divsf3+0x24>
    3f66:	29 f4       	brne	.+10     	; 0x3f72 <__divsf3+0x20>
    3f68:	5f 3f       	cpi	r21, 0xFF	; 255
    3f6a:	29 f0       	breq	.+10     	; 0x3f76 <__divsf3+0x24>
    3f6c:	0c 94 b2 20 	jmp	0x4164	; 0x4164 <__fp_inf>
    3f70:	51 11       	cpse	r21, r1
    3f72:	0c 94 fd 20 	jmp	0x41fa	; 0x41fa <__fp_szero>
    3f76:	0c 94 b8 20 	jmp	0x4170	; 0x4170 <__fp_nan>

00003f7a <__divsf3x>:
    3f7a:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__fp_split3>
    3f7e:	68 f3       	brcs	.-38     	; 0x3f5a <__divsf3+0x8>

00003f80 <__divsf3_pse>:
    3f80:	99 23       	and	r25, r25
    3f82:	b1 f3       	breq	.-20     	; 0x3f70 <__divsf3+0x1e>
    3f84:	55 23       	and	r21, r21
    3f86:	91 f3       	breq	.-28     	; 0x3f6c <__divsf3+0x1a>
    3f88:	95 1b       	sub	r25, r21
    3f8a:	55 0b       	sbc	r21, r21
    3f8c:	bb 27       	eor	r27, r27
    3f8e:	aa 27       	eor	r26, r26
    3f90:	62 17       	cp	r22, r18
    3f92:	73 07       	cpc	r23, r19
    3f94:	84 07       	cpc	r24, r20
    3f96:	38 f0       	brcs	.+14     	; 0x3fa6 <__divsf3_pse+0x26>
    3f98:	9f 5f       	subi	r25, 0xFF	; 255
    3f9a:	5f 4f       	sbci	r21, 0xFF	; 255
    3f9c:	22 0f       	add	r18, r18
    3f9e:	33 1f       	adc	r19, r19
    3fa0:	44 1f       	adc	r20, r20
    3fa2:	aa 1f       	adc	r26, r26
    3fa4:	a9 f3       	breq	.-22     	; 0x3f90 <__divsf3_pse+0x10>
    3fa6:	35 d0       	rcall	.+106    	; 0x4012 <__stack+0x13>
    3fa8:	0e 2e       	mov	r0, r30
    3faa:	3a f0       	brmi	.+14     	; 0x3fba <__divsf3_pse+0x3a>
    3fac:	e0 e8       	ldi	r30, 0x80	; 128
    3fae:	32 d0       	rcall	.+100    	; 0x4014 <__stack+0x15>
    3fb0:	91 50       	subi	r25, 0x01	; 1
    3fb2:	50 40       	sbci	r21, 0x00	; 0
    3fb4:	e6 95       	lsr	r30
    3fb6:	00 1c       	adc	r0, r0
    3fb8:	ca f7       	brpl	.-14     	; 0x3fac <__divsf3_pse+0x2c>
    3fba:	2b d0       	rcall	.+86     	; 0x4012 <__stack+0x13>
    3fbc:	fe 2f       	mov	r31, r30
    3fbe:	29 d0       	rcall	.+82     	; 0x4012 <__stack+0x13>
    3fc0:	66 0f       	add	r22, r22
    3fc2:	77 1f       	adc	r23, r23
    3fc4:	88 1f       	adc	r24, r24
    3fc6:	bb 1f       	adc	r27, r27
    3fc8:	26 17       	cp	r18, r22
    3fca:	37 07       	cpc	r19, r23
    3fcc:	48 07       	cpc	r20, r24
    3fce:	ab 07       	cpc	r26, r27
    3fd0:	b0 e8       	ldi	r27, 0x80	; 128
    3fd2:	09 f0       	breq	.+2      	; 0x3fd6 <__divsf3_pse+0x56>
    3fd4:	bb 0b       	sbc	r27, r27
    3fd6:	80 2d       	mov	r24, r0
    3fd8:	bf 01       	movw	r22, r30
    3fda:	ff 27       	eor	r31, r31
    3fdc:	93 58       	subi	r25, 0x83	; 131
    3fde:	5f 4f       	sbci	r21, 0xFF	; 255
    3fe0:	3a f0       	brmi	.+14     	; 0x3ff0 <__divsf3_pse+0x70>
    3fe2:	9e 3f       	cpi	r25, 0xFE	; 254
    3fe4:	51 05       	cpc	r21, r1
    3fe6:	78 f0       	brcs	.+30     	; 0x4006 <__stack+0x7>
    3fe8:	0c 94 b2 20 	jmp	0x4164	; 0x4164 <__fp_inf>
    3fec:	0c 94 fd 20 	jmp	0x41fa	; 0x41fa <__fp_szero>
    3ff0:	5f 3f       	cpi	r21, 0xFF	; 255
    3ff2:	e4 f3       	brlt	.-8      	; 0x3fec <__divsf3_pse+0x6c>
    3ff4:	98 3e       	cpi	r25, 0xE8	; 232
    3ff6:	d4 f3       	brlt	.-12     	; 0x3fec <__divsf3_pse+0x6c>
    3ff8:	86 95       	lsr	r24
    3ffa:	77 95       	ror	r23
    3ffc:	67 95       	ror	r22
    3ffe:	b7 95       	ror	r27
    4000:	f7 95       	ror	r31
    4002:	9f 5f       	subi	r25, 0xFF	; 255
    4004:	c9 f7       	brne	.-14     	; 0x3ff8 <__divsf3_pse+0x78>
    4006:	88 0f       	add	r24, r24
    4008:	91 1d       	adc	r25, r1
    400a:	96 95       	lsr	r25
    400c:	87 95       	ror	r24
    400e:	97 f9       	bld	r25, 7
    4010:	08 95       	ret
    4012:	e1 e0       	ldi	r30, 0x01	; 1
    4014:	66 0f       	add	r22, r22
    4016:	77 1f       	adc	r23, r23
    4018:	88 1f       	adc	r24, r24
    401a:	bb 1f       	adc	r27, r27
    401c:	62 17       	cp	r22, r18
    401e:	73 07       	cpc	r23, r19
    4020:	84 07       	cpc	r24, r20
    4022:	ba 07       	cpc	r27, r26
    4024:	20 f0       	brcs	.+8      	; 0x402e <__stack+0x2f>
    4026:	62 1b       	sub	r22, r18
    4028:	73 0b       	sbc	r23, r19
    402a:	84 0b       	sbc	r24, r20
    402c:	ba 0b       	sbc	r27, r26
    402e:	ee 1f       	adc	r30, r30
    4030:	88 f7       	brcc	.-30     	; 0x4014 <__stack+0x15>
    4032:	e0 95       	com	r30
    4034:	08 95       	ret

00004036 <__fixsfsi>:
    4036:	0e 94 22 20 	call	0x4044	; 0x4044 <__fixunssfsi>
    403a:	68 94       	set
    403c:	b1 11       	cpse	r27, r1
    403e:	0c 94 fd 20 	jmp	0x41fa	; 0x41fa <__fp_szero>
    4042:	08 95       	ret

00004044 <__fixunssfsi>:
    4044:	0e 94 e2 20 	call	0x41c4	; 0x41c4 <__fp_splitA>
    4048:	88 f0       	brcs	.+34     	; 0x406c <__fixunssfsi+0x28>
    404a:	9f 57       	subi	r25, 0x7F	; 127
    404c:	98 f0       	brcs	.+38     	; 0x4074 <__fixunssfsi+0x30>
    404e:	b9 2f       	mov	r27, r25
    4050:	99 27       	eor	r25, r25
    4052:	b7 51       	subi	r27, 0x17	; 23
    4054:	b0 f0       	brcs	.+44     	; 0x4082 <__fixunssfsi+0x3e>
    4056:	e1 f0       	breq	.+56     	; 0x4090 <__fixunssfsi+0x4c>
    4058:	66 0f       	add	r22, r22
    405a:	77 1f       	adc	r23, r23
    405c:	88 1f       	adc	r24, r24
    405e:	99 1f       	adc	r25, r25
    4060:	1a f0       	brmi	.+6      	; 0x4068 <__fixunssfsi+0x24>
    4062:	ba 95       	dec	r27
    4064:	c9 f7       	brne	.-14     	; 0x4058 <__fixunssfsi+0x14>
    4066:	14 c0       	rjmp	.+40     	; 0x4090 <__fixunssfsi+0x4c>
    4068:	b1 30       	cpi	r27, 0x01	; 1
    406a:	91 f0       	breq	.+36     	; 0x4090 <__fixunssfsi+0x4c>
    406c:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <__fp_zero>
    4070:	b1 e0       	ldi	r27, 0x01	; 1
    4072:	08 95       	ret
    4074:	0c 94 fc 20 	jmp	0x41f8	; 0x41f8 <__fp_zero>
    4078:	67 2f       	mov	r22, r23
    407a:	78 2f       	mov	r23, r24
    407c:	88 27       	eor	r24, r24
    407e:	b8 5f       	subi	r27, 0xF8	; 248
    4080:	39 f0       	breq	.+14     	; 0x4090 <__fixunssfsi+0x4c>
    4082:	b9 3f       	cpi	r27, 0xF9	; 249
    4084:	cc f3       	brlt	.-14     	; 0x4078 <__fixunssfsi+0x34>
    4086:	86 95       	lsr	r24
    4088:	77 95       	ror	r23
    408a:	67 95       	ror	r22
    408c:	b3 95       	inc	r27
    408e:	d9 f7       	brne	.-10     	; 0x4086 <__fixunssfsi+0x42>
    4090:	3e f4       	brtc	.+14     	; 0x40a0 <__fixunssfsi+0x5c>
    4092:	90 95       	com	r25
    4094:	80 95       	com	r24
    4096:	70 95       	com	r23
    4098:	61 95       	neg	r22
    409a:	7f 4f       	sbci	r23, 0xFF	; 255
    409c:	8f 4f       	sbci	r24, 0xFF	; 255
    409e:	9f 4f       	sbci	r25, 0xFF	; 255
    40a0:	08 95       	ret

000040a2 <__floatunsisf>:
    40a2:	e8 94       	clt
    40a4:	09 c0       	rjmp	.+18     	; 0x40b8 <__floatsisf+0x12>

000040a6 <__floatsisf>:
    40a6:	97 fb       	bst	r25, 7
    40a8:	3e f4       	brtc	.+14     	; 0x40b8 <__floatsisf+0x12>
    40aa:	90 95       	com	r25
    40ac:	80 95       	com	r24
    40ae:	70 95       	com	r23
    40b0:	61 95       	neg	r22
    40b2:	7f 4f       	sbci	r23, 0xFF	; 255
    40b4:	8f 4f       	sbci	r24, 0xFF	; 255
    40b6:	9f 4f       	sbci	r25, 0xFF	; 255
    40b8:	99 23       	and	r25, r25
    40ba:	a9 f0       	breq	.+42     	; 0x40e6 <__floatsisf+0x40>
    40bc:	f9 2f       	mov	r31, r25
    40be:	96 e9       	ldi	r25, 0x96	; 150
    40c0:	bb 27       	eor	r27, r27
    40c2:	93 95       	inc	r25
    40c4:	f6 95       	lsr	r31
    40c6:	87 95       	ror	r24
    40c8:	77 95       	ror	r23
    40ca:	67 95       	ror	r22
    40cc:	b7 95       	ror	r27
    40ce:	f1 11       	cpse	r31, r1
    40d0:	f8 cf       	rjmp	.-16     	; 0x40c2 <__floatsisf+0x1c>
    40d2:	fa f4       	brpl	.+62     	; 0x4112 <__floatsisf+0x6c>
    40d4:	bb 0f       	add	r27, r27
    40d6:	11 f4       	brne	.+4      	; 0x40dc <__floatsisf+0x36>
    40d8:	60 ff       	sbrs	r22, 0
    40da:	1b c0       	rjmp	.+54     	; 0x4112 <__floatsisf+0x6c>
    40dc:	6f 5f       	subi	r22, 0xFF	; 255
    40de:	7f 4f       	sbci	r23, 0xFF	; 255
    40e0:	8f 4f       	sbci	r24, 0xFF	; 255
    40e2:	9f 4f       	sbci	r25, 0xFF	; 255
    40e4:	16 c0       	rjmp	.+44     	; 0x4112 <__floatsisf+0x6c>
    40e6:	88 23       	and	r24, r24
    40e8:	11 f0       	breq	.+4      	; 0x40ee <__floatsisf+0x48>
    40ea:	96 e9       	ldi	r25, 0x96	; 150
    40ec:	11 c0       	rjmp	.+34     	; 0x4110 <__floatsisf+0x6a>
    40ee:	77 23       	and	r23, r23
    40f0:	21 f0       	breq	.+8      	; 0x40fa <__floatsisf+0x54>
    40f2:	9e e8       	ldi	r25, 0x8E	; 142
    40f4:	87 2f       	mov	r24, r23
    40f6:	76 2f       	mov	r23, r22
    40f8:	05 c0       	rjmp	.+10     	; 0x4104 <__floatsisf+0x5e>
    40fa:	66 23       	and	r22, r22
    40fc:	71 f0       	breq	.+28     	; 0x411a <__floatsisf+0x74>
    40fe:	96 e8       	ldi	r25, 0x86	; 134
    4100:	86 2f       	mov	r24, r22
    4102:	70 e0       	ldi	r23, 0x00	; 0
    4104:	60 e0       	ldi	r22, 0x00	; 0
    4106:	2a f0       	brmi	.+10     	; 0x4112 <__floatsisf+0x6c>
    4108:	9a 95       	dec	r25
    410a:	66 0f       	add	r22, r22
    410c:	77 1f       	adc	r23, r23
    410e:	88 1f       	adc	r24, r24
    4110:	da f7       	brpl	.-10     	; 0x4108 <__floatsisf+0x62>
    4112:	88 0f       	add	r24, r24
    4114:	96 95       	lsr	r25
    4116:	87 95       	ror	r24
    4118:	97 f9       	bld	r25, 7
    411a:	08 95       	ret

0000411c <__fp_cmp>:
    411c:	99 0f       	add	r25, r25
    411e:	00 08       	sbc	r0, r0
    4120:	55 0f       	add	r21, r21
    4122:	aa 0b       	sbc	r26, r26
    4124:	e0 e8       	ldi	r30, 0x80	; 128
    4126:	fe ef       	ldi	r31, 0xFE	; 254
    4128:	16 16       	cp	r1, r22
    412a:	17 06       	cpc	r1, r23
    412c:	e8 07       	cpc	r30, r24
    412e:	f9 07       	cpc	r31, r25
    4130:	c0 f0       	brcs	.+48     	; 0x4162 <__fp_cmp+0x46>
    4132:	12 16       	cp	r1, r18
    4134:	13 06       	cpc	r1, r19
    4136:	e4 07       	cpc	r30, r20
    4138:	f5 07       	cpc	r31, r21
    413a:	98 f0       	brcs	.+38     	; 0x4162 <__fp_cmp+0x46>
    413c:	62 1b       	sub	r22, r18
    413e:	73 0b       	sbc	r23, r19
    4140:	84 0b       	sbc	r24, r20
    4142:	95 0b       	sbc	r25, r21
    4144:	39 f4       	brne	.+14     	; 0x4154 <__fp_cmp+0x38>
    4146:	0a 26       	eor	r0, r26
    4148:	61 f0       	breq	.+24     	; 0x4162 <__fp_cmp+0x46>
    414a:	23 2b       	or	r18, r19
    414c:	24 2b       	or	r18, r20
    414e:	25 2b       	or	r18, r21
    4150:	21 f4       	brne	.+8      	; 0x415a <__fp_cmp+0x3e>
    4152:	08 95       	ret
    4154:	0a 26       	eor	r0, r26
    4156:	09 f4       	brne	.+2      	; 0x415a <__fp_cmp+0x3e>
    4158:	a1 40       	sbci	r26, 0x01	; 1
    415a:	a6 95       	lsr	r26
    415c:	8f ef       	ldi	r24, 0xFF	; 255
    415e:	81 1d       	adc	r24, r1
    4160:	81 1d       	adc	r24, r1
    4162:	08 95       	ret

00004164 <__fp_inf>:
    4164:	97 f9       	bld	r25, 7
    4166:	9f 67       	ori	r25, 0x7F	; 127
    4168:	80 e8       	ldi	r24, 0x80	; 128
    416a:	70 e0       	ldi	r23, 0x00	; 0
    416c:	60 e0       	ldi	r22, 0x00	; 0
    416e:	08 95       	ret

00004170 <__fp_nan>:
    4170:	9f ef       	ldi	r25, 0xFF	; 255
    4172:	80 ec       	ldi	r24, 0xC0	; 192
    4174:	08 95       	ret

00004176 <__fp_pscA>:
    4176:	00 24       	eor	r0, r0
    4178:	0a 94       	dec	r0
    417a:	16 16       	cp	r1, r22
    417c:	17 06       	cpc	r1, r23
    417e:	18 06       	cpc	r1, r24
    4180:	09 06       	cpc	r0, r25
    4182:	08 95       	ret

00004184 <__fp_pscB>:
    4184:	00 24       	eor	r0, r0
    4186:	0a 94       	dec	r0
    4188:	12 16       	cp	r1, r18
    418a:	13 06       	cpc	r1, r19
    418c:	14 06       	cpc	r1, r20
    418e:	05 06       	cpc	r0, r21
    4190:	08 95       	ret

00004192 <__fp_round>:
    4192:	09 2e       	mov	r0, r25
    4194:	03 94       	inc	r0
    4196:	00 0c       	add	r0, r0
    4198:	11 f4       	brne	.+4      	; 0x419e <__fp_round+0xc>
    419a:	88 23       	and	r24, r24
    419c:	52 f0       	brmi	.+20     	; 0x41b2 <__fp_round+0x20>
    419e:	bb 0f       	add	r27, r27
    41a0:	40 f4       	brcc	.+16     	; 0x41b2 <__fp_round+0x20>
    41a2:	bf 2b       	or	r27, r31
    41a4:	11 f4       	brne	.+4      	; 0x41aa <__fp_round+0x18>
    41a6:	60 ff       	sbrs	r22, 0
    41a8:	04 c0       	rjmp	.+8      	; 0x41b2 <__fp_round+0x20>
    41aa:	6f 5f       	subi	r22, 0xFF	; 255
    41ac:	7f 4f       	sbci	r23, 0xFF	; 255
    41ae:	8f 4f       	sbci	r24, 0xFF	; 255
    41b0:	9f 4f       	sbci	r25, 0xFF	; 255
    41b2:	08 95       	ret

000041b4 <__fp_split3>:
    41b4:	57 fd       	sbrc	r21, 7
    41b6:	90 58       	subi	r25, 0x80	; 128
    41b8:	44 0f       	add	r20, r20
    41ba:	55 1f       	adc	r21, r21
    41bc:	59 f0       	breq	.+22     	; 0x41d4 <__fp_splitA+0x10>
    41be:	5f 3f       	cpi	r21, 0xFF	; 255
    41c0:	71 f0       	breq	.+28     	; 0x41de <__fp_splitA+0x1a>
    41c2:	47 95       	ror	r20

000041c4 <__fp_splitA>:
    41c4:	88 0f       	add	r24, r24
    41c6:	97 fb       	bst	r25, 7
    41c8:	99 1f       	adc	r25, r25
    41ca:	61 f0       	breq	.+24     	; 0x41e4 <__fp_splitA+0x20>
    41cc:	9f 3f       	cpi	r25, 0xFF	; 255
    41ce:	79 f0       	breq	.+30     	; 0x41ee <__fp_splitA+0x2a>
    41d0:	87 95       	ror	r24
    41d2:	08 95       	ret
    41d4:	12 16       	cp	r1, r18
    41d6:	13 06       	cpc	r1, r19
    41d8:	14 06       	cpc	r1, r20
    41da:	55 1f       	adc	r21, r21
    41dc:	f2 cf       	rjmp	.-28     	; 0x41c2 <__fp_split3+0xe>
    41de:	46 95       	lsr	r20
    41e0:	f1 df       	rcall	.-30     	; 0x41c4 <__fp_splitA>
    41e2:	08 c0       	rjmp	.+16     	; 0x41f4 <__fp_splitA+0x30>
    41e4:	16 16       	cp	r1, r22
    41e6:	17 06       	cpc	r1, r23
    41e8:	18 06       	cpc	r1, r24
    41ea:	99 1f       	adc	r25, r25
    41ec:	f1 cf       	rjmp	.-30     	; 0x41d0 <__fp_splitA+0xc>
    41ee:	86 95       	lsr	r24
    41f0:	71 05       	cpc	r23, r1
    41f2:	61 05       	cpc	r22, r1
    41f4:	08 94       	sec
    41f6:	08 95       	ret

000041f8 <__fp_zero>:
    41f8:	e8 94       	clt

000041fa <__fp_szero>:
    41fa:	bb 27       	eor	r27, r27
    41fc:	66 27       	eor	r22, r22
    41fe:	77 27       	eor	r23, r23
    4200:	cb 01       	movw	r24, r22
    4202:	97 f9       	bld	r25, 7
    4204:	08 95       	ret

00004206 <__gesf2>:
    4206:	0e 94 8e 20 	call	0x411c	; 0x411c <__fp_cmp>
    420a:	08 f4       	brcc	.+2      	; 0x420e <__gesf2+0x8>
    420c:	8f ef       	ldi	r24, 0xFF	; 255
    420e:	08 95       	ret

00004210 <__mulsf3>:
    4210:	0e 94 1b 21 	call	0x4236	; 0x4236 <__mulsf3x>
    4214:	0c 94 c9 20 	jmp	0x4192	; 0x4192 <__fp_round>
    4218:	0e 94 bb 20 	call	0x4176	; 0x4176 <__fp_pscA>
    421c:	38 f0       	brcs	.+14     	; 0x422c <__mulsf3+0x1c>
    421e:	0e 94 c2 20 	call	0x4184	; 0x4184 <__fp_pscB>
    4222:	20 f0       	brcs	.+8      	; 0x422c <__mulsf3+0x1c>
    4224:	95 23       	and	r25, r21
    4226:	11 f0       	breq	.+4      	; 0x422c <__mulsf3+0x1c>
    4228:	0c 94 b2 20 	jmp	0x4164	; 0x4164 <__fp_inf>
    422c:	0c 94 b8 20 	jmp	0x4170	; 0x4170 <__fp_nan>
    4230:	11 24       	eor	r1, r1
    4232:	0c 94 fd 20 	jmp	0x41fa	; 0x41fa <__fp_szero>

00004236 <__mulsf3x>:
    4236:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__fp_split3>
    423a:	70 f3       	brcs	.-36     	; 0x4218 <__mulsf3+0x8>

0000423c <__mulsf3_pse>:
    423c:	95 9f       	mul	r25, r21
    423e:	c1 f3       	breq	.-16     	; 0x4230 <__mulsf3+0x20>
    4240:	95 0f       	add	r25, r21
    4242:	50 e0       	ldi	r21, 0x00	; 0
    4244:	55 1f       	adc	r21, r21
    4246:	62 9f       	mul	r22, r18
    4248:	f0 01       	movw	r30, r0
    424a:	72 9f       	mul	r23, r18
    424c:	bb 27       	eor	r27, r27
    424e:	f0 0d       	add	r31, r0
    4250:	b1 1d       	adc	r27, r1
    4252:	63 9f       	mul	r22, r19
    4254:	aa 27       	eor	r26, r26
    4256:	f0 0d       	add	r31, r0
    4258:	b1 1d       	adc	r27, r1
    425a:	aa 1f       	adc	r26, r26
    425c:	64 9f       	mul	r22, r20
    425e:	66 27       	eor	r22, r22
    4260:	b0 0d       	add	r27, r0
    4262:	a1 1d       	adc	r26, r1
    4264:	66 1f       	adc	r22, r22
    4266:	82 9f       	mul	r24, r18
    4268:	22 27       	eor	r18, r18
    426a:	b0 0d       	add	r27, r0
    426c:	a1 1d       	adc	r26, r1
    426e:	62 1f       	adc	r22, r18
    4270:	73 9f       	mul	r23, r19
    4272:	b0 0d       	add	r27, r0
    4274:	a1 1d       	adc	r26, r1
    4276:	62 1f       	adc	r22, r18
    4278:	83 9f       	mul	r24, r19
    427a:	a0 0d       	add	r26, r0
    427c:	61 1d       	adc	r22, r1
    427e:	22 1f       	adc	r18, r18
    4280:	74 9f       	mul	r23, r20
    4282:	33 27       	eor	r19, r19
    4284:	a0 0d       	add	r26, r0
    4286:	61 1d       	adc	r22, r1
    4288:	23 1f       	adc	r18, r19
    428a:	84 9f       	mul	r24, r20
    428c:	60 0d       	add	r22, r0
    428e:	21 1d       	adc	r18, r1
    4290:	82 2f       	mov	r24, r18
    4292:	76 2f       	mov	r23, r22
    4294:	6a 2f       	mov	r22, r26
    4296:	11 24       	eor	r1, r1
    4298:	9f 57       	subi	r25, 0x7F	; 127
    429a:	50 40       	sbci	r21, 0x00	; 0
    429c:	9a f0       	brmi	.+38     	; 0x42c4 <__mulsf3_pse+0x88>
    429e:	f1 f0       	breq	.+60     	; 0x42dc <__mulsf3_pse+0xa0>
    42a0:	88 23       	and	r24, r24
    42a2:	4a f0       	brmi	.+18     	; 0x42b6 <__mulsf3_pse+0x7a>
    42a4:	ee 0f       	add	r30, r30
    42a6:	ff 1f       	adc	r31, r31
    42a8:	bb 1f       	adc	r27, r27
    42aa:	66 1f       	adc	r22, r22
    42ac:	77 1f       	adc	r23, r23
    42ae:	88 1f       	adc	r24, r24
    42b0:	91 50       	subi	r25, 0x01	; 1
    42b2:	50 40       	sbci	r21, 0x00	; 0
    42b4:	a9 f7       	brne	.-22     	; 0x42a0 <__mulsf3_pse+0x64>
    42b6:	9e 3f       	cpi	r25, 0xFE	; 254
    42b8:	51 05       	cpc	r21, r1
    42ba:	80 f0       	brcs	.+32     	; 0x42dc <__mulsf3_pse+0xa0>
    42bc:	0c 94 b2 20 	jmp	0x4164	; 0x4164 <__fp_inf>
    42c0:	0c 94 fd 20 	jmp	0x41fa	; 0x41fa <__fp_szero>
    42c4:	5f 3f       	cpi	r21, 0xFF	; 255
    42c6:	e4 f3       	brlt	.-8      	; 0x42c0 <__mulsf3_pse+0x84>
    42c8:	98 3e       	cpi	r25, 0xE8	; 232
    42ca:	d4 f3       	brlt	.-12     	; 0x42c0 <__mulsf3_pse+0x84>
    42cc:	86 95       	lsr	r24
    42ce:	77 95       	ror	r23
    42d0:	67 95       	ror	r22
    42d2:	b7 95       	ror	r27
    42d4:	f7 95       	ror	r31
    42d6:	e7 95       	ror	r30
    42d8:	9f 5f       	subi	r25, 0xFF	; 255
    42da:	c1 f7       	brne	.-16     	; 0x42cc <__mulsf3_pse+0x90>
    42dc:	fe 2b       	or	r31, r30
    42de:	88 0f       	add	r24, r24
    42e0:	91 1d       	adc	r25, r1
    42e2:	96 95       	lsr	r25
    42e4:	87 95       	ror	r24
    42e6:	97 f9       	bld	r25, 7
    42e8:	08 95       	ret

000042ea <__mulsi3>:
    42ea:	db 01       	movw	r26, r22
    42ec:	8f 93       	push	r24
    42ee:	9f 93       	push	r25
    42f0:	0e 94 d6 21 	call	0x43ac	; 0x43ac <__muluhisi3>
    42f4:	bf 91       	pop	r27
    42f6:	af 91       	pop	r26
    42f8:	a2 9f       	mul	r26, r18
    42fa:	80 0d       	add	r24, r0
    42fc:	91 1d       	adc	r25, r1
    42fe:	a3 9f       	mul	r26, r19
    4300:	90 0d       	add	r25, r0
    4302:	b2 9f       	mul	r27, r18
    4304:	90 0d       	add	r25, r0
    4306:	11 24       	eor	r1, r1
    4308:	08 95       	ret

0000430a <__udivmodsi4>:
    430a:	a1 e2       	ldi	r26, 0x21	; 33
    430c:	1a 2e       	mov	r1, r26
    430e:	aa 1b       	sub	r26, r26
    4310:	bb 1b       	sub	r27, r27
    4312:	fd 01       	movw	r30, r26
    4314:	0d c0       	rjmp	.+26     	; 0x4330 <__udivmodsi4_ep>

00004316 <__udivmodsi4_loop>:
    4316:	aa 1f       	adc	r26, r26
    4318:	bb 1f       	adc	r27, r27
    431a:	ee 1f       	adc	r30, r30
    431c:	ff 1f       	adc	r31, r31
    431e:	a2 17       	cp	r26, r18
    4320:	b3 07       	cpc	r27, r19
    4322:	e4 07       	cpc	r30, r20
    4324:	f5 07       	cpc	r31, r21
    4326:	20 f0       	brcs	.+8      	; 0x4330 <__udivmodsi4_ep>
    4328:	a2 1b       	sub	r26, r18
    432a:	b3 0b       	sbc	r27, r19
    432c:	e4 0b       	sbc	r30, r20
    432e:	f5 0b       	sbc	r31, r21

00004330 <__udivmodsi4_ep>:
    4330:	66 1f       	adc	r22, r22
    4332:	77 1f       	adc	r23, r23
    4334:	88 1f       	adc	r24, r24
    4336:	99 1f       	adc	r25, r25
    4338:	1a 94       	dec	r1
    433a:	69 f7       	brne	.-38     	; 0x4316 <__udivmodsi4_loop>
    433c:	60 95       	com	r22
    433e:	70 95       	com	r23
    4340:	80 95       	com	r24
    4342:	90 95       	com	r25
    4344:	9b 01       	movw	r18, r22
    4346:	ac 01       	movw	r20, r24
    4348:	bd 01       	movw	r22, r26
    434a:	cf 01       	movw	r24, r30
    434c:	08 95       	ret

0000434e <__divmodsi4>:
    434e:	05 2e       	mov	r0, r21
    4350:	97 fb       	bst	r25, 7
    4352:	1e f4       	brtc	.+6      	; 0x435a <__divmodsi4+0xc>
    4354:	00 94       	com	r0
    4356:	0e 94 be 21 	call	0x437c	; 0x437c <__negsi2>
    435a:	57 fd       	sbrc	r21, 7
    435c:	07 d0       	rcall	.+14     	; 0x436c <__divmodsi4_neg2>
    435e:	0e 94 85 21 	call	0x430a	; 0x430a <__udivmodsi4>
    4362:	07 fc       	sbrc	r0, 7
    4364:	03 d0       	rcall	.+6      	; 0x436c <__divmodsi4_neg2>
    4366:	4e f4       	brtc	.+18     	; 0x437a <__divmodsi4_exit>
    4368:	0c 94 be 21 	jmp	0x437c	; 0x437c <__negsi2>

0000436c <__divmodsi4_neg2>:
    436c:	50 95       	com	r21
    436e:	40 95       	com	r20
    4370:	30 95       	com	r19
    4372:	21 95       	neg	r18
    4374:	3f 4f       	sbci	r19, 0xFF	; 255
    4376:	4f 4f       	sbci	r20, 0xFF	; 255
    4378:	5f 4f       	sbci	r21, 0xFF	; 255

0000437a <__divmodsi4_exit>:
    437a:	08 95       	ret

0000437c <__negsi2>:
    437c:	90 95       	com	r25
    437e:	80 95       	com	r24
    4380:	70 95       	com	r23
    4382:	61 95       	neg	r22
    4384:	7f 4f       	sbci	r23, 0xFF	; 255
    4386:	8f 4f       	sbci	r24, 0xFF	; 255
    4388:	9f 4f       	sbci	r25, 0xFF	; 255
    438a:	08 95       	ret

0000438c <__tablejump2__>:
    438c:	ee 0f       	add	r30, r30
    438e:	ff 1f       	adc	r31, r31
    4390:	88 1f       	adc	r24, r24
    4392:	8b bf       	out	0x3b, r24	; 59
    4394:	07 90       	elpm	r0, Z+
    4396:	f6 91       	elpm	r31, Z
    4398:	e0 2d       	mov	r30, r0
    439a:	1b be       	out	0x3b, r1	; 59
    439c:	19 94       	eijmp

0000439e <__usmulhisi3>:
    439e:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <__umulhisi3>

000043a2 <__usmulhisi3_tail>:
    43a2:	b7 ff       	sbrs	r27, 7
    43a4:	08 95       	ret
    43a6:	82 1b       	sub	r24, r18
    43a8:	93 0b       	sbc	r25, r19
    43aa:	08 95       	ret

000043ac <__muluhisi3>:
    43ac:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <__umulhisi3>
    43b0:	a5 9f       	mul	r26, r21
    43b2:	90 0d       	add	r25, r0
    43b4:	b4 9f       	mul	r27, r20
    43b6:	90 0d       	add	r25, r0
    43b8:	a4 9f       	mul	r26, r20
    43ba:	80 0d       	add	r24, r0
    43bc:	91 1d       	adc	r25, r1
    43be:	11 24       	eor	r1, r1
    43c0:	08 95       	ret

000043c2 <__umulhisi3>:
    43c2:	a2 9f       	mul	r26, r18
    43c4:	b0 01       	movw	r22, r0
    43c6:	b3 9f       	mul	r27, r19
    43c8:	c0 01       	movw	r24, r0
    43ca:	a3 9f       	mul	r26, r19
    43cc:	70 0d       	add	r23, r0
    43ce:	81 1d       	adc	r24, r1
    43d0:	11 24       	eor	r1, r1
    43d2:	91 1d       	adc	r25, r1
    43d4:	b2 9f       	mul	r27, r18
    43d6:	70 0d       	add	r23, r0
    43d8:	81 1d       	adc	r24, r1
    43da:	11 24       	eor	r1, r1
    43dc:	91 1d       	adc	r25, r1
    43de:	08 95       	ret

000043e0 <memcpy>:
    43e0:	fb 01       	movw	r30, r22
    43e2:	dc 01       	movw	r26, r24
    43e4:	02 c0       	rjmp	.+4      	; 0x43ea <memcpy+0xa>
    43e6:	01 90       	ld	r0, Z+
    43e8:	0d 92       	st	X+, r0
    43ea:	41 50       	subi	r20, 0x01	; 1
    43ec:	50 40       	sbci	r21, 0x00	; 0
    43ee:	d8 f7       	brcc	.-10     	; 0x43e6 <memcpy+0x6>
    43f0:	08 95       	ret

000043f2 <memset>:
    43f2:	dc 01       	movw	r26, r24
    43f4:	01 c0       	rjmp	.+2      	; 0x43f8 <memset+0x6>
    43f6:	6d 93       	st	X+, r22
    43f8:	41 50       	subi	r20, 0x01	; 1
    43fa:	50 40       	sbci	r21, 0x00	; 0
    43fc:	e0 f7       	brcc	.-8      	; 0x43f6 <memset+0x4>
    43fe:	08 95       	ret

00004400 <strncpy>:
    4400:	fb 01       	movw	r30, r22
    4402:	dc 01       	movw	r26, r24
    4404:	41 50       	subi	r20, 0x01	; 1
    4406:	50 40       	sbci	r21, 0x00	; 0
    4408:	48 f0       	brcs	.+18     	; 0x441c <strncpy+0x1c>
    440a:	01 90       	ld	r0, Z+
    440c:	0d 92       	st	X+, r0
    440e:	00 20       	and	r0, r0
    4410:	c9 f7       	brne	.-14     	; 0x4404 <strncpy+0x4>
    4412:	01 c0       	rjmp	.+2      	; 0x4416 <strncpy+0x16>
    4414:	1d 92       	st	X+, r1
    4416:	41 50       	subi	r20, 0x01	; 1
    4418:	50 40       	sbci	r21, 0x00	; 0
    441a:	e0 f7       	brcc	.-8      	; 0x4414 <strncpy+0x14>
    441c:	08 95       	ret

0000441e <ultoa>:
    441e:	25 32       	cpi	r18, 0x25	; 37
    4420:	31 05       	cpc	r19, r1
    4422:	20 f4       	brcc	.+8      	; 0x442c <ultoa+0xe>
    4424:	22 30       	cpi	r18, 0x02	; 2
    4426:	10 f0       	brcs	.+4      	; 0x442c <ultoa+0xe>
    4428:	0c 94 1a 22 	jmp	0x4434	; 0x4434 <__ultoa_ncheck>
    442c:	fa 01       	movw	r30, r20
    442e:	10 82       	st	Z, r1
    4430:	ca 01       	movw	r24, r20
    4432:	08 95       	ret

00004434 <__ultoa_ncheck>:
    4434:	bb 27       	eor	r27, r27

00004436 <__ultoa_common>:
    4436:	fa 01       	movw	r30, r20
    4438:	a6 2f       	mov	r26, r22
    443a:	62 17       	cp	r22, r18
    443c:	71 05       	cpc	r23, r1
    443e:	81 05       	cpc	r24, r1
    4440:	91 05       	cpc	r25, r1
    4442:	33 0b       	sbc	r19, r19
    4444:	30 fb       	bst	r19, 0
    4446:	66 f0       	brts	.+24     	; 0x4460 <__ultoa_common+0x2a>
    4448:	aa 27       	eor	r26, r26
    444a:	66 0f       	add	r22, r22
    444c:	77 1f       	adc	r23, r23
    444e:	88 1f       	adc	r24, r24
    4450:	99 1f       	adc	r25, r25
    4452:	aa 1f       	adc	r26, r26
    4454:	a2 17       	cp	r26, r18
    4456:	10 f0       	brcs	.+4      	; 0x445c <__ultoa_common+0x26>
    4458:	a2 1b       	sub	r26, r18
    445a:	63 95       	inc	r22
    445c:	38 50       	subi	r19, 0x08	; 8
    445e:	a9 f7       	brne	.-22     	; 0x444a <__ultoa_common+0x14>
    4460:	a0 5d       	subi	r26, 0xD0	; 208
    4462:	aa 33       	cpi	r26, 0x3A	; 58
    4464:	08 f0       	brcs	.+2      	; 0x4468 <__ultoa_common+0x32>
    4466:	a9 5d       	subi	r26, 0xD9	; 217
    4468:	a1 93       	st	Z+, r26
    446a:	36 f7       	brtc	.-52     	; 0x4438 <__ultoa_common+0x2>
    446c:	b1 11       	cpse	r27, r1
    446e:	b1 93       	st	Z+, r27
    4470:	10 82       	st	Z, r1
    4472:	ca 01       	movw	r24, r20
    4474:	0c 94 61 22 	jmp	0x44c2	; 0x44c2 <strrev>

00004478 <utoa>:
    4478:	45 32       	cpi	r20, 0x25	; 37
    447a:	51 05       	cpc	r21, r1
    447c:	20 f4       	brcc	.+8      	; 0x4486 <utoa+0xe>
    447e:	42 30       	cpi	r20, 0x02	; 2
    4480:	10 f0       	brcs	.+4      	; 0x4486 <utoa+0xe>
    4482:	0c 94 47 22 	jmp	0x448e	; 0x448e <__utoa_ncheck>
    4486:	fb 01       	movw	r30, r22
    4488:	10 82       	st	Z, r1
    448a:	cb 01       	movw	r24, r22
    448c:	08 95       	ret

0000448e <__utoa_ncheck>:
    448e:	bb 27       	eor	r27, r27

00004490 <__utoa_common>:
    4490:	fb 01       	movw	r30, r22
    4492:	55 27       	eor	r21, r21
    4494:	aa 27       	eor	r26, r26
    4496:	88 0f       	add	r24, r24
    4498:	99 1f       	adc	r25, r25
    449a:	aa 1f       	adc	r26, r26
    449c:	a4 17       	cp	r26, r20
    449e:	10 f0       	brcs	.+4      	; 0x44a4 <__utoa_common+0x14>
    44a0:	a4 1b       	sub	r26, r20
    44a2:	83 95       	inc	r24
    44a4:	50 51       	subi	r21, 0x10	; 16
    44a6:	b9 f7       	brne	.-18     	; 0x4496 <__utoa_common+0x6>
    44a8:	a0 5d       	subi	r26, 0xD0	; 208
    44aa:	aa 33       	cpi	r26, 0x3A	; 58
    44ac:	08 f0       	brcs	.+2      	; 0x44b0 <__utoa_common+0x20>
    44ae:	a9 5d       	subi	r26, 0xD9	; 217
    44b0:	a1 93       	st	Z+, r26
    44b2:	00 97       	sbiw	r24, 0x00	; 0
    44b4:	79 f7       	brne	.-34     	; 0x4494 <__utoa_common+0x4>
    44b6:	b1 11       	cpse	r27, r1
    44b8:	b1 93       	st	Z+, r27
    44ba:	11 92       	st	Z+, r1
    44bc:	cb 01       	movw	r24, r22
    44be:	0c 94 61 22 	jmp	0x44c2	; 0x44c2 <strrev>

000044c2 <strrev>:
    44c2:	dc 01       	movw	r26, r24
    44c4:	fc 01       	movw	r30, r24
    44c6:	67 2f       	mov	r22, r23
    44c8:	71 91       	ld	r23, Z+
    44ca:	77 23       	and	r23, r23
    44cc:	e1 f7       	brne	.-8      	; 0x44c6 <strrev+0x4>
    44ce:	32 97       	sbiw	r30, 0x02	; 2
    44d0:	04 c0       	rjmp	.+8      	; 0x44da <strrev+0x18>
    44d2:	7c 91       	ld	r23, X
    44d4:	6d 93       	st	X+, r22
    44d6:	70 83       	st	Z, r23
    44d8:	62 91       	ld	r22, -Z
    44da:	ae 17       	cp	r26, r30
    44dc:	bf 07       	cpc	r27, r31
    44de:	c8 f3       	brcs	.-14     	; 0x44d2 <strrev+0x10>
    44e0:	08 95       	ret

000044e2 <_exit>:
    44e2:	f8 94       	cli

000044e4 <__stop_program>:
    44e4:	ff cf       	rjmp	.-2      	; 0x44e4 <__stop_program>
