
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000477a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  0000477a  0000480e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  008020bc  008020bc  000048ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000048ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000048fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c0  00000000  00000000  0000493c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012a42  00000000  00000000  00004ffc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000064d0  00000000  00000000  00017a3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005688  00000000  00000000  0001df0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001284  00000000  00000000  00023598  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000630d  00000000  00000000  0002481c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006126  00000000  00000000  0002ab29  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000578  00000000  00000000  00030c4f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 95 03 	jmp	0x72a	; 0x72a <__ctors_end>
       4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      10:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      14:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      18:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      1c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      20:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      24:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      28:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      2c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      30:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      34:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      38:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      3c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      40:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      44:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      48:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      4c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      50:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      54:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      58:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      5c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      60:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      64:	0c 94 86 1f 	jmp	0x3f0c	; 0x3f0c <__vector_25>
      68:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      6c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      70:	0c 94 e4 1f 	jmp	0x3fc8	; 0x3fc8 <__vector_28>
      74:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      78:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      7c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      80:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      84:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      88:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      8c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      90:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      94:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      98:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      9c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c4:	0c 94 77 0f 	jmp	0x1eee	; 0x1eee <__vector_49>
      c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e8:	0c 94 fe 20 	jmp	0x41fc	; 0x41fc <__vector_58>
      ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      fc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     100:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     104:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     108:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     10c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     110:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     114:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     118:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     11c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     120:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     124:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     128:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     12c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     130:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     134:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     138:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     13c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     140:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     144:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     148:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     14c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     150:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     154:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     158:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     15c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     160:	0c 94 42 20 	jmp	0x4084	; 0x4084 <__vector_88>
     164:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     168:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     16c:	0c 94 a0 20 	jmp	0x4140	; 0x4140 <__vector_91>
     170:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     174:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     178:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     17c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     180:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     184:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     188:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     18c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     190:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     194:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     198:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     19c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1fc:	be 0b       	sbc	r27, r30
     1fe:	36 0c       	add	r3, r6
     200:	36 0c       	add	r3, r6
     202:	36 0c       	add	r3, r6
     204:	36 0c       	add	r3, r6
     206:	36 0c       	add	r3, r6
     208:	36 0c       	add	r3, r6
     20a:	36 0c       	add	r3, r6
     20c:	36 0c       	add	r3, r6
     20e:	36 0c       	add	r3, r6
     210:	36 0c       	add	r3, r6
     212:	36 0c       	add	r3, r6
     214:	36 0c       	add	r3, r6
     216:	36 0c       	add	r3, r6
     218:	36 0c       	add	r3, r6
     21a:	36 0c       	add	r3, r6
     21c:	36 0c       	add	r3, r6
     21e:	36 0c       	add	r3, r6
     220:	36 0c       	add	r3, r6
     222:	36 0c       	add	r3, r6
     224:	36 0c       	add	r3, r6
     226:	36 0c       	add	r3, r6
     228:	36 0c       	add	r3, r6
     22a:	36 0c       	add	r3, r6
     22c:	36 0c       	add	r3, r6
     22e:	36 0c       	add	r3, r6
     230:	36 0c       	add	r3, r6
     232:	36 0c       	add	r3, r6
     234:	36 0c       	add	r3, r6
     236:	36 0c       	add	r3, r6
     238:	36 0c       	add	r3, r6
     23a:	36 0c       	add	r3, r6
     23c:	36 0c       	add	r3, r6
     23e:	36 0c       	add	r3, r6
     240:	36 0c       	add	r3, r6
     242:	36 0c       	add	r3, r6
     244:	36 0c       	add	r3, r6
     246:	36 0c       	add	r3, r6
     248:	36 0c       	add	r3, r6
     24a:	36 0c       	add	r3, r6
     24c:	36 0c       	add	r3, r6
     24e:	36 0c       	add	r3, r6
     250:	36 0c       	add	r3, r6
     252:	36 0c       	add	r3, r6
     254:	36 0c       	add	r3, r6
     256:	36 0c       	add	r3, r6
     258:	36 0c       	add	r3, r6
     25a:	36 0c       	add	r3, r6
     25c:	36 0c       	add	r3, r6
     25e:	36 0c       	add	r3, r6
     260:	36 0c       	add	r3, r6
     262:	36 0c       	add	r3, r6
     264:	36 0c       	add	r3, r6
     266:	36 0c       	add	r3, r6
     268:	36 0c       	add	r3, r6
     26a:	36 0c       	add	r3, r6
     26c:	36 0c       	add	r3, r6
     26e:	36 0c       	add	r3, r6
     270:	36 0c       	add	r3, r6
     272:	36 0c       	add	r3, r6
     274:	36 0c       	add	r3, r6
     276:	36 0c       	add	r3, r6
     278:	36 0c       	add	r3, r6
     27a:	36 0c       	add	r3, r6
     27c:	36 0c       	add	r3, r6
     27e:	36 0c       	add	r3, r6
     280:	36 0c       	add	r3, r6
     282:	36 0c       	add	r3, r6
     284:	36 0c       	add	r3, r6
     286:	36 0c       	add	r3, r6
     288:	36 0c       	add	r3, r6
     28a:	d2 0b       	sbc	r29, r18
     28c:	36 0c       	add	r3, r6
     28e:	04 0c       	add	r0, r4
     290:	be 0b       	sbc	r27, r30
     292:	36 0c       	add	r3, r6
     294:	ec 0b       	sbc	r30, r28
     296:	ba 0b       	sbc	r27, r26
     298:	36 0c       	add	r3, r6
     29a:	36 0c       	add	r3, r6
     29c:	36 0c       	add	r3, r6
     29e:	36 0c       	add	r3, r6
     2a0:	36 0c       	add	r3, r6
     2a2:	a0 0b       	sbc	r26, r16
     2a4:	36 0c       	add	r3, r6
     2a6:	36 0c       	add	r3, r6
     2a8:	36 0c       	add	r3, r6
     2aa:	1e 0c       	add	r1, r14
     2ac:	b2 0b       	sbc	r27, r18
     2ae:	36 0c       	add	r3, r6
     2b0:	36 0c       	add	r3, r6
     2b2:	ae 0b       	sbc	r26, r30
     2b4:	49 1d       	adc	r20, r9
     2b6:	4c 1d       	adc	r20, r12
     2b8:	4f 1d       	adc	r20, r15
     2ba:	52 1d       	adc	r21, r2
     2bc:	55 1d       	adc	r21, r5
     2be:	58 1d       	adc	r21, r8
     2c0:	5a 1d       	adc	r21, r10
     2c2:	6b 1d       	adc	r22, r11
     2c4:	73 1d       	adc	r23, r3
     2c6:	7d 1d       	adc	r23, r13
     2c8:	7b 1d       	adc	r23, r11

000002ca <__trampolines_start>:
     2ca:	0c 94 f1 1c 	jmp	0x39e2	; 0x39e2 <_ZN8emstream14check_for_charEv>
     2ce:	0c 94 5a 1d 	jmp	0x3ab4	; 0x3ab4 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2d2:	0c 94 b2 0b 	jmp	0x1764	; 0x1764 <_ZN9task_user3runEv+0x170>
     2d6:	0c 94 ba 0b 	jmp	0x1774	; 0x1774 <_ZN9task_user3runEv+0x180>
     2da:	0c 94 ee 1c 	jmp	0x39dc	; 0x39dc <_ZN8emstream7getcharEv>
     2de:	0c 94 55 1c 	jmp	0x38aa	; 0x38aa <__cxa_pure_virtual>
     2e2:	0c 94 36 0c 	jmp	0x186c	; 0x186c <_ZN9task_user3runEv+0x278>
     2e6:	0c 94 be 0b 	jmp	0x177c	; 0x177c <_ZN9task_user3runEv+0x188>
     2ea:	0c 94 73 1d 	jmp	0x3ae6	; 0x3ae6 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2ee:	0c 94 00 22 	jmp	0x4400	; 0x4400 <_GLOBAL__sub_I_counter>
     2f2:	0c 94 49 1d 	jmp	0x3a92	; 0x3a92 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2f6:	0c 94 58 1d 	jmp	0x3ab0	; 0x3ab0 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2fa:	0c 94 b4 04 	jmp	0x968	; 0x968 <_ZN13LimitSwitches3runEv>
     2fe:	0c 94 fb 11 	jmp	0x23f6	; 0x23f6 <prvIdleTask>
     302:	0c 94 4f 1d 	jmp	0x3a9e	; 0x3a9e <_ZN8emstreamlsE15ser_manipulator+0x2a>
     306:	0c 94 92 1a 	jmp	0x3524	; 0x3524 <_ZN14frt_text_queue14check_for_charEv>
     30a:	0c 94 2a 19 	jmp	0x3254	; 0x3254 <_ZN8frt_task12print_statusER8emstream>
     30e:	0c 94 1e 0c 	jmp	0x183c	; 0x183c <_ZN9task_user3runEv+0x248>
     312:	0c 94 9d 1a 	jmp	0x353a	; 0x353a <_ZN14frt_text_queue7putcharEc>
     316:	0c 94 a0 1e 	jmp	0x3d40	; 0x3d40 <_ZN5rs2327putcharEc>
     31a:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <_ZN15EncoderPendulum3runEv>
     31e:	0c 94 a0 0b 	jmp	0x1740	; 0x1740 <_ZN9task_user3runEv+0x14c>
     322:	0c 94 7b 1d 	jmp	0x3af6	; 0x3af6 <_ZN8emstreamlsE15ser_manipulator+0x82>
     326:	0c 94 ae 0b 	jmp	0x175c	; 0x175c <_ZN9task_user3runEv+0x168>
     32a:	0c 94 ea 1e 	jmp	0x3dd4	; 0x3dd4 <_ZN5rs23214check_for_charEv>
     32e:	0c 94 4c 1d 	jmp	0x3a98	; 0x3a98 <_ZN8emstreamlsE15ser_manipulator+0x24>
     332:	0c 94 fd 1e 	jmp	0x3dfa	; 0x3dfa <_ZN5rs23212clear_screenEv>
     336:	0c 94 f4 1c 	jmp	0x39e8	; 0x39e8 <_ZN8emstream12clear_screenEv>
     33a:	0c 94 d2 0b 	jmp	0x17a4	; 0x17a4 <_ZN9task_user3runEv+0x1b0>
     33e:	0c 94 fa 0a 	jmp	0x15f4	; 0x15f4 <_ZN9task_user3runEv>
     342:	0c 94 ec 0b 	jmp	0x17d8	; 0x17d8 <_ZN9task_user3runEv+0x1e4>
     346:	0c 94 74 1a 	jmp	0x34e8	; 0x34e8 <_ZN14frt_text_queue7getcharEv>
     34a:	0c 94 7d 1d 	jmp	0x3afa	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
     34e:	0c 94 cd 03 	jmp	0x79a	; 0x79a <_ZN12EncoderMotor3runEv>
     352:	0c 94 c4 1e 	jmp	0x3d88	; 0x3d88 <_ZN5rs2327getcharEv>
     356:	0c 94 55 1d 	jmp	0x3aaa	; 0x3aaa <_ZN8emstreamlsE15ser_manipulator+0x36>
     35a:	0c 94 52 1d 	jmp	0x3aa4	; 0x3aa4 <_ZN8emstreamlsE15ser_manipulator+0x30>
     35e:	0c 94 6b 1d 	jmp	0x3ad6	; 0x3ad6 <_ZN8emstreamlsE15ser_manipulator+0x62>
     362:	0c 94 ec 1c 	jmp	0x39d8	; 0x39d8 <_ZN8emstream13ready_to_sendEv>
     366:	0c 94 19 05 	jmp	0xa32	; 0xa32 <_ZN5Motor3runEv>
     36a:	0c 94 04 0c 	jmp	0x1808	; 0x1808 <_ZN9task_user3runEv+0x214>
     36e:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <_ZN8emstream12transmit_nowEv>
     372:	0c 94 92 03 	jmp	0x724	; 0x724 <_call_static_run_method>

00000376 <__trampolines_end>:
     376:	2c 20       	and	r2, r12
     378:	54 43       	sbci	r21, 0x34	; 52
     37a:	43 30       	cpi	r20, 0x03	; 3
     37c:	43 43       	sbci	r20, 0x33	; 51
     37e:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000381 <_ZZN9task_user11show_statusEvE3__c_3>:
     381:	2f 00                                               /.

00000383 <_ZZN9task_user11show_statusEvE3__c_2>:
     383:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000391 <_ZZN9task_user11show_statusEvE3__c_1>:
     391:	54 69 6d 65 3a 20 00                                Time: .

00000398 <_ZZN9task_user11show_statusEvE3__c_0>:
     398:	44 65 63 20 20 37 20 32 30 31 37 00                 Dec  7 2017.

000003a4 <_ZZN9task_user11show_statusEvE3__c>:
     3a4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3b4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003c3 <_ZZN9task_user18print_help_messageEvE3__c_14>:
     3c3:	20 20 20 20 72 3a 20 20 20 52 65 73 65 74 20 74         r:   Reset t
     3d3:	6f 20 49 64 6c 65 00                                o Idle.

000003da <_ZZN9task_user18print_help_messageEvE3__c_13>:
     3da:	20 20 20 20 64 3a 20 20 20 45 6d 65 72 67 65 6e         d:   Emergen
     3ea:	63 79 20 53 74 6f 70 00                             cy Stop.

000003f2 <_ZZN9task_user18print_help_messageEvE3__c_12>:
     3f2:	20 20 20 20 67 3a 20 20 20 53 77 69 6e 67 20 50         g:   Swing P
     402:	65 6e 64 75 6c 75 6d 20 55 70 72 69 67 68 74 2c     endulum Upright,
     412:	20 74 68 65 6e 20 47 6f 2e 00                        then Go..

0000041c <_ZZN9task_user18print_help_messageEvE3__c_11>:
     41c:	20 20 20 20 62 3a 20 20 20 42 65 67 69 6e 20 43         b:   Begin C
     42c:	61 6c 69 62 72 61 74 69 6f 6e 20 6f 66 20 49 6e     alibration of In
     43c:	76 65 72 74 65 64 20 50 65 6e 64 75 6c 75 6d 3f     verted Pendulum?
	...

0000044d <_ZZN9task_user18print_help_messageEvE3__c_10>:
     44d:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000045c <_ZZN9task_user18print_help_messageEvE3__c_9>:
     45c:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     46c:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000477 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     477:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     487:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000495 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     495:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     4a5:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     4b5:	6d 61 74 69 6f 6e 00                                mation.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_6>:
     4bc:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     4cc:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000004dd <_ZZN9task_user18print_help_messageEvE3__c_5>:
     4dd:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4ed:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004f5 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4f5:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     505:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000511 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     511:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     521:	68 65 20 41 56 52 00                                he AVR.

00000528 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     528:	20 68 65 6c 70 00                                    help.

0000052e <_ZZN9task_user18print_help_messageEvE3__c_1>:
     52e:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     53e:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000054d <_ZZN9task_user18print_help_messageEvE3__c_0>:
     54d:	1b 5b 33 30 6d 00                                   .[30m.

00000553 <_ZZN9task_user18print_help_messageEvE3__c>:
     553:	1b 5b 34 36 6d 00                                   .[46m.

00000559 <_ZZN9task_user3runEvE3__c_7>:
     559:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     569:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000576 <_ZZN9task_user3runEvE3__c_6>:
     576:	3a 57 54 46 3f 00                                   :WTF?.

0000057c <_ZZN9task_user3runEvE3__c_5>:
     57c:	52 65 73 65 74 2c 20 74 72 79 20 48 6f 6d 69 6e     Reset, try Homin
     58c:	67 20 61 67 61 69 6e 20 62 79 20 70 72 65 73 73     g again by press
     59c:	69 6e 67 20 27 62 27 00                             ing 'b'.

000005a4 <_ZZN9task_user3runEvE3__c_4>:
     5a4:	45 4d 45 52 47 45 4e 43 59 20 53 54 4f 50 00        EMERGENCY STOP.

000005b3 <_ZZN9task_user3runEvE3__c_3>:
     5b3:	43 6f 6d 6d 65 6e 63 65 20 42 61 6c 61 6e 63 65     Commence Balance
	...

000005c4 <_ZZN9task_user3runEvE3__c_2>:
     5c4:	42 65 67 69 6e 20 48 6f 6d 69 6e 67 00              Begin Homing.

000005d1 <_ZZN9task_user3runEvE3__c_1>:
     5d1:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     5e1:	65 00                                               e.

000005e3 <_ZZN9task_user3runEvE3__c_0>:
     5e3:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000005f1 <_ZZN9task_user3runEvE3__c>:
     5f1:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 74 6f 20     Press Ctrl-A to 
     601:	67 65 74 20 74 6f 20 63 6f 6d 6d 61 6e 64 20 6d     get to command m
     611:	6f 64 65 20 66 6f 72 20 49 6e 76 65 72 74 65 64     ode for Inverted
     621:	20 50 65 6e 64 75 6c 75 6d 00                        Pendulum.

0000062b <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     62b:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000635 <_ZZN8frt_task15emergency_resetEvE3__c>:
     635:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000644 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     644:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     654:	61 73 6b 20 00                                      ask .

00000659 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     659:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000667 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     667:	20 63 72 65 61 74 65 64 00                           created.

00000670 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     670:	54 61 73 6b 20 00                                   Task .

00000676 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     676:	1b 5b 32 32 6d 00                                   .[22m.

0000067c <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     67c:	54 61 73 6b 3a 20 00                                Task: .

00000683 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     683:	1b 5b 31 6d 00                                      .[1m.

00000688 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     688:	1b 5b 32 32 6d 00                                   .[22m.

0000068e <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     68e:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000699 <_ZZ17print_task_stacksP8emstreamE3__c>:
     699:	1b 5b 31 6d 00                                      .[1m.

0000069e <_ZZ15print_task_listP8emstreamE3__c_9>:
     69e:	09 09 00                                            ...

000006a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     6a1:	2f 00                                               /.

000006a3 <_ZZ15print_task_listP8emstreamE3__c_7>:
     6a3:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000006ae <_ZZ15print_task_listP8emstreamE3__c_6>:
     6ae:	09 2d 2d 2d 2d 00                                   .----.

000006b4 <_ZZ15print_task_listP8emstreamE3__c_5>:
     6b4:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000006c0 <_ZZ15print_task_listP8emstreamE3__c_4>:
     6c0:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000006d1 <_ZZ15print_task_listP8emstreamE3__c_3>:
     6d1:	09 52 75 6e 73 00                                   .Runs.

000006d7 <_ZZ15print_task_listP8emstreamE3__c_2>:
     6d7:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000006e3 <_ZZ15print_task_listP8emstreamE3__c_1>:
     6e3:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000006f4 <_ZZ15print_task_listP8emstreamE3__c_0>:
     6f4:	09 53 74 61 63 6b 00                                .Stack.

000006fb <_ZZ15print_task_listP8emstreamE3__c>:
     6fb:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000706 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     706:	09 00                                               ..

00000708 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     708:	09 00                                               ..

0000070a <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     70a:	2f 00                                               /.

0000070c <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     70c:	09 00                                               ..

0000070e <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     70e:	09 00                                               ..

00000710 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     710:	1b 5b 32 32 6d 00                                   .[22m.

00000716 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     716:	1b 5b 31 6d 00                                      .[1m.

0000071b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     71b:	1b 5b 31 6d 00                                      .[1m.

00000720 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     720:	20 20 00 00                                           ..

00000724 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     724:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <_ZN8frt_task22_call_users_run_methodEPS_>

00000728 <__ctors_start>:
     728:	00 22       	and	r0, r16

0000072a <__ctors_end>:
     72a:	11 24       	eor	r1, r1
     72c:	1f be       	out	0x3f, r1	; 63
     72e:	cf ef       	ldi	r28, 0xFF	; 255
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df e3       	ldi	r29, 0x3F	; 63
     734:	de bf       	out	0x3e, r29	; 62
     736:	00 e0       	ldi	r16, 0x00	; 0
     738:	0c bf       	out	0x3c, r16	; 60
     73a:	18 be       	out	0x38, r1	; 56
     73c:	19 be       	out	0x39, r1	; 57
     73e:	1a be       	out	0x3a, r1	; 58
     740:	1b be       	out	0x3b, r1	; 59

00000742 <__do_copy_data>:
     742:	10 e2       	ldi	r17, 0x20	; 32
     744:	a0 e0       	ldi	r26, 0x00	; 0
     746:	b0 e2       	ldi	r27, 0x20	; 32
     748:	ea e7       	ldi	r30, 0x7A	; 122
     74a:	f7 e4       	ldi	r31, 0x47	; 71
     74c:	00 e0       	ldi	r16, 0x00	; 0
     74e:	0b bf       	out	0x3b, r16	; 59
     750:	02 c0       	rjmp	.+4      	; 0x756 <__do_copy_data+0x14>
     752:	07 90       	elpm	r0, Z+
     754:	0d 92       	st	X+, r0
     756:	ac 3b       	cpi	r26, 0xBC	; 188
     758:	b1 07       	cpc	r27, r17
     75a:	d9 f7       	brne	.-10     	; 0x752 <__do_copy_data+0x10>
     75c:	1b be       	out	0x3b, r1	; 59

0000075e <__do_clear_bss>:
     75e:	21 e3       	ldi	r18, 0x31	; 49
     760:	ac eb       	ldi	r26, 0xBC	; 188
     762:	b0 e2       	ldi	r27, 0x20	; 32
     764:	01 c0       	rjmp	.+2      	; 0x768 <.do_clear_bss_start>

00000766 <.do_clear_bss_loop>:
     766:	1d 92       	st	X+, r1

00000768 <.do_clear_bss_start>:
     768:	a6 36       	cpi	r26, 0x66	; 102
     76a:	b2 07       	cpc	r27, r18
     76c:	e1 f7       	brne	.-8      	; 0x766 <.do_clear_bss_loop>

0000076e <__do_global_ctors>:
     76e:	13 e0       	ldi	r17, 0x03	; 3
     770:	c5 e9       	ldi	r28, 0x95	; 149
     772:	d3 e0       	ldi	r29, 0x03	; 3
     774:	00 e0       	ldi	r16, 0x00	; 0
     776:	06 c0       	rjmp	.+12     	; 0x784 <__do_global_ctors+0x16>
     778:	21 97       	sbiw	r28, 0x01	; 1
     77a:	01 09       	sbc	r16, r1
     77c:	80 2f       	mov	r24, r16
     77e:	fe 01       	movw	r30, r28
     780:	0e 94 e1 22 	call	0x45c2	; 0x45c2 <__tablejump2__>
     784:	c4 39       	cpi	r28, 0x94	; 148
     786:	d1 07       	cpc	r29, r17
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	08 07       	cpc	r16, r24
     78c:	a9 f7       	brne	.-22     	; 0x778 <__do_global_ctors+0xa>
     78e:	0e 94 71 21 	call	0x42e2	; 0x42e2 <main>
     792:	0c 94 bb 23 	jmp	0x4776	; 0x4776 <_exit>

00000796 <__bad_interrupt>:
     796:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000079a <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <_ZN12EncoderMotor3runEv+0x6>
     7a0:	1f 92       	push	r1
     7a2:	cd b7       	in	r28, 0x3d	; 61
     7a4:	de b7       	in	r29, 0x3e	; 62
     7a6:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7a8:	0e 94 9a 13 	call	0x2734	; 0x2734 <xTaskGetTickCount>
     7ac:	69 83       	std	Y+1, r22	; 0x01
     7ae:	7a 83       	std	Y+2, r23	; 0x02
     7b0:	8b 83       	std	Y+3, r24	; 0x03
     7b2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     7b4:	e0 e8       	ldi	r30, 0x80	; 128
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	8c e0       	ldi	r24, 0x0C	; 12
     7ba:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     7bc:	82 89       	ldd	r24, Z+18	; 0x12
     7be:	83 60       	ori	r24, 0x03	; 3
     7c0:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     7c2:	83 89       	ldd	r24, Z+19	; 0x13
     7c4:	83 60       	ori	r24, 0x03	; 3
     7c6:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     7c8:	e0 e8       	ldi	r30, 0x80	; 128
     7ca:	f1 e0       	ldi	r31, 0x01	; 1
     7cc:	82 e7       	ldi	r24, 0x72	; 114
     7ce:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     7d0:	89 e0       	ldi	r24, 0x09	; 9
     7d2:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     7d4:	e0 e0       	ldi	r30, 0x00	; 0
     7d6:	f9 e0       	ldi	r31, 0x09	; 9
     7d8:	88 e6       	ldi	r24, 0x68	; 104
     7da:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	9f ef       	ldi	r25, 0xFF	; 255
     7e0:	86 a3       	std	Z+38, r24	; 0x26
     7e2:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     7e8:	0f 2e       	mov	r0, r31
     7ea:	a1 2c       	mov	r10, r1
     7ec:	f9 e0       	ldi	r31, 0x09	; 9
     7ee:	bf 2e       	mov	r11, r31
     7f0:	f0 2d       	mov	r31, r0
     7f2:	f5 01       	movw	r30, r10
     7f4:	00 a1       	ldd	r16, Z+32	; 0x20
     7f6:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     7f8:	0f b6       	in	r0, 0x3f	; 63
     7fa:	f8 94       	cli
     7fc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	0f 92       	push	r0
			the_data = new_data;
     808:	c8 01       	movw	r24, r16
     80a:	01 2e       	mov	r0, r17
     80c:	00 0c       	add	r0, r0
     80e:	aa 0b       	sbc	r26, r26
     810:	bb 0b       	sbc	r27, r27
     812:	ac 01       	movw	r20, r24
     814:	bd 01       	movw	r22, r26
     816:	44 0f       	add	r20, r20
     818:	55 1f       	adc	r21, r21
     81a:	66 1f       	adc	r22, r22
     81c:	77 1f       	adc	r23, r23
     81e:	3a 01       	movw	r6, r20
     820:	4b 01       	movw	r8, r22
     822:	68 0e       	add	r6, r24
     824:	79 1e       	adc	r7, r25
     826:	8a 1e       	adc	r8, r26
     828:	9b 1e       	adc	r9, r27
     82a:	c4 01       	movw	r24, r8
     82c:	b3 01       	movw	r22, r6
     82e:	24 e6       	ldi	r18, 0x64	; 100
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	0e 94 c2 22 	call	0x4584	; 0x4584 <__divmodsi4>
     83a:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <linear_offset>
     83e:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <linear_offset+0x1>
     842:	28 1b       	sub	r18, r24
     844:	39 0b       	sbc	r19, r25
     846:	20 93 52 31 	sts	0x3152, r18	; 0x803152 <linear_position>
     84a:	30 93 53 31 	sts	0x3153, r19	; 0x803153 <linear_position+0x1>
			portEXIT_CRITICAL ();
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
			the_data = new_data;
     858:	c8 01       	movw	r24, r16
     85a:	8c 19       	sub	r24, r12
     85c:	9d 09       	sbc	r25, r13
     85e:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <thdMotor>
     862:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     86a:	f7 01       	movw	r30, r14
     86c:	86 85       	ldd	r24, Z+14	; 0x0e
     86e:	97 85       	ldd	r25, Z+15	; 0x0f
     870:	a0 89       	ldd	r26, Z+16	; 0x10
     872:	b1 89       	ldd	r27, Z+17	; 0x11
     874:	01 96       	adiw	r24, 0x01	; 1
     876:	a1 1d       	adc	r26, r1
     878:	b1 1d       	adc	r27, r1
     87a:	86 87       	std	Z+14, r24	; 0x0e
     87c:	97 87       	std	Z+15, r25	; 0x0f
     87e:	a0 8b       	std	Z+16, r26	; 0x10
     880:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     882:	41 e0       	ldi	r20, 0x01	; 1
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	ce 01       	movw	r24, r28
     88c:	01 96       	adiw	r24, 0x01	; 1
     88e:	0e 94 38 15 	call	0x2a70	; 0x2a70 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     892:	68 01       	movw	r12, r16
     894:	ae cf       	rjmp	.-164    	; 0x7f2 <_ZN12EncoderMotor3runEv+0x58>

00000896 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a0:	0e 94 d5 17 	call	0x2faa	; 0x2faa <_ZN8frt_taskC1EPKchjP8emstream>
     8a4:	8a e0       	ldi	r24, 0x0A	; 10
     8a6:	90 e2       	ldi	r25, 0x20	; 32
     8a8:	88 83       	st	Y, r24
     8aa:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN15EncoderPendulum3runEv+0x6>
     8bc:	1f 92       	push	r1
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 9a 13 	call	0x2734	; 0x2734 <xTaskGetTickCount>
     8c8:	69 83       	std	Y+1, r22	; 0x01
     8ca:	7a 83       	std	Y+2, r23	; 0x02
     8cc:	8b 83       	std	Y+3, r24	; 0x03
     8ce:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     8d0:	e0 e8       	ldi	r30, 0x80	; 128
     8d2:	f6 e0       	ldi	r31, 0x06	; 6
     8d4:	83 e0       	ldi	r24, 0x03	; 3
     8d6:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     8d8:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     8da:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     8dc:	e0 e8       	ldi	r30, 0x80	; 128
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	80 e7       	ldi	r24, 0x70	; 112
     8e2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     8e4:	89 e0       	ldi	r24, 0x09	; 9
     8e6:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     8e8:	e0 e4       	ldi	r30, 0x40	; 64
     8ea:	f8 e0       	ldi	r31, 0x08	; 8
     8ec:	8a e6       	ldi	r24, 0x6A	; 106
     8ee:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     8f0:	80 ea       	ldi	r24, 0xA0	; 160
     8f2:	95 e0       	ldi	r25, 0x05	; 5
     8f4:	86 a3       	std	Z+38, r24	; 0x26
     8f6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     8fc:	68 94       	set
     8fe:	ee 24       	eor	r14, r14
     900:	e6 f8       	bld	r14, 6
     902:	ff 24       	eor	r15, r15
     904:	f3 f8       	bld	r15, 3
     906:	f7 01       	movw	r30, r14
     908:	80 a1       	ldd	r24, Z+32	; 0x20
     90a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
			the_data = new_data;
     912:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <thPendulum>
     916:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <thPendulum+0x1>
			portEXIT_CRITICAL ();
     91a:	0f 90       	pop	r0
     91c:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     91e:	f8 01       	movw	r30, r16
     920:	86 85       	ldd	r24, Z+14	; 0x0e
     922:	97 85       	ldd	r25, Z+15	; 0x0f
     924:	a0 89       	ldd	r26, Z+16	; 0x10
     926:	b1 89       	ldd	r27, Z+17	; 0x11
     928:	01 96       	adiw	r24, 0x01	; 1
     92a:	a1 1d       	adc	r26, r1
     92c:	b1 1d       	adc	r27, r1
     92e:	86 87       	std	Z+14, r24	; 0x0e
     930:	97 87       	std	Z+15, r25	; 0x0f
     932:	a0 8b       	std	Z+16, r26	; 0x10
     934:	b1 8b       	std	Z+17, r27	; 0x11
     936:	41 e0       	ldi	r20, 0x01	; 1
     938:	50 e0       	ldi	r21, 0x00	; 0
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	70 e0       	ldi	r23, 0x00	; 0
     93e:	ce 01       	movw	r24, r28
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	0e 94 38 15 	call	0x2a70	; 0x2a70 <vTaskDelayUntil>
     946:	df cf       	rjmp	.-66     	; 0x906 <_ZN15EncoderPendulum3runEv+0x50>

00000948 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     952:	0e 94 d5 17 	call	0x2faa	; 0x2faa <_ZN8frt_taskC1EPKchjP8emstream>
     956:	82 e1       	ldi	r24, 0x12	; 18
     958:	90 e2       	ldi	r25, 0x20	; 32
     95a:	88 83       	st	Y, r24
     95c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	08 95       	ret

00000968 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	00 d0       	rcall	.+0      	; 0x96e <_ZN13LimitSwitches3runEv+0x6>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     976:	0e 94 9a 13 	call	0x2734	; 0x2734 <xTaskGetTickCount>
     97a:	69 83       	std	Y+1, r22	; 0x01
     97c:	7a 83       	std	Y+2, r23	; 0x02
     97e:	8b 83       	std	Y+3, r24	; 0x03
     980:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     982:	e0 e6       	ldi	r30, 0x60	; 96
     984:	f6 e0       	ldi	r31, 0x06	; 6
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     98a:	84 e0       	ldi	r24, 0x04	; 4
     98c:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     98e:	88 e1       	ldi	r24, 0x18	; 24
     990:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     992:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     994:	08 e6       	ldi	r16, 0x68	; 104
     996:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     998:	dd 24       	eor	r13, r13
     99a:	d3 94       	inc	r13
     99c:	f8 01       	movw	r30, r16
     99e:	80 81       	ld	r24, Z
     9a0:	80 fd       	sbrc	r24, 0
     9a2:	08 c0       	rjmp	.+16     	; 0x9b4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
			the_data = new_data;
     9aa:	d0 92 4d 31 	sts	0x314D, r13	; 0x80314d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9ae:	0f 90       	pop	r0
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	07 c0       	rjmp	.+14     	; 0x9c2 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	0f 92       	push	r0
			the_data = new_data;
     9ba:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     9c2:	f8 01       	movw	r30, r16
     9c4:	80 81       	ld	r24, Z
     9c6:	82 fd       	sbrc	r24, 2
     9c8:	08 c0       	rjmp	.+16     	; 0x9da <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
			the_data = new_data;
     9d0:	d0 92 4c 31 	sts	0x314C, r13	; 0x80314c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	f8 94       	cli
     9de:	0f 92       	push	r0
			the_data = new_data;
     9e0:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     9e8:	f7 01       	movw	r30, r14
     9ea:	86 85       	ldd	r24, Z+14	; 0x0e
     9ec:	97 85       	ldd	r25, Z+15	; 0x0f
     9ee:	a0 89       	ldd	r26, Z+16	; 0x10
     9f0:	b1 89       	ldd	r27, Z+17	; 0x11
     9f2:	01 96       	adiw	r24, 0x01	; 1
     9f4:	a1 1d       	adc	r26, r1
     9f6:	b1 1d       	adc	r27, r1
     9f8:	86 87       	std	Z+14, r24	; 0x0e
     9fa:	97 87       	std	Z+15, r25	; 0x0f
     9fc:	a0 8b       	std	Z+16, r26	; 0x10
     9fe:	b1 8b       	std	Z+17, r27	; 0x11
     a00:	41 e0       	ldi	r20, 0x01	; 1
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	01 96       	adiw	r24, 0x01	; 1
     a0c:	0e 94 38 15 	call	0x2a70	; 0x2a70 <vTaskDelayUntil>
     a10:	c5 cf       	rjmp	.-118    	; 0x99c <_ZN13LimitSwitches3runEv+0x34>

00000a12 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a1c:	0e 94 d5 17 	call	0x2faa	; 0x2faa <_ZN8frt_taskC1EPKchjP8emstream>
     a20:	8a e1       	ldi	r24, 0x1A	; 26
     a22:	90 e2       	ldi	r25, 0x20	; 32
     a24:	88 83       	st	Y, r24
     a26:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	08 95       	ret

00000a32 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	6a 97       	sbiw	r28, 0x1a	; 26
     a3c:	cd bf       	out	0x3d, r28	; 61
     a3e:	de bf       	out	0x3e, r29	; 62
     a40:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     a42:	0e 94 9a 13 	call	0x2734	; 0x2734 <xTaskGetTickCount>
     a46:	69 83       	std	Y+1, r22	; 0x01
     a48:	7a 83       	std	Y+2, r23	; 0x02
     a4a:	8b 83       	std	Y+3, r24	; 0x03
     a4c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     a4e:	f8 01       	movw	r30, r16
     a50:	fe 96       	adiw	r30, 0x3e	; 62
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	a0 e0       	ldi	r26, 0x00	; 0
     a58:	b0 e0       	ldi	r27, 0x00	; 0
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
     a5e:	a2 83       	std	Z+2, r26	; 0x02
     a60:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     a62:	d8 01       	movw	r26, r16
     a64:	dc 96       	adiw	r26, 0x3c	; 60
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     a6c:	a0 e4       	ldi	r26, 0x40	; 64
     a6e:	b6 e0       	ldi	r27, 0x06	; 6
     a70:	87 e0       	ldi	r24, 0x07	; 7
     a72:	11 96       	adiw	r26, 0x01	; 1
     a74:	8c 93       	st	X, r24
     a76:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     a78:	84 e0       	ldi	r24, 0x04	; 4
     a7a:	15 96       	adiw	r26, 0x05	; 5
     a7c:	8c 93       	st	X, r24
     a7e:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     a80:	e0 e0       	ldi	r30, 0x00	; 0
     a82:	f8 e0       	ldi	r31, 0x08	; 8
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     a88:	83 e0       	ldi	r24, 0x03	; 3
     a8a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     a8c:	a6 a3       	std	Z+38, r26	; 0x26
     a8e:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     a90:	10 a6       	std	Z+40, r1	; 0x28
     a92:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     a94:	12 a6       	std	Z+42, r1	; 0x2a
     a96:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     a98:	81 81       	ldd	r24, Z+1	; 0x01
     a9a:	80 63       	ori	r24, 0x30	; 48
     a9c:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	0f 92       	push	r0
			the_data = new_data;
     aa4:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <linear_offset>
     aa8:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     aac:	0f 90       	pop	r0
     aae:	0f be       	out	0x3f, r0	; 63
	linear_offset.put(0);								// Initialize motor offset	
	int16_t left_home;									// Initialize left distance to calculate center
	int16_t position_set;								// Setpoint of cart's position
	int16_t KP_pos = 0.4*256;							// P gain for cart position				
	int16_t position_error = 0;							// positional error	
	int16_t position_midpoint = 0;						// midpoint calculated from homing sequence
     ab0:	1d 8a       	std	Y+21, r1	; 0x15
     ab2:	1e 8a       	std	Y+22, r1	; 0x16
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(500);
				_integral = 0;
     ab4:	58 01       	movw	r10, r16
     ab6:	b0 e5       	ldi	r27, 0x50	; 80
     ab8:	ab 0e       	add	r10, r27
     aba:	b1 1c       	adc	r11, r1
			case(4) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
     abc:	f8 01       	movw	r30, r16
     abe:	fe 96       	adiw	r30, 0x3e	; 62
     ac0:	ed 83       	std	Y+5, r30	; 0x05
     ac2:	fe 83       	std	Y+6, r31	; 0x06
				_pre_angle_error = angle_error;
				angle_Dout = (_Kd_angle * angle_derivative)/256;

				output_correct = output;
     ac4:	68 01       	movw	r12, r16
     ac6:	fe e5       	ldi	r31, 0x5E	; 94
     ac8:	cf 0e       	add	r12, r31
     aca:	d1 1c       	adc	r13, r1
     acc:	98 01       	movw	r18, r16
     ace:	20 5a       	subi	r18, 0xA0	; 160
     ad0:	3f 4f       	sbci	r19, 0xFF	; 255
     ad2:	2f 87       	std	Y+15, r18	; 0x0f
     ad4:	38 8b       	std	Y+16, r19	; 0x10
				linear_offset.put(0);										// re initialize
				if (begin.get())											// If user begins Calibration Sequence
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     ad6:	0f 2e       	mov	r0, r31
     ad8:	fa e0       	ldi	r31, 0x0A	; 10
     ada:	2f 2e       	mov	r2, r31
     adc:	31 2c       	mov	r3, r1
     ade:	f0 2d       	mov	r31, r0
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     ae0:	c8 01       	movw	r24, r16
     ae2:	88 5b       	subi	r24, 0xB8	; 184
     ae4:	9f 4f       	sbci	r25, 0xFF	; 255
     ae6:	89 8b       	std	Y+17, r24	; 0x11
     ae8:	9a 8b       	std	Y+18, r25	; 0x12
		_Ki = .7*256;
     aea:	d8 01       	movw	r26, r16
     aec:	a4 5b       	subi	r26, 0xB4	; 180
     aee:	bf 4f       	sbci	r27, 0xFF	; 255
     af0:	af 83       	std	Y+7, r26	; 0x07
     af2:	b8 87       	std	Y+8, r27	; 0x08
		_Kd = 0;
     af4:	f8 01       	movw	r30, r16
     af6:	e6 5b       	subi	r30, 0xB6	; 182
     af8:	ff 4f       	sbci	r31, 0xFF	; 255
     afa:	eb 8b       	std	Y+19, r30	; 0x13
     afc:	fc 8b       	std	Y+20, r31	; 0x14
		antiwind_gain = .75*256;
     afe:	2c 5f       	subi	r18, 0xFC	; 252
     b00:	3f 4f       	sbci	r19, 0xFF	; 255
     b02:	29 87       	std	Y+9, r18	; 0x09
     b04:	3a 87       	std	Y+10, r19	; 0x0a
		
		_max = 1600;
     b06:	04 97       	sbiw	r24, 0x04	; 4
     b08:	8b 87       	std	Y+11, r24	; 0x0b
     b0a:	9c 87       	std	Y+12, r25	; 0x0c
		_min = -1600;
     b0c:	16 97       	sbiw	r26, 0x06	; 6
     b0e:	ad 87       	std	Y+13, r26	; 0x0d
     b10:	be 87       	std	Y+14, r27	; 0x0e
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
     b12:	48 01       	movw	r8, r16
     b14:	b6 e6       	ldi	r27, 0x66	; 102
     b16:	8b 0e       	add	r8, r27
     b18:	91 1c       	adc	r9, r1
	int16_t omegam_saturation_point;
	int16_t K_position_antiwind = 0*256;				// position anti windup gain
	
	while(1){
		// Increment counter for debugging
		runs++;
     b1a:	f8 01       	movw	r30, r16
     b1c:	46 85       	ldd	r20, Z+14	; 0x0e
     b1e:	57 85       	ldd	r21, Z+15	; 0x0f
     b20:	60 89       	ldd	r22, Z+16	; 0x10
     b22:	71 89       	ldd	r23, Z+17	; 0x11
     b24:	4f 5f       	subi	r20, 0xFF	; 255
     b26:	5f 4f       	sbci	r21, 0xFF	; 255
     b28:	6f 4f       	sbci	r22, 0xFF	; 255
     b2a:	7f 4f       	sbci	r23, 0xFF	; 255
     b2c:	46 87       	std	Z+14, r20	; 0x0e
     b2e:	57 87       	std	Z+15, r21	; 0x0f
     b30:	60 8b       	std	Z+16, r22	; 0x10
     b32:	71 8b       	std	Z+17, r23	; 0x11
		
		switch (state)
     b34:	84 85       	ldd	r24, Z+12	; 0x0c
     b36:	82 30       	cpi	r24, 0x02	; 2
     b38:	09 f4       	brne	.+2      	; 0xb3c <_ZN5Motor3runEv+0x10a>
     b3a:	99 c0       	rjmp	.+306    	; 0xc6e <_ZN5Motor3runEv+0x23c>
     b3c:	30 f4       	brcc	.+12     	; 0xb4a <_ZN5Motor3runEv+0x118>
     b3e:	88 23       	and	r24, r24
     b40:	69 f0       	breq	.+26     	; 0xb5c <_ZN5Motor3runEv+0x12a>
     b42:	81 30       	cpi	r24, 0x01	; 1
     b44:	09 f4       	brne	.+2      	; 0xb48 <_ZN5Motor3runEv+0x116>
     b46:	58 c0       	rjmp	.+176    	; 0xbf8 <_ZN5Motor3runEv+0x1c6>
     b48:	cc c1       	rjmp	.+920    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
     b4a:	84 30       	cpi	r24, 0x04	; 4
     b4c:	09 f4       	brne	.+2      	; 0xb50 <_ZN5Motor3runEv+0x11e>
     b4e:	08 c1       	rjmp	.+528    	; 0xd60 <_ZN5Motor3runEv+0x32e>
     b50:	08 f4       	brcc	.+2      	; 0xb54 <_ZN5Motor3runEv+0x122>
     b52:	a1 c0       	rjmp	.+322    	; 0xc96 <_ZN5Motor3runEv+0x264>
     b54:	84 36       	cpi	r24, 0x64	; 100
     b56:	09 f4       	brne	.+2      	; 0xb5a <_ZN5Motor3runEv+0x128>
     b58:	90 c1       	rjmp	.+800    	; 0xe7a <_ZN5Motor3runEv+0x448>
     b5a:	c3 c1       	rjmp	.+902    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	0f 92       	push	r0
			the_data = new_data;
     b62:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <linear_offset>
     b66:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     b6a:	0f 90       	pop	r0
     b6c:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b6e:	0f b6       	in	r0, 0x3f	; 63
     b70:	f8 94       	cli
     b72:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b74:	0f 90       	pop	r0
     b76:	0f be       	out	0x3f, r0	; 63
		{
			// Home right
			case(0) :
				linear_offset.put(0);										// re initialize
				if (begin.get())											// If user begins Calibration Sequence
     b78:	80 91 49 31 	lds	r24, 0x3149	; 0x803149 <begin>
     b7c:	88 23       	and	r24, r24
     b7e:	09 f4       	brne	.+2      	; 0xb82 <_ZN5Motor3runEv+0x150>
     b80:	b0 c1       	rjmp	.+864    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b82:	0f b6       	in	r0, 0x3f	; 63
     b84:	f8 94       	cli
     b86:	0f 92       	push	r0
			the_data = new_data;
     b88:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     b8c:	0f 90       	pop	r0
     b8e:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b90:	0f b6       	in	r0, 0x3f	; 63
     b92:	f8 94       	cli
     b94:	0f 92       	push	r0
			the_data = new_data;
     b96:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <stop>
			portEXIT_CRITICAL ();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     b9e:	f8 01       	movw	r30, r16
     ba0:	22 8e       	std	Z+26, r2	; 0x1a
     ba2:	33 8e       	std	Z+27, r3	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ba4:	0f b6       	in	r0, 0x3f	; 63
     ba6:	f8 94       	cli
     ba8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63

					if (rightLimitSwitch.get())
     bae:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rightLimitSwitch>
     bb2:	88 23       	and	r24, r24
     bb4:	09 f4       	brne	.+2      	; 0xbb8 <_ZN5Motor3runEv+0x186>
     bb6:	95 c1       	rjmp	.+810    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bb8:	0f b6       	in	r0, 0x3f	; 63
     bba:	f8 94       	cli
     bbc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bbe:	0f 90       	pop	r0
     bc0:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bc2:	0f b6       	in	r0, 0x3f	; 63
     bc4:	f8 94       	cli
     bc6:	0f 92       	push	r0
			the_data = new_data;
     bc8:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     bcc:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     bd0:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <linear_offset>
     bd4:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
     bdc:	d5 01       	movw	r26, r10
     bde:	1d 92       	st	X+, r1
     be0:	1d 92       	st	X+, r1
     be2:	1d 92       	st	X+, r1
     be4:	1c 92       	st	X, r1
     be6:	13 97       	sbiw	r26, 0x03	; 3
						output_correct = 0;
     be8:	f6 01       	movw	r30, r12
     bea:	10 82       	st	Z, r1
     bec:	11 82       	std	Z+1, r1	; 0x01
						transition_to(1);									// if right Limit Switch is triggered 
     bee:	61 e0       	ldi	r22, 0x01	; 1
     bf0:	c8 01       	movw	r24, r16
     bf2:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
     bf6:	75 c1       	rjmp	.+746    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	0f 92       	push	r0
			the_data = new_data;
     bfe:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <begin>
			portEXIT_CRITICAL ();
     c02:	0f 90       	pop	r0
     c04:	0f be       	out	0x3f, r0	; 63
				break;
				
			// Home left
			case(1) :
				begin.put(0);		// turn off flag
				omegam_set = -10;	// [ticks/ms]
     c06:	86 ef       	ldi	r24, 0xF6	; 246
     c08:	9f ef       	ldi	r25, 0xFF	; 255
     c0a:	82 8f       	std	Z+26, r24	; 0x1a
     c0c:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	f8 94       	cli
     c12:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c14:	0f 90       	pop	r0
     c16:	0f be       	out	0x3f, r0	; 63
				
				if (leftLimitSwitch.get())
     c18:	80 91 4d 31 	lds	r24, 0x314D	; 0x80314d <leftLimitSwitch>
     c1c:	88 23       	and	r24, r24
     c1e:	c1 f0       	breq	.+48     	; 0xc50 <_ZN5Motor3runEv+0x21e>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c20:	0f b6       	in	r0, 0x3f	; 63
     c22:	f8 94       	cli
     c24:	0f 92       	push	r0
			temporary_copy = the_data;
     c26:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <linear_position>
     c2a:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <linear_position+0x1>
     c2e:	ef 8b       	std	Y+23, r30	; 0x17
     c30:	f8 8f       	std	Y+24, r31	; 0x18
			portEXIT_CRITICAL ();
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     c36:	d5 01       	movw	r26, r10
     c38:	1d 92       	st	X+, r1
     c3a:	1d 92       	st	X+, r1
     c3c:	1d 92       	st	X+, r1
     c3e:	1c 92       	st	X, r1
     c40:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     c42:	f6 01       	movw	r30, r12
     c44:	10 82       	st	Z, r1
     c46:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     c48:	62 e0       	ldi	r22, 0x02	; 2
     c4a:	c8 01       	movw	r24, r16
     c4c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c56:	0f 90       	pop	r0
     c58:	0f be       	out	0x3f, r0	; 63
				}
						
				if (reset.get() == 1)
     c5a:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     c5e:	88 23       	and	r24, r24
     c60:	09 f4       	brne	.+2      	; 0xc64 <_ZN5Motor3runEv+0x232>
     c62:	3f c1       	rjmp	.+638    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				{
					transition_to(0);
     c64:	60 e0       	ldi	r22, 0x00	; 0
     c66:	c8 01       	movw	r24, r16
     c68:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
     c6c:	3a c1       	rjmp	.+628    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     c6e:	64 ef       	ldi	r22, 0xF4	; 244
     c70:	71 e0       	ldi	r23, 0x01	; 1
     c72:	80 e0       	ldi	r24, 0x00	; 0
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <vTaskDelay>
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(500);
				_integral = 0;
     c7a:	d5 01       	movw	r26, r10
     c7c:	1d 92       	st	X+, r1
     c7e:	1d 92       	st	X+, r1
     c80:	1d 92       	st	X+, r1
     c82:	1c 92       	st	X, r1
     c84:	13 97       	sbiw	r26, 0x03	; 3
				omegam_set = 0;
     c86:	f8 01       	movw	r30, r16
     c88:	12 8e       	std	Z+26, r1	; 0x1a
     c8a:	13 8e       	std	Z+27, r1	; 0x1b
				transition_to(3);
     c8c:	63 e0       	ldi	r22, 0x03	; 3
     c8e:	c8 01       	movw	r24, r16
     c90:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
				break;
     c94:	26 c1       	rjmp	.+588    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				
			
			// Center Cart - Position Loop included
			case(3) :
				position_midpoint = left_home/2;
     c96:	8f 89       	ldd	r24, Y+23	; 0x17
     c98:	98 8d       	ldd	r25, Y+24	; 0x18
     c9a:	99 23       	and	r25, r25
     c9c:	0c f4       	brge	.+2      	; 0xca0 <_ZN5Motor3runEv+0x26e>
     c9e:	01 96       	adiw	r24, 0x01	; 1
     ca0:	9c 01       	movw	r18, r24
     ca2:	35 95       	asr	r19
     ca4:	27 95       	ror	r18
     ca6:	2d 8b       	std	Y+21, r18	; 0x15
     ca8:	3e 8b       	std	Y+22, r19	; 0x16
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cb0:	0f 90       	pop	r0
     cb2:	0f be       	out	0x3f, r0	; 63
				
				position_error_windup = position_error - antiwind_pos_correct;			// Subtracts omegam_set windup
				position_windup_integral = (_Ki_position * position_error_windup);	// Integral gain on omegam_set windup difference
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_integral * dt)/256;						// Integrates omegam_set windup difference with gain
				omegam_set_windup = ssadd(omegam_set_Kp, omegam_set_Ki);					// Add proportionality and integral gain
     cb4:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     cb8:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     cbc:	28 1b       	sub	r18, r24
     cbe:	39 0b       	sbc	r19, r25
     cc0:	c9 01       	movw	r24, r18
     cc2:	46 e6       	ldi	r20, 0x66	; 102
     cc4:	48 9f       	mul	r20, r24
     cc6:	90 01       	movw	r18, r0
     cc8:	49 9f       	mul	r20, r25
     cca:	30 0d       	add	r19, r0
     ccc:	11 24       	eor	r1, r1
     cce:	33 23       	and	r19, r19
     cd0:	14 f4       	brge	.+4      	; 0xcd6 <_ZN5Motor3runEv+0x2a4>
     cd2:	21 50       	subi	r18, 0x01	; 1
     cd4:	3f 4f       	sbci	r19, 0xFF	; 255
     cd6:	60 e0       	ldi	r22, 0x00	; 0
     cd8:	70 e0       	ldi	r23, 0x00	; 0
     cda:	83 2f       	mov	r24, r19
     cdc:	93 2f       	mov	r25, r19
     cde:	99 0f       	add	r25, r25
     ce0:	99 0b       	sbc	r25, r25
     ce2:	0e 94 51 09 	call	0x12a2	; 0x12a2 <_ZN7satmath20signed_saturated_addEii>
				omegam_set = omegam_set_windup;												// Set desired to requested
				
				omegam_saturation_point = 40;
				if( omegam_set > omegam_saturation_point )														// Saturate requested omegam_set
     ce6:	89 32       	cpi	r24, 0x29	; 41
     ce8:	91 05       	cpc	r25, r1
     cea:	44 f0       	brlt	.+16     	; 0xcfc <_ZN5Motor3runEv+0x2ca>
				{
					omegam_set = omegam_saturation_point;
     cec:	88 e2       	ldi	r24, 0x28	; 40
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	d8 01       	movw	r26, r16
     cf2:	5a 96       	adiw	r26, 0x1a	; 26
     cf4:	8d 93       	st	X+, r24
     cf6:	9c 93       	st	X, r25
     cf8:	5b 97       	sbiw	r26, 0x1b	; 27
     cfa:	0f c0       	rjmp	.+30     	; 0xd1a <_ZN5Motor3runEv+0x2e8>
				}
				else if( omegam_set < -omegam_saturation_point )
     cfc:	88 3d       	cpi	r24, 0xD8	; 216
     cfe:	bf ef       	ldi	r27, 0xFF	; 255
     d00:	9b 07       	cpc	r25, r27
     d02:	24 f0       	brlt	.+8      	; 0xd0c <_ZN5Motor3runEv+0x2da>
				position_error_windup = position_error - antiwind_pos_correct;			// Subtracts omegam_set windup
				position_windup_integral = (_Ki_position * position_error_windup);	// Integral gain on omegam_set windup difference
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_integral * dt)/256;						// Integrates omegam_set windup difference with gain
				omegam_set_windup = ssadd(omegam_set_Kp, omegam_set_Ki);					// Add proportionality and integral gain
				omegam_set = omegam_set_windup;												// Set desired to requested
     d04:	f8 01       	movw	r30, r16
     d06:	82 8f       	std	Z+26, r24	; 0x1a
     d08:	93 8f       	std	Z+27, r25	; 0x1b
     d0a:	07 c0       	rjmp	.+14     	; 0xd1a <_ZN5Motor3runEv+0x2e8>
				{
					omegam_set = omegam_saturation_point;
				}
				else if( omegam_set < -omegam_saturation_point )
				{
					omegam_set = -omegam_saturation_point;
     d0c:	88 ed       	ldi	r24, 0xD8	; 216
     d0e:	9f ef       	ldi	r25, 0xFF	; 255
     d10:	d8 01       	movw	r26, r16
     d12:	5a 96       	adiw	r26, 0x1a	; 26
     d14:	8d 93       	st	X+, r24
     d16:	9c 93       	st	X, r25
     d18:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	f8 94       	cli
     d1e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d20:	0f 90       	pop	r0
     d22:	0f be       	out	0x3f, r0	; 63
				}
				
				antiwind_position = omegam_set_windup - omegam_set;					// Calculate windup error between desired and requested
				antiwind_pos_correct = (antiwind_error*K_position_antiwind)/256;
				
				if (reset.get() == 1)			// if user hits reset
     d24:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     d28:	88 23       	and	r24, r24
     d2a:	59 f0       	breq	.+22     	; 0xd42 <_ZN5Motor3runEv+0x310>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d2c:	0f b6       	in	r0, 0x3f	; 63
     d2e:	f8 94       	cli
     d30:	0f 92       	push	r0
			the_data = new_data;
     d32:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     d36:	0f 90       	pop	r0
     d38:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);				// turn off flag
					transition_to(0);
     d3a:	60 e0       	ldi	r22, 0x00	; 0
     d3c:	c8 01       	movw	r24, r16
     d3e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d42:	0f b6       	in	r0, 0x3f	; 63
     d44:	f8 94       	cli
     d46:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d48:	0f 90       	pop	r0
     d4a:	0f be       	out	0x3f, r0	; 63
					
				}
				
				if(go.get() == 1)				// If user says pendulum is upright or angle = 720;
     d4c:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <go>
     d50:	88 23       	and	r24, r24
     d52:	09 f4       	brne	.+2      	; 0xd56 <_ZN5Motor3runEv+0x324>
     d54:	c6 c0       	rjmp	.+396    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				{
					transition_to(4);
     d56:	64 e0       	ldi	r22, 0x04	; 4
     d58:	c8 01       	movw	r24, r16
     d5a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
     d5e:	c1 c0       	rjmp	.+386    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d60:	0f b6       	in	r0, 0x3f	; 63
     d62:	f8 94       	cli
     d64:	0f 92       	push	r0
			the_data = new_data;
     d66:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <go>
			portEXIT_CRITICAL ();
     d6a:	0f 90       	pop	r0
     d6c:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d6e:	0f b6       	in	r0, 0x3f	; 63
     d70:	f8 94       	cli
     d72:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d74:	0f 90       	pop	r0
     d76:	0f be       	out	0x3f, r0	; 63
			break;
			
			// Pendulum Balance if user sets pendulum "Inverted" and presses go
			case(4) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
     d78:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <thPendulum>
     d7c:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <thPendulum+0x1>
     d80:	20 ed       	ldi	r18, 0xD0	; 208
     d82:	32 e0       	ldi	r19, 0x02	; 2
     d84:	79 01       	movw	r14, r18
     d86:	e8 1a       	sub	r14, r24
     d88:	f9 0a       	sbc	r15, r25
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
				angle_Dout = (_Kd_angle * angle_derivative)/256;
     d8a:	b7 01       	movw	r22, r14
     d8c:	e9 8d       	ldd	r30, Y+25	; 0x19
     d8e:	fa 8d       	ldd	r31, Y+26	; 0x1a
     d90:	6e 1b       	sub	r22, r30
     d92:	7f 0b       	sbc	r23, r31
     d94:	07 2e       	mov	r0, r23
     d96:	00 0c       	add	r0, r0
     d98:	88 0b       	sbc	r24, r24
     d9a:	99 0b       	sbc	r25, r25
     d9c:	ad 81       	ldd	r26, Y+5	; 0x05
     d9e:	be 81       	ldd	r27, Y+6	; 0x06
     da0:	2d 91       	ld	r18, X+
     da2:	3d 91       	ld	r19, X+
     da4:	4d 91       	ld	r20, X+
     da6:	5c 91       	ld	r21, X
     da8:	0e 94 c2 22 	call	0x4584	; 0x4584 <__divmodsi4>
     dac:	60 ec       	ldi	r22, 0xC0	; 192
     dae:	62 03       	mulsu	r22, r18
     db0:	c0 01       	movw	r24, r0
     db2:	63 9f       	mul	r22, r19
     db4:	90 0d       	add	r25, r0
     db6:	11 24       	eor	r1, r1
     db8:	99 23       	and	r25, r25
     dba:	14 f4       	brge	.+4      	; 0xdc0 <_ZN5Motor3runEv+0x38e>
     dbc:	81 50       	subi	r24, 0x01	; 1
     dbe:	9f 4f       	sbci	r25, 0xFF	; 255
     dc0:	79 2f       	mov	r23, r25
     dc2:	77 0f       	add	r23, r23
     dc4:	77 0b       	sbc	r23, r23
     dc6:	69 2f       	mov	r22, r25

				output_correct = output;
     dc8:	ef 85       	ldd	r30, Y+15	; 0x0f
     dca:	f8 89       	ldd	r31, Y+16	; 0x10
     dcc:	80 81       	ld	r24, Z
     dce:	91 81       	ldd	r25, Z+1	; 0x01
     dd0:	d6 01       	movw	r26, r12
     dd2:	8d 93       	st	X+, r24
     dd4:	9c 93       	st	X, r25
				Pang_out = position_midpoint + (angle_error*KP_angle)/256;
				
				// Calculate total output
				position_set = ssadd(Pang_out, angle_Dout);
     dd6:	20 e8       	ldi	r18, 0x80	; 128
     dd8:	3d ef       	ldi	r19, 0xFD	; 253
     dda:	e2 9e       	mul	r14, r18
     ddc:	c0 01       	movw	r24, r0
     dde:	e3 9e       	mul	r14, r19
     de0:	90 0d       	add	r25, r0
     de2:	f2 9e       	mul	r15, r18
     de4:	90 0d       	add	r25, r0
     de6:	11 24       	eor	r1, r1
     de8:	99 23       	and	r25, r25
     dea:	14 f4       	brge	.+4      	; 0xdf0 <_ZN5Motor3runEv+0x3be>
     dec:	81 50       	subi	r24, 0x01	; 1
     dee:	9f 4f       	sbci	r25, 0xFF	; 255
     df0:	89 2f       	mov	r24, r25
     df2:	99 0f       	add	r25, r25
     df4:	99 0b       	sbc	r25, r25
     df6:	ed 89       	ldd	r30, Y+21	; 0x15
     df8:	fe 89       	ldd	r31, Y+22	; 0x16
     dfa:	8e 0f       	add	r24, r30
     dfc:	9f 1f       	adc	r25, r31
     dfe:	0e 94 51 09 	call	0x12a2	; 0x12a2 <_ZN7satmath20signed_saturated_addEii>
				
				// Saturation for limits of tracks
				
				if (position_set >= -150) //20
     e02:	8a 36       	cpi	r24, 0x6A	; 106
     e04:	ff ef       	ldi	r31, 0xFF	; 255
     e06:	9f 07       	cpc	r25, r31
     e08:	3c f4       	brge	.+14     	; 0xe18 <_ZN5Motor3runEv+0x3e6>
				{
					position_set = -150;
					omegam_set = 0;
				}
				else if (position_set <= -250) //325
     e0a:	87 30       	cpi	r24, 0x07	; 7
     e0c:	2f ef       	ldi	r18, 0xFF	; 255
     e0e:	92 07       	cpc	r25, r18
     e10:	2c f4       	brge	.+10     	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				{
					position_set = -250; //352
     e12:	86 e0       	ldi	r24, 0x06	; 6
     e14:	9f ef       	ldi	r25, 0xFF	; 255
     e16:	02 c0       	rjmp	.+4      	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				
				// Saturation for limits of tracks
				
				if (position_set >= -150) //20
				{
					position_set = -150;
     e18:	8a e6       	ldi	r24, 0x6A	; 106
     e1a:	9f ef       	ldi	r25, 0xFF	; 255
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	f8 94       	cli
     e20:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e22:	0f 90       	pop	r0
     e24:	0f be       	out	0x3f, r0	; 63
					position_set = position_set;
				}
				
				position_error = position_set - linear_position.get();  // 
				omegam_set_windup = position_error*KP_pos/256;
				omegam_set = omegam_set_windup;
     e26:	20 91 52 31 	lds	r18, 0x3152	; 0x803152 <linear_position>
     e2a:	30 91 53 31 	lds	r19, 0x3153	; 0x803153 <linear_position+0x1>
     e2e:	82 1b       	sub	r24, r18
     e30:	93 0b       	sbc	r25, r19
     e32:	46 e6       	ldi	r20, 0x66	; 102
     e34:	48 9f       	mul	r20, r24
     e36:	90 01       	movw	r18, r0
     e38:	49 9f       	mul	r20, r25
     e3a:	30 0d       	add	r19, r0
     e3c:	11 24       	eor	r1, r1
     e3e:	33 23       	and	r19, r19
     e40:	14 f4       	brge	.+4      	; 0xe46 <_ZN5Motor3runEv+0x414>
     e42:	21 50       	subi	r18, 0x01	; 1
     e44:	3f 4f       	sbci	r19, 0xFF	; 255
     e46:	83 2f       	mov	r24, r19
     e48:	88 0f       	add	r24, r24
     e4a:	88 0b       	sbc	r24, r24
     e4c:	d8 01       	movw	r26, r16
     e4e:	5a 96       	adiw	r26, 0x1a	; 26
     e50:	3c 93       	st	X, r19
     e52:	5a 97       	sbiw	r26, 0x1a	; 26
     e54:	5b 96       	adiw	r26, 0x1b	; 27
     e56:	8c 93       	st	X, r24
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e58:	0f b6       	in	r0, 0x3f	; 63
     e5a:	f8 94       	cli
     e5c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e5e:	0f 90       	pop	r0
     e60:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get())
     e62:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     e66:	88 23       	and	r24, r24
     e68:	09 f4       	brne	.+2      	; 0xe6c <_ZN5Motor3runEv+0x43a>
     e6a:	39 c0       	rjmp	.+114    	; 0xede <_ZN5Motor3runEv+0x4ac>
				{
					transition_to(0);
     e6c:	60 e0       	ldi	r22, 0x00	; 0
     e6e:	c8 01       	movw	r24, r16
     e70:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
     e74:	e9 8e       	std	Y+25, r14	; 0x19
     e76:	fa 8e       	std	Y+26, r15	; 0x1a
     e78:	34 c0       	rjmp	.+104    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				}
					
			break;
			
			case(100) :
			omegam_set = 0;
     e7a:	f8 01       	movw	r30, r16
     e7c:	12 8e       	std	Z+26, r1	; 0x1a
     e7e:	13 8e       	std	Z+27, r1	; 0x1b
			
			if (runs%300 == 0)
     e80:	cb 01       	movw	r24, r22
     e82:	ba 01       	movw	r22, r20
     e84:	2c e2       	ldi	r18, 0x2C	; 44
     e86:	31 e0       	ldi	r19, 0x01	; 1
     e88:	40 e0       	ldi	r20, 0x00	; 0
     e8a:	50 e0       	ldi	r21, 0x00	; 0
     e8c:	0e 94 a0 22 	call	0x4540	; 0x4540 <__udivmodsi4>
     e90:	67 2b       	or	r22, r23
     e92:	68 2b       	or	r22, r24
     e94:	69 2b       	or	r22, r25
     e96:	71 f4       	brne	.+28     	; 0xeb4 <_ZN5Motor3runEv+0x482>
			{
				*p_serial << "Error State" << endl;
     e98:	d8 01       	movw	r26, r16
     e9a:	16 96       	adiw	r26, 0x06	; 6
     e9c:	ed 90       	ld	r14, X+
     e9e:	fc 90       	ld	r15, X
     ea0:	17 97       	sbiw	r26, 0x07	; 7
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     ea2:	6e e1       	ldi	r22, 0x1E	; 30
     ea4:	70 e2       	ldi	r23, 0x20	; 32
     ea6:	c7 01       	movw	r24, r14
     ea8:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
     eac:	66 e0       	ldi	r22, 0x06	; 6
     eae:	c7 01       	movw	r24, r14
     eb0:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     eba:	0f 90       	pop	r0
     ebc:	0f be       	out	0x3f, r0	; 63
			}
			
				if (reset.get())										// if user hits reset
     ebe:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     ec2:	88 23       	and	r24, r24
     ec4:	71 f0       	breq	.+28     	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     ec6:	0f b6       	in	r0, 0x3f	; 63
     ec8:	f8 94       	cli
     eca:	0f 92       	push	r0
			the_data = new_data;
     ecc:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     ed0:	0f 90       	pop	r0
     ed2:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);
					transition_to(0);
     ed4:	60 e0       	ldi	r22, 0x00	; 0
     ed6:	c8 01       	movw	r24, r16
     ed8:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
     edc:	02 c0       	rjmp	.+4      	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
     ede:	e9 8e       	std	Y+25, r14	; 0x19
     ee0:	fa 8e       	std	Y+26, r15	; 0x1a
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ee2:	0f b6       	in	r0, 0x3f	; 63
     ee4:	f8 94       	cli
     ee6:	0f 92       	push	r0
			temporary_copy = the_data;
     ee8:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <thdMotor>
     eec:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     ef0:	0f 90       	pop	r0
     ef2:	0f be       	out	0x3f, r0	; 63
		
		};

		
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     ef4:	f8 01       	movw	r30, r16
     ef6:	86 8f       	std	Z+30, r24	; 0x1e
     ef8:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     efa:	a9 89       	ldd	r26, Y+17	; 0x11
     efc:	ba 89       	ldd	r27, Y+18	; 0x12
     efe:	2d 92       	st	X+, r2
     f00:	3c 92       	st	X, r3
		_Ki = .7*256;
     f02:	23 eb       	ldi	r18, 0xB3	; 179
     f04:	30 e0       	ldi	r19, 0x00	; 0
     f06:	ef 81       	ldd	r30, Y+7	; 0x07
     f08:	f8 85       	ldd	r31, Y+8	; 0x08
     f0a:	20 83       	st	Z, r18
     f0c:	31 83       	std	Z+1, r19	; 0x01
		_Kd = 0;
     f0e:	ab 89       	ldd	r26, Y+19	; 0x13
     f10:	bc 89       	ldd	r27, Y+20	; 0x14
     f12:	1d 92       	st	X+, r1
     f14:	1c 92       	st	X, r1
		antiwind_gain = .75*256;
     f16:	20 ec       	ldi	r18, 0xC0	; 192
     f18:	30 e0       	ldi	r19, 0x00	; 0
     f1a:	e9 85       	ldd	r30, Y+9	; 0x09
     f1c:	fa 85       	ldd	r31, Y+10	; 0x0a
     f1e:	20 83       	st	Z, r18
     f20:	31 83       	std	Z+1, r19	; 0x01
		
		_max = 1600;
     f22:	20 e4       	ldi	r18, 0x40	; 64
     f24:	36 e0       	ldi	r19, 0x06	; 6
     f26:	ab 85       	ldd	r26, Y+11	; 0x0b
     f28:	bc 85       	ldd	r27, Y+12	; 0x0c
     f2a:	2d 93       	st	X+, r18
     f2c:	3c 93       	st	X, r19
		_min = -1600;
     f2e:	20 ec       	ldi	r18, 0xC0	; 192
     f30:	39 ef       	ldi	r19, 0xF9	; 249
     f32:	ed 85       	ldd	r30, Y+13	; 0x0d
     f34:	fe 85       	ldd	r31, Y+14	; 0x0e
     f36:	20 83       	st	Z, r18
     f38:	31 83       	std	Z+1, r19	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     f3a:	d8 01       	movw	r26, r16
     f3c:	5a 96       	adiw	r26, 0x1a	; 26
     f3e:	ed 90       	ld	r14, X+
     f40:	fc 90       	ld	r15, X
     f42:	5b 97       	sbiw	r26, 0x1b	; 27
     f44:	e8 1a       	sub	r14, r24
     f46:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     f48:	b7 01       	movw	r22, r14
     f4a:	c1 01       	movw	r24, r2
     f4c:	0e 94 6d 09 	call	0x12da	; 0x12da <_ZN7satmath20signed_saturated_mulEii>
     f50:	2b 01       	movw	r4, r22
     f52:	3c 01       	movw	r6, r24
     f54:	f8 01       	movw	r30, r16
     f56:	e4 5a       	subi	r30, 0xA4	; 164
     f58:	ff 4f       	sbci	r31, 0xFF	; 255
     f5a:	60 83       	st	Z, r22
     f5c:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     f5e:	f4 01       	movw	r30, r8
     f60:	80 81       	ld	r24, Z
     f62:	91 81       	ldd	r25, Z+1	; 0x01
     f64:	97 01       	movw	r18, r14
     f66:	28 1b       	sub	r18, r24
     f68:	39 0b       	sbc	r19, r25
     f6a:	c9 01       	movw	r24, r18
     f6c:	f8 01       	movw	r30, r16
     f6e:	e8 59       	subi	r30, 0x98	; 152
     f70:	ff 4f       	sbci	r31, 0xFF	; 255
     f72:	20 83       	st	Z, r18
     f74:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     f76:	af 81       	ldd	r26, Y+7	; 0x07
     f78:	b8 85       	ldd	r27, Y+8	; 0x08
     f7a:	2d 91       	ld	r18, X+
     f7c:	3c 91       	ld	r19, X
     f7e:	82 9f       	mul	r24, r18
     f80:	d0 01       	movw	r26, r0
     f82:	83 9f       	mul	r24, r19
     f84:	b0 0d       	add	r27, r0
     f86:	92 9f       	mul	r25, r18
     f88:	b0 0d       	add	r27, r0
     f8a:	11 24       	eor	r1, r1
     f8c:	32 96       	adiw	r30, 0x02	; 2
     f8e:	a0 83       	st	Z, r26
     f90:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     f92:	ed 81       	ldd	r30, Y+5	; 0x05
     f94:	fe 81       	ldd	r31, Y+6	; 0x06
     f96:	20 81       	ld	r18, Z
     f98:	31 81       	ldd	r19, Z+1	; 0x01
     f9a:	42 81       	ldd	r20, Z+2	; 0x02
     f9c:	53 81       	ldd	r21, Z+3	; 0x03
     f9e:	0e 94 13 23 	call	0x4626	; 0x4626 <__mulshisi3>
     fa2:	9b 01       	movw	r18, r22
     fa4:	ac 01       	movw	r20, r24
     fa6:	99 23       	and	r25, r25
     fa8:	24 f4       	brge	.+8      	; 0xfb2 <_ZN5Motor3runEv+0x580>
     faa:	21 50       	subi	r18, 0x01	; 1
     fac:	3f 4f       	sbci	r19, 0xFF	; 255
     fae:	4f 4f       	sbci	r20, 0xFF	; 255
     fb0:	5f 4f       	sbci	r21, 0xFF	; 255
     fb2:	bb 27       	eor	r27, r27
     fb4:	57 fd       	sbrc	r21, 7
     fb6:	ba 95       	dec	r27
     fb8:	a5 2f       	mov	r26, r21
     fba:	94 2f       	mov	r25, r20
     fbc:	83 2f       	mov	r24, r19
     fbe:	f5 01       	movw	r30, r10
     fc0:	40 81       	ld	r20, Z
     fc2:	51 81       	ldd	r21, Z+1	; 0x01
     fc4:	62 81       	ldd	r22, Z+2	; 0x02
     fc6:	73 81       	ldd	r23, Z+3	; 0x03
     fc8:	84 0f       	add	r24, r20
     fca:	95 1f       	adc	r25, r21
     fcc:	a6 1f       	adc	r26, r22
     fce:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     fd0:	81 30       	cpi	r24, 0x01	; 1
     fd2:	fa ec       	ldi	r31, 0xCA	; 202
     fd4:	9f 07       	cpc	r25, r31
     fd6:	fa e9       	ldi	r31, 0x9A	; 154
     fd8:	af 07       	cpc	r26, r31
     fda:	fb e3       	ldi	r31, 0x3B	; 59
     fdc:	bf 07       	cpc	r27, r31
     fde:	54 f0       	brlt	.+20     	; 0xff4 <_ZN5Motor3runEv+0x5c2>
		{
			_integral = 1000000000;
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	9a ec       	ldi	r25, 0xCA	; 202
     fe4:	aa e9       	ldi	r26, 0x9A	; 154
     fe6:	bb e3       	ldi	r27, 0x3B	; 59
     fe8:	f5 01       	movw	r30, r10
     fea:	80 83       	st	Z, r24
     fec:	91 83       	std	Z+1, r25	; 0x01
     fee:	a2 83       	std	Z+2, r26	; 0x02
     ff0:	b3 83       	std	Z+3, r27	; 0x03
     ff2:	17 c0       	rjmp	.+46     	; 0x1022 <_ZN5Motor3runEv+0x5f0>
		}
		else if(_integral < -1000000000)
     ff4:	81 15       	cp	r24, r1
     ff6:	f6 e3       	ldi	r31, 0x36	; 54
     ff8:	9f 07       	cpc	r25, r31
     ffa:	f5 e6       	ldi	r31, 0x65	; 101
     ffc:	af 07       	cpc	r26, r31
     ffe:	f4 ec       	ldi	r31, 0xC4	; 196
    1000:	bf 07       	cpc	r27, r31
    1002:	34 f0       	brlt	.+12     	; 0x1010 <_ZN5Motor3runEv+0x5de>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
    1004:	f5 01       	movw	r30, r10
    1006:	80 83       	st	Z, r24
    1008:	91 83       	std	Z+1, r25	; 0x01
    100a:	a2 83       	std	Z+2, r26	; 0x02
    100c:	b3 83       	std	Z+3, r27	; 0x03
    100e:	09 c0       	rjmp	.+18     	; 0x1022 <_ZN5Motor3runEv+0x5f0>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
    1010:	80 e0       	ldi	r24, 0x00	; 0
    1012:	96 e3       	ldi	r25, 0x36	; 54
    1014:	a5 e6       	ldi	r26, 0x65	; 101
    1016:	b4 ec       	ldi	r27, 0xC4	; 196
    1018:	f5 01       	movw	r30, r10
    101a:	80 83       	st	Z, r24
    101c:	91 83       	std	Z+1, r25	; 0x01
    101e:	a2 83       	std	Z+2, r26	; 0x02
    1020:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
    1022:	d5 01       	movw	r26, r10
    1024:	6d 91       	ld	r22, X+
    1026:	7c 91       	ld	r23, X
    1028:	c2 01       	movw	r24, r4
    102a:	0e 94 51 09 	call	0x12a2	; 0x12a2 <_ZN7satmath20signed_saturated_addEii>
    102e:	ef 85       	ldd	r30, Y+15	; 0x0f
    1030:	f8 89       	ldd	r31, Y+16	; 0x10
    1032:	80 83       	st	Z, r24
    1034:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
    1036:	d6 01       	movw	r26, r12
    1038:	8d 93       	st	X+, r24
    103a:	9c 93       	st	X, r25
    103c:	11 97       	sbiw	r26, 0x01	; 1
		
		// Restrict to max/min
		if( output_correct > _max )
    103e:	eb 85       	ldd	r30, Y+11	; 0x0b
    1040:	fc 85       	ldd	r31, Y+12	; 0x0c
    1042:	20 81       	ld	r18, Z
    1044:	31 81       	ldd	r19, Z+1	; 0x01
    1046:	28 17       	cp	r18, r24
    1048:	39 07       	cpc	r19, r25
    104a:	1c f4       	brge	.+6      	; 0x1052 <_ZN5Motor3runEv+0x620>
		{
		output_correct = _max;
    104c:	2d 93       	st	X+, r18
    104e:	3c 93       	st	X, r19
    1050:	0a c0       	rjmp	.+20     	; 0x1066 <_ZN5Motor3runEv+0x634>
		}
		else if( output_correct < _min )
    1052:	ad 85       	ldd	r26, Y+13	; 0x0d
    1054:	be 85       	ldd	r27, Y+14	; 0x0e
    1056:	2d 91       	ld	r18, X+
    1058:	3c 91       	ld	r19, X
    105a:	82 17       	cp	r24, r18
    105c:	93 07       	cpc	r25, r19
    105e:	1c f4       	brge	.+6      	; 0x1066 <_ZN5Motor3runEv+0x634>
		{
		output_correct = _min;
    1060:	f6 01       	movw	r30, r12
    1062:	20 83       	st	Z, r18
    1064:	31 83       	std	Z+1, r19	; 0x01
		}

		// Save error to previous error
		_pre_error = error;
    1066:	f8 01       	movw	r30, r16
    1068:	e2 5b       	subi	r30, 0xB2	; 178
    106a:	ff 4f       	sbci	r31, 0xFF	; 255
    106c:	e0 82       	st	Z, r14
    106e:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
    1070:	d6 01       	movw	r26, r12
    1072:	2d 91       	ld	r18, X+
    1074:	3c 91       	ld	r19, X
    1076:	82 1b       	sub	r24, r18
    1078:	93 0b       	sbc	r25, r19
    107a:	74 96       	adiw	r30, 0x14	; 20
    107c:	80 83       	st	Z, r24
    107e:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
    1080:	e9 85       	ldd	r30, Y+9	; 0x09
    1082:	fa 85       	ldd	r31, Y+10	; 0x0a
    1084:	40 81       	ld	r20, Z
    1086:	51 81       	ldd	r21, Z+1	; 0x01
    1088:	84 9f       	mul	r24, r20
    108a:	90 01       	movw	r18, r0
    108c:	85 9f       	mul	r24, r21
    108e:	30 0d       	add	r19, r0
    1090:	94 9f       	mul	r25, r20
    1092:	30 0d       	add	r19, r0
    1094:	11 24       	eor	r1, r1
    1096:	33 23       	and	r19, r19
    1098:	14 f4       	brge	.+4      	; 0x109e <_ZN5Motor3runEv+0x66c>
    109a:	21 50       	subi	r18, 0x01	; 1
    109c:	3f 4f       	sbci	r19, 0xFF	; 255
    109e:	83 2f       	mov	r24, r19
    10a0:	88 0f       	add	r24, r24
    10a2:	88 0b       	sbc	r24, r24
    10a4:	d4 01       	movw	r26, r8
    10a6:	3c 93       	st	X, r19
    10a8:	11 96       	adiw	r26, 0x01	; 1
    10aa:	8c 93       	st	X, r24
		
		
			if(runs%100 == 0){
    10ac:	f8 01       	movw	r30, r16
    10ae:	66 85       	ldd	r22, Z+14	; 0x0e
    10b0:	77 85       	ldd	r23, Z+15	; 0x0f
    10b2:	80 89       	ldd	r24, Z+16	; 0x10
    10b4:	91 89       	ldd	r25, Z+17	; 0x11
    10b6:	24 e6       	ldi	r18, 0x64	; 100
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	40 e0       	ldi	r20, 0x00	; 0
    10bc:	50 e0       	ldi	r21, 0x00	; 0
    10be:	0e 94 a0 22 	call	0x4540	; 0x4540 <__udivmodsi4>
    10c2:	67 2b       	or	r22, r23
    10c4:	68 2b       	or	r22, r24
    10c6:	69 2b       	or	r22, r25
    10c8:	99 f4       	brne	.+38     	; 0x10f0 <_ZN5Motor3runEv+0x6be>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10ca:	0f b6       	in	r0, 0x3f	; 63
    10cc:	f8 94       	cli
    10ce:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10d0:	0f 90       	pop	r0
    10d2:	0f be       	out	0x3f, r0	; 63
				//*p_serial << "Integral: " << _integral << endl;
				//*p_serial << "Measured: " << omegam_measured << endl;
				//*p_serial << "PWM Signal: " << output_correct << endl;
				//*p_serial << angle_error << endl;
				//*p_serial << position_set << endl;
				*p_serial << thPendulum.get() << endl;
    10d4:	60 91 4e 31 	lds	r22, 0x314E	; 0x80314e <thPendulum>
    10d8:	70 91 4f 31 	lds	r23, 0x314F	; 0x80314f <thPendulum+0x1>
    10dc:	d8 01       	movw	r26, r16
    10de:	16 96       	adiw	r26, 0x06	; 6
    10e0:	8d 91       	ld	r24, X+
    10e2:	9c 91       	ld	r25, X
    10e4:	17 97       	sbiw	r26, 0x07	; 7
    10e6:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <_ZN8emstreamlsEi>
    10ea:	66 e0       	ldi	r22, 0x06	; 6
    10ec:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10f0:	0f b6       	in	r0, 0x3f	; 63
    10f2:	f8 94       	cli
    10f4:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10f6:	0f 90       	pop	r0
    10f8:	0f be       	out	0x3f, r0	; 63
				//*p_serial << "stop flag" << stop.get() << endl;
				//*p_serial << "reset flag " << reset.get() << endl;
				//*p_serial << position_midpoint << endl;
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get() || stop.get())		// If limit switch or If emergency stop button was hit
    10fa:	80 91 4d 31 	lds	r24, 0x314D	; 0x80314d <leftLimitSwitch>
    10fe:	81 11       	cpse	r24, r1
    1100:	12 c0       	rjmp	.+36     	; 0x1126 <_ZN5Motor3runEv+0x6f4>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    1102:	0f b6       	in	r0, 0x3f	; 63
    1104:	f8 94       	cli
    1106:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rightLimitSwitch>
    1110:	81 11       	cpse	r24, r1
    1112:	09 c0       	rjmp	.+18     	; 0x1126 <_ZN5Motor3runEv+0x6f4>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    1114:	0f b6       	in	r0, 0x3f	; 63
    1116:	f8 94       	cli
    1118:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    111a:	0f 90       	pop	r0
    111c:	0f be       	out	0x3f, r0	; 63
    111e:	80 91 47 31 	lds	r24, 0x3147	; 0x803147 <stop>
    1122:	88 23       	and	r24, r24
    1124:	89 f0       	breq	.+34     	; 0x1148 <_ZN5Motor3runEv+0x716>
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
    1126:	f5 01       	movw	r30, r10
    1128:	10 82       	st	Z, r1
    112a:	11 82       	std	Z+1, r1	; 0x01
    112c:	12 82       	std	Z+2, r1	; 0x02
    112e:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;
    1130:	d6 01       	movw	r26, r12
    1132:	1d 92       	st	X+, r1
    1134:	1c 92       	st	X, r1
			
			if (state == 4 || state == 3)
    1136:	f8 01       	movw	r30, r16
    1138:	84 85       	ldd	r24, Z+12	; 0x0c
    113a:	83 50       	subi	r24, 0x03	; 3
    113c:	82 30       	cpi	r24, 0x02	; 2
    113e:	20 f4       	brcc	.+8      	; 0x1148 <_ZN5Motor3runEv+0x716>
			{
				transition_to(100);
    1140:	64 e6       	ldi	r22, 0x64	; 100
    1142:	c8 01       	movw	r24, r16
    1144:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
    1148:	d8 01       	movw	r26, r16
    114a:	98 96       	adiw	r26, 0x28	; 40
    114c:	1d 92       	st	X+, r1
    114e:	1c 92       	st	X, r1
    1150:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
    1152:	92 96       	adiw	r26, 0x22	; 34
    1154:	8d 91       	ld	r24, X+
    1156:	9c 91       	ld	r25, X
    1158:	93 97       	sbiw	r26, 0x23	; 35
    115a:	60 e0       	ldi	r22, 0x00	; 0
    115c:	70 e0       	ldi	r23, 0x00	; 0
    115e:	0e 94 8c 22 	call	0x4518	; 0x4518 <__divmodhi4>
    1162:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
    1164:	07 2e       	mov	r0, r23
    1166:	00 0c       	add	r0, r0
    1168:	88 0b       	sbc	r24, r24
    116a:	99 0b       	sbc	r25, r25
    116c:	0e 94 18 22 	call	0x4430	; 0x4430 <__floatsisf>
    1170:	2b 01       	movw	r4, r22
    1172:	3c 01       	movw	r6, r24
    1174:	23 e3       	ldi	r18, 0x33	; 51
    1176:	33 e3       	ldi	r19, 0x33	; 51
    1178:	4b e8       	ldi	r20, 0x8B	; 139
    117a:	51 e4       	ldi	r21, 0x41	; 65
    117c:	0e 94 77 22 	call	0x44ee	; 0x44ee <__gesf2>
    1180:	18 16       	cp	r1, r24
    1182:	34 f4       	brge	.+12     	; 0x1190 <_ZN5Motor3runEv+0x75e>
			Im_set = 17.4;
    1184:	81 e1       	ldi	r24, 0x11	; 17
    1186:	90 e0       	ldi	r25, 0x00	; 0
    1188:	f8 01       	movw	r30, r16
    118a:	84 a3       	std	Z+36, r24	; 0x24
    118c:	95 a3       	std	Z+37, r25	; 0x25
    118e:	15 c0       	rjmp	.+42     	; 0x11ba <_ZN5Motor3runEv+0x788>
		} else if(Im_set < -17.4) {
    1190:	23 e3       	ldi	r18, 0x33	; 51
    1192:	33 e3       	ldi	r19, 0x33	; 51
    1194:	4b e8       	ldi	r20, 0x8B	; 139
    1196:	51 ec       	ldi	r21, 0xC1	; 193
    1198:	c3 01       	movw	r24, r6
    119a:	b2 01       	movw	r22, r4
    119c:	0e 94 11 22 	call	0x4422	; 0x4422 <__cmpsf2>
    11a0:	88 23       	and	r24, r24
    11a2:	34 f0       	brlt	.+12     	; 0x11b0 <_ZN5Motor3runEv+0x77e>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
    11a4:	d8 01       	movw	r26, r16
    11a6:	94 96       	adiw	r26, 0x24	; 36
    11a8:	ed 92       	st	X+, r14
    11aa:	fc 92       	st	X, r15
    11ac:	95 97       	sbiw	r26, 0x25	; 37
    11ae:	05 c0       	rjmp	.+10     	; 0x11ba <_ZN5Motor3runEv+0x788>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
    11b0:	8f ee       	ldi	r24, 0xEF	; 239
    11b2:	9f ef       	ldi	r25, 0xFF	; 255
    11b4:	f8 01       	movw	r30, r16
    11b6:	84 a3       	std	Z+36, r24	; 0x24
    11b8:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
    11ba:	d8 01       	movw	r26, r16
    11bc:	d6 96       	adiw	r26, 0x36	; 54
    11be:	1d 92       	st	X+, r1
    11c0:	1c 92       	st	X, r1
    11c2:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
    11c4:	d2 96       	adiw	r26, 0x32	; 50
    11c6:	1d 92       	st	X+, r1
    11c8:	1c 92       	st	X, r1
    11ca:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
    11cc:	d4 96       	adiw	r26, 0x34	; 52
    11ce:	1d 92       	st	X+, r1
    11d0:	1c 92       	st	X, r1
    11d2:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
    11d4:	d0 96       	adiw	r26, 0x30	; 48
    11d6:	8d 91       	ld	r24, X+
    11d8:	9c 91       	ld	r25, X
    11da:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
    11dc:	89 31       	cpi	r24, 0x19	; 25
    11de:	91 05       	cpc	r25, r1
    11e0:	3c f0       	brlt	.+14     	; 0x11f0 <_ZN5Motor3runEv+0x7be>
			V_m = 24;
    11e2:	88 e1       	ldi	r24, 0x18	; 24
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	d8 96       	adiw	r26, 0x38	; 56
    11e8:	8d 93       	st	X+, r24
    11ea:	9c 93       	st	X, r25
    11ec:	d9 97       	sbiw	r26, 0x39	; 57
    11ee:	0f c0       	rjmp	.+30     	; 0x120e <_ZN5Motor3runEv+0x7dc>
		} else if(V_m < -24) {
    11f0:	88 3e       	cpi	r24, 0xE8	; 232
    11f2:	bf ef       	ldi	r27, 0xFF	; 255
    11f4:	9b 07       	cpc	r25, r27
    11f6:	24 f0       	brlt	.+8      	; 0x1200 <_ZN5Motor3runEv+0x7ce>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
    11f8:	f8 01       	movw	r30, r16
    11fa:	80 af       	std	Z+56, r24	; 0x38
    11fc:	91 af       	std	Z+57, r25	; 0x39
    11fe:	07 c0       	rjmp	.+14     	; 0x120e <_ZN5Motor3runEv+0x7dc>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
    1200:	88 ee       	ldi	r24, 0xE8	; 232
    1202:	9f ef       	ldi	r25, 0xFF	; 255
    1204:	d8 01       	movw	r26, r16
    1206:	d8 96       	adiw	r26, 0x38	; 56
    1208:	8d 93       	st	X+, r24
    120a:	9c 93       	st	X, r25
    120c:	d9 97       	sbiw	r26, 0x39	; 57
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
    120e:	f6 01       	movw	r30, r12
    1210:	80 81       	ld	r24, Z
    1212:	91 81       	ldd	r25, Z+1	; 0x01
    1214:	99 23       	and	r25, r25
    1216:	3c f0       	brlt	.+14     	; 0x1226 <_ZN5Motor3runEv+0x7f4>
		{
			TCC0.CCA = output_correct;
    1218:	e0 e0       	ldi	r30, 0x00	; 0
    121a:	f8 e0       	ldi	r31, 0x08	; 8
    121c:	80 a7       	std	Z+40, r24	; 0x28
    121e:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
    1220:	12 a6       	std	Z+42, r1	; 0x2a
    1222:	13 a6       	std	Z+43, r1	; 0x2b
    1224:	0c c0       	rjmp	.+24     	; 0x123e <_ZN5Motor3runEv+0x80c>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
    1226:	e0 e0       	ldi	r30, 0x00	; 0
    1228:	f8 e0       	ldi	r31, 0x08	; 8
    122a:	10 a6       	std	Z+40, r1	; 0x28
    122c:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
    122e:	d6 01       	movw	r26, r12
    1230:	8d 91       	ld	r24, X+
    1232:	9c 91       	ld	r25, X
    1234:	91 95       	neg	r25
    1236:	81 95       	neg	r24
    1238:	91 09       	sbc	r25, r1
    123a:	82 a7       	std	Z+42, r24	; 0x2a
    123c:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
    123e:	ed 81       	ldd	r30, Y+5	; 0x05
    1240:	fe 81       	ldd	r31, Y+6	; 0x06
    1242:	20 81       	ld	r18, Z
    1244:	31 81       	ldd	r19, Z+1	; 0x01
    1246:	42 81       	ldd	r20, Z+2	; 0x02
    1248:	53 81       	ldd	r21, Z+3	; 0x03
    124a:	a8 ee       	ldi	r26, 0xE8	; 232
    124c:	b3 e0       	ldi	r27, 0x03	; 3
    124e:	0e 94 08 23 	call	0x4610	; 0x4610 <__muluhisi3>
    1252:	68 3e       	cpi	r22, 0xE8	; 232
    1254:	f3 e0       	ldi	r31, 0x03	; 3
    1256:	7f 07       	cpc	r23, r31
    1258:	81 05       	cpc	r24, r1
    125a:	91 05       	cpc	r25, r1
    125c:	48 f0       	brcs	.+18     	; 0x1270 <_ZN5Motor3runEv+0x83e>
    125e:	28 ee       	ldi	r18, 0xE8	; 232
    1260:	33 e0       	ldi	r19, 0x03	; 3
    1262:	40 e0       	ldi	r20, 0x00	; 0
    1264:	50 e0       	ldi	r21, 0x00	; 0
    1266:	0e 94 a0 22 	call	0x4540	; 0x4540 <__udivmodsi4>
    126a:	ba 01       	movw	r22, r20
    126c:	a9 01       	movw	r20, r18
    126e:	04 c0       	rjmp	.+8      	; 0x1278 <_ZN5Motor3runEv+0x846>
    1270:	41 e0       	ldi	r20, 0x01	; 1
    1272:	50 e0       	ldi	r21, 0x00	; 0
    1274:	60 e0       	ldi	r22, 0x00	; 0
    1276:	70 e0       	ldi	r23, 0x00	; 0
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
    1278:	ce 01       	movw	r24, r28
    127a:	01 96       	adiw	r24, 0x01	; 1
    127c:	0e 94 38 15 	call	0x2a70	; 0x2a70 <vTaskDelayUntil>
    1280:	4c cc       	rjmp	.-1896   	; 0xb1a <_ZN5Motor3runEv+0xe8>

00001282 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
    1282:	0f 93       	push	r16
    1284:	1f 93       	push	r17
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
    128a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    128c:	0e 94 d5 17 	call	0x2faa	; 0x2faa <_ZN8frt_taskC1EPKchjP8emstream>
    1290:	8e e2       	ldi	r24, 0x2E	; 46
    1292:	90 e2       	ldi	r25, 0x20	; 32
    1294:	88 83       	st	Y, r24
    1296:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
    1298:	df 91       	pop	r29
    129a:	cf 91       	pop	r28
    129c:	1f 91       	pop	r17
    129e:	0f 91       	pop	r16
    12a0:	08 95       	ret

000012a2 <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
    12a2:	9c 01       	movw	r18, r24
    12a4:	93 2f       	mov	r25, r19
    12a6:	99 1f       	adc	r25, r25
    12a8:	99 27       	eor	r25, r25
    12aa:	99 1f       	adc	r25, r25
    12ac:	89 2f       	mov	r24, r25
    12ae:	90 e0       	ldi	r25, 0x00	; 0
    12b0:	81 50       	subi	r24, 0x01	; 1
    12b2:	90 48       	sbci	r25, 0x80	; 128
    12b4:	43 2f       	mov	r20, r19
    12b6:	40 95       	com	r20
    12b8:	44 1f       	adc	r20, r20
    12ba:	44 27       	eor	r20, r20
    12bc:	44 1f       	adc	r20, r20
    12be:	fc 01       	movw	r30, r24
    12c0:	e2 1b       	sub	r30, r18
    12c2:	f3 0b       	sbc	r31, r19
    12c4:	51 e0       	ldi	r21, 0x01	; 1
    12c6:	e6 17       	cp	r30, r22
    12c8:	f7 07       	cpc	r31, r23
    12ca:	0c f0       	brlt	.+2      	; 0x12ce <_ZN7satmath20signed_saturated_addEii+0x2c>
    12cc:	50 e0       	ldi	r21, 0x00	; 0
    12ce:	45 17       	cp	r20, r21
    12d0:	19 f0       	breq	.+6      	; 0x12d8 <_ZN7satmath20signed_saturated_addEii+0x36>
    12d2:	c9 01       	movw	r24, r18
    12d4:	86 0f       	add	r24, r22
    12d6:	97 1f       	adc	r25, r23
    12d8:	08 95       	ret

000012da <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    12da:	81 15       	cp	r24, r1
    12dc:	20 e8       	ldi	r18, 0x80	; 128
    12de:	92 07       	cpc	r25, r18
    12e0:	21 f4       	brne	.+8      	; 0x12ea <_ZN7satmath20signed_saturated_mulEii+0x10>
    12e2:	61 15       	cp	r22, r1
    12e4:	20 e8       	ldi	r18, 0x80	; 128
    12e6:	72 07       	cpc	r23, r18
    12e8:	29 f0       	breq	.+10     	; 0x12f4 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
    12ea:	9c 01       	movw	r18, r24
    12ec:	db 01       	movw	r26, r22
    12ee:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <__mulhisi3>
    12f2:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    12f4:	6f ef       	ldi	r22, 0xFF	; 255
    12f6:	7f ef       	ldi	r23, 0xFF	; 255
    12f8:	8f ef       	ldi	r24, 0xFF	; 255
    12fa:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
    12fc:	08 95       	ret

000012fe <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    12fe:	0f 93       	push	r16
    1300:	1f 93       	push	r17
    1302:	cf 93       	push	r28
    1304:	df 93       	push	r29
    1306:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    1308:	0e 94 d5 17 	call	0x2faa	; 0x2faa <_ZN8frt_taskC1EPKchjP8emstream>
    130c:	86 e3       	ldi	r24, 0x36	; 54
    130e:	90 e2       	ldi	r25, 0x20	; 32
    1310:	88 83       	st	Y, r24
    1312:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    1314:	df 91       	pop	r29
    1316:	cf 91       	pop	r28
    1318:	1f 91       	pop	r17
    131a:	0f 91       	pop	r16
    131c:	08 95       	ret

0000131e <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    131e:	0f 93       	push	r16
    1320:	1f 93       	push	r17
    1322:	cf 93       	push	r28
    1324:	df 93       	push	r29
    1326:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    1328:	6a e0       	ldi	r22, 0x0A	; 10
    132a:	8e 81       	ldd	r24, Y+6	; 0x06
    132c:	9f 81       	ldd	r25, Y+7	; 0x07
    132e:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1332:	8c 01       	movw	r16, r24
    1334:	63 e5       	ldi	r22, 0x53	; 83
    1336:	75 e0       	ldi	r23, 0x05	; 5
    1338:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    133c:	6a e0       	ldi	r22, 0x0A	; 10
    133e:	c8 01       	movw	r24, r16
    1340:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1344:	8c 01       	movw	r16, r24
    1346:	6d e4       	ldi	r22, 0x4D	; 77
    1348:	75 e0       	ldi	r23, 0x05	; 5
    134a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    134e:	67 e0       	ldi	r22, 0x07	; 7
    1350:	c8 01       	movw	r24, r16
    1352:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    1356:	6a e0       	ldi	r22, 0x0A	; 10
    1358:	8e 81       	ldd	r24, Y+6	; 0x06
    135a:	9f 81       	ldd	r25, Y+7	; 0x07
    135c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1360:	8c 01       	movw	r16, r24
    1362:	6e e2       	ldi	r22, 0x2E	; 46
    1364:	75 e0       	ldi	r23, 0x05	; 5
    1366:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    136a:	6a e0       	ldi	r22, 0x0A	; 10
    136c:	c8 01       	movw	r24, r16
    136e:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1372:	8c 01       	movw	r16, r24
    1374:	68 e2       	ldi	r22, 0x28	; 40
    1376:	75 e0       	ldi	r23, 0x05	; 5
    1378:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    137c:	66 e0       	ldi	r22, 0x06	; 6
    137e:	c8 01       	movw	r24, r16
    1380:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1384:	6a e0       	ldi	r22, 0x0A	; 10
    1386:	8e 81       	ldd	r24, Y+6	; 0x06
    1388:	9f 81       	ldd	r25, Y+7	; 0x07
    138a:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    138e:	8c 01       	movw	r16, r24
    1390:	61 e1       	ldi	r22, 0x11	; 17
    1392:	75 e0       	ldi	r23, 0x05	; 5
    1394:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1398:	66 e0       	ldi	r22, 0x06	; 6
    139a:	c8 01       	movw	r24, r16
    139c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    13a0:	6a e0       	ldi	r22, 0x0A	; 10
    13a2:	8e 81       	ldd	r24, Y+6	; 0x06
    13a4:	9f 81       	ldd	r25, Y+7	; 0x07
    13a6:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    13aa:	8c 01       	movw	r16, r24
    13ac:	65 ef       	ldi	r22, 0xF5	; 245
    13ae:	74 e0       	ldi	r23, 0x04	; 4
    13b0:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    13b4:	66 e0       	ldi	r22, 0x06	; 6
    13b6:	c8 01       	movw	r24, r16
    13b8:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    13bc:	6a e0       	ldi	r22, 0x0A	; 10
    13be:	8e 81       	ldd	r24, Y+6	; 0x06
    13c0:	9f 81       	ldd	r25, Y+7	; 0x07
    13c2:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    13c6:	8c 01       	movw	r16, r24
    13c8:	6d ed       	ldi	r22, 0xDD	; 221
    13ca:	74 e0       	ldi	r23, 0x04	; 4
    13cc:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    13d0:	66 e0       	ldi	r22, 0x06	; 6
    13d2:	c8 01       	movw	r24, r16
    13d4:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    13d8:	6a e0       	ldi	r22, 0x0A	; 10
    13da:	8e 81       	ldd	r24, Y+6	; 0x06
    13dc:	9f 81       	ldd	r25, Y+7	; 0x07
    13de:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    13e2:	8c 01       	movw	r16, r24
    13e4:	6c eb       	ldi	r22, 0xBC	; 188
    13e6:	74 e0       	ldi	r23, 0x04	; 4
    13e8:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    13ec:	66 e0       	ldi	r22, 0x06	; 6
    13ee:	c8 01       	movw	r24, r16
    13f0:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    13f4:	6a e0       	ldi	r22, 0x0A	; 10
    13f6:	8e 81       	ldd	r24, Y+6	; 0x06
    13f8:	9f 81       	ldd	r25, Y+7	; 0x07
    13fa:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    13fe:	8c 01       	movw	r16, r24
    1400:	65 e9       	ldi	r22, 0x95	; 149
    1402:	74 e0       	ldi	r23, 0x04	; 4
    1404:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1408:	66 e0       	ldi	r22, 0x06	; 6
    140a:	c8 01       	movw	r24, r16
    140c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1410:	6a e0       	ldi	r22, 0x0A	; 10
    1412:	8e 81       	ldd	r24, Y+6	; 0x06
    1414:	9f 81       	ldd	r25, Y+7	; 0x07
    1416:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    141a:	8c 01       	movw	r16, r24
    141c:	67 e7       	ldi	r22, 0x77	; 119
    141e:	74 e0       	ldi	r23, 0x04	; 4
    1420:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1424:	66 e0       	ldi	r22, 0x06	; 6
    1426:	c8 01       	movw	r24, r16
    1428:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    142c:	6a e0       	ldi	r22, 0x0A	; 10
    142e:	8e 81       	ldd	r24, Y+6	; 0x06
    1430:	9f 81       	ldd	r25, Y+7	; 0x07
    1432:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1436:	8c 01       	movw	r16, r24
    1438:	6c e5       	ldi	r22, 0x5C	; 92
    143a:	74 e0       	ldi	r23, 0x04	; 4
    143c:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1440:	66 e0       	ldi	r22, 0x06	; 6
    1442:	c8 01       	movw	r24, r16
    1444:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    1448:	6a e0       	ldi	r22, 0x0A	; 10
    144a:	8e 81       	ldd	r24, Y+6	; 0x06
    144c:	9f 81       	ldd	r25, Y+7	; 0x07
    144e:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1452:	8c 01       	movw	r16, r24
    1454:	6d e4       	ldi	r22, 0x4D	; 77
    1456:	74 e0       	ldi	r23, 0x04	; 4
    1458:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    145c:	66 e0       	ldi	r22, 0x06	; 6
    145e:	c8 01       	movw	r24, r16
    1460:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    b:   Begin Calibration of Inverted Pendulum?") << endl;
    1464:	6a e0       	ldi	r22, 0x0A	; 10
    1466:	8e 81       	ldd	r24, Y+6	; 0x06
    1468:	9f 81       	ldd	r25, Y+7	; 0x07
    146a:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    146e:	8c 01       	movw	r16, r24
    1470:	6c e1       	ldi	r22, 0x1C	; 28
    1472:	74 e0       	ldi	r23, 0x04	; 4
    1474:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1478:	66 e0       	ldi	r22, 0x06	; 6
    147a:	c8 01       	movw	r24, r16
    147c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    g:   Swing Pendulum Upright, then Go.") << endl;
    1480:	6a e0       	ldi	r22, 0x0A	; 10
    1482:	8e 81       	ldd	r24, Y+6	; 0x06
    1484:	9f 81       	ldd	r25, Y+7	; 0x07
    1486:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    148a:	8c 01       	movw	r16, r24
    148c:	62 ef       	ldi	r22, 0xF2	; 242
    148e:	73 e0       	ldi	r23, 0x03	; 3
    1490:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1494:	66 e0       	ldi	r22, 0x06	; 6
    1496:	c8 01       	movw	r24, r16
    1498:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    d:   Emergency Stop") << endl;
    149c:	6a e0       	ldi	r22, 0x0A	; 10
    149e:	8e 81       	ldd	r24, Y+6	; 0x06
    14a0:	9f 81       	ldd	r25, Y+7	; 0x07
    14a2:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    14a6:	8c 01       	movw	r16, r24
    14a8:	6a ed       	ldi	r22, 0xDA	; 218
    14aa:	73 e0       	ldi	r23, 0x03	; 3
    14ac:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    14b0:	66 e0       	ldi	r22, 0x06	; 6
    14b2:	c8 01       	movw	r24, r16
    14b4:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    r:   Reset to Idle") << endl;
    14b8:	6a e0       	ldi	r22, 0x0A	; 10
    14ba:	8e 81       	ldd	r24, Y+6	; 0x06
    14bc:	9f 81       	ldd	r25, Y+7	; 0x07
    14be:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    14c2:	ec 01       	movw	r28, r24
    14c4:	63 ec       	ldi	r22, 0xC3	; 195
    14c6:	73 e0       	ldi	r23, 0x03	; 3
    14c8:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    14cc:	66 e0       	ldi	r22, 0x06	; 6
    14ce:	ce 01       	movw	r24, r28
    14d0:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
}
    14d4:	df 91       	pop	r29
    14d6:	cf 91       	pop	r28
    14d8:	1f 91       	pop	r17
    14da:	0f 91       	pop	r16
    14dc:	08 95       	ret

000014de <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    14de:	af 92       	push	r10
    14e0:	bf 92       	push	r11
    14e2:	cf 92       	push	r12
    14e4:	df 92       	push	r13
    14e6:	ef 92       	push	r14
    14e8:	ff 92       	push	r15
    14ea:	0f 93       	push	r16
    14ec:	1f 93       	push	r17
    14ee:	cf 93       	push	r28
    14f0:	df 93       	push	r29
    14f2:	00 d0       	rcall	.+0      	; 0x14f4 <_ZN9task_user11show_statusEv+0x16>
    14f4:	00 d0       	rcall	.+0      	; 0x14f6 <_ZN9task_user11show_statusEv+0x18>
    14f6:	cd b7       	in	r28, 0x3d	; 61
    14f8:	de b7       	in	r29, 0x3e	; 62
    14fa:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    14fc:	19 82       	std	Y+1, r1	; 0x01
    14fe:	1a 82       	std	Y+2, r1	; 0x02
    1500:	1b 82       	std	Y+3, r1	; 0x03
    1502:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1504:	1d 82       	std	Y+5, r1	; 0x05
    1506:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1508:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <xPortGetFreeHeapSize>
    150c:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    150e:	ce 01       	movw	r24, r28
    1510:	01 96       	adiw	r24, 0x01	; 1
    1512:	0e 94 86 1b 	call	0x370c	; 0x370c <_ZN10time_stamp10set_to_nowEv>
    1516:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1518:	66 e0       	ldi	r22, 0x06	; 6
    151a:	f8 01       	movw	r30, r16
    151c:	86 81       	ldd	r24, Z+6	; 0x06
    151e:	97 81       	ldd	r25, Z+7	; 0x07
    1520:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1524:	6a e0       	ldi	r22, 0x0A	; 10
    1526:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    152a:	7c 01       	movw	r14, r24
    152c:	64 ea       	ldi	r22, 0xA4	; 164
    152e:	73 e0       	ldi	r23, 0x03	; 3
    1530:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1534:	6a e0       	ldi	r22, 0x0A	; 10
    1536:	c7 01       	movw	r24, r14
    1538:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    153c:	7c 01       	movw	r14, r24
    153e:	68 e9       	ldi	r22, 0x98	; 152
    1540:	73 e0       	ldi	r23, 0x03	; 3
    1542:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1546:	66 e0       	ldi	r22, 0x06	; 6
    1548:	c7 01       	movw	r24, r14
    154a:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    154e:	6a e0       	ldi	r22, 0x0A	; 10
    1550:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1554:	7c 01       	movw	r14, r24
    1556:	61 e9       	ldi	r22, 0x91	; 145
    1558:	73 e0       	ldi	r23, 0x03	; 3
    155a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    155e:	b5 01       	movw	r22, r10
    1560:	c7 01       	movw	r24, r14
    1562:	0e 94 2a 1b 	call	0x3654	; 0x3654 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1566:	6a e0       	ldi	r22, 0x0A	; 10
    1568:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    156c:	7c 01       	movw	r14, r24
    156e:	63 e8       	ldi	r22, 0x83	; 131
    1570:	73 e0       	ldi	r23, 0x03	; 3
    1572:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1576:	b6 01       	movw	r22, r12
    1578:	c7 01       	movw	r24, r14
    157a:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <_ZN8emstreamlsEj>
    157e:	6a e0       	ldi	r22, 0x0A	; 10
    1580:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1584:	7c 01       	movw	r14, r24
    1586:	61 e8       	ldi	r22, 0x81	; 129
    1588:	73 e0       	ldi	r23, 0x03	; 3
    158a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    158e:	4f ef       	ldi	r20, 0xFF	; 255
    1590:	5f e0       	ldi	r21, 0x0F	; 15
    1592:	60 e0       	ldi	r22, 0x00	; 0
    1594:	70 e0       	ldi	r23, 0x00	; 0
    1596:	c7 01       	movw	r24, r14
    1598:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    159c:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    15a0:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    15a4:	6a e0       	ldi	r22, 0x0A	; 10
    15a6:	f8 01       	movw	r30, r16
    15a8:	86 81       	ldd	r24, Z+6	; 0x06
    15aa:	97 81       	ldd	r25, Z+7	; 0x07
    15ac:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    15b0:	7c 01       	movw	r14, r24
    15b2:	66 e7       	ldi	r22, 0x76	; 118
    15b4:	73 e0       	ldi	r23, 0x03	; 3
    15b6:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    15ba:	b6 01       	movw	r22, r12
    15bc:	c7 01       	movw	r24, r14
    15be:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <_ZN8emstreamlsEj>
    15c2:	66 e0       	ldi	r22, 0x06	; 6
    15c4:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    15c8:	66 e0       	ldi	r22, 0x06	; 6
    15ca:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    15ce:	f8 01       	movw	r30, r16
    15d0:	86 81       	ldd	r24, Z+6	; 0x06
    15d2:	97 81       	ldd	r25, Z+7	; 0x07
    15d4:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_Z15print_task_listP8emstream>
}
    15d8:	26 96       	adiw	r28, 0x06	; 6
    15da:	cd bf       	out	0x3d, r28	; 61
    15dc:	de bf       	out	0x3e, r29	; 62
    15de:	df 91       	pop	r29
    15e0:	cf 91       	pop	r28
    15e2:	1f 91       	pop	r17
    15e4:	0f 91       	pop	r16
    15e6:	ff 90       	pop	r15
    15e8:	ef 90       	pop	r14
    15ea:	df 90       	pop	r13
    15ec:	cf 90       	pop	r12
    15ee:	bf 90       	pop	r11
    15f0:	af 90       	pop	r10
    15f2:	08 95       	ret

000015f4 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    15f4:	cf 93       	push	r28
    15f6:	df 93       	push	r29
    15f8:	00 d0       	rcall	.+0      	; 0x15fa <_ZN9task_user3runEv+0x6>
    15fa:	00 d0       	rcall	.+0      	; 0x15fc <_ZN9task_user3runEv+0x8>
    15fc:	cd b7       	in	r28, 0x3d	; 61
    15fe:	de b7       	in	r29, 0x3e	; 62
    1600:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1602:	19 82       	std	Y+1, r1	; 0x01
    1604:	1a 82       	std	Y+2, r1	; 0x02
    1606:	1b 82       	std	Y+3, r1	; 0x03
    1608:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    160a:	1d 82       	std	Y+5, r1	; 0x05
    160c:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;
    160e:	6a e0       	ldi	r22, 0x0A	; 10
    1610:	dc 01       	movw	r26, r24
    1612:	16 96       	adiw	r26, 0x06	; 6
    1614:	8d 91       	ld	r24, X+
    1616:	9c 91       	ld	r25, X
    1618:	17 97       	sbiw	r26, 0x07	; 7
    161a:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    161e:	7c 01       	movw	r14, r24
    1620:	61 ef       	ldi	r22, 0xF1	; 241
    1622:	75 e0       	ldi	r23, 0x05	; 5
    1624:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1628:	66 e0       	ldi	r22, 0x06	; 6
    162a:	c7 01       	movw	r24, r14
    162c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1630:	f8 01       	movw	r30, r16
    1632:	84 85       	ldd	r24, Z+12	; 0x0c
    1634:	88 23       	and	r24, r24
    1636:	21 f0       	breq	.+8      	; 0x1640 <_ZN9task_user3runEv+0x4c>
    1638:	81 30       	cpi	r24, 0x01	; 1
    163a:	09 f4       	brne	.+2      	; 0x163e <_ZN9task_user3runEv+0x4a>
    163c:	5d c0       	rjmp	.+186    	; 0x16f8 <_ZN9task_user3runEv+0x104>
    163e:	32 c1       	rjmp	.+612    	; 0x18a4 <_ZN9task_user3runEv+0x2b0>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1640:	86 81       	ldd	r24, Z+6	; 0x06
    1642:	97 81       	ldd	r25, Z+7	; 0x07
    1644:	dc 01       	movw	r26, r24
    1646:	ed 91       	ld	r30, X+
    1648:	fc 91       	ld	r31, X
    164a:	04 80       	ldd	r0, Z+4	; 0x04
    164c:	f5 81       	ldd	r31, Z+5	; 0x05
    164e:	e0 2d       	mov	r30, r0
    1650:	19 95       	eicall
    1652:	88 23       	and	r24, r24
    1654:	a9 f1       	breq	.+106    	; 0x16c0 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1656:	f8 01       	movw	r30, r16
    1658:	86 81       	ldd	r24, Z+6	; 0x06
    165a:	97 81       	ldd	r25, Z+7	; 0x07
    165c:	dc 01       	movw	r26, r24
    165e:	ed 91       	ld	r30, X+
    1660:	fc 91       	ld	r31, X
    1662:	06 80       	ldd	r0, Z+6	; 0x06
    1664:	f7 81       	ldd	r31, Z+7	; 0x07
    1666:	e0 2d       	mov	r30, r0
    1668:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    166a:	99 27       	eor	r25, r25
    166c:	81 30       	cpi	r24, 0x01	; 1
    166e:	91 05       	cpc	r25, r1
    1670:	f9 f0       	breq	.+62     	; 0x16b0 <_ZN9task_user3runEv+0xbc>
    1672:	03 97       	sbiw	r24, 0x03	; 3
    1674:	09 f0       	breq	.+2      	; 0x1678 <_ZN9task_user3runEv+0x84>
    1676:	31 c1       	rjmp	.+610    	; 0x18da <_ZN9task_user3runEv+0x2e6>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1678:	6a e0       	ldi	r22, 0x0A	; 10
    167a:	f8 01       	movw	r30, r16
    167c:	86 81       	ldd	r24, Z+6	; 0x06
    167e:	97 81       	ldd	r25, Z+7	; 0x07
    1680:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1684:	8c 01       	movw	r16, r24
    1686:	63 ee       	ldi	r22, 0xE3	; 227
    1688:	75 e0       	ldi	r23, 0x05	; 5
    168a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    168e:	66 e0       	ldi	r22, 0x06	; 6
    1690:	c8 01       	movw	r24, r16
    1692:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1696:	93 e0       	ldi	r25, 0x03	; 3
    1698:	88 ed       	ldi	r24, 0xD8	; 216
    169a:	08 b6       	in	r0, 0x38	; 56
    169c:	18 be       	out	0x38, r1	; 56
    169e:	84 bf       	out	0x34, r24	; 52
    16a0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    16a4:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    16a8:	81 fd       	sbrc	r24, 1
    16aa:	fc cf       	rjmp	.-8      	; 0x16a4 <_ZN9task_user3runEv+0xb0>
    16ac:	08 be       	out	0x38, r0	; 56
    16ae:	ff cf       	rjmp	.-2      	; 0x16ae <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    16b0:	c8 01       	movw	r24, r16
    16b2:	0e 94 8f 09 	call	0x131e	; 0x131e <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    16b6:	61 e0       	ldi	r22, 0x01	; 1
    16b8:	c8 01       	movw	r24, r16
    16ba:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
							break;
    16be:	0d c1       	rjmp	.+538    	; 0x18da <_ZN9task_user3runEv+0x2e6>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    16c0:	84 e5       	ldi	r24, 0x54	; 84
    16c2:	91 e3       	ldi	r25, 0x31	; 49
    16c4:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN14frt_text_queue14check_for_charEv>
    16c8:	88 23       	and	r24, r24
    16ca:	09 f4       	brne	.+2      	; 0x16ce <_ZN9task_user3runEv+0xda>
    16cc:	06 c1       	rjmp	.+524    	; 0x18da <_ZN9task_user3runEv+0x2e6>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    16ce:	d8 01       	movw	r26, r16
    16d0:	16 96       	adiw	r26, 0x06	; 6
    16d2:	ed 91       	ld	r30, X+
    16d4:	fc 91       	ld	r31, X
    16d6:	17 97       	sbiw	r26, 0x07	; 7
    16d8:	01 90       	ld	r0, Z+
    16da:	f0 81       	ld	r31, Z
    16dc:	e0 2d       	mov	r30, r0
    16de:	e2 80       	ldd	r14, Z+2	; 0x02
    16e0:	f3 80       	ldd	r15, Z+3	; 0x03
    16e2:	84 e5       	ldi	r24, 0x54	; 84
    16e4:	91 e3       	ldi	r25, 0x31	; 49
    16e6:	0e 94 74 1a 	call	0x34e8	; 0x34e8 <_ZN14frt_text_queue7getcharEv>
    16ea:	68 2f       	mov	r22, r24
    16ec:	f8 01       	movw	r30, r16
    16ee:	86 81       	ldd	r24, Z+6	; 0x06
    16f0:	97 81       	ldd	r25, Z+7	; 0x07
    16f2:	f7 01       	movw	r30, r14
    16f4:	19 95       	eicall
    16f6:	f1 c0       	rjmp	.+482    	; 0x18da <_ZN9task_user3runEv+0x2e6>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    16f8:	86 81       	ldd	r24, Z+6	; 0x06
    16fa:	97 81       	ldd	r25, Z+7	; 0x07
    16fc:	dc 01       	movw	r26, r24
    16fe:	ed 91       	ld	r30, X+
    1700:	fc 91       	ld	r31, X
    1702:	04 80       	ldd	r0, Z+4	; 0x04
    1704:	f5 81       	ldd	r31, Z+5	; 0x05
    1706:	e0 2d       	mov	r30, r0
    1708:	19 95       	eicall
    170a:	88 23       	and	r24, r24
    170c:	09 f4       	brne	.+2      	; 0x1710 <_ZN9task_user3runEv+0x11c>
    170e:	e5 c0       	rjmp	.+458    	; 0x18da <_ZN9task_user3runEv+0x2e6>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1710:	f8 01       	movw	r30, r16
    1712:	86 81       	ldd	r24, Z+6	; 0x06
    1714:	97 81       	ldd	r25, Z+7	; 0x07
    1716:	dc 01       	movw	r26, r24
    1718:	ed 91       	ld	r30, X+
    171a:	fc 91       	ld	r31, X
    171c:	06 80       	ldd	r0, Z+6	; 0x06
    171e:	f7 81       	ldd	r31, Z+7	; 0x07
    1720:	e0 2d       	mov	r30, r0
    1722:	19 95       	eicall
    1724:	bc 01       	movw	r22, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1726:	fc 01       	movw	r30, r24
    1728:	ff 27       	eor	r31, r31
    172a:	7b 97       	sbiw	r30, 0x1b	; 27
    172c:	ec 35       	cpi	r30, 0x5C	; 92
    172e:	f1 05       	cpc	r31, r1
    1730:	08 f0       	brcs	.+2      	; 0x1734 <_ZN9task_user3runEv+0x140>
    1732:	9c c0       	rjmp	.+312    	; 0x186c <_ZN9task_user3runEv+0x278>
    1734:	88 27       	eor	r24, r24
    1736:	e2 50       	subi	r30, 0x02	; 2
    1738:	ff 4f       	sbci	r31, 0xFF	; 255
    173a:	8f 4f       	sbci	r24, 0xFF	; 255
    173c:	0c 94 e1 22 	jmp	0x45c2	; 0x45c2 <__tablejump2__>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1740:	ce 01       	movw	r24, r28
    1742:	01 96       	adiw	r24, 0x01	; 1
    1744:	0e 94 86 1b 	call	0x370c	; 0x370c <_ZN10time_stamp10set_to_nowEv>
    1748:	bc 01       	movw	r22, r24
    174a:	f8 01       	movw	r30, r16
    174c:	86 81       	ldd	r24, Z+6	; 0x06
    174e:	97 81       	ldd	r25, Z+7	; 0x07
    1750:	0e 94 2a 1b 	call	0x3654	; 0x3654 <_ZlsR8emstreamR10time_stamp>
    1754:	66 e0       	ldi	r22, 0x06	; 6
    1756:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
							break;
    175a:	bf c0       	rjmp	.+382    	; 0x18da <_ZN9task_user3runEv+0x2e6>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    175c:	c8 01       	movw	r24, r16
    175e:	0e 94 6f 0a 	call	0x14de	; 0x14de <_ZN9task_user11show_statusEv>
							break;
    1762:	bb c0       	rjmp	.+374    	; 0x18da <_ZN9task_user3runEv+0x2e6>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1764:	d8 01       	movw	r26, r16
    1766:	16 96       	adiw	r26, 0x06	; 6
    1768:	8d 91       	ld	r24, X+
    176a:	9c 91       	ld	r25, X
    176c:	17 97       	sbiw	r26, 0x07	; 7
    176e:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <_Z17print_task_stacksP8emstream>
							break;
    1772:	b3 c0       	rjmp	.+358    	; 0x18da <_ZN9task_user3runEv+0x2e6>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1774:	c8 01       	movw	r24, r16
    1776:	0e 94 8f 09 	call	0x131e	; 0x131e <_ZN9task_user18print_help_messageEv>
							break;
    177a:	af c0       	rjmp	.+350    	; 0x18da <_ZN9task_user3runEv+0x2e6>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    177c:	6a e0       	ldi	r22, 0x0A	; 10
    177e:	f8 01       	movw	r30, r16
    1780:	86 81       	ldd	r24, Z+6	; 0x06
    1782:	97 81       	ldd	r25, Z+7	; 0x07
    1784:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1788:	7c 01       	movw	r14, r24
    178a:	61 ed       	ldi	r22, 0xD1	; 209
    178c:	75 e0       	ldi	r23, 0x05	; 5
    178e:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1792:	66 e0       	ldi	r22, 0x06	; 6
    1794:	c7 01       	movw	r24, r14
    1796:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0); 
    179a:	60 e0       	ldi	r22, 0x00	; 0
    179c:	c8 01       	movw	r24, r16
    179e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN8frt_task13transition_toEh>
							break;
    17a2:	9b c0       	rjmp	.+310    	; 0x18da <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    17a4:	0f b6       	in	r0, 0x3f	; 63
    17a6:	f8 94       	cli
    17a8:	0f 92       	push	r0
			the_data = new_data;
    17aa:	81 e0       	ldi	r24, 0x01	; 1
    17ac:	80 93 49 31 	sts	0x3149, r24	; 0x803149 <begin>
			portEXIT_CRITICAL ();
    17b0:	0f 90       	pop	r0
    17b2:	0f be       	out	0x3f, r0	; 63
							
						case ('b'):
							begin.put(true);
							*p_serial << PMS ("Begin Homing") << endl;
    17b4:	6a e0       	ldi	r22, 0x0A	; 10
    17b6:	d8 01       	movw	r26, r16
    17b8:	16 96       	adiw	r26, 0x06	; 6
    17ba:	8d 91       	ld	r24, X+
    17bc:	9c 91       	ld	r25, X
    17be:	17 97       	sbiw	r26, 0x07	; 7
    17c0:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    17c4:	7c 01       	movw	r14, r24
    17c6:	64 ec       	ldi	r22, 0xC4	; 196
    17c8:	75 e0       	ldi	r23, 0x05	; 5
    17ca:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    17ce:	66 e0       	ldi	r22, 0x06	; 6
    17d0:	c7 01       	movw	r24, r14
    17d2:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
							break;
    17d6:	81 c0       	rjmp	.+258    	; 0x18da <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    17d8:	0f b6       	in	r0, 0x3f	; 63
    17da:	f8 94       	cli
    17dc:	0f 92       	push	r0
			the_data = new_data;
    17de:	81 e0       	ldi	r24, 0x01	; 1
    17e0:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <go>
			portEXIT_CRITICAL ();
    17e4:	0f 90       	pop	r0
    17e6:	0f be       	out	0x3f, r0	; 63
						
						case ('g'):
							go.put(true);
							*p_serial << PMS ("Commence Balance") << endl;
    17e8:	6a e0       	ldi	r22, 0x0A	; 10
    17ea:	f8 01       	movw	r30, r16
    17ec:	86 81       	ldd	r24, Z+6	; 0x06
    17ee:	97 81       	ldd	r25, Z+7	; 0x07
    17f0:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    17f4:	7c 01       	movw	r14, r24
    17f6:	63 eb       	ldi	r22, 0xB3	; 179
    17f8:	75 e0       	ldi	r23, 0x05	; 5
    17fa:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    17fe:	66 e0       	ldi	r22, 0x06	; 6
    1800:	c7 01       	movw	r24, r14
    1802:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1806:	69 c0       	rjmp	.+210    	; 0x18da <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1808:	0f b6       	in	r0, 0x3f	; 63
    180a:	f8 94       	cli
    180c:	0f 92       	push	r0
			the_data = new_data;
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	80 93 47 31 	sts	0x3147, r24	; 0x803147 <stop>
			portEXIT_CRITICAL ();
    1814:	0f 90       	pop	r0
    1816:	0f be       	out	0x3f, r0	; 63
						
						case('d'):
							stop.put(true);
							*p_serial << PMS ("EMERGENCY STOP") << endl;
    1818:	6a e0       	ldi	r22, 0x0A	; 10
    181a:	d8 01       	movw	r26, r16
    181c:	16 96       	adiw	r26, 0x06	; 6
    181e:	8d 91       	ld	r24, X+
    1820:	9c 91       	ld	r25, X
    1822:	17 97       	sbiw	r26, 0x07	; 7
    1824:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1828:	7c 01       	movw	r14, r24
    182a:	64 ea       	ldi	r22, 0xA4	; 164
    182c:	75 e0       	ldi	r23, 0x05	; 5
    182e:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1832:	66 e0       	ldi	r22, 0x06	; 6
    1834:	c7 01       	movw	r24, r14
    1836:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
							break;
    183a:	4f c0       	rjmp	.+158    	; 0x18da <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	0f 92       	push	r0
			the_data = new_data;
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <reset>
			portEXIT_CRITICAL ();
    1848:	0f 90       	pop	r0
    184a:	0f be       	out	0x3f, r0	; 63
						
						case('r'):
							reset.put(true);
							*p_serial << PMS ("Reset, try Homing again by pressing 'b'") << endl;
    184c:	6a e0       	ldi	r22, 0x0A	; 10
    184e:	f8 01       	movw	r30, r16
    1850:	86 81       	ldd	r24, Z+6	; 0x06
    1852:	97 81       	ldd	r25, Z+7	; 0x07
    1854:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1858:	7c 01       	movw	r14, r24
    185a:	6c e7       	ldi	r22, 0x7C	; 124
    185c:	75 e0       	ldi	r23, 0x05	; 5
    185e:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    1862:	66 e0       	ldi	r22, 0x06	; 6
    1864:	c7 01       	movw	r24, r14
    1866:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
							break;
    186a:	37 c0       	rjmp	.+110    	; 0x18da <_ZN9task_user3runEv+0x2e6>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    186c:	d8 01       	movw	r26, r16
    186e:	16 96       	adiw	r26, 0x06	; 6
    1870:	8d 91       	ld	r24, X+
    1872:	9c 91       	ld	r25, X
    1874:	17 97       	sbiw	r26, 0x07	; 7
    1876:	dc 01       	movw	r26, r24
    1878:	ed 91       	ld	r30, X+
    187a:	fc 91       	ld	r31, X
    187c:	02 80       	ldd	r0, Z+2	; 0x02
    187e:	f3 81       	ldd	r31, Z+3	; 0x03
    1880:	e0 2d       	mov	r30, r0
    1882:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1884:	6a e0       	ldi	r22, 0x0A	; 10
    1886:	f8 01       	movw	r30, r16
    1888:	86 81       	ldd	r24, Z+6	; 0x06
    188a:	97 81       	ldd	r25, Z+7	; 0x07
    188c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    1890:	7c 01       	movw	r14, r24
    1892:	66 e7       	ldi	r22, 0x76	; 118
    1894:	75 e0       	ldi	r23, 0x05	; 5
    1896:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    189a:	66 e0       	ldi	r22, 0x06	; 6
    189c:	c7 01       	movw	r24, r14
    189e:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
							break;
    18a2:	1b c0       	rjmp	.+54     	; 0x18da <_ZN9task_user3runEv+0x2e6>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    18a4:	6a e0       	ldi	r22, 0x0A	; 10
    18a6:	86 81       	ldd	r24, Z+6	; 0x06
    18a8:	97 81       	ldd	r25, Z+7	; 0x07
    18aa:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    18ae:	8c 01       	movw	r16, r24
    18b0:	69 e5       	ldi	r22, 0x59	; 89
    18b2:	75 e0       	ldi	r23, 0x05	; 5
    18b4:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    18b8:	66 e0       	ldi	r22, 0x06	; 6
    18ba:	c8 01       	movw	r24, r16
    18bc:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    18c0:	93 e0       	ldi	r25, 0x03	; 3
    18c2:	88 ed       	ldi	r24, 0xD8	; 216
    18c4:	08 b6       	in	r0, 0x38	; 56
    18c6:	18 be       	out	0x38, r1	; 56
    18c8:	84 bf       	out	0x34, r24	; 52
    18ca:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    18ce:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    18d2:	81 fd       	sbrc	r24, 1
    18d4:	fc cf       	rjmp	.-8      	; 0x18ce <_ZN9task_user3runEv+0x2da>
    18d6:	08 be       	out	0x38, r0	; 56
    18d8:	ff cf       	rjmp	.-2      	; 0x18d8 <_ZN9task_user3runEv+0x2e4>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    18da:	f8 01       	movw	r30, r16
    18dc:	86 85       	ldd	r24, Z+14	; 0x0e
    18de:	97 85       	ldd	r25, Z+15	; 0x0f
    18e0:	a0 89       	ldd	r26, Z+16	; 0x10
    18e2:	b1 89       	ldd	r27, Z+17	; 0x11
    18e4:	01 96       	adiw	r24, 0x01	; 1
    18e6:	a1 1d       	adc	r26, r1
    18e8:	b1 1d       	adc	r27, r1
    18ea:	86 87       	std	Z+14, r24	; 0x0e
    18ec:	97 87       	std	Z+15, r25	; 0x0f
    18ee:	a0 8b       	std	Z+16, r26	; 0x10
    18f0:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    18f2:	61 e0       	ldi	r22, 0x01	; 1
    18f4:	70 e0       	ldi	r23, 0x00	; 0
    18f6:	80 e0       	ldi	r24, 0x00	; 0
    18f8:	90 e0       	ldi	r25, 0x00	; 0
    18fa:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <vTaskDelay>
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;

	
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    18fe:	98 ce       	rjmp	.-720    	; 0x1630 <_ZN9task_user3runEv+0x3c>

00001900 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1900:	0f 93       	push	r16
    1902:	1f 93       	push	r17
    1904:	cf 93       	push	r28
    1906:	df 93       	push	r29
    1908:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    190a:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    190e:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    1912:	81 11       	cpse	r24, r1
    1914:	1d c0       	rjmp	.+58     	; 0x1950 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1916:	a1 ec       	ldi	r26, 0xC1	; 193
    1918:	b0 e2       	ldi	r27, 0x20	; 32
    191a:	e5 ec       	ldi	r30, 0xC5	; 197
    191c:	f0 e2       	ldi	r31, 0x20	; 32
    191e:	ed 93       	st	X+, r30
    1920:	fc 93       	st	X, r31
    1922:	11 97       	sbiw	r26, 0x01	; 1
    1924:	12 96       	adiw	r26, 0x02	; 2
    1926:	1d 92       	st	X+, r1
    1928:	1c 92       	st	X, r1
    192a:	13 97       	sbiw	r26, 0x03	; 3
    192c:	ad eb       	ldi	r26, 0xBD	; 189
    192e:	b0 e2       	ldi	r27, 0x20	; 32
    1930:	8f ef       	ldi	r24, 0xFF	; 255
    1932:	9f e0       	ldi	r25, 0x0F	; 15
    1934:	12 96       	adiw	r26, 0x02	; 2
    1936:	8d 93       	st	X+, r24
    1938:	9c 93       	st	X, r25
    193a:	13 97       	sbiw	r26, 0x03	; 3
    193c:	1d 92       	st	X+, r1
    193e:	1c 92       	st	X, r1
    1940:	11 97       	sbiw	r26, 0x01	; 1
    1942:	82 83       	std	Z+2, r24	; 0x02
    1944:	93 83       	std	Z+3, r25	; 0x03
    1946:	a0 83       	st	Z, r26
    1948:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1950:	20 97       	sbiw	r28, 0x00	; 0
    1952:	09 f4       	brne	.+2      	; 0x1956 <pvPortMalloc+0x56>
    1954:	5f c0       	rjmp	.+190    	; 0x1a14 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1956:	9e 01       	movw	r18, r28
    1958:	2b 5f       	subi	r18, 0xFB	; 251
    195a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    195c:	24 96       	adiw	r28, 0x04	; 4
    195e:	ce 3f       	cpi	r28, 0xFE	; 254
    1960:	df 40       	sbci	r29, 0x0F	; 15
    1962:	08 f0       	brcs	.+2      	; 0x1966 <pvPortMalloc+0x66>
    1964:	5a c0       	rjmp	.+180    	; 0x1a1a <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1966:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    196a:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    196e:	a1 ec       	ldi	r26, 0xC1	; 193
    1970:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1972:	02 c0       	rjmp	.+4      	; 0x1978 <pvPortMalloc+0x78>
    1974:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1976:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1978:	82 81       	ldd	r24, Z+2	; 0x02
    197a:	93 81       	ldd	r25, Z+3	; 0x03
    197c:	82 17       	cp	r24, r18
    197e:	93 07       	cpc	r25, r19
    1980:	20 f4       	brcc	.+8      	; 0x198a <pvPortMalloc+0x8a>
    1982:	80 81       	ld	r24, Z
    1984:	91 81       	ldd	r25, Z+1	; 0x01
    1986:	00 97       	sbiw	r24, 0x00	; 0
    1988:	a9 f7       	brne	.-22     	; 0x1974 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    198a:	c0 e2       	ldi	r28, 0x20	; 32
    198c:	ed 3b       	cpi	r30, 0xBD	; 189
    198e:	fc 07       	cpc	r31, r28
    1990:	09 f4       	brne	.+2      	; 0x1994 <pvPortMalloc+0x94>
    1992:	46 c0       	rjmp	.+140    	; 0x1a20 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1994:	cd 91       	ld	r28, X+
    1996:	dc 91       	ld	r29, X
    1998:	11 97       	sbiw	r26, 0x01	; 1
    199a:	8e 01       	movw	r16, r28
    199c:	0b 5f       	subi	r16, 0xFB	; 251
    199e:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    19a0:	80 81       	ld	r24, Z
    19a2:	91 81       	ldd	r25, Z+1	; 0x01
    19a4:	8d 93       	st	X+, r24
    19a6:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    19a8:	82 81       	ldd	r24, Z+2	; 0x02
    19aa:	93 81       	ldd	r25, Z+3	; 0x03
    19ac:	82 1b       	sub	r24, r18
    19ae:	93 0b       	sbc	r25, r19
    19b0:	8b 30       	cpi	r24, 0x0B	; 11
    19b2:	91 05       	cpc	r25, r1
    19b4:	10 f1       	brcs	.+68     	; 0x19fa <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    19b6:	bf 01       	movw	r22, r30
    19b8:	62 0f       	add	r22, r18
    19ba:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    19bc:	db 01       	movw	r26, r22
    19be:	12 96       	adiw	r26, 0x02	; 2
    19c0:	8d 93       	st	X+, r24
    19c2:	9c 93       	st	X, r25
    19c4:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    19c6:	22 83       	std	Z+2, r18	; 0x02
    19c8:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    19ca:	12 96       	adiw	r26, 0x02	; 2
    19cc:	4d 91       	ld	r20, X+
    19ce:	5c 91       	ld	r21, X
    19d0:	13 97       	sbiw	r26, 0x03	; 3
    19d2:	81 ec       	ldi	r24, 0xC1	; 193
    19d4:	90 e2       	ldi	r25, 0x20	; 32
    19d6:	01 c0       	rjmp	.+2      	; 0x19da <pvPortMalloc+0xda>
    19d8:	cd 01       	movw	r24, r26
    19da:	ec 01       	movw	r28, r24
    19dc:	a8 81       	ld	r26, Y
    19de:	b9 81       	ldd	r27, Y+1	; 0x01
    19e0:	12 96       	adiw	r26, 0x02	; 2
    19e2:	2d 91       	ld	r18, X+
    19e4:	3c 91       	ld	r19, X
    19e6:	13 97       	sbiw	r26, 0x03	; 3
    19e8:	24 17       	cp	r18, r20
    19ea:	35 07       	cpc	r19, r21
    19ec:	a8 f3       	brcs	.-22     	; 0x19d8 <pvPortMalloc+0xd8>
    19ee:	eb 01       	movw	r28, r22
    19f0:	a8 83       	st	Y, r26
    19f2:	b9 83       	std	Y+1, r27	; 0x01
    19f4:	dc 01       	movw	r26, r24
    19f6:	6d 93       	st	X+, r22
    19f8:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    19fa:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    19fe:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1a02:	22 81       	ldd	r18, Z+2	; 0x02
    1a04:	33 81       	ldd	r19, Z+3	; 0x03
    1a06:	82 1b       	sub	r24, r18
    1a08:	93 0b       	sbc	r25, r19
    1a0a:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1a0e:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1a12:	08 c0       	rjmp	.+16     	; 0x1a24 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1a14:	00 e0       	ldi	r16, 0x00	; 0
    1a16:	10 e0       	ldi	r17, 0x00	; 0
    1a18:	05 c0       	rjmp	.+10     	; 0x1a24 <pvPortMalloc+0x124>
    1a1a:	00 e0       	ldi	r16, 0x00	; 0
    1a1c:	10 e0       	ldi	r17, 0x00	; 0
    1a1e:	02 c0       	rjmp	.+4      	; 0x1a24 <pvPortMalloc+0x124>
    1a20:	00 e0       	ldi	r16, 0x00	; 0
    1a22:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1a24:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1a28:	c8 01       	movw	r24, r16
    1a2a:	df 91       	pop	r29
    1a2c:	cf 91       	pop	r28
    1a2e:	1f 91       	pop	r17
    1a30:	0f 91       	pop	r16
    1a32:	08 95       	ret

00001a34 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1a34:	0f 93       	push	r16
    1a36:	1f 93       	push	r17
    1a38:	cf 93       	push	r28
    1a3a:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1a3c:	00 97       	sbiw	r24, 0x00	; 0
    1a3e:	41 f1       	breq	.+80     	; 0x1a90 <vPortFree+0x5c>
    1a40:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1a42:	8c 01       	movw	r16, r24
    1a44:	05 50       	subi	r16, 0x05	; 5
    1a46:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1a48:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1a4c:	f8 01       	movw	r30, r16
    1a4e:	42 81       	ldd	r20, Z+2	; 0x02
    1a50:	53 81       	ldd	r21, Z+3	; 0x03
    1a52:	a1 ec       	ldi	r26, 0xC1	; 193
    1a54:	b0 e2       	ldi	r27, 0x20	; 32
    1a56:	01 c0       	rjmp	.+2      	; 0x1a5a <vPortFree+0x26>
    1a58:	df 01       	movw	r26, r30
    1a5a:	ed 91       	ld	r30, X+
    1a5c:	fc 91       	ld	r31, X
    1a5e:	11 97       	sbiw	r26, 0x01	; 1
    1a60:	22 81       	ldd	r18, Z+2	; 0x02
    1a62:	33 81       	ldd	r19, Z+3	; 0x03
    1a64:	24 17       	cp	r18, r20
    1a66:	35 07       	cpc	r19, r21
    1a68:	b8 f3       	brcs	.-18     	; 0x1a58 <vPortFree+0x24>
    1a6a:	25 97       	sbiw	r28, 0x05	; 5
    1a6c:	e8 83       	st	Y, r30
    1a6e:	f9 83       	std	Y+1, r31	; 0x01
    1a70:	0d 93       	st	X+, r16
    1a72:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1a74:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1a78:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1a80:	82 0f       	add	r24, r18
    1a82:	93 1f       	adc	r25, r19
    1a84:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1a88:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1a8c:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
	}
}
    1a90:	df 91       	pop	r29
    1a92:	cf 91       	pop	r28
    1a94:	1f 91       	pop	r17
    1a96:	0f 91       	pop	r16
    1a98:	08 95       	ret

00001a9a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1a9a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1a9e:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1aa2:	08 95       	ret

00001aa4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1aa4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1aa6:	03 96       	adiw	r24, 0x03	; 3
    1aa8:	81 83       	std	Z+1, r24	; 0x01
    1aaa:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1aac:	4f ef       	ldi	r20, 0xFF	; 255
    1aae:	5f ef       	ldi	r21, 0xFF	; 255
    1ab0:	ba 01       	movw	r22, r20
    1ab2:	43 83       	std	Z+3, r20	; 0x03
    1ab4:	54 83       	std	Z+4, r21	; 0x04
    1ab6:	65 83       	std	Z+5, r22	; 0x05
    1ab8:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1aba:	87 83       	std	Z+7, r24	; 0x07
    1abc:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1abe:	81 87       	std	Z+9, r24	; 0x09
    1ac0:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1ac2:	10 82       	st	Z, r1
    1ac4:	08 95       	ret

00001ac6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1ac6:	fc 01       	movw	r30, r24
    1ac8:	12 86       	std	Z+10, r1	; 0x0a
    1aca:	13 86       	std	Z+11, r1	; 0x0b
    1acc:	08 95       	ret

00001ace <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1ace:	cf 93       	push	r28
    1ad0:	df 93       	push	r29
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1ad6:	21 81       	ldd	r18, Z+1	; 0x01
    1ad8:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1ada:	e9 01       	movw	r28, r18
    1adc:	8c 81       	ldd	r24, Y+4	; 0x04
    1ade:	9d 81       	ldd	r25, Y+5	; 0x05
    1ae0:	14 96       	adiw	r26, 0x04	; 4
    1ae2:	8d 93       	st	X+, r24
    1ae4:	9c 93       	st	X, r25
    1ae6:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1ae8:	81 81       	ldd	r24, Z+1	; 0x01
    1aea:	92 81       	ldd	r25, Z+2	; 0x02
    1aec:	16 96       	adiw	r26, 0x06	; 6
    1aee:	8d 93       	st	X+, r24
    1af0:	9c 93       	st	X, r25
    1af2:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1af4:	8c 81       	ldd	r24, Y+4	; 0x04
    1af6:	9d 81       	ldd	r25, Y+5	; 0x05
    1af8:	ec 01       	movw	r28, r24
    1afa:	6e 83       	std	Y+6, r22	; 0x06
    1afc:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1afe:	e9 01       	movw	r28, r18
    1b00:	6c 83       	std	Y+4, r22	; 0x04
    1b02:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1b04:	61 83       	std	Z+1, r22	; 0x01
    1b06:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b08:	1a 96       	adiw	r26, 0x0a	; 10
    1b0a:	ed 93       	st	X+, r30
    1b0c:	fc 93       	st	X, r31
    1b0e:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1b10:	80 81       	ld	r24, Z
    1b12:	8f 5f       	subi	r24, 0xFF	; 255
    1b14:	80 83       	st	Z, r24
}
    1b16:	df 91       	pop	r29
    1b18:	cf 91       	pop	r28
    1b1a:	08 95       	ret

00001b1c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1b1c:	0f 93       	push	r16
    1b1e:	1f 93       	push	r17
    1b20:	cf 93       	push	r28
    1b22:	df 93       	push	r29
    1b24:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1b26:	08 81       	ld	r16, Y
    1b28:	19 81       	ldd	r17, Y+1	; 0x01
    1b2a:	2a 81       	ldd	r18, Y+2	; 0x02
    1b2c:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1b2e:	0f 3f       	cpi	r16, 0xFF	; 255
    1b30:	4f ef       	ldi	r20, 0xFF	; 255
    1b32:	14 07       	cpc	r17, r20
    1b34:	24 07       	cpc	r18, r20
    1b36:	34 07       	cpc	r19, r20
    1b38:	31 f4       	brne	.+12     	; 0x1b46 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1b3a:	dc 01       	movw	r26, r24
    1b3c:	19 96       	adiw	r26, 0x09	; 9
    1b3e:	ed 91       	ld	r30, X+
    1b40:	fc 91       	ld	r31, X
    1b42:	1a 97       	sbiw	r26, 0x0a	; 10
    1b44:	1f c0       	rjmp	.+62     	; 0x1b84 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1b46:	fc 01       	movw	r30, r24
    1b48:	33 96       	adiw	r30, 0x03	; 3
    1b4a:	dc 01       	movw	r26, r24
    1b4c:	17 96       	adiw	r26, 0x07	; 7
    1b4e:	4d 91       	ld	r20, X+
    1b50:	5c 91       	ld	r21, X
    1b52:	18 97       	sbiw	r26, 0x08	; 8
    1b54:	da 01       	movw	r26, r20
    1b56:	4d 91       	ld	r20, X+
    1b58:	5d 91       	ld	r21, X+
    1b5a:	6d 91       	ld	r22, X+
    1b5c:	7c 91       	ld	r23, X
    1b5e:	04 17       	cp	r16, r20
    1b60:	15 07       	cpc	r17, r21
    1b62:	26 07       	cpc	r18, r22
    1b64:	37 07       	cpc	r19, r23
    1b66:	70 f0       	brcs	.+28     	; 0x1b84 <vListInsert+0x68>
    1b68:	04 80       	ldd	r0, Z+4	; 0x04
    1b6a:	f5 81       	ldd	r31, Z+5	; 0x05
    1b6c:	e0 2d       	mov	r30, r0
    1b6e:	a4 81       	ldd	r26, Z+4	; 0x04
    1b70:	b5 81       	ldd	r27, Z+5	; 0x05
    1b72:	4d 91       	ld	r20, X+
    1b74:	5d 91       	ld	r21, X+
    1b76:	6d 91       	ld	r22, X+
    1b78:	7c 91       	ld	r23, X
    1b7a:	04 17       	cp	r16, r20
    1b7c:	15 07       	cpc	r17, r21
    1b7e:	26 07       	cpc	r18, r22
    1b80:	37 07       	cpc	r19, r23
    1b82:	90 f7       	brcc	.-28     	; 0x1b68 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1b84:	a4 81       	ldd	r26, Z+4	; 0x04
    1b86:	b5 81       	ldd	r27, Z+5	; 0x05
    1b88:	ac 83       	std	Y+4, r26	; 0x04
    1b8a:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1b8c:	16 96       	adiw	r26, 0x06	; 6
    1b8e:	cd 93       	st	X+, r28
    1b90:	dc 93       	st	X, r29
    1b92:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1b94:	ee 83       	std	Y+6, r30	; 0x06
    1b96:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1b98:	c4 83       	std	Z+4, r28	; 0x04
    1b9a:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b9c:	8a 87       	std	Y+10, r24	; 0x0a
    1b9e:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1ba0:	fc 01       	movw	r30, r24
    1ba2:	20 81       	ld	r18, Z
    1ba4:	2f 5f       	subi	r18, 0xFF	; 255
    1ba6:	20 83       	st	Z, r18
}
    1ba8:	df 91       	pop	r29
    1baa:	cf 91       	pop	r28
    1bac:	1f 91       	pop	r17
    1bae:	0f 91       	pop	r16
    1bb0:	08 95       	ret

00001bb2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1bb2:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1bb4:	a4 81       	ldd	r26, Z+4	; 0x04
    1bb6:	b5 81       	ldd	r27, Z+5	; 0x05
    1bb8:	86 81       	ldd	r24, Z+6	; 0x06
    1bba:	97 81       	ldd	r25, Z+7	; 0x07
    1bbc:	16 96       	adiw	r26, 0x06	; 6
    1bbe:	8d 93       	st	X+, r24
    1bc0:	9c 93       	st	X, r25
    1bc2:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1bc4:	a6 81       	ldd	r26, Z+6	; 0x06
    1bc6:	b7 81       	ldd	r27, Z+7	; 0x07
    1bc8:	84 81       	ldd	r24, Z+4	; 0x04
    1bca:	95 81       	ldd	r25, Z+5	; 0x05
    1bcc:	14 96       	adiw	r26, 0x04	; 4
    1bce:	8d 93       	st	X+, r24
    1bd0:	9c 93       	st	X, r25
    1bd2:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1bd4:	a2 85       	ldd	r26, Z+10	; 0x0a
    1bd6:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1bd8:	11 96       	adiw	r26, 0x01	; 1
    1bda:	8d 91       	ld	r24, X+
    1bdc:	9c 91       	ld	r25, X
    1bde:	12 97       	sbiw	r26, 0x02	; 2
    1be0:	e8 17       	cp	r30, r24
    1be2:	f9 07       	cpc	r31, r25
    1be4:	31 f4       	brne	.+12     	; 0x1bf2 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1be6:	86 81       	ldd	r24, Z+6	; 0x06
    1be8:	97 81       	ldd	r25, Z+7	; 0x07
    1bea:	11 96       	adiw	r26, 0x01	; 1
    1bec:	8d 93       	st	X+, r24
    1bee:	9c 93       	st	X, r25
    1bf0:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1bf2:	12 86       	std	Z+10, r1	; 0x0a
    1bf4:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1bf6:	8c 91       	ld	r24, X
    1bf8:	81 50       	subi	r24, 0x01	; 1
    1bfa:	8c 93       	st	X, r24
    1bfc:	08 95       	ret

00001bfe <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1bfe:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <portStackTopForTask>
    1c02:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <portStackTopForTask+0x1>
    1c06:	31 e1       	ldi	r19, 0x11	; 17
    1c08:	fc 01       	movw	r30, r24
    1c0a:	30 83       	st	Z, r19
    1c0c:	31 97       	sbiw	r30, 0x01	; 1
    1c0e:	22 e2       	ldi	r18, 0x22	; 34
    1c10:	20 83       	st	Z, r18
    1c12:	31 97       	sbiw	r30, 0x01	; 1
    1c14:	a3 e3       	ldi	r26, 0x33	; 51
    1c16:	a0 83       	st	Z, r26
    1c18:	31 97       	sbiw	r30, 0x01	; 1
    1c1a:	60 83       	st	Z, r22
    1c1c:	31 97       	sbiw	r30, 0x01	; 1
    1c1e:	70 83       	st	Z, r23
    1c20:	31 97       	sbiw	r30, 0x01	; 1
    1c22:	10 82       	st	Z, r1
    1c24:	31 97       	sbiw	r30, 0x01	; 1
    1c26:	10 82       	st	Z, r1
    1c28:	31 97       	sbiw	r30, 0x01	; 1
    1c2a:	60 e8       	ldi	r22, 0x80	; 128
    1c2c:	60 83       	st	Z, r22
    1c2e:	31 97       	sbiw	r30, 0x01	; 1
    1c30:	10 82       	st	Z, r1
    1c32:	31 97       	sbiw	r30, 0x01	; 1
    1c34:	10 82       	st	Z, r1
    1c36:	31 97       	sbiw	r30, 0x01	; 1
    1c38:	10 82       	st	Z, r1
    1c3a:	31 97       	sbiw	r30, 0x01	; 1
    1c3c:	62 e0       	ldi	r22, 0x02	; 2
    1c3e:	60 83       	st	Z, r22
    1c40:	31 97       	sbiw	r30, 0x01	; 1
    1c42:	63 e0       	ldi	r22, 0x03	; 3
    1c44:	60 83       	st	Z, r22
    1c46:	31 97       	sbiw	r30, 0x01	; 1
    1c48:	64 e0       	ldi	r22, 0x04	; 4
    1c4a:	60 83       	st	Z, r22
    1c4c:	31 97       	sbiw	r30, 0x01	; 1
    1c4e:	65 e0       	ldi	r22, 0x05	; 5
    1c50:	60 83       	st	Z, r22
    1c52:	31 97       	sbiw	r30, 0x01	; 1
    1c54:	66 e0       	ldi	r22, 0x06	; 6
    1c56:	60 83       	st	Z, r22
    1c58:	31 97       	sbiw	r30, 0x01	; 1
    1c5a:	67 e0       	ldi	r22, 0x07	; 7
    1c5c:	60 83       	st	Z, r22
    1c5e:	31 97       	sbiw	r30, 0x01	; 1
    1c60:	68 e0       	ldi	r22, 0x08	; 8
    1c62:	60 83       	st	Z, r22
    1c64:	31 97       	sbiw	r30, 0x01	; 1
    1c66:	69 e0       	ldi	r22, 0x09	; 9
    1c68:	60 83       	st	Z, r22
    1c6a:	31 97       	sbiw	r30, 0x01	; 1
    1c6c:	60 e1       	ldi	r22, 0x10	; 16
    1c6e:	60 83       	st	Z, r22
    1c70:	31 97       	sbiw	r30, 0x01	; 1
    1c72:	30 83       	st	Z, r19
    1c74:	31 97       	sbiw	r30, 0x01	; 1
    1c76:	32 e1       	ldi	r19, 0x12	; 18
    1c78:	30 83       	st	Z, r19
    1c7a:	31 97       	sbiw	r30, 0x01	; 1
    1c7c:	33 e1       	ldi	r19, 0x13	; 19
    1c7e:	30 83       	st	Z, r19
    1c80:	31 97       	sbiw	r30, 0x01	; 1
    1c82:	34 e1       	ldi	r19, 0x14	; 20
    1c84:	30 83       	st	Z, r19
    1c86:	31 97       	sbiw	r30, 0x01	; 1
    1c88:	35 e1       	ldi	r19, 0x15	; 21
    1c8a:	30 83       	st	Z, r19
    1c8c:	31 97       	sbiw	r30, 0x01	; 1
    1c8e:	36 e1       	ldi	r19, 0x16	; 22
    1c90:	30 83       	st	Z, r19
    1c92:	31 97       	sbiw	r30, 0x01	; 1
    1c94:	37 e1       	ldi	r19, 0x17	; 23
    1c96:	30 83       	st	Z, r19
    1c98:	31 97       	sbiw	r30, 0x01	; 1
    1c9a:	38 e1       	ldi	r19, 0x18	; 24
    1c9c:	30 83       	st	Z, r19
    1c9e:	31 97       	sbiw	r30, 0x01	; 1
    1ca0:	39 e1       	ldi	r19, 0x19	; 25
    1ca2:	30 83       	st	Z, r19
    1ca4:	31 97       	sbiw	r30, 0x01	; 1
    1ca6:	30 e2       	ldi	r19, 0x20	; 32
    1ca8:	30 83       	st	Z, r19
    1caa:	31 97       	sbiw	r30, 0x01	; 1
    1cac:	31 e2       	ldi	r19, 0x21	; 33
    1cae:	30 83       	st	Z, r19
    1cb0:	31 97       	sbiw	r30, 0x01	; 1
    1cb2:	20 83       	st	Z, r18
    1cb4:	31 97       	sbiw	r30, 0x01	; 1
    1cb6:	23 e2       	ldi	r18, 0x23	; 35
    1cb8:	20 83       	st	Z, r18
    1cba:	31 97       	sbiw	r30, 0x01	; 1
    1cbc:	40 83       	st	Z, r20
    1cbe:	31 97       	sbiw	r30, 0x01	; 1
    1cc0:	50 83       	st	Z, r21
    1cc2:	31 97       	sbiw	r30, 0x01	; 1
    1cc4:	26 e2       	ldi	r18, 0x26	; 38
    1cc6:	20 83       	st	Z, r18
    1cc8:	31 97       	sbiw	r30, 0x01	; 1
    1cca:	27 e2       	ldi	r18, 0x27	; 39
    1ccc:	20 83       	st	Z, r18
    1cce:	31 97       	sbiw	r30, 0x01	; 1
    1cd0:	28 e2       	ldi	r18, 0x28	; 40
    1cd2:	20 83       	st	Z, r18
    1cd4:	31 97       	sbiw	r30, 0x01	; 1
    1cd6:	29 e2       	ldi	r18, 0x29	; 41
    1cd8:	20 83       	st	Z, r18
    1cda:	31 97       	sbiw	r30, 0x01	; 1
    1cdc:	20 e3       	ldi	r18, 0x30	; 48
    1cde:	20 83       	st	Z, r18
    1ce0:	31 97       	sbiw	r30, 0x01	; 1
    1ce2:	21 e3       	ldi	r18, 0x31	; 49
    1ce4:	20 83       	st	Z, r18
    1ce6:	89 97       	sbiw	r24, 0x29	; 41
    1ce8:	08 95       	ret

00001cea <xPortStartScheduler>:
    1cea:	8c e7       	ldi	r24, 0x7C	; 124
    1cec:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1cf0:	8f ef       	ldi	r24, 0xFF	; 255
    1cf2:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1cfc:	91 e1       	ldi	r25, 0x11	; 17
    1cfe:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1d02:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1d06:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1d0a:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1d0e:	cd 91       	ld	r28, X+
    1d10:	cd bf       	out	0x3d, r28	; 61
    1d12:	dd 91       	ld	r29, X+
    1d14:	de bf       	out	0x3e, r29	; 62
    1d16:	ff 91       	pop	r31
    1d18:	ef 91       	pop	r30
    1d1a:	df 91       	pop	r29
    1d1c:	cf 91       	pop	r28
    1d1e:	bf 91       	pop	r27
    1d20:	af 91       	pop	r26
    1d22:	9f 91       	pop	r25
    1d24:	8f 91       	pop	r24
    1d26:	7f 91       	pop	r23
    1d28:	6f 91       	pop	r22
    1d2a:	5f 91       	pop	r21
    1d2c:	4f 91       	pop	r20
    1d2e:	3f 91       	pop	r19
    1d30:	2f 91       	pop	r18
    1d32:	1f 91       	pop	r17
    1d34:	0f 91       	pop	r16
    1d36:	ff 90       	pop	r15
    1d38:	ef 90       	pop	r14
    1d3a:	df 90       	pop	r13
    1d3c:	cf 90       	pop	r12
    1d3e:	bf 90       	pop	r11
    1d40:	af 90       	pop	r10
    1d42:	9f 90       	pop	r9
    1d44:	8f 90       	pop	r8
    1d46:	7f 90       	pop	r7
    1d48:	6f 90       	pop	r6
    1d4a:	5f 90       	pop	r5
    1d4c:	4f 90       	pop	r4
    1d4e:	3f 90       	pop	r3
    1d50:	2f 90       	pop	r2
    1d52:	1f 90       	pop	r1
    1d54:	0f 90       	pop	r0
    1d56:	0c be       	out	0x3c, r0	; 60
    1d58:	0f 90       	pop	r0
    1d5a:	0b be       	out	0x3b, r0	; 59
    1d5c:	0f 90       	pop	r0
    1d5e:	0f be       	out	0x3f, r0	; 63
    1d60:	0f 90       	pop	r0
    1d62:	08 95       	ret
    1d64:	08 95       	ret

00001d66 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d66:	0f 92       	push	r0
    1d68:	0f b6       	in	r0, 0x3f	; 63
    1d6a:	f8 94       	cli
    1d6c:	0f 92       	push	r0
    1d6e:	0b b6       	in	r0, 0x3b	; 59
    1d70:	0f 92       	push	r0
    1d72:	0c b6       	in	r0, 0x3c	; 60
    1d74:	0f 92       	push	r0
    1d76:	1f 92       	push	r1
    1d78:	11 24       	eor	r1, r1
    1d7a:	2f 92       	push	r2
    1d7c:	3f 92       	push	r3
    1d7e:	4f 92       	push	r4
    1d80:	5f 92       	push	r5
    1d82:	6f 92       	push	r6
    1d84:	7f 92       	push	r7
    1d86:	8f 92       	push	r8
    1d88:	9f 92       	push	r9
    1d8a:	af 92       	push	r10
    1d8c:	bf 92       	push	r11
    1d8e:	cf 92       	push	r12
    1d90:	df 92       	push	r13
    1d92:	ef 92       	push	r14
    1d94:	ff 92       	push	r15
    1d96:	0f 93       	push	r16
    1d98:	1f 93       	push	r17
    1d9a:	2f 93       	push	r18
    1d9c:	3f 93       	push	r19
    1d9e:	4f 93       	push	r20
    1da0:	5f 93       	push	r21
    1da2:	6f 93       	push	r22
    1da4:	7f 93       	push	r23
    1da6:	8f 93       	push	r24
    1da8:	9f 93       	push	r25
    1daa:	af 93       	push	r26
    1dac:	bf 93       	push	r27
    1dae:	cf 93       	push	r28
    1db0:	df 93       	push	r29
    1db2:	ef 93       	push	r30
    1db4:	ff 93       	push	r31
    1db6:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1dba:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1dbe:	0d b6       	in	r0, 0x3d	; 61
    1dc0:	0d 92       	st	X+, r0
    1dc2:	0e b6       	in	r0, 0x3e	; 62
    1dc4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1dc6:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1dca:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1dce:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1dd2:	cd 91       	ld	r28, X+
    1dd4:	cd bf       	out	0x3d, r28	; 61
    1dd6:	dd 91       	ld	r29, X+
    1dd8:	de bf       	out	0x3e, r29	; 62
    1dda:	ff 91       	pop	r31
    1ddc:	ef 91       	pop	r30
    1dde:	df 91       	pop	r29
    1de0:	cf 91       	pop	r28
    1de2:	bf 91       	pop	r27
    1de4:	af 91       	pop	r26
    1de6:	9f 91       	pop	r25
    1de8:	8f 91       	pop	r24
    1dea:	7f 91       	pop	r23
    1dec:	6f 91       	pop	r22
    1dee:	5f 91       	pop	r21
    1df0:	4f 91       	pop	r20
    1df2:	3f 91       	pop	r19
    1df4:	2f 91       	pop	r18
    1df6:	1f 91       	pop	r17
    1df8:	0f 91       	pop	r16
    1dfa:	ff 90       	pop	r15
    1dfc:	ef 90       	pop	r14
    1dfe:	df 90       	pop	r13
    1e00:	cf 90       	pop	r12
    1e02:	bf 90       	pop	r11
    1e04:	af 90       	pop	r10
    1e06:	9f 90       	pop	r9
    1e08:	8f 90       	pop	r8
    1e0a:	7f 90       	pop	r7
    1e0c:	6f 90       	pop	r6
    1e0e:	5f 90       	pop	r5
    1e10:	4f 90       	pop	r4
    1e12:	3f 90       	pop	r3
    1e14:	2f 90       	pop	r2
    1e16:	1f 90       	pop	r1
    1e18:	0f 90       	pop	r0
    1e1a:	0c be       	out	0x3c, r0	; 60
    1e1c:	0f 90       	pop	r0
    1e1e:	0b be       	out	0x3b, r0	; 59
    1e20:	0f 90       	pop	r0
    1e22:	0f be       	out	0x3f, r0	; 63
    1e24:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e26:	08 95       	ret

00001e28 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e28:	0f 92       	push	r0
    1e2a:	0f b6       	in	r0, 0x3f	; 63
    1e2c:	f8 94       	cli
    1e2e:	0f 92       	push	r0
    1e30:	0b b6       	in	r0, 0x3b	; 59
    1e32:	0f 92       	push	r0
    1e34:	0c b6       	in	r0, 0x3c	; 60
    1e36:	0f 92       	push	r0
    1e38:	1f 92       	push	r1
    1e3a:	11 24       	eor	r1, r1
    1e3c:	2f 92       	push	r2
    1e3e:	3f 92       	push	r3
    1e40:	4f 92       	push	r4
    1e42:	5f 92       	push	r5
    1e44:	6f 92       	push	r6
    1e46:	7f 92       	push	r7
    1e48:	8f 92       	push	r8
    1e4a:	9f 92       	push	r9
    1e4c:	af 92       	push	r10
    1e4e:	bf 92       	push	r11
    1e50:	cf 92       	push	r12
    1e52:	df 92       	push	r13
    1e54:	ef 92       	push	r14
    1e56:	ff 92       	push	r15
    1e58:	0f 93       	push	r16
    1e5a:	1f 93       	push	r17
    1e5c:	2f 93       	push	r18
    1e5e:	3f 93       	push	r19
    1e60:	4f 93       	push	r20
    1e62:	5f 93       	push	r21
    1e64:	6f 93       	push	r22
    1e66:	7f 93       	push	r23
    1e68:	8f 93       	push	r24
    1e6a:	9f 93       	push	r25
    1e6c:	af 93       	push	r26
    1e6e:	bf 93       	push	r27
    1e70:	cf 93       	push	r28
    1e72:	df 93       	push	r29
    1e74:	ef 93       	push	r30
    1e76:	ff 93       	push	r31
    1e78:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1e7c:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1e80:	0d b6       	in	r0, 0x3d	; 61
    1e82:	0d 92       	st	X+, r0
    1e84:	0e b6       	in	r0, 0x3e	; 62
    1e86:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1e88:	0e 94 b5 13 	call	0x276a	; 0x276a <vTaskIncrementTick>
	vTaskSwitchContext();
    1e8c:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e90:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1e94:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1e98:	cd 91       	ld	r28, X+
    1e9a:	cd bf       	out	0x3d, r28	; 61
    1e9c:	dd 91       	ld	r29, X+
    1e9e:	de bf       	out	0x3e, r29	; 62
    1ea0:	ff 91       	pop	r31
    1ea2:	ef 91       	pop	r30
    1ea4:	df 91       	pop	r29
    1ea6:	cf 91       	pop	r28
    1ea8:	bf 91       	pop	r27
    1eaa:	af 91       	pop	r26
    1eac:	9f 91       	pop	r25
    1eae:	8f 91       	pop	r24
    1eb0:	7f 91       	pop	r23
    1eb2:	6f 91       	pop	r22
    1eb4:	5f 91       	pop	r21
    1eb6:	4f 91       	pop	r20
    1eb8:	3f 91       	pop	r19
    1eba:	2f 91       	pop	r18
    1ebc:	1f 91       	pop	r17
    1ebe:	0f 91       	pop	r16
    1ec0:	ff 90       	pop	r15
    1ec2:	ef 90       	pop	r14
    1ec4:	df 90       	pop	r13
    1ec6:	cf 90       	pop	r12
    1ec8:	bf 90       	pop	r11
    1eca:	af 90       	pop	r10
    1ecc:	9f 90       	pop	r9
    1ece:	8f 90       	pop	r8
    1ed0:	7f 90       	pop	r7
    1ed2:	6f 90       	pop	r6
    1ed4:	5f 90       	pop	r5
    1ed6:	4f 90       	pop	r4
    1ed8:	3f 90       	pop	r3
    1eda:	2f 90       	pop	r2
    1edc:	1f 90       	pop	r1
    1ede:	0f 90       	pop	r0
    1ee0:	0c be       	out	0x3c, r0	; 60
    1ee2:	0f 90       	pop	r0
    1ee4:	0b be       	out	0x3b, r0	; 59
    1ee6:	0f 90       	pop	r0
    1ee8:	0f be       	out	0x3f, r0	; 63
    1eea:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1eec:	08 95       	ret

00001eee <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1eee:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1ef2:	18 95       	reti

00001ef4 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ef4:	cf 93       	push	r28
    1ef6:	df 93       	push	r29
    1ef8:	ec 01       	movw	r28, r24
    1efa:	88 a1       	ldd	r24, Y+32	; 0x20
    1efc:	81 11       	cpse	r24, r1
    1efe:	0b c0       	rjmp	.+22     	; 0x1f16 <prvCopyDataToQueue+0x22>
    1f00:	88 81       	ld	r24, Y
    1f02:	99 81       	ldd	r25, Y+1	; 0x01
    1f04:	89 2b       	or	r24, r25
    1f06:	e1 f5       	brne	.+120    	; 0x1f80 <prvCopyDataToQueue+0x8c>
    1f08:	8a 81       	ldd	r24, Y+2	; 0x02
    1f0a:	9b 81       	ldd	r25, Y+3	; 0x03
    1f0c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <vTaskPriorityDisinherit>
    1f10:	1a 82       	std	Y+2, r1	; 0x02
    1f12:	1b 82       	std	Y+3, r1	; 0x03
    1f14:	35 c0       	rjmp	.+106    	; 0x1f80 <prvCopyDataToQueue+0x8c>
    1f16:	41 11       	cpse	r20, r1
    1f18:	17 c0       	rjmp	.+46     	; 0x1f48 <prvCopyDataToQueue+0x54>
    1f1a:	48 2f       	mov	r20, r24
    1f1c:	50 e0       	ldi	r21, 0x00	; 0
    1f1e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f20:	9d 81       	ldd	r25, Y+5	; 0x05
    1f22:	0e 94 2f 23 	call	0x465e	; 0x465e <memcpy>
    1f26:	28 a1       	ldd	r18, Y+32	; 0x20
    1f28:	8c 81       	ldd	r24, Y+4	; 0x04
    1f2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f2c:	82 0f       	add	r24, r18
    1f2e:	91 1d       	adc	r25, r1
    1f30:	8c 83       	std	Y+4, r24	; 0x04
    1f32:	9d 83       	std	Y+5, r25	; 0x05
    1f34:	2a 81       	ldd	r18, Y+2	; 0x02
    1f36:	3b 81       	ldd	r19, Y+3	; 0x03
    1f38:	82 17       	cp	r24, r18
    1f3a:	93 07       	cpc	r25, r19
    1f3c:	08 f1       	brcs	.+66     	; 0x1f80 <prvCopyDataToQueue+0x8c>
    1f3e:	88 81       	ld	r24, Y
    1f40:	99 81       	ldd	r25, Y+1	; 0x01
    1f42:	8c 83       	std	Y+4, r24	; 0x04
    1f44:	9d 83       	std	Y+5, r25	; 0x05
    1f46:	1c c0       	rjmp	.+56     	; 0x1f80 <prvCopyDataToQueue+0x8c>
    1f48:	48 2f       	mov	r20, r24
    1f4a:	50 e0       	ldi	r21, 0x00	; 0
    1f4c:	8e 81       	ldd	r24, Y+6	; 0x06
    1f4e:	9f 81       	ldd	r25, Y+7	; 0x07
    1f50:	0e 94 2f 23 	call	0x465e	; 0x465e <memcpy>
    1f54:	88 a1       	ldd	r24, Y+32	; 0x20
    1f56:	90 e0       	ldi	r25, 0x00	; 0
    1f58:	91 95       	neg	r25
    1f5a:	81 95       	neg	r24
    1f5c:	91 09       	sbc	r25, r1
    1f5e:	2e 81       	ldd	r18, Y+6	; 0x06
    1f60:	3f 81       	ldd	r19, Y+7	; 0x07
    1f62:	28 0f       	add	r18, r24
    1f64:	39 1f       	adc	r19, r25
    1f66:	2e 83       	std	Y+6, r18	; 0x06
    1f68:	3f 83       	std	Y+7, r19	; 0x07
    1f6a:	48 81       	ld	r20, Y
    1f6c:	59 81       	ldd	r21, Y+1	; 0x01
    1f6e:	24 17       	cp	r18, r20
    1f70:	35 07       	cpc	r19, r21
    1f72:	30 f4       	brcc	.+12     	; 0x1f80 <prvCopyDataToQueue+0x8c>
    1f74:	2a 81       	ldd	r18, Y+2	; 0x02
    1f76:	3b 81       	ldd	r19, Y+3	; 0x03
    1f78:	82 0f       	add	r24, r18
    1f7a:	93 1f       	adc	r25, r19
    1f7c:	8e 83       	std	Y+6, r24	; 0x06
    1f7e:	9f 83       	std	Y+7, r25	; 0x07
    1f80:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f82:	8f 5f       	subi	r24, 0xFF	; 255
    1f84:	8e 8f       	std	Y+30, r24	; 0x1e
    1f86:	df 91       	pop	r29
    1f88:	cf 91       	pop	r28
    1f8a:	08 95       	ret

00001f8c <prvCopyDataFromQueue>:
    1f8c:	fc 01       	movw	r30, r24
    1f8e:	80 81       	ld	r24, Z
    1f90:	91 81       	ldd	r25, Z+1	; 0x01
    1f92:	00 97       	sbiw	r24, 0x00	; 0
    1f94:	a1 f0       	breq	.+40     	; 0x1fbe <prvCopyDataFromQueue+0x32>
    1f96:	40 a1       	ldd	r20, Z+32	; 0x20
    1f98:	50 e0       	ldi	r21, 0x00	; 0
    1f9a:	26 81       	ldd	r18, Z+6	; 0x06
    1f9c:	37 81       	ldd	r19, Z+7	; 0x07
    1f9e:	24 0f       	add	r18, r20
    1fa0:	35 1f       	adc	r19, r21
    1fa2:	26 83       	std	Z+6, r18	; 0x06
    1fa4:	37 83       	std	Z+7, r19	; 0x07
    1fa6:	a2 81       	ldd	r26, Z+2	; 0x02
    1fa8:	b3 81       	ldd	r27, Z+3	; 0x03
    1faa:	2a 17       	cp	r18, r26
    1fac:	3b 07       	cpc	r19, r27
    1fae:	10 f0       	brcs	.+4      	; 0x1fb4 <prvCopyDataFromQueue+0x28>
    1fb0:	86 83       	std	Z+6, r24	; 0x06
    1fb2:	97 83       	std	Z+7, r25	; 0x07
    1fb4:	cb 01       	movw	r24, r22
    1fb6:	66 81       	ldd	r22, Z+6	; 0x06
    1fb8:	77 81       	ldd	r23, Z+7	; 0x07
    1fba:	0e 94 2f 23 	call	0x465e	; 0x465e <memcpy>
    1fbe:	08 95       	ret

00001fc0 <prvUnlockQueue>:
    1fc0:	0f 93       	push	r16
    1fc2:	1f 93       	push	r17
    1fc4:	cf 93       	push	r28
    1fc6:	df 93       	push	r29
    1fc8:	ec 01       	movw	r28, r24
    1fca:	0f b6       	in	r0, 0x3f	; 63
    1fcc:	f8 94       	cli
    1fce:	0f 92       	push	r0
    1fd0:	8a a1       	ldd	r24, Y+34	; 0x22
    1fd2:	18 16       	cp	r1, r24
    1fd4:	b4 f4       	brge	.+44     	; 0x2002 <prvUnlockQueue+0x42>
    1fd6:	8b 89       	ldd	r24, Y+19	; 0x13
    1fd8:	81 11       	cpse	r24, r1
    1fda:	05 c0       	rjmp	.+10     	; 0x1fe6 <prvUnlockQueue+0x26>
    1fdc:	12 c0       	rjmp	.+36     	; 0x2002 <prvUnlockQueue+0x42>
    1fde:	8b 89       	ldd	r24, Y+19	; 0x13
    1fe0:	81 11       	cpse	r24, r1
    1fe2:	04 c0       	rjmp	.+8      	; 0x1fec <prvUnlockQueue+0x2c>
    1fe4:	0e c0       	rjmp	.+28     	; 0x2002 <prvUnlockQueue+0x42>
    1fe6:	8e 01       	movw	r16, r28
    1fe8:	0d 5e       	subi	r16, 0xED	; 237
    1fea:	1f 4f       	sbci	r17, 0xFF	; 255
    1fec:	c8 01       	movw	r24, r16
    1fee:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <xTaskRemoveFromEventList>
    1ff2:	81 11       	cpse	r24, r1
    1ff4:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <vTaskMissedYield>
    1ff8:	8a a1       	ldd	r24, Y+34	; 0x22
    1ffa:	81 50       	subi	r24, 0x01	; 1
    1ffc:	8a a3       	std	Y+34, r24	; 0x22
    1ffe:	18 16       	cp	r1, r24
    2000:	74 f3       	brlt	.-36     	; 0x1fde <prvUnlockQueue+0x1e>
    2002:	8f ef       	ldi	r24, 0xFF	; 255
    2004:	8a a3       	std	Y+34, r24	; 0x22
    2006:	0f 90       	pop	r0
    2008:	0f be       	out	0x3f, r0	; 63
    200a:	0f b6       	in	r0, 0x3f	; 63
    200c:	f8 94       	cli
    200e:	0f 92       	push	r0
    2010:	89 a1       	ldd	r24, Y+33	; 0x21
    2012:	18 16       	cp	r1, r24
    2014:	b4 f4       	brge	.+44     	; 0x2042 <prvUnlockQueue+0x82>
    2016:	88 85       	ldd	r24, Y+8	; 0x08
    2018:	81 11       	cpse	r24, r1
    201a:	05 c0       	rjmp	.+10     	; 0x2026 <prvUnlockQueue+0x66>
    201c:	12 c0       	rjmp	.+36     	; 0x2042 <prvUnlockQueue+0x82>
    201e:	88 85       	ldd	r24, Y+8	; 0x08
    2020:	81 11       	cpse	r24, r1
    2022:	04 c0       	rjmp	.+8      	; 0x202c <prvUnlockQueue+0x6c>
    2024:	0e c0       	rjmp	.+28     	; 0x2042 <prvUnlockQueue+0x82>
    2026:	8e 01       	movw	r16, r28
    2028:	08 5f       	subi	r16, 0xF8	; 248
    202a:	1f 4f       	sbci	r17, 0xFF	; 255
    202c:	c8 01       	movw	r24, r16
    202e:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <xTaskRemoveFromEventList>
    2032:	81 11       	cpse	r24, r1
    2034:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <vTaskMissedYield>
    2038:	89 a1       	ldd	r24, Y+33	; 0x21
    203a:	81 50       	subi	r24, 0x01	; 1
    203c:	89 a3       	std	Y+33, r24	; 0x21
    203e:	18 16       	cp	r1, r24
    2040:	74 f3       	brlt	.-36     	; 0x201e <prvUnlockQueue+0x5e>
    2042:	8f ef       	ldi	r24, 0xFF	; 255
    2044:	89 a3       	std	Y+33, r24	; 0x21
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63
    204a:	df 91       	pop	r29
    204c:	cf 91       	pop	r28
    204e:	1f 91       	pop	r17
    2050:	0f 91       	pop	r16
    2052:	08 95       	ret

00002054 <xQueueGenericReset>:
    2054:	1f 93       	push	r17
    2056:	cf 93       	push	r28
    2058:	df 93       	push	r29
    205a:	61 30       	cpi	r22, 0x01	; 1
    205c:	59 f0       	breq	.+22     	; 0x2074 <xQueueGenericReset+0x20>
    205e:	fc 01       	movw	r30, r24
    2060:	23 89       	ldd	r18, Z+19	; 0x13
    2062:	30 85       	ldd	r19, Z+8	; 0x08
    2064:	31 11       	cpse	r19, r1
    2066:	2c c0       	rjmp	.+88     	; 0x20c0 <xQueueGenericReset+0x6c>
    2068:	11 e0       	ldi	r17, 0x01	; 1
    206a:	21 11       	cpse	r18, r1
    206c:	10 e0       	ldi	r17, 0x00	; 0
    206e:	21 11       	cpse	r18, r1
    2070:	28 c0       	rjmp	.+80     	; 0x20c2 <xQueueGenericReset+0x6e>
    2072:	01 c0       	rjmp	.+2      	; 0x2076 <xQueueGenericReset+0x22>
    2074:	11 e0       	ldi	r17, 0x01	; 1
    2076:	ec 01       	movw	r28, r24
    2078:	48 81       	ld	r20, Y
    207a:	59 81       	ldd	r21, Y+1	; 0x01
    207c:	28 a1       	ldd	r18, Y+32	; 0x20
    207e:	30 e0       	ldi	r19, 0x00	; 0
    2080:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2082:	62 9f       	mul	r22, r18
    2084:	c0 01       	movw	r24, r0
    2086:	63 9f       	mul	r22, r19
    2088:	90 0d       	add	r25, r0
    208a:	11 24       	eor	r1, r1
    208c:	ba 01       	movw	r22, r20
    208e:	68 0f       	add	r22, r24
    2090:	79 1f       	adc	r23, r25
    2092:	6a 83       	std	Y+2, r22	; 0x02
    2094:	7b 83       	std	Y+3, r23	; 0x03
    2096:	1e 8e       	std	Y+30, r1	; 0x1e
    2098:	4c 83       	std	Y+4, r20	; 0x04
    209a:	5d 83       	std	Y+5, r21	; 0x05
    209c:	82 1b       	sub	r24, r18
    209e:	93 0b       	sbc	r25, r19
    20a0:	84 0f       	add	r24, r20
    20a2:	95 1f       	adc	r25, r21
    20a4:	8e 83       	std	Y+6, r24	; 0x06
    20a6:	9f 83       	std	Y+7, r25	; 0x07
    20a8:	8f ef       	ldi	r24, 0xFF	; 255
    20aa:	89 a3       	std	Y+33, r24	; 0x21
    20ac:	8a a3       	std	Y+34, r24	; 0x22
    20ae:	ce 01       	movw	r24, r28
    20b0:	08 96       	adiw	r24, 0x08	; 8
    20b2:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    20b6:	ce 01       	movw	r24, r28
    20b8:	43 96       	adiw	r24, 0x13	; 19
    20ba:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    20be:	01 c0       	rjmp	.+2      	; 0x20c2 <xQueueGenericReset+0x6e>
    20c0:	10 e0       	ldi	r17, 0x00	; 0
    20c2:	81 2f       	mov	r24, r17
    20c4:	df 91       	pop	r29
    20c6:	cf 91       	pop	r28
    20c8:	1f 91       	pop	r17
    20ca:	08 95       	ret

000020cc <xQueueGenericCreate>:
    20cc:	0f 93       	push	r16
    20ce:	1f 93       	push	r17
    20d0:	cf 93       	push	r28
    20d2:	df 93       	push	r29
    20d4:	88 23       	and	r24, r24
    20d6:	01 f1       	breq	.+64     	; 0x2118 <xQueueGenericCreate+0x4c>
    20d8:	06 2f       	mov	r16, r22
    20da:	18 2f       	mov	r17, r24
    20dc:	83 e2       	ldi	r24, 0x23	; 35
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	0e 94 80 0c 	call	0x1900	; 0x1900 <pvPortMalloc>
    20e4:	ec 01       	movw	r28, r24
    20e6:	89 2b       	or	r24, r25
    20e8:	c9 f0       	breq	.+50     	; 0x211c <xQueueGenericCreate+0x50>
    20ea:	10 9f       	mul	r17, r16
    20ec:	c0 01       	movw	r24, r0
    20ee:	11 24       	eor	r1, r1
    20f0:	01 96       	adiw	r24, 0x01	; 1
    20f2:	0e 94 80 0c 	call	0x1900	; 0x1900 <pvPortMalloc>
    20f6:	88 83       	st	Y, r24
    20f8:	99 83       	std	Y+1, r25	; 0x01
    20fa:	89 2b       	or	r24, r25
    20fc:	39 f0       	breq	.+14     	; 0x210c <xQueueGenericCreate+0x40>
    20fe:	1f 8f       	std	Y+31, r17	; 0x1f
    2100:	08 a3       	std	Y+32, r16	; 0x20
    2102:	61 e0       	ldi	r22, 0x01	; 1
    2104:	ce 01       	movw	r24, r28
    2106:	0e 94 2a 10 	call	0x2054	; 0x2054 <xQueueGenericReset>
    210a:	08 c0       	rjmp	.+16     	; 0x211c <xQueueGenericCreate+0x50>
    210c:	ce 01       	movw	r24, r28
    210e:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <vPortFree>
    2112:	c0 e0       	ldi	r28, 0x00	; 0
    2114:	d0 e0       	ldi	r29, 0x00	; 0
    2116:	02 c0       	rjmp	.+4      	; 0x211c <xQueueGenericCreate+0x50>
    2118:	c0 e0       	ldi	r28, 0x00	; 0
    211a:	d0 e0       	ldi	r29, 0x00	; 0
    211c:	ce 01       	movw	r24, r28
    211e:	df 91       	pop	r29
    2120:	cf 91       	pop	r28
    2122:	1f 91       	pop	r17
    2124:	0f 91       	pop	r16
    2126:	08 95       	ret

00002128 <xQueueGenericSend>:
    2128:	af 92       	push	r10
    212a:	bf 92       	push	r11
    212c:	cf 92       	push	r12
    212e:	df 92       	push	r13
    2130:	ef 92       	push	r14
    2132:	ff 92       	push	r15
    2134:	0f 93       	push	r16
    2136:	1f 93       	push	r17
    2138:	cf 93       	push	r28
    213a:	df 93       	push	r29
    213c:	cd b7       	in	r28, 0x3d	; 61
    213e:	de b7       	in	r29, 0x3e	; 62
    2140:	29 97       	sbiw	r28, 0x09	; 9
    2142:	cd bf       	out	0x3d, r28	; 61
    2144:	de bf       	out	0x3e, r29	; 62
    2146:	7c 01       	movw	r14, r24
    2148:	5b 01       	movw	r10, r22
    214a:	2e 83       	std	Y+6, r18	; 0x06
    214c:	3f 83       	std	Y+7, r19	; 0x07
    214e:	48 87       	std	Y+8, r20	; 0x08
    2150:	59 87       	std	Y+9, r21	; 0x09
    2152:	10 e0       	ldi	r17, 0x00	; 0
    2154:	6c 01       	movw	r12, r24
    2156:	88 e0       	ldi	r24, 0x08	; 8
    2158:	c8 0e       	add	r12, r24
    215a:	d1 1c       	adc	r13, r1
    215c:	0f b6       	in	r0, 0x3f	; 63
    215e:	f8 94       	cli
    2160:	0f 92       	push	r0
    2162:	f7 01       	movw	r30, r14
    2164:	96 8d       	ldd	r25, Z+30	; 0x1e
    2166:	87 8d       	ldd	r24, Z+31	; 0x1f
    2168:	98 17       	cp	r25, r24
    216a:	a8 f4       	brcc	.+42     	; 0x2196 <xQueueGenericSend+0x6e>
    216c:	40 2f       	mov	r20, r16
    216e:	b5 01       	movw	r22, r10
    2170:	c7 01       	movw	r24, r14
    2172:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <prvCopyDataToQueue>
    2176:	f7 01       	movw	r30, r14
    2178:	83 89       	ldd	r24, Z+19	; 0x13
    217a:	88 23       	and	r24, r24
    217c:	41 f0       	breq	.+16     	; 0x218e <xQueueGenericSend+0x66>
    217e:	c7 01       	movw	r24, r14
    2180:	43 96       	adiw	r24, 0x13	; 19
    2182:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <xTaskRemoveFromEventList>
    2186:	81 30       	cpi	r24, 0x01	; 1
    2188:	11 f4       	brne	.+4      	; 0x218e <xQueueGenericSend+0x66>
    218a:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
    218e:	0f 90       	pop	r0
    2190:	0f be       	out	0x3f, r0	; 63
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	56 c0       	rjmp	.+172    	; 0x2242 <xQueueGenericSend+0x11a>
    2196:	8e 81       	ldd	r24, Y+6	; 0x06
    2198:	9f 81       	ldd	r25, Y+7	; 0x07
    219a:	a8 85       	ldd	r26, Y+8	; 0x08
    219c:	b9 85       	ldd	r27, Y+9	; 0x09
    219e:	89 2b       	or	r24, r25
    21a0:	8a 2b       	or	r24, r26
    21a2:	8b 2b       	or	r24, r27
    21a4:	21 f4       	brne	.+8      	; 0x21ae <xQueueGenericSend+0x86>
    21a6:	0f 90       	pop	r0
    21a8:	0f be       	out	0x3f, r0	; 63
    21aa:	80 e0       	ldi	r24, 0x00	; 0
    21ac:	4a c0       	rjmp	.+148    	; 0x2242 <xQueueGenericSend+0x11a>
    21ae:	11 11       	cpse	r17, r1
    21b0:	05 c0       	rjmp	.+10     	; 0x21bc <xQueueGenericSend+0x94>
    21b2:	ce 01       	movw	r24, r28
    21b4:	01 96       	adiw	r24, 0x01	; 1
    21b6:	0e 94 99 16 	call	0x2d32	; 0x2d32 <vTaskSetTimeOutState>
    21ba:	11 e0       	ldi	r17, 0x01	; 1
    21bc:	0f 90       	pop	r0
    21be:	0f be       	out	0x3f, r0	; 63
    21c0:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSuspendAll>
    21c4:	0f b6       	in	r0, 0x3f	; 63
    21c6:	f8 94       	cli
    21c8:	0f 92       	push	r0
    21ca:	f7 01       	movw	r30, r14
    21cc:	81 a1       	ldd	r24, Z+33	; 0x21
    21ce:	8f 3f       	cpi	r24, 0xFF	; 255
    21d0:	09 f4       	brne	.+2      	; 0x21d4 <xQueueGenericSend+0xac>
    21d2:	11 a2       	std	Z+33, r1	; 0x21
    21d4:	f7 01       	movw	r30, r14
    21d6:	82 a1       	ldd	r24, Z+34	; 0x22
    21d8:	8f 3f       	cpi	r24, 0xFF	; 255
    21da:	09 f4       	brne	.+2      	; 0x21de <xQueueGenericSend+0xb6>
    21dc:	12 a2       	std	Z+34, r1	; 0x22
    21de:	0f 90       	pop	r0
    21e0:	0f be       	out	0x3f, r0	; 63
    21e2:	be 01       	movw	r22, r28
    21e4:	6a 5f       	subi	r22, 0xFA	; 250
    21e6:	7f 4f       	sbci	r23, 0xFF	; 255
    21e8:	ce 01       	movw	r24, r28
    21ea:	01 96       	adiw	r24, 0x01	; 1
    21ec:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <xTaskCheckForTimeOut>
    21f0:	81 11       	cpse	r24, r1
    21f2:	21 c0       	rjmp	.+66     	; 0x2236 <xQueueGenericSend+0x10e>
    21f4:	0f b6       	in	r0, 0x3f	; 63
    21f6:	f8 94       	cli
    21f8:	0f 92       	push	r0
    21fa:	f7 01       	movw	r30, r14
    21fc:	96 8d       	ldd	r25, Z+30	; 0x1e
    21fe:	0f 90       	pop	r0
    2200:	0f be       	out	0x3f, r0	; 63
    2202:	87 8d       	ldd	r24, Z+31	; 0x1f
    2204:	98 13       	cpse	r25, r24
    2206:	11 c0       	rjmp	.+34     	; 0x222a <xQueueGenericSend+0x102>
    2208:	4e 81       	ldd	r20, Y+6	; 0x06
    220a:	5f 81       	ldd	r21, Y+7	; 0x07
    220c:	68 85       	ldd	r22, Y+8	; 0x08
    220e:	79 85       	ldd	r23, Y+9	; 0x09
    2210:	c6 01       	movw	r24, r12
    2212:	0e 94 30 16 	call	0x2c60	; 0x2c60 <vTaskPlaceOnEventList>
    2216:	c7 01       	movw	r24, r14
    2218:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <prvUnlockQueue>
    221c:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
    2220:	81 11       	cpse	r24, r1
    2222:	9c cf       	rjmp	.-200    	; 0x215c <xQueueGenericSend+0x34>
    2224:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
    2228:	99 cf       	rjmp	.-206    	; 0x215c <xQueueGenericSend+0x34>
    222a:	c7 01       	movw	r24, r14
    222c:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <prvUnlockQueue>
    2230:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
    2234:	93 cf       	rjmp	.-218    	; 0x215c <xQueueGenericSend+0x34>
    2236:	c7 01       	movw	r24, r14
    2238:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <prvUnlockQueue>
    223c:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
    2240:	80 e0       	ldi	r24, 0x00	; 0
    2242:	29 96       	adiw	r28, 0x09	; 9
    2244:	cd bf       	out	0x3d, r28	; 61
    2246:	de bf       	out	0x3e, r29	; 62
    2248:	df 91       	pop	r29
    224a:	cf 91       	pop	r28
    224c:	1f 91       	pop	r17
    224e:	0f 91       	pop	r16
    2250:	ff 90       	pop	r15
    2252:	ef 90       	pop	r14
    2254:	df 90       	pop	r13
    2256:	cf 90       	pop	r12
    2258:	bf 90       	pop	r11
    225a:	af 90       	pop	r10
    225c:	08 95       	ret

0000225e <xQueueGenericReceive>:
    225e:	af 92       	push	r10
    2260:	bf 92       	push	r11
    2262:	cf 92       	push	r12
    2264:	df 92       	push	r13
    2266:	ef 92       	push	r14
    2268:	ff 92       	push	r15
    226a:	0f 93       	push	r16
    226c:	1f 93       	push	r17
    226e:	cf 93       	push	r28
    2270:	df 93       	push	r29
    2272:	cd b7       	in	r28, 0x3d	; 61
    2274:	de b7       	in	r29, 0x3e	; 62
    2276:	29 97       	sbiw	r28, 0x09	; 9
    2278:	cd bf       	out	0x3d, r28	; 61
    227a:	de bf       	out	0x3e, r29	; 62
    227c:	7c 01       	movw	r14, r24
    227e:	5b 01       	movw	r10, r22
    2280:	2e 83       	std	Y+6, r18	; 0x06
    2282:	3f 83       	std	Y+7, r19	; 0x07
    2284:	48 87       	std	Y+8, r20	; 0x08
    2286:	59 87       	std	Y+9, r21	; 0x09
    2288:	10 e0       	ldi	r17, 0x00	; 0
    228a:	6c 01       	movw	r12, r24
    228c:	83 e1       	ldi	r24, 0x13	; 19
    228e:	c8 0e       	add	r12, r24
    2290:	d1 1c       	adc	r13, r1
    2292:	0f b6       	in	r0, 0x3f	; 63
    2294:	f8 94       	cli
    2296:	0f 92       	push	r0
    2298:	f7 01       	movw	r30, r14
    229a:	86 8d       	ldd	r24, Z+30	; 0x1e
    229c:	88 23       	and	r24, r24
    229e:	99 f1       	breq	.+102    	; 0x2306 <xQueueGenericReceive+0xa8>
    22a0:	c6 80       	ldd	r12, Z+6	; 0x06
    22a2:	d7 80       	ldd	r13, Z+7	; 0x07
    22a4:	b5 01       	movw	r22, r10
    22a6:	c7 01       	movw	r24, r14
    22a8:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <prvCopyDataFromQueue>
    22ac:	01 11       	cpse	r16, r1
    22ae:	1a c0       	rjmp	.+52     	; 0x22e4 <xQueueGenericReceive+0x86>
    22b0:	f7 01       	movw	r30, r14
    22b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    22b4:	81 50       	subi	r24, 0x01	; 1
    22b6:	86 8f       	std	Z+30, r24	; 0x1e
    22b8:	80 81       	ld	r24, Z
    22ba:	91 81       	ldd	r25, Z+1	; 0x01
    22bc:	89 2b       	or	r24, r25
    22be:	29 f4       	brne	.+10     	; 0x22ca <xQueueGenericReceive+0x6c>
    22c0:	0e 94 34 17 	call	0x2e68	; 0x2e68 <xTaskGetCurrentTaskHandle>
    22c4:	f7 01       	movw	r30, r14
    22c6:	82 83       	std	Z+2, r24	; 0x02
    22c8:	93 83       	std	Z+3, r25	; 0x03
    22ca:	f7 01       	movw	r30, r14
    22cc:	80 85       	ldd	r24, Z+8	; 0x08
    22ce:	88 23       	and	r24, r24
    22d0:	b1 f0       	breq	.+44     	; 0x22fe <xQueueGenericReceive+0xa0>
    22d2:	c7 01       	movw	r24, r14
    22d4:	08 96       	adiw	r24, 0x08	; 8
    22d6:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <xTaskRemoveFromEventList>
    22da:	81 30       	cpi	r24, 0x01	; 1
    22dc:	81 f4       	brne	.+32     	; 0x22fe <xQueueGenericReceive+0xa0>
    22de:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
    22e2:	0d c0       	rjmp	.+26     	; 0x22fe <xQueueGenericReceive+0xa0>
    22e4:	f7 01       	movw	r30, r14
    22e6:	c6 82       	std	Z+6, r12	; 0x06
    22e8:	d7 82       	std	Z+7, r13	; 0x07
    22ea:	83 89       	ldd	r24, Z+19	; 0x13
    22ec:	88 23       	and	r24, r24
    22ee:	39 f0       	breq	.+14     	; 0x22fe <xQueueGenericReceive+0xa0>
    22f0:	c7 01       	movw	r24, r14
    22f2:	43 96       	adiw	r24, 0x13	; 19
    22f4:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <xTaskRemoveFromEventList>
    22f8:	81 11       	cpse	r24, r1
    22fa:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
    22fe:	0f 90       	pop	r0
    2300:	0f be       	out	0x3f, r0	; 63
    2302:	81 e0       	ldi	r24, 0x01	; 1
    2304:	62 c0       	rjmp	.+196    	; 0x23ca <xQueueGenericReceive+0x16c>
    2306:	8e 81       	ldd	r24, Y+6	; 0x06
    2308:	9f 81       	ldd	r25, Y+7	; 0x07
    230a:	a8 85       	ldd	r26, Y+8	; 0x08
    230c:	b9 85       	ldd	r27, Y+9	; 0x09
    230e:	89 2b       	or	r24, r25
    2310:	8a 2b       	or	r24, r26
    2312:	8b 2b       	or	r24, r27
    2314:	21 f4       	brne	.+8      	; 0x231e <xQueueGenericReceive+0xc0>
    2316:	0f 90       	pop	r0
    2318:	0f be       	out	0x3f, r0	; 63
    231a:	80 e0       	ldi	r24, 0x00	; 0
    231c:	56 c0       	rjmp	.+172    	; 0x23ca <xQueueGenericReceive+0x16c>
    231e:	11 11       	cpse	r17, r1
    2320:	05 c0       	rjmp	.+10     	; 0x232c <xQueueGenericReceive+0xce>
    2322:	ce 01       	movw	r24, r28
    2324:	01 96       	adiw	r24, 0x01	; 1
    2326:	0e 94 99 16 	call	0x2d32	; 0x2d32 <vTaskSetTimeOutState>
    232a:	11 e0       	ldi	r17, 0x01	; 1
    232c:	0f 90       	pop	r0
    232e:	0f be       	out	0x3f, r0	; 63
    2330:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSuspendAll>
    2334:	0f b6       	in	r0, 0x3f	; 63
    2336:	f8 94       	cli
    2338:	0f 92       	push	r0
    233a:	f7 01       	movw	r30, r14
    233c:	81 a1       	ldd	r24, Z+33	; 0x21
    233e:	8f 3f       	cpi	r24, 0xFF	; 255
    2340:	09 f4       	brne	.+2      	; 0x2344 <xQueueGenericReceive+0xe6>
    2342:	11 a2       	std	Z+33, r1	; 0x21
    2344:	f7 01       	movw	r30, r14
    2346:	82 a1       	ldd	r24, Z+34	; 0x22
    2348:	8f 3f       	cpi	r24, 0xFF	; 255
    234a:	09 f4       	brne	.+2      	; 0x234e <xQueueGenericReceive+0xf0>
    234c:	12 a2       	std	Z+34, r1	; 0x22
    234e:	0f 90       	pop	r0
    2350:	0f be       	out	0x3f, r0	; 63
    2352:	be 01       	movw	r22, r28
    2354:	6a 5f       	subi	r22, 0xFA	; 250
    2356:	7f 4f       	sbci	r23, 0xFF	; 255
    2358:	ce 01       	movw	r24, r28
    235a:	01 96       	adiw	r24, 0x01	; 1
    235c:	0e 94 aa 16 	call	0x2d54	; 0x2d54 <xTaskCheckForTimeOut>
    2360:	81 11       	cpse	r24, r1
    2362:	2d c0       	rjmp	.+90     	; 0x23be <xQueueGenericReceive+0x160>
    2364:	0f b6       	in	r0, 0x3f	; 63
    2366:	f8 94       	cli
    2368:	0f 92       	push	r0
    236a:	f7 01       	movw	r30, r14
    236c:	86 8d       	ldd	r24, Z+30	; 0x1e
    236e:	0f 90       	pop	r0
    2370:	0f be       	out	0x3f, r0	; 63
    2372:	81 11       	cpse	r24, r1
    2374:	1e c0       	rjmp	.+60     	; 0x23b2 <xQueueGenericReceive+0x154>
    2376:	80 81       	ld	r24, Z
    2378:	91 81       	ldd	r25, Z+1	; 0x01
    237a:	89 2b       	or	r24, r25
    237c:	49 f4       	brne	.+18     	; 0x2390 <xQueueGenericReceive+0x132>
    237e:	0f b6       	in	r0, 0x3f	; 63
    2380:	f8 94       	cli
    2382:	0f 92       	push	r0
    2384:	82 81       	ldd	r24, Z+2	; 0x02
    2386:	93 81       	ldd	r25, Z+3	; 0x03
    2388:	0e 94 39 17 	call	0x2e72	; 0x2e72 <vTaskPriorityInherit>
    238c:	0f 90       	pop	r0
    238e:	0f be       	out	0x3f, r0	; 63
    2390:	4e 81       	ldd	r20, Y+6	; 0x06
    2392:	5f 81       	ldd	r21, Y+7	; 0x07
    2394:	68 85       	ldd	r22, Y+8	; 0x08
    2396:	79 85       	ldd	r23, Y+9	; 0x09
    2398:	c6 01       	movw	r24, r12
    239a:	0e 94 30 16 	call	0x2c60	; 0x2c60 <vTaskPlaceOnEventList>
    239e:	c7 01       	movw	r24, r14
    23a0:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <prvUnlockQueue>
    23a4:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
    23a8:	81 11       	cpse	r24, r1
    23aa:	73 cf       	rjmp	.-282    	; 0x2292 <xQueueGenericReceive+0x34>
    23ac:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
    23b0:	70 cf       	rjmp	.-288    	; 0x2292 <xQueueGenericReceive+0x34>
    23b2:	c7 01       	movw	r24, r14
    23b4:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <prvUnlockQueue>
    23b8:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
    23bc:	6a cf       	rjmp	.-300    	; 0x2292 <xQueueGenericReceive+0x34>
    23be:	c7 01       	movw	r24, r14
    23c0:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <prvUnlockQueue>
    23c4:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
    23c8:	80 e0       	ldi	r24, 0x00	; 0
    23ca:	29 96       	adiw	r28, 0x09	; 9
    23cc:	cd bf       	out	0x3d, r28	; 61
    23ce:	de bf       	out	0x3e, r29	; 62
    23d0:	df 91       	pop	r29
    23d2:	cf 91       	pop	r28
    23d4:	1f 91       	pop	r17
    23d6:	0f 91       	pop	r16
    23d8:	ff 90       	pop	r15
    23da:	ef 90       	pop	r14
    23dc:	df 90       	pop	r13
    23de:	cf 90       	pop	r12
    23e0:	bf 90       	pop	r11
    23e2:	af 90       	pop	r10
    23e4:	08 95       	ret

000023e6 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    23ec:	fc 01       	movw	r30, r24
    23ee:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    23f0:	0f 90       	pop	r0
    23f2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    23f4:	08 95       	ret

000023f6 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    23f6:	c8 ef       	ldi	r28, 0xF8	; 248
    23f8:	d0 e3       	ldi	r29, 0x30	; 48
    23fa:	88 81       	ld	r24, Y
    23fc:	82 30       	cpi	r24, 0x02	; 2
    23fe:	e8 f3       	brcs	.-6      	; 0x23fa <prvIdleTask+0x4>
    2400:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
    2404:	fa cf       	rjmp	.-12     	; 0x23fa <prvIdleTask+0x4>

00002406 <prvAddCurrentTaskToDelayedList>:
    2406:	cf 92       	push	r12
    2408:	df 92       	push	r13
    240a:	ef 92       	push	r14
    240c:	ff 92       	push	r15
    240e:	6b 01       	movw	r12, r22
    2410:	7c 01       	movw	r14, r24
    2412:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2416:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    241a:	62 83       	std	Z+2, r22	; 0x02
    241c:	73 83       	std	Z+3, r23	; 0x03
    241e:	84 83       	std	Z+4, r24	; 0x04
    2420:	95 83       	std	Z+5, r25	; 0x05
    2422:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2426:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    242a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    242e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2432:	c8 16       	cp	r12, r24
    2434:	d9 06       	cpc	r13, r25
    2436:	ea 06       	cpc	r14, r26
    2438:	fb 06       	cpc	r15, r27
    243a:	68 f4       	brcc	.+26     	; 0x2456 <prvAddCurrentTaskToDelayedList+0x50>
    243c:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2440:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2444:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2448:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    244c:	6e 5f       	subi	r22, 0xFE	; 254
    244e:	7f 4f       	sbci	r23, 0xFF	; 255
    2450:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <vListInsert>
    2454:	21 c0       	rjmp	.+66     	; 0x2498 <prvAddCurrentTaskToDelayedList+0x92>
    2456:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    245a:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    245e:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2462:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2466:	6e 5f       	subi	r22, 0xFE	; 254
    2468:	7f 4f       	sbci	r23, 0xFF	; 255
    246a:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <vListInsert>
    246e:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2472:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2476:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    247a:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    247e:	c8 16       	cp	r12, r24
    2480:	d9 06       	cpc	r13, r25
    2482:	ea 06       	cpc	r14, r26
    2484:	fb 06       	cpc	r15, r27
    2486:	40 f4       	brcc	.+16     	; 0x2498 <prvAddCurrentTaskToDelayedList+0x92>
    2488:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    248c:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    2490:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2494:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2498:	ff 90       	pop	r15
    249a:	ef 90       	pop	r14
    249c:	df 90       	pop	r13
    249e:	cf 90       	pop	r12
    24a0:	08 95       	ret

000024a2 <xTaskGenericCreate>:
    24a2:	4f 92       	push	r4
    24a4:	5f 92       	push	r5
    24a6:	6f 92       	push	r6
    24a8:	7f 92       	push	r7
    24aa:	8f 92       	push	r8
    24ac:	9f 92       	push	r9
    24ae:	af 92       	push	r10
    24b0:	bf 92       	push	r11
    24b2:	cf 92       	push	r12
    24b4:	df 92       	push	r13
    24b6:	ef 92       	push	r14
    24b8:	ff 92       	push	r15
    24ba:	0f 93       	push	r16
    24bc:	1f 93       	push	r17
    24be:	cf 93       	push	r28
    24c0:	df 93       	push	r29
    24c2:	5c 01       	movw	r10, r24
    24c4:	4b 01       	movw	r8, r22
    24c6:	3a 01       	movw	r6, r20
    24c8:	29 01       	movw	r4, r18
    24ca:	88 e2       	ldi	r24, 0x28	; 40
    24cc:	90 e0       	ldi	r25, 0x00	; 0
    24ce:	0e 94 80 0c 	call	0x1900	; 0x1900 <pvPortMalloc>
    24d2:	ec 01       	movw	r28, r24
    24d4:	89 2b       	or	r24, r25
    24d6:	09 f4       	brne	.+2      	; 0x24da <xTaskGenericCreate+0x38>
    24d8:	d4 c0       	rjmp	.+424    	; 0x2682 <xTaskGenericCreate+0x1e0>
    24da:	c1 14       	cp	r12, r1
    24dc:	d1 04       	cpc	r13, r1
    24de:	09 f0       	breq	.+2      	; 0x24e2 <xTaskGenericCreate+0x40>
    24e0:	cc c0       	rjmp	.+408    	; 0x267a <xTaskGenericCreate+0x1d8>
    24e2:	c3 01       	movw	r24, r6
    24e4:	0e 94 80 0c 	call	0x1900	; 0x1900 <pvPortMalloc>
    24e8:	8b 8f       	std	Y+27, r24	; 0x1b
    24ea:	9c 8f       	std	Y+28, r25	; 0x1c
    24ec:	00 97       	sbiw	r24, 0x00	; 0
    24ee:	21 f4       	brne	.+8      	; 0x24f8 <xTaskGenericCreate+0x56>
    24f0:	ce 01       	movw	r24, r28
    24f2:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <vPortFree>
    24f6:	c5 c0       	rjmp	.+394    	; 0x2682 <xTaskGenericCreate+0x1e0>
    24f8:	a3 01       	movw	r20, r6
    24fa:	61 e1       	ldi	r22, 0x11	; 17
    24fc:	70 e0       	ldi	r23, 0x00	; 0
    24fe:	0e 94 38 23 	call	0x4670	; 0x4670 <memset>
    2502:	93 01       	movw	r18, r6
    2504:	21 50       	subi	r18, 0x01	; 1
    2506:	31 09       	sbc	r19, r1
    2508:	8b 8d       	ldd	r24, Y+27	; 0x1b
    250a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    250c:	3c 01       	movw	r6, r24
    250e:	62 0e       	add	r6, r18
    2510:	73 1e       	adc	r7, r19
    2512:	4a e0       	ldi	r20, 0x0A	; 10
    2514:	50 e0       	ldi	r21, 0x00	; 0
    2516:	b4 01       	movw	r22, r8
    2518:	ce 01       	movw	r24, r28
    251a:	4d 96       	adiw	r24, 0x1d	; 29
    251c:	0e 94 3f 23 	call	0x467e	; 0x467e <strncpy>
    2520:	1e a2       	std	Y+38, r1	; 0x26
    2522:	10 2f       	mov	r17, r16
    2524:	04 30       	cpi	r16, 0x04	; 4
    2526:	08 f0       	brcs	.+2      	; 0x252a <xTaskGenericCreate+0x88>
    2528:	13 e0       	ldi	r17, 0x03	; 3
    252a:	1a 8f       	std	Y+26, r17	; 0x1a
    252c:	1f a3       	std	Y+39, r17	; 0x27
    252e:	6e 01       	movw	r12, r28
    2530:	22 e0       	ldi	r18, 0x02	; 2
    2532:	c2 0e       	add	r12, r18
    2534:	d1 1c       	adc	r13, r1
    2536:	c6 01       	movw	r24, r12
    2538:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <vListInitialiseItem>
    253c:	ce 01       	movw	r24, r28
    253e:	0e 96       	adiw	r24, 0x0e	; 14
    2540:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <vListInitialiseItem>
    2544:	ca 87       	std	Y+10, r28	; 0x0a
    2546:	db 87       	std	Y+11, r29	; 0x0b
    2548:	84 e0       	ldi	r24, 0x04	; 4
    254a:	90 e0       	ldi	r25, 0x00	; 0
    254c:	a0 e0       	ldi	r26, 0x00	; 0
    254e:	b0 e0       	ldi	r27, 0x00	; 0
    2550:	81 1b       	sub	r24, r17
    2552:	91 09       	sbc	r25, r1
    2554:	a1 09       	sbc	r26, r1
    2556:	b1 09       	sbc	r27, r1
    2558:	8e 87       	std	Y+14, r24	; 0x0e
    255a:	9f 87       	std	Y+15, r25	; 0x0f
    255c:	a8 8b       	std	Y+16, r26	; 0x10
    255e:	b9 8b       	std	Y+17, r27	; 0x11
    2560:	ce 8b       	std	Y+22, r28	; 0x16
    2562:	df 8b       	std	Y+23, r29	; 0x17
    2564:	a2 01       	movw	r20, r4
    2566:	b5 01       	movw	r22, r10
    2568:	c3 01       	movw	r24, r6
    256a:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <pxPortInitialiseStack>
    256e:	88 83       	st	Y, r24
    2570:	99 83       	std	Y+1, r25	; 0x01
    2572:	e1 14       	cp	r14, r1
    2574:	f1 04       	cpc	r15, r1
    2576:	19 f0       	breq	.+6      	; 0x257e <xTaskGenericCreate+0xdc>
    2578:	f7 01       	movw	r30, r14
    257a:	c0 83       	st	Z, r28
    257c:	d1 83       	std	Z+1, r29	; 0x01
    257e:	0f b6       	in	r0, 0x3f	; 63
    2580:	f8 94       	cli
    2582:	0f 92       	push	r0
    2584:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2588:	8f 5f       	subi	r24, 0xFF	; 255
    258a:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    258e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2592:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2596:	89 2b       	or	r24, r25
    2598:	89 f5       	brne	.+98     	; 0x25fc <xTaskGenericCreate+0x15a>
    259a:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    259e:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    25a2:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    25a6:	81 30       	cpi	r24, 0x01	; 1
    25a8:	c1 f5       	brne	.+112    	; 0x261a <xTaskGenericCreate+0x178>
    25aa:	88 ef       	ldi	r24, 0xF8	; 248
    25ac:	90 e3       	ldi	r25, 0x30	; 48
    25ae:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    25b2:	83 e0       	ldi	r24, 0x03	; 3
    25b4:	91 e3       	ldi	r25, 0x31	; 49
    25b6:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    25ba:	8e e0       	ldi	r24, 0x0E	; 14
    25bc:	91 e3       	ldi	r25, 0x31	; 49
    25be:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    25c2:	89 e1       	ldi	r24, 0x19	; 25
    25c4:	91 e3       	ldi	r25, 0x31	; 49
    25c6:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    25ca:	8d ee       	ldi	r24, 0xED	; 237
    25cc:	90 e3       	ldi	r25, 0x30	; 48
    25ce:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    25d2:	82 ee       	ldi	r24, 0xE2	; 226
    25d4:	90 e3       	ldi	r25, 0x30	; 48
    25d6:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    25da:	83 ed       	ldi	r24, 0xD3	; 211
    25dc:	90 e3       	ldi	r25, 0x30	; 48
    25de:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <vListInitialise>
    25e2:	8d ee       	ldi	r24, 0xED	; 237
    25e4:	90 e3       	ldi	r25, 0x30	; 48
    25e6:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    25ea:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    25ee:	82 ee       	ldi	r24, 0xE2	; 226
    25f0:	90 e3       	ldi	r25, 0x30	; 48
    25f2:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    25f6:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    25fa:	0f c0       	rjmp	.+30     	; 0x261a <xTaskGenericCreate+0x178>
    25fc:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    2600:	81 11       	cpse	r24, r1
    2602:	0b c0       	rjmp	.+22     	; 0x261a <xTaskGenericCreate+0x178>
    2604:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2608:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    260c:	82 8d       	ldd	r24, Z+26	; 0x1a
    260e:	08 17       	cp	r16, r24
    2610:	20 f0       	brcs	.+8      	; 0x261a <xTaskGenericCreate+0x178>
    2612:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    2616:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    261a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    261c:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    2620:	98 17       	cp	r25, r24
    2622:	10 f4       	brcc	.+4      	; 0x2628 <xTaskGenericCreate+0x186>
    2624:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    2628:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    262c:	9f 5f       	subi	r25, 0xFF	; 255
    262e:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    2632:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2636:	98 17       	cp	r25, r24
    2638:	10 f4       	brcc	.+4      	; 0x263e <xTaskGenericCreate+0x19c>
    263a:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    263e:	fb e0       	ldi	r31, 0x0B	; 11
    2640:	8f 9f       	mul	r24, r31
    2642:	c0 01       	movw	r24, r0
    2644:	11 24       	eor	r1, r1
    2646:	b6 01       	movw	r22, r12
    2648:	88 50       	subi	r24, 0x08	; 8
    264a:	9f 4c       	sbci	r25, 0xCF	; 207
    264c:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInsertEnd>
    2650:	0f 90       	pop	r0
    2652:	0f be       	out	0x3f, r0	; 63
    2654:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    2658:	88 23       	and	r24, r24
    265a:	59 f0       	breq	.+22     	; 0x2672 <xTaskGenericCreate+0x1d0>
    265c:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2660:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2664:	82 8d       	ldd	r24, Z+26	; 0x1a
    2666:	80 17       	cp	r24, r16
    2668:	30 f4       	brcc	.+12     	; 0x2676 <xTaskGenericCreate+0x1d4>
    266a:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
    266e:	81 e0       	ldi	r24, 0x01	; 1
    2670:	09 c0       	rjmp	.+18     	; 0x2684 <xTaskGenericCreate+0x1e2>
    2672:	81 e0       	ldi	r24, 0x01	; 1
    2674:	07 c0       	rjmp	.+14     	; 0x2684 <xTaskGenericCreate+0x1e2>
    2676:	81 e0       	ldi	r24, 0x01	; 1
    2678:	05 c0       	rjmp	.+10     	; 0x2684 <xTaskGenericCreate+0x1e2>
    267a:	cb 8e       	std	Y+27, r12	; 0x1b
    267c:	dc 8e       	std	Y+28, r13	; 0x1c
    267e:	c6 01       	movw	r24, r12
    2680:	3b cf       	rjmp	.-394    	; 0x24f8 <xTaskGenericCreate+0x56>
    2682:	8f ef       	ldi	r24, 0xFF	; 255
    2684:	df 91       	pop	r29
    2686:	cf 91       	pop	r28
    2688:	1f 91       	pop	r17
    268a:	0f 91       	pop	r16
    268c:	ff 90       	pop	r15
    268e:	ef 90       	pop	r14
    2690:	df 90       	pop	r13
    2692:	cf 90       	pop	r12
    2694:	bf 90       	pop	r11
    2696:	af 90       	pop	r10
    2698:	9f 90       	pop	r9
    269a:	8f 90       	pop	r8
    269c:	7f 90       	pop	r7
    269e:	6f 90       	pop	r6
    26a0:	5f 90       	pop	r5
    26a2:	4f 90       	pop	r4
    26a4:	08 95       	ret

000026a6 <uxTaskPriorityGet>:
    26a6:	0f b6       	in	r0, 0x3f	; 63
    26a8:	f8 94       	cli
    26aa:	0f 92       	push	r0
    26ac:	00 97       	sbiw	r24, 0x00	; 0
    26ae:	21 f4       	brne	.+8      	; 0x26b8 <uxTaskPriorityGet+0x12>
    26b0:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    26b4:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    26b8:	0f 90       	pop	r0
    26ba:	0f be       	out	0x3f, r0	; 63
    26bc:	fc 01       	movw	r30, r24
    26be:	82 8d       	ldd	r24, Z+26	; 0x1a
    26c0:	08 95       	ret

000026c2 <vTaskStartScheduler>:
    26c2:	af 92       	push	r10
    26c4:	bf 92       	push	r11
    26c6:	cf 92       	push	r12
    26c8:	df 92       	push	r13
    26ca:	ef 92       	push	r14
    26cc:	ff 92       	push	r15
    26ce:	0f 93       	push	r16
    26d0:	a1 2c       	mov	r10, r1
    26d2:	b1 2c       	mov	r11, r1
    26d4:	c1 2c       	mov	r12, r1
    26d6:	d1 2c       	mov	r13, r1
    26d8:	0f 2e       	mov	r0, r31
    26da:	f1 ed       	ldi	r31, 0xD1	; 209
    26dc:	ef 2e       	mov	r14, r31
    26de:	f0 e3       	ldi	r31, 0x30	; 48
    26e0:	ff 2e       	mov	r15, r31
    26e2:	f0 2d       	mov	r31, r0
    26e4:	00 e0       	ldi	r16, 0x00	; 0
    26e6:	20 e0       	ldi	r18, 0x00	; 0
    26e8:	30 e0       	ldi	r19, 0x00	; 0
    26ea:	44 e6       	ldi	r20, 0x64	; 100
    26ec:	50 e0       	ldi	r21, 0x00	; 0
    26ee:	6a e3       	ldi	r22, 0x3A	; 58
    26f0:	70 e2       	ldi	r23, 0x20	; 32
    26f2:	8b ef       	ldi	r24, 0xFB	; 251
    26f4:	91 e1       	ldi	r25, 0x11	; 17
    26f6:	0e 94 51 12 	call	0x24a2	; 0x24a2 <xTaskGenericCreate>
    26fa:	81 30       	cpi	r24, 0x01	; 1
    26fc:	69 f4       	brne	.+26     	; 0x2718 <vTaskStartScheduler+0x56>
    26fe:	f8 94       	cli
    2700:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    2704:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    2708:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    270c:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    2710:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    2714:	0e 94 75 0e 	call	0x1cea	; 0x1cea <xPortStartScheduler>
    2718:	0f 91       	pop	r16
    271a:	ff 90       	pop	r15
    271c:	ef 90       	pop	r14
    271e:	df 90       	pop	r13
    2720:	cf 90       	pop	r12
    2722:	bf 90       	pop	r11
    2724:	af 90       	pop	r10
    2726:	08 95       	ret

00002728 <vTaskSuspendAll>:
    2728:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    272c:	8f 5f       	subi	r24, 0xFF	; 255
    272e:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    2732:	08 95       	ret

00002734 <xTaskGetTickCount>:
    2734:	0f b6       	in	r0, 0x3f	; 63
    2736:	f8 94       	cli
    2738:	0f 92       	push	r0
    273a:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    273e:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2742:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2746:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    274a:	0f 90       	pop	r0
    274c:	0f be       	out	0x3f, r0	; 63
    274e:	08 95       	ret

00002750 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2750:	00 97       	sbiw	r24, 0x00	; 0
    2752:	21 f4       	brne	.+8      	; 0x275c <pcTaskGetTaskName+0xc>
    2754:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2758:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    275c:	4d 96       	adiw	r24, 0x1d	; 29
    275e:	08 95       	ret

00002760 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2760:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    2764:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    2768:	08 95       	ret

0000276a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    276a:	ff 92       	push	r15
    276c:	0f 93       	push	r16
    276e:	1f 93       	push	r17
    2770:	cf 93       	push	r28
    2772:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2774:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2778:	81 11       	cpse	r24, r1
    277a:	ed c0       	rjmp	.+474    	; 0x2956 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    277c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2780:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2784:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2788:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    278c:	01 96       	adiw	r24, 0x01	; 1
    278e:	a1 1d       	adc	r26, r1
    2790:	b1 1d       	adc	r27, r1
    2792:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2796:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    279a:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    279e:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    27a2:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    27a6:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    27aa:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    27ae:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    27b2:	89 2b       	or	r24, r25
    27b4:	8a 2b       	or	r24, r26
    27b6:	8b 2b       	or	r24, r27
    27b8:	f1 f5       	brne	.+124    	; 0x2836 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    27ba:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    27be:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    27c2:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    27c6:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    27ca:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    27ce:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    27d2:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    27d6:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    27da:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    27de:	8f 5f       	subi	r24, 0xFF	; 255
    27e0:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    27e4:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    27e8:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    27ec:	80 81       	ld	r24, Z
    27ee:	81 11       	cpse	r24, r1
    27f0:	0c c0       	rjmp	.+24     	; 0x280a <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    27f2:	8f ef       	ldi	r24, 0xFF	; 255
    27f4:	9f ef       	ldi	r25, 0xFF	; 255
    27f6:	dc 01       	movw	r26, r24
    27f8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27fc:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2800:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2804:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2808:	16 c0       	rjmp	.+44     	; 0x2836 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    280a:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    280e:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2812:	07 80       	ldd	r0, Z+7	; 0x07
    2814:	f0 85       	ldd	r31, Z+8	; 0x08
    2816:	e0 2d       	mov	r30, r0
    2818:	00 84       	ldd	r0, Z+8	; 0x08
    281a:	f1 85       	ldd	r31, Z+9	; 0x09
    281c:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    281e:	82 81       	ldd	r24, Z+2	; 0x02
    2820:	93 81       	ldd	r25, Z+3	; 0x03
    2822:	a4 81       	ldd	r26, Z+4	; 0x04
    2824:	b5 81       	ldd	r27, Z+5	; 0x05
    2826:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    282a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    282e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2832:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2836:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    283a:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    283e:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2842:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2846:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    284a:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    284e:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2852:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2856:	48 17       	cp	r20, r24
    2858:	59 07       	cpc	r21, r25
    285a:	6a 07       	cpc	r22, r26
    285c:	7b 07       	cpc	r23, r27
    285e:	08 f4       	brcc	.+2      	; 0x2862 <vTaskIncrementTick+0xf8>
    2860:	7f c0       	rjmp	.+254    	; 0x2960 <vTaskIncrementTick+0x1f6>
    2862:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2866:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    286a:	80 81       	ld	r24, Z
    286c:	88 23       	and	r24, r24
    286e:	f9 f0       	breq	.+62     	; 0x28ae <vTaskIncrementTick+0x144>
    2870:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2874:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2878:	07 80       	ldd	r0, Z+7	; 0x07
    287a:	f0 85       	ldd	r31, Z+8	; 0x08
    287c:	e0 2d       	mov	r30, r0
    287e:	c0 85       	ldd	r28, Z+8	; 0x08
    2880:	d1 85       	ldd	r29, Z+9	; 0x09
    2882:	8a 81       	ldd	r24, Y+2	; 0x02
    2884:	9b 81       	ldd	r25, Y+3	; 0x03
    2886:	ac 81       	ldd	r26, Y+4	; 0x04
    2888:	bd 81       	ldd	r27, Y+5	; 0x05
    288a:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    288e:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2892:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2896:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    289a:	48 17       	cp	r20, r24
    289c:	59 07       	cpc	r21, r25
    289e:	6a 07       	cpc	r22, r26
    28a0:	7b 07       	cpc	r23, r27
    28a2:	58 f1       	brcs	.+86     	; 0x28fa <vTaskIncrementTick+0x190>
    28a4:	0f 2e       	mov	r0, r31
    28a6:	fb e0       	ldi	r31, 0x0B	; 11
    28a8:	ff 2e       	mov	r15, r31
    28aa:	f0 2d       	mov	r31, r0
    28ac:	2f c0       	rjmp	.+94     	; 0x290c <vTaskIncrementTick+0x1a2>
    28ae:	8f ef       	ldi	r24, 0xFF	; 255
    28b0:	9f ef       	ldi	r25, 0xFF	; 255
    28b2:	dc 01       	movw	r26, r24
    28b4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    28b8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    28bc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    28c0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    28c4:	4d c0       	rjmp	.+154    	; 0x2960 <vTaskIncrementTick+0x1f6>
    28c6:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    28ca:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    28ce:	07 80       	ldd	r0, Z+7	; 0x07
    28d0:	f0 85       	ldd	r31, Z+8	; 0x08
    28d2:	e0 2d       	mov	r30, r0
    28d4:	c0 85       	ldd	r28, Z+8	; 0x08
    28d6:	d1 85       	ldd	r29, Z+9	; 0x09
    28d8:	8a 81       	ldd	r24, Y+2	; 0x02
    28da:	9b 81       	ldd	r25, Y+3	; 0x03
    28dc:	ac 81       	ldd	r26, Y+4	; 0x04
    28de:	bd 81       	ldd	r27, Y+5	; 0x05
    28e0:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    28e4:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    28e8:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    28ec:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    28f0:	48 17       	cp	r20, r24
    28f2:	59 07       	cpc	r21, r25
    28f4:	6a 07       	cpc	r22, r26
    28f6:	7b 07       	cpc	r23, r27
    28f8:	48 f4       	brcc	.+18     	; 0x290c <vTaskIncrementTick+0x1a2>
    28fa:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    28fe:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2902:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2906:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    290a:	2a c0       	rjmp	.+84     	; 0x2960 <vTaskIncrementTick+0x1f6>
    290c:	8e 01       	movw	r16, r28
    290e:	0e 5f       	subi	r16, 0xFE	; 254
    2910:	1f 4f       	sbci	r17, 0xFF	; 255
    2912:	c8 01       	movw	r24, r16
    2914:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>
    2918:	88 8d       	ldd	r24, Y+24	; 0x18
    291a:	99 8d       	ldd	r25, Y+25	; 0x19
    291c:	89 2b       	or	r24, r25
    291e:	21 f0       	breq	.+8      	; 0x2928 <vTaskIncrementTick+0x1be>
    2920:	ce 01       	movw	r24, r28
    2922:	0e 96       	adiw	r24, 0x0e	; 14
    2924:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>
    2928:	8a 8d       	ldd	r24, Y+26	; 0x1a
    292a:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    292e:	98 17       	cp	r25, r24
    2930:	10 f4       	brcc	.+4      	; 0x2936 <vTaskIncrementTick+0x1cc>
    2932:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2936:	f8 9e       	mul	r15, r24
    2938:	c0 01       	movw	r24, r0
    293a:	11 24       	eor	r1, r1
    293c:	b8 01       	movw	r22, r16
    293e:	88 50       	subi	r24, 0x08	; 8
    2940:	9f 4c       	sbci	r25, 0xCF	; 207
    2942:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInsertEnd>
    2946:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    294a:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    294e:	80 81       	ld	r24, Z
    2950:	81 11       	cpse	r24, r1
    2952:	b9 cf       	rjmp	.-142    	; 0x28c6 <vTaskIncrementTick+0x15c>
    2954:	ac cf       	rjmp	.-168    	; 0x28ae <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    2956:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    295a:	8f 5f       	subi	r24, 0xFF	; 255
    295c:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2960:	df 91       	pop	r29
    2962:	cf 91       	pop	r28
    2964:	1f 91       	pop	r17
    2966:	0f 91       	pop	r16
    2968:	ff 90       	pop	r15
    296a:	08 95       	ret

0000296c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    296c:	cf 92       	push	r12
    296e:	df 92       	push	r13
    2970:	ef 92       	push	r14
    2972:	ff 92       	push	r15
    2974:	0f 93       	push	r16
    2976:	1f 93       	push	r17
    2978:	cf 93       	push	r28
    297a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    297c:	0f b6       	in	r0, 0x3f	; 63
    297e:	f8 94       	cli
    2980:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2982:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2986:	81 50       	subi	r24, 0x01	; 1
    2988:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    298c:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2990:	81 11       	cpse	r24, r1
    2992:	60 c0       	rjmp	.+192    	; 0x2a54 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2994:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2998:	81 11       	cpse	r24, r1
    299a:	2c c0       	rjmp	.+88     	; 0x29f4 <xTaskResumeAll+0x88>
    299c:	5e c0       	rjmp	.+188    	; 0x2a5a <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    299e:	d7 01       	movw	r26, r14
    29a0:	17 96       	adiw	r26, 0x07	; 7
    29a2:	ed 91       	ld	r30, X+
    29a4:	fc 91       	ld	r31, X
    29a6:	18 97       	sbiw	r26, 0x08	; 8
    29a8:	c0 85       	ldd	r28, Z+8	; 0x08
    29aa:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    29ac:	ce 01       	movw	r24, r28
    29ae:	0e 96       	adiw	r24, 0x0e	; 14
    29b0:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    29b4:	8e 01       	movw	r16, r28
    29b6:	0e 5f       	subi	r16, 0xFE	; 254
    29b8:	1f 4f       	sbci	r17, 0xFF	; 255
    29ba:	c8 01       	movw	r24, r16
    29bc:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    29c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29c2:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    29c6:	98 17       	cp	r25, r24
    29c8:	10 f4       	brcc	.+4      	; 0x29ce <xTaskResumeAll+0x62>
    29ca:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    29ce:	d8 9e       	mul	r13, r24
    29d0:	c0 01       	movw	r24, r0
    29d2:	11 24       	eor	r1, r1
    29d4:	b8 01       	movw	r22, r16
    29d6:	88 50       	subi	r24, 0x08	; 8
    29d8:	9f 4c       	sbci	r25, 0xCF	; 207
    29da:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    29de:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    29e2:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    29e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    29e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    29ea:	98 17       	cp	r25, r24
    29ec:	70 f0       	brcs	.+28     	; 0x2a0a <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    29ee:	cc 24       	eor	r12, r12
    29f0:	c3 94       	inc	r12
    29f2:	0b c0       	rjmp	.+22     	; 0x2a0a <xTaskResumeAll+0x9e>
    29f4:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    29f6:	0f 2e       	mov	r0, r31
    29f8:	f3 ed       	ldi	r31, 0xD3	; 211
    29fa:	ef 2e       	mov	r14, r31
    29fc:	f0 e3       	ldi	r31, 0x30	; 48
    29fe:	ff 2e       	mov	r15, r31
    2a00:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2a02:	0f 2e       	mov	r0, r31
    2a04:	fb e0       	ldi	r31, 0x0B	; 11
    2a06:	df 2e       	mov	r13, r31
    2a08:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2a0a:	f7 01       	movw	r30, r14
    2a0c:	80 81       	ld	r24, Z
    2a0e:	81 11       	cpse	r24, r1
    2a10:	c6 cf       	rjmp	.-116    	; 0x299e <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2a12:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2a16:	88 23       	and	r24, r24
    2a18:	81 f0       	breq	.+32     	; 0x2a3a <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2a1a:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2a1e:	88 23       	and	r24, r24
    2a20:	99 f0       	breq	.+38     	; 0x2a48 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2a22:	0e 94 b5 13 	call	0x276a	; 0x276a <vTaskIncrementTick>
						--uxMissedTicks;
    2a26:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2a2a:	81 50       	subi	r24, 0x01	; 1
    2a2c:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2a30:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2a34:	81 11       	cpse	r24, r1
    2a36:	f5 cf       	rjmp	.-22     	; 0x2a22 <xTaskResumeAll+0xb6>
    2a38:	07 c0       	rjmp	.+14     	; 0x2a48 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2a3a:	f1 e0       	ldi	r31, 0x01	; 1
    2a3c:	cf 16       	cp	r12, r31
    2a3e:	21 f0       	breq	.+8      	; 0x2a48 <xTaskResumeAll+0xdc>
    2a40:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    2a44:	81 30       	cpi	r24, 0x01	; 1
    2a46:	41 f4       	brne	.+16     	; 0x2a58 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2a48:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    2a4c:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2a50:	81 e0       	ldi	r24, 0x01	; 1
    2a52:	03 c0       	rjmp	.+6      	; 0x2a5a <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2a54:	80 e0       	ldi	r24, 0x00	; 0
    2a56:	01 c0       	rjmp	.+2      	; 0x2a5a <xTaskResumeAll+0xee>
    2a58:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2a5a:	0f 90       	pop	r0
    2a5c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2a5e:	df 91       	pop	r29
    2a60:	cf 91       	pop	r28
    2a62:	1f 91       	pop	r17
    2a64:	0f 91       	pop	r16
    2a66:	ff 90       	pop	r15
    2a68:	ef 90       	pop	r14
    2a6a:	df 90       	pop	r13
    2a6c:	cf 90       	pop	r12
    2a6e:	08 95       	ret

00002a70 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2a70:	cf 92       	push	r12
    2a72:	df 92       	push	r13
    2a74:	ef 92       	push	r14
    2a76:	ff 92       	push	r15
    2a78:	cf 93       	push	r28
    2a7a:	df 93       	push	r29
    2a7c:	ec 01       	movw	r28, r24
    2a7e:	6a 01       	movw	r12, r20
    2a80:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2a82:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a86:	88 81       	ld	r24, Y
    2a88:	99 81       	ldd	r25, Y+1	; 0x01
    2a8a:	aa 81       	ldd	r26, Y+2	; 0x02
    2a8c:	bb 81       	ldd	r27, Y+3	; 0x03
    2a8e:	c8 0e       	add	r12, r24
    2a90:	d9 1e       	adc	r13, r25
    2a92:	ea 1e       	adc	r14, r26
    2a94:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2a96:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2a9a:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2a9e:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2aa2:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2aa6:	48 17       	cp	r20, r24
    2aa8:	59 07       	cpc	r21, r25
    2aaa:	6a 07       	cpc	r22, r26
    2aac:	7b 07       	cpc	r23, r27
    2aae:	b8 f4       	brcc	.+46     	; 0x2ade <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2ab0:	c8 16       	cp	r12, r24
    2ab2:	d9 06       	cpc	r13, r25
    2ab4:	ea 06       	cpc	r14, r26
    2ab6:	fb 06       	cpc	r15, r27
    2ab8:	e0 f5       	brcc	.+120    	; 0x2b32 <vTaskDelayUntil+0xc2>
    2aba:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2abe:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2ac2:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2ac6:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2aca:	c8 82       	st	Y, r12
    2acc:	d9 82       	std	Y+1, r13	; 0x01
    2ace:	ea 82       	std	Y+2, r14	; 0x02
    2ad0:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2ad2:	8c 15       	cp	r24, r12
    2ad4:	9d 05       	cpc	r25, r13
    2ad6:	ae 05       	cpc	r26, r14
    2ad8:	bf 05       	cpc	r27, r15
    2ada:	f8 f4       	brcc	.+62     	; 0x2b1a <vTaskDelayUntil+0xaa>
    2adc:	13 c0       	rjmp	.+38     	; 0x2b04 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2ade:	c8 16       	cp	r12, r24
    2ae0:	d9 06       	cpc	r13, r25
    2ae2:	ea 06       	cpc	r14, r26
    2ae4:	fb 06       	cpc	r15, r27
    2ae6:	00 f1       	brcs	.+64     	; 0x2b28 <vTaskDelayUntil+0xb8>
    2ae8:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2aec:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2af0:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2af4:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2af8:	8c 15       	cp	r24, r12
    2afa:	9d 05       	cpc	r25, r13
    2afc:	ae 05       	cpc	r26, r14
    2afe:	bf 05       	cpc	r27, r15
    2b00:	98 f0       	brcs	.+38     	; 0x2b28 <vTaskDelayUntil+0xb8>
    2b02:	17 c0       	rjmp	.+46     	; 0x2b32 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b04:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2b08:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2b0c:	02 96       	adiw	r24, 0x02	; 2
    2b0e:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b12:	c7 01       	movw	r24, r14
    2b14:	b6 01       	movw	r22, r12
    2b16:	0e 94 03 12 	call	0x2406	; 0x2406 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2b1a:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b1e:	81 11       	cpse	r24, r1
    2b20:	0d c0       	rjmp	.+26     	; 0x2b3c <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2b22:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
		}
	}
    2b26:	0a c0       	rjmp	.+20     	; 0x2b3c <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2b28:	c8 82       	st	Y, r12
    2b2a:	d9 82       	std	Y+1, r13	; 0x01
    2b2c:	ea 82       	std	Y+2, r14	; 0x02
    2b2e:	fb 82       	std	Y+3, r15	; 0x03
    2b30:	e9 cf       	rjmp	.-46     	; 0x2b04 <vTaskDelayUntil+0x94>
    2b32:	c8 82       	st	Y, r12
    2b34:	d9 82       	std	Y+1, r13	; 0x01
    2b36:	ea 82       	std	Y+2, r14	; 0x02
    2b38:	fb 82       	std	Y+3, r15	; 0x03
    2b3a:	ef cf       	rjmp	.-34     	; 0x2b1a <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2b3c:	df 91       	pop	r29
    2b3e:	cf 91       	pop	r28
    2b40:	ff 90       	pop	r15
    2b42:	ef 90       	pop	r14
    2b44:	df 90       	pop	r13
    2b46:	cf 90       	pop	r12
    2b48:	08 95       	ret

00002b4a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2b4a:	cf 92       	push	r12
    2b4c:	df 92       	push	r13
    2b4e:	ef 92       	push	r14
    2b50:	ff 92       	push	r15
    2b52:	6b 01       	movw	r12, r22
    2b54:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2b56:	67 2b       	or	r22, r23
    2b58:	68 2b       	or	r22, r24
    2b5a:	69 2b       	or	r22, r25
    2b5c:	e9 f0       	breq	.+58     	; 0x2b98 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2b5e:	0e 94 94 13 	call	0x2728	; 0x2728 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2b62:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2b66:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2b6a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2b6e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2b72:	c8 0e       	add	r12, r24
    2b74:	d9 1e       	adc	r13, r25
    2b76:	ea 1e       	adc	r14, r26
    2b78:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b7a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2b7e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2b82:	02 96       	adiw	r24, 0x02	; 2
    2b84:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b88:	c7 01       	movw	r24, r14
    2b8a:	b6 01       	movw	r22, r12
    2b8c:	0e 94 03 12 	call	0x2406	; 0x2406 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b90:	0e 94 b6 14 	call	0x296c	; 0x296c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b94:	81 11       	cpse	r24, r1
    2b96:	02 c0       	rjmp	.+4      	; 0x2b9c <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2b98:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vPortYield>
		}
	}
    2b9c:	ff 90       	pop	r15
    2b9e:	ef 90       	pop	r14
    2ba0:	df 90       	pop	r13
    2ba2:	cf 90       	pop	r12
    2ba4:	08 95       	ret

00002ba6 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2ba6:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2baa:	81 11       	cpse	r24, r1
    2bac:	0c c0       	rjmp	.+24     	; 0x2bc6 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2bae:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2bb2:	4b e0       	ldi	r20, 0x0B	; 11
    2bb4:	e4 9f       	mul	r30, r20
    2bb6:	f0 01       	movw	r30, r0
    2bb8:	11 24       	eor	r1, r1
    2bba:	e8 50       	subi	r30, 0x08	; 8
    2bbc:	ff 4c       	sbci	r31, 0xCF	; 207
    2bbe:	80 81       	ld	r24, Z
    2bc0:	88 23       	and	r24, r24
    2bc2:	29 f0       	breq	.+10     	; 0x2bce <vTaskSwitchContext+0x28>
    2bc4:	14 c0       	rjmp	.+40     	; 0x2bee <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2bc6:	81 e0       	ldi	r24, 0x01	; 1
    2bc8:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2bcc:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2bce:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2bd0:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2bd4:	81 50       	subi	r24, 0x01	; 1
    2bd6:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2bda:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2bde:	9e 9f       	mul	r25, r30
    2be0:	f0 01       	movw	r30, r0
    2be2:	11 24       	eor	r1, r1
    2be4:	e8 50       	subi	r30, 0x08	; 8
    2be6:	ff 4c       	sbci	r31, 0xCF	; 207
    2be8:	80 81       	ld	r24, Z
    2bea:	88 23       	and	r24, r24
    2bec:	89 f3       	breq	.-30     	; 0x2bd0 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2bee:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2bf2:	28 2f       	mov	r18, r24
    2bf4:	30 e0       	ldi	r19, 0x00	; 0
    2bf6:	4b e0       	ldi	r20, 0x0B	; 11
    2bf8:	84 9f       	mul	r24, r20
    2bfa:	c0 01       	movw	r24, r0
    2bfc:	11 24       	eor	r1, r1
    2bfe:	dc 01       	movw	r26, r24
    2c00:	a8 50       	subi	r26, 0x08	; 8
    2c02:	bf 4c       	sbci	r27, 0xCF	; 207
    2c04:	11 96       	adiw	r26, 0x01	; 1
    2c06:	ed 91       	ld	r30, X+
    2c08:	fc 91       	ld	r31, X
    2c0a:	12 97       	sbiw	r26, 0x02	; 2
    2c0c:	04 80       	ldd	r0, Z+4	; 0x04
    2c0e:	f5 81       	ldd	r31, Z+5	; 0x05
    2c10:	e0 2d       	mov	r30, r0
    2c12:	11 96       	adiw	r26, 0x01	; 1
    2c14:	ed 93       	st	X+, r30
    2c16:	fc 93       	st	X, r31
    2c18:	12 97       	sbiw	r26, 0x02	; 2
    2c1a:	85 50       	subi	r24, 0x05	; 5
    2c1c:	9f 4c       	sbci	r25, 0xCF	; 207
    2c1e:	e8 17       	cp	r30, r24
    2c20:	f9 07       	cpc	r31, r25
    2c22:	61 f4       	brne	.+24     	; 0x2c3c <vTaskSwitchContext+0x96>
    2c24:	84 81       	ldd	r24, Z+4	; 0x04
    2c26:	95 81       	ldd	r25, Z+5	; 0x05
    2c28:	4b e0       	ldi	r20, 0x0B	; 11
    2c2a:	42 9f       	mul	r20, r18
    2c2c:	f0 01       	movw	r30, r0
    2c2e:	43 9f       	mul	r20, r19
    2c30:	f0 0d       	add	r31, r0
    2c32:	11 24       	eor	r1, r1
    2c34:	e8 50       	subi	r30, 0x08	; 8
    2c36:	ff 4c       	sbci	r31, 0xCF	; 207
    2c38:	81 83       	std	Z+1, r24	; 0x01
    2c3a:	92 83       	std	Z+2, r25	; 0x02
    2c3c:	8b e0       	ldi	r24, 0x0B	; 11
    2c3e:	82 9f       	mul	r24, r18
    2c40:	f0 01       	movw	r30, r0
    2c42:	83 9f       	mul	r24, r19
    2c44:	f0 0d       	add	r31, r0
    2c46:	11 24       	eor	r1, r1
    2c48:	e8 50       	subi	r30, 0x08	; 8
    2c4a:	ff 4c       	sbci	r31, 0xCF	; 207
    2c4c:	01 80       	ldd	r0, Z+1	; 0x01
    2c4e:	f2 81       	ldd	r31, Z+2	; 0x02
    2c50:	e0 2d       	mov	r30, r0
    2c52:	80 85       	ldd	r24, Z+8	; 0x08
    2c54:	91 85       	ldd	r25, Z+9	; 0x09
    2c56:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    2c5a:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    2c5e:	08 95       	ret

00002c60 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2c60:	cf 92       	push	r12
    2c62:	df 92       	push	r13
    2c64:	ef 92       	push	r14
    2c66:	ff 92       	push	r15
    2c68:	6a 01       	movw	r12, r20
    2c6a:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2c6c:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2c70:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2c74:	62 5f       	subi	r22, 0xF2	; 242
    2c76:	7f 4f       	sbci	r23, 0xFF	; 255
    2c78:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c7c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2c80:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2c84:	02 96       	adiw	r24, 0x02	; 2
    2c86:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2c8a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2c8e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2c92:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2c96:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2c9a:	bc 01       	movw	r22, r24
    2c9c:	cd 01       	movw	r24, r26
    2c9e:	6c 0d       	add	r22, r12
    2ca0:	7d 1d       	adc	r23, r13
    2ca2:	8e 1d       	adc	r24, r14
    2ca4:	9f 1d       	adc	r25, r15
    2ca6:	0e 94 03 12 	call	0x2406	; 0x2406 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2caa:	ff 90       	pop	r15
    2cac:	ef 90       	pop	r14
    2cae:	df 90       	pop	r13
    2cb0:	cf 90       	pop	r12
    2cb2:	08 95       	ret

00002cb4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2cb4:	0f 93       	push	r16
    2cb6:	1f 93       	push	r17
    2cb8:	cf 93       	push	r28
    2cba:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2cbc:	dc 01       	movw	r26, r24
    2cbe:	17 96       	adiw	r26, 0x07	; 7
    2cc0:	ed 91       	ld	r30, X+
    2cc2:	fc 91       	ld	r31, X
    2cc4:	18 97       	sbiw	r26, 0x08	; 8
    2cc6:	c0 85       	ldd	r28, Z+8	; 0x08
    2cc8:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2cca:	8e 01       	movw	r16, r28
    2ccc:	02 5f       	subi	r16, 0xF2	; 242
    2cce:	1f 4f       	sbci	r17, 0xFF	; 255
    2cd0:	c8 01       	movw	r24, r16
    2cd2:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2cd6:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2cda:	81 11       	cpse	r24, r1
    2cdc:	16 c0       	rjmp	.+44     	; 0x2d0a <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2cde:	0c 50       	subi	r16, 0x0C	; 12
    2ce0:	11 09       	sbc	r17, r1
    2ce2:	c8 01       	movw	r24, r16
    2ce4:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2ce8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2cea:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2cee:	98 17       	cp	r25, r24
    2cf0:	10 f4       	brcc	.+4      	; 0x2cf6 <xTaskRemoveFromEventList+0x42>
    2cf2:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2cf6:	bb e0       	ldi	r27, 0x0B	; 11
    2cf8:	8b 9f       	mul	r24, r27
    2cfa:	c0 01       	movw	r24, r0
    2cfc:	11 24       	eor	r1, r1
    2cfe:	b8 01       	movw	r22, r16
    2d00:	88 50       	subi	r24, 0x08	; 8
    2d02:	9f 4c       	sbci	r25, 0xCF	; 207
    2d04:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInsertEnd>
    2d08:	05 c0       	rjmp	.+10     	; 0x2d14 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2d0a:	b8 01       	movw	r22, r16
    2d0c:	83 ed       	ldi	r24, 0xD3	; 211
    2d0e:	90 e3       	ldi	r25, 0x30	; 48
    2d10:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2d14:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2d18:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2d1c:	81 e0       	ldi	r24, 0x01	; 1
    2d1e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2d20:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d22:	29 17       	cp	r18, r25
    2d24:	08 f4       	brcc	.+2      	; 0x2d28 <xTaskRemoveFromEventList+0x74>
    2d26:	80 e0       	ldi	r24, 0x00	; 0
}
    2d28:	df 91       	pop	r29
    2d2a:	cf 91       	pop	r28
    2d2c:	1f 91       	pop	r17
    2d2e:	0f 91       	pop	r16
    2d30:	08 95       	ret

00002d32 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2d32:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2d36:	fc 01       	movw	r30, r24
    2d38:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2d3a:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2d3e:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2d42:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d46:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2d4a:	41 83       	std	Z+1, r20	; 0x01
    2d4c:	52 83       	std	Z+2, r21	; 0x02
    2d4e:	63 83       	std	Z+3, r22	; 0x03
    2d50:	74 83       	std	Z+4, r23	; 0x04
    2d52:	08 95       	ret

00002d54 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2d54:	8f 92       	push	r8
    2d56:	9f 92       	push	r9
    2d58:	af 92       	push	r10
    2d5a:	bf 92       	push	r11
    2d5c:	cf 92       	push	r12
    2d5e:	df 92       	push	r13
    2d60:	ef 92       	push	r14
    2d62:	ff 92       	push	r15
    2d64:	0f 93       	push	r16
    2d66:	1f 93       	push	r17
    2d68:	cf 93       	push	r28
    2d6a:	df 93       	push	r29
    2d6c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2d6e:	0f b6       	in	r0, 0x3f	; 63
    2d70:	f8 94       	cli
    2d72:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2d74:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2d78:	90 81       	ld	r25, Z
    2d7a:	98 17       	cp	r25, r24
    2d7c:	89 f0       	breq	.+34     	; 0x2da0 <xTaskCheckForTimeOut+0x4c>
    2d7e:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2d82:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2d86:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d8a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2d8e:	01 81       	ldd	r16, Z+1	; 0x01
    2d90:	12 81       	ldd	r17, Z+2	; 0x02
    2d92:	23 81       	ldd	r18, Z+3	; 0x03
    2d94:	34 81       	ldd	r19, Z+4	; 0x04
    2d96:	80 17       	cp	r24, r16
    2d98:	91 07       	cpc	r25, r17
    2d9a:	a2 07       	cpc	r26, r18
    2d9c:	b3 07       	cpc	r27, r19
    2d9e:	a8 f5       	brcc	.+106    	; 0x2e0a <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2da0:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2da4:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2da8:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2dac:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2db0:	c1 80       	ldd	r12, Z+1	; 0x01
    2db2:	d2 80       	ldd	r13, Z+2	; 0x02
    2db4:	e3 80       	ldd	r14, Z+3	; 0x03
    2db6:	f4 80       	ldd	r15, Z+4	; 0x04
    2db8:	eb 01       	movw	r28, r22
    2dba:	08 81       	ld	r16, Y
    2dbc:	19 81       	ldd	r17, Y+1	; 0x01
    2dbe:	2a 81       	ldd	r18, Y+2	; 0x02
    2dc0:	3b 81       	ldd	r19, Y+3	; 0x03
    2dc2:	8c 19       	sub	r24, r12
    2dc4:	9d 09       	sbc	r25, r13
    2dc6:	ae 09       	sbc	r26, r14
    2dc8:	bf 09       	sbc	r27, r15
    2dca:	80 17       	cp	r24, r16
    2dcc:	91 07       	cpc	r25, r17
    2dce:	a2 07       	cpc	r26, r18
    2dd0:	b3 07       	cpc	r27, r19
    2dd2:	e8 f4       	brcc	.+58     	; 0x2e0e <xTaskCheckForTimeOut+0xba>
    2dd4:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2dd6:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    2dda:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2dde:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2de2:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2de6:	b5 01       	movw	r22, r10
    2de8:	a4 01       	movw	r20, r8
    2dea:	4c 19       	sub	r20, r12
    2dec:	5d 09       	sbc	r21, r13
    2dee:	6e 09       	sbc	r22, r14
    2df0:	7f 09       	sbc	r23, r15
    2df2:	04 1b       	sub	r16, r20
    2df4:	15 0b       	sbc	r17, r21
    2df6:	26 0b       	sbc	r18, r22
    2df8:	37 0b       	sbc	r19, r23
    2dfa:	08 83       	st	Y, r16
    2dfc:	19 83       	std	Y+1, r17	; 0x01
    2dfe:	2a 83       	std	Y+2, r18	; 0x02
    2e00:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2e02:	0e 94 99 16 	call	0x2d32	; 0x2d32 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2e06:	80 e0       	ldi	r24, 0x00	; 0
    2e08:	03 c0       	rjmp	.+6      	; 0x2e10 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2e0a:	81 e0       	ldi	r24, 0x01	; 1
    2e0c:	01 c0       	rjmp	.+2      	; 0x2e10 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2e0e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2e10:	0f 90       	pop	r0
    2e12:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2e14:	df 91       	pop	r29
    2e16:	cf 91       	pop	r28
    2e18:	1f 91       	pop	r17
    2e1a:	0f 91       	pop	r16
    2e1c:	ff 90       	pop	r15
    2e1e:	ef 90       	pop	r14
    2e20:	df 90       	pop	r13
    2e22:	cf 90       	pop	r12
    2e24:	bf 90       	pop	r11
    2e26:	af 90       	pop	r10
    2e28:	9f 90       	pop	r9
    2e2a:	8f 90       	pop	r8
    2e2c:	08 95       	ret

00002e2e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2e2e:	81 e0       	ldi	r24, 0x01	; 1
    2e30:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2e34:	08 95       	ret

00002e36 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2e36:	00 97       	sbiw	r24, 0x00	; 0
    2e38:	21 f4       	brne	.+8      	; 0x2e42 <uxTaskGetStackHighWaterMark+0xc>
    2e3a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2e3e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2e42:	dc 01       	movw	r26, r24
    2e44:	5b 96       	adiw	r26, 0x1b	; 27
    2e46:	ed 91       	ld	r30, X+
    2e48:	fc 91       	ld	r31, X
    2e4a:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e4c:	80 81       	ld	r24, Z
    2e4e:	81 31       	cpi	r24, 0x11	; 17
    2e50:	41 f4       	brne	.+16     	; 0x2e62 <uxTaskGetStackHighWaterMark+0x2c>
    2e52:	31 96       	adiw	r30, 0x01	; 1
    2e54:	80 e0       	ldi	r24, 0x00	; 0
    2e56:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2e58:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e5a:	21 91       	ld	r18, Z+
    2e5c:	21 31       	cpi	r18, 0x11	; 17
    2e5e:	e1 f3       	breq	.-8      	; 0x2e58 <uxTaskGetStackHighWaterMark+0x22>
    2e60:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2e62:	80 e0       	ldi	r24, 0x00	; 0
    2e64:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2e66:	08 95       	ret

00002e68 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2e68:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2e6c:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2e70:	08 95       	ret

00002e72 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2e72:	0f 93       	push	r16
    2e74:	1f 93       	push	r17
    2e76:	cf 93       	push	r28
    2e78:	df 93       	push	r29
    2e7a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2e7c:	22 8d       	ldd	r18, Z+26	; 0x1a
    2e7e:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2e82:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2e86:	5a 96       	adiw	r26, 0x1a	; 26
    2e88:	8c 91       	ld	r24, X
    2e8a:	28 17       	cp	r18, r24
    2e8c:	08 f0       	brcs	.+2      	; 0x2e90 <vTaskPriorityInherit+0x1e>
    2e8e:	41 c0       	rjmp	.+130    	; 0x2f12 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2e90:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2e94:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2e98:	5a 96       	adiw	r26, 0x1a	; 26
    2e9a:	3c 91       	ld	r19, X
    2e9c:	84 e0       	ldi	r24, 0x04	; 4
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
    2ea0:	a0 e0       	ldi	r26, 0x00	; 0
    2ea2:	b0 e0       	ldi	r27, 0x00	; 0
    2ea4:	83 1b       	sub	r24, r19
    2ea6:	91 09       	sbc	r25, r1
    2ea8:	a1 09       	sbc	r26, r1
    2eaa:	b1 09       	sbc	r27, r1
    2eac:	86 87       	std	Z+14, r24	; 0x0e
    2eae:	97 87       	std	Z+15, r25	; 0x0f
    2eb0:	a0 8b       	std	Z+16, r26	; 0x10
    2eb2:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2eb4:	8b e0       	ldi	r24, 0x0B	; 11
    2eb6:	28 9f       	mul	r18, r24
    2eb8:	90 01       	movw	r18, r0
    2eba:	11 24       	eor	r1, r1
    2ebc:	28 50       	subi	r18, 0x08	; 8
    2ebe:	3f 4c       	sbci	r19, 0xCF	; 207
    2ec0:	84 85       	ldd	r24, Z+12	; 0x0c
    2ec2:	95 85       	ldd	r25, Z+13	; 0x0d
    2ec4:	82 17       	cp	r24, r18
    2ec6:	93 07       	cpc	r25, r19
    2ec8:	e9 f4       	brne	.+58     	; 0x2f04 <vTaskPriorityInherit+0x92>
    2eca:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2ecc:	ef 01       	movw	r28, r30
    2ece:	22 96       	adiw	r28, 0x02	; 2
    2ed0:	ce 01       	movw	r24, r28
    2ed2:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2ed6:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2eda:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2ede:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ee0:	f8 01       	movw	r30, r16
    2ee2:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2ee4:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2ee8:	98 17       	cp	r25, r24
    2eea:	10 f4       	brcc	.+4      	; 0x2ef0 <vTaskPriorityInherit+0x7e>
    2eec:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2ef0:	fb e0       	ldi	r31, 0x0B	; 11
    2ef2:	8f 9f       	mul	r24, r31
    2ef4:	c0 01       	movw	r24, r0
    2ef6:	11 24       	eor	r1, r1
    2ef8:	be 01       	movw	r22, r28
    2efa:	88 50       	subi	r24, 0x08	; 8
    2efc:	9f 4c       	sbci	r25, 0xCF	; 207
    2efe:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInsertEnd>
    2f02:	07 c0       	rjmp	.+14     	; 0x2f12 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2f04:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2f08:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2f0c:	5a 96       	adiw	r26, 0x1a	; 26
    2f0e:	8c 91       	ld	r24, X
    2f10:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2f12:	df 91       	pop	r29
    2f14:	cf 91       	pop	r28
    2f16:	1f 91       	pop	r17
    2f18:	0f 91       	pop	r16
    2f1a:	08 95       	ret

00002f1c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2f1c:	0f 93       	push	r16
    2f1e:	1f 93       	push	r17
    2f20:	cf 93       	push	r28
    2f22:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2f24:	00 97       	sbiw	r24, 0x00	; 0
    2f26:	49 f1       	breq	.+82     	; 0x2f7a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2f28:	fc 01       	movw	r30, r24
    2f2a:	32 8d       	ldd	r19, Z+26	; 0x1a
    2f2c:	27 a1       	ldd	r18, Z+39	; 0x27
    2f2e:	32 17       	cp	r19, r18
    2f30:	21 f1       	breq	.+72     	; 0x2f7a <vTaskPriorityDisinherit+0x5e>
    2f32:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2f34:	8c 01       	movw	r16, r24
    2f36:	0e 5f       	subi	r16, 0xFE	; 254
    2f38:	1f 4f       	sbci	r17, 0xFF	; 255
    2f3a:	c8 01       	movw	r24, r16
    2f3c:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2f40:	8f a1       	ldd	r24, Y+39	; 0x27
    2f42:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2f44:	44 e0       	ldi	r20, 0x04	; 4
    2f46:	50 e0       	ldi	r21, 0x00	; 0
    2f48:	60 e0       	ldi	r22, 0x00	; 0
    2f4a:	70 e0       	ldi	r23, 0x00	; 0
    2f4c:	48 1b       	sub	r20, r24
    2f4e:	51 09       	sbc	r21, r1
    2f50:	61 09       	sbc	r22, r1
    2f52:	71 09       	sbc	r23, r1
    2f54:	4e 87       	std	Y+14, r20	; 0x0e
    2f56:	5f 87       	std	Y+15, r21	; 0x0f
    2f58:	68 8b       	std	Y+16, r22	; 0x10
    2f5a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2f5c:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2f60:	98 17       	cp	r25, r24
    2f62:	10 f4       	brcc	.+4      	; 0x2f68 <vTaskPriorityDisinherit+0x4c>
    2f64:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2f68:	fb e0       	ldi	r31, 0x0B	; 11
    2f6a:	8f 9f       	mul	r24, r31
    2f6c:	c0 01       	movw	r24, r0
    2f6e:	11 24       	eor	r1, r1
    2f70:	b8 01       	movw	r22, r16
    2f72:	88 50       	subi	r24, 0x08	; 8
    2f74:	9f 4c       	sbci	r25, 0xCF	; 207
    2f76:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInsertEnd>
			}
		}
	}
    2f7a:	df 91       	pop	r29
    2f7c:	cf 91       	pop	r28
    2f7e:	1f 91       	pop	r17
    2f80:	0f 91       	pop	r16
    2f82:	08 95       	ret

00002f84 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2f84:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2f86:	e8 81       	ld	r30, Y
    2f88:	f9 81       	ldd	r31, Y+1	; 0x01
    2f8a:	01 90       	ld	r0, Z+
    2f8c:	f0 81       	ld	r31, Z
    2f8e:	e0 2d       	mov	r30, r0
    2f90:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2f92:	1a 82       	std	Y+2, r1	; 0x02
    2f94:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2f96:	6f ef       	ldi	r22, 0xFF	; 255
    2f98:	7f ef       	ldi	r23, 0xFF	; 255
    2f9a:	cb 01       	movw	r24, r22
    2f9c:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <vTaskDelay>
    2fa0:	fa cf       	rjmp	.-12     	; 0x2f96 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002fa2 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2fa2:	fc 01       	movw	r30, r24
    2fa4:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2fa6:	65 87       	std	Z+13, r22	; 0x0d
    2fa8:	08 95       	ret

00002faa <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2faa:	4f 92       	push	r4
    2fac:	5f 92       	push	r5
    2fae:	6f 92       	push	r6
    2fb0:	7f 92       	push	r7
    2fb2:	8f 92       	push	r8
    2fb4:	9f 92       	push	r9
    2fb6:	af 92       	push	r10
    2fb8:	bf 92       	push	r11
    2fba:	cf 92       	push	r12
    2fbc:	df 92       	push	r13
    2fbe:	ef 92       	push	r14
    2fc0:	ff 92       	push	r15
    2fc2:	0f 93       	push	r16
    2fc4:	1f 93       	push	r17
    2fc6:	cf 93       	push	r28
    2fc8:	df 93       	push	r29
    2fca:	cd b7       	in	r28, 0x3d	; 61
    2fcc:	de b7       	in	r29, 0x3e	; 62
    2fce:	2a 97       	sbiw	r28, 0x0a	; 10
    2fd0:	cd bf       	out	0x3d, r28	; 61
    2fd2:	de bf       	out	0x3e, r29	; 62
    2fd4:	4c 01       	movw	r8, r24
    2fd6:	29 01       	movw	r4, r18
    2fd8:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2fda:	83 e4       	ldi	r24, 0x43	; 67
    2fdc:	90 e2       	ldi	r25, 0x20	; 32
    2fde:	f4 01       	movw	r30, r8
    2fe0:	80 83       	st	Z, r24
    2fe2:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2fe4:	fb 01       	movw	r30, r22
    2fe6:	80 81       	ld	r24, Z
    2fe8:	88 23       	and	r24, r24
    2fea:	69 f0       	breq	.+26     	; 0x3006 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2fec:	de 01       	movw	r26, r28
    2fee:	11 96       	adiw	r26, 0x01	; 1
    2ff0:	31 96       	adiw	r30, 0x01	; 1
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	02 c0       	rjmp	.+4      	; 0x2ffa <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2ff6:	99 30       	cpi	r25, 0x09	; 9
    2ff8:	39 f0       	breq	.+14     	; 0x3008 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2ffa:	9f 5f       	subi	r25, 0xFF	; 255
    2ffc:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2ffe:	81 91       	ld	r24, Z+
    3000:	81 11       	cpse	r24, r1
    3002:	f9 cf       	rjmp	.-14     	; 0x2ff6 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    3004:	01 c0       	rjmp	.+2      	; 0x3008 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    3006:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    3008:	e1 e0       	ldi	r30, 0x01	; 1
    300a:	f0 e0       	ldi	r31, 0x00	; 0
    300c:	ec 0f       	add	r30, r28
    300e:	fd 1f       	adc	r31, r29
    3010:	e9 0f       	add	r30, r25
    3012:	f1 1d       	adc	r31, r1
    3014:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3016:	74 01       	movw	r14, r8
    3018:	f2 e0       	ldi	r31, 0x02	; 2
    301a:	ef 0e       	add	r14, r31
    301c:	f1 1c       	adc	r15, r1
    301e:	a1 2c       	mov	r10, r1
    3020:	b1 2c       	mov	r11, r1
    3022:	c1 2c       	mov	r12, r1
    3024:	d1 2c       	mov	r13, r1
    3026:	04 2f       	mov	r16, r20
    3028:	94 01       	movw	r18, r8
    302a:	a2 01       	movw	r20, r4
    302c:	be 01       	movw	r22, r28
    302e:	6f 5f       	subi	r22, 0xFF	; 255
    3030:	7f 4f       	sbci	r23, 0xFF	; 255
    3032:	82 e9       	ldi	r24, 0x92	; 146
    3034:	93 e0       	ldi	r25, 0x03	; 3
    3036:	0e 94 51 12 	call	0x24a2	; 0x24a2 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    303a:	f4 01       	movw	r30, r8
    303c:	66 82       	std	Z+6, r6	; 0x06
    303e:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    3040:	40 86       	std	Z+8, r4	; 0x08
    3042:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    3044:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    3048:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    304c:	24 83       	std	Z+4, r18	; 0x04
    304e:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    3050:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    3054:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    3058:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    305a:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    305c:	40 90 64 31 	lds	r4, 0x3164	; 0x803164 <portStackTopForTask>
    3060:	50 90 65 31 	lds	r5, 0x3165	; 0x803165 <portStackTopForTask+0x1>
    3064:	ff ef       	ldi	r31, 0xFF	; 255
    3066:	4f 1a       	sub	r4, r31
    3068:	5f 0a       	sbc	r5, r31
    306a:	40 92 64 31 	sts	0x3164, r4	; 0x803164 <portStackTopForTask>
    306e:	50 92 65 31 	sts	0x3165, r5	; 0x803165 <portStackTopForTask+0x1>
    3072:	f4 01       	movw	r30, r8
    3074:	42 86       	std	Z+10, r4	; 0x0a
    3076:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    3078:	16 86       	std	Z+14, r1	; 0x0e
    307a:	17 86       	std	Z+15, r1	; 0x0f
    307c:	10 8a       	std	Z+16, r1	; 0x10
    307e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    3080:	61 14       	cp	r6, r1
    3082:	71 04       	cpc	r7, r1
    3084:	09 f4       	brne	.+2      	; 0x3088 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3086:	44 c0       	rjmp	.+136    	; 0x3110 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    3088:	81 30       	cpi	r24, 0x01	; 1
    308a:	79 f5       	brne	.+94     	; 0x30ea <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    308c:	6a e0       	ldi	r22, 0x0A	; 10
    308e:	c3 01       	movw	r24, r6
    3090:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3094:	7c 01       	movw	r14, r24
    3096:	60 e7       	ldi	r22, 0x70	; 112
    3098:	76 e0       	ldi	r23, 0x06	; 6
    309a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    309e:	be 01       	movw	r22, r28
    30a0:	6f 5f       	subi	r22, 0xFF	; 255
    30a2:	7f 4f       	sbci	r23, 0xFF	; 255
    30a4:	c7 01       	movw	r24, r14
    30a6:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    30aa:	6a e0       	ldi	r22, 0x0A	; 10
    30ac:	c7 01       	movw	r24, r14
    30ae:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    30b2:	7c 01       	movw	r14, r24
    30b4:	67 e6       	ldi	r22, 0x67	; 103
    30b6:	76 e0       	ldi	r23, 0x06	; 6
    30b8:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    30bc:	6a e0       	ldi	r22, 0x0A	; 10
    30be:	c7 01       	movw	r24, r14
    30c0:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    30c4:	7c 01       	movw	r14, r24
    30c6:	69 e5       	ldi	r22, 0x59	; 89
    30c8:	76 e0       	ldi	r23, 0x06	; 6
    30ca:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    30ce:	63 e0       	ldi	r22, 0x03	; 3
    30d0:	c7 01       	movw	r24, r14
    30d2:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    30d6:	b2 01       	movw	r22, r4
    30d8:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <_ZN8emstreamlsEj>
    30dc:	62 e0       	ldi	r22, 0x02	; 2
    30de:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    30e2:	66 e0       	ldi	r22, 0x06	; 6
    30e4:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    30e8:	13 c0       	rjmp	.+38     	; 0x3110 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    30ea:	6a e0       	ldi	r22, 0x0A	; 10
    30ec:	c3 01       	movw	r24, r6
    30ee:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    30f2:	4c 01       	movw	r8, r24
    30f4:	64 e4       	ldi	r22, 0x44	; 68
    30f6:	76 e0       	ldi	r23, 0x06	; 6
    30f8:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    30fc:	be 01       	movw	r22, r28
    30fe:	6f 5f       	subi	r22, 0xFF	; 255
    3100:	7f 4f       	sbci	r23, 0xFF	; 255
    3102:	c4 01       	movw	r24, r8
    3104:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    3108:	66 e0       	ldi	r22, 0x06	; 6
    310a:	c4 01       	movw	r24, r8
    310c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    3110:	2a 96       	adiw	r28, 0x0a	; 10
    3112:	cd bf       	out	0x3d, r28	; 61
    3114:	de bf       	out	0x3e, r29	; 62
    3116:	df 91       	pop	r29
    3118:	cf 91       	pop	r28
    311a:	1f 91       	pop	r17
    311c:	0f 91       	pop	r16
    311e:	ff 90       	pop	r15
    3120:	ef 90       	pop	r14
    3122:	df 90       	pop	r13
    3124:	cf 90       	pop	r12
    3126:	bf 90       	pop	r11
    3128:	af 90       	pop	r10
    312a:	9f 90       	pop	r9
    312c:	8f 90       	pop	r8
    312e:	7f 90       	pop	r7
    3130:	6f 90       	pop	r6
    3132:	5f 90       	pop	r5
    3134:	4f 90       	pop	r4
    3136:	08 95       	ret

00003138 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    3138:	cf 92       	push	r12
    313a:	df 92       	push	r13
    313c:	ef 92       	push	r14
    313e:	ff 92       	push	r15
    3140:	0f 93       	push	r16
    3142:	1f 93       	push	r17
    3144:	cf 93       	push	r28
    3146:	df 93       	push	r29
    3148:	ec 01       	movw	r28, r24
    314a:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    314c:	8a 81       	ldd	r24, Y+2	; 0x02
    314e:	9b 81       	ldd	r25, Y+3	; 0x03
    3150:	0e 94 a8 13 	call	0x2750	; 0x2750 <pcTaskGetTaskName>
    3154:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3156:	6a e0       	ldi	r22, 0x0A	; 10
    3158:	c7 01       	movw	r24, r14
    315a:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    315e:	8c 01       	movw	r16, r24
    3160:	63 e8       	ldi	r22, 0x83	; 131
    3162:	76 e0       	ldi	r23, 0x06	; 6
    3164:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    3168:	6a e0       	ldi	r22, 0x0A	; 10
    316a:	c8 01       	movw	r24, r16
    316c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3170:	8c 01       	movw	r16, r24
    3172:	6c e7       	ldi	r22, 0x7C	; 124
    3174:	76 e0       	ldi	r23, 0x06	; 6
    3176:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    317a:	b6 01       	movw	r22, r12
    317c:	c8 01       	movw	r24, r16
    317e:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    3182:	6a e0       	ldi	r22, 0x0A	; 10
    3184:	c8 01       	movw	r24, r16
    3186:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    318a:	8c 01       	movw	r16, r24
    318c:	66 e7       	ldi	r22, 0x76	; 118
    318e:	76 e0       	ldi	r23, 0x06	; 6
    3190:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    3194:	66 e0       	ldi	r22, 0x06	; 6
    3196:	c8 01       	movw	r24, r16
    3198:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    319c:	8a 85       	ldd	r24, Y+10	; 0x0a
    319e:	9b 85       	ldd	r25, Y+11	; 0x0b
    31a0:	e8 85       	ldd	r30, Y+8	; 0x08
    31a2:	f9 85       	ldd	r31, Y+9	; 0x09
    31a4:	01 e1       	ldi	r16, 0x11	; 17
    31a6:	21 e0       	ldi	r18, 0x01	; 1
    31a8:	a7 01       	movw	r20, r14
    31aa:	bc 01       	movw	r22, r24
    31ac:	8e 1b       	sub	r24, r30
    31ae:	9f 0b       	sbc	r25, r31
    31b0:	0e 94 9e 1b 	call	0x373c	; 0x373c <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    31b4:	8c 81       	ldd	r24, Y+4	; 0x04
    31b6:	9d 81       	ldd	r25, Y+5	; 0x05
    31b8:	00 97       	sbiw	r24, 0x00	; 0
    31ba:	19 f0       	breq	.+6      	; 0x31c2 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    31bc:	b7 01       	movw	r22, r14
    31be:	0e 94 9c 18 	call	0x3138	; 0x3138 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    31c2:	df 91       	pop	r29
    31c4:	cf 91       	pop	r28
    31c6:	1f 91       	pop	r17
    31c8:	0f 91       	pop	r16
    31ca:	ff 90       	pop	r15
    31cc:	ef 90       	pop	r14
    31ce:	df 90       	pop	r13
    31d0:	cf 90       	pop	r12
    31d2:	08 95       	ret

000031d4 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    31d4:	0f 93       	push	r16
    31d6:	1f 93       	push	r17
    31d8:	cf 93       	push	r28
    31da:	df 93       	push	r29
    31dc:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    31de:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    31e2:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    31e6:	00 97       	sbiw	r24, 0x00	; 0
    31e8:	19 f0       	breq	.+6      	; 0x31f0 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    31ea:	be 01       	movw	r22, r28
    31ec:	0e 94 9c 18 	call	0x3138	; 0x3138 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    31f0:	6a e0       	ldi	r22, 0x0A	; 10
    31f2:	ce 01       	movw	r24, r28
    31f4:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    31f8:	8c 01       	movw	r16, r24
    31fa:	69 e9       	ldi	r22, 0x99	; 153
    31fc:	76 e0       	ldi	r23, 0x06	; 6
    31fe:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    3202:	6a e0       	ldi	r22, 0x0A	; 10
    3204:	c8 01       	movw	r24, r16
    3206:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    320a:	8c 01       	movw	r16, r24
    320c:	6e e8       	ldi	r22, 0x8E	; 142
    320e:	76 e0       	ldi	r23, 0x06	; 6
    3210:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    3214:	6a e0       	ldi	r22, 0x0A	; 10
    3216:	c8 01       	movw	r24, r16
    3218:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    321c:	8c 01       	movw	r16, r24
    321e:	68 e8       	ldi	r22, 0x88	; 136
    3220:	76 e0       	ldi	r23, 0x06	; 6
    3222:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    3226:	66 e0       	ldi	r22, 0x06	; 6
    3228:	c8 01       	movw	r24, r16
    322a:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    322e:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <portStackTopForTask>
    3232:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <portStackTopForTask+0x1>
    3236:	bc 01       	movw	r22, r24
    3238:	6f 5f       	subi	r22, 0xFF	; 255
    323a:	7f 4f       	sbci	r23, 0xFF	; 255
    323c:	01 e1       	ldi	r16, 0x11	; 17
    323e:	21 e0       	ldi	r18, 0x01	; 1
    3240:	ae 01       	movw	r20, r28
    3242:	83 56       	subi	r24, 0x63	; 99
    3244:	91 09       	sbc	r25, r1
    3246:	0e 94 9e 1b 	call	0x373c	; 0x373c <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    324a:	df 91       	pop	r29
    324c:	cf 91       	pop	r28
    324e:	1f 91       	pop	r17
    3250:	0f 91       	pop	r16
    3252:	08 95       	ret

00003254 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3254:	8f 92       	push	r8
    3256:	9f 92       	push	r9
    3258:	af 92       	push	r10
    325a:	bf 92       	push	r11
    325c:	cf 92       	push	r12
    325e:	df 92       	push	r13
    3260:	ef 92       	push	r14
    3262:	ff 92       	push	r15
    3264:	0f 93       	push	r16
    3266:	1f 93       	push	r17
    3268:	cf 93       	push	r28
    326a:	df 93       	push	r29
    326c:	ec 01       	movw	r28, r24
    326e:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    3270:	8a 81       	ldd	r24, Y+2	; 0x02
    3272:	9b 81       	ldd	r25, Y+3	; 0x03
    3274:	0e 94 a8 13 	call	0x2750	; 0x2750 <pcTaskGetTaskName>
    3278:	bc 01       	movw	r22, r24
    327a:	c8 01       	movw	r24, r16
    327c:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    3280:	d8 01       	movw	r26, r16
    3282:	ed 91       	ld	r30, X+
    3284:	fc 91       	ld	r31, X
    3286:	02 80       	ldd	r0, Z+2	; 0x02
    3288:	f3 81       	ldd	r31, Z+3	; 0x03
    328a:	e0 2d       	mov	r30, r0
    328c:	69 e0       	ldi	r22, 0x09	; 9
    328e:	c8 01       	movw	r24, r16
    3290:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    3292:	8a 81       	ldd	r24, Y+2	; 0x02
    3294:	9b 81       	ldd	r25, Y+3	; 0x03
    3296:	0e 94 a8 13 	call	0x2750	; 0x2750 <pcTaskGetTaskName>
    329a:	fc 01       	movw	r30, r24
    329c:	01 90       	ld	r0, Z+
    329e:	00 20       	and	r0, r0
    32a0:	e9 f7       	brne	.-6      	; 0x329c <_ZN8frt_task12print_statusER8emstream+0x48>
    32a2:	31 97       	sbiw	r30, 0x01	; 1
    32a4:	e8 1b       	sub	r30, r24
    32a6:	f9 0b       	sbc	r31, r25
    32a8:	38 97       	sbiw	r30, 0x08	; 8
    32aa:	48 f4       	brcc	.+18     	; 0x32be <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    32ac:	d8 01       	movw	r26, r16
    32ae:	ed 91       	ld	r30, X+
    32b0:	fc 91       	ld	r31, X
    32b2:	02 80       	ldd	r0, Z+2	; 0x02
    32b4:	f3 81       	ldd	r31, Z+3	; 0x03
    32b6:	e0 2d       	mov	r30, r0
    32b8:	69 e0       	ldi	r22, 0x09	; 9
    32ba:	c8 01       	movw	r24, r16
    32bc:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    32be:	ce 84       	ldd	r12, Y+14	; 0x0e
    32c0:	df 84       	ldd	r13, Y+15	; 0x0f
    32c2:	e8 88       	ldd	r14, Y+16	; 0x10
    32c4:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    32c6:	a8 84       	ldd	r10, Y+8	; 0x08
    32c8:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    32ca:	8a 81       	ldd	r24, Y+2	; 0x02
    32cc:	9b 81       	ldd	r25, Y+3	; 0x03
    32ce:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <uxTaskGetStackHighWaterMark>
    32d2:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    32d4:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    32d6:	8a 81       	ldd	r24, Y+2	; 0x02
    32d8:	9b 81       	ldd	r25, Y+3	; 0x03
    32da:	0e 94 53 13 	call	0x26a6	; 0x26a6 <uxTaskPriorityGet>
    32de:	68 2f       	mov	r22, r24
    32e0:	c8 01       	movw	r24, r16
    32e2:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
    32e6:	6a e0       	ldi	r22, 0x0A	; 10
    32e8:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    32ec:	ec 01       	movw	r28, r24
    32ee:	6e e0       	ldi	r22, 0x0E	; 14
    32f0:	77 e0       	ldi	r23, 0x07	; 7
    32f2:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
			<< get_state ()
    32f6:	68 2d       	mov	r22, r8
    32f8:	ce 01       	movw	r24, r28
    32fa:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    32fe:	6a e0       	ldi	r22, 0x0A	; 10
    3300:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3304:	ec 01       	movw	r28, r24
    3306:	6c e0       	ldi	r22, 0x0C	; 12
    3308:	77 e0       	ldi	r23, 0x07	; 7
    330a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    330e:	69 2d       	mov	r22, r9
    3310:	ce 01       	movw	r24, r28
    3312:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
    3316:	6a e0       	ldi	r22, 0x0A	; 10
    3318:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    331c:	ec 01       	movw	r28, r24
    331e:	6a e0       	ldi	r22, 0x0A	; 10
    3320:	77 e0       	ldi	r23, 0x07	; 7
    3322:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3326:	b5 01       	movw	r22, r10
    3328:	ce 01       	movw	r24, r28
    332a:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <_ZN8emstreamlsEj>
    332e:	6a e0       	ldi	r22, 0x0A	; 10
    3330:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3334:	ec 01       	movw	r28, r24
    3336:	68 e0       	ldi	r22, 0x08	; 8
    3338:	77 e0       	ldi	r23, 0x07	; 7
    333a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    333e:	6a e0       	ldi	r22, 0x0A	; 10
    3340:	ce 01       	movw	r24, r28
    3342:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3346:	ec 01       	movw	r28, r24
    3348:	66 e0       	ldi	r22, 0x06	; 6
    334a:	77 e0       	ldi	r23, 0x07	; 7
    334c:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    3350:	b7 01       	movw	r22, r14
    3352:	a6 01       	movw	r20, r12
    3354:	ce 01       	movw	r24, r28
    3356:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <_ZN8emstreamlsEm>
}
    335a:	df 91       	pop	r29
    335c:	cf 91       	pop	r28
    335e:	1f 91       	pop	r17
    3360:	0f 91       	pop	r16
    3362:	ff 90       	pop	r15
    3364:	ef 90       	pop	r14
    3366:	df 90       	pop	r13
    3368:	cf 90       	pop	r12
    336a:	bf 90       	pop	r11
    336c:	af 90       	pop	r10
    336e:	9f 90       	pop	r9
    3370:	8f 90       	pop	r8
    3372:	08 95       	ret

00003374 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3374:	cf 93       	push	r28
    3376:	df 93       	push	r29
    3378:	ec 01       	movw	r28, r24
    337a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    337c:	db 01       	movw	r26, r22
    337e:	ed 91       	ld	r30, X+
    3380:	fc 91       	ld	r31, X
    3382:	02 80       	ldd	r0, Z+2	; 0x02
    3384:	f3 81       	ldd	r31, Z+3	; 0x03
    3386:	e0 2d       	mov	r30, r0
    3388:	be 01       	movw	r22, r28
    338a:	19 95       	eicall
	return (ser_dev);
}
    338c:	ce 01       	movw	r24, r28
    338e:	df 91       	pop	r29
    3390:	cf 91       	pop	r28
    3392:	08 95       	ret

00003394 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3394:	0f 93       	push	r16
    3396:	1f 93       	push	r17
    3398:	cf 93       	push	r28
    339a:	df 93       	push	r29
    339c:	ec 01       	movw	r28, r24
    339e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    33a0:	bc 01       	movw	r22, r24
    33a2:	c8 01       	movw	r24, r16
    33a4:	0e 94 ba 19 	call	0x3374	; 0x3374 <_ZlsR8emstreamR8frt_task>
    33a8:	66 e0       	ldi	r22, 0x06	; 6
    33aa:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    33ae:	8c 81       	ldd	r24, Y+4	; 0x04
    33b0:	9d 81       	ldd	r25, Y+5	; 0x05
    33b2:	00 97       	sbiw	r24, 0x00	; 0
    33b4:	19 f0       	breq	.+6      	; 0x33bc <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    33b6:	b8 01       	movw	r22, r16
    33b8:	0e 94 ca 19 	call	0x3394	; 0x3394 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    33bc:	df 91       	pop	r29
    33be:	cf 91       	pop	r28
    33c0:	1f 91       	pop	r17
    33c2:	0f 91       	pop	r16
    33c4:	08 95       	ret

000033c6 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    33c6:	0f 93       	push	r16
    33c8:	1f 93       	push	r17
    33ca:	cf 93       	push	r28
    33cc:	df 93       	push	r29
    33ce:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    33d0:	6a e0       	ldi	r22, 0x0A	; 10
    33d2:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    33d6:	8c 01       	movw	r16, r24
    33d8:	6b ef       	ldi	r22, 0xFB	; 251
    33da:	76 e0       	ldi	r23, 0x06	; 6
    33dc:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    33e0:	6a e0       	ldi	r22, 0x0A	; 10
    33e2:	c8 01       	movw	r24, r16
    33e4:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    33e8:	8c 01       	movw	r16, r24
    33ea:	64 ef       	ldi	r22, 0xF4	; 244
    33ec:	76 e0       	ldi	r23, 0x06	; 6
    33ee:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    33f2:	66 e0       	ldi	r22, 0x06	; 6
    33f4:	c8 01       	movw	r24, r16
    33f6:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    33fa:	6a e0       	ldi	r22, 0x0A	; 10
    33fc:	ce 01       	movw	r24, r28
    33fe:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3402:	8c 01       	movw	r16, r24
    3404:	63 ee       	ldi	r22, 0xE3	; 227
    3406:	76 e0       	ldi	r23, 0x06	; 6
    3408:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    340c:	6a e0       	ldi	r22, 0x0A	; 10
    340e:	c8 01       	movw	r24, r16
    3410:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3414:	8c 01       	movw	r16, r24
    3416:	67 ed       	ldi	r22, 0xD7	; 215
    3418:	76 e0       	ldi	r23, 0x06	; 6
    341a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    341e:	6a e0       	ldi	r22, 0x0A	; 10
    3420:	c8 01       	movw	r24, r16
    3422:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3426:	8c 01       	movw	r16, r24
    3428:	61 ed       	ldi	r22, 0xD1	; 209
    342a:	76 e0       	ldi	r23, 0x06	; 6
    342c:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    3430:	66 e0       	ldi	r22, 0x06	; 6
    3432:	c8 01       	movw	r24, r16
    3434:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3438:	6a e0       	ldi	r22, 0x0A	; 10
    343a:	ce 01       	movw	r24, r28
    343c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3440:	8c 01       	movw	r16, r24
    3442:	60 ec       	ldi	r22, 0xC0	; 192
    3444:	76 e0       	ldi	r23, 0x06	; 6
    3446:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    344a:	6a e0       	ldi	r22, 0x0A	; 10
    344c:	c8 01       	movw	r24, r16
    344e:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3452:	8c 01       	movw	r16, r24
    3454:	64 eb       	ldi	r22, 0xB4	; 180
    3456:	76 e0       	ldi	r23, 0x06	; 6
    3458:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    345c:	6a e0       	ldi	r22, 0x0A	; 10
    345e:	c8 01       	movw	r24, r16
    3460:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3464:	8c 01       	movw	r16, r24
    3466:	6e ea       	ldi	r22, 0xAE	; 174
    3468:	76 e0       	ldi	r23, 0x06	; 6
    346a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    346e:	66 e0       	ldi	r22, 0x06	; 6
    3470:	c8 01       	movw	r24, r16
    3472:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3476:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    347a:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    347e:	00 97       	sbiw	r24, 0x00	; 0
    3480:	19 f0       	breq	.+6      	; 0x3488 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    3482:	be 01       	movw	r22, r28
    3484:	0e 94 ca 19 	call	0x3394	; 0x3394 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3488:	0e 94 b0 13 	call	0x2760	; 0x2760 <xTaskGetIdleTaskHandle>
    348c:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <uxTaskGetStackHighWaterMark>
    3490:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    3492:	6a e0       	ldi	r22, 0x0A	; 10
    3494:	ce 01       	movw	r24, r28
    3496:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    349a:	ec 01       	movw	r28, r24
    349c:	63 ea       	ldi	r22, 0xA3	; 163
    349e:	76 e0       	ldi	r23, 0x06	; 6
    34a0:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    34a4:	61 2f       	mov	r22, r17
    34a6:	ce 01       	movw	r24, r28
    34a8:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    34ac:	6a e0       	ldi	r22, 0x0A	; 10
    34ae:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    34b2:	ec 01       	movw	r28, r24
    34b4:	61 ea       	ldi	r22, 0xA1	; 161
    34b6:	76 e0       	ldi	r23, 0x06	; 6
    34b8:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    34bc:	64 e6       	ldi	r22, 0x64	; 100
    34be:	70 e0       	ldi	r23, 0x00	; 0
    34c0:	ce 01       	movw	r24, r28
    34c2:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <_ZN8emstreamlsEj>
    34c6:	6a e0       	ldi	r22, 0x0A	; 10
    34c8:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    34cc:	ec 01       	movw	r28, r24
    34ce:	6e e9       	ldi	r22, 0x9E	; 158
    34d0:	76 e0       	ldi	r23, 0x06	; 6
    34d2:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    34d6:	66 e0       	ldi	r22, 0x06	; 6
    34d8:	ce 01       	movw	r24, r28
    34da:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
}
    34de:	df 91       	pop	r29
    34e0:	cf 91       	pop	r28
    34e2:	1f 91       	pop	r17
    34e4:	0f 91       	pop	r16
    34e6:	08 95       	ret

000034e8 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    34e8:	0f 93       	push	r16
    34ea:	cf 93       	push	r28
    34ec:	df 93       	push	r29
    34ee:	1f 92       	push	r1
    34f0:	cd b7       	in	r28, 0x3d	; 61
    34f2:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    34f4:	00 e0       	ldi	r16, 0x00	; 0
    34f6:	2f ef       	ldi	r18, 0xFF	; 255
    34f8:	3f ef       	ldi	r19, 0xFF	; 255
    34fa:	a9 01       	movw	r20, r18
    34fc:	be 01       	movw	r22, r28
    34fe:	6f 5f       	subi	r22, 0xFF	; 255
    3500:	7f 4f       	sbci	r23, 0xFF	; 255
    3502:	fc 01       	movw	r30, r24
    3504:	80 85       	ldd	r24, Z+8	; 0x08
    3506:	91 85       	ldd	r25, Z+9	; 0x09
    3508:	0e 94 2f 11 	call	0x225e	; 0x225e <xQueueGenericReceive>
    350c:	81 30       	cpi	r24, 0x01	; 1
    350e:	19 f4       	brne	.+6      	; 0x3516 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3510:	89 81       	ldd	r24, Y+1	; 0x01
    3512:	90 e0       	ldi	r25, 0x00	; 0
    3514:	02 c0       	rjmp	.+4      	; 0x351a <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3516:	8f ef       	ldi	r24, 0xFF	; 255
    3518:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    351a:	0f 90       	pop	r0
    351c:	df 91       	pop	r29
    351e:	cf 91       	pop	r28
    3520:	0f 91       	pop	r16
    3522:	08 95       	ret

00003524 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3524:	fc 01       	movw	r30, r24
    3526:	80 85       	ldd	r24, Z+8	; 0x08
    3528:	91 85       	ldd	r25, Z+9	; 0x09
    352a:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <uxQueueMessagesWaiting>
    352e:	91 e0       	ldi	r25, 0x01	; 1
    3530:	81 11       	cpse	r24, r1
    3532:	01 c0       	rjmp	.+2      	; 0x3536 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3534:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3536:	89 2f       	mov	r24, r25
    3538:	08 95       	ret

0000353a <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    353a:	0f 93       	push	r16
    353c:	cf 93       	push	r28
    353e:	df 93       	push	r29
    3540:	1f 92       	push	r1
    3542:	cd b7       	in	r28, 0x3d	; 61
    3544:	de b7       	in	r29, 0x3e	; 62
    3546:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3548:	fc 01       	movw	r30, r24
    354a:	22 85       	ldd	r18, Z+10	; 0x0a
    354c:	33 85       	ldd	r19, Z+11	; 0x0b
    354e:	44 85       	ldd	r20, Z+12	; 0x0c
    3550:	55 85       	ldd	r21, Z+13	; 0x0d
    3552:	00 e0       	ldi	r16, 0x00	; 0
    3554:	be 01       	movw	r22, r28
    3556:	6f 5f       	subi	r22, 0xFF	; 255
    3558:	7f 4f       	sbci	r23, 0xFF	; 255
    355a:	80 85       	ldd	r24, Z+8	; 0x08
    355c:	91 85       	ldd	r25, Z+9	; 0x09
    355e:	0e 94 94 10 	call	0x2128	; 0x2128 <xQueueGenericSend>
    3562:	91 e0       	ldi	r25, 0x01	; 1
    3564:	81 11       	cpse	r24, r1
    3566:	01 c0       	rjmp	.+2      	; 0x356a <_ZN14frt_text_queue7putcharEc+0x30>
    3568:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    356a:	89 2f       	mov	r24, r25
    356c:	0f 90       	pop	r0
    356e:	df 91       	pop	r29
    3570:	cf 91       	pop	r28
    3572:	0f 91       	pop	r16
    3574:	08 95       	ret

00003576 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3576:	8f 92       	push	r8
    3578:	9f 92       	push	r9
    357a:	bf 92       	push	r11
    357c:	cf 92       	push	r12
    357e:	df 92       	push	r13
    3580:	ef 92       	push	r14
    3582:	ff 92       	push	r15
    3584:	0f 93       	push	r16
    3586:	1f 93       	push	r17
    3588:	cf 93       	push	r28
    358a:	df 93       	push	r29
    358c:	ec 01       	movw	r28, r24
    358e:	b6 2e       	mov	r11, r22
    3590:	4a 01       	movw	r8, r20
    3592:	68 01       	movw	r12, r16
    3594:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3596:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <_ZN8emstreamC1Ev>
    359a:	8b e4       	ldi	r24, 0x4B	; 75
    359c:	90 e2       	ldi	r25, 0x20	; 32
    359e:	88 83       	st	Y, r24
    35a0:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    35a2:	8e 86       	std	Y+14, r8	; 0x0e
    35a4:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    35a6:	40 e0       	ldi	r20, 0x00	; 0
    35a8:	61 e0       	ldi	r22, 0x01	; 1
    35aa:	8b 2d       	mov	r24, r11
    35ac:	0e 94 66 10 	call	0x20cc	; 0x20cc <xQueueGenericCreate>
    35b0:	88 87       	std	Y+8, r24	; 0x08
    35b2:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    35b4:	ca 86       	std	Y+10, r12	; 0x0a
    35b6:	db 86       	std	Y+11, r13	; 0x0b
    35b8:	ec 86       	std	Y+12, r14	; 0x0c
    35ba:	fd 86       	std	Y+13, r15	; 0x0d
}
    35bc:	df 91       	pop	r29
    35be:	cf 91       	pop	r28
    35c0:	1f 91       	pop	r17
    35c2:	0f 91       	pop	r16
    35c4:	ff 90       	pop	r15
    35c6:	ef 90       	pop	r14
    35c8:	df 90       	pop	r13
    35ca:	cf 90       	pop	r12
    35cc:	bf 90       	pop	r11
    35ce:	9f 90       	pop	r9
    35d0:	8f 90       	pop	r8
    35d2:	08 95       	ret

000035d4 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    35d4:	cf 92       	push	r12
    35d6:	df 92       	push	r13
    35d8:	ef 92       	push	r14
    35da:	ff 92       	push	r15
    35dc:	cf 93       	push	r28
    35de:	df 93       	push	r29
    35e0:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    35e2:	68 81       	ld	r22, Y
    35e4:	79 81       	ldd	r23, Y+1	; 0x01
    35e6:	8a 81       	ldd	r24, Y+2	; 0x02
    35e8:	9b 81       	ldd	r25, Y+3	; 0x03
    35ea:	0f 2e       	mov	r0, r31
    35ec:	f8 ee       	ldi	r31, 0xE8	; 232
    35ee:	cf 2e       	mov	r12, r31
    35f0:	f3 e0       	ldi	r31, 0x03	; 3
    35f2:	df 2e       	mov	r13, r31
    35f4:	e1 2c       	mov	r14, r1
    35f6:	f1 2c       	mov	r15, r1
    35f8:	f0 2d       	mov	r31, r0
    35fa:	a7 01       	movw	r20, r14
    35fc:	96 01       	movw	r18, r12
    35fe:	0e 94 a0 22 	call	0x4540	; 0x4540 <__udivmodsi4>
    3602:	9b 01       	movw	r18, r22
    3604:	ac 01       	movw	r20, r24
    3606:	60 e4       	ldi	r22, 0x40	; 64
    3608:	72 e4       	ldi	r23, 0x42	; 66
    360a:	8f e0       	ldi	r24, 0x0F	; 15
    360c:	90 e0       	ldi	r25, 0x00	; 0
    360e:	0e 94 7c 22 	call	0x44f8	; 0x44f8 <__mulsi3>
    3612:	a7 01       	movw	r20, r14
    3614:	96 01       	movw	r18, r12
    3616:	0e 94 a0 22 	call	0x4540	; 0x4540 <__udivmodsi4>
    361a:	69 01       	movw	r12, r18
    361c:	7a 01       	movw	r14, r20
    361e:	ac 81       	ldd	r26, Y+4	; 0x04
    3620:	bd 81       	ldd	r27, Y+5	; 0x05
    3622:	20 e4       	ldi	r18, 0x40	; 64
    3624:	32 e4       	ldi	r19, 0x42	; 66
    3626:	4f e0       	ldi	r20, 0x0F	; 15
    3628:	50 e0       	ldi	r21, 0x00	; 0
    362a:	0e 94 08 23 	call	0x4610	; 0x4610 <__muluhisi3>
    362e:	20 e0       	ldi	r18, 0x00	; 0
    3630:	38 e4       	ldi	r19, 0x48	; 72
    3632:	48 ee       	ldi	r20, 0xE8	; 232
    3634:	51 e0       	ldi	r21, 0x01	; 1
    3636:	0e 94 a0 22 	call	0x4540	; 0x4540 <__udivmodsi4>
    363a:	c7 01       	movw	r24, r14
    363c:	b6 01       	movw	r22, r12
    363e:	62 0f       	add	r22, r18
    3640:	73 1f       	adc	r23, r19
    3642:	84 1f       	adc	r24, r20
    3644:	95 1f       	adc	r25, r21
}
    3646:	df 91       	pop	r29
    3648:	cf 91       	pop	r28
    364a:	ff 90       	pop	r15
    364c:	ef 90       	pop	r14
    364e:	df 90       	pop	r13
    3650:	cf 90       	pop	r12
    3652:	08 95       	ret

00003654 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3654:	cf 92       	push	r12
    3656:	df 92       	push	r13
    3658:	ef 92       	push	r14
    365a:	ff 92       	push	r15
    365c:	0f 93       	push	r16
    365e:	1f 93       	push	r17
    3660:	cf 93       	push	r28
    3662:	df 93       	push	r29
    3664:	cd b7       	in	r28, 0x3d	; 61
    3666:	de b7       	in	r29, 0x3e	; 62
    3668:	2f 97       	sbiw	r28, 0x0f	; 15
    366a:	cd bf       	out	0x3d, r28	; 61
    366c:	de bf       	out	0x3e, r29	; 62
    366e:	6c 01       	movw	r12, r24
    3670:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3672:	db 01       	movw	r26, r22
    3674:	6d 91       	ld	r22, X+
    3676:	7d 91       	ld	r23, X+
    3678:	8d 91       	ld	r24, X+
    367a:	9c 91       	ld	r25, X
    367c:	28 ee       	ldi	r18, 0xE8	; 232
    367e:	33 e0       	ldi	r19, 0x03	; 3
    3680:	40 e0       	ldi	r20, 0x00	; 0
    3682:	50 e0       	ldi	r21, 0x00	; 0
    3684:	0e 94 a0 22 	call	0x4540	; 0x4540 <__udivmodsi4>
    3688:	ba 01       	movw	r22, r20
    368a:	a9 01       	movw	r20, r18
    368c:	c6 01       	movw	r24, r12
    368e:	0e 94 de 1d 	call	0x3bbc	; 0x3bbc <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3692:	d6 01       	movw	r26, r12
    3694:	ed 91       	ld	r30, X+
    3696:	fc 91       	ld	r31, X
    3698:	02 80       	ldd	r0, Z+2	; 0x02
    369a:	f3 81       	ldd	r31, Z+3	; 0x03
    369c:	e0 2d       	mov	r30, r0
    369e:	6e e2       	ldi	r22, 0x2E	; 46
    36a0:	c6 01       	movw	r24, r12
    36a2:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    36a4:	c8 01       	movw	r24, r16
    36a6:	0e 94 ea 1a 	call	0x35d4	; 0x35d4 <_ZN10time_stamp12get_microsecEv>
    36aa:	8e 01       	movw	r16, r28
    36ac:	09 5f       	subi	r16, 0xF9	; 249
    36ae:	1f 4f       	sbci	r17, 0xFF	; 255
    36b0:	fe 01       	movw	r30, r28
    36b2:	31 96       	adiw	r30, 0x01	; 1
    36b4:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    36b6:	2a e0       	ldi	r18, 0x0A	; 10
    36b8:	30 e0       	ldi	r19, 0x00	; 0
    36ba:	40 e0       	ldi	r20, 0x00	; 0
    36bc:	50 e0       	ldi	r21, 0x00	; 0
    36be:	0e 94 c2 22 	call	0x4584	; 0x4584 <__divmodsi4>
    36c2:	e6 2f       	mov	r30, r22
    36c4:	28 87       	std	Y+8, r18	; 0x08
    36c6:	39 87       	std	Y+9, r19	; 0x09
    36c8:	4a 87       	std	Y+10, r20	; 0x0a
    36ca:	5b 87       	std	Y+11, r21	; 0x0b
    36cc:	68 85       	ldd	r22, Y+8	; 0x08
    36ce:	79 85       	ldd	r23, Y+9	; 0x09
    36d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    36d2:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    36d4:	20 e3       	ldi	r18, 0x30	; 48
    36d6:	2e 0f       	add	r18, r30
    36d8:	d8 01       	movw	r26, r16
    36da:	2e 93       	st	-X, r18
    36dc:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    36de:	ae 15       	cp	r26, r14
    36e0:	bf 05       	cpc	r27, r15
    36e2:	49 f7       	brne	.-46     	; 0x36b6 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    36e4:	1f 82       	std	Y+7, r1	; 0x07
    36e6:	be 01       	movw	r22, r28
    36e8:	6f 5f       	subi	r22, 0xFF	; 255
    36ea:	7f 4f       	sbci	r23, 0xFF	; 255
    36ec:	c6 01       	movw	r24, r12
    36ee:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    36f2:	c6 01       	movw	r24, r12
    36f4:	2f 96       	adiw	r28, 0x0f	; 15
    36f6:	cd bf       	out	0x3d, r28	; 61
    36f8:	de bf       	out	0x3e, r29	; 62
    36fa:	df 91       	pop	r29
    36fc:	cf 91       	pop	r28
    36fe:	1f 91       	pop	r17
    3700:	0f 91       	pop	r16
    3702:	ff 90       	pop	r15
    3704:	ef 90       	pop	r14
    3706:	df 90       	pop	r13
    3708:	cf 90       	pop	r12
    370a:	08 95       	ret

0000370c <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    370c:	cf 93       	push	r28
    370e:	df 93       	push	r29
    3710:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3712:	0f b6       	in	r0, 0x3f	; 63
    3714:	f8 94       	cli
    3716:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3718:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    371c:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3720:	8c 83       	std	Y+4, r24	; 0x04
    3722:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3724:	0e 94 9a 13 	call	0x2734	; 0x2734 <xTaskGetTickCount>
    3728:	68 83       	st	Y, r22
    372a:	79 83       	std	Y+1, r23	; 0x01
    372c:	8a 83       	std	Y+2, r24	; 0x02
    372e:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3730:	0f 90       	pop	r0
    3732:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3734:	ce 01       	movw	r24, r28
    3736:	df 91       	pop	r29
    3738:	cf 91       	pop	r28
    373a:	08 95       	ret

0000373c <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    373c:	5f 92       	push	r5
    373e:	6f 92       	push	r6
    3740:	7f 92       	push	r7
    3742:	8f 92       	push	r8
    3744:	9f 92       	push	r9
    3746:	af 92       	push	r10
    3748:	bf 92       	push	r11
    374a:	cf 92       	push	r12
    374c:	df 92       	push	r13
    374e:	ef 92       	push	r14
    3750:	ff 92       	push	r15
    3752:	0f 93       	push	r16
    3754:	1f 93       	push	r17
    3756:	cf 93       	push	r28
    3758:	df 93       	push	r29
    375a:	5c 01       	movw	r10, r24
    375c:	4b 01       	movw	r8, r22
    375e:	7a 01       	movw	r14, r20
    3760:	12 2f       	mov	r17, r18
    3762:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3764:	63 e0       	ldi	r22, 0x03	; 3
    3766:	ca 01       	movw	r24, r20
    3768:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    376c:	a8 14       	cp	r10, r8
    376e:	b9 04       	cpc	r11, r9
    3770:	08 f0       	brcs	.+2      	; 0x3774 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3772:	7d c0       	rjmp	.+250    	; 0x386e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3774:	65 01       	movw	r12, r10
    3776:	84 e1       	ldi	r24, 0x14	; 20
    3778:	c8 0e       	add	r12, r24
    377a:	d1 1c       	adc	r13, r1
    377c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    377e:	6a 2c       	mov	r6, r10
    3780:	5b 2c       	mov	r5, r11
    3782:	b5 01       	movw	r22, r10
    3784:	c7 01       	movw	r24, r14
    3786:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <_ZN8emstreamlsEj>
    378a:	6a e0       	ldi	r22, 0x0A	; 10
    378c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3790:	60 e2       	ldi	r22, 0x20	; 32
    3792:	77 e0       	ldi	r23, 0x07	; 7
    3794:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3798:	11 23       	and	r17, r17
    379a:	09 f4       	brne	.+2      	; 0x379e <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    379c:	6d c0       	rjmp	.+218    	; 0x3878 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    379e:	00 23       	and	r16, r16
    37a0:	09 f4       	brne	.+2      	; 0x37a4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    37a2:	6a c0       	rjmp	.+212    	; 0x3878 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    37a4:	6a e0       	ldi	r22, 0x0A	; 10
    37a6:	c7 01       	movw	r24, r14
    37a8:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    37ac:	6b e1       	ldi	r22, 0x1B	; 27
    37ae:	77 e0       	ldi	r23, 0x07	; 7
    37b0:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    37b4:	61 c0       	rjmp	.+194    	; 0x3878 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    37b6:	11 23       	and	r17, r17
    37b8:	71 f0       	breq	.+28     	; 0x37d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    37ba:	01 11       	cpse	r16, r1
    37bc:	0c c0       	rjmp	.+24     	; 0x37d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    37be:	88 81       	ld	r24, Y
    37c0:	87 15       	cp	r24, r7
    37c2:	49 f0       	breq	.+18     	; 0x37d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    37c4:	6a e0       	ldi	r22, 0x0A	; 10
    37c6:	c7 01       	movw	r24, r14
    37c8:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    37cc:	66 e1       	ldi	r22, 0x16	; 22
    37ce:	77 e0       	ldi	r23, 0x07	; 7
    37d0:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    37d4:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    37d6:	69 91       	ld	r22, Y+
    37d8:	c7 01       	movw	r24, r14
    37da:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    37de:	dc 01       	movw	r26, r24
    37e0:	ed 91       	ld	r30, X+
    37e2:	fc 91       	ld	r31, X
    37e4:	02 80       	ldd	r0, Z+2	; 0x02
    37e6:	f3 81       	ldd	r31, Z+3	; 0x03
    37e8:	e0 2d       	mov	r30, r0
    37ea:	60 e2       	ldi	r22, 0x20	; 32
    37ec:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    37ee:	cc 16       	cp	r12, r28
    37f0:	dd 06       	cpc	r13, r29
    37f2:	09 f7       	brne	.-62     	; 0x37b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    37f4:	11 23       	and	r17, r17
    37f6:	89 f0       	breq	.+34     	; 0x381a <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    37f8:	6a e0       	ldi	r22, 0x0A	; 10
    37fa:	c7 01       	movw	r24, r14
    37fc:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3800:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3802:	60 e1       	ldi	r22, 0x10	; 16
    3804:	77 e0       	ldi	r23, 0x07	; 7
    3806:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    380a:	e8 81       	ld	r30, Y
    380c:	f9 81       	ldd	r31, Y+1	; 0x01
    380e:	02 80       	ldd	r0, Z+2	; 0x02
    3810:	f3 81       	ldd	r31, Z+3	; 0x03
    3812:	e0 2d       	mov	r30, r0
    3814:	60 e2       	ldi	r22, 0x20	; 32
    3816:	ce 01       	movw	r24, r28
    3818:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    381a:	c6 2d       	mov	r28, r6
    381c:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    381e:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3820:	80 ee       	ldi	r24, 0xE0	; 224
    3822:	86 0f       	add	r24, r22
    3824:	8f 35       	cpi	r24, 0x5F	; 95
    3826:	48 f4       	brcc	.+18     	; 0x383a <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3828:	d7 01       	movw	r26, r14
    382a:	ed 91       	ld	r30, X+
    382c:	fc 91       	ld	r31, X
    382e:	02 80       	ldd	r0, Z+2	; 0x02
    3830:	f3 81       	ldd	r31, Z+3	; 0x03
    3832:	e0 2d       	mov	r30, r0
    3834:	c7 01       	movw	r24, r14
    3836:	19 95       	eicall
    3838:	09 c0       	rjmp	.+18     	; 0x384c <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    383a:	d7 01       	movw	r26, r14
    383c:	ed 91       	ld	r30, X+
    383e:	fc 91       	ld	r31, X
    3840:	02 80       	ldd	r0, Z+2	; 0x02
    3842:	f3 81       	ldd	r31, Z+3	; 0x03
    3844:	e0 2d       	mov	r30, r0
    3846:	6e e2       	ldi	r22, 0x2E	; 46
    3848:	c7 01       	movw	r24, r14
    384a:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    384c:	cc 16       	cp	r12, r28
    384e:	dd 06       	cpc	r13, r29
    3850:	31 f7       	brne	.-52     	; 0x381e <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3852:	b4 e1       	ldi	r27, 0x14	; 20
    3854:	ab 0e       	add	r10, r27
    3856:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3858:	66 e0       	ldi	r22, 0x06	; 6
    385a:	c7 01       	movw	r24, r14
    385c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    3860:	84 e1       	ldi	r24, 0x14	; 20
    3862:	c8 0e       	add	r12, r24
    3864:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3866:	a8 14       	cp	r10, r8
    3868:	b9 04       	cpc	r11, r9
    386a:	08 f4       	brcc	.+2      	; 0x386e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    386c:	88 cf       	rjmp	.-240    	; 0x377e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    386e:	62 e0       	ldi	r22, 0x02	; 2
    3870:	c7 01       	movw	r24, r14
    3872:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
}
    3876:	03 c0       	rjmp	.+6      	; 0x387e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3878:	c6 2d       	mov	r28, r6
    387a:	d5 2d       	mov	r29, r5
    387c:	9c cf       	rjmp	.-200    	; 0x37b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    387e:	df 91       	pop	r29
    3880:	cf 91       	pop	r28
    3882:	1f 91       	pop	r17
    3884:	0f 91       	pop	r16
    3886:	ff 90       	pop	r15
    3888:	ef 90       	pop	r14
    388a:	df 90       	pop	r13
    388c:	cf 90       	pop	r12
    388e:	bf 90       	pop	r11
    3890:	af 90       	pop	r10
    3892:	9f 90       	pop	r9
    3894:	8f 90       	pop	r8
    3896:	7f 90       	pop	r7
    3898:	6f 90       	pop	r6
    389a:	5f 90       	pop	r5
    389c:	08 95       	ret

0000389e <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    389e:	0e 94 80 0c 	call	0x1900	; 0x1900 <pvPortMalloc>
    38a2:	08 95       	ret

000038a4 <_Znaj>:
    38a4:	0e 94 80 0c 	call	0x1900	; 0x1900 <pvPortMalloc>
    38a8:	08 95       	ret

000038aa <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    38aa:	08 95       	ret

000038ac <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    38ac:	cf 93       	push	r28
    38ae:	df 93       	push	r29
    38b0:	fc 01       	movw	r30, r24
    38b2:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    38b4:	40 3a       	cpi	r20, 0xA0	; 160
    38b6:	68 e0       	ldi	r22, 0x08	; 8
    38b8:	56 07       	cpc	r21, r22
    38ba:	49 f4       	brne	.+18     	; 0x38ce <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    38bc:	80 e4       	ldi	r24, 0x40	; 64
    38be:	96 e0       	ldi	r25, 0x06	; 6
    38c0:	82 83       	std	Z+2, r24	; 0x02
    38c2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    38c4:	82 e0       	ldi	r24, 0x02	; 2
    38c6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    38c8:	83 e0       	ldi	r24, 0x03	; 3
    38ca:	85 83       	std	Z+5, r24	; 0x05
    38cc:	32 c0       	rjmp	.+100    	; 0x3932 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    38ce:	40 3b       	cpi	r20, 0xB0	; 176
    38d0:	78 e0       	ldi	r23, 0x08	; 8
    38d2:	57 07       	cpc	r21, r23
    38d4:	49 f4       	brne	.+18     	; 0x38e8 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    38d6:	80 e4       	ldi	r24, 0x40	; 64
    38d8:	96 e0       	ldi	r25, 0x06	; 6
    38da:	82 83       	std	Z+2, r24	; 0x02
    38dc:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    38de:	86 e0       	ldi	r24, 0x06	; 6
    38e0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    38e2:	87 e0       	ldi	r24, 0x07	; 7
    38e4:	85 83       	std	Z+5, r24	; 0x05
    38e6:	25 c0       	rjmp	.+74     	; 0x3932 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    38e8:	40 3a       	cpi	r20, 0xA0	; 160
    38ea:	89 e0       	ldi	r24, 0x09	; 9
    38ec:	58 07       	cpc	r21, r24
    38ee:	49 f4       	brne	.+18     	; 0x3902 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    38f0:	80 e6       	ldi	r24, 0x60	; 96
    38f2:	96 e0       	ldi	r25, 0x06	; 6
    38f4:	82 83       	std	Z+2, r24	; 0x02
    38f6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    38f8:	82 e0       	ldi	r24, 0x02	; 2
    38fa:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    38fc:	83 e0       	ldi	r24, 0x03	; 3
    38fe:	85 83       	std	Z+5, r24	; 0x05
    3900:	18 c0       	rjmp	.+48     	; 0x3932 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3902:	40 3b       	cpi	r20, 0xB0	; 176
    3904:	69 e0       	ldi	r22, 0x09	; 9
    3906:	56 07       	cpc	r21, r22
    3908:	49 f4       	brne	.+18     	; 0x391c <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    390a:	80 e6       	ldi	r24, 0x60	; 96
    390c:	96 e0       	ldi	r25, 0x06	; 6
    390e:	82 83       	std	Z+2, r24	; 0x02
    3910:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3912:	86 e0       	ldi	r24, 0x06	; 6
    3914:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3916:	87 e0       	ldi	r24, 0x07	; 7
    3918:	85 83       	std	Z+5, r24	; 0x05
    391a:	0b c0       	rjmp	.+22     	; 0x3932 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    391c:	40 3a       	cpi	r20, 0xA0	; 160
    391e:	5a 40       	sbci	r21, 0x0A	; 10
    3920:	41 f4       	brne	.+16     	; 0x3932 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3922:	80 e8       	ldi	r24, 0x80	; 128
    3924:	96 e0       	ldi	r25, 0x06	; 6
    3926:	82 83       	std	Z+2, r24	; 0x02
    3928:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    392a:	82 e0       	ldi	r24, 0x02	; 2
    392c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    392e:	83 e0       	ldi	r24, 0x03	; 3
    3930:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3932:	a6 83       	std	Z+6, r26	; 0x06
    3934:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3936:	cd 01       	movw	r24, r26
    3938:	01 96       	adiw	r24, 0x01	; 1
    393a:	80 87       	std	Z+8, r24	; 0x08
    393c:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    393e:	03 96       	adiw	r24, 0x03	; 3
    3940:	82 87       	std	Z+10, r24	; 0x0a
    3942:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3944:	25 81       	ldd	r18, Z+5	; 0x05
    3946:	c2 81       	ldd	r28, Z+2	; 0x02
    3948:	d3 81       	ldd	r29, Z+3	; 0x03
    394a:	4c 81       	ldd	r20, Y+4	; 0x04
    394c:	81 e0       	ldi	r24, 0x01	; 1
    394e:	90 e0       	ldi	r25, 0x00	; 0
    3950:	bc 01       	movw	r22, r24
    3952:	02 c0       	rjmp	.+4      	; 0x3958 <_ZN7base232C1EjP12USART_struct+0xac>
    3954:	66 0f       	add	r22, r22
    3956:	77 1f       	adc	r23, r23
    3958:	2a 95       	dec	r18
    395a:	e2 f7       	brpl	.-8      	; 0x3954 <_ZN7base232C1EjP12USART_struct+0xa8>
    395c:	9b 01       	movw	r18, r22
    395e:	24 2b       	or	r18, r20
    3960:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3962:	25 81       	ldd	r18, Z+5	; 0x05
    3964:	c2 81       	ldd	r28, Z+2	; 0x02
    3966:	d3 81       	ldd	r29, Z+3	; 0x03
    3968:	48 81       	ld	r20, Y
    396a:	bc 01       	movw	r22, r24
    396c:	02 c0       	rjmp	.+4      	; 0x3972 <_ZN7base232C1EjP12USART_struct+0xc6>
    396e:	66 0f       	add	r22, r22
    3970:	77 1f       	adc	r23, r23
    3972:	2a 95       	dec	r18
    3974:	e2 f7       	brpl	.-8      	; 0x396e <_ZN7base232C1EjP12USART_struct+0xc2>
    3976:	9b 01       	movw	r18, r22
    3978:	24 2b       	or	r18, r20
    397a:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    397c:	34 81       	ldd	r19, Z+4	; 0x04
    397e:	c2 81       	ldd	r28, Z+2	; 0x02
    3980:	d3 81       	ldd	r29, Z+3	; 0x03
    3982:	28 81       	ld	r18, Y
    3984:	02 c0       	rjmp	.+4      	; 0x398a <_ZN7base232C1EjP12USART_struct+0xde>
    3986:	88 0f       	add	r24, r24
    3988:	99 1f       	adc	r25, r25
    398a:	3a 95       	dec	r19
    398c:	e2 f7       	brpl	.-8      	; 0x3986 <_ZN7base232C1EjP12USART_struct+0xda>
    398e:	80 95       	com	r24
    3990:	90 95       	com	r25
    3992:	82 23       	and	r24, r18
    3994:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3996:	80 e1       	ldi	r24, 0x10	; 16
    3998:	13 96       	adiw	r26, 0x03	; 3
    399a:	8c 93       	st	X, r24
    399c:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    399e:	83 e0       	ldi	r24, 0x03	; 3
    39a0:	15 96       	adiw	r26, 0x05	; 5
    39a2:	8c 93       	st	X, r24
    39a4:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    39a6:	80 ef       	ldi	r24, 0xF0	; 240
    39a8:	17 96       	adiw	r26, 0x07	; 7
    39aa:	8c 93       	st	X, r24
    39ac:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    39ae:	81 e2       	ldi	r24, 0x21	; 33
    39b0:	16 96       	adiw	r26, 0x06	; 6
    39b2:	8c 93       	st	X, r24
    39b4:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    39b6:	88 e1       	ldi	r24, 0x18	; 24
    39b8:	14 96       	adiw	r26, 0x04	; 4
    39ba:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    39bc:	80 e8       	ldi	r24, 0x80	; 128
    39be:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    39c0:	80 e4       	ldi	r24, 0x40	; 64
    39c2:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    39c4:	80 e2       	ldi	r24, 0x20	; 32
    39c6:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    39c8:	06 80       	ldd	r0, Z+6	; 0x06
    39ca:	f7 81       	ldd	r31, Z+7	; 0x07
    39cc:	e0 2d       	mov	r30, r0
    39ce:	80 81       	ld	r24, Z
    39d0:	80 81       	ld	r24, Z
}
    39d2:	df 91       	pop	r29
    39d4:	cf 91       	pop	r28
    39d6:	08 95       	ret

000039d8 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    39d8:	81 e0       	ldi	r24, 0x01	; 1
    39da:	08 95       	ret

000039dc <_ZN8emstream7getcharEv>:
    39dc:	80 e0       	ldi	r24, 0x00	; 0
    39de:	90 e0       	ldi	r25, 0x00	; 0
    39e0:	08 95       	ret

000039e2 <_ZN8emstream14check_for_charEv>:
    39e2:	80 e0       	ldi	r24, 0x00	; 0
    39e4:	08 95       	ret

000039e6 <_ZN8emstream12transmit_nowEv>:
    39e6:	08 95       	ret

000039e8 <_ZN8emstream12clear_screenEv>:
    39e8:	08 95       	ret

000039ea <_ZN8emstreamC1Ev>:
    39ea:	fc 01       	movw	r30, r24
    39ec:	8b e5       	ldi	r24, 0x5B	; 91
    39ee:	90 e2       	ldi	r25, 0x20	; 32
    39f0:	80 83       	st	Z, r24
    39f2:	91 83       	std	Z+1, r25	; 0x01
    39f4:	8a e0       	ldi	r24, 0x0A	; 10
    39f6:	82 83       	std	Z+2, r24	; 0x02
    39f8:	13 82       	std	Z+3, r1	; 0x03
    39fa:	83 e0       	ldi	r24, 0x03	; 3
    39fc:	85 83       	std	Z+5, r24	; 0x05
    39fe:	14 82       	std	Z+4, r1	; 0x04
    3a00:	16 82       	std	Z+6, r1	; 0x06
    3a02:	17 82       	std	Z+7, r1	; 0x07
    3a04:	08 95       	ret

00003a06 <_ZN8emstream4putsEPKc>:
    3a06:	0f 93       	push	r16
    3a08:	1f 93       	push	r17
    3a0a:	cf 93       	push	r28
    3a0c:	df 93       	push	r29
    3a0e:	8c 01       	movw	r16, r24
    3a10:	fb 01       	movw	r30, r22
    3a12:	dc 01       	movw	r26, r24
    3a14:	14 96       	adiw	r26, 0x04	; 4
    3a16:	8c 91       	ld	r24, X
    3a18:	81 11       	cpse	r24, r1
    3a1a:	04 c0       	rjmp	.+8      	; 0x3a24 <_ZN8emstream4putsEPKc+0x1e>
    3a1c:	60 81       	ld	r22, Z
    3a1e:	61 11       	cpse	r22, r1
    3a20:	17 c0       	rjmp	.+46     	; 0x3a50 <_ZN8emstream4putsEPKc+0x4a>
    3a22:	23 c0       	rjmp	.+70     	; 0x3a6a <_ZN8emstream4putsEPKc+0x64>
    3a24:	d8 01       	movw	r26, r16
    3a26:	14 96       	adiw	r26, 0x04	; 4
    3a28:	1c 92       	st	X, r1
    3a2a:	eb 01       	movw	r28, r22
    3a2c:	21 96       	adiw	r28, 0x01	; 1
    3a2e:	64 91       	lpm	r22, Z
    3a30:	66 23       	and	r22, r22
    3a32:	d9 f0       	breq	.+54     	; 0x3a6a <_ZN8emstream4putsEPKc+0x64>
    3a34:	d8 01       	movw	r26, r16
    3a36:	ed 91       	ld	r30, X+
    3a38:	fc 91       	ld	r31, X
    3a3a:	02 80       	ldd	r0, Z+2	; 0x02
    3a3c:	f3 81       	ldd	r31, Z+3	; 0x03
    3a3e:	e0 2d       	mov	r30, r0
    3a40:	c8 01       	movw	r24, r16
    3a42:	19 95       	eicall
    3a44:	fe 01       	movw	r30, r28
    3a46:	64 91       	lpm	r22, Z
    3a48:	21 96       	adiw	r28, 0x01	; 1
    3a4a:	61 11       	cpse	r22, r1
    3a4c:	f3 cf       	rjmp	.-26     	; 0x3a34 <_ZN8emstream4putsEPKc+0x2e>
    3a4e:	0d c0       	rjmp	.+26     	; 0x3a6a <_ZN8emstream4putsEPKc+0x64>
    3a50:	ef 01       	movw	r28, r30
    3a52:	21 96       	adiw	r28, 0x01	; 1
    3a54:	d8 01       	movw	r26, r16
    3a56:	ed 91       	ld	r30, X+
    3a58:	fc 91       	ld	r31, X
    3a5a:	02 80       	ldd	r0, Z+2	; 0x02
    3a5c:	f3 81       	ldd	r31, Z+3	; 0x03
    3a5e:	e0 2d       	mov	r30, r0
    3a60:	c8 01       	movw	r24, r16
    3a62:	19 95       	eicall
    3a64:	69 91       	ld	r22, Y+
    3a66:	61 11       	cpse	r22, r1
    3a68:	f5 cf       	rjmp	.-22     	; 0x3a54 <_ZN8emstream4putsEPKc+0x4e>
    3a6a:	df 91       	pop	r29
    3a6c:	cf 91       	pop	r28
    3a6e:	1f 91       	pop	r17
    3a70:	0f 91       	pop	r16
    3a72:	08 95       	ret

00003a74 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3a74:	cf 93       	push	r28
    3a76:	df 93       	push	r29
    3a78:	ec 01       	movw	r28, r24
	switch (new_manip)
    3a7a:	86 2f       	mov	r24, r22
    3a7c:	90 e0       	ldi	r25, 0x00	; 0
    3a7e:	8b 30       	cpi	r24, 0x0B	; 11
    3a80:	91 05       	cpc	r25, r1
    3a82:	d8 f5       	brcc	.+118    	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
    3a84:	fc 01       	movw	r30, r24
    3a86:	88 27       	eor	r24, r24
    3a88:	e6 5a       	subi	r30, 0xA6	; 166
    3a8a:	fe 4f       	sbci	r31, 0xFE	; 254
    3a8c:	8f 4f       	sbci	r24, 0xFF	; 255
    3a8e:	0c 94 e1 22 	jmp	0x45c2	; 0x45c2 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3a92:	82 e0       	ldi	r24, 0x02	; 2
    3a94:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a96:	31 c0       	rjmp	.+98     	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3a98:	88 e0       	ldi	r24, 0x08	; 8
    3a9a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a9c:	2e c0       	rjmp	.+92     	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3a9e:	8a e0       	ldi	r24, 0x0A	; 10
    3aa0:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3aa2:	2b c0       	rjmp	.+86     	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3aa4:	80 e1       	ldi	r24, 0x10	; 16
    3aa6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3aa8:	28 c0       	rjmp	.+80     	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3aaa:	81 e0       	ldi	r24, 0x01	; 1
    3aac:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3aae:	25 c0       	rjmp	.+74     	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3ab0:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3ab2:	23 c0       	rjmp	.+70     	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3ab4:	e8 81       	ld	r30, Y
    3ab6:	f9 81       	ldd	r31, Y+1	; 0x01
    3ab8:	02 80       	ldd	r0, Z+2	; 0x02
    3aba:	f3 81       	ldd	r31, Z+3	; 0x03
    3abc:	e0 2d       	mov	r30, r0
    3abe:	6d e0       	ldi	r22, 0x0D	; 13
    3ac0:	ce 01       	movw	r24, r28
    3ac2:	19 95       	eicall
    3ac4:	e8 81       	ld	r30, Y
    3ac6:	f9 81       	ldd	r31, Y+1	; 0x01
    3ac8:	02 80       	ldd	r0, Z+2	; 0x02
    3aca:	f3 81       	ldd	r31, Z+3	; 0x03
    3acc:	e0 2d       	mov	r30, r0
    3ace:	6a e0       	ldi	r22, 0x0A	; 10
    3ad0:	ce 01       	movw	r24, r28
    3ad2:	19 95       	eicall
			break;
    3ad4:	12 c0       	rjmp	.+36     	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3ad6:	e8 81       	ld	r30, Y
    3ad8:	f9 81       	ldd	r31, Y+1	; 0x01
    3ada:	02 84       	ldd	r0, Z+10	; 0x0a
    3adc:	f3 85       	ldd	r31, Z+11	; 0x0b
    3ade:	e0 2d       	mov	r30, r0
    3ae0:	ce 01       	movw	r24, r28
    3ae2:	19 95       	eicall
			break;
    3ae4:	0a c0       	rjmp	.+20     	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3ae6:	e8 81       	ld	r30, Y
    3ae8:	f9 81       	ldd	r31, Y+1	; 0x01
    3aea:	00 84       	ldd	r0, Z+8	; 0x08
    3aec:	f1 85       	ldd	r31, Z+9	; 0x09
    3aee:	e0 2d       	mov	r30, r0
    3af0:	ce 01       	movw	r24, r28
    3af2:	19 95       	eicall
			break;
    3af4:	02 c0       	rjmp	.+4      	; 0x3afa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3af6:	81 e0       	ldi	r24, 0x01	; 1
    3af8:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3afa:	ce 01       	movw	r24, r28
    3afc:	df 91       	pop	r29
    3afe:	cf 91       	pop	r28
    3b00:	08 95       	ret

00003b02 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    3b02:	0f 93       	push	r16
    3b04:	1f 93       	push	r17
    3b06:	cf 93       	push	r28
    3b08:	df 93       	push	r29
    3b0a:	cd b7       	in	r28, 0x3d	; 61
    3b0c:	de b7       	in	r29, 0x3e	; 62
    3b0e:	61 97       	sbiw	r28, 0x11	; 17
    3b10:	cd bf       	out	0x3d, r28	; 61
    3b12:	de bf       	out	0x3e, r29	; 62
    3b14:	8c 01       	movw	r16, r24
    3b16:	9b 01       	movw	r18, r22
	if (base != 10)
    3b18:	fc 01       	movw	r30, r24
    3b1a:	92 81       	ldd	r25, Z+2	; 0x02
    3b1c:	9a 30       	cpi	r25, 0x0A	; 10
    3b1e:	21 f0       	breq	.+8      	; 0x3b28 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    3b20:	c8 01       	movw	r24, r16
    3b22:	0e 94 aa 1d 	call	0x3b54	; 0x3b54 <_ZN8emstreamlsEj>
    3b26:	0d c0       	rjmp	.+26     	; 0x3b42 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3b28:	4a e0       	ldi	r20, 0x0A	; 10
    3b2a:	be 01       	movw	r22, r28
    3b2c:	6f 5f       	subi	r22, 0xFF	; 255
    3b2e:	7f 4f       	sbci	r23, 0xFF	; 255
    3b30:	c9 01       	movw	r24, r18
    3b32:	0e 94 4e 23 	call	0x469c	; 0x469c <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    3b36:	be 01       	movw	r22, r28
    3b38:	6f 5f       	subi	r22, 0xFF	; 255
    3b3a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b3c:	c8 01       	movw	r24, r16
    3b3e:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3b42:	c8 01       	movw	r24, r16
    3b44:	61 96       	adiw	r28, 0x11	; 17
    3b46:	cd bf       	out	0x3d, r28	; 61
    3b48:	de bf       	out	0x3e, r29	; 62
    3b4a:	df 91       	pop	r29
    3b4c:	cf 91       	pop	r28
    3b4e:	1f 91       	pop	r17
    3b50:	0f 91       	pop	r16
    3b52:	08 95       	ret

00003b54 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3b54:	ff 92       	push	r15
    3b56:	0f 93       	push	r16
    3b58:	1f 93       	push	r17
    3b5a:	cf 93       	push	r28
    3b5c:	df 93       	push	r29
    3b5e:	cd b7       	in	r28, 0x3d	; 61
    3b60:	de b7       	in	r29, 0x3e	; 62
    3b62:	61 97       	sbiw	r28, 0x11	; 17
    3b64:	cd bf       	out	0x3d, r28	; 61
    3b66:	de bf       	out	0x3e, r29	; 62
    3b68:	8c 01       	movw	r16, r24
    3b6a:	f6 2e       	mov	r15, r22
    3b6c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3b6e:	f8 01       	movw	r30, r16
    3b70:	42 81       	ldd	r20, Z+2	; 0x02
    3b72:	40 31       	cpi	r20, 0x10	; 16
    3b74:	21 f0       	breq	.+8      	; 0x3b7e <_ZN8emstreamlsEj+0x2a>
    3b76:	48 30       	cpi	r20, 0x08	; 8
    3b78:	11 f0       	breq	.+4      	; 0x3b7e <_ZN8emstreamlsEj+0x2a>
    3b7a:	42 30       	cpi	r20, 0x02	; 2
    3b7c:	41 f4       	brne	.+16     	; 0x3b8e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3b7e:	69 2f       	mov	r22, r25
    3b80:	c8 01       	movw	r24, r16
    3b82:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
    3b86:	6f 2d       	mov	r22, r15
    3b88:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
    3b8c:	0d c0       	rjmp	.+26     	; 0x3ba8 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3b8e:	50 e0       	ldi	r21, 0x00	; 0
    3b90:	be 01       	movw	r22, r28
    3b92:	6f 5f       	subi	r22, 0xFF	; 255
    3b94:	7f 4f       	sbci	r23, 0xFF	; 255
    3b96:	8f 2d       	mov	r24, r15
    3b98:	0e 94 86 23 	call	0x470c	; 0x470c <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3b9c:	be 01       	movw	r22, r28
    3b9e:	6f 5f       	subi	r22, 0xFF	; 255
    3ba0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ba2:	c8 01       	movw	r24, r16
    3ba4:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3ba8:	c8 01       	movw	r24, r16
    3baa:	61 96       	adiw	r28, 0x11	; 17
    3bac:	cd bf       	out	0x3d, r28	; 61
    3bae:	de bf       	out	0x3e, r29	; 62
    3bb0:	df 91       	pop	r29
    3bb2:	cf 91       	pop	r28
    3bb4:	1f 91       	pop	r17
    3bb6:	0f 91       	pop	r16
    3bb8:	ff 90       	pop	r15
    3bba:	08 95       	ret

00003bbc <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3bbc:	df 92       	push	r13
    3bbe:	ef 92       	push	r14
    3bc0:	ff 92       	push	r15
    3bc2:	0f 93       	push	r16
    3bc4:	1f 93       	push	r17
    3bc6:	cf 93       	push	r28
    3bc8:	df 93       	push	r29
    3bca:	cd b7       	in	r28, 0x3d	; 61
    3bcc:	de b7       	in	r29, 0x3e	; 62
    3bce:	a1 97       	sbiw	r28, 0x21	; 33
    3bd0:	cd bf       	out	0x3d, r28	; 61
    3bd2:	de bf       	out	0x3e, r29	; 62
    3bd4:	8c 01       	movw	r16, r24
    3bd6:	d4 2e       	mov	r13, r20
    3bd8:	e5 2e       	mov	r14, r21
    3bda:	f6 2e       	mov	r15, r22
    3bdc:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3bde:	f8 01       	movw	r30, r16
    3be0:	22 81       	ldd	r18, Z+2	; 0x02
    3be2:	20 31       	cpi	r18, 0x10	; 16
    3be4:	21 f0       	breq	.+8      	; 0x3bee <_ZN8emstreamlsEm+0x32>
    3be6:	28 30       	cpi	r18, 0x08	; 8
    3be8:	11 f0       	breq	.+4      	; 0x3bee <_ZN8emstreamlsEm+0x32>
    3bea:	22 30       	cpi	r18, 0x02	; 2
    3bec:	71 f4       	brne	.+28     	; 0x3c0a <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3bee:	69 2f       	mov	r22, r25
    3bf0:	c8 01       	movw	r24, r16
    3bf2:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
    3bf6:	6f 2d       	mov	r22, r15
    3bf8:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
    3bfc:	6e 2d       	mov	r22, r14
    3bfe:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
    3c02:	6d 2d       	mov	r22, r13
    3c04:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <_ZN8emstreamlsEh>
    3c08:	0f c0       	rjmp	.+30     	; 0x3c28 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3c0a:	30 e0       	ldi	r19, 0x00	; 0
    3c0c:	ae 01       	movw	r20, r28
    3c0e:	4f 5f       	subi	r20, 0xFF	; 255
    3c10:	5f 4f       	sbci	r21, 0xFF	; 255
    3c12:	6d 2d       	mov	r22, r13
    3c14:	7e 2d       	mov	r23, r14
    3c16:	8f 2d       	mov	r24, r15
    3c18:	0e 94 59 23 	call	0x46b2	; 0x46b2 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3c1c:	be 01       	movw	r22, r28
    3c1e:	6f 5f       	subi	r22, 0xFF	; 255
    3c20:	7f 4f       	sbci	r23, 0xFF	; 255
    3c22:	c8 01       	movw	r24, r16
    3c24:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3c28:	c8 01       	movw	r24, r16
    3c2a:	a1 96       	adiw	r28, 0x21	; 33
    3c2c:	cd bf       	out	0x3d, r28	; 61
    3c2e:	de bf       	out	0x3e, r29	; 62
    3c30:	df 91       	pop	r29
    3c32:	cf 91       	pop	r28
    3c34:	1f 91       	pop	r17
    3c36:	0f 91       	pop	r16
    3c38:	ff 90       	pop	r15
    3c3a:	ef 90       	pop	r14
    3c3c:	df 90       	pop	r13
    3c3e:	08 95       	ret

00003c40 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3c40:	cf 92       	push	r12
    3c42:	df 92       	push	r13
    3c44:	ef 92       	push	r14
    3c46:	ff 92       	push	r15
    3c48:	0f 93       	push	r16
    3c4a:	1f 93       	push	r17
    3c4c:	cf 93       	push	r28
    3c4e:	df 93       	push	r29
    3c50:	cd b7       	in	r28, 0x3d	; 61
    3c52:	de b7       	in	r29, 0x3e	; 62
    3c54:	29 97       	sbiw	r28, 0x09	; 9
    3c56:	cd bf       	out	0x3d, r28	; 61
    3c58:	de bf       	out	0x3e, r29	; 62
    3c5a:	8c 01       	movw	r16, r24
    3c5c:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3c5e:	dc 01       	movw	r26, r24
    3c60:	13 96       	adiw	r26, 0x03	; 3
    3c62:	8c 91       	ld	r24, X
    3c64:	13 97       	sbiw	r26, 0x03	; 3
    3c66:	88 23       	and	r24, r24
    3c68:	41 f0       	breq	.+16     	; 0x3c7a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3c6a:	ed 91       	ld	r30, X+
    3c6c:	fc 91       	ld	r31, X
    3c6e:	02 80       	ldd	r0, Z+2	; 0x02
    3c70:	f3 81       	ldd	r31, Z+3	; 0x03
    3c72:	e0 2d       	mov	r30, r0
    3c74:	c8 01       	movw	r24, r16
    3c76:	19 95       	eicall
    3c78:	56 c0       	rjmp	.+172    	; 0x3d26 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3c7a:	f8 01       	movw	r30, r16
    3c7c:	42 81       	ldd	r20, Z+2	; 0x02
    3c7e:	42 30       	cpi	r20, 0x02	; 2
    3c80:	19 f5       	brne	.+70     	; 0x3cc8 <_ZN8emstreamlsEh+0x88>
    3c82:	68 94       	set
    3c84:	cc 24       	eor	r12, r12
    3c86:	c3 f8       	bld	r12, 3
    3c88:	d1 2c       	mov	r13, r1
    3c8a:	68 94       	set
    3c8c:	ff 24       	eor	r15, r15
    3c8e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3c90:	8e 2d       	mov	r24, r14
    3c92:	8f 21       	and	r24, r15
    3c94:	51 f0       	breq	.+20     	; 0x3caa <_ZN8emstreamlsEh+0x6a>
    3c96:	d8 01       	movw	r26, r16
    3c98:	ed 91       	ld	r30, X+
    3c9a:	fc 91       	ld	r31, X
    3c9c:	02 80       	ldd	r0, Z+2	; 0x02
    3c9e:	f3 81       	ldd	r31, Z+3	; 0x03
    3ca0:	e0 2d       	mov	r30, r0
    3ca2:	61 e3       	ldi	r22, 0x31	; 49
    3ca4:	c8 01       	movw	r24, r16
    3ca6:	19 95       	eicall
    3ca8:	09 c0       	rjmp	.+18     	; 0x3cbc <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3caa:	d8 01       	movw	r26, r16
    3cac:	ed 91       	ld	r30, X+
    3cae:	fc 91       	ld	r31, X
    3cb0:	02 80       	ldd	r0, Z+2	; 0x02
    3cb2:	f3 81       	ldd	r31, Z+3	; 0x03
    3cb4:	e0 2d       	mov	r30, r0
    3cb6:	60 e3       	ldi	r22, 0x30	; 48
    3cb8:	c8 01       	movw	r24, r16
    3cba:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3cbc:	f6 94       	lsr	r15
    3cbe:	b1 e0       	ldi	r27, 0x01	; 1
    3cc0:	cb 1a       	sub	r12, r27
    3cc2:	d1 08       	sbc	r13, r1
    3cc4:	29 f7       	brne	.-54     	; 0x3c90 <_ZN8emstreamlsEh+0x50>
    3cc6:	2f c0       	rjmp	.+94     	; 0x3d26 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3cc8:	40 31       	cpi	r20, 0x10	; 16
    3cca:	f9 f4       	brne	.+62     	; 0x3d0a <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3ccc:	62 95       	swap	r22
    3cce:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3cd0:	01 90       	ld	r0, Z+
    3cd2:	f0 81       	ld	r31, Z
    3cd4:	e0 2d       	mov	r30, r0
    3cd6:	02 80       	ldd	r0, Z+2	; 0x02
    3cd8:	f3 81       	ldd	r31, Z+3	; 0x03
    3cda:	e0 2d       	mov	r30, r0
    3cdc:	6a 30       	cpi	r22, 0x0A	; 10
    3cde:	10 f0       	brcs	.+4      	; 0x3ce4 <_ZN8emstreamlsEh+0xa4>
    3ce0:	69 5c       	subi	r22, 0xC9	; 201
    3ce2:	01 c0       	rjmp	.+2      	; 0x3ce6 <_ZN8emstreamlsEh+0xa6>
    3ce4:	60 5d       	subi	r22, 0xD0	; 208
    3ce6:	c8 01       	movw	r24, r16
    3ce8:	19 95       	eicall
		temp_char = num & 0x0F;
    3cea:	6e 2d       	mov	r22, r14
    3cec:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3cee:	d8 01       	movw	r26, r16
    3cf0:	ed 91       	ld	r30, X+
    3cf2:	fc 91       	ld	r31, X
    3cf4:	02 80       	ldd	r0, Z+2	; 0x02
    3cf6:	f3 81       	ldd	r31, Z+3	; 0x03
    3cf8:	e0 2d       	mov	r30, r0
    3cfa:	6a 30       	cpi	r22, 0x0A	; 10
    3cfc:	10 f0       	brcs	.+4      	; 0x3d02 <_ZN8emstreamlsEh+0xc2>
    3cfe:	69 5c       	subi	r22, 0xC9	; 201
    3d00:	01 c0       	rjmp	.+2      	; 0x3d04 <_ZN8emstreamlsEh+0xc4>
    3d02:	60 5d       	subi	r22, 0xD0	; 208
    3d04:	c8 01       	movw	r24, r16
    3d06:	19 95       	eicall
    3d08:	0e c0       	rjmp	.+28     	; 0x3d26 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3d0a:	50 e0       	ldi	r21, 0x00	; 0
    3d0c:	be 01       	movw	r22, r28
    3d0e:	6f 5f       	subi	r22, 0xFF	; 255
    3d10:	7f 4f       	sbci	r23, 0xFF	; 255
    3d12:	8e 2d       	mov	r24, r14
    3d14:	90 e0       	ldi	r25, 0x00	; 0
    3d16:	0e 94 86 23 	call	0x470c	; 0x470c <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3d1a:	be 01       	movw	r22, r28
    3d1c:	6f 5f       	subi	r22, 0xFF	; 255
    3d1e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d20:	c8 01       	movw	r24, r16
    3d22:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3d26:	c8 01       	movw	r24, r16
    3d28:	29 96       	adiw	r28, 0x09	; 9
    3d2a:	cd bf       	out	0x3d, r28	; 61
    3d2c:	de bf       	out	0x3e, r29	; 62
    3d2e:	df 91       	pop	r29
    3d30:	cf 91       	pop	r28
    3d32:	1f 91       	pop	r17
    3d34:	0f 91       	pop	r16
    3d36:	ff 90       	pop	r15
    3d38:	ef 90       	pop	r14
    3d3a:	df 90       	pop	r13
    3d3c:	cf 90       	pop	r12
    3d3e:	08 95       	ret

00003d40 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3d40:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3d42:	50 96       	adiw	r26, 0x10	; 16
    3d44:	ed 91       	ld	r30, X+
    3d46:	fc 91       	ld	r31, X
    3d48:	51 97       	sbiw	r26, 0x11	; 17
    3d4a:	80 81       	ld	r24, Z
    3d4c:	54 96       	adiw	r26, 0x14	; 20
    3d4e:	4c 91       	ld	r20, X
    3d50:	54 97       	sbiw	r26, 0x14	; 20
    3d52:	84 23       	and	r24, r20
    3d54:	29 f0       	breq	.+10     	; 0x3d60 <_ZN5rs2327putcharEc+0x20>
    3d56:	09 c0       	rjmp	.+18     	; 0x3d6a <_ZN5rs2327putcharEc+0x2a>
    3d58:	21 50       	subi	r18, 0x01	; 1
    3d5a:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3d5c:	19 f4       	brne	.+6      	; 0x3d64 <_ZN5rs2327putcharEc+0x24>
    3d5e:	12 c0       	rjmp	.+36     	; 0x3d84 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3d60:	21 e2       	ldi	r18, 0x21	; 33
    3d62:	3e e4       	ldi	r19, 0x4E	; 78
    3d64:	90 81       	ld	r25, Z
    3d66:	94 23       	and	r25, r20
    3d68:	b9 f3       	breq	.-18     	; 0x3d58 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3d6a:	90 81       	ld	r25, Z
    3d6c:	56 96       	adiw	r26, 0x16	; 22
    3d6e:	8c 91       	ld	r24, X
    3d70:	56 97       	sbiw	r26, 0x16	; 22
    3d72:	89 2b       	or	r24, r25
    3d74:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3d76:	1e 96       	adiw	r26, 0x0e	; 14
    3d78:	ed 91       	ld	r30, X+
    3d7a:	fc 91       	ld	r31, X
    3d7c:	1f 97       	sbiw	r26, 0x0f	; 15
    3d7e:	60 83       	st	Z, r22
	return (true);
    3d80:	81 e0       	ldi	r24, 0x01	; 1
    3d82:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3d84:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3d86:	08 95       	ret

00003d88 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3d88:	cf 93       	push	r28
    3d8a:	df 93       	push	r29
    3d8c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3d8e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3d90:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3d92:	28 81       	ld	r18, Y
    3d94:	39 81       	ldd	r19, Y+1	; 0x01
    3d96:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3d98:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3d9a:	4d 91       	ld	r20, X+
    3d9c:	5c 91       	ld	r21, X
    3d9e:	24 17       	cp	r18, r20
    3da0:	35 07       	cpc	r19, r21
    3da2:	e9 f3       	breq	.-6      	; 0x3d9e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3da4:	a7 89       	ldd	r26, Z+23	; 0x17
    3da6:	b0 8d       	ldd	r27, Z+24	; 0x18
    3da8:	0d 90       	ld	r0, X+
    3daa:	bc 91       	ld	r27, X
    3dac:	a0 2d       	mov	r26, r0
    3dae:	a2 0f       	add	r26, r18
    3db0:	b3 1f       	adc	r27, r19
    3db2:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3db4:	2f 5f       	subi	r18, 0xFF	; 255
    3db6:	3f 4f       	sbci	r19, 0xFF	; 255
    3db8:	28 83       	st	Y, r18
    3dba:	39 83       	std	Y+1, r19	; 0x01
    3dbc:	24 36       	cpi	r18, 0x64	; 100
    3dbe:	31 05       	cpc	r19, r1
    3dc0:	28 f0       	brcs	.+10     	; 0x3dcc <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3dc2:	01 8c       	ldd	r0, Z+25	; 0x19
    3dc4:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3dc6:	e0 2d       	mov	r30, r0
    3dc8:	10 82       	st	Z, r1
    3dca:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3dcc:	90 e0       	ldi	r25, 0x00	; 0
    3dce:	df 91       	pop	r29
    3dd0:	cf 91       	pop	r28
    3dd2:	08 95       	ret

00003dd4 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3dd4:	cf 93       	push	r28
    3dd6:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3dd8:	ec 01       	movw	r28, r24
    3dda:	a9 8d       	ldd	r26, Y+25	; 0x19
    3ddc:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3dde:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3de0:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3de2:	81 e0       	ldi	r24, 0x01	; 1
    3de4:	4d 91       	ld	r20, X+
    3de6:	5c 91       	ld	r21, X
    3de8:	20 81       	ld	r18, Z
    3dea:	31 81       	ldd	r19, Z+1	; 0x01
    3dec:	42 17       	cp	r20, r18
    3dee:	53 07       	cpc	r21, r19
    3df0:	09 f4       	brne	.+2      	; 0x3df4 <_ZN5rs23214check_for_charEv+0x20>
    3df2:	80 e0       	ldi	r24, 0x00	; 0
}
    3df4:	df 91       	pop	r29
    3df6:	cf 91       	pop	r28
    3df8:	08 95       	ret

00003dfa <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3dfa:	dc 01       	movw	r26, r24
    3dfc:	ed 91       	ld	r30, X+
    3dfe:	fc 91       	ld	r31, X
    3e00:	02 80       	ldd	r0, Z+2	; 0x02
    3e02:	f3 81       	ldd	r31, Z+3	; 0x03
    3e04:	e0 2d       	mov	r30, r0
    3e06:	6c e0       	ldi	r22, 0x0C	; 12
    3e08:	19 95       	eicall
    3e0a:	08 95       	ret

00003e0c <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3e0c:	ef 92       	push	r14
    3e0e:	ff 92       	push	r15
    3e10:	0f 93       	push	r16
    3e12:	1f 93       	push	r17
    3e14:	cf 93       	push	r28
    3e16:	df 93       	push	r29
    3e18:	ec 01       	movw	r28, r24
    3e1a:	7b 01       	movw	r14, r22
    3e1c:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3e1e:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <_ZN8emstreamC1Ev>
    3e22:	a8 01       	movw	r20, r16
    3e24:	b7 01       	movw	r22, r14
    3e26:	ce 01       	movw	r24, r28
    3e28:	08 96       	adiw	r24, 0x08	; 8
    3e2a:	0e 94 56 1c 	call	0x38ac	; 0x38ac <_ZN7base232C1EjP12USART_struct>
    3e2e:	8b e6       	ldi	r24, 0x6B	; 107
    3e30:	90 e2       	ldi	r25, 0x20	; 32
    3e32:	88 83       	st	Y, r24
    3e34:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3e36:	00 3a       	cpi	r16, 0xA0	; 160
    3e38:	88 e0       	ldi	r24, 0x08	; 8
    3e3a:	18 07       	cpc	r17, r24
    3e3c:	69 f4       	brne	.+26     	; 0x3e58 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3e3e:	84 e4       	ldi	r24, 0x44	; 68
    3e40:	91 e3       	ldi	r25, 0x31	; 49
    3e42:	8f 8b       	std	Y+23, r24	; 0x17
    3e44:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3e46:	8a e3       	ldi	r24, 0x3A	; 58
    3e48:	91 e3       	ldi	r25, 0x31	; 49
    3e4a:	89 8f       	std	Y+25, r24	; 0x19
    3e4c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3e4e:	80 e3       	ldi	r24, 0x30	; 48
    3e50:	91 e3       	ldi	r25, 0x31	; 49
    3e52:	8b 8f       	std	Y+27, r24	; 0x1b
    3e54:	9c 8f       	std	Y+28, r25	; 0x1c
    3e56:	42 c0       	rjmp	.+132    	; 0x3edc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3e58:	00 3b       	cpi	r16, 0xB0	; 176
    3e5a:	e8 e0       	ldi	r30, 0x08	; 8
    3e5c:	1e 07       	cpc	r17, r30
    3e5e:	69 f4       	brne	.+26     	; 0x3e7a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3e60:	82 e4       	ldi	r24, 0x42	; 66
    3e62:	91 e3       	ldi	r25, 0x31	; 49
    3e64:	8f 8b       	std	Y+23, r24	; 0x17
    3e66:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3e68:	88 e3       	ldi	r24, 0x38	; 56
    3e6a:	91 e3       	ldi	r25, 0x31	; 49
    3e6c:	89 8f       	std	Y+25, r24	; 0x19
    3e6e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3e70:	8e e2       	ldi	r24, 0x2E	; 46
    3e72:	91 e3       	ldi	r25, 0x31	; 49
    3e74:	8b 8f       	std	Y+27, r24	; 0x1b
    3e76:	9c 8f       	std	Y+28, r25	; 0x1c
    3e78:	31 c0       	rjmp	.+98     	; 0x3edc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3e7a:	00 3a       	cpi	r16, 0xA0	; 160
    3e7c:	f9 e0       	ldi	r31, 0x09	; 9
    3e7e:	1f 07       	cpc	r17, r31
    3e80:	69 f4       	brne	.+26     	; 0x3e9c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3e82:	80 e4       	ldi	r24, 0x40	; 64
    3e84:	91 e3       	ldi	r25, 0x31	; 49
    3e86:	8f 8b       	std	Y+23, r24	; 0x17
    3e88:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3e8a:	86 e3       	ldi	r24, 0x36	; 54
    3e8c:	91 e3       	ldi	r25, 0x31	; 49
    3e8e:	89 8f       	std	Y+25, r24	; 0x19
    3e90:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3e92:	8c e2       	ldi	r24, 0x2C	; 44
    3e94:	91 e3       	ldi	r25, 0x31	; 49
    3e96:	8b 8f       	std	Y+27, r24	; 0x1b
    3e98:	9c 8f       	std	Y+28, r25	; 0x1c
    3e9a:	20 c0       	rjmp	.+64     	; 0x3edc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3e9c:	00 3b       	cpi	r16, 0xB0	; 176
    3e9e:	89 e0       	ldi	r24, 0x09	; 9
    3ea0:	18 07       	cpc	r17, r24
    3ea2:	69 f4       	brne	.+26     	; 0x3ebe <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3ea4:	8e e3       	ldi	r24, 0x3E	; 62
    3ea6:	91 e3       	ldi	r25, 0x31	; 49
    3ea8:	8f 8b       	std	Y+23, r24	; 0x17
    3eaa:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3eac:	84 e3       	ldi	r24, 0x34	; 52
    3eae:	91 e3       	ldi	r25, 0x31	; 49
    3eb0:	89 8f       	std	Y+25, r24	; 0x19
    3eb2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3eb4:	8a e2       	ldi	r24, 0x2A	; 42
    3eb6:	91 e3       	ldi	r25, 0x31	; 49
    3eb8:	8b 8f       	std	Y+27, r24	; 0x1b
    3eba:	9c 8f       	std	Y+28, r25	; 0x1c
    3ebc:	0f c0       	rjmp	.+30     	; 0x3edc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3ebe:	00 3a       	cpi	r16, 0xA0	; 160
    3ec0:	1a 40       	sbci	r17, 0x0A	; 10
    3ec2:	61 f4       	brne	.+24     	; 0x3edc <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3ec4:	8c e3       	ldi	r24, 0x3C	; 60
    3ec6:	91 e3       	ldi	r25, 0x31	; 49
    3ec8:	8f 8b       	std	Y+23, r24	; 0x17
    3eca:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3ecc:	82 e3       	ldi	r24, 0x32	; 50
    3ece:	91 e3       	ldi	r25, 0x31	; 49
    3ed0:	89 8f       	std	Y+25, r24	; 0x19
    3ed2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3ed4:	88 e2       	ldi	r24, 0x28	; 40
    3ed6:	91 e3       	ldi	r25, 0x31	; 49
    3ed8:	8b 8f       	std	Y+27, r24	; 0x1b
    3eda:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3edc:	0f 89       	ldd	r16, Y+23	; 0x17
    3ede:	18 8d       	ldd	r17, Y+24	; 0x18
    3ee0:	84 e6       	ldi	r24, 0x64	; 100
    3ee2:	90 e0       	ldi	r25, 0x00	; 0
    3ee4:	0e 94 52 1c 	call	0x38a4	; 0x38a4 <_Znaj>
    3ee8:	f8 01       	movw	r30, r16
    3eea:	80 83       	st	Z, r24
    3eec:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3eee:	e9 8d       	ldd	r30, Y+25	; 0x19
    3ef0:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3ef2:	10 82       	st	Z, r1
    3ef4:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3ef6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3ef8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3efa:	10 82       	st	Z, r1
    3efc:	11 82       	std	Z+1, r1	; 0x01
}
    3efe:	df 91       	pop	r29
    3f00:	cf 91       	pop	r28
    3f02:	1f 91       	pop	r17
    3f04:	0f 91       	pop	r16
    3f06:	ff 90       	pop	r15
    3f08:	ef 90       	pop	r14
    3f0a:	08 95       	ret

00003f0c <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3f0c:	1f 92       	push	r1
    3f0e:	0f 92       	push	r0
    3f10:	0f b6       	in	r0, 0x3f	; 63
    3f12:	0f 92       	push	r0
    3f14:	11 24       	eor	r1, r1
    3f16:	08 b6       	in	r0, 0x38	; 56
    3f18:	0f 92       	push	r0
    3f1a:	18 be       	out	0x38, r1	; 56
    3f1c:	0b b6       	in	r0, 0x3b	; 59
    3f1e:	0f 92       	push	r0
    3f20:	1b be       	out	0x3b, r1	; 59
    3f22:	2f 93       	push	r18
    3f24:	3f 93       	push	r19
    3f26:	8f 93       	push	r24
    3f28:	9f 93       	push	r25
    3f2a:	ef 93       	push	r30
    3f2c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3f2e:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3f32:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    3f36:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    3f3a:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3f3e:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3f42:	e8 0f       	add	r30, r24
    3f44:	f9 1f       	adc	r31, r25
    3f46:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3f48:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3f4c:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3f50:	01 96       	adiw	r24, 0x01	; 1
    3f52:	84 36       	cpi	r24, 0x64	; 100
    3f54:	91 05       	cpc	r25, r1
    3f56:	60 f4       	brcc	.+24     	; 0x3f70 <__vector_25+0x64>
    3f58:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    3f5c:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f60:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    3f64:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3f68:	82 17       	cp	r24, r18
    3f6a:	93 07       	cpc	r25, r19
    3f6c:	f1 f4       	brne	.+60     	; 0x3faa <__vector_25+0x9e>
    3f6e:	0c c0       	rjmp	.+24     	; 0x3f88 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3f70:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    3f74:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f78:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    3f7c:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3f80:	18 16       	cp	r1, r24
    3f82:	19 06       	cpc	r1, r25
    3f84:	91 f4       	brne	.+36     	; 0x3faa <__vector_25+0x9e>
    3f86:	0e c0       	rjmp	.+28     	; 0x3fa4 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f88:	01 96       	adiw	r24, 0x01	; 1
    3f8a:	84 36       	cpi	r24, 0x64	; 100
    3f8c:	91 05       	cpc	r25, r1
    3f8e:	28 f4       	brcc	.+10     	; 0x3f9a <__vector_25+0x8e>
    3f90:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    3f94:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    3f98:	08 c0       	rjmp	.+16     	; 0x3faa <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3f9a:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    3f9e:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    3fa2:	03 c0       	rjmp	.+6      	; 0x3faa <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3fa4:	81 e0       	ldi	r24, 0x01	; 1
    3fa6:	90 e0       	ldi	r25, 0x00	; 0
    3fa8:	f3 cf       	rjmp	.-26     	; 0x3f90 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3faa:	ff 91       	pop	r31
    3fac:	ef 91       	pop	r30
    3fae:	9f 91       	pop	r25
    3fb0:	8f 91       	pop	r24
    3fb2:	3f 91       	pop	r19
    3fb4:	2f 91       	pop	r18
    3fb6:	0f 90       	pop	r0
    3fb8:	0b be       	out	0x3b, r0	; 59
    3fba:	0f 90       	pop	r0
    3fbc:	08 be       	out	0x38, r0	; 56
    3fbe:	0f 90       	pop	r0
    3fc0:	0f be       	out	0x3f, r0	; 63
    3fc2:	0f 90       	pop	r0
    3fc4:	1f 90       	pop	r1
    3fc6:	18 95       	reti

00003fc8 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3fc8:	1f 92       	push	r1
    3fca:	0f 92       	push	r0
    3fcc:	0f b6       	in	r0, 0x3f	; 63
    3fce:	0f 92       	push	r0
    3fd0:	11 24       	eor	r1, r1
    3fd2:	08 b6       	in	r0, 0x38	; 56
    3fd4:	0f 92       	push	r0
    3fd6:	18 be       	out	0x38, r1	; 56
    3fd8:	0b b6       	in	r0, 0x3b	; 59
    3fda:	0f 92       	push	r0
    3fdc:	1b be       	out	0x3b, r1	; 59
    3fde:	2f 93       	push	r18
    3fe0:	3f 93       	push	r19
    3fe2:	8f 93       	push	r24
    3fe4:	9f 93       	push	r25
    3fe6:	ef 93       	push	r30
    3fe8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3fea:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3fee:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    3ff2:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3ff6:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3ffa:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3ffe:	e8 0f       	add	r30, r24
    4000:	f9 1f       	adc	r31, r25
    4002:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    4004:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    4008:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    400c:	01 96       	adiw	r24, 0x01	; 1
    400e:	84 36       	cpi	r24, 0x64	; 100
    4010:	91 05       	cpc	r25, r1
    4012:	60 f4       	brcc	.+24     	; 0x402c <__stack+0x2d>
    4014:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    4018:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    401c:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    4020:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    4024:	82 17       	cp	r24, r18
    4026:	93 07       	cpc	r25, r19
    4028:	f1 f4       	brne	.+60     	; 0x4066 <__stack+0x67>
    402a:	0c c0       	rjmp	.+24     	; 0x4044 <__stack+0x45>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    402c:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    4030:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4034:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    4038:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    403c:	18 16       	cp	r1, r24
    403e:	19 06       	cpc	r1, r25
    4040:	91 f4       	brne	.+36     	; 0x4066 <__stack+0x67>
    4042:	0e c0       	rjmp	.+28     	; 0x4060 <__stack+0x61>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4044:	01 96       	adiw	r24, 0x01	; 1
    4046:	84 36       	cpi	r24, 0x64	; 100
    4048:	91 05       	cpc	r25, r1
    404a:	28 f4       	brcc	.+10     	; 0x4056 <__stack+0x57>
    404c:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    4050:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    4054:	08 c0       	rjmp	.+16     	; 0x4066 <__stack+0x67>
	rcvC1_read_index = 0;
    4056:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    405a:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    405e:	03 c0       	rjmp	.+6      	; 0x4066 <__stack+0x67>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4060:	81 e0       	ldi	r24, 0x01	; 1
    4062:	90 e0       	ldi	r25, 0x00	; 0
    4064:	f3 cf       	rjmp	.-26     	; 0x404c <__stack+0x4d>
	rcvC1_read_index = 0;
}
    4066:	ff 91       	pop	r31
    4068:	ef 91       	pop	r30
    406a:	9f 91       	pop	r25
    406c:	8f 91       	pop	r24
    406e:	3f 91       	pop	r19
    4070:	2f 91       	pop	r18
    4072:	0f 90       	pop	r0
    4074:	0b be       	out	0x3b, r0	; 59
    4076:	0f 90       	pop	r0
    4078:	08 be       	out	0x38, r0	; 56
    407a:	0f 90       	pop	r0
    407c:	0f be       	out	0x3f, r0	; 63
    407e:	0f 90       	pop	r0
    4080:	1f 90       	pop	r1
    4082:	18 95       	reti

00004084 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    4084:	1f 92       	push	r1
    4086:	0f 92       	push	r0
    4088:	0f b6       	in	r0, 0x3f	; 63
    408a:	0f 92       	push	r0
    408c:	11 24       	eor	r1, r1
    408e:	08 b6       	in	r0, 0x38	; 56
    4090:	0f 92       	push	r0
    4092:	18 be       	out	0x38, r1	; 56
    4094:	0b b6       	in	r0, 0x3b	; 59
    4096:	0f 92       	push	r0
    4098:	1b be       	out	0x3b, r1	; 59
    409a:	2f 93       	push	r18
    409c:	3f 93       	push	r19
    409e:	8f 93       	push	r24
    40a0:	9f 93       	push	r25
    40a2:	ef 93       	push	r30
    40a4:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    40a6:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    40aa:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    40ae:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    40b2:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    40b6:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    40ba:	e8 0f       	add	r30, r24
    40bc:	f9 1f       	adc	r31, r25
    40be:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    40c0:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    40c4:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    40c8:	01 96       	adiw	r24, 0x01	; 1
    40ca:	84 36       	cpi	r24, 0x64	; 100
    40cc:	91 05       	cpc	r25, r1
    40ce:	60 f4       	brcc	.+24     	; 0x40e8 <__vector_88+0x64>
    40d0:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    40d4:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    40d8:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    40dc:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    40e0:	82 17       	cp	r24, r18
    40e2:	93 07       	cpc	r25, r19
    40e4:	f1 f4       	brne	.+60     	; 0x4122 <__vector_88+0x9e>
    40e6:	0c c0       	rjmp	.+24     	; 0x4100 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    40e8:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    40ec:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    40f0:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    40f4:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    40f8:	18 16       	cp	r1, r24
    40fa:	19 06       	cpc	r1, r25
    40fc:	91 f4       	brne	.+36     	; 0x4122 <__vector_88+0x9e>
    40fe:	0e c0       	rjmp	.+28     	; 0x411c <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4100:	01 96       	adiw	r24, 0x01	; 1
    4102:	84 36       	cpi	r24, 0x64	; 100
    4104:	91 05       	cpc	r25, r1
    4106:	28 f4       	brcc	.+10     	; 0x4112 <__vector_88+0x8e>
    4108:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    410c:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    4110:	08 c0       	rjmp	.+16     	; 0x4122 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    4112:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    4116:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    411a:	03 c0       	rjmp	.+6      	; 0x4122 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    411c:	81 e0       	ldi	r24, 0x01	; 1
    411e:	90 e0       	ldi	r25, 0x00	; 0
    4120:	f3 cf       	rjmp	.-26     	; 0x4108 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    4122:	ff 91       	pop	r31
    4124:	ef 91       	pop	r30
    4126:	9f 91       	pop	r25
    4128:	8f 91       	pop	r24
    412a:	3f 91       	pop	r19
    412c:	2f 91       	pop	r18
    412e:	0f 90       	pop	r0
    4130:	0b be       	out	0x3b, r0	; 59
    4132:	0f 90       	pop	r0
    4134:	08 be       	out	0x38, r0	; 56
    4136:	0f 90       	pop	r0
    4138:	0f be       	out	0x3f, r0	; 63
    413a:	0f 90       	pop	r0
    413c:	1f 90       	pop	r1
    413e:	18 95       	reti

00004140 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    4140:	1f 92       	push	r1
    4142:	0f 92       	push	r0
    4144:	0f b6       	in	r0, 0x3f	; 63
    4146:	0f 92       	push	r0
    4148:	11 24       	eor	r1, r1
    414a:	08 b6       	in	r0, 0x38	; 56
    414c:	0f 92       	push	r0
    414e:	18 be       	out	0x38, r1	; 56
    4150:	0b b6       	in	r0, 0x3b	; 59
    4152:	0f 92       	push	r0
    4154:	1b be       	out	0x3b, r1	; 59
    4156:	2f 93       	push	r18
    4158:	3f 93       	push	r19
    415a:	8f 93       	push	r24
    415c:	9f 93       	push	r25
    415e:	ef 93       	push	r30
    4160:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    4162:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    4166:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    416a:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    416e:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    4172:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    4176:	e8 0f       	add	r30, r24
    4178:	f9 1f       	adc	r31, r25
    417a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    417c:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    4180:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    4184:	01 96       	adiw	r24, 0x01	; 1
    4186:	84 36       	cpi	r24, 0x64	; 100
    4188:	91 05       	cpc	r25, r1
    418a:	60 f4       	brcc	.+24     	; 0x41a4 <__vector_91+0x64>
    418c:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    4190:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4194:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    4198:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    419c:	82 17       	cp	r24, r18
    419e:	93 07       	cpc	r25, r19
    41a0:	f1 f4       	brne	.+60     	; 0x41de <__vector_91+0x9e>
    41a2:	0c c0       	rjmp	.+24     	; 0x41bc <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    41a4:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    41a8:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    41ac:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    41b0:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    41b4:	18 16       	cp	r1, r24
    41b6:	19 06       	cpc	r1, r25
    41b8:	91 f4       	brne	.+36     	; 0x41de <__vector_91+0x9e>
    41ba:	0e c0       	rjmp	.+28     	; 0x41d8 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    41bc:	01 96       	adiw	r24, 0x01	; 1
    41be:	84 36       	cpi	r24, 0x64	; 100
    41c0:	91 05       	cpc	r25, r1
    41c2:	28 f4       	brcc	.+10     	; 0x41ce <__vector_91+0x8e>
    41c4:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    41c8:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    41cc:	08 c0       	rjmp	.+16     	; 0x41de <__vector_91+0x9e>
	rcvD1_read_index = 0;
    41ce:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    41d2:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    41d6:	03 c0       	rjmp	.+6      	; 0x41de <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    41d8:	81 e0       	ldi	r24, 0x01	; 1
    41da:	90 e0       	ldi	r25, 0x00	; 0
    41dc:	f3 cf       	rjmp	.-26     	; 0x41c4 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    41de:	ff 91       	pop	r31
    41e0:	ef 91       	pop	r30
    41e2:	9f 91       	pop	r25
    41e4:	8f 91       	pop	r24
    41e6:	3f 91       	pop	r19
    41e8:	2f 91       	pop	r18
    41ea:	0f 90       	pop	r0
    41ec:	0b be       	out	0x3b, r0	; 59
    41ee:	0f 90       	pop	r0
    41f0:	08 be       	out	0x38, r0	; 56
    41f2:	0f 90       	pop	r0
    41f4:	0f be       	out	0x3f, r0	; 63
    41f6:	0f 90       	pop	r0
    41f8:	1f 90       	pop	r1
    41fa:	18 95       	reti

000041fc <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    41fc:	1f 92       	push	r1
    41fe:	0f 92       	push	r0
    4200:	0f b6       	in	r0, 0x3f	; 63
    4202:	0f 92       	push	r0
    4204:	11 24       	eor	r1, r1
    4206:	08 b6       	in	r0, 0x38	; 56
    4208:	0f 92       	push	r0
    420a:	18 be       	out	0x38, r1	; 56
    420c:	0b b6       	in	r0, 0x3b	; 59
    420e:	0f 92       	push	r0
    4210:	1b be       	out	0x3b, r1	; 59
    4212:	2f 93       	push	r18
    4214:	3f 93       	push	r19
    4216:	8f 93       	push	r24
    4218:	9f 93       	push	r25
    421a:	ef 93       	push	r30
    421c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    421e:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    4222:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    4226:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    422a:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    422e:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    4232:	e8 0f       	add	r30, r24
    4234:	f9 1f       	adc	r31, r25
    4236:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4238:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    423c:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    4240:	01 96       	adiw	r24, 0x01	; 1
    4242:	84 36       	cpi	r24, 0x64	; 100
    4244:	91 05       	cpc	r25, r1
    4246:	60 f4       	brcc	.+24     	; 0x4260 <__vector_58+0x64>
    4248:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    424c:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4250:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    4254:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    4258:	82 17       	cp	r24, r18
    425a:	93 07       	cpc	r25, r19
    425c:	f1 f4       	brne	.+60     	; 0x429a <__vector_58+0x9e>
    425e:	0c c0       	rjmp	.+24     	; 0x4278 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4260:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    4264:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4268:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    426c:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    4270:	18 16       	cp	r1, r24
    4272:	19 06       	cpc	r1, r25
    4274:	91 f4       	brne	.+36     	; 0x429a <__vector_58+0x9e>
    4276:	0e c0       	rjmp	.+28     	; 0x4294 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4278:	01 96       	adiw	r24, 0x01	; 1
    427a:	84 36       	cpi	r24, 0x64	; 100
    427c:	91 05       	cpc	r25, r1
    427e:	28 f4       	brcc	.+10     	; 0x428a <__vector_58+0x8e>
    4280:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    4284:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    4288:	08 c0       	rjmp	.+16     	; 0x429a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    428a:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    428e:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    4292:	03 c0       	rjmp	.+6      	; 0x429a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4294:	81 e0       	ldi	r24, 0x01	; 1
    4296:	90 e0       	ldi	r25, 0x00	; 0
    4298:	f3 cf       	rjmp	.-26     	; 0x4280 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    429a:	ff 91       	pop	r31
    429c:	ef 91       	pop	r30
    429e:	9f 91       	pop	r25
    42a0:	8f 91       	pop	r24
    42a2:	3f 91       	pop	r19
    42a4:	2f 91       	pop	r18
    42a6:	0f 90       	pop	r0
    42a8:	0b be       	out	0x3b, r0	; 59
    42aa:	0f 90       	pop	r0
    42ac:	08 be       	out	0x38, r0	; 56
    42ae:	0f 90       	pop	r0
    42b0:	0f be       	out	0x3f, r0	; 63
    42b2:	0f 90       	pop	r0
    42b4:	1f 90       	pop	r1
    42b6:	18 95       	reti

000042b8 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    42b8:	0f 93       	push	r16
    42ba:	cf 93       	push	r28
    42bc:	df 93       	push	r29
    42be:	1f 92       	push	r1
    42c0:	cd b7       	in	r28, 0x3d	; 61
    42c2:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    42c4:	2f b7       	in	r18, 0x3f	; 63
    42c6:	29 83       	std	Y+1, r18	; 0x01
	cli();
    42c8:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    42ca:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    42cc:	fc 01       	movw	r30, r24
    42ce:	08 ed       	ldi	r16, 0xD8	; 216
    42d0:	04 bf       	out	0x34, r16	; 52
    42d2:	60 83       	st	Z, r22

	SREG = saved_sreg;
    42d4:	89 81       	ldd	r24, Y+1	; 0x01
    42d6:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    42d8:	0f 90       	pop	r0
    42da:	df 91       	pop	r29
    42dc:	cf 91       	pop	r28
    42de:	0f 91       	pop	r16
    42e0:	08 95       	ret

000042e2 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    42e2:	0f 93       	push	r16
    42e4:	1f 93       	push	r17
    42e6:	cf 93       	push	r28
    42e8:	df 93       	push	r29
    42ea:	cd b7       	in	r28, 0x3d	; 61
    42ec:	de b7       	in	r29, 0x3e	; 62
    42ee:	6d 97       	sbiw	r28, 0x1d	; 29
    42f0:	cd bf       	out	0x3d, r28	; 61
    42f2:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    42f4:	e0 e6       	ldi	r30, 0x60	; 96
    42f6:	f6 e0       	ldi	r31, 0x06	; 6
    42f8:	80 e4       	ldi	r24, 0x40	; 64
    42fa:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    42fc:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    42fe:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    4300:	e0 e5       	ldi	r30, 0x50	; 80
    4302:	f0 e0       	ldi	r31, 0x00	; 0
    4304:	80 81       	ld	r24, Z
    4306:	82 60       	ori	r24, 0x02	; 2
    4308:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    430a:	81 81       	ldd	r24, Z+1	; 0x01
    430c:	81 ff       	sbrs	r24, 1
    430e:	fd cf       	rjmp	.-6      	; 0x430a <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4310:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4314:	68 7f       	andi	r22, 0xF8	; 248
    4316:	61 60       	ori	r22, 0x01	; 1
    4318:	80 e4       	ldi	r24, 0x40	; 64
    431a:	90 e0       	ldi	r25, 0x00	; 0
    431c:	0e 94 5c 21 	call	0x42b8	; 0x42b8 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4320:	e0 e5       	ldi	r30, 0x50	; 80
    4322:	f0 e0       	ldi	r31, 0x00	; 0
    4324:	80 81       	ld	r24, Z
    4326:	8e 7f       	andi	r24, 0xFE	; 254
    4328:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    432a:	9d ef       	ldi	r25, 0xFD	; 253
    432c:	88 ed       	ldi	r24, 0xD8	; 216
    432e:	08 b6       	in	r0, 0x38	; 56
    4330:	18 be       	out	0x38, r1	; 56
    4332:	84 bf       	out	0x34, r24	; 52
    4334:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4338:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    433a:	40 eb       	ldi	r20, 0xB0	; 176
    433c:	58 e0       	ldi	r21, 0x08	; 8
    433e:	60 e0       	ldi	r22, 0x00	; 0
    4340:	70 e0       	ldi	r23, 0x00	; 0
    4342:	ce 01       	movw	r24, r28
    4344:	01 96       	adiw	r24, 0x01	; 1
    4346:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    434a:	67 e0       	ldi	r22, 0x07	; 7
    434c:	ce 01       	movw	r24, r28
    434e:	01 96       	adiw	r24, 0x01	; 1
    4350:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    4354:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    4356:	67 e7       	ldi	r22, 0x77	; 119
    4358:	70 e2       	ldi	r23, 0x20	; 32
    435a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN8emstream4putsEPKc>
    435e:	66 e0       	ldi	r22, 0x06	; 6
    4360:	c8 01       	movw	r24, r16
    4362:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
    4366:	66 e0       	ldi	r22, 0x06	; 6
    4368:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    436c:	82 e1       	ldi	r24, 0x12	; 18
    436e:	90 e0       	ldi	r25, 0x00	; 0
    4370:	0e 94 4f 1c 	call	0x389e	; 0x389e <_Znwj>
    4374:	8e 01       	movw	r16, r28
    4376:	0f 5f       	subi	r16, 0xFF	; 255
    4378:	1f 4f       	sbci	r17, 0xFF	; 255
    437a:	24 e0       	ldi	r18, 0x04	; 4
    437c:	31 e0       	ldi	r19, 0x01	; 1
    437e:	40 e0       	ldi	r20, 0x00	; 0
    4380:	66 e9       	ldi	r22, 0x96	; 150
    4382:	70 e2       	ldi	r23, 0x20	; 32
    4384:	0e 94 7f 09 	call	0x12fe	; 0x12fe <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    4388:	82 e1       	ldi	r24, 0x12	; 18
    438a:	90 e0       	ldi	r25, 0x00	; 0
    438c:	0e 94 4f 1c 	call	0x389e	; 0x389e <_Znwj>
    4390:	24 e0       	ldi	r18, 0x04	; 4
    4392:	31 e0       	ldi	r19, 0x01	; 1
    4394:	42 e0       	ldi	r20, 0x02	; 2
    4396:	6e e9       	ldi	r22, 0x9E	; 158
    4398:	70 e2       	ldi	r23, 0x20	; 32
    439a:	0e 94 4b 04 	call	0x896	; 0x896 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    439e:	82 e1       	ldi	r24, 0x12	; 18
    43a0:	90 e0       	ldi	r25, 0x00	; 0
    43a2:	0e 94 4f 1c 	call	0x389e	; 0x389e <_Znwj>
    43a6:	24 e0       	ldi	r18, 0x04	; 4
    43a8:	31 e0       	ldi	r19, 0x01	; 1
    43aa:	43 e0       	ldi	r20, 0x03	; 3
    43ac:	65 ea       	ldi	r22, 0xA5	; 165
    43ae:	70 e2       	ldi	r23, 0x20	; 32
    43b0:	0e 94 a4 04 	call	0x948	; 0x948 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    43b4:	82 e1       	ldi	r24, 0x12	; 18
    43b6:	90 e0       	ldi	r25, 0x00	; 0
    43b8:	0e 94 4f 1c 	call	0x389e	; 0x389e <_Znwj>
    43bc:	24 e0       	ldi	r18, 0x04	; 4
    43be:	31 e0       	ldi	r19, 0x01	; 1
    43c0:	44 e0       	ldi	r20, 0x04	; 4
    43c2:	6c ea       	ldi	r22, 0xAC	; 172
    43c4:	70 e2       	ldi	r23, 0x20	; 32
    43c6:	0e 94 09 05 	call	0xa12	; 0xa12 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    43ca:	8c e6       	ldi	r24, 0x6C	; 108
    43cc:	90 e0       	ldi	r25, 0x00	; 0
    43ce:	0e 94 4f 1c 	call	0x389e	; 0x389e <_Znwj>
    43d2:	24 e0       	ldi	r18, 0x04	; 4
    43d4:	31 e0       	ldi	r19, 0x01	; 1
    43d6:	43 e0       	ldi	r20, 0x03	; 3
    43d8:	65 eb       	ldi	r22, 0xB5	; 181
    43da:	70 e2       	ldi	r23, 0x20	; 32
    43dc:	0e 94 41 09 	call	0x1282	; 0x1282 <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    43e0:	87 e0       	ldi	r24, 0x07	; 7
    43e2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    43e6:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    43e8:	0e 94 61 13 	call	0x26c2	; 0x26c2 <vTaskStartScheduler>
	
	
	return 0;
    43ec:	80 e0       	ldi	r24, 0x00	; 0
    43ee:	90 e0       	ldi	r25, 0x00	; 0
    43f0:	6d 96       	adiw	r28, 0x1d	; 29
    43f2:	cd bf       	out	0x3d, r28	; 61
    43f4:	de bf       	out	0x3e, r29	; 62
    43f6:	df 91       	pop	r29
    43f8:	cf 91       	pop	r28
    43fa:	1f 91       	pop	r17
    43fc:	0f 91       	pop	r16
    43fe:	08 95       	ret

00004400 <_GLOBAL__sub_I_counter>:
    4400:	0f 93       	push	r16
    4402:	1f 93       	push	r17
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4404:	0a e0       	ldi	r16, 0x0A	; 10
    4406:	10 e0       	ldi	r17, 0x00	; 0
    4408:	20 e0       	ldi	r18, 0x00	; 0
    440a:	30 e0       	ldi	r19, 0x00	; 0
    440c:	40 e0       	ldi	r20, 0x00	; 0
    440e:	50 e0       	ldi	r21, 0x00	; 0
    4410:	60 e2       	ldi	r22, 0x20	; 32
    4412:	70 e0       	ldi	r23, 0x00	; 0
    4414:	84 e5       	ldi	r24, 0x54	; 84
    4416:	91 e3       	ldi	r25, 0x31	; 49
    4418:	0e 94 bb 1a 	call	0x3576	; 0x3576 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    441c:	1f 91       	pop	r17
    441e:	0f 91       	pop	r16
    4420:	08 95       	ret

00004422 <__cmpsf2>:
    4422:	0e 94 53 22 	call	0x44a6	; 0x44a6 <__fp_cmp>
    4426:	08 f4       	brcc	.+2      	; 0x442a <__cmpsf2+0x8>
    4428:	81 e0       	ldi	r24, 0x01	; 1
    442a:	08 95       	ret

0000442c <__floatunsisf>:
    442c:	e8 94       	clt
    442e:	09 c0       	rjmp	.+18     	; 0x4442 <__floatsisf+0x12>

00004430 <__floatsisf>:
    4430:	97 fb       	bst	r25, 7
    4432:	3e f4       	brtc	.+14     	; 0x4442 <__floatsisf+0x12>
    4434:	90 95       	com	r25
    4436:	80 95       	com	r24
    4438:	70 95       	com	r23
    443a:	61 95       	neg	r22
    443c:	7f 4f       	sbci	r23, 0xFF	; 255
    443e:	8f 4f       	sbci	r24, 0xFF	; 255
    4440:	9f 4f       	sbci	r25, 0xFF	; 255
    4442:	99 23       	and	r25, r25
    4444:	a9 f0       	breq	.+42     	; 0x4470 <__floatsisf+0x40>
    4446:	f9 2f       	mov	r31, r25
    4448:	96 e9       	ldi	r25, 0x96	; 150
    444a:	bb 27       	eor	r27, r27
    444c:	93 95       	inc	r25
    444e:	f6 95       	lsr	r31
    4450:	87 95       	ror	r24
    4452:	77 95       	ror	r23
    4454:	67 95       	ror	r22
    4456:	b7 95       	ror	r27
    4458:	f1 11       	cpse	r31, r1
    445a:	f8 cf       	rjmp	.-16     	; 0x444c <__floatsisf+0x1c>
    445c:	fa f4       	brpl	.+62     	; 0x449c <__floatsisf+0x6c>
    445e:	bb 0f       	add	r27, r27
    4460:	11 f4       	brne	.+4      	; 0x4466 <__floatsisf+0x36>
    4462:	60 ff       	sbrs	r22, 0
    4464:	1b c0       	rjmp	.+54     	; 0x449c <__floatsisf+0x6c>
    4466:	6f 5f       	subi	r22, 0xFF	; 255
    4468:	7f 4f       	sbci	r23, 0xFF	; 255
    446a:	8f 4f       	sbci	r24, 0xFF	; 255
    446c:	9f 4f       	sbci	r25, 0xFF	; 255
    446e:	16 c0       	rjmp	.+44     	; 0x449c <__floatsisf+0x6c>
    4470:	88 23       	and	r24, r24
    4472:	11 f0       	breq	.+4      	; 0x4478 <__floatsisf+0x48>
    4474:	96 e9       	ldi	r25, 0x96	; 150
    4476:	11 c0       	rjmp	.+34     	; 0x449a <__floatsisf+0x6a>
    4478:	77 23       	and	r23, r23
    447a:	21 f0       	breq	.+8      	; 0x4484 <__floatsisf+0x54>
    447c:	9e e8       	ldi	r25, 0x8E	; 142
    447e:	87 2f       	mov	r24, r23
    4480:	76 2f       	mov	r23, r22
    4482:	05 c0       	rjmp	.+10     	; 0x448e <__floatsisf+0x5e>
    4484:	66 23       	and	r22, r22
    4486:	71 f0       	breq	.+28     	; 0x44a4 <__floatsisf+0x74>
    4488:	96 e8       	ldi	r25, 0x86	; 134
    448a:	86 2f       	mov	r24, r22
    448c:	70 e0       	ldi	r23, 0x00	; 0
    448e:	60 e0       	ldi	r22, 0x00	; 0
    4490:	2a f0       	brmi	.+10     	; 0x449c <__floatsisf+0x6c>
    4492:	9a 95       	dec	r25
    4494:	66 0f       	add	r22, r22
    4496:	77 1f       	adc	r23, r23
    4498:	88 1f       	adc	r24, r24
    449a:	da f7       	brpl	.-10     	; 0x4492 <__floatsisf+0x62>
    449c:	88 0f       	add	r24, r24
    449e:	96 95       	lsr	r25
    44a0:	87 95       	ror	r24
    44a2:	97 f9       	bld	r25, 7
    44a4:	08 95       	ret

000044a6 <__fp_cmp>:
    44a6:	99 0f       	add	r25, r25
    44a8:	00 08       	sbc	r0, r0
    44aa:	55 0f       	add	r21, r21
    44ac:	aa 0b       	sbc	r26, r26
    44ae:	e0 e8       	ldi	r30, 0x80	; 128
    44b0:	fe ef       	ldi	r31, 0xFE	; 254
    44b2:	16 16       	cp	r1, r22
    44b4:	17 06       	cpc	r1, r23
    44b6:	e8 07       	cpc	r30, r24
    44b8:	f9 07       	cpc	r31, r25
    44ba:	c0 f0       	brcs	.+48     	; 0x44ec <__fp_cmp+0x46>
    44bc:	12 16       	cp	r1, r18
    44be:	13 06       	cpc	r1, r19
    44c0:	e4 07       	cpc	r30, r20
    44c2:	f5 07       	cpc	r31, r21
    44c4:	98 f0       	brcs	.+38     	; 0x44ec <__fp_cmp+0x46>
    44c6:	62 1b       	sub	r22, r18
    44c8:	73 0b       	sbc	r23, r19
    44ca:	84 0b       	sbc	r24, r20
    44cc:	95 0b       	sbc	r25, r21
    44ce:	39 f4       	brne	.+14     	; 0x44de <__fp_cmp+0x38>
    44d0:	0a 26       	eor	r0, r26
    44d2:	61 f0       	breq	.+24     	; 0x44ec <__fp_cmp+0x46>
    44d4:	23 2b       	or	r18, r19
    44d6:	24 2b       	or	r18, r20
    44d8:	25 2b       	or	r18, r21
    44da:	21 f4       	brne	.+8      	; 0x44e4 <__fp_cmp+0x3e>
    44dc:	08 95       	ret
    44de:	0a 26       	eor	r0, r26
    44e0:	09 f4       	brne	.+2      	; 0x44e4 <__fp_cmp+0x3e>
    44e2:	a1 40       	sbci	r26, 0x01	; 1
    44e4:	a6 95       	lsr	r26
    44e6:	8f ef       	ldi	r24, 0xFF	; 255
    44e8:	81 1d       	adc	r24, r1
    44ea:	81 1d       	adc	r24, r1
    44ec:	08 95       	ret

000044ee <__gesf2>:
    44ee:	0e 94 53 22 	call	0x44a6	; 0x44a6 <__fp_cmp>
    44f2:	08 f4       	brcc	.+2      	; 0x44f6 <__gesf2+0x8>
    44f4:	8f ef       	ldi	r24, 0xFF	; 255
    44f6:	08 95       	ret

000044f8 <__mulsi3>:
    44f8:	db 01       	movw	r26, r22
    44fa:	8f 93       	push	r24
    44fc:	9f 93       	push	r25
    44fe:	0e 94 08 23 	call	0x4610	; 0x4610 <__muluhisi3>
    4502:	bf 91       	pop	r27
    4504:	af 91       	pop	r26
    4506:	a2 9f       	mul	r26, r18
    4508:	80 0d       	add	r24, r0
    450a:	91 1d       	adc	r25, r1
    450c:	a3 9f       	mul	r26, r19
    450e:	90 0d       	add	r25, r0
    4510:	b2 9f       	mul	r27, r18
    4512:	90 0d       	add	r25, r0
    4514:	11 24       	eor	r1, r1
    4516:	08 95       	ret

00004518 <__divmodhi4>:
    4518:	97 fb       	bst	r25, 7
    451a:	07 2e       	mov	r0, r23
    451c:	16 f4       	brtc	.+4      	; 0x4522 <__divmodhi4+0xa>
    451e:	00 94       	com	r0
    4520:	07 d0       	rcall	.+14     	; 0x4530 <__divmodhi4_neg1>
    4522:	77 fd       	sbrc	r23, 7
    4524:	09 d0       	rcall	.+18     	; 0x4538 <__divmodhi4_neg2>
    4526:	0e 94 1b 23 	call	0x4636	; 0x4636 <__udivmodhi4>
    452a:	07 fc       	sbrc	r0, 7
    452c:	05 d0       	rcall	.+10     	; 0x4538 <__divmodhi4_neg2>
    452e:	3e f4       	brtc	.+14     	; 0x453e <__divmodhi4_exit>

00004530 <__divmodhi4_neg1>:
    4530:	90 95       	com	r25
    4532:	81 95       	neg	r24
    4534:	9f 4f       	sbci	r25, 0xFF	; 255
    4536:	08 95       	ret

00004538 <__divmodhi4_neg2>:
    4538:	70 95       	com	r23
    453a:	61 95       	neg	r22
    453c:	7f 4f       	sbci	r23, 0xFF	; 255

0000453e <__divmodhi4_exit>:
    453e:	08 95       	ret

00004540 <__udivmodsi4>:
    4540:	a1 e2       	ldi	r26, 0x21	; 33
    4542:	1a 2e       	mov	r1, r26
    4544:	aa 1b       	sub	r26, r26
    4546:	bb 1b       	sub	r27, r27
    4548:	fd 01       	movw	r30, r26
    454a:	0d c0       	rjmp	.+26     	; 0x4566 <__udivmodsi4_ep>

0000454c <__udivmodsi4_loop>:
    454c:	aa 1f       	adc	r26, r26
    454e:	bb 1f       	adc	r27, r27
    4550:	ee 1f       	adc	r30, r30
    4552:	ff 1f       	adc	r31, r31
    4554:	a2 17       	cp	r26, r18
    4556:	b3 07       	cpc	r27, r19
    4558:	e4 07       	cpc	r30, r20
    455a:	f5 07       	cpc	r31, r21
    455c:	20 f0       	brcs	.+8      	; 0x4566 <__udivmodsi4_ep>
    455e:	a2 1b       	sub	r26, r18
    4560:	b3 0b       	sbc	r27, r19
    4562:	e4 0b       	sbc	r30, r20
    4564:	f5 0b       	sbc	r31, r21

00004566 <__udivmodsi4_ep>:
    4566:	66 1f       	adc	r22, r22
    4568:	77 1f       	adc	r23, r23
    456a:	88 1f       	adc	r24, r24
    456c:	99 1f       	adc	r25, r25
    456e:	1a 94       	dec	r1
    4570:	69 f7       	brne	.-38     	; 0x454c <__udivmodsi4_loop>
    4572:	60 95       	com	r22
    4574:	70 95       	com	r23
    4576:	80 95       	com	r24
    4578:	90 95       	com	r25
    457a:	9b 01       	movw	r18, r22
    457c:	ac 01       	movw	r20, r24
    457e:	bd 01       	movw	r22, r26
    4580:	cf 01       	movw	r24, r30
    4582:	08 95       	ret

00004584 <__divmodsi4>:
    4584:	05 2e       	mov	r0, r21
    4586:	97 fb       	bst	r25, 7
    4588:	1e f4       	brtc	.+6      	; 0x4590 <__divmodsi4+0xc>
    458a:	00 94       	com	r0
    458c:	0e 94 d9 22 	call	0x45b2	; 0x45b2 <__negsi2>
    4590:	57 fd       	sbrc	r21, 7
    4592:	07 d0       	rcall	.+14     	; 0x45a2 <__divmodsi4_neg2>
    4594:	0e 94 a0 22 	call	0x4540	; 0x4540 <__udivmodsi4>
    4598:	07 fc       	sbrc	r0, 7
    459a:	03 d0       	rcall	.+6      	; 0x45a2 <__divmodsi4_neg2>
    459c:	4e f4       	brtc	.+18     	; 0x45b0 <__divmodsi4_exit>
    459e:	0c 94 d9 22 	jmp	0x45b2	; 0x45b2 <__negsi2>

000045a2 <__divmodsi4_neg2>:
    45a2:	50 95       	com	r21
    45a4:	40 95       	com	r20
    45a6:	30 95       	com	r19
    45a8:	21 95       	neg	r18
    45aa:	3f 4f       	sbci	r19, 0xFF	; 255
    45ac:	4f 4f       	sbci	r20, 0xFF	; 255
    45ae:	5f 4f       	sbci	r21, 0xFF	; 255

000045b0 <__divmodsi4_exit>:
    45b0:	08 95       	ret

000045b2 <__negsi2>:
    45b2:	90 95       	com	r25
    45b4:	80 95       	com	r24
    45b6:	70 95       	com	r23
    45b8:	61 95       	neg	r22
    45ba:	7f 4f       	sbci	r23, 0xFF	; 255
    45bc:	8f 4f       	sbci	r24, 0xFF	; 255
    45be:	9f 4f       	sbci	r25, 0xFF	; 255
    45c0:	08 95       	ret

000045c2 <__tablejump2__>:
    45c2:	ee 0f       	add	r30, r30
    45c4:	ff 1f       	adc	r31, r31
    45c6:	88 1f       	adc	r24, r24
    45c8:	8b bf       	out	0x3b, r24	; 59
    45ca:	07 90       	elpm	r0, Z+
    45cc:	f6 91       	elpm	r31, Z
    45ce:	e0 2d       	mov	r30, r0
    45d0:	1b be       	out	0x3b, r1	; 59
    45d2:	19 94       	eijmp

000045d4 <__mulhisi3>:
    45d4:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <__umulhisi3>
    45d8:	33 23       	and	r19, r19
    45da:	12 f4       	brpl	.+4      	; 0x45e0 <__mulhisi3+0xc>
    45dc:	8a 1b       	sub	r24, r26
    45de:	9b 0b       	sbc	r25, r27
    45e0:	0c 94 03 23 	jmp	0x4606	; 0x4606 <__usmulhisi3_tail>

000045e4 <__umulhisi3>:
    45e4:	a2 9f       	mul	r26, r18
    45e6:	b0 01       	movw	r22, r0
    45e8:	b3 9f       	mul	r27, r19
    45ea:	c0 01       	movw	r24, r0
    45ec:	a3 9f       	mul	r26, r19
    45ee:	70 0d       	add	r23, r0
    45f0:	81 1d       	adc	r24, r1
    45f2:	11 24       	eor	r1, r1
    45f4:	91 1d       	adc	r25, r1
    45f6:	b2 9f       	mul	r27, r18
    45f8:	70 0d       	add	r23, r0
    45fa:	81 1d       	adc	r24, r1
    45fc:	11 24       	eor	r1, r1
    45fe:	91 1d       	adc	r25, r1
    4600:	08 95       	ret

00004602 <__usmulhisi3>:
    4602:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <__umulhisi3>

00004606 <__usmulhisi3_tail>:
    4606:	b7 ff       	sbrs	r27, 7
    4608:	08 95       	ret
    460a:	82 1b       	sub	r24, r18
    460c:	93 0b       	sbc	r25, r19
    460e:	08 95       	ret

00004610 <__muluhisi3>:
    4610:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <__umulhisi3>
    4614:	a5 9f       	mul	r26, r21
    4616:	90 0d       	add	r25, r0
    4618:	b4 9f       	mul	r27, r20
    461a:	90 0d       	add	r25, r0
    461c:	a4 9f       	mul	r26, r20
    461e:	80 0d       	add	r24, r0
    4620:	91 1d       	adc	r25, r1
    4622:	11 24       	eor	r1, r1
    4624:	08 95       	ret

00004626 <__mulshisi3>:
    4626:	b7 ff       	sbrs	r27, 7
    4628:	0c 94 08 23 	jmp	0x4610	; 0x4610 <__muluhisi3>

0000462c <__mulohisi3>:
    462c:	0e 94 08 23 	call	0x4610	; 0x4610 <__muluhisi3>
    4630:	82 1b       	sub	r24, r18
    4632:	93 0b       	sbc	r25, r19
    4634:	08 95       	ret

00004636 <__udivmodhi4>:
    4636:	aa 1b       	sub	r26, r26
    4638:	bb 1b       	sub	r27, r27
    463a:	51 e1       	ldi	r21, 0x11	; 17
    463c:	07 c0       	rjmp	.+14     	; 0x464c <__udivmodhi4_ep>

0000463e <__udivmodhi4_loop>:
    463e:	aa 1f       	adc	r26, r26
    4640:	bb 1f       	adc	r27, r27
    4642:	a6 17       	cp	r26, r22
    4644:	b7 07       	cpc	r27, r23
    4646:	10 f0       	brcs	.+4      	; 0x464c <__udivmodhi4_ep>
    4648:	a6 1b       	sub	r26, r22
    464a:	b7 0b       	sbc	r27, r23

0000464c <__udivmodhi4_ep>:
    464c:	88 1f       	adc	r24, r24
    464e:	99 1f       	adc	r25, r25
    4650:	5a 95       	dec	r21
    4652:	a9 f7       	brne	.-22     	; 0x463e <__udivmodhi4_loop>
    4654:	80 95       	com	r24
    4656:	90 95       	com	r25
    4658:	bc 01       	movw	r22, r24
    465a:	cd 01       	movw	r24, r26
    465c:	08 95       	ret

0000465e <memcpy>:
    465e:	fb 01       	movw	r30, r22
    4660:	dc 01       	movw	r26, r24
    4662:	02 c0       	rjmp	.+4      	; 0x4668 <memcpy+0xa>
    4664:	01 90       	ld	r0, Z+
    4666:	0d 92       	st	X+, r0
    4668:	41 50       	subi	r20, 0x01	; 1
    466a:	50 40       	sbci	r21, 0x00	; 0
    466c:	d8 f7       	brcc	.-10     	; 0x4664 <memcpy+0x6>
    466e:	08 95       	ret

00004670 <memset>:
    4670:	dc 01       	movw	r26, r24
    4672:	01 c0       	rjmp	.+2      	; 0x4676 <memset+0x6>
    4674:	6d 93       	st	X+, r22
    4676:	41 50       	subi	r20, 0x01	; 1
    4678:	50 40       	sbci	r21, 0x00	; 0
    467a:	e0 f7       	brcc	.-8      	; 0x4674 <memset+0x4>
    467c:	08 95       	ret

0000467e <strncpy>:
    467e:	fb 01       	movw	r30, r22
    4680:	dc 01       	movw	r26, r24
    4682:	41 50       	subi	r20, 0x01	; 1
    4684:	50 40       	sbci	r21, 0x00	; 0
    4686:	48 f0       	brcs	.+18     	; 0x469a <strncpy+0x1c>
    4688:	01 90       	ld	r0, Z+
    468a:	0d 92       	st	X+, r0
    468c:	00 20       	and	r0, r0
    468e:	c9 f7       	brne	.-14     	; 0x4682 <strncpy+0x4>
    4690:	01 c0       	rjmp	.+2      	; 0x4694 <strncpy+0x16>
    4692:	1d 92       	st	X+, r1
    4694:	41 50       	subi	r20, 0x01	; 1
    4696:	50 40       	sbci	r21, 0x00	; 0
    4698:	e0 f7       	brcc	.-8      	; 0x4692 <strncpy+0x14>
    469a:	08 95       	ret

0000469c <__itoa_ncheck>:
    469c:	bb 27       	eor	r27, r27
    469e:	4a 30       	cpi	r20, 0x0A	; 10
    46a0:	31 f4       	brne	.+12     	; 0x46ae <__itoa_ncheck+0x12>
    46a2:	99 23       	and	r25, r25
    46a4:	22 f4       	brpl	.+8      	; 0x46ae <__itoa_ncheck+0x12>
    46a6:	bd e2       	ldi	r27, 0x2D	; 45
    46a8:	90 95       	com	r25
    46aa:	81 95       	neg	r24
    46ac:	9f 4f       	sbci	r25, 0xFF	; 255
    46ae:	0c 94 92 23 	jmp	0x4724	; 0x4724 <__utoa_common>

000046b2 <ultoa>:
    46b2:	25 32       	cpi	r18, 0x25	; 37
    46b4:	31 05       	cpc	r19, r1
    46b6:	20 f4       	brcc	.+8      	; 0x46c0 <ultoa+0xe>
    46b8:	22 30       	cpi	r18, 0x02	; 2
    46ba:	10 f0       	brcs	.+4      	; 0x46c0 <ultoa+0xe>
    46bc:	0c 94 64 23 	jmp	0x46c8	; 0x46c8 <__ultoa_ncheck>
    46c0:	fa 01       	movw	r30, r20
    46c2:	10 82       	st	Z, r1
    46c4:	ca 01       	movw	r24, r20
    46c6:	08 95       	ret

000046c8 <__ultoa_ncheck>:
    46c8:	bb 27       	eor	r27, r27

000046ca <__ultoa_common>:
    46ca:	fa 01       	movw	r30, r20
    46cc:	a6 2f       	mov	r26, r22
    46ce:	62 17       	cp	r22, r18
    46d0:	71 05       	cpc	r23, r1
    46d2:	81 05       	cpc	r24, r1
    46d4:	91 05       	cpc	r25, r1
    46d6:	33 0b       	sbc	r19, r19
    46d8:	30 fb       	bst	r19, 0
    46da:	66 f0       	brts	.+24     	; 0x46f4 <__ultoa_common+0x2a>
    46dc:	aa 27       	eor	r26, r26
    46de:	66 0f       	add	r22, r22
    46e0:	77 1f       	adc	r23, r23
    46e2:	88 1f       	adc	r24, r24
    46e4:	99 1f       	adc	r25, r25
    46e6:	aa 1f       	adc	r26, r26
    46e8:	a2 17       	cp	r26, r18
    46ea:	10 f0       	brcs	.+4      	; 0x46f0 <__ultoa_common+0x26>
    46ec:	a2 1b       	sub	r26, r18
    46ee:	63 95       	inc	r22
    46f0:	38 50       	subi	r19, 0x08	; 8
    46f2:	a9 f7       	brne	.-22     	; 0x46de <__ultoa_common+0x14>
    46f4:	a0 5d       	subi	r26, 0xD0	; 208
    46f6:	aa 33       	cpi	r26, 0x3A	; 58
    46f8:	08 f0       	brcs	.+2      	; 0x46fc <__ultoa_common+0x32>
    46fa:	a9 5d       	subi	r26, 0xD9	; 217
    46fc:	a1 93       	st	Z+, r26
    46fe:	36 f7       	brtc	.-52     	; 0x46cc <__ultoa_common+0x2>
    4700:	b1 11       	cpse	r27, r1
    4702:	b1 93       	st	Z+, r27
    4704:	10 82       	st	Z, r1
    4706:	ca 01       	movw	r24, r20
    4708:	0c 94 ab 23 	jmp	0x4756	; 0x4756 <strrev>

0000470c <utoa>:
    470c:	45 32       	cpi	r20, 0x25	; 37
    470e:	51 05       	cpc	r21, r1
    4710:	20 f4       	brcc	.+8      	; 0x471a <utoa+0xe>
    4712:	42 30       	cpi	r20, 0x02	; 2
    4714:	10 f0       	brcs	.+4      	; 0x471a <utoa+0xe>
    4716:	0c 94 91 23 	jmp	0x4722	; 0x4722 <__utoa_ncheck>
    471a:	fb 01       	movw	r30, r22
    471c:	10 82       	st	Z, r1
    471e:	cb 01       	movw	r24, r22
    4720:	08 95       	ret

00004722 <__utoa_ncheck>:
    4722:	bb 27       	eor	r27, r27

00004724 <__utoa_common>:
    4724:	fb 01       	movw	r30, r22
    4726:	55 27       	eor	r21, r21
    4728:	aa 27       	eor	r26, r26
    472a:	88 0f       	add	r24, r24
    472c:	99 1f       	adc	r25, r25
    472e:	aa 1f       	adc	r26, r26
    4730:	a4 17       	cp	r26, r20
    4732:	10 f0       	brcs	.+4      	; 0x4738 <__utoa_common+0x14>
    4734:	a4 1b       	sub	r26, r20
    4736:	83 95       	inc	r24
    4738:	50 51       	subi	r21, 0x10	; 16
    473a:	b9 f7       	brne	.-18     	; 0x472a <__utoa_common+0x6>
    473c:	a0 5d       	subi	r26, 0xD0	; 208
    473e:	aa 33       	cpi	r26, 0x3A	; 58
    4740:	08 f0       	brcs	.+2      	; 0x4744 <__utoa_common+0x20>
    4742:	a9 5d       	subi	r26, 0xD9	; 217
    4744:	a1 93       	st	Z+, r26
    4746:	00 97       	sbiw	r24, 0x00	; 0
    4748:	79 f7       	brne	.-34     	; 0x4728 <__utoa_common+0x4>
    474a:	b1 11       	cpse	r27, r1
    474c:	b1 93       	st	Z+, r27
    474e:	11 92       	st	Z+, r1
    4750:	cb 01       	movw	r24, r22
    4752:	0c 94 ab 23 	jmp	0x4756	; 0x4756 <strrev>

00004756 <strrev>:
    4756:	dc 01       	movw	r26, r24
    4758:	fc 01       	movw	r30, r24
    475a:	67 2f       	mov	r22, r23
    475c:	71 91       	ld	r23, Z+
    475e:	77 23       	and	r23, r23
    4760:	e1 f7       	brne	.-8      	; 0x475a <strrev+0x4>
    4762:	32 97       	sbiw	r30, 0x02	; 2
    4764:	04 c0       	rjmp	.+8      	; 0x476e <strrev+0x18>
    4766:	7c 91       	ld	r23, X
    4768:	6d 93       	st	X+, r22
    476a:	70 83       	st	Z, r23
    476c:	62 91       	ld	r22, -Z
    476e:	ae 17       	cp	r26, r30
    4770:	bf 07       	cpc	r27, r31
    4772:	c8 f3       	brcs	.-14     	; 0x4766 <strrev+0x10>
    4774:	08 95       	ret

00004776 <_exit>:
    4776:	f8 94       	cli

00004778 <__stop_program>:
    4778:	ff cf       	rjmp	.-2      	; 0x4778 <__stop_program>
