
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004716  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c8  00802000  00004716  000047aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  008020c8  008020c8  00004872  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004872  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000048a4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c0  00000000  00000000  000048e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012a39  00000000  00000000  00004fa4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000064c7  00000000  00000000  000179dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005668  00000000  00000000  0001dea4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001284  00000000  00000000  0002350c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006323  00000000  00000000  00024790  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000060a5  00000000  00000000  0002aab3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000578  00000000  00000000  00030b58  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 95 03 	jmp	0x72a	; 0x72a <__ctors_end>
       4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      10:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      14:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      18:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      1c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      20:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      24:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      28:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      2c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      30:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      34:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      38:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      3c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      40:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      44:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      48:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      4c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      50:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      54:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      58:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      5c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      60:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      64:	0c 94 54 1f 	jmp	0x3ea8	; 0x3ea8 <__vector_25>
      68:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      6c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      70:	0c 94 b2 1f 	jmp	0x3f64	; 0x3f64 <__vector_28>
      74:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      78:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      7c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      80:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      84:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      88:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      8c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      90:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      94:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      98:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      9c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c4:	0c 94 45 0f 	jmp	0x1e8a	; 0x1e8a <__vector_49>
      c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e8:	0c 94 cc 20 	jmp	0x4198	; 0x4198 <__vector_58>
      ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      fc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     100:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     104:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     108:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     10c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     110:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     114:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     118:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     11c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     120:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     124:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     128:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     12c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     130:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     134:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     138:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     13c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     140:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     144:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     148:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     14c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     150:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     154:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     158:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     15c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     160:	0c 94 10 20 	jmp	0x4020	; 0x4020 <__vector_88>
     164:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     168:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     16c:	0c 94 6e 20 	jmp	0x40dc	; 0x40dc <__vector_91>
     170:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     174:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     178:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     17c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     180:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     184:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     188:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     18c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     190:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     194:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     198:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     19c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1fc:	8c 0b       	sbc	r24, r28
     1fe:	04 0c       	add	r0, r4
     200:	04 0c       	add	r0, r4
     202:	04 0c       	add	r0, r4
     204:	04 0c       	add	r0, r4
     206:	04 0c       	add	r0, r4
     208:	04 0c       	add	r0, r4
     20a:	04 0c       	add	r0, r4
     20c:	04 0c       	add	r0, r4
     20e:	04 0c       	add	r0, r4
     210:	04 0c       	add	r0, r4
     212:	04 0c       	add	r0, r4
     214:	04 0c       	add	r0, r4
     216:	04 0c       	add	r0, r4
     218:	04 0c       	add	r0, r4
     21a:	04 0c       	add	r0, r4
     21c:	04 0c       	add	r0, r4
     21e:	04 0c       	add	r0, r4
     220:	04 0c       	add	r0, r4
     222:	04 0c       	add	r0, r4
     224:	04 0c       	add	r0, r4
     226:	04 0c       	add	r0, r4
     228:	04 0c       	add	r0, r4
     22a:	04 0c       	add	r0, r4
     22c:	04 0c       	add	r0, r4
     22e:	04 0c       	add	r0, r4
     230:	04 0c       	add	r0, r4
     232:	04 0c       	add	r0, r4
     234:	04 0c       	add	r0, r4
     236:	04 0c       	add	r0, r4
     238:	04 0c       	add	r0, r4
     23a:	04 0c       	add	r0, r4
     23c:	04 0c       	add	r0, r4
     23e:	04 0c       	add	r0, r4
     240:	04 0c       	add	r0, r4
     242:	04 0c       	add	r0, r4
     244:	04 0c       	add	r0, r4
     246:	04 0c       	add	r0, r4
     248:	04 0c       	add	r0, r4
     24a:	04 0c       	add	r0, r4
     24c:	04 0c       	add	r0, r4
     24e:	04 0c       	add	r0, r4
     250:	04 0c       	add	r0, r4
     252:	04 0c       	add	r0, r4
     254:	04 0c       	add	r0, r4
     256:	04 0c       	add	r0, r4
     258:	04 0c       	add	r0, r4
     25a:	04 0c       	add	r0, r4
     25c:	04 0c       	add	r0, r4
     25e:	04 0c       	add	r0, r4
     260:	04 0c       	add	r0, r4
     262:	04 0c       	add	r0, r4
     264:	04 0c       	add	r0, r4
     266:	04 0c       	add	r0, r4
     268:	04 0c       	add	r0, r4
     26a:	04 0c       	add	r0, r4
     26c:	04 0c       	add	r0, r4
     26e:	04 0c       	add	r0, r4
     270:	04 0c       	add	r0, r4
     272:	04 0c       	add	r0, r4
     274:	04 0c       	add	r0, r4
     276:	04 0c       	add	r0, r4
     278:	04 0c       	add	r0, r4
     27a:	04 0c       	add	r0, r4
     27c:	04 0c       	add	r0, r4
     27e:	04 0c       	add	r0, r4
     280:	04 0c       	add	r0, r4
     282:	04 0c       	add	r0, r4
     284:	04 0c       	add	r0, r4
     286:	04 0c       	add	r0, r4
     288:	04 0c       	add	r0, r4
     28a:	a0 0b       	sbc	r26, r16
     28c:	04 0c       	add	r0, r4
     28e:	d2 0b       	sbc	r29, r18
     290:	8c 0b       	sbc	r24, r28
     292:	04 0c       	add	r0, r4
     294:	ba 0b       	sbc	r27, r26
     296:	88 0b       	sbc	r24, r24
     298:	04 0c       	add	r0, r4
     29a:	04 0c       	add	r0, r4
     29c:	04 0c       	add	r0, r4
     29e:	04 0c       	add	r0, r4
     2a0:	04 0c       	add	r0, r4
     2a2:	6e 0b       	sbc	r22, r30
     2a4:	04 0c       	add	r0, r4
     2a6:	04 0c       	add	r0, r4
     2a8:	04 0c       	add	r0, r4
     2aa:	ec 0b       	sbc	r30, r28
     2ac:	80 0b       	sbc	r24, r16
     2ae:	04 0c       	add	r0, r4
     2b0:	04 0c       	add	r0, r4
     2b2:	7c 0b       	sbc	r23, r28
     2b4:	17 1d       	adc	r17, r7
     2b6:	1a 1d       	adc	r17, r10
     2b8:	1d 1d       	adc	r17, r13
     2ba:	20 1d       	adc	r18, r0
     2bc:	23 1d       	adc	r18, r3
     2be:	26 1d       	adc	r18, r6
     2c0:	28 1d       	adc	r18, r8
     2c2:	39 1d       	adc	r19, r9
     2c4:	41 1d       	adc	r20, r1
     2c6:	4b 1d       	adc	r20, r11
     2c8:	49 1d       	adc	r20, r9

000002ca <__trampolines_start>:
     2ca:	0c 94 bf 1c 	jmp	0x397e	; 0x397e <_ZN8emstream14check_for_charEv>
     2ce:	0c 94 28 1d 	jmp	0x3a50	; 0x3a50 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2d2:	0c 94 80 0b 	jmp	0x1700	; 0x1700 <_ZN9task_user3runEv+0x170>
     2d6:	0c 94 88 0b 	jmp	0x1710	; 0x1710 <_ZN9task_user3runEv+0x180>
     2da:	0c 94 bc 1c 	jmp	0x3978	; 0x3978 <_ZN8emstream7getcharEv>
     2de:	0c 94 23 1c 	jmp	0x3846	; 0x3846 <__cxa_pure_virtual>
     2e2:	0c 94 04 0c 	jmp	0x1808	; 0x1808 <_ZN9task_user3runEv+0x278>
     2e6:	0c 94 8c 0b 	jmp	0x1718	; 0x1718 <_ZN9task_user3runEv+0x188>
     2ea:	0c 94 41 1d 	jmp	0x3a82	; 0x3a82 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2ee:	0c 94 ce 21 	jmp	0x439c	; 0x439c <_GLOBAL__sub_I_counter>
     2f2:	0c 94 17 1d 	jmp	0x3a2e	; 0x3a2e <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2f6:	0c 94 26 1d 	jmp	0x3a4c	; 0x3a4c <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2fa:	0c 94 b4 04 	jmp	0x968	; 0x968 <_ZN13LimitSwitches3runEv>
     2fe:	0c 94 c9 11 	jmp	0x2392	; 0x2392 <prvIdleTask>
     302:	0c 94 1d 1d 	jmp	0x3a3a	; 0x3a3a <_ZN8emstreamlsE15ser_manipulator+0x2a>
     306:	0c 94 60 1a 	jmp	0x34c0	; 0x34c0 <_ZN14frt_text_queue14check_for_charEv>
     30a:	0c 94 f8 18 	jmp	0x31f0	; 0x31f0 <_ZN8frt_task12print_statusER8emstream>
     30e:	0c 94 ec 0b 	jmp	0x17d8	; 0x17d8 <_ZN9task_user3runEv+0x248>
     312:	0c 94 6b 1a 	jmp	0x34d6	; 0x34d6 <_ZN14frt_text_queue7putcharEc>
     316:	0c 94 6e 1e 	jmp	0x3cdc	; 0x3cdc <_ZN5rs2327putcharEc>
     31a:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <_ZN15EncoderPendulum3runEv>
     31e:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <_ZN9task_user3runEv+0x14c>
     322:	0c 94 49 1d 	jmp	0x3a92	; 0x3a92 <_ZN8emstreamlsE15ser_manipulator+0x82>
     326:	0c 94 7c 0b 	jmp	0x16f8	; 0x16f8 <_ZN9task_user3runEv+0x168>
     32a:	0c 94 b8 1e 	jmp	0x3d70	; 0x3d70 <_ZN5rs23214check_for_charEv>
     32e:	0c 94 1a 1d 	jmp	0x3a34	; 0x3a34 <_ZN8emstreamlsE15ser_manipulator+0x24>
     332:	0c 94 cb 1e 	jmp	0x3d96	; 0x3d96 <_ZN5rs23212clear_screenEv>
     336:	0c 94 c2 1c 	jmp	0x3984	; 0x3984 <_ZN8emstream12clear_screenEv>
     33a:	0c 94 a0 0b 	jmp	0x1740	; 0x1740 <_ZN9task_user3runEv+0x1b0>
     33e:	0c 94 c8 0a 	jmp	0x1590	; 0x1590 <_ZN9task_user3runEv>
     342:	0c 94 ba 0b 	jmp	0x1774	; 0x1774 <_ZN9task_user3runEv+0x1e4>
     346:	0c 94 42 1a 	jmp	0x3484	; 0x3484 <_ZN14frt_text_queue7getcharEv>
     34a:	0c 94 4b 1d 	jmp	0x3a96	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
     34e:	0c 94 cd 03 	jmp	0x79a	; 0x79a <_ZN12EncoderMotor3runEv>
     352:	0c 94 92 1e 	jmp	0x3d24	; 0x3d24 <_ZN5rs2327getcharEv>
     356:	0c 94 23 1d 	jmp	0x3a46	; 0x3a46 <_ZN8emstreamlsE15ser_manipulator+0x36>
     35a:	0c 94 20 1d 	jmp	0x3a40	; 0x3a40 <_ZN8emstreamlsE15ser_manipulator+0x30>
     35e:	0c 94 39 1d 	jmp	0x3a72	; 0x3a72 <_ZN8emstreamlsE15ser_manipulator+0x62>
     362:	0c 94 ba 1c 	jmp	0x3974	; 0x3974 <_ZN8emstream13ready_to_sendEv>
     366:	0c 94 19 05 	jmp	0xa32	; 0xa32 <_ZN5Motor3runEv>
     36a:	0c 94 d2 0b 	jmp	0x17a4	; 0x17a4 <_ZN9task_user3runEv+0x214>
     36e:	0c 94 c1 1c 	jmp	0x3982	; 0x3982 <_ZN8emstream12transmit_nowEv>
     372:	0c 94 92 03 	jmp	0x724	; 0x724 <_call_static_run_method>

00000376 <__trampolines_end>:
     376:	2c 20       	and	r2, r12
     378:	54 43       	sbci	r21, 0x34	; 52
     37a:	43 30       	cpi	r20, 0x03	; 3
     37c:	43 43       	sbci	r20, 0x33	; 51
     37e:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000381 <_ZZN9task_user11show_statusEvE3__c_3>:
     381:	2f 00                                               /.

00000383 <_ZZN9task_user11show_statusEvE3__c_2>:
     383:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000391 <_ZZN9task_user11show_statusEvE3__c_1>:
     391:	54 69 6d 65 3a 20 00                                Time: .

00000398 <_ZZN9task_user11show_statusEvE3__c_0>:
     398:	44 65 63 20 20 37 20 32 30 31 37 00                 Dec  7 2017.

000003a4 <_ZZN9task_user11show_statusEvE3__c>:
     3a4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3b4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003c3 <_ZZN9task_user18print_help_messageEvE3__c_14>:
     3c3:	20 20 20 20 72 3a 20 20 20 52 65 73 65 74 20 74         r:   Reset t
     3d3:	6f 20 49 64 6c 65 00                                o Idle.

000003da <_ZZN9task_user18print_help_messageEvE3__c_13>:
     3da:	20 20 20 20 64 3a 20 20 20 45 6d 65 72 67 65 6e         d:   Emergen
     3ea:	63 79 20 53 74 6f 70 00                             cy Stop.

000003f2 <_ZZN9task_user18print_help_messageEvE3__c_12>:
     3f2:	20 20 20 20 67 3a 20 20 20 53 77 69 6e 67 20 50         g:   Swing P
     402:	65 6e 64 75 6c 75 6d 20 55 70 72 69 67 68 74 2c     endulum Upright,
     412:	20 74 68 65 6e 20 47 6f 2e 00                        then Go..

0000041c <_ZZN9task_user18print_help_messageEvE3__c_11>:
     41c:	20 20 20 20 62 3a 20 20 20 42 65 67 69 6e 20 43         b:   Begin C
     42c:	61 6c 69 62 72 61 74 69 6f 6e 20 6f 66 20 49 6e     alibration of In
     43c:	76 65 72 74 65 64 20 50 65 6e 64 75 6c 75 6d 3f     verted Pendulum?
	...

0000044d <_ZZN9task_user18print_help_messageEvE3__c_10>:
     44d:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000045c <_ZZN9task_user18print_help_messageEvE3__c_9>:
     45c:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     46c:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000477 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     477:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     487:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000495 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     495:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     4a5:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     4b5:	6d 61 74 69 6f 6e 00                                mation.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_6>:
     4bc:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     4cc:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000004dd <_ZZN9task_user18print_help_messageEvE3__c_5>:
     4dd:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4ed:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004f5 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4f5:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     505:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000511 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     511:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     521:	68 65 20 41 56 52 00                                he AVR.

00000528 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     528:	20 68 65 6c 70 00                                    help.

0000052e <_ZZN9task_user18print_help_messageEvE3__c_1>:
     52e:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     53e:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000054d <_ZZN9task_user18print_help_messageEvE3__c_0>:
     54d:	1b 5b 33 30 6d 00                                   .[30m.

00000553 <_ZZN9task_user18print_help_messageEvE3__c>:
     553:	1b 5b 34 36 6d 00                                   .[46m.

00000559 <_ZZN9task_user3runEvE3__c_7>:
     559:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     569:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000576 <_ZZN9task_user3runEvE3__c_6>:
     576:	3a 57 54 46 3f 00                                   :WTF?.

0000057c <_ZZN9task_user3runEvE3__c_5>:
     57c:	52 65 73 65 74 2c 20 74 72 79 20 48 6f 6d 69 6e     Reset, try Homin
     58c:	67 20 61 67 61 69 6e 20 62 79 20 70 72 65 73 73     g again by press
     59c:	69 6e 67 20 27 62 27 00                             ing 'b'.

000005a4 <_ZZN9task_user3runEvE3__c_4>:
     5a4:	45 4d 45 52 47 45 4e 43 59 20 53 54 4f 50 00        EMERGENCY STOP.

000005b3 <_ZZN9task_user3runEvE3__c_3>:
     5b3:	43 6f 6d 6d 65 6e 63 65 20 42 61 6c 61 6e 63 65     Commence Balance
	...

000005c4 <_ZZN9task_user3runEvE3__c_2>:
     5c4:	42 65 67 69 6e 20 48 6f 6d 69 6e 67 00              Begin Homing.

000005d1 <_ZZN9task_user3runEvE3__c_1>:
     5d1:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     5e1:	65 00                                               e.

000005e3 <_ZZN9task_user3runEvE3__c_0>:
     5e3:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000005f1 <_ZZN9task_user3runEvE3__c>:
     5f1:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 74 6f 20     Press Ctrl-A to 
     601:	67 65 74 20 74 6f 20 63 6f 6d 6d 61 6e 64 20 6d     get to command m
     611:	6f 64 65 20 66 6f 72 20 49 6e 76 65 72 74 65 64     ode for Inverted
     621:	20 50 65 6e 64 75 6c 75 6d 00                        Pendulum.

0000062b <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     62b:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000635 <_ZZN8frt_task15emergency_resetEvE3__c>:
     635:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000644 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     644:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     654:	61 73 6b 20 00                                      ask .

00000659 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     659:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000667 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     667:	20 63 72 65 61 74 65 64 00                           created.

00000670 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     670:	54 61 73 6b 20 00                                   Task .

00000676 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     676:	1b 5b 32 32 6d 00                                   .[22m.

0000067c <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     67c:	54 61 73 6b 3a 20 00                                Task: .

00000683 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     683:	1b 5b 31 6d 00                                      .[1m.

00000688 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     688:	1b 5b 32 32 6d 00                                   .[22m.

0000068e <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     68e:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000699 <_ZZ17print_task_stacksP8emstreamE3__c>:
     699:	1b 5b 31 6d 00                                      .[1m.

0000069e <_ZZ15print_task_listP8emstreamE3__c_9>:
     69e:	09 09 00                                            ...

000006a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     6a1:	2f 00                                               /.

000006a3 <_ZZ15print_task_listP8emstreamE3__c_7>:
     6a3:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000006ae <_ZZ15print_task_listP8emstreamE3__c_6>:
     6ae:	09 2d 2d 2d 2d 00                                   .----.

000006b4 <_ZZ15print_task_listP8emstreamE3__c_5>:
     6b4:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000006c0 <_ZZ15print_task_listP8emstreamE3__c_4>:
     6c0:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000006d1 <_ZZ15print_task_listP8emstreamE3__c_3>:
     6d1:	09 52 75 6e 73 00                                   .Runs.

000006d7 <_ZZ15print_task_listP8emstreamE3__c_2>:
     6d7:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000006e3 <_ZZ15print_task_listP8emstreamE3__c_1>:
     6e3:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000006f4 <_ZZ15print_task_listP8emstreamE3__c_0>:
     6f4:	09 53 74 61 63 6b 00                                .Stack.

000006fb <_ZZ15print_task_listP8emstreamE3__c>:
     6fb:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000706 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     706:	09 00                                               ..

00000708 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     708:	09 00                                               ..

0000070a <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     70a:	2f 00                                               /.

0000070c <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     70c:	09 00                                               ..

0000070e <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     70e:	09 00                                               ..

00000710 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     710:	1b 5b 32 32 6d 00                                   .[22m.

00000716 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     716:	1b 5b 31 6d 00                                      .[1m.

0000071b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     71b:	1b 5b 31 6d 00                                      .[1m.

00000720 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     720:	20 20 00 00                                           ..

00000724 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     724:	0e 94 90 17 	call	0x2f20	; 0x2f20 <_ZN8frt_task22_call_users_run_methodEPS_>

00000728 <__ctors_start>:
     728:	ce 21       	and	r28, r14

0000072a <__ctors_end>:
     72a:	11 24       	eor	r1, r1
     72c:	1f be       	out	0x3f, r1	; 63
     72e:	cf ef       	ldi	r28, 0xFF	; 255
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df e3       	ldi	r29, 0x3F	; 63
     734:	de bf       	out	0x3e, r29	; 62
     736:	00 e0       	ldi	r16, 0x00	; 0
     738:	0c bf       	out	0x3c, r16	; 60
     73a:	18 be       	out	0x38, r1	; 56
     73c:	19 be       	out	0x39, r1	; 57
     73e:	1a be       	out	0x3a, r1	; 58
     740:	1b be       	out	0x3b, r1	; 59

00000742 <__do_copy_data>:
     742:	10 e2       	ldi	r17, 0x20	; 32
     744:	a0 e0       	ldi	r26, 0x00	; 0
     746:	b0 e2       	ldi	r27, 0x20	; 32
     748:	e6 e1       	ldi	r30, 0x16	; 22
     74a:	f7 e4       	ldi	r31, 0x47	; 71
     74c:	00 e0       	ldi	r16, 0x00	; 0
     74e:	0b bf       	out	0x3b, r16	; 59
     750:	02 c0       	rjmp	.+4      	; 0x756 <__do_copy_data+0x14>
     752:	07 90       	elpm	r0, Z+
     754:	0d 92       	st	X+, r0
     756:	a8 3c       	cpi	r26, 0xC8	; 200
     758:	b1 07       	cpc	r27, r17
     75a:	d9 f7       	brne	.-10     	; 0x752 <__do_copy_data+0x10>
     75c:	1b be       	out	0x3b, r1	; 59

0000075e <__do_clear_bss>:
     75e:	21 e3       	ldi	r18, 0x31	; 49
     760:	a8 ec       	ldi	r26, 0xC8	; 200
     762:	b0 e2       	ldi	r27, 0x20	; 32
     764:	01 c0       	rjmp	.+2      	; 0x768 <.do_clear_bss_start>

00000766 <.do_clear_bss_loop>:
     766:	1d 92       	st	X+, r1

00000768 <.do_clear_bss_start>:
     768:	a2 37       	cpi	r26, 0x72	; 114
     76a:	b2 07       	cpc	r27, r18
     76c:	e1 f7       	brne	.-8      	; 0x766 <.do_clear_bss_loop>

0000076e <__do_global_ctors>:
     76e:	13 e0       	ldi	r17, 0x03	; 3
     770:	c5 e9       	ldi	r28, 0x95	; 149
     772:	d3 e0       	ldi	r29, 0x03	; 3
     774:	00 e0       	ldi	r16, 0x00	; 0
     776:	06 c0       	rjmp	.+12     	; 0x784 <__do_global_ctors+0x16>
     778:	21 97       	sbiw	r28, 0x01	; 1
     77a:	01 09       	sbc	r16, r1
     77c:	80 2f       	mov	r24, r16
     77e:	fe 01       	movw	r30, r28
     780:	0e 94 af 22 	call	0x455e	; 0x455e <__tablejump2__>
     784:	c4 39       	cpi	r28, 0x94	; 148
     786:	d1 07       	cpc	r29, r17
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	08 07       	cpc	r16, r24
     78c:	a9 f7       	brne	.-22     	; 0x778 <__do_global_ctors+0xa>
     78e:	0e 94 3f 21 	call	0x427e	; 0x427e <main>
     792:	0c 94 89 23 	jmp	0x4712	; 0x4712 <_exit>

00000796 <__bad_interrupt>:
     796:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000079a <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <_ZN12EncoderMotor3runEv+0x6>
     7a0:	1f 92       	push	r1
     7a2:	cd b7       	in	r28, 0x3d	; 61
     7a4:	de b7       	in	r29, 0x3e	; 62
     7a6:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7a8:	0e 94 68 13 	call	0x26d0	; 0x26d0 <xTaskGetTickCount>
     7ac:	69 83       	std	Y+1, r22	; 0x01
     7ae:	7a 83       	std	Y+2, r23	; 0x02
     7b0:	8b 83       	std	Y+3, r24	; 0x03
     7b2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     7b4:	e0 e8       	ldi	r30, 0x80	; 128
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	8c e0       	ldi	r24, 0x0C	; 12
     7ba:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     7bc:	82 89       	ldd	r24, Z+18	; 0x12
     7be:	83 60       	ori	r24, 0x03	; 3
     7c0:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     7c2:	83 89       	ldd	r24, Z+19	; 0x13
     7c4:	83 60       	ori	r24, 0x03	; 3
     7c6:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     7c8:	e0 e8       	ldi	r30, 0x80	; 128
     7ca:	f1 e0       	ldi	r31, 0x01	; 1
     7cc:	82 e7       	ldi	r24, 0x72	; 114
     7ce:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     7d0:	89 e0       	ldi	r24, 0x09	; 9
     7d2:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     7d4:	e0 e0       	ldi	r30, 0x00	; 0
     7d6:	f9 e0       	ldi	r31, 0x09	; 9
     7d8:	88 e6       	ldi	r24, 0x68	; 104
     7da:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	9f ef       	ldi	r25, 0xFF	; 255
     7e0:	86 a3       	std	Z+38, r24	; 0x26
     7e2:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     7e8:	0f 2e       	mov	r0, r31
     7ea:	a1 2c       	mov	r10, r1
     7ec:	f9 e0       	ldi	r31, 0x09	; 9
     7ee:	bf 2e       	mov	r11, r31
     7f0:	f0 2d       	mov	r31, r0
     7f2:	f5 01       	movw	r30, r10
     7f4:	00 a1       	ldd	r16, Z+32	; 0x20
     7f6:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     7f8:	0f b6       	in	r0, 0x3f	; 63
     7fa:	f8 94       	cli
     7fc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	0f 92       	push	r0
			the_data = new_data;
     808:	c8 01       	movw	r24, r16
     80a:	01 2e       	mov	r0, r17
     80c:	00 0c       	add	r0, r0
     80e:	aa 0b       	sbc	r26, r26
     810:	bb 0b       	sbc	r27, r27
     812:	ac 01       	movw	r20, r24
     814:	bd 01       	movw	r22, r26
     816:	44 0f       	add	r20, r20
     818:	55 1f       	adc	r21, r21
     81a:	66 1f       	adc	r22, r22
     81c:	77 1f       	adc	r23, r23
     81e:	3a 01       	movw	r6, r20
     820:	4b 01       	movw	r8, r22
     822:	68 0e       	add	r6, r24
     824:	79 1e       	adc	r7, r25
     826:	8a 1e       	adc	r8, r26
     828:	9b 1e       	adc	r9, r27
     82a:	c4 01       	movw	r24, r8
     82c:	b3 01       	movw	r22, r6
     82e:	24 e6       	ldi	r18, 0x64	; 100
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	0e 94 90 22 	call	0x4520	; 0x4520 <__divmodsi4>
     83a:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <linear_offset>
     83e:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <linear_offset+0x1>
     842:	28 1b       	sub	r18, r24
     844:	39 0b       	sbc	r19, r25
     846:	20 93 5e 31 	sts	0x315E, r18	; 0x80315e <linear_position>
     84a:	30 93 5f 31 	sts	0x315F, r19	; 0x80315f <linear_position+0x1>
			portEXIT_CRITICAL ();
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
			the_data = new_data;
     858:	c8 01       	movw	r24, r16
     85a:	8c 19       	sub	r24, r12
     85c:	9d 09       	sbc	r25, r13
     85e:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <thdMotor>
     862:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     86a:	f7 01       	movw	r30, r14
     86c:	86 85       	ldd	r24, Z+14	; 0x0e
     86e:	97 85       	ldd	r25, Z+15	; 0x0f
     870:	a0 89       	ldd	r26, Z+16	; 0x10
     872:	b1 89       	ldd	r27, Z+17	; 0x11
     874:	01 96       	adiw	r24, 0x01	; 1
     876:	a1 1d       	adc	r26, r1
     878:	b1 1d       	adc	r27, r1
     87a:	86 87       	std	Z+14, r24	; 0x0e
     87c:	97 87       	std	Z+15, r25	; 0x0f
     87e:	a0 8b       	std	Z+16, r26	; 0x10
     880:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     882:	41 e0       	ldi	r20, 0x01	; 1
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	ce 01       	movw	r24, r28
     88c:	01 96       	adiw	r24, 0x01	; 1
     88e:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     892:	68 01       	movw	r12, r16
     894:	ae cf       	rjmp	.-164    	; 0x7f2 <_ZN12EncoderMotor3runEv+0x58>

00000896 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a0:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <_ZN8frt_taskC1EPKchjP8emstream>
     8a4:	8a e0       	ldi	r24, 0x0A	; 10
     8a6:	90 e2       	ldi	r25, 0x20	; 32
     8a8:	88 83       	st	Y, r24
     8aa:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN15EncoderPendulum3runEv+0x6>
     8bc:	1f 92       	push	r1
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 68 13 	call	0x26d0	; 0x26d0 <xTaskGetTickCount>
     8c8:	69 83       	std	Y+1, r22	; 0x01
     8ca:	7a 83       	std	Y+2, r23	; 0x02
     8cc:	8b 83       	std	Y+3, r24	; 0x03
     8ce:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     8d0:	e0 e8       	ldi	r30, 0x80	; 128
     8d2:	f6 e0       	ldi	r31, 0x06	; 6
     8d4:	83 e0       	ldi	r24, 0x03	; 3
     8d6:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     8d8:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     8da:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     8dc:	e0 e8       	ldi	r30, 0x80	; 128
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	80 e7       	ldi	r24, 0x70	; 112
     8e2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     8e4:	89 e0       	ldi	r24, 0x09	; 9
     8e6:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     8e8:	e0 e4       	ldi	r30, 0x40	; 64
     8ea:	f8 e0       	ldi	r31, 0x08	; 8
     8ec:	8a e6       	ldi	r24, 0x6A	; 106
     8ee:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     8f0:	80 ea       	ldi	r24, 0xA0	; 160
     8f2:	95 e0       	ldi	r25, 0x05	; 5
     8f4:	86 a3       	std	Z+38, r24	; 0x26
     8f6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     8fc:	68 94       	set
     8fe:	ee 24       	eor	r14, r14
     900:	e6 f8       	bld	r14, 6
     902:	ff 24       	eor	r15, r15
     904:	f3 f8       	bld	r15, 3
     906:	f7 01       	movw	r30, r14
     908:	80 a1       	ldd	r24, Z+32	; 0x20
     90a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
			the_data = new_data;
     912:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <thPendulum>
     916:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <thPendulum+0x1>
			portEXIT_CRITICAL ();
     91a:	0f 90       	pop	r0
     91c:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     91e:	f8 01       	movw	r30, r16
     920:	86 85       	ldd	r24, Z+14	; 0x0e
     922:	97 85       	ldd	r25, Z+15	; 0x0f
     924:	a0 89       	ldd	r26, Z+16	; 0x10
     926:	b1 89       	ldd	r27, Z+17	; 0x11
     928:	01 96       	adiw	r24, 0x01	; 1
     92a:	a1 1d       	adc	r26, r1
     92c:	b1 1d       	adc	r27, r1
     92e:	86 87       	std	Z+14, r24	; 0x0e
     930:	97 87       	std	Z+15, r25	; 0x0f
     932:	a0 8b       	std	Z+16, r26	; 0x10
     934:	b1 8b       	std	Z+17, r27	; 0x11
     936:	41 e0       	ldi	r20, 0x01	; 1
     938:	50 e0       	ldi	r21, 0x00	; 0
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	70 e0       	ldi	r23, 0x00	; 0
     93e:	ce 01       	movw	r24, r28
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <vTaskDelayUntil>
     946:	df cf       	rjmp	.-66     	; 0x906 <_ZN15EncoderPendulum3runEv+0x50>

00000948 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     952:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <_ZN8frt_taskC1EPKchjP8emstream>
     956:	82 e1       	ldi	r24, 0x12	; 18
     958:	90 e2       	ldi	r25, 0x20	; 32
     95a:	88 83       	st	Y, r24
     95c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	08 95       	ret

00000968 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	00 d0       	rcall	.+0      	; 0x96e <_ZN13LimitSwitches3runEv+0x6>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     976:	0e 94 68 13 	call	0x26d0	; 0x26d0 <xTaskGetTickCount>
     97a:	69 83       	std	Y+1, r22	; 0x01
     97c:	7a 83       	std	Y+2, r23	; 0x02
     97e:	8b 83       	std	Y+3, r24	; 0x03
     980:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     982:	e0 e6       	ldi	r30, 0x60	; 96
     984:	f6 e0       	ldi	r31, 0x06	; 6
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     98a:	84 e0       	ldi	r24, 0x04	; 4
     98c:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     98e:	88 e1       	ldi	r24, 0x18	; 24
     990:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     992:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     994:	08 e6       	ldi	r16, 0x68	; 104
     996:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     998:	dd 24       	eor	r13, r13
     99a:	d3 94       	inc	r13
     99c:	f8 01       	movw	r30, r16
     99e:	80 81       	ld	r24, Z
     9a0:	80 fd       	sbrc	r24, 0
     9a2:	08 c0       	rjmp	.+16     	; 0x9b4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
			the_data = new_data;
     9aa:	d0 92 59 31 	sts	0x3159, r13	; 0x803159 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9ae:	0f 90       	pop	r0
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	07 c0       	rjmp	.+14     	; 0x9c2 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	0f 92       	push	r0
			the_data = new_data;
     9ba:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     9c2:	f8 01       	movw	r30, r16
     9c4:	80 81       	ld	r24, Z
     9c6:	82 fd       	sbrc	r24, 2
     9c8:	08 c0       	rjmp	.+16     	; 0x9da <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
			the_data = new_data;
     9d0:	d0 92 58 31 	sts	0x3158, r13	; 0x803158 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	f8 94       	cli
     9de:	0f 92       	push	r0
			the_data = new_data;
     9e0:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     9e8:	f7 01       	movw	r30, r14
     9ea:	86 85       	ldd	r24, Z+14	; 0x0e
     9ec:	97 85       	ldd	r25, Z+15	; 0x0f
     9ee:	a0 89       	ldd	r26, Z+16	; 0x10
     9f0:	b1 89       	ldd	r27, Z+17	; 0x11
     9f2:	01 96       	adiw	r24, 0x01	; 1
     9f4:	a1 1d       	adc	r26, r1
     9f6:	b1 1d       	adc	r27, r1
     9f8:	86 87       	std	Z+14, r24	; 0x0e
     9fa:	97 87       	std	Z+15, r25	; 0x0f
     9fc:	a0 8b       	std	Z+16, r26	; 0x10
     9fe:	b1 8b       	std	Z+17, r27	; 0x11
     a00:	41 e0       	ldi	r20, 0x01	; 1
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	01 96       	adiw	r24, 0x01	; 1
     a0c:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <vTaskDelayUntil>
     a10:	c5 cf       	rjmp	.-118    	; 0x99c <_ZN13LimitSwitches3runEv+0x34>

00000a12 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a1c:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <_ZN8frt_taskC1EPKchjP8emstream>
     a20:	8a e1       	ldi	r24, 0x1A	; 26
     a22:	90 e2       	ldi	r25, 0x20	; 32
     a24:	88 83       	st	Y, r24
     a26:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	08 95       	ret

00000a32 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	6a 97       	sbiw	r28, 0x1a	; 26
     a3c:	cd bf       	out	0x3d, r28	; 61
     a3e:	de bf       	out	0x3e, r29	; 62
     a40:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     a42:	0e 94 68 13 	call	0x26d0	; 0x26d0 <xTaskGetTickCount>
     a46:	69 83       	std	Y+1, r22	; 0x01
     a48:	7a 83       	std	Y+2, r23	; 0x02
     a4a:	8b 83       	std	Y+3, r24	; 0x03
     a4c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     a4e:	f8 01       	movw	r30, r16
     a50:	fe 96       	adiw	r30, 0x3e	; 62
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	a0 e0       	ldi	r26, 0x00	; 0
     a58:	b0 e0       	ldi	r27, 0x00	; 0
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
     a5e:	a2 83       	std	Z+2, r26	; 0x02
     a60:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     a62:	d8 01       	movw	r26, r16
     a64:	dc 96       	adiw	r26, 0x3c	; 60
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     a6c:	a0 e4       	ldi	r26, 0x40	; 64
     a6e:	b6 e0       	ldi	r27, 0x06	; 6
     a70:	87 e0       	ldi	r24, 0x07	; 7
     a72:	11 96       	adiw	r26, 0x01	; 1
     a74:	8c 93       	st	X, r24
     a76:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     a78:	84 e0       	ldi	r24, 0x04	; 4
     a7a:	15 96       	adiw	r26, 0x05	; 5
     a7c:	8c 93       	st	X, r24
     a7e:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     a80:	e0 e0       	ldi	r30, 0x00	; 0
     a82:	f8 e0       	ldi	r31, 0x08	; 8
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     a88:	83 e0       	ldi	r24, 0x03	; 3
     a8a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     a8c:	a6 a3       	std	Z+38, r26	; 0x26
     a8e:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     a90:	10 a6       	std	Z+40, r1	; 0x28
     a92:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     a94:	12 a6       	std	Z+42, r1	; 0x2a
     a96:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     a98:	81 81       	ldd	r24, Z+1	; 0x01
     a9a:	80 63       	ori	r24, 0x30	; 48
     a9c:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	0f 92       	push	r0
			the_data = new_data;
     aa4:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <linear_offset>
     aa8:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <linear_offset+0x1>
			portEXIT_CRITICAL ();
     aac:	0f 90       	pop	r0
     aae:	0f be       	out	0x3f, r0	; 63
	linear_offset.put(0);								// Initialize motor offset	
	int16_t left_home;									// Initialize left distance to calculate center
	int16_t position_set;								// Setpoint of cart's position
	int16_t KP_pos = 0.5*256;							// P gain for cart position				
	int16_t position_error = 0;							// positional error	
	int16_t position_midpoint = 0;						// midpoint calculated from homing sequence
     ab0:	19 8e       	std	Y+25, r1	; 0x19
     ab2:	1a 8e       	std	Y+26, r1	; 0x1a
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(500);
				_integral = 0;
     ab4:	58 01       	movw	r10, r16
     ab6:	b0 e5       	ldi	r27, 0x50	; 80
     ab8:	ab 0e       	add	r10, r27
     aba:	b1 1c       	adc	r11, r1
			case(0) :
				if (begin.get())											// If user begins Calibration Sequence
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     abc:	0f 2e       	mov	r0, r31
     abe:	fa e0       	ldi	r31, 0x0A	; 10
     ac0:	2f 2e       	mov	r2, r31
     ac2:	31 2c       	mov	r3, r1
     ac4:	f0 2d       	mov	r31, r0

					if (rightLimitSwitch.get())
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
						output_correct = 0;
     ac6:	68 01       	movw	r12, r16
     ac8:	ee e5       	ldi	r30, 0x5E	; 94
     aca:	ce 0e       	add	r12, r30
     acc:	d1 1c       	adc	r13, r1
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     ace:	98 01       	movw	r18, r16
     ad0:	28 5b       	subi	r18, 0xB8	; 184
     ad2:	3f 4f       	sbci	r19, 0xFF	; 255
     ad4:	29 8b       	std	Y+17, r18	; 0x11
     ad6:	3a 8b       	std	Y+18, r19	; 0x12
		_Ki = .7*256;
     ad8:	c8 01       	movw	r24, r16
     ada:	84 5b       	subi	r24, 0xB4	; 180
     adc:	9f 4f       	sbci	r25, 0xFF	; 255
     ade:	8d 83       	std	Y+5, r24	; 0x05
     ae0:	9e 83       	std	Y+6, r25	; 0x06
		_Kd = 0;
     ae2:	d8 01       	movw	r26, r16
     ae4:	a6 5b       	subi	r26, 0xB6	; 182
     ae6:	bf 4f       	sbci	r27, 0xFF	; 255
     ae8:	ab 8b       	std	Y+19, r26	; 0x13
     aea:	bc 8b       	std	Y+20, r27	; 0x14
		antiwind_gain = .75*256;
     aec:	f8 01       	movw	r30, r16
     aee:	ec 59       	subi	r30, 0x9C	; 156
     af0:	ff 4f       	sbci	r31, 0xFF	; 255
     af2:	ef 83       	std	Y+7, r30	; 0x07
     af4:	f8 87       	std	Y+8, r31	; 0x08
		
		_max = 1600;
     af6:	24 50       	subi	r18, 0x04	; 4
     af8:	31 09       	sbc	r19, r1
     afa:	29 87       	std	Y+9, r18	; 0x09
     afc:	3a 87       	std	Y+10, r19	; 0x0a
		_min = -1600;
     afe:	06 97       	sbiw	r24, 0x06	; 6
     b00:	8d 87       	std	Y+13, r24	; 0x0d
     b02:	9e 87       	std	Y+14, r25	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     b04:	52 96       	adiw	r26, 0x12	; 18
     b06:	ad 8b       	std	Y+21, r26	; 0x15
     b08:	be 8b       	std	Y+22, r27	; 0x16

		// Integral term
		error_int = error - antiwind_correct;
     b0a:	48 01       	movw	r8, r16
     b0c:	b6 e6       	ldi	r27, 0x66	; 102
     b0e:	8b 0e       	add	r8, r27
     b10:	91 1c       	adc	r9, r1
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     b12:	b6 97       	sbiw	r30, 0x26	; 38
     b14:	eb 87       	std	Y+11, r30	; 0x0b
     b16:	fc 87       	std	Y+12, r31	; 0x0c
	int16_t K_position_antiwind = 0*256;				// position anti windup gain
	int16_t position_saturation_point;
	
	while(1){
		// Increment counter for debugging
		runs++;
     b18:	d8 01       	movw	r26, r16
     b1a:	1e 96       	adiw	r26, 0x0e	; 14
     b1c:	4d 91       	ld	r20, X+
     b1e:	5d 91       	ld	r21, X+
     b20:	6d 91       	ld	r22, X+
     b22:	7c 91       	ld	r23, X
     b24:	51 97       	sbiw	r26, 0x11	; 17
     b26:	4f 5f       	subi	r20, 0xFF	; 255
     b28:	5f 4f       	sbci	r21, 0xFF	; 255
     b2a:	6f 4f       	sbci	r22, 0xFF	; 255
     b2c:	7f 4f       	sbci	r23, 0xFF	; 255
     b2e:	f8 01       	movw	r30, r16
     b30:	46 87       	std	Z+14, r20	; 0x0e
     b32:	57 87       	std	Z+15, r21	; 0x0f
     b34:	60 8b       	std	Z+16, r22	; 0x10
     b36:	71 8b       	std	Z+17, r23	; 0x11
		
		switch (state)
     b38:	84 85       	ldd	r24, Z+12	; 0x0c
     b3a:	82 30       	cpi	r24, 0x02	; 2
     b3c:	09 f4       	brne	.+2      	; 0xb40 <_ZN5Motor3runEv+0x10e>
     b3e:	8f c0       	rjmp	.+286    	; 0xc5e <_ZN5Motor3runEv+0x22c>
     b40:	30 f4       	brcc	.+12     	; 0xb4e <_ZN5Motor3runEv+0x11c>
     b42:	88 23       	and	r24, r24
     b44:	69 f0       	breq	.+26     	; 0xb60 <_ZN5Motor3runEv+0x12e>
     b46:	81 30       	cpi	r24, 0x01	; 1
     b48:	09 f4       	brne	.+2      	; 0xb4c <_ZN5Motor3runEv+0x11a>
     b4a:	4d c0       	rjmp	.+154    	; 0xbe6 <_ZN5Motor3runEv+0x1b4>
     b4c:	a3 c1       	rjmp	.+838    	; 0xe94 <_ZN5Motor3runEv+0x462>
     b4e:	84 30       	cpi	r24, 0x04	; 4
     b50:	09 f4       	brne	.+2      	; 0xb54 <_ZN5Motor3runEv+0x122>
     b52:	01 c1       	rjmp	.+514    	; 0xd56 <_ZN5Motor3runEv+0x324>
     b54:	08 f4       	brcc	.+2      	; 0xb58 <_ZN5Motor3runEv+0x126>
     b56:	97 c0       	rjmp	.+302    	; 0xc86 <_ZN5Motor3runEv+0x254>
     b58:	84 36       	cpi	r24, 0x64	; 100
     b5a:	09 f4       	brne	.+2      	; 0xb5e <_ZN5Motor3runEv+0x12c>
     b5c:	65 c1       	rjmp	.+714    	; 0xe28 <_ZN5Motor3runEv+0x3f6>
     b5e:	9a c1       	rjmp	.+820    	; 0xe94 <_ZN5Motor3runEv+0x462>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b60:	0f b6       	in	r0, 0x3f	; 63
     b62:	f8 94       	cli
     b64:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b66:	0f 90       	pop	r0
     b68:	0f be       	out	0x3f, r0	; 63
		{
			// Home right
			case(0) :
				if (begin.get())											// If user begins Calibration Sequence
     b6a:	80 91 55 31 	lds	r24, 0x3155	; 0x803155 <begin>
     b6e:	88 23       	and	r24, r24
     b70:	09 f4       	brne	.+2      	; 0xb74 <_ZN5Motor3runEv+0x142>
     b72:	90 c1       	rjmp	.+800    	; 0xe94 <_ZN5Motor3runEv+0x462>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b74:	0f b6       	in	r0, 0x3f	; 63
     b76:	f8 94       	cli
     b78:	0f 92       	push	r0
			the_data = new_data;
     b7a:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <reset>
			portEXIT_CRITICAL ();
     b7e:	0f 90       	pop	r0
     b80:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b82:	0f b6       	in	r0, 0x3f	; 63
     b84:	f8 94       	cli
     b86:	0f 92       	push	r0
			the_data = new_data;
     b88:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <stop>
			portEXIT_CRITICAL ();
     b8c:	0f 90       	pop	r0
     b8e:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     b90:	22 8e       	std	Z+26, r2	; 0x1a
     b92:	33 8e       	std	Z+27, r3	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b94:	0f b6       	in	r0, 0x3f	; 63
     b96:	f8 94       	cli
     b98:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63

					if (rightLimitSwitch.get())
     b9e:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rightLimitSwitch>
     ba2:	88 23       	and	r24, r24
     ba4:	09 f4       	brne	.+2      	; 0xba8 <_ZN5Motor3runEv+0x176>
     ba6:	76 c1       	rjmp	.+748    	; 0xe94 <_ZN5Motor3runEv+0x462>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ba8:	0f b6       	in	r0, 0x3f	; 63
     baa:	f8 94       	cli
     bac:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bae:	0f 90       	pop	r0
     bb0:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bb2:	0f b6       	in	r0, 0x3f	; 63
     bb4:	f8 94       	cli
     bb6:	0f 92       	push	r0
			the_data = new_data;
     bb8:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <linear_position>
     bbc:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <linear_position+0x1>
     bc0:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <linear_offset>
     bc4:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <linear_offset+0x1>
			portEXIT_CRITICAL ();
     bc8:	0f 90       	pop	r0
     bca:	0f be       	out	0x3f, r0	; 63
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
     bcc:	f5 01       	movw	r30, r10
     bce:	10 82       	st	Z, r1
     bd0:	11 82       	std	Z+1, r1	; 0x01
     bd2:	12 82       	std	Z+2, r1	; 0x02
     bd4:	13 82       	std	Z+3, r1	; 0x03
						output_correct = 0;
     bd6:	d6 01       	movw	r26, r12
     bd8:	1d 92       	st	X+, r1
     bda:	1c 92       	st	X, r1
						transition_to(1);									// if right Limit Switch is triggered 
     bdc:	61 e0       	ldi	r22, 0x01	; 1
     bde:	c8 01       	movw	r24, r16
     be0:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
     be4:	57 c1       	rjmp	.+686    	; 0xe94 <_ZN5Motor3runEv+0x462>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     be6:	0f b6       	in	r0, 0x3f	; 63
     be8:	f8 94       	cli
     bea:	0f 92       	push	r0
			the_data = new_data;
     bec:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <begin>
			portEXIT_CRITICAL ();
     bf0:	0f 90       	pop	r0
     bf2:	0f be       	out	0x3f, r0	; 63
				break;
				
			// Home left
			case(1) :
				begin.put(0);		// turn off flag
				omegam_set = -10;	// [ticks/ms]
     bf4:	86 ef       	ldi	r24, 0xF6	; 246
     bf6:	9f ef       	ldi	r25, 0xFF	; 255
     bf8:	f8 01       	movw	r30, r16
     bfa:	82 8f       	std	Z+26, r24	; 0x1a
     bfc:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bfe:	0f b6       	in	r0, 0x3f	; 63
     c00:	f8 94       	cli
     c02:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c04:	0f 90       	pop	r0
     c06:	0f be       	out	0x3f, r0	; 63
				
				if (leftLimitSwitch.get())
     c08:	80 91 59 31 	lds	r24, 0x3159	; 0x803159 <leftLimitSwitch>
     c0c:	88 23       	and	r24, r24
     c0e:	c1 f0       	breq	.+48     	; 0xc40 <_ZN5Motor3runEv+0x20e>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c10:	0f b6       	in	r0, 0x3f	; 63
     c12:	f8 94       	cli
     c14:	0f 92       	push	r0
			temporary_copy = the_data;
     c16:	20 91 5e 31 	lds	r18, 0x315E	; 0x80315e <linear_position>
     c1a:	30 91 5f 31 	lds	r19, 0x315F	; 0x80315f <linear_position+0x1>
     c1e:	2f 8b       	std	Y+23, r18	; 0x17
     c20:	38 8f       	std	Y+24, r19	; 0x18
			portEXIT_CRITICAL ();
     c22:	0f 90       	pop	r0
     c24:	0f be       	out	0x3f, r0	; 63
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     c26:	d5 01       	movw	r26, r10
     c28:	1d 92       	st	X+, r1
     c2a:	1d 92       	st	X+, r1
     c2c:	1d 92       	st	X+, r1
     c2e:	1c 92       	st	X, r1
     c30:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     c32:	f6 01       	movw	r30, r12
     c34:	10 82       	st	Z, r1
     c36:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     c38:	62 e0       	ldi	r22, 0x02	; 2
     c3a:	c8 01       	movw	r24, r16
     c3c:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c46:	0f 90       	pop	r0
     c48:	0f be       	out	0x3f, r0	; 63
				}
						
				if (reset.get() == 1)
     c4a:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <reset>
     c4e:	88 23       	and	r24, r24
     c50:	09 f4       	brne	.+2      	; 0xc54 <_ZN5Motor3runEv+0x222>
     c52:	20 c1       	rjmp	.+576    	; 0xe94 <_ZN5Motor3runEv+0x462>
				{
					transition_to(0);
     c54:	60 e0       	ldi	r22, 0x00	; 0
     c56:	c8 01       	movw	r24, r16
     c58:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
     c5c:	1b c1       	rjmp	.+566    	; 0xe94 <_ZN5Motor3runEv+0x462>
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     c5e:	64 ef       	ldi	r22, 0xF4	; 244
     c60:	71 e0       	ldi	r23, 0x01	; 1
     c62:	80 e0       	ldi	r24, 0x00	; 0
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <vTaskDelay>
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(500);
				_integral = 0;
     c6a:	d5 01       	movw	r26, r10
     c6c:	1d 92       	st	X+, r1
     c6e:	1d 92       	st	X+, r1
     c70:	1d 92       	st	X+, r1
     c72:	1c 92       	st	X, r1
     c74:	13 97       	sbiw	r26, 0x03	; 3
				omegam_set = 0;
     c76:	f8 01       	movw	r30, r16
     c78:	12 8e       	std	Z+26, r1	; 0x1a
     c7a:	13 8e       	std	Z+27, r1	; 0x1b
				transition_to(3);
     c7c:	63 e0       	ldi	r22, 0x03	; 3
     c7e:	c8 01       	movw	r24, r16
     c80:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
				break;
     c84:	07 c1       	rjmp	.+526    	; 0xe94 <_ZN5Motor3runEv+0x462>
				
			
			// Center Cart - Position Loop included
			case(3) :
				position_midpoint = left_home/2;
     c86:	8f 89       	ldd	r24, Y+23	; 0x17
     c88:	98 8d       	ldd	r25, Y+24	; 0x18
     c8a:	99 23       	and	r25, r25
     c8c:	0c f4       	brge	.+2      	; 0xc90 <_ZN5Motor3runEv+0x25e>
     c8e:	01 96       	adiw	r24, 0x01	; 1
     c90:	9c 01       	movw	r18, r24
     c92:	35 95       	asr	r19
     c94:	27 95       	ror	r18
     c96:	2f 87       	std	Y+15, r18	; 0x0f
     c98:	38 8b       	std	Y+16, r19	; 0x10
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c9a:	0f b6       	in	r0, 0x3f	; 63
     c9c:	f8 94       	cli
     c9e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     ca0:	0f 90       	pop	r0
     ca2:	0f be       	out	0x3f, r0	; 63
				
				position_error_windup = position_error - antiwind_pos_correct;			// Subtracts omegam_set windup
				position_windup_integral = (_Ki_position * position_error_windup);	// Integral gain on omegam_set windup difference
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_integral * dt)/256;						// Integrates omegam_set windup difference with gain
				omegam_set_windup = ssadd(omegam_set_Kp, omegam_set_Ki);					// Add proportionality and integral gain
     ca4:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <linear_position>
     ca8:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <linear_position+0x1>
     cac:	28 1b       	sub	r18, r24
     cae:	39 0b       	sbc	r19, r25
     cb0:	c9 01       	movw	r24, r18
     cb2:	36 95       	lsr	r19
     cb4:	32 2f       	mov	r19, r18
     cb6:	22 27       	eor	r18, r18
     cb8:	37 95       	ror	r19
     cba:	27 95       	ror	r18
     cbc:	90 ff       	sbrs	r25, 0
     cbe:	02 c0       	rjmp	.+4      	; 0xcc4 <_ZN5Motor3runEv+0x292>
     cc0:	21 50       	subi	r18, 0x01	; 1
     cc2:	3f 4f       	sbci	r19, 0xFF	; 255
     cc4:	60 e0       	ldi	r22, 0x00	; 0
     cc6:	70 e0       	ldi	r23, 0x00	; 0
     cc8:	83 2f       	mov	r24, r19
     cca:	93 2f       	mov	r25, r19
     ccc:	99 0f       	add	r25, r25
     cce:	99 0b       	sbc	r25, r25
     cd0:	0e 94 1f 09 	call	0x123e	; 0x123e <_ZN7satmath20signed_saturated_addEii>
				omegam_set = omegam_set_windup;												// Set desired to requested
				
				omegam_saturation_point = 40;
				if( omegam_set > omegam_saturation_point )														// Saturate requested omegam_set
     cd4:	89 32       	cpi	r24, 0x29	; 41
     cd6:	91 05       	cpc	r25, r1
     cd8:	44 f0       	brlt	.+16     	; 0xcea <_ZN5Motor3runEv+0x2b8>
				{
					omegam_set = omegam_saturation_point;
     cda:	88 e2       	ldi	r24, 0x28	; 40
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	d8 01       	movw	r26, r16
     ce0:	5a 96       	adiw	r26, 0x1a	; 26
     ce2:	8d 93       	st	X+, r24
     ce4:	9c 93       	st	X, r25
     ce6:	5b 97       	sbiw	r26, 0x1b	; 27
     ce8:	0f c0       	rjmp	.+30     	; 0xd08 <_ZN5Motor3runEv+0x2d6>
				}
				else if( omegam_set < -omegam_saturation_point )
     cea:	88 3d       	cpi	r24, 0xD8	; 216
     cec:	bf ef       	ldi	r27, 0xFF	; 255
     cee:	9b 07       	cpc	r25, r27
     cf0:	24 f0       	brlt	.+8      	; 0xcfa <_ZN5Motor3runEv+0x2c8>
				position_error_windup = position_error - antiwind_pos_correct;			// Subtracts omegam_set windup
				position_windup_integral = (_Ki_position * position_error_windup);	// Integral gain on omegam_set windup difference
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_integral * dt)/256;						// Integrates omegam_set windup difference with gain
				omegam_set_windup = ssadd(omegam_set_Kp, omegam_set_Ki);					// Add proportionality and integral gain
				omegam_set = omegam_set_windup;												// Set desired to requested
     cf2:	f8 01       	movw	r30, r16
     cf4:	82 8f       	std	Z+26, r24	; 0x1a
     cf6:	93 8f       	std	Z+27, r25	; 0x1b
     cf8:	07 c0       	rjmp	.+14     	; 0xd08 <_ZN5Motor3runEv+0x2d6>
				{
					omegam_set = omegam_saturation_point;
				}
				else if( omegam_set < -omegam_saturation_point )
				{
					omegam_set = -omegam_saturation_point;
     cfa:	88 ed       	ldi	r24, 0xD8	; 216
     cfc:	9f ef       	ldi	r25, 0xFF	; 255
     cfe:	d8 01       	movw	r26, r16
     d00:	5a 96       	adiw	r26, 0x1a	; 26
     d02:	8d 93       	st	X+, r24
     d04:	9c 93       	st	X, r25
     d06:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d08:	0f b6       	in	r0, 0x3f	; 63
     d0a:	f8 94       	cli
     d0c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d0e:	0f 90       	pop	r0
     d10:	0f be       	out	0x3f, r0	; 63
				}
				
				antiwind_position = omegam_set_windup - omegam_set;					// Calculate windup error between desired and requested
				antiwind_pos_correct = (antiwind_error*K_position_antiwind)/256;
				
				if (reset.get() == 1)			// if user hits reset
     d12:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <reset>
     d16:	88 23       	and	r24, r24
     d18:	59 f0       	breq	.+22     	; 0xd30 <_ZN5Motor3runEv+0x2fe>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	f8 94       	cli
     d1e:	0f 92       	push	r0
			the_data = new_data;
     d20:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <reset>
			portEXIT_CRITICAL ();
     d24:	0f 90       	pop	r0
     d26:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);				// turn off flag
					transition_to(0);
     d28:	60 e0       	ldi	r22, 0x00	; 0
     d2a:	c8 01       	movw	r24, r16
     d2c:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d30:	0f b6       	in	r0, 0x3f	; 63
     d32:	f8 94       	cli
     d34:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d36:	0f 90       	pop	r0
     d38:	0f be       	out	0x3f, r0	; 63
					
				}
				
				if(go.get() == 1)				// If user says pendulum is upright or angle = 720;
     d3a:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <go>
     d3e:	88 23       	and	r24, r24
     d40:	09 f4       	brne	.+2      	; 0xd44 <_ZN5Motor3runEv+0x312>
     d42:	a4 c0       	rjmp	.+328    	; 0xe8c <_ZN5Motor3runEv+0x45a>
				{
					transition_to(4);
     d44:	64 e0       	ldi	r22, 0x04	; 4
     d46:	c8 01       	movw	r24, r16
     d48:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
				break;
				
			
			// Center Cart - Position Loop included
			case(3) :
				position_midpoint = left_home/2;
     d4c:	ef 85       	ldd	r30, Y+15	; 0x0f
     d4e:	f8 89       	ldd	r31, Y+16	; 0x10
     d50:	e9 8f       	std	Y+25, r30	; 0x19
     d52:	fa 8f       	std	Y+26, r31	; 0x1a
     d54:	9f c0       	rjmp	.+318    	; 0xe94 <_ZN5Motor3runEv+0x462>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d56:	0f b6       	in	r0, 0x3f	; 63
     d58:	f8 94       	cli
     d5a:	0f 92       	push	r0
			the_data = new_data;
     d5c:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <go>
			portEXIT_CRITICAL ();
     d60:	0f 90       	pop	r0
     d62:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d64:	0f b6       	in	r0, 0x3f	; 63
     d66:	f8 94       	cli
     d68:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d6a:	0f 90       	pop	r0
     d6c:	0f be       	out	0x3f, r0	; 63
			
			// Pendulum Balance if user sets pendulum "Inverted" and presses go
			case(4) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				position_set = position_midpoint + (angle_error*KP_angle)/256;
     d6e:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <thPendulum>
     d72:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <thPendulum+0x1>
     d76:	20 ed       	ldi	r18, 0xD0	; 208
     d78:	32 e0       	ldi	r19, 0x02	; 2
     d7a:	28 1b       	sub	r18, r24
     d7c:	39 0b       	sbc	r19, r25
     d7e:	48 e1       	ldi	r20, 0x18	; 24
     d80:	5c ef       	ldi	r21, 0xFC	; 252
     d82:	24 9f       	mul	r18, r20
     d84:	c0 01       	movw	r24, r0
     d86:	25 9f       	mul	r18, r21
     d88:	90 0d       	add	r25, r0
     d8a:	34 9f       	mul	r19, r20
     d8c:	90 0d       	add	r25, r0
     d8e:	11 24       	eor	r1, r1
     d90:	99 23       	and	r25, r25
     d92:	14 f4       	brge	.+4      	; 0xd98 <_ZN5Motor3runEv+0x366>
     d94:	81 50       	subi	r24, 0x01	; 1
     d96:	9f 4f       	sbci	r25, 0xFF	; 255
     d98:	89 2f       	mov	r24, r25
     d9a:	99 0f       	add	r25, r25
     d9c:	99 0b       	sbc	r25, r25
     d9e:	29 8d       	ldd	r18, Y+25	; 0x19
     da0:	3a 8d       	ldd	r19, Y+26	; 0x1a
     da2:	28 0f       	add	r18, r24
     da4:	39 1f       	adc	r19, r25
     da6:	2f 87       	std	Y+15, r18	; 0x0f
     da8:	38 8b       	std	Y+16, r19	; 0x10
				
				// Saturation for limits of tracks
				
				if (position_set >= -150) //20
     daa:	2a 36       	cpi	r18, 0x6A	; 106
     dac:	8f ef       	ldi	r24, 0xFF	; 255
     dae:	38 07       	cpc	r19, r24
     db0:	44 f4       	brge	.+16     	; 0xdc2 <_ZN5Motor3runEv+0x390>
				{
					position_set = -150;
					omegam_set = 0;
				}
				else if (position_set <= -250) //325
     db2:	27 30       	cpi	r18, 0x07	; 7
     db4:	3f 4f       	sbci	r19, 0xFF	; 255
     db6:	4c f4       	brge	.+18     	; 0xdca <_ZN5Motor3runEv+0x398>
				{
					position_set = -250; //352
     db8:	a6 e0       	ldi	r26, 0x06	; 6
     dba:	bf ef       	ldi	r27, 0xFF	; 255
     dbc:	af 87       	std	Y+15, r26	; 0x0f
     dbe:	b8 8b       	std	Y+16, r27	; 0x10
     dc0:	04 c0       	rjmp	.+8      	; 0xdca <_ZN5Motor3runEv+0x398>
				
				// Saturation for limits of tracks
				
				if (position_set >= -150) //20
				{
					position_set = -150;
     dc2:	ea e6       	ldi	r30, 0x6A	; 106
     dc4:	ff ef       	ldi	r31, 0xFF	; 255
     dc6:	ef 87       	std	Y+15, r30	; 0x0f
     dc8:	f8 8b       	std	Y+16, r31	; 0x10
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     dd0:	0f 90       	pop	r0
     dd2:	0f be       	out	0x3f, r0	; 63
					position_set = position_set;
				}
				
				position_error = position_set - linear_position.get();  // 
				omegam_set_windup = position_error*KP_pos/256;
				omegam_set = omegam_set_windup;
     dd4:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <linear_position>
     dd8:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <linear_position+0x1>
     ddc:	2f 85       	ldd	r18, Y+15	; 0x0f
     dde:	38 89       	ldd	r19, Y+16	; 0x10
     de0:	28 1b       	sub	r18, r24
     de2:	39 0b       	sbc	r19, r25
     de4:	c9 01       	movw	r24, r18
     de6:	96 95       	lsr	r25
     de8:	98 2f       	mov	r25, r24
     dea:	88 27       	eor	r24, r24
     dec:	97 95       	ror	r25
     dee:	87 95       	ror	r24
     df0:	30 ff       	sbrs	r19, 0
     df2:	02 c0       	rjmp	.+4      	; 0xdf8 <_ZN5Motor3runEv+0x3c6>
     df4:	81 50       	subi	r24, 0x01	; 1
     df6:	9f 4f       	sbci	r25, 0xFF	; 255
     df8:	89 2f       	mov	r24, r25
     dfa:	88 0f       	add	r24, r24
     dfc:	88 0b       	sbc	r24, r24
     dfe:	d8 01       	movw	r26, r16
     e00:	5a 96       	adiw	r26, 0x1a	; 26
     e02:	9c 93       	st	X, r25
     e04:	5a 97       	sbiw	r26, 0x1a	; 26
     e06:	5b 96       	adiw	r26, 0x1b	; 27
     e08:	8c 93       	st	X, r24
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e0a:	0f b6       	in	r0, 0x3f	; 63
     e0c:	f8 94       	cli
     e0e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e10:	0f 90       	pop	r0
     e12:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get())
     e14:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <reset>
     e18:	88 23       	and	r24, r24
     e1a:	09 f4       	brne	.+2      	; 0xe1e <_ZN5Motor3runEv+0x3ec>
     e1c:	3b c0       	rjmp	.+118    	; 0xe94 <_ZN5Motor3runEv+0x462>
				{
					transition_to(0);
     e1e:	60 e0       	ldi	r22, 0x00	; 0
     e20:	c8 01       	movw	r24, r16
     e22:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
     e26:	36 c0       	rjmp	.+108    	; 0xe94 <_ZN5Motor3runEv+0x462>
				}
					
			break;
			
			case(100) :
			omegam_set = 0;
     e28:	f8 01       	movw	r30, r16
     e2a:	12 8e       	std	Z+26, r1	; 0x1a
     e2c:	13 8e       	std	Z+27, r1	; 0x1b
			
			if (runs%300 == 0)
     e2e:	cb 01       	movw	r24, r22
     e30:	ba 01       	movw	r22, r20
     e32:	2c e2       	ldi	r18, 0x2C	; 44
     e34:	31 e0       	ldi	r19, 0x01	; 1
     e36:	40 e0       	ldi	r20, 0x00	; 0
     e38:	50 e0       	ldi	r21, 0x00	; 0
     e3a:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__udivmodsi4>
     e3e:	67 2b       	or	r22, r23
     e40:	68 2b       	or	r22, r24
     e42:	69 2b       	or	r22, r25
     e44:	71 f4       	brne	.+28     	; 0xe62 <_ZN5Motor3runEv+0x430>
			{
				*p_serial << "Error State" << endl;
     e46:	d8 01       	movw	r26, r16
     e48:	16 96       	adiw	r26, 0x06	; 6
     e4a:	ed 90       	ld	r14, X+
     e4c:	fc 90       	ld	r15, X
     e4e:	17 97       	sbiw	r26, 0x07	; 7
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     e50:	6e e1       	ldi	r22, 0x1E	; 30
     e52:	70 e2       	ldi	r23, 0x20	; 32
     e54:	c7 01       	movw	r24, r14
     e56:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
     e5a:	66 e0       	ldi	r22, 0x06	; 6
     e5c:	c7 01       	movw	r24, r14
     e5e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e62:	0f b6       	in	r0, 0x3f	; 63
     e64:	f8 94       	cli
     e66:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e68:	0f 90       	pop	r0
     e6a:	0f be       	out	0x3f, r0	; 63
			}
			
				if (reset.get())										// if user hits reset
     e6c:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <reset>
     e70:	88 23       	and	r24, r24
     e72:	81 f0       	breq	.+32     	; 0xe94 <_ZN5Motor3runEv+0x462>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	f8 94       	cli
     e78:	0f 92       	push	r0
			the_data = new_data;
     e7a:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <reset>
			portEXIT_CRITICAL ();
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);
					transition_to(0);
     e82:	60 e0       	ldi	r22, 0x00	; 0
     e84:	c8 01       	movw	r24, r16
     e86:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
     e8a:	04 c0       	rjmp	.+8      	; 0xe94 <_ZN5Motor3runEv+0x462>
				break;
				
			
			// Center Cart - Position Loop included
			case(3) :
				position_midpoint = left_home/2;
     e8c:	ef 85       	ldd	r30, Y+15	; 0x0f
     e8e:	f8 89       	ldd	r31, Y+16	; 0x10
     e90:	e9 8f       	std	Y+25, r30	; 0x19
     e92:	fa 8f       	std	Y+26, r31	; 0x1a
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e94:	0f b6       	in	r0, 0x3f	; 63
     e96:	f8 94       	cli
     e98:	0f 92       	push	r0
			temporary_copy = the_data;
     e9a:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <thdMotor>
     e9e:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     ea2:	0f 90       	pop	r0
     ea4:	0f be       	out	0x3f, r0	; 63
		
		};

		
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     ea6:	d8 01       	movw	r26, r16
     ea8:	5e 96       	adiw	r26, 0x1e	; 30
     eaa:	8d 93       	st	X+, r24
     eac:	9c 93       	st	X, r25
     eae:	5f 97       	sbiw	r26, 0x1f	; 31
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     eb0:	e9 89       	ldd	r30, Y+17	; 0x11
     eb2:	fa 89       	ldd	r31, Y+18	; 0x12
     eb4:	20 82       	st	Z, r2
     eb6:	31 82       	std	Z+1, r3	; 0x01
		_Ki = .7*256;
     eb8:	23 eb       	ldi	r18, 0xB3	; 179
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	ad 81       	ldd	r26, Y+5	; 0x05
     ebe:	be 81       	ldd	r27, Y+6	; 0x06
     ec0:	2d 93       	st	X+, r18
     ec2:	3c 93       	st	X, r19
		_Kd = 0;
     ec4:	eb 89       	ldd	r30, Y+19	; 0x13
     ec6:	fc 89       	ldd	r31, Y+20	; 0x14
     ec8:	10 82       	st	Z, r1
     eca:	11 82       	std	Z+1, r1	; 0x01
		antiwind_gain = .75*256;
     ecc:	20 ec       	ldi	r18, 0xC0	; 192
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	af 81       	ldd	r26, Y+7	; 0x07
     ed2:	b8 85       	ldd	r27, Y+8	; 0x08
     ed4:	2d 93       	st	X+, r18
     ed6:	3c 93       	st	X, r19
		
		_max = 1600;
     ed8:	20 e4       	ldi	r18, 0x40	; 64
     eda:	36 e0       	ldi	r19, 0x06	; 6
     edc:	e9 85       	ldd	r30, Y+9	; 0x09
     ede:	fa 85       	ldd	r31, Y+10	; 0x0a
     ee0:	20 83       	st	Z, r18
     ee2:	31 83       	std	Z+1, r19	; 0x01
		_min = -1600;
     ee4:	20 ec       	ldi	r18, 0xC0	; 192
     ee6:	39 ef       	ldi	r19, 0xF9	; 249
     ee8:	ad 85       	ldd	r26, Y+13	; 0x0d
     eea:	be 85       	ldd	r27, Y+14	; 0x0e
     eec:	2d 93       	st	X+, r18
     eee:	3c 93       	st	X, r19
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     ef0:	f8 01       	movw	r30, r16
     ef2:	e2 8c       	ldd	r14, Z+26	; 0x1a
     ef4:	f3 8c       	ldd	r15, Z+27	; 0x1b
     ef6:	e8 1a       	sub	r14, r24
     ef8:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     efa:	b7 01       	movw	r22, r14
     efc:	c1 01       	movw	r24, r2
     efe:	0e 94 3b 09 	call	0x1276	; 0x1276 <_ZN7satmath20signed_saturated_mulEii>
     f02:	2b 01       	movw	r4, r22
     f04:	3c 01       	movw	r6, r24
     f06:	ad 89       	ldd	r26, Y+21	; 0x15
     f08:	be 89       	ldd	r27, Y+22	; 0x16
     f0a:	6d 93       	st	X+, r22
     f0c:	7c 93       	st	X, r23

		// Integral term
		error_int = error - antiwind_correct;
     f0e:	f4 01       	movw	r30, r8
     f10:	80 81       	ld	r24, Z
     f12:	91 81       	ldd	r25, Z+1	; 0x01
     f14:	97 01       	movw	r18, r14
     f16:	28 1b       	sub	r18, r24
     f18:	39 0b       	sbc	r19, r25
     f1a:	c9 01       	movw	r24, r18
     f1c:	f8 01       	movw	r30, r16
     f1e:	e8 59       	subi	r30, 0x98	; 152
     f20:	ff 4f       	sbci	r31, 0xFF	; 255
     f22:	20 83       	st	Z, r18
     f24:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     f26:	ad 81       	ldd	r26, Y+5	; 0x05
     f28:	be 81       	ldd	r27, Y+6	; 0x06
     f2a:	2d 91       	ld	r18, X+
     f2c:	3c 91       	ld	r19, X
     f2e:	82 9f       	mul	r24, r18
     f30:	d0 01       	movw	r26, r0
     f32:	83 9f       	mul	r24, r19
     f34:	b0 0d       	add	r27, r0
     f36:	92 9f       	mul	r25, r18
     f38:	b0 0d       	add	r27, r0
     f3a:	11 24       	eor	r1, r1
     f3c:	32 96       	adiw	r30, 0x02	; 2
     f3e:	a0 83       	st	Z, r26
     f40:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     f42:	eb 85       	ldd	r30, Y+11	; 0x0b
     f44:	fc 85       	ldd	r31, Y+12	; 0x0c
     f46:	20 81       	ld	r18, Z
     f48:	31 81       	ldd	r19, Z+1	; 0x01
     f4a:	42 81       	ldd	r20, Z+2	; 0x02
     f4c:	53 81       	ldd	r21, Z+3	; 0x03
     f4e:	0e 94 e1 22 	call	0x45c2	; 0x45c2 <__mulshisi3>
     f52:	9b 01       	movw	r18, r22
     f54:	ac 01       	movw	r20, r24
     f56:	99 23       	and	r25, r25
     f58:	24 f4       	brge	.+8      	; 0xf62 <_ZN5Motor3runEv+0x530>
     f5a:	21 50       	subi	r18, 0x01	; 1
     f5c:	3f 4f       	sbci	r19, 0xFF	; 255
     f5e:	4f 4f       	sbci	r20, 0xFF	; 255
     f60:	5f 4f       	sbci	r21, 0xFF	; 255
     f62:	bb 27       	eor	r27, r27
     f64:	57 fd       	sbrc	r21, 7
     f66:	ba 95       	dec	r27
     f68:	a5 2f       	mov	r26, r21
     f6a:	94 2f       	mov	r25, r20
     f6c:	83 2f       	mov	r24, r19
     f6e:	f5 01       	movw	r30, r10
     f70:	40 81       	ld	r20, Z
     f72:	51 81       	ldd	r21, Z+1	; 0x01
     f74:	62 81       	ldd	r22, Z+2	; 0x02
     f76:	73 81       	ldd	r23, Z+3	; 0x03
     f78:	84 0f       	add	r24, r20
     f7a:	95 1f       	adc	r25, r21
     f7c:	a6 1f       	adc	r26, r22
     f7e:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     f80:	81 30       	cpi	r24, 0x01	; 1
     f82:	fa ec       	ldi	r31, 0xCA	; 202
     f84:	9f 07       	cpc	r25, r31
     f86:	fa e9       	ldi	r31, 0x9A	; 154
     f88:	af 07       	cpc	r26, r31
     f8a:	fb e3       	ldi	r31, 0x3B	; 59
     f8c:	bf 07       	cpc	r27, r31
     f8e:	54 f0       	brlt	.+20     	; 0xfa4 <_ZN5Motor3runEv+0x572>
		{
			_integral = 1000000000;
     f90:	80 e0       	ldi	r24, 0x00	; 0
     f92:	9a ec       	ldi	r25, 0xCA	; 202
     f94:	aa e9       	ldi	r26, 0x9A	; 154
     f96:	bb e3       	ldi	r27, 0x3B	; 59
     f98:	f5 01       	movw	r30, r10
     f9a:	80 83       	st	Z, r24
     f9c:	91 83       	std	Z+1, r25	; 0x01
     f9e:	a2 83       	std	Z+2, r26	; 0x02
     fa0:	b3 83       	std	Z+3, r27	; 0x03
     fa2:	17 c0       	rjmp	.+46     	; 0xfd2 <_ZN5Motor3runEv+0x5a0>
		}
		else if(_integral < -1000000000)
     fa4:	81 15       	cp	r24, r1
     fa6:	f6 e3       	ldi	r31, 0x36	; 54
     fa8:	9f 07       	cpc	r25, r31
     faa:	f5 e6       	ldi	r31, 0x65	; 101
     fac:	af 07       	cpc	r26, r31
     fae:	f4 ec       	ldi	r31, 0xC4	; 196
     fb0:	bf 07       	cpc	r27, r31
     fb2:	34 f0       	brlt	.+12     	; 0xfc0 <_ZN5Motor3runEv+0x58e>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     fb4:	f5 01       	movw	r30, r10
     fb6:	80 83       	st	Z, r24
     fb8:	91 83       	std	Z+1, r25	; 0x01
     fba:	a2 83       	std	Z+2, r26	; 0x02
     fbc:	b3 83       	std	Z+3, r27	; 0x03
     fbe:	09 c0       	rjmp	.+18     	; 0xfd2 <_ZN5Motor3runEv+0x5a0>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
     fc0:	80 e0       	ldi	r24, 0x00	; 0
     fc2:	96 e3       	ldi	r25, 0x36	; 54
     fc4:	a5 e6       	ldi	r26, 0x65	; 101
     fc6:	b4 ec       	ldi	r27, 0xC4	; 196
     fc8:	f5 01       	movw	r30, r10
     fca:	80 83       	st	Z, r24
     fcc:	91 83       	std	Z+1, r25	; 0x01
     fce:	a2 83       	std	Z+2, r26	; 0x02
     fd0:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     fd2:	d5 01       	movw	r26, r10
     fd4:	6d 91       	ld	r22, X+
     fd6:	7c 91       	ld	r23, X
     fd8:	c2 01       	movw	r24, r4
     fda:	0e 94 1f 09 	call	0x123e	; 0x123e <_ZN7satmath20signed_saturated_addEii>
     fde:	f8 01       	movw	r30, r16
     fe0:	e0 5a       	subi	r30, 0xA0	; 160
     fe2:	ff 4f       	sbci	r31, 0xFF	; 255
     fe4:	80 83       	st	Z, r24
     fe6:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     fe8:	f6 01       	movw	r30, r12
     fea:	80 83       	st	Z, r24
     fec:	91 83       	std	Z+1, r25	; 0x01
		
		// Restrict to max/min
		if( output_correct > _max )
     fee:	a9 85       	ldd	r26, Y+9	; 0x09
     ff0:	ba 85       	ldd	r27, Y+10	; 0x0a
     ff2:	2d 91       	ld	r18, X+
     ff4:	3c 91       	ld	r19, X
     ff6:	28 17       	cp	r18, r24
     ff8:	39 07       	cpc	r19, r25
     ffa:	1c f4       	brge	.+6      	; 0x1002 <_ZN5Motor3runEv+0x5d0>
		{
		output_correct = _max;
     ffc:	20 83       	st	Z, r18
     ffe:	31 83       	std	Z+1, r19	; 0x01
    1000:	0a c0       	rjmp	.+20     	; 0x1016 <_ZN5Motor3runEv+0x5e4>
		}
		else if( output_correct < _min )
    1002:	ed 85       	ldd	r30, Y+13	; 0x0d
    1004:	fe 85       	ldd	r31, Y+14	; 0x0e
    1006:	20 81       	ld	r18, Z
    1008:	31 81       	ldd	r19, Z+1	; 0x01
    100a:	82 17       	cp	r24, r18
    100c:	93 07       	cpc	r25, r19
    100e:	1c f4       	brge	.+6      	; 0x1016 <_ZN5Motor3runEv+0x5e4>
		{
		output_correct = _min;
    1010:	d6 01       	movw	r26, r12
    1012:	2d 93       	st	X+, r18
    1014:	3c 93       	st	X, r19
		}

		// Save error to previous error
		_pre_error = error;
    1016:	f8 01       	movw	r30, r16
    1018:	e2 5b       	subi	r30, 0xB2	; 178
    101a:	ff 4f       	sbci	r31, 0xFF	; 255
    101c:	e0 82       	st	Z, r14
    101e:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
    1020:	f6 01       	movw	r30, r12
    1022:	20 81       	ld	r18, Z
    1024:	31 81       	ldd	r19, Z+1	; 0x01
    1026:	82 1b       	sub	r24, r18
    1028:	93 0b       	sbc	r25, r19
    102a:	f8 01       	movw	r30, r16
    102c:	ee 59       	subi	r30, 0x9E	; 158
    102e:	ff 4f       	sbci	r31, 0xFF	; 255
    1030:	80 83       	st	Z, r24
    1032:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
    1034:	af 81       	ldd	r26, Y+7	; 0x07
    1036:	b8 85       	ldd	r27, Y+8	; 0x08
    1038:	4d 91       	ld	r20, X+
    103a:	5c 91       	ld	r21, X
    103c:	84 9f       	mul	r24, r20
    103e:	90 01       	movw	r18, r0
    1040:	85 9f       	mul	r24, r21
    1042:	30 0d       	add	r19, r0
    1044:	94 9f       	mul	r25, r20
    1046:	30 0d       	add	r19, r0
    1048:	11 24       	eor	r1, r1
    104a:	33 23       	and	r19, r19
    104c:	14 f4       	brge	.+4      	; 0x1052 <_ZN5Motor3runEv+0x620>
    104e:	21 50       	subi	r18, 0x01	; 1
    1050:	3f 4f       	sbci	r19, 0xFF	; 255
    1052:	83 2f       	mov	r24, r19
    1054:	88 0f       	add	r24, r24
    1056:	88 0b       	sbc	r24, r24
    1058:	f4 01       	movw	r30, r8
    105a:	30 83       	st	Z, r19
    105c:	81 83       	std	Z+1, r24	; 0x01
		
		
			if(runs%150 == 0){
    105e:	d8 01       	movw	r26, r16
    1060:	1e 96       	adiw	r26, 0x0e	; 14
    1062:	6d 91       	ld	r22, X+
    1064:	7d 91       	ld	r23, X+
    1066:	8d 91       	ld	r24, X+
    1068:	9c 91       	ld	r25, X
    106a:	51 97       	sbiw	r26, 0x11	; 17
    106c:	26 e9       	ldi	r18, 0x96	; 150
    106e:	30 e0       	ldi	r19, 0x00	; 0
    1070:	40 e0       	ldi	r20, 0x00	; 0
    1072:	50 e0       	ldi	r21, 0x00	; 0
    1074:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__udivmodsi4>
    1078:	67 2b       	or	r22, r23
    107a:	68 2b       	or	r22, r24
    107c:	69 2b       	or	r22, r25
    107e:	81 f4       	brne	.+32     	; 0x10a0 <_ZN5Motor3runEv+0x66e>
				//*p_serial << thPendulum.get() << endl;
				//*p_serial << angle_error << endl;
				//*p_serial << "right: " << rightLimitSwitch.get() << endl;
				//*p_serial << "left: " << leftLimitSwitch.get() << endl;
				//*p_serial << "linear pos: " << linear_position.get() << endl;
				*p_serial << "linear set: " << position_set << endl;
    1080:	f8 01       	movw	r30, r16
    1082:	e6 80       	ldd	r14, Z+6	; 0x06
    1084:	f7 80       	ldd	r15, Z+7	; 0x07
    1086:	6a e2       	ldi	r22, 0x2A	; 42
    1088:	70 e2       	ldi	r23, 0x20	; 32
    108a:	c7 01       	movw	r24, r14
    108c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1090:	6f 85       	ldd	r22, Y+15	; 0x0f
    1092:	78 89       	ldd	r23, Y+16	; 0x10
    1094:	c7 01       	movw	r24, r14
    1096:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <_ZN8emstreamlsEi>
    109a:	66 e0       	ldi	r22, 0x06	; 6
    109c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10a0:	0f b6       	in	r0, 0x3f	; 63
    10a2:	f8 94       	cli
    10a4:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10a6:	0f 90       	pop	r0
    10a8:	0f be       	out	0x3f, r0	; 63
				//*p_serial << "go flag " << go.get() << endl;
				//*p_serial << "stop flag" << stop.get() << endl;
				//*p_serial << "reset flag " << reset.get() << endl;
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get() || stop.get())		// If limit switch or If emergency stop button was hit
    10aa:	80 91 59 31 	lds	r24, 0x3159	; 0x803159 <leftLimitSwitch>
    10ae:	81 11       	cpse	r24, r1
    10b0:	12 c0       	rjmp	.+36     	; 0x10d6 <_ZN5Motor3runEv+0x6a4>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	f8 94       	cli
    10b6:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10b8:	0f 90       	pop	r0
    10ba:	0f be       	out	0x3f, r0	; 63
    10bc:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rightLimitSwitch>
    10c0:	81 11       	cpse	r24, r1
    10c2:	09 c0       	rjmp	.+18     	; 0x10d6 <_ZN5Motor3runEv+0x6a4>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10c4:	0f b6       	in	r0, 0x3f	; 63
    10c6:	f8 94       	cli
    10c8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10ca:	0f 90       	pop	r0
    10cc:	0f be       	out	0x3f, r0	; 63
    10ce:	80 91 53 31 	lds	r24, 0x3153	; 0x803153 <stop>
    10d2:	88 23       	and	r24, r24
    10d4:	99 f0       	breq	.+38     	; 0x10fc <_ZN5Motor3runEv+0x6ca>
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
    10d6:	d5 01       	movw	r26, r10
    10d8:	1d 92       	st	X+, r1
    10da:	1d 92       	st	X+, r1
    10dc:	1d 92       	st	X+, r1
    10de:	1c 92       	st	X, r1
    10e0:	13 97       	sbiw	r26, 0x03	; 3
			output_correct = 0;
    10e2:	f6 01       	movw	r30, r12
    10e4:	10 82       	st	Z, r1
    10e6:	11 82       	std	Z+1, r1	; 0x01
			
			if (state == 4 || state == 3)
    10e8:	d8 01       	movw	r26, r16
    10ea:	1c 96       	adiw	r26, 0x0c	; 12
    10ec:	8c 91       	ld	r24, X
    10ee:	83 50       	subi	r24, 0x03	; 3
    10f0:	82 30       	cpi	r24, 0x02	; 2
    10f2:	20 f4       	brcc	.+8      	; 0x10fc <_ZN5Motor3runEv+0x6ca>
			{
				transition_to(100);
    10f4:	64 e6       	ldi	r22, 0x64	; 100
    10f6:	c8 01       	movw	r24, r16
    10f8:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
    10fc:	f8 01       	movw	r30, r16
    10fe:	10 a6       	std	Z+40, r1	; 0x28
    1100:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
    1102:	82 a1       	ldd	r24, Z+34	; 0x22
    1104:	93 a1       	ldd	r25, Z+35	; 0x23
    1106:	60 e0       	ldi	r22, 0x00	; 0
    1108:	70 e0       	ldi	r23, 0x00	; 0
    110a:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <__divmodhi4>
    110e:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
    1110:	07 2e       	mov	r0, r23
    1112:	00 0c       	add	r0, r0
    1114:	88 0b       	sbc	r24, r24
    1116:	99 0b       	sbc	r25, r25
    1118:	0e 94 e6 21 	call	0x43cc	; 0x43cc <__floatsisf>
    111c:	2b 01       	movw	r4, r22
    111e:	3c 01       	movw	r6, r24
    1120:	23 e3       	ldi	r18, 0x33	; 51
    1122:	33 e3       	ldi	r19, 0x33	; 51
    1124:	4b e8       	ldi	r20, 0x8B	; 139
    1126:	51 e4       	ldi	r21, 0x41	; 65
    1128:	0e 94 45 22 	call	0x448a	; 0x448a <__gesf2>
    112c:	18 16       	cp	r1, r24
    112e:	44 f4       	brge	.+16     	; 0x1140 <_ZN5Motor3runEv+0x70e>
			Im_set = 17.4;
    1130:	81 e1       	ldi	r24, 0x11	; 17
    1132:	90 e0       	ldi	r25, 0x00	; 0
    1134:	d8 01       	movw	r26, r16
    1136:	94 96       	adiw	r26, 0x24	; 36
    1138:	8d 93       	st	X+, r24
    113a:	9c 93       	st	X, r25
    113c:	95 97       	sbiw	r26, 0x25	; 37
    113e:	15 c0       	rjmp	.+42     	; 0x116a <_ZN5Motor3runEv+0x738>
		} else if(Im_set < -17.4) {
    1140:	23 e3       	ldi	r18, 0x33	; 51
    1142:	33 e3       	ldi	r19, 0x33	; 51
    1144:	4b e8       	ldi	r20, 0x8B	; 139
    1146:	51 ec       	ldi	r21, 0xC1	; 193
    1148:	c3 01       	movw	r24, r6
    114a:	b2 01       	movw	r22, r4
    114c:	0e 94 df 21 	call	0x43be	; 0x43be <__cmpsf2>
    1150:	88 23       	and	r24, r24
    1152:	24 f0       	brlt	.+8      	; 0x115c <_ZN5Motor3runEv+0x72a>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
    1154:	f8 01       	movw	r30, r16
    1156:	e4 a2       	std	Z+36, r14	; 0x24
    1158:	f5 a2       	std	Z+37, r15	; 0x25
    115a:	07 c0       	rjmp	.+14     	; 0x116a <_ZN5Motor3runEv+0x738>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
    115c:	8f ee       	ldi	r24, 0xEF	; 239
    115e:	9f ef       	ldi	r25, 0xFF	; 255
    1160:	d8 01       	movw	r26, r16
    1162:	94 96       	adiw	r26, 0x24	; 36
    1164:	8d 93       	st	X+, r24
    1166:	9c 93       	st	X, r25
    1168:	95 97       	sbiw	r26, 0x25	; 37
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
    116a:	f8 01       	movw	r30, r16
    116c:	16 aa       	std	Z+54, r1	; 0x36
    116e:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
    1170:	12 aa       	std	Z+50, r1	; 0x32
    1172:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
    1174:	14 aa       	std	Z+52, r1	; 0x34
    1176:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
    1178:	80 a9       	ldd	r24, Z+48	; 0x30
    117a:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
    117c:	89 31       	cpi	r24, 0x19	; 25
    117e:	91 05       	cpc	r25, r1
    1180:	2c f0       	brlt	.+10     	; 0x118c <_ZN5Motor3runEv+0x75a>
			V_m = 24;
    1182:	88 e1       	ldi	r24, 0x18	; 24
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	80 af       	std	Z+56, r24	; 0x38
    1188:	91 af       	std	Z+57, r25	; 0x39
    118a:	0f c0       	rjmp	.+30     	; 0x11aa <_ZN5Motor3runEv+0x778>
		} else if(V_m < -24) {
    118c:	88 3e       	cpi	r24, 0xE8	; 232
    118e:	ff ef       	ldi	r31, 0xFF	; 255
    1190:	9f 07       	cpc	r25, r31
    1192:	34 f0       	brlt	.+12     	; 0x11a0 <_ZN5Motor3runEv+0x76e>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
    1194:	d8 01       	movw	r26, r16
    1196:	d8 96       	adiw	r26, 0x38	; 56
    1198:	8d 93       	st	X+, r24
    119a:	9c 93       	st	X, r25
    119c:	d9 97       	sbiw	r26, 0x39	; 57
    119e:	05 c0       	rjmp	.+10     	; 0x11aa <_ZN5Motor3runEv+0x778>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
    11a0:	88 ee       	ldi	r24, 0xE8	; 232
    11a2:	9f ef       	ldi	r25, 0xFF	; 255
    11a4:	f8 01       	movw	r30, r16
    11a6:	80 af       	std	Z+56, r24	; 0x38
    11a8:	91 af       	std	Z+57, r25	; 0x39
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
    11aa:	d6 01       	movw	r26, r12
    11ac:	8d 91       	ld	r24, X+
    11ae:	9c 91       	ld	r25, X
    11b0:	99 23       	and	r25, r25
    11b2:	3c f0       	brlt	.+14     	; 0x11c2 <_ZN5Motor3runEv+0x790>
		{
			TCC0.CCA = output_correct;
    11b4:	e0 e0       	ldi	r30, 0x00	; 0
    11b6:	f8 e0       	ldi	r31, 0x08	; 8
    11b8:	80 a7       	std	Z+40, r24	; 0x28
    11ba:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
    11bc:	12 a6       	std	Z+42, r1	; 0x2a
    11be:	13 a6       	std	Z+43, r1	; 0x2b
    11c0:	0c c0       	rjmp	.+24     	; 0x11da <_ZN5Motor3runEv+0x7a8>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
    11c2:	e0 e0       	ldi	r30, 0x00	; 0
    11c4:	f8 e0       	ldi	r31, 0x08	; 8
    11c6:	10 a6       	std	Z+40, r1	; 0x28
    11c8:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
    11ca:	d6 01       	movw	r26, r12
    11cc:	8d 91       	ld	r24, X+
    11ce:	9c 91       	ld	r25, X
    11d0:	91 95       	neg	r25
    11d2:	81 95       	neg	r24
    11d4:	91 09       	sbc	r25, r1
    11d6:	82 a7       	std	Z+42, r24	; 0x2a
    11d8:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
    11da:	eb 85       	ldd	r30, Y+11	; 0x0b
    11dc:	fc 85       	ldd	r31, Y+12	; 0x0c
    11de:	20 81       	ld	r18, Z
    11e0:	31 81       	ldd	r19, Z+1	; 0x01
    11e2:	42 81       	ldd	r20, Z+2	; 0x02
    11e4:	53 81       	ldd	r21, Z+3	; 0x03
    11e6:	a8 ee       	ldi	r26, 0xE8	; 232
    11e8:	b3 e0       	ldi	r27, 0x03	; 3
    11ea:	0e 94 d6 22 	call	0x45ac	; 0x45ac <__muluhisi3>
    11ee:	68 3e       	cpi	r22, 0xE8	; 232
    11f0:	f3 e0       	ldi	r31, 0x03	; 3
    11f2:	7f 07       	cpc	r23, r31
    11f4:	81 05       	cpc	r24, r1
    11f6:	91 05       	cpc	r25, r1
    11f8:	48 f0       	brcs	.+18     	; 0x120c <_ZN5Motor3runEv+0x7da>
    11fa:	28 ee       	ldi	r18, 0xE8	; 232
    11fc:	33 e0       	ldi	r19, 0x03	; 3
    11fe:	40 e0       	ldi	r20, 0x00	; 0
    1200:	50 e0       	ldi	r21, 0x00	; 0
    1202:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__udivmodsi4>
    1206:	ba 01       	movw	r22, r20
    1208:	a9 01       	movw	r20, r18
    120a:	04 c0       	rjmp	.+8      	; 0x1214 <_ZN5Motor3runEv+0x7e2>
    120c:	41 e0       	ldi	r20, 0x01	; 1
    120e:	50 e0       	ldi	r21, 0x00	; 0
    1210:	60 e0       	ldi	r22, 0x00	; 0
    1212:	70 e0       	ldi	r23, 0x00	; 0
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
    1214:	ce 01       	movw	r24, r28
    1216:	01 96       	adiw	r24, 0x01	; 1
    1218:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <vTaskDelayUntil>
    121c:	7d cc       	rjmp	.-1798   	; 0xb18 <_ZN5Motor3runEv+0xe6>

0000121e <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
    121e:	0f 93       	push	r16
    1220:	1f 93       	push	r17
    1222:	cf 93       	push	r28
    1224:	df 93       	push	r29
    1226:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    1228:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <_ZN8frt_taskC1EPKchjP8emstream>
    122c:	8b e3       	ldi	r24, 0x3B	; 59
    122e:	90 e2       	ldi	r25, 0x20	; 32
    1230:	88 83       	st	Y, r24
    1232:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
    1234:	df 91       	pop	r29
    1236:	cf 91       	pop	r28
    1238:	1f 91       	pop	r17
    123a:	0f 91       	pop	r16
    123c:	08 95       	ret

0000123e <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
    123e:	9c 01       	movw	r18, r24
    1240:	93 2f       	mov	r25, r19
    1242:	99 1f       	adc	r25, r25
    1244:	99 27       	eor	r25, r25
    1246:	99 1f       	adc	r25, r25
    1248:	89 2f       	mov	r24, r25
    124a:	90 e0       	ldi	r25, 0x00	; 0
    124c:	81 50       	subi	r24, 0x01	; 1
    124e:	90 48       	sbci	r25, 0x80	; 128
    1250:	43 2f       	mov	r20, r19
    1252:	40 95       	com	r20
    1254:	44 1f       	adc	r20, r20
    1256:	44 27       	eor	r20, r20
    1258:	44 1f       	adc	r20, r20
    125a:	fc 01       	movw	r30, r24
    125c:	e2 1b       	sub	r30, r18
    125e:	f3 0b       	sbc	r31, r19
    1260:	51 e0       	ldi	r21, 0x01	; 1
    1262:	e6 17       	cp	r30, r22
    1264:	f7 07       	cpc	r31, r23
    1266:	0c f0       	brlt	.+2      	; 0x126a <_ZN7satmath20signed_saturated_addEii+0x2c>
    1268:	50 e0       	ldi	r21, 0x00	; 0
    126a:	45 17       	cp	r20, r21
    126c:	19 f0       	breq	.+6      	; 0x1274 <_ZN7satmath20signed_saturated_addEii+0x36>
    126e:	c9 01       	movw	r24, r18
    1270:	86 0f       	add	r24, r22
    1272:	97 1f       	adc	r25, r23
    1274:	08 95       	ret

00001276 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    1276:	81 15       	cp	r24, r1
    1278:	20 e8       	ldi	r18, 0x80	; 128
    127a:	92 07       	cpc	r25, r18
    127c:	21 f4       	brne	.+8      	; 0x1286 <_ZN7satmath20signed_saturated_mulEii+0x10>
    127e:	61 15       	cp	r22, r1
    1280:	20 e8       	ldi	r18, 0x80	; 128
    1282:	72 07       	cpc	r23, r18
    1284:	29 f0       	breq	.+10     	; 0x1290 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
    1286:	9c 01       	movw	r18, r24
    1288:	db 01       	movw	r26, r22
    128a:	0e 94 b8 22 	call	0x4570	; 0x4570 <__mulhisi3>
    128e:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    1290:	6f ef       	ldi	r22, 0xFF	; 255
    1292:	7f ef       	ldi	r23, 0xFF	; 255
    1294:	8f ef       	ldi	r24, 0xFF	; 255
    1296:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
    1298:	08 95       	ret

0000129a <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    129a:	0f 93       	push	r16
    129c:	1f 93       	push	r17
    129e:	cf 93       	push	r28
    12a0:	df 93       	push	r29
    12a2:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    12a4:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <_ZN8frt_taskC1EPKchjP8emstream>
    12a8:	83 e4       	ldi	r24, 0x43	; 67
    12aa:	90 e2       	ldi	r25, 0x20	; 32
    12ac:	88 83       	st	Y, r24
    12ae:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	1f 91       	pop	r17
    12b6:	0f 91       	pop	r16
    12b8:	08 95       	ret

000012ba <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    12ba:	0f 93       	push	r16
    12bc:	1f 93       	push	r17
    12be:	cf 93       	push	r28
    12c0:	df 93       	push	r29
    12c2:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    12c4:	6a e0       	ldi	r22, 0x0A	; 10
    12c6:	8e 81       	ldd	r24, Y+6	; 0x06
    12c8:	9f 81       	ldd	r25, Y+7	; 0x07
    12ca:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    12ce:	8c 01       	movw	r16, r24
    12d0:	63 e5       	ldi	r22, 0x53	; 83
    12d2:	75 e0       	ldi	r23, 0x05	; 5
    12d4:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    12d8:	6a e0       	ldi	r22, 0x0A	; 10
    12da:	c8 01       	movw	r24, r16
    12dc:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    12e0:	8c 01       	movw	r16, r24
    12e2:	6d e4       	ldi	r22, 0x4D	; 77
    12e4:	75 e0       	ldi	r23, 0x05	; 5
    12e6:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    12ea:	67 e0       	ldi	r22, 0x07	; 7
    12ec:	c8 01       	movw	r24, r16
    12ee:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    12f2:	6a e0       	ldi	r22, 0x0A	; 10
    12f4:	8e 81       	ldd	r24, Y+6	; 0x06
    12f6:	9f 81       	ldd	r25, Y+7	; 0x07
    12f8:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    12fc:	8c 01       	movw	r16, r24
    12fe:	6e e2       	ldi	r22, 0x2E	; 46
    1300:	75 e0       	ldi	r23, 0x05	; 5
    1302:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1306:	6a e0       	ldi	r22, 0x0A	; 10
    1308:	c8 01       	movw	r24, r16
    130a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    130e:	8c 01       	movw	r16, r24
    1310:	68 e2       	ldi	r22, 0x28	; 40
    1312:	75 e0       	ldi	r23, 0x05	; 5
    1314:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1318:	66 e0       	ldi	r22, 0x06	; 6
    131a:	c8 01       	movw	r24, r16
    131c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1320:	6a e0       	ldi	r22, 0x0A	; 10
    1322:	8e 81       	ldd	r24, Y+6	; 0x06
    1324:	9f 81       	ldd	r25, Y+7	; 0x07
    1326:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    132a:	8c 01       	movw	r16, r24
    132c:	61 e1       	ldi	r22, 0x11	; 17
    132e:	75 e0       	ldi	r23, 0x05	; 5
    1330:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1334:	66 e0       	ldi	r22, 0x06	; 6
    1336:	c8 01       	movw	r24, r16
    1338:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    133c:	6a e0       	ldi	r22, 0x0A	; 10
    133e:	8e 81       	ldd	r24, Y+6	; 0x06
    1340:	9f 81       	ldd	r25, Y+7	; 0x07
    1342:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1346:	8c 01       	movw	r16, r24
    1348:	65 ef       	ldi	r22, 0xF5	; 245
    134a:	74 e0       	ldi	r23, 0x04	; 4
    134c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1350:	66 e0       	ldi	r22, 0x06	; 6
    1352:	c8 01       	movw	r24, r16
    1354:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1358:	6a e0       	ldi	r22, 0x0A	; 10
    135a:	8e 81       	ldd	r24, Y+6	; 0x06
    135c:	9f 81       	ldd	r25, Y+7	; 0x07
    135e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1362:	8c 01       	movw	r16, r24
    1364:	6d ed       	ldi	r22, 0xDD	; 221
    1366:	74 e0       	ldi	r23, 0x04	; 4
    1368:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    136c:	66 e0       	ldi	r22, 0x06	; 6
    136e:	c8 01       	movw	r24, r16
    1370:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1374:	6a e0       	ldi	r22, 0x0A	; 10
    1376:	8e 81       	ldd	r24, Y+6	; 0x06
    1378:	9f 81       	ldd	r25, Y+7	; 0x07
    137a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    137e:	8c 01       	movw	r16, r24
    1380:	6c eb       	ldi	r22, 0xBC	; 188
    1382:	74 e0       	ldi	r23, 0x04	; 4
    1384:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1388:	66 e0       	ldi	r22, 0x06	; 6
    138a:	c8 01       	movw	r24, r16
    138c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1390:	6a e0       	ldi	r22, 0x0A	; 10
    1392:	8e 81       	ldd	r24, Y+6	; 0x06
    1394:	9f 81       	ldd	r25, Y+7	; 0x07
    1396:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    139a:	8c 01       	movw	r16, r24
    139c:	65 e9       	ldi	r22, 0x95	; 149
    139e:	74 e0       	ldi	r23, 0x04	; 4
    13a0:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    13a4:	66 e0       	ldi	r22, 0x06	; 6
    13a6:	c8 01       	movw	r24, r16
    13a8:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    13ac:	6a e0       	ldi	r22, 0x0A	; 10
    13ae:	8e 81       	ldd	r24, Y+6	; 0x06
    13b0:	9f 81       	ldd	r25, Y+7	; 0x07
    13b2:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    13b6:	8c 01       	movw	r16, r24
    13b8:	67 e7       	ldi	r22, 0x77	; 119
    13ba:	74 e0       	ldi	r23, 0x04	; 4
    13bc:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    13c0:	66 e0       	ldi	r22, 0x06	; 6
    13c2:	c8 01       	movw	r24, r16
    13c4:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    13c8:	6a e0       	ldi	r22, 0x0A	; 10
    13ca:	8e 81       	ldd	r24, Y+6	; 0x06
    13cc:	9f 81       	ldd	r25, Y+7	; 0x07
    13ce:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    13d2:	8c 01       	movw	r16, r24
    13d4:	6c e5       	ldi	r22, 0x5C	; 92
    13d6:	74 e0       	ldi	r23, 0x04	; 4
    13d8:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    13dc:	66 e0       	ldi	r22, 0x06	; 6
    13de:	c8 01       	movw	r24, r16
    13e0:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    13e4:	6a e0       	ldi	r22, 0x0A	; 10
    13e6:	8e 81       	ldd	r24, Y+6	; 0x06
    13e8:	9f 81       	ldd	r25, Y+7	; 0x07
    13ea:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    13ee:	8c 01       	movw	r16, r24
    13f0:	6d e4       	ldi	r22, 0x4D	; 77
    13f2:	74 e0       	ldi	r23, 0x04	; 4
    13f4:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    13f8:	66 e0       	ldi	r22, 0x06	; 6
    13fa:	c8 01       	movw	r24, r16
    13fc:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    b:   Begin Calibration of Inverted Pendulum?") << endl;
    1400:	6a e0       	ldi	r22, 0x0A	; 10
    1402:	8e 81       	ldd	r24, Y+6	; 0x06
    1404:	9f 81       	ldd	r25, Y+7	; 0x07
    1406:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    140a:	8c 01       	movw	r16, r24
    140c:	6c e1       	ldi	r22, 0x1C	; 28
    140e:	74 e0       	ldi	r23, 0x04	; 4
    1410:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1414:	66 e0       	ldi	r22, 0x06	; 6
    1416:	c8 01       	movw	r24, r16
    1418:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    g:   Swing Pendulum Upright, then Go.") << endl;
    141c:	6a e0       	ldi	r22, 0x0A	; 10
    141e:	8e 81       	ldd	r24, Y+6	; 0x06
    1420:	9f 81       	ldd	r25, Y+7	; 0x07
    1422:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1426:	8c 01       	movw	r16, r24
    1428:	62 ef       	ldi	r22, 0xF2	; 242
    142a:	73 e0       	ldi	r23, 0x03	; 3
    142c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1430:	66 e0       	ldi	r22, 0x06	; 6
    1432:	c8 01       	movw	r24, r16
    1434:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    d:   Emergency Stop") << endl;
    1438:	6a e0       	ldi	r22, 0x0A	; 10
    143a:	8e 81       	ldd	r24, Y+6	; 0x06
    143c:	9f 81       	ldd	r25, Y+7	; 0x07
    143e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1442:	8c 01       	movw	r16, r24
    1444:	6a ed       	ldi	r22, 0xDA	; 218
    1446:	73 e0       	ldi	r23, 0x03	; 3
    1448:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    144c:	66 e0       	ldi	r22, 0x06	; 6
    144e:	c8 01       	movw	r24, r16
    1450:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    r:   Reset to Idle") << endl;
    1454:	6a e0       	ldi	r22, 0x0A	; 10
    1456:	8e 81       	ldd	r24, Y+6	; 0x06
    1458:	9f 81       	ldd	r25, Y+7	; 0x07
    145a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    145e:	ec 01       	movw	r28, r24
    1460:	63 ec       	ldi	r22, 0xC3	; 195
    1462:	73 e0       	ldi	r23, 0x03	; 3
    1464:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1468:	66 e0       	ldi	r22, 0x06	; 6
    146a:	ce 01       	movw	r24, r28
    146c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
}
    1470:	df 91       	pop	r29
    1472:	cf 91       	pop	r28
    1474:	1f 91       	pop	r17
    1476:	0f 91       	pop	r16
    1478:	08 95       	ret

0000147a <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    147a:	af 92       	push	r10
    147c:	bf 92       	push	r11
    147e:	cf 92       	push	r12
    1480:	df 92       	push	r13
    1482:	ef 92       	push	r14
    1484:	ff 92       	push	r15
    1486:	0f 93       	push	r16
    1488:	1f 93       	push	r17
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	00 d0       	rcall	.+0      	; 0x1490 <_ZN9task_user11show_statusEv+0x16>
    1490:	00 d0       	rcall	.+0      	; 0x1492 <_ZN9task_user11show_statusEv+0x18>
    1492:	cd b7       	in	r28, 0x3d	; 61
    1494:	de b7       	in	r29, 0x3e	; 62
    1496:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1498:	19 82       	std	Y+1, r1	; 0x01
    149a:	1a 82       	std	Y+2, r1	; 0x02
    149c:	1b 82       	std	Y+3, r1	; 0x03
    149e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    14a0:	1d 82       	std	Y+5, r1	; 0x05
    14a2:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    14a4:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <xPortGetFreeHeapSize>
    14a8:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    14aa:	ce 01       	movw	r24, r28
    14ac:	01 96       	adiw	r24, 0x01	; 1
    14ae:	0e 94 54 1b 	call	0x36a8	; 0x36a8 <_ZN10time_stamp10set_to_nowEv>
    14b2:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    14b4:	66 e0       	ldi	r22, 0x06	; 6
    14b6:	f8 01       	movw	r30, r16
    14b8:	86 81       	ldd	r24, Z+6	; 0x06
    14ba:	97 81       	ldd	r25, Z+7	; 0x07
    14bc:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    14c0:	6a e0       	ldi	r22, 0x0A	; 10
    14c2:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    14c6:	7c 01       	movw	r14, r24
    14c8:	64 ea       	ldi	r22, 0xA4	; 164
    14ca:	73 e0       	ldi	r23, 0x03	; 3
    14cc:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    14d0:	6a e0       	ldi	r22, 0x0A	; 10
    14d2:	c7 01       	movw	r24, r14
    14d4:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    14d8:	7c 01       	movw	r14, r24
    14da:	68 e9       	ldi	r22, 0x98	; 152
    14dc:	73 e0       	ldi	r23, 0x03	; 3
    14de:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    14e2:	66 e0       	ldi	r22, 0x06	; 6
    14e4:	c7 01       	movw	r24, r14
    14e6:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    14ea:	6a e0       	ldi	r22, 0x0A	; 10
    14ec:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    14f0:	7c 01       	movw	r14, r24
    14f2:	61 e9       	ldi	r22, 0x91	; 145
    14f4:	73 e0       	ldi	r23, 0x03	; 3
    14f6:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    14fa:	b5 01       	movw	r22, r10
    14fc:	c7 01       	movw	r24, r14
    14fe:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1502:	6a e0       	ldi	r22, 0x0A	; 10
    1504:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1508:	7c 01       	movw	r14, r24
    150a:	63 e8       	ldi	r22, 0x83	; 131
    150c:	73 e0       	ldi	r23, 0x03	; 3
    150e:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1512:	b6 01       	movw	r22, r12
    1514:	c7 01       	movw	r24, r14
    1516:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <_ZN8emstreamlsEj>
    151a:	6a e0       	ldi	r22, 0x0A	; 10
    151c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1520:	7c 01       	movw	r14, r24
    1522:	61 e8       	ldi	r22, 0x81	; 129
    1524:	73 e0       	ldi	r23, 0x03	; 3
    1526:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    152a:	4f ef       	ldi	r20, 0xFF	; 255
    152c:	5f e0       	ldi	r21, 0x0F	; 15
    152e:	60 e0       	ldi	r22, 0x00	; 0
    1530:	70 e0       	ldi	r23, 0x00	; 0
    1532:	c7 01       	movw	r24, r14
    1534:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1538:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    153c:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1540:	6a e0       	ldi	r22, 0x0A	; 10
    1542:	f8 01       	movw	r30, r16
    1544:	86 81       	ldd	r24, Z+6	; 0x06
    1546:	97 81       	ldd	r25, Z+7	; 0x07
    1548:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    154c:	7c 01       	movw	r14, r24
    154e:	66 e7       	ldi	r22, 0x76	; 118
    1550:	73 e0       	ldi	r23, 0x03	; 3
    1552:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1556:	b6 01       	movw	r22, r12
    1558:	c7 01       	movw	r24, r14
    155a:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <_ZN8emstreamlsEj>
    155e:	66 e0       	ldi	r22, 0x06	; 6
    1560:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1564:	66 e0       	ldi	r22, 0x06	; 6
    1566:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    156a:	f8 01       	movw	r30, r16
    156c:	86 81       	ldd	r24, Z+6	; 0x06
    156e:	97 81       	ldd	r25, Z+7	; 0x07
    1570:	0e 94 b1 19 	call	0x3362	; 0x3362 <_Z15print_task_listP8emstream>
}
    1574:	26 96       	adiw	r28, 0x06	; 6
    1576:	cd bf       	out	0x3d, r28	; 61
    1578:	de bf       	out	0x3e, r29	; 62
    157a:	df 91       	pop	r29
    157c:	cf 91       	pop	r28
    157e:	1f 91       	pop	r17
    1580:	0f 91       	pop	r16
    1582:	ff 90       	pop	r15
    1584:	ef 90       	pop	r14
    1586:	df 90       	pop	r13
    1588:	cf 90       	pop	r12
    158a:	bf 90       	pop	r11
    158c:	af 90       	pop	r10
    158e:	08 95       	ret

00001590 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1590:	cf 93       	push	r28
    1592:	df 93       	push	r29
    1594:	00 d0       	rcall	.+0      	; 0x1596 <_ZN9task_user3runEv+0x6>
    1596:	00 d0       	rcall	.+0      	; 0x1598 <_ZN9task_user3runEv+0x8>
    1598:	cd b7       	in	r28, 0x3d	; 61
    159a:	de b7       	in	r29, 0x3e	; 62
    159c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    159e:	19 82       	std	Y+1, r1	; 0x01
    15a0:	1a 82       	std	Y+2, r1	; 0x02
    15a2:	1b 82       	std	Y+3, r1	; 0x03
    15a4:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    15a6:	1d 82       	std	Y+5, r1	; 0x05
    15a8:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;
    15aa:	6a e0       	ldi	r22, 0x0A	; 10
    15ac:	dc 01       	movw	r26, r24
    15ae:	16 96       	adiw	r26, 0x06	; 6
    15b0:	8d 91       	ld	r24, X+
    15b2:	9c 91       	ld	r25, X
    15b4:	17 97       	sbiw	r26, 0x07	; 7
    15b6:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    15ba:	7c 01       	movw	r14, r24
    15bc:	61 ef       	ldi	r22, 0xF1	; 241
    15be:	75 e0       	ldi	r23, 0x05	; 5
    15c0:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    15c4:	66 e0       	ldi	r22, 0x06	; 6
    15c6:	c7 01       	movw	r24, r14
    15c8:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    15cc:	f8 01       	movw	r30, r16
    15ce:	84 85       	ldd	r24, Z+12	; 0x0c
    15d0:	88 23       	and	r24, r24
    15d2:	21 f0       	breq	.+8      	; 0x15dc <_ZN9task_user3runEv+0x4c>
    15d4:	81 30       	cpi	r24, 0x01	; 1
    15d6:	09 f4       	brne	.+2      	; 0x15da <_ZN9task_user3runEv+0x4a>
    15d8:	5d c0       	rjmp	.+186    	; 0x1694 <_ZN9task_user3runEv+0x104>
    15da:	32 c1       	rjmp	.+612    	; 0x1840 <_ZN9task_user3runEv+0x2b0>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    15dc:	86 81       	ldd	r24, Z+6	; 0x06
    15de:	97 81       	ldd	r25, Z+7	; 0x07
    15e0:	dc 01       	movw	r26, r24
    15e2:	ed 91       	ld	r30, X+
    15e4:	fc 91       	ld	r31, X
    15e6:	04 80       	ldd	r0, Z+4	; 0x04
    15e8:	f5 81       	ldd	r31, Z+5	; 0x05
    15ea:	e0 2d       	mov	r30, r0
    15ec:	19 95       	eicall
    15ee:	88 23       	and	r24, r24
    15f0:	a9 f1       	breq	.+106    	; 0x165c <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    15f2:	f8 01       	movw	r30, r16
    15f4:	86 81       	ldd	r24, Z+6	; 0x06
    15f6:	97 81       	ldd	r25, Z+7	; 0x07
    15f8:	dc 01       	movw	r26, r24
    15fa:	ed 91       	ld	r30, X+
    15fc:	fc 91       	ld	r31, X
    15fe:	06 80       	ldd	r0, Z+6	; 0x06
    1600:	f7 81       	ldd	r31, Z+7	; 0x07
    1602:	e0 2d       	mov	r30, r0
    1604:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1606:	99 27       	eor	r25, r25
    1608:	81 30       	cpi	r24, 0x01	; 1
    160a:	91 05       	cpc	r25, r1
    160c:	f9 f0       	breq	.+62     	; 0x164c <_ZN9task_user3runEv+0xbc>
    160e:	03 97       	sbiw	r24, 0x03	; 3
    1610:	09 f0       	breq	.+2      	; 0x1614 <_ZN9task_user3runEv+0x84>
    1612:	31 c1       	rjmp	.+610    	; 0x1876 <_ZN9task_user3runEv+0x2e6>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1614:	6a e0       	ldi	r22, 0x0A	; 10
    1616:	f8 01       	movw	r30, r16
    1618:	86 81       	ldd	r24, Z+6	; 0x06
    161a:	97 81       	ldd	r25, Z+7	; 0x07
    161c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1620:	8c 01       	movw	r16, r24
    1622:	63 ee       	ldi	r22, 0xE3	; 227
    1624:	75 e0       	ldi	r23, 0x05	; 5
    1626:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    162a:	66 e0       	ldi	r22, 0x06	; 6
    162c:	c8 01       	movw	r24, r16
    162e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1632:	93 e0       	ldi	r25, 0x03	; 3
    1634:	88 ed       	ldi	r24, 0xD8	; 216
    1636:	08 b6       	in	r0, 0x38	; 56
    1638:	18 be       	out	0x38, r1	; 56
    163a:	84 bf       	out	0x34, r24	; 52
    163c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1640:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1644:	81 fd       	sbrc	r24, 1
    1646:	fc cf       	rjmp	.-8      	; 0x1640 <_ZN9task_user3runEv+0xb0>
    1648:	08 be       	out	0x38, r0	; 56
    164a:	ff cf       	rjmp	.-2      	; 0x164a <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    164c:	c8 01       	movw	r24, r16
    164e:	0e 94 5d 09 	call	0x12ba	; 0x12ba <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1652:	61 e0       	ldi	r22, 0x01	; 1
    1654:	c8 01       	movw	r24, r16
    1656:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
							break;
    165a:	0d c1       	rjmp	.+538    	; 0x1876 <_ZN9task_user3runEv+0x2e6>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    165c:	80 e6       	ldi	r24, 0x60	; 96
    165e:	91 e3       	ldi	r25, 0x31	; 49
    1660:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <_ZN14frt_text_queue14check_for_charEv>
    1664:	88 23       	and	r24, r24
    1666:	09 f4       	brne	.+2      	; 0x166a <_ZN9task_user3runEv+0xda>
    1668:	06 c1       	rjmp	.+524    	; 0x1876 <_ZN9task_user3runEv+0x2e6>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    166a:	d8 01       	movw	r26, r16
    166c:	16 96       	adiw	r26, 0x06	; 6
    166e:	ed 91       	ld	r30, X+
    1670:	fc 91       	ld	r31, X
    1672:	17 97       	sbiw	r26, 0x07	; 7
    1674:	01 90       	ld	r0, Z+
    1676:	f0 81       	ld	r31, Z
    1678:	e0 2d       	mov	r30, r0
    167a:	e2 80       	ldd	r14, Z+2	; 0x02
    167c:	f3 80       	ldd	r15, Z+3	; 0x03
    167e:	80 e6       	ldi	r24, 0x60	; 96
    1680:	91 e3       	ldi	r25, 0x31	; 49
    1682:	0e 94 42 1a 	call	0x3484	; 0x3484 <_ZN14frt_text_queue7getcharEv>
    1686:	68 2f       	mov	r22, r24
    1688:	f8 01       	movw	r30, r16
    168a:	86 81       	ldd	r24, Z+6	; 0x06
    168c:	97 81       	ldd	r25, Z+7	; 0x07
    168e:	f7 01       	movw	r30, r14
    1690:	19 95       	eicall
    1692:	f1 c0       	rjmp	.+482    	; 0x1876 <_ZN9task_user3runEv+0x2e6>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1694:	86 81       	ldd	r24, Z+6	; 0x06
    1696:	97 81       	ldd	r25, Z+7	; 0x07
    1698:	dc 01       	movw	r26, r24
    169a:	ed 91       	ld	r30, X+
    169c:	fc 91       	ld	r31, X
    169e:	04 80       	ldd	r0, Z+4	; 0x04
    16a0:	f5 81       	ldd	r31, Z+5	; 0x05
    16a2:	e0 2d       	mov	r30, r0
    16a4:	19 95       	eicall
    16a6:	88 23       	and	r24, r24
    16a8:	09 f4       	brne	.+2      	; 0x16ac <_ZN9task_user3runEv+0x11c>
    16aa:	e5 c0       	rjmp	.+458    	; 0x1876 <_ZN9task_user3runEv+0x2e6>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    16ac:	f8 01       	movw	r30, r16
    16ae:	86 81       	ldd	r24, Z+6	; 0x06
    16b0:	97 81       	ldd	r25, Z+7	; 0x07
    16b2:	dc 01       	movw	r26, r24
    16b4:	ed 91       	ld	r30, X+
    16b6:	fc 91       	ld	r31, X
    16b8:	06 80       	ldd	r0, Z+6	; 0x06
    16ba:	f7 81       	ldd	r31, Z+7	; 0x07
    16bc:	e0 2d       	mov	r30, r0
    16be:	19 95       	eicall
    16c0:	bc 01       	movw	r22, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    16c2:	fc 01       	movw	r30, r24
    16c4:	ff 27       	eor	r31, r31
    16c6:	7b 97       	sbiw	r30, 0x1b	; 27
    16c8:	ec 35       	cpi	r30, 0x5C	; 92
    16ca:	f1 05       	cpc	r31, r1
    16cc:	08 f0       	brcs	.+2      	; 0x16d0 <_ZN9task_user3runEv+0x140>
    16ce:	9c c0       	rjmp	.+312    	; 0x1808 <_ZN9task_user3runEv+0x278>
    16d0:	88 27       	eor	r24, r24
    16d2:	e2 50       	subi	r30, 0x02	; 2
    16d4:	ff 4f       	sbci	r31, 0xFF	; 255
    16d6:	8f 4f       	sbci	r24, 0xFF	; 255
    16d8:	0c 94 af 22 	jmp	0x455e	; 0x455e <__tablejump2__>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    16dc:	ce 01       	movw	r24, r28
    16de:	01 96       	adiw	r24, 0x01	; 1
    16e0:	0e 94 54 1b 	call	0x36a8	; 0x36a8 <_ZN10time_stamp10set_to_nowEv>
    16e4:	bc 01       	movw	r22, r24
    16e6:	f8 01       	movw	r30, r16
    16e8:	86 81       	ldd	r24, Z+6	; 0x06
    16ea:	97 81       	ldd	r25, Z+7	; 0x07
    16ec:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <_ZlsR8emstreamR10time_stamp>
    16f0:	66 e0       	ldi	r22, 0x06	; 6
    16f2:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
							break;
    16f6:	bf c0       	rjmp	.+382    	; 0x1876 <_ZN9task_user3runEv+0x2e6>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    16f8:	c8 01       	movw	r24, r16
    16fa:	0e 94 3d 0a 	call	0x147a	; 0x147a <_ZN9task_user11show_statusEv>
							break;
    16fe:	bb c0       	rjmp	.+374    	; 0x1876 <_ZN9task_user3runEv+0x2e6>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1700:	d8 01       	movw	r26, r16
    1702:	16 96       	adiw	r26, 0x06	; 6
    1704:	8d 91       	ld	r24, X+
    1706:	9c 91       	ld	r25, X
    1708:	17 97       	sbiw	r26, 0x07	; 7
    170a:	0e 94 b8 18 	call	0x3170	; 0x3170 <_Z17print_task_stacksP8emstream>
							break;
    170e:	b3 c0       	rjmp	.+358    	; 0x1876 <_ZN9task_user3runEv+0x2e6>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1710:	c8 01       	movw	r24, r16
    1712:	0e 94 5d 09 	call	0x12ba	; 0x12ba <_ZN9task_user18print_help_messageEv>
							break;
    1716:	af c0       	rjmp	.+350    	; 0x1876 <_ZN9task_user3runEv+0x2e6>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1718:	6a e0       	ldi	r22, 0x0A	; 10
    171a:	f8 01       	movw	r30, r16
    171c:	86 81       	ldd	r24, Z+6	; 0x06
    171e:	97 81       	ldd	r25, Z+7	; 0x07
    1720:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1724:	7c 01       	movw	r14, r24
    1726:	61 ed       	ldi	r22, 0xD1	; 209
    1728:	75 e0       	ldi	r23, 0x05	; 5
    172a:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    172e:	66 e0       	ldi	r22, 0x06	; 6
    1730:	c7 01       	movw	r24, r14
    1732:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0); 
    1736:	60 e0       	ldi	r22, 0x00	; 0
    1738:	c8 01       	movw	r24, r16
    173a:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN8frt_task13transition_toEh>
							break;
    173e:	9b c0       	rjmp	.+310    	; 0x1876 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1740:	0f b6       	in	r0, 0x3f	; 63
    1742:	f8 94       	cli
    1744:	0f 92       	push	r0
			the_data = new_data;
    1746:	81 e0       	ldi	r24, 0x01	; 1
    1748:	80 93 55 31 	sts	0x3155, r24	; 0x803155 <begin>
			portEXIT_CRITICAL ();
    174c:	0f 90       	pop	r0
    174e:	0f be       	out	0x3f, r0	; 63
							
						case ('b'):
							begin.put(true);
							*p_serial << PMS ("Begin Homing") << endl;
    1750:	6a e0       	ldi	r22, 0x0A	; 10
    1752:	d8 01       	movw	r26, r16
    1754:	16 96       	adiw	r26, 0x06	; 6
    1756:	8d 91       	ld	r24, X+
    1758:	9c 91       	ld	r25, X
    175a:	17 97       	sbiw	r26, 0x07	; 7
    175c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1760:	7c 01       	movw	r14, r24
    1762:	64 ec       	ldi	r22, 0xC4	; 196
    1764:	75 e0       	ldi	r23, 0x05	; 5
    1766:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    176a:	66 e0       	ldi	r22, 0x06	; 6
    176c:	c7 01       	movw	r24, r14
    176e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1772:	81 c0       	rjmp	.+258    	; 0x1876 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	0f 92       	push	r0
			the_data = new_data;
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <go>
			portEXIT_CRITICAL ();
    1780:	0f 90       	pop	r0
    1782:	0f be       	out	0x3f, r0	; 63
						
						case ('g'):
							go.put(true);
							*p_serial << PMS ("Commence Balance") << endl;
    1784:	6a e0       	ldi	r22, 0x0A	; 10
    1786:	f8 01       	movw	r30, r16
    1788:	86 81       	ldd	r24, Z+6	; 0x06
    178a:	97 81       	ldd	r25, Z+7	; 0x07
    178c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    1790:	7c 01       	movw	r14, r24
    1792:	63 eb       	ldi	r22, 0xB3	; 179
    1794:	75 e0       	ldi	r23, 0x05	; 5
    1796:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    179a:	66 e0       	ldi	r22, 0x06	; 6
    179c:	c7 01       	movw	r24, r14
    179e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
							break;
    17a2:	69 c0       	rjmp	.+210    	; 0x1876 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    17a4:	0f b6       	in	r0, 0x3f	; 63
    17a6:	f8 94       	cli
    17a8:	0f 92       	push	r0
			the_data = new_data;
    17aa:	81 e0       	ldi	r24, 0x01	; 1
    17ac:	80 93 53 31 	sts	0x3153, r24	; 0x803153 <stop>
			portEXIT_CRITICAL ();
    17b0:	0f 90       	pop	r0
    17b2:	0f be       	out	0x3f, r0	; 63
						
						case('d'):
							stop.put(true);
							*p_serial << PMS ("EMERGENCY STOP") << endl;
    17b4:	6a e0       	ldi	r22, 0x0A	; 10
    17b6:	d8 01       	movw	r26, r16
    17b8:	16 96       	adiw	r26, 0x06	; 6
    17ba:	8d 91       	ld	r24, X+
    17bc:	9c 91       	ld	r25, X
    17be:	17 97       	sbiw	r26, 0x07	; 7
    17c0:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    17c4:	7c 01       	movw	r14, r24
    17c6:	64 ea       	ldi	r22, 0xA4	; 164
    17c8:	75 e0       	ldi	r23, 0x05	; 5
    17ca:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    17ce:	66 e0       	ldi	r22, 0x06	; 6
    17d0:	c7 01       	movw	r24, r14
    17d2:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
							break;
    17d6:	4f c0       	rjmp	.+158    	; 0x1876 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    17d8:	0f b6       	in	r0, 0x3f	; 63
    17da:	f8 94       	cli
    17dc:	0f 92       	push	r0
			the_data = new_data;
    17de:	81 e0       	ldi	r24, 0x01	; 1
    17e0:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <reset>
			portEXIT_CRITICAL ();
    17e4:	0f 90       	pop	r0
    17e6:	0f be       	out	0x3f, r0	; 63
						
						case('r'):
							reset.put(true);
							*p_serial << PMS ("Reset, try Homing again by pressing 'b'") << endl;
    17e8:	6a e0       	ldi	r22, 0x0A	; 10
    17ea:	f8 01       	movw	r30, r16
    17ec:	86 81       	ldd	r24, Z+6	; 0x06
    17ee:	97 81       	ldd	r25, Z+7	; 0x07
    17f0:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    17f4:	7c 01       	movw	r14, r24
    17f6:	6c e7       	ldi	r22, 0x7C	; 124
    17f8:	75 e0       	ldi	r23, 0x05	; 5
    17fa:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    17fe:	66 e0       	ldi	r22, 0x06	; 6
    1800:	c7 01       	movw	r24, r14
    1802:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1806:	37 c0       	rjmp	.+110    	; 0x1876 <_ZN9task_user3runEv+0x2e6>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1808:	d8 01       	movw	r26, r16
    180a:	16 96       	adiw	r26, 0x06	; 6
    180c:	8d 91       	ld	r24, X+
    180e:	9c 91       	ld	r25, X
    1810:	17 97       	sbiw	r26, 0x07	; 7
    1812:	dc 01       	movw	r26, r24
    1814:	ed 91       	ld	r30, X+
    1816:	fc 91       	ld	r31, X
    1818:	02 80       	ldd	r0, Z+2	; 0x02
    181a:	f3 81       	ldd	r31, Z+3	; 0x03
    181c:	e0 2d       	mov	r30, r0
    181e:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1820:	6a e0       	ldi	r22, 0x0A	; 10
    1822:	f8 01       	movw	r30, r16
    1824:	86 81       	ldd	r24, Z+6	; 0x06
    1826:	97 81       	ldd	r25, Z+7	; 0x07
    1828:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    182c:	7c 01       	movw	r14, r24
    182e:	66 e7       	ldi	r22, 0x76	; 118
    1830:	75 e0       	ldi	r23, 0x05	; 5
    1832:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1836:	66 e0       	ldi	r22, 0x06	; 6
    1838:	c7 01       	movw	r24, r14
    183a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
							break;
    183e:	1b c0       	rjmp	.+54     	; 0x1876 <_ZN9task_user3runEv+0x2e6>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1840:	6a e0       	ldi	r22, 0x0A	; 10
    1842:	86 81       	ldd	r24, Z+6	; 0x06
    1844:	97 81       	ldd	r25, Z+7	; 0x07
    1846:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    184a:	8c 01       	movw	r16, r24
    184c:	69 e5       	ldi	r22, 0x59	; 89
    184e:	75 e0       	ldi	r23, 0x05	; 5
    1850:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    1854:	66 e0       	ldi	r22, 0x06	; 6
    1856:	c8 01       	movw	r24, r16
    1858:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    185c:	93 e0       	ldi	r25, 0x03	; 3
    185e:	88 ed       	ldi	r24, 0xD8	; 216
    1860:	08 b6       	in	r0, 0x38	; 56
    1862:	18 be       	out	0x38, r1	; 56
    1864:	84 bf       	out	0x34, r24	; 52
    1866:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    186a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    186e:	81 fd       	sbrc	r24, 1
    1870:	fc cf       	rjmp	.-8      	; 0x186a <_ZN9task_user3runEv+0x2da>
    1872:	08 be       	out	0x38, r0	; 56
    1874:	ff cf       	rjmp	.-2      	; 0x1874 <_ZN9task_user3runEv+0x2e4>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1876:	f8 01       	movw	r30, r16
    1878:	86 85       	ldd	r24, Z+14	; 0x0e
    187a:	97 85       	ldd	r25, Z+15	; 0x0f
    187c:	a0 89       	ldd	r26, Z+16	; 0x10
    187e:	b1 89       	ldd	r27, Z+17	; 0x11
    1880:	01 96       	adiw	r24, 0x01	; 1
    1882:	a1 1d       	adc	r26, r1
    1884:	b1 1d       	adc	r27, r1
    1886:	86 87       	std	Z+14, r24	; 0x0e
    1888:	97 87       	std	Z+15, r25	; 0x0f
    188a:	a0 8b       	std	Z+16, r26	; 0x10
    188c:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    188e:	61 e0       	ldi	r22, 0x01	; 1
    1890:	70 e0       	ldi	r23, 0x00	; 0
    1892:	80 e0       	ldi	r24, 0x00	; 0
    1894:	90 e0       	ldi	r25, 0x00	; 0
    1896:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <vTaskDelay>
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;

	
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    189a:	98 ce       	rjmp	.-720    	; 0x15cc <_ZN9task_user3runEv+0x3c>

0000189c <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    189c:	0f 93       	push	r16
    189e:	1f 93       	push	r17
    18a0:	cf 93       	push	r28
    18a2:	df 93       	push	r29
    18a4:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    18a6:	0e 94 62 13 	call	0x26c4	; 0x26c4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    18aa:	80 91 c8 20 	lds	r24, 0x20C8	; 0x8020c8 <__data_end>
    18ae:	81 11       	cpse	r24, r1
    18b0:	1d c0       	rjmp	.+58     	; 0x18ec <pvPortMalloc+0x50>
		{
			prvHeapInit();
    18b2:	ad ec       	ldi	r26, 0xCD	; 205
    18b4:	b0 e2       	ldi	r27, 0x20	; 32
    18b6:	e1 ed       	ldi	r30, 0xD1	; 209
    18b8:	f0 e2       	ldi	r31, 0x20	; 32
    18ba:	ed 93       	st	X+, r30
    18bc:	fc 93       	st	X, r31
    18be:	11 97       	sbiw	r26, 0x01	; 1
    18c0:	12 96       	adiw	r26, 0x02	; 2
    18c2:	1d 92       	st	X+, r1
    18c4:	1c 92       	st	X, r1
    18c6:	13 97       	sbiw	r26, 0x03	; 3
    18c8:	a9 ec       	ldi	r26, 0xC9	; 201
    18ca:	b0 e2       	ldi	r27, 0x20	; 32
    18cc:	8f ef       	ldi	r24, 0xFF	; 255
    18ce:	9f e0       	ldi	r25, 0x0F	; 15
    18d0:	12 96       	adiw	r26, 0x02	; 2
    18d2:	8d 93       	st	X+, r24
    18d4:	9c 93       	st	X, r25
    18d6:	13 97       	sbiw	r26, 0x03	; 3
    18d8:	1d 92       	st	X+, r1
    18da:	1c 92       	st	X, r1
    18dc:	11 97       	sbiw	r26, 0x01	; 1
    18de:	82 83       	std	Z+2, r24	; 0x02
    18e0:	93 83       	std	Z+3, r25	; 0x03
    18e2:	a0 83       	st	Z, r26
    18e4:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	80 93 c8 20 	sts	0x20C8, r24	; 0x8020c8 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    18ec:	20 97       	sbiw	r28, 0x00	; 0
    18ee:	09 f4       	brne	.+2      	; 0x18f2 <pvPortMalloc+0x56>
    18f0:	5f c0       	rjmp	.+190    	; 0x19b0 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    18f2:	9e 01       	movw	r18, r28
    18f4:	2b 5f       	subi	r18, 0xFB	; 251
    18f6:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    18f8:	24 96       	adiw	r28, 0x04	; 4
    18fa:	ce 3f       	cpi	r28, 0xFE	; 254
    18fc:	df 40       	sbci	r29, 0x0F	; 15
    18fe:	08 f0       	brcs	.+2      	; 0x1902 <pvPortMalloc+0x66>
    1900:	5a c0       	rjmp	.+180    	; 0x19b6 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1902:	e0 91 cd 20 	lds	r30, 0x20CD	; 0x8020cd <xStart>
    1906:	f0 91 ce 20 	lds	r31, 0x20CE	; 0x8020ce <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    190a:	ad ec       	ldi	r26, 0xCD	; 205
    190c:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    190e:	02 c0       	rjmp	.+4      	; 0x1914 <pvPortMalloc+0x78>
    1910:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1912:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1914:	82 81       	ldd	r24, Z+2	; 0x02
    1916:	93 81       	ldd	r25, Z+3	; 0x03
    1918:	82 17       	cp	r24, r18
    191a:	93 07       	cpc	r25, r19
    191c:	20 f4       	brcc	.+8      	; 0x1926 <pvPortMalloc+0x8a>
    191e:	80 81       	ld	r24, Z
    1920:	91 81       	ldd	r25, Z+1	; 0x01
    1922:	00 97       	sbiw	r24, 0x00	; 0
    1924:	a9 f7       	brne	.-22     	; 0x1910 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1926:	c0 e2       	ldi	r28, 0x20	; 32
    1928:	e9 3c       	cpi	r30, 0xC9	; 201
    192a:	fc 07       	cpc	r31, r28
    192c:	09 f4       	brne	.+2      	; 0x1930 <pvPortMalloc+0x94>
    192e:	46 c0       	rjmp	.+140    	; 0x19bc <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1930:	cd 91       	ld	r28, X+
    1932:	dc 91       	ld	r29, X
    1934:	11 97       	sbiw	r26, 0x01	; 1
    1936:	8e 01       	movw	r16, r28
    1938:	0b 5f       	subi	r16, 0xFB	; 251
    193a:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    193c:	80 81       	ld	r24, Z
    193e:	91 81       	ldd	r25, Z+1	; 0x01
    1940:	8d 93       	st	X+, r24
    1942:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1944:	82 81       	ldd	r24, Z+2	; 0x02
    1946:	93 81       	ldd	r25, Z+3	; 0x03
    1948:	82 1b       	sub	r24, r18
    194a:	93 0b       	sbc	r25, r19
    194c:	8b 30       	cpi	r24, 0x0B	; 11
    194e:	91 05       	cpc	r25, r1
    1950:	10 f1       	brcs	.+68     	; 0x1996 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1952:	bf 01       	movw	r22, r30
    1954:	62 0f       	add	r22, r18
    1956:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1958:	db 01       	movw	r26, r22
    195a:	12 96       	adiw	r26, 0x02	; 2
    195c:	8d 93       	st	X+, r24
    195e:	9c 93       	st	X, r25
    1960:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1962:	22 83       	std	Z+2, r18	; 0x02
    1964:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1966:	12 96       	adiw	r26, 0x02	; 2
    1968:	4d 91       	ld	r20, X+
    196a:	5c 91       	ld	r21, X
    196c:	13 97       	sbiw	r26, 0x03	; 3
    196e:	8d ec       	ldi	r24, 0xCD	; 205
    1970:	90 e2       	ldi	r25, 0x20	; 32
    1972:	01 c0       	rjmp	.+2      	; 0x1976 <pvPortMalloc+0xda>
    1974:	cd 01       	movw	r24, r26
    1976:	ec 01       	movw	r28, r24
    1978:	a8 81       	ld	r26, Y
    197a:	b9 81       	ldd	r27, Y+1	; 0x01
    197c:	12 96       	adiw	r26, 0x02	; 2
    197e:	2d 91       	ld	r18, X+
    1980:	3c 91       	ld	r19, X
    1982:	13 97       	sbiw	r26, 0x03	; 3
    1984:	24 17       	cp	r18, r20
    1986:	35 07       	cpc	r19, r21
    1988:	a8 f3       	brcs	.-22     	; 0x1974 <pvPortMalloc+0xd8>
    198a:	eb 01       	movw	r28, r22
    198c:	a8 83       	st	Y, r26
    198e:	b9 83       	std	Y+1, r27	; 0x01
    1990:	dc 01       	movw	r26, r24
    1992:	6d 93       	st	X+, r22
    1994:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1996:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    199a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    199e:	22 81       	ldd	r18, Z+2	; 0x02
    19a0:	33 81       	ldd	r19, Z+3	; 0x03
    19a2:	82 1b       	sub	r24, r18
    19a4:	93 0b       	sbc	r25, r19
    19a6:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    19aa:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    19ae:	08 c0       	rjmp	.+16     	; 0x19c0 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    19b0:	00 e0       	ldi	r16, 0x00	; 0
    19b2:	10 e0       	ldi	r17, 0x00	; 0
    19b4:	05 c0       	rjmp	.+10     	; 0x19c0 <pvPortMalloc+0x124>
    19b6:	00 e0       	ldi	r16, 0x00	; 0
    19b8:	10 e0       	ldi	r17, 0x00	; 0
    19ba:	02 c0       	rjmp	.+4      	; 0x19c0 <pvPortMalloc+0x124>
    19bc:	00 e0       	ldi	r16, 0x00	; 0
    19be:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    19c0:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    19c4:	c8 01       	movw	r24, r16
    19c6:	df 91       	pop	r29
    19c8:	cf 91       	pop	r28
    19ca:	1f 91       	pop	r17
    19cc:	0f 91       	pop	r16
    19ce:	08 95       	ret

000019d0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    19d0:	0f 93       	push	r16
    19d2:	1f 93       	push	r17
    19d4:	cf 93       	push	r28
    19d6:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    19d8:	00 97       	sbiw	r24, 0x00	; 0
    19da:	41 f1       	breq	.+80     	; 0x1a2c <vPortFree+0x5c>
    19dc:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    19de:	8c 01       	movw	r16, r24
    19e0:	05 50       	subi	r16, 0x05	; 5
    19e2:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    19e4:	0e 94 62 13 	call	0x26c4	; 0x26c4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    19e8:	f8 01       	movw	r30, r16
    19ea:	42 81       	ldd	r20, Z+2	; 0x02
    19ec:	53 81       	ldd	r21, Z+3	; 0x03
    19ee:	ad ec       	ldi	r26, 0xCD	; 205
    19f0:	b0 e2       	ldi	r27, 0x20	; 32
    19f2:	01 c0       	rjmp	.+2      	; 0x19f6 <vPortFree+0x26>
    19f4:	df 01       	movw	r26, r30
    19f6:	ed 91       	ld	r30, X+
    19f8:	fc 91       	ld	r31, X
    19fa:	11 97       	sbiw	r26, 0x01	; 1
    19fc:	22 81       	ldd	r18, Z+2	; 0x02
    19fe:	33 81       	ldd	r19, Z+3	; 0x03
    1a00:	24 17       	cp	r18, r20
    1a02:	35 07       	cpc	r19, r21
    1a04:	b8 f3       	brcs	.-18     	; 0x19f4 <vPortFree+0x24>
    1a06:	25 97       	sbiw	r28, 0x05	; 5
    1a08:	e8 83       	st	Y, r30
    1a0a:	f9 83       	std	Y+1, r31	; 0x01
    1a0c:	0d 93       	st	X+, r16
    1a0e:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1a10:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1a14:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1a18:	8a 81       	ldd	r24, Y+2	; 0x02
    1a1a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a1c:	82 0f       	add	r24, r18
    1a1e:	93 1f       	adc	r25, r19
    1a20:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1a24:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1a28:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
	}
}
    1a2c:	df 91       	pop	r29
    1a2e:	cf 91       	pop	r28
    1a30:	1f 91       	pop	r17
    1a32:	0f 91       	pop	r16
    1a34:	08 95       	ret

00001a36 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1a36:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1a3a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1a3e:	08 95       	ret

00001a40 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1a40:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1a42:	03 96       	adiw	r24, 0x03	; 3
    1a44:	81 83       	std	Z+1, r24	; 0x01
    1a46:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1a48:	4f ef       	ldi	r20, 0xFF	; 255
    1a4a:	5f ef       	ldi	r21, 0xFF	; 255
    1a4c:	ba 01       	movw	r22, r20
    1a4e:	43 83       	std	Z+3, r20	; 0x03
    1a50:	54 83       	std	Z+4, r21	; 0x04
    1a52:	65 83       	std	Z+5, r22	; 0x05
    1a54:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1a56:	87 83       	std	Z+7, r24	; 0x07
    1a58:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1a5a:	81 87       	std	Z+9, r24	; 0x09
    1a5c:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1a5e:	10 82       	st	Z, r1
    1a60:	08 95       	ret

00001a62 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1a62:	fc 01       	movw	r30, r24
    1a64:	12 86       	std	Z+10, r1	; 0x0a
    1a66:	13 86       	std	Z+11, r1	; 0x0b
    1a68:	08 95       	ret

00001a6a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1a6a:	cf 93       	push	r28
    1a6c:	df 93       	push	r29
    1a6e:	fc 01       	movw	r30, r24
    1a70:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1a72:	21 81       	ldd	r18, Z+1	; 0x01
    1a74:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1a76:	e9 01       	movw	r28, r18
    1a78:	8c 81       	ldd	r24, Y+4	; 0x04
    1a7a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a7c:	14 96       	adiw	r26, 0x04	; 4
    1a7e:	8d 93       	st	X+, r24
    1a80:	9c 93       	st	X, r25
    1a82:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1a84:	81 81       	ldd	r24, Z+1	; 0x01
    1a86:	92 81       	ldd	r25, Z+2	; 0x02
    1a88:	16 96       	adiw	r26, 0x06	; 6
    1a8a:	8d 93       	st	X+, r24
    1a8c:	9c 93       	st	X, r25
    1a8e:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1a90:	8c 81       	ldd	r24, Y+4	; 0x04
    1a92:	9d 81       	ldd	r25, Y+5	; 0x05
    1a94:	ec 01       	movw	r28, r24
    1a96:	6e 83       	std	Y+6, r22	; 0x06
    1a98:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1a9a:	e9 01       	movw	r28, r18
    1a9c:	6c 83       	std	Y+4, r22	; 0x04
    1a9e:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1aa0:	61 83       	std	Z+1, r22	; 0x01
    1aa2:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1aa4:	1a 96       	adiw	r26, 0x0a	; 10
    1aa6:	ed 93       	st	X+, r30
    1aa8:	fc 93       	st	X, r31
    1aaa:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1aac:	80 81       	ld	r24, Z
    1aae:	8f 5f       	subi	r24, 0xFF	; 255
    1ab0:	80 83       	st	Z, r24
}
    1ab2:	df 91       	pop	r29
    1ab4:	cf 91       	pop	r28
    1ab6:	08 95       	ret

00001ab8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1ab8:	0f 93       	push	r16
    1aba:	1f 93       	push	r17
    1abc:	cf 93       	push	r28
    1abe:	df 93       	push	r29
    1ac0:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1ac2:	08 81       	ld	r16, Y
    1ac4:	19 81       	ldd	r17, Y+1	; 0x01
    1ac6:	2a 81       	ldd	r18, Y+2	; 0x02
    1ac8:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1aca:	0f 3f       	cpi	r16, 0xFF	; 255
    1acc:	4f ef       	ldi	r20, 0xFF	; 255
    1ace:	14 07       	cpc	r17, r20
    1ad0:	24 07       	cpc	r18, r20
    1ad2:	34 07       	cpc	r19, r20
    1ad4:	31 f4       	brne	.+12     	; 0x1ae2 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1ad6:	dc 01       	movw	r26, r24
    1ad8:	19 96       	adiw	r26, 0x09	; 9
    1ada:	ed 91       	ld	r30, X+
    1adc:	fc 91       	ld	r31, X
    1ade:	1a 97       	sbiw	r26, 0x0a	; 10
    1ae0:	1f c0       	rjmp	.+62     	; 0x1b20 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1ae2:	fc 01       	movw	r30, r24
    1ae4:	33 96       	adiw	r30, 0x03	; 3
    1ae6:	dc 01       	movw	r26, r24
    1ae8:	17 96       	adiw	r26, 0x07	; 7
    1aea:	4d 91       	ld	r20, X+
    1aec:	5c 91       	ld	r21, X
    1aee:	18 97       	sbiw	r26, 0x08	; 8
    1af0:	da 01       	movw	r26, r20
    1af2:	4d 91       	ld	r20, X+
    1af4:	5d 91       	ld	r21, X+
    1af6:	6d 91       	ld	r22, X+
    1af8:	7c 91       	ld	r23, X
    1afa:	04 17       	cp	r16, r20
    1afc:	15 07       	cpc	r17, r21
    1afe:	26 07       	cpc	r18, r22
    1b00:	37 07       	cpc	r19, r23
    1b02:	70 f0       	brcs	.+28     	; 0x1b20 <vListInsert+0x68>
    1b04:	04 80       	ldd	r0, Z+4	; 0x04
    1b06:	f5 81       	ldd	r31, Z+5	; 0x05
    1b08:	e0 2d       	mov	r30, r0
    1b0a:	a4 81       	ldd	r26, Z+4	; 0x04
    1b0c:	b5 81       	ldd	r27, Z+5	; 0x05
    1b0e:	4d 91       	ld	r20, X+
    1b10:	5d 91       	ld	r21, X+
    1b12:	6d 91       	ld	r22, X+
    1b14:	7c 91       	ld	r23, X
    1b16:	04 17       	cp	r16, r20
    1b18:	15 07       	cpc	r17, r21
    1b1a:	26 07       	cpc	r18, r22
    1b1c:	37 07       	cpc	r19, r23
    1b1e:	90 f7       	brcc	.-28     	; 0x1b04 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1b20:	a4 81       	ldd	r26, Z+4	; 0x04
    1b22:	b5 81       	ldd	r27, Z+5	; 0x05
    1b24:	ac 83       	std	Y+4, r26	; 0x04
    1b26:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1b28:	16 96       	adiw	r26, 0x06	; 6
    1b2a:	cd 93       	st	X+, r28
    1b2c:	dc 93       	st	X, r29
    1b2e:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1b30:	ee 83       	std	Y+6, r30	; 0x06
    1b32:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1b34:	c4 83       	std	Z+4, r28	; 0x04
    1b36:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b38:	8a 87       	std	Y+10, r24	; 0x0a
    1b3a:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1b3c:	fc 01       	movw	r30, r24
    1b3e:	20 81       	ld	r18, Z
    1b40:	2f 5f       	subi	r18, 0xFF	; 255
    1b42:	20 83       	st	Z, r18
}
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	1f 91       	pop	r17
    1b4a:	0f 91       	pop	r16
    1b4c:	08 95       	ret

00001b4e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1b4e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1b50:	a4 81       	ldd	r26, Z+4	; 0x04
    1b52:	b5 81       	ldd	r27, Z+5	; 0x05
    1b54:	86 81       	ldd	r24, Z+6	; 0x06
    1b56:	97 81       	ldd	r25, Z+7	; 0x07
    1b58:	16 96       	adiw	r26, 0x06	; 6
    1b5a:	8d 93       	st	X+, r24
    1b5c:	9c 93       	st	X, r25
    1b5e:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1b60:	a6 81       	ldd	r26, Z+6	; 0x06
    1b62:	b7 81       	ldd	r27, Z+7	; 0x07
    1b64:	84 81       	ldd	r24, Z+4	; 0x04
    1b66:	95 81       	ldd	r25, Z+5	; 0x05
    1b68:	14 96       	adiw	r26, 0x04	; 4
    1b6a:	8d 93       	st	X+, r24
    1b6c:	9c 93       	st	X, r25
    1b6e:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1b70:	a2 85       	ldd	r26, Z+10	; 0x0a
    1b72:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1b74:	11 96       	adiw	r26, 0x01	; 1
    1b76:	8d 91       	ld	r24, X+
    1b78:	9c 91       	ld	r25, X
    1b7a:	12 97       	sbiw	r26, 0x02	; 2
    1b7c:	e8 17       	cp	r30, r24
    1b7e:	f9 07       	cpc	r31, r25
    1b80:	31 f4       	brne	.+12     	; 0x1b8e <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1b82:	86 81       	ldd	r24, Z+6	; 0x06
    1b84:	97 81       	ldd	r25, Z+7	; 0x07
    1b86:	11 96       	adiw	r26, 0x01	; 1
    1b88:	8d 93       	st	X+, r24
    1b8a:	9c 93       	st	X, r25
    1b8c:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1b8e:	12 86       	std	Z+10, r1	; 0x0a
    1b90:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1b92:	8c 91       	ld	r24, X
    1b94:	81 50       	subi	r24, 0x01	; 1
    1b96:	8c 93       	st	X, r24
    1b98:	08 95       	ret

00001b9a <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1b9a:	80 93 70 31 	sts	0x3170, r24	; 0x803170 <portStackTopForTask>
    1b9e:	90 93 71 31 	sts	0x3171, r25	; 0x803171 <portStackTopForTask+0x1>
    1ba2:	31 e1       	ldi	r19, 0x11	; 17
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	30 83       	st	Z, r19
    1ba8:	31 97       	sbiw	r30, 0x01	; 1
    1baa:	22 e2       	ldi	r18, 0x22	; 34
    1bac:	20 83       	st	Z, r18
    1bae:	31 97       	sbiw	r30, 0x01	; 1
    1bb0:	a3 e3       	ldi	r26, 0x33	; 51
    1bb2:	a0 83       	st	Z, r26
    1bb4:	31 97       	sbiw	r30, 0x01	; 1
    1bb6:	60 83       	st	Z, r22
    1bb8:	31 97       	sbiw	r30, 0x01	; 1
    1bba:	70 83       	st	Z, r23
    1bbc:	31 97       	sbiw	r30, 0x01	; 1
    1bbe:	10 82       	st	Z, r1
    1bc0:	31 97       	sbiw	r30, 0x01	; 1
    1bc2:	10 82       	st	Z, r1
    1bc4:	31 97       	sbiw	r30, 0x01	; 1
    1bc6:	60 e8       	ldi	r22, 0x80	; 128
    1bc8:	60 83       	st	Z, r22
    1bca:	31 97       	sbiw	r30, 0x01	; 1
    1bcc:	10 82       	st	Z, r1
    1bce:	31 97       	sbiw	r30, 0x01	; 1
    1bd0:	10 82       	st	Z, r1
    1bd2:	31 97       	sbiw	r30, 0x01	; 1
    1bd4:	10 82       	st	Z, r1
    1bd6:	31 97       	sbiw	r30, 0x01	; 1
    1bd8:	62 e0       	ldi	r22, 0x02	; 2
    1bda:	60 83       	st	Z, r22
    1bdc:	31 97       	sbiw	r30, 0x01	; 1
    1bde:	63 e0       	ldi	r22, 0x03	; 3
    1be0:	60 83       	st	Z, r22
    1be2:	31 97       	sbiw	r30, 0x01	; 1
    1be4:	64 e0       	ldi	r22, 0x04	; 4
    1be6:	60 83       	st	Z, r22
    1be8:	31 97       	sbiw	r30, 0x01	; 1
    1bea:	65 e0       	ldi	r22, 0x05	; 5
    1bec:	60 83       	st	Z, r22
    1bee:	31 97       	sbiw	r30, 0x01	; 1
    1bf0:	66 e0       	ldi	r22, 0x06	; 6
    1bf2:	60 83       	st	Z, r22
    1bf4:	31 97       	sbiw	r30, 0x01	; 1
    1bf6:	67 e0       	ldi	r22, 0x07	; 7
    1bf8:	60 83       	st	Z, r22
    1bfa:	31 97       	sbiw	r30, 0x01	; 1
    1bfc:	68 e0       	ldi	r22, 0x08	; 8
    1bfe:	60 83       	st	Z, r22
    1c00:	31 97       	sbiw	r30, 0x01	; 1
    1c02:	69 e0       	ldi	r22, 0x09	; 9
    1c04:	60 83       	st	Z, r22
    1c06:	31 97       	sbiw	r30, 0x01	; 1
    1c08:	60 e1       	ldi	r22, 0x10	; 16
    1c0a:	60 83       	st	Z, r22
    1c0c:	31 97       	sbiw	r30, 0x01	; 1
    1c0e:	30 83       	st	Z, r19
    1c10:	31 97       	sbiw	r30, 0x01	; 1
    1c12:	32 e1       	ldi	r19, 0x12	; 18
    1c14:	30 83       	st	Z, r19
    1c16:	31 97       	sbiw	r30, 0x01	; 1
    1c18:	33 e1       	ldi	r19, 0x13	; 19
    1c1a:	30 83       	st	Z, r19
    1c1c:	31 97       	sbiw	r30, 0x01	; 1
    1c1e:	34 e1       	ldi	r19, 0x14	; 20
    1c20:	30 83       	st	Z, r19
    1c22:	31 97       	sbiw	r30, 0x01	; 1
    1c24:	35 e1       	ldi	r19, 0x15	; 21
    1c26:	30 83       	st	Z, r19
    1c28:	31 97       	sbiw	r30, 0x01	; 1
    1c2a:	36 e1       	ldi	r19, 0x16	; 22
    1c2c:	30 83       	st	Z, r19
    1c2e:	31 97       	sbiw	r30, 0x01	; 1
    1c30:	37 e1       	ldi	r19, 0x17	; 23
    1c32:	30 83       	st	Z, r19
    1c34:	31 97       	sbiw	r30, 0x01	; 1
    1c36:	38 e1       	ldi	r19, 0x18	; 24
    1c38:	30 83       	st	Z, r19
    1c3a:	31 97       	sbiw	r30, 0x01	; 1
    1c3c:	39 e1       	ldi	r19, 0x19	; 25
    1c3e:	30 83       	st	Z, r19
    1c40:	31 97       	sbiw	r30, 0x01	; 1
    1c42:	30 e2       	ldi	r19, 0x20	; 32
    1c44:	30 83       	st	Z, r19
    1c46:	31 97       	sbiw	r30, 0x01	; 1
    1c48:	31 e2       	ldi	r19, 0x21	; 33
    1c4a:	30 83       	st	Z, r19
    1c4c:	31 97       	sbiw	r30, 0x01	; 1
    1c4e:	20 83       	st	Z, r18
    1c50:	31 97       	sbiw	r30, 0x01	; 1
    1c52:	23 e2       	ldi	r18, 0x23	; 35
    1c54:	20 83       	st	Z, r18
    1c56:	31 97       	sbiw	r30, 0x01	; 1
    1c58:	40 83       	st	Z, r20
    1c5a:	31 97       	sbiw	r30, 0x01	; 1
    1c5c:	50 83       	st	Z, r21
    1c5e:	31 97       	sbiw	r30, 0x01	; 1
    1c60:	26 e2       	ldi	r18, 0x26	; 38
    1c62:	20 83       	st	Z, r18
    1c64:	31 97       	sbiw	r30, 0x01	; 1
    1c66:	27 e2       	ldi	r18, 0x27	; 39
    1c68:	20 83       	st	Z, r18
    1c6a:	31 97       	sbiw	r30, 0x01	; 1
    1c6c:	28 e2       	ldi	r18, 0x28	; 40
    1c6e:	20 83       	st	Z, r18
    1c70:	31 97       	sbiw	r30, 0x01	; 1
    1c72:	29 e2       	ldi	r18, 0x29	; 41
    1c74:	20 83       	st	Z, r18
    1c76:	31 97       	sbiw	r30, 0x01	; 1
    1c78:	20 e3       	ldi	r18, 0x30	; 48
    1c7a:	20 83       	st	Z, r18
    1c7c:	31 97       	sbiw	r30, 0x01	; 1
    1c7e:	21 e3       	ldi	r18, 0x31	; 49
    1c80:	20 83       	st	Z, r18
    1c82:	89 97       	sbiw	r24, 0x29	; 41
    1c84:	08 95       	ret

00001c86 <xPortStartScheduler>:
    1c86:	8c e7       	ldi	r24, 0x7C	; 124
    1c88:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1c8c:	8f ef       	ldi	r24, 0xFF	; 255
    1c8e:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1c92:	81 e0       	ldi	r24, 0x01	; 1
    1c94:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1c98:	91 e1       	ldi	r25, 0x11	; 17
    1c9a:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1c9e:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1ca2:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1ca6:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1caa:	cd 91       	ld	r28, X+
    1cac:	cd bf       	out	0x3d, r28	; 61
    1cae:	dd 91       	ld	r29, X+
    1cb0:	de bf       	out	0x3e, r29	; 62
    1cb2:	ff 91       	pop	r31
    1cb4:	ef 91       	pop	r30
    1cb6:	df 91       	pop	r29
    1cb8:	cf 91       	pop	r28
    1cba:	bf 91       	pop	r27
    1cbc:	af 91       	pop	r26
    1cbe:	9f 91       	pop	r25
    1cc0:	8f 91       	pop	r24
    1cc2:	7f 91       	pop	r23
    1cc4:	6f 91       	pop	r22
    1cc6:	5f 91       	pop	r21
    1cc8:	4f 91       	pop	r20
    1cca:	3f 91       	pop	r19
    1ccc:	2f 91       	pop	r18
    1cce:	1f 91       	pop	r17
    1cd0:	0f 91       	pop	r16
    1cd2:	ff 90       	pop	r15
    1cd4:	ef 90       	pop	r14
    1cd6:	df 90       	pop	r13
    1cd8:	cf 90       	pop	r12
    1cda:	bf 90       	pop	r11
    1cdc:	af 90       	pop	r10
    1cde:	9f 90       	pop	r9
    1ce0:	8f 90       	pop	r8
    1ce2:	7f 90       	pop	r7
    1ce4:	6f 90       	pop	r6
    1ce6:	5f 90       	pop	r5
    1ce8:	4f 90       	pop	r4
    1cea:	3f 90       	pop	r3
    1cec:	2f 90       	pop	r2
    1cee:	1f 90       	pop	r1
    1cf0:	0f 90       	pop	r0
    1cf2:	0c be       	out	0x3c, r0	; 60
    1cf4:	0f 90       	pop	r0
    1cf6:	0b be       	out	0x3b, r0	; 59
    1cf8:	0f 90       	pop	r0
    1cfa:	0f be       	out	0x3f, r0	; 63
    1cfc:	0f 90       	pop	r0
    1cfe:	08 95       	ret
    1d00:	08 95       	ret

00001d02 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d02:	0f 92       	push	r0
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	f8 94       	cli
    1d08:	0f 92       	push	r0
    1d0a:	0b b6       	in	r0, 0x3b	; 59
    1d0c:	0f 92       	push	r0
    1d0e:	0c b6       	in	r0, 0x3c	; 60
    1d10:	0f 92       	push	r0
    1d12:	1f 92       	push	r1
    1d14:	11 24       	eor	r1, r1
    1d16:	2f 92       	push	r2
    1d18:	3f 92       	push	r3
    1d1a:	4f 92       	push	r4
    1d1c:	5f 92       	push	r5
    1d1e:	6f 92       	push	r6
    1d20:	7f 92       	push	r7
    1d22:	8f 92       	push	r8
    1d24:	9f 92       	push	r9
    1d26:	af 92       	push	r10
    1d28:	bf 92       	push	r11
    1d2a:	cf 92       	push	r12
    1d2c:	df 92       	push	r13
    1d2e:	ef 92       	push	r14
    1d30:	ff 92       	push	r15
    1d32:	0f 93       	push	r16
    1d34:	1f 93       	push	r17
    1d36:	2f 93       	push	r18
    1d38:	3f 93       	push	r19
    1d3a:	4f 93       	push	r20
    1d3c:	5f 93       	push	r21
    1d3e:	6f 93       	push	r22
    1d40:	7f 93       	push	r23
    1d42:	8f 93       	push	r24
    1d44:	9f 93       	push	r25
    1d46:	af 93       	push	r26
    1d48:	bf 93       	push	r27
    1d4a:	cf 93       	push	r28
    1d4c:	df 93       	push	r29
    1d4e:	ef 93       	push	r30
    1d50:	ff 93       	push	r31
    1d52:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1d56:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1d5a:	0d b6       	in	r0, 0x3d	; 61
    1d5c:	0d 92       	st	X+, r0
    1d5e:	0e b6       	in	r0, 0x3e	; 62
    1d60:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1d62:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1d66:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1d6a:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1d6e:	cd 91       	ld	r28, X+
    1d70:	cd bf       	out	0x3d, r28	; 61
    1d72:	dd 91       	ld	r29, X+
    1d74:	de bf       	out	0x3e, r29	; 62
    1d76:	ff 91       	pop	r31
    1d78:	ef 91       	pop	r30
    1d7a:	df 91       	pop	r29
    1d7c:	cf 91       	pop	r28
    1d7e:	bf 91       	pop	r27
    1d80:	af 91       	pop	r26
    1d82:	9f 91       	pop	r25
    1d84:	8f 91       	pop	r24
    1d86:	7f 91       	pop	r23
    1d88:	6f 91       	pop	r22
    1d8a:	5f 91       	pop	r21
    1d8c:	4f 91       	pop	r20
    1d8e:	3f 91       	pop	r19
    1d90:	2f 91       	pop	r18
    1d92:	1f 91       	pop	r17
    1d94:	0f 91       	pop	r16
    1d96:	ff 90       	pop	r15
    1d98:	ef 90       	pop	r14
    1d9a:	df 90       	pop	r13
    1d9c:	cf 90       	pop	r12
    1d9e:	bf 90       	pop	r11
    1da0:	af 90       	pop	r10
    1da2:	9f 90       	pop	r9
    1da4:	8f 90       	pop	r8
    1da6:	7f 90       	pop	r7
    1da8:	6f 90       	pop	r6
    1daa:	5f 90       	pop	r5
    1dac:	4f 90       	pop	r4
    1dae:	3f 90       	pop	r3
    1db0:	2f 90       	pop	r2
    1db2:	1f 90       	pop	r1
    1db4:	0f 90       	pop	r0
    1db6:	0c be       	out	0x3c, r0	; 60
    1db8:	0f 90       	pop	r0
    1dba:	0b be       	out	0x3b, r0	; 59
    1dbc:	0f 90       	pop	r0
    1dbe:	0f be       	out	0x3f, r0	; 63
    1dc0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1dc2:	08 95       	ret

00001dc4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1dc4:	0f 92       	push	r0
    1dc6:	0f b6       	in	r0, 0x3f	; 63
    1dc8:	f8 94       	cli
    1dca:	0f 92       	push	r0
    1dcc:	0b b6       	in	r0, 0x3b	; 59
    1dce:	0f 92       	push	r0
    1dd0:	0c b6       	in	r0, 0x3c	; 60
    1dd2:	0f 92       	push	r0
    1dd4:	1f 92       	push	r1
    1dd6:	11 24       	eor	r1, r1
    1dd8:	2f 92       	push	r2
    1dda:	3f 92       	push	r3
    1ddc:	4f 92       	push	r4
    1dde:	5f 92       	push	r5
    1de0:	6f 92       	push	r6
    1de2:	7f 92       	push	r7
    1de4:	8f 92       	push	r8
    1de6:	9f 92       	push	r9
    1de8:	af 92       	push	r10
    1dea:	bf 92       	push	r11
    1dec:	cf 92       	push	r12
    1dee:	df 92       	push	r13
    1df0:	ef 92       	push	r14
    1df2:	ff 92       	push	r15
    1df4:	0f 93       	push	r16
    1df6:	1f 93       	push	r17
    1df8:	2f 93       	push	r18
    1dfa:	3f 93       	push	r19
    1dfc:	4f 93       	push	r20
    1dfe:	5f 93       	push	r21
    1e00:	6f 93       	push	r22
    1e02:	7f 93       	push	r23
    1e04:	8f 93       	push	r24
    1e06:	9f 93       	push	r25
    1e08:	af 93       	push	r26
    1e0a:	bf 93       	push	r27
    1e0c:	cf 93       	push	r28
    1e0e:	df 93       	push	r29
    1e10:	ef 93       	push	r30
    1e12:	ff 93       	push	r31
    1e14:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1e18:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1e1c:	0d b6       	in	r0, 0x3d	; 61
    1e1e:	0d 92       	st	X+, r0
    1e20:	0e b6       	in	r0, 0x3e	; 62
    1e22:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1e24:	0e 94 83 13 	call	0x2706	; 0x2706 <vTaskIncrementTick>
	vTaskSwitchContext();
    1e28:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e2c:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1e30:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1e34:	cd 91       	ld	r28, X+
    1e36:	cd bf       	out	0x3d, r28	; 61
    1e38:	dd 91       	ld	r29, X+
    1e3a:	de bf       	out	0x3e, r29	; 62
    1e3c:	ff 91       	pop	r31
    1e3e:	ef 91       	pop	r30
    1e40:	df 91       	pop	r29
    1e42:	cf 91       	pop	r28
    1e44:	bf 91       	pop	r27
    1e46:	af 91       	pop	r26
    1e48:	9f 91       	pop	r25
    1e4a:	8f 91       	pop	r24
    1e4c:	7f 91       	pop	r23
    1e4e:	6f 91       	pop	r22
    1e50:	5f 91       	pop	r21
    1e52:	4f 91       	pop	r20
    1e54:	3f 91       	pop	r19
    1e56:	2f 91       	pop	r18
    1e58:	1f 91       	pop	r17
    1e5a:	0f 91       	pop	r16
    1e5c:	ff 90       	pop	r15
    1e5e:	ef 90       	pop	r14
    1e60:	df 90       	pop	r13
    1e62:	cf 90       	pop	r12
    1e64:	bf 90       	pop	r11
    1e66:	af 90       	pop	r10
    1e68:	9f 90       	pop	r9
    1e6a:	8f 90       	pop	r8
    1e6c:	7f 90       	pop	r7
    1e6e:	6f 90       	pop	r6
    1e70:	5f 90       	pop	r5
    1e72:	4f 90       	pop	r4
    1e74:	3f 90       	pop	r3
    1e76:	2f 90       	pop	r2
    1e78:	1f 90       	pop	r1
    1e7a:	0f 90       	pop	r0
    1e7c:	0c be       	out	0x3c, r0	; 60
    1e7e:	0f 90       	pop	r0
    1e80:	0b be       	out	0x3b, r0	; 59
    1e82:	0f 90       	pop	r0
    1e84:	0f be       	out	0x3f, r0	; 63
    1e86:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e88:	08 95       	ret

00001e8a <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1e8a:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1e8e:	18 95       	reti

00001e90 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e90:	cf 93       	push	r28
    1e92:	df 93       	push	r29
    1e94:	ec 01       	movw	r28, r24
    1e96:	88 a1       	ldd	r24, Y+32	; 0x20
    1e98:	81 11       	cpse	r24, r1
    1e9a:	0b c0       	rjmp	.+22     	; 0x1eb2 <prvCopyDataToQueue+0x22>
    1e9c:	88 81       	ld	r24, Y
    1e9e:	99 81       	ldd	r25, Y+1	; 0x01
    1ea0:	89 2b       	or	r24, r25
    1ea2:	e1 f5       	brne	.+120    	; 0x1f1c <prvCopyDataToQueue+0x8c>
    1ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ea8:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vTaskPriorityDisinherit>
    1eac:	1a 82       	std	Y+2, r1	; 0x02
    1eae:	1b 82       	std	Y+3, r1	; 0x03
    1eb0:	35 c0       	rjmp	.+106    	; 0x1f1c <prvCopyDataToQueue+0x8c>
    1eb2:	41 11       	cpse	r20, r1
    1eb4:	17 c0       	rjmp	.+46     	; 0x1ee4 <prvCopyDataToQueue+0x54>
    1eb6:	48 2f       	mov	r20, r24
    1eb8:	50 e0       	ldi	r21, 0x00	; 0
    1eba:	8c 81       	ldd	r24, Y+4	; 0x04
    1ebc:	9d 81       	ldd	r25, Y+5	; 0x05
    1ebe:	0e 94 fd 22 	call	0x45fa	; 0x45fa <memcpy>
    1ec2:	28 a1       	ldd	r18, Y+32	; 0x20
    1ec4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ec6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ec8:	82 0f       	add	r24, r18
    1eca:	91 1d       	adc	r25, r1
    1ecc:	8c 83       	std	Y+4, r24	; 0x04
    1ece:	9d 83       	std	Y+5, r25	; 0x05
    1ed0:	2a 81       	ldd	r18, Y+2	; 0x02
    1ed2:	3b 81       	ldd	r19, Y+3	; 0x03
    1ed4:	82 17       	cp	r24, r18
    1ed6:	93 07       	cpc	r25, r19
    1ed8:	08 f1       	brcs	.+66     	; 0x1f1c <prvCopyDataToQueue+0x8c>
    1eda:	88 81       	ld	r24, Y
    1edc:	99 81       	ldd	r25, Y+1	; 0x01
    1ede:	8c 83       	std	Y+4, r24	; 0x04
    1ee0:	9d 83       	std	Y+5, r25	; 0x05
    1ee2:	1c c0       	rjmp	.+56     	; 0x1f1c <prvCopyDataToQueue+0x8c>
    1ee4:	48 2f       	mov	r20, r24
    1ee6:	50 e0       	ldi	r21, 0x00	; 0
    1ee8:	8e 81       	ldd	r24, Y+6	; 0x06
    1eea:	9f 81       	ldd	r25, Y+7	; 0x07
    1eec:	0e 94 fd 22 	call	0x45fa	; 0x45fa <memcpy>
    1ef0:	88 a1       	ldd	r24, Y+32	; 0x20
    1ef2:	90 e0       	ldi	r25, 0x00	; 0
    1ef4:	91 95       	neg	r25
    1ef6:	81 95       	neg	r24
    1ef8:	91 09       	sbc	r25, r1
    1efa:	2e 81       	ldd	r18, Y+6	; 0x06
    1efc:	3f 81       	ldd	r19, Y+7	; 0x07
    1efe:	28 0f       	add	r18, r24
    1f00:	39 1f       	adc	r19, r25
    1f02:	2e 83       	std	Y+6, r18	; 0x06
    1f04:	3f 83       	std	Y+7, r19	; 0x07
    1f06:	48 81       	ld	r20, Y
    1f08:	59 81       	ldd	r21, Y+1	; 0x01
    1f0a:	24 17       	cp	r18, r20
    1f0c:	35 07       	cpc	r19, r21
    1f0e:	30 f4       	brcc	.+12     	; 0x1f1c <prvCopyDataToQueue+0x8c>
    1f10:	2a 81       	ldd	r18, Y+2	; 0x02
    1f12:	3b 81       	ldd	r19, Y+3	; 0x03
    1f14:	82 0f       	add	r24, r18
    1f16:	93 1f       	adc	r25, r19
    1f18:	8e 83       	std	Y+6, r24	; 0x06
    1f1a:	9f 83       	std	Y+7, r25	; 0x07
    1f1c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f1e:	8f 5f       	subi	r24, 0xFF	; 255
    1f20:	8e 8f       	std	Y+30, r24	; 0x1e
    1f22:	df 91       	pop	r29
    1f24:	cf 91       	pop	r28
    1f26:	08 95       	ret

00001f28 <prvCopyDataFromQueue>:
    1f28:	fc 01       	movw	r30, r24
    1f2a:	80 81       	ld	r24, Z
    1f2c:	91 81       	ldd	r25, Z+1	; 0x01
    1f2e:	00 97       	sbiw	r24, 0x00	; 0
    1f30:	a1 f0       	breq	.+40     	; 0x1f5a <prvCopyDataFromQueue+0x32>
    1f32:	40 a1       	ldd	r20, Z+32	; 0x20
    1f34:	50 e0       	ldi	r21, 0x00	; 0
    1f36:	26 81       	ldd	r18, Z+6	; 0x06
    1f38:	37 81       	ldd	r19, Z+7	; 0x07
    1f3a:	24 0f       	add	r18, r20
    1f3c:	35 1f       	adc	r19, r21
    1f3e:	26 83       	std	Z+6, r18	; 0x06
    1f40:	37 83       	std	Z+7, r19	; 0x07
    1f42:	a2 81       	ldd	r26, Z+2	; 0x02
    1f44:	b3 81       	ldd	r27, Z+3	; 0x03
    1f46:	2a 17       	cp	r18, r26
    1f48:	3b 07       	cpc	r19, r27
    1f4a:	10 f0       	brcs	.+4      	; 0x1f50 <prvCopyDataFromQueue+0x28>
    1f4c:	86 83       	std	Z+6, r24	; 0x06
    1f4e:	97 83       	std	Z+7, r25	; 0x07
    1f50:	cb 01       	movw	r24, r22
    1f52:	66 81       	ldd	r22, Z+6	; 0x06
    1f54:	77 81       	ldd	r23, Z+7	; 0x07
    1f56:	0e 94 fd 22 	call	0x45fa	; 0x45fa <memcpy>
    1f5a:	08 95       	ret

00001f5c <prvUnlockQueue>:
    1f5c:	0f 93       	push	r16
    1f5e:	1f 93       	push	r17
    1f60:	cf 93       	push	r28
    1f62:	df 93       	push	r29
    1f64:	ec 01       	movw	r28, r24
    1f66:	0f b6       	in	r0, 0x3f	; 63
    1f68:	f8 94       	cli
    1f6a:	0f 92       	push	r0
    1f6c:	8a a1       	ldd	r24, Y+34	; 0x22
    1f6e:	18 16       	cp	r1, r24
    1f70:	b4 f4       	brge	.+44     	; 0x1f9e <prvUnlockQueue+0x42>
    1f72:	8b 89       	ldd	r24, Y+19	; 0x13
    1f74:	81 11       	cpse	r24, r1
    1f76:	05 c0       	rjmp	.+10     	; 0x1f82 <prvUnlockQueue+0x26>
    1f78:	12 c0       	rjmp	.+36     	; 0x1f9e <prvUnlockQueue+0x42>
    1f7a:	8b 89       	ldd	r24, Y+19	; 0x13
    1f7c:	81 11       	cpse	r24, r1
    1f7e:	04 c0       	rjmp	.+8      	; 0x1f88 <prvUnlockQueue+0x2c>
    1f80:	0e c0       	rjmp	.+28     	; 0x1f9e <prvUnlockQueue+0x42>
    1f82:	8e 01       	movw	r16, r28
    1f84:	0d 5e       	subi	r16, 0xED	; 237
    1f86:	1f 4f       	sbci	r17, 0xFF	; 255
    1f88:	c8 01       	movw	r24, r16
    1f8a:	0e 94 28 16 	call	0x2c50	; 0x2c50 <xTaskRemoveFromEventList>
    1f8e:	81 11       	cpse	r24, r1
    1f90:	0e 94 e5 16 	call	0x2dca	; 0x2dca <vTaskMissedYield>
    1f94:	8a a1       	ldd	r24, Y+34	; 0x22
    1f96:	81 50       	subi	r24, 0x01	; 1
    1f98:	8a a3       	std	Y+34, r24	; 0x22
    1f9a:	18 16       	cp	r1, r24
    1f9c:	74 f3       	brlt	.-36     	; 0x1f7a <prvUnlockQueue+0x1e>
    1f9e:	8f ef       	ldi	r24, 0xFF	; 255
    1fa0:	8a a3       	std	Y+34, r24	; 0x22
    1fa2:	0f 90       	pop	r0
    1fa4:	0f be       	out	0x3f, r0	; 63
    1fa6:	0f b6       	in	r0, 0x3f	; 63
    1fa8:	f8 94       	cli
    1faa:	0f 92       	push	r0
    1fac:	89 a1       	ldd	r24, Y+33	; 0x21
    1fae:	18 16       	cp	r1, r24
    1fb0:	b4 f4       	brge	.+44     	; 0x1fde <prvUnlockQueue+0x82>
    1fb2:	88 85       	ldd	r24, Y+8	; 0x08
    1fb4:	81 11       	cpse	r24, r1
    1fb6:	05 c0       	rjmp	.+10     	; 0x1fc2 <prvUnlockQueue+0x66>
    1fb8:	12 c0       	rjmp	.+36     	; 0x1fde <prvUnlockQueue+0x82>
    1fba:	88 85       	ldd	r24, Y+8	; 0x08
    1fbc:	81 11       	cpse	r24, r1
    1fbe:	04 c0       	rjmp	.+8      	; 0x1fc8 <prvUnlockQueue+0x6c>
    1fc0:	0e c0       	rjmp	.+28     	; 0x1fde <prvUnlockQueue+0x82>
    1fc2:	8e 01       	movw	r16, r28
    1fc4:	08 5f       	subi	r16, 0xF8	; 248
    1fc6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fc8:	c8 01       	movw	r24, r16
    1fca:	0e 94 28 16 	call	0x2c50	; 0x2c50 <xTaskRemoveFromEventList>
    1fce:	81 11       	cpse	r24, r1
    1fd0:	0e 94 e5 16 	call	0x2dca	; 0x2dca <vTaskMissedYield>
    1fd4:	89 a1       	ldd	r24, Y+33	; 0x21
    1fd6:	81 50       	subi	r24, 0x01	; 1
    1fd8:	89 a3       	std	Y+33, r24	; 0x21
    1fda:	18 16       	cp	r1, r24
    1fdc:	74 f3       	brlt	.-36     	; 0x1fba <prvUnlockQueue+0x5e>
    1fde:	8f ef       	ldi	r24, 0xFF	; 255
    1fe0:	89 a3       	std	Y+33, r24	; 0x21
    1fe2:	0f 90       	pop	r0
    1fe4:	0f be       	out	0x3f, r0	; 63
    1fe6:	df 91       	pop	r29
    1fe8:	cf 91       	pop	r28
    1fea:	1f 91       	pop	r17
    1fec:	0f 91       	pop	r16
    1fee:	08 95       	ret

00001ff0 <xQueueGenericReset>:
    1ff0:	1f 93       	push	r17
    1ff2:	cf 93       	push	r28
    1ff4:	df 93       	push	r29
    1ff6:	61 30       	cpi	r22, 0x01	; 1
    1ff8:	59 f0       	breq	.+22     	; 0x2010 <xQueueGenericReset+0x20>
    1ffa:	fc 01       	movw	r30, r24
    1ffc:	23 89       	ldd	r18, Z+19	; 0x13
    1ffe:	30 85       	ldd	r19, Z+8	; 0x08
    2000:	31 11       	cpse	r19, r1
    2002:	2c c0       	rjmp	.+88     	; 0x205c <xQueueGenericReset+0x6c>
    2004:	11 e0       	ldi	r17, 0x01	; 1
    2006:	21 11       	cpse	r18, r1
    2008:	10 e0       	ldi	r17, 0x00	; 0
    200a:	21 11       	cpse	r18, r1
    200c:	28 c0       	rjmp	.+80     	; 0x205e <xQueueGenericReset+0x6e>
    200e:	01 c0       	rjmp	.+2      	; 0x2012 <xQueueGenericReset+0x22>
    2010:	11 e0       	ldi	r17, 0x01	; 1
    2012:	ec 01       	movw	r28, r24
    2014:	48 81       	ld	r20, Y
    2016:	59 81       	ldd	r21, Y+1	; 0x01
    2018:	28 a1       	ldd	r18, Y+32	; 0x20
    201a:	30 e0       	ldi	r19, 0x00	; 0
    201c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    201e:	62 9f       	mul	r22, r18
    2020:	c0 01       	movw	r24, r0
    2022:	63 9f       	mul	r22, r19
    2024:	90 0d       	add	r25, r0
    2026:	11 24       	eor	r1, r1
    2028:	ba 01       	movw	r22, r20
    202a:	68 0f       	add	r22, r24
    202c:	79 1f       	adc	r23, r25
    202e:	6a 83       	std	Y+2, r22	; 0x02
    2030:	7b 83       	std	Y+3, r23	; 0x03
    2032:	1e 8e       	std	Y+30, r1	; 0x1e
    2034:	4c 83       	std	Y+4, r20	; 0x04
    2036:	5d 83       	std	Y+5, r21	; 0x05
    2038:	82 1b       	sub	r24, r18
    203a:	93 0b       	sbc	r25, r19
    203c:	84 0f       	add	r24, r20
    203e:	95 1f       	adc	r25, r21
    2040:	8e 83       	std	Y+6, r24	; 0x06
    2042:	9f 83       	std	Y+7, r25	; 0x07
    2044:	8f ef       	ldi	r24, 0xFF	; 255
    2046:	89 a3       	std	Y+33, r24	; 0x21
    2048:	8a a3       	std	Y+34, r24	; 0x22
    204a:	ce 01       	movw	r24, r28
    204c:	08 96       	adiw	r24, 0x08	; 8
    204e:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    2052:	ce 01       	movw	r24, r28
    2054:	43 96       	adiw	r24, 0x13	; 19
    2056:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    205a:	01 c0       	rjmp	.+2      	; 0x205e <xQueueGenericReset+0x6e>
    205c:	10 e0       	ldi	r17, 0x00	; 0
    205e:	81 2f       	mov	r24, r17
    2060:	df 91       	pop	r29
    2062:	cf 91       	pop	r28
    2064:	1f 91       	pop	r17
    2066:	08 95       	ret

00002068 <xQueueGenericCreate>:
    2068:	0f 93       	push	r16
    206a:	1f 93       	push	r17
    206c:	cf 93       	push	r28
    206e:	df 93       	push	r29
    2070:	88 23       	and	r24, r24
    2072:	01 f1       	breq	.+64     	; 0x20b4 <xQueueGenericCreate+0x4c>
    2074:	06 2f       	mov	r16, r22
    2076:	18 2f       	mov	r17, r24
    2078:	83 e2       	ldi	r24, 0x23	; 35
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	0e 94 4e 0c 	call	0x189c	; 0x189c <pvPortMalloc>
    2080:	ec 01       	movw	r28, r24
    2082:	89 2b       	or	r24, r25
    2084:	c9 f0       	breq	.+50     	; 0x20b8 <xQueueGenericCreate+0x50>
    2086:	10 9f       	mul	r17, r16
    2088:	c0 01       	movw	r24, r0
    208a:	11 24       	eor	r1, r1
    208c:	01 96       	adiw	r24, 0x01	; 1
    208e:	0e 94 4e 0c 	call	0x189c	; 0x189c <pvPortMalloc>
    2092:	88 83       	st	Y, r24
    2094:	99 83       	std	Y+1, r25	; 0x01
    2096:	89 2b       	or	r24, r25
    2098:	39 f0       	breq	.+14     	; 0x20a8 <xQueueGenericCreate+0x40>
    209a:	1f 8f       	std	Y+31, r17	; 0x1f
    209c:	08 a3       	std	Y+32, r16	; 0x20
    209e:	61 e0       	ldi	r22, 0x01	; 1
    20a0:	ce 01       	movw	r24, r28
    20a2:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <xQueueGenericReset>
    20a6:	08 c0       	rjmp	.+16     	; 0x20b8 <xQueueGenericCreate+0x50>
    20a8:	ce 01       	movw	r24, r28
    20aa:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vPortFree>
    20ae:	c0 e0       	ldi	r28, 0x00	; 0
    20b0:	d0 e0       	ldi	r29, 0x00	; 0
    20b2:	02 c0       	rjmp	.+4      	; 0x20b8 <xQueueGenericCreate+0x50>
    20b4:	c0 e0       	ldi	r28, 0x00	; 0
    20b6:	d0 e0       	ldi	r29, 0x00	; 0
    20b8:	ce 01       	movw	r24, r28
    20ba:	df 91       	pop	r29
    20bc:	cf 91       	pop	r28
    20be:	1f 91       	pop	r17
    20c0:	0f 91       	pop	r16
    20c2:	08 95       	ret

000020c4 <xQueueGenericSend>:
    20c4:	af 92       	push	r10
    20c6:	bf 92       	push	r11
    20c8:	cf 92       	push	r12
    20ca:	df 92       	push	r13
    20cc:	ef 92       	push	r14
    20ce:	ff 92       	push	r15
    20d0:	0f 93       	push	r16
    20d2:	1f 93       	push	r17
    20d4:	cf 93       	push	r28
    20d6:	df 93       	push	r29
    20d8:	cd b7       	in	r28, 0x3d	; 61
    20da:	de b7       	in	r29, 0x3e	; 62
    20dc:	29 97       	sbiw	r28, 0x09	; 9
    20de:	cd bf       	out	0x3d, r28	; 61
    20e0:	de bf       	out	0x3e, r29	; 62
    20e2:	7c 01       	movw	r14, r24
    20e4:	5b 01       	movw	r10, r22
    20e6:	2e 83       	std	Y+6, r18	; 0x06
    20e8:	3f 83       	std	Y+7, r19	; 0x07
    20ea:	48 87       	std	Y+8, r20	; 0x08
    20ec:	59 87       	std	Y+9, r21	; 0x09
    20ee:	10 e0       	ldi	r17, 0x00	; 0
    20f0:	6c 01       	movw	r12, r24
    20f2:	88 e0       	ldi	r24, 0x08	; 8
    20f4:	c8 0e       	add	r12, r24
    20f6:	d1 1c       	adc	r13, r1
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	f8 94       	cli
    20fc:	0f 92       	push	r0
    20fe:	f7 01       	movw	r30, r14
    2100:	96 8d       	ldd	r25, Z+30	; 0x1e
    2102:	87 8d       	ldd	r24, Z+31	; 0x1f
    2104:	98 17       	cp	r25, r24
    2106:	a8 f4       	brcc	.+42     	; 0x2132 <xQueueGenericSend+0x6e>
    2108:	40 2f       	mov	r20, r16
    210a:	b5 01       	movw	r22, r10
    210c:	c7 01       	movw	r24, r14
    210e:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <prvCopyDataToQueue>
    2112:	f7 01       	movw	r30, r14
    2114:	83 89       	ldd	r24, Z+19	; 0x13
    2116:	88 23       	and	r24, r24
    2118:	41 f0       	breq	.+16     	; 0x212a <xQueueGenericSend+0x66>
    211a:	c7 01       	movw	r24, r14
    211c:	43 96       	adiw	r24, 0x13	; 19
    211e:	0e 94 28 16 	call	0x2c50	; 0x2c50 <xTaskRemoveFromEventList>
    2122:	81 30       	cpi	r24, 0x01	; 1
    2124:	11 f4       	brne	.+4      	; 0x212a <xQueueGenericSend+0x66>
    2126:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
    212a:	0f 90       	pop	r0
    212c:	0f be       	out	0x3f, r0	; 63
    212e:	81 e0       	ldi	r24, 0x01	; 1
    2130:	56 c0       	rjmp	.+172    	; 0x21de <xQueueGenericSend+0x11a>
    2132:	8e 81       	ldd	r24, Y+6	; 0x06
    2134:	9f 81       	ldd	r25, Y+7	; 0x07
    2136:	a8 85       	ldd	r26, Y+8	; 0x08
    2138:	b9 85       	ldd	r27, Y+9	; 0x09
    213a:	89 2b       	or	r24, r25
    213c:	8a 2b       	or	r24, r26
    213e:	8b 2b       	or	r24, r27
    2140:	21 f4       	brne	.+8      	; 0x214a <xQueueGenericSend+0x86>
    2142:	0f 90       	pop	r0
    2144:	0f be       	out	0x3f, r0	; 63
    2146:	80 e0       	ldi	r24, 0x00	; 0
    2148:	4a c0       	rjmp	.+148    	; 0x21de <xQueueGenericSend+0x11a>
    214a:	11 11       	cpse	r17, r1
    214c:	05 c0       	rjmp	.+10     	; 0x2158 <xQueueGenericSend+0x94>
    214e:	ce 01       	movw	r24, r28
    2150:	01 96       	adiw	r24, 0x01	; 1
    2152:	0e 94 67 16 	call	0x2cce	; 0x2cce <vTaskSetTimeOutState>
    2156:	11 e0       	ldi	r17, 0x01	; 1
    2158:	0f 90       	pop	r0
    215a:	0f be       	out	0x3f, r0	; 63
    215c:	0e 94 62 13 	call	0x26c4	; 0x26c4 <vTaskSuspendAll>
    2160:	0f b6       	in	r0, 0x3f	; 63
    2162:	f8 94       	cli
    2164:	0f 92       	push	r0
    2166:	f7 01       	movw	r30, r14
    2168:	81 a1       	ldd	r24, Z+33	; 0x21
    216a:	8f 3f       	cpi	r24, 0xFF	; 255
    216c:	09 f4       	brne	.+2      	; 0x2170 <xQueueGenericSend+0xac>
    216e:	11 a2       	std	Z+33, r1	; 0x21
    2170:	f7 01       	movw	r30, r14
    2172:	82 a1       	ldd	r24, Z+34	; 0x22
    2174:	8f 3f       	cpi	r24, 0xFF	; 255
    2176:	09 f4       	brne	.+2      	; 0x217a <xQueueGenericSend+0xb6>
    2178:	12 a2       	std	Z+34, r1	; 0x22
    217a:	0f 90       	pop	r0
    217c:	0f be       	out	0x3f, r0	; 63
    217e:	be 01       	movw	r22, r28
    2180:	6a 5f       	subi	r22, 0xFA	; 250
    2182:	7f 4f       	sbci	r23, 0xFF	; 255
    2184:	ce 01       	movw	r24, r28
    2186:	01 96       	adiw	r24, 0x01	; 1
    2188:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <xTaskCheckForTimeOut>
    218c:	81 11       	cpse	r24, r1
    218e:	21 c0       	rjmp	.+66     	; 0x21d2 <xQueueGenericSend+0x10e>
    2190:	0f b6       	in	r0, 0x3f	; 63
    2192:	f8 94       	cli
    2194:	0f 92       	push	r0
    2196:	f7 01       	movw	r30, r14
    2198:	96 8d       	ldd	r25, Z+30	; 0x1e
    219a:	0f 90       	pop	r0
    219c:	0f be       	out	0x3f, r0	; 63
    219e:	87 8d       	ldd	r24, Z+31	; 0x1f
    21a0:	98 13       	cpse	r25, r24
    21a2:	11 c0       	rjmp	.+34     	; 0x21c6 <xQueueGenericSend+0x102>
    21a4:	4e 81       	ldd	r20, Y+6	; 0x06
    21a6:	5f 81       	ldd	r21, Y+7	; 0x07
    21a8:	68 85       	ldd	r22, Y+8	; 0x08
    21aa:	79 85       	ldd	r23, Y+9	; 0x09
    21ac:	c6 01       	movw	r24, r12
    21ae:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <vTaskPlaceOnEventList>
    21b2:	c7 01       	movw	r24, r14
    21b4:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <prvUnlockQueue>
    21b8:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
    21bc:	81 11       	cpse	r24, r1
    21be:	9c cf       	rjmp	.-200    	; 0x20f8 <xQueueGenericSend+0x34>
    21c0:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
    21c4:	99 cf       	rjmp	.-206    	; 0x20f8 <xQueueGenericSend+0x34>
    21c6:	c7 01       	movw	r24, r14
    21c8:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <prvUnlockQueue>
    21cc:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
    21d0:	93 cf       	rjmp	.-218    	; 0x20f8 <xQueueGenericSend+0x34>
    21d2:	c7 01       	movw	r24, r14
    21d4:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <prvUnlockQueue>
    21d8:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
    21dc:	80 e0       	ldi	r24, 0x00	; 0
    21de:	29 96       	adiw	r28, 0x09	; 9
    21e0:	cd bf       	out	0x3d, r28	; 61
    21e2:	de bf       	out	0x3e, r29	; 62
    21e4:	df 91       	pop	r29
    21e6:	cf 91       	pop	r28
    21e8:	1f 91       	pop	r17
    21ea:	0f 91       	pop	r16
    21ec:	ff 90       	pop	r15
    21ee:	ef 90       	pop	r14
    21f0:	df 90       	pop	r13
    21f2:	cf 90       	pop	r12
    21f4:	bf 90       	pop	r11
    21f6:	af 90       	pop	r10
    21f8:	08 95       	ret

000021fa <xQueueGenericReceive>:
    21fa:	af 92       	push	r10
    21fc:	bf 92       	push	r11
    21fe:	cf 92       	push	r12
    2200:	df 92       	push	r13
    2202:	ef 92       	push	r14
    2204:	ff 92       	push	r15
    2206:	0f 93       	push	r16
    2208:	1f 93       	push	r17
    220a:	cf 93       	push	r28
    220c:	df 93       	push	r29
    220e:	cd b7       	in	r28, 0x3d	; 61
    2210:	de b7       	in	r29, 0x3e	; 62
    2212:	29 97       	sbiw	r28, 0x09	; 9
    2214:	cd bf       	out	0x3d, r28	; 61
    2216:	de bf       	out	0x3e, r29	; 62
    2218:	7c 01       	movw	r14, r24
    221a:	5b 01       	movw	r10, r22
    221c:	2e 83       	std	Y+6, r18	; 0x06
    221e:	3f 83       	std	Y+7, r19	; 0x07
    2220:	48 87       	std	Y+8, r20	; 0x08
    2222:	59 87       	std	Y+9, r21	; 0x09
    2224:	10 e0       	ldi	r17, 0x00	; 0
    2226:	6c 01       	movw	r12, r24
    2228:	83 e1       	ldi	r24, 0x13	; 19
    222a:	c8 0e       	add	r12, r24
    222c:	d1 1c       	adc	r13, r1
    222e:	0f b6       	in	r0, 0x3f	; 63
    2230:	f8 94       	cli
    2232:	0f 92       	push	r0
    2234:	f7 01       	movw	r30, r14
    2236:	86 8d       	ldd	r24, Z+30	; 0x1e
    2238:	88 23       	and	r24, r24
    223a:	99 f1       	breq	.+102    	; 0x22a2 <xQueueGenericReceive+0xa8>
    223c:	c6 80       	ldd	r12, Z+6	; 0x06
    223e:	d7 80       	ldd	r13, Z+7	; 0x07
    2240:	b5 01       	movw	r22, r10
    2242:	c7 01       	movw	r24, r14
    2244:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <prvCopyDataFromQueue>
    2248:	01 11       	cpse	r16, r1
    224a:	1a c0       	rjmp	.+52     	; 0x2280 <xQueueGenericReceive+0x86>
    224c:	f7 01       	movw	r30, r14
    224e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2250:	81 50       	subi	r24, 0x01	; 1
    2252:	86 8f       	std	Z+30, r24	; 0x1e
    2254:	80 81       	ld	r24, Z
    2256:	91 81       	ldd	r25, Z+1	; 0x01
    2258:	89 2b       	or	r24, r25
    225a:	29 f4       	brne	.+10     	; 0x2266 <xQueueGenericReceive+0x6c>
    225c:	0e 94 02 17 	call	0x2e04	; 0x2e04 <xTaskGetCurrentTaskHandle>
    2260:	f7 01       	movw	r30, r14
    2262:	82 83       	std	Z+2, r24	; 0x02
    2264:	93 83       	std	Z+3, r25	; 0x03
    2266:	f7 01       	movw	r30, r14
    2268:	80 85       	ldd	r24, Z+8	; 0x08
    226a:	88 23       	and	r24, r24
    226c:	b1 f0       	breq	.+44     	; 0x229a <xQueueGenericReceive+0xa0>
    226e:	c7 01       	movw	r24, r14
    2270:	08 96       	adiw	r24, 0x08	; 8
    2272:	0e 94 28 16 	call	0x2c50	; 0x2c50 <xTaskRemoveFromEventList>
    2276:	81 30       	cpi	r24, 0x01	; 1
    2278:	81 f4       	brne	.+32     	; 0x229a <xQueueGenericReceive+0xa0>
    227a:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
    227e:	0d c0       	rjmp	.+26     	; 0x229a <xQueueGenericReceive+0xa0>
    2280:	f7 01       	movw	r30, r14
    2282:	c6 82       	std	Z+6, r12	; 0x06
    2284:	d7 82       	std	Z+7, r13	; 0x07
    2286:	83 89       	ldd	r24, Z+19	; 0x13
    2288:	88 23       	and	r24, r24
    228a:	39 f0       	breq	.+14     	; 0x229a <xQueueGenericReceive+0xa0>
    228c:	c7 01       	movw	r24, r14
    228e:	43 96       	adiw	r24, 0x13	; 19
    2290:	0e 94 28 16 	call	0x2c50	; 0x2c50 <xTaskRemoveFromEventList>
    2294:	81 11       	cpse	r24, r1
    2296:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
    229a:	0f 90       	pop	r0
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	81 e0       	ldi	r24, 0x01	; 1
    22a0:	62 c0       	rjmp	.+196    	; 0x2366 <xQueueGenericReceive+0x16c>
    22a2:	8e 81       	ldd	r24, Y+6	; 0x06
    22a4:	9f 81       	ldd	r25, Y+7	; 0x07
    22a6:	a8 85       	ldd	r26, Y+8	; 0x08
    22a8:	b9 85       	ldd	r27, Y+9	; 0x09
    22aa:	89 2b       	or	r24, r25
    22ac:	8a 2b       	or	r24, r26
    22ae:	8b 2b       	or	r24, r27
    22b0:	21 f4       	brne	.+8      	; 0x22ba <xQueueGenericReceive+0xc0>
    22b2:	0f 90       	pop	r0
    22b4:	0f be       	out	0x3f, r0	; 63
    22b6:	80 e0       	ldi	r24, 0x00	; 0
    22b8:	56 c0       	rjmp	.+172    	; 0x2366 <xQueueGenericReceive+0x16c>
    22ba:	11 11       	cpse	r17, r1
    22bc:	05 c0       	rjmp	.+10     	; 0x22c8 <xQueueGenericReceive+0xce>
    22be:	ce 01       	movw	r24, r28
    22c0:	01 96       	adiw	r24, 0x01	; 1
    22c2:	0e 94 67 16 	call	0x2cce	; 0x2cce <vTaskSetTimeOutState>
    22c6:	11 e0       	ldi	r17, 0x01	; 1
    22c8:	0f 90       	pop	r0
    22ca:	0f be       	out	0x3f, r0	; 63
    22cc:	0e 94 62 13 	call	0x26c4	; 0x26c4 <vTaskSuspendAll>
    22d0:	0f b6       	in	r0, 0x3f	; 63
    22d2:	f8 94       	cli
    22d4:	0f 92       	push	r0
    22d6:	f7 01       	movw	r30, r14
    22d8:	81 a1       	ldd	r24, Z+33	; 0x21
    22da:	8f 3f       	cpi	r24, 0xFF	; 255
    22dc:	09 f4       	brne	.+2      	; 0x22e0 <xQueueGenericReceive+0xe6>
    22de:	11 a2       	std	Z+33, r1	; 0x21
    22e0:	f7 01       	movw	r30, r14
    22e2:	82 a1       	ldd	r24, Z+34	; 0x22
    22e4:	8f 3f       	cpi	r24, 0xFF	; 255
    22e6:	09 f4       	brne	.+2      	; 0x22ea <xQueueGenericReceive+0xf0>
    22e8:	12 a2       	std	Z+34, r1	; 0x22
    22ea:	0f 90       	pop	r0
    22ec:	0f be       	out	0x3f, r0	; 63
    22ee:	be 01       	movw	r22, r28
    22f0:	6a 5f       	subi	r22, 0xFA	; 250
    22f2:	7f 4f       	sbci	r23, 0xFF	; 255
    22f4:	ce 01       	movw	r24, r28
    22f6:	01 96       	adiw	r24, 0x01	; 1
    22f8:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <xTaskCheckForTimeOut>
    22fc:	81 11       	cpse	r24, r1
    22fe:	2d c0       	rjmp	.+90     	; 0x235a <xQueueGenericReceive+0x160>
    2300:	0f b6       	in	r0, 0x3f	; 63
    2302:	f8 94       	cli
    2304:	0f 92       	push	r0
    2306:	f7 01       	movw	r30, r14
    2308:	86 8d       	ldd	r24, Z+30	; 0x1e
    230a:	0f 90       	pop	r0
    230c:	0f be       	out	0x3f, r0	; 63
    230e:	81 11       	cpse	r24, r1
    2310:	1e c0       	rjmp	.+60     	; 0x234e <xQueueGenericReceive+0x154>
    2312:	80 81       	ld	r24, Z
    2314:	91 81       	ldd	r25, Z+1	; 0x01
    2316:	89 2b       	or	r24, r25
    2318:	49 f4       	brne	.+18     	; 0x232c <xQueueGenericReceive+0x132>
    231a:	0f b6       	in	r0, 0x3f	; 63
    231c:	f8 94       	cli
    231e:	0f 92       	push	r0
    2320:	82 81       	ldd	r24, Z+2	; 0x02
    2322:	93 81       	ldd	r25, Z+3	; 0x03
    2324:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <vTaskPriorityInherit>
    2328:	0f 90       	pop	r0
    232a:	0f be       	out	0x3f, r0	; 63
    232c:	4e 81       	ldd	r20, Y+6	; 0x06
    232e:	5f 81       	ldd	r21, Y+7	; 0x07
    2330:	68 85       	ldd	r22, Y+8	; 0x08
    2332:	79 85       	ldd	r23, Y+9	; 0x09
    2334:	c6 01       	movw	r24, r12
    2336:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <vTaskPlaceOnEventList>
    233a:	c7 01       	movw	r24, r14
    233c:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <prvUnlockQueue>
    2340:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
    2344:	81 11       	cpse	r24, r1
    2346:	73 cf       	rjmp	.-282    	; 0x222e <xQueueGenericReceive+0x34>
    2348:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
    234c:	70 cf       	rjmp	.-288    	; 0x222e <xQueueGenericReceive+0x34>
    234e:	c7 01       	movw	r24, r14
    2350:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <prvUnlockQueue>
    2354:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
    2358:	6a cf       	rjmp	.-300    	; 0x222e <xQueueGenericReceive+0x34>
    235a:	c7 01       	movw	r24, r14
    235c:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <prvUnlockQueue>
    2360:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
    2364:	80 e0       	ldi	r24, 0x00	; 0
    2366:	29 96       	adiw	r28, 0x09	; 9
    2368:	cd bf       	out	0x3d, r28	; 61
    236a:	de bf       	out	0x3e, r29	; 62
    236c:	df 91       	pop	r29
    236e:	cf 91       	pop	r28
    2370:	1f 91       	pop	r17
    2372:	0f 91       	pop	r16
    2374:	ff 90       	pop	r15
    2376:	ef 90       	pop	r14
    2378:	df 90       	pop	r13
    237a:	cf 90       	pop	r12
    237c:	bf 90       	pop	r11
    237e:	af 90       	pop	r10
    2380:	08 95       	ret

00002382 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2382:	0f b6       	in	r0, 0x3f	; 63
    2384:	f8 94       	cli
    2386:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2388:	fc 01       	movw	r30, r24
    238a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    238c:	0f 90       	pop	r0
    238e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2390:	08 95       	ret

00002392 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    2392:	c4 e0       	ldi	r28, 0x04	; 4
    2394:	d1 e3       	ldi	r29, 0x31	; 49
    2396:	88 81       	ld	r24, Y
    2398:	82 30       	cpi	r24, 0x02	; 2
    239a:	e8 f3       	brcs	.-6      	; 0x2396 <prvIdleTask+0x4>
    239c:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
    23a0:	fa cf       	rjmp	.-12     	; 0x2396 <prvIdleTask+0x4>

000023a2 <prvAddCurrentTaskToDelayedList>:
    23a2:	cf 92       	push	r12
    23a4:	df 92       	push	r13
    23a6:	ef 92       	push	r14
    23a8:	ff 92       	push	r15
    23aa:	6b 01       	movw	r12, r22
    23ac:	7c 01       	movw	r14, r24
    23ae:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    23b2:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    23b6:	62 83       	std	Z+2, r22	; 0x02
    23b8:	73 83       	std	Z+3, r23	; 0x03
    23ba:	84 83       	std	Z+4, r24	; 0x04
    23bc:	95 83       	std	Z+5, r25	; 0x05
    23be:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    23c2:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    23c6:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    23ca:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    23ce:	c8 16       	cp	r12, r24
    23d0:	d9 06       	cpc	r13, r25
    23d2:	ea 06       	cpc	r14, r26
    23d4:	fb 06       	cpc	r15, r27
    23d6:	68 f4       	brcc	.+26     	; 0x23f2 <prvAddCurrentTaskToDelayedList+0x50>
    23d8:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    23dc:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    23e0:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <pxOverflowDelayedTaskList>
    23e4:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    23e8:	6e 5f       	subi	r22, 0xFE	; 254
    23ea:	7f 4f       	sbci	r23, 0xFF	; 255
    23ec:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <vListInsert>
    23f0:	21 c0       	rjmp	.+66     	; 0x2434 <prvAddCurrentTaskToDelayedList+0x92>
    23f2:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    23f6:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    23fa:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    23fe:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    2402:	6e 5f       	subi	r22, 0xFE	; 254
    2404:	7f 4f       	sbci	r23, 0xFF	; 255
    2406:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <vListInsert>
    240a:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    240e:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2412:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2416:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    241a:	c8 16       	cp	r12, r24
    241c:	d9 06       	cpc	r13, r25
    241e:	ea 06       	cpc	r14, r26
    2420:	fb 06       	cpc	r15, r27
    2422:	40 f4       	brcc	.+16     	; 0x2434 <prvAddCurrentTaskToDelayedList+0x92>
    2424:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2428:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    242c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2430:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2434:	ff 90       	pop	r15
    2436:	ef 90       	pop	r14
    2438:	df 90       	pop	r13
    243a:	cf 90       	pop	r12
    243c:	08 95       	ret

0000243e <xTaskGenericCreate>:
    243e:	4f 92       	push	r4
    2440:	5f 92       	push	r5
    2442:	6f 92       	push	r6
    2444:	7f 92       	push	r7
    2446:	8f 92       	push	r8
    2448:	9f 92       	push	r9
    244a:	af 92       	push	r10
    244c:	bf 92       	push	r11
    244e:	cf 92       	push	r12
    2450:	df 92       	push	r13
    2452:	ef 92       	push	r14
    2454:	ff 92       	push	r15
    2456:	0f 93       	push	r16
    2458:	1f 93       	push	r17
    245a:	cf 93       	push	r28
    245c:	df 93       	push	r29
    245e:	5c 01       	movw	r10, r24
    2460:	4b 01       	movw	r8, r22
    2462:	3a 01       	movw	r6, r20
    2464:	29 01       	movw	r4, r18
    2466:	88 e2       	ldi	r24, 0x28	; 40
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	0e 94 4e 0c 	call	0x189c	; 0x189c <pvPortMalloc>
    246e:	ec 01       	movw	r28, r24
    2470:	89 2b       	or	r24, r25
    2472:	09 f4       	brne	.+2      	; 0x2476 <xTaskGenericCreate+0x38>
    2474:	d4 c0       	rjmp	.+424    	; 0x261e <xTaskGenericCreate+0x1e0>
    2476:	c1 14       	cp	r12, r1
    2478:	d1 04       	cpc	r13, r1
    247a:	09 f0       	breq	.+2      	; 0x247e <xTaskGenericCreate+0x40>
    247c:	cc c0       	rjmp	.+408    	; 0x2616 <xTaskGenericCreate+0x1d8>
    247e:	c3 01       	movw	r24, r6
    2480:	0e 94 4e 0c 	call	0x189c	; 0x189c <pvPortMalloc>
    2484:	8b 8f       	std	Y+27, r24	; 0x1b
    2486:	9c 8f       	std	Y+28, r25	; 0x1c
    2488:	00 97       	sbiw	r24, 0x00	; 0
    248a:	21 f4       	brne	.+8      	; 0x2494 <xTaskGenericCreate+0x56>
    248c:	ce 01       	movw	r24, r28
    248e:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <vPortFree>
    2492:	c5 c0       	rjmp	.+394    	; 0x261e <xTaskGenericCreate+0x1e0>
    2494:	a3 01       	movw	r20, r6
    2496:	61 e1       	ldi	r22, 0x11	; 17
    2498:	70 e0       	ldi	r23, 0x00	; 0
    249a:	0e 94 06 23 	call	0x460c	; 0x460c <memset>
    249e:	93 01       	movw	r18, r6
    24a0:	21 50       	subi	r18, 0x01	; 1
    24a2:	31 09       	sbc	r19, r1
    24a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    24a6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    24a8:	3c 01       	movw	r6, r24
    24aa:	62 0e       	add	r6, r18
    24ac:	73 1e       	adc	r7, r19
    24ae:	4a e0       	ldi	r20, 0x0A	; 10
    24b0:	50 e0       	ldi	r21, 0x00	; 0
    24b2:	b4 01       	movw	r22, r8
    24b4:	ce 01       	movw	r24, r28
    24b6:	4d 96       	adiw	r24, 0x1d	; 29
    24b8:	0e 94 0d 23 	call	0x461a	; 0x461a <strncpy>
    24bc:	1e a2       	std	Y+38, r1	; 0x26
    24be:	10 2f       	mov	r17, r16
    24c0:	04 30       	cpi	r16, 0x04	; 4
    24c2:	08 f0       	brcs	.+2      	; 0x24c6 <xTaskGenericCreate+0x88>
    24c4:	13 e0       	ldi	r17, 0x03	; 3
    24c6:	1a 8f       	std	Y+26, r17	; 0x1a
    24c8:	1f a3       	std	Y+39, r17	; 0x27
    24ca:	6e 01       	movw	r12, r28
    24cc:	22 e0       	ldi	r18, 0x02	; 2
    24ce:	c2 0e       	add	r12, r18
    24d0:	d1 1c       	adc	r13, r1
    24d2:	c6 01       	movw	r24, r12
    24d4:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <vListInitialiseItem>
    24d8:	ce 01       	movw	r24, r28
    24da:	0e 96       	adiw	r24, 0x0e	; 14
    24dc:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <vListInitialiseItem>
    24e0:	ca 87       	std	Y+10, r28	; 0x0a
    24e2:	db 87       	std	Y+11, r29	; 0x0b
    24e4:	84 e0       	ldi	r24, 0x04	; 4
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    24e8:	a0 e0       	ldi	r26, 0x00	; 0
    24ea:	b0 e0       	ldi	r27, 0x00	; 0
    24ec:	81 1b       	sub	r24, r17
    24ee:	91 09       	sbc	r25, r1
    24f0:	a1 09       	sbc	r26, r1
    24f2:	b1 09       	sbc	r27, r1
    24f4:	8e 87       	std	Y+14, r24	; 0x0e
    24f6:	9f 87       	std	Y+15, r25	; 0x0f
    24f8:	a8 8b       	std	Y+16, r26	; 0x10
    24fa:	b9 8b       	std	Y+17, r27	; 0x11
    24fc:	ce 8b       	std	Y+22, r28	; 0x16
    24fe:	df 8b       	std	Y+23, r29	; 0x17
    2500:	a2 01       	movw	r20, r4
    2502:	b5 01       	movw	r22, r10
    2504:	c3 01       	movw	r24, r6
    2506:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <pxPortInitialiseStack>
    250a:	88 83       	st	Y, r24
    250c:	99 83       	std	Y+1, r25	; 0x01
    250e:	e1 14       	cp	r14, r1
    2510:	f1 04       	cpc	r15, r1
    2512:	19 f0       	breq	.+6      	; 0x251a <xTaskGenericCreate+0xdc>
    2514:	f7 01       	movw	r30, r14
    2516:	c0 83       	st	Z, r28
    2518:	d1 83       	std	Z+1, r29	; 0x01
    251a:	0f b6       	in	r0, 0x3f	; 63
    251c:	f8 94       	cli
    251e:	0f 92       	push	r0
    2520:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    2524:	8f 5f       	subi	r24, 0xFF	; 255
    2526:	80 93 dc 30 	sts	0x30DC, r24	; 0x8030dc <uxCurrentNumberOfTasks>
    252a:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    252e:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2532:	89 2b       	or	r24, r25
    2534:	89 f5       	brne	.+98     	; 0x2598 <xTaskGenericCreate+0x15a>
    2536:	c0 93 30 31 	sts	0x3130, r28	; 0x803130 <pxCurrentTCB>
    253a:	d0 93 31 31 	sts	0x3131, r29	; 0x803131 <pxCurrentTCB+0x1>
    253e:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    2542:	81 30       	cpi	r24, 0x01	; 1
    2544:	c1 f5       	brne	.+112    	; 0x25b6 <xTaskGenericCreate+0x178>
    2546:	84 e0       	ldi	r24, 0x04	; 4
    2548:	91 e3       	ldi	r25, 0x31	; 49
    254a:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    254e:	8f e0       	ldi	r24, 0x0F	; 15
    2550:	91 e3       	ldi	r25, 0x31	; 49
    2552:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    2556:	8a e1       	ldi	r24, 0x1A	; 26
    2558:	91 e3       	ldi	r25, 0x31	; 49
    255a:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    255e:	85 e2       	ldi	r24, 0x25	; 37
    2560:	91 e3       	ldi	r25, 0x31	; 49
    2562:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    2566:	89 ef       	ldi	r24, 0xF9	; 249
    2568:	90 e3       	ldi	r25, 0x30	; 48
    256a:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    256e:	8e ee       	ldi	r24, 0xEE	; 238
    2570:	90 e3       	ldi	r25, 0x30	; 48
    2572:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    2576:	8f ed       	ldi	r24, 0xDF	; 223
    2578:	90 e3       	ldi	r25, 0x30	; 48
    257a:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <vListInitialise>
    257e:	89 ef       	ldi	r24, 0xF9	; 249
    2580:	90 e3       	ldi	r25, 0x30	; 48
    2582:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxDelayedTaskList>
    2586:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxDelayedTaskList+0x1>
    258a:	8e ee       	ldi	r24, 0xEE	; 238
    258c:	90 e3       	ldi	r25, 0x30	; 48
    258e:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <pxOverflowDelayedTaskList>
    2592:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    2596:	0f c0       	rjmp	.+30     	; 0x25b6 <xTaskGenericCreate+0x178>
    2598:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <xSchedulerRunning>
    259c:	81 11       	cpse	r24, r1
    259e:	0b c0       	rjmp	.+22     	; 0x25b6 <xTaskGenericCreate+0x178>
    25a0:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    25a4:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    25a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    25aa:	08 17       	cp	r16, r24
    25ac:	20 f0       	brcs	.+8      	; 0x25b6 <xTaskGenericCreate+0x178>
    25ae:	c0 93 30 31 	sts	0x3130, r28	; 0x803130 <pxCurrentTCB>
    25b2:	d0 93 31 31 	sts	0x3131, r29	; 0x803131 <pxCurrentTCB+0x1>
    25b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    25b8:	90 91 d7 30 	lds	r25, 0x30D7	; 0x8030d7 <uxTopUsedPriority>
    25bc:	98 17       	cp	r25, r24
    25be:	10 f4       	brcc	.+4      	; 0x25c4 <xTaskGenericCreate+0x186>
    25c0:	80 93 d7 30 	sts	0x30D7, r24	; 0x8030d7 <uxTopUsedPriority>
    25c4:	90 91 d0 30 	lds	r25, 0x30D0	; 0x8030d0 <uxTaskNumber>
    25c8:	9f 5f       	subi	r25, 0xFF	; 255
    25ca:	90 93 d0 30 	sts	0x30D0, r25	; 0x8030d0 <uxTaskNumber>
    25ce:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    25d2:	98 17       	cp	r25, r24
    25d4:	10 f4       	brcc	.+4      	; 0x25da <xTaskGenericCreate+0x19c>
    25d6:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    25da:	fb e0       	ldi	r31, 0x0B	; 11
    25dc:	8f 9f       	mul	r24, r31
    25de:	c0 01       	movw	r24, r0
    25e0:	11 24       	eor	r1, r1
    25e2:	b6 01       	movw	r22, r12
    25e4:	8c 5f       	subi	r24, 0xFC	; 252
    25e6:	9e 4c       	sbci	r25, 0xCE	; 206
    25e8:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vListInsertEnd>
    25ec:	0f 90       	pop	r0
    25ee:	0f be       	out	0x3f, r0	; 63
    25f0:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <xSchedulerRunning>
    25f4:	88 23       	and	r24, r24
    25f6:	59 f0       	breq	.+22     	; 0x260e <xTaskGenericCreate+0x1d0>
    25f8:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    25fc:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2600:	82 8d       	ldd	r24, Z+26	; 0x1a
    2602:	80 17       	cp	r24, r16
    2604:	30 f4       	brcc	.+12     	; 0x2612 <xTaskGenericCreate+0x1d4>
    2606:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
    260a:	81 e0       	ldi	r24, 0x01	; 1
    260c:	09 c0       	rjmp	.+18     	; 0x2620 <xTaskGenericCreate+0x1e2>
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	07 c0       	rjmp	.+14     	; 0x2620 <xTaskGenericCreate+0x1e2>
    2612:	81 e0       	ldi	r24, 0x01	; 1
    2614:	05 c0       	rjmp	.+10     	; 0x2620 <xTaskGenericCreate+0x1e2>
    2616:	cb 8e       	std	Y+27, r12	; 0x1b
    2618:	dc 8e       	std	Y+28, r13	; 0x1c
    261a:	c6 01       	movw	r24, r12
    261c:	3b cf       	rjmp	.-394    	; 0x2494 <xTaskGenericCreate+0x56>
    261e:	8f ef       	ldi	r24, 0xFF	; 255
    2620:	df 91       	pop	r29
    2622:	cf 91       	pop	r28
    2624:	1f 91       	pop	r17
    2626:	0f 91       	pop	r16
    2628:	ff 90       	pop	r15
    262a:	ef 90       	pop	r14
    262c:	df 90       	pop	r13
    262e:	cf 90       	pop	r12
    2630:	bf 90       	pop	r11
    2632:	af 90       	pop	r10
    2634:	9f 90       	pop	r9
    2636:	8f 90       	pop	r8
    2638:	7f 90       	pop	r7
    263a:	6f 90       	pop	r6
    263c:	5f 90       	pop	r5
    263e:	4f 90       	pop	r4
    2640:	08 95       	ret

00002642 <uxTaskPriorityGet>:
    2642:	0f b6       	in	r0, 0x3f	; 63
    2644:	f8 94       	cli
    2646:	0f 92       	push	r0
    2648:	00 97       	sbiw	r24, 0x00	; 0
    264a:	21 f4       	brne	.+8      	; 0x2654 <uxTaskPriorityGet+0x12>
    264c:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2650:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2654:	0f 90       	pop	r0
    2656:	0f be       	out	0x3f, r0	; 63
    2658:	fc 01       	movw	r30, r24
    265a:	82 8d       	ldd	r24, Z+26	; 0x1a
    265c:	08 95       	ret

0000265e <vTaskStartScheduler>:
    265e:	af 92       	push	r10
    2660:	bf 92       	push	r11
    2662:	cf 92       	push	r12
    2664:	df 92       	push	r13
    2666:	ef 92       	push	r14
    2668:	ff 92       	push	r15
    266a:	0f 93       	push	r16
    266c:	a1 2c       	mov	r10, r1
    266e:	b1 2c       	mov	r11, r1
    2670:	c1 2c       	mov	r12, r1
    2672:	d1 2c       	mov	r13, r1
    2674:	0f 2e       	mov	r0, r31
    2676:	fd ed       	ldi	r31, 0xDD	; 221
    2678:	ef 2e       	mov	r14, r31
    267a:	f0 e3       	ldi	r31, 0x30	; 48
    267c:	ff 2e       	mov	r15, r31
    267e:	f0 2d       	mov	r31, r0
    2680:	00 e0       	ldi	r16, 0x00	; 0
    2682:	20 e0       	ldi	r18, 0x00	; 0
    2684:	30 e0       	ldi	r19, 0x00	; 0
    2686:	44 e6       	ldi	r20, 0x64	; 100
    2688:	50 e0       	ldi	r21, 0x00	; 0
    268a:	67 e4       	ldi	r22, 0x47	; 71
    268c:	70 e2       	ldi	r23, 0x20	; 32
    268e:	89 ec       	ldi	r24, 0xC9	; 201
    2690:	91 e1       	ldi	r25, 0x11	; 17
    2692:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskGenericCreate>
    2696:	81 30       	cpi	r24, 0x01	; 1
    2698:	69 f4       	brne	.+26     	; 0x26b4 <vTaskStartScheduler+0x56>
    269a:	f8 94       	cli
    269c:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <xSchedulerRunning>
    26a0:	10 92 d8 30 	sts	0x30D8, r1	; 0x8030d8 <xTickCount>
    26a4:	10 92 d9 30 	sts	0x30D9, r1	; 0x8030d9 <xTickCount+0x1>
    26a8:	10 92 da 30 	sts	0x30DA, r1	; 0x8030da <xTickCount+0x2>
    26ac:	10 92 db 30 	sts	0x30DB, r1	; 0x8030db <xTickCount+0x3>
    26b0:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <xPortStartScheduler>
    26b4:	0f 91       	pop	r16
    26b6:	ff 90       	pop	r15
    26b8:	ef 90       	pop	r14
    26ba:	df 90       	pop	r13
    26bc:	cf 90       	pop	r12
    26be:	bf 90       	pop	r11
    26c0:	af 90       	pop	r10
    26c2:	08 95       	ret

000026c4 <vTaskSuspendAll>:
    26c4:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    26c8:	8f 5f       	subi	r24, 0xFF	; 255
    26ca:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <uxSchedulerSuspended>
    26ce:	08 95       	ret

000026d0 <xTaskGetTickCount>:
    26d0:	0f b6       	in	r0, 0x3f	; 63
    26d2:	f8 94       	cli
    26d4:	0f 92       	push	r0
    26d6:	60 91 d8 30 	lds	r22, 0x30D8	; 0x8030d8 <xTickCount>
    26da:	70 91 d9 30 	lds	r23, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    26de:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount+0x2>
    26e2:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x3>
    26e6:	0f 90       	pop	r0
    26e8:	0f be       	out	0x3f, r0	; 63
    26ea:	08 95       	ret

000026ec <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    26ec:	00 97       	sbiw	r24, 0x00	; 0
    26ee:	21 f4       	brne	.+8      	; 0x26f8 <pcTaskGetTaskName+0xc>
    26f0:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    26f4:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    26f8:	4d 96       	adiw	r24, 0x1d	; 29
    26fa:	08 95       	ret

000026fc <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    26fc:	80 91 dd 30 	lds	r24, 0x30DD	; 0x8030dd <xIdleTaskHandle>
    2700:	90 91 de 30 	lds	r25, 0x30DE	; 0x8030de <xIdleTaskHandle+0x1>
    2704:	08 95       	ret

00002706 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2706:	ff 92       	push	r15
    2708:	0f 93       	push	r16
    270a:	1f 93       	push	r17
    270c:	cf 93       	push	r28
    270e:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2710:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2714:	81 11       	cpse	r24, r1
    2716:	ed c0       	rjmp	.+474    	; 0x28f2 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    2718:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    271c:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2720:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2724:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2728:	01 96       	adiw	r24, 0x01	; 1
    272a:	a1 1d       	adc	r26, r1
    272c:	b1 1d       	adc	r27, r1
    272e:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <xTickCount>
    2732:	90 93 d9 30 	sts	0x30D9, r25	; 0x8030d9 <xTickCount+0x1>
    2736:	a0 93 da 30 	sts	0x30DA, r26	; 0x8030da <xTickCount+0x2>
    273a:	b0 93 db 30 	sts	0x30DB, r27	; 0x8030db <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    273e:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2742:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2746:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    274a:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    274e:	89 2b       	or	r24, r25
    2750:	8a 2b       	or	r24, r26
    2752:	8b 2b       	or	r24, r27
    2754:	f1 f5       	brne	.+124    	; 0x27d2 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2756:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    275a:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    275e:	20 91 ea 30 	lds	r18, 0x30EA	; 0x8030ea <pxOverflowDelayedTaskList>
    2762:	30 91 eb 30 	lds	r19, 0x30EB	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    2766:	20 93 ec 30 	sts	0x30EC, r18	; 0x8030ec <pxDelayedTaskList>
    276a:	30 93 ed 30 	sts	0x30ED, r19	; 0x8030ed <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    276e:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <pxOverflowDelayedTaskList>
    2772:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2776:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    277a:	8f 5f       	subi	r24, 0xFF	; 255
    277c:	80 93 d1 30 	sts	0x30D1, r24	; 0x8030d1 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2780:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    2784:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    2788:	80 81       	ld	r24, Z
    278a:	81 11       	cpse	r24, r1
    278c:	0c c0       	rjmp	.+24     	; 0x27a6 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    278e:	8f ef       	ldi	r24, 0xFF	; 255
    2790:	9f ef       	ldi	r25, 0xFF	; 255
    2792:	dc 01       	movw	r26, r24
    2794:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2798:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    279c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27a0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    27a4:	16 c0       	rjmp	.+44     	; 0x27d2 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    27a6:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    27aa:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    27ae:	07 80       	ldd	r0, Z+7	; 0x07
    27b0:	f0 85       	ldd	r31, Z+8	; 0x08
    27b2:	e0 2d       	mov	r30, r0
    27b4:	00 84       	ldd	r0, Z+8	; 0x08
    27b6:	f1 85       	ldd	r31, Z+9	; 0x09
    27b8:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    27ba:	82 81       	ldd	r24, Z+2	; 0x02
    27bc:	93 81       	ldd	r25, Z+3	; 0x03
    27be:	a4 81       	ldd	r26, Z+4	; 0x04
    27c0:	b5 81       	ldd	r27, Z+5	; 0x05
    27c2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27c6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    27ca:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27ce:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    27d2:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    27d6:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    27da:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    27de:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    27e2:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    27e6:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    27ea:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    27ee:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    27f2:	48 17       	cp	r20, r24
    27f4:	59 07       	cpc	r21, r25
    27f6:	6a 07       	cpc	r22, r26
    27f8:	7b 07       	cpc	r23, r27
    27fa:	08 f4       	brcc	.+2      	; 0x27fe <vTaskIncrementTick+0xf8>
    27fc:	7f c0       	rjmp	.+254    	; 0x28fc <vTaskIncrementTick+0x1f6>
    27fe:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    2802:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    2806:	80 81       	ld	r24, Z
    2808:	88 23       	and	r24, r24
    280a:	f9 f0       	breq	.+62     	; 0x284a <vTaskIncrementTick+0x144>
    280c:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    2810:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    2814:	07 80       	ldd	r0, Z+7	; 0x07
    2816:	f0 85       	ldd	r31, Z+8	; 0x08
    2818:	e0 2d       	mov	r30, r0
    281a:	c0 85       	ldd	r28, Z+8	; 0x08
    281c:	d1 85       	ldd	r29, Z+9	; 0x09
    281e:	8a 81       	ldd	r24, Y+2	; 0x02
    2820:	9b 81       	ldd	r25, Y+3	; 0x03
    2822:	ac 81       	ldd	r26, Y+4	; 0x04
    2824:	bd 81       	ldd	r27, Y+5	; 0x05
    2826:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    282a:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    282e:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    2832:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    2836:	48 17       	cp	r20, r24
    2838:	59 07       	cpc	r21, r25
    283a:	6a 07       	cpc	r22, r26
    283c:	7b 07       	cpc	r23, r27
    283e:	58 f1       	brcs	.+86     	; 0x2896 <vTaskIncrementTick+0x190>
    2840:	0f 2e       	mov	r0, r31
    2842:	fb e0       	ldi	r31, 0x0B	; 11
    2844:	ff 2e       	mov	r15, r31
    2846:	f0 2d       	mov	r31, r0
    2848:	2f c0       	rjmp	.+94     	; 0x28a8 <vTaskIncrementTick+0x1a2>
    284a:	8f ef       	ldi	r24, 0xFF	; 255
    284c:	9f ef       	ldi	r25, 0xFF	; 255
    284e:	dc 01       	movw	r26, r24
    2850:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2854:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2858:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    285c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2860:	4d c0       	rjmp	.+154    	; 0x28fc <vTaskIncrementTick+0x1f6>
    2862:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    2866:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    286a:	07 80       	ldd	r0, Z+7	; 0x07
    286c:	f0 85       	ldd	r31, Z+8	; 0x08
    286e:	e0 2d       	mov	r30, r0
    2870:	c0 85       	ldd	r28, Z+8	; 0x08
    2872:	d1 85       	ldd	r29, Z+9	; 0x09
    2874:	8a 81       	ldd	r24, Y+2	; 0x02
    2876:	9b 81       	ldd	r25, Y+3	; 0x03
    2878:	ac 81       	ldd	r26, Y+4	; 0x04
    287a:	bd 81       	ldd	r27, Y+5	; 0x05
    287c:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    2880:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2884:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    2888:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    288c:	48 17       	cp	r20, r24
    288e:	59 07       	cpc	r21, r25
    2890:	6a 07       	cpc	r22, r26
    2892:	7b 07       	cpc	r23, r27
    2894:	48 f4       	brcc	.+18     	; 0x28a8 <vTaskIncrementTick+0x1a2>
    2896:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    289a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    289e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    28a2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    28a6:	2a c0       	rjmp	.+84     	; 0x28fc <vTaskIncrementTick+0x1f6>
    28a8:	8e 01       	movw	r16, r28
    28aa:	0e 5f       	subi	r16, 0xFE	; 254
    28ac:	1f 4f       	sbci	r17, 0xFF	; 255
    28ae:	c8 01       	movw	r24, r16
    28b0:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>
    28b4:	88 8d       	ldd	r24, Y+24	; 0x18
    28b6:	99 8d       	ldd	r25, Y+25	; 0x19
    28b8:	89 2b       	or	r24, r25
    28ba:	21 f0       	breq	.+8      	; 0x28c4 <vTaskIncrementTick+0x1be>
    28bc:	ce 01       	movw	r24, r28
    28be:	0e 96       	adiw	r24, 0x0e	; 14
    28c0:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>
    28c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28c6:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    28ca:	98 17       	cp	r25, r24
    28cc:	10 f4       	brcc	.+4      	; 0x28d2 <vTaskIncrementTick+0x1cc>
    28ce:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    28d2:	f8 9e       	mul	r15, r24
    28d4:	c0 01       	movw	r24, r0
    28d6:	11 24       	eor	r1, r1
    28d8:	b8 01       	movw	r22, r16
    28da:	8c 5f       	subi	r24, 0xFC	; 252
    28dc:	9e 4c       	sbci	r25, 0xCE	; 206
    28de:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vListInsertEnd>
    28e2:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    28e6:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    28ea:	80 81       	ld	r24, Z
    28ec:	81 11       	cpse	r24, r1
    28ee:	b9 cf       	rjmp	.-142    	; 0x2862 <vTaskIncrementTick+0x15c>
    28f0:	ac cf       	rjmp	.-168    	; 0x284a <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    28f2:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    28f6:	8f 5f       	subi	r24, 0xFF	; 255
    28f8:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    28fc:	df 91       	pop	r29
    28fe:	cf 91       	pop	r28
    2900:	1f 91       	pop	r17
    2902:	0f 91       	pop	r16
    2904:	ff 90       	pop	r15
    2906:	08 95       	ret

00002908 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2908:	cf 92       	push	r12
    290a:	df 92       	push	r13
    290c:	ef 92       	push	r14
    290e:	ff 92       	push	r15
    2910:	0f 93       	push	r16
    2912:	1f 93       	push	r17
    2914:	cf 93       	push	r28
    2916:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2918:	0f b6       	in	r0, 0x3f	; 63
    291a:	f8 94       	cli
    291c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    291e:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2922:	81 50       	subi	r24, 0x01	; 1
    2924:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2928:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    292c:	81 11       	cpse	r24, r1
    292e:	60 c0       	rjmp	.+192    	; 0x29f0 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2930:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    2934:	81 11       	cpse	r24, r1
    2936:	2c c0       	rjmp	.+88     	; 0x2990 <xTaskResumeAll+0x88>
    2938:	5e c0       	rjmp	.+188    	; 0x29f6 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    293a:	d7 01       	movw	r26, r14
    293c:	17 96       	adiw	r26, 0x07	; 7
    293e:	ed 91       	ld	r30, X+
    2940:	fc 91       	ld	r31, X
    2942:	18 97       	sbiw	r26, 0x08	; 8
    2944:	c0 85       	ldd	r28, Z+8	; 0x08
    2946:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2948:	ce 01       	movw	r24, r28
    294a:	0e 96       	adiw	r24, 0x0e	; 14
    294c:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2950:	8e 01       	movw	r16, r28
    2952:	0e 5f       	subi	r16, 0xFE	; 254
    2954:	1f 4f       	sbci	r17, 0xFF	; 255
    2956:	c8 01       	movw	r24, r16
    2958:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    295c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    295e:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2962:	98 17       	cp	r25, r24
    2964:	10 f4       	brcc	.+4      	; 0x296a <xTaskResumeAll+0x62>
    2966:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    296a:	d8 9e       	mul	r13, r24
    296c:	c0 01       	movw	r24, r0
    296e:	11 24       	eor	r1, r1
    2970:	b8 01       	movw	r22, r16
    2972:	8c 5f       	subi	r24, 0xFC	; 252
    2974:	9e 4c       	sbci	r25, 0xCE	; 206
    2976:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    297a:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    297e:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2982:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2984:	82 8d       	ldd	r24, Z+26	; 0x1a
    2986:	98 17       	cp	r25, r24
    2988:	70 f0       	brcs	.+28     	; 0x29a6 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    298a:	cc 24       	eor	r12, r12
    298c:	c3 94       	inc	r12
    298e:	0b c0       	rjmp	.+22     	; 0x29a6 <xTaskResumeAll+0x9e>
    2990:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2992:	0f 2e       	mov	r0, r31
    2994:	ff ed       	ldi	r31, 0xDF	; 223
    2996:	ef 2e       	mov	r14, r31
    2998:	f0 e3       	ldi	r31, 0x30	; 48
    299a:	ff 2e       	mov	r15, r31
    299c:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    299e:	0f 2e       	mov	r0, r31
    29a0:	fb e0       	ldi	r31, 0x0B	; 11
    29a2:	df 2e       	mov	r13, r31
    29a4:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    29a6:	f7 01       	movw	r30, r14
    29a8:	80 81       	ld	r24, Z
    29aa:	81 11       	cpse	r24, r1
    29ac:	c6 cf       	rjmp	.-116    	; 0x293a <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29ae:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    29b2:	88 23       	and	r24, r24
    29b4:	81 f0       	breq	.+32     	; 0x29d6 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29b6:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    29ba:	88 23       	and	r24, r24
    29bc:	99 f0       	breq	.+38     	; 0x29e4 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    29be:	0e 94 83 13 	call	0x2706	; 0x2706 <vTaskIncrementTick>
						--uxMissedTicks;
    29c2:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    29c6:	81 50       	subi	r24, 0x01	; 1
    29c8:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29cc:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    29d0:	81 11       	cpse	r24, r1
    29d2:	f5 cf       	rjmp	.-22     	; 0x29be <xTaskResumeAll+0xb6>
    29d4:	07 c0       	rjmp	.+14     	; 0x29e4 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    29d6:	f1 e0       	ldi	r31, 0x01	; 1
    29d8:	cf 16       	cp	r12, r31
    29da:	21 f0       	breq	.+8      	; 0x29e4 <xTaskResumeAll+0xdc>
    29dc:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <xMissedYield>
    29e0:	81 30       	cpi	r24, 0x01	; 1
    29e2:	41 f4       	brne	.+16     	; 0x29f4 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    29e4:	10 92 d2 30 	sts	0x30D2, r1	; 0x8030d2 <xMissedYield>
					portYIELD_WITHIN_API();
    29e8:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    29ec:	81 e0       	ldi	r24, 0x01	; 1
    29ee:	03 c0       	rjmp	.+6      	; 0x29f6 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    29f0:	80 e0       	ldi	r24, 0x00	; 0
    29f2:	01 c0       	rjmp	.+2      	; 0x29f6 <xTaskResumeAll+0xee>
    29f4:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    29f6:	0f 90       	pop	r0
    29f8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    29fa:	df 91       	pop	r29
    29fc:	cf 91       	pop	r28
    29fe:	1f 91       	pop	r17
    2a00:	0f 91       	pop	r16
    2a02:	ff 90       	pop	r15
    2a04:	ef 90       	pop	r14
    2a06:	df 90       	pop	r13
    2a08:	cf 90       	pop	r12
    2a0a:	08 95       	ret

00002a0c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2a0c:	cf 92       	push	r12
    2a0e:	df 92       	push	r13
    2a10:	ef 92       	push	r14
    2a12:	ff 92       	push	r15
    2a14:	cf 93       	push	r28
    2a16:	df 93       	push	r29
    2a18:	ec 01       	movw	r28, r24
    2a1a:	6a 01       	movw	r12, r20
    2a1c:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2a1e:	0e 94 62 13 	call	0x26c4	; 0x26c4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a22:	88 81       	ld	r24, Y
    2a24:	99 81       	ldd	r25, Y+1	; 0x01
    2a26:	aa 81       	ldd	r26, Y+2	; 0x02
    2a28:	bb 81       	ldd	r27, Y+3	; 0x03
    2a2a:	c8 0e       	add	r12, r24
    2a2c:	d9 1e       	adc	r13, r25
    2a2e:	ea 1e       	adc	r14, r26
    2a30:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2a32:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    2a36:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2a3a:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    2a3e:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    2a42:	48 17       	cp	r20, r24
    2a44:	59 07       	cpc	r21, r25
    2a46:	6a 07       	cpc	r22, r26
    2a48:	7b 07       	cpc	r23, r27
    2a4a:	b8 f4       	brcc	.+46     	; 0x2a7a <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2a4c:	c8 16       	cp	r12, r24
    2a4e:	d9 06       	cpc	r13, r25
    2a50:	ea 06       	cpc	r14, r26
    2a52:	fb 06       	cpc	r15, r27
    2a54:	e0 f5       	brcc	.+120    	; 0x2ace <vTaskDelayUntil+0xc2>
    2a56:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2a5a:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2a5e:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2a62:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2a66:	c8 82       	st	Y, r12
    2a68:	d9 82       	std	Y+1, r13	; 0x01
    2a6a:	ea 82       	std	Y+2, r14	; 0x02
    2a6c:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2a6e:	8c 15       	cp	r24, r12
    2a70:	9d 05       	cpc	r25, r13
    2a72:	ae 05       	cpc	r26, r14
    2a74:	bf 05       	cpc	r27, r15
    2a76:	f8 f4       	brcc	.+62     	; 0x2ab6 <vTaskDelayUntil+0xaa>
    2a78:	13 c0       	rjmp	.+38     	; 0x2aa0 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2a7a:	c8 16       	cp	r12, r24
    2a7c:	d9 06       	cpc	r13, r25
    2a7e:	ea 06       	cpc	r14, r26
    2a80:	fb 06       	cpc	r15, r27
    2a82:	00 f1       	brcs	.+64     	; 0x2ac4 <vTaskDelayUntil+0xb8>
    2a84:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2a88:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2a8c:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2a90:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2a94:	8c 15       	cp	r24, r12
    2a96:	9d 05       	cpc	r25, r13
    2a98:	ae 05       	cpc	r26, r14
    2a9a:	bf 05       	cpc	r27, r15
    2a9c:	98 f0       	brcs	.+38     	; 0x2ac4 <vTaskDelayUntil+0xb8>
    2a9e:	17 c0       	rjmp	.+46     	; 0x2ace <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2aa0:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2aa4:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2aa8:	02 96       	adiw	r24, 0x02	; 2
    2aaa:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2aae:	c7 01       	movw	r24, r14
    2ab0:	b6 01       	movw	r22, r12
    2ab2:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2ab6:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2aba:	81 11       	cpse	r24, r1
    2abc:	0d c0       	rjmp	.+26     	; 0x2ad8 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2abe:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
		}
	}
    2ac2:	0a c0       	rjmp	.+20     	; 0x2ad8 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2ac4:	c8 82       	st	Y, r12
    2ac6:	d9 82       	std	Y+1, r13	; 0x01
    2ac8:	ea 82       	std	Y+2, r14	; 0x02
    2aca:	fb 82       	std	Y+3, r15	; 0x03
    2acc:	e9 cf       	rjmp	.-46     	; 0x2aa0 <vTaskDelayUntil+0x94>
    2ace:	c8 82       	st	Y, r12
    2ad0:	d9 82       	std	Y+1, r13	; 0x01
    2ad2:	ea 82       	std	Y+2, r14	; 0x02
    2ad4:	fb 82       	std	Y+3, r15	; 0x03
    2ad6:	ef cf       	rjmp	.-34     	; 0x2ab6 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2ad8:	df 91       	pop	r29
    2ada:	cf 91       	pop	r28
    2adc:	ff 90       	pop	r15
    2ade:	ef 90       	pop	r14
    2ae0:	df 90       	pop	r13
    2ae2:	cf 90       	pop	r12
    2ae4:	08 95       	ret

00002ae6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2ae6:	cf 92       	push	r12
    2ae8:	df 92       	push	r13
    2aea:	ef 92       	push	r14
    2aec:	ff 92       	push	r15
    2aee:	6b 01       	movw	r12, r22
    2af0:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2af2:	67 2b       	or	r22, r23
    2af4:	68 2b       	or	r22, r24
    2af6:	69 2b       	or	r22, r25
    2af8:	e9 f0       	breq	.+58     	; 0x2b34 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2afa:	0e 94 62 13 	call	0x26c4	; 0x26c4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2afe:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2b02:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2b06:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2b0a:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2b0e:	c8 0e       	add	r12, r24
    2b10:	d9 1e       	adc	r13, r25
    2b12:	ea 1e       	adc	r14, r26
    2b14:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b16:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2b1a:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2b1e:	02 96       	adiw	r24, 0x02	; 2
    2b20:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b24:	c7 01       	movw	r24, r14
    2b26:	b6 01       	movw	r22, r12
    2b28:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b2c:	0e 94 84 14 	call	0x2908	; 0x2908 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b30:	81 11       	cpse	r24, r1
    2b32:	02 c0       	rjmp	.+4      	; 0x2b38 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2b34:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vPortYield>
		}
	}
    2b38:	ff 90       	pop	r15
    2b3a:	ef 90       	pop	r14
    2b3c:	df 90       	pop	r13
    2b3e:	cf 90       	pop	r12
    2b40:	08 95       	ret

00002b42 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2b42:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2b46:	81 11       	cpse	r24, r1
    2b48:	0c c0       	rjmp	.+24     	; 0x2b62 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2b4a:	e0 91 d6 30 	lds	r30, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2b4e:	4b e0       	ldi	r20, 0x0B	; 11
    2b50:	e4 9f       	mul	r30, r20
    2b52:	f0 01       	movw	r30, r0
    2b54:	11 24       	eor	r1, r1
    2b56:	ec 5f       	subi	r30, 0xFC	; 252
    2b58:	fe 4c       	sbci	r31, 0xCE	; 206
    2b5a:	80 81       	ld	r24, Z
    2b5c:	88 23       	and	r24, r24
    2b5e:	29 f0       	breq	.+10     	; 0x2b6a <vTaskSwitchContext+0x28>
    2b60:	14 c0       	rjmp	.+40     	; 0x2b8a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2b62:	81 e0       	ldi	r24, 0x01	; 1
    2b64:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <xMissedYield>
    2b68:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2b6a:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2b6c:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2b70:	81 50       	subi	r24, 0x01	; 1
    2b72:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2b76:	e0 91 d6 30 	lds	r30, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2b7a:	9e 9f       	mul	r25, r30
    2b7c:	f0 01       	movw	r30, r0
    2b7e:	11 24       	eor	r1, r1
    2b80:	ec 5f       	subi	r30, 0xFC	; 252
    2b82:	fe 4c       	sbci	r31, 0xCE	; 206
    2b84:	80 81       	ld	r24, Z
    2b86:	88 23       	and	r24, r24
    2b88:	89 f3       	breq	.-30     	; 0x2b6c <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2b8a:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2b8e:	28 2f       	mov	r18, r24
    2b90:	30 e0       	ldi	r19, 0x00	; 0
    2b92:	4b e0       	ldi	r20, 0x0B	; 11
    2b94:	84 9f       	mul	r24, r20
    2b96:	c0 01       	movw	r24, r0
    2b98:	11 24       	eor	r1, r1
    2b9a:	dc 01       	movw	r26, r24
    2b9c:	ac 5f       	subi	r26, 0xFC	; 252
    2b9e:	be 4c       	sbci	r27, 0xCE	; 206
    2ba0:	11 96       	adiw	r26, 0x01	; 1
    2ba2:	ed 91       	ld	r30, X+
    2ba4:	fc 91       	ld	r31, X
    2ba6:	12 97       	sbiw	r26, 0x02	; 2
    2ba8:	04 80       	ldd	r0, Z+4	; 0x04
    2baa:	f5 81       	ldd	r31, Z+5	; 0x05
    2bac:	e0 2d       	mov	r30, r0
    2bae:	11 96       	adiw	r26, 0x01	; 1
    2bb0:	ed 93       	st	X+, r30
    2bb2:	fc 93       	st	X, r31
    2bb4:	12 97       	sbiw	r26, 0x02	; 2
    2bb6:	89 5f       	subi	r24, 0xF9	; 249
    2bb8:	9e 4c       	sbci	r25, 0xCE	; 206
    2bba:	e8 17       	cp	r30, r24
    2bbc:	f9 07       	cpc	r31, r25
    2bbe:	61 f4       	brne	.+24     	; 0x2bd8 <vTaskSwitchContext+0x96>
    2bc0:	84 81       	ldd	r24, Z+4	; 0x04
    2bc2:	95 81       	ldd	r25, Z+5	; 0x05
    2bc4:	4b e0       	ldi	r20, 0x0B	; 11
    2bc6:	42 9f       	mul	r20, r18
    2bc8:	f0 01       	movw	r30, r0
    2bca:	43 9f       	mul	r20, r19
    2bcc:	f0 0d       	add	r31, r0
    2bce:	11 24       	eor	r1, r1
    2bd0:	ec 5f       	subi	r30, 0xFC	; 252
    2bd2:	fe 4c       	sbci	r31, 0xCE	; 206
    2bd4:	81 83       	std	Z+1, r24	; 0x01
    2bd6:	92 83       	std	Z+2, r25	; 0x02
    2bd8:	8b e0       	ldi	r24, 0x0B	; 11
    2bda:	82 9f       	mul	r24, r18
    2bdc:	f0 01       	movw	r30, r0
    2bde:	83 9f       	mul	r24, r19
    2be0:	f0 0d       	add	r31, r0
    2be2:	11 24       	eor	r1, r1
    2be4:	ec 5f       	subi	r30, 0xFC	; 252
    2be6:	fe 4c       	sbci	r31, 0xCE	; 206
    2be8:	01 80       	ldd	r0, Z+1	; 0x01
    2bea:	f2 81       	ldd	r31, Z+2	; 0x02
    2bec:	e0 2d       	mov	r30, r0
    2bee:	80 85       	ldd	r24, Z+8	; 0x08
    2bf0:	91 85       	ldd	r25, Z+9	; 0x09
    2bf2:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <pxCurrentTCB>
    2bf6:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <pxCurrentTCB+0x1>
    2bfa:	08 95       	ret

00002bfc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2bfc:	cf 92       	push	r12
    2bfe:	df 92       	push	r13
    2c00:	ef 92       	push	r14
    2c02:	ff 92       	push	r15
    2c04:	6a 01       	movw	r12, r20
    2c06:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2c08:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    2c0c:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2c10:	62 5f       	subi	r22, 0xF2	; 242
    2c12:	7f 4f       	sbci	r23, 0xFF	; 255
    2c14:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c18:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2c1c:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2c20:	02 96       	adiw	r24, 0x02	; 2
    2c22:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2c26:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2c2a:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2c2e:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2c32:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2c36:	bc 01       	movw	r22, r24
    2c38:	cd 01       	movw	r24, r26
    2c3a:	6c 0d       	add	r22, r12
    2c3c:	7d 1d       	adc	r23, r13
    2c3e:	8e 1d       	adc	r24, r14
    2c40:	9f 1d       	adc	r25, r15
    2c42:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2c46:	ff 90       	pop	r15
    2c48:	ef 90       	pop	r14
    2c4a:	df 90       	pop	r13
    2c4c:	cf 90       	pop	r12
    2c4e:	08 95       	ret

00002c50 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2c50:	0f 93       	push	r16
    2c52:	1f 93       	push	r17
    2c54:	cf 93       	push	r28
    2c56:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2c58:	dc 01       	movw	r26, r24
    2c5a:	17 96       	adiw	r26, 0x07	; 7
    2c5c:	ed 91       	ld	r30, X+
    2c5e:	fc 91       	ld	r31, X
    2c60:	18 97       	sbiw	r26, 0x08	; 8
    2c62:	c0 85       	ldd	r28, Z+8	; 0x08
    2c64:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2c66:	8e 01       	movw	r16, r28
    2c68:	02 5f       	subi	r16, 0xF2	; 242
    2c6a:	1f 4f       	sbci	r17, 0xFF	; 255
    2c6c:	c8 01       	movw	r24, r16
    2c6e:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2c72:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2c76:	81 11       	cpse	r24, r1
    2c78:	16 c0       	rjmp	.+44     	; 0x2ca6 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2c7a:	0c 50       	subi	r16, 0x0C	; 12
    2c7c:	11 09       	sbc	r17, r1
    2c7e:	c8 01       	movw	r24, r16
    2c80:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2c84:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2c86:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2c8a:	98 17       	cp	r25, r24
    2c8c:	10 f4       	brcc	.+4      	; 0x2c92 <xTaskRemoveFromEventList+0x42>
    2c8e:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    2c92:	bb e0       	ldi	r27, 0x0B	; 11
    2c94:	8b 9f       	mul	r24, r27
    2c96:	c0 01       	movw	r24, r0
    2c98:	11 24       	eor	r1, r1
    2c9a:	b8 01       	movw	r22, r16
    2c9c:	8c 5f       	subi	r24, 0xFC	; 252
    2c9e:	9e 4c       	sbci	r25, 0xCE	; 206
    2ca0:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vListInsertEnd>
    2ca4:	05 c0       	rjmp	.+10     	; 0x2cb0 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2ca6:	b8 01       	movw	r22, r16
    2ca8:	8f ed       	ldi	r24, 0xDF	; 223
    2caa:	90 e3       	ldi	r25, 0x30	; 48
    2cac:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2cb0:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    2cb4:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2cb8:	81 e0       	ldi	r24, 0x01	; 1
    2cba:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2cbc:	92 8d       	ldd	r25, Z+26	; 0x1a
    2cbe:	29 17       	cp	r18, r25
    2cc0:	08 f4       	brcc	.+2      	; 0x2cc4 <xTaskRemoveFromEventList+0x74>
    2cc2:	80 e0       	ldi	r24, 0x00	; 0
}
    2cc4:	df 91       	pop	r29
    2cc6:	cf 91       	pop	r28
    2cc8:	1f 91       	pop	r17
    2cca:	0f 91       	pop	r16
    2ccc:	08 95       	ret

00002cce <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2cce:	20 91 d1 30 	lds	r18, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    2cd2:	fc 01       	movw	r30, r24
    2cd4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2cd6:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    2cda:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2cde:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    2ce2:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    2ce6:	41 83       	std	Z+1, r20	; 0x01
    2ce8:	52 83       	std	Z+2, r21	; 0x02
    2cea:	63 83       	std	Z+3, r22	; 0x03
    2cec:	74 83       	std	Z+4, r23	; 0x04
    2cee:	08 95       	ret

00002cf0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2cf0:	8f 92       	push	r8
    2cf2:	9f 92       	push	r9
    2cf4:	af 92       	push	r10
    2cf6:	bf 92       	push	r11
    2cf8:	cf 92       	push	r12
    2cfa:	df 92       	push	r13
    2cfc:	ef 92       	push	r14
    2cfe:	ff 92       	push	r15
    2d00:	0f 93       	push	r16
    2d02:	1f 93       	push	r17
    2d04:	cf 93       	push	r28
    2d06:	df 93       	push	r29
    2d08:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2d0a:	0f b6       	in	r0, 0x3f	; 63
    2d0c:	f8 94       	cli
    2d0e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2d10:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    2d14:	90 81       	ld	r25, Z
    2d16:	98 17       	cp	r25, r24
    2d18:	89 f0       	breq	.+34     	; 0x2d3c <xTaskCheckForTimeOut+0x4c>
    2d1a:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2d1e:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2d22:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2d26:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2d2a:	01 81       	ldd	r16, Z+1	; 0x01
    2d2c:	12 81       	ldd	r17, Z+2	; 0x02
    2d2e:	23 81       	ldd	r18, Z+3	; 0x03
    2d30:	34 81       	ldd	r19, Z+4	; 0x04
    2d32:	80 17       	cp	r24, r16
    2d34:	91 07       	cpc	r25, r17
    2d36:	a2 07       	cpc	r26, r18
    2d38:	b3 07       	cpc	r27, r19
    2d3a:	a8 f5       	brcc	.+106    	; 0x2da6 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2d3c:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2d40:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2d44:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2d48:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2d4c:	c1 80       	ldd	r12, Z+1	; 0x01
    2d4e:	d2 80       	ldd	r13, Z+2	; 0x02
    2d50:	e3 80       	ldd	r14, Z+3	; 0x03
    2d52:	f4 80       	ldd	r15, Z+4	; 0x04
    2d54:	eb 01       	movw	r28, r22
    2d56:	08 81       	ld	r16, Y
    2d58:	19 81       	ldd	r17, Y+1	; 0x01
    2d5a:	2a 81       	ldd	r18, Y+2	; 0x02
    2d5c:	3b 81       	ldd	r19, Y+3	; 0x03
    2d5e:	8c 19       	sub	r24, r12
    2d60:	9d 09       	sbc	r25, r13
    2d62:	ae 09       	sbc	r26, r14
    2d64:	bf 09       	sbc	r27, r15
    2d66:	80 17       	cp	r24, r16
    2d68:	91 07       	cpc	r25, r17
    2d6a:	a2 07       	cpc	r26, r18
    2d6c:	b3 07       	cpc	r27, r19
    2d6e:	e8 f4       	brcc	.+58     	; 0x2daa <xTaskCheckForTimeOut+0xba>
    2d70:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2d72:	80 90 d8 30 	lds	r8, 0x30D8	; 0x8030d8 <xTickCount>
    2d76:	90 90 d9 30 	lds	r9, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2d7a:	a0 90 da 30 	lds	r10, 0x30DA	; 0x8030da <xTickCount+0x2>
    2d7e:	b0 90 db 30 	lds	r11, 0x30DB	; 0x8030db <xTickCount+0x3>
    2d82:	b5 01       	movw	r22, r10
    2d84:	a4 01       	movw	r20, r8
    2d86:	4c 19       	sub	r20, r12
    2d88:	5d 09       	sbc	r21, r13
    2d8a:	6e 09       	sbc	r22, r14
    2d8c:	7f 09       	sbc	r23, r15
    2d8e:	04 1b       	sub	r16, r20
    2d90:	15 0b       	sbc	r17, r21
    2d92:	26 0b       	sbc	r18, r22
    2d94:	37 0b       	sbc	r19, r23
    2d96:	08 83       	st	Y, r16
    2d98:	19 83       	std	Y+1, r17	; 0x01
    2d9a:	2a 83       	std	Y+2, r18	; 0x02
    2d9c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2d9e:	0e 94 67 16 	call	0x2cce	; 0x2cce <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2da2:	80 e0       	ldi	r24, 0x00	; 0
    2da4:	03 c0       	rjmp	.+6      	; 0x2dac <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2da6:	81 e0       	ldi	r24, 0x01	; 1
    2da8:	01 c0       	rjmp	.+2      	; 0x2dac <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2daa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2dac:	0f 90       	pop	r0
    2dae:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2db0:	df 91       	pop	r29
    2db2:	cf 91       	pop	r28
    2db4:	1f 91       	pop	r17
    2db6:	0f 91       	pop	r16
    2db8:	ff 90       	pop	r15
    2dba:	ef 90       	pop	r14
    2dbc:	df 90       	pop	r13
    2dbe:	cf 90       	pop	r12
    2dc0:	bf 90       	pop	r11
    2dc2:	af 90       	pop	r10
    2dc4:	9f 90       	pop	r9
    2dc6:	8f 90       	pop	r8
    2dc8:	08 95       	ret

00002dca <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2dca:	81 e0       	ldi	r24, 0x01	; 1
    2dcc:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <xMissedYield>
    2dd0:	08 95       	ret

00002dd2 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2dd2:	00 97       	sbiw	r24, 0x00	; 0
    2dd4:	21 f4       	brne	.+8      	; 0x2dde <uxTaskGetStackHighWaterMark+0xc>
    2dd6:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2dda:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2dde:	dc 01       	movw	r26, r24
    2de0:	5b 96       	adiw	r26, 0x1b	; 27
    2de2:	ed 91       	ld	r30, X+
    2de4:	fc 91       	ld	r31, X
    2de6:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2de8:	80 81       	ld	r24, Z
    2dea:	81 31       	cpi	r24, 0x11	; 17
    2dec:	41 f4       	brne	.+16     	; 0x2dfe <uxTaskGetStackHighWaterMark+0x2c>
    2dee:	31 96       	adiw	r30, 0x01	; 1
    2df0:	80 e0       	ldi	r24, 0x00	; 0
    2df2:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2df4:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2df6:	21 91       	ld	r18, Z+
    2df8:	21 31       	cpi	r18, 0x11	; 17
    2dfa:	e1 f3       	breq	.-8      	; 0x2df4 <uxTaskGetStackHighWaterMark+0x22>
    2dfc:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2dfe:	80 e0       	ldi	r24, 0x00	; 0
    2e00:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2e02:	08 95       	ret

00002e04 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2e04:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2e08:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2e0c:	08 95       	ret

00002e0e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2e0e:	0f 93       	push	r16
    2e10:	1f 93       	push	r17
    2e12:	cf 93       	push	r28
    2e14:	df 93       	push	r29
    2e16:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2e18:	22 8d       	ldd	r18, Z+26	; 0x1a
    2e1a:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    2e1e:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2e22:	5a 96       	adiw	r26, 0x1a	; 26
    2e24:	8c 91       	ld	r24, X
    2e26:	28 17       	cp	r18, r24
    2e28:	08 f0       	brcs	.+2      	; 0x2e2c <vTaskPriorityInherit+0x1e>
    2e2a:	41 c0       	rjmp	.+130    	; 0x2eae <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2e2c:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    2e30:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2e34:	5a 96       	adiw	r26, 0x1a	; 26
    2e36:	3c 91       	ld	r19, X
    2e38:	84 e0       	ldi	r24, 0x04	; 4
    2e3a:	90 e0       	ldi	r25, 0x00	; 0
    2e3c:	a0 e0       	ldi	r26, 0x00	; 0
    2e3e:	b0 e0       	ldi	r27, 0x00	; 0
    2e40:	83 1b       	sub	r24, r19
    2e42:	91 09       	sbc	r25, r1
    2e44:	a1 09       	sbc	r26, r1
    2e46:	b1 09       	sbc	r27, r1
    2e48:	86 87       	std	Z+14, r24	; 0x0e
    2e4a:	97 87       	std	Z+15, r25	; 0x0f
    2e4c:	a0 8b       	std	Z+16, r26	; 0x10
    2e4e:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2e50:	8b e0       	ldi	r24, 0x0B	; 11
    2e52:	28 9f       	mul	r18, r24
    2e54:	90 01       	movw	r18, r0
    2e56:	11 24       	eor	r1, r1
    2e58:	2c 5f       	subi	r18, 0xFC	; 252
    2e5a:	3e 4c       	sbci	r19, 0xCE	; 206
    2e5c:	84 85       	ldd	r24, Z+12	; 0x0c
    2e5e:	95 85       	ldd	r25, Z+13	; 0x0d
    2e60:	82 17       	cp	r24, r18
    2e62:	93 07       	cpc	r25, r19
    2e64:	e9 f4       	brne	.+58     	; 0x2ea0 <vTaskPriorityInherit+0x92>
    2e66:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2e68:	ef 01       	movw	r28, r30
    2e6a:	22 96       	adiw	r28, 0x02	; 2
    2e6c:	ce 01       	movw	r24, r28
    2e6e:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2e72:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    2e76:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2e7a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e7c:	f8 01       	movw	r30, r16
    2e7e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2e80:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2e84:	98 17       	cp	r25, r24
    2e86:	10 f4       	brcc	.+4      	; 0x2e8c <vTaskPriorityInherit+0x7e>
    2e88:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    2e8c:	fb e0       	ldi	r31, 0x0B	; 11
    2e8e:	8f 9f       	mul	r24, r31
    2e90:	c0 01       	movw	r24, r0
    2e92:	11 24       	eor	r1, r1
    2e94:	be 01       	movw	r22, r28
    2e96:	8c 5f       	subi	r24, 0xFC	; 252
    2e98:	9e 4c       	sbci	r25, 0xCE	; 206
    2e9a:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vListInsertEnd>
    2e9e:	07 c0       	rjmp	.+14     	; 0x2eae <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2ea0:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    2ea4:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2ea8:	5a 96       	adiw	r26, 0x1a	; 26
    2eaa:	8c 91       	ld	r24, X
    2eac:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2eae:	df 91       	pop	r29
    2eb0:	cf 91       	pop	r28
    2eb2:	1f 91       	pop	r17
    2eb4:	0f 91       	pop	r16
    2eb6:	08 95       	ret

00002eb8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2eb8:	0f 93       	push	r16
    2eba:	1f 93       	push	r17
    2ebc:	cf 93       	push	r28
    2ebe:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2ec0:	00 97       	sbiw	r24, 0x00	; 0
    2ec2:	49 f1       	breq	.+82     	; 0x2f16 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2ec4:	fc 01       	movw	r30, r24
    2ec6:	32 8d       	ldd	r19, Z+26	; 0x1a
    2ec8:	27 a1       	ldd	r18, Z+39	; 0x27
    2eca:	32 17       	cp	r19, r18
    2ecc:	21 f1       	breq	.+72     	; 0x2f16 <vTaskPriorityDisinherit+0x5e>
    2ece:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2ed0:	8c 01       	movw	r16, r24
    2ed2:	0e 5f       	subi	r16, 0xFE	; 254
    2ed4:	1f 4f       	sbci	r17, 0xFF	; 255
    2ed6:	c8 01       	movw	r24, r16
    2ed8:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2edc:	8f a1       	ldd	r24, Y+39	; 0x27
    2ede:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2ee0:	44 e0       	ldi	r20, 0x04	; 4
    2ee2:	50 e0       	ldi	r21, 0x00	; 0
    2ee4:	60 e0       	ldi	r22, 0x00	; 0
    2ee6:	70 e0       	ldi	r23, 0x00	; 0
    2ee8:	48 1b       	sub	r20, r24
    2eea:	51 09       	sbc	r21, r1
    2eec:	61 09       	sbc	r22, r1
    2eee:	71 09       	sbc	r23, r1
    2ef0:	4e 87       	std	Y+14, r20	; 0x0e
    2ef2:	5f 87       	std	Y+15, r21	; 0x0f
    2ef4:	68 8b       	std	Y+16, r22	; 0x10
    2ef6:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2ef8:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2efc:	98 17       	cp	r25, r24
    2efe:	10 f4       	brcc	.+4      	; 0x2f04 <vTaskPriorityDisinherit+0x4c>
    2f00:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    2f04:	fb e0       	ldi	r31, 0x0B	; 11
    2f06:	8f 9f       	mul	r24, r31
    2f08:	c0 01       	movw	r24, r0
    2f0a:	11 24       	eor	r1, r1
    2f0c:	b8 01       	movw	r22, r16
    2f0e:	8c 5f       	subi	r24, 0xFC	; 252
    2f10:	9e 4c       	sbci	r25, 0xCE	; 206
    2f12:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <vListInsertEnd>
			}
		}
	}
    2f16:	df 91       	pop	r29
    2f18:	cf 91       	pop	r28
    2f1a:	1f 91       	pop	r17
    2f1c:	0f 91       	pop	r16
    2f1e:	08 95       	ret

00002f20 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2f20:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2f22:	e8 81       	ld	r30, Y
    2f24:	f9 81       	ldd	r31, Y+1	; 0x01
    2f26:	01 90       	ld	r0, Z+
    2f28:	f0 81       	ld	r31, Z
    2f2a:	e0 2d       	mov	r30, r0
    2f2c:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2f2e:	1a 82       	std	Y+2, r1	; 0x02
    2f30:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2f32:	6f ef       	ldi	r22, 0xFF	; 255
    2f34:	7f ef       	ldi	r23, 0xFF	; 255
    2f36:	cb 01       	movw	r24, r22
    2f38:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <vTaskDelay>
    2f3c:	fa cf       	rjmp	.-12     	; 0x2f32 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002f3e <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2f3e:	fc 01       	movw	r30, r24
    2f40:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2f42:	65 87       	std	Z+13, r22	; 0x0d
    2f44:	08 95       	ret

00002f46 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2f46:	4f 92       	push	r4
    2f48:	5f 92       	push	r5
    2f4a:	6f 92       	push	r6
    2f4c:	7f 92       	push	r7
    2f4e:	8f 92       	push	r8
    2f50:	9f 92       	push	r9
    2f52:	af 92       	push	r10
    2f54:	bf 92       	push	r11
    2f56:	cf 92       	push	r12
    2f58:	df 92       	push	r13
    2f5a:	ef 92       	push	r14
    2f5c:	ff 92       	push	r15
    2f5e:	0f 93       	push	r16
    2f60:	1f 93       	push	r17
    2f62:	cf 93       	push	r28
    2f64:	df 93       	push	r29
    2f66:	cd b7       	in	r28, 0x3d	; 61
    2f68:	de b7       	in	r29, 0x3e	; 62
    2f6a:	2a 97       	sbiw	r28, 0x0a	; 10
    2f6c:	cd bf       	out	0x3d, r28	; 61
    2f6e:	de bf       	out	0x3e, r29	; 62
    2f70:	4c 01       	movw	r8, r24
    2f72:	29 01       	movw	r4, r18
    2f74:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2f76:	80 e5       	ldi	r24, 0x50	; 80
    2f78:	90 e2       	ldi	r25, 0x20	; 32
    2f7a:	f4 01       	movw	r30, r8
    2f7c:	80 83       	st	Z, r24
    2f7e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2f80:	fb 01       	movw	r30, r22
    2f82:	80 81       	ld	r24, Z
    2f84:	88 23       	and	r24, r24
    2f86:	69 f0       	breq	.+26     	; 0x2fa2 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2f88:	de 01       	movw	r26, r28
    2f8a:	11 96       	adiw	r26, 0x01	; 1
    2f8c:	31 96       	adiw	r30, 0x01	; 1
    2f8e:	90 e0       	ldi	r25, 0x00	; 0
    2f90:	02 c0       	rjmp	.+4      	; 0x2f96 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2f92:	99 30       	cpi	r25, 0x09	; 9
    2f94:	39 f0       	breq	.+14     	; 0x2fa4 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2f96:	9f 5f       	subi	r25, 0xFF	; 255
    2f98:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2f9a:	81 91       	ld	r24, Z+
    2f9c:	81 11       	cpse	r24, r1
    2f9e:	f9 cf       	rjmp	.-14     	; 0x2f92 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2fa0:	01 c0       	rjmp	.+2      	; 0x2fa4 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2fa2:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2fa4:	e1 e0       	ldi	r30, 0x01	; 1
    2fa6:	f0 e0       	ldi	r31, 0x00	; 0
    2fa8:	ec 0f       	add	r30, r28
    2faa:	fd 1f       	adc	r31, r29
    2fac:	e9 0f       	add	r30, r25
    2fae:	f1 1d       	adc	r31, r1
    2fb0:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2fb2:	74 01       	movw	r14, r8
    2fb4:	f2 e0       	ldi	r31, 0x02	; 2
    2fb6:	ef 0e       	add	r14, r31
    2fb8:	f1 1c       	adc	r15, r1
    2fba:	a1 2c       	mov	r10, r1
    2fbc:	b1 2c       	mov	r11, r1
    2fbe:	c1 2c       	mov	r12, r1
    2fc0:	d1 2c       	mov	r13, r1
    2fc2:	04 2f       	mov	r16, r20
    2fc4:	94 01       	movw	r18, r8
    2fc6:	a2 01       	movw	r20, r4
    2fc8:	be 01       	movw	r22, r28
    2fca:	6f 5f       	subi	r22, 0xFF	; 255
    2fcc:	7f 4f       	sbci	r23, 0xFF	; 255
    2fce:	82 e9       	ldi	r24, 0x92	; 146
    2fd0:	93 e0       	ldi	r25, 0x03	; 3
    2fd2:	0e 94 1f 12 	call	0x243e	; 0x243e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2fd6:	f4 01       	movw	r30, r8
    2fd8:	66 82       	std	Z+6, r6	; 0x06
    2fda:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2fdc:	40 86       	std	Z+8, r4	; 0x08
    2fde:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2fe0:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <last_created_task_pointer>
    2fe4:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    2fe8:	24 83       	std	Z+4, r18	; 0x04
    2fea:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2fec:	80 92 32 31 	sts	0x3132, r8	; 0x803132 <last_created_task_pointer>
    2ff0:	90 92 33 31 	sts	0x3133, r9	; 0x803133 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2ff4:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2ff6:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2ff8:	40 90 70 31 	lds	r4, 0x3170	; 0x803170 <portStackTopForTask>
    2ffc:	50 90 71 31 	lds	r5, 0x3171	; 0x803171 <portStackTopForTask+0x1>
    3000:	ff ef       	ldi	r31, 0xFF	; 255
    3002:	4f 1a       	sub	r4, r31
    3004:	5f 0a       	sbc	r5, r31
    3006:	40 92 70 31 	sts	0x3170, r4	; 0x803170 <portStackTopForTask>
    300a:	50 92 71 31 	sts	0x3171, r5	; 0x803171 <portStackTopForTask+0x1>
    300e:	f4 01       	movw	r30, r8
    3010:	42 86       	std	Z+10, r4	; 0x0a
    3012:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    3014:	16 86       	std	Z+14, r1	; 0x0e
    3016:	17 86       	std	Z+15, r1	; 0x0f
    3018:	10 8a       	std	Z+16, r1	; 0x10
    301a:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    301c:	61 14       	cp	r6, r1
    301e:	71 04       	cpc	r7, r1
    3020:	09 f4       	brne	.+2      	; 0x3024 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3022:	44 c0       	rjmp	.+136    	; 0x30ac <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    3024:	81 30       	cpi	r24, 0x01	; 1
    3026:	79 f5       	brne	.+94     	; 0x3086 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    3028:	6a e0       	ldi	r22, 0x0A	; 10
    302a:	c3 01       	movw	r24, r6
    302c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3030:	7c 01       	movw	r14, r24
    3032:	60 e7       	ldi	r22, 0x70	; 112
    3034:	76 e0       	ldi	r23, 0x06	; 6
    3036:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    303a:	be 01       	movw	r22, r28
    303c:	6f 5f       	subi	r22, 0xFF	; 255
    303e:	7f 4f       	sbci	r23, 0xFF	; 255
    3040:	c7 01       	movw	r24, r14
    3042:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    3046:	6a e0       	ldi	r22, 0x0A	; 10
    3048:	c7 01       	movw	r24, r14
    304a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    304e:	7c 01       	movw	r14, r24
    3050:	67 e6       	ldi	r22, 0x67	; 103
    3052:	76 e0       	ldi	r23, 0x06	; 6
    3054:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    3058:	6a e0       	ldi	r22, 0x0A	; 10
    305a:	c7 01       	movw	r24, r14
    305c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3060:	7c 01       	movw	r14, r24
    3062:	69 e5       	ldi	r22, 0x59	; 89
    3064:	76 e0       	ldi	r23, 0x06	; 6
    3066:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    306a:	63 e0       	ldi	r22, 0x03	; 3
    306c:	c7 01       	movw	r24, r14
    306e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3072:	b2 01       	movw	r22, r4
    3074:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <_ZN8emstreamlsEj>
    3078:	62 e0       	ldi	r22, 0x02	; 2
    307a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    307e:	66 e0       	ldi	r22, 0x06	; 6
    3080:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3084:	13 c0       	rjmp	.+38     	; 0x30ac <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    3086:	6a e0       	ldi	r22, 0x0A	; 10
    3088:	c3 01       	movw	r24, r6
    308a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    308e:	4c 01       	movw	r8, r24
    3090:	64 e4       	ldi	r22, 0x44	; 68
    3092:	76 e0       	ldi	r23, 0x06	; 6
    3094:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    3098:	be 01       	movw	r22, r28
    309a:	6f 5f       	subi	r22, 0xFF	; 255
    309c:	7f 4f       	sbci	r23, 0xFF	; 255
    309e:	c4 01       	movw	r24, r8
    30a0:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    30a4:	66 e0       	ldi	r22, 0x06	; 6
    30a6:	c4 01       	movw	r24, r8
    30a8:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    30ac:	2a 96       	adiw	r28, 0x0a	; 10
    30ae:	cd bf       	out	0x3d, r28	; 61
    30b0:	de bf       	out	0x3e, r29	; 62
    30b2:	df 91       	pop	r29
    30b4:	cf 91       	pop	r28
    30b6:	1f 91       	pop	r17
    30b8:	0f 91       	pop	r16
    30ba:	ff 90       	pop	r15
    30bc:	ef 90       	pop	r14
    30be:	df 90       	pop	r13
    30c0:	cf 90       	pop	r12
    30c2:	bf 90       	pop	r11
    30c4:	af 90       	pop	r10
    30c6:	9f 90       	pop	r9
    30c8:	8f 90       	pop	r8
    30ca:	7f 90       	pop	r7
    30cc:	6f 90       	pop	r6
    30ce:	5f 90       	pop	r5
    30d0:	4f 90       	pop	r4
    30d2:	08 95       	ret

000030d4 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    30d4:	cf 92       	push	r12
    30d6:	df 92       	push	r13
    30d8:	ef 92       	push	r14
    30da:	ff 92       	push	r15
    30dc:	0f 93       	push	r16
    30de:	1f 93       	push	r17
    30e0:	cf 93       	push	r28
    30e2:	df 93       	push	r29
    30e4:	ec 01       	movw	r28, r24
    30e6:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    30e8:	8a 81       	ldd	r24, Y+2	; 0x02
    30ea:	9b 81       	ldd	r25, Y+3	; 0x03
    30ec:	0e 94 76 13 	call	0x26ec	; 0x26ec <pcTaskGetTaskName>
    30f0:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    30f2:	6a e0       	ldi	r22, 0x0A	; 10
    30f4:	c7 01       	movw	r24, r14
    30f6:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    30fa:	8c 01       	movw	r16, r24
    30fc:	63 e8       	ldi	r22, 0x83	; 131
    30fe:	76 e0       	ldi	r23, 0x06	; 6
    3100:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    3104:	6a e0       	ldi	r22, 0x0A	; 10
    3106:	c8 01       	movw	r24, r16
    3108:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    310c:	8c 01       	movw	r16, r24
    310e:	6c e7       	ldi	r22, 0x7C	; 124
    3110:	76 e0       	ldi	r23, 0x06	; 6
    3112:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    3116:	b6 01       	movw	r22, r12
    3118:	c8 01       	movw	r24, r16
    311a:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    311e:	6a e0       	ldi	r22, 0x0A	; 10
    3120:	c8 01       	movw	r24, r16
    3122:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3126:	8c 01       	movw	r16, r24
    3128:	66 e7       	ldi	r22, 0x76	; 118
    312a:	76 e0       	ldi	r23, 0x06	; 6
    312c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    3130:	66 e0       	ldi	r22, 0x06	; 6
    3132:	c8 01       	movw	r24, r16
    3134:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    3138:	8a 85       	ldd	r24, Y+10	; 0x0a
    313a:	9b 85       	ldd	r25, Y+11	; 0x0b
    313c:	e8 85       	ldd	r30, Y+8	; 0x08
    313e:	f9 85       	ldd	r31, Y+9	; 0x09
    3140:	01 e1       	ldi	r16, 0x11	; 17
    3142:	21 e0       	ldi	r18, 0x01	; 1
    3144:	a7 01       	movw	r20, r14
    3146:	bc 01       	movw	r22, r24
    3148:	8e 1b       	sub	r24, r30
    314a:	9f 0b       	sbc	r25, r31
    314c:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    3150:	8c 81       	ldd	r24, Y+4	; 0x04
    3152:	9d 81       	ldd	r25, Y+5	; 0x05
    3154:	00 97       	sbiw	r24, 0x00	; 0
    3156:	19 f0       	breq	.+6      	; 0x315e <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    3158:	b7 01       	movw	r22, r14
    315a:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    315e:	df 91       	pop	r29
    3160:	cf 91       	pop	r28
    3162:	1f 91       	pop	r17
    3164:	0f 91       	pop	r16
    3166:	ff 90       	pop	r15
    3168:	ef 90       	pop	r14
    316a:	df 90       	pop	r13
    316c:	cf 90       	pop	r12
    316e:	08 95       	ret

00003170 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3170:	0f 93       	push	r16
    3172:	1f 93       	push	r17
    3174:	cf 93       	push	r28
    3176:	df 93       	push	r29
    3178:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    317a:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <last_created_task_pointer>
    317e:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    3182:	00 97       	sbiw	r24, 0x00	; 0
    3184:	19 f0       	breq	.+6      	; 0x318c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3186:	be 01       	movw	r22, r28
    3188:	0e 94 6a 18 	call	0x30d4	; 0x30d4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    318c:	6a e0       	ldi	r22, 0x0A	; 10
    318e:	ce 01       	movw	r24, r28
    3190:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3194:	8c 01       	movw	r16, r24
    3196:	69 e9       	ldi	r22, 0x99	; 153
    3198:	76 e0       	ldi	r23, 0x06	; 6
    319a:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    319e:	6a e0       	ldi	r22, 0x0A	; 10
    31a0:	c8 01       	movw	r24, r16
    31a2:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    31a6:	8c 01       	movw	r16, r24
    31a8:	6e e8       	ldi	r22, 0x8E	; 142
    31aa:	76 e0       	ldi	r23, 0x06	; 6
    31ac:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    31b0:	6a e0       	ldi	r22, 0x0A	; 10
    31b2:	c8 01       	movw	r24, r16
    31b4:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    31b8:	8c 01       	movw	r16, r24
    31ba:	68 e8       	ldi	r22, 0x88	; 136
    31bc:	76 e0       	ldi	r23, 0x06	; 6
    31be:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    31c2:	66 e0       	ldi	r22, 0x06	; 6
    31c4:	c8 01       	movw	r24, r16
    31c6:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    31ca:	80 91 70 31 	lds	r24, 0x3170	; 0x803170 <portStackTopForTask>
    31ce:	90 91 71 31 	lds	r25, 0x3171	; 0x803171 <portStackTopForTask+0x1>
    31d2:	bc 01       	movw	r22, r24
    31d4:	6f 5f       	subi	r22, 0xFF	; 255
    31d6:	7f 4f       	sbci	r23, 0xFF	; 255
    31d8:	01 e1       	ldi	r16, 0x11	; 17
    31da:	21 e0       	ldi	r18, 0x01	; 1
    31dc:	ae 01       	movw	r20, r28
    31de:	83 56       	subi	r24, 0x63	; 99
    31e0:	91 09       	sbc	r25, r1
    31e2:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    31e6:	df 91       	pop	r29
    31e8:	cf 91       	pop	r28
    31ea:	1f 91       	pop	r17
    31ec:	0f 91       	pop	r16
    31ee:	08 95       	ret

000031f0 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    31f0:	8f 92       	push	r8
    31f2:	9f 92       	push	r9
    31f4:	af 92       	push	r10
    31f6:	bf 92       	push	r11
    31f8:	cf 92       	push	r12
    31fa:	df 92       	push	r13
    31fc:	ef 92       	push	r14
    31fe:	ff 92       	push	r15
    3200:	0f 93       	push	r16
    3202:	1f 93       	push	r17
    3204:	cf 93       	push	r28
    3206:	df 93       	push	r29
    3208:	ec 01       	movw	r28, r24
    320a:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    320c:	8a 81       	ldd	r24, Y+2	; 0x02
    320e:	9b 81       	ldd	r25, Y+3	; 0x03
    3210:	0e 94 76 13 	call	0x26ec	; 0x26ec <pcTaskGetTaskName>
    3214:	bc 01       	movw	r22, r24
    3216:	c8 01       	movw	r24, r16
    3218:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    321c:	d8 01       	movw	r26, r16
    321e:	ed 91       	ld	r30, X+
    3220:	fc 91       	ld	r31, X
    3222:	02 80       	ldd	r0, Z+2	; 0x02
    3224:	f3 81       	ldd	r31, Z+3	; 0x03
    3226:	e0 2d       	mov	r30, r0
    3228:	69 e0       	ldi	r22, 0x09	; 9
    322a:	c8 01       	movw	r24, r16
    322c:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    322e:	8a 81       	ldd	r24, Y+2	; 0x02
    3230:	9b 81       	ldd	r25, Y+3	; 0x03
    3232:	0e 94 76 13 	call	0x26ec	; 0x26ec <pcTaskGetTaskName>
    3236:	fc 01       	movw	r30, r24
    3238:	01 90       	ld	r0, Z+
    323a:	00 20       	and	r0, r0
    323c:	e9 f7       	brne	.-6      	; 0x3238 <_ZN8frt_task12print_statusER8emstream+0x48>
    323e:	31 97       	sbiw	r30, 0x01	; 1
    3240:	e8 1b       	sub	r30, r24
    3242:	f9 0b       	sbc	r31, r25
    3244:	38 97       	sbiw	r30, 0x08	; 8
    3246:	48 f4       	brcc	.+18     	; 0x325a <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    3248:	d8 01       	movw	r26, r16
    324a:	ed 91       	ld	r30, X+
    324c:	fc 91       	ld	r31, X
    324e:	02 80       	ldd	r0, Z+2	; 0x02
    3250:	f3 81       	ldd	r31, Z+3	; 0x03
    3252:	e0 2d       	mov	r30, r0
    3254:	69 e0       	ldi	r22, 0x09	; 9
    3256:	c8 01       	movw	r24, r16
    3258:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    325a:	ce 84       	ldd	r12, Y+14	; 0x0e
    325c:	df 84       	ldd	r13, Y+15	; 0x0f
    325e:	e8 88       	ldd	r14, Y+16	; 0x10
    3260:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    3262:	a8 84       	ldd	r10, Y+8	; 0x08
    3264:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3266:	8a 81       	ldd	r24, Y+2	; 0x02
    3268:	9b 81       	ldd	r25, Y+3	; 0x03
    326a:	0e 94 e9 16 	call	0x2dd2	; 0x2dd2 <uxTaskGetStackHighWaterMark>
    326e:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3270:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3272:	8a 81       	ldd	r24, Y+2	; 0x02
    3274:	9b 81       	ldd	r25, Y+3	; 0x03
    3276:	0e 94 21 13 	call	0x2642	; 0x2642 <uxTaskPriorityGet>
    327a:	68 2f       	mov	r22, r24
    327c:	c8 01       	movw	r24, r16
    327e:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
    3282:	6a e0       	ldi	r22, 0x0A	; 10
    3284:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3288:	ec 01       	movw	r28, r24
    328a:	6e e0       	ldi	r22, 0x0E	; 14
    328c:	77 e0       	ldi	r23, 0x07	; 7
    328e:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3292:	68 2d       	mov	r22, r8
    3294:	ce 01       	movw	r24, r28
    3296:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    329a:	6a e0       	ldi	r22, 0x0A	; 10
    329c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    32a0:	ec 01       	movw	r28, r24
    32a2:	6c e0       	ldi	r22, 0x0C	; 12
    32a4:	77 e0       	ldi	r23, 0x07	; 7
    32a6:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    32aa:	69 2d       	mov	r22, r9
    32ac:	ce 01       	movw	r24, r28
    32ae:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
    32b2:	6a e0       	ldi	r22, 0x0A	; 10
    32b4:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    32b8:	ec 01       	movw	r28, r24
    32ba:	6a e0       	ldi	r22, 0x0A	; 10
    32bc:	77 e0       	ldi	r23, 0x07	; 7
    32be:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    32c2:	b5 01       	movw	r22, r10
    32c4:	ce 01       	movw	r24, r28
    32c6:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <_ZN8emstreamlsEj>
    32ca:	6a e0       	ldi	r22, 0x0A	; 10
    32cc:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    32d0:	ec 01       	movw	r28, r24
    32d2:	68 e0       	ldi	r22, 0x08	; 8
    32d4:	77 e0       	ldi	r23, 0x07	; 7
    32d6:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    32da:	6a e0       	ldi	r22, 0x0A	; 10
    32dc:	ce 01       	movw	r24, r28
    32de:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    32e2:	ec 01       	movw	r28, r24
    32e4:	66 e0       	ldi	r22, 0x06	; 6
    32e6:	77 e0       	ldi	r23, 0x07	; 7
    32e8:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    32ec:	b7 01       	movw	r22, r14
    32ee:	a6 01       	movw	r20, r12
    32f0:	ce 01       	movw	r24, r28
    32f2:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <_ZN8emstreamlsEm>
}
    32f6:	df 91       	pop	r29
    32f8:	cf 91       	pop	r28
    32fa:	1f 91       	pop	r17
    32fc:	0f 91       	pop	r16
    32fe:	ff 90       	pop	r15
    3300:	ef 90       	pop	r14
    3302:	df 90       	pop	r13
    3304:	cf 90       	pop	r12
    3306:	bf 90       	pop	r11
    3308:	af 90       	pop	r10
    330a:	9f 90       	pop	r9
    330c:	8f 90       	pop	r8
    330e:	08 95       	ret

00003310 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3310:	cf 93       	push	r28
    3312:	df 93       	push	r29
    3314:	ec 01       	movw	r28, r24
    3316:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    3318:	db 01       	movw	r26, r22
    331a:	ed 91       	ld	r30, X+
    331c:	fc 91       	ld	r31, X
    331e:	02 80       	ldd	r0, Z+2	; 0x02
    3320:	f3 81       	ldd	r31, Z+3	; 0x03
    3322:	e0 2d       	mov	r30, r0
    3324:	be 01       	movw	r22, r28
    3326:	19 95       	eicall
	return (ser_dev);
}
    3328:	ce 01       	movw	r24, r28
    332a:	df 91       	pop	r29
    332c:	cf 91       	pop	r28
    332e:	08 95       	ret

00003330 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3330:	0f 93       	push	r16
    3332:	1f 93       	push	r17
    3334:	cf 93       	push	r28
    3336:	df 93       	push	r29
    3338:	ec 01       	movw	r28, r24
    333a:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    333c:	bc 01       	movw	r22, r24
    333e:	c8 01       	movw	r24, r16
    3340:	0e 94 88 19 	call	0x3310	; 0x3310 <_ZlsR8emstreamR8frt_task>
    3344:	66 e0       	ldi	r22, 0x06	; 6
    3346:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    334a:	8c 81       	ldd	r24, Y+4	; 0x04
    334c:	9d 81       	ldd	r25, Y+5	; 0x05
    334e:	00 97       	sbiw	r24, 0x00	; 0
    3350:	19 f0       	breq	.+6      	; 0x3358 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3352:	b8 01       	movw	r22, r16
    3354:	0e 94 98 19 	call	0x3330	; 0x3330 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    3358:	df 91       	pop	r29
    335a:	cf 91       	pop	r28
    335c:	1f 91       	pop	r17
    335e:	0f 91       	pop	r16
    3360:	08 95       	ret

00003362 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    3362:	0f 93       	push	r16
    3364:	1f 93       	push	r17
    3366:	cf 93       	push	r28
    3368:	df 93       	push	r29
    336a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    336c:	6a e0       	ldi	r22, 0x0A	; 10
    336e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3372:	8c 01       	movw	r16, r24
    3374:	6b ef       	ldi	r22, 0xFB	; 251
    3376:	76 e0       	ldi	r23, 0x06	; 6
    3378:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    337c:	6a e0       	ldi	r22, 0x0A	; 10
    337e:	c8 01       	movw	r24, r16
    3380:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3384:	8c 01       	movw	r16, r24
    3386:	64 ef       	ldi	r22, 0xF4	; 244
    3388:	76 e0       	ldi	r23, 0x06	; 6
    338a:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    338e:	66 e0       	ldi	r22, 0x06	; 6
    3390:	c8 01       	movw	r24, r16
    3392:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3396:	6a e0       	ldi	r22, 0x0A	; 10
    3398:	ce 01       	movw	r24, r28
    339a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    339e:	8c 01       	movw	r16, r24
    33a0:	63 ee       	ldi	r22, 0xE3	; 227
    33a2:	76 e0       	ldi	r23, 0x06	; 6
    33a4:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    33a8:	6a e0       	ldi	r22, 0x0A	; 10
    33aa:	c8 01       	movw	r24, r16
    33ac:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    33b0:	8c 01       	movw	r16, r24
    33b2:	67 ed       	ldi	r22, 0xD7	; 215
    33b4:	76 e0       	ldi	r23, 0x06	; 6
    33b6:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    33ba:	6a e0       	ldi	r22, 0x0A	; 10
    33bc:	c8 01       	movw	r24, r16
    33be:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    33c2:	8c 01       	movw	r16, r24
    33c4:	61 ed       	ldi	r22, 0xD1	; 209
    33c6:	76 e0       	ldi	r23, 0x06	; 6
    33c8:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    33cc:	66 e0       	ldi	r22, 0x06	; 6
    33ce:	c8 01       	movw	r24, r16
    33d0:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    33d4:	6a e0       	ldi	r22, 0x0A	; 10
    33d6:	ce 01       	movw	r24, r28
    33d8:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    33dc:	8c 01       	movw	r16, r24
    33de:	60 ec       	ldi	r22, 0xC0	; 192
    33e0:	76 e0       	ldi	r23, 0x06	; 6
    33e2:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    33e6:	6a e0       	ldi	r22, 0x0A	; 10
    33e8:	c8 01       	movw	r24, r16
    33ea:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    33ee:	8c 01       	movw	r16, r24
    33f0:	64 eb       	ldi	r22, 0xB4	; 180
    33f2:	76 e0       	ldi	r23, 0x06	; 6
    33f4:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    33f8:	6a e0       	ldi	r22, 0x0A	; 10
    33fa:	c8 01       	movw	r24, r16
    33fc:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3400:	8c 01       	movw	r16, r24
    3402:	6e ea       	ldi	r22, 0xAE	; 174
    3404:	76 e0       	ldi	r23, 0x06	; 6
    3406:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    340a:	66 e0       	ldi	r22, 0x06	; 6
    340c:	c8 01       	movw	r24, r16
    340e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3412:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <last_created_task_pointer>
    3416:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    341a:	00 97       	sbiw	r24, 0x00	; 0
    341c:	19 f0       	breq	.+6      	; 0x3424 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    341e:	be 01       	movw	r22, r28
    3420:	0e 94 98 19 	call	0x3330	; 0x3330 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3424:	0e 94 7e 13 	call	0x26fc	; 0x26fc <xTaskGetIdleTaskHandle>
    3428:	0e 94 e9 16 	call	0x2dd2	; 0x2dd2 <uxTaskGetStackHighWaterMark>
    342c:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    342e:	6a e0       	ldi	r22, 0x0A	; 10
    3430:	ce 01       	movw	r24, r28
    3432:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3436:	ec 01       	movw	r28, r24
    3438:	63 ea       	ldi	r22, 0xA3	; 163
    343a:	76 e0       	ldi	r23, 0x06	; 6
    343c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3440:	61 2f       	mov	r22, r17
    3442:	ce 01       	movw	r24, r28
    3444:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    3448:	6a e0       	ldi	r22, 0x0A	; 10
    344a:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    344e:	ec 01       	movw	r28, r24
    3450:	61 ea       	ldi	r22, 0xA1	; 161
    3452:	76 e0       	ldi	r23, 0x06	; 6
    3454:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    3458:	64 e6       	ldi	r22, 0x64	; 100
    345a:	70 e0       	ldi	r23, 0x00	; 0
    345c:	ce 01       	movw	r24, r28
    345e:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <_ZN8emstreamlsEj>
    3462:	6a e0       	ldi	r22, 0x0A	; 10
    3464:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3468:	ec 01       	movw	r28, r24
    346a:	6e e9       	ldi	r22, 0x9E	; 158
    346c:	76 e0       	ldi	r23, 0x06	; 6
    346e:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3472:	66 e0       	ldi	r22, 0x06	; 6
    3474:	ce 01       	movw	r24, r28
    3476:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
}
    347a:	df 91       	pop	r29
    347c:	cf 91       	pop	r28
    347e:	1f 91       	pop	r17
    3480:	0f 91       	pop	r16
    3482:	08 95       	ret

00003484 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3484:	0f 93       	push	r16
    3486:	cf 93       	push	r28
    3488:	df 93       	push	r29
    348a:	1f 92       	push	r1
    348c:	cd b7       	in	r28, 0x3d	; 61
    348e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3490:	00 e0       	ldi	r16, 0x00	; 0
    3492:	2f ef       	ldi	r18, 0xFF	; 255
    3494:	3f ef       	ldi	r19, 0xFF	; 255
    3496:	a9 01       	movw	r20, r18
    3498:	be 01       	movw	r22, r28
    349a:	6f 5f       	subi	r22, 0xFF	; 255
    349c:	7f 4f       	sbci	r23, 0xFF	; 255
    349e:	fc 01       	movw	r30, r24
    34a0:	80 85       	ldd	r24, Z+8	; 0x08
    34a2:	91 85       	ldd	r25, Z+9	; 0x09
    34a4:	0e 94 fd 10 	call	0x21fa	; 0x21fa <xQueueGenericReceive>
    34a8:	81 30       	cpi	r24, 0x01	; 1
    34aa:	19 f4       	brne	.+6      	; 0x34b2 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    34ac:	89 81       	ldd	r24, Y+1	; 0x01
    34ae:	90 e0       	ldi	r25, 0x00	; 0
    34b0:	02 c0       	rjmp	.+4      	; 0x34b6 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    34b2:	8f ef       	ldi	r24, 0xFF	; 255
    34b4:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    34b6:	0f 90       	pop	r0
    34b8:	df 91       	pop	r29
    34ba:	cf 91       	pop	r28
    34bc:	0f 91       	pop	r16
    34be:	08 95       	ret

000034c0 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    34c0:	fc 01       	movw	r30, r24
    34c2:	80 85       	ldd	r24, Z+8	; 0x08
    34c4:	91 85       	ldd	r25, Z+9	; 0x09
    34c6:	0e 94 c1 11 	call	0x2382	; 0x2382 <uxQueueMessagesWaiting>
    34ca:	91 e0       	ldi	r25, 0x01	; 1
    34cc:	81 11       	cpse	r24, r1
    34ce:	01 c0       	rjmp	.+2      	; 0x34d2 <_ZN14frt_text_queue14check_for_charEv+0x12>
    34d0:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    34d2:	89 2f       	mov	r24, r25
    34d4:	08 95       	ret

000034d6 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    34d6:	0f 93       	push	r16
    34d8:	cf 93       	push	r28
    34da:	df 93       	push	r29
    34dc:	1f 92       	push	r1
    34de:	cd b7       	in	r28, 0x3d	; 61
    34e0:	de b7       	in	r29, 0x3e	; 62
    34e2:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    34e4:	fc 01       	movw	r30, r24
    34e6:	22 85       	ldd	r18, Z+10	; 0x0a
    34e8:	33 85       	ldd	r19, Z+11	; 0x0b
    34ea:	44 85       	ldd	r20, Z+12	; 0x0c
    34ec:	55 85       	ldd	r21, Z+13	; 0x0d
    34ee:	00 e0       	ldi	r16, 0x00	; 0
    34f0:	be 01       	movw	r22, r28
    34f2:	6f 5f       	subi	r22, 0xFF	; 255
    34f4:	7f 4f       	sbci	r23, 0xFF	; 255
    34f6:	80 85       	ldd	r24, Z+8	; 0x08
    34f8:	91 85       	ldd	r25, Z+9	; 0x09
    34fa:	0e 94 62 10 	call	0x20c4	; 0x20c4 <xQueueGenericSend>
    34fe:	91 e0       	ldi	r25, 0x01	; 1
    3500:	81 11       	cpse	r24, r1
    3502:	01 c0       	rjmp	.+2      	; 0x3506 <_ZN14frt_text_queue7putcharEc+0x30>
    3504:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    3506:	89 2f       	mov	r24, r25
    3508:	0f 90       	pop	r0
    350a:	df 91       	pop	r29
    350c:	cf 91       	pop	r28
    350e:	0f 91       	pop	r16
    3510:	08 95       	ret

00003512 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3512:	8f 92       	push	r8
    3514:	9f 92       	push	r9
    3516:	bf 92       	push	r11
    3518:	cf 92       	push	r12
    351a:	df 92       	push	r13
    351c:	ef 92       	push	r14
    351e:	ff 92       	push	r15
    3520:	0f 93       	push	r16
    3522:	1f 93       	push	r17
    3524:	cf 93       	push	r28
    3526:	df 93       	push	r29
    3528:	ec 01       	movw	r28, r24
    352a:	b6 2e       	mov	r11, r22
    352c:	4a 01       	movw	r8, r20
    352e:	68 01       	movw	r12, r16
    3530:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3532:	0e 94 c3 1c 	call	0x3986	; 0x3986 <_ZN8emstreamC1Ev>
    3536:	88 e5       	ldi	r24, 0x58	; 88
    3538:	90 e2       	ldi	r25, 0x20	; 32
    353a:	88 83       	st	Y, r24
    353c:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    353e:	8e 86       	std	Y+14, r8	; 0x0e
    3540:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3542:	40 e0       	ldi	r20, 0x00	; 0
    3544:	61 e0       	ldi	r22, 0x01	; 1
    3546:	8b 2d       	mov	r24, r11
    3548:	0e 94 34 10 	call	0x2068	; 0x2068 <xQueueGenericCreate>
    354c:	88 87       	std	Y+8, r24	; 0x08
    354e:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3550:	ca 86       	std	Y+10, r12	; 0x0a
    3552:	db 86       	std	Y+11, r13	; 0x0b
    3554:	ec 86       	std	Y+12, r14	; 0x0c
    3556:	fd 86       	std	Y+13, r15	; 0x0d
}
    3558:	df 91       	pop	r29
    355a:	cf 91       	pop	r28
    355c:	1f 91       	pop	r17
    355e:	0f 91       	pop	r16
    3560:	ff 90       	pop	r15
    3562:	ef 90       	pop	r14
    3564:	df 90       	pop	r13
    3566:	cf 90       	pop	r12
    3568:	bf 90       	pop	r11
    356a:	9f 90       	pop	r9
    356c:	8f 90       	pop	r8
    356e:	08 95       	ret

00003570 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3570:	cf 92       	push	r12
    3572:	df 92       	push	r13
    3574:	ef 92       	push	r14
    3576:	ff 92       	push	r15
    3578:	cf 93       	push	r28
    357a:	df 93       	push	r29
    357c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    357e:	68 81       	ld	r22, Y
    3580:	79 81       	ldd	r23, Y+1	; 0x01
    3582:	8a 81       	ldd	r24, Y+2	; 0x02
    3584:	9b 81       	ldd	r25, Y+3	; 0x03
    3586:	0f 2e       	mov	r0, r31
    3588:	f8 ee       	ldi	r31, 0xE8	; 232
    358a:	cf 2e       	mov	r12, r31
    358c:	f3 e0       	ldi	r31, 0x03	; 3
    358e:	df 2e       	mov	r13, r31
    3590:	e1 2c       	mov	r14, r1
    3592:	f1 2c       	mov	r15, r1
    3594:	f0 2d       	mov	r31, r0
    3596:	a7 01       	movw	r20, r14
    3598:	96 01       	movw	r18, r12
    359a:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__udivmodsi4>
    359e:	9b 01       	movw	r18, r22
    35a0:	ac 01       	movw	r20, r24
    35a2:	60 e4       	ldi	r22, 0x40	; 64
    35a4:	72 e4       	ldi	r23, 0x42	; 66
    35a6:	8f e0       	ldi	r24, 0x0F	; 15
    35a8:	90 e0       	ldi	r25, 0x00	; 0
    35aa:	0e 94 4a 22 	call	0x4494	; 0x4494 <__mulsi3>
    35ae:	a7 01       	movw	r20, r14
    35b0:	96 01       	movw	r18, r12
    35b2:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__udivmodsi4>
    35b6:	69 01       	movw	r12, r18
    35b8:	7a 01       	movw	r14, r20
    35ba:	ac 81       	ldd	r26, Y+4	; 0x04
    35bc:	bd 81       	ldd	r27, Y+5	; 0x05
    35be:	20 e4       	ldi	r18, 0x40	; 64
    35c0:	32 e4       	ldi	r19, 0x42	; 66
    35c2:	4f e0       	ldi	r20, 0x0F	; 15
    35c4:	50 e0       	ldi	r21, 0x00	; 0
    35c6:	0e 94 d6 22 	call	0x45ac	; 0x45ac <__muluhisi3>
    35ca:	20 e0       	ldi	r18, 0x00	; 0
    35cc:	38 e4       	ldi	r19, 0x48	; 72
    35ce:	48 ee       	ldi	r20, 0xE8	; 232
    35d0:	51 e0       	ldi	r21, 0x01	; 1
    35d2:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__udivmodsi4>
    35d6:	c7 01       	movw	r24, r14
    35d8:	b6 01       	movw	r22, r12
    35da:	62 0f       	add	r22, r18
    35dc:	73 1f       	adc	r23, r19
    35de:	84 1f       	adc	r24, r20
    35e0:	95 1f       	adc	r25, r21
}
    35e2:	df 91       	pop	r29
    35e4:	cf 91       	pop	r28
    35e6:	ff 90       	pop	r15
    35e8:	ef 90       	pop	r14
    35ea:	df 90       	pop	r13
    35ec:	cf 90       	pop	r12
    35ee:	08 95       	ret

000035f0 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    35f0:	cf 92       	push	r12
    35f2:	df 92       	push	r13
    35f4:	ef 92       	push	r14
    35f6:	ff 92       	push	r15
    35f8:	0f 93       	push	r16
    35fa:	1f 93       	push	r17
    35fc:	cf 93       	push	r28
    35fe:	df 93       	push	r29
    3600:	cd b7       	in	r28, 0x3d	; 61
    3602:	de b7       	in	r29, 0x3e	; 62
    3604:	2f 97       	sbiw	r28, 0x0f	; 15
    3606:	cd bf       	out	0x3d, r28	; 61
    3608:	de bf       	out	0x3e, r29	; 62
    360a:	6c 01       	movw	r12, r24
    360c:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    360e:	db 01       	movw	r26, r22
    3610:	6d 91       	ld	r22, X+
    3612:	7d 91       	ld	r23, X+
    3614:	8d 91       	ld	r24, X+
    3616:	9c 91       	ld	r25, X
    3618:	28 ee       	ldi	r18, 0xE8	; 232
    361a:	33 e0       	ldi	r19, 0x03	; 3
    361c:	40 e0       	ldi	r20, 0x00	; 0
    361e:	50 e0       	ldi	r21, 0x00	; 0
    3620:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__udivmodsi4>
    3624:	ba 01       	movw	r22, r20
    3626:	a9 01       	movw	r20, r18
    3628:	c6 01       	movw	r24, r12
    362a:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    362e:	d6 01       	movw	r26, r12
    3630:	ed 91       	ld	r30, X+
    3632:	fc 91       	ld	r31, X
    3634:	02 80       	ldd	r0, Z+2	; 0x02
    3636:	f3 81       	ldd	r31, Z+3	; 0x03
    3638:	e0 2d       	mov	r30, r0
    363a:	6e e2       	ldi	r22, 0x2E	; 46
    363c:	c6 01       	movw	r24, r12
    363e:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3640:	c8 01       	movw	r24, r16
    3642:	0e 94 b8 1a 	call	0x3570	; 0x3570 <_ZN10time_stamp12get_microsecEv>
    3646:	8e 01       	movw	r16, r28
    3648:	09 5f       	subi	r16, 0xF9	; 249
    364a:	1f 4f       	sbci	r17, 0xFF	; 255
    364c:	fe 01       	movw	r30, r28
    364e:	31 96       	adiw	r30, 0x01	; 1
    3650:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3652:	2a e0       	ldi	r18, 0x0A	; 10
    3654:	30 e0       	ldi	r19, 0x00	; 0
    3656:	40 e0       	ldi	r20, 0x00	; 0
    3658:	50 e0       	ldi	r21, 0x00	; 0
    365a:	0e 94 90 22 	call	0x4520	; 0x4520 <__divmodsi4>
    365e:	e6 2f       	mov	r30, r22
    3660:	28 87       	std	Y+8, r18	; 0x08
    3662:	39 87       	std	Y+9, r19	; 0x09
    3664:	4a 87       	std	Y+10, r20	; 0x0a
    3666:	5b 87       	std	Y+11, r21	; 0x0b
    3668:	68 85       	ldd	r22, Y+8	; 0x08
    366a:	79 85       	ldd	r23, Y+9	; 0x09
    366c:	8a 85       	ldd	r24, Y+10	; 0x0a
    366e:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3670:	20 e3       	ldi	r18, 0x30	; 48
    3672:	2e 0f       	add	r18, r30
    3674:	d8 01       	movw	r26, r16
    3676:	2e 93       	st	-X, r18
    3678:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    367a:	ae 15       	cp	r26, r14
    367c:	bf 05       	cpc	r27, r15
    367e:	49 f7       	brne	.-46     	; 0x3652 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3680:	1f 82       	std	Y+7, r1	; 0x07
    3682:	be 01       	movw	r22, r28
    3684:	6f 5f       	subi	r22, 0xFF	; 255
    3686:	7f 4f       	sbci	r23, 0xFF	; 255
    3688:	c6 01       	movw	r24, r12
    368a:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    368e:	c6 01       	movw	r24, r12
    3690:	2f 96       	adiw	r28, 0x0f	; 15
    3692:	cd bf       	out	0x3d, r28	; 61
    3694:	de bf       	out	0x3e, r29	; 62
    3696:	df 91       	pop	r29
    3698:	cf 91       	pop	r28
    369a:	1f 91       	pop	r17
    369c:	0f 91       	pop	r16
    369e:	ff 90       	pop	r15
    36a0:	ef 90       	pop	r14
    36a2:	df 90       	pop	r13
    36a4:	cf 90       	pop	r12
    36a6:	08 95       	ret

000036a8 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    36a8:	cf 93       	push	r28
    36aa:	df 93       	push	r29
    36ac:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    36ae:	0f b6       	in	r0, 0x3f	; 63
    36b0:	f8 94       	cli
    36b2:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    36b4:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    36b8:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    36bc:	8c 83       	std	Y+4, r24	; 0x04
    36be:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    36c0:	0e 94 68 13 	call	0x26d0	; 0x26d0 <xTaskGetTickCount>
    36c4:	68 83       	st	Y, r22
    36c6:	79 83       	std	Y+1, r23	; 0x01
    36c8:	8a 83       	std	Y+2, r24	; 0x02
    36ca:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    36cc:	0f 90       	pop	r0
    36ce:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    36d0:	ce 01       	movw	r24, r28
    36d2:	df 91       	pop	r29
    36d4:	cf 91       	pop	r28
    36d6:	08 95       	ret

000036d8 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    36d8:	5f 92       	push	r5
    36da:	6f 92       	push	r6
    36dc:	7f 92       	push	r7
    36de:	8f 92       	push	r8
    36e0:	9f 92       	push	r9
    36e2:	af 92       	push	r10
    36e4:	bf 92       	push	r11
    36e6:	cf 92       	push	r12
    36e8:	df 92       	push	r13
    36ea:	ef 92       	push	r14
    36ec:	ff 92       	push	r15
    36ee:	0f 93       	push	r16
    36f0:	1f 93       	push	r17
    36f2:	cf 93       	push	r28
    36f4:	df 93       	push	r29
    36f6:	5c 01       	movw	r10, r24
    36f8:	4b 01       	movw	r8, r22
    36fa:	7a 01       	movw	r14, r20
    36fc:	12 2f       	mov	r17, r18
    36fe:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3700:	63 e0       	ldi	r22, 0x03	; 3
    3702:	ca 01       	movw	r24, r20
    3704:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3708:	a8 14       	cp	r10, r8
    370a:	b9 04       	cpc	r11, r9
    370c:	08 f0       	brcs	.+2      	; 0x3710 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    370e:	7d c0       	rjmp	.+250    	; 0x380a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3710:	65 01       	movw	r12, r10
    3712:	84 e1       	ldi	r24, 0x14	; 20
    3714:	c8 0e       	add	r12, r24
    3716:	d1 1c       	adc	r13, r1
    3718:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    371a:	6a 2c       	mov	r6, r10
    371c:	5b 2c       	mov	r5, r11
    371e:	b5 01       	movw	r22, r10
    3720:	c7 01       	movw	r24, r14
    3722:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <_ZN8emstreamlsEj>
    3726:	6a e0       	ldi	r22, 0x0A	; 10
    3728:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    372c:	60 e2       	ldi	r22, 0x20	; 32
    372e:	77 e0       	ldi	r23, 0x07	; 7
    3730:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3734:	11 23       	and	r17, r17
    3736:	09 f4       	brne	.+2      	; 0x373a <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3738:	6d c0       	rjmp	.+218    	; 0x3814 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    373a:	00 23       	and	r16, r16
    373c:	09 f4       	brne	.+2      	; 0x3740 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    373e:	6a c0       	rjmp	.+212    	; 0x3814 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3740:	6a e0       	ldi	r22, 0x0A	; 10
    3742:	c7 01       	movw	r24, r14
    3744:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3748:	6b e1       	ldi	r22, 0x1B	; 27
    374a:	77 e0       	ldi	r23, 0x07	; 7
    374c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    3750:	61 c0       	rjmp	.+194    	; 0x3814 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3752:	11 23       	and	r17, r17
    3754:	71 f0       	breq	.+28     	; 0x3772 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3756:	01 11       	cpse	r16, r1
    3758:	0c c0       	rjmp	.+24     	; 0x3772 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    375a:	88 81       	ld	r24, Y
    375c:	87 15       	cp	r24, r7
    375e:	49 f0       	breq	.+18     	; 0x3772 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3760:	6a e0       	ldi	r22, 0x0A	; 10
    3762:	c7 01       	movw	r24, r14
    3764:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    3768:	66 e1       	ldi	r22, 0x16	; 22
    376a:	77 e0       	ldi	r23, 0x07	; 7
    376c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3770:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3772:	69 91       	ld	r22, Y+
    3774:	c7 01       	movw	r24, r14
    3776:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    377a:	dc 01       	movw	r26, r24
    377c:	ed 91       	ld	r30, X+
    377e:	fc 91       	ld	r31, X
    3780:	02 80       	ldd	r0, Z+2	; 0x02
    3782:	f3 81       	ldd	r31, Z+3	; 0x03
    3784:	e0 2d       	mov	r30, r0
    3786:	60 e2       	ldi	r22, 0x20	; 32
    3788:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    378a:	cc 16       	cp	r12, r28
    378c:	dd 06       	cpc	r13, r29
    378e:	09 f7       	brne	.-62     	; 0x3752 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3790:	11 23       	and	r17, r17
    3792:	89 f0       	breq	.+34     	; 0x37b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3794:	6a e0       	ldi	r22, 0x0A	; 10
    3796:	c7 01       	movw	r24, r14
    3798:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    379c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    379e:	60 e1       	ldi	r22, 0x10	; 16
    37a0:	77 e0       	ldi	r23, 0x07	; 7
    37a2:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    37a6:	e8 81       	ld	r30, Y
    37a8:	f9 81       	ldd	r31, Y+1	; 0x01
    37aa:	02 80       	ldd	r0, Z+2	; 0x02
    37ac:	f3 81       	ldd	r31, Z+3	; 0x03
    37ae:	e0 2d       	mov	r30, r0
    37b0:	60 e2       	ldi	r22, 0x20	; 32
    37b2:	ce 01       	movw	r24, r28
    37b4:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    37b6:	c6 2d       	mov	r28, r6
    37b8:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    37ba:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    37bc:	80 ee       	ldi	r24, 0xE0	; 224
    37be:	86 0f       	add	r24, r22
    37c0:	8f 35       	cpi	r24, 0x5F	; 95
    37c2:	48 f4       	brcc	.+18     	; 0x37d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    37c4:	d7 01       	movw	r26, r14
    37c6:	ed 91       	ld	r30, X+
    37c8:	fc 91       	ld	r31, X
    37ca:	02 80       	ldd	r0, Z+2	; 0x02
    37cc:	f3 81       	ldd	r31, Z+3	; 0x03
    37ce:	e0 2d       	mov	r30, r0
    37d0:	c7 01       	movw	r24, r14
    37d2:	19 95       	eicall
    37d4:	09 c0       	rjmp	.+18     	; 0x37e8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    37d6:	d7 01       	movw	r26, r14
    37d8:	ed 91       	ld	r30, X+
    37da:	fc 91       	ld	r31, X
    37dc:	02 80       	ldd	r0, Z+2	; 0x02
    37de:	f3 81       	ldd	r31, Z+3	; 0x03
    37e0:	e0 2d       	mov	r30, r0
    37e2:	6e e2       	ldi	r22, 0x2E	; 46
    37e4:	c7 01       	movw	r24, r14
    37e6:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    37e8:	cc 16       	cp	r12, r28
    37ea:	dd 06       	cpc	r13, r29
    37ec:	31 f7       	brne	.-52     	; 0x37ba <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    37ee:	b4 e1       	ldi	r27, 0x14	; 20
    37f0:	ab 0e       	add	r10, r27
    37f2:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    37f4:	66 e0       	ldi	r22, 0x06	; 6
    37f6:	c7 01       	movw	r24, r14
    37f8:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    37fc:	84 e1       	ldi	r24, 0x14	; 20
    37fe:	c8 0e       	add	r12, r24
    3800:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3802:	a8 14       	cp	r10, r8
    3804:	b9 04       	cpc	r11, r9
    3806:	08 f4       	brcc	.+2      	; 0x380a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3808:	88 cf       	rjmp	.-240    	; 0x371a <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    380a:	62 e0       	ldi	r22, 0x02	; 2
    380c:	c7 01       	movw	r24, r14
    380e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
}
    3812:	03 c0       	rjmp	.+6      	; 0x381a <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3814:	c6 2d       	mov	r28, r6
    3816:	d5 2d       	mov	r29, r5
    3818:	9c cf       	rjmp	.-200    	; 0x3752 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    381a:	df 91       	pop	r29
    381c:	cf 91       	pop	r28
    381e:	1f 91       	pop	r17
    3820:	0f 91       	pop	r16
    3822:	ff 90       	pop	r15
    3824:	ef 90       	pop	r14
    3826:	df 90       	pop	r13
    3828:	cf 90       	pop	r12
    382a:	bf 90       	pop	r11
    382c:	af 90       	pop	r10
    382e:	9f 90       	pop	r9
    3830:	8f 90       	pop	r8
    3832:	7f 90       	pop	r7
    3834:	6f 90       	pop	r6
    3836:	5f 90       	pop	r5
    3838:	08 95       	ret

0000383a <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    383a:	0e 94 4e 0c 	call	0x189c	; 0x189c <pvPortMalloc>
    383e:	08 95       	ret

00003840 <_Znaj>:
    3840:	0e 94 4e 0c 	call	0x189c	; 0x189c <pvPortMalloc>
    3844:	08 95       	ret

00003846 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3846:	08 95       	ret

00003848 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3848:	cf 93       	push	r28
    384a:	df 93       	push	r29
    384c:	fc 01       	movw	r30, r24
    384e:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3850:	40 3a       	cpi	r20, 0xA0	; 160
    3852:	68 e0       	ldi	r22, 0x08	; 8
    3854:	56 07       	cpc	r21, r22
    3856:	49 f4       	brne	.+18     	; 0x386a <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3858:	80 e4       	ldi	r24, 0x40	; 64
    385a:	96 e0       	ldi	r25, 0x06	; 6
    385c:	82 83       	std	Z+2, r24	; 0x02
    385e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3860:	82 e0       	ldi	r24, 0x02	; 2
    3862:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3864:	83 e0       	ldi	r24, 0x03	; 3
    3866:	85 83       	std	Z+5, r24	; 0x05
    3868:	32 c0       	rjmp	.+100    	; 0x38ce <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    386a:	40 3b       	cpi	r20, 0xB0	; 176
    386c:	78 e0       	ldi	r23, 0x08	; 8
    386e:	57 07       	cpc	r21, r23
    3870:	49 f4       	brne	.+18     	; 0x3884 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3872:	80 e4       	ldi	r24, 0x40	; 64
    3874:	96 e0       	ldi	r25, 0x06	; 6
    3876:	82 83       	std	Z+2, r24	; 0x02
    3878:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    387a:	86 e0       	ldi	r24, 0x06	; 6
    387c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    387e:	87 e0       	ldi	r24, 0x07	; 7
    3880:	85 83       	std	Z+5, r24	; 0x05
    3882:	25 c0       	rjmp	.+74     	; 0x38ce <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3884:	40 3a       	cpi	r20, 0xA0	; 160
    3886:	89 e0       	ldi	r24, 0x09	; 9
    3888:	58 07       	cpc	r21, r24
    388a:	49 f4       	brne	.+18     	; 0x389e <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    388c:	80 e6       	ldi	r24, 0x60	; 96
    388e:	96 e0       	ldi	r25, 0x06	; 6
    3890:	82 83       	std	Z+2, r24	; 0x02
    3892:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3894:	82 e0       	ldi	r24, 0x02	; 2
    3896:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3898:	83 e0       	ldi	r24, 0x03	; 3
    389a:	85 83       	std	Z+5, r24	; 0x05
    389c:	18 c0       	rjmp	.+48     	; 0x38ce <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    389e:	40 3b       	cpi	r20, 0xB0	; 176
    38a0:	69 e0       	ldi	r22, 0x09	; 9
    38a2:	56 07       	cpc	r21, r22
    38a4:	49 f4       	brne	.+18     	; 0x38b8 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    38a6:	80 e6       	ldi	r24, 0x60	; 96
    38a8:	96 e0       	ldi	r25, 0x06	; 6
    38aa:	82 83       	std	Z+2, r24	; 0x02
    38ac:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    38ae:	86 e0       	ldi	r24, 0x06	; 6
    38b0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    38b2:	87 e0       	ldi	r24, 0x07	; 7
    38b4:	85 83       	std	Z+5, r24	; 0x05
    38b6:	0b c0       	rjmp	.+22     	; 0x38ce <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    38b8:	40 3a       	cpi	r20, 0xA0	; 160
    38ba:	5a 40       	sbci	r21, 0x0A	; 10
    38bc:	41 f4       	brne	.+16     	; 0x38ce <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    38be:	80 e8       	ldi	r24, 0x80	; 128
    38c0:	96 e0       	ldi	r25, 0x06	; 6
    38c2:	82 83       	std	Z+2, r24	; 0x02
    38c4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    38c6:	82 e0       	ldi	r24, 0x02	; 2
    38c8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    38ca:	83 e0       	ldi	r24, 0x03	; 3
    38cc:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    38ce:	a6 83       	std	Z+6, r26	; 0x06
    38d0:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    38d2:	cd 01       	movw	r24, r26
    38d4:	01 96       	adiw	r24, 0x01	; 1
    38d6:	80 87       	std	Z+8, r24	; 0x08
    38d8:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    38da:	03 96       	adiw	r24, 0x03	; 3
    38dc:	82 87       	std	Z+10, r24	; 0x0a
    38de:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    38e0:	25 81       	ldd	r18, Z+5	; 0x05
    38e2:	c2 81       	ldd	r28, Z+2	; 0x02
    38e4:	d3 81       	ldd	r29, Z+3	; 0x03
    38e6:	4c 81       	ldd	r20, Y+4	; 0x04
    38e8:	81 e0       	ldi	r24, 0x01	; 1
    38ea:	90 e0       	ldi	r25, 0x00	; 0
    38ec:	bc 01       	movw	r22, r24
    38ee:	02 c0       	rjmp	.+4      	; 0x38f4 <_ZN7base232C1EjP12USART_struct+0xac>
    38f0:	66 0f       	add	r22, r22
    38f2:	77 1f       	adc	r23, r23
    38f4:	2a 95       	dec	r18
    38f6:	e2 f7       	brpl	.-8      	; 0x38f0 <_ZN7base232C1EjP12USART_struct+0xa8>
    38f8:	9b 01       	movw	r18, r22
    38fa:	24 2b       	or	r18, r20
    38fc:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    38fe:	25 81       	ldd	r18, Z+5	; 0x05
    3900:	c2 81       	ldd	r28, Z+2	; 0x02
    3902:	d3 81       	ldd	r29, Z+3	; 0x03
    3904:	48 81       	ld	r20, Y
    3906:	bc 01       	movw	r22, r24
    3908:	02 c0       	rjmp	.+4      	; 0x390e <_ZN7base232C1EjP12USART_struct+0xc6>
    390a:	66 0f       	add	r22, r22
    390c:	77 1f       	adc	r23, r23
    390e:	2a 95       	dec	r18
    3910:	e2 f7       	brpl	.-8      	; 0x390a <_ZN7base232C1EjP12USART_struct+0xc2>
    3912:	9b 01       	movw	r18, r22
    3914:	24 2b       	or	r18, r20
    3916:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3918:	34 81       	ldd	r19, Z+4	; 0x04
    391a:	c2 81       	ldd	r28, Z+2	; 0x02
    391c:	d3 81       	ldd	r29, Z+3	; 0x03
    391e:	28 81       	ld	r18, Y
    3920:	02 c0       	rjmp	.+4      	; 0x3926 <_ZN7base232C1EjP12USART_struct+0xde>
    3922:	88 0f       	add	r24, r24
    3924:	99 1f       	adc	r25, r25
    3926:	3a 95       	dec	r19
    3928:	e2 f7       	brpl	.-8      	; 0x3922 <_ZN7base232C1EjP12USART_struct+0xda>
    392a:	80 95       	com	r24
    392c:	90 95       	com	r25
    392e:	82 23       	and	r24, r18
    3930:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3932:	80 e1       	ldi	r24, 0x10	; 16
    3934:	13 96       	adiw	r26, 0x03	; 3
    3936:	8c 93       	st	X, r24
    3938:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    393a:	83 e0       	ldi	r24, 0x03	; 3
    393c:	15 96       	adiw	r26, 0x05	; 5
    393e:	8c 93       	st	X, r24
    3940:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3942:	80 ef       	ldi	r24, 0xF0	; 240
    3944:	17 96       	adiw	r26, 0x07	; 7
    3946:	8c 93       	st	X, r24
    3948:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    394a:	81 e2       	ldi	r24, 0x21	; 33
    394c:	16 96       	adiw	r26, 0x06	; 6
    394e:	8c 93       	st	X, r24
    3950:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3952:	88 e1       	ldi	r24, 0x18	; 24
    3954:	14 96       	adiw	r26, 0x04	; 4
    3956:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3958:	80 e8       	ldi	r24, 0x80	; 128
    395a:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    395c:	80 e4       	ldi	r24, 0x40	; 64
    395e:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3960:	80 e2       	ldi	r24, 0x20	; 32
    3962:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3964:	06 80       	ldd	r0, Z+6	; 0x06
    3966:	f7 81       	ldd	r31, Z+7	; 0x07
    3968:	e0 2d       	mov	r30, r0
    396a:	80 81       	ld	r24, Z
    396c:	80 81       	ld	r24, Z
}
    396e:	df 91       	pop	r29
    3970:	cf 91       	pop	r28
    3972:	08 95       	ret

00003974 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3974:	81 e0       	ldi	r24, 0x01	; 1
    3976:	08 95       	ret

00003978 <_ZN8emstream7getcharEv>:
    3978:	80 e0       	ldi	r24, 0x00	; 0
    397a:	90 e0       	ldi	r25, 0x00	; 0
    397c:	08 95       	ret

0000397e <_ZN8emstream14check_for_charEv>:
    397e:	80 e0       	ldi	r24, 0x00	; 0
    3980:	08 95       	ret

00003982 <_ZN8emstream12transmit_nowEv>:
    3982:	08 95       	ret

00003984 <_ZN8emstream12clear_screenEv>:
    3984:	08 95       	ret

00003986 <_ZN8emstreamC1Ev>:
    3986:	fc 01       	movw	r30, r24
    3988:	88 e6       	ldi	r24, 0x68	; 104
    398a:	90 e2       	ldi	r25, 0x20	; 32
    398c:	80 83       	st	Z, r24
    398e:	91 83       	std	Z+1, r25	; 0x01
    3990:	8a e0       	ldi	r24, 0x0A	; 10
    3992:	82 83       	std	Z+2, r24	; 0x02
    3994:	13 82       	std	Z+3, r1	; 0x03
    3996:	83 e0       	ldi	r24, 0x03	; 3
    3998:	85 83       	std	Z+5, r24	; 0x05
    399a:	14 82       	std	Z+4, r1	; 0x04
    399c:	16 82       	std	Z+6, r1	; 0x06
    399e:	17 82       	std	Z+7, r1	; 0x07
    39a0:	08 95       	ret

000039a2 <_ZN8emstream4putsEPKc>:
    39a2:	0f 93       	push	r16
    39a4:	1f 93       	push	r17
    39a6:	cf 93       	push	r28
    39a8:	df 93       	push	r29
    39aa:	8c 01       	movw	r16, r24
    39ac:	fb 01       	movw	r30, r22
    39ae:	dc 01       	movw	r26, r24
    39b0:	14 96       	adiw	r26, 0x04	; 4
    39b2:	8c 91       	ld	r24, X
    39b4:	81 11       	cpse	r24, r1
    39b6:	04 c0       	rjmp	.+8      	; 0x39c0 <_ZN8emstream4putsEPKc+0x1e>
    39b8:	60 81       	ld	r22, Z
    39ba:	61 11       	cpse	r22, r1
    39bc:	17 c0       	rjmp	.+46     	; 0x39ec <_ZN8emstream4putsEPKc+0x4a>
    39be:	23 c0       	rjmp	.+70     	; 0x3a06 <_ZN8emstream4putsEPKc+0x64>
    39c0:	d8 01       	movw	r26, r16
    39c2:	14 96       	adiw	r26, 0x04	; 4
    39c4:	1c 92       	st	X, r1
    39c6:	eb 01       	movw	r28, r22
    39c8:	21 96       	adiw	r28, 0x01	; 1
    39ca:	64 91       	lpm	r22, Z
    39cc:	66 23       	and	r22, r22
    39ce:	d9 f0       	breq	.+54     	; 0x3a06 <_ZN8emstream4putsEPKc+0x64>
    39d0:	d8 01       	movw	r26, r16
    39d2:	ed 91       	ld	r30, X+
    39d4:	fc 91       	ld	r31, X
    39d6:	02 80       	ldd	r0, Z+2	; 0x02
    39d8:	f3 81       	ldd	r31, Z+3	; 0x03
    39da:	e0 2d       	mov	r30, r0
    39dc:	c8 01       	movw	r24, r16
    39de:	19 95       	eicall
    39e0:	fe 01       	movw	r30, r28
    39e2:	64 91       	lpm	r22, Z
    39e4:	21 96       	adiw	r28, 0x01	; 1
    39e6:	61 11       	cpse	r22, r1
    39e8:	f3 cf       	rjmp	.-26     	; 0x39d0 <_ZN8emstream4putsEPKc+0x2e>
    39ea:	0d c0       	rjmp	.+26     	; 0x3a06 <_ZN8emstream4putsEPKc+0x64>
    39ec:	ef 01       	movw	r28, r30
    39ee:	21 96       	adiw	r28, 0x01	; 1
    39f0:	d8 01       	movw	r26, r16
    39f2:	ed 91       	ld	r30, X+
    39f4:	fc 91       	ld	r31, X
    39f6:	02 80       	ldd	r0, Z+2	; 0x02
    39f8:	f3 81       	ldd	r31, Z+3	; 0x03
    39fa:	e0 2d       	mov	r30, r0
    39fc:	c8 01       	movw	r24, r16
    39fe:	19 95       	eicall
    3a00:	69 91       	ld	r22, Y+
    3a02:	61 11       	cpse	r22, r1
    3a04:	f5 cf       	rjmp	.-22     	; 0x39f0 <_ZN8emstream4putsEPKc+0x4e>
    3a06:	df 91       	pop	r29
    3a08:	cf 91       	pop	r28
    3a0a:	1f 91       	pop	r17
    3a0c:	0f 91       	pop	r16
    3a0e:	08 95       	ret

00003a10 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3a10:	cf 93       	push	r28
    3a12:	df 93       	push	r29
    3a14:	ec 01       	movw	r28, r24
	switch (new_manip)
    3a16:	86 2f       	mov	r24, r22
    3a18:	90 e0       	ldi	r25, 0x00	; 0
    3a1a:	8b 30       	cpi	r24, 0x0B	; 11
    3a1c:	91 05       	cpc	r25, r1
    3a1e:	d8 f5       	brcc	.+118    	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
    3a20:	fc 01       	movw	r30, r24
    3a22:	88 27       	eor	r24, r24
    3a24:	e6 5a       	subi	r30, 0xA6	; 166
    3a26:	fe 4f       	sbci	r31, 0xFE	; 254
    3a28:	8f 4f       	sbci	r24, 0xFF	; 255
    3a2a:	0c 94 af 22 	jmp	0x455e	; 0x455e <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3a2e:	82 e0       	ldi	r24, 0x02	; 2
    3a30:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a32:	31 c0       	rjmp	.+98     	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3a34:	88 e0       	ldi	r24, 0x08	; 8
    3a36:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a38:	2e c0       	rjmp	.+92     	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3a3a:	8a e0       	ldi	r24, 0x0A	; 10
    3a3c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a3e:	2b c0       	rjmp	.+86     	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3a40:	80 e1       	ldi	r24, 0x10	; 16
    3a42:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a44:	28 c0       	rjmp	.+80     	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3a46:	81 e0       	ldi	r24, 0x01	; 1
    3a48:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3a4a:	25 c0       	rjmp	.+74     	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3a4c:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3a4e:	23 c0       	rjmp	.+70     	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3a50:	e8 81       	ld	r30, Y
    3a52:	f9 81       	ldd	r31, Y+1	; 0x01
    3a54:	02 80       	ldd	r0, Z+2	; 0x02
    3a56:	f3 81       	ldd	r31, Z+3	; 0x03
    3a58:	e0 2d       	mov	r30, r0
    3a5a:	6d e0       	ldi	r22, 0x0D	; 13
    3a5c:	ce 01       	movw	r24, r28
    3a5e:	19 95       	eicall
    3a60:	e8 81       	ld	r30, Y
    3a62:	f9 81       	ldd	r31, Y+1	; 0x01
    3a64:	02 80       	ldd	r0, Z+2	; 0x02
    3a66:	f3 81       	ldd	r31, Z+3	; 0x03
    3a68:	e0 2d       	mov	r30, r0
    3a6a:	6a e0       	ldi	r22, 0x0A	; 10
    3a6c:	ce 01       	movw	r24, r28
    3a6e:	19 95       	eicall
			break;
    3a70:	12 c0       	rjmp	.+36     	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3a72:	e8 81       	ld	r30, Y
    3a74:	f9 81       	ldd	r31, Y+1	; 0x01
    3a76:	02 84       	ldd	r0, Z+10	; 0x0a
    3a78:	f3 85       	ldd	r31, Z+11	; 0x0b
    3a7a:	e0 2d       	mov	r30, r0
    3a7c:	ce 01       	movw	r24, r28
    3a7e:	19 95       	eicall
			break;
    3a80:	0a c0       	rjmp	.+20     	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3a82:	e8 81       	ld	r30, Y
    3a84:	f9 81       	ldd	r31, Y+1	; 0x01
    3a86:	00 84       	ldd	r0, Z+8	; 0x08
    3a88:	f1 85       	ldd	r31, Z+9	; 0x09
    3a8a:	e0 2d       	mov	r30, r0
    3a8c:	ce 01       	movw	r24, r28
    3a8e:	19 95       	eicall
			break;
    3a90:	02 c0       	rjmp	.+4      	; 0x3a96 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3a92:	81 e0       	ldi	r24, 0x01	; 1
    3a94:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3a96:	ce 01       	movw	r24, r28
    3a98:	df 91       	pop	r29
    3a9a:	cf 91       	pop	r28
    3a9c:	08 95       	ret

00003a9e <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    3a9e:	0f 93       	push	r16
    3aa0:	1f 93       	push	r17
    3aa2:	cf 93       	push	r28
    3aa4:	df 93       	push	r29
    3aa6:	cd b7       	in	r28, 0x3d	; 61
    3aa8:	de b7       	in	r29, 0x3e	; 62
    3aaa:	61 97       	sbiw	r28, 0x11	; 17
    3aac:	cd bf       	out	0x3d, r28	; 61
    3aae:	de bf       	out	0x3e, r29	; 62
    3ab0:	8c 01       	movw	r16, r24
    3ab2:	9b 01       	movw	r18, r22
	if (base != 10)
    3ab4:	fc 01       	movw	r30, r24
    3ab6:	92 81       	ldd	r25, Z+2	; 0x02
    3ab8:	9a 30       	cpi	r25, 0x0A	; 10
    3aba:	21 f0       	breq	.+8      	; 0x3ac4 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    3abc:	c8 01       	movw	r24, r16
    3abe:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <_ZN8emstreamlsEj>
    3ac2:	0d c0       	rjmp	.+26     	; 0x3ade <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3ac4:	4a e0       	ldi	r20, 0x0A	; 10
    3ac6:	be 01       	movw	r22, r28
    3ac8:	6f 5f       	subi	r22, 0xFF	; 255
    3aca:	7f 4f       	sbci	r23, 0xFF	; 255
    3acc:	c9 01       	movw	r24, r18
    3ace:	0e 94 1c 23 	call	0x4638	; 0x4638 <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    3ad2:	be 01       	movw	r22, r28
    3ad4:	6f 5f       	subi	r22, 0xFF	; 255
    3ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ad8:	c8 01       	movw	r24, r16
    3ada:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3ade:	c8 01       	movw	r24, r16
    3ae0:	61 96       	adiw	r28, 0x11	; 17
    3ae2:	cd bf       	out	0x3d, r28	; 61
    3ae4:	de bf       	out	0x3e, r29	; 62
    3ae6:	df 91       	pop	r29
    3ae8:	cf 91       	pop	r28
    3aea:	1f 91       	pop	r17
    3aec:	0f 91       	pop	r16
    3aee:	08 95       	ret

00003af0 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3af0:	ff 92       	push	r15
    3af2:	0f 93       	push	r16
    3af4:	1f 93       	push	r17
    3af6:	cf 93       	push	r28
    3af8:	df 93       	push	r29
    3afa:	cd b7       	in	r28, 0x3d	; 61
    3afc:	de b7       	in	r29, 0x3e	; 62
    3afe:	61 97       	sbiw	r28, 0x11	; 17
    3b00:	cd bf       	out	0x3d, r28	; 61
    3b02:	de bf       	out	0x3e, r29	; 62
    3b04:	8c 01       	movw	r16, r24
    3b06:	f6 2e       	mov	r15, r22
    3b08:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3b0a:	f8 01       	movw	r30, r16
    3b0c:	42 81       	ldd	r20, Z+2	; 0x02
    3b0e:	40 31       	cpi	r20, 0x10	; 16
    3b10:	21 f0       	breq	.+8      	; 0x3b1a <_ZN8emstreamlsEj+0x2a>
    3b12:	48 30       	cpi	r20, 0x08	; 8
    3b14:	11 f0       	breq	.+4      	; 0x3b1a <_ZN8emstreamlsEj+0x2a>
    3b16:	42 30       	cpi	r20, 0x02	; 2
    3b18:	41 f4       	brne	.+16     	; 0x3b2a <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3b1a:	69 2f       	mov	r22, r25
    3b1c:	c8 01       	movw	r24, r16
    3b1e:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
    3b22:	6f 2d       	mov	r22, r15
    3b24:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
    3b28:	0d c0       	rjmp	.+26     	; 0x3b44 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3b2a:	50 e0       	ldi	r21, 0x00	; 0
    3b2c:	be 01       	movw	r22, r28
    3b2e:	6f 5f       	subi	r22, 0xFF	; 255
    3b30:	7f 4f       	sbci	r23, 0xFF	; 255
    3b32:	8f 2d       	mov	r24, r15
    3b34:	0e 94 54 23 	call	0x46a8	; 0x46a8 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3b38:	be 01       	movw	r22, r28
    3b3a:	6f 5f       	subi	r22, 0xFF	; 255
    3b3c:	7f 4f       	sbci	r23, 0xFF	; 255
    3b3e:	c8 01       	movw	r24, r16
    3b40:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3b44:	c8 01       	movw	r24, r16
    3b46:	61 96       	adiw	r28, 0x11	; 17
    3b48:	cd bf       	out	0x3d, r28	; 61
    3b4a:	de bf       	out	0x3e, r29	; 62
    3b4c:	df 91       	pop	r29
    3b4e:	cf 91       	pop	r28
    3b50:	1f 91       	pop	r17
    3b52:	0f 91       	pop	r16
    3b54:	ff 90       	pop	r15
    3b56:	08 95       	ret

00003b58 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3b58:	df 92       	push	r13
    3b5a:	ef 92       	push	r14
    3b5c:	ff 92       	push	r15
    3b5e:	0f 93       	push	r16
    3b60:	1f 93       	push	r17
    3b62:	cf 93       	push	r28
    3b64:	df 93       	push	r29
    3b66:	cd b7       	in	r28, 0x3d	; 61
    3b68:	de b7       	in	r29, 0x3e	; 62
    3b6a:	a1 97       	sbiw	r28, 0x21	; 33
    3b6c:	cd bf       	out	0x3d, r28	; 61
    3b6e:	de bf       	out	0x3e, r29	; 62
    3b70:	8c 01       	movw	r16, r24
    3b72:	d4 2e       	mov	r13, r20
    3b74:	e5 2e       	mov	r14, r21
    3b76:	f6 2e       	mov	r15, r22
    3b78:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3b7a:	f8 01       	movw	r30, r16
    3b7c:	22 81       	ldd	r18, Z+2	; 0x02
    3b7e:	20 31       	cpi	r18, 0x10	; 16
    3b80:	21 f0       	breq	.+8      	; 0x3b8a <_ZN8emstreamlsEm+0x32>
    3b82:	28 30       	cpi	r18, 0x08	; 8
    3b84:	11 f0       	breq	.+4      	; 0x3b8a <_ZN8emstreamlsEm+0x32>
    3b86:	22 30       	cpi	r18, 0x02	; 2
    3b88:	71 f4       	brne	.+28     	; 0x3ba6 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3b8a:	69 2f       	mov	r22, r25
    3b8c:	c8 01       	movw	r24, r16
    3b8e:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
    3b92:	6f 2d       	mov	r22, r15
    3b94:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
    3b98:	6e 2d       	mov	r22, r14
    3b9a:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
    3b9e:	6d 2d       	mov	r22, r13
    3ba0:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <_ZN8emstreamlsEh>
    3ba4:	0f c0       	rjmp	.+30     	; 0x3bc4 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3ba6:	30 e0       	ldi	r19, 0x00	; 0
    3ba8:	ae 01       	movw	r20, r28
    3baa:	4f 5f       	subi	r20, 0xFF	; 255
    3bac:	5f 4f       	sbci	r21, 0xFF	; 255
    3bae:	6d 2d       	mov	r22, r13
    3bb0:	7e 2d       	mov	r23, r14
    3bb2:	8f 2d       	mov	r24, r15
    3bb4:	0e 94 27 23 	call	0x464e	; 0x464e <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3bb8:	be 01       	movw	r22, r28
    3bba:	6f 5f       	subi	r22, 0xFF	; 255
    3bbc:	7f 4f       	sbci	r23, 0xFF	; 255
    3bbe:	c8 01       	movw	r24, r16
    3bc0:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3bc4:	c8 01       	movw	r24, r16
    3bc6:	a1 96       	adiw	r28, 0x21	; 33
    3bc8:	cd bf       	out	0x3d, r28	; 61
    3bca:	de bf       	out	0x3e, r29	; 62
    3bcc:	df 91       	pop	r29
    3bce:	cf 91       	pop	r28
    3bd0:	1f 91       	pop	r17
    3bd2:	0f 91       	pop	r16
    3bd4:	ff 90       	pop	r15
    3bd6:	ef 90       	pop	r14
    3bd8:	df 90       	pop	r13
    3bda:	08 95       	ret

00003bdc <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3bdc:	cf 92       	push	r12
    3bde:	df 92       	push	r13
    3be0:	ef 92       	push	r14
    3be2:	ff 92       	push	r15
    3be4:	0f 93       	push	r16
    3be6:	1f 93       	push	r17
    3be8:	cf 93       	push	r28
    3bea:	df 93       	push	r29
    3bec:	cd b7       	in	r28, 0x3d	; 61
    3bee:	de b7       	in	r29, 0x3e	; 62
    3bf0:	29 97       	sbiw	r28, 0x09	; 9
    3bf2:	cd bf       	out	0x3d, r28	; 61
    3bf4:	de bf       	out	0x3e, r29	; 62
    3bf6:	8c 01       	movw	r16, r24
    3bf8:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3bfa:	dc 01       	movw	r26, r24
    3bfc:	13 96       	adiw	r26, 0x03	; 3
    3bfe:	8c 91       	ld	r24, X
    3c00:	13 97       	sbiw	r26, 0x03	; 3
    3c02:	88 23       	and	r24, r24
    3c04:	41 f0       	breq	.+16     	; 0x3c16 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3c06:	ed 91       	ld	r30, X+
    3c08:	fc 91       	ld	r31, X
    3c0a:	02 80       	ldd	r0, Z+2	; 0x02
    3c0c:	f3 81       	ldd	r31, Z+3	; 0x03
    3c0e:	e0 2d       	mov	r30, r0
    3c10:	c8 01       	movw	r24, r16
    3c12:	19 95       	eicall
    3c14:	56 c0       	rjmp	.+172    	; 0x3cc2 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3c16:	f8 01       	movw	r30, r16
    3c18:	42 81       	ldd	r20, Z+2	; 0x02
    3c1a:	42 30       	cpi	r20, 0x02	; 2
    3c1c:	19 f5       	brne	.+70     	; 0x3c64 <_ZN8emstreamlsEh+0x88>
    3c1e:	68 94       	set
    3c20:	cc 24       	eor	r12, r12
    3c22:	c3 f8       	bld	r12, 3
    3c24:	d1 2c       	mov	r13, r1
    3c26:	68 94       	set
    3c28:	ff 24       	eor	r15, r15
    3c2a:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3c2c:	8e 2d       	mov	r24, r14
    3c2e:	8f 21       	and	r24, r15
    3c30:	51 f0       	breq	.+20     	; 0x3c46 <_ZN8emstreamlsEh+0x6a>
    3c32:	d8 01       	movw	r26, r16
    3c34:	ed 91       	ld	r30, X+
    3c36:	fc 91       	ld	r31, X
    3c38:	02 80       	ldd	r0, Z+2	; 0x02
    3c3a:	f3 81       	ldd	r31, Z+3	; 0x03
    3c3c:	e0 2d       	mov	r30, r0
    3c3e:	61 e3       	ldi	r22, 0x31	; 49
    3c40:	c8 01       	movw	r24, r16
    3c42:	19 95       	eicall
    3c44:	09 c0       	rjmp	.+18     	; 0x3c58 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3c46:	d8 01       	movw	r26, r16
    3c48:	ed 91       	ld	r30, X+
    3c4a:	fc 91       	ld	r31, X
    3c4c:	02 80       	ldd	r0, Z+2	; 0x02
    3c4e:	f3 81       	ldd	r31, Z+3	; 0x03
    3c50:	e0 2d       	mov	r30, r0
    3c52:	60 e3       	ldi	r22, 0x30	; 48
    3c54:	c8 01       	movw	r24, r16
    3c56:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3c58:	f6 94       	lsr	r15
    3c5a:	b1 e0       	ldi	r27, 0x01	; 1
    3c5c:	cb 1a       	sub	r12, r27
    3c5e:	d1 08       	sbc	r13, r1
    3c60:	29 f7       	brne	.-54     	; 0x3c2c <_ZN8emstreamlsEh+0x50>
    3c62:	2f c0       	rjmp	.+94     	; 0x3cc2 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3c64:	40 31       	cpi	r20, 0x10	; 16
    3c66:	f9 f4       	brne	.+62     	; 0x3ca6 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3c68:	62 95       	swap	r22
    3c6a:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3c6c:	01 90       	ld	r0, Z+
    3c6e:	f0 81       	ld	r31, Z
    3c70:	e0 2d       	mov	r30, r0
    3c72:	02 80       	ldd	r0, Z+2	; 0x02
    3c74:	f3 81       	ldd	r31, Z+3	; 0x03
    3c76:	e0 2d       	mov	r30, r0
    3c78:	6a 30       	cpi	r22, 0x0A	; 10
    3c7a:	10 f0       	brcs	.+4      	; 0x3c80 <_ZN8emstreamlsEh+0xa4>
    3c7c:	69 5c       	subi	r22, 0xC9	; 201
    3c7e:	01 c0       	rjmp	.+2      	; 0x3c82 <_ZN8emstreamlsEh+0xa6>
    3c80:	60 5d       	subi	r22, 0xD0	; 208
    3c82:	c8 01       	movw	r24, r16
    3c84:	19 95       	eicall
		temp_char = num & 0x0F;
    3c86:	6e 2d       	mov	r22, r14
    3c88:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3c8a:	d8 01       	movw	r26, r16
    3c8c:	ed 91       	ld	r30, X+
    3c8e:	fc 91       	ld	r31, X
    3c90:	02 80       	ldd	r0, Z+2	; 0x02
    3c92:	f3 81       	ldd	r31, Z+3	; 0x03
    3c94:	e0 2d       	mov	r30, r0
    3c96:	6a 30       	cpi	r22, 0x0A	; 10
    3c98:	10 f0       	brcs	.+4      	; 0x3c9e <_ZN8emstreamlsEh+0xc2>
    3c9a:	69 5c       	subi	r22, 0xC9	; 201
    3c9c:	01 c0       	rjmp	.+2      	; 0x3ca0 <_ZN8emstreamlsEh+0xc4>
    3c9e:	60 5d       	subi	r22, 0xD0	; 208
    3ca0:	c8 01       	movw	r24, r16
    3ca2:	19 95       	eicall
    3ca4:	0e c0       	rjmp	.+28     	; 0x3cc2 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3ca6:	50 e0       	ldi	r21, 0x00	; 0
    3ca8:	be 01       	movw	r22, r28
    3caa:	6f 5f       	subi	r22, 0xFF	; 255
    3cac:	7f 4f       	sbci	r23, 0xFF	; 255
    3cae:	8e 2d       	mov	r24, r14
    3cb0:	90 e0       	ldi	r25, 0x00	; 0
    3cb2:	0e 94 54 23 	call	0x46a8	; 0x46a8 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3cb6:	be 01       	movw	r22, r28
    3cb8:	6f 5f       	subi	r22, 0xFF	; 255
    3cba:	7f 4f       	sbci	r23, 0xFF	; 255
    3cbc:	c8 01       	movw	r24, r16
    3cbe:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3cc2:	c8 01       	movw	r24, r16
    3cc4:	29 96       	adiw	r28, 0x09	; 9
    3cc6:	cd bf       	out	0x3d, r28	; 61
    3cc8:	de bf       	out	0x3e, r29	; 62
    3cca:	df 91       	pop	r29
    3ccc:	cf 91       	pop	r28
    3cce:	1f 91       	pop	r17
    3cd0:	0f 91       	pop	r16
    3cd2:	ff 90       	pop	r15
    3cd4:	ef 90       	pop	r14
    3cd6:	df 90       	pop	r13
    3cd8:	cf 90       	pop	r12
    3cda:	08 95       	ret

00003cdc <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3cdc:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3cde:	50 96       	adiw	r26, 0x10	; 16
    3ce0:	ed 91       	ld	r30, X+
    3ce2:	fc 91       	ld	r31, X
    3ce4:	51 97       	sbiw	r26, 0x11	; 17
    3ce6:	80 81       	ld	r24, Z
    3ce8:	54 96       	adiw	r26, 0x14	; 20
    3cea:	4c 91       	ld	r20, X
    3cec:	54 97       	sbiw	r26, 0x14	; 20
    3cee:	84 23       	and	r24, r20
    3cf0:	29 f0       	breq	.+10     	; 0x3cfc <_ZN5rs2327putcharEc+0x20>
    3cf2:	09 c0       	rjmp	.+18     	; 0x3d06 <_ZN5rs2327putcharEc+0x2a>
    3cf4:	21 50       	subi	r18, 0x01	; 1
    3cf6:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3cf8:	19 f4       	brne	.+6      	; 0x3d00 <_ZN5rs2327putcharEc+0x24>
    3cfa:	12 c0       	rjmp	.+36     	; 0x3d20 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3cfc:	21 e2       	ldi	r18, 0x21	; 33
    3cfe:	3e e4       	ldi	r19, 0x4E	; 78
    3d00:	90 81       	ld	r25, Z
    3d02:	94 23       	and	r25, r20
    3d04:	b9 f3       	breq	.-18     	; 0x3cf4 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3d06:	90 81       	ld	r25, Z
    3d08:	56 96       	adiw	r26, 0x16	; 22
    3d0a:	8c 91       	ld	r24, X
    3d0c:	56 97       	sbiw	r26, 0x16	; 22
    3d0e:	89 2b       	or	r24, r25
    3d10:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3d12:	1e 96       	adiw	r26, 0x0e	; 14
    3d14:	ed 91       	ld	r30, X+
    3d16:	fc 91       	ld	r31, X
    3d18:	1f 97       	sbiw	r26, 0x0f	; 15
    3d1a:	60 83       	st	Z, r22
	return (true);
    3d1c:	81 e0       	ldi	r24, 0x01	; 1
    3d1e:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3d20:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3d22:	08 95       	ret

00003d24 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3d24:	cf 93       	push	r28
    3d26:	df 93       	push	r29
    3d28:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3d2a:	c1 8d       	ldd	r28, Z+25	; 0x19
    3d2c:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3d2e:	28 81       	ld	r18, Y
    3d30:	39 81       	ldd	r19, Y+1	; 0x01
    3d32:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3d34:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3d36:	4d 91       	ld	r20, X+
    3d38:	5c 91       	ld	r21, X
    3d3a:	24 17       	cp	r18, r20
    3d3c:	35 07       	cpc	r19, r21
    3d3e:	e9 f3       	breq	.-6      	; 0x3d3a <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3d40:	a7 89       	ldd	r26, Z+23	; 0x17
    3d42:	b0 8d       	ldd	r27, Z+24	; 0x18
    3d44:	0d 90       	ld	r0, X+
    3d46:	bc 91       	ld	r27, X
    3d48:	a0 2d       	mov	r26, r0
    3d4a:	a2 0f       	add	r26, r18
    3d4c:	b3 1f       	adc	r27, r19
    3d4e:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3d50:	2f 5f       	subi	r18, 0xFF	; 255
    3d52:	3f 4f       	sbci	r19, 0xFF	; 255
    3d54:	28 83       	st	Y, r18
    3d56:	39 83       	std	Y+1, r19	; 0x01
    3d58:	24 36       	cpi	r18, 0x64	; 100
    3d5a:	31 05       	cpc	r19, r1
    3d5c:	28 f0       	brcs	.+10     	; 0x3d68 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3d5e:	01 8c       	ldd	r0, Z+25	; 0x19
    3d60:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3d62:	e0 2d       	mov	r30, r0
    3d64:	10 82       	st	Z, r1
    3d66:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3d68:	90 e0       	ldi	r25, 0x00	; 0
    3d6a:	df 91       	pop	r29
    3d6c:	cf 91       	pop	r28
    3d6e:	08 95       	ret

00003d70 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3d70:	cf 93       	push	r28
    3d72:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3d74:	ec 01       	movw	r28, r24
    3d76:	a9 8d       	ldd	r26, Y+25	; 0x19
    3d78:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3d7a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3d7c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3d7e:	81 e0       	ldi	r24, 0x01	; 1
    3d80:	4d 91       	ld	r20, X+
    3d82:	5c 91       	ld	r21, X
    3d84:	20 81       	ld	r18, Z
    3d86:	31 81       	ldd	r19, Z+1	; 0x01
    3d88:	42 17       	cp	r20, r18
    3d8a:	53 07       	cpc	r21, r19
    3d8c:	09 f4       	brne	.+2      	; 0x3d90 <_ZN5rs23214check_for_charEv+0x20>
    3d8e:	80 e0       	ldi	r24, 0x00	; 0
}
    3d90:	df 91       	pop	r29
    3d92:	cf 91       	pop	r28
    3d94:	08 95       	ret

00003d96 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3d96:	dc 01       	movw	r26, r24
    3d98:	ed 91       	ld	r30, X+
    3d9a:	fc 91       	ld	r31, X
    3d9c:	02 80       	ldd	r0, Z+2	; 0x02
    3d9e:	f3 81       	ldd	r31, Z+3	; 0x03
    3da0:	e0 2d       	mov	r30, r0
    3da2:	6c e0       	ldi	r22, 0x0C	; 12
    3da4:	19 95       	eicall
    3da6:	08 95       	ret

00003da8 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3da8:	ef 92       	push	r14
    3daa:	ff 92       	push	r15
    3dac:	0f 93       	push	r16
    3dae:	1f 93       	push	r17
    3db0:	cf 93       	push	r28
    3db2:	df 93       	push	r29
    3db4:	ec 01       	movw	r28, r24
    3db6:	7b 01       	movw	r14, r22
    3db8:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3dba:	0e 94 c3 1c 	call	0x3986	; 0x3986 <_ZN8emstreamC1Ev>
    3dbe:	a8 01       	movw	r20, r16
    3dc0:	b7 01       	movw	r22, r14
    3dc2:	ce 01       	movw	r24, r28
    3dc4:	08 96       	adiw	r24, 0x08	; 8
    3dc6:	0e 94 24 1c 	call	0x3848	; 0x3848 <_ZN7base232C1EjP12USART_struct>
    3dca:	88 e7       	ldi	r24, 0x78	; 120
    3dcc:	90 e2       	ldi	r25, 0x20	; 32
    3dce:	88 83       	st	Y, r24
    3dd0:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3dd2:	00 3a       	cpi	r16, 0xA0	; 160
    3dd4:	88 e0       	ldi	r24, 0x08	; 8
    3dd6:	18 07       	cpc	r17, r24
    3dd8:	69 f4       	brne	.+26     	; 0x3df4 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3dda:	80 e5       	ldi	r24, 0x50	; 80
    3ddc:	91 e3       	ldi	r25, 0x31	; 49
    3dde:	8f 8b       	std	Y+23, r24	; 0x17
    3de0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3de2:	86 e4       	ldi	r24, 0x46	; 70
    3de4:	91 e3       	ldi	r25, 0x31	; 49
    3de6:	89 8f       	std	Y+25, r24	; 0x19
    3de8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3dea:	8c e3       	ldi	r24, 0x3C	; 60
    3dec:	91 e3       	ldi	r25, 0x31	; 49
    3dee:	8b 8f       	std	Y+27, r24	; 0x1b
    3df0:	9c 8f       	std	Y+28, r25	; 0x1c
    3df2:	42 c0       	rjmp	.+132    	; 0x3e78 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3df4:	00 3b       	cpi	r16, 0xB0	; 176
    3df6:	e8 e0       	ldi	r30, 0x08	; 8
    3df8:	1e 07       	cpc	r17, r30
    3dfa:	69 f4       	brne	.+26     	; 0x3e16 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3dfc:	8e e4       	ldi	r24, 0x4E	; 78
    3dfe:	91 e3       	ldi	r25, 0x31	; 49
    3e00:	8f 8b       	std	Y+23, r24	; 0x17
    3e02:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3e04:	84 e4       	ldi	r24, 0x44	; 68
    3e06:	91 e3       	ldi	r25, 0x31	; 49
    3e08:	89 8f       	std	Y+25, r24	; 0x19
    3e0a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3e0c:	8a e3       	ldi	r24, 0x3A	; 58
    3e0e:	91 e3       	ldi	r25, 0x31	; 49
    3e10:	8b 8f       	std	Y+27, r24	; 0x1b
    3e12:	9c 8f       	std	Y+28, r25	; 0x1c
    3e14:	31 c0       	rjmp	.+98     	; 0x3e78 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3e16:	00 3a       	cpi	r16, 0xA0	; 160
    3e18:	f9 e0       	ldi	r31, 0x09	; 9
    3e1a:	1f 07       	cpc	r17, r31
    3e1c:	69 f4       	brne	.+26     	; 0x3e38 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3e1e:	8c e4       	ldi	r24, 0x4C	; 76
    3e20:	91 e3       	ldi	r25, 0x31	; 49
    3e22:	8f 8b       	std	Y+23, r24	; 0x17
    3e24:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3e26:	82 e4       	ldi	r24, 0x42	; 66
    3e28:	91 e3       	ldi	r25, 0x31	; 49
    3e2a:	89 8f       	std	Y+25, r24	; 0x19
    3e2c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3e2e:	88 e3       	ldi	r24, 0x38	; 56
    3e30:	91 e3       	ldi	r25, 0x31	; 49
    3e32:	8b 8f       	std	Y+27, r24	; 0x1b
    3e34:	9c 8f       	std	Y+28, r25	; 0x1c
    3e36:	20 c0       	rjmp	.+64     	; 0x3e78 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3e38:	00 3b       	cpi	r16, 0xB0	; 176
    3e3a:	89 e0       	ldi	r24, 0x09	; 9
    3e3c:	18 07       	cpc	r17, r24
    3e3e:	69 f4       	brne	.+26     	; 0x3e5a <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3e40:	8a e4       	ldi	r24, 0x4A	; 74
    3e42:	91 e3       	ldi	r25, 0x31	; 49
    3e44:	8f 8b       	std	Y+23, r24	; 0x17
    3e46:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3e48:	80 e4       	ldi	r24, 0x40	; 64
    3e4a:	91 e3       	ldi	r25, 0x31	; 49
    3e4c:	89 8f       	std	Y+25, r24	; 0x19
    3e4e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3e50:	86 e3       	ldi	r24, 0x36	; 54
    3e52:	91 e3       	ldi	r25, 0x31	; 49
    3e54:	8b 8f       	std	Y+27, r24	; 0x1b
    3e56:	9c 8f       	std	Y+28, r25	; 0x1c
    3e58:	0f c0       	rjmp	.+30     	; 0x3e78 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3e5a:	00 3a       	cpi	r16, 0xA0	; 160
    3e5c:	1a 40       	sbci	r17, 0x0A	; 10
    3e5e:	61 f4       	brne	.+24     	; 0x3e78 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3e60:	88 e4       	ldi	r24, 0x48	; 72
    3e62:	91 e3       	ldi	r25, 0x31	; 49
    3e64:	8f 8b       	std	Y+23, r24	; 0x17
    3e66:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3e68:	8e e3       	ldi	r24, 0x3E	; 62
    3e6a:	91 e3       	ldi	r25, 0x31	; 49
    3e6c:	89 8f       	std	Y+25, r24	; 0x19
    3e6e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3e70:	84 e3       	ldi	r24, 0x34	; 52
    3e72:	91 e3       	ldi	r25, 0x31	; 49
    3e74:	8b 8f       	std	Y+27, r24	; 0x1b
    3e76:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3e78:	0f 89       	ldd	r16, Y+23	; 0x17
    3e7a:	18 8d       	ldd	r17, Y+24	; 0x18
    3e7c:	84 e6       	ldi	r24, 0x64	; 100
    3e7e:	90 e0       	ldi	r25, 0x00	; 0
    3e80:	0e 94 20 1c 	call	0x3840	; 0x3840 <_Znaj>
    3e84:	f8 01       	movw	r30, r16
    3e86:	80 83       	st	Z, r24
    3e88:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3e8a:	e9 8d       	ldd	r30, Y+25	; 0x19
    3e8c:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3e8e:	10 82       	st	Z, r1
    3e90:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3e92:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3e94:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3e96:	10 82       	st	Z, r1
    3e98:	11 82       	std	Z+1, r1	; 0x01
}
    3e9a:	df 91       	pop	r29
    3e9c:	cf 91       	pop	r28
    3e9e:	1f 91       	pop	r17
    3ea0:	0f 91       	pop	r16
    3ea2:	ff 90       	pop	r15
    3ea4:	ef 90       	pop	r14
    3ea6:	08 95       	ret

00003ea8 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3ea8:	1f 92       	push	r1
    3eaa:	0f 92       	push	r0
    3eac:	0f b6       	in	r0, 0x3f	; 63
    3eae:	0f 92       	push	r0
    3eb0:	11 24       	eor	r1, r1
    3eb2:	08 b6       	in	r0, 0x38	; 56
    3eb4:	0f 92       	push	r0
    3eb6:	18 be       	out	0x38, r1	; 56
    3eb8:	0b b6       	in	r0, 0x3b	; 59
    3eba:	0f 92       	push	r0
    3ebc:	1b be       	out	0x3b, r1	; 59
    3ebe:	2f 93       	push	r18
    3ec0:	3f 93       	push	r19
    3ec2:	8f 93       	push	r24
    3ec4:	9f 93       	push	r25
    3ec6:	ef 93       	push	r30
    3ec8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3eca:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3ece:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <rcvC0_buffer>
    3ed2:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <rcvC0_buffer+0x1>
    3ed6:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    3eda:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    3ede:	e8 0f       	add	r30, r24
    3ee0:	f9 1f       	adc	r31, r25
    3ee2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3ee4:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    3ee8:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    3eec:	01 96       	adiw	r24, 0x01	; 1
    3eee:	84 36       	cpi	r24, 0x64	; 100
    3ef0:	91 05       	cpc	r25, r1
    3ef2:	60 f4       	brcc	.+24     	; 0x3f0c <__vector_25+0x64>
    3ef4:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <rcvC0_write_index>
    3ef8:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3efc:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <rcvC0_read_index>
    3f00:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <rcvC0_read_index+0x1>
    3f04:	82 17       	cp	r24, r18
    3f06:	93 07       	cpc	r25, r19
    3f08:	f1 f4       	brne	.+60     	; 0x3f46 <__vector_25+0x9e>
    3f0a:	0c c0       	rjmp	.+24     	; 0x3f24 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3f0c:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rcvC0_write_index>
    3f10:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f14:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvC0_read_index>
    3f18:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvC0_read_index+0x1>
    3f1c:	18 16       	cp	r1, r24
    3f1e:	19 06       	cpc	r1, r25
    3f20:	91 f4       	brne	.+36     	; 0x3f46 <__vector_25+0x9e>
    3f22:	0e c0       	rjmp	.+28     	; 0x3f40 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f24:	01 96       	adiw	r24, 0x01	; 1
    3f26:	84 36       	cpi	r24, 0x64	; 100
    3f28:	91 05       	cpc	r25, r1
    3f2a:	28 f4       	brcc	.+10     	; 0x3f36 <__vector_25+0x8e>
    3f2c:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvC0_read_index>
    3f30:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvC0_read_index+0x1>
    3f34:	08 c0       	rjmp	.+16     	; 0x3f46 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3f36:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvC0_read_index>
    3f3a:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvC0_read_index+0x1>
}
    3f3e:	03 c0       	rjmp	.+6      	; 0x3f46 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f40:	81 e0       	ldi	r24, 0x01	; 1
    3f42:	90 e0       	ldi	r25, 0x00	; 0
    3f44:	f3 cf       	rjmp	.-26     	; 0x3f2c <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3f46:	ff 91       	pop	r31
    3f48:	ef 91       	pop	r30
    3f4a:	9f 91       	pop	r25
    3f4c:	8f 91       	pop	r24
    3f4e:	3f 91       	pop	r19
    3f50:	2f 91       	pop	r18
    3f52:	0f 90       	pop	r0
    3f54:	0b be       	out	0x3b, r0	; 59
    3f56:	0f 90       	pop	r0
    3f58:	08 be       	out	0x38, r0	; 56
    3f5a:	0f 90       	pop	r0
    3f5c:	0f be       	out	0x3f, r0	; 63
    3f5e:	0f 90       	pop	r0
    3f60:	1f 90       	pop	r1
    3f62:	18 95       	reti

00003f64 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3f64:	1f 92       	push	r1
    3f66:	0f 92       	push	r0
    3f68:	0f b6       	in	r0, 0x3f	; 63
    3f6a:	0f 92       	push	r0
    3f6c:	11 24       	eor	r1, r1
    3f6e:	08 b6       	in	r0, 0x38	; 56
    3f70:	0f 92       	push	r0
    3f72:	18 be       	out	0x38, r1	; 56
    3f74:	0b b6       	in	r0, 0x3b	; 59
    3f76:	0f 92       	push	r0
    3f78:	1b be       	out	0x3b, r1	; 59
    3f7a:	2f 93       	push	r18
    3f7c:	3f 93       	push	r19
    3f7e:	8f 93       	push	r24
    3f80:	9f 93       	push	r25
    3f82:	ef 93       	push	r30
    3f84:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3f86:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3f8a:	e0 91 4e 31 	lds	r30, 0x314E	; 0x80314e <rcvC1_buffer>
    3f8e:	f0 91 4f 31 	lds	r31, 0x314F	; 0x80314f <rcvC1_buffer+0x1>
    3f92:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC1_write_index>
    3f96:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC1_write_index+0x1>
    3f9a:	e8 0f       	add	r30, r24
    3f9c:	f9 1f       	adc	r31, r25
    3f9e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3fa0:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC1_write_index>
    3fa4:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC1_write_index+0x1>
    3fa8:	01 96       	adiw	r24, 0x01	; 1
    3faa:	84 36       	cpi	r24, 0x64	; 100
    3fac:	91 05       	cpc	r25, r1
    3fae:	60 f4       	brcc	.+24     	; 0x3fc8 <__vector_28+0x64>
    3fb0:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC1_write_index>
    3fb4:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3fb8:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <rcvC1_read_index>
    3fbc:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <rcvC1_read_index+0x1>
    3fc0:	82 17       	cp	r24, r18
    3fc2:	93 07       	cpc	r25, r19
    3fc4:	f1 f4       	brne	.+60     	; 0x4002 <__stack+0x3>
    3fc6:	0c c0       	rjmp	.+24     	; 0x3fe0 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3fc8:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC1_write_index>
    3fcc:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3fd0:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <rcvC1_read_index>
    3fd4:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <rcvC1_read_index+0x1>
    3fd8:	18 16       	cp	r1, r24
    3fda:	19 06       	cpc	r1, r25
    3fdc:	91 f4       	brne	.+36     	; 0x4002 <__stack+0x3>
    3fde:	0e c0       	rjmp	.+28     	; 0x3ffc <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3fe0:	01 96       	adiw	r24, 0x01	; 1
    3fe2:	84 36       	cpi	r24, 0x64	; 100
    3fe4:	91 05       	cpc	r25, r1
    3fe6:	28 f4       	brcc	.+10     	; 0x3ff2 <__vector_28+0x8e>
    3fe8:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <rcvC1_read_index>
    3fec:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <rcvC1_read_index+0x1>
    3ff0:	08 c0       	rjmp	.+16     	; 0x4002 <__stack+0x3>
	rcvC1_read_index = 0;
    3ff2:	10 92 44 31 	sts	0x3144, r1	; 0x803144 <rcvC1_read_index>
    3ff6:	10 92 45 31 	sts	0x3145, r1	; 0x803145 <rcvC1_read_index+0x1>
}
    3ffa:	03 c0       	rjmp	.+6      	; 0x4002 <__stack+0x3>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3ffc:	81 e0       	ldi	r24, 0x01	; 1
    3ffe:	90 e0       	ldi	r25, 0x00	; 0
    4000:	f3 cf       	rjmp	.-26     	; 0x3fe8 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    4002:	ff 91       	pop	r31
    4004:	ef 91       	pop	r30
    4006:	9f 91       	pop	r25
    4008:	8f 91       	pop	r24
    400a:	3f 91       	pop	r19
    400c:	2f 91       	pop	r18
    400e:	0f 90       	pop	r0
    4010:	0b be       	out	0x3b, r0	; 59
    4012:	0f 90       	pop	r0
    4014:	08 be       	out	0x38, r0	; 56
    4016:	0f 90       	pop	r0
    4018:	0f be       	out	0x3f, r0	; 63
    401a:	0f 90       	pop	r0
    401c:	1f 90       	pop	r1
    401e:	18 95       	reti

00004020 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    4020:	1f 92       	push	r1
    4022:	0f 92       	push	r0
    4024:	0f b6       	in	r0, 0x3f	; 63
    4026:	0f 92       	push	r0
    4028:	11 24       	eor	r1, r1
    402a:	08 b6       	in	r0, 0x38	; 56
    402c:	0f 92       	push	r0
    402e:	18 be       	out	0x38, r1	; 56
    4030:	0b b6       	in	r0, 0x3b	; 59
    4032:	0f 92       	push	r0
    4034:	1b be       	out	0x3b, r1	; 59
    4036:	2f 93       	push	r18
    4038:	3f 93       	push	r19
    403a:	8f 93       	push	r24
    403c:	9f 93       	push	r25
    403e:	ef 93       	push	r30
    4040:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    4042:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    4046:	e0 91 4c 31 	lds	r30, 0x314C	; 0x80314c <rcvD0_buffer>
    404a:	f0 91 4d 31 	lds	r31, 0x314D	; 0x80314d <rcvD0_buffer+0x1>
    404e:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    4052:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    4056:	e8 0f       	add	r30, r24
    4058:	f9 1f       	adc	r31, r25
    405a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    405c:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvD0_write_index>
    4060:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvD0_write_index+0x1>
    4064:	01 96       	adiw	r24, 0x01	; 1
    4066:	84 36       	cpi	r24, 0x64	; 100
    4068:	91 05       	cpc	r25, r1
    406a:	60 f4       	brcc	.+24     	; 0x4084 <__vector_88+0x64>
    406c:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvD0_write_index>
    4070:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    4074:	20 91 42 31 	lds	r18, 0x3142	; 0x803142 <rcvD0_read_index>
    4078:	30 91 43 31 	lds	r19, 0x3143	; 0x803143 <rcvD0_read_index+0x1>
    407c:	82 17       	cp	r24, r18
    407e:	93 07       	cpc	r25, r19
    4080:	f1 f4       	brne	.+60     	; 0x40be <__vector_88+0x9e>
    4082:	0c c0       	rjmp	.+24     	; 0x409c <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    4084:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvD0_write_index>
    4088:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    408c:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvD0_read_index>
    4090:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvD0_read_index+0x1>
    4094:	18 16       	cp	r1, r24
    4096:	19 06       	cpc	r1, r25
    4098:	91 f4       	brne	.+36     	; 0x40be <__vector_88+0x9e>
    409a:	0e c0       	rjmp	.+28     	; 0x40b8 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    409c:	01 96       	adiw	r24, 0x01	; 1
    409e:	84 36       	cpi	r24, 0x64	; 100
    40a0:	91 05       	cpc	r25, r1
    40a2:	28 f4       	brcc	.+10     	; 0x40ae <__vector_88+0x8e>
    40a4:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <rcvD0_read_index>
    40a8:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <rcvD0_read_index+0x1>
    40ac:	08 c0       	rjmp	.+16     	; 0x40be <__vector_88+0x9e>
	rcvD0_read_index = 0;
    40ae:	10 92 42 31 	sts	0x3142, r1	; 0x803142 <rcvD0_read_index>
    40b2:	10 92 43 31 	sts	0x3143, r1	; 0x803143 <rcvD0_read_index+0x1>
}
    40b6:	03 c0       	rjmp	.+6      	; 0x40be <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    40b8:	81 e0       	ldi	r24, 0x01	; 1
    40ba:	90 e0       	ldi	r25, 0x00	; 0
    40bc:	f3 cf       	rjmp	.-26     	; 0x40a4 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    40be:	ff 91       	pop	r31
    40c0:	ef 91       	pop	r30
    40c2:	9f 91       	pop	r25
    40c4:	8f 91       	pop	r24
    40c6:	3f 91       	pop	r19
    40c8:	2f 91       	pop	r18
    40ca:	0f 90       	pop	r0
    40cc:	0b be       	out	0x3b, r0	; 59
    40ce:	0f 90       	pop	r0
    40d0:	08 be       	out	0x38, r0	; 56
    40d2:	0f 90       	pop	r0
    40d4:	0f be       	out	0x3f, r0	; 63
    40d6:	0f 90       	pop	r0
    40d8:	1f 90       	pop	r1
    40da:	18 95       	reti

000040dc <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    40dc:	1f 92       	push	r1
    40de:	0f 92       	push	r0
    40e0:	0f b6       	in	r0, 0x3f	; 63
    40e2:	0f 92       	push	r0
    40e4:	11 24       	eor	r1, r1
    40e6:	08 b6       	in	r0, 0x38	; 56
    40e8:	0f 92       	push	r0
    40ea:	18 be       	out	0x38, r1	; 56
    40ec:	0b b6       	in	r0, 0x3b	; 59
    40ee:	0f 92       	push	r0
    40f0:	1b be       	out	0x3b, r1	; 59
    40f2:	2f 93       	push	r18
    40f4:	3f 93       	push	r19
    40f6:	8f 93       	push	r24
    40f8:	9f 93       	push	r25
    40fa:	ef 93       	push	r30
    40fc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    40fe:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    4102:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <rcvD1_buffer>
    4106:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <rcvD1_buffer+0x1>
    410a:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD1_write_index>
    410e:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD1_write_index+0x1>
    4112:	e8 0f       	add	r30, r24
    4114:	f9 1f       	adc	r31, r25
    4116:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    4118:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD1_write_index>
    411c:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD1_write_index+0x1>
    4120:	01 96       	adiw	r24, 0x01	; 1
    4122:	84 36       	cpi	r24, 0x64	; 100
    4124:	91 05       	cpc	r25, r1
    4126:	60 f4       	brcc	.+24     	; 0x4140 <__vector_91+0x64>
    4128:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD1_write_index>
    412c:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4130:	20 91 40 31 	lds	r18, 0x3140	; 0x803140 <rcvD1_read_index>
    4134:	30 91 41 31 	lds	r19, 0x3141	; 0x803141 <rcvD1_read_index+0x1>
    4138:	82 17       	cp	r24, r18
    413a:	93 07       	cpc	r25, r19
    413c:	f1 f4       	brne	.+60     	; 0x417a <__vector_91+0x9e>
    413e:	0c c0       	rjmp	.+24     	; 0x4158 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    4140:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD1_write_index>
    4144:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4148:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvD1_read_index>
    414c:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvD1_read_index+0x1>
    4150:	18 16       	cp	r1, r24
    4152:	19 06       	cpc	r1, r25
    4154:	91 f4       	brne	.+36     	; 0x417a <__vector_91+0x9e>
    4156:	0e c0       	rjmp	.+28     	; 0x4174 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4158:	01 96       	adiw	r24, 0x01	; 1
    415a:	84 36       	cpi	r24, 0x64	; 100
    415c:	91 05       	cpc	r25, r1
    415e:	28 f4       	brcc	.+10     	; 0x416a <__vector_91+0x8e>
    4160:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <rcvD1_read_index>
    4164:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <rcvD1_read_index+0x1>
    4168:	08 c0       	rjmp	.+16     	; 0x417a <__vector_91+0x9e>
	rcvD1_read_index = 0;
    416a:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rcvD1_read_index>
    416e:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <rcvD1_read_index+0x1>
}
    4172:	03 c0       	rjmp	.+6      	; 0x417a <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4174:	81 e0       	ldi	r24, 0x01	; 1
    4176:	90 e0       	ldi	r25, 0x00	; 0
    4178:	f3 cf       	rjmp	.-26     	; 0x4160 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    417a:	ff 91       	pop	r31
    417c:	ef 91       	pop	r30
    417e:	9f 91       	pop	r25
    4180:	8f 91       	pop	r24
    4182:	3f 91       	pop	r19
    4184:	2f 91       	pop	r18
    4186:	0f 90       	pop	r0
    4188:	0b be       	out	0x3b, r0	; 59
    418a:	0f 90       	pop	r0
    418c:	08 be       	out	0x38, r0	; 56
    418e:	0f 90       	pop	r0
    4190:	0f be       	out	0x3f, r0	; 63
    4192:	0f 90       	pop	r0
    4194:	1f 90       	pop	r1
    4196:	18 95       	reti

00004198 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    4198:	1f 92       	push	r1
    419a:	0f 92       	push	r0
    419c:	0f b6       	in	r0, 0x3f	; 63
    419e:	0f 92       	push	r0
    41a0:	11 24       	eor	r1, r1
    41a2:	08 b6       	in	r0, 0x38	; 56
    41a4:	0f 92       	push	r0
    41a6:	18 be       	out	0x38, r1	; 56
    41a8:	0b b6       	in	r0, 0x3b	; 59
    41aa:	0f 92       	push	r0
    41ac:	1b be       	out	0x3b, r1	; 59
    41ae:	2f 93       	push	r18
    41b0:	3f 93       	push	r19
    41b2:	8f 93       	push	r24
    41b4:	9f 93       	push	r25
    41b6:	ef 93       	push	r30
    41b8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    41ba:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    41be:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <rcvE0_buffer>
    41c2:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <rcvE0_buffer+0x1>
    41c6:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvE0_write_index>
    41ca:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvE0_write_index+0x1>
    41ce:	e8 0f       	add	r30, r24
    41d0:	f9 1f       	adc	r31, r25
    41d2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    41d4:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvE0_write_index>
    41d8:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvE0_write_index+0x1>
    41dc:	01 96       	adiw	r24, 0x01	; 1
    41de:	84 36       	cpi	r24, 0x64	; 100
    41e0:	91 05       	cpc	r25, r1
    41e2:	60 f4       	brcc	.+24     	; 0x41fc <__vector_58+0x64>
    41e4:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvE0_write_index>
    41e8:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    41ec:	20 91 3e 31 	lds	r18, 0x313E	; 0x80313e <rcvE0_read_index>
    41f0:	30 91 3f 31 	lds	r19, 0x313F	; 0x80313f <rcvE0_read_index+0x1>
    41f4:	82 17       	cp	r24, r18
    41f6:	93 07       	cpc	r25, r19
    41f8:	f1 f4       	brne	.+60     	; 0x4236 <__vector_58+0x9e>
    41fa:	0c c0       	rjmp	.+24     	; 0x4214 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    41fc:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvE0_write_index>
    4200:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4204:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvE0_read_index>
    4208:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvE0_read_index+0x1>
    420c:	18 16       	cp	r1, r24
    420e:	19 06       	cpc	r1, r25
    4210:	91 f4       	brne	.+36     	; 0x4236 <__vector_58+0x9e>
    4212:	0e c0       	rjmp	.+28     	; 0x4230 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4214:	01 96       	adiw	r24, 0x01	; 1
    4216:	84 36       	cpi	r24, 0x64	; 100
    4218:	91 05       	cpc	r25, r1
    421a:	28 f4       	brcc	.+10     	; 0x4226 <__vector_58+0x8e>
    421c:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <rcvE0_read_index>
    4220:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <rcvE0_read_index+0x1>
    4224:	08 c0       	rjmp	.+16     	; 0x4236 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    4226:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <rcvE0_read_index>
    422a:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <rcvE0_read_index+0x1>
}
    422e:	03 c0       	rjmp	.+6      	; 0x4236 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4230:	81 e0       	ldi	r24, 0x01	; 1
    4232:	90 e0       	ldi	r25, 0x00	; 0
    4234:	f3 cf       	rjmp	.-26     	; 0x421c <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    4236:	ff 91       	pop	r31
    4238:	ef 91       	pop	r30
    423a:	9f 91       	pop	r25
    423c:	8f 91       	pop	r24
    423e:	3f 91       	pop	r19
    4240:	2f 91       	pop	r18
    4242:	0f 90       	pop	r0
    4244:	0b be       	out	0x3b, r0	; 59
    4246:	0f 90       	pop	r0
    4248:	08 be       	out	0x38, r0	; 56
    424a:	0f 90       	pop	r0
    424c:	0f be       	out	0x3f, r0	; 63
    424e:	0f 90       	pop	r0
    4250:	1f 90       	pop	r1
    4252:	18 95       	reti

00004254 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4254:	0f 93       	push	r16
    4256:	cf 93       	push	r28
    4258:	df 93       	push	r29
    425a:	1f 92       	push	r1
    425c:	cd b7       	in	r28, 0x3d	; 61
    425e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4260:	2f b7       	in	r18, 0x3f	; 63
    4262:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4264:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4266:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4268:	fc 01       	movw	r30, r24
    426a:	08 ed       	ldi	r16, 0xD8	; 216
    426c:	04 bf       	out	0x34, r16	; 52
    426e:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4270:	89 81       	ldd	r24, Y+1	; 0x01
    4272:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4274:	0f 90       	pop	r0
    4276:	df 91       	pop	r29
    4278:	cf 91       	pop	r28
    427a:	0f 91       	pop	r16
    427c:	08 95       	ret

0000427e <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    427e:	0f 93       	push	r16
    4280:	1f 93       	push	r17
    4282:	cf 93       	push	r28
    4284:	df 93       	push	r29
    4286:	cd b7       	in	r28, 0x3d	; 61
    4288:	de b7       	in	r29, 0x3e	; 62
    428a:	6d 97       	sbiw	r28, 0x1d	; 29
    428c:	cd bf       	out	0x3d, r28	; 61
    428e:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    4290:	e0 e6       	ldi	r30, 0x60	; 96
    4292:	f6 e0       	ldi	r31, 0x06	; 6
    4294:	80 e4       	ldi	r24, 0x40	; 64
    4296:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    4298:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    429a:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    429c:	e0 e5       	ldi	r30, 0x50	; 80
    429e:	f0 e0       	ldi	r31, 0x00	; 0
    42a0:	80 81       	ld	r24, Z
    42a2:	82 60       	ori	r24, 0x02	; 2
    42a4:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    42a6:	81 81       	ldd	r24, Z+1	; 0x01
    42a8:	81 ff       	sbrs	r24, 1
    42aa:	fd cf       	rjmp	.-6      	; 0x42a6 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    42ac:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    42b0:	68 7f       	andi	r22, 0xF8	; 248
    42b2:	61 60       	ori	r22, 0x01	; 1
    42b4:	80 e4       	ldi	r24, 0x40	; 64
    42b6:	90 e0       	ldi	r25, 0x00	; 0
    42b8:	0e 94 2a 21 	call	0x4254	; 0x4254 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    42bc:	e0 e5       	ldi	r30, 0x50	; 80
    42be:	f0 e0       	ldi	r31, 0x00	; 0
    42c0:	80 81       	ld	r24, Z
    42c2:	8e 7f       	andi	r24, 0xFE	; 254
    42c4:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    42c6:	9d ef       	ldi	r25, 0xFD	; 253
    42c8:	88 ed       	ldi	r24, 0xD8	; 216
    42ca:	08 b6       	in	r0, 0x38	; 56
    42cc:	18 be       	out	0x38, r1	; 56
    42ce:	84 bf       	out	0x34, r24	; 52
    42d0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    42d4:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    42d6:	40 eb       	ldi	r20, 0xB0	; 176
    42d8:	58 e0       	ldi	r21, 0x08	; 8
    42da:	60 e0       	ldi	r22, 0x00	; 0
    42dc:	70 e0       	ldi	r23, 0x00	; 0
    42de:	ce 01       	movw	r24, r28
    42e0:	01 96       	adiw	r24, 0x01	; 1
    42e2:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    42e6:	67 e0       	ldi	r22, 0x07	; 7
    42e8:	ce 01       	movw	r24, r28
    42ea:	01 96       	adiw	r24, 0x01	; 1
    42ec:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    42f0:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    42f2:	64 e8       	ldi	r22, 0x84	; 132
    42f4:	70 e2       	ldi	r23, 0x20	; 32
    42f6:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <_ZN8emstream4putsEPKc>
    42fa:	66 e0       	ldi	r22, 0x06	; 6
    42fc:	c8 01       	movw	r24, r16
    42fe:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
    4302:	66 e0       	ldi	r22, 0x06	; 6
    4304:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    4308:	82 e1       	ldi	r24, 0x12	; 18
    430a:	90 e0       	ldi	r25, 0x00	; 0
    430c:	0e 94 1d 1c 	call	0x383a	; 0x383a <_Znwj>
    4310:	8e 01       	movw	r16, r28
    4312:	0f 5f       	subi	r16, 0xFF	; 255
    4314:	1f 4f       	sbci	r17, 0xFF	; 255
    4316:	24 e0       	ldi	r18, 0x04	; 4
    4318:	31 e0       	ldi	r19, 0x01	; 1
    431a:	40 e0       	ldi	r20, 0x00	; 0
    431c:	63 ea       	ldi	r22, 0xA3	; 163
    431e:	70 e2       	ldi	r23, 0x20	; 32
    4320:	0e 94 4d 09 	call	0x129a	; 0x129a <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    4324:	82 e1       	ldi	r24, 0x12	; 18
    4326:	90 e0       	ldi	r25, 0x00	; 0
    4328:	0e 94 1d 1c 	call	0x383a	; 0x383a <_Znwj>
    432c:	24 e0       	ldi	r18, 0x04	; 4
    432e:	31 e0       	ldi	r19, 0x01	; 1
    4330:	42 e0       	ldi	r20, 0x02	; 2
    4332:	6b ea       	ldi	r22, 0xAB	; 171
    4334:	70 e2       	ldi	r23, 0x20	; 32
    4336:	0e 94 4b 04 	call	0x896	; 0x896 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    433a:	82 e1       	ldi	r24, 0x12	; 18
    433c:	90 e0       	ldi	r25, 0x00	; 0
    433e:	0e 94 1d 1c 	call	0x383a	; 0x383a <_Znwj>
    4342:	24 e0       	ldi	r18, 0x04	; 4
    4344:	31 e0       	ldi	r19, 0x01	; 1
    4346:	43 e0       	ldi	r20, 0x03	; 3
    4348:	62 eb       	ldi	r22, 0xB2	; 178
    434a:	70 e2       	ldi	r23, 0x20	; 32
    434c:	0e 94 a4 04 	call	0x948	; 0x948 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    4350:	82 e1       	ldi	r24, 0x12	; 18
    4352:	90 e0       	ldi	r25, 0x00	; 0
    4354:	0e 94 1d 1c 	call	0x383a	; 0x383a <_Znwj>
    4358:	24 e0       	ldi	r18, 0x04	; 4
    435a:	31 e0       	ldi	r19, 0x01	; 1
    435c:	44 e0       	ldi	r20, 0x04	; 4
    435e:	69 eb       	ldi	r22, 0xB9	; 185
    4360:	70 e2       	ldi	r23, 0x20	; 32
    4362:	0e 94 09 05 	call	0xa12	; 0xa12 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    4366:	8c e6       	ldi	r24, 0x6C	; 108
    4368:	90 e0       	ldi	r25, 0x00	; 0
    436a:	0e 94 1d 1c 	call	0x383a	; 0x383a <_Znwj>
    436e:	24 e0       	ldi	r18, 0x04	; 4
    4370:	31 e0       	ldi	r19, 0x01	; 1
    4372:	43 e0       	ldi	r20, 0x03	; 3
    4374:	62 ec       	ldi	r22, 0xC2	; 194
    4376:	70 e2       	ldi	r23, 0x20	; 32
    4378:	0e 94 0f 09 	call	0x121e	; 0x121e <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    437c:	87 e0       	ldi	r24, 0x07	; 7
    437e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4382:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4384:	0e 94 2f 13 	call	0x265e	; 0x265e <vTaskStartScheduler>
	
	
	return 0;
    4388:	80 e0       	ldi	r24, 0x00	; 0
    438a:	90 e0       	ldi	r25, 0x00	; 0
    438c:	6d 96       	adiw	r28, 0x1d	; 29
    438e:	cd bf       	out	0x3d, r28	; 61
    4390:	de bf       	out	0x3e, r29	; 62
    4392:	df 91       	pop	r29
    4394:	cf 91       	pop	r28
    4396:	1f 91       	pop	r17
    4398:	0f 91       	pop	r16
    439a:	08 95       	ret

0000439c <_GLOBAL__sub_I_counter>:
    439c:	0f 93       	push	r16
    439e:	1f 93       	push	r17
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    43a0:	0a e0       	ldi	r16, 0x0A	; 10
    43a2:	10 e0       	ldi	r17, 0x00	; 0
    43a4:	20 e0       	ldi	r18, 0x00	; 0
    43a6:	30 e0       	ldi	r19, 0x00	; 0
    43a8:	40 e0       	ldi	r20, 0x00	; 0
    43aa:	50 e0       	ldi	r21, 0x00	; 0
    43ac:	60 e2       	ldi	r22, 0x20	; 32
    43ae:	70 e0       	ldi	r23, 0x00	; 0
    43b0:	80 e6       	ldi	r24, 0x60	; 96
    43b2:	91 e3       	ldi	r25, 0x31	; 49
    43b4:	0e 94 89 1a 	call	0x3512	; 0x3512 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    43b8:	1f 91       	pop	r17
    43ba:	0f 91       	pop	r16
    43bc:	08 95       	ret

000043be <__cmpsf2>:
    43be:	0e 94 21 22 	call	0x4442	; 0x4442 <__fp_cmp>
    43c2:	08 f4       	brcc	.+2      	; 0x43c6 <__cmpsf2+0x8>
    43c4:	81 e0       	ldi	r24, 0x01	; 1
    43c6:	08 95       	ret

000043c8 <__floatunsisf>:
    43c8:	e8 94       	clt
    43ca:	09 c0       	rjmp	.+18     	; 0x43de <__floatsisf+0x12>

000043cc <__floatsisf>:
    43cc:	97 fb       	bst	r25, 7
    43ce:	3e f4       	brtc	.+14     	; 0x43de <__floatsisf+0x12>
    43d0:	90 95       	com	r25
    43d2:	80 95       	com	r24
    43d4:	70 95       	com	r23
    43d6:	61 95       	neg	r22
    43d8:	7f 4f       	sbci	r23, 0xFF	; 255
    43da:	8f 4f       	sbci	r24, 0xFF	; 255
    43dc:	9f 4f       	sbci	r25, 0xFF	; 255
    43de:	99 23       	and	r25, r25
    43e0:	a9 f0       	breq	.+42     	; 0x440c <__floatsisf+0x40>
    43e2:	f9 2f       	mov	r31, r25
    43e4:	96 e9       	ldi	r25, 0x96	; 150
    43e6:	bb 27       	eor	r27, r27
    43e8:	93 95       	inc	r25
    43ea:	f6 95       	lsr	r31
    43ec:	87 95       	ror	r24
    43ee:	77 95       	ror	r23
    43f0:	67 95       	ror	r22
    43f2:	b7 95       	ror	r27
    43f4:	f1 11       	cpse	r31, r1
    43f6:	f8 cf       	rjmp	.-16     	; 0x43e8 <__floatsisf+0x1c>
    43f8:	fa f4       	brpl	.+62     	; 0x4438 <__floatsisf+0x6c>
    43fa:	bb 0f       	add	r27, r27
    43fc:	11 f4       	brne	.+4      	; 0x4402 <__floatsisf+0x36>
    43fe:	60 ff       	sbrs	r22, 0
    4400:	1b c0       	rjmp	.+54     	; 0x4438 <__floatsisf+0x6c>
    4402:	6f 5f       	subi	r22, 0xFF	; 255
    4404:	7f 4f       	sbci	r23, 0xFF	; 255
    4406:	8f 4f       	sbci	r24, 0xFF	; 255
    4408:	9f 4f       	sbci	r25, 0xFF	; 255
    440a:	16 c0       	rjmp	.+44     	; 0x4438 <__floatsisf+0x6c>
    440c:	88 23       	and	r24, r24
    440e:	11 f0       	breq	.+4      	; 0x4414 <__floatsisf+0x48>
    4410:	96 e9       	ldi	r25, 0x96	; 150
    4412:	11 c0       	rjmp	.+34     	; 0x4436 <__floatsisf+0x6a>
    4414:	77 23       	and	r23, r23
    4416:	21 f0       	breq	.+8      	; 0x4420 <__floatsisf+0x54>
    4418:	9e e8       	ldi	r25, 0x8E	; 142
    441a:	87 2f       	mov	r24, r23
    441c:	76 2f       	mov	r23, r22
    441e:	05 c0       	rjmp	.+10     	; 0x442a <__floatsisf+0x5e>
    4420:	66 23       	and	r22, r22
    4422:	71 f0       	breq	.+28     	; 0x4440 <__floatsisf+0x74>
    4424:	96 e8       	ldi	r25, 0x86	; 134
    4426:	86 2f       	mov	r24, r22
    4428:	70 e0       	ldi	r23, 0x00	; 0
    442a:	60 e0       	ldi	r22, 0x00	; 0
    442c:	2a f0       	brmi	.+10     	; 0x4438 <__floatsisf+0x6c>
    442e:	9a 95       	dec	r25
    4430:	66 0f       	add	r22, r22
    4432:	77 1f       	adc	r23, r23
    4434:	88 1f       	adc	r24, r24
    4436:	da f7       	brpl	.-10     	; 0x442e <__floatsisf+0x62>
    4438:	88 0f       	add	r24, r24
    443a:	96 95       	lsr	r25
    443c:	87 95       	ror	r24
    443e:	97 f9       	bld	r25, 7
    4440:	08 95       	ret

00004442 <__fp_cmp>:
    4442:	99 0f       	add	r25, r25
    4444:	00 08       	sbc	r0, r0
    4446:	55 0f       	add	r21, r21
    4448:	aa 0b       	sbc	r26, r26
    444a:	e0 e8       	ldi	r30, 0x80	; 128
    444c:	fe ef       	ldi	r31, 0xFE	; 254
    444e:	16 16       	cp	r1, r22
    4450:	17 06       	cpc	r1, r23
    4452:	e8 07       	cpc	r30, r24
    4454:	f9 07       	cpc	r31, r25
    4456:	c0 f0       	brcs	.+48     	; 0x4488 <__fp_cmp+0x46>
    4458:	12 16       	cp	r1, r18
    445a:	13 06       	cpc	r1, r19
    445c:	e4 07       	cpc	r30, r20
    445e:	f5 07       	cpc	r31, r21
    4460:	98 f0       	brcs	.+38     	; 0x4488 <__fp_cmp+0x46>
    4462:	62 1b       	sub	r22, r18
    4464:	73 0b       	sbc	r23, r19
    4466:	84 0b       	sbc	r24, r20
    4468:	95 0b       	sbc	r25, r21
    446a:	39 f4       	brne	.+14     	; 0x447a <__fp_cmp+0x38>
    446c:	0a 26       	eor	r0, r26
    446e:	61 f0       	breq	.+24     	; 0x4488 <__fp_cmp+0x46>
    4470:	23 2b       	or	r18, r19
    4472:	24 2b       	or	r18, r20
    4474:	25 2b       	or	r18, r21
    4476:	21 f4       	brne	.+8      	; 0x4480 <__fp_cmp+0x3e>
    4478:	08 95       	ret
    447a:	0a 26       	eor	r0, r26
    447c:	09 f4       	brne	.+2      	; 0x4480 <__fp_cmp+0x3e>
    447e:	a1 40       	sbci	r26, 0x01	; 1
    4480:	a6 95       	lsr	r26
    4482:	8f ef       	ldi	r24, 0xFF	; 255
    4484:	81 1d       	adc	r24, r1
    4486:	81 1d       	adc	r24, r1
    4488:	08 95       	ret

0000448a <__gesf2>:
    448a:	0e 94 21 22 	call	0x4442	; 0x4442 <__fp_cmp>
    448e:	08 f4       	brcc	.+2      	; 0x4492 <__gesf2+0x8>
    4490:	8f ef       	ldi	r24, 0xFF	; 255
    4492:	08 95       	ret

00004494 <__mulsi3>:
    4494:	db 01       	movw	r26, r22
    4496:	8f 93       	push	r24
    4498:	9f 93       	push	r25
    449a:	0e 94 d6 22 	call	0x45ac	; 0x45ac <__muluhisi3>
    449e:	bf 91       	pop	r27
    44a0:	af 91       	pop	r26
    44a2:	a2 9f       	mul	r26, r18
    44a4:	80 0d       	add	r24, r0
    44a6:	91 1d       	adc	r25, r1
    44a8:	a3 9f       	mul	r26, r19
    44aa:	90 0d       	add	r25, r0
    44ac:	b2 9f       	mul	r27, r18
    44ae:	90 0d       	add	r25, r0
    44b0:	11 24       	eor	r1, r1
    44b2:	08 95       	ret

000044b4 <__divmodhi4>:
    44b4:	97 fb       	bst	r25, 7
    44b6:	07 2e       	mov	r0, r23
    44b8:	16 f4       	brtc	.+4      	; 0x44be <__divmodhi4+0xa>
    44ba:	00 94       	com	r0
    44bc:	07 d0       	rcall	.+14     	; 0x44cc <__divmodhi4_neg1>
    44be:	77 fd       	sbrc	r23, 7
    44c0:	09 d0       	rcall	.+18     	; 0x44d4 <__divmodhi4_neg2>
    44c2:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <__udivmodhi4>
    44c6:	07 fc       	sbrc	r0, 7
    44c8:	05 d0       	rcall	.+10     	; 0x44d4 <__divmodhi4_neg2>
    44ca:	3e f4       	brtc	.+14     	; 0x44da <__divmodhi4_exit>

000044cc <__divmodhi4_neg1>:
    44cc:	90 95       	com	r25
    44ce:	81 95       	neg	r24
    44d0:	9f 4f       	sbci	r25, 0xFF	; 255
    44d2:	08 95       	ret

000044d4 <__divmodhi4_neg2>:
    44d4:	70 95       	com	r23
    44d6:	61 95       	neg	r22
    44d8:	7f 4f       	sbci	r23, 0xFF	; 255

000044da <__divmodhi4_exit>:
    44da:	08 95       	ret

000044dc <__udivmodsi4>:
    44dc:	a1 e2       	ldi	r26, 0x21	; 33
    44de:	1a 2e       	mov	r1, r26
    44e0:	aa 1b       	sub	r26, r26
    44e2:	bb 1b       	sub	r27, r27
    44e4:	fd 01       	movw	r30, r26
    44e6:	0d c0       	rjmp	.+26     	; 0x4502 <__udivmodsi4_ep>

000044e8 <__udivmodsi4_loop>:
    44e8:	aa 1f       	adc	r26, r26
    44ea:	bb 1f       	adc	r27, r27
    44ec:	ee 1f       	adc	r30, r30
    44ee:	ff 1f       	adc	r31, r31
    44f0:	a2 17       	cp	r26, r18
    44f2:	b3 07       	cpc	r27, r19
    44f4:	e4 07       	cpc	r30, r20
    44f6:	f5 07       	cpc	r31, r21
    44f8:	20 f0       	brcs	.+8      	; 0x4502 <__udivmodsi4_ep>
    44fa:	a2 1b       	sub	r26, r18
    44fc:	b3 0b       	sbc	r27, r19
    44fe:	e4 0b       	sbc	r30, r20
    4500:	f5 0b       	sbc	r31, r21

00004502 <__udivmodsi4_ep>:
    4502:	66 1f       	adc	r22, r22
    4504:	77 1f       	adc	r23, r23
    4506:	88 1f       	adc	r24, r24
    4508:	99 1f       	adc	r25, r25
    450a:	1a 94       	dec	r1
    450c:	69 f7       	brne	.-38     	; 0x44e8 <__udivmodsi4_loop>
    450e:	60 95       	com	r22
    4510:	70 95       	com	r23
    4512:	80 95       	com	r24
    4514:	90 95       	com	r25
    4516:	9b 01       	movw	r18, r22
    4518:	ac 01       	movw	r20, r24
    451a:	bd 01       	movw	r22, r26
    451c:	cf 01       	movw	r24, r30
    451e:	08 95       	ret

00004520 <__divmodsi4>:
    4520:	05 2e       	mov	r0, r21
    4522:	97 fb       	bst	r25, 7
    4524:	1e f4       	brtc	.+6      	; 0x452c <__divmodsi4+0xc>
    4526:	00 94       	com	r0
    4528:	0e 94 a7 22 	call	0x454e	; 0x454e <__negsi2>
    452c:	57 fd       	sbrc	r21, 7
    452e:	07 d0       	rcall	.+14     	; 0x453e <__divmodsi4_neg2>
    4530:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__udivmodsi4>
    4534:	07 fc       	sbrc	r0, 7
    4536:	03 d0       	rcall	.+6      	; 0x453e <__divmodsi4_neg2>
    4538:	4e f4       	brtc	.+18     	; 0x454c <__divmodsi4_exit>
    453a:	0c 94 a7 22 	jmp	0x454e	; 0x454e <__negsi2>

0000453e <__divmodsi4_neg2>:
    453e:	50 95       	com	r21
    4540:	40 95       	com	r20
    4542:	30 95       	com	r19
    4544:	21 95       	neg	r18
    4546:	3f 4f       	sbci	r19, 0xFF	; 255
    4548:	4f 4f       	sbci	r20, 0xFF	; 255
    454a:	5f 4f       	sbci	r21, 0xFF	; 255

0000454c <__divmodsi4_exit>:
    454c:	08 95       	ret

0000454e <__negsi2>:
    454e:	90 95       	com	r25
    4550:	80 95       	com	r24
    4552:	70 95       	com	r23
    4554:	61 95       	neg	r22
    4556:	7f 4f       	sbci	r23, 0xFF	; 255
    4558:	8f 4f       	sbci	r24, 0xFF	; 255
    455a:	9f 4f       	sbci	r25, 0xFF	; 255
    455c:	08 95       	ret

0000455e <__tablejump2__>:
    455e:	ee 0f       	add	r30, r30
    4560:	ff 1f       	adc	r31, r31
    4562:	88 1f       	adc	r24, r24
    4564:	8b bf       	out	0x3b, r24	; 59
    4566:	07 90       	elpm	r0, Z+
    4568:	f6 91       	elpm	r31, Z
    456a:	e0 2d       	mov	r30, r0
    456c:	1b be       	out	0x3b, r1	; 59
    456e:	19 94       	eijmp

00004570 <__mulhisi3>:
    4570:	0e 94 c0 22 	call	0x4580	; 0x4580 <__umulhisi3>
    4574:	33 23       	and	r19, r19
    4576:	12 f4       	brpl	.+4      	; 0x457c <__mulhisi3+0xc>
    4578:	8a 1b       	sub	r24, r26
    457a:	9b 0b       	sbc	r25, r27
    457c:	0c 94 d1 22 	jmp	0x45a2	; 0x45a2 <__usmulhisi3_tail>

00004580 <__umulhisi3>:
    4580:	a2 9f       	mul	r26, r18
    4582:	b0 01       	movw	r22, r0
    4584:	b3 9f       	mul	r27, r19
    4586:	c0 01       	movw	r24, r0
    4588:	a3 9f       	mul	r26, r19
    458a:	70 0d       	add	r23, r0
    458c:	81 1d       	adc	r24, r1
    458e:	11 24       	eor	r1, r1
    4590:	91 1d       	adc	r25, r1
    4592:	b2 9f       	mul	r27, r18
    4594:	70 0d       	add	r23, r0
    4596:	81 1d       	adc	r24, r1
    4598:	11 24       	eor	r1, r1
    459a:	91 1d       	adc	r25, r1
    459c:	08 95       	ret

0000459e <__usmulhisi3>:
    459e:	0e 94 c0 22 	call	0x4580	; 0x4580 <__umulhisi3>

000045a2 <__usmulhisi3_tail>:
    45a2:	b7 ff       	sbrs	r27, 7
    45a4:	08 95       	ret
    45a6:	82 1b       	sub	r24, r18
    45a8:	93 0b       	sbc	r25, r19
    45aa:	08 95       	ret

000045ac <__muluhisi3>:
    45ac:	0e 94 c0 22 	call	0x4580	; 0x4580 <__umulhisi3>
    45b0:	a5 9f       	mul	r26, r21
    45b2:	90 0d       	add	r25, r0
    45b4:	b4 9f       	mul	r27, r20
    45b6:	90 0d       	add	r25, r0
    45b8:	a4 9f       	mul	r26, r20
    45ba:	80 0d       	add	r24, r0
    45bc:	91 1d       	adc	r25, r1
    45be:	11 24       	eor	r1, r1
    45c0:	08 95       	ret

000045c2 <__mulshisi3>:
    45c2:	b7 ff       	sbrs	r27, 7
    45c4:	0c 94 d6 22 	jmp	0x45ac	; 0x45ac <__muluhisi3>

000045c8 <__mulohisi3>:
    45c8:	0e 94 d6 22 	call	0x45ac	; 0x45ac <__muluhisi3>
    45cc:	82 1b       	sub	r24, r18
    45ce:	93 0b       	sbc	r25, r19
    45d0:	08 95       	ret

000045d2 <__udivmodhi4>:
    45d2:	aa 1b       	sub	r26, r26
    45d4:	bb 1b       	sub	r27, r27
    45d6:	51 e1       	ldi	r21, 0x11	; 17
    45d8:	07 c0       	rjmp	.+14     	; 0x45e8 <__udivmodhi4_ep>

000045da <__udivmodhi4_loop>:
    45da:	aa 1f       	adc	r26, r26
    45dc:	bb 1f       	adc	r27, r27
    45de:	a6 17       	cp	r26, r22
    45e0:	b7 07       	cpc	r27, r23
    45e2:	10 f0       	brcs	.+4      	; 0x45e8 <__udivmodhi4_ep>
    45e4:	a6 1b       	sub	r26, r22
    45e6:	b7 0b       	sbc	r27, r23

000045e8 <__udivmodhi4_ep>:
    45e8:	88 1f       	adc	r24, r24
    45ea:	99 1f       	adc	r25, r25
    45ec:	5a 95       	dec	r21
    45ee:	a9 f7       	brne	.-22     	; 0x45da <__udivmodhi4_loop>
    45f0:	80 95       	com	r24
    45f2:	90 95       	com	r25
    45f4:	bc 01       	movw	r22, r24
    45f6:	cd 01       	movw	r24, r26
    45f8:	08 95       	ret

000045fa <memcpy>:
    45fa:	fb 01       	movw	r30, r22
    45fc:	dc 01       	movw	r26, r24
    45fe:	02 c0       	rjmp	.+4      	; 0x4604 <memcpy+0xa>
    4600:	01 90       	ld	r0, Z+
    4602:	0d 92       	st	X+, r0
    4604:	41 50       	subi	r20, 0x01	; 1
    4606:	50 40       	sbci	r21, 0x00	; 0
    4608:	d8 f7       	brcc	.-10     	; 0x4600 <memcpy+0x6>
    460a:	08 95       	ret

0000460c <memset>:
    460c:	dc 01       	movw	r26, r24
    460e:	01 c0       	rjmp	.+2      	; 0x4612 <memset+0x6>
    4610:	6d 93       	st	X+, r22
    4612:	41 50       	subi	r20, 0x01	; 1
    4614:	50 40       	sbci	r21, 0x00	; 0
    4616:	e0 f7       	brcc	.-8      	; 0x4610 <memset+0x4>
    4618:	08 95       	ret

0000461a <strncpy>:
    461a:	fb 01       	movw	r30, r22
    461c:	dc 01       	movw	r26, r24
    461e:	41 50       	subi	r20, 0x01	; 1
    4620:	50 40       	sbci	r21, 0x00	; 0
    4622:	48 f0       	brcs	.+18     	; 0x4636 <strncpy+0x1c>
    4624:	01 90       	ld	r0, Z+
    4626:	0d 92       	st	X+, r0
    4628:	00 20       	and	r0, r0
    462a:	c9 f7       	brne	.-14     	; 0x461e <strncpy+0x4>
    462c:	01 c0       	rjmp	.+2      	; 0x4630 <strncpy+0x16>
    462e:	1d 92       	st	X+, r1
    4630:	41 50       	subi	r20, 0x01	; 1
    4632:	50 40       	sbci	r21, 0x00	; 0
    4634:	e0 f7       	brcc	.-8      	; 0x462e <strncpy+0x14>
    4636:	08 95       	ret

00004638 <__itoa_ncheck>:
    4638:	bb 27       	eor	r27, r27
    463a:	4a 30       	cpi	r20, 0x0A	; 10
    463c:	31 f4       	brne	.+12     	; 0x464a <__itoa_ncheck+0x12>
    463e:	99 23       	and	r25, r25
    4640:	22 f4       	brpl	.+8      	; 0x464a <__itoa_ncheck+0x12>
    4642:	bd e2       	ldi	r27, 0x2D	; 45
    4644:	90 95       	com	r25
    4646:	81 95       	neg	r24
    4648:	9f 4f       	sbci	r25, 0xFF	; 255
    464a:	0c 94 60 23 	jmp	0x46c0	; 0x46c0 <__utoa_common>

0000464e <ultoa>:
    464e:	25 32       	cpi	r18, 0x25	; 37
    4650:	31 05       	cpc	r19, r1
    4652:	20 f4       	brcc	.+8      	; 0x465c <ultoa+0xe>
    4654:	22 30       	cpi	r18, 0x02	; 2
    4656:	10 f0       	brcs	.+4      	; 0x465c <ultoa+0xe>
    4658:	0c 94 32 23 	jmp	0x4664	; 0x4664 <__ultoa_ncheck>
    465c:	fa 01       	movw	r30, r20
    465e:	10 82       	st	Z, r1
    4660:	ca 01       	movw	r24, r20
    4662:	08 95       	ret

00004664 <__ultoa_ncheck>:
    4664:	bb 27       	eor	r27, r27

00004666 <__ultoa_common>:
    4666:	fa 01       	movw	r30, r20
    4668:	a6 2f       	mov	r26, r22
    466a:	62 17       	cp	r22, r18
    466c:	71 05       	cpc	r23, r1
    466e:	81 05       	cpc	r24, r1
    4670:	91 05       	cpc	r25, r1
    4672:	33 0b       	sbc	r19, r19
    4674:	30 fb       	bst	r19, 0
    4676:	66 f0       	brts	.+24     	; 0x4690 <__ultoa_common+0x2a>
    4678:	aa 27       	eor	r26, r26
    467a:	66 0f       	add	r22, r22
    467c:	77 1f       	adc	r23, r23
    467e:	88 1f       	adc	r24, r24
    4680:	99 1f       	adc	r25, r25
    4682:	aa 1f       	adc	r26, r26
    4684:	a2 17       	cp	r26, r18
    4686:	10 f0       	brcs	.+4      	; 0x468c <__ultoa_common+0x26>
    4688:	a2 1b       	sub	r26, r18
    468a:	63 95       	inc	r22
    468c:	38 50       	subi	r19, 0x08	; 8
    468e:	a9 f7       	brne	.-22     	; 0x467a <__ultoa_common+0x14>
    4690:	a0 5d       	subi	r26, 0xD0	; 208
    4692:	aa 33       	cpi	r26, 0x3A	; 58
    4694:	08 f0       	brcs	.+2      	; 0x4698 <__ultoa_common+0x32>
    4696:	a9 5d       	subi	r26, 0xD9	; 217
    4698:	a1 93       	st	Z+, r26
    469a:	36 f7       	brtc	.-52     	; 0x4668 <__ultoa_common+0x2>
    469c:	b1 11       	cpse	r27, r1
    469e:	b1 93       	st	Z+, r27
    46a0:	10 82       	st	Z, r1
    46a2:	ca 01       	movw	r24, r20
    46a4:	0c 94 79 23 	jmp	0x46f2	; 0x46f2 <strrev>

000046a8 <utoa>:
    46a8:	45 32       	cpi	r20, 0x25	; 37
    46aa:	51 05       	cpc	r21, r1
    46ac:	20 f4       	brcc	.+8      	; 0x46b6 <utoa+0xe>
    46ae:	42 30       	cpi	r20, 0x02	; 2
    46b0:	10 f0       	brcs	.+4      	; 0x46b6 <utoa+0xe>
    46b2:	0c 94 5f 23 	jmp	0x46be	; 0x46be <__utoa_ncheck>
    46b6:	fb 01       	movw	r30, r22
    46b8:	10 82       	st	Z, r1
    46ba:	cb 01       	movw	r24, r22
    46bc:	08 95       	ret

000046be <__utoa_ncheck>:
    46be:	bb 27       	eor	r27, r27

000046c0 <__utoa_common>:
    46c0:	fb 01       	movw	r30, r22
    46c2:	55 27       	eor	r21, r21
    46c4:	aa 27       	eor	r26, r26
    46c6:	88 0f       	add	r24, r24
    46c8:	99 1f       	adc	r25, r25
    46ca:	aa 1f       	adc	r26, r26
    46cc:	a4 17       	cp	r26, r20
    46ce:	10 f0       	brcs	.+4      	; 0x46d4 <__utoa_common+0x14>
    46d0:	a4 1b       	sub	r26, r20
    46d2:	83 95       	inc	r24
    46d4:	50 51       	subi	r21, 0x10	; 16
    46d6:	b9 f7       	brne	.-18     	; 0x46c6 <__utoa_common+0x6>
    46d8:	a0 5d       	subi	r26, 0xD0	; 208
    46da:	aa 33       	cpi	r26, 0x3A	; 58
    46dc:	08 f0       	brcs	.+2      	; 0x46e0 <__utoa_common+0x20>
    46de:	a9 5d       	subi	r26, 0xD9	; 217
    46e0:	a1 93       	st	Z+, r26
    46e2:	00 97       	sbiw	r24, 0x00	; 0
    46e4:	79 f7       	brne	.-34     	; 0x46c4 <__utoa_common+0x4>
    46e6:	b1 11       	cpse	r27, r1
    46e8:	b1 93       	st	Z+, r27
    46ea:	11 92       	st	Z+, r1
    46ec:	cb 01       	movw	r24, r22
    46ee:	0c 94 79 23 	jmp	0x46f2	; 0x46f2 <strrev>

000046f2 <strrev>:
    46f2:	dc 01       	movw	r26, r24
    46f4:	fc 01       	movw	r30, r24
    46f6:	67 2f       	mov	r22, r23
    46f8:	71 91       	ld	r23, Z+
    46fa:	77 23       	and	r23, r23
    46fc:	e1 f7       	brne	.-8      	; 0x46f6 <strrev+0x4>
    46fe:	32 97       	sbiw	r30, 0x02	; 2
    4700:	04 c0       	rjmp	.+8      	; 0x470a <strrev+0x18>
    4702:	7c 91       	ld	r23, X
    4704:	6d 93       	st	X+, r22
    4706:	70 83       	st	Z, r23
    4708:	62 91       	ld	r22, -Z
    470a:	ae 17       	cp	r26, r30
    470c:	bf 07       	cpc	r27, r31
    470e:	c8 f3       	brcs	.-14     	; 0x4702 <strrev+0x10>
    4710:	08 95       	ret

00004712 <_exit>:
    4712:	f8 94       	cli

00004714 <__stop_program>:
    4714:	ff cf       	rjmp	.-2      	; 0x4714 <__stop_program>
