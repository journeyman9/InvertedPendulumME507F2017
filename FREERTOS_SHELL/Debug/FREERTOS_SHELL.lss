
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000045d8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ca  00802000  000045d8  0000466c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ae  008020ca  008020ca  00004736  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004736  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004768  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006d8  00000000  00000000  000047a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000123ca  00000000  00000000  00004e80  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000077d6  00000000  00000000  0001724a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000050e6  00000000  00000000  0001ea20  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001408  00000000  00000000  00023b08  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006e3e  00000000  00000000  00024f10  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006317  00000000  00000000  0002bd4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000578  00000000  00000000  00032065  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a7 02 	jmp	0x54e	; 0x54e <__ctors_end>
       4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      10:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      14:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      18:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      1c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      20:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      24:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      28:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      2c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      30:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      34:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      38:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      3c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      40:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      44:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      4c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      50:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      54:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      58:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      5c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      60:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      64:	0c 94 6a 1c 	jmp	0x38d4	; 0x38d4 <__vector_25>
      68:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      6c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      70:	0c 94 c8 1c 	jmp	0x3990	; 0x3990 <__vector_28>
      74:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      78:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      7c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      80:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      84:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      88:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      8c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      90:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      94:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      98:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      9c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      dc:	0c 94 1a 0c 	jmp	0x1834	; 0x1834 <__vector_55>
      e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e8:	0c 94 e2 1d 	jmp	0x3bc4	; 0x3bc4 <__vector_58>
      ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f4:	0c 94 40 1e 	jmp	0x3c80	; 0x3c80 <__vector_61>
      f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      fc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     100:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     104:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     108:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     10c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     110:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     114:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     118:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     11c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     120:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     124:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     128:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     12c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     130:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     134:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     138:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     13c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     140:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     144:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     148:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     14c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     150:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     154:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     158:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     15c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     160:	0c 94 26 1d 	jmp	0x3a4c	; 0x3a4c <__vector_88>
     164:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     168:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     16c:	0c 94 84 1d 	jmp	0x3b08	; 0x3b08 <__vector_91>
     170:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     174:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     178:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     17c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     180:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     184:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     188:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     18c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     190:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     194:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     198:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     19c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1dc:	0c 94 9e 1e 	jmp	0x3d3c	; 0x3d3c <__vector_119>
     1e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1fc:	0b 1a       	sub	r0, r27
     1fe:	0e 1a       	sub	r0, r30
     200:	11 1a       	sub	r1, r17
     202:	14 1a       	sub	r1, r20
     204:	17 1a       	sub	r1, r23
     206:	1a 1a       	sub	r1, r26
     208:	1c 1a       	sub	r1, r28
     20a:	2d 1a       	sub	r2, r29
     20c:	35 1a       	sub	r3, r21
     20e:	3f 1a       	sub	r3, r31
     210:	3d 1a       	sub	r3, r29

00000212 <__trampolines_start>:
     212:	0c 94 86 1b 	jmp	0x370c	; 0x370c <_ZN5rs2327getcharEv>
     216:	0c 94 1a 1a 	jmp	0x3434	; 0x3434 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     21a:	0c 94 cd 15 	jmp	0x2b9a	; 0x2b9a <_ZN8frt_task12print_statusER8emstream>
     21e:	0c 94 11 1a 	jmp	0x3422	; 0x3422 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     222:	0c 94 b5 19 	jmp	0x336a	; 0x336a <_ZN8emstream12transmit_nowEv>
     226:	0c 94 17 1a 	jmp	0x342e	; 0x342e <_ZN8emstreamlsE15ser_manipulator+0x36>
     22a:	0c 94 ae 19 	jmp	0x335c	; 0x335c <_ZN8emstream13ready_to_sendEv>
     22e:	0c 94 b0 19 	jmp	0x3360	; 0x3360 <_ZN8emstream7getcharEv>
     232:	0c 94 b3 19 	jmp	0x3366	; 0x3366 <_ZN8emstream14check_for_charEv>
     236:	0c 94 0b 1a 	jmp	0x3416	; 0x3416 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     23a:	0c 94 f4 07 	jmp	0xfe8	; 0xfe8 <_ZN9task_user3runEv>
     23e:	0c 94 3f 1a 	jmp	0x347e	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
     242:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <_ZN14frt_text_queue14check_for_charEv>
     246:	0c 94 1c 1a 	jmp	0x3438	; 0x3438 <_ZN8emstreamlsE15ser_manipulator+0x40>
     24a:	0c 94 b6 19 	jmp	0x336c	; 0x336c <_ZN8emstream12clear_screenEv>
     24e:	0c 94 14 1a 	jmp	0x3428	; 0x3428 <_ZN8emstreamlsE15ser_manipulator+0x30>
     252:	0c 94 06 04 	jmp	0x80c	; 0x80c <_ZN13LimitSwitches3runEv>
     256:	0c 94 35 1a 	jmp	0x346a	; 0x346a <_ZN8emstreamlsE15ser_manipulator+0x72>
     25a:	0c 94 2d 1a 	jmp	0x345a	; 0x345a <_ZN8emstreamlsE15ser_manipulator+0x62>
     25e:	0c 94 fd 18 	jmp	0x31fa	; 0x31fa <__cxa_pure_virtual>
     262:	0c 94 a4 02 	jmp	0x548	; 0x548 <_call_static_run_method>
     266:	0c 94 17 17 	jmp	0x2e2e	; 0x2e2e <_ZN14frt_text_queue7getcharEv>
     26a:	0c 94 9b 1f 	jmp	0x3f36	; 0x3f36 <_GLOBAL__sub_I_counter>
     26e:	0c 94 bf 1b 	jmp	0x377e	; 0x377e <_ZN5rs23212clear_screenEv>
     272:	0c 94 0e 1a 	jmp	0x341c	; 0x341c <_ZN8emstreamlsE15ser_manipulator+0x24>
     276:	0c 94 b5 03 	jmp	0x76a	; 0x76a <_ZN15EncoderPendulum3runEv>
     27a:	0c 94 9e 0e 	jmp	0x1d3c	; 0x1d3c <prvIdleTask>
     27e:	0c 94 4b 04 	jmp	0x896	; 0x896 <_ZN5Motor3runEv>
     282:	0c 94 ac 1b 	jmp	0x3758	; 0x3758 <_ZN5rs23214check_for_charEv>
     286:	0c 94 df 02 	jmp	0x5be	; 0x5be <_ZN12EncoderMotor3runEv>
     28a:	0c 94 40 17 	jmp	0x2e80	; 0x2e80 <_ZN14frt_text_queue7putcharEc>
     28e:	0c 94 3d 1a 	jmp	0x347a	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x82>
     292:	0c 94 62 1b 	jmp	0x36c4	; 0x36c4 <_ZN5rs2327putcharEc>

00000296 <__trampolines_end>:
     296:	2c 20       	and	r2, r12
     298:	54 43       	sbci	r21, 0x34	; 52
     29a:	43 30       	cpi	r20, 0x03	; 3
     29c:	43 43       	sbci	r20, 0x33	; 51
     29e:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a1 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a1:	2f 00                                               /.

000002a3 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b1 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b1:	54 69 6d 65 3a 20 00                                Time: .

000002b8 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b8:	4e 6f 76 20 32 35 20 32 30 31 37 00                 Nov 25 2017.

000002c4 <_ZZN9task_user11show_statusEvE3__c>:
     2c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     302:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000030d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     30d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     31d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34b:	6d 61 74 69 6f 6e 00                                mation.

00000352 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     352:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     362:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000373 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     373:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     383:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3a7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3b7:	68 65 20 41 56 52 00                                he AVR.

000003be <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3be:	20 68 65 6c 70 00                                    help.

000003c4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e3:	1b 5b 33 30 6d 00                                   .[30m.

000003e9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e9:	1b 5b 34 36 6d 00                                   .[46m.

000003ef <_ZZN9task_user3runEvE3__c_3>:
     3ef:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ff:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000040c <_ZZN9task_user3runEvE3__c_2>:
     40c:	3a 57 54 46 3f 00                                   :WTF?.

00000412 <_ZZN9task_user3runEvE3__c_1>:
     412:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     422:	65 00                                               e.

00000424 <_ZZN9task_user3runEvE3__c_0>:
     424:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000432 <_ZZN9task_user3runEvE3__c>:
     432:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     442:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000450 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     450:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045a <_ZZN8frt_task15emergency_resetEvE3__c>:
     45a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000469 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     469:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     479:	61 73 6b 20 00                                      ask .

0000047e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     47e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000048c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     48c:	20 63 72 65 61 74 65 64 00                           created.

00000495 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     495:	54 61 73 6b 20 00                                   Task .

0000049b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49b:	1b 5b 32 32 6d 00                                   .[22m.

000004a1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a1:	54 61 73 6b 3a 20 00                                Task: .

000004a8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a8:	1b 5b 31 6d 00                                      .[1m.

000004ad <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4ad:	1b 5b 32 32 6d 00                                   .[22m.

000004b3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004be <_ZZ17print_task_stacksP8emstreamE3__c>:
     4be:	1b 5b 31 6d 00                                      .[1m.

000004c3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c3:	09 09 00                                            ...

000004c6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4c6:	2f 00                                               /.

000004c8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d3:	09 2d 2d 2d 2d 00                                   .----.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004f6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4f6:	09 52 75 6e 73 00                                   .Runs.

000004fc <_ZZ15print_task_listP8emstreamE3__c_2>:
     4fc:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000508 <_ZZ15print_task_listP8emstreamE3__c_1>:
     508:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000519 <_ZZ15print_task_listP8emstreamE3__c_0>:
     519:	09 53 74 61 63 6b 00                                .Stack.

00000520 <_ZZ15print_task_listP8emstreamE3__c>:
     520:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52b:	09 00                                               ..

0000052d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     52d:	09 00                                               ..

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     52f:	2f 00                                               /.

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     533:	09 00                                               ..

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53b:	1b 5b 31 6d 00                                      .[1m.

00000540 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     545:	20 20 00                                              .

00000548 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     548:	0e 94 65 14 	call	0x28ca	; 0x28ca <_ZN8frt_task22_call_users_run_methodEPS_>

0000054c <__ctors_start>:
     54c:	9b 1f       	adc	r25, r27

0000054e <__ctors_end>:
     54e:	11 24       	eor	r1, r1
     550:	1f be       	out	0x3f, r1	; 63
     552:	cf ef       	ldi	r28, 0xFF	; 255
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df e3       	ldi	r29, 0x3F	; 63
     558:	de bf       	out	0x3e, r29	; 62
     55a:	00 e0       	ldi	r16, 0x00	; 0
     55c:	0c bf       	out	0x3c, r16	; 60
     55e:	18 be       	out	0x38, r1	; 56
     560:	19 be       	out	0x39, r1	; 57
     562:	1a be       	out	0x3a, r1	; 58
     564:	1b be       	out	0x3b, r1	; 59

00000566 <__do_copy_data>:
     566:	10 e2       	ldi	r17, 0x20	; 32
     568:	a0 e0       	ldi	r26, 0x00	; 0
     56a:	b0 e2       	ldi	r27, 0x20	; 32
     56c:	e8 ed       	ldi	r30, 0xD8	; 216
     56e:	f5 e4       	ldi	r31, 0x45	; 69
     570:	00 e0       	ldi	r16, 0x00	; 0
     572:	0b bf       	out	0x3b, r16	; 59
     574:	02 c0       	rjmp	.+4      	; 0x57a <__do_copy_data+0x14>
     576:	07 90       	elpm	r0, Z+
     578:	0d 92       	st	X+, r0
     57a:	aa 3c       	cpi	r26, 0xCA	; 202
     57c:	b1 07       	cpc	r27, r17
     57e:	d9 f7       	brne	.-10     	; 0x576 <__do_copy_data+0x10>
     580:	1b be       	out	0x3b, r1	; 59

00000582 <__do_clear_bss>:
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	aa ec       	ldi	r26, 0xCA	; 202
     586:	b0 e2       	ldi	r27, 0x20	; 32
     588:	01 c0       	rjmp	.+2      	; 0x58c <.do_clear_bss_start>

0000058a <.do_clear_bss_loop>:
     58a:	1d 92       	st	X+, r1

0000058c <.do_clear_bss_start>:
     58c:	a8 37       	cpi	r26, 0x78	; 120
     58e:	b2 07       	cpc	r27, r18
     590:	e1 f7       	brne	.-8      	; 0x58a <.do_clear_bss_loop>

00000592 <__do_global_ctors>:
     592:	12 e0       	ldi	r17, 0x02	; 2
     594:	c7 ea       	ldi	r28, 0xA7	; 167
     596:	d2 e0       	ldi	r29, 0x02	; 2
     598:	00 e0       	ldi	r16, 0x00	; 0
     59a:	06 c0       	rjmp	.+12     	; 0x5a8 <__do_global_ctors+0x16>
     59c:	21 97       	sbiw	r28, 0x01	; 1
     59e:	01 09       	sbc	r16, r1
     5a0:	80 2f       	mov	r24, r16
     5a2:	fe 01       	movw	r30, r28
     5a4:	0e 94 3b 22 	call	0x4476	; 0x4476 <__tablejump2__>
     5a8:	c6 3a       	cpi	r28, 0xA6	; 166
     5aa:	d1 07       	cpc	r29, r17
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 07       	cpc	r16, r24
     5b0:	a9 f7       	brne	.-22     	; 0x59c <__do_global_ctors+0xa>
     5b2:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <main>
     5b6:	0c 94 ea 22 	jmp	0x45d4	; 0x45d4 <_exit>

000005ba <__bad_interrupt>:
     5ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005be <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN12EncoderMotor3runEv+0x6>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5cc:	0e 94 3d 10 	call	0x207a	; 0x207a <xTaskGetTickCount>
     5d0:	69 83       	std	Y+1, r22	; 0x01
     5d2:	7a 83       	std	Y+2, r23	; 0x02
     5d4:	8b 83       	std	Y+3, r24	; 0x03
     5d6:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN4_bm | PIN5_bm;										// Set both CHa and CHb for input
     5d8:	e0 e8       	ldi	r30, 0x80	; 128
     5da:	f6 e0       	ldi	r31, 0x06	; 6
     5dc:	80 e3       	ldi	r24, 0x30	; 48
     5de:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN4CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e0:	84 89       	ldd	r24, Z+20	; 0x14
     5e2:	83 60       	ori	r24, 0x03	; 3
     5e4:	84 8b       	std	Z+20, r24	; 0x14
	PORTE.PIN5CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5e6:	85 89       	ldd	r24, Z+21	; 0x15
     5e8:	83 60       	ori	r24, 0x03	; 3
     5ea:	85 8b       	std	Z+21, r24	; 0x15
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN4_gc;								// Configure CHa as a multiplexer input for event channel 1
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	84 e7       	ldi	r24, 0x74	; 116
     5f2:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f4:	89 e0       	ldi	r24, 0x09	; 9
     5f6:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f8:	e0 e0       	ldi	r30, 0x00	; 0
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	88 e6       	ldi	r24, 0x68	; 104
     5fe:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	86 a3       	std	Z+38, r24	; 0x26
     606:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	80 83       	st	Z, r24
	int16_t angularVelocity;
	float x_calc;
	int16_t x;

	while(1){
		encoder_count = TCD0.CNT;											// get count
     60c:	0f 2e       	mov	r0, r31
     60e:	61 2c       	mov	r6, r1
     610:	f9 e0       	ldi	r31, 0x09	; 9
     612:	7f 2e       	mov	r7, r31
     614:	f0 2d       	mov	r31, r0
		//*p_serial << "Linear Position: " << x << " [mm]" << endl;
		linear_position.put(x);
		//*p_serial << "Linear Position: " << linear_position.get() << " [mm]" << endl;
		
		angularVelocityCalc = ((int16_t) (encoder_count-last_encoder_count))*60/(4.00000*1000.00000)/dt;	// convert to velocity [RPM]
		angularVelocity = angularVelocityCalc;
     616:	0f 2e       	mov	r0, r31
     618:	fc e3       	ldi	r31, 0x3C	; 60
     61a:	5f 2e       	mov	r5, r31
     61c:	f0 2d       	mov	r31, r0
	int16_t angularVelocity;
	float x_calc;
	int16_t x;

	while(1){
		encoder_count = TCD0.CNT;											// get count
     61e:	f3 01       	movw	r30, r6
     620:	00 a1       	ldd	r16, Z+32	; 0x20
     622:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     624:	0f b6       	in	r0, 0x3f	; 63
     626:	f8 94       	cli
     628:	0f 92       	push	r0
			the_data = new_data;
     62a:	48 01       	movw	r8, r16
     62c:	01 2e       	mov	r0, r17
     62e:	00 0c       	add	r0, r0
     630:	aa 08       	sbc	r10, r10
     632:	bb 08       	sbc	r11, r11
     634:	c5 01       	movw	r24, r10
     636:	b4 01       	movw	r22, r8
     638:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     63c:	20 e0       	ldi	r18, 0x00	; 0
     63e:	30 e0       	ldi	r19, 0x00	; 0
     640:	4a e7       	ldi	r20, 0x7A	; 122
     642:	55 e4       	ldi	r21, 0x45	; 69
     644:	0e 94 1e 20 	call	0x403c	; 0x403c <__divsf3>
     648:	20 e0       	ldi	r18, 0x00	; 0
     64a:	30 e0       	ldi	r19, 0x00	; 0
     64c:	44 eb       	ldi	r20, 0xB4	; 180
     64e:	53 e4       	ldi	r21, 0x43	; 67
     650:	0e 94 7d 21 	call	0x42fa	; 0x42fa <__mulsf3>
     654:	0e 94 90 20 	call	0x4120	; 0x4120 <__fixsfsi>
     658:	60 93 62 31 	sts	0x3162, r22	; 0x803162 <thMotor>
     65c:	70 93 63 31 	sts	0x3163, r23	; 0x803163 <thMotor+0x1>
			portEXIT_CRITICAL ();
     660:	0f 90       	pop	r0
     662:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     664:	0f b6       	in	r0, 0x3f	; 63
     666:	f8 94       	cli
     668:	0f 92       	push	r0
			the_data = new_data;
     66a:	d5 01       	movw	r26, r10
     66c:	c4 01       	movw	r24, r8
     66e:	88 0f       	add	r24, r24
     670:	99 1f       	adc	r25, r25
     672:	aa 1f       	adc	r26, r26
     674:	bb 1f       	adc	r27, r27
     676:	bc 01       	movw	r22, r24
     678:	cd 01       	movw	r24, r26
     67a:	68 0d       	add	r22, r8
     67c:	79 1d       	adc	r23, r9
     67e:	8a 1d       	adc	r24, r10
     680:	9b 1d       	adc	r25, r11
     682:	24 e6       	ldi	r18, 0x64	; 100
     684:	30 e0       	ldi	r19, 0x00	; 0
     686:	40 e0       	ldi	r20, 0x00	; 0
     688:	50 e0       	ldi	r21, 0x00	; 0
     68a:	0e 94 1c 22 	call	0x4438	; 0x4438 <__divmodsi4>
     68e:	ca 01       	movw	r24, r20
     690:	b9 01       	movw	r22, r18
     692:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     696:	0e 94 90 20 	call	0x4120	; 0x4120 <__fixsfsi>
     69a:	60 93 64 31 	sts	0x3164, r22	; 0x803164 <linear_position>
     69e:	70 93 65 31 	sts	0x3165, r23	; 0x803165 <linear_position+0x1>
			portEXIT_CRITICAL ();
     6a2:	0f 90       	pop	r0
     6a4:	0f be       	out	0x3f, r0	; 63
		//*p_serial << "Linear Position: " << x << " [mm]" << endl;
		linear_position.put(x);
		//*p_serial << "Linear Position: " << linear_position.get() << " [mm]" << endl;
		
		angularVelocityCalc = ((int16_t) (encoder_count-last_encoder_count))*60/(4.00000*1000.00000)/dt;	// convert to velocity [RPM]
		angularVelocity = angularVelocityCalc;
     6a6:	c8 01       	movw	r24, r16
     6a8:	8c 19       	sub	r24, r12
     6aa:	9d 09       	sbc	r25, r13
     6ac:	58 9e       	mul	r5, r24
     6ae:	b0 01       	movw	r22, r0
     6b0:	59 9e       	mul	r5, r25
     6b2:	70 0d       	add	r23, r0
     6b4:	11 24       	eor	r1, r1
     6b6:	07 2e       	mov	r0, r23
     6b8:	00 0c       	add	r0, r0
     6ba:	88 0b       	sbc	r24, r24
     6bc:	99 0b       	sbc	r25, r25
     6be:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     6c2:	20 e0       	ldi	r18, 0x00	; 0
     6c4:	30 e0       	ldi	r19, 0x00	; 0
     6c6:	4a e7       	ldi	r20, 0x7A	; 122
     6c8:	55 e4       	ldi	r21, 0x45	; 69
     6ca:	0e 94 1e 20 	call	0x403c	; 0x403c <__divsf3>
     6ce:	2a e0       	ldi	r18, 0x0A	; 10
     6d0:	37 ed       	ldi	r19, 0xD7	; 215
     6d2:	43 ea       	ldi	r20, 0xA3	; 163
     6d4:	5b e3       	ldi	r21, 0x3B	; 59
     6d6:	0e 94 1e 20 	call	0x403c	; 0x403c <__divsf3>
     6da:	0e 94 90 20 	call	0x4120	; 0x4120 <__fixsfsi>
     6de:	4b 01       	movw	r8, r22
     6e0:	5c 01       	movw	r10, r24
		*p_serial << "Angular Velocity: " << angularVelocity << " [RPM]" << endl;
     6e2:	f7 01       	movw	r30, r14
     6e4:	c6 80       	ldd	r12, Z+6	; 0x06
     6e6:	d7 80       	ldd	r13, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     6e8:	66 e0       	ldi	r22, 0x06	; 6
     6ea:	70 e2       	ldi	r23, 0x20	; 32
     6ec:	c6 01       	movw	r24, r12
     6ee:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     6f2:	b4 01       	movw	r22, r8
     6f4:	c6 01       	movw	r24, r12
     6f6:	0e 94 43 1a 	call	0x3486	; 0x3486 <_ZN8emstreamlsEi>
     6fa:	6c 01       	movw	r12, r24
     6fc:	69 e1       	ldi	r22, 0x19	; 25
     6fe:	70 e2       	ldi	r23, 0x20	; 32
     700:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     704:	66 e0       	ldi	r22, 0x06	; 6
     706:	c6 01       	movw	r24, r12
     708:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     70c:	0f b6       	in	r0, 0x3f	; 63
     70e:	f8 94       	cli
     710:	0f 92       	push	r0
			the_data = new_data;
     712:	80 92 60 31 	sts	0x3160, r8	; 0x803160 <thdMotor>
     716:	90 92 61 31 	sts	0x3161, r9	; 0x803161 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     71a:	0f 90       	pop	r0
     71c:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     71e:	f7 01       	movw	r30, r14
     720:	86 85       	ldd	r24, Z+14	; 0x0e
     722:	97 85       	ldd	r25, Z+15	; 0x0f
     724:	a0 89       	ldd	r26, Z+16	; 0x10
     726:	b1 89       	ldd	r27, Z+17	; 0x11
     728:	01 96       	adiw	r24, 0x01	; 1
     72a:	a1 1d       	adc	r26, r1
     72c:	b1 1d       	adc	r27, r1
     72e:	86 87       	std	Z+14, r24	; 0x0e
     730:	97 87       	std	Z+15, r25	; 0x0f
     732:	a0 8b       	std	Z+16, r26	; 0x10
     734:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     736:	45 e0       	ldi	r20, 0x05	; 5
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	60 e0       	ldi	r22, 0x00	; 0
     73c:	70 e0       	ldi	r23, 0x00	; 0
     73e:	ce 01       	movw	r24, r28
     740:	01 96       	adiw	r24, 0x01	; 1
     742:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vTaskDelayUntil>
		angularVelocityCalc = ((int16_t) (encoder_count-last_encoder_count))*60/(4.00000*1000.00000)/dt;	// convert to velocity [RPM]
		angularVelocity = angularVelocityCalc;
		*p_serial << "Angular Velocity: " << angularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     746:	68 01       	movw	r12, r16
     748:	6a cf       	rjmp	.-300    	; 0x61e <_ZN12EncoderMotor3runEv+0x60>

0000074a <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     74a:	0f 93       	push	r16
     74c:	1f 93       	push	r17
     74e:	cf 93       	push	r28
     750:	df 93       	push	r29
     752:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     754:	0e 94 78 14 	call	0x28f0	; 0x28f0 <_ZN8frt_taskC1EPKchjP8emstream>
     758:	84 e2       	ldi	r24, 0x24	; 36
     75a:	90 e2       	ldi	r25, 0x20	; 32
     75c:	88 83       	st	Y, r24
     75e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     760:	df 91       	pop	r29
     762:	cf 91       	pop	r28
     764:	1f 91       	pop	r17
     766:	0f 91       	pop	r16
     768:	08 95       	ret

0000076a <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     76a:	cf 93       	push	r28
     76c:	df 93       	push	r29
     76e:	00 d0       	rcall	.+0      	; 0x770 <_ZN15EncoderPendulum3runEv+0x6>
     770:	1f 92       	push	r1
     772:	cd b7       	in	r28, 0x3d	; 61
     774:	de b7       	in	r29, 0x3e	; 62
     776:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     778:	0e 94 3d 10 	call	0x207a	; 0x207a <xTaskGetTickCount>
     77c:	69 83       	std	Y+1, r22	; 0x01
     77e:	7a 83       	std	Y+2, r23	; 0x02
     780:	8b 83       	std	Y+3, r24	; 0x03
     782:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTC.DIRCLR = (PIN4_bm | PIN5_bm);							// set C4 & C5 as inputs
     784:	e0 e4       	ldi	r30, 0x40	; 64
     786:	f6 e0       	ldi	r31, 0x06	; 6
     788:	80 e3       	ldi	r24, 0x30	; 48
     78a:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN4CTRL = PORT_ISC_LEVEL_gc;							// set C4 for level sensing
     78c:	83 e0       	ldi	r24, 0x03	; 3
     78e:	84 8b       	std	Z+20, r24	; 0x14
	PORTC.PIN5CTRL = PORT_ISC_LEVEL_gc;							// set C5 for level sensing
     790:	85 8b       	std	Z+21, r24	; 0x15
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTC_PIN4_gc;					// set PC4 as Multiplexer for Event Chan 0
     792:	e0 e8       	ldi	r30, 0x80	; 128
     794:	f1 e0       	ldi	r31, 0x01	; 1
     796:	84 e6       	ldi	r24, 0x64	; 100
     798:	81 83       	std	Z+1, r24	; 0x01
	EVSYS.CH1CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     79a:	89 e0       	ldi	r24, 0x09	; 9
     79c:	81 87       	std	Z+9, r24	; 0x09
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH1_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     79e:	e0 e4       	ldi	r30, 0x40	; 64
     7a0:	f8 e0       	ldi	r31, 0x08	; 8
     7a2:	89 e6       	ldi	r24, 0x69	; 105
     7a4:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0xFFFF;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     7a6:	8f ef       	ldi	r24, 0xFF	; 255
     7a8:	9f ef       	ldi	r25, 0xFF	; 255
     7aa:	86 a3       	std	Z+38, r24	; 0x26
     7ac:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     7ae:	81 e0       	ldi	r24, 0x01	; 1
     7b0:	80 83       	st	Z, r24
	
	uint16_t count;												// contains the current encoder value
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     7b2:	68 94       	set
     7b4:	ee 24       	eor	r14, r14
     7b6:	e6 f8       	bld	r14, 6
     7b8:	ff 24       	eor	r15, r15
     7ba:	f3 f8       	bld	r15, 3
     7bc:	f7 01       	movw	r30, r14
     7be:	80 a1       	ldd	r24, Z+32	; 0x20
     7c0:	91 a1       	ldd	r25, Z+33	; 0x21
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     7c2:	f8 01       	movw	r30, r16
     7c4:	86 85       	ldd	r24, Z+14	; 0x0e
     7c6:	97 85       	ldd	r25, Z+15	; 0x0f
     7c8:	a0 89       	ldd	r26, Z+16	; 0x10
     7ca:	b1 89       	ldd	r27, Z+17	; 0x11
     7cc:	01 96       	adiw	r24, 0x01	; 1
     7ce:	a1 1d       	adc	r26, r1
     7d0:	b1 1d       	adc	r27, r1
     7d2:	86 87       	std	Z+14, r24	; 0x0e
     7d4:	97 87       	std	Z+15, r25	; 0x0f
     7d6:	a0 8b       	std	Z+16, r26	; 0x10
     7d8:	b1 8b       	std	Z+17, r27	; 0x11
     7da:	41 e0       	ldi	r20, 0x01	; 1
     7dc:	50 e0       	ldi	r21, 0x00	; 0
     7de:	60 e0       	ldi	r22, 0x00	; 0
     7e0:	70 e0       	ldi	r23, 0x00	; 0
     7e2:	ce 01       	movw	r24, r28
     7e4:	01 96       	adiw	r24, 0x01	; 1
     7e6:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vTaskDelayUntil>
     7ea:	e8 cf       	rjmp	.-48     	; 0x7bc <_ZN15EncoderPendulum3runEv+0x52>

000007ec <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     7ec:	0f 93       	push	r16
     7ee:	1f 93       	push	r17
     7f0:	cf 93       	push	r28
     7f2:	df 93       	push	r29
     7f4:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7f6:	0e 94 78 14 	call	0x28f0	; 0x28f0 <_ZN8frt_taskC1EPKchjP8emstream>
     7fa:	8c e2       	ldi	r24, 0x2C	; 44
     7fc:	90 e2       	ldi	r25, 0x20	; 32
     7fe:	88 83       	st	Y, r24
     800:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     802:	df 91       	pop	r29
     804:	cf 91       	pop	r28
     806:	1f 91       	pop	r17
     808:	0f 91       	pop	r16
     80a:	08 95       	ret

0000080c <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     80c:	cf 93       	push	r28
     80e:	df 93       	push	r29
     810:	00 d0       	rcall	.+0      	; 0x812 <_ZN13LimitSwitches3runEv+0x6>
     812:	1f 92       	push	r1
     814:	cd b7       	in	r28, 0x3d	; 61
     816:	de b7       	in	r29, 0x3e	; 62
     818:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     81a:	0e 94 3d 10 	call	0x207a	; 0x207a <xTaskGetTickCount>
     81e:	69 83       	std	Y+1, r22	; 0x01
     820:	7a 83       	std	Y+2, r23	; 0x02
     822:	8b 83       	std	Y+3, r24	; 0x03
     824:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PK0 & PK2) and LED output
	PORTK.DIRCLR = PIN0_bm;									// set K0 as input
     826:	e0 e2       	ldi	r30, 0x20	; 32
     828:	f7 e0       	ldi	r31, 0x07	; 7
     82a:	81 e0       	ldi	r24, 0x01	; 1
     82c:	82 83       	std	Z+2, r24	; 0x02
	PORTK.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set K0 as pullup
     82e:	88 e1       	ldi	r24, 0x18	; 24
     830:	80 8b       	std	Z+16, r24	; 0x10
	PORTK.DIRCLR = PIN2_bm;									// set K2 as input
     832:	94 e0       	ldi	r25, 0x04	; 4
     834:	92 83       	std	Z+2, r25	; 0x02
	PORTK.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set K2 as pullup
     836:	82 8b       	std	Z+18, r24	; 0x12
	bool rightLimit;
	bool leftLimit;

	while(1){
		
		if(!(PORTK_IN & PIN0_bm))							// check whether limit is pressed (pin K0 is high)
     838:	0f 2e       	mov	r0, r31
     83a:	f8 e2       	ldi	r31, 0x28	; 40
     83c:	ef 2e       	mov	r14, r31
     83e:	f7 e0       	ldi	r31, 0x07	; 7
     840:	ff 2e       	mov	r15, r31
     842:	f0 2d       	mov	r31, r0
     844:	f7 01       	movw	r30, r14
     846:	80 81       	ld	r24, Z
     848:	80 fd       	sbrc	r24, 0
		{	
			rightLimit = 1;
			//*p_serial << "rightLimit: " << rightLimit << endl;
			
		}
		else if (!(PORTK_IN & PIN2_bm))						// check whether limit is pressed (pin K2 is high)
     84a:	80 81       	ld	r24, Z
			leftLimit = 0;
			//*p_serial << "limits: " << rightLimit << leftLimit << endl;
		}
		
		// Increment counter for debugging
		runs++;
     84c:	f8 01       	movw	r30, r16
     84e:	86 85       	ldd	r24, Z+14	; 0x0e
     850:	97 85       	ldd	r25, Z+15	; 0x0f
     852:	a0 89       	ldd	r26, Z+16	; 0x10
     854:	b1 89       	ldd	r27, Z+17	; 0x11
     856:	01 96       	adiw	r24, 0x01	; 1
     858:	a1 1d       	adc	r26, r1
     85a:	b1 1d       	adc	r27, r1
     85c:	86 87       	std	Z+14, r24	; 0x0e
     85e:	97 87       	std	Z+15, r25	; 0x0f
     860:	a0 8b       	std	Z+16, r26	; 0x10
     862:	b1 8b       	std	Z+17, r27	; 0x11
     864:	41 e0       	ldi	r20, 0x01	; 1
     866:	50 e0       	ldi	r21, 0x00	; 0
     868:	60 e0       	ldi	r22, 0x00	; 0
     86a:	70 e0       	ldi	r23, 0x00	; 0
     86c:	ce 01       	movw	r24, r28
     86e:	01 96       	adiw	r24, 0x01	; 1
     870:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vTaskDelayUntil>
     874:	e7 cf       	rjmp	.-50     	; 0x844 <_ZN13LimitSwitches3runEv+0x38>

00000876 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     876:	0f 93       	push	r16
     878:	1f 93       	push	r17
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     880:	0e 94 78 14 	call	0x28f0	; 0x28f0 <_ZN8frt_taskC1EPKchjP8emstream>
     884:	84 e3       	ldi	r24, 0x34	; 52
     886:	90 e2       	ldi	r25, 0x20	; 32
     888:	88 83       	st	Y, r24
     88a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	1f 91       	pop	r17
     892:	0f 91       	pop	r16
     894:	08 95       	ret

00000896 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     896:	cf 93       	push	r28
     898:	df 93       	push	r29
     89a:	00 d0       	rcall	.+0      	; 0x89c <_ZN5Motor3runEv+0x6>
     89c:	00 d0       	rcall	.+0      	; 0x89e <_ZN5Motor3runEv+0x8>
     89e:	cd b7       	in	r28, 0x3d	; 61
     8a0:	de b7       	in	r29, 0x3e	; 62
     8a2:	3c 01       	movw	r6, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8a4:	0e 94 3d 10 	call	0x207a	; 0x207a <xTaskGetTickCount>
     8a8:	69 83       	std	Y+1, r22	; 0x01
     8aa:	7a 83       	std	Y+2, r23	; 0x02
     8ac:	8b 83       	std	Y+3, r24	; 0x03
     8ae:	9c 83       	std	Y+4, r25	; 0x04

	dt = .008;
     8b0:	f3 01       	movw	r30, r6
     8b2:	fe 96       	adiw	r30, 0x3e	; 62
     8b4:	8f e6       	ldi	r24, 0x6F	; 111
     8b6:	92 e1       	ldi	r25, 0x12	; 18
     8b8:	a3 e0       	ldi	r26, 0x03	; 3
     8ba:	bc e3       	ldi	r27, 0x3C	; 60
     8bc:	80 83       	st	Z, r24
     8be:	91 83       	std	Z+1, r25	; 0x01
     8c0:	a2 83       	std	Z+2, r26	; 0x02
     8c2:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	f3 01       	movw	r30, r6
     8ca:	84 af       	std	Z+60, r24	; 0x3c
     8cc:	95 af       	std	Z+61, r25	; 0x3d
		runs++;
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     8ce:	68 94       	set
     8d0:	44 24       	eor	r4, r4
     8d2:	41 f8       	bld	r4, 1
     8d4:	51 2c       	mov	r5, r1
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     8d6:	0f 2e       	mov	r0, r31
     8d8:	ff e3       	ldi	r31, 0x3F	; 63
     8da:	2f 2e       	mov	r2, r31
     8dc:	f0 2d       	mov	r31, r0
     8de:	0f 2e       	mov	r0, r31
     8e0:	fc e3       	ldi	r31, 0x3C	; 60
     8e2:	3f 2e       	mov	r3, r31
     8e4:	f0 2d       	mov	r31, r0
	dt = .008;
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     8e6:	f3 01       	movw	r30, r6
     8e8:	86 85       	ldd	r24, Z+14	; 0x0e
     8ea:	97 85       	ldd	r25, Z+15	; 0x0f
     8ec:	a0 89       	ldd	r26, Z+16	; 0x10
     8ee:	b1 89       	ldd	r27, Z+17	; 0x11
     8f0:	01 96       	adiw	r24, 0x01	; 1
     8f2:	a1 1d       	adc	r26, r1
     8f4:	b1 1d       	adc	r27, r1
     8f6:	86 87       	std	Z+14, r24	; 0x0e
     8f8:	97 87       	std	Z+15, r25	; 0x0f
     8fa:	a0 8b       	std	Z+16, r26	; 0x10
     8fc:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     8fe:	42 8e       	std	Z+26, r4	; 0x1a
     900:	53 8e       	std	Z+27, r5	; 0x1b

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
     902:	16 8e       	std	Z+30, r1	; 0x1e
     904:	17 8e       	std	Z+31, r1	; 0x1f
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     906:	2f 92       	push	r2
     908:	1f 92       	push	r1
     90a:	1f 92       	push	r1
     90c:	1f 92       	push	r1
     90e:	3f 92       	push	r3
     910:	f3 e2       	ldi	r31, 0x23	; 35
     912:	ff 93       	push	r31
     914:	27 ed       	ldi	r18, 0xD7	; 215
     916:	2f 93       	push	r18
     918:	3a e0       	ldi	r19, 0x0A	; 10
     91a:	3f 93       	push	r19
     91c:	0f 2e       	mov	r0, r31
     91e:	fd ec       	ldi	r31, 0xCD	; 205
     920:	8f 2e       	mov	r8, r31
     922:	fc ec       	ldi	r31, 0xCC	; 204
     924:	9f 2e       	mov	r9, r31
     926:	a9 2c       	mov	r10, r9
     928:	fd e3       	ldi	r31, 0x3D	; 61
     92a:	bf 2e       	mov	r11, r31
     92c:	f0 2d       	mov	r31, r0
     92e:	0f 2e       	mov	r0, r31
     930:	f4 e1       	ldi	r31, 0x14	; 20
     932:	cf 2e       	mov	r12, r31
     934:	fe ea       	ldi	r31, 0xAE	; 174
     936:	df 2e       	mov	r13, r31
     938:	ff e8       	ldi	r31, 0x8F	; 143
     93a:	ef 2e       	mov	r14, r31
     93c:	ff eb       	ldi	r31, 0xBF	; 191
     93e:	ff 2e       	mov	r15, r31
     940:	f0 2d       	mov	r31, r0
     942:	04 e1       	ldi	r16, 0x14	; 20
     944:	1e ea       	ldi	r17, 0xAE	; 174
     946:	2f e8       	ldi	r18, 0x8F	; 143
     948:	3f e3       	ldi	r19, 0x3F	; 63
     94a:	b5 01       	movw	r22, r10
     94c:	a4 01       	movw	r20, r8
     94e:	ce 01       	movw	r24, r28
     950:	05 96       	adiw	r24, 0x05	; 5
     952:	0e 94 80 05 	call	0xb00	; 0xb00 <_ZN3PIDC1Edddddd>
		double Tset = pidTorque.calculate(omegam_set, omegam_measured);
     956:	f3 01       	movw	r30, r6
     958:	66 8d       	ldd	r22, Z+30	; 0x1e
     95a:	77 8d       	ldd	r23, Z+31	; 0x1f
     95c:	02 8d       	ldd	r16, Z+26	; 0x1a
     95e:	13 8d       	ldd	r17, Z+27	; 0x1b
     960:	07 2e       	mov	r0, r23
     962:	00 0c       	add	r0, r0
     964:	88 0b       	sbc	r24, r24
     966:	99 0b       	sbc	r25, r25
     968:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     96c:	6b 01       	movw	r12, r22
     96e:	7c 01       	movw	r14, r24
     970:	b8 01       	movw	r22, r16
     972:	11 0f       	add	r17, r17
     974:	88 0b       	sbc	r24, r24
     976:	99 0b       	sbc	r25, r25
     978:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     97c:	ab 01       	movw	r20, r22
     97e:	bc 01       	movw	r22, r24
     980:	97 01       	movw	r18, r14
     982:	86 01       	movw	r16, r12
     984:	ce 01       	movw	r24, r28
     986:	05 96       	adiw	r24, 0x05	; 5
     988:	0e 94 a7 06 	call	0xd4e	; 0xd4e <_ZN3PID9calculateEdd>
     98c:	6b 01       	movw	r12, r22
     98e:	7c 01       	movw	r14, r24
		//printf("val:% 7.3f inc:% 7.3f\n", omegam_measured, inc);
		omegam_measured += inc;
     990:	f3 01       	movw	r30, r6
     992:	24 ad       	ldd	r18, Z+60	; 0x3c
     994:	35 ad       	ldd	r19, Z+61	; 0x3d
     996:	86 8d       	ldd	r24, Z+30	; 0x1e
     998:	97 8d       	ldd	r25, Z+31	; 0x1f
     99a:	82 0f       	add	r24, r18
     99c:	93 1f       	adc	r25, r19
     99e:	86 8f       	std	Z+30, r24	; 0x1e
     9a0:	97 8f       	std	Z+31, r25	; 0x1f

		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     9a2:	10 a6       	std	Z+40, r1	; 0x28
     9a4:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     9a6:	60 a5       	ldd	r22, Z+40	; 0x28
     9a8:	71 a5       	ldd	r23, Z+41	; 0x29
     9aa:	07 2e       	mov	r0, r23
     9ac:	00 0c       	add	r0, r0
     9ae:	88 0b       	sbc	r24, r24
     9b0:	99 0b       	sbc	r25, r25
     9b2:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     9b6:	9b 01       	movw	r18, r22
     9b8:	ac 01       	movw	r20, r24
     9ba:	c7 01       	movw	r24, r14
     9bc:	b6 01       	movw	r22, r12
     9be:	0e 94 1e 20 	call	0x403c	; 0x403c <__divsf3>
     9c2:	0e 94 90 20 	call	0x4120	; 0x4120 <__fixsfsi>
     9c6:	f3 01       	movw	r30, r6
     9c8:	64 a3       	std	Z+36, r22	; 0x24
     9ca:	75 a3       	std	Z+37, r23	; 0x25

		// Saturater for current
		
		if(Im_set > 17.4) {
     9cc:	64 a1       	ldd	r22, Z+36	; 0x24
     9ce:	75 a1       	ldd	r23, Z+37	; 0x25
     9d0:	07 2e       	mov	r0, r23
     9d2:	00 0c       	add	r0, r0
     9d4:	88 0b       	sbc	r24, r24
     9d6:	99 0b       	sbc	r25, r25
     9d8:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     9dc:	cd bf       	out	0x3d, r28	; 61
     9de:	de bf       	out	0x3e, r29	; 62
     9e0:	23 e3       	ldi	r18, 0x33	; 51
     9e2:	33 e3       	ldi	r19, 0x33	; 51
     9e4:	4b e8       	ldi	r20, 0x8B	; 139
     9e6:	51 e4       	ldi	r21, 0x41	; 65
     9e8:	0e 94 78 21 	call	0x42f0	; 0x42f0 <__gesf2>
     9ec:	18 16       	cp	r1, r24
     9ee:	34 f4       	brge	.+12     	; 0x9fc <_ZN5Motor3runEv+0x166>
			Im_set = 17.4;
     9f0:	21 e1       	ldi	r18, 0x11	; 17
     9f2:	30 e0       	ldi	r19, 0x00	; 0
     9f4:	f3 01       	movw	r30, r6
     9f6:	24 a3       	std	Z+36, r18	; 0x24
     9f8:	35 a3       	std	Z+37, r19	; 0x25
     9fa:	16 c0       	rjmp	.+44     	; 0xa28 <_ZN5Motor3runEv+0x192>
		} else if(Im_set < -17.4) {
     9fc:	f3 01       	movw	r30, r6
     9fe:	64 a1       	ldd	r22, Z+36	; 0x24
     a00:	75 a1       	ldd	r23, Z+37	; 0x25
     a02:	07 2e       	mov	r0, r23
     a04:	00 0c       	add	r0, r0
     a06:	88 0b       	sbc	r24, r24
     a08:	99 0b       	sbc	r25, r25
     a0a:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     a0e:	23 e3       	ldi	r18, 0x33	; 51
     a10:	33 e3       	ldi	r19, 0x33	; 51
     a12:	4b e8       	ldi	r20, 0x8B	; 139
     a14:	51 ec       	ldi	r21, 0xC1	; 193
     a16:	0e 94 19 20 	call	0x4032	; 0x4032 <__cmpsf2>
     a1a:	88 23       	and	r24, r24
     a1c:	2c f4       	brge	.+10     	; 0xa28 <_ZN5Motor3runEv+0x192>
			Im_set = -17.4;
     a1e:	2f ee       	ldi	r18, 0xEF	; 239
     a20:	3f ef       	ldi	r19, 0xFF	; 255
     a22:	f3 01       	movw	r30, r6
     a24:	24 a3       	std	Z+36, r18	; 0x24
     a26:	35 a3       	std	Z+37, r19	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     a28:	f3 01       	movw	r30, r6
     a2a:	16 aa       	std	Z+54, r1	; 0x36
     a2c:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     a2e:	60 a5       	ldd	r22, Z+40	; 0x28
     a30:	71 a5       	ldd	r23, Z+41	; 0x29
     a32:	06 a9       	ldd	r16, Z+54	; 0x36
     a34:	17 a9       	ldd	r17, Z+55	; 0x37
     a36:	07 2e       	mov	r0, r23
     a38:	00 0c       	add	r0, r0
     a3a:	88 0b       	sbc	r24, r24
     a3c:	99 0b       	sbc	r25, r25
     a3e:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     a42:	20 e5       	ldi	r18, 0x50	; 80
     a44:	3a e6       	ldi	r19, 0x6A	; 106
     a46:	41 ea       	ldi	r20, 0xA1	; 161
     a48:	57 e4       	ldi	r21, 0x47	; 71
     a4a:	0e 94 7d 21 	call	0x42fa	; 0x42fa <__mulsf3>
     a4e:	6b 01       	movw	r12, r22
     a50:	7c 01       	movw	r14, r24
     a52:	b8 01       	movw	r22, r16
     a54:	11 0f       	add	r17, r17
     a56:	88 0b       	sbc	r24, r24
     a58:	99 0b       	sbc	r25, r25
     a5a:	0e 94 c8 20 	call	0x4190	; 0x4190 <__floatsisf>
     a5e:	9b 01       	movw	r18, r22
     a60:	ac 01       	movw	r20, r24
     a62:	c7 01       	movw	r24, r14
     a64:	b6 01       	movw	r22, r12
     a66:	0e 94 7d 21 	call	0x42fa	; 0x42fa <__mulsf3>
     a6a:	0e 94 90 20 	call	0x4120	; 0x4120 <__fixsfsi>
     a6e:	f3 01       	movw	r30, r6
     a70:	62 ab       	std	Z+50, r22	; 0x32
     a72:	73 ab       	std	Z+51, r23	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     a74:	46 a9       	ldd	r20, Z+54	; 0x36
     a76:	57 a9       	ldd	r21, Z+55	; 0x37
     a78:	26 8d       	ldd	r18, Z+30	; 0x1e
     a7a:	37 8d       	ldd	r19, Z+31	; 0x1f
     a7c:	42 9f       	mul	r20, r18
     a7e:	c0 01       	movw	r24, r0
     a80:	43 9f       	mul	r20, r19
     a82:	90 0d       	add	r25, r0
     a84:	52 9f       	mul	r21, r18
     a86:	90 0d       	add	r25, r0
     a88:	11 24       	eor	r1, r1
     a8a:	84 ab       	std	Z+52, r24	; 0x34
     a8c:	95 ab       	std	Z+53, r25	; 0x35

		V_m = V_R + V_E;
     a8e:	20 a9       	ldd	r18, Z+48	; 0x30
     a90:	31 a9       	ldd	r19, Z+49	; 0x31
     a92:	84 a9       	ldd	r24, Z+52	; 0x34
     a94:	95 a9       	ldd	r25, Z+53	; 0x35
     a96:	82 0f       	add	r24, r18
     a98:	93 1f       	adc	r25, r19
     a9a:	80 af       	std	Z+56, r24	; 0x38
     a9c:	91 af       	std	Z+57, r25	; 0x39

		// Saturater for voltage
		if (V_m > 24) {
     a9e:	80 ad       	ldd	r24, Z+56	; 0x38
     aa0:	91 ad       	ldd	r25, Z+57	; 0x39
     aa2:	49 97       	sbiw	r24, 0x19	; 25
     aa4:	2c f0       	brlt	.+10     	; 0xab0 <_ZN5Motor3runEv+0x21a>
			V_m = 24;
     aa6:	28 e1       	ldi	r18, 0x18	; 24
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	20 af       	std	Z+56, r18	; 0x38
     aac:	31 af       	std	Z+57, r19	; 0x39
     aae:	0b c0       	rjmp	.+22     	; 0xac6 <_ZN5Motor3runEv+0x230>
		} else if(V_m < -24) {
     ab0:	f3 01       	movw	r30, r6
     ab2:	80 ad       	ldd	r24, Z+56	; 0x38
     ab4:	91 ad       	ldd	r25, Z+57	; 0x39
     ab6:	88 3e       	cpi	r24, 0xE8	; 232
     ab8:	9f 4f       	sbci	r25, 0xFF	; 255
     aba:	2c f4       	brge	.+10     	; 0xac6 <_ZN5Motor3runEv+0x230>
			V_m = -24;
     abc:	28 ee       	ldi	r18, 0xE8	; 232
     abe:	3f ef       	ldi	r19, 0xFF	; 255
     ac0:	f3 01       	movw	r30, r6
     ac2:	20 af       	std	Z+56, r18	; 0x38
     ac4:	31 af       	std	Z+57, r19	; 0x39
     ac6:	41 e0       	ldi	r20, 0x01	; 1
     ac8:	50 e0       	ldi	r21, 0x00	; 0
     aca:	60 e0       	ldi	r22, 0x00	; 0
     acc:	70 e0       	ldi	r23, 0x00	; 0
     ace:	ce 01       	movw	r24, r28
     ad0:	01 96       	adiw	r24, 0x01	; 1
     ad2:	0e 94 db 11 	call	0x23b6	; 0x23b6 <vTaskDelayUntil>
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     ad6:	ce 01       	movw	r24, r28
     ad8:	05 96       	adiw	r24, 0x05	; 5
     ada:	0e 94 e7 05 	call	0xbce	; 0xbce <_ZN3PIDD1Ev>
	portTickType previousTicks = xTaskGetTickCount ();

	dt = .008;
	inc = 1;
	
	while(1){
     ade:	03 cf       	rjmp	.-506    	; 0x8e6 <_ZN5Motor3runEv+0x50>

00000ae0 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     ae0:	0f 93       	push	r16
     ae2:	1f 93       	push	r17
     ae4:	cf 93       	push	r28
     ae6:	df 93       	push	r29
     ae8:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     aea:	0e 94 78 14 	call	0x28f0	; 0x28f0 <_ZN8frt_taskC1EPKchjP8emstream>
     aee:	8c e3       	ldi	r24, 0x3C	; 60
     af0:	90 e2       	ldi	r25, 0x20	; 32
     af2:	88 83       	st	Y, r24
     af4:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     af6:	df 91       	pop	r29
     af8:	cf 91       	pop	r28
     afa:	1f 91       	pop	r17
     afc:	0f 91       	pop	r16
     afe:	08 95       	ret

00000b00 <_ZN3PIDC1Edddddd>:
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}
     b00:	2f 92       	push	r2
     b02:	3f 92       	push	r3
     b04:	4f 92       	push	r4
     b06:	5f 92       	push	r5
     b08:	6f 92       	push	r6
     b0a:	7f 92       	push	r7
     b0c:	8f 92       	push	r8
     b0e:	9f 92       	push	r9
     b10:	af 92       	push	r10
     b12:	bf 92       	push	r11
     b14:	cf 92       	push	r12
     b16:	df 92       	push	r13
     b18:	ef 92       	push	r14
     b1a:	ff 92       	push	r15
     b1c:	0f 93       	push	r16
     b1e:	1f 93       	push	r17
     b20:	cf 93       	push	r28
     b22:	df 93       	push	r29
     b24:	00 d0       	rcall	.+0      	; 0xb26 <_ZN3PIDC1Edddddd+0x26>
     b26:	1f 92       	push	r1
     b28:	cd b7       	in	r28, 0x3d	; 61
     b2a:	de b7       	in	r29, 0x3e	; 62
     b2c:	1c 01       	movw	r2, r24
     b2e:	2a 01       	movw	r4, r20
     b30:	3b 01       	movw	r6, r22
     b32:	09 83       	std	Y+1, r16	; 0x01
     b34:	1a 83       	std	Y+2, r17	; 0x02
     b36:	2b 83       	std	Y+3, r18	; 0x03
     b38:	3c 83       	std	Y+4, r19	; 0x04
     b3a:	80 e2       	ldi	r24, 0x20	; 32
     b3c:	90 e0       	ldi	r25, 0x00	; 0
     b3e:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <_Znwj>
     b42:	fc 01       	movw	r30, r24
     b44:	40 82       	st	Z, r4
     b46:	51 82       	std	Z+1, r5	; 0x01
     b48:	62 82       	std	Z+2, r6	; 0x02
     b4a:	73 82       	std	Z+3, r7	; 0x03
     b4c:	89 81       	ldd	r24, Y+1	; 0x01
     b4e:	9a 81       	ldd	r25, Y+2	; 0x02
     b50:	ab 81       	ldd	r26, Y+3	; 0x03
     b52:	bc 81       	ldd	r27, Y+4	; 0x04
     b54:	84 83       	std	Z+4, r24	; 0x04
     b56:	95 83       	std	Z+5, r25	; 0x05
     b58:	a6 83       	std	Z+6, r26	; 0x06
     b5a:	b7 83       	std	Z+7, r27	; 0x07
     b5c:	c0 86       	std	Z+8, r12	; 0x08
     b5e:	d1 86       	std	Z+9, r13	; 0x09
     b60:	e2 86       	std	Z+10, r14	; 0x0a
     b62:	f3 86       	std	Z+11, r15	; 0x0b
     b64:	84 86       	std	Z+12, r8	; 0x0c
     b66:	95 86       	std	Z+13, r9	; 0x0d
     b68:	a6 86       	std	Z+14, r10	; 0x0e
     b6a:	b7 86       	std	Z+15, r11	; 0x0f
     b6c:	4a 8d       	ldd	r20, Y+26	; 0x1a
     b6e:	5b 8d       	ldd	r21, Y+27	; 0x1b
     b70:	6c 8d       	ldd	r22, Y+28	; 0x1c
     b72:	7d 8d       	ldd	r23, Y+29	; 0x1d
     b74:	40 8b       	std	Z+16, r20	; 0x10
     b76:	51 8b       	std	Z+17, r21	; 0x11
     b78:	62 8b       	std	Z+18, r22	; 0x12
     b7a:	73 8b       	std	Z+19, r23	; 0x13
     b7c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b7e:	9f 8d       	ldd	r25, Y+31	; 0x1f
     b80:	a8 a1       	ldd	r26, Y+32	; 0x20
     b82:	b9 a1       	ldd	r27, Y+33	; 0x21
     b84:	84 8b       	std	Z+20, r24	; 0x14
     b86:	95 8b       	std	Z+21, r25	; 0x15
     b88:	a6 8b       	std	Z+22, r26	; 0x16
     b8a:	b7 8b       	std	Z+23, r27	; 0x17
     b8c:	10 8e       	std	Z+24, r1	; 0x18
     b8e:	11 8e       	std	Z+25, r1	; 0x19
     b90:	12 8e       	std	Z+26, r1	; 0x1a
     b92:	13 8e       	std	Z+27, r1	; 0x1b
     b94:	14 8e       	std	Z+28, r1	; 0x1c
     b96:	15 8e       	std	Z+29, r1	; 0x1d
     b98:	16 8e       	std	Z+30, r1	; 0x1e
     b9a:	17 8e       	std	Z+31, r1	; 0x1f
     b9c:	d1 01       	movw	r26, r2
     b9e:	ed 93       	st	X+, r30
     ba0:	fc 93       	st	X, r31
     ba2:	24 96       	adiw	r28, 0x04	; 4
     ba4:	cd bf       	out	0x3d, r28	; 61
     ba6:	de bf       	out	0x3e, r29	; 62
     ba8:	df 91       	pop	r29
     baa:	cf 91       	pop	r28
     bac:	1f 91       	pop	r17
     bae:	0f 91       	pop	r16
     bb0:	ff 90       	pop	r15
     bb2:	ef 90       	pop	r14
     bb4:	df 90       	pop	r13
     bb6:	cf 90       	pop	r12
     bb8:	bf 90       	pop	r11
     bba:	af 90       	pop	r10
     bbc:	9f 90       	pop	r9
     bbe:	8f 90       	pop	r8
     bc0:	7f 90       	pop	r7
     bc2:	6f 90       	pop	r6
     bc4:	5f 90       	pop	r5
     bc6:	4f 90       	pop	r4
     bc8:	3f 90       	pop	r3
     bca:	2f 90       	pop	r2
     bcc:	08 95       	ret

00000bce <_ZN3PIDD1Ev>:
     bce:	fc 01       	movw	r30, r24
     bd0:	80 81       	ld	r24, Z
     bd2:	91 81       	ldd	r25, Z+1	; 0x01
     bd4:	00 97       	sbiw	r24, 0x00	; 0
     bd6:	11 f0       	breq	.+4      	; 0xbdc <_ZN3PIDD1Ev+0xe>
     bd8:	0e 94 f5 18 	call	0x31ea	; 0x31ea <_ZdlPv>
     bdc:	08 95       	ret

00000bde <_ZN7PIDImpl9calculateEdd>:

double PIDImpl::calculate( double setpoint, double pv )
{
     bde:	4f 92       	push	r4
     be0:	5f 92       	push	r5
     be2:	6f 92       	push	r6
     be4:	7f 92       	push	r7
     be6:	8f 92       	push	r8
     be8:	9f 92       	push	r9
     bea:	af 92       	push	r10
     bec:	bf 92       	push	r11
     bee:	cf 92       	push	r12
     bf0:	df 92       	push	r13
     bf2:	ef 92       	push	r14
     bf4:	ff 92       	push	r15
     bf6:	0f 93       	push	r16
     bf8:	1f 93       	push	r17
     bfa:	cf 93       	push	r28
     bfc:	df 93       	push	r29
     bfe:	00 d0       	rcall	.+0      	; 0xc00 <_ZN7PIDImpl9calculateEdd+0x22>
     c00:	00 d0       	rcall	.+0      	; 0xc02 <_ZN7PIDImpl9calculateEdd+0x24>
     c02:	cd b7       	in	r28, 0x3d	; 61
     c04:	de b7       	in	r29, 0x3e	; 62
     c06:	8d 83       	std	Y+5, r24	; 0x05
     c08:	9e 83       	std	Y+6, r25	; 0x06
     c0a:	cb 01       	movw	r24, r22
     c0c:	ba 01       	movw	r22, r20
    
    // Calculate error
    double error = setpoint - pv;
     c0e:	a9 01       	movw	r20, r18
     c10:	98 01       	movw	r18, r16
     c12:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <__subsf3>
     c16:	6b 01       	movw	r12, r22
     c18:	7c 01       	movw	r14, r24

    // Proportional term
    double Pout = _Kp * error;
     c1a:	ed 81       	ldd	r30, Y+5	; 0x05
     c1c:	fe 81       	ldd	r31, Y+6	; 0x06
     c1e:	24 85       	ldd	r18, Z+12	; 0x0c
     c20:	35 85       	ldd	r19, Z+13	; 0x0d
     c22:	46 85       	ldd	r20, Z+14	; 0x0e
     c24:	57 85       	ldd	r21, Z+15	; 0x0f
     c26:	0e 94 7d 21 	call	0x42fa	; 0x42fa <__mulsf3>
     c2a:	69 83       	std	Y+1, r22	; 0x01
     c2c:	7a 83       	std	Y+2, r23	; 0x02
     c2e:	8b 83       	std	Y+3, r24	; 0x03
     c30:	9c 83       	std	Y+4, r25	; 0x04

    // Integral term
    _integral += error * _dt;
     c32:	ed 81       	ldd	r30, Y+5	; 0x05
     c34:	fe 81       	ldd	r31, Y+6	; 0x06
     c36:	40 80       	ld	r4, Z
     c38:	51 80       	ldd	r5, Z+1	; 0x01
     c3a:	62 80       	ldd	r6, Z+2	; 0x02
     c3c:	73 80       	ldd	r7, Z+3	; 0x03
     c3e:	a3 01       	movw	r20, r6
     c40:	92 01       	movw	r18, r4
     c42:	c7 01       	movw	r24, r14
     c44:	b6 01       	movw	r22, r12
     c46:	0e 94 7d 21 	call	0x42fa	; 0x42fa <__mulsf3>
     c4a:	ed 81       	ldd	r30, Y+5	; 0x05
     c4c:	fe 81       	ldd	r31, Y+6	; 0x06
     c4e:	24 8d       	ldd	r18, Z+28	; 0x1c
     c50:	35 8d       	ldd	r19, Z+29	; 0x1d
     c52:	46 8d       	ldd	r20, Z+30	; 0x1e
     c54:	57 8d       	ldd	r21, Z+31	; 0x1f
     c56:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <__addsf3>
     c5a:	4b 01       	movw	r8, r22
     c5c:	5c 01       	movw	r10, r24
     c5e:	ed 81       	ldd	r30, Y+5	; 0x05
     c60:	fe 81       	ldd	r31, Y+6	; 0x06
     c62:	64 8f       	std	Z+28, r22	; 0x1c
     c64:	75 8f       	std	Z+29, r23	; 0x1d
     c66:	86 8f       	std	Z+30, r24	; 0x1e
     c68:	97 8f       	std	Z+31, r25	; 0x1f
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     c6a:	20 8d       	ldd	r18, Z+24	; 0x18
     c6c:	31 8d       	ldd	r19, Z+25	; 0x19
     c6e:	42 8d       	ldd	r20, Z+26	; 0x1a
     c70:	53 8d       	ldd	r21, Z+27	; 0x1b
     c72:	c7 01       	movw	r24, r14
     c74:	b6 01       	movw	r22, r12
     c76:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <__subsf3>
     c7a:	a3 01       	movw	r20, r6
     c7c:	92 01       	movw	r18, r4
     c7e:	0e 94 1e 20 	call	0x403c	; 0x403c <__divsf3>
     c82:	ed 81       	ldd	r30, Y+5	; 0x05
     c84:	fe 81       	ldd	r31, Y+6	; 0x06
     c86:	20 89       	ldd	r18, Z+16	; 0x10
     c88:	31 89       	ldd	r19, Z+17	; 0x11
     c8a:	42 89       	ldd	r20, Z+18	; 0x12
     c8c:	53 89       	ldd	r21, Z+19	; 0x13
     c8e:	0e 94 7d 21 	call	0x42fa	; 0x42fa <__mulsf3>
     c92:	2b 01       	movw	r4, r22
     c94:	3c 01       	movw	r6, r24
     c96:	ed 81       	ldd	r30, Y+5	; 0x05
     c98:	fe 81       	ldd	r31, Y+6	; 0x06
     c9a:	24 89       	ldd	r18, Z+20	; 0x14
     c9c:	35 89       	ldd	r19, Z+21	; 0x15
     c9e:	46 89       	ldd	r20, Z+22	; 0x16
     ca0:	57 89       	ldd	r21, Z+23	; 0x17
     ca2:	c5 01       	movw	r24, r10
     ca4:	b4 01       	movw	r22, r8
     ca6:	0e 94 7d 21 	call	0x42fa	; 0x42fa <__mulsf3>
     caa:	29 81       	ldd	r18, Y+1	; 0x01
     cac:	3a 81       	ldd	r19, Y+2	; 0x02
     cae:	4b 81       	ldd	r20, Y+3	; 0x03
     cb0:	5c 81       	ldd	r21, Y+4	; 0x04
     cb2:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <__addsf3>
     cb6:	9b 01       	movw	r18, r22
     cb8:	ac 01       	movw	r20, r24
     cba:	c3 01       	movw	r24, r6
     cbc:	b2 01       	movw	r22, r4
     cbe:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <__addsf3>
     cc2:	b6 2e       	mov	r11, r22
     cc4:	a7 2e       	mov	r10, r23
     cc6:	98 2e       	mov	r9, r24
     cc8:	89 2e       	mov	r8, r25

    // Restrict to max/min
    if( output > _max )
     cca:	ed 81       	ldd	r30, Y+5	; 0x05
     ccc:	fe 81       	ldd	r31, Y+6	; 0x06
     cce:	74 80       	ldd	r7, Z+4	; 0x04
     cd0:	65 80       	ldd	r6, Z+5	; 0x05
     cd2:	56 80       	ldd	r5, Z+6	; 0x06
     cd4:	47 80       	ldd	r4, Z+7	; 0x07
     cd6:	27 2d       	mov	r18, r7
     cd8:	36 2d       	mov	r19, r6
     cda:	45 2d       	mov	r20, r5
     cdc:	54 2d       	mov	r21, r4
     cde:	0e 94 78 21 	call	0x42f0	; 0x42f0 <__gesf2>
     ce2:	18 16       	cp	r1, r24
     ce4:	b4 f0       	brlt	.+44     	; 0xd12 <_ZN7PIDImpl9calculateEdd+0x134>
        output = _max;
    else if( output < _min )
     ce6:	ed 81       	ldd	r30, Y+5	; 0x05
     ce8:	fe 81       	ldd	r31, Y+6	; 0x06
     cea:	70 84       	ldd	r7, Z+8	; 0x08
     cec:	61 84       	ldd	r6, Z+9	; 0x09
     cee:	52 84       	ldd	r5, Z+10	; 0x0a
     cf0:	43 84       	ldd	r4, Z+11	; 0x0b
     cf2:	27 2d       	mov	r18, r7
     cf4:	36 2d       	mov	r19, r6
     cf6:	45 2d       	mov	r20, r5
     cf8:	54 2d       	mov	r21, r4
     cfa:	6b 2d       	mov	r22, r11
     cfc:	7a 2d       	mov	r23, r10
     cfe:	89 2d       	mov	r24, r9
     d00:	98 2d       	mov	r25, r8
     d02:	0e 94 19 20 	call	0x4032	; 0x4032 <__cmpsf2>
     d06:	88 23       	and	r24, r24
     d08:	24 f0       	brlt	.+8      	; 0xd12 <_ZN7PIDImpl9calculateEdd+0x134>
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     d0a:	7b 2c       	mov	r7, r11
     d0c:	6a 2c       	mov	r6, r10
     d0e:	59 2c       	mov	r5, r9
     d10:	48 2c       	mov	r4, r8
        output = _max;
    else if( output < _min )
        output = _min;

    // Save error to previous error
    _pre_error = error;
     d12:	ed 81       	ldd	r30, Y+5	; 0x05
     d14:	fe 81       	ldd	r31, Y+6	; 0x06
     d16:	c0 8e       	std	Z+24, r12	; 0x18
     d18:	d1 8e       	std	Z+25, r13	; 0x19
     d1a:	e2 8e       	std	Z+26, r14	; 0x1a
     d1c:	f3 8e       	std	Z+27, r15	; 0x1b

    return output;
}
     d1e:	67 2d       	mov	r22, r7
     d20:	76 2d       	mov	r23, r6
     d22:	85 2d       	mov	r24, r5
     d24:	94 2d       	mov	r25, r4
     d26:	26 96       	adiw	r28, 0x06	; 6
     d28:	cd bf       	out	0x3d, r28	; 61
     d2a:	de bf       	out	0x3e, r29	; 62
     d2c:	df 91       	pop	r29
     d2e:	cf 91       	pop	r28
     d30:	1f 91       	pop	r17
     d32:	0f 91       	pop	r16
     d34:	ff 90       	pop	r15
     d36:	ef 90       	pop	r14
     d38:	df 90       	pop	r13
     d3a:	cf 90       	pop	r12
     d3c:	bf 90       	pop	r11
     d3e:	af 90       	pop	r10
     d40:	9f 90       	pop	r9
     d42:	8f 90       	pop	r8
     d44:	7f 90       	pop	r7
     d46:	6f 90       	pop	r6
     d48:	5f 90       	pop	r5
     d4a:	4f 90       	pop	r4
     d4c:	08 95       	ret

00000d4e <_ZN3PID9calculateEdd>:
PID::PID( double dt, double max, double min, double Kp, double Kd, double Ki )
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
double PID::calculate( double setpoint, double pv )
{
     d4e:	0f 93       	push	r16
     d50:	1f 93       	push	r17
    return pimpl->calculate(setpoint,pv);
     d52:	fc 01       	movw	r30, r24
     d54:	80 81       	ld	r24, Z
     d56:	91 81       	ldd	r25, Z+1	; 0x01
     d58:	0e 94 ef 05 	call	0xbde	; 0xbde <_ZN7PIDImpl9calculateEdd>
}
     d5c:	1f 91       	pop	r17
     d5e:	0f 91       	pop	r16
     d60:	08 95       	ret

00000d62 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     d62:	0f 93       	push	r16
     d64:	1f 93       	push	r17
     d66:	cf 93       	push	r28
     d68:	df 93       	push	r29
     d6a:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d6c:	0e 94 78 14 	call	0x28f0	; 0x28f0 <_ZN8frt_taskC1EPKchjP8emstream>
     d70:	84 e4       	ldi	r24, 0x44	; 68
     d72:	90 e2       	ldi	r25, 0x20	; 32
     d74:	88 83       	st	Y, r24
     d76:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	1f 91       	pop	r17
     d7e:	0f 91       	pop	r16
     d80:	08 95       	ret

00000d82 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     d82:	0f 93       	push	r16
     d84:	1f 93       	push	r17
     d86:	cf 93       	push	r28
     d88:	df 93       	push	r29
     d8a:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     d8c:	6a e0       	ldi	r22, 0x0A	; 10
     d8e:	8e 81       	ldd	r24, Y+6	; 0x06
     d90:	9f 81       	ldd	r25, Y+7	; 0x07
     d92:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     d96:	8c 01       	movw	r16, r24
     d98:	69 ee       	ldi	r22, 0xE9	; 233
     d9a:	73 e0       	ldi	r23, 0x03	; 3
     d9c:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     da0:	6a e0       	ldi	r22, 0x0A	; 10
     da2:	c8 01       	movw	r24, r16
     da4:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     da8:	8c 01       	movw	r16, r24
     daa:	63 ee       	ldi	r22, 0xE3	; 227
     dac:	73 e0       	ldi	r23, 0x03	; 3
     dae:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     db2:	67 e0       	ldi	r22, 0x07	; 7
     db4:	c8 01       	movw	r24, r16
     db6:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     dba:	6a e0       	ldi	r22, 0x0A	; 10
     dbc:	8e 81       	ldd	r24, Y+6	; 0x06
     dbe:	9f 81       	ldd	r25, Y+7	; 0x07
     dc0:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     dc4:	8c 01       	movw	r16, r24
     dc6:	64 ec       	ldi	r22, 0xC4	; 196
     dc8:	73 e0       	ldi	r23, 0x03	; 3
     dca:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     dce:	6a e0       	ldi	r22, 0x0A	; 10
     dd0:	c8 01       	movw	r24, r16
     dd2:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     dd6:	8c 01       	movw	r16, r24
     dd8:	6e eb       	ldi	r22, 0xBE	; 190
     dda:	73 e0       	ldi	r23, 0x03	; 3
     ddc:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     de0:	66 e0       	ldi	r22, 0x06	; 6
     de2:	c8 01       	movw	r24, r16
     de4:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     de8:	6a e0       	ldi	r22, 0x0A	; 10
     dea:	8e 81       	ldd	r24, Y+6	; 0x06
     dec:	9f 81       	ldd	r25, Y+7	; 0x07
     dee:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     df2:	8c 01       	movw	r16, r24
     df4:	67 ea       	ldi	r22, 0xA7	; 167
     df6:	73 e0       	ldi	r23, 0x03	; 3
     df8:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     dfc:	66 e0       	ldi	r22, 0x06	; 6
     dfe:	c8 01       	movw	r24, r16
     e00:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e04:	6a e0       	ldi	r22, 0x0A	; 10
     e06:	8e 81       	ldd	r24, Y+6	; 0x06
     e08:	9f 81       	ldd	r25, Y+7	; 0x07
     e0a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     e0e:	8c 01       	movw	r16, r24
     e10:	6b e8       	ldi	r22, 0x8B	; 139
     e12:	73 e0       	ldi	r23, 0x03	; 3
     e14:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     e18:	66 e0       	ldi	r22, 0x06	; 6
     e1a:	c8 01       	movw	r24, r16
     e1c:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e20:	6a e0       	ldi	r22, 0x0A	; 10
     e22:	8e 81       	ldd	r24, Y+6	; 0x06
     e24:	9f 81       	ldd	r25, Y+7	; 0x07
     e26:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     e2a:	8c 01       	movw	r16, r24
     e2c:	63 e7       	ldi	r22, 0x73	; 115
     e2e:	73 e0       	ldi	r23, 0x03	; 3
     e30:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     e34:	66 e0       	ldi	r22, 0x06	; 6
     e36:	c8 01       	movw	r24, r16
     e38:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e3c:	6a e0       	ldi	r22, 0x0A	; 10
     e3e:	8e 81       	ldd	r24, Y+6	; 0x06
     e40:	9f 81       	ldd	r25, Y+7	; 0x07
     e42:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     e46:	8c 01       	movw	r16, r24
     e48:	62 e5       	ldi	r22, 0x52	; 82
     e4a:	73 e0       	ldi	r23, 0x03	; 3
     e4c:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     e50:	66 e0       	ldi	r22, 0x06	; 6
     e52:	c8 01       	movw	r24, r16
     e54:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e58:	6a e0       	ldi	r22, 0x0A	; 10
     e5a:	8e 81       	ldd	r24, Y+6	; 0x06
     e5c:	9f 81       	ldd	r25, Y+7	; 0x07
     e5e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     e62:	8c 01       	movw	r16, r24
     e64:	6b e2       	ldi	r22, 0x2B	; 43
     e66:	73 e0       	ldi	r23, 0x03	; 3
     e68:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     e6c:	66 e0       	ldi	r22, 0x06	; 6
     e6e:	c8 01       	movw	r24, r16
     e70:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     e74:	6a e0       	ldi	r22, 0x0A	; 10
     e76:	8e 81       	ldd	r24, Y+6	; 0x06
     e78:	9f 81       	ldd	r25, Y+7	; 0x07
     e7a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     e7e:	8c 01       	movw	r16, r24
     e80:	6d e0       	ldi	r22, 0x0D	; 13
     e82:	73 e0       	ldi	r23, 0x03	; 3
     e84:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     e88:	66 e0       	ldi	r22, 0x06	; 6
     e8a:	c8 01       	movw	r24, r16
     e8c:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     e90:	6a e0       	ldi	r22, 0x0A	; 10
     e92:	8e 81       	ldd	r24, Y+6	; 0x06
     e94:	9f 81       	ldd	r25, Y+7	; 0x07
     e96:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     e9a:	8c 01       	movw	r16, r24
     e9c:	62 ef       	ldi	r22, 0xF2	; 242
     e9e:	72 e0       	ldi	r23, 0x02	; 2
     ea0:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     ea4:	66 e0       	ldi	r22, 0x06	; 6
     ea6:	c8 01       	movw	r24, r16
     ea8:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     eac:	6a e0       	ldi	r22, 0x0A	; 10
     eae:	8e 81       	ldd	r24, Y+6	; 0x06
     eb0:	9f 81       	ldd	r25, Y+7	; 0x07
     eb2:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     eb6:	ec 01       	movw	r28, r24
     eb8:	63 ee       	ldi	r22, 0xE3	; 227
     eba:	72 e0       	ldi	r23, 0x02	; 2
     ebc:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     ec0:	66 e0       	ldi	r22, 0x06	; 6
     ec2:	ce 01       	movw	r24, r28
     ec4:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
}
     ec8:	df 91       	pop	r29
     eca:	cf 91       	pop	r28
     ecc:	1f 91       	pop	r17
     ece:	0f 91       	pop	r16
     ed0:	08 95       	ret

00000ed2 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     ed2:	af 92       	push	r10
     ed4:	bf 92       	push	r11
     ed6:	cf 92       	push	r12
     ed8:	df 92       	push	r13
     eda:	ef 92       	push	r14
     edc:	ff 92       	push	r15
     ede:	0f 93       	push	r16
     ee0:	1f 93       	push	r17
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
     ee6:	00 d0       	rcall	.+0      	; 0xee8 <_ZN9task_user11show_statusEv+0x16>
     ee8:	00 d0       	rcall	.+0      	; 0xeea <_ZN9task_user11show_statusEv+0x18>
     eea:	cd b7       	in	r28, 0x3d	; 61
     eec:	de b7       	in	r29, 0x3e	; 62
     eee:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     ef0:	19 82       	std	Y+1, r1	; 0x01
     ef2:	1a 82       	std	Y+2, r1	; 0x02
     ef4:	1b 82       	std	Y+3, r1	; 0x03
     ef6:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     ef8:	1d 82       	std	Y+5, r1	; 0x05
     efa:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     efc:	0e 94 ee 09 	call	0x13dc	; 0x13dc <xPortGetFreeHeapSize>
     f00:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f02:	ce 01       	movw	r24, r28
     f04:	01 96       	adiw	r24, 0x01	; 1
     f06:	0e 94 29 18 	call	0x3052	; 0x3052 <_ZN10time_stamp10set_to_nowEv>
     f0a:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f0c:	66 e0       	ldi	r22, 0x06	; 6
     f0e:	f8 01       	movw	r30, r16
     f10:	86 81       	ldd	r24, Z+6	; 0x06
     f12:	97 81       	ldd	r25, Z+7	; 0x07
     f14:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     f18:	6a e0       	ldi	r22, 0x0A	; 10
     f1a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     f1e:	7c 01       	movw	r14, r24
     f20:	64 ec       	ldi	r22, 0xC4	; 196
     f22:	72 e0       	ldi	r23, 0x02	; 2
     f24:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     f28:	6a e0       	ldi	r22, 0x0A	; 10
     f2a:	c7 01       	movw	r24, r14
     f2c:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     f30:	7c 01       	movw	r14, r24
     f32:	68 eb       	ldi	r22, 0xB8	; 184
     f34:	72 e0       	ldi	r23, 0x02	; 2
     f36:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     f3a:	66 e0       	ldi	r22, 0x06	; 6
     f3c:	c7 01       	movw	r24, r14
     f3e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f42:	6a e0       	ldi	r22, 0x0A	; 10
     f44:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     f48:	7c 01       	movw	r14, r24
     f4a:	61 eb       	ldi	r22, 0xB1	; 177
     f4c:	72 e0       	ldi	r23, 0x02	; 2
     f4e:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     f52:	b5 01       	movw	r22, r10
     f54:	c7 01       	movw	r24, r14
     f56:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f5a:	6a e0       	ldi	r22, 0x0A	; 10
     f5c:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     f60:	7c 01       	movw	r14, r24
     f62:	63 ea       	ldi	r22, 0xA3	; 163
     f64:	72 e0       	ldi	r23, 0x02	; 2
     f66:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     f6a:	b6 01       	movw	r22, r12
     f6c:	c7 01       	movw	r24, r14
     f6e:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <_ZN8emstreamlsEj>
     f72:	6a e0       	ldi	r22, 0x0A	; 10
     f74:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     f78:	7c 01       	movw	r14, r24
     f7a:	61 ea       	ldi	r22, 0xA1	; 161
     f7c:	72 e0       	ldi	r23, 0x02	; 2
     f7e:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     f82:	4f ef       	ldi	r20, 0xFF	; 255
     f84:	5f e0       	ldi	r21, 0x0F	; 15
     f86:	60 e0       	ldi	r22, 0x00	; 0
     f88:	70 e0       	ldi	r23, 0x00	; 0
     f8a:	c7 01       	movw	r24, r14
     f8c:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     f90:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     f94:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     f98:	6a e0       	ldi	r22, 0x0A	; 10
     f9a:	f8 01       	movw	r30, r16
     f9c:	86 81       	ldd	r24, Z+6	; 0x06
     f9e:	97 81       	ldd	r25, Z+7	; 0x07
     fa0:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     fa4:	7c 01       	movw	r14, r24
     fa6:	66 e9       	ldi	r22, 0x96	; 150
     fa8:	72 e0       	ldi	r23, 0x02	; 2
     faa:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
     fae:	b6 01       	movw	r22, r12
     fb0:	c7 01       	movw	r24, r14
     fb2:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <_ZN8emstreamlsEj>
     fb6:	66 e0       	ldi	r22, 0x06	; 6
     fb8:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
     fbc:	66 e0       	ldi	r22, 0x06	; 6
     fbe:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     fc2:	f8 01       	movw	r30, r16
     fc4:	86 81       	ldd	r24, Z+6	; 0x06
     fc6:	97 81       	ldd	r25, Z+7	; 0x07
     fc8:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <_Z15print_task_listP8emstream>
}
     fcc:	26 96       	adiw	r28, 0x06	; 6
     fce:	cd bf       	out	0x3d, r28	; 61
     fd0:	de bf       	out	0x3e, r29	; 62
     fd2:	df 91       	pop	r29
     fd4:	cf 91       	pop	r28
     fd6:	1f 91       	pop	r17
     fd8:	0f 91       	pop	r16
     fda:	ff 90       	pop	r15
     fdc:	ef 90       	pop	r14
     fde:	df 90       	pop	r13
     fe0:	cf 90       	pop	r12
     fe2:	bf 90       	pop	r11
     fe4:	af 90       	pop	r10
     fe6:	08 95       	ret

00000fe8 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     fe8:	cf 93       	push	r28
     fea:	df 93       	push	r29
     fec:	00 d0       	rcall	.+0      	; 0xfee <_ZN9task_user3runEv+0x6>
     fee:	00 d0       	rcall	.+0      	; 0xff0 <_ZN9task_user3runEv+0x8>
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     ff6:	19 82       	std	Y+1, r1	; 0x01
     ff8:	1a 82       	std	Y+2, r1	; 0x02
     ffa:	1b 82       	std	Y+3, r1	; 0x03
     ffc:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     ffe:	1d 82       	std	Y+5, r1	; 0x05
    1000:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1002:	6a e0       	ldi	r22, 0x0A	; 10
    1004:	dc 01       	movw	r26, r24
    1006:	16 96       	adiw	r26, 0x06	; 6
    1008:	8d 91       	ld	r24, X+
    100a:	9c 91       	ld	r25, X
    100c:	17 97       	sbiw	r26, 0x07	; 7
    100e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    1012:	7c 01       	movw	r14, r24
    1014:	62 e3       	ldi	r22, 0x32	; 50
    1016:	74 e0       	ldi	r23, 0x04	; 4
    1018:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    101c:	66 e0       	ldi	r22, 0x06	; 6
    101e:	c7 01       	movw	r24, r14
    1020:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1024:	f8 01       	movw	r30, r16
    1026:	84 85       	ldd	r24, Z+12	; 0x0c
    1028:	88 23       	and	r24, r24
    102a:	21 f0       	breq	.+8      	; 0x1034 <_ZN9task_user3runEv+0x4c>
    102c:	81 30       	cpi	r24, 0x01	; 1
    102e:	09 f4       	brne	.+2      	; 0x1032 <_ZN9task_user3runEv+0x4a>
    1030:	5d c0       	rjmp	.+186    	; 0x10ec <_ZN9task_user3runEv+0x104>
    1032:	d8 c0       	rjmp	.+432    	; 0x11e4 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1034:	86 81       	ldd	r24, Z+6	; 0x06
    1036:	97 81       	ldd	r25, Z+7	; 0x07
    1038:	dc 01       	movw	r26, r24
    103a:	ed 91       	ld	r30, X+
    103c:	fc 91       	ld	r31, X
    103e:	04 80       	ldd	r0, Z+4	; 0x04
    1040:	f5 81       	ldd	r31, Z+5	; 0x05
    1042:	e0 2d       	mov	r30, r0
    1044:	19 95       	eicall
    1046:	88 23       	and	r24, r24
    1048:	a9 f1       	breq	.+106    	; 0x10b4 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    104a:	f8 01       	movw	r30, r16
    104c:	86 81       	ldd	r24, Z+6	; 0x06
    104e:	97 81       	ldd	r25, Z+7	; 0x07
    1050:	dc 01       	movw	r26, r24
    1052:	ed 91       	ld	r30, X+
    1054:	fc 91       	ld	r31, X
    1056:	06 80       	ldd	r0, Z+6	; 0x06
    1058:	f7 81       	ldd	r31, Z+7	; 0x07
    105a:	e0 2d       	mov	r30, r0
    105c:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    105e:	99 27       	eor	r25, r25
    1060:	81 30       	cpi	r24, 0x01	; 1
    1062:	91 05       	cpc	r25, r1
    1064:	f9 f0       	breq	.+62     	; 0x10a4 <_ZN9task_user3runEv+0xbc>
    1066:	03 97       	sbiw	r24, 0x03	; 3
    1068:	09 f0       	breq	.+2      	; 0x106c <_ZN9task_user3runEv+0x84>
    106a:	d8 c0       	rjmp	.+432    	; 0x121c <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    106c:	6a e0       	ldi	r22, 0x0A	; 10
    106e:	f8 01       	movw	r30, r16
    1070:	86 81       	ldd	r24, Z+6	; 0x06
    1072:	97 81       	ldd	r25, Z+7	; 0x07
    1074:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    1078:	8c 01       	movw	r16, r24
    107a:	64 e2       	ldi	r22, 0x24	; 36
    107c:	74 e0       	ldi	r23, 0x04	; 4
    107e:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    1082:	66 e0       	ldi	r22, 0x06	; 6
    1084:	c8 01       	movw	r24, r16
    1086:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    108a:	93 e0       	ldi	r25, 0x03	; 3
    108c:	88 ed       	ldi	r24, 0xD8	; 216
    108e:	08 b6       	in	r0, 0x38	; 56
    1090:	18 be       	out	0x38, r1	; 56
    1092:	84 bf       	out	0x34, r24	; 52
    1094:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1098:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    109c:	81 fd       	sbrc	r24, 1
    109e:	fc cf       	rjmp	.-8      	; 0x1098 <_ZN9task_user3runEv+0xb0>
    10a0:	08 be       	out	0x38, r0	; 56
    10a2:	ff cf       	rjmp	.-2      	; 0x10a2 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10a4:	c8 01       	movw	r24, r16
    10a6:	0e 94 c1 06 	call	0xd82	; 0xd82 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10aa:	61 e0       	ldi	r22, 0x01	; 1
    10ac:	c8 01       	movw	r24, r16
    10ae:	0e 94 74 14 	call	0x28e8	; 0x28e8 <_ZN8frt_task13transition_toEh>
							break;
    10b2:	b4 c0       	rjmp	.+360    	; 0x121c <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10b4:	86 e6       	ldi	r24, 0x66	; 102
    10b6:	91 e3       	ldi	r25, 0x31	; 49
    10b8:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <_ZN14frt_text_queue14check_for_charEv>
    10bc:	88 23       	and	r24, r24
    10be:	09 f4       	brne	.+2      	; 0x10c2 <_ZN9task_user3runEv+0xda>
    10c0:	ad c0       	rjmp	.+346    	; 0x121c <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    10c2:	d8 01       	movw	r26, r16
    10c4:	16 96       	adiw	r26, 0x06	; 6
    10c6:	ed 91       	ld	r30, X+
    10c8:	fc 91       	ld	r31, X
    10ca:	17 97       	sbiw	r26, 0x07	; 7
    10cc:	01 90       	ld	r0, Z+
    10ce:	f0 81       	ld	r31, Z
    10d0:	e0 2d       	mov	r30, r0
    10d2:	e2 80       	ldd	r14, Z+2	; 0x02
    10d4:	f3 80       	ldd	r15, Z+3	; 0x03
    10d6:	86 e6       	ldi	r24, 0x66	; 102
    10d8:	91 e3       	ldi	r25, 0x31	; 49
    10da:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <_ZN14frt_text_queue7getcharEv>
    10de:	68 2f       	mov	r22, r24
    10e0:	f8 01       	movw	r30, r16
    10e2:	86 81       	ldd	r24, Z+6	; 0x06
    10e4:	97 81       	ldd	r25, Z+7	; 0x07
    10e6:	f7 01       	movw	r30, r14
    10e8:	19 95       	eicall
    10ea:	98 c0       	rjmp	.+304    	; 0x121c <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    10ec:	86 81       	ldd	r24, Z+6	; 0x06
    10ee:	97 81       	ldd	r25, Z+7	; 0x07
    10f0:	dc 01       	movw	r26, r24
    10f2:	ed 91       	ld	r30, X+
    10f4:	fc 91       	ld	r31, X
    10f6:	04 80       	ldd	r0, Z+4	; 0x04
    10f8:	f5 81       	ldd	r31, Z+5	; 0x05
    10fa:	e0 2d       	mov	r30, r0
    10fc:	19 95       	eicall
    10fe:	88 23       	and	r24, r24
    1100:	09 f4       	brne	.+2      	; 0x1104 <_ZN9task_user3runEv+0x11c>
    1102:	8c c0       	rjmp	.+280    	; 0x121c <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1104:	f8 01       	movw	r30, r16
    1106:	86 81       	ldd	r24, Z+6	; 0x06
    1108:	97 81       	ldd	r25, Z+7	; 0x07
    110a:	dc 01       	movw	r26, r24
    110c:	ed 91       	ld	r30, X+
    110e:	fc 91       	ld	r31, X
    1110:	06 80       	ldd	r0, Z+6	; 0x06
    1112:	f7 81       	ldd	r31, Z+7	; 0x07
    1114:	e0 2d       	mov	r30, r0
    1116:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1118:	9c 01       	movw	r18, r24
    111a:	33 27       	eor	r19, r19
    111c:	28 36       	cpi	r18, 0x68	; 104
    111e:	31 05       	cpc	r19, r1
    1120:	59 f1       	breq	.+86     	; 0x1178 <_ZN9task_user3runEv+0x190>
    1122:	3c f4       	brge	.+14     	; 0x1132 <_ZN9task_user3runEv+0x14a>
    1124:	2b 31       	cpi	r18, 0x1B	; 27
    1126:	31 05       	cpc	r19, r1
    1128:	59 f1       	breq	.+86     	; 0x1180 <_ZN9task_user3runEv+0x198>
    112a:	25 36       	cpi	r18, 0x65	; 101
    112c:	31 05       	cpc	r19, r1
    112e:	41 f1       	breq	.+80     	; 0x1180 <_ZN9task_user3runEv+0x198>
    1130:	3b c0       	rjmp	.+118    	; 0x11a8 <_ZN9task_user3runEv+0x1c0>
    1132:	23 37       	cpi	r18, 0x73	; 115
    1134:	31 05       	cpc	r19, r1
    1136:	c1 f0       	breq	.+48     	; 0x1168 <_ZN9task_user3runEv+0x180>
    1138:	26 37       	cpi	r18, 0x76	; 118
    113a:	31 05       	cpc	r19, r1
    113c:	89 f0       	breq	.+34     	; 0x1160 <_ZN9task_user3runEv+0x178>
    113e:	2e 36       	cpi	r18, 0x6E	; 110
    1140:	31 05       	cpc	r19, r1
    1142:	91 f5       	brne	.+100    	; 0x11a8 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1144:	ce 01       	movw	r24, r28
    1146:	01 96       	adiw	r24, 0x01	; 1
    1148:	0e 94 29 18 	call	0x3052	; 0x3052 <_ZN10time_stamp10set_to_nowEv>
    114c:	bc 01       	movw	r22, r24
    114e:	f8 01       	movw	r30, r16
    1150:	86 81       	ldd	r24, Z+6	; 0x06
    1152:	97 81       	ldd	r25, Z+7	; 0x07
    1154:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <_ZlsR8emstreamR10time_stamp>
    1158:	66 e0       	ldi	r22, 0x06	; 6
    115a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
							break;
    115e:	5e c0       	rjmp	.+188    	; 0x121c <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1160:	c8 01       	movw	r24, r16
    1162:	0e 94 69 07 	call	0xed2	; 0xed2 <_ZN9task_user11show_statusEv>
							break;
    1166:	5a c0       	rjmp	.+180    	; 0x121c <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1168:	d8 01       	movw	r26, r16
    116a:	16 96       	adiw	r26, 0x06	; 6
    116c:	8d 91       	ld	r24, X+
    116e:	9c 91       	ld	r25, X
    1170:	17 97       	sbiw	r26, 0x07	; 7
    1172:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <_Z17print_task_stacksP8emstream>
							break;
    1176:	52 c0       	rjmp	.+164    	; 0x121c <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1178:	c8 01       	movw	r24, r16
    117a:	0e 94 c1 06 	call	0xd82	; 0xd82 <_ZN9task_user18print_help_messageEv>
							break;
    117e:	4e c0       	rjmp	.+156    	; 0x121c <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1180:	6a e0       	ldi	r22, 0x0A	; 10
    1182:	f8 01       	movw	r30, r16
    1184:	86 81       	ldd	r24, Z+6	; 0x06
    1186:	97 81       	ldd	r25, Z+7	; 0x07
    1188:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    118c:	7c 01       	movw	r14, r24
    118e:	62 e1       	ldi	r22, 0x12	; 18
    1190:	74 e0       	ldi	r23, 0x04	; 4
    1192:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    1196:	66 e0       	ldi	r22, 0x06	; 6
    1198:	c7 01       	movw	r24, r14
    119a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    119e:	60 e0       	ldi	r22, 0x00	; 0
    11a0:	c8 01       	movw	r24, r16
    11a2:	0e 94 74 14 	call	0x28e8	; 0x28e8 <_ZN8frt_task13transition_toEh>
							break;
    11a6:	3a c0       	rjmp	.+116    	; 0x121c <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11a8:	f8 01       	movw	r30, r16
    11aa:	a6 81       	ldd	r26, Z+6	; 0x06
    11ac:	b7 81       	ldd	r27, Z+7	; 0x07
    11ae:	ed 91       	ld	r30, X+
    11b0:	fc 91       	ld	r31, X
    11b2:	11 97       	sbiw	r26, 0x01	; 1
    11b4:	02 80       	ldd	r0, Z+2	; 0x02
    11b6:	f3 81       	ldd	r31, Z+3	; 0x03
    11b8:	e0 2d       	mov	r30, r0
    11ba:	68 2f       	mov	r22, r24
    11bc:	cd 01       	movw	r24, r26
    11be:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    11c0:	6a e0       	ldi	r22, 0x0A	; 10
    11c2:	d8 01       	movw	r26, r16
    11c4:	16 96       	adiw	r26, 0x06	; 6
    11c6:	8d 91       	ld	r24, X+
    11c8:	9c 91       	ld	r25, X
    11ca:	17 97       	sbiw	r26, 0x07	; 7
    11cc:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    11d0:	7c 01       	movw	r14, r24
    11d2:	6c e0       	ldi	r22, 0x0C	; 12
    11d4:	74 e0       	ldi	r23, 0x04	; 4
    11d6:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    11da:	66 e0       	ldi	r22, 0x06	; 6
    11dc:	c7 01       	movw	r24, r14
    11de:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
							break;
    11e2:	1c c0       	rjmp	.+56     	; 0x121c <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    11e4:	6a e0       	ldi	r22, 0x0A	; 10
    11e6:	f8 01       	movw	r30, r16
    11e8:	86 81       	ldd	r24, Z+6	; 0x06
    11ea:	97 81       	ldd	r25, Z+7	; 0x07
    11ec:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    11f0:	8c 01       	movw	r16, r24
    11f2:	6f ee       	ldi	r22, 0xEF	; 239
    11f4:	73 e0       	ldi	r23, 0x03	; 3
    11f6:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    11fa:	66 e0       	ldi	r22, 0x06	; 6
    11fc:	c8 01       	movw	r24, r16
    11fe:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1202:	93 e0       	ldi	r25, 0x03	; 3
    1204:	88 ed       	ldi	r24, 0xD8	; 216
    1206:	08 b6       	in	r0, 0x38	; 56
    1208:	18 be       	out	0x38, r1	; 56
    120a:	84 bf       	out	0x34, r24	; 52
    120c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1210:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1214:	81 fd       	sbrc	r24, 1
    1216:	fc cf       	rjmp	.-8      	; 0x1210 <_ZN9task_user3runEv+0x228>
    1218:	08 be       	out	0x38, r0	; 56
    121a:	ff cf       	rjmp	.-2      	; 0x121a <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    121c:	f8 01       	movw	r30, r16
    121e:	86 85       	ldd	r24, Z+14	; 0x0e
    1220:	97 85       	ldd	r25, Z+15	; 0x0f
    1222:	a0 89       	ldd	r26, Z+16	; 0x10
    1224:	b1 89       	ldd	r27, Z+17	; 0x11
    1226:	01 96       	adiw	r24, 0x01	; 1
    1228:	a1 1d       	adc	r26, r1
    122a:	b1 1d       	adc	r27, r1
    122c:	86 87       	std	Z+14, r24	; 0x0e
    122e:	97 87       	std	Z+15, r25	; 0x0f
    1230:	a0 8b       	std	Z+16, r26	; 0x10
    1232:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1234:	61 e0       	ldi	r22, 0x01	; 1
    1236:	70 e0       	ldi	r23, 0x00	; 0
    1238:	80 e0       	ldi	r24, 0x00	; 0
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	0e 94 48 12 	call	0x2490	; 0x2490 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1240:	f1 ce       	rjmp	.-542    	; 0x1024 <_ZN9task_user3runEv+0x3c>

00001242 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1242:	0f 93       	push	r16
    1244:	1f 93       	push	r17
    1246:	cf 93       	push	r28
    1248:	df 93       	push	r29
    124a:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    124c:	0e 94 37 10 	call	0x206e	; 0x206e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1250:	80 91 ca 20 	lds	r24, 0x20CA	; 0x8020ca <__data_end>
    1254:	81 11       	cpse	r24, r1
    1256:	1d c0       	rjmp	.+58     	; 0x1292 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1258:	af ec       	ldi	r26, 0xCF	; 207
    125a:	b0 e2       	ldi	r27, 0x20	; 32
    125c:	e3 ed       	ldi	r30, 0xD3	; 211
    125e:	f0 e2       	ldi	r31, 0x20	; 32
    1260:	ed 93       	st	X+, r30
    1262:	fc 93       	st	X, r31
    1264:	11 97       	sbiw	r26, 0x01	; 1
    1266:	12 96       	adiw	r26, 0x02	; 2
    1268:	1d 92       	st	X+, r1
    126a:	1c 92       	st	X, r1
    126c:	13 97       	sbiw	r26, 0x03	; 3
    126e:	ab ec       	ldi	r26, 0xCB	; 203
    1270:	b0 e2       	ldi	r27, 0x20	; 32
    1272:	8f ef       	ldi	r24, 0xFF	; 255
    1274:	9f e0       	ldi	r25, 0x0F	; 15
    1276:	12 96       	adiw	r26, 0x02	; 2
    1278:	8d 93       	st	X+, r24
    127a:	9c 93       	st	X, r25
    127c:	13 97       	sbiw	r26, 0x03	; 3
    127e:	1d 92       	st	X+, r1
    1280:	1c 92       	st	X, r1
    1282:	11 97       	sbiw	r26, 0x01	; 1
    1284:	82 83       	std	Z+2, r24	; 0x02
    1286:	93 83       	std	Z+3, r25	; 0x03
    1288:	a0 83       	st	Z, r26
    128a:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    128c:	81 e0       	ldi	r24, 0x01	; 1
    128e:	80 93 ca 20 	sts	0x20CA, r24	; 0x8020ca <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1292:	20 97       	sbiw	r28, 0x00	; 0
    1294:	09 f4       	brne	.+2      	; 0x1298 <pvPortMalloc+0x56>
    1296:	5f c0       	rjmp	.+190    	; 0x1356 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1298:	9e 01       	movw	r18, r28
    129a:	2b 5f       	subi	r18, 0xFB	; 251
    129c:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    129e:	24 96       	adiw	r28, 0x04	; 4
    12a0:	ce 3f       	cpi	r28, 0xFE	; 254
    12a2:	df 40       	sbci	r29, 0x0F	; 15
    12a4:	08 f0       	brcs	.+2      	; 0x12a8 <pvPortMalloc+0x66>
    12a6:	5a c0       	rjmp	.+180    	; 0x135c <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    12a8:	e0 91 cf 20 	lds	r30, 0x20CF	; 0x8020cf <xStart>
    12ac:	f0 91 d0 20 	lds	r31, 0x20D0	; 0x8020d0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    12b0:	af ec       	ldi	r26, 0xCF	; 207
    12b2:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12b4:	02 c0       	rjmp	.+4      	; 0x12ba <pvPortMalloc+0x78>
    12b6:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    12b8:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12ba:	82 81       	ldd	r24, Z+2	; 0x02
    12bc:	93 81       	ldd	r25, Z+3	; 0x03
    12be:	82 17       	cp	r24, r18
    12c0:	93 07       	cpc	r25, r19
    12c2:	20 f4       	brcc	.+8      	; 0x12cc <pvPortMalloc+0x8a>
    12c4:	80 81       	ld	r24, Z
    12c6:	91 81       	ldd	r25, Z+1	; 0x01
    12c8:	00 97       	sbiw	r24, 0x00	; 0
    12ca:	a9 f7       	brne	.-22     	; 0x12b6 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    12cc:	c0 e2       	ldi	r28, 0x20	; 32
    12ce:	eb 3c       	cpi	r30, 0xCB	; 203
    12d0:	fc 07       	cpc	r31, r28
    12d2:	09 f4       	brne	.+2      	; 0x12d6 <pvPortMalloc+0x94>
    12d4:	46 c0       	rjmp	.+140    	; 0x1362 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    12d6:	cd 91       	ld	r28, X+
    12d8:	dc 91       	ld	r29, X
    12da:	11 97       	sbiw	r26, 0x01	; 1
    12dc:	8e 01       	movw	r16, r28
    12de:	0b 5f       	subi	r16, 0xFB	; 251
    12e0:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    12e2:	80 81       	ld	r24, Z
    12e4:	91 81       	ldd	r25, Z+1	; 0x01
    12e6:	8d 93       	st	X+, r24
    12e8:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    12ea:	82 81       	ldd	r24, Z+2	; 0x02
    12ec:	93 81       	ldd	r25, Z+3	; 0x03
    12ee:	82 1b       	sub	r24, r18
    12f0:	93 0b       	sbc	r25, r19
    12f2:	8b 30       	cpi	r24, 0x0B	; 11
    12f4:	91 05       	cpc	r25, r1
    12f6:	10 f1       	brcs	.+68     	; 0x133c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    12f8:	bf 01       	movw	r22, r30
    12fa:	62 0f       	add	r22, r18
    12fc:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    12fe:	db 01       	movw	r26, r22
    1300:	12 96       	adiw	r26, 0x02	; 2
    1302:	8d 93       	st	X+, r24
    1304:	9c 93       	st	X, r25
    1306:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1308:	22 83       	std	Z+2, r18	; 0x02
    130a:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    130c:	12 96       	adiw	r26, 0x02	; 2
    130e:	4d 91       	ld	r20, X+
    1310:	5c 91       	ld	r21, X
    1312:	13 97       	sbiw	r26, 0x03	; 3
    1314:	8f ec       	ldi	r24, 0xCF	; 207
    1316:	90 e2       	ldi	r25, 0x20	; 32
    1318:	01 c0       	rjmp	.+2      	; 0x131c <pvPortMalloc+0xda>
    131a:	cd 01       	movw	r24, r26
    131c:	ec 01       	movw	r28, r24
    131e:	a8 81       	ld	r26, Y
    1320:	b9 81       	ldd	r27, Y+1	; 0x01
    1322:	12 96       	adiw	r26, 0x02	; 2
    1324:	2d 91       	ld	r18, X+
    1326:	3c 91       	ld	r19, X
    1328:	13 97       	sbiw	r26, 0x03	; 3
    132a:	24 17       	cp	r18, r20
    132c:	35 07       	cpc	r19, r21
    132e:	a8 f3       	brcs	.-22     	; 0x131a <pvPortMalloc+0xd8>
    1330:	eb 01       	movw	r28, r22
    1332:	a8 83       	st	Y, r26
    1334:	b9 83       	std	Y+1, r27	; 0x01
    1336:	dc 01       	movw	r26, r24
    1338:	6d 93       	st	X+, r22
    133a:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    133c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1340:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1344:	22 81       	ldd	r18, Z+2	; 0x02
    1346:	33 81       	ldd	r19, Z+3	; 0x03
    1348:	82 1b       	sub	r24, r18
    134a:	93 0b       	sbc	r25, r19
    134c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1350:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1354:	08 c0       	rjmp	.+16     	; 0x1366 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1356:	00 e0       	ldi	r16, 0x00	; 0
    1358:	10 e0       	ldi	r17, 0x00	; 0
    135a:	05 c0       	rjmp	.+10     	; 0x1366 <pvPortMalloc+0x124>
    135c:	00 e0       	ldi	r16, 0x00	; 0
    135e:	10 e0       	ldi	r17, 0x00	; 0
    1360:	02 c0       	rjmp	.+4      	; 0x1366 <pvPortMalloc+0x124>
    1362:	00 e0       	ldi	r16, 0x00	; 0
    1364:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1366:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    136a:	c8 01       	movw	r24, r16
    136c:	df 91       	pop	r29
    136e:	cf 91       	pop	r28
    1370:	1f 91       	pop	r17
    1372:	0f 91       	pop	r16
    1374:	08 95       	ret

00001376 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1376:	0f 93       	push	r16
    1378:	1f 93       	push	r17
    137a:	cf 93       	push	r28
    137c:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    137e:	00 97       	sbiw	r24, 0x00	; 0
    1380:	41 f1       	breq	.+80     	; 0x13d2 <vPortFree+0x5c>
    1382:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1384:	8c 01       	movw	r16, r24
    1386:	05 50       	subi	r16, 0x05	; 5
    1388:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    138a:	0e 94 37 10 	call	0x206e	; 0x206e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    138e:	f8 01       	movw	r30, r16
    1390:	42 81       	ldd	r20, Z+2	; 0x02
    1392:	53 81       	ldd	r21, Z+3	; 0x03
    1394:	af ec       	ldi	r26, 0xCF	; 207
    1396:	b0 e2       	ldi	r27, 0x20	; 32
    1398:	01 c0       	rjmp	.+2      	; 0x139c <vPortFree+0x26>
    139a:	df 01       	movw	r26, r30
    139c:	ed 91       	ld	r30, X+
    139e:	fc 91       	ld	r31, X
    13a0:	11 97       	sbiw	r26, 0x01	; 1
    13a2:	22 81       	ldd	r18, Z+2	; 0x02
    13a4:	33 81       	ldd	r19, Z+3	; 0x03
    13a6:	24 17       	cp	r18, r20
    13a8:	35 07       	cpc	r19, r21
    13aa:	b8 f3       	brcs	.-18     	; 0x139a <vPortFree+0x24>
    13ac:	25 97       	sbiw	r28, 0x05	; 5
    13ae:	e8 83       	st	Y, r30
    13b0:	f9 83       	std	Y+1, r31	; 0x01
    13b2:	0d 93       	st	X+, r16
    13b4:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    13b6:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    13ba:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    13be:	8a 81       	ldd	r24, Y+2	; 0x02
    13c0:	9b 81       	ldd	r25, Y+3	; 0x03
    13c2:	82 0f       	add	r24, r18
    13c4:	93 1f       	adc	r25, r19
    13c6:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    13ca:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    13ce:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
	}
}
    13d2:	df 91       	pop	r29
    13d4:	cf 91       	pop	r28
    13d6:	1f 91       	pop	r17
    13d8:	0f 91       	pop	r16
    13da:	08 95       	ret

000013dc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    13dc:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    13e0:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    13e4:	08 95       	ret

000013e6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    13e6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    13e8:	03 96       	adiw	r24, 0x03	; 3
    13ea:	81 83       	std	Z+1, r24	; 0x01
    13ec:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    13ee:	4f ef       	ldi	r20, 0xFF	; 255
    13f0:	5f ef       	ldi	r21, 0xFF	; 255
    13f2:	ba 01       	movw	r22, r20
    13f4:	43 83       	std	Z+3, r20	; 0x03
    13f6:	54 83       	std	Z+4, r21	; 0x04
    13f8:	65 83       	std	Z+5, r22	; 0x05
    13fa:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    13fc:	87 83       	std	Z+7, r24	; 0x07
    13fe:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1400:	81 87       	std	Z+9, r24	; 0x09
    1402:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1404:	10 82       	st	Z, r1
    1406:	08 95       	ret

00001408 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1408:	fc 01       	movw	r30, r24
    140a:	12 86       	std	Z+10, r1	; 0x0a
    140c:	13 86       	std	Z+11, r1	; 0x0b
    140e:	08 95       	ret

00001410 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1410:	cf 93       	push	r28
    1412:	df 93       	push	r29
    1414:	fc 01       	movw	r30, r24
    1416:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1418:	21 81       	ldd	r18, Z+1	; 0x01
    141a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    141c:	e9 01       	movw	r28, r18
    141e:	8c 81       	ldd	r24, Y+4	; 0x04
    1420:	9d 81       	ldd	r25, Y+5	; 0x05
    1422:	14 96       	adiw	r26, 0x04	; 4
    1424:	8d 93       	st	X+, r24
    1426:	9c 93       	st	X, r25
    1428:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    142a:	81 81       	ldd	r24, Z+1	; 0x01
    142c:	92 81       	ldd	r25, Z+2	; 0x02
    142e:	16 96       	adiw	r26, 0x06	; 6
    1430:	8d 93       	st	X+, r24
    1432:	9c 93       	st	X, r25
    1434:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1436:	8c 81       	ldd	r24, Y+4	; 0x04
    1438:	9d 81       	ldd	r25, Y+5	; 0x05
    143a:	ec 01       	movw	r28, r24
    143c:	6e 83       	std	Y+6, r22	; 0x06
    143e:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1440:	e9 01       	movw	r28, r18
    1442:	6c 83       	std	Y+4, r22	; 0x04
    1444:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1446:	61 83       	std	Z+1, r22	; 0x01
    1448:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    144a:	1a 96       	adiw	r26, 0x0a	; 10
    144c:	ed 93       	st	X+, r30
    144e:	fc 93       	st	X, r31
    1450:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1452:	80 81       	ld	r24, Z
    1454:	8f 5f       	subi	r24, 0xFF	; 255
    1456:	80 83       	st	Z, r24
}
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	08 95       	ret

0000145e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    145e:	0f 93       	push	r16
    1460:	1f 93       	push	r17
    1462:	cf 93       	push	r28
    1464:	df 93       	push	r29
    1466:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1468:	08 81       	ld	r16, Y
    146a:	19 81       	ldd	r17, Y+1	; 0x01
    146c:	2a 81       	ldd	r18, Y+2	; 0x02
    146e:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1470:	0f 3f       	cpi	r16, 0xFF	; 255
    1472:	4f ef       	ldi	r20, 0xFF	; 255
    1474:	14 07       	cpc	r17, r20
    1476:	24 07       	cpc	r18, r20
    1478:	34 07       	cpc	r19, r20
    147a:	31 f4       	brne	.+12     	; 0x1488 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    147c:	dc 01       	movw	r26, r24
    147e:	19 96       	adiw	r26, 0x09	; 9
    1480:	ed 91       	ld	r30, X+
    1482:	fc 91       	ld	r31, X
    1484:	1a 97       	sbiw	r26, 0x0a	; 10
    1486:	1f c0       	rjmp	.+62     	; 0x14c6 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1488:	fc 01       	movw	r30, r24
    148a:	33 96       	adiw	r30, 0x03	; 3
    148c:	dc 01       	movw	r26, r24
    148e:	17 96       	adiw	r26, 0x07	; 7
    1490:	4d 91       	ld	r20, X+
    1492:	5c 91       	ld	r21, X
    1494:	18 97       	sbiw	r26, 0x08	; 8
    1496:	da 01       	movw	r26, r20
    1498:	4d 91       	ld	r20, X+
    149a:	5d 91       	ld	r21, X+
    149c:	6d 91       	ld	r22, X+
    149e:	7c 91       	ld	r23, X
    14a0:	04 17       	cp	r16, r20
    14a2:	15 07       	cpc	r17, r21
    14a4:	26 07       	cpc	r18, r22
    14a6:	37 07       	cpc	r19, r23
    14a8:	70 f0       	brcs	.+28     	; 0x14c6 <vListInsert+0x68>
    14aa:	04 80       	ldd	r0, Z+4	; 0x04
    14ac:	f5 81       	ldd	r31, Z+5	; 0x05
    14ae:	e0 2d       	mov	r30, r0
    14b0:	a4 81       	ldd	r26, Z+4	; 0x04
    14b2:	b5 81       	ldd	r27, Z+5	; 0x05
    14b4:	4d 91       	ld	r20, X+
    14b6:	5d 91       	ld	r21, X+
    14b8:	6d 91       	ld	r22, X+
    14ba:	7c 91       	ld	r23, X
    14bc:	04 17       	cp	r16, r20
    14be:	15 07       	cpc	r17, r21
    14c0:	26 07       	cpc	r18, r22
    14c2:	37 07       	cpc	r19, r23
    14c4:	90 f7       	brcc	.-28     	; 0x14aa <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    14c6:	a4 81       	ldd	r26, Z+4	; 0x04
    14c8:	b5 81       	ldd	r27, Z+5	; 0x05
    14ca:	ac 83       	std	Y+4, r26	; 0x04
    14cc:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    14ce:	16 96       	adiw	r26, 0x06	; 6
    14d0:	cd 93       	st	X+, r28
    14d2:	dc 93       	st	X, r29
    14d4:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    14d6:	ee 83       	std	Y+6, r30	; 0x06
    14d8:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    14da:	c4 83       	std	Z+4, r28	; 0x04
    14dc:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14de:	8a 87       	std	Y+10, r24	; 0x0a
    14e0:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    14e2:	fc 01       	movw	r30, r24
    14e4:	20 81       	ld	r18, Z
    14e6:	2f 5f       	subi	r18, 0xFF	; 255
    14e8:	20 83       	st	Z, r18
}
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	1f 91       	pop	r17
    14f0:	0f 91       	pop	r16
    14f2:	08 95       	ret

000014f4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    14f4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    14f6:	a4 81       	ldd	r26, Z+4	; 0x04
    14f8:	b5 81       	ldd	r27, Z+5	; 0x05
    14fa:	86 81       	ldd	r24, Z+6	; 0x06
    14fc:	97 81       	ldd	r25, Z+7	; 0x07
    14fe:	16 96       	adiw	r26, 0x06	; 6
    1500:	8d 93       	st	X+, r24
    1502:	9c 93       	st	X, r25
    1504:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1506:	a6 81       	ldd	r26, Z+6	; 0x06
    1508:	b7 81       	ldd	r27, Z+7	; 0x07
    150a:	84 81       	ldd	r24, Z+4	; 0x04
    150c:	95 81       	ldd	r25, Z+5	; 0x05
    150e:	14 96       	adiw	r26, 0x04	; 4
    1510:	8d 93       	st	X+, r24
    1512:	9c 93       	st	X, r25
    1514:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1516:	a2 85       	ldd	r26, Z+10	; 0x0a
    1518:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    151a:	11 96       	adiw	r26, 0x01	; 1
    151c:	8d 91       	ld	r24, X+
    151e:	9c 91       	ld	r25, X
    1520:	12 97       	sbiw	r26, 0x02	; 2
    1522:	e8 17       	cp	r30, r24
    1524:	f9 07       	cpc	r31, r25
    1526:	31 f4       	brne	.+12     	; 0x1534 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1528:	86 81       	ldd	r24, Z+6	; 0x06
    152a:	97 81       	ldd	r25, Z+7	; 0x07
    152c:	11 96       	adiw	r26, 0x01	; 1
    152e:	8d 93       	st	X+, r24
    1530:	9c 93       	st	X, r25
    1532:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1534:	12 86       	std	Z+10, r1	; 0x0a
    1536:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1538:	8c 91       	ld	r24, X
    153a:	81 50       	subi	r24, 0x01	; 1
    153c:	8c 93       	st	X, r24
    153e:	08 95       	ret

00001540 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1540:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <portStackTopForTask>
    1544:	90 93 77 31 	sts	0x3177, r25	; 0x803177 <portStackTopForTask+0x1>
    1548:	31 e1       	ldi	r19, 0x11	; 17
    154a:	fc 01       	movw	r30, r24
    154c:	30 83       	st	Z, r19
    154e:	31 97       	sbiw	r30, 0x01	; 1
    1550:	22 e2       	ldi	r18, 0x22	; 34
    1552:	20 83       	st	Z, r18
    1554:	31 97       	sbiw	r30, 0x01	; 1
    1556:	a3 e3       	ldi	r26, 0x33	; 51
    1558:	a0 83       	st	Z, r26
    155a:	31 97       	sbiw	r30, 0x01	; 1
    155c:	60 83       	st	Z, r22
    155e:	31 97       	sbiw	r30, 0x01	; 1
    1560:	70 83       	st	Z, r23
    1562:	31 97       	sbiw	r30, 0x01	; 1
    1564:	10 82       	st	Z, r1
    1566:	31 97       	sbiw	r30, 0x01	; 1
    1568:	10 82       	st	Z, r1
    156a:	31 97       	sbiw	r30, 0x01	; 1
    156c:	60 e8       	ldi	r22, 0x80	; 128
    156e:	60 83       	st	Z, r22
    1570:	31 97       	sbiw	r30, 0x01	; 1
    1572:	10 82       	st	Z, r1
    1574:	31 97       	sbiw	r30, 0x01	; 1
    1576:	10 82       	st	Z, r1
    1578:	31 97       	sbiw	r30, 0x01	; 1
    157a:	10 82       	st	Z, r1
    157c:	31 97       	sbiw	r30, 0x01	; 1
    157e:	62 e0       	ldi	r22, 0x02	; 2
    1580:	60 83       	st	Z, r22
    1582:	31 97       	sbiw	r30, 0x01	; 1
    1584:	63 e0       	ldi	r22, 0x03	; 3
    1586:	60 83       	st	Z, r22
    1588:	31 97       	sbiw	r30, 0x01	; 1
    158a:	64 e0       	ldi	r22, 0x04	; 4
    158c:	60 83       	st	Z, r22
    158e:	31 97       	sbiw	r30, 0x01	; 1
    1590:	65 e0       	ldi	r22, 0x05	; 5
    1592:	60 83       	st	Z, r22
    1594:	31 97       	sbiw	r30, 0x01	; 1
    1596:	66 e0       	ldi	r22, 0x06	; 6
    1598:	60 83       	st	Z, r22
    159a:	31 97       	sbiw	r30, 0x01	; 1
    159c:	67 e0       	ldi	r22, 0x07	; 7
    159e:	60 83       	st	Z, r22
    15a0:	31 97       	sbiw	r30, 0x01	; 1
    15a2:	68 e0       	ldi	r22, 0x08	; 8
    15a4:	60 83       	st	Z, r22
    15a6:	31 97       	sbiw	r30, 0x01	; 1
    15a8:	69 e0       	ldi	r22, 0x09	; 9
    15aa:	60 83       	st	Z, r22
    15ac:	31 97       	sbiw	r30, 0x01	; 1
    15ae:	60 e1       	ldi	r22, 0x10	; 16
    15b0:	60 83       	st	Z, r22
    15b2:	31 97       	sbiw	r30, 0x01	; 1
    15b4:	30 83       	st	Z, r19
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	32 e1       	ldi	r19, 0x12	; 18
    15ba:	30 83       	st	Z, r19
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	33 e1       	ldi	r19, 0x13	; 19
    15c0:	30 83       	st	Z, r19
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	34 e1       	ldi	r19, 0x14	; 20
    15c6:	30 83       	st	Z, r19
    15c8:	31 97       	sbiw	r30, 0x01	; 1
    15ca:	35 e1       	ldi	r19, 0x15	; 21
    15cc:	30 83       	st	Z, r19
    15ce:	31 97       	sbiw	r30, 0x01	; 1
    15d0:	36 e1       	ldi	r19, 0x16	; 22
    15d2:	30 83       	st	Z, r19
    15d4:	31 97       	sbiw	r30, 0x01	; 1
    15d6:	37 e1       	ldi	r19, 0x17	; 23
    15d8:	30 83       	st	Z, r19
    15da:	31 97       	sbiw	r30, 0x01	; 1
    15dc:	38 e1       	ldi	r19, 0x18	; 24
    15de:	30 83       	st	Z, r19
    15e0:	31 97       	sbiw	r30, 0x01	; 1
    15e2:	39 e1       	ldi	r19, 0x19	; 25
    15e4:	30 83       	st	Z, r19
    15e6:	31 97       	sbiw	r30, 0x01	; 1
    15e8:	30 e2       	ldi	r19, 0x20	; 32
    15ea:	30 83       	st	Z, r19
    15ec:	31 97       	sbiw	r30, 0x01	; 1
    15ee:	31 e2       	ldi	r19, 0x21	; 33
    15f0:	30 83       	st	Z, r19
    15f2:	31 97       	sbiw	r30, 0x01	; 1
    15f4:	20 83       	st	Z, r18
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	23 e2       	ldi	r18, 0x23	; 35
    15fa:	20 83       	st	Z, r18
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	40 83       	st	Z, r20
    1600:	31 97       	sbiw	r30, 0x01	; 1
    1602:	50 83       	st	Z, r21
    1604:	31 97       	sbiw	r30, 0x01	; 1
    1606:	26 e2       	ldi	r18, 0x26	; 38
    1608:	20 83       	st	Z, r18
    160a:	31 97       	sbiw	r30, 0x01	; 1
    160c:	27 e2       	ldi	r18, 0x27	; 39
    160e:	20 83       	st	Z, r18
    1610:	31 97       	sbiw	r30, 0x01	; 1
    1612:	28 e2       	ldi	r18, 0x28	; 40
    1614:	20 83       	st	Z, r18
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	29 e2       	ldi	r18, 0x29	; 41
    161a:	20 83       	st	Z, r18
    161c:	31 97       	sbiw	r30, 0x01	; 1
    161e:	20 e3       	ldi	r18, 0x30	; 48
    1620:	20 83       	st	Z, r18
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	21 e3       	ldi	r18, 0x31	; 49
    1626:	20 83       	st	Z, r18
    1628:	89 97       	sbiw	r24, 0x29	; 41
    162a:	08 95       	ret

0000162c <xPortStartScheduler>:
    162c:	8c e7       	ldi	r24, 0x7C	; 124
    162e:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
    1632:	8f ef       	ldi	r24, 0xFF	; 255
    1634:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
    1638:	81 e0       	ldi	r24, 0x01	; 1
    163a:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    163e:	81 e1       	ldi	r24, 0x11	; 17
    1640:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    1644:	83 e0       	ldi	r24, 0x03	; 3
    1646:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
    164a:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    164e:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1652:	cd 91       	ld	r28, X+
    1654:	cd bf       	out	0x3d, r28	; 61
    1656:	dd 91       	ld	r29, X+
    1658:	de bf       	out	0x3e, r29	; 62
    165a:	ff 91       	pop	r31
    165c:	ef 91       	pop	r30
    165e:	df 91       	pop	r29
    1660:	cf 91       	pop	r28
    1662:	bf 91       	pop	r27
    1664:	af 91       	pop	r26
    1666:	9f 91       	pop	r25
    1668:	8f 91       	pop	r24
    166a:	7f 91       	pop	r23
    166c:	6f 91       	pop	r22
    166e:	5f 91       	pop	r21
    1670:	4f 91       	pop	r20
    1672:	3f 91       	pop	r19
    1674:	2f 91       	pop	r18
    1676:	1f 91       	pop	r17
    1678:	0f 91       	pop	r16
    167a:	ff 90       	pop	r15
    167c:	ef 90       	pop	r14
    167e:	df 90       	pop	r13
    1680:	cf 90       	pop	r12
    1682:	bf 90       	pop	r11
    1684:	af 90       	pop	r10
    1686:	9f 90       	pop	r9
    1688:	8f 90       	pop	r8
    168a:	7f 90       	pop	r7
    168c:	6f 90       	pop	r6
    168e:	5f 90       	pop	r5
    1690:	4f 90       	pop	r4
    1692:	3f 90       	pop	r3
    1694:	2f 90       	pop	r2
    1696:	1f 90       	pop	r1
    1698:	0f 90       	pop	r0
    169a:	0c be       	out	0x3c, r0	; 60
    169c:	0f 90       	pop	r0
    169e:	0b be       	out	0x3b, r0	; 59
    16a0:	0f 90       	pop	r0
    16a2:	0f be       	out	0x3f, r0	; 63
    16a4:	0f 90       	pop	r0
    16a6:	08 95       	ret
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	08 95       	ret

000016ac <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16ac:	0f 92       	push	r0
    16ae:	0f b6       	in	r0, 0x3f	; 63
    16b0:	f8 94       	cli
    16b2:	0f 92       	push	r0
    16b4:	0b b6       	in	r0, 0x3b	; 59
    16b6:	0f 92       	push	r0
    16b8:	0c b6       	in	r0, 0x3c	; 60
    16ba:	0f 92       	push	r0
    16bc:	1f 92       	push	r1
    16be:	11 24       	eor	r1, r1
    16c0:	2f 92       	push	r2
    16c2:	3f 92       	push	r3
    16c4:	4f 92       	push	r4
    16c6:	5f 92       	push	r5
    16c8:	6f 92       	push	r6
    16ca:	7f 92       	push	r7
    16cc:	8f 92       	push	r8
    16ce:	9f 92       	push	r9
    16d0:	af 92       	push	r10
    16d2:	bf 92       	push	r11
    16d4:	cf 92       	push	r12
    16d6:	df 92       	push	r13
    16d8:	ef 92       	push	r14
    16da:	ff 92       	push	r15
    16dc:	0f 93       	push	r16
    16de:	1f 93       	push	r17
    16e0:	2f 93       	push	r18
    16e2:	3f 93       	push	r19
    16e4:	4f 93       	push	r20
    16e6:	5f 93       	push	r21
    16e8:	6f 93       	push	r22
    16ea:	7f 93       	push	r23
    16ec:	8f 93       	push	r24
    16ee:	9f 93       	push	r25
    16f0:	af 93       	push	r26
    16f2:	bf 93       	push	r27
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	ef 93       	push	r30
    16fa:	ff 93       	push	r31
    16fc:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    1700:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1704:	0d b6       	in	r0, 0x3d	; 61
    1706:	0d 92       	st	X+, r0
    1708:	0e b6       	in	r0, 0x3e	; 62
    170a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    170c:	0e 94 76 12 	call	0x24ec	; 0x24ec <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1710:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    1714:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1718:	cd 91       	ld	r28, X+
    171a:	cd bf       	out	0x3d, r28	; 61
    171c:	dd 91       	ld	r29, X+
    171e:	de bf       	out	0x3e, r29	; 62
    1720:	ff 91       	pop	r31
    1722:	ef 91       	pop	r30
    1724:	df 91       	pop	r29
    1726:	cf 91       	pop	r28
    1728:	bf 91       	pop	r27
    172a:	af 91       	pop	r26
    172c:	9f 91       	pop	r25
    172e:	8f 91       	pop	r24
    1730:	7f 91       	pop	r23
    1732:	6f 91       	pop	r22
    1734:	5f 91       	pop	r21
    1736:	4f 91       	pop	r20
    1738:	3f 91       	pop	r19
    173a:	2f 91       	pop	r18
    173c:	1f 91       	pop	r17
    173e:	0f 91       	pop	r16
    1740:	ff 90       	pop	r15
    1742:	ef 90       	pop	r14
    1744:	df 90       	pop	r13
    1746:	cf 90       	pop	r12
    1748:	bf 90       	pop	r11
    174a:	af 90       	pop	r10
    174c:	9f 90       	pop	r9
    174e:	8f 90       	pop	r8
    1750:	7f 90       	pop	r7
    1752:	6f 90       	pop	r6
    1754:	5f 90       	pop	r5
    1756:	4f 90       	pop	r4
    1758:	3f 90       	pop	r3
    175a:	2f 90       	pop	r2
    175c:	1f 90       	pop	r1
    175e:	0f 90       	pop	r0
    1760:	0c be       	out	0x3c, r0	; 60
    1762:	0f 90       	pop	r0
    1764:	0b be       	out	0x3b, r0	; 59
    1766:	0f 90       	pop	r0
    1768:	0f be       	out	0x3f, r0	; 63
    176a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    176c:	08 95       	ret

0000176e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    176e:	0f 92       	push	r0
    1770:	0f b6       	in	r0, 0x3f	; 63
    1772:	f8 94       	cli
    1774:	0f 92       	push	r0
    1776:	0b b6       	in	r0, 0x3b	; 59
    1778:	0f 92       	push	r0
    177a:	0c b6       	in	r0, 0x3c	; 60
    177c:	0f 92       	push	r0
    177e:	1f 92       	push	r1
    1780:	11 24       	eor	r1, r1
    1782:	2f 92       	push	r2
    1784:	3f 92       	push	r3
    1786:	4f 92       	push	r4
    1788:	5f 92       	push	r5
    178a:	6f 92       	push	r6
    178c:	7f 92       	push	r7
    178e:	8f 92       	push	r8
    1790:	9f 92       	push	r9
    1792:	af 92       	push	r10
    1794:	bf 92       	push	r11
    1796:	cf 92       	push	r12
    1798:	df 92       	push	r13
    179a:	ef 92       	push	r14
    179c:	ff 92       	push	r15
    179e:	0f 93       	push	r16
    17a0:	1f 93       	push	r17
    17a2:	2f 93       	push	r18
    17a4:	3f 93       	push	r19
    17a6:	4f 93       	push	r20
    17a8:	5f 93       	push	r21
    17aa:	6f 93       	push	r22
    17ac:	7f 93       	push	r23
    17ae:	8f 93       	push	r24
    17b0:	9f 93       	push	r25
    17b2:	af 93       	push	r26
    17b4:	bf 93       	push	r27
    17b6:	cf 93       	push	r28
    17b8:	df 93       	push	r29
    17ba:	ef 93       	push	r30
    17bc:	ff 93       	push	r31
    17be:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    17c2:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    17c6:	0d b6       	in	r0, 0x3d	; 61
    17c8:	0d 92       	st	X+, r0
    17ca:	0e b6       	in	r0, 0x3e	; 62
    17cc:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    17ce:	0e 94 58 10 	call	0x20b0	; 0x20b0 <vTaskIncrementTick>
	vTaskSwitchContext();
    17d2:	0e 94 76 12 	call	0x24ec	; 0x24ec <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17d6:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    17da:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    17de:	cd 91       	ld	r28, X+
    17e0:	cd bf       	out	0x3d, r28	; 61
    17e2:	dd 91       	ld	r29, X+
    17e4:	de bf       	out	0x3e, r29	; 62
    17e6:	ff 91       	pop	r31
    17e8:	ef 91       	pop	r30
    17ea:	df 91       	pop	r29
    17ec:	cf 91       	pop	r28
    17ee:	bf 91       	pop	r27
    17f0:	af 91       	pop	r26
    17f2:	9f 91       	pop	r25
    17f4:	8f 91       	pop	r24
    17f6:	7f 91       	pop	r23
    17f8:	6f 91       	pop	r22
    17fa:	5f 91       	pop	r21
    17fc:	4f 91       	pop	r20
    17fe:	3f 91       	pop	r19
    1800:	2f 91       	pop	r18
    1802:	1f 91       	pop	r17
    1804:	0f 91       	pop	r16
    1806:	ff 90       	pop	r15
    1808:	ef 90       	pop	r14
    180a:	df 90       	pop	r13
    180c:	cf 90       	pop	r12
    180e:	bf 90       	pop	r11
    1810:	af 90       	pop	r10
    1812:	9f 90       	pop	r9
    1814:	8f 90       	pop	r8
    1816:	7f 90       	pop	r7
    1818:	6f 90       	pop	r6
    181a:	5f 90       	pop	r5
    181c:	4f 90       	pop	r4
    181e:	3f 90       	pop	r3
    1820:	2f 90       	pop	r2
    1822:	1f 90       	pop	r1
    1824:	0f 90       	pop	r0
    1826:	0c be       	out	0x3c, r0	; 60
    1828:	0f 90       	pop	r0
    182a:	0b be       	out	0x3b, r0	; 59
    182c:	0f 90       	pop	r0
    182e:	0f be       	out	0x3f, r0	; 63
    1830:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1832:	08 95       	ret

00001834 <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1834:	0e 94 b7 0b 	call	0x176e	; 0x176e <vPortYieldFromTick>
		asm volatile ( "reti" );
    1838:	18 95       	reti

0000183a <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    183a:	cf 93       	push	r28
    183c:	df 93       	push	r29
    183e:	ec 01       	movw	r28, r24
    1840:	88 a1       	ldd	r24, Y+32	; 0x20
    1842:	81 11       	cpse	r24, r1
    1844:	0b c0       	rjmp	.+22     	; 0x185c <prvCopyDataToQueue+0x22>
    1846:	88 81       	ld	r24, Y
    1848:	99 81       	ldd	r25, Y+1	; 0x01
    184a:	89 2b       	or	r24, r25
    184c:	e1 f5       	brne	.+120    	; 0x18c6 <prvCopyDataToQueue+0x8c>
    184e:	8a 81       	ldd	r24, Y+2	; 0x02
    1850:	9b 81       	ldd	r25, Y+3	; 0x03
    1852:	0e 94 31 14 	call	0x2862	; 0x2862 <vTaskPriorityDisinherit>
    1856:	1a 82       	std	Y+2, r1	; 0x02
    1858:	1b 82       	std	Y+3, r1	; 0x03
    185a:	35 c0       	rjmp	.+106    	; 0x18c6 <prvCopyDataToQueue+0x8c>
    185c:	41 11       	cpse	r20, r1
    185e:	17 c0       	rjmp	.+46     	; 0x188e <prvCopyDataToQueue+0x54>
    1860:	48 2f       	mov	r20, r24
    1862:	50 e0       	ldi	r21, 0x00	; 0
    1864:	8c 81       	ldd	r24, Y+4	; 0x04
    1866:	9d 81       	ldd	r25, Y+5	; 0x05
    1868:	0e 94 5e 22 	call	0x44bc	; 0x44bc <memcpy>
    186c:	28 a1       	ldd	r18, Y+32	; 0x20
    186e:	8c 81       	ldd	r24, Y+4	; 0x04
    1870:	9d 81       	ldd	r25, Y+5	; 0x05
    1872:	82 0f       	add	r24, r18
    1874:	91 1d       	adc	r25, r1
    1876:	8c 83       	std	Y+4, r24	; 0x04
    1878:	9d 83       	std	Y+5, r25	; 0x05
    187a:	2a 81       	ldd	r18, Y+2	; 0x02
    187c:	3b 81       	ldd	r19, Y+3	; 0x03
    187e:	82 17       	cp	r24, r18
    1880:	93 07       	cpc	r25, r19
    1882:	08 f1       	brcs	.+66     	; 0x18c6 <prvCopyDataToQueue+0x8c>
    1884:	88 81       	ld	r24, Y
    1886:	99 81       	ldd	r25, Y+1	; 0x01
    1888:	8c 83       	std	Y+4, r24	; 0x04
    188a:	9d 83       	std	Y+5, r25	; 0x05
    188c:	1c c0       	rjmp	.+56     	; 0x18c6 <prvCopyDataToQueue+0x8c>
    188e:	48 2f       	mov	r20, r24
    1890:	50 e0       	ldi	r21, 0x00	; 0
    1892:	8e 81       	ldd	r24, Y+6	; 0x06
    1894:	9f 81       	ldd	r25, Y+7	; 0x07
    1896:	0e 94 5e 22 	call	0x44bc	; 0x44bc <memcpy>
    189a:	88 a1       	ldd	r24, Y+32	; 0x20
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	91 95       	neg	r25
    18a0:	81 95       	neg	r24
    18a2:	91 09       	sbc	r25, r1
    18a4:	2e 81       	ldd	r18, Y+6	; 0x06
    18a6:	3f 81       	ldd	r19, Y+7	; 0x07
    18a8:	28 0f       	add	r18, r24
    18aa:	39 1f       	adc	r19, r25
    18ac:	2e 83       	std	Y+6, r18	; 0x06
    18ae:	3f 83       	std	Y+7, r19	; 0x07
    18b0:	48 81       	ld	r20, Y
    18b2:	59 81       	ldd	r21, Y+1	; 0x01
    18b4:	24 17       	cp	r18, r20
    18b6:	35 07       	cpc	r19, r21
    18b8:	30 f4       	brcc	.+12     	; 0x18c6 <prvCopyDataToQueue+0x8c>
    18ba:	2a 81       	ldd	r18, Y+2	; 0x02
    18bc:	3b 81       	ldd	r19, Y+3	; 0x03
    18be:	82 0f       	add	r24, r18
    18c0:	93 1f       	adc	r25, r19
    18c2:	8e 83       	std	Y+6, r24	; 0x06
    18c4:	9f 83       	std	Y+7, r25	; 0x07
    18c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18c8:	8f 5f       	subi	r24, 0xFF	; 255
    18ca:	8e 8f       	std	Y+30, r24	; 0x1e
    18cc:	df 91       	pop	r29
    18ce:	cf 91       	pop	r28
    18d0:	08 95       	ret

000018d2 <prvCopyDataFromQueue>:
    18d2:	fc 01       	movw	r30, r24
    18d4:	80 81       	ld	r24, Z
    18d6:	91 81       	ldd	r25, Z+1	; 0x01
    18d8:	00 97       	sbiw	r24, 0x00	; 0
    18da:	a1 f0       	breq	.+40     	; 0x1904 <prvCopyDataFromQueue+0x32>
    18dc:	40 a1       	ldd	r20, Z+32	; 0x20
    18de:	50 e0       	ldi	r21, 0x00	; 0
    18e0:	26 81       	ldd	r18, Z+6	; 0x06
    18e2:	37 81       	ldd	r19, Z+7	; 0x07
    18e4:	24 0f       	add	r18, r20
    18e6:	35 1f       	adc	r19, r21
    18e8:	26 83       	std	Z+6, r18	; 0x06
    18ea:	37 83       	std	Z+7, r19	; 0x07
    18ec:	a2 81       	ldd	r26, Z+2	; 0x02
    18ee:	b3 81       	ldd	r27, Z+3	; 0x03
    18f0:	2a 17       	cp	r18, r26
    18f2:	3b 07       	cpc	r19, r27
    18f4:	10 f0       	brcs	.+4      	; 0x18fa <prvCopyDataFromQueue+0x28>
    18f6:	86 83       	std	Z+6, r24	; 0x06
    18f8:	97 83       	std	Z+7, r25	; 0x07
    18fa:	cb 01       	movw	r24, r22
    18fc:	66 81       	ldd	r22, Z+6	; 0x06
    18fe:	77 81       	ldd	r23, Z+7	; 0x07
    1900:	0e 94 5e 22 	call	0x44bc	; 0x44bc <memcpy>
    1904:	08 95       	ret

00001906 <prvUnlockQueue>:
    1906:	0f 93       	push	r16
    1908:	1f 93       	push	r17
    190a:	cf 93       	push	r28
    190c:	df 93       	push	r29
    190e:	ec 01       	movw	r28, r24
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	0f 92       	push	r0
    1916:	8a a1       	ldd	r24, Y+34	; 0x22
    1918:	18 16       	cp	r1, r24
    191a:	b4 f4       	brge	.+44     	; 0x1948 <prvUnlockQueue+0x42>
    191c:	8b 89       	ldd	r24, Y+19	; 0x13
    191e:	81 11       	cpse	r24, r1
    1920:	05 c0       	rjmp	.+10     	; 0x192c <prvUnlockQueue+0x26>
    1922:	12 c0       	rjmp	.+36     	; 0x1948 <prvUnlockQueue+0x42>
    1924:	8b 89       	ldd	r24, Y+19	; 0x13
    1926:	81 11       	cpse	r24, r1
    1928:	04 c0       	rjmp	.+8      	; 0x1932 <prvUnlockQueue+0x2c>
    192a:	0e c0       	rjmp	.+28     	; 0x1948 <prvUnlockQueue+0x42>
    192c:	8e 01       	movw	r16, r28
    192e:	0d 5e       	subi	r16, 0xED	; 237
    1930:	1f 4f       	sbci	r17, 0xFF	; 255
    1932:	c8 01       	movw	r24, r16
    1934:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskRemoveFromEventList>
    1938:	81 11       	cpse	r24, r1
    193a:	0e 94 ba 13 	call	0x2774	; 0x2774 <vTaskMissedYield>
    193e:	8a a1       	ldd	r24, Y+34	; 0x22
    1940:	81 50       	subi	r24, 0x01	; 1
    1942:	8a a3       	std	Y+34, r24	; 0x22
    1944:	18 16       	cp	r1, r24
    1946:	74 f3       	brlt	.-36     	; 0x1924 <prvUnlockQueue+0x1e>
    1948:	8f ef       	ldi	r24, 0xFF	; 255
    194a:	8a a3       	std	Y+34, r24	; 0x22
    194c:	0f 90       	pop	r0
    194e:	0f be       	out	0x3f, r0	; 63
    1950:	0f b6       	in	r0, 0x3f	; 63
    1952:	f8 94       	cli
    1954:	0f 92       	push	r0
    1956:	89 a1       	ldd	r24, Y+33	; 0x21
    1958:	18 16       	cp	r1, r24
    195a:	b4 f4       	brge	.+44     	; 0x1988 <prvUnlockQueue+0x82>
    195c:	88 85       	ldd	r24, Y+8	; 0x08
    195e:	81 11       	cpse	r24, r1
    1960:	05 c0       	rjmp	.+10     	; 0x196c <prvUnlockQueue+0x66>
    1962:	12 c0       	rjmp	.+36     	; 0x1988 <prvUnlockQueue+0x82>
    1964:	88 85       	ldd	r24, Y+8	; 0x08
    1966:	81 11       	cpse	r24, r1
    1968:	04 c0       	rjmp	.+8      	; 0x1972 <prvUnlockQueue+0x6c>
    196a:	0e c0       	rjmp	.+28     	; 0x1988 <prvUnlockQueue+0x82>
    196c:	8e 01       	movw	r16, r28
    196e:	08 5f       	subi	r16, 0xF8	; 248
    1970:	1f 4f       	sbci	r17, 0xFF	; 255
    1972:	c8 01       	movw	r24, r16
    1974:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskRemoveFromEventList>
    1978:	81 11       	cpse	r24, r1
    197a:	0e 94 ba 13 	call	0x2774	; 0x2774 <vTaskMissedYield>
    197e:	89 a1       	ldd	r24, Y+33	; 0x21
    1980:	81 50       	subi	r24, 0x01	; 1
    1982:	89 a3       	std	Y+33, r24	; 0x21
    1984:	18 16       	cp	r1, r24
    1986:	74 f3       	brlt	.-36     	; 0x1964 <prvUnlockQueue+0x5e>
    1988:	8f ef       	ldi	r24, 0xFF	; 255
    198a:	89 a3       	std	Y+33, r24	; 0x21
    198c:	0f 90       	pop	r0
    198e:	0f be       	out	0x3f, r0	; 63
    1990:	df 91       	pop	r29
    1992:	cf 91       	pop	r28
    1994:	1f 91       	pop	r17
    1996:	0f 91       	pop	r16
    1998:	08 95       	ret

0000199a <xQueueGenericReset>:
    199a:	1f 93       	push	r17
    199c:	cf 93       	push	r28
    199e:	df 93       	push	r29
    19a0:	61 30       	cpi	r22, 0x01	; 1
    19a2:	59 f0       	breq	.+22     	; 0x19ba <xQueueGenericReset+0x20>
    19a4:	fc 01       	movw	r30, r24
    19a6:	23 89       	ldd	r18, Z+19	; 0x13
    19a8:	30 85       	ldd	r19, Z+8	; 0x08
    19aa:	31 11       	cpse	r19, r1
    19ac:	2c c0       	rjmp	.+88     	; 0x1a06 <xQueueGenericReset+0x6c>
    19ae:	11 e0       	ldi	r17, 0x01	; 1
    19b0:	21 11       	cpse	r18, r1
    19b2:	10 e0       	ldi	r17, 0x00	; 0
    19b4:	21 11       	cpse	r18, r1
    19b6:	28 c0       	rjmp	.+80     	; 0x1a08 <xQueueGenericReset+0x6e>
    19b8:	01 c0       	rjmp	.+2      	; 0x19bc <xQueueGenericReset+0x22>
    19ba:	11 e0       	ldi	r17, 0x01	; 1
    19bc:	ec 01       	movw	r28, r24
    19be:	48 81       	ld	r20, Y
    19c0:	59 81       	ldd	r21, Y+1	; 0x01
    19c2:	28 a1       	ldd	r18, Y+32	; 0x20
    19c4:	30 e0       	ldi	r19, 0x00	; 0
    19c6:	6f 8d       	ldd	r22, Y+31	; 0x1f
    19c8:	62 9f       	mul	r22, r18
    19ca:	c0 01       	movw	r24, r0
    19cc:	63 9f       	mul	r22, r19
    19ce:	90 0d       	add	r25, r0
    19d0:	11 24       	eor	r1, r1
    19d2:	ba 01       	movw	r22, r20
    19d4:	68 0f       	add	r22, r24
    19d6:	79 1f       	adc	r23, r25
    19d8:	6a 83       	std	Y+2, r22	; 0x02
    19da:	7b 83       	std	Y+3, r23	; 0x03
    19dc:	1e 8e       	std	Y+30, r1	; 0x1e
    19de:	4c 83       	std	Y+4, r20	; 0x04
    19e0:	5d 83       	std	Y+5, r21	; 0x05
    19e2:	82 1b       	sub	r24, r18
    19e4:	93 0b       	sbc	r25, r19
    19e6:	84 0f       	add	r24, r20
    19e8:	95 1f       	adc	r25, r21
    19ea:	8e 83       	std	Y+6, r24	; 0x06
    19ec:	9f 83       	std	Y+7, r25	; 0x07
    19ee:	8f ef       	ldi	r24, 0xFF	; 255
    19f0:	89 a3       	std	Y+33, r24	; 0x21
    19f2:	8a a3       	std	Y+34, r24	; 0x22
    19f4:	ce 01       	movw	r24, r28
    19f6:	08 96       	adiw	r24, 0x08	; 8
    19f8:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    19fc:	ce 01       	movw	r24, r28
    19fe:	43 96       	adiw	r24, 0x13	; 19
    1a00:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    1a04:	01 c0       	rjmp	.+2      	; 0x1a08 <xQueueGenericReset+0x6e>
    1a06:	10 e0       	ldi	r17, 0x00	; 0
    1a08:	81 2f       	mov	r24, r17
    1a0a:	df 91       	pop	r29
    1a0c:	cf 91       	pop	r28
    1a0e:	1f 91       	pop	r17
    1a10:	08 95       	ret

00001a12 <xQueueGenericCreate>:
    1a12:	0f 93       	push	r16
    1a14:	1f 93       	push	r17
    1a16:	cf 93       	push	r28
    1a18:	df 93       	push	r29
    1a1a:	88 23       	and	r24, r24
    1a1c:	01 f1       	breq	.+64     	; 0x1a5e <xQueueGenericCreate+0x4c>
    1a1e:	06 2f       	mov	r16, r22
    1a20:	18 2f       	mov	r17, r24
    1a22:	83 e2       	ldi	r24, 0x23	; 35
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	0e 94 21 09 	call	0x1242	; 0x1242 <pvPortMalloc>
    1a2a:	ec 01       	movw	r28, r24
    1a2c:	89 2b       	or	r24, r25
    1a2e:	c9 f0       	breq	.+50     	; 0x1a62 <xQueueGenericCreate+0x50>
    1a30:	10 9f       	mul	r17, r16
    1a32:	c0 01       	movw	r24, r0
    1a34:	11 24       	eor	r1, r1
    1a36:	01 96       	adiw	r24, 0x01	; 1
    1a38:	0e 94 21 09 	call	0x1242	; 0x1242 <pvPortMalloc>
    1a3c:	88 83       	st	Y, r24
    1a3e:	99 83       	std	Y+1, r25	; 0x01
    1a40:	89 2b       	or	r24, r25
    1a42:	39 f0       	breq	.+14     	; 0x1a52 <xQueueGenericCreate+0x40>
    1a44:	1f 8f       	std	Y+31, r17	; 0x1f
    1a46:	08 a3       	std	Y+32, r16	; 0x20
    1a48:	61 e0       	ldi	r22, 0x01	; 1
    1a4a:	ce 01       	movw	r24, r28
    1a4c:	0e 94 cd 0c 	call	0x199a	; 0x199a <xQueueGenericReset>
    1a50:	08 c0       	rjmp	.+16     	; 0x1a62 <xQueueGenericCreate+0x50>
    1a52:	ce 01       	movw	r24, r28
    1a54:	0e 94 bb 09 	call	0x1376	; 0x1376 <vPortFree>
    1a58:	c0 e0       	ldi	r28, 0x00	; 0
    1a5a:	d0 e0       	ldi	r29, 0x00	; 0
    1a5c:	02 c0       	rjmp	.+4      	; 0x1a62 <xQueueGenericCreate+0x50>
    1a5e:	c0 e0       	ldi	r28, 0x00	; 0
    1a60:	d0 e0       	ldi	r29, 0x00	; 0
    1a62:	ce 01       	movw	r24, r28
    1a64:	df 91       	pop	r29
    1a66:	cf 91       	pop	r28
    1a68:	1f 91       	pop	r17
    1a6a:	0f 91       	pop	r16
    1a6c:	08 95       	ret

00001a6e <xQueueGenericSend>:
    1a6e:	af 92       	push	r10
    1a70:	bf 92       	push	r11
    1a72:	cf 92       	push	r12
    1a74:	df 92       	push	r13
    1a76:	ef 92       	push	r14
    1a78:	ff 92       	push	r15
    1a7a:	0f 93       	push	r16
    1a7c:	1f 93       	push	r17
    1a7e:	cf 93       	push	r28
    1a80:	df 93       	push	r29
    1a82:	cd b7       	in	r28, 0x3d	; 61
    1a84:	de b7       	in	r29, 0x3e	; 62
    1a86:	29 97       	sbiw	r28, 0x09	; 9
    1a88:	cd bf       	out	0x3d, r28	; 61
    1a8a:	de bf       	out	0x3e, r29	; 62
    1a8c:	7c 01       	movw	r14, r24
    1a8e:	5b 01       	movw	r10, r22
    1a90:	2e 83       	std	Y+6, r18	; 0x06
    1a92:	3f 83       	std	Y+7, r19	; 0x07
    1a94:	48 87       	std	Y+8, r20	; 0x08
    1a96:	59 87       	std	Y+9, r21	; 0x09
    1a98:	10 e0       	ldi	r17, 0x00	; 0
    1a9a:	6c 01       	movw	r12, r24
    1a9c:	88 e0       	ldi	r24, 0x08	; 8
    1a9e:	c8 0e       	add	r12, r24
    1aa0:	d1 1c       	adc	r13, r1
    1aa2:	0f b6       	in	r0, 0x3f	; 63
    1aa4:	f8 94       	cli
    1aa6:	0f 92       	push	r0
    1aa8:	f7 01       	movw	r30, r14
    1aaa:	96 8d       	ldd	r25, Z+30	; 0x1e
    1aac:	87 8d       	ldd	r24, Z+31	; 0x1f
    1aae:	98 17       	cp	r25, r24
    1ab0:	a8 f4       	brcc	.+42     	; 0x1adc <xQueueGenericSend+0x6e>
    1ab2:	40 2f       	mov	r20, r16
    1ab4:	b5 01       	movw	r22, r10
    1ab6:	c7 01       	movw	r24, r14
    1ab8:	0e 94 1d 0c 	call	0x183a	; 0x183a <prvCopyDataToQueue>
    1abc:	f7 01       	movw	r30, r14
    1abe:	83 89       	ldd	r24, Z+19	; 0x13
    1ac0:	88 23       	and	r24, r24
    1ac2:	41 f0       	breq	.+16     	; 0x1ad4 <xQueueGenericSend+0x66>
    1ac4:	c7 01       	movw	r24, r14
    1ac6:	43 96       	adiw	r24, 0x13	; 19
    1ac8:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskRemoveFromEventList>
    1acc:	81 30       	cpi	r24, 0x01	; 1
    1ace:	11 f4       	brne	.+4      	; 0x1ad4 <xQueueGenericSend+0x66>
    1ad0:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
    1ad4:	0f 90       	pop	r0
    1ad6:	0f be       	out	0x3f, r0	; 63
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	56 c0       	rjmp	.+172    	; 0x1b88 <xQueueGenericSend+0x11a>
    1adc:	8e 81       	ldd	r24, Y+6	; 0x06
    1ade:	9f 81       	ldd	r25, Y+7	; 0x07
    1ae0:	a8 85       	ldd	r26, Y+8	; 0x08
    1ae2:	b9 85       	ldd	r27, Y+9	; 0x09
    1ae4:	89 2b       	or	r24, r25
    1ae6:	8a 2b       	or	r24, r26
    1ae8:	8b 2b       	or	r24, r27
    1aea:	21 f4       	brne	.+8      	; 0x1af4 <xQueueGenericSend+0x86>
    1aec:	0f 90       	pop	r0
    1aee:	0f be       	out	0x3f, r0	; 63
    1af0:	80 e0       	ldi	r24, 0x00	; 0
    1af2:	4a c0       	rjmp	.+148    	; 0x1b88 <xQueueGenericSend+0x11a>
    1af4:	11 11       	cpse	r17, r1
    1af6:	05 c0       	rjmp	.+10     	; 0x1b02 <xQueueGenericSend+0x94>
    1af8:	ce 01       	movw	r24, r28
    1afa:	01 96       	adiw	r24, 0x01	; 1
    1afc:	0e 94 3c 13 	call	0x2678	; 0x2678 <vTaskSetTimeOutState>
    1b00:	11 e0       	ldi	r17, 0x01	; 1
    1b02:	0f 90       	pop	r0
    1b04:	0f be       	out	0x3f, r0	; 63
    1b06:	0e 94 37 10 	call	0x206e	; 0x206e <vTaskSuspendAll>
    1b0a:	0f b6       	in	r0, 0x3f	; 63
    1b0c:	f8 94       	cli
    1b0e:	0f 92       	push	r0
    1b10:	f7 01       	movw	r30, r14
    1b12:	81 a1       	ldd	r24, Z+33	; 0x21
    1b14:	8f 3f       	cpi	r24, 0xFF	; 255
    1b16:	09 f4       	brne	.+2      	; 0x1b1a <xQueueGenericSend+0xac>
    1b18:	11 a2       	std	Z+33, r1	; 0x21
    1b1a:	f7 01       	movw	r30, r14
    1b1c:	82 a1       	ldd	r24, Z+34	; 0x22
    1b1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b20:	09 f4       	brne	.+2      	; 0x1b24 <xQueueGenericSend+0xb6>
    1b22:	12 a2       	std	Z+34, r1	; 0x22
    1b24:	0f 90       	pop	r0
    1b26:	0f be       	out	0x3f, r0	; 63
    1b28:	be 01       	movw	r22, r28
    1b2a:	6a 5f       	subi	r22, 0xFA	; 250
    1b2c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b2e:	ce 01       	movw	r24, r28
    1b30:	01 96       	adiw	r24, 0x01	; 1
    1b32:	0e 94 4d 13 	call	0x269a	; 0x269a <xTaskCheckForTimeOut>
    1b36:	81 11       	cpse	r24, r1
    1b38:	21 c0       	rjmp	.+66     	; 0x1b7c <xQueueGenericSend+0x10e>
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	f8 94       	cli
    1b3e:	0f 92       	push	r0
    1b40:	f7 01       	movw	r30, r14
    1b42:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b44:	0f 90       	pop	r0
    1b46:	0f be       	out	0x3f, r0	; 63
    1b48:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b4a:	98 13       	cpse	r25, r24
    1b4c:	11 c0       	rjmp	.+34     	; 0x1b70 <xQueueGenericSend+0x102>
    1b4e:	4e 81       	ldd	r20, Y+6	; 0x06
    1b50:	5f 81       	ldd	r21, Y+7	; 0x07
    1b52:	68 85       	ldd	r22, Y+8	; 0x08
    1b54:	79 85       	ldd	r23, Y+9	; 0x09
    1b56:	c6 01       	movw	r24, r12
    1b58:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <vTaskPlaceOnEventList>
    1b5c:	c7 01       	movw	r24, r14
    1b5e:	0e 94 83 0c 	call	0x1906	; 0x1906 <prvUnlockQueue>
    1b62:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
    1b66:	81 11       	cpse	r24, r1
    1b68:	9c cf       	rjmp	.-200    	; 0x1aa2 <xQueueGenericSend+0x34>
    1b6a:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
    1b6e:	99 cf       	rjmp	.-206    	; 0x1aa2 <xQueueGenericSend+0x34>
    1b70:	c7 01       	movw	r24, r14
    1b72:	0e 94 83 0c 	call	0x1906	; 0x1906 <prvUnlockQueue>
    1b76:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
    1b7a:	93 cf       	rjmp	.-218    	; 0x1aa2 <xQueueGenericSend+0x34>
    1b7c:	c7 01       	movw	r24, r14
    1b7e:	0e 94 83 0c 	call	0x1906	; 0x1906 <prvUnlockQueue>
    1b82:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
    1b86:	80 e0       	ldi	r24, 0x00	; 0
    1b88:	29 96       	adiw	r28, 0x09	; 9
    1b8a:	cd bf       	out	0x3d, r28	; 61
    1b8c:	de bf       	out	0x3e, r29	; 62
    1b8e:	df 91       	pop	r29
    1b90:	cf 91       	pop	r28
    1b92:	1f 91       	pop	r17
    1b94:	0f 91       	pop	r16
    1b96:	ff 90       	pop	r15
    1b98:	ef 90       	pop	r14
    1b9a:	df 90       	pop	r13
    1b9c:	cf 90       	pop	r12
    1b9e:	bf 90       	pop	r11
    1ba0:	af 90       	pop	r10
    1ba2:	08 95       	ret

00001ba4 <xQueueGenericReceive>:
    1ba4:	af 92       	push	r10
    1ba6:	bf 92       	push	r11
    1ba8:	cf 92       	push	r12
    1baa:	df 92       	push	r13
    1bac:	ef 92       	push	r14
    1bae:	ff 92       	push	r15
    1bb0:	0f 93       	push	r16
    1bb2:	1f 93       	push	r17
    1bb4:	cf 93       	push	r28
    1bb6:	df 93       	push	r29
    1bb8:	cd b7       	in	r28, 0x3d	; 61
    1bba:	de b7       	in	r29, 0x3e	; 62
    1bbc:	29 97       	sbiw	r28, 0x09	; 9
    1bbe:	cd bf       	out	0x3d, r28	; 61
    1bc0:	de bf       	out	0x3e, r29	; 62
    1bc2:	7c 01       	movw	r14, r24
    1bc4:	5b 01       	movw	r10, r22
    1bc6:	2e 83       	std	Y+6, r18	; 0x06
    1bc8:	3f 83       	std	Y+7, r19	; 0x07
    1bca:	48 87       	std	Y+8, r20	; 0x08
    1bcc:	59 87       	std	Y+9, r21	; 0x09
    1bce:	10 e0       	ldi	r17, 0x00	; 0
    1bd0:	6c 01       	movw	r12, r24
    1bd2:	83 e1       	ldi	r24, 0x13	; 19
    1bd4:	c8 0e       	add	r12, r24
    1bd6:	d1 1c       	adc	r13, r1
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	0f 92       	push	r0
    1bde:	f7 01       	movw	r30, r14
    1be0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1be2:	88 23       	and	r24, r24
    1be4:	99 f1       	breq	.+102    	; 0x1c4c <xQueueGenericReceive+0xa8>
    1be6:	c6 80       	ldd	r12, Z+6	; 0x06
    1be8:	d7 80       	ldd	r13, Z+7	; 0x07
    1bea:	b5 01       	movw	r22, r10
    1bec:	c7 01       	movw	r24, r14
    1bee:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <prvCopyDataFromQueue>
    1bf2:	01 11       	cpse	r16, r1
    1bf4:	1a c0       	rjmp	.+52     	; 0x1c2a <xQueueGenericReceive+0x86>
    1bf6:	f7 01       	movw	r30, r14
    1bf8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bfa:	81 50       	subi	r24, 0x01	; 1
    1bfc:	86 8f       	std	Z+30, r24	; 0x1e
    1bfe:	80 81       	ld	r24, Z
    1c00:	91 81       	ldd	r25, Z+1	; 0x01
    1c02:	89 2b       	or	r24, r25
    1c04:	29 f4       	brne	.+10     	; 0x1c10 <xQueueGenericReceive+0x6c>
    1c06:	0e 94 d7 13 	call	0x27ae	; 0x27ae <xTaskGetCurrentTaskHandle>
    1c0a:	f7 01       	movw	r30, r14
    1c0c:	82 83       	std	Z+2, r24	; 0x02
    1c0e:	93 83       	std	Z+3, r25	; 0x03
    1c10:	f7 01       	movw	r30, r14
    1c12:	80 85       	ldd	r24, Z+8	; 0x08
    1c14:	88 23       	and	r24, r24
    1c16:	b1 f0       	breq	.+44     	; 0x1c44 <xQueueGenericReceive+0xa0>
    1c18:	c7 01       	movw	r24, r14
    1c1a:	08 96       	adiw	r24, 0x08	; 8
    1c1c:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskRemoveFromEventList>
    1c20:	81 30       	cpi	r24, 0x01	; 1
    1c22:	81 f4       	brne	.+32     	; 0x1c44 <xQueueGenericReceive+0xa0>
    1c24:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
    1c28:	0d c0       	rjmp	.+26     	; 0x1c44 <xQueueGenericReceive+0xa0>
    1c2a:	f7 01       	movw	r30, r14
    1c2c:	c6 82       	std	Z+6, r12	; 0x06
    1c2e:	d7 82       	std	Z+7, r13	; 0x07
    1c30:	83 89       	ldd	r24, Z+19	; 0x13
    1c32:	88 23       	and	r24, r24
    1c34:	39 f0       	breq	.+14     	; 0x1c44 <xQueueGenericReceive+0xa0>
    1c36:	c7 01       	movw	r24, r14
    1c38:	43 96       	adiw	r24, 0x13	; 19
    1c3a:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskRemoveFromEventList>
    1c3e:	81 11       	cpse	r24, r1
    1c40:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
    1c44:	0f 90       	pop	r0
    1c46:	0f be       	out	0x3f, r0	; 63
    1c48:	81 e0       	ldi	r24, 0x01	; 1
    1c4a:	62 c0       	rjmp	.+196    	; 0x1d10 <xQueueGenericReceive+0x16c>
    1c4c:	8e 81       	ldd	r24, Y+6	; 0x06
    1c4e:	9f 81       	ldd	r25, Y+7	; 0x07
    1c50:	a8 85       	ldd	r26, Y+8	; 0x08
    1c52:	b9 85       	ldd	r27, Y+9	; 0x09
    1c54:	89 2b       	or	r24, r25
    1c56:	8a 2b       	or	r24, r26
    1c58:	8b 2b       	or	r24, r27
    1c5a:	21 f4       	brne	.+8      	; 0x1c64 <xQueueGenericReceive+0xc0>
    1c5c:	0f 90       	pop	r0
    1c5e:	0f be       	out	0x3f, r0	; 63
    1c60:	80 e0       	ldi	r24, 0x00	; 0
    1c62:	56 c0       	rjmp	.+172    	; 0x1d10 <xQueueGenericReceive+0x16c>
    1c64:	11 11       	cpse	r17, r1
    1c66:	05 c0       	rjmp	.+10     	; 0x1c72 <xQueueGenericReceive+0xce>
    1c68:	ce 01       	movw	r24, r28
    1c6a:	01 96       	adiw	r24, 0x01	; 1
    1c6c:	0e 94 3c 13 	call	0x2678	; 0x2678 <vTaskSetTimeOutState>
    1c70:	11 e0       	ldi	r17, 0x01	; 1
    1c72:	0f 90       	pop	r0
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	0e 94 37 10 	call	0x206e	; 0x206e <vTaskSuspendAll>
    1c7a:	0f b6       	in	r0, 0x3f	; 63
    1c7c:	f8 94       	cli
    1c7e:	0f 92       	push	r0
    1c80:	f7 01       	movw	r30, r14
    1c82:	81 a1       	ldd	r24, Z+33	; 0x21
    1c84:	8f 3f       	cpi	r24, 0xFF	; 255
    1c86:	09 f4       	brne	.+2      	; 0x1c8a <xQueueGenericReceive+0xe6>
    1c88:	11 a2       	std	Z+33, r1	; 0x21
    1c8a:	f7 01       	movw	r30, r14
    1c8c:	82 a1       	ldd	r24, Z+34	; 0x22
    1c8e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c90:	09 f4       	brne	.+2      	; 0x1c94 <xQueueGenericReceive+0xf0>
    1c92:	12 a2       	std	Z+34, r1	; 0x22
    1c94:	0f 90       	pop	r0
    1c96:	0f be       	out	0x3f, r0	; 63
    1c98:	be 01       	movw	r22, r28
    1c9a:	6a 5f       	subi	r22, 0xFA	; 250
    1c9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c9e:	ce 01       	movw	r24, r28
    1ca0:	01 96       	adiw	r24, 0x01	; 1
    1ca2:	0e 94 4d 13 	call	0x269a	; 0x269a <xTaskCheckForTimeOut>
    1ca6:	81 11       	cpse	r24, r1
    1ca8:	2d c0       	rjmp	.+90     	; 0x1d04 <xQueueGenericReceive+0x160>
    1caa:	0f b6       	in	r0, 0x3f	; 63
    1cac:	f8 94       	cli
    1cae:	0f 92       	push	r0
    1cb0:	f7 01       	movw	r30, r14
    1cb2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cb4:	0f 90       	pop	r0
    1cb6:	0f be       	out	0x3f, r0	; 63
    1cb8:	81 11       	cpse	r24, r1
    1cba:	1e c0       	rjmp	.+60     	; 0x1cf8 <xQueueGenericReceive+0x154>
    1cbc:	80 81       	ld	r24, Z
    1cbe:	91 81       	ldd	r25, Z+1	; 0x01
    1cc0:	89 2b       	or	r24, r25
    1cc2:	49 f4       	brne	.+18     	; 0x1cd6 <xQueueGenericReceive+0x132>
    1cc4:	0f b6       	in	r0, 0x3f	; 63
    1cc6:	f8 94       	cli
    1cc8:	0f 92       	push	r0
    1cca:	82 81       	ldd	r24, Z+2	; 0x02
    1ccc:	93 81       	ldd	r25, Z+3	; 0x03
    1cce:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <vTaskPriorityInherit>
    1cd2:	0f 90       	pop	r0
    1cd4:	0f be       	out	0x3f, r0	; 63
    1cd6:	4e 81       	ldd	r20, Y+6	; 0x06
    1cd8:	5f 81       	ldd	r21, Y+7	; 0x07
    1cda:	68 85       	ldd	r22, Y+8	; 0x08
    1cdc:	79 85       	ldd	r23, Y+9	; 0x09
    1cde:	c6 01       	movw	r24, r12
    1ce0:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <vTaskPlaceOnEventList>
    1ce4:	c7 01       	movw	r24, r14
    1ce6:	0e 94 83 0c 	call	0x1906	; 0x1906 <prvUnlockQueue>
    1cea:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
    1cee:	81 11       	cpse	r24, r1
    1cf0:	73 cf       	rjmp	.-282    	; 0x1bd8 <xQueueGenericReceive+0x34>
    1cf2:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
    1cf6:	70 cf       	rjmp	.-288    	; 0x1bd8 <xQueueGenericReceive+0x34>
    1cf8:	c7 01       	movw	r24, r14
    1cfa:	0e 94 83 0c 	call	0x1906	; 0x1906 <prvUnlockQueue>
    1cfe:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
    1d02:	6a cf       	rjmp	.-300    	; 0x1bd8 <xQueueGenericReceive+0x34>
    1d04:	c7 01       	movw	r24, r14
    1d06:	0e 94 83 0c 	call	0x1906	; 0x1906 <prvUnlockQueue>
    1d0a:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
    1d10:	29 96       	adiw	r28, 0x09	; 9
    1d12:	cd bf       	out	0x3d, r28	; 61
    1d14:	de bf       	out	0x3e, r29	; 62
    1d16:	df 91       	pop	r29
    1d18:	cf 91       	pop	r28
    1d1a:	1f 91       	pop	r17
    1d1c:	0f 91       	pop	r16
    1d1e:	ff 90       	pop	r15
    1d20:	ef 90       	pop	r14
    1d22:	df 90       	pop	r13
    1d24:	cf 90       	pop	r12
    1d26:	bf 90       	pop	r11
    1d28:	af 90       	pop	r10
    1d2a:	08 95       	ret

00001d2c <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	f8 94       	cli
    1d30:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d32:	fc 01       	movw	r30, r24
    1d34:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d36:	0f 90       	pop	r0
    1d38:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d3a:	08 95       	ret

00001d3c <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d3c:	c6 e0       	ldi	r28, 0x06	; 6
    1d3e:	d1 e3       	ldi	r29, 0x31	; 49
    1d40:	88 81       	ld	r24, Y
    1d42:	82 30       	cpi	r24, 0x02	; 2
    1d44:	e8 f3       	brcs	.-6      	; 0x1d40 <prvIdleTask+0x4>
    1d46:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
    1d4a:	fa cf       	rjmp	.-12     	; 0x1d40 <prvIdleTask+0x4>

00001d4c <prvAddCurrentTaskToDelayedList>:
    1d4c:	cf 92       	push	r12
    1d4e:	df 92       	push	r13
    1d50:	ef 92       	push	r14
    1d52:	ff 92       	push	r15
    1d54:	6b 01       	movw	r12, r22
    1d56:	7c 01       	movw	r14, r24
    1d58:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1d5c:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1d60:	62 83       	std	Z+2, r22	; 0x02
    1d62:	73 83       	std	Z+3, r23	; 0x03
    1d64:	84 83       	std	Z+4, r24	; 0x04
    1d66:	95 83       	std	Z+5, r25	; 0x05
    1d68:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1d6c:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1d70:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1d74:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1d78:	c8 16       	cp	r12, r24
    1d7a:	d9 06       	cpc	r13, r25
    1d7c:	ea 06       	cpc	r14, r26
    1d7e:	fb 06       	cpc	r15, r27
    1d80:	68 f4       	brcc	.+26     	; 0x1d9c <prvAddCurrentTaskToDelayedList+0x50>
    1d82:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    1d86:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1d8a:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxOverflowDelayedTaskList>
    1d8e:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    1d92:	6e 5f       	subi	r22, 0xFE	; 254
    1d94:	7f 4f       	sbci	r23, 0xFF	; 255
    1d96:	0e 94 2f 0a 	call	0x145e	; 0x145e <vListInsert>
    1d9a:	21 c0       	rjmp	.+66     	; 0x1dde <prvAddCurrentTaskToDelayedList+0x92>
    1d9c:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    1da0:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1da4:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1da8:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1dac:	6e 5f       	subi	r22, 0xFE	; 254
    1dae:	7f 4f       	sbci	r23, 0xFF	; 255
    1db0:	0e 94 2f 0a 	call	0x145e	; 0x145e <vListInsert>
    1db4:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1db8:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dbc:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dc0:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dc4:	c8 16       	cp	r12, r24
    1dc6:	d9 06       	cpc	r13, r25
    1dc8:	ea 06       	cpc	r14, r26
    1dca:	fb 06       	cpc	r15, r27
    1dcc:	40 f4       	brcc	.+16     	; 0x1dde <prvAddCurrentTaskToDelayedList+0x92>
    1dce:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1dd2:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dd6:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dda:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dde:	ff 90       	pop	r15
    1de0:	ef 90       	pop	r14
    1de2:	df 90       	pop	r13
    1de4:	cf 90       	pop	r12
    1de6:	08 95       	ret

00001de8 <xTaskGenericCreate>:
    1de8:	4f 92       	push	r4
    1dea:	5f 92       	push	r5
    1dec:	6f 92       	push	r6
    1dee:	7f 92       	push	r7
    1df0:	8f 92       	push	r8
    1df2:	9f 92       	push	r9
    1df4:	af 92       	push	r10
    1df6:	bf 92       	push	r11
    1df8:	cf 92       	push	r12
    1dfa:	df 92       	push	r13
    1dfc:	ef 92       	push	r14
    1dfe:	ff 92       	push	r15
    1e00:	0f 93       	push	r16
    1e02:	1f 93       	push	r17
    1e04:	cf 93       	push	r28
    1e06:	df 93       	push	r29
    1e08:	5c 01       	movw	r10, r24
    1e0a:	4b 01       	movw	r8, r22
    1e0c:	3a 01       	movw	r6, r20
    1e0e:	29 01       	movw	r4, r18
    1e10:	88 e2       	ldi	r24, 0x28	; 40
    1e12:	90 e0       	ldi	r25, 0x00	; 0
    1e14:	0e 94 21 09 	call	0x1242	; 0x1242 <pvPortMalloc>
    1e18:	ec 01       	movw	r28, r24
    1e1a:	89 2b       	or	r24, r25
    1e1c:	09 f4       	brne	.+2      	; 0x1e20 <xTaskGenericCreate+0x38>
    1e1e:	d4 c0       	rjmp	.+424    	; 0x1fc8 <xTaskGenericCreate+0x1e0>
    1e20:	c1 14       	cp	r12, r1
    1e22:	d1 04       	cpc	r13, r1
    1e24:	09 f0       	breq	.+2      	; 0x1e28 <xTaskGenericCreate+0x40>
    1e26:	cc c0       	rjmp	.+408    	; 0x1fc0 <xTaskGenericCreate+0x1d8>
    1e28:	c3 01       	movw	r24, r6
    1e2a:	0e 94 21 09 	call	0x1242	; 0x1242 <pvPortMalloc>
    1e2e:	8b 8f       	std	Y+27, r24	; 0x1b
    1e30:	9c 8f       	std	Y+28, r25	; 0x1c
    1e32:	00 97       	sbiw	r24, 0x00	; 0
    1e34:	21 f4       	brne	.+8      	; 0x1e3e <xTaskGenericCreate+0x56>
    1e36:	ce 01       	movw	r24, r28
    1e38:	0e 94 bb 09 	call	0x1376	; 0x1376 <vPortFree>
    1e3c:	c5 c0       	rjmp	.+394    	; 0x1fc8 <xTaskGenericCreate+0x1e0>
    1e3e:	a3 01       	movw	r20, r6
    1e40:	61 e1       	ldi	r22, 0x11	; 17
    1e42:	70 e0       	ldi	r23, 0x00	; 0
    1e44:	0e 94 67 22 	call	0x44ce	; 0x44ce <memset>
    1e48:	93 01       	movw	r18, r6
    1e4a:	21 50       	subi	r18, 0x01	; 1
    1e4c:	31 09       	sbc	r19, r1
    1e4e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e50:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e52:	3c 01       	movw	r6, r24
    1e54:	62 0e       	add	r6, r18
    1e56:	73 1e       	adc	r7, r19
    1e58:	4a e0       	ldi	r20, 0x0A	; 10
    1e5a:	50 e0       	ldi	r21, 0x00	; 0
    1e5c:	b4 01       	movw	r22, r8
    1e5e:	ce 01       	movw	r24, r28
    1e60:	4d 96       	adiw	r24, 0x1d	; 29
    1e62:	0e 94 6e 22 	call	0x44dc	; 0x44dc <strncpy>
    1e66:	1e a2       	std	Y+38, r1	; 0x26
    1e68:	10 2f       	mov	r17, r16
    1e6a:	04 30       	cpi	r16, 0x04	; 4
    1e6c:	08 f0       	brcs	.+2      	; 0x1e70 <xTaskGenericCreate+0x88>
    1e6e:	13 e0       	ldi	r17, 0x03	; 3
    1e70:	1a 8f       	std	Y+26, r17	; 0x1a
    1e72:	1f a3       	std	Y+39, r17	; 0x27
    1e74:	6e 01       	movw	r12, r28
    1e76:	22 e0       	ldi	r18, 0x02	; 2
    1e78:	c2 0e       	add	r12, r18
    1e7a:	d1 1c       	adc	r13, r1
    1e7c:	c6 01       	movw	r24, r12
    1e7e:	0e 94 04 0a 	call	0x1408	; 0x1408 <vListInitialiseItem>
    1e82:	ce 01       	movw	r24, r28
    1e84:	0e 96       	adiw	r24, 0x0e	; 14
    1e86:	0e 94 04 0a 	call	0x1408	; 0x1408 <vListInitialiseItem>
    1e8a:	ca 87       	std	Y+10, r28	; 0x0a
    1e8c:	db 87       	std	Y+11, r29	; 0x0b
    1e8e:	84 e0       	ldi	r24, 0x04	; 4
    1e90:	90 e0       	ldi	r25, 0x00	; 0
    1e92:	a0 e0       	ldi	r26, 0x00	; 0
    1e94:	b0 e0       	ldi	r27, 0x00	; 0
    1e96:	81 1b       	sub	r24, r17
    1e98:	91 09       	sbc	r25, r1
    1e9a:	a1 09       	sbc	r26, r1
    1e9c:	b1 09       	sbc	r27, r1
    1e9e:	8e 87       	std	Y+14, r24	; 0x0e
    1ea0:	9f 87       	std	Y+15, r25	; 0x0f
    1ea2:	a8 8b       	std	Y+16, r26	; 0x10
    1ea4:	b9 8b       	std	Y+17, r27	; 0x11
    1ea6:	ce 8b       	std	Y+22, r28	; 0x16
    1ea8:	df 8b       	std	Y+23, r29	; 0x17
    1eaa:	a2 01       	movw	r20, r4
    1eac:	b5 01       	movw	r22, r10
    1eae:	c3 01       	movw	r24, r6
    1eb0:	0e 94 a0 0a 	call	0x1540	; 0x1540 <pxPortInitialiseStack>
    1eb4:	88 83       	st	Y, r24
    1eb6:	99 83       	std	Y+1, r25	; 0x01
    1eb8:	e1 14       	cp	r14, r1
    1eba:	f1 04       	cpc	r15, r1
    1ebc:	19 f0       	breq	.+6      	; 0x1ec4 <xTaskGenericCreate+0xdc>
    1ebe:	f7 01       	movw	r30, r14
    1ec0:	c0 83       	st	Z, r28
    1ec2:	d1 83       	std	Z+1, r29	; 0x01
    1ec4:	0f b6       	in	r0, 0x3f	; 63
    1ec6:	f8 94       	cli
    1ec8:	0f 92       	push	r0
    1eca:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1ece:	8f 5f       	subi	r24, 0xFF	; 255
    1ed0:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <uxCurrentNumberOfTasks>
    1ed4:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1ed8:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1edc:	89 2b       	or	r24, r25
    1ede:	89 f5       	brne	.+98     	; 0x1f42 <xTaskGenericCreate+0x15a>
    1ee0:	c0 93 32 31 	sts	0x3132, r28	; 0x803132 <pxCurrentTCB>
    1ee4:	d0 93 33 31 	sts	0x3133, r29	; 0x803133 <pxCurrentTCB+0x1>
    1ee8:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1eec:	81 30       	cpi	r24, 0x01	; 1
    1eee:	c1 f5       	brne	.+112    	; 0x1f60 <xTaskGenericCreate+0x178>
    1ef0:	86 e0       	ldi	r24, 0x06	; 6
    1ef2:	91 e3       	ldi	r25, 0x31	; 49
    1ef4:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    1ef8:	81 e1       	ldi	r24, 0x11	; 17
    1efa:	91 e3       	ldi	r25, 0x31	; 49
    1efc:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    1f00:	8c e1       	ldi	r24, 0x1C	; 28
    1f02:	91 e3       	ldi	r25, 0x31	; 49
    1f04:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    1f08:	87 e2       	ldi	r24, 0x27	; 39
    1f0a:	91 e3       	ldi	r25, 0x31	; 49
    1f0c:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    1f10:	8b ef       	ldi	r24, 0xFB	; 251
    1f12:	90 e3       	ldi	r25, 0x30	; 48
    1f14:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    1f18:	80 ef       	ldi	r24, 0xF0	; 240
    1f1a:	90 e3       	ldi	r25, 0x30	; 48
    1f1c:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    1f20:	81 ee       	ldi	r24, 0xE1	; 225
    1f22:	90 e3       	ldi	r25, 0x30	; 48
    1f24:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialise>
    1f28:	8b ef       	ldi	r24, 0xFB	; 251
    1f2a:	90 e3       	ldi	r25, 0x30	; 48
    1f2c:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <pxDelayedTaskList>
    1f30:	90 93 ef 30 	sts	0x30EF, r25	; 0x8030ef <pxDelayedTaskList+0x1>
    1f34:	80 ef       	ldi	r24, 0xF0	; 240
    1f36:	90 e3       	ldi	r25, 0x30	; 48
    1f38:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxOverflowDelayedTaskList>
    1f3c:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    1f40:	0f c0       	rjmp	.+30     	; 0x1f60 <xTaskGenericCreate+0x178>
    1f42:	80 91 d7 30 	lds	r24, 0x30D7	; 0x8030d7 <xSchedulerRunning>
    1f46:	81 11       	cpse	r24, r1
    1f48:	0b c0       	rjmp	.+22     	; 0x1f60 <xTaskGenericCreate+0x178>
    1f4a:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1f4e:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1f52:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f54:	08 17       	cp	r16, r24
    1f56:	20 f0       	brcs	.+8      	; 0x1f60 <xTaskGenericCreate+0x178>
    1f58:	c0 93 32 31 	sts	0x3132, r28	; 0x803132 <pxCurrentTCB>
    1f5c:	d0 93 33 31 	sts	0x3133, r29	; 0x803133 <pxCurrentTCB+0x1>
    1f60:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f62:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <uxTopUsedPriority>
    1f66:	98 17       	cp	r25, r24
    1f68:	10 f4       	brcc	.+4      	; 0x1f6e <xTaskGenericCreate+0x186>
    1f6a:	80 93 d9 30 	sts	0x30D9, r24	; 0x8030d9 <uxTopUsedPriority>
    1f6e:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <uxTaskNumber>
    1f72:	9f 5f       	subi	r25, 0xFF	; 255
    1f74:	90 93 d2 30 	sts	0x30D2, r25	; 0x8030d2 <uxTaskNumber>
    1f78:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    1f7c:	98 17       	cp	r25, r24
    1f7e:	10 f4       	brcc	.+4      	; 0x1f84 <xTaskGenericCreate+0x19c>
    1f80:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    1f84:	fb e0       	ldi	r31, 0x0B	; 11
    1f86:	8f 9f       	mul	r24, r31
    1f88:	c0 01       	movw	r24, r0
    1f8a:	11 24       	eor	r1, r1
    1f8c:	b6 01       	movw	r22, r12
    1f8e:	8a 5f       	subi	r24, 0xFA	; 250
    1f90:	9e 4c       	sbci	r25, 0xCE	; 206
    1f92:	0e 94 08 0a 	call	0x1410	; 0x1410 <vListInsertEnd>
    1f96:	0f 90       	pop	r0
    1f98:	0f be       	out	0x3f, r0	; 63
    1f9a:	80 91 d7 30 	lds	r24, 0x30D7	; 0x8030d7 <xSchedulerRunning>
    1f9e:	88 23       	and	r24, r24
    1fa0:	59 f0       	breq	.+22     	; 0x1fb8 <xTaskGenericCreate+0x1d0>
    1fa2:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1fa6:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1faa:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fac:	80 17       	cp	r24, r16
    1fae:	30 f4       	brcc	.+12     	; 0x1fbc <xTaskGenericCreate+0x1d4>
    1fb0:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
    1fb4:	81 e0       	ldi	r24, 0x01	; 1
    1fb6:	09 c0       	rjmp	.+18     	; 0x1fca <xTaskGenericCreate+0x1e2>
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	07 c0       	rjmp	.+14     	; 0x1fca <xTaskGenericCreate+0x1e2>
    1fbc:	81 e0       	ldi	r24, 0x01	; 1
    1fbe:	05 c0       	rjmp	.+10     	; 0x1fca <xTaskGenericCreate+0x1e2>
    1fc0:	cb 8e       	std	Y+27, r12	; 0x1b
    1fc2:	dc 8e       	std	Y+28, r13	; 0x1c
    1fc4:	c6 01       	movw	r24, r12
    1fc6:	3b cf       	rjmp	.-394    	; 0x1e3e <xTaskGenericCreate+0x56>
    1fc8:	8f ef       	ldi	r24, 0xFF	; 255
    1fca:	df 91       	pop	r29
    1fcc:	cf 91       	pop	r28
    1fce:	1f 91       	pop	r17
    1fd0:	0f 91       	pop	r16
    1fd2:	ff 90       	pop	r15
    1fd4:	ef 90       	pop	r14
    1fd6:	df 90       	pop	r13
    1fd8:	cf 90       	pop	r12
    1fda:	bf 90       	pop	r11
    1fdc:	af 90       	pop	r10
    1fde:	9f 90       	pop	r9
    1fe0:	8f 90       	pop	r8
    1fe2:	7f 90       	pop	r7
    1fe4:	6f 90       	pop	r6
    1fe6:	5f 90       	pop	r5
    1fe8:	4f 90       	pop	r4
    1fea:	08 95       	ret

00001fec <uxTaskPriorityGet>:
    1fec:	0f b6       	in	r0, 0x3f	; 63
    1fee:	f8 94       	cli
    1ff0:	0f 92       	push	r0
    1ff2:	00 97       	sbiw	r24, 0x00	; 0
    1ff4:	21 f4       	brne	.+8      	; 0x1ffe <uxTaskPriorityGet+0x12>
    1ff6:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1ffa:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1ffe:	0f 90       	pop	r0
    2000:	0f be       	out	0x3f, r0	; 63
    2002:	fc 01       	movw	r30, r24
    2004:	82 8d       	ldd	r24, Z+26	; 0x1a
    2006:	08 95       	ret

00002008 <vTaskStartScheduler>:
    2008:	af 92       	push	r10
    200a:	bf 92       	push	r11
    200c:	cf 92       	push	r12
    200e:	df 92       	push	r13
    2010:	ef 92       	push	r14
    2012:	ff 92       	push	r15
    2014:	0f 93       	push	r16
    2016:	a1 2c       	mov	r10, r1
    2018:	b1 2c       	mov	r11, r1
    201a:	c1 2c       	mov	r12, r1
    201c:	d1 2c       	mov	r13, r1
    201e:	0f 2e       	mov	r0, r31
    2020:	ff ed       	ldi	r31, 0xDF	; 223
    2022:	ef 2e       	mov	r14, r31
    2024:	f0 e3       	ldi	r31, 0x30	; 48
    2026:	ff 2e       	mov	r15, r31
    2028:	f0 2d       	mov	r31, r0
    202a:	00 e0       	ldi	r16, 0x00	; 0
    202c:	20 e0       	ldi	r18, 0x00	; 0
    202e:	30 e0       	ldi	r19, 0x00	; 0
    2030:	44 e6       	ldi	r20, 0x64	; 100
    2032:	50 e0       	ldi	r21, 0x00	; 0
    2034:	68 e4       	ldi	r22, 0x48	; 72
    2036:	70 e2       	ldi	r23, 0x20	; 32
    2038:	8e e9       	ldi	r24, 0x9E	; 158
    203a:	9e e0       	ldi	r25, 0x0E	; 14
    203c:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <xTaskGenericCreate>
    2040:	81 30       	cpi	r24, 0x01	; 1
    2042:	69 f4       	brne	.+26     	; 0x205e <vTaskStartScheduler+0x56>
    2044:	f8 94       	cli
    2046:	80 93 d7 30 	sts	0x30D7, r24	; 0x8030d7 <xSchedulerRunning>
    204a:	10 92 da 30 	sts	0x30DA, r1	; 0x8030da <xTickCount>
    204e:	10 92 db 30 	sts	0x30DB, r1	; 0x8030db <xTickCount+0x1>
    2052:	10 92 dc 30 	sts	0x30DC, r1	; 0x8030dc <xTickCount+0x2>
    2056:	10 92 dd 30 	sts	0x30DD, r1	; 0x8030dd <xTickCount+0x3>
    205a:	0e 94 16 0b 	call	0x162c	; 0x162c <xPortStartScheduler>
    205e:	0f 91       	pop	r16
    2060:	ff 90       	pop	r15
    2062:	ef 90       	pop	r14
    2064:	df 90       	pop	r13
    2066:	cf 90       	pop	r12
    2068:	bf 90       	pop	r11
    206a:	af 90       	pop	r10
    206c:	08 95       	ret

0000206e <vTaskSuspendAll>:
    206e:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    2072:	8f 5f       	subi	r24, 0xFF	; 255
    2074:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxSchedulerSuspended>
    2078:	08 95       	ret

0000207a <xTaskGetTickCount>:
    207a:	0f b6       	in	r0, 0x3f	; 63
    207c:	f8 94       	cli
    207e:	0f 92       	push	r0
    2080:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount>
    2084:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x1>
    2088:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <xTickCount+0x2>
    208c:	90 91 dd 30 	lds	r25, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2090:	0f 90       	pop	r0
    2092:	0f be       	out	0x3f, r0	; 63
    2094:	08 95       	ret

00002096 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2096:	00 97       	sbiw	r24, 0x00	; 0
    2098:	21 f4       	brne	.+8      	; 0x20a2 <pcTaskGetTaskName+0xc>
    209a:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    209e:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20a2:	4d 96       	adiw	r24, 0x1d	; 29
    20a4:	08 95       	ret

000020a6 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20a6:	80 91 df 30 	lds	r24, 0x30DF	; 0x8030df <xIdleTaskHandle>
    20aa:	90 91 e0 30 	lds	r25, 0x30E0	; 0x8030e0 <xIdleTaskHandle+0x1>
    20ae:	08 95       	ret

000020b0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20b0:	ff 92       	push	r15
    20b2:	0f 93       	push	r16
    20b4:	1f 93       	push	r17
    20b6:	cf 93       	push	r28
    20b8:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20ba:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    20be:	81 11       	cpse	r24, r1
    20c0:	ed c0       	rjmp	.+474    	; 0x229c <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    20c2:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    20c6:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    20ca:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    20ce:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    20d2:	01 96       	adiw	r24, 0x01	; 1
    20d4:	a1 1d       	adc	r26, r1
    20d6:	b1 1d       	adc	r27, r1
    20d8:	80 93 da 30 	sts	0x30DA, r24	; 0x8030da <xTickCount>
    20dc:	90 93 db 30 	sts	0x30DB, r25	; 0x8030db <xTickCount+0x1>
    20e0:	a0 93 dc 30 	sts	0x30DC, r26	; 0x8030dc <xTickCount+0x2>
    20e4:	b0 93 dd 30 	sts	0x30DD, r27	; 0x8030dd <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    20e8:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    20ec:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    20f0:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    20f4:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    20f8:	89 2b       	or	r24, r25
    20fa:	8a 2b       	or	r24, r26
    20fc:	8b 2b       	or	r24, r27
    20fe:	f1 f5       	brne	.+124    	; 0x217c <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2100:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    2104:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2108:	20 91 ec 30 	lds	r18, 0x30EC	; 0x8030ec <pxOverflowDelayedTaskList>
    210c:	30 91 ed 30 	lds	r19, 0x30ED	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    2110:	20 93 ee 30 	sts	0x30EE, r18	; 0x8030ee <pxDelayedTaskList>
    2114:	30 93 ef 30 	sts	0x30EF, r19	; 0x8030ef <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2118:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxOverflowDelayedTaskList>
    211c:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2120:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    2124:	8f 5f       	subi	r24, 0xFF	; 255
    2126:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    212a:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    212e:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    2132:	80 81       	ld	r24, Z
    2134:	81 11       	cpse	r24, r1
    2136:	0c c0       	rjmp	.+24     	; 0x2150 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2138:	8f ef       	ldi	r24, 0xFF	; 255
    213a:	9f ef       	ldi	r25, 0xFF	; 255
    213c:	dc 01       	movw	r26, r24
    213e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2142:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2146:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    214a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    214e:	16 c0       	rjmp	.+44     	; 0x217c <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2150:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    2154:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    2158:	07 80       	ldd	r0, Z+7	; 0x07
    215a:	f0 85       	ldd	r31, Z+8	; 0x08
    215c:	e0 2d       	mov	r30, r0
    215e:	00 84       	ldd	r0, Z+8	; 0x08
    2160:	f1 85       	ldd	r31, Z+9	; 0x09
    2162:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2164:	82 81       	ldd	r24, Z+2	; 0x02
    2166:	93 81       	ldd	r25, Z+3	; 0x03
    2168:	a4 81       	ldd	r26, Z+4	; 0x04
    216a:	b5 81       	ldd	r27, Z+5	; 0x05
    216c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2170:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2174:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2178:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    217c:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    2180:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    2184:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2188:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    218c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2190:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2194:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2198:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    219c:	48 17       	cp	r20, r24
    219e:	59 07       	cpc	r21, r25
    21a0:	6a 07       	cpc	r22, r26
    21a2:	7b 07       	cpc	r23, r27
    21a4:	08 f4       	brcc	.+2      	; 0x21a8 <vTaskIncrementTick+0xf8>
    21a6:	7f c0       	rjmp	.+254    	; 0x22a6 <vTaskIncrementTick+0x1f6>
    21a8:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    21ac:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    21b0:	80 81       	ld	r24, Z
    21b2:	88 23       	and	r24, r24
    21b4:	f9 f0       	breq	.+62     	; 0x21f4 <vTaskIncrementTick+0x144>
    21b6:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    21ba:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    21be:	07 80       	ldd	r0, Z+7	; 0x07
    21c0:	f0 85       	ldd	r31, Z+8	; 0x08
    21c2:	e0 2d       	mov	r30, r0
    21c4:	c0 85       	ldd	r28, Z+8	; 0x08
    21c6:	d1 85       	ldd	r29, Z+9	; 0x09
    21c8:	8a 81       	ldd	r24, Y+2	; 0x02
    21ca:	9b 81       	ldd	r25, Y+3	; 0x03
    21cc:	ac 81       	ldd	r26, Y+4	; 0x04
    21ce:	bd 81       	ldd	r27, Y+5	; 0x05
    21d0:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    21d4:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    21d8:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    21dc:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    21e0:	48 17       	cp	r20, r24
    21e2:	59 07       	cpc	r21, r25
    21e4:	6a 07       	cpc	r22, r26
    21e6:	7b 07       	cpc	r23, r27
    21e8:	58 f1       	brcs	.+86     	; 0x2240 <vTaskIncrementTick+0x190>
    21ea:	0f 2e       	mov	r0, r31
    21ec:	fb e0       	ldi	r31, 0x0B	; 11
    21ee:	ff 2e       	mov	r15, r31
    21f0:	f0 2d       	mov	r31, r0
    21f2:	2f c0       	rjmp	.+94     	; 0x2252 <vTaskIncrementTick+0x1a2>
    21f4:	8f ef       	ldi	r24, 0xFF	; 255
    21f6:	9f ef       	ldi	r25, 0xFF	; 255
    21f8:	dc 01       	movw	r26, r24
    21fa:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21fe:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2202:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2206:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    220a:	4d c0       	rjmp	.+154    	; 0x22a6 <vTaskIncrementTick+0x1f6>
    220c:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    2210:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    2214:	07 80       	ldd	r0, Z+7	; 0x07
    2216:	f0 85       	ldd	r31, Z+8	; 0x08
    2218:	e0 2d       	mov	r30, r0
    221a:	c0 85       	ldd	r28, Z+8	; 0x08
    221c:	d1 85       	ldd	r29, Z+9	; 0x09
    221e:	8a 81       	ldd	r24, Y+2	; 0x02
    2220:	9b 81       	ldd	r25, Y+3	; 0x03
    2222:	ac 81       	ldd	r26, Y+4	; 0x04
    2224:	bd 81       	ldd	r27, Y+5	; 0x05
    2226:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    222a:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    222e:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2232:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2236:	48 17       	cp	r20, r24
    2238:	59 07       	cpc	r21, r25
    223a:	6a 07       	cpc	r22, r26
    223c:	7b 07       	cpc	r23, r27
    223e:	48 f4       	brcc	.+18     	; 0x2252 <vTaskIncrementTick+0x1a2>
    2240:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2244:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2248:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    224c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2250:	2a c0       	rjmp	.+84     	; 0x22a6 <vTaskIncrementTick+0x1f6>
    2252:	8e 01       	movw	r16, r28
    2254:	0e 5f       	subi	r16, 0xFE	; 254
    2256:	1f 4f       	sbci	r17, 0xFF	; 255
    2258:	c8 01       	movw	r24, r16
    225a:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>
    225e:	88 8d       	ldd	r24, Y+24	; 0x18
    2260:	99 8d       	ldd	r25, Y+25	; 0x19
    2262:	89 2b       	or	r24, r25
    2264:	21 f0       	breq	.+8      	; 0x226e <vTaskIncrementTick+0x1be>
    2266:	ce 01       	movw	r24, r28
    2268:	0e 96       	adiw	r24, 0x0e	; 14
    226a:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>
    226e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2270:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2274:	98 17       	cp	r25, r24
    2276:	10 f4       	brcc	.+4      	; 0x227c <vTaskIncrementTick+0x1cc>
    2278:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    227c:	f8 9e       	mul	r15, r24
    227e:	c0 01       	movw	r24, r0
    2280:	11 24       	eor	r1, r1
    2282:	b8 01       	movw	r22, r16
    2284:	8a 5f       	subi	r24, 0xFA	; 250
    2286:	9e 4c       	sbci	r25, 0xCE	; 206
    2288:	0e 94 08 0a 	call	0x1410	; 0x1410 <vListInsertEnd>
    228c:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    2290:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    2294:	80 81       	ld	r24, Z
    2296:	81 11       	cpse	r24, r1
    2298:	b9 cf       	rjmp	.-142    	; 0x220c <vTaskIncrementTick+0x15c>
    229a:	ac cf       	rjmp	.-168    	; 0x21f4 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    229c:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    22a0:	8f 5f       	subi	r24, 0xFF	; 255
    22a2:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22a6:	df 91       	pop	r29
    22a8:	cf 91       	pop	r28
    22aa:	1f 91       	pop	r17
    22ac:	0f 91       	pop	r16
    22ae:	ff 90       	pop	r15
    22b0:	08 95       	ret

000022b2 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22b2:	cf 92       	push	r12
    22b4:	df 92       	push	r13
    22b6:	ef 92       	push	r14
    22b8:	ff 92       	push	r15
    22ba:	0f 93       	push	r16
    22bc:	1f 93       	push	r17
    22be:	cf 93       	push	r28
    22c0:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    22c2:	0f b6       	in	r0, 0x3f	; 63
    22c4:	f8 94       	cli
    22c6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    22c8:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    22cc:	81 50       	subi	r24, 0x01	; 1
    22ce:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22d2:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    22d6:	81 11       	cpse	r24, r1
    22d8:	60 c0       	rjmp	.+192    	; 0x239a <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    22da:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    22de:	81 11       	cpse	r24, r1
    22e0:	2c c0       	rjmp	.+88     	; 0x233a <xTaskResumeAll+0x88>
    22e2:	5e c0       	rjmp	.+188    	; 0x23a0 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    22e4:	d7 01       	movw	r26, r14
    22e6:	17 96       	adiw	r26, 0x07	; 7
    22e8:	ed 91       	ld	r30, X+
    22ea:	fc 91       	ld	r31, X
    22ec:	18 97       	sbiw	r26, 0x08	; 8
    22ee:	c0 85       	ldd	r28, Z+8	; 0x08
    22f0:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    22f2:	ce 01       	movw	r24, r28
    22f4:	0e 96       	adiw	r24, 0x0e	; 14
    22f6:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    22fa:	8e 01       	movw	r16, r28
    22fc:	0e 5f       	subi	r16, 0xFE	; 254
    22fe:	1f 4f       	sbci	r17, 0xFF	; 255
    2300:	c8 01       	movw	r24, r16
    2302:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2306:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2308:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    230c:	98 17       	cp	r25, r24
    230e:	10 f4       	brcc	.+4      	; 0x2314 <xTaskResumeAll+0x62>
    2310:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    2314:	d8 9e       	mul	r13, r24
    2316:	c0 01       	movw	r24, r0
    2318:	11 24       	eor	r1, r1
    231a:	b8 01       	movw	r22, r16
    231c:	8a 5f       	subi	r24, 0xFA	; 250
    231e:	9e 4c       	sbci	r25, 0xCE	; 206
    2320:	0e 94 08 0a 	call	0x1410	; 0x1410 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2324:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    2328:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    232c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    232e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2330:	98 17       	cp	r25, r24
    2332:	70 f0       	brcs	.+28     	; 0x2350 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2334:	cc 24       	eor	r12, r12
    2336:	c3 94       	inc	r12
    2338:	0b c0       	rjmp	.+22     	; 0x2350 <xTaskResumeAll+0x9e>
    233a:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    233c:	0f 2e       	mov	r0, r31
    233e:	f1 ee       	ldi	r31, 0xE1	; 225
    2340:	ef 2e       	mov	r14, r31
    2342:	f0 e3       	ldi	r31, 0x30	; 48
    2344:	ff 2e       	mov	r15, r31
    2346:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2348:	0f 2e       	mov	r0, r31
    234a:	fb e0       	ldi	r31, 0x0B	; 11
    234c:	df 2e       	mov	r13, r31
    234e:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2350:	f7 01       	movw	r30, r14
    2352:	80 81       	ld	r24, Z
    2354:	81 11       	cpse	r24, r1
    2356:	c6 cf       	rjmp	.-116    	; 0x22e4 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2358:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    235c:	88 23       	and	r24, r24
    235e:	81 f0       	breq	.+32     	; 0x2380 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2360:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    2364:	88 23       	and	r24, r24
    2366:	99 f0       	breq	.+38     	; 0x238e <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2368:	0e 94 58 10 	call	0x20b0	; 0x20b0 <vTaskIncrementTick>
						--uxMissedTicks;
    236c:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    2370:	81 50       	subi	r24, 0x01	; 1
    2372:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2376:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    237a:	81 11       	cpse	r24, r1
    237c:	f5 cf       	rjmp	.-22     	; 0x2368 <xTaskResumeAll+0xb6>
    237e:	07 c0       	rjmp	.+14     	; 0x238e <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2380:	f1 e0       	ldi	r31, 0x01	; 1
    2382:	cf 16       	cp	r12, r31
    2384:	21 f0       	breq	.+8      	; 0x238e <xTaskResumeAll+0xdc>
    2386:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <xMissedYield>
    238a:	81 30       	cpi	r24, 0x01	; 1
    238c:	41 f4       	brne	.+16     	; 0x239e <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    238e:	10 92 d4 30 	sts	0x30D4, r1	; 0x8030d4 <xMissedYield>
					portYIELD_WITHIN_API();
    2392:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	03 c0       	rjmp	.+6      	; 0x23a0 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    239a:	80 e0       	ldi	r24, 0x00	; 0
    239c:	01 c0       	rjmp	.+2      	; 0x23a0 <xTaskResumeAll+0xee>
    239e:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23a0:	0f 90       	pop	r0
    23a2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23a4:	df 91       	pop	r29
    23a6:	cf 91       	pop	r28
    23a8:	1f 91       	pop	r17
    23aa:	0f 91       	pop	r16
    23ac:	ff 90       	pop	r15
    23ae:	ef 90       	pop	r14
    23b0:	df 90       	pop	r13
    23b2:	cf 90       	pop	r12
    23b4:	08 95       	ret

000023b6 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    23b6:	cf 92       	push	r12
    23b8:	df 92       	push	r13
    23ba:	ef 92       	push	r14
    23bc:	ff 92       	push	r15
    23be:	cf 93       	push	r28
    23c0:	df 93       	push	r29
    23c2:	ec 01       	movw	r28, r24
    23c4:	6a 01       	movw	r12, r20
    23c6:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    23c8:	0e 94 37 10 	call	0x206e	; 0x206e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    23cc:	88 81       	ld	r24, Y
    23ce:	99 81       	ldd	r25, Y+1	; 0x01
    23d0:	aa 81       	ldd	r26, Y+2	; 0x02
    23d2:	bb 81       	ldd	r27, Y+3	; 0x03
    23d4:	c8 0e       	add	r12, r24
    23d6:	d9 1e       	adc	r13, r25
    23d8:	ea 1e       	adc	r14, r26
    23da:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    23dc:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    23e0:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    23e4:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    23e8:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    23ec:	48 17       	cp	r20, r24
    23ee:	59 07       	cpc	r21, r25
    23f0:	6a 07       	cpc	r22, r26
    23f2:	7b 07       	cpc	r23, r27
    23f4:	b8 f4       	brcc	.+46     	; 0x2424 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    23f6:	c8 16       	cp	r12, r24
    23f8:	d9 06       	cpc	r13, r25
    23fa:	ea 06       	cpc	r14, r26
    23fc:	fb 06       	cpc	r15, r27
    23fe:	e0 f5       	brcc	.+120    	; 0x2478 <vTaskDelayUntil+0xc2>
    2400:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    2404:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2408:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    240c:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2410:	c8 82       	st	Y, r12
    2412:	d9 82       	std	Y+1, r13	; 0x01
    2414:	ea 82       	std	Y+2, r14	; 0x02
    2416:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2418:	8c 15       	cp	r24, r12
    241a:	9d 05       	cpc	r25, r13
    241c:	ae 05       	cpc	r26, r14
    241e:	bf 05       	cpc	r27, r15
    2420:	f8 f4       	brcc	.+62     	; 0x2460 <vTaskDelayUntil+0xaa>
    2422:	13 c0       	rjmp	.+38     	; 0x244a <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2424:	c8 16       	cp	r12, r24
    2426:	d9 06       	cpc	r13, r25
    2428:	ea 06       	cpc	r14, r26
    242a:	fb 06       	cpc	r15, r27
    242c:	00 f1       	brcs	.+64     	; 0x246e <vTaskDelayUntil+0xb8>
    242e:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    2432:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2436:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    243a:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    243e:	8c 15       	cp	r24, r12
    2440:	9d 05       	cpc	r25, r13
    2442:	ae 05       	cpc	r26, r14
    2444:	bf 05       	cpc	r27, r15
    2446:	98 f0       	brcs	.+38     	; 0x246e <vTaskDelayUntil+0xb8>
    2448:	17 c0       	rjmp	.+46     	; 0x2478 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    244a:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    244e:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2452:	02 96       	adiw	r24, 0x02	; 2
    2454:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2458:	c7 01       	movw	r24, r14
    245a:	b6 01       	movw	r22, r12
    245c:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2460:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2464:	81 11       	cpse	r24, r1
    2466:	0d c0       	rjmp	.+26     	; 0x2482 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2468:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
		}
	}
    246c:	0a c0       	rjmp	.+20     	; 0x2482 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    246e:	c8 82       	st	Y, r12
    2470:	d9 82       	std	Y+1, r13	; 0x01
    2472:	ea 82       	std	Y+2, r14	; 0x02
    2474:	fb 82       	std	Y+3, r15	; 0x03
    2476:	e9 cf       	rjmp	.-46     	; 0x244a <vTaskDelayUntil+0x94>
    2478:	c8 82       	st	Y, r12
    247a:	d9 82       	std	Y+1, r13	; 0x01
    247c:	ea 82       	std	Y+2, r14	; 0x02
    247e:	fb 82       	std	Y+3, r15	; 0x03
    2480:	ef cf       	rjmp	.-34     	; 0x2460 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2482:	df 91       	pop	r29
    2484:	cf 91       	pop	r28
    2486:	ff 90       	pop	r15
    2488:	ef 90       	pop	r14
    248a:	df 90       	pop	r13
    248c:	cf 90       	pop	r12
    248e:	08 95       	ret

00002490 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2490:	cf 92       	push	r12
    2492:	df 92       	push	r13
    2494:	ef 92       	push	r14
    2496:	ff 92       	push	r15
    2498:	6b 01       	movw	r12, r22
    249a:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    249c:	67 2b       	or	r22, r23
    249e:	68 2b       	or	r22, r24
    24a0:	69 2b       	or	r22, r25
    24a2:	e9 f0       	breq	.+58     	; 0x24de <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    24a4:	0e 94 37 10 	call	0x206e	; 0x206e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24a8:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    24ac:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    24b0:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    24b4:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    24b8:	c8 0e       	add	r12, r24
    24ba:	d9 1e       	adc	r13, r25
    24bc:	ea 1e       	adc	r14, r26
    24be:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24c0:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    24c4:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    24c8:	02 96       	adiw	r24, 0x02	; 2
    24ca:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24ce:	c7 01       	movw	r24, r14
    24d0:	b6 01       	movw	r22, r12
    24d2:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    24d6:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24da:	81 11       	cpse	r24, r1
    24dc:	02 c0       	rjmp	.+4      	; 0x24e2 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    24de:	0e 94 56 0b 	call	0x16ac	; 0x16ac <vPortYield>
		}
	}
    24e2:	ff 90       	pop	r15
    24e4:	ef 90       	pop	r14
    24e6:	df 90       	pop	r13
    24e8:	cf 90       	pop	r12
    24ea:	08 95       	ret

000024ec <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    24ec:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    24f0:	81 11       	cpse	r24, r1
    24f2:	0c c0       	rjmp	.+24     	; 0x250c <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    24f4:	e0 91 d8 30 	lds	r30, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    24f8:	4b e0       	ldi	r20, 0x0B	; 11
    24fa:	e4 9f       	mul	r30, r20
    24fc:	f0 01       	movw	r30, r0
    24fe:	11 24       	eor	r1, r1
    2500:	ea 5f       	subi	r30, 0xFA	; 250
    2502:	fe 4c       	sbci	r31, 0xCE	; 206
    2504:	80 81       	ld	r24, Z
    2506:	88 23       	and	r24, r24
    2508:	29 f0       	breq	.+10     	; 0x2514 <vTaskSwitchContext+0x28>
    250a:	14 c0       	rjmp	.+40     	; 0x2534 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    250c:	81 e0       	ldi	r24, 0x01	; 1
    250e:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <xMissedYield>
    2512:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2514:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2516:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    251a:	81 50       	subi	r24, 0x01	; 1
    251c:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2520:	e0 91 d8 30 	lds	r30, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2524:	9e 9f       	mul	r25, r30
    2526:	f0 01       	movw	r30, r0
    2528:	11 24       	eor	r1, r1
    252a:	ea 5f       	subi	r30, 0xFA	; 250
    252c:	fe 4c       	sbci	r31, 0xCE	; 206
    252e:	80 81       	ld	r24, Z
    2530:	88 23       	and	r24, r24
    2532:	89 f3       	breq	.-30     	; 0x2516 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2534:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2538:	28 2f       	mov	r18, r24
    253a:	30 e0       	ldi	r19, 0x00	; 0
    253c:	4b e0       	ldi	r20, 0x0B	; 11
    253e:	84 9f       	mul	r24, r20
    2540:	c0 01       	movw	r24, r0
    2542:	11 24       	eor	r1, r1
    2544:	dc 01       	movw	r26, r24
    2546:	aa 5f       	subi	r26, 0xFA	; 250
    2548:	be 4c       	sbci	r27, 0xCE	; 206
    254a:	11 96       	adiw	r26, 0x01	; 1
    254c:	ed 91       	ld	r30, X+
    254e:	fc 91       	ld	r31, X
    2550:	12 97       	sbiw	r26, 0x02	; 2
    2552:	04 80       	ldd	r0, Z+4	; 0x04
    2554:	f5 81       	ldd	r31, Z+5	; 0x05
    2556:	e0 2d       	mov	r30, r0
    2558:	11 96       	adiw	r26, 0x01	; 1
    255a:	ed 93       	st	X+, r30
    255c:	fc 93       	st	X, r31
    255e:	12 97       	sbiw	r26, 0x02	; 2
    2560:	87 5f       	subi	r24, 0xF7	; 247
    2562:	9e 4c       	sbci	r25, 0xCE	; 206
    2564:	e8 17       	cp	r30, r24
    2566:	f9 07       	cpc	r31, r25
    2568:	61 f4       	brne	.+24     	; 0x2582 <vTaskSwitchContext+0x96>
    256a:	84 81       	ldd	r24, Z+4	; 0x04
    256c:	95 81       	ldd	r25, Z+5	; 0x05
    256e:	4b e0       	ldi	r20, 0x0B	; 11
    2570:	42 9f       	mul	r20, r18
    2572:	f0 01       	movw	r30, r0
    2574:	43 9f       	mul	r20, r19
    2576:	f0 0d       	add	r31, r0
    2578:	11 24       	eor	r1, r1
    257a:	ea 5f       	subi	r30, 0xFA	; 250
    257c:	fe 4c       	sbci	r31, 0xCE	; 206
    257e:	81 83       	std	Z+1, r24	; 0x01
    2580:	92 83       	std	Z+2, r25	; 0x02
    2582:	8b e0       	ldi	r24, 0x0B	; 11
    2584:	82 9f       	mul	r24, r18
    2586:	f0 01       	movw	r30, r0
    2588:	83 9f       	mul	r24, r19
    258a:	f0 0d       	add	r31, r0
    258c:	11 24       	eor	r1, r1
    258e:	ea 5f       	subi	r30, 0xFA	; 250
    2590:	fe 4c       	sbci	r31, 0xCE	; 206
    2592:	01 80       	ldd	r0, Z+1	; 0x01
    2594:	f2 81       	ldd	r31, Z+2	; 0x02
    2596:	e0 2d       	mov	r30, r0
    2598:	80 85       	ldd	r24, Z+8	; 0x08
    259a:	91 85       	ldd	r25, Z+9	; 0x09
    259c:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <pxCurrentTCB>
    25a0:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <pxCurrentTCB+0x1>
    25a4:	08 95       	ret

000025a6 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25a6:	cf 92       	push	r12
    25a8:	df 92       	push	r13
    25aa:	ef 92       	push	r14
    25ac:	ff 92       	push	r15
    25ae:	6a 01       	movw	r12, r20
    25b0:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25b2:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    25b6:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    25ba:	62 5f       	subi	r22, 0xF2	; 242
    25bc:	7f 4f       	sbci	r23, 0xFF	; 255
    25be:	0e 94 2f 0a 	call	0x145e	; 0x145e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25c2:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    25c6:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    25ca:	02 96       	adiw	r24, 0x02	; 2
    25cc:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    25d0:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    25d4:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    25d8:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    25dc:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    25e0:	bc 01       	movw	r22, r24
    25e2:	cd 01       	movw	r24, r26
    25e4:	6c 0d       	add	r22, r12
    25e6:	7d 1d       	adc	r23, r13
    25e8:	8e 1d       	adc	r24, r14
    25ea:	9f 1d       	adc	r25, r15
    25ec:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    25f0:	ff 90       	pop	r15
    25f2:	ef 90       	pop	r14
    25f4:	df 90       	pop	r13
    25f6:	cf 90       	pop	r12
    25f8:	08 95       	ret

000025fa <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    25fa:	0f 93       	push	r16
    25fc:	1f 93       	push	r17
    25fe:	cf 93       	push	r28
    2600:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2602:	dc 01       	movw	r26, r24
    2604:	17 96       	adiw	r26, 0x07	; 7
    2606:	ed 91       	ld	r30, X+
    2608:	fc 91       	ld	r31, X
    260a:	18 97       	sbiw	r26, 0x08	; 8
    260c:	c0 85       	ldd	r28, Z+8	; 0x08
    260e:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2610:	8e 01       	movw	r16, r28
    2612:	02 5f       	subi	r16, 0xF2	; 242
    2614:	1f 4f       	sbci	r17, 0xFF	; 255
    2616:	c8 01       	movw	r24, r16
    2618:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    261c:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    2620:	81 11       	cpse	r24, r1
    2622:	16 c0       	rjmp	.+44     	; 0x2650 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2624:	0c 50       	subi	r16, 0x0C	; 12
    2626:	11 09       	sbc	r17, r1
    2628:	c8 01       	movw	r24, r16
    262a:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    262e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2630:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2634:	98 17       	cp	r25, r24
    2636:	10 f4       	brcc	.+4      	; 0x263c <xTaskRemoveFromEventList+0x42>
    2638:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    263c:	bb e0       	ldi	r27, 0x0B	; 11
    263e:	8b 9f       	mul	r24, r27
    2640:	c0 01       	movw	r24, r0
    2642:	11 24       	eor	r1, r1
    2644:	b8 01       	movw	r22, r16
    2646:	8a 5f       	subi	r24, 0xFA	; 250
    2648:	9e 4c       	sbci	r25, 0xCE	; 206
    264a:	0e 94 08 0a 	call	0x1410	; 0x1410 <vListInsertEnd>
    264e:	05 c0       	rjmp	.+10     	; 0x265a <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2650:	b8 01       	movw	r22, r16
    2652:	81 ee       	ldi	r24, 0xE1	; 225
    2654:	90 e3       	ldi	r25, 0x30	; 48
    2656:	0e 94 08 0a 	call	0x1410	; 0x1410 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    265a:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    265e:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2666:	92 8d       	ldd	r25, Z+26	; 0x1a
    2668:	29 17       	cp	r18, r25
    266a:	08 f4       	brcc	.+2      	; 0x266e <xTaskRemoveFromEventList+0x74>
    266c:	80 e0       	ldi	r24, 0x00	; 0
}
    266e:	df 91       	pop	r29
    2670:	cf 91       	pop	r28
    2672:	1f 91       	pop	r17
    2674:	0f 91       	pop	r16
    2676:	08 95       	ret

00002678 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2678:	20 91 d3 30 	lds	r18, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    267c:	fc 01       	movw	r30, r24
    267e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2680:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    2684:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    2688:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    268c:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2690:	41 83       	std	Z+1, r20	; 0x01
    2692:	52 83       	std	Z+2, r21	; 0x02
    2694:	63 83       	std	Z+3, r22	; 0x03
    2696:	74 83       	std	Z+4, r23	; 0x04
    2698:	08 95       	ret

0000269a <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    269a:	8f 92       	push	r8
    269c:	9f 92       	push	r9
    269e:	af 92       	push	r10
    26a0:	bf 92       	push	r11
    26a2:	cf 92       	push	r12
    26a4:	df 92       	push	r13
    26a6:	ef 92       	push	r14
    26a8:	ff 92       	push	r15
    26aa:	0f 93       	push	r16
    26ac:	1f 93       	push	r17
    26ae:	cf 93       	push	r28
    26b0:	df 93       	push	r29
    26b2:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26b4:	0f b6       	in	r0, 0x3f	; 63
    26b6:	f8 94       	cli
    26b8:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26ba:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    26be:	90 81       	ld	r25, Z
    26c0:	98 17       	cp	r25, r24
    26c2:	89 f0       	breq	.+34     	; 0x26e6 <xTaskCheckForTimeOut+0x4c>
    26c4:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    26c8:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    26cc:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    26d0:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    26d4:	01 81       	ldd	r16, Z+1	; 0x01
    26d6:	12 81       	ldd	r17, Z+2	; 0x02
    26d8:	23 81       	ldd	r18, Z+3	; 0x03
    26da:	34 81       	ldd	r19, Z+4	; 0x04
    26dc:	80 17       	cp	r24, r16
    26de:	91 07       	cpc	r25, r17
    26e0:	a2 07       	cpc	r26, r18
    26e2:	b3 07       	cpc	r27, r19
    26e4:	a8 f5       	brcc	.+106    	; 0x2750 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    26e6:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    26ea:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    26ee:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    26f2:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    26f6:	c1 80       	ldd	r12, Z+1	; 0x01
    26f8:	d2 80       	ldd	r13, Z+2	; 0x02
    26fa:	e3 80       	ldd	r14, Z+3	; 0x03
    26fc:	f4 80       	ldd	r15, Z+4	; 0x04
    26fe:	eb 01       	movw	r28, r22
    2700:	08 81       	ld	r16, Y
    2702:	19 81       	ldd	r17, Y+1	; 0x01
    2704:	2a 81       	ldd	r18, Y+2	; 0x02
    2706:	3b 81       	ldd	r19, Y+3	; 0x03
    2708:	8c 19       	sub	r24, r12
    270a:	9d 09       	sbc	r25, r13
    270c:	ae 09       	sbc	r26, r14
    270e:	bf 09       	sbc	r27, r15
    2710:	80 17       	cp	r24, r16
    2712:	91 07       	cpc	r25, r17
    2714:	a2 07       	cpc	r26, r18
    2716:	b3 07       	cpc	r27, r19
    2718:	e8 f4       	brcc	.+58     	; 0x2754 <xTaskCheckForTimeOut+0xba>
    271a:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    271c:	80 90 da 30 	lds	r8, 0x30DA	; 0x8030da <xTickCount>
    2720:	90 90 db 30 	lds	r9, 0x30DB	; 0x8030db <xTickCount+0x1>
    2724:	a0 90 dc 30 	lds	r10, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2728:	b0 90 dd 30 	lds	r11, 0x30DD	; 0x8030dd <xTickCount+0x3>
    272c:	b5 01       	movw	r22, r10
    272e:	a4 01       	movw	r20, r8
    2730:	4c 19       	sub	r20, r12
    2732:	5d 09       	sbc	r21, r13
    2734:	6e 09       	sbc	r22, r14
    2736:	7f 09       	sbc	r23, r15
    2738:	04 1b       	sub	r16, r20
    273a:	15 0b       	sbc	r17, r21
    273c:	26 0b       	sbc	r18, r22
    273e:	37 0b       	sbc	r19, r23
    2740:	08 83       	st	Y, r16
    2742:	19 83       	std	Y+1, r17	; 0x01
    2744:	2a 83       	std	Y+2, r18	; 0x02
    2746:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2748:	0e 94 3c 13 	call	0x2678	; 0x2678 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    274c:	80 e0       	ldi	r24, 0x00	; 0
    274e:	03 c0       	rjmp	.+6      	; 0x2756 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2750:	81 e0       	ldi	r24, 0x01	; 1
    2752:	01 c0       	rjmp	.+2      	; 0x2756 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2754:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2756:	0f 90       	pop	r0
    2758:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    275a:	df 91       	pop	r29
    275c:	cf 91       	pop	r28
    275e:	1f 91       	pop	r17
    2760:	0f 91       	pop	r16
    2762:	ff 90       	pop	r15
    2764:	ef 90       	pop	r14
    2766:	df 90       	pop	r13
    2768:	cf 90       	pop	r12
    276a:	bf 90       	pop	r11
    276c:	af 90       	pop	r10
    276e:	9f 90       	pop	r9
    2770:	8f 90       	pop	r8
    2772:	08 95       	ret

00002774 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2774:	81 e0       	ldi	r24, 0x01	; 1
    2776:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <xMissedYield>
    277a:	08 95       	ret

0000277c <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    277c:	00 97       	sbiw	r24, 0x00	; 0
    277e:	21 f4       	brne	.+8      	; 0x2788 <uxTaskGetStackHighWaterMark+0xc>
    2780:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    2784:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2788:	dc 01       	movw	r26, r24
    278a:	5b 96       	adiw	r26, 0x1b	; 27
    278c:	ed 91       	ld	r30, X+
    278e:	fc 91       	ld	r31, X
    2790:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2792:	80 81       	ld	r24, Z
    2794:	81 31       	cpi	r24, 0x11	; 17
    2796:	41 f4       	brne	.+16     	; 0x27a8 <uxTaskGetStackHighWaterMark+0x2c>
    2798:	31 96       	adiw	r30, 0x01	; 1
    279a:	80 e0       	ldi	r24, 0x00	; 0
    279c:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    279e:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27a0:	21 91       	ld	r18, Z+
    27a2:	21 31       	cpi	r18, 0x11	; 17
    27a4:	e1 f3       	breq	.-8      	; 0x279e <uxTaskGetStackHighWaterMark+0x22>
    27a6:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27a8:	80 e0       	ldi	r24, 0x00	; 0
    27aa:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27ac:	08 95       	ret

000027ae <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27ae:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    27b2:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>

		return xReturn;
	}
    27b6:	08 95       	ret

000027b8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27b8:	0f 93       	push	r16
    27ba:	1f 93       	push	r17
    27bc:	cf 93       	push	r28
    27be:	df 93       	push	r29
    27c0:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    27c2:	22 8d       	ldd	r18, Z+26	; 0x1a
    27c4:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    27c8:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    27cc:	5a 96       	adiw	r26, 0x1a	; 26
    27ce:	8c 91       	ld	r24, X
    27d0:	28 17       	cp	r18, r24
    27d2:	08 f0       	brcs	.+2      	; 0x27d6 <vTaskPriorityInherit+0x1e>
    27d4:	41 c0       	rjmp	.+130    	; 0x2858 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    27d6:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    27da:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    27de:	5a 96       	adiw	r26, 0x1a	; 26
    27e0:	3c 91       	ld	r19, X
    27e2:	84 e0       	ldi	r24, 0x04	; 4
    27e4:	90 e0       	ldi	r25, 0x00	; 0
    27e6:	a0 e0       	ldi	r26, 0x00	; 0
    27e8:	b0 e0       	ldi	r27, 0x00	; 0
    27ea:	83 1b       	sub	r24, r19
    27ec:	91 09       	sbc	r25, r1
    27ee:	a1 09       	sbc	r26, r1
    27f0:	b1 09       	sbc	r27, r1
    27f2:	86 87       	std	Z+14, r24	; 0x0e
    27f4:	97 87       	std	Z+15, r25	; 0x0f
    27f6:	a0 8b       	std	Z+16, r26	; 0x10
    27f8:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    27fa:	8b e0       	ldi	r24, 0x0B	; 11
    27fc:	28 9f       	mul	r18, r24
    27fe:	90 01       	movw	r18, r0
    2800:	11 24       	eor	r1, r1
    2802:	2a 5f       	subi	r18, 0xFA	; 250
    2804:	3e 4c       	sbci	r19, 0xCE	; 206
    2806:	84 85       	ldd	r24, Z+12	; 0x0c
    2808:	95 85       	ldd	r25, Z+13	; 0x0d
    280a:	82 17       	cp	r24, r18
    280c:	93 07       	cpc	r25, r19
    280e:	e9 f4       	brne	.+58     	; 0x284a <vTaskPriorityInherit+0x92>
    2810:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2812:	ef 01       	movw	r28, r30
    2814:	22 96       	adiw	r28, 0x02	; 2
    2816:	ce 01       	movw	r24, r28
    2818:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    281c:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    2820:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2824:	82 8d       	ldd	r24, Z+26	; 0x1a
    2826:	f8 01       	movw	r30, r16
    2828:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    282a:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    282e:	98 17       	cp	r25, r24
    2830:	10 f4       	brcc	.+4      	; 0x2836 <vTaskPriorityInherit+0x7e>
    2832:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    2836:	fb e0       	ldi	r31, 0x0B	; 11
    2838:	8f 9f       	mul	r24, r31
    283a:	c0 01       	movw	r24, r0
    283c:	11 24       	eor	r1, r1
    283e:	be 01       	movw	r22, r28
    2840:	8a 5f       	subi	r24, 0xFA	; 250
    2842:	9e 4c       	sbci	r25, 0xCE	; 206
    2844:	0e 94 08 0a 	call	0x1410	; 0x1410 <vListInsertEnd>
    2848:	07 c0       	rjmp	.+14     	; 0x2858 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    284a:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    284e:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2852:	5a 96       	adiw	r26, 0x1a	; 26
    2854:	8c 91       	ld	r24, X
    2856:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2858:	df 91       	pop	r29
    285a:	cf 91       	pop	r28
    285c:	1f 91       	pop	r17
    285e:	0f 91       	pop	r16
    2860:	08 95       	ret

00002862 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2862:	0f 93       	push	r16
    2864:	1f 93       	push	r17
    2866:	cf 93       	push	r28
    2868:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    286a:	00 97       	sbiw	r24, 0x00	; 0
    286c:	49 f1       	breq	.+82     	; 0x28c0 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    286e:	fc 01       	movw	r30, r24
    2870:	32 8d       	ldd	r19, Z+26	; 0x1a
    2872:	27 a1       	ldd	r18, Z+39	; 0x27
    2874:	32 17       	cp	r19, r18
    2876:	21 f1       	breq	.+72     	; 0x28c0 <vTaskPriorityDisinherit+0x5e>
    2878:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    287a:	8c 01       	movw	r16, r24
    287c:	0e 5f       	subi	r16, 0xFE	; 254
    287e:	1f 4f       	sbci	r17, 0xFF	; 255
    2880:	c8 01       	movw	r24, r16
    2882:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2886:	8f a1       	ldd	r24, Y+39	; 0x27
    2888:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    288a:	44 e0       	ldi	r20, 0x04	; 4
    288c:	50 e0       	ldi	r21, 0x00	; 0
    288e:	60 e0       	ldi	r22, 0x00	; 0
    2890:	70 e0       	ldi	r23, 0x00	; 0
    2892:	48 1b       	sub	r20, r24
    2894:	51 09       	sbc	r21, r1
    2896:	61 09       	sbc	r22, r1
    2898:	71 09       	sbc	r23, r1
    289a:	4e 87       	std	Y+14, r20	; 0x0e
    289c:	5f 87       	std	Y+15, r21	; 0x0f
    289e:	68 8b       	std	Y+16, r22	; 0x10
    28a0:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28a2:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    28a6:	98 17       	cp	r25, r24
    28a8:	10 f4       	brcc	.+4      	; 0x28ae <vTaskPriorityDisinherit+0x4c>
    28aa:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    28ae:	fb e0       	ldi	r31, 0x0B	; 11
    28b0:	8f 9f       	mul	r24, r31
    28b2:	c0 01       	movw	r24, r0
    28b4:	11 24       	eor	r1, r1
    28b6:	b8 01       	movw	r22, r16
    28b8:	8a 5f       	subi	r24, 0xFA	; 250
    28ba:	9e 4c       	sbci	r25, 0xCE	; 206
    28bc:	0e 94 08 0a 	call	0x1410	; 0x1410 <vListInsertEnd>
			}
		}
	}
    28c0:	df 91       	pop	r29
    28c2:	cf 91       	pop	r28
    28c4:	1f 91       	pop	r17
    28c6:	0f 91       	pop	r16
    28c8:	08 95       	ret

000028ca <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    28ca:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    28cc:	e8 81       	ld	r30, Y
    28ce:	f9 81       	ldd	r31, Y+1	; 0x01
    28d0:	01 90       	ld	r0, Z+
    28d2:	f0 81       	ld	r31, Z
    28d4:	e0 2d       	mov	r30, r0
    28d6:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    28d8:	1a 82       	std	Y+2, r1	; 0x02
    28da:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    28dc:	6f ef       	ldi	r22, 0xFF	; 255
    28de:	7f ef       	ldi	r23, 0xFF	; 255
    28e0:	cb 01       	movw	r24, r22
    28e2:	0e 94 48 12 	call	0x2490	; 0x2490 <vTaskDelay>
    28e6:	fa cf       	rjmp	.-12     	; 0x28dc <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000028e8 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    28e8:	fc 01       	movw	r30, r24
    28ea:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    28ec:	65 87       	std	Z+13, r22	; 0x0d
    28ee:	08 95       	ret

000028f0 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    28f0:	4f 92       	push	r4
    28f2:	5f 92       	push	r5
    28f4:	6f 92       	push	r6
    28f6:	7f 92       	push	r7
    28f8:	8f 92       	push	r8
    28fa:	9f 92       	push	r9
    28fc:	af 92       	push	r10
    28fe:	bf 92       	push	r11
    2900:	cf 92       	push	r12
    2902:	df 92       	push	r13
    2904:	ef 92       	push	r14
    2906:	ff 92       	push	r15
    2908:	0f 93       	push	r16
    290a:	1f 93       	push	r17
    290c:	cf 93       	push	r28
    290e:	df 93       	push	r29
    2910:	cd b7       	in	r28, 0x3d	; 61
    2912:	de b7       	in	r29, 0x3e	; 62
    2914:	2a 97       	sbiw	r28, 0x0a	; 10
    2916:	cd bf       	out	0x3d, r28	; 61
    2918:	de bf       	out	0x3e, r29	; 62
    291a:	4c 01       	movw	r8, r24
    291c:	29 01       	movw	r4, r18
    291e:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2920:	81 e5       	ldi	r24, 0x51	; 81
    2922:	90 e2       	ldi	r25, 0x20	; 32
    2924:	f4 01       	movw	r30, r8
    2926:	80 83       	st	Z, r24
    2928:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    292a:	fb 01       	movw	r30, r22
    292c:	80 81       	ld	r24, Z
    292e:	88 23       	and	r24, r24
    2930:	69 f0       	breq	.+26     	; 0x294c <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2932:	de 01       	movw	r26, r28
    2934:	11 96       	adiw	r26, 0x01	; 1
    2936:	31 96       	adiw	r30, 0x01	; 1
    2938:	90 e0       	ldi	r25, 0x00	; 0
    293a:	02 c0       	rjmp	.+4      	; 0x2940 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    293c:	99 30       	cpi	r25, 0x09	; 9
    293e:	39 f0       	breq	.+14     	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2940:	9f 5f       	subi	r25, 0xFF	; 255
    2942:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2944:	81 91       	ld	r24, Z+
    2946:	81 11       	cpse	r24, r1
    2948:	f9 cf       	rjmp	.-14     	; 0x293c <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    294a:	01 c0       	rjmp	.+2      	; 0x294e <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    294c:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    294e:	e1 e0       	ldi	r30, 0x01	; 1
    2950:	f0 e0       	ldi	r31, 0x00	; 0
    2952:	ec 0f       	add	r30, r28
    2954:	fd 1f       	adc	r31, r29
    2956:	e9 0f       	add	r30, r25
    2958:	f1 1d       	adc	r31, r1
    295a:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    295c:	74 01       	movw	r14, r8
    295e:	f2 e0       	ldi	r31, 0x02	; 2
    2960:	ef 0e       	add	r14, r31
    2962:	f1 1c       	adc	r15, r1
    2964:	a1 2c       	mov	r10, r1
    2966:	b1 2c       	mov	r11, r1
    2968:	c1 2c       	mov	r12, r1
    296a:	d1 2c       	mov	r13, r1
    296c:	04 2f       	mov	r16, r20
    296e:	94 01       	movw	r18, r8
    2970:	a2 01       	movw	r20, r4
    2972:	be 01       	movw	r22, r28
    2974:	6f 5f       	subi	r22, 0xFF	; 255
    2976:	7f 4f       	sbci	r23, 0xFF	; 255
    2978:	84 ea       	ldi	r24, 0xA4	; 164
    297a:	92 e0       	ldi	r25, 0x02	; 2
    297c:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2980:	f4 01       	movw	r30, r8
    2982:	66 82       	std	Z+6, r6	; 0x06
    2984:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2986:	40 86       	std	Z+8, r4	; 0x08
    2988:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    298a:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <last_created_task_pointer>
    298e:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    2992:	24 83       	std	Z+4, r18	; 0x04
    2994:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2996:	80 92 34 31 	sts	0x3134, r8	; 0x803134 <last_created_task_pointer>
    299a:	90 92 35 31 	sts	0x3135, r9	; 0x803135 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    299e:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29a0:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29a2:	40 90 76 31 	lds	r4, 0x3176	; 0x803176 <portStackTopForTask>
    29a6:	50 90 77 31 	lds	r5, 0x3177	; 0x803177 <portStackTopForTask+0x1>
    29aa:	ff ef       	ldi	r31, 0xFF	; 255
    29ac:	4f 1a       	sub	r4, r31
    29ae:	5f 0a       	sbc	r5, r31
    29b0:	40 92 76 31 	sts	0x3176, r4	; 0x803176 <portStackTopForTask>
    29b4:	50 92 77 31 	sts	0x3177, r5	; 0x803177 <portStackTopForTask+0x1>
    29b8:	f4 01       	movw	r30, r8
    29ba:	42 86       	std	Z+10, r4	; 0x0a
    29bc:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    29be:	16 86       	std	Z+14, r1	; 0x0e
    29c0:	17 86       	std	Z+15, r1	; 0x0f
    29c2:	10 8a       	std	Z+16, r1	; 0x10
    29c4:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    29c6:	61 14       	cp	r6, r1
    29c8:	71 04       	cpc	r7, r1
    29ca:	09 f4       	brne	.+2      	; 0x29ce <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    29cc:	44 c0       	rjmp	.+136    	; 0x2a56 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    29ce:	81 30       	cpi	r24, 0x01	; 1
    29d0:	79 f5       	brne	.+94     	; 0x2a30 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    29d2:	6a e0       	ldi	r22, 0x0A	; 10
    29d4:	c3 01       	movw	r24, r6
    29d6:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    29da:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    29dc:	65 e9       	ldi	r22, 0x95	; 149
    29de:	74 e0       	ldi	r23, 0x04	; 4
    29e0:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    29e4:	be 01       	movw	r22, r28
    29e6:	6f 5f       	subi	r22, 0xFF	; 255
    29e8:	7f 4f       	sbci	r23, 0xFF	; 255
    29ea:	c7 01       	movw	r24, r14
    29ec:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    29f0:	6a e0       	ldi	r22, 0x0A	; 10
    29f2:	c7 01       	movw	r24, r14
    29f4:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    29f8:	7c 01       	movw	r14, r24
    29fa:	6c e8       	ldi	r22, 0x8C	; 140
    29fc:	74 e0       	ldi	r23, 0x04	; 4
    29fe:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a02:	6a e0       	ldi	r22, 0x0A	; 10
    2a04:	c7 01       	movw	r24, r14
    2a06:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2a0a:	7c 01       	movw	r14, r24
    2a0c:	6e e7       	ldi	r22, 0x7E	; 126
    2a0e:	74 e0       	ldi	r23, 0x04	; 4
    2a10:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2a14:	63 e0       	ldi	r22, 0x03	; 3
    2a16:	c7 01       	movw	r24, r14
    2a18:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2a1c:	b2 01       	movw	r22, r4
    2a1e:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <_ZN8emstreamlsEj>
    2a22:	62 e0       	ldi	r22, 0x02	; 2
    2a24:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2a28:	66 e0       	ldi	r22, 0x06	; 6
    2a2a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2a2e:	13 c0       	rjmp	.+38     	; 0x2a56 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a30:	6a e0       	ldi	r22, 0x0A	; 10
    2a32:	c3 01       	movw	r24, r6
    2a34:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2a38:	4c 01       	movw	r8, r24
    2a3a:	69 e6       	ldi	r22, 0x69	; 105
    2a3c:	74 e0       	ldi	r23, 0x04	; 4
    2a3e:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2a42:	be 01       	movw	r22, r28
    2a44:	6f 5f       	subi	r22, 0xFF	; 255
    2a46:	7f 4f       	sbci	r23, 0xFF	; 255
    2a48:	c4 01       	movw	r24, r8
    2a4a:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2a4e:	66 e0       	ldi	r22, 0x06	; 6
    2a50:	c4 01       	movw	r24, r8
    2a52:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a56:	2a 96       	adiw	r28, 0x0a	; 10
    2a58:	cd bf       	out	0x3d, r28	; 61
    2a5a:	de bf       	out	0x3e, r29	; 62
    2a5c:	df 91       	pop	r29
    2a5e:	cf 91       	pop	r28
    2a60:	1f 91       	pop	r17
    2a62:	0f 91       	pop	r16
    2a64:	ff 90       	pop	r15
    2a66:	ef 90       	pop	r14
    2a68:	df 90       	pop	r13
    2a6a:	cf 90       	pop	r12
    2a6c:	bf 90       	pop	r11
    2a6e:	af 90       	pop	r10
    2a70:	9f 90       	pop	r9
    2a72:	8f 90       	pop	r8
    2a74:	7f 90       	pop	r7
    2a76:	6f 90       	pop	r6
    2a78:	5f 90       	pop	r5
    2a7a:	4f 90       	pop	r4
    2a7c:	08 95       	ret

00002a7e <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2a7e:	cf 92       	push	r12
    2a80:	df 92       	push	r13
    2a82:	ef 92       	push	r14
    2a84:	ff 92       	push	r15
    2a86:	0f 93       	push	r16
    2a88:	1f 93       	push	r17
    2a8a:	cf 93       	push	r28
    2a8c:	df 93       	push	r29
    2a8e:	ec 01       	movw	r28, r24
    2a90:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2a92:	8a 81       	ldd	r24, Y+2	; 0x02
    2a94:	9b 81       	ldd	r25, Y+3	; 0x03
    2a96:	0e 94 4b 10 	call	0x2096	; 0x2096 <pcTaskGetTaskName>
    2a9a:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2a9c:	6a e0       	ldi	r22, 0x0A	; 10
    2a9e:	c7 01       	movw	r24, r14
    2aa0:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2aa4:	8c 01       	movw	r16, r24
    2aa6:	68 ea       	ldi	r22, 0xA8	; 168
    2aa8:	74 e0       	ldi	r23, 0x04	; 4
    2aaa:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2aae:	6a e0       	ldi	r22, 0x0A	; 10
    2ab0:	c8 01       	movw	r24, r16
    2ab2:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2ab6:	8c 01       	movw	r16, r24
    2ab8:	61 ea       	ldi	r22, 0xA1	; 161
    2aba:	74 e0       	ldi	r23, 0x04	; 4
    2abc:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2ac0:	b6 01       	movw	r22, r12
    2ac2:	c8 01       	movw	r24, r16
    2ac4:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2ac8:	6a e0       	ldi	r22, 0x0A	; 10
    2aca:	c8 01       	movw	r24, r16
    2acc:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2ad0:	8c 01       	movw	r16, r24
    2ad2:	6b e9       	ldi	r22, 0x9B	; 155
    2ad4:	74 e0       	ldi	r23, 0x04	; 4
    2ad6:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2ada:	66 e0       	ldi	r22, 0x06	; 6
    2adc:	c8 01       	movw	r24, r16
    2ade:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2ae2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ae4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ae6:	e8 85       	ldd	r30, Y+8	; 0x08
    2ae8:	f9 85       	ldd	r31, Y+9	; 0x09
    2aea:	01 e1       	ldi	r16, 0x11	; 17
    2aec:	21 e0       	ldi	r18, 0x01	; 1
    2aee:	a7 01       	movw	r20, r14
    2af0:	bc 01       	movw	r22, r24
    2af2:	8e 1b       	sub	r24, r30
    2af4:	9f 0b       	sbc	r25, r31
    2af6:	0e 94 41 18 	call	0x3082	; 0x3082 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2afa:	8c 81       	ldd	r24, Y+4	; 0x04
    2afc:	9d 81       	ldd	r25, Y+5	; 0x05
    2afe:	00 97       	sbiw	r24, 0x00	; 0
    2b00:	19 f0       	breq	.+6      	; 0x2b08 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b02:	b7 01       	movw	r22, r14
    2b04:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b08:	df 91       	pop	r29
    2b0a:	cf 91       	pop	r28
    2b0c:	1f 91       	pop	r17
    2b0e:	0f 91       	pop	r16
    2b10:	ff 90       	pop	r15
    2b12:	ef 90       	pop	r14
    2b14:	df 90       	pop	r13
    2b16:	cf 90       	pop	r12
    2b18:	08 95       	ret

00002b1a <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b1a:	0f 93       	push	r16
    2b1c:	1f 93       	push	r17
    2b1e:	cf 93       	push	r28
    2b20:	df 93       	push	r29
    2b22:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b24:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <last_created_task_pointer>
    2b28:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    2b2c:	00 97       	sbiw	r24, 0x00	; 0
    2b2e:	19 f0       	breq	.+6      	; 0x2b36 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b30:	be 01       	movw	r22, r28
    2b32:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b36:	6a e0       	ldi	r22, 0x0A	; 10
    2b38:	ce 01       	movw	r24, r28
    2b3a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2b3e:	8c 01       	movw	r16, r24
    2b40:	6e eb       	ldi	r22, 0xBE	; 190
    2b42:	74 e0       	ldi	r23, 0x04	; 4
    2b44:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2b48:	6a e0       	ldi	r22, 0x0A	; 10
    2b4a:	c8 01       	movw	r24, r16
    2b4c:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2b50:	8c 01       	movw	r16, r24
    2b52:	63 eb       	ldi	r22, 0xB3	; 179
    2b54:	74 e0       	ldi	r23, 0x04	; 4
    2b56:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2b5a:	6a e0       	ldi	r22, 0x0A	; 10
    2b5c:	c8 01       	movw	r24, r16
    2b5e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2b62:	8c 01       	movw	r16, r24
    2b64:	6d ea       	ldi	r22, 0xAD	; 173
    2b66:	74 e0       	ldi	r23, 0x04	; 4
    2b68:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2b6c:	66 e0       	ldi	r22, 0x06	; 6
    2b6e:	c8 01       	movw	r24, r16
    2b70:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2b74:	80 91 76 31 	lds	r24, 0x3176	; 0x803176 <portStackTopForTask>
    2b78:	90 91 77 31 	lds	r25, 0x3177	; 0x803177 <portStackTopForTask+0x1>
    2b7c:	bc 01       	movw	r22, r24
    2b7e:	6f 5f       	subi	r22, 0xFF	; 255
    2b80:	7f 4f       	sbci	r23, 0xFF	; 255
    2b82:	01 e1       	ldi	r16, 0x11	; 17
    2b84:	21 e0       	ldi	r18, 0x01	; 1
    2b86:	ae 01       	movw	r20, r28
    2b88:	83 56       	subi	r24, 0x63	; 99
    2b8a:	91 09       	sbc	r25, r1
    2b8c:	0e 94 41 18 	call	0x3082	; 0x3082 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2b90:	df 91       	pop	r29
    2b92:	cf 91       	pop	r28
    2b94:	1f 91       	pop	r17
    2b96:	0f 91       	pop	r16
    2b98:	08 95       	ret

00002b9a <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2b9a:	8f 92       	push	r8
    2b9c:	9f 92       	push	r9
    2b9e:	af 92       	push	r10
    2ba0:	bf 92       	push	r11
    2ba2:	cf 92       	push	r12
    2ba4:	df 92       	push	r13
    2ba6:	ef 92       	push	r14
    2ba8:	ff 92       	push	r15
    2baa:	0f 93       	push	r16
    2bac:	1f 93       	push	r17
    2bae:	cf 93       	push	r28
    2bb0:	df 93       	push	r29
    2bb2:	ec 01       	movw	r28, r24
    2bb4:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2bb6:	8a 81       	ldd	r24, Y+2	; 0x02
    2bb8:	9b 81       	ldd	r25, Y+3	; 0x03
    2bba:	0e 94 4b 10 	call	0x2096	; 0x2096 <pcTaskGetTaskName>
    2bbe:	bc 01       	movw	r22, r24
    2bc0:	c8 01       	movw	r24, r16
    2bc2:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2bc6:	d8 01       	movw	r26, r16
    2bc8:	ed 91       	ld	r30, X+
    2bca:	fc 91       	ld	r31, X
    2bcc:	02 80       	ldd	r0, Z+2	; 0x02
    2bce:	f3 81       	ldd	r31, Z+3	; 0x03
    2bd0:	e0 2d       	mov	r30, r0
    2bd2:	69 e0       	ldi	r22, 0x09	; 9
    2bd4:	c8 01       	movw	r24, r16
    2bd6:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2bd8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bda:	9b 81       	ldd	r25, Y+3	; 0x03
    2bdc:	0e 94 4b 10 	call	0x2096	; 0x2096 <pcTaskGetTaskName>
    2be0:	fc 01       	movw	r30, r24
    2be2:	01 90       	ld	r0, Z+
    2be4:	00 20       	and	r0, r0
    2be6:	e9 f7       	brne	.-6      	; 0x2be2 <_ZN8frt_task12print_statusER8emstream+0x48>
    2be8:	31 97       	sbiw	r30, 0x01	; 1
    2bea:	e8 1b       	sub	r30, r24
    2bec:	f9 0b       	sbc	r31, r25
    2bee:	38 97       	sbiw	r30, 0x08	; 8
    2bf0:	48 f4       	brcc	.+18     	; 0x2c04 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2bf2:	d8 01       	movw	r26, r16
    2bf4:	ed 91       	ld	r30, X+
    2bf6:	fc 91       	ld	r31, X
    2bf8:	02 80       	ldd	r0, Z+2	; 0x02
    2bfa:	f3 81       	ldd	r31, Z+3	; 0x03
    2bfc:	e0 2d       	mov	r30, r0
    2bfe:	69 e0       	ldi	r22, 0x09	; 9
    2c00:	c8 01       	movw	r24, r16
    2c02:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c04:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c06:	df 84       	ldd	r13, Y+15	; 0x0f
    2c08:	e8 88       	ldd	r14, Y+16	; 0x10
    2c0a:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c0c:	a8 84       	ldd	r10, Y+8	; 0x08
    2c0e:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c10:	8a 81       	ldd	r24, Y+2	; 0x02
    2c12:	9b 81       	ldd	r25, Y+3	; 0x03
    2c14:	0e 94 be 13 	call	0x277c	; 0x277c <uxTaskGetStackHighWaterMark>
    2c18:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c1a:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c20:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <uxTaskPriorityGet>
    2c24:	68 2f       	mov	r22, r24
    2c26:	c8 01       	movw	r24, r16
    2c28:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
    2c2c:	6a e0       	ldi	r22, 0x0A	; 10
    2c2e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2c32:	ec 01       	movw	r28, r24
    2c34:	63 e3       	ldi	r22, 0x33	; 51
    2c36:	75 e0       	ldi	r23, 0x05	; 5
    2c38:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c3c:	68 2d       	mov	r22, r8
    2c3e:	ce 01       	movw	r24, r28
    2c40:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c44:	6a e0       	ldi	r22, 0x0A	; 10
    2c46:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2c4a:	ec 01       	movw	r28, r24
    2c4c:	61 e3       	ldi	r22, 0x31	; 49
    2c4e:	75 e0       	ldi	r23, 0x05	; 5
    2c50:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2c54:	69 2d       	mov	r22, r9
    2c56:	ce 01       	movw	r24, r28
    2c58:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
    2c5c:	6a e0       	ldi	r22, 0x0A	; 10
    2c5e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2c62:	ec 01       	movw	r28, r24
    2c64:	6f e2       	ldi	r22, 0x2F	; 47
    2c66:	75 e0       	ldi	r23, 0x05	; 5
    2c68:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2c6c:	b5 01       	movw	r22, r10
    2c6e:	ce 01       	movw	r24, r28
    2c70:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <_ZN8emstreamlsEj>
    2c74:	6a e0       	ldi	r22, 0x0A	; 10
    2c76:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2c7a:	ec 01       	movw	r28, r24
    2c7c:	6d e2       	ldi	r22, 0x2D	; 45
    2c7e:	75 e0       	ldi	r23, 0x05	; 5
    2c80:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2c84:	6a e0       	ldi	r22, 0x0A	; 10
    2c86:	ce 01       	movw	r24, r28
    2c88:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2c8c:	ec 01       	movw	r28, r24
    2c8e:	6b e2       	ldi	r22, 0x2B	; 43
    2c90:	75 e0       	ldi	r23, 0x05	; 5
    2c92:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2c96:	b7 01       	movw	r22, r14
    2c98:	a6 01       	movw	r20, r12
    2c9a:	ce 01       	movw	r24, r28
    2c9c:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEm>
}
    2ca0:	df 91       	pop	r29
    2ca2:	cf 91       	pop	r28
    2ca4:	1f 91       	pop	r17
    2ca6:	0f 91       	pop	r16
    2ca8:	ff 90       	pop	r15
    2caa:	ef 90       	pop	r14
    2cac:	df 90       	pop	r13
    2cae:	cf 90       	pop	r12
    2cb0:	bf 90       	pop	r11
    2cb2:	af 90       	pop	r10
    2cb4:	9f 90       	pop	r9
    2cb6:	8f 90       	pop	r8
    2cb8:	08 95       	ret

00002cba <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2cba:	cf 93       	push	r28
    2cbc:	df 93       	push	r29
    2cbe:	ec 01       	movw	r28, r24
    2cc0:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2cc2:	db 01       	movw	r26, r22
    2cc4:	ed 91       	ld	r30, X+
    2cc6:	fc 91       	ld	r31, X
    2cc8:	02 80       	ldd	r0, Z+2	; 0x02
    2cca:	f3 81       	ldd	r31, Z+3	; 0x03
    2ccc:	e0 2d       	mov	r30, r0
    2cce:	be 01       	movw	r22, r28
    2cd0:	19 95       	eicall
	return (ser_dev);
}
    2cd2:	ce 01       	movw	r24, r28
    2cd4:	df 91       	pop	r29
    2cd6:	cf 91       	pop	r28
    2cd8:	08 95       	ret

00002cda <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2cda:	0f 93       	push	r16
    2cdc:	1f 93       	push	r17
    2cde:	cf 93       	push	r28
    2ce0:	df 93       	push	r29
    2ce2:	ec 01       	movw	r28, r24
    2ce4:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2ce6:	bc 01       	movw	r22, r24
    2ce8:	c8 01       	movw	r24, r16
    2cea:	0e 94 5d 16 	call	0x2cba	; 0x2cba <_ZlsR8emstreamR8frt_task>
    2cee:	66 e0       	ldi	r22, 0x06	; 6
    2cf0:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2cf4:	8c 81       	ldd	r24, Y+4	; 0x04
    2cf6:	9d 81       	ldd	r25, Y+5	; 0x05
    2cf8:	00 97       	sbiw	r24, 0x00	; 0
    2cfa:	19 f0       	breq	.+6      	; 0x2d02 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2cfc:	b8 01       	movw	r22, r16
    2cfe:	0e 94 6d 16 	call	0x2cda	; 0x2cda <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d02:	df 91       	pop	r29
    2d04:	cf 91       	pop	r28
    2d06:	1f 91       	pop	r17
    2d08:	0f 91       	pop	r16
    2d0a:	08 95       	ret

00002d0c <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d0c:	0f 93       	push	r16
    2d0e:	1f 93       	push	r17
    2d10:	cf 93       	push	r28
    2d12:	df 93       	push	r29
    2d14:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d16:	6a e0       	ldi	r22, 0x0A	; 10
    2d18:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2d1c:	8c 01       	movw	r16, r24
    2d1e:	60 e2       	ldi	r22, 0x20	; 32
    2d20:	75 e0       	ldi	r23, 0x05	; 5
    2d22:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d26:	6a e0       	ldi	r22, 0x0A	; 10
    2d28:	c8 01       	movw	r24, r16
    2d2a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2d2e:	8c 01       	movw	r16, r24
    2d30:	69 e1       	ldi	r22, 0x19	; 25
    2d32:	75 e0       	ldi	r23, 0x05	; 5
    2d34:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d38:	66 e0       	ldi	r22, 0x06	; 6
    2d3a:	c8 01       	movw	r24, r16
    2d3c:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d40:	6a e0       	ldi	r22, 0x0A	; 10
    2d42:	ce 01       	movw	r24, r28
    2d44:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2d48:	8c 01       	movw	r16, r24
    2d4a:	68 e0       	ldi	r22, 0x08	; 8
    2d4c:	75 e0       	ldi	r23, 0x05	; 5
    2d4e:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2d52:	6a e0       	ldi	r22, 0x0A	; 10
    2d54:	c8 01       	movw	r24, r16
    2d56:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2d5a:	8c 01       	movw	r16, r24
    2d5c:	6c ef       	ldi	r22, 0xFC	; 252
    2d5e:	74 e0       	ldi	r23, 0x04	; 4
    2d60:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2d64:	6a e0       	ldi	r22, 0x0A	; 10
    2d66:	c8 01       	movw	r24, r16
    2d68:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2d6c:	8c 01       	movw	r16, r24
    2d6e:	66 ef       	ldi	r22, 0xF6	; 246
    2d70:	74 e0       	ldi	r23, 0x04	; 4
    2d72:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2d76:	66 e0       	ldi	r22, 0x06	; 6
    2d78:	c8 01       	movw	r24, r16
    2d7a:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2d7e:	6a e0       	ldi	r22, 0x0A	; 10
    2d80:	ce 01       	movw	r24, r28
    2d82:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2d86:	8c 01       	movw	r16, r24
    2d88:	65 ee       	ldi	r22, 0xE5	; 229
    2d8a:	74 e0       	ldi	r23, 0x04	; 4
    2d8c:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2d90:	6a e0       	ldi	r22, 0x0A	; 10
    2d92:	c8 01       	movw	r24, r16
    2d94:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2d98:	8c 01       	movw	r16, r24
    2d9a:	69 ed       	ldi	r22, 0xD9	; 217
    2d9c:	74 e0       	ldi	r23, 0x04	; 4
    2d9e:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2da2:	6a e0       	ldi	r22, 0x0A	; 10
    2da4:	c8 01       	movw	r24, r16
    2da6:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2daa:	8c 01       	movw	r16, r24
    2dac:	63 ed       	ldi	r22, 0xD3	; 211
    2dae:	74 e0       	ldi	r23, 0x04	; 4
    2db0:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2db4:	66 e0       	ldi	r22, 0x06	; 6
    2db6:	c8 01       	movw	r24, r16
    2db8:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2dbc:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <last_created_task_pointer>
    2dc0:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    2dc4:	00 97       	sbiw	r24, 0x00	; 0
    2dc6:	19 f0       	breq	.+6      	; 0x2dce <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2dc8:	be 01       	movw	r22, r28
    2dca:	0e 94 6d 16 	call	0x2cda	; 0x2cda <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2dce:	0e 94 53 10 	call	0x20a6	; 0x20a6 <xTaskGetIdleTaskHandle>
    2dd2:	0e 94 be 13 	call	0x277c	; 0x277c <uxTaskGetStackHighWaterMark>
    2dd6:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2dd8:	6a e0       	ldi	r22, 0x0A	; 10
    2dda:	ce 01       	movw	r24, r28
    2ddc:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2de0:	ec 01       	movw	r28, r24
    2de2:	68 ec       	ldi	r22, 0xC8	; 200
    2de4:	74 e0       	ldi	r23, 0x04	; 4
    2de6:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2dea:	61 2f       	mov	r22, r17
    2dec:	ce 01       	movw	r24, r28
    2dee:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2df2:	6a e0       	ldi	r22, 0x0A	; 10
    2df4:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2df8:	ec 01       	movw	r28, r24
    2dfa:	66 ec       	ldi	r22, 0xC6	; 198
    2dfc:	74 e0       	ldi	r23, 0x04	; 4
    2dfe:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    2e02:	64 e6       	ldi	r22, 0x64	; 100
    2e04:	70 e0       	ldi	r23, 0x00	; 0
    2e06:	ce 01       	movw	r24, r28
    2e08:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <_ZN8emstreamlsEj>
    2e0c:	6a e0       	ldi	r22, 0x0A	; 10
    2e0e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    2e12:	ec 01       	movw	r28, r24
    2e14:	63 ec       	ldi	r22, 0xC3	; 195
    2e16:	74 e0       	ldi	r23, 0x04	; 4
    2e18:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e1c:	66 e0       	ldi	r22, 0x06	; 6
    2e1e:	ce 01       	movw	r24, r28
    2e20:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
}
    2e24:	df 91       	pop	r29
    2e26:	cf 91       	pop	r28
    2e28:	1f 91       	pop	r17
    2e2a:	0f 91       	pop	r16
    2e2c:	08 95       	ret

00002e2e <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e2e:	0f 93       	push	r16
    2e30:	cf 93       	push	r28
    2e32:	df 93       	push	r29
    2e34:	1f 92       	push	r1
    2e36:	cd b7       	in	r28, 0x3d	; 61
    2e38:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e3a:	00 e0       	ldi	r16, 0x00	; 0
    2e3c:	2f ef       	ldi	r18, 0xFF	; 255
    2e3e:	3f ef       	ldi	r19, 0xFF	; 255
    2e40:	a9 01       	movw	r20, r18
    2e42:	be 01       	movw	r22, r28
    2e44:	6f 5f       	subi	r22, 0xFF	; 255
    2e46:	7f 4f       	sbci	r23, 0xFF	; 255
    2e48:	fc 01       	movw	r30, r24
    2e4a:	80 85       	ldd	r24, Z+8	; 0x08
    2e4c:	91 85       	ldd	r25, Z+9	; 0x09
    2e4e:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <xQueueGenericReceive>
    2e52:	81 30       	cpi	r24, 0x01	; 1
    2e54:	19 f4       	brne	.+6      	; 0x2e5c <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e56:	89 81       	ldd	r24, Y+1	; 0x01
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	02 c0       	rjmp	.+4      	; 0x2e60 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2e5c:	8f ef       	ldi	r24, 0xFF	; 255
    2e5e:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2e60:	0f 90       	pop	r0
    2e62:	df 91       	pop	r29
    2e64:	cf 91       	pop	r28
    2e66:	0f 91       	pop	r16
    2e68:	08 95       	ret

00002e6a <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2e6a:	fc 01       	movw	r30, r24
    2e6c:	80 85       	ldd	r24, Z+8	; 0x08
    2e6e:	91 85       	ldd	r25, Z+9	; 0x09
    2e70:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxQueueMessagesWaiting>
    2e74:	91 e0       	ldi	r25, 0x01	; 1
    2e76:	81 11       	cpse	r24, r1
    2e78:	01 c0       	rjmp	.+2      	; 0x2e7c <_ZN14frt_text_queue14check_for_charEv+0x12>
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2e7c:	89 2f       	mov	r24, r25
    2e7e:	08 95       	ret

00002e80 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2e80:	0f 93       	push	r16
    2e82:	cf 93       	push	r28
    2e84:	df 93       	push	r29
    2e86:	1f 92       	push	r1
    2e88:	cd b7       	in	r28, 0x3d	; 61
    2e8a:	de b7       	in	r29, 0x3e	; 62
    2e8c:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2e8e:	fc 01       	movw	r30, r24
    2e90:	22 85       	ldd	r18, Z+10	; 0x0a
    2e92:	33 85       	ldd	r19, Z+11	; 0x0b
    2e94:	44 85       	ldd	r20, Z+12	; 0x0c
    2e96:	55 85       	ldd	r21, Z+13	; 0x0d
    2e98:	00 e0       	ldi	r16, 0x00	; 0
    2e9a:	be 01       	movw	r22, r28
    2e9c:	6f 5f       	subi	r22, 0xFF	; 255
    2e9e:	7f 4f       	sbci	r23, 0xFF	; 255
    2ea0:	80 85       	ldd	r24, Z+8	; 0x08
    2ea2:	91 85       	ldd	r25, Z+9	; 0x09
    2ea4:	0e 94 37 0d 	call	0x1a6e	; 0x1a6e <xQueueGenericSend>
    2ea8:	91 e0       	ldi	r25, 0x01	; 1
    2eaa:	81 11       	cpse	r24, r1
    2eac:	01 c0       	rjmp	.+2      	; 0x2eb0 <_ZN14frt_text_queue7putcharEc+0x30>
    2eae:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2eb0:	89 2f       	mov	r24, r25
    2eb2:	0f 90       	pop	r0
    2eb4:	df 91       	pop	r29
    2eb6:	cf 91       	pop	r28
    2eb8:	0f 91       	pop	r16
    2eba:	08 95       	ret

00002ebc <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ebc:	8f 92       	push	r8
    2ebe:	9f 92       	push	r9
    2ec0:	bf 92       	push	r11
    2ec2:	cf 92       	push	r12
    2ec4:	df 92       	push	r13
    2ec6:	ef 92       	push	r14
    2ec8:	ff 92       	push	r15
    2eca:	0f 93       	push	r16
    2ecc:	1f 93       	push	r17
    2ece:	cf 93       	push	r28
    2ed0:	df 93       	push	r29
    2ed2:	ec 01       	movw	r28, r24
    2ed4:	b6 2e       	mov	r11, r22
    2ed6:	4a 01       	movw	r8, r20
    2ed8:	68 01       	movw	r12, r16
    2eda:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2edc:	0e 94 b7 19 	call	0x336e	; 0x336e <_ZN8emstreamC1Ev>
    2ee0:	89 e5       	ldi	r24, 0x59	; 89
    2ee2:	90 e2       	ldi	r25, 0x20	; 32
    2ee4:	88 83       	st	Y, r24
    2ee6:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2ee8:	8e 86       	std	Y+14, r8	; 0x0e
    2eea:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2eec:	40 e0       	ldi	r20, 0x00	; 0
    2eee:	61 e0       	ldi	r22, 0x01	; 1
    2ef0:	8b 2d       	mov	r24, r11
    2ef2:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <xQueueGenericCreate>
    2ef6:	88 87       	std	Y+8, r24	; 0x08
    2ef8:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2efa:	ca 86       	std	Y+10, r12	; 0x0a
    2efc:	db 86       	std	Y+11, r13	; 0x0b
    2efe:	ec 86       	std	Y+12, r14	; 0x0c
    2f00:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f02:	df 91       	pop	r29
    2f04:	cf 91       	pop	r28
    2f06:	1f 91       	pop	r17
    2f08:	0f 91       	pop	r16
    2f0a:	ff 90       	pop	r15
    2f0c:	ef 90       	pop	r14
    2f0e:	df 90       	pop	r13
    2f10:	cf 90       	pop	r12
    2f12:	bf 90       	pop	r11
    2f14:	9f 90       	pop	r9
    2f16:	8f 90       	pop	r8
    2f18:	08 95       	ret

00002f1a <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f1a:	cf 92       	push	r12
    2f1c:	df 92       	push	r13
    2f1e:	ef 92       	push	r14
    2f20:	ff 92       	push	r15
    2f22:	cf 93       	push	r28
    2f24:	df 93       	push	r29
    2f26:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f28:	68 81       	ld	r22, Y
    2f2a:	79 81       	ldd	r23, Y+1	; 0x01
    2f2c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f2e:	9b 81       	ldd	r25, Y+3	; 0x03
    2f30:	0f 2e       	mov	r0, r31
    2f32:	f8 ee       	ldi	r31, 0xE8	; 232
    2f34:	cf 2e       	mov	r12, r31
    2f36:	f3 e0       	ldi	r31, 0x03	; 3
    2f38:	df 2e       	mov	r13, r31
    2f3a:	e1 2c       	mov	r14, r1
    2f3c:	f1 2c       	mov	r15, r1
    2f3e:	f0 2d       	mov	r31, r0
    2f40:	a7 01       	movw	r20, r14
    2f42:	96 01       	movw	r18, r12
    2f44:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <__udivmodsi4>
    2f48:	9b 01       	movw	r18, r22
    2f4a:	ac 01       	movw	r20, r24
    2f4c:	60 e4       	ldi	r22, 0x40	; 64
    2f4e:	72 e4       	ldi	r23, 0x42	; 66
    2f50:	8f e0       	ldi	r24, 0x0F	; 15
    2f52:	90 e0       	ldi	r25, 0x00	; 0
    2f54:	0e 94 ea 21 	call	0x43d4	; 0x43d4 <__mulsi3>
    2f58:	a7 01       	movw	r20, r14
    2f5a:	96 01       	movw	r18, r12
    2f5c:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <__udivmodsi4>
    2f60:	69 01       	movw	r12, r18
    2f62:	7a 01       	movw	r14, r20
    2f64:	ac 81       	ldd	r26, Y+4	; 0x04
    2f66:	bd 81       	ldd	r27, Y+5	; 0x05
    2f68:	20 e4       	ldi	r18, 0x40	; 64
    2f6a:	32 e4       	ldi	r19, 0x42	; 66
    2f6c:	4f e0       	ldi	r20, 0x0F	; 15
    2f6e:	50 e0       	ldi	r21, 0x00	; 0
    2f70:	0e 94 44 22 	call	0x4488	; 0x4488 <__muluhisi3>
    2f74:	20 e0       	ldi	r18, 0x00	; 0
    2f76:	38 e4       	ldi	r19, 0x48	; 72
    2f78:	48 ee       	ldi	r20, 0xE8	; 232
    2f7a:	51 e0       	ldi	r21, 0x01	; 1
    2f7c:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <__udivmodsi4>
    2f80:	c7 01       	movw	r24, r14
    2f82:	b6 01       	movw	r22, r12
    2f84:	62 0f       	add	r22, r18
    2f86:	73 1f       	adc	r23, r19
    2f88:	84 1f       	adc	r24, r20
    2f8a:	95 1f       	adc	r25, r21
}
    2f8c:	df 91       	pop	r29
    2f8e:	cf 91       	pop	r28
    2f90:	ff 90       	pop	r15
    2f92:	ef 90       	pop	r14
    2f94:	df 90       	pop	r13
    2f96:	cf 90       	pop	r12
    2f98:	08 95       	ret

00002f9a <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2f9a:	cf 92       	push	r12
    2f9c:	df 92       	push	r13
    2f9e:	ef 92       	push	r14
    2fa0:	ff 92       	push	r15
    2fa2:	0f 93       	push	r16
    2fa4:	1f 93       	push	r17
    2fa6:	cf 93       	push	r28
    2fa8:	df 93       	push	r29
    2faa:	cd b7       	in	r28, 0x3d	; 61
    2fac:	de b7       	in	r29, 0x3e	; 62
    2fae:	2f 97       	sbiw	r28, 0x0f	; 15
    2fb0:	cd bf       	out	0x3d, r28	; 61
    2fb2:	de bf       	out	0x3e, r29	; 62
    2fb4:	6c 01       	movw	r12, r24
    2fb6:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2fb8:	db 01       	movw	r26, r22
    2fba:	6d 91       	ld	r22, X+
    2fbc:	7d 91       	ld	r23, X+
    2fbe:	8d 91       	ld	r24, X+
    2fc0:	9c 91       	ld	r25, X
    2fc2:	28 ee       	ldi	r18, 0xE8	; 232
    2fc4:	33 e0       	ldi	r19, 0x03	; 3
    2fc6:	40 e0       	ldi	r20, 0x00	; 0
    2fc8:	50 e0       	ldi	r21, 0x00	; 0
    2fca:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <__udivmodsi4>
    2fce:	ba 01       	movw	r22, r20
    2fd0:	a9 01       	movw	r20, r18
    2fd2:	c6 01       	movw	r24, r12
    2fd4:	0e 94 a0 1a 	call	0x3540	; 0x3540 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2fd8:	d6 01       	movw	r26, r12
    2fda:	ed 91       	ld	r30, X+
    2fdc:	fc 91       	ld	r31, X
    2fde:	02 80       	ldd	r0, Z+2	; 0x02
    2fe0:	f3 81       	ldd	r31, Z+3	; 0x03
    2fe2:	e0 2d       	mov	r30, r0
    2fe4:	6e e2       	ldi	r22, 0x2E	; 46
    2fe6:	c6 01       	movw	r24, r12
    2fe8:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2fea:	c8 01       	movw	r24, r16
    2fec:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <_ZN10time_stamp12get_microsecEv>
    2ff0:	8e 01       	movw	r16, r28
    2ff2:	09 5f       	subi	r16, 0xF9	; 249
    2ff4:	1f 4f       	sbci	r17, 0xFF	; 255
    2ff6:	fe 01       	movw	r30, r28
    2ff8:	31 96       	adiw	r30, 0x01	; 1
    2ffa:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2ffc:	2a e0       	ldi	r18, 0x0A	; 10
    2ffe:	30 e0       	ldi	r19, 0x00	; 0
    3000:	40 e0       	ldi	r20, 0x00	; 0
    3002:	50 e0       	ldi	r21, 0x00	; 0
    3004:	0e 94 1c 22 	call	0x4438	; 0x4438 <__divmodsi4>
    3008:	e6 2f       	mov	r30, r22
    300a:	28 87       	std	Y+8, r18	; 0x08
    300c:	39 87       	std	Y+9, r19	; 0x09
    300e:	4a 87       	std	Y+10, r20	; 0x0a
    3010:	5b 87       	std	Y+11, r21	; 0x0b
    3012:	68 85       	ldd	r22, Y+8	; 0x08
    3014:	79 85       	ldd	r23, Y+9	; 0x09
    3016:	8a 85       	ldd	r24, Y+10	; 0x0a
    3018:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    301a:	20 e3       	ldi	r18, 0x30	; 48
    301c:	2e 0f       	add	r18, r30
    301e:	d8 01       	movw	r26, r16
    3020:	2e 93       	st	-X, r18
    3022:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3024:	ae 15       	cp	r26, r14
    3026:	bf 05       	cpc	r27, r15
    3028:	49 f7       	brne	.-46     	; 0x2ffc <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    302a:	1f 82       	std	Y+7, r1	; 0x07
    302c:	be 01       	movw	r22, r28
    302e:	6f 5f       	subi	r22, 0xFF	; 255
    3030:	7f 4f       	sbci	r23, 0xFF	; 255
    3032:	c6 01       	movw	r24, r12
    3034:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3038:	c6 01       	movw	r24, r12
    303a:	2f 96       	adiw	r28, 0x0f	; 15
    303c:	cd bf       	out	0x3d, r28	; 61
    303e:	de bf       	out	0x3e, r29	; 62
    3040:	df 91       	pop	r29
    3042:	cf 91       	pop	r28
    3044:	1f 91       	pop	r17
    3046:	0f 91       	pop	r16
    3048:	ff 90       	pop	r15
    304a:	ef 90       	pop	r14
    304c:	df 90       	pop	r13
    304e:	cf 90       	pop	r12
    3050:	08 95       	ret

00003052 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3052:	cf 93       	push	r28
    3054:	df 93       	push	r29
    3056:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3058:	0f b6       	in	r0, 0x3f	; 63
    305a:	f8 94       	cli
    305c:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    305e:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3062:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3066:	8c 83       	std	Y+4, r24	; 0x04
    3068:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    306a:	0e 94 3d 10 	call	0x207a	; 0x207a <xTaskGetTickCount>
    306e:	68 83       	st	Y, r22
    3070:	79 83       	std	Y+1, r23	; 0x01
    3072:	8a 83       	std	Y+2, r24	; 0x02
    3074:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3076:	0f 90       	pop	r0
    3078:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    307a:	ce 01       	movw	r24, r28
    307c:	df 91       	pop	r29
    307e:	cf 91       	pop	r28
    3080:	08 95       	ret

00003082 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3082:	5f 92       	push	r5
    3084:	6f 92       	push	r6
    3086:	7f 92       	push	r7
    3088:	8f 92       	push	r8
    308a:	9f 92       	push	r9
    308c:	af 92       	push	r10
    308e:	bf 92       	push	r11
    3090:	cf 92       	push	r12
    3092:	df 92       	push	r13
    3094:	ef 92       	push	r14
    3096:	ff 92       	push	r15
    3098:	0f 93       	push	r16
    309a:	1f 93       	push	r17
    309c:	cf 93       	push	r28
    309e:	df 93       	push	r29
    30a0:	5c 01       	movw	r10, r24
    30a2:	4b 01       	movw	r8, r22
    30a4:	7a 01       	movw	r14, r20
    30a6:	12 2f       	mov	r17, r18
    30a8:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    30aa:	63 e0       	ldi	r22, 0x03	; 3
    30ac:	ca 01       	movw	r24, r20
    30ae:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    30b2:	a8 14       	cp	r10, r8
    30b4:	b9 04       	cpc	r11, r9
    30b6:	08 f0       	brcs	.+2      	; 0x30ba <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    30b8:	7d c0       	rjmp	.+250    	; 0x31b4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30ba:	65 01       	movw	r12, r10
    30bc:	84 e1       	ldi	r24, 0x14	; 20
    30be:	c8 0e       	add	r12, r24
    30c0:	d1 1c       	adc	r13, r1
    30c2:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    30c4:	6a 2c       	mov	r6, r10
    30c6:	5b 2c       	mov	r5, r11
    30c8:	b5 01       	movw	r22, r10
    30ca:	c7 01       	movw	r24, r14
    30cc:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <_ZN8emstreamlsEj>
    30d0:	6a e0       	ldi	r22, 0x0A	; 10
    30d2:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    30d6:	65 e4       	ldi	r22, 0x45	; 69
    30d8:	75 e0       	ldi	r23, 0x05	; 5
    30da:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    30de:	11 23       	and	r17, r17
    30e0:	09 f4       	brne	.+2      	; 0x30e4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    30e2:	6d c0       	rjmp	.+218    	; 0x31be <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    30e4:	00 23       	and	r16, r16
    30e6:	09 f4       	brne	.+2      	; 0x30ea <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    30e8:	6a c0       	rjmp	.+212    	; 0x31be <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    30ea:	6a e0       	ldi	r22, 0x0A	; 10
    30ec:	c7 01       	movw	r24, r14
    30ee:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    30f2:	60 e4       	ldi	r22, 0x40	; 64
    30f4:	75 e0       	ldi	r23, 0x05	; 5
    30f6:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    30fa:	61 c0       	rjmp	.+194    	; 0x31be <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    30fc:	11 23       	and	r17, r17
    30fe:	71 f0       	breq	.+28     	; 0x311c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3100:	01 11       	cpse	r16, r1
    3102:	0c c0       	rjmp	.+24     	; 0x311c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3104:	88 81       	ld	r24, Y
    3106:	87 15       	cp	r24, r7
    3108:	49 f0       	breq	.+18     	; 0x311c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    310a:	6a e0       	ldi	r22, 0x0A	; 10
    310c:	c7 01       	movw	r24, r14
    310e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    3112:	6b e3       	ldi	r22, 0x3B	; 59
    3114:	75 e0       	ldi	r23, 0x05	; 5
    3116:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    311a:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    311c:	69 91       	ld	r22, Y+
    311e:	c7 01       	movw	r24, r14
    3120:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3124:	dc 01       	movw	r26, r24
    3126:	ed 91       	ld	r30, X+
    3128:	fc 91       	ld	r31, X
    312a:	02 80       	ldd	r0, Z+2	; 0x02
    312c:	f3 81       	ldd	r31, Z+3	; 0x03
    312e:	e0 2d       	mov	r30, r0
    3130:	60 e2       	ldi	r22, 0x20	; 32
    3132:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3134:	cc 16       	cp	r12, r28
    3136:	dd 06       	cpc	r13, r29
    3138:	09 f7       	brne	.-62     	; 0x30fc <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    313a:	11 23       	and	r17, r17
    313c:	89 f0       	breq	.+34     	; 0x3160 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    313e:	6a e0       	ldi	r22, 0x0A	; 10
    3140:	c7 01       	movw	r24, r14
    3142:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    3146:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3148:	65 e3       	ldi	r22, 0x35	; 53
    314a:	75 e0       	ldi	r23, 0x05	; 5
    314c:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3150:	e8 81       	ld	r30, Y
    3152:	f9 81       	ldd	r31, Y+1	; 0x01
    3154:	02 80       	ldd	r0, Z+2	; 0x02
    3156:	f3 81       	ldd	r31, Z+3	; 0x03
    3158:	e0 2d       	mov	r30, r0
    315a:	60 e2       	ldi	r22, 0x20	; 32
    315c:	ce 01       	movw	r24, r28
    315e:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3160:	c6 2d       	mov	r28, r6
    3162:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3164:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3166:	80 ee       	ldi	r24, 0xE0	; 224
    3168:	86 0f       	add	r24, r22
    316a:	8f 35       	cpi	r24, 0x5F	; 95
    316c:	48 f4       	brcc	.+18     	; 0x3180 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    316e:	d7 01       	movw	r26, r14
    3170:	ed 91       	ld	r30, X+
    3172:	fc 91       	ld	r31, X
    3174:	02 80       	ldd	r0, Z+2	; 0x02
    3176:	f3 81       	ldd	r31, Z+3	; 0x03
    3178:	e0 2d       	mov	r30, r0
    317a:	c7 01       	movw	r24, r14
    317c:	19 95       	eicall
    317e:	09 c0       	rjmp	.+18     	; 0x3192 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3180:	d7 01       	movw	r26, r14
    3182:	ed 91       	ld	r30, X+
    3184:	fc 91       	ld	r31, X
    3186:	02 80       	ldd	r0, Z+2	; 0x02
    3188:	f3 81       	ldd	r31, Z+3	; 0x03
    318a:	e0 2d       	mov	r30, r0
    318c:	6e e2       	ldi	r22, 0x2E	; 46
    318e:	c7 01       	movw	r24, r14
    3190:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3192:	cc 16       	cp	r12, r28
    3194:	dd 06       	cpc	r13, r29
    3196:	31 f7       	brne	.-52     	; 0x3164 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3198:	b4 e1       	ldi	r27, 0x14	; 20
    319a:	ab 0e       	add	r10, r27
    319c:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    319e:	66 e0       	ldi	r22, 0x06	; 6
    31a0:	c7 01       	movw	r24, r14
    31a2:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    31a6:	84 e1       	ldi	r24, 0x14	; 20
    31a8:	c8 0e       	add	r12, r24
    31aa:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31ac:	a8 14       	cp	r10, r8
    31ae:	b9 04       	cpc	r11, r9
    31b0:	08 f4       	brcc	.+2      	; 0x31b4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31b2:	88 cf       	rjmp	.-240    	; 0x30c4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    31b4:	62 e0       	ldi	r22, 0x02	; 2
    31b6:	c7 01       	movw	r24, r14
    31b8:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
}
    31bc:	03 c0       	rjmp	.+6      	; 0x31c4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31be:	c6 2d       	mov	r28, r6
    31c0:	d5 2d       	mov	r29, r5
    31c2:	9c cf       	rjmp	.-200    	; 0x30fc <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    31c4:	df 91       	pop	r29
    31c6:	cf 91       	pop	r28
    31c8:	1f 91       	pop	r17
    31ca:	0f 91       	pop	r16
    31cc:	ff 90       	pop	r15
    31ce:	ef 90       	pop	r14
    31d0:	df 90       	pop	r13
    31d2:	cf 90       	pop	r12
    31d4:	bf 90       	pop	r11
    31d6:	af 90       	pop	r10
    31d8:	9f 90       	pop	r9
    31da:	8f 90       	pop	r8
    31dc:	7f 90       	pop	r7
    31de:	6f 90       	pop	r6
    31e0:	5f 90       	pop	r5
    31e2:	08 95       	ret

000031e4 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    31e4:	0e 94 21 09 	call	0x1242	; 0x1242 <pvPortMalloc>
    31e8:	08 95       	ret

000031ea <_ZdlPv>:
    31ea:	00 97       	sbiw	r24, 0x00	; 0
    31ec:	11 f0       	breq	.+4      	; 0x31f2 <_ZdlPv+0x8>
    31ee:	0e 94 bb 09 	call	0x1376	; 0x1376 <vPortFree>
    31f2:	08 95       	ret

000031f4 <_Znaj>:
    31f4:	0e 94 21 09 	call	0x1242	; 0x1242 <pvPortMalloc>
    31f8:	08 95       	ret

000031fa <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    31fa:	08 95       	ret

000031fc <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    31fc:	cf 93       	push	r28
    31fe:	df 93       	push	r29
    3200:	fc 01       	movw	r30, r24
    3202:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3204:	40 3a       	cpi	r20, 0xA0	; 160
    3206:	68 e0       	ldi	r22, 0x08	; 8
    3208:	56 07       	cpc	r21, r22
    320a:	49 f4       	brne	.+18     	; 0x321e <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    320c:	80 e4       	ldi	r24, 0x40	; 64
    320e:	96 e0       	ldi	r25, 0x06	; 6
    3210:	82 83       	std	Z+2, r24	; 0x02
    3212:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3214:	82 e0       	ldi	r24, 0x02	; 2
    3216:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3218:	83 e0       	ldi	r24, 0x03	; 3
    321a:	85 83       	std	Z+5, r24	; 0x05
    321c:	4c c0       	rjmp	.+152    	; 0x32b6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    321e:	40 3b       	cpi	r20, 0xB0	; 176
    3220:	78 e0       	ldi	r23, 0x08	; 8
    3222:	57 07       	cpc	r21, r23
    3224:	49 f4       	brne	.+18     	; 0x3238 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3226:	80 e4       	ldi	r24, 0x40	; 64
    3228:	96 e0       	ldi	r25, 0x06	; 6
    322a:	82 83       	std	Z+2, r24	; 0x02
    322c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    322e:	86 e0       	ldi	r24, 0x06	; 6
    3230:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3232:	87 e0       	ldi	r24, 0x07	; 7
    3234:	85 83       	std	Z+5, r24	; 0x05
    3236:	3f c0       	rjmp	.+126    	; 0x32b6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3238:	40 3a       	cpi	r20, 0xA0	; 160
    323a:	89 e0       	ldi	r24, 0x09	; 9
    323c:	58 07       	cpc	r21, r24
    323e:	49 f4       	brne	.+18     	; 0x3252 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3240:	80 e6       	ldi	r24, 0x60	; 96
    3242:	96 e0       	ldi	r25, 0x06	; 6
    3244:	82 83       	std	Z+2, r24	; 0x02
    3246:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3248:	82 e0       	ldi	r24, 0x02	; 2
    324a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    324c:	83 e0       	ldi	r24, 0x03	; 3
    324e:	85 83       	std	Z+5, r24	; 0x05
    3250:	32 c0       	rjmp	.+100    	; 0x32b6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3252:	40 3b       	cpi	r20, 0xB0	; 176
    3254:	69 e0       	ldi	r22, 0x09	; 9
    3256:	56 07       	cpc	r21, r22
    3258:	49 f4       	brne	.+18     	; 0x326c <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    325a:	80 e6       	ldi	r24, 0x60	; 96
    325c:	96 e0       	ldi	r25, 0x06	; 6
    325e:	82 83       	std	Z+2, r24	; 0x02
    3260:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3262:	86 e0       	ldi	r24, 0x06	; 6
    3264:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3266:	87 e0       	ldi	r24, 0x07	; 7
    3268:	85 83       	std	Z+5, r24	; 0x05
    326a:	25 c0       	rjmp	.+74     	; 0x32b6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    326c:	40 3a       	cpi	r20, 0xA0	; 160
    326e:	7a e0       	ldi	r23, 0x0A	; 10
    3270:	57 07       	cpc	r21, r23
    3272:	49 f4       	brne	.+18     	; 0x3286 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    3274:	80 e8       	ldi	r24, 0x80	; 128
    3276:	96 e0       	ldi	r25, 0x06	; 6
    3278:	82 83       	std	Z+2, r24	; 0x02
    327a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    327c:	82 e0       	ldi	r24, 0x02	; 2
    327e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3280:	83 e0       	ldi	r24, 0x03	; 3
    3282:	85 83       	std	Z+5, r24	; 0x05
    3284:	18 c0       	rjmp	.+48     	; 0x32b6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    3286:	40 3b       	cpi	r20, 0xB0	; 176
    3288:	8a e0       	ldi	r24, 0x0A	; 10
    328a:	58 07       	cpc	r21, r24
    328c:	49 f4       	brne	.+18     	; 0x32a0 <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    328e:	80 e8       	ldi	r24, 0x80	; 128
    3290:	96 e0       	ldi	r25, 0x06	; 6
    3292:	82 83       	std	Z+2, r24	; 0x02
    3294:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3296:	86 e0       	ldi	r24, 0x06	; 6
    3298:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    329a:	87 e0       	ldi	r24, 0x07	; 7
    329c:	85 83       	std	Z+5, r24	; 0x05
    329e:	0b c0       	rjmp	.+22     	; 0x32b6 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    32a0:	40 3a       	cpi	r20, 0xA0	; 160
    32a2:	5b 40       	sbci	r21, 0x0B	; 11
    32a4:	41 f4       	brne	.+16     	; 0x32b6 <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    32a6:	80 ea       	ldi	r24, 0xA0	; 160
    32a8:	96 e0       	ldi	r25, 0x06	; 6
    32aa:	82 83       	std	Z+2, r24	; 0x02
    32ac:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32ae:	82 e0       	ldi	r24, 0x02	; 2
    32b0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32b2:	83 e0       	ldi	r24, 0x03	; 3
    32b4:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    32b6:	a6 83       	std	Z+6, r26	; 0x06
    32b8:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    32ba:	cd 01       	movw	r24, r26
    32bc:	01 96       	adiw	r24, 0x01	; 1
    32be:	80 87       	std	Z+8, r24	; 0x08
    32c0:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    32c2:	03 96       	adiw	r24, 0x03	; 3
    32c4:	82 87       	std	Z+10, r24	; 0x0a
    32c6:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    32c8:	25 81       	ldd	r18, Z+5	; 0x05
    32ca:	c2 81       	ldd	r28, Z+2	; 0x02
    32cc:	d3 81       	ldd	r29, Z+3	; 0x03
    32ce:	4c 81       	ldd	r20, Y+4	; 0x04
    32d0:	81 e0       	ldi	r24, 0x01	; 1
    32d2:	90 e0       	ldi	r25, 0x00	; 0
    32d4:	bc 01       	movw	r22, r24
    32d6:	02 c0       	rjmp	.+4      	; 0x32dc <_ZN7base232C1EjP12USART_struct+0xe0>
    32d8:	66 0f       	add	r22, r22
    32da:	77 1f       	adc	r23, r23
    32dc:	2a 95       	dec	r18
    32de:	e2 f7       	brpl	.-8      	; 0x32d8 <_ZN7base232C1EjP12USART_struct+0xdc>
    32e0:	9b 01       	movw	r18, r22
    32e2:	24 2b       	or	r18, r20
    32e4:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    32e6:	25 81       	ldd	r18, Z+5	; 0x05
    32e8:	c2 81       	ldd	r28, Z+2	; 0x02
    32ea:	d3 81       	ldd	r29, Z+3	; 0x03
    32ec:	48 81       	ld	r20, Y
    32ee:	bc 01       	movw	r22, r24
    32f0:	02 c0       	rjmp	.+4      	; 0x32f6 <_ZN7base232C1EjP12USART_struct+0xfa>
    32f2:	66 0f       	add	r22, r22
    32f4:	77 1f       	adc	r23, r23
    32f6:	2a 95       	dec	r18
    32f8:	e2 f7       	brpl	.-8      	; 0x32f2 <_ZN7base232C1EjP12USART_struct+0xf6>
    32fa:	9b 01       	movw	r18, r22
    32fc:	24 2b       	or	r18, r20
    32fe:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3300:	34 81       	ldd	r19, Z+4	; 0x04
    3302:	c2 81       	ldd	r28, Z+2	; 0x02
    3304:	d3 81       	ldd	r29, Z+3	; 0x03
    3306:	28 81       	ld	r18, Y
    3308:	02 c0       	rjmp	.+4      	; 0x330e <_ZN7base232C1EjP12USART_struct+0x112>
    330a:	88 0f       	add	r24, r24
    330c:	99 1f       	adc	r25, r25
    330e:	3a 95       	dec	r19
    3310:	e2 f7       	brpl	.-8      	; 0x330a <_ZN7base232C1EjP12USART_struct+0x10e>
    3312:	80 95       	com	r24
    3314:	90 95       	com	r25
    3316:	82 23       	and	r24, r18
    3318:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    331a:	80 e1       	ldi	r24, 0x10	; 16
    331c:	13 96       	adiw	r26, 0x03	; 3
    331e:	8c 93       	st	X, r24
    3320:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3322:	83 e0       	ldi	r24, 0x03	; 3
    3324:	15 96       	adiw	r26, 0x05	; 5
    3326:	8c 93       	st	X, r24
    3328:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    332a:	80 ef       	ldi	r24, 0xF0	; 240
    332c:	17 96       	adiw	r26, 0x07	; 7
    332e:	8c 93       	st	X, r24
    3330:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3332:	81 e2       	ldi	r24, 0x21	; 33
    3334:	16 96       	adiw	r26, 0x06	; 6
    3336:	8c 93       	st	X, r24
    3338:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    333a:	88 e1       	ldi	r24, 0x18	; 24
    333c:	14 96       	adiw	r26, 0x04	; 4
    333e:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3340:	80 e8       	ldi	r24, 0x80	; 128
    3342:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3344:	80 e4       	ldi	r24, 0x40	; 64
    3346:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3348:	80 e2       	ldi	r24, 0x20	; 32
    334a:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    334c:	06 80       	ldd	r0, Z+6	; 0x06
    334e:	f7 81       	ldd	r31, Z+7	; 0x07
    3350:	e0 2d       	mov	r30, r0
    3352:	80 81       	ld	r24, Z
    3354:	80 81       	ld	r24, Z
}
    3356:	df 91       	pop	r29
    3358:	cf 91       	pop	r28
    335a:	08 95       	ret

0000335c <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    335c:	81 e0       	ldi	r24, 0x01	; 1
    335e:	08 95       	ret

00003360 <_ZN8emstream7getcharEv>:
    3360:	80 e0       	ldi	r24, 0x00	; 0
    3362:	90 e0       	ldi	r25, 0x00	; 0
    3364:	08 95       	ret

00003366 <_ZN8emstream14check_for_charEv>:
    3366:	80 e0       	ldi	r24, 0x00	; 0
    3368:	08 95       	ret

0000336a <_ZN8emstream12transmit_nowEv>:
    336a:	08 95       	ret

0000336c <_ZN8emstream12clear_screenEv>:
    336c:	08 95       	ret

0000336e <_ZN8emstreamC1Ev>:
    336e:	fc 01       	movw	r30, r24
    3370:	89 e6       	ldi	r24, 0x69	; 105
    3372:	90 e2       	ldi	r25, 0x20	; 32
    3374:	80 83       	st	Z, r24
    3376:	91 83       	std	Z+1, r25	; 0x01
    3378:	8a e0       	ldi	r24, 0x0A	; 10
    337a:	82 83       	std	Z+2, r24	; 0x02
    337c:	13 82       	std	Z+3, r1	; 0x03
    337e:	83 e0       	ldi	r24, 0x03	; 3
    3380:	85 83       	std	Z+5, r24	; 0x05
    3382:	14 82       	std	Z+4, r1	; 0x04
    3384:	16 82       	std	Z+6, r1	; 0x06
    3386:	17 82       	std	Z+7, r1	; 0x07
    3388:	08 95       	ret

0000338a <_ZN8emstream4putsEPKc>:
    338a:	0f 93       	push	r16
    338c:	1f 93       	push	r17
    338e:	cf 93       	push	r28
    3390:	df 93       	push	r29
    3392:	8c 01       	movw	r16, r24
    3394:	fb 01       	movw	r30, r22
    3396:	dc 01       	movw	r26, r24
    3398:	14 96       	adiw	r26, 0x04	; 4
    339a:	8c 91       	ld	r24, X
    339c:	81 11       	cpse	r24, r1
    339e:	04 c0       	rjmp	.+8      	; 0x33a8 <_ZN8emstream4putsEPKc+0x1e>
    33a0:	60 81       	ld	r22, Z
    33a2:	61 11       	cpse	r22, r1
    33a4:	17 c0       	rjmp	.+46     	; 0x33d4 <_ZN8emstream4putsEPKc+0x4a>
    33a6:	23 c0       	rjmp	.+70     	; 0x33ee <_ZN8emstream4putsEPKc+0x64>
    33a8:	d8 01       	movw	r26, r16
    33aa:	14 96       	adiw	r26, 0x04	; 4
    33ac:	1c 92       	st	X, r1
    33ae:	eb 01       	movw	r28, r22
    33b0:	21 96       	adiw	r28, 0x01	; 1
    33b2:	64 91       	lpm	r22, Z
    33b4:	66 23       	and	r22, r22
    33b6:	d9 f0       	breq	.+54     	; 0x33ee <_ZN8emstream4putsEPKc+0x64>
    33b8:	d8 01       	movw	r26, r16
    33ba:	ed 91       	ld	r30, X+
    33bc:	fc 91       	ld	r31, X
    33be:	02 80       	ldd	r0, Z+2	; 0x02
    33c0:	f3 81       	ldd	r31, Z+3	; 0x03
    33c2:	e0 2d       	mov	r30, r0
    33c4:	c8 01       	movw	r24, r16
    33c6:	19 95       	eicall
    33c8:	fe 01       	movw	r30, r28
    33ca:	64 91       	lpm	r22, Z
    33cc:	21 96       	adiw	r28, 0x01	; 1
    33ce:	61 11       	cpse	r22, r1
    33d0:	f3 cf       	rjmp	.-26     	; 0x33b8 <_ZN8emstream4putsEPKc+0x2e>
    33d2:	0d c0       	rjmp	.+26     	; 0x33ee <_ZN8emstream4putsEPKc+0x64>
    33d4:	ef 01       	movw	r28, r30
    33d6:	21 96       	adiw	r28, 0x01	; 1
    33d8:	d8 01       	movw	r26, r16
    33da:	ed 91       	ld	r30, X+
    33dc:	fc 91       	ld	r31, X
    33de:	02 80       	ldd	r0, Z+2	; 0x02
    33e0:	f3 81       	ldd	r31, Z+3	; 0x03
    33e2:	e0 2d       	mov	r30, r0
    33e4:	c8 01       	movw	r24, r16
    33e6:	19 95       	eicall
    33e8:	69 91       	ld	r22, Y+
    33ea:	61 11       	cpse	r22, r1
    33ec:	f5 cf       	rjmp	.-22     	; 0x33d8 <_ZN8emstream4putsEPKc+0x4e>
    33ee:	df 91       	pop	r29
    33f0:	cf 91       	pop	r28
    33f2:	1f 91       	pop	r17
    33f4:	0f 91       	pop	r16
    33f6:	08 95       	ret

000033f8 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    33f8:	cf 93       	push	r28
    33fa:	df 93       	push	r29
    33fc:	ec 01       	movw	r28, r24
	switch (new_manip)
    33fe:	86 2f       	mov	r24, r22
    3400:	90 e0       	ldi	r25, 0x00	; 0
    3402:	8b 30       	cpi	r24, 0x0B	; 11
    3404:	91 05       	cpc	r25, r1
    3406:	d8 f5       	brcc	.+118    	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
    3408:	fc 01       	movw	r30, r24
    340a:	88 27       	eor	r24, r24
    340c:	e2 50       	subi	r30, 0x02	; 2
    340e:	ff 4f       	sbci	r31, 0xFF	; 255
    3410:	8f 4f       	sbci	r24, 0xFF	; 255
    3412:	0c 94 3b 22 	jmp	0x4476	; 0x4476 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3416:	82 e0       	ldi	r24, 0x02	; 2
    3418:	8a 83       	std	Y+2, r24	; 0x02
			break;
    341a:	31 c0       	rjmp	.+98     	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    341c:	88 e0       	ldi	r24, 0x08	; 8
    341e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3420:	2e c0       	rjmp	.+92     	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3422:	8a e0       	ldi	r24, 0x0A	; 10
    3424:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3426:	2b c0       	rjmp	.+86     	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3428:	80 e1       	ldi	r24, 0x10	; 16
    342a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    342c:	28 c0       	rjmp	.+80     	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    342e:	81 e0       	ldi	r24, 0x01	; 1
    3430:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3432:	25 c0       	rjmp	.+74     	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3434:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3436:	23 c0       	rjmp	.+70     	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3438:	e8 81       	ld	r30, Y
    343a:	f9 81       	ldd	r31, Y+1	; 0x01
    343c:	02 80       	ldd	r0, Z+2	; 0x02
    343e:	f3 81       	ldd	r31, Z+3	; 0x03
    3440:	e0 2d       	mov	r30, r0
    3442:	6d e0       	ldi	r22, 0x0D	; 13
    3444:	ce 01       	movw	r24, r28
    3446:	19 95       	eicall
    3448:	e8 81       	ld	r30, Y
    344a:	f9 81       	ldd	r31, Y+1	; 0x01
    344c:	02 80       	ldd	r0, Z+2	; 0x02
    344e:	f3 81       	ldd	r31, Z+3	; 0x03
    3450:	e0 2d       	mov	r30, r0
    3452:	6a e0       	ldi	r22, 0x0A	; 10
    3454:	ce 01       	movw	r24, r28
    3456:	19 95       	eicall
			break;
    3458:	12 c0       	rjmp	.+36     	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    345a:	e8 81       	ld	r30, Y
    345c:	f9 81       	ldd	r31, Y+1	; 0x01
    345e:	02 84       	ldd	r0, Z+10	; 0x0a
    3460:	f3 85       	ldd	r31, Z+11	; 0x0b
    3462:	e0 2d       	mov	r30, r0
    3464:	ce 01       	movw	r24, r28
    3466:	19 95       	eicall
			break;
    3468:	0a c0       	rjmp	.+20     	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    346a:	e8 81       	ld	r30, Y
    346c:	f9 81       	ldd	r31, Y+1	; 0x01
    346e:	00 84       	ldd	r0, Z+8	; 0x08
    3470:	f1 85       	ldd	r31, Z+9	; 0x09
    3472:	e0 2d       	mov	r30, r0
    3474:	ce 01       	movw	r24, r28
    3476:	19 95       	eicall
			break;
    3478:	02 c0       	rjmp	.+4      	; 0x347e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    347a:	81 e0       	ldi	r24, 0x01	; 1
    347c:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    347e:	ce 01       	movw	r24, r28
    3480:	df 91       	pop	r29
    3482:	cf 91       	pop	r28
    3484:	08 95       	ret

00003486 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    3486:	0f 93       	push	r16
    3488:	1f 93       	push	r17
    348a:	cf 93       	push	r28
    348c:	df 93       	push	r29
    348e:	cd b7       	in	r28, 0x3d	; 61
    3490:	de b7       	in	r29, 0x3e	; 62
    3492:	61 97       	sbiw	r28, 0x11	; 17
    3494:	cd bf       	out	0x3d, r28	; 61
    3496:	de bf       	out	0x3e, r29	; 62
    3498:	8c 01       	movw	r16, r24
    349a:	9b 01       	movw	r18, r22
	if (base != 10)
    349c:	fc 01       	movw	r30, r24
    349e:	92 81       	ldd	r25, Z+2	; 0x02
    34a0:	9a 30       	cpi	r25, 0x0A	; 10
    34a2:	21 f0       	breq	.+8      	; 0x34ac <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    34a4:	c8 01       	movw	r24, r16
    34a6:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <_ZN8emstreamlsEj>
    34aa:	0d c0       	rjmp	.+26     	; 0x34c6 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    34ac:	4a e0       	ldi	r20, 0x0A	; 10
    34ae:	be 01       	movw	r22, r28
    34b0:	6f 5f       	subi	r22, 0xFF	; 255
    34b2:	7f 4f       	sbci	r23, 0xFF	; 255
    34b4:	c9 01       	movw	r24, r18
    34b6:	0e 94 7d 22 	call	0x44fa	; 0x44fa <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    34ba:	be 01       	movw	r22, r28
    34bc:	6f 5f       	subi	r22, 0xFF	; 255
    34be:	7f 4f       	sbci	r23, 0xFF	; 255
    34c0:	c8 01       	movw	r24, r16
    34c2:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    34c6:	c8 01       	movw	r24, r16
    34c8:	61 96       	adiw	r28, 0x11	; 17
    34ca:	cd bf       	out	0x3d, r28	; 61
    34cc:	de bf       	out	0x3e, r29	; 62
    34ce:	df 91       	pop	r29
    34d0:	cf 91       	pop	r28
    34d2:	1f 91       	pop	r17
    34d4:	0f 91       	pop	r16
    34d6:	08 95       	ret

000034d8 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    34d8:	ff 92       	push	r15
    34da:	0f 93       	push	r16
    34dc:	1f 93       	push	r17
    34de:	cf 93       	push	r28
    34e0:	df 93       	push	r29
    34e2:	cd b7       	in	r28, 0x3d	; 61
    34e4:	de b7       	in	r29, 0x3e	; 62
    34e6:	61 97       	sbiw	r28, 0x11	; 17
    34e8:	cd bf       	out	0x3d, r28	; 61
    34ea:	de bf       	out	0x3e, r29	; 62
    34ec:	8c 01       	movw	r16, r24
    34ee:	f6 2e       	mov	r15, r22
    34f0:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    34f2:	f8 01       	movw	r30, r16
    34f4:	42 81       	ldd	r20, Z+2	; 0x02
    34f6:	40 31       	cpi	r20, 0x10	; 16
    34f8:	21 f0       	breq	.+8      	; 0x3502 <_ZN8emstreamlsEj+0x2a>
    34fa:	48 30       	cpi	r20, 0x08	; 8
    34fc:	11 f0       	breq	.+4      	; 0x3502 <_ZN8emstreamlsEj+0x2a>
    34fe:	42 30       	cpi	r20, 0x02	; 2
    3500:	41 f4       	brne	.+16     	; 0x3512 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3502:	69 2f       	mov	r22, r25
    3504:	c8 01       	movw	r24, r16
    3506:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
    350a:	6f 2d       	mov	r22, r15
    350c:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
    3510:	0d c0       	rjmp	.+26     	; 0x352c <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3512:	50 e0       	ldi	r21, 0x00	; 0
    3514:	be 01       	movw	r22, r28
    3516:	6f 5f       	subi	r22, 0xFF	; 255
    3518:	7f 4f       	sbci	r23, 0xFF	; 255
    351a:	8f 2d       	mov	r24, r15
    351c:	0e 94 b5 22 	call	0x456a	; 0x456a <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3520:	be 01       	movw	r22, r28
    3522:	6f 5f       	subi	r22, 0xFF	; 255
    3524:	7f 4f       	sbci	r23, 0xFF	; 255
    3526:	c8 01       	movw	r24, r16
    3528:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    352c:	c8 01       	movw	r24, r16
    352e:	61 96       	adiw	r28, 0x11	; 17
    3530:	cd bf       	out	0x3d, r28	; 61
    3532:	de bf       	out	0x3e, r29	; 62
    3534:	df 91       	pop	r29
    3536:	cf 91       	pop	r28
    3538:	1f 91       	pop	r17
    353a:	0f 91       	pop	r16
    353c:	ff 90       	pop	r15
    353e:	08 95       	ret

00003540 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3540:	df 92       	push	r13
    3542:	ef 92       	push	r14
    3544:	ff 92       	push	r15
    3546:	0f 93       	push	r16
    3548:	1f 93       	push	r17
    354a:	cf 93       	push	r28
    354c:	df 93       	push	r29
    354e:	cd b7       	in	r28, 0x3d	; 61
    3550:	de b7       	in	r29, 0x3e	; 62
    3552:	a1 97       	sbiw	r28, 0x21	; 33
    3554:	cd bf       	out	0x3d, r28	; 61
    3556:	de bf       	out	0x3e, r29	; 62
    3558:	8c 01       	movw	r16, r24
    355a:	d4 2e       	mov	r13, r20
    355c:	e5 2e       	mov	r14, r21
    355e:	f6 2e       	mov	r15, r22
    3560:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3562:	f8 01       	movw	r30, r16
    3564:	22 81       	ldd	r18, Z+2	; 0x02
    3566:	20 31       	cpi	r18, 0x10	; 16
    3568:	21 f0       	breq	.+8      	; 0x3572 <_ZN8emstreamlsEm+0x32>
    356a:	28 30       	cpi	r18, 0x08	; 8
    356c:	11 f0       	breq	.+4      	; 0x3572 <_ZN8emstreamlsEm+0x32>
    356e:	22 30       	cpi	r18, 0x02	; 2
    3570:	71 f4       	brne	.+28     	; 0x358e <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3572:	69 2f       	mov	r22, r25
    3574:	c8 01       	movw	r24, r16
    3576:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
    357a:	6f 2d       	mov	r22, r15
    357c:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
    3580:	6e 2d       	mov	r22, r14
    3582:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
    3586:	6d 2d       	mov	r22, r13
    3588:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN8emstreamlsEh>
    358c:	0f c0       	rjmp	.+30     	; 0x35ac <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    358e:	30 e0       	ldi	r19, 0x00	; 0
    3590:	ae 01       	movw	r20, r28
    3592:	4f 5f       	subi	r20, 0xFF	; 255
    3594:	5f 4f       	sbci	r21, 0xFF	; 255
    3596:	6d 2d       	mov	r22, r13
    3598:	7e 2d       	mov	r23, r14
    359a:	8f 2d       	mov	r24, r15
    359c:	0e 94 88 22 	call	0x4510	; 0x4510 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    35a0:	be 01       	movw	r22, r28
    35a2:	6f 5f       	subi	r22, 0xFF	; 255
    35a4:	7f 4f       	sbci	r23, 0xFF	; 255
    35a6:	c8 01       	movw	r24, r16
    35a8:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35ac:	c8 01       	movw	r24, r16
    35ae:	a1 96       	adiw	r28, 0x21	; 33
    35b0:	cd bf       	out	0x3d, r28	; 61
    35b2:	de bf       	out	0x3e, r29	; 62
    35b4:	df 91       	pop	r29
    35b6:	cf 91       	pop	r28
    35b8:	1f 91       	pop	r17
    35ba:	0f 91       	pop	r16
    35bc:	ff 90       	pop	r15
    35be:	ef 90       	pop	r14
    35c0:	df 90       	pop	r13
    35c2:	08 95       	ret

000035c4 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    35c4:	cf 92       	push	r12
    35c6:	df 92       	push	r13
    35c8:	ef 92       	push	r14
    35ca:	ff 92       	push	r15
    35cc:	0f 93       	push	r16
    35ce:	1f 93       	push	r17
    35d0:	cf 93       	push	r28
    35d2:	df 93       	push	r29
    35d4:	cd b7       	in	r28, 0x3d	; 61
    35d6:	de b7       	in	r29, 0x3e	; 62
    35d8:	29 97       	sbiw	r28, 0x09	; 9
    35da:	cd bf       	out	0x3d, r28	; 61
    35dc:	de bf       	out	0x3e, r29	; 62
    35de:	8c 01       	movw	r16, r24
    35e0:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    35e2:	dc 01       	movw	r26, r24
    35e4:	13 96       	adiw	r26, 0x03	; 3
    35e6:	8c 91       	ld	r24, X
    35e8:	13 97       	sbiw	r26, 0x03	; 3
    35ea:	88 23       	and	r24, r24
    35ec:	41 f0       	breq	.+16     	; 0x35fe <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    35ee:	ed 91       	ld	r30, X+
    35f0:	fc 91       	ld	r31, X
    35f2:	02 80       	ldd	r0, Z+2	; 0x02
    35f4:	f3 81       	ldd	r31, Z+3	; 0x03
    35f6:	e0 2d       	mov	r30, r0
    35f8:	c8 01       	movw	r24, r16
    35fa:	19 95       	eicall
    35fc:	56 c0       	rjmp	.+172    	; 0x36aa <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    35fe:	f8 01       	movw	r30, r16
    3600:	42 81       	ldd	r20, Z+2	; 0x02
    3602:	42 30       	cpi	r20, 0x02	; 2
    3604:	19 f5       	brne	.+70     	; 0x364c <_ZN8emstreamlsEh+0x88>
    3606:	68 94       	set
    3608:	cc 24       	eor	r12, r12
    360a:	c3 f8       	bld	r12, 3
    360c:	d1 2c       	mov	r13, r1
    360e:	68 94       	set
    3610:	ff 24       	eor	r15, r15
    3612:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3614:	8e 2d       	mov	r24, r14
    3616:	8f 21       	and	r24, r15
    3618:	51 f0       	breq	.+20     	; 0x362e <_ZN8emstreamlsEh+0x6a>
    361a:	d8 01       	movw	r26, r16
    361c:	ed 91       	ld	r30, X+
    361e:	fc 91       	ld	r31, X
    3620:	02 80       	ldd	r0, Z+2	; 0x02
    3622:	f3 81       	ldd	r31, Z+3	; 0x03
    3624:	e0 2d       	mov	r30, r0
    3626:	61 e3       	ldi	r22, 0x31	; 49
    3628:	c8 01       	movw	r24, r16
    362a:	19 95       	eicall
    362c:	09 c0       	rjmp	.+18     	; 0x3640 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    362e:	d8 01       	movw	r26, r16
    3630:	ed 91       	ld	r30, X+
    3632:	fc 91       	ld	r31, X
    3634:	02 80       	ldd	r0, Z+2	; 0x02
    3636:	f3 81       	ldd	r31, Z+3	; 0x03
    3638:	e0 2d       	mov	r30, r0
    363a:	60 e3       	ldi	r22, 0x30	; 48
    363c:	c8 01       	movw	r24, r16
    363e:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3640:	f6 94       	lsr	r15
    3642:	b1 e0       	ldi	r27, 0x01	; 1
    3644:	cb 1a       	sub	r12, r27
    3646:	d1 08       	sbc	r13, r1
    3648:	29 f7       	brne	.-54     	; 0x3614 <_ZN8emstreamlsEh+0x50>
    364a:	2f c0       	rjmp	.+94     	; 0x36aa <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    364c:	40 31       	cpi	r20, 0x10	; 16
    364e:	f9 f4       	brne	.+62     	; 0x368e <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3650:	62 95       	swap	r22
    3652:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3654:	01 90       	ld	r0, Z+
    3656:	f0 81       	ld	r31, Z
    3658:	e0 2d       	mov	r30, r0
    365a:	02 80       	ldd	r0, Z+2	; 0x02
    365c:	f3 81       	ldd	r31, Z+3	; 0x03
    365e:	e0 2d       	mov	r30, r0
    3660:	6a 30       	cpi	r22, 0x0A	; 10
    3662:	10 f0       	brcs	.+4      	; 0x3668 <_ZN8emstreamlsEh+0xa4>
    3664:	69 5c       	subi	r22, 0xC9	; 201
    3666:	01 c0       	rjmp	.+2      	; 0x366a <_ZN8emstreamlsEh+0xa6>
    3668:	60 5d       	subi	r22, 0xD0	; 208
    366a:	c8 01       	movw	r24, r16
    366c:	19 95       	eicall
		temp_char = num & 0x0F;
    366e:	6e 2d       	mov	r22, r14
    3670:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3672:	d8 01       	movw	r26, r16
    3674:	ed 91       	ld	r30, X+
    3676:	fc 91       	ld	r31, X
    3678:	02 80       	ldd	r0, Z+2	; 0x02
    367a:	f3 81       	ldd	r31, Z+3	; 0x03
    367c:	e0 2d       	mov	r30, r0
    367e:	6a 30       	cpi	r22, 0x0A	; 10
    3680:	10 f0       	brcs	.+4      	; 0x3686 <_ZN8emstreamlsEh+0xc2>
    3682:	69 5c       	subi	r22, 0xC9	; 201
    3684:	01 c0       	rjmp	.+2      	; 0x3688 <_ZN8emstreamlsEh+0xc4>
    3686:	60 5d       	subi	r22, 0xD0	; 208
    3688:	c8 01       	movw	r24, r16
    368a:	19 95       	eicall
    368c:	0e c0       	rjmp	.+28     	; 0x36aa <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    368e:	50 e0       	ldi	r21, 0x00	; 0
    3690:	be 01       	movw	r22, r28
    3692:	6f 5f       	subi	r22, 0xFF	; 255
    3694:	7f 4f       	sbci	r23, 0xFF	; 255
    3696:	8e 2d       	mov	r24, r14
    3698:	90 e0       	ldi	r25, 0x00	; 0
    369a:	0e 94 b5 22 	call	0x456a	; 0x456a <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    369e:	be 01       	movw	r22, r28
    36a0:	6f 5f       	subi	r22, 0xFF	; 255
    36a2:	7f 4f       	sbci	r23, 0xFF	; 255
    36a4:	c8 01       	movw	r24, r16
    36a6:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    36aa:	c8 01       	movw	r24, r16
    36ac:	29 96       	adiw	r28, 0x09	; 9
    36ae:	cd bf       	out	0x3d, r28	; 61
    36b0:	de bf       	out	0x3e, r29	; 62
    36b2:	df 91       	pop	r29
    36b4:	cf 91       	pop	r28
    36b6:	1f 91       	pop	r17
    36b8:	0f 91       	pop	r16
    36ba:	ff 90       	pop	r15
    36bc:	ef 90       	pop	r14
    36be:	df 90       	pop	r13
    36c0:	cf 90       	pop	r12
    36c2:	08 95       	ret

000036c4 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    36c4:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36c6:	50 96       	adiw	r26, 0x10	; 16
    36c8:	ed 91       	ld	r30, X+
    36ca:	fc 91       	ld	r31, X
    36cc:	51 97       	sbiw	r26, 0x11	; 17
    36ce:	80 81       	ld	r24, Z
    36d0:	54 96       	adiw	r26, 0x14	; 20
    36d2:	4c 91       	ld	r20, X
    36d4:	54 97       	sbiw	r26, 0x14	; 20
    36d6:	84 23       	and	r24, r20
    36d8:	29 f0       	breq	.+10     	; 0x36e4 <_ZN5rs2327putcharEc+0x20>
    36da:	09 c0       	rjmp	.+18     	; 0x36ee <_ZN5rs2327putcharEc+0x2a>
    36dc:	21 50       	subi	r18, 0x01	; 1
    36de:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    36e0:	19 f4       	brne	.+6      	; 0x36e8 <_ZN5rs2327putcharEc+0x24>
    36e2:	12 c0       	rjmp	.+36     	; 0x3708 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36e4:	21 e2       	ldi	r18, 0x21	; 33
    36e6:	3e e4       	ldi	r19, 0x4E	; 78
    36e8:	90 81       	ld	r25, Z
    36ea:	94 23       	and	r25, r20
    36ec:	b9 f3       	breq	.-18     	; 0x36dc <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    36ee:	90 81       	ld	r25, Z
    36f0:	56 96       	adiw	r26, 0x16	; 22
    36f2:	8c 91       	ld	r24, X
    36f4:	56 97       	sbiw	r26, 0x16	; 22
    36f6:	89 2b       	or	r24, r25
    36f8:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    36fa:	1e 96       	adiw	r26, 0x0e	; 14
    36fc:	ed 91       	ld	r30, X+
    36fe:	fc 91       	ld	r31, X
    3700:	1f 97       	sbiw	r26, 0x0f	; 15
    3702:	60 83       	st	Z, r22
	return (true);
    3704:	81 e0       	ldi	r24, 0x01	; 1
    3706:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3708:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    370a:	08 95       	ret

0000370c <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    370c:	cf 93       	push	r28
    370e:	df 93       	push	r29
    3710:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3712:	c1 8d       	ldd	r28, Z+25	; 0x19
    3714:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3716:	28 81       	ld	r18, Y
    3718:	39 81       	ldd	r19, Y+1	; 0x01
    371a:	a3 8d       	ldd	r26, Z+27	; 0x1b
    371c:	b4 8d       	ldd	r27, Z+28	; 0x1c
    371e:	4d 91       	ld	r20, X+
    3720:	5c 91       	ld	r21, X
    3722:	24 17       	cp	r18, r20
    3724:	35 07       	cpc	r19, r21
    3726:	e9 f3       	breq	.-6      	; 0x3722 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3728:	a7 89       	ldd	r26, Z+23	; 0x17
    372a:	b0 8d       	ldd	r27, Z+24	; 0x18
    372c:	0d 90       	ld	r0, X+
    372e:	bc 91       	ld	r27, X
    3730:	a0 2d       	mov	r26, r0
    3732:	a2 0f       	add	r26, r18
    3734:	b3 1f       	adc	r27, r19
    3736:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3738:	2f 5f       	subi	r18, 0xFF	; 255
    373a:	3f 4f       	sbci	r19, 0xFF	; 255
    373c:	28 83       	st	Y, r18
    373e:	39 83       	std	Y+1, r19	; 0x01
    3740:	24 36       	cpi	r18, 0x64	; 100
    3742:	31 05       	cpc	r19, r1
    3744:	28 f0       	brcs	.+10     	; 0x3750 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3746:	01 8c       	ldd	r0, Z+25	; 0x19
    3748:	f2 8d       	ldd	r31, Z+26	; 0x1a
    374a:	e0 2d       	mov	r30, r0
    374c:	10 82       	st	Z, r1
    374e:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3750:	90 e0       	ldi	r25, 0x00	; 0
    3752:	df 91       	pop	r29
    3754:	cf 91       	pop	r28
    3756:	08 95       	ret

00003758 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3758:	cf 93       	push	r28
    375a:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    375c:	ec 01       	movw	r28, r24
    375e:	a9 8d       	ldd	r26, Y+25	; 0x19
    3760:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3762:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3764:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3766:	81 e0       	ldi	r24, 0x01	; 1
    3768:	4d 91       	ld	r20, X+
    376a:	5c 91       	ld	r21, X
    376c:	20 81       	ld	r18, Z
    376e:	31 81       	ldd	r19, Z+1	; 0x01
    3770:	42 17       	cp	r20, r18
    3772:	53 07       	cpc	r21, r19
    3774:	09 f4       	brne	.+2      	; 0x3778 <_ZN5rs23214check_for_charEv+0x20>
    3776:	80 e0       	ldi	r24, 0x00	; 0
}
    3778:	df 91       	pop	r29
    377a:	cf 91       	pop	r28
    377c:	08 95       	ret

0000377e <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    377e:	dc 01       	movw	r26, r24
    3780:	ed 91       	ld	r30, X+
    3782:	fc 91       	ld	r31, X
    3784:	02 80       	ldd	r0, Z+2	; 0x02
    3786:	f3 81       	ldd	r31, Z+3	; 0x03
    3788:	e0 2d       	mov	r30, r0
    378a:	6c e0       	ldi	r22, 0x0C	; 12
    378c:	19 95       	eicall
    378e:	08 95       	ret

00003790 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3790:	ef 92       	push	r14
    3792:	ff 92       	push	r15
    3794:	0f 93       	push	r16
    3796:	1f 93       	push	r17
    3798:	cf 93       	push	r28
    379a:	df 93       	push	r29
    379c:	ec 01       	movw	r28, r24
    379e:	7b 01       	movw	r14, r22
    37a0:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    37a2:	0e 94 b7 19 	call	0x336e	; 0x336e <_ZN8emstreamC1Ev>
    37a6:	a8 01       	movw	r20, r16
    37a8:	b7 01       	movw	r22, r14
    37aa:	ce 01       	movw	r24, r28
    37ac:	08 96       	adiw	r24, 0x08	; 8
    37ae:	0e 94 fe 18 	call	0x31fc	; 0x31fc <_ZN7base232C1EjP12USART_struct>
    37b2:	89 e7       	ldi	r24, 0x79	; 121
    37b4:	90 e2       	ldi	r25, 0x20	; 32
    37b6:	88 83       	st	Y, r24
    37b8:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    37ba:	00 3a       	cpi	r16, 0xA0	; 160
    37bc:	88 e0       	ldi	r24, 0x08	; 8
    37be:	18 07       	cpc	r17, r24
    37c0:	69 f4       	brne	.+26     	; 0x37dc <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    37c2:	8e e5       	ldi	r24, 0x5E	; 94
    37c4:	91 e3       	ldi	r25, 0x31	; 49
    37c6:	8f 8b       	std	Y+23, r24	; 0x17
    37c8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    37ca:	80 e5       	ldi	r24, 0x50	; 80
    37cc:	91 e3       	ldi	r25, 0x31	; 49
    37ce:	89 8f       	std	Y+25, r24	; 0x19
    37d0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    37d2:	82 e4       	ldi	r24, 0x42	; 66
    37d4:	91 e3       	ldi	r25, 0x31	; 49
    37d6:	8b 8f       	std	Y+27, r24	; 0x1b
    37d8:	9c 8f       	std	Y+28, r25	; 0x1c
    37da:	64 c0       	rjmp	.+200    	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    37dc:	00 3b       	cpi	r16, 0xB0	; 176
    37de:	e8 e0       	ldi	r30, 0x08	; 8
    37e0:	1e 07       	cpc	r17, r30
    37e2:	69 f4       	brne	.+26     	; 0x37fe <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    37e4:	8c e5       	ldi	r24, 0x5C	; 92
    37e6:	91 e3       	ldi	r25, 0x31	; 49
    37e8:	8f 8b       	std	Y+23, r24	; 0x17
    37ea:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    37ec:	8e e4       	ldi	r24, 0x4E	; 78
    37ee:	91 e3       	ldi	r25, 0x31	; 49
    37f0:	89 8f       	std	Y+25, r24	; 0x19
    37f2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    37f4:	80 e4       	ldi	r24, 0x40	; 64
    37f6:	91 e3       	ldi	r25, 0x31	; 49
    37f8:	8b 8f       	std	Y+27, r24	; 0x1b
    37fa:	9c 8f       	std	Y+28, r25	; 0x1c
    37fc:	53 c0       	rjmp	.+166    	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    37fe:	00 3a       	cpi	r16, 0xA0	; 160
    3800:	f9 e0       	ldi	r31, 0x09	; 9
    3802:	1f 07       	cpc	r17, r31
    3804:	69 f4       	brne	.+26     	; 0x3820 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3806:	8a e5       	ldi	r24, 0x5A	; 90
    3808:	91 e3       	ldi	r25, 0x31	; 49
    380a:	8f 8b       	std	Y+23, r24	; 0x17
    380c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    380e:	8c e4       	ldi	r24, 0x4C	; 76
    3810:	91 e3       	ldi	r25, 0x31	; 49
    3812:	89 8f       	std	Y+25, r24	; 0x19
    3814:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3816:	8e e3       	ldi	r24, 0x3E	; 62
    3818:	91 e3       	ldi	r25, 0x31	; 49
    381a:	8b 8f       	std	Y+27, r24	; 0x1b
    381c:	9c 8f       	std	Y+28, r25	; 0x1c
    381e:	42 c0       	rjmp	.+132    	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3820:	00 3b       	cpi	r16, 0xB0	; 176
    3822:	89 e0       	ldi	r24, 0x09	; 9
    3824:	18 07       	cpc	r17, r24
    3826:	69 f4       	brne	.+26     	; 0x3842 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3828:	88 e5       	ldi	r24, 0x58	; 88
    382a:	91 e3       	ldi	r25, 0x31	; 49
    382c:	8f 8b       	std	Y+23, r24	; 0x17
    382e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3830:	8a e4       	ldi	r24, 0x4A	; 74
    3832:	91 e3       	ldi	r25, 0x31	; 49
    3834:	89 8f       	std	Y+25, r24	; 0x19
    3836:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3838:	8c e3       	ldi	r24, 0x3C	; 60
    383a:	91 e3       	ldi	r25, 0x31	; 49
    383c:	8b 8f       	std	Y+27, r24	; 0x1b
    383e:	9c 8f       	std	Y+28, r25	; 0x1c
    3840:	31 c0       	rjmp	.+98     	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3842:	00 3a       	cpi	r16, 0xA0	; 160
    3844:	ea e0       	ldi	r30, 0x0A	; 10
    3846:	1e 07       	cpc	r17, r30
    3848:	69 f4       	brne	.+26     	; 0x3864 <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    384a:	86 e5       	ldi	r24, 0x56	; 86
    384c:	91 e3       	ldi	r25, 0x31	; 49
    384e:	8f 8b       	std	Y+23, r24	; 0x17
    3850:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3852:	88 e4       	ldi	r24, 0x48	; 72
    3854:	91 e3       	ldi	r25, 0x31	; 49
    3856:	89 8f       	std	Y+25, r24	; 0x19
    3858:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    385a:	8a e3       	ldi	r24, 0x3A	; 58
    385c:	91 e3       	ldi	r25, 0x31	; 49
    385e:	8b 8f       	std	Y+27, r24	; 0x1b
    3860:	9c 8f       	std	Y+28, r25	; 0x1c
    3862:	20 c0       	rjmp	.+64     	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    3864:	00 3b       	cpi	r16, 0xB0	; 176
    3866:	fa e0       	ldi	r31, 0x0A	; 10
    3868:	1f 07       	cpc	r17, r31
    386a:	69 f4       	brne	.+26     	; 0x3886 <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    386c:	84 e5       	ldi	r24, 0x54	; 84
    386e:	91 e3       	ldi	r25, 0x31	; 49
    3870:	8f 8b       	std	Y+23, r24	; 0x17
    3872:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    3874:	86 e4       	ldi	r24, 0x46	; 70
    3876:	91 e3       	ldi	r25, 0x31	; 49
    3878:	89 8f       	std	Y+25, r24	; 0x19
    387a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    387c:	88 e3       	ldi	r24, 0x38	; 56
    387e:	91 e3       	ldi	r25, 0x31	; 49
    3880:	8b 8f       	std	Y+27, r24	; 0x1b
    3882:	9c 8f       	std	Y+28, r25	; 0x1c
    3884:	0f c0       	rjmp	.+30     	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    3886:	00 3a       	cpi	r16, 0xA0	; 160
    3888:	1b 40       	sbci	r17, 0x0B	; 11
    388a:	61 f4       	brne	.+24     	; 0x38a4 <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    388c:	82 e5       	ldi	r24, 0x52	; 82
    388e:	91 e3       	ldi	r25, 0x31	; 49
    3890:	8f 8b       	std	Y+23, r24	; 0x17
    3892:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    3894:	84 e4       	ldi	r24, 0x44	; 68
    3896:	91 e3       	ldi	r25, 0x31	; 49
    3898:	89 8f       	std	Y+25, r24	; 0x19
    389a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    389c:	86 e3       	ldi	r24, 0x36	; 54
    389e:	91 e3       	ldi	r25, 0x31	; 49
    38a0:	8b 8f       	std	Y+27, r24	; 0x1b
    38a2:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    38a4:	0f 89       	ldd	r16, Y+23	; 0x17
    38a6:	18 8d       	ldd	r17, Y+24	; 0x18
    38a8:	84 e6       	ldi	r24, 0x64	; 100
    38aa:	90 e0       	ldi	r25, 0x00	; 0
    38ac:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <_Znaj>
    38b0:	f8 01       	movw	r30, r16
    38b2:	80 83       	st	Z, r24
    38b4:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    38b6:	e9 8d       	ldd	r30, Y+25	; 0x19
    38b8:	fa 8d       	ldd	r31, Y+26	; 0x1a
    38ba:	10 82       	st	Z, r1
    38bc:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    38be:	eb 8d       	ldd	r30, Y+27	; 0x1b
    38c0:	fc 8d       	ldd	r31, Y+28	; 0x1c
    38c2:	10 82       	st	Z, r1
    38c4:	11 82       	std	Z+1, r1	; 0x01
}
    38c6:	df 91       	pop	r29
    38c8:	cf 91       	pop	r28
    38ca:	1f 91       	pop	r17
    38cc:	0f 91       	pop	r16
    38ce:	ff 90       	pop	r15
    38d0:	ef 90       	pop	r14
    38d2:	08 95       	ret

000038d4 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    38d4:	1f 92       	push	r1
    38d6:	0f 92       	push	r0
    38d8:	0f b6       	in	r0, 0x3f	; 63
    38da:	0f 92       	push	r0
    38dc:	11 24       	eor	r1, r1
    38de:	08 b6       	in	r0, 0x38	; 56
    38e0:	0f 92       	push	r0
    38e2:	18 be       	out	0x38, r1	; 56
    38e4:	0b b6       	in	r0, 0x3b	; 59
    38e6:	0f 92       	push	r0
    38e8:	1b be       	out	0x3b, r1	; 59
    38ea:	2f 93       	push	r18
    38ec:	3f 93       	push	r19
    38ee:	8f 93       	push	r24
    38f0:	9f 93       	push	r25
    38f2:	ef 93       	push	r30
    38f4:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    38f6:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    38fa:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <rcvC0_buffer>
    38fe:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <rcvC0_buffer+0x1>
    3902:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    3906:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    390a:	e8 0f       	add	r30, r24
    390c:	f9 1f       	adc	r31, r25
    390e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3910:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    3914:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    3918:	01 96       	adiw	r24, 0x01	; 1
    391a:	84 36       	cpi	r24, 0x64	; 100
    391c:	91 05       	cpc	r25, r1
    391e:	60 f4       	brcc	.+24     	; 0x3938 <__vector_25+0x64>
    3920:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <rcvC0_write_index>
    3924:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3928:	20 91 50 31 	lds	r18, 0x3150	; 0x803150 <rcvC0_read_index>
    392c:	30 91 51 31 	lds	r19, 0x3151	; 0x803151 <rcvC0_read_index+0x1>
    3930:	82 17       	cp	r24, r18
    3932:	93 07       	cpc	r25, r19
    3934:	f1 f4       	brne	.+60     	; 0x3972 <__vector_25+0x9e>
    3936:	0c c0       	rjmp	.+24     	; 0x3950 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3938:	10 92 42 31 	sts	0x3142, r1	; 0x803142 <rcvC0_write_index>
    393c:	10 92 43 31 	sts	0x3143, r1	; 0x803143 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3940:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC0_read_index>
    3944:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC0_read_index+0x1>
    3948:	18 16       	cp	r1, r24
    394a:	19 06       	cpc	r1, r25
    394c:	91 f4       	brne	.+36     	; 0x3972 <__vector_25+0x9e>
    394e:	0e c0       	rjmp	.+28     	; 0x396c <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3950:	01 96       	adiw	r24, 0x01	; 1
    3952:	84 36       	cpi	r24, 0x64	; 100
    3954:	91 05       	cpc	r25, r1
    3956:	28 f4       	brcc	.+10     	; 0x3962 <__vector_25+0x8e>
    3958:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvC0_read_index>
    395c:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvC0_read_index+0x1>
    3960:	08 c0       	rjmp	.+16     	; 0x3972 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3962:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvC0_read_index>
    3966:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvC0_read_index+0x1>
}
    396a:	03 c0       	rjmp	.+6      	; 0x3972 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    396c:	81 e0       	ldi	r24, 0x01	; 1
    396e:	90 e0       	ldi	r25, 0x00	; 0
    3970:	f3 cf       	rjmp	.-26     	; 0x3958 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3972:	ff 91       	pop	r31
    3974:	ef 91       	pop	r30
    3976:	9f 91       	pop	r25
    3978:	8f 91       	pop	r24
    397a:	3f 91       	pop	r19
    397c:	2f 91       	pop	r18
    397e:	0f 90       	pop	r0
    3980:	0b be       	out	0x3b, r0	; 59
    3982:	0f 90       	pop	r0
    3984:	08 be       	out	0x38, r0	; 56
    3986:	0f 90       	pop	r0
    3988:	0f be       	out	0x3f, r0	; 63
    398a:	0f 90       	pop	r0
    398c:	1f 90       	pop	r1
    398e:	18 95       	reti

00003990 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3990:	1f 92       	push	r1
    3992:	0f 92       	push	r0
    3994:	0f b6       	in	r0, 0x3f	; 63
    3996:	0f 92       	push	r0
    3998:	11 24       	eor	r1, r1
    399a:	08 b6       	in	r0, 0x38	; 56
    399c:	0f 92       	push	r0
    399e:	18 be       	out	0x38, r1	; 56
    39a0:	0b b6       	in	r0, 0x3b	; 59
    39a2:	0f 92       	push	r0
    39a4:	1b be       	out	0x3b, r1	; 59
    39a6:	2f 93       	push	r18
    39a8:	3f 93       	push	r19
    39aa:	8f 93       	push	r24
    39ac:	9f 93       	push	r25
    39ae:	ef 93       	push	r30
    39b0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    39b2:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    39b6:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <rcvC1_buffer>
    39ba:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <rcvC1_buffer+0x1>
    39be:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC1_write_index>
    39c2:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC1_write_index+0x1>
    39c6:	e8 0f       	add	r30, r24
    39c8:	f9 1f       	adc	r31, r25
    39ca:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    39cc:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC1_write_index>
    39d0:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC1_write_index+0x1>
    39d4:	01 96       	adiw	r24, 0x01	; 1
    39d6:	84 36       	cpi	r24, 0x64	; 100
    39d8:	91 05       	cpc	r25, r1
    39da:	60 f4       	brcc	.+24     	; 0x39f4 <__vector_28+0x64>
    39dc:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <rcvC1_write_index>
    39e0:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39e4:	20 91 4e 31 	lds	r18, 0x314E	; 0x80314e <rcvC1_read_index>
    39e8:	30 91 4f 31 	lds	r19, 0x314F	; 0x80314f <rcvC1_read_index+0x1>
    39ec:	82 17       	cp	r24, r18
    39ee:	93 07       	cpc	r25, r19
    39f0:	f1 f4       	brne	.+60     	; 0x3a2e <__vector_28+0x9e>
    39f2:	0c c0       	rjmp	.+24     	; 0x3a0c <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    39f4:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rcvC1_write_index>
    39f8:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39fc:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvC1_read_index>
    3a00:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvC1_read_index+0x1>
    3a04:	18 16       	cp	r1, r24
    3a06:	19 06       	cpc	r1, r25
    3a08:	91 f4       	brne	.+36     	; 0x3a2e <__vector_28+0x9e>
    3a0a:	0e c0       	rjmp	.+28     	; 0x3a28 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a0c:	01 96       	adiw	r24, 0x01	; 1
    3a0e:	84 36       	cpi	r24, 0x64	; 100
    3a10:	91 05       	cpc	r25, r1
    3a12:	28 f4       	brcc	.+10     	; 0x3a1e <__vector_28+0x8e>
    3a14:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvC1_read_index>
    3a18:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvC1_read_index+0x1>
    3a1c:	08 c0       	rjmp	.+16     	; 0x3a2e <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3a1e:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvC1_read_index>
    3a22:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvC1_read_index+0x1>
}
    3a26:	03 c0       	rjmp	.+6      	; 0x3a2e <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a28:	81 e0       	ldi	r24, 0x01	; 1
    3a2a:	90 e0       	ldi	r25, 0x00	; 0
    3a2c:	f3 cf       	rjmp	.-26     	; 0x3a14 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3a2e:	ff 91       	pop	r31
    3a30:	ef 91       	pop	r30
    3a32:	9f 91       	pop	r25
    3a34:	8f 91       	pop	r24
    3a36:	3f 91       	pop	r19
    3a38:	2f 91       	pop	r18
    3a3a:	0f 90       	pop	r0
    3a3c:	0b be       	out	0x3b, r0	; 59
    3a3e:	0f 90       	pop	r0
    3a40:	08 be       	out	0x38, r0	; 56
    3a42:	0f 90       	pop	r0
    3a44:	0f be       	out	0x3f, r0	; 63
    3a46:	0f 90       	pop	r0
    3a48:	1f 90       	pop	r1
    3a4a:	18 95       	reti

00003a4c <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3a4c:	1f 92       	push	r1
    3a4e:	0f 92       	push	r0
    3a50:	0f b6       	in	r0, 0x3f	; 63
    3a52:	0f 92       	push	r0
    3a54:	11 24       	eor	r1, r1
    3a56:	08 b6       	in	r0, 0x38	; 56
    3a58:	0f 92       	push	r0
    3a5a:	18 be       	out	0x38, r1	; 56
    3a5c:	0b b6       	in	r0, 0x3b	; 59
    3a5e:	0f 92       	push	r0
    3a60:	1b be       	out	0x3b, r1	; 59
    3a62:	2f 93       	push	r18
    3a64:	3f 93       	push	r19
    3a66:	8f 93       	push	r24
    3a68:	9f 93       	push	r25
    3a6a:	ef 93       	push	r30
    3a6c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3a6e:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3a72:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <rcvD0_buffer>
    3a76:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <rcvD0_buffer+0x1>
    3a7a:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    3a7e:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    3a82:	e8 0f       	add	r30, r24
    3a84:	f9 1f       	adc	r31, r25
    3a86:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3a88:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvD0_write_index>
    3a8c:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvD0_write_index+0x1>
    3a90:	01 96       	adiw	r24, 0x01	; 1
    3a92:	84 36       	cpi	r24, 0x64	; 100
    3a94:	91 05       	cpc	r25, r1
    3a96:	60 f4       	brcc	.+24     	; 0x3ab0 <__vector_88+0x64>
    3a98:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <rcvD0_write_index>
    3a9c:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3aa0:	20 91 4c 31 	lds	r18, 0x314C	; 0x80314c <rcvD0_read_index>
    3aa4:	30 91 4d 31 	lds	r19, 0x314D	; 0x80314d <rcvD0_read_index+0x1>
    3aa8:	82 17       	cp	r24, r18
    3aaa:	93 07       	cpc	r25, r19
    3aac:	f1 f4       	brne	.+60     	; 0x3aea <__vector_88+0x9e>
    3aae:	0c c0       	rjmp	.+24     	; 0x3ac8 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3ab0:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <rcvD0_write_index>
    3ab4:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3ab8:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD0_read_index>
    3abc:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD0_read_index+0x1>
    3ac0:	18 16       	cp	r1, r24
    3ac2:	19 06       	cpc	r1, r25
    3ac4:	91 f4       	brne	.+36     	; 0x3aea <__vector_88+0x9e>
    3ac6:	0e c0       	rjmp	.+28     	; 0x3ae4 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3ac8:	01 96       	adiw	r24, 0x01	; 1
    3aca:	84 36       	cpi	r24, 0x64	; 100
    3acc:	91 05       	cpc	r25, r1
    3ace:	28 f4       	brcc	.+10     	; 0x3ada <__vector_88+0x8e>
    3ad0:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvD0_read_index>
    3ad4:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvD0_read_index+0x1>
    3ad8:	08 c0       	rjmp	.+16     	; 0x3aea <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3ada:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvD0_read_index>
    3ade:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvD0_read_index+0x1>
}
    3ae2:	03 c0       	rjmp	.+6      	; 0x3aea <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3ae4:	81 e0       	ldi	r24, 0x01	; 1
    3ae6:	90 e0       	ldi	r25, 0x00	; 0
    3ae8:	f3 cf       	rjmp	.-26     	; 0x3ad0 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3aea:	ff 91       	pop	r31
    3aec:	ef 91       	pop	r30
    3aee:	9f 91       	pop	r25
    3af0:	8f 91       	pop	r24
    3af2:	3f 91       	pop	r19
    3af4:	2f 91       	pop	r18
    3af6:	0f 90       	pop	r0
    3af8:	0b be       	out	0x3b, r0	; 59
    3afa:	0f 90       	pop	r0
    3afc:	08 be       	out	0x38, r0	; 56
    3afe:	0f 90       	pop	r0
    3b00:	0f be       	out	0x3f, r0	; 63
    3b02:	0f 90       	pop	r0
    3b04:	1f 90       	pop	r1
    3b06:	18 95       	reti

00003b08 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3b08:	1f 92       	push	r1
    3b0a:	0f 92       	push	r0
    3b0c:	0f b6       	in	r0, 0x3f	; 63
    3b0e:	0f 92       	push	r0
    3b10:	11 24       	eor	r1, r1
    3b12:	08 b6       	in	r0, 0x38	; 56
    3b14:	0f 92       	push	r0
    3b16:	18 be       	out	0x38, r1	; 56
    3b18:	0b b6       	in	r0, 0x3b	; 59
    3b1a:	0f 92       	push	r0
    3b1c:	1b be       	out	0x3b, r1	; 59
    3b1e:	2f 93       	push	r18
    3b20:	3f 93       	push	r19
    3b22:	8f 93       	push	r24
    3b24:	9f 93       	push	r25
    3b26:	ef 93       	push	r30
    3b28:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3b2a:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3b2e:	e0 91 58 31 	lds	r30, 0x3158	; 0x803158 <rcvD1_buffer>
    3b32:	f0 91 59 31 	lds	r31, 0x3159	; 0x803159 <rcvD1_buffer+0x1>
    3b36:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvD1_write_index>
    3b3a:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvD1_write_index+0x1>
    3b3e:	e8 0f       	add	r30, r24
    3b40:	f9 1f       	adc	r31, r25
    3b42:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3b44:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvD1_write_index>
    3b48:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvD1_write_index+0x1>
    3b4c:	01 96       	adiw	r24, 0x01	; 1
    3b4e:	84 36       	cpi	r24, 0x64	; 100
    3b50:	91 05       	cpc	r25, r1
    3b52:	60 f4       	brcc	.+24     	; 0x3b6c <__vector_91+0x64>
    3b54:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <rcvD1_write_index>
    3b58:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b5c:	20 91 4a 31 	lds	r18, 0x314A	; 0x80314a <rcvD1_read_index>
    3b60:	30 91 4b 31 	lds	r19, 0x314B	; 0x80314b <rcvD1_read_index+0x1>
    3b64:	82 17       	cp	r24, r18
    3b66:	93 07       	cpc	r25, r19
    3b68:	f1 f4       	brne	.+60     	; 0x3ba6 <__vector_91+0x9e>
    3b6a:	0c c0       	rjmp	.+24     	; 0x3b84 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3b6c:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rcvD1_write_index>
    3b70:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b74:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvD1_read_index>
    3b78:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvD1_read_index+0x1>
    3b7c:	18 16       	cp	r1, r24
    3b7e:	19 06       	cpc	r1, r25
    3b80:	91 f4       	brne	.+36     	; 0x3ba6 <__vector_91+0x9e>
    3b82:	0e c0       	rjmp	.+28     	; 0x3ba0 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b84:	01 96       	adiw	r24, 0x01	; 1
    3b86:	84 36       	cpi	r24, 0x64	; 100
    3b88:	91 05       	cpc	r25, r1
    3b8a:	28 f4       	brcc	.+10     	; 0x3b96 <__vector_91+0x8e>
    3b8c:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <rcvD1_read_index>
    3b90:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <rcvD1_read_index+0x1>
    3b94:	08 c0       	rjmp	.+16     	; 0x3ba6 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3b96:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <rcvD1_read_index>
    3b9a:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <rcvD1_read_index+0x1>
}
    3b9e:	03 c0       	rjmp	.+6      	; 0x3ba6 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3ba0:	81 e0       	ldi	r24, 0x01	; 1
    3ba2:	90 e0       	ldi	r25, 0x00	; 0
    3ba4:	f3 cf       	rjmp	.-26     	; 0x3b8c <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3ba6:	ff 91       	pop	r31
    3ba8:	ef 91       	pop	r30
    3baa:	9f 91       	pop	r25
    3bac:	8f 91       	pop	r24
    3bae:	3f 91       	pop	r19
    3bb0:	2f 91       	pop	r18
    3bb2:	0f 90       	pop	r0
    3bb4:	0b be       	out	0x3b, r0	; 59
    3bb6:	0f 90       	pop	r0
    3bb8:	08 be       	out	0x38, r0	; 56
    3bba:	0f 90       	pop	r0
    3bbc:	0f be       	out	0x3f, r0	; 63
    3bbe:	0f 90       	pop	r0
    3bc0:	1f 90       	pop	r1
    3bc2:	18 95       	reti

00003bc4 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3bc4:	1f 92       	push	r1
    3bc6:	0f 92       	push	r0
    3bc8:	0f b6       	in	r0, 0x3f	; 63
    3bca:	0f 92       	push	r0
    3bcc:	11 24       	eor	r1, r1
    3bce:	08 b6       	in	r0, 0x38	; 56
    3bd0:	0f 92       	push	r0
    3bd2:	18 be       	out	0x38, r1	; 56
    3bd4:	0b b6       	in	r0, 0x3b	; 59
    3bd6:	0f 92       	push	r0
    3bd8:	1b be       	out	0x3b, r1	; 59
    3bda:	2f 93       	push	r18
    3bdc:	3f 93       	push	r19
    3bde:	8f 93       	push	r24
    3be0:	9f 93       	push	r25
    3be2:	ef 93       	push	r30
    3be4:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3be6:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3bea:	e0 91 56 31 	lds	r30, 0x3156	; 0x803156 <rcvE0_buffer>
    3bee:	f0 91 57 31 	lds	r31, 0x3157	; 0x803157 <rcvE0_buffer+0x1>
    3bf2:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvE0_write_index>
    3bf6:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvE0_write_index+0x1>
    3bfa:	e8 0f       	add	r30, r24
    3bfc:	f9 1f       	adc	r31, r25
    3bfe:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3c00:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvE0_write_index>
    3c04:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvE0_write_index+0x1>
    3c08:	01 96       	adiw	r24, 0x01	; 1
    3c0a:	84 36       	cpi	r24, 0x64	; 100
    3c0c:	91 05       	cpc	r25, r1
    3c0e:	60 f4       	brcc	.+24     	; 0x3c28 <__vector_58+0x64>
    3c10:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvE0_write_index>
    3c14:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c18:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <rcvE0_read_index>
    3c1c:	30 91 49 31 	lds	r19, 0x3149	; 0x803149 <rcvE0_read_index+0x1>
    3c20:	82 17       	cp	r24, r18
    3c22:	93 07       	cpc	r25, r19
    3c24:	f1 f4       	brne	.+60     	; 0x3c62 <__vector_58+0x9e>
    3c26:	0c c0       	rjmp	.+24     	; 0x3c40 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3c28:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvE0_write_index>
    3c2c:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c30:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvE0_read_index>
    3c34:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvE0_read_index+0x1>
    3c38:	18 16       	cp	r1, r24
    3c3a:	19 06       	cpc	r1, r25
    3c3c:	91 f4       	brne	.+36     	; 0x3c62 <__vector_58+0x9e>
    3c3e:	0e c0       	rjmp	.+28     	; 0x3c5c <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c40:	01 96       	adiw	r24, 0x01	; 1
    3c42:	84 36       	cpi	r24, 0x64	; 100
    3c44:	91 05       	cpc	r25, r1
    3c46:	28 f4       	brcc	.+10     	; 0x3c52 <__vector_58+0x8e>
    3c48:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <rcvE0_read_index>
    3c4c:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <rcvE0_read_index+0x1>
    3c50:	08 c0       	rjmp	.+16     	; 0x3c62 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3c52:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rcvE0_read_index>
    3c56:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <rcvE0_read_index+0x1>
}
    3c5a:	03 c0       	rjmp	.+6      	; 0x3c62 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c5c:	81 e0       	ldi	r24, 0x01	; 1
    3c5e:	90 e0       	ldi	r25, 0x00	; 0
    3c60:	f3 cf       	rjmp	.-26     	; 0x3c48 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3c62:	ff 91       	pop	r31
    3c64:	ef 91       	pop	r30
    3c66:	9f 91       	pop	r25
    3c68:	8f 91       	pop	r24
    3c6a:	3f 91       	pop	r19
    3c6c:	2f 91       	pop	r18
    3c6e:	0f 90       	pop	r0
    3c70:	0b be       	out	0x3b, r0	; 59
    3c72:	0f 90       	pop	r0
    3c74:	08 be       	out	0x38, r0	; 56
    3c76:	0f 90       	pop	r0
    3c78:	0f be       	out	0x3f, r0	; 63
    3c7a:	0f 90       	pop	r0
    3c7c:	1f 90       	pop	r1
    3c7e:	18 95       	reti

00003c80 <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    3c80:	1f 92       	push	r1
    3c82:	0f 92       	push	r0
    3c84:	0f b6       	in	r0, 0x3f	; 63
    3c86:	0f 92       	push	r0
    3c88:	11 24       	eor	r1, r1
    3c8a:	08 b6       	in	r0, 0x38	; 56
    3c8c:	0f 92       	push	r0
    3c8e:	18 be       	out	0x38, r1	; 56
    3c90:	0b b6       	in	r0, 0x3b	; 59
    3c92:	0f 92       	push	r0
    3c94:	1b be       	out	0x3b, r1	; 59
    3c96:	2f 93       	push	r18
    3c98:	3f 93       	push	r19
    3c9a:	8f 93       	push	r24
    3c9c:	9f 93       	push	r25
    3c9e:	ef 93       	push	r30
    3ca0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    3ca2:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    3ca6:	e0 91 54 31 	lds	r30, 0x3154	; 0x803154 <rcvE1_buffer>
    3caa:	f0 91 55 31 	lds	r31, 0x3155	; 0x803155 <rcvE1_buffer+0x1>
    3cae:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvE1_write_index>
    3cb2:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvE1_write_index+0x1>
    3cb6:	e8 0f       	add	r30, r24
    3cb8:	f9 1f       	adc	r31, r25
    3cba:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    3cbc:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvE1_write_index>
    3cc0:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvE1_write_index+0x1>
    3cc4:	01 96       	adiw	r24, 0x01	; 1
    3cc6:	84 36       	cpi	r24, 0x64	; 100
    3cc8:	91 05       	cpc	r25, r1
    3cca:	60 f4       	brcc	.+24     	; 0x3ce4 <__vector_61+0x64>
    3ccc:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvE1_write_index>
    3cd0:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3cd4:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <rcvE1_read_index>
    3cd8:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <rcvE1_read_index+0x1>
    3cdc:	82 17       	cp	r24, r18
    3cde:	93 07       	cpc	r25, r19
    3ce0:	f1 f4       	brne	.+60     	; 0x3d1e <__vector_61+0x9e>
    3ce2:	0c c0       	rjmp	.+24     	; 0x3cfc <__vector_61+0x7c>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    3ce4:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvE1_write_index>
    3ce8:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3cec:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvE1_read_index>
    3cf0:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvE1_read_index+0x1>
    3cf4:	18 16       	cp	r1, r24
    3cf6:	19 06       	cpc	r1, r25
    3cf8:	91 f4       	brne	.+36     	; 0x3d1e <__vector_61+0x9e>
    3cfa:	0e c0       	rjmp	.+28     	; 0x3d18 <__vector_61+0x98>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3cfc:	01 96       	adiw	r24, 0x01	; 1
    3cfe:	84 36       	cpi	r24, 0x64	; 100
    3d00:	91 05       	cpc	r25, r1
    3d02:	28 f4       	brcc	.+10     	; 0x3d0e <__vector_61+0x8e>
    3d04:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvE1_read_index>
    3d08:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvE1_read_index+0x1>
    3d0c:	08 c0       	rjmp	.+16     	; 0x3d1e <__vector_61+0x9e>
	rcvE1_read_index = 0;
    3d0e:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvE1_read_index>
    3d12:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvE1_read_index+0x1>
}
    3d16:	03 c0       	rjmp	.+6      	; 0x3d1e <__vector_61+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3d18:	81 e0       	ldi	r24, 0x01	; 1
    3d1a:	90 e0       	ldi	r25, 0x00	; 0
    3d1c:	f3 cf       	rjmp	.-26     	; 0x3d04 <__vector_61+0x84>
	rcvE1_read_index = 0;
}
    3d1e:	ff 91       	pop	r31
    3d20:	ef 91       	pop	r30
    3d22:	9f 91       	pop	r25
    3d24:	8f 91       	pop	r24
    3d26:	3f 91       	pop	r19
    3d28:	2f 91       	pop	r18
    3d2a:	0f 90       	pop	r0
    3d2c:	0b be       	out	0x3b, r0	; 59
    3d2e:	0f 90       	pop	r0
    3d30:	08 be       	out	0x38, r0	; 56
    3d32:	0f 90       	pop	r0
    3d34:	0f be       	out	0x3f, r0	; 63
    3d36:	0f 90       	pop	r0
    3d38:	1f 90       	pop	r1
    3d3a:	18 95       	reti

00003d3c <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    3d3c:	1f 92       	push	r1
    3d3e:	0f 92       	push	r0
    3d40:	0f b6       	in	r0, 0x3f	; 63
    3d42:	0f 92       	push	r0
    3d44:	11 24       	eor	r1, r1
    3d46:	08 b6       	in	r0, 0x38	; 56
    3d48:	0f 92       	push	r0
    3d4a:	18 be       	out	0x38, r1	; 56
    3d4c:	0b b6       	in	r0, 0x3b	; 59
    3d4e:	0f 92       	push	r0
    3d50:	1b be       	out	0x3b, r1	; 59
    3d52:	2f 93       	push	r18
    3d54:	3f 93       	push	r19
    3d56:	8f 93       	push	r24
    3d58:	9f 93       	push	r25
    3d5a:	ef 93       	push	r30
    3d5c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    3d5e:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    3d62:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <rcvF0_buffer>
    3d66:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <rcvF0_buffer+0x1>
    3d6a:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvF0_write_index>
    3d6e:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvF0_write_index+0x1>
    3d72:	e8 0f       	add	r30, r24
    3d74:	f9 1f       	adc	r31, r25
    3d76:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    3d78:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvF0_write_index>
    3d7c:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvF0_write_index+0x1>
    3d80:	01 96       	adiw	r24, 0x01	; 1
    3d82:	84 36       	cpi	r24, 0x64	; 100
    3d84:	91 05       	cpc	r25, r1
    3d86:	60 f4       	brcc	.+24     	; 0x3da0 <__vector_119+0x64>
    3d88:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvF0_write_index>
    3d8c:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3d90:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <rcvF0_read_index>
    3d94:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <rcvF0_read_index+0x1>
    3d98:	82 17       	cp	r24, r18
    3d9a:	93 07       	cpc	r25, r19
    3d9c:	f1 f4       	brne	.+60     	; 0x3dda <__vector_119+0x9e>
    3d9e:	0c c0       	rjmp	.+24     	; 0x3db8 <__vector_119+0x7c>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    3da0:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvF0_write_index>
    3da4:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3da8:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <rcvF0_read_index>
    3dac:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <rcvF0_read_index+0x1>
    3db0:	18 16       	cp	r1, r24
    3db2:	19 06       	cpc	r1, r25
    3db4:	91 f4       	brne	.+36     	; 0x3dda <__vector_119+0x9e>
    3db6:	0e c0       	rjmp	.+28     	; 0x3dd4 <__vector_119+0x98>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3db8:	01 96       	adiw	r24, 0x01	; 1
    3dba:	84 36       	cpi	r24, 0x64	; 100
    3dbc:	91 05       	cpc	r25, r1
    3dbe:	28 f4       	brcc	.+10     	; 0x3dca <__vector_119+0x8e>
    3dc0:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <rcvF0_read_index>
    3dc4:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <rcvF0_read_index+0x1>
    3dc8:	08 c0       	rjmp	.+16     	; 0x3dda <__vector_119+0x9e>
	rcvF0_read_index = 0;
    3dca:	10 92 44 31 	sts	0x3144, r1	; 0x803144 <rcvF0_read_index>
    3dce:	10 92 45 31 	sts	0x3145, r1	; 0x803145 <rcvF0_read_index+0x1>
}
    3dd2:	03 c0       	rjmp	.+6      	; 0x3dda <__vector_119+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3dd4:	81 e0       	ldi	r24, 0x01	; 1
    3dd6:	90 e0       	ldi	r25, 0x00	; 0
    3dd8:	f3 cf       	rjmp	.-26     	; 0x3dc0 <__vector_119+0x84>
	rcvF0_read_index = 0;
}
    3dda:	ff 91       	pop	r31
    3ddc:	ef 91       	pop	r30
    3dde:	9f 91       	pop	r25
    3de0:	8f 91       	pop	r24
    3de2:	3f 91       	pop	r19
    3de4:	2f 91       	pop	r18
    3de6:	0f 90       	pop	r0
    3de8:	0b be       	out	0x3b, r0	; 59
    3dea:	0f 90       	pop	r0
    3dec:	08 be       	out	0x38, r0	; 56
    3dee:	0f 90       	pop	r0
    3df0:	0f be       	out	0x3f, r0	; 63
    3df2:	0f 90       	pop	r0
    3df4:	1f 90       	pop	r1
    3df6:	18 95       	reti

00003df8 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3df8:	0f 93       	push	r16
    3dfa:	cf 93       	push	r28
    3dfc:	df 93       	push	r29
    3dfe:	1f 92       	push	r1
    3e00:	cd b7       	in	r28, 0x3d	; 61
    3e02:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3e04:	2f b7       	in	r18, 0x3f	; 63
    3e06:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3e08:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3e0a:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3e0c:	fc 01       	movw	r30, r24
    3e0e:	08 ed       	ldi	r16, 0xD8	; 216
    3e10:	04 bf       	out	0x34, r16	; 52
    3e12:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3e14:	89 81       	ldd	r24, Y+1	; 0x01
    3e16:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3e18:	0f 90       	pop	r0
    3e1a:	df 91       	pop	r29
    3e1c:	cf 91       	pop	r28
    3e1e:	0f 91       	pop	r16
    3e20:	08 95       	ret

00003e22 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3e22:	0f 93       	push	r16
    3e24:	1f 93       	push	r17
    3e26:	cf 93       	push	r28
    3e28:	df 93       	push	r29
    3e2a:	cd b7       	in	r28, 0x3d	; 61
    3e2c:	de b7       	in	r29, 0x3e	; 62
    3e2e:	6d 97       	sbiw	r28, 0x1d	; 29
    3e30:	cd bf       	out	0x3d, r28	; 61
    3e32:	de bf       	out	0x3e, r29	; 62
	//Clear any interrupts
	cli();
    3e34:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3e36:	e0 e5       	ldi	r30, 0x50	; 80
    3e38:	f0 e0       	ldi	r31, 0x00	; 0
    3e3a:	80 81       	ld	r24, Z
    3e3c:	82 60       	ori	r24, 0x02	; 2
    3e3e:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3e40:	81 81       	ldd	r24, Z+1	; 0x01
    3e42:	81 ff       	sbrs	r24, 1
    3e44:	fd cf       	rjmp	.-6      	; 0x3e40 <main+0x1e>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3e46:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3e4a:	68 7f       	andi	r22, 0xF8	; 248
    3e4c:	61 60       	ori	r22, 0x01	; 1
    3e4e:	80 e4       	ldi	r24, 0x40	; 64
    3e50:	90 e0       	ldi	r25, 0x00	; 0
    3e52:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3e56:	e0 e5       	ldi	r30, 0x50	; 80
    3e58:	f0 e0       	ldi	r31, 0x00	; 0
    3e5a:	80 81       	ld	r24, Z
    3e5c:	8e 7f       	andi	r24, 0xFE	; 254
    3e5e:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3e60:	9d ef       	ldi	r25, 0xFD	; 253
    3e62:	88 ed       	ldi	r24, 0xD8	; 216
    3e64:	08 b6       	in	r0, 0x38	; 56
    3e66:	18 be       	out	0x38, r1	; 56
    3e68:	84 bf       	out	0x34, r24	; 52
    3e6a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3e6e:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
    3e70:	40 ea       	ldi	r20, 0xA0	; 160
    3e72:	58 e0       	ldi	r21, 0x08	; 8
    3e74:	60 e0       	ldi	r22, 0x00	; 0
    3e76:	70 e0       	ldi	r23, 0x00	; 0
    3e78:	ce 01       	movw	r24, r28
    3e7a:	01 96       	adiw	r24, 0x01	; 1
    3e7c:	0e 94 c8 1b 	call	0x3790	; 0x3790 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3e80:	67 e0       	ldi	r22, 0x07	; 7
    3e82:	ce 01       	movw	r24, r28
    3e84:	01 96       	adiw	r24, 0x01	; 1
    3e86:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    3e8a:	8c 01       	movw	r16, r24
    3e8c:	65 e8       	ldi	r22, 0x85	; 133
    3e8e:	70 e2       	ldi	r23, 0x20	; 32
    3e90:	0e 94 c5 19 	call	0x338a	; 0x338a <_ZN8emstream4putsEPKc>
    3e94:	66 e0       	ldi	r22, 0x06	; 6
    3e96:	c8 01       	movw	r24, r16
    3e98:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
    3e9c:	66 e0       	ldi	r22, 0x06	; 6
    3e9e:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3ea2:	82 e1       	ldi	r24, 0x12	; 18
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <_Znwj>
    3eaa:	8e 01       	movw	r16, r28
    3eac:	0f 5f       	subi	r16, 0xFF	; 255
    3eae:	1f 4f       	sbci	r17, 0xFF	; 255
    3eb0:	24 e0       	ldi	r18, 0x04	; 4
    3eb2:	31 e0       	ldi	r19, 0x01	; 1
    3eb4:	40 e0       	ldi	r20, 0x00	; 0
    3eb6:	64 ea       	ldi	r22, 0xA4	; 164
    3eb8:	70 e2       	ldi	r23, 0x20	; 32
    3eba:	0e 94 b1 06 	call	0xd62	; 0xd62 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3ebe:	82 e1       	ldi	r24, 0x12	; 18
    3ec0:	90 e0       	ldi	r25, 0x00	; 0
    3ec2:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <_Znwj>
    3ec6:	24 e0       	ldi	r18, 0x04	; 4
    3ec8:	31 e0       	ldi	r19, 0x01	; 1
    3eca:	42 e0       	ldi	r20, 0x02	; 2
    3ecc:	6c ea       	ldi	r22, 0xAC	; 172
    3ece:	70 e2       	ldi	r23, 0x20	; 32
    3ed0:	0e 94 a5 03 	call	0x74a	; 0x74a <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3ed4:	82 e1       	ldi	r24, 0x12	; 18
    3ed6:	90 e0       	ldi	r25, 0x00	; 0
    3ed8:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <_Znwj>
    3edc:	24 e0       	ldi	r18, 0x04	; 4
    3ede:	31 e0       	ldi	r19, 0x01	; 1
    3ee0:	43 e0       	ldi	r20, 0x03	; 3
    3ee2:	63 eb       	ldi	r22, 0xB3	; 179
    3ee4:	70 e2       	ldi	r23, 0x20	; 32
    3ee6:	0e 94 f6 03 	call	0x7ec	; 0x7ec <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3eea:	82 e1       	ldi	r24, 0x12	; 18
    3eec:	90 e0       	ldi	r25, 0x00	; 0
    3eee:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <_Znwj>
    3ef2:	24 e0       	ldi	r18, 0x04	; 4
    3ef4:	31 e0       	ldi	r19, 0x01	; 1
    3ef6:	44 e0       	ldi	r20, 0x04	; 4
    3ef8:	6a eb       	ldi	r22, 0xBA	; 186
    3efa:	70 e2       	ldi	r23, 0x20	; 32
    3efc:	0e 94 3b 04 	call	0x876	; 0x876 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(1), 260, &ser_dev);
    3f00:	82 e4       	ldi	r24, 0x42	; 66
    3f02:	90 e0       	ldi	r25, 0x00	; 0
    3f04:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <_Znwj>
    3f08:	24 e0       	ldi	r18, 0x04	; 4
    3f0a:	31 e0       	ldi	r19, 0x01	; 1
    3f0c:	41 e0       	ldi	r20, 0x01	; 1
    3f0e:	63 ec       	ldi	r22, 0xC3	; 195
    3f10:	70 e2       	ldi	r23, 0x20	; 32
    3f12:	0e 94 70 05 	call	0xae0	; 0xae0 <_ZN5MotorC1EPKchjP8emstream>

	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3f16:	87 e0       	ldi	r24, 0x07	; 7
    3f18:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3f1c:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3f1e:	0e 94 04 10 	call	0x2008	; 0x2008 <vTaskStartScheduler>
	
	return 0;
    3f22:	80 e0       	ldi	r24, 0x00	; 0
    3f24:	90 e0       	ldi	r25, 0x00	; 0
    3f26:	6d 96       	adiw	r28, 0x1d	; 29
    3f28:	cd bf       	out	0x3d, r28	; 61
    3f2a:	de bf       	out	0x3e, r29	; 62
    3f2c:	df 91       	pop	r29
    3f2e:	cf 91       	pop	r28
    3f30:	1f 91       	pop	r17
    3f32:	0f 91       	pop	r16
    3f34:	08 95       	ret

00003f36 <_GLOBAL__sub_I_counter>:
    3f36:	0f 93       	push	r16
    3f38:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3f3a:	0a e0       	ldi	r16, 0x0A	; 10
    3f3c:	10 e0       	ldi	r17, 0x00	; 0
    3f3e:	20 e0       	ldi	r18, 0x00	; 0
    3f40:	30 e0       	ldi	r19, 0x00	; 0
    3f42:	40 e0       	ldi	r20, 0x00	; 0
    3f44:	50 e0       	ldi	r21, 0x00	; 0
    3f46:	60 e2       	ldi	r22, 0x20	; 32
    3f48:	70 e0       	ldi	r23, 0x00	; 0
    3f4a:	86 e6       	ldi	r24, 0x66	; 102
    3f4c:	91 e3       	ldi	r25, 0x31	; 49
    3f4e:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    3f52:	1f 91       	pop	r17
    3f54:	0f 91       	pop	r16
    3f56:	08 95       	ret

00003f58 <__subsf3>:
    3f58:	50 58       	subi	r21, 0x80	; 128

00003f5a <__addsf3>:
    3f5a:	bb 27       	eor	r27, r27
    3f5c:	aa 27       	eor	r26, r26
    3f5e:	0e 94 c4 1f 	call	0x3f88	; 0x3f88 <__addsf3x>
    3f62:	0c 94 3e 21 	jmp	0x427c	; 0x427c <__fp_round>
    3f66:	0e 94 30 21 	call	0x4260	; 0x4260 <__fp_pscA>
    3f6a:	38 f0       	brcs	.+14     	; 0x3f7a <__addsf3+0x20>
    3f6c:	0e 94 37 21 	call	0x426e	; 0x426e <__fp_pscB>
    3f70:	20 f0       	brcs	.+8      	; 0x3f7a <__addsf3+0x20>
    3f72:	39 f4       	brne	.+14     	; 0x3f82 <__addsf3+0x28>
    3f74:	9f 3f       	cpi	r25, 0xFF	; 255
    3f76:	19 f4       	brne	.+6      	; 0x3f7e <__addsf3+0x24>
    3f78:	26 f4       	brtc	.+8      	; 0x3f82 <__addsf3+0x28>
    3f7a:	0c 94 2d 21 	jmp	0x425a	; 0x425a <__fp_nan>
    3f7e:	0e f4       	brtc	.+2      	; 0x3f82 <__addsf3+0x28>
    3f80:	e0 95       	com	r30
    3f82:	e7 fb       	bst	r30, 7
    3f84:	0c 94 27 21 	jmp	0x424e	; 0x424e <__fp_inf>

00003f88 <__addsf3x>:
    3f88:	e9 2f       	mov	r30, r25
    3f8a:	0e 94 4f 21 	call	0x429e	; 0x429e <__fp_split3>
    3f8e:	58 f3       	brcs	.-42     	; 0x3f66 <__addsf3+0xc>
    3f90:	ba 17       	cp	r27, r26
    3f92:	62 07       	cpc	r22, r18
    3f94:	73 07       	cpc	r23, r19
    3f96:	84 07       	cpc	r24, r20
    3f98:	95 07       	cpc	r25, r21
    3f9a:	20 f0       	brcs	.+8      	; 0x3fa4 <__addsf3x+0x1c>
    3f9c:	79 f4       	brne	.+30     	; 0x3fbc <__addsf3x+0x34>
    3f9e:	a6 f5       	brtc	.+104    	; 0x4008 <__stack+0x9>
    3fa0:	0c 94 71 21 	jmp	0x42e2	; 0x42e2 <__fp_zero>
    3fa4:	0e f4       	brtc	.+2      	; 0x3fa8 <__addsf3x+0x20>
    3fa6:	e0 95       	com	r30
    3fa8:	0b 2e       	mov	r0, r27
    3faa:	ba 2f       	mov	r27, r26
    3fac:	a0 2d       	mov	r26, r0
    3fae:	0b 01       	movw	r0, r22
    3fb0:	b9 01       	movw	r22, r18
    3fb2:	90 01       	movw	r18, r0
    3fb4:	0c 01       	movw	r0, r24
    3fb6:	ca 01       	movw	r24, r20
    3fb8:	a0 01       	movw	r20, r0
    3fba:	11 24       	eor	r1, r1
    3fbc:	ff 27       	eor	r31, r31
    3fbe:	59 1b       	sub	r21, r25
    3fc0:	99 f0       	breq	.+38     	; 0x3fe8 <__addsf3x+0x60>
    3fc2:	59 3f       	cpi	r21, 0xF9	; 249
    3fc4:	50 f4       	brcc	.+20     	; 0x3fda <__addsf3x+0x52>
    3fc6:	50 3e       	cpi	r21, 0xE0	; 224
    3fc8:	68 f1       	brcs	.+90     	; 0x4024 <__stack+0x25>
    3fca:	1a 16       	cp	r1, r26
    3fcc:	f0 40       	sbci	r31, 0x00	; 0
    3fce:	a2 2f       	mov	r26, r18
    3fd0:	23 2f       	mov	r18, r19
    3fd2:	34 2f       	mov	r19, r20
    3fd4:	44 27       	eor	r20, r20
    3fd6:	58 5f       	subi	r21, 0xF8	; 248
    3fd8:	f3 cf       	rjmp	.-26     	; 0x3fc0 <__addsf3x+0x38>
    3fda:	46 95       	lsr	r20
    3fdc:	37 95       	ror	r19
    3fde:	27 95       	ror	r18
    3fe0:	a7 95       	ror	r26
    3fe2:	f0 40       	sbci	r31, 0x00	; 0
    3fe4:	53 95       	inc	r21
    3fe6:	c9 f7       	brne	.-14     	; 0x3fda <__addsf3x+0x52>
    3fe8:	7e f4       	brtc	.+30     	; 0x4008 <__stack+0x9>
    3fea:	1f 16       	cp	r1, r31
    3fec:	ba 0b       	sbc	r27, r26
    3fee:	62 0b       	sbc	r22, r18
    3ff0:	73 0b       	sbc	r23, r19
    3ff2:	84 0b       	sbc	r24, r20
    3ff4:	ba f0       	brmi	.+46     	; 0x4024 <__stack+0x25>
    3ff6:	91 50       	subi	r25, 0x01	; 1
    3ff8:	a1 f0       	breq	.+40     	; 0x4022 <__stack+0x23>
    3ffa:	ff 0f       	add	r31, r31
    3ffc:	bb 1f       	adc	r27, r27
    3ffe:	66 1f       	adc	r22, r22
    4000:	77 1f       	adc	r23, r23
    4002:	88 1f       	adc	r24, r24
    4004:	c2 f7       	brpl	.-16     	; 0x3ff6 <__addsf3x+0x6e>
    4006:	0e c0       	rjmp	.+28     	; 0x4024 <__stack+0x25>
    4008:	ba 0f       	add	r27, r26
    400a:	62 1f       	adc	r22, r18
    400c:	73 1f       	adc	r23, r19
    400e:	84 1f       	adc	r24, r20
    4010:	48 f4       	brcc	.+18     	; 0x4024 <__stack+0x25>
    4012:	87 95       	ror	r24
    4014:	77 95       	ror	r23
    4016:	67 95       	ror	r22
    4018:	b7 95       	ror	r27
    401a:	f7 95       	ror	r31
    401c:	9e 3f       	cpi	r25, 0xFE	; 254
    401e:	08 f0       	brcs	.+2      	; 0x4022 <__stack+0x23>
    4020:	b0 cf       	rjmp	.-160    	; 0x3f82 <__addsf3+0x28>
    4022:	93 95       	inc	r25
    4024:	88 0f       	add	r24, r24
    4026:	08 f0       	brcs	.+2      	; 0x402a <__stack+0x2b>
    4028:	99 27       	eor	r25, r25
    402a:	ee 0f       	add	r30, r30
    402c:	97 95       	ror	r25
    402e:	87 95       	ror	r24
    4030:	08 95       	ret

00004032 <__cmpsf2>:
    4032:	0e 94 03 21 	call	0x4206	; 0x4206 <__fp_cmp>
    4036:	08 f4       	brcc	.+2      	; 0x403a <__cmpsf2+0x8>
    4038:	81 e0       	ldi	r24, 0x01	; 1
    403a:	08 95       	ret

0000403c <__divsf3>:
    403c:	0e 94 32 20 	call	0x4064	; 0x4064 <__divsf3x>
    4040:	0c 94 3e 21 	jmp	0x427c	; 0x427c <__fp_round>
    4044:	0e 94 37 21 	call	0x426e	; 0x426e <__fp_pscB>
    4048:	58 f0       	brcs	.+22     	; 0x4060 <__divsf3+0x24>
    404a:	0e 94 30 21 	call	0x4260	; 0x4260 <__fp_pscA>
    404e:	40 f0       	brcs	.+16     	; 0x4060 <__divsf3+0x24>
    4050:	29 f4       	brne	.+10     	; 0x405c <__divsf3+0x20>
    4052:	5f 3f       	cpi	r21, 0xFF	; 255
    4054:	29 f0       	breq	.+10     	; 0x4060 <__divsf3+0x24>
    4056:	0c 94 27 21 	jmp	0x424e	; 0x424e <__fp_inf>
    405a:	51 11       	cpse	r21, r1
    405c:	0c 94 72 21 	jmp	0x42e4	; 0x42e4 <__fp_szero>
    4060:	0c 94 2d 21 	jmp	0x425a	; 0x425a <__fp_nan>

00004064 <__divsf3x>:
    4064:	0e 94 4f 21 	call	0x429e	; 0x429e <__fp_split3>
    4068:	68 f3       	brcs	.-38     	; 0x4044 <__divsf3+0x8>

0000406a <__divsf3_pse>:
    406a:	99 23       	and	r25, r25
    406c:	b1 f3       	breq	.-20     	; 0x405a <__divsf3+0x1e>
    406e:	55 23       	and	r21, r21
    4070:	91 f3       	breq	.-28     	; 0x4056 <__divsf3+0x1a>
    4072:	95 1b       	sub	r25, r21
    4074:	55 0b       	sbc	r21, r21
    4076:	bb 27       	eor	r27, r27
    4078:	aa 27       	eor	r26, r26
    407a:	62 17       	cp	r22, r18
    407c:	73 07       	cpc	r23, r19
    407e:	84 07       	cpc	r24, r20
    4080:	38 f0       	brcs	.+14     	; 0x4090 <__divsf3_pse+0x26>
    4082:	9f 5f       	subi	r25, 0xFF	; 255
    4084:	5f 4f       	sbci	r21, 0xFF	; 255
    4086:	22 0f       	add	r18, r18
    4088:	33 1f       	adc	r19, r19
    408a:	44 1f       	adc	r20, r20
    408c:	aa 1f       	adc	r26, r26
    408e:	a9 f3       	breq	.-22     	; 0x407a <__divsf3_pse+0x10>
    4090:	35 d0       	rcall	.+106    	; 0x40fc <__divsf3_pse+0x92>
    4092:	0e 2e       	mov	r0, r30
    4094:	3a f0       	brmi	.+14     	; 0x40a4 <__divsf3_pse+0x3a>
    4096:	e0 e8       	ldi	r30, 0x80	; 128
    4098:	32 d0       	rcall	.+100    	; 0x40fe <__divsf3_pse+0x94>
    409a:	91 50       	subi	r25, 0x01	; 1
    409c:	50 40       	sbci	r21, 0x00	; 0
    409e:	e6 95       	lsr	r30
    40a0:	00 1c       	adc	r0, r0
    40a2:	ca f7       	brpl	.-14     	; 0x4096 <__divsf3_pse+0x2c>
    40a4:	2b d0       	rcall	.+86     	; 0x40fc <__divsf3_pse+0x92>
    40a6:	fe 2f       	mov	r31, r30
    40a8:	29 d0       	rcall	.+82     	; 0x40fc <__divsf3_pse+0x92>
    40aa:	66 0f       	add	r22, r22
    40ac:	77 1f       	adc	r23, r23
    40ae:	88 1f       	adc	r24, r24
    40b0:	bb 1f       	adc	r27, r27
    40b2:	26 17       	cp	r18, r22
    40b4:	37 07       	cpc	r19, r23
    40b6:	48 07       	cpc	r20, r24
    40b8:	ab 07       	cpc	r26, r27
    40ba:	b0 e8       	ldi	r27, 0x80	; 128
    40bc:	09 f0       	breq	.+2      	; 0x40c0 <__divsf3_pse+0x56>
    40be:	bb 0b       	sbc	r27, r27
    40c0:	80 2d       	mov	r24, r0
    40c2:	bf 01       	movw	r22, r30
    40c4:	ff 27       	eor	r31, r31
    40c6:	93 58       	subi	r25, 0x83	; 131
    40c8:	5f 4f       	sbci	r21, 0xFF	; 255
    40ca:	3a f0       	brmi	.+14     	; 0x40da <__divsf3_pse+0x70>
    40cc:	9e 3f       	cpi	r25, 0xFE	; 254
    40ce:	51 05       	cpc	r21, r1
    40d0:	78 f0       	brcs	.+30     	; 0x40f0 <__divsf3_pse+0x86>
    40d2:	0c 94 27 21 	jmp	0x424e	; 0x424e <__fp_inf>
    40d6:	0c 94 72 21 	jmp	0x42e4	; 0x42e4 <__fp_szero>
    40da:	5f 3f       	cpi	r21, 0xFF	; 255
    40dc:	e4 f3       	brlt	.-8      	; 0x40d6 <__divsf3_pse+0x6c>
    40de:	98 3e       	cpi	r25, 0xE8	; 232
    40e0:	d4 f3       	brlt	.-12     	; 0x40d6 <__divsf3_pse+0x6c>
    40e2:	86 95       	lsr	r24
    40e4:	77 95       	ror	r23
    40e6:	67 95       	ror	r22
    40e8:	b7 95       	ror	r27
    40ea:	f7 95       	ror	r31
    40ec:	9f 5f       	subi	r25, 0xFF	; 255
    40ee:	c9 f7       	brne	.-14     	; 0x40e2 <__divsf3_pse+0x78>
    40f0:	88 0f       	add	r24, r24
    40f2:	91 1d       	adc	r25, r1
    40f4:	96 95       	lsr	r25
    40f6:	87 95       	ror	r24
    40f8:	97 f9       	bld	r25, 7
    40fa:	08 95       	ret
    40fc:	e1 e0       	ldi	r30, 0x01	; 1
    40fe:	66 0f       	add	r22, r22
    4100:	77 1f       	adc	r23, r23
    4102:	88 1f       	adc	r24, r24
    4104:	bb 1f       	adc	r27, r27
    4106:	62 17       	cp	r22, r18
    4108:	73 07       	cpc	r23, r19
    410a:	84 07       	cpc	r24, r20
    410c:	ba 07       	cpc	r27, r26
    410e:	20 f0       	brcs	.+8      	; 0x4118 <__divsf3_pse+0xae>
    4110:	62 1b       	sub	r22, r18
    4112:	73 0b       	sbc	r23, r19
    4114:	84 0b       	sbc	r24, r20
    4116:	ba 0b       	sbc	r27, r26
    4118:	ee 1f       	adc	r30, r30
    411a:	88 f7       	brcc	.-30     	; 0x40fe <__divsf3_pse+0x94>
    411c:	e0 95       	com	r30
    411e:	08 95       	ret

00004120 <__fixsfsi>:
    4120:	0e 94 97 20 	call	0x412e	; 0x412e <__fixunssfsi>
    4124:	68 94       	set
    4126:	b1 11       	cpse	r27, r1
    4128:	0c 94 72 21 	jmp	0x42e4	; 0x42e4 <__fp_szero>
    412c:	08 95       	ret

0000412e <__fixunssfsi>:
    412e:	0e 94 57 21 	call	0x42ae	; 0x42ae <__fp_splitA>
    4132:	88 f0       	brcs	.+34     	; 0x4156 <__fixunssfsi+0x28>
    4134:	9f 57       	subi	r25, 0x7F	; 127
    4136:	98 f0       	brcs	.+38     	; 0x415e <__fixunssfsi+0x30>
    4138:	b9 2f       	mov	r27, r25
    413a:	99 27       	eor	r25, r25
    413c:	b7 51       	subi	r27, 0x17	; 23
    413e:	b0 f0       	brcs	.+44     	; 0x416c <__fixunssfsi+0x3e>
    4140:	e1 f0       	breq	.+56     	; 0x417a <__fixunssfsi+0x4c>
    4142:	66 0f       	add	r22, r22
    4144:	77 1f       	adc	r23, r23
    4146:	88 1f       	adc	r24, r24
    4148:	99 1f       	adc	r25, r25
    414a:	1a f0       	brmi	.+6      	; 0x4152 <__fixunssfsi+0x24>
    414c:	ba 95       	dec	r27
    414e:	c9 f7       	brne	.-14     	; 0x4142 <__fixunssfsi+0x14>
    4150:	14 c0       	rjmp	.+40     	; 0x417a <__fixunssfsi+0x4c>
    4152:	b1 30       	cpi	r27, 0x01	; 1
    4154:	91 f0       	breq	.+36     	; 0x417a <__fixunssfsi+0x4c>
    4156:	0e 94 71 21 	call	0x42e2	; 0x42e2 <__fp_zero>
    415a:	b1 e0       	ldi	r27, 0x01	; 1
    415c:	08 95       	ret
    415e:	0c 94 71 21 	jmp	0x42e2	; 0x42e2 <__fp_zero>
    4162:	67 2f       	mov	r22, r23
    4164:	78 2f       	mov	r23, r24
    4166:	88 27       	eor	r24, r24
    4168:	b8 5f       	subi	r27, 0xF8	; 248
    416a:	39 f0       	breq	.+14     	; 0x417a <__fixunssfsi+0x4c>
    416c:	b9 3f       	cpi	r27, 0xF9	; 249
    416e:	cc f3       	brlt	.-14     	; 0x4162 <__fixunssfsi+0x34>
    4170:	86 95       	lsr	r24
    4172:	77 95       	ror	r23
    4174:	67 95       	ror	r22
    4176:	b3 95       	inc	r27
    4178:	d9 f7       	brne	.-10     	; 0x4170 <__fixunssfsi+0x42>
    417a:	3e f4       	brtc	.+14     	; 0x418a <__fixunssfsi+0x5c>
    417c:	90 95       	com	r25
    417e:	80 95       	com	r24
    4180:	70 95       	com	r23
    4182:	61 95       	neg	r22
    4184:	7f 4f       	sbci	r23, 0xFF	; 255
    4186:	8f 4f       	sbci	r24, 0xFF	; 255
    4188:	9f 4f       	sbci	r25, 0xFF	; 255
    418a:	08 95       	ret

0000418c <__floatunsisf>:
    418c:	e8 94       	clt
    418e:	09 c0       	rjmp	.+18     	; 0x41a2 <__floatsisf+0x12>

00004190 <__floatsisf>:
    4190:	97 fb       	bst	r25, 7
    4192:	3e f4       	brtc	.+14     	; 0x41a2 <__floatsisf+0x12>
    4194:	90 95       	com	r25
    4196:	80 95       	com	r24
    4198:	70 95       	com	r23
    419a:	61 95       	neg	r22
    419c:	7f 4f       	sbci	r23, 0xFF	; 255
    419e:	8f 4f       	sbci	r24, 0xFF	; 255
    41a0:	9f 4f       	sbci	r25, 0xFF	; 255
    41a2:	99 23       	and	r25, r25
    41a4:	a9 f0       	breq	.+42     	; 0x41d0 <__floatsisf+0x40>
    41a6:	f9 2f       	mov	r31, r25
    41a8:	96 e9       	ldi	r25, 0x96	; 150
    41aa:	bb 27       	eor	r27, r27
    41ac:	93 95       	inc	r25
    41ae:	f6 95       	lsr	r31
    41b0:	87 95       	ror	r24
    41b2:	77 95       	ror	r23
    41b4:	67 95       	ror	r22
    41b6:	b7 95       	ror	r27
    41b8:	f1 11       	cpse	r31, r1
    41ba:	f8 cf       	rjmp	.-16     	; 0x41ac <__floatsisf+0x1c>
    41bc:	fa f4       	brpl	.+62     	; 0x41fc <__floatsisf+0x6c>
    41be:	bb 0f       	add	r27, r27
    41c0:	11 f4       	brne	.+4      	; 0x41c6 <__floatsisf+0x36>
    41c2:	60 ff       	sbrs	r22, 0
    41c4:	1b c0       	rjmp	.+54     	; 0x41fc <__floatsisf+0x6c>
    41c6:	6f 5f       	subi	r22, 0xFF	; 255
    41c8:	7f 4f       	sbci	r23, 0xFF	; 255
    41ca:	8f 4f       	sbci	r24, 0xFF	; 255
    41cc:	9f 4f       	sbci	r25, 0xFF	; 255
    41ce:	16 c0       	rjmp	.+44     	; 0x41fc <__floatsisf+0x6c>
    41d0:	88 23       	and	r24, r24
    41d2:	11 f0       	breq	.+4      	; 0x41d8 <__floatsisf+0x48>
    41d4:	96 e9       	ldi	r25, 0x96	; 150
    41d6:	11 c0       	rjmp	.+34     	; 0x41fa <__floatsisf+0x6a>
    41d8:	77 23       	and	r23, r23
    41da:	21 f0       	breq	.+8      	; 0x41e4 <__floatsisf+0x54>
    41dc:	9e e8       	ldi	r25, 0x8E	; 142
    41de:	87 2f       	mov	r24, r23
    41e0:	76 2f       	mov	r23, r22
    41e2:	05 c0       	rjmp	.+10     	; 0x41ee <__floatsisf+0x5e>
    41e4:	66 23       	and	r22, r22
    41e6:	71 f0       	breq	.+28     	; 0x4204 <__floatsisf+0x74>
    41e8:	96 e8       	ldi	r25, 0x86	; 134
    41ea:	86 2f       	mov	r24, r22
    41ec:	70 e0       	ldi	r23, 0x00	; 0
    41ee:	60 e0       	ldi	r22, 0x00	; 0
    41f0:	2a f0       	brmi	.+10     	; 0x41fc <__floatsisf+0x6c>
    41f2:	9a 95       	dec	r25
    41f4:	66 0f       	add	r22, r22
    41f6:	77 1f       	adc	r23, r23
    41f8:	88 1f       	adc	r24, r24
    41fa:	da f7       	brpl	.-10     	; 0x41f2 <__floatsisf+0x62>
    41fc:	88 0f       	add	r24, r24
    41fe:	96 95       	lsr	r25
    4200:	87 95       	ror	r24
    4202:	97 f9       	bld	r25, 7
    4204:	08 95       	ret

00004206 <__fp_cmp>:
    4206:	99 0f       	add	r25, r25
    4208:	00 08       	sbc	r0, r0
    420a:	55 0f       	add	r21, r21
    420c:	aa 0b       	sbc	r26, r26
    420e:	e0 e8       	ldi	r30, 0x80	; 128
    4210:	fe ef       	ldi	r31, 0xFE	; 254
    4212:	16 16       	cp	r1, r22
    4214:	17 06       	cpc	r1, r23
    4216:	e8 07       	cpc	r30, r24
    4218:	f9 07       	cpc	r31, r25
    421a:	c0 f0       	brcs	.+48     	; 0x424c <__fp_cmp+0x46>
    421c:	12 16       	cp	r1, r18
    421e:	13 06       	cpc	r1, r19
    4220:	e4 07       	cpc	r30, r20
    4222:	f5 07       	cpc	r31, r21
    4224:	98 f0       	brcs	.+38     	; 0x424c <__fp_cmp+0x46>
    4226:	62 1b       	sub	r22, r18
    4228:	73 0b       	sbc	r23, r19
    422a:	84 0b       	sbc	r24, r20
    422c:	95 0b       	sbc	r25, r21
    422e:	39 f4       	brne	.+14     	; 0x423e <__fp_cmp+0x38>
    4230:	0a 26       	eor	r0, r26
    4232:	61 f0       	breq	.+24     	; 0x424c <__fp_cmp+0x46>
    4234:	23 2b       	or	r18, r19
    4236:	24 2b       	or	r18, r20
    4238:	25 2b       	or	r18, r21
    423a:	21 f4       	brne	.+8      	; 0x4244 <__fp_cmp+0x3e>
    423c:	08 95       	ret
    423e:	0a 26       	eor	r0, r26
    4240:	09 f4       	brne	.+2      	; 0x4244 <__fp_cmp+0x3e>
    4242:	a1 40       	sbci	r26, 0x01	; 1
    4244:	a6 95       	lsr	r26
    4246:	8f ef       	ldi	r24, 0xFF	; 255
    4248:	81 1d       	adc	r24, r1
    424a:	81 1d       	adc	r24, r1
    424c:	08 95       	ret

0000424e <__fp_inf>:
    424e:	97 f9       	bld	r25, 7
    4250:	9f 67       	ori	r25, 0x7F	; 127
    4252:	80 e8       	ldi	r24, 0x80	; 128
    4254:	70 e0       	ldi	r23, 0x00	; 0
    4256:	60 e0       	ldi	r22, 0x00	; 0
    4258:	08 95       	ret

0000425a <__fp_nan>:
    425a:	9f ef       	ldi	r25, 0xFF	; 255
    425c:	80 ec       	ldi	r24, 0xC0	; 192
    425e:	08 95       	ret

00004260 <__fp_pscA>:
    4260:	00 24       	eor	r0, r0
    4262:	0a 94       	dec	r0
    4264:	16 16       	cp	r1, r22
    4266:	17 06       	cpc	r1, r23
    4268:	18 06       	cpc	r1, r24
    426a:	09 06       	cpc	r0, r25
    426c:	08 95       	ret

0000426e <__fp_pscB>:
    426e:	00 24       	eor	r0, r0
    4270:	0a 94       	dec	r0
    4272:	12 16       	cp	r1, r18
    4274:	13 06       	cpc	r1, r19
    4276:	14 06       	cpc	r1, r20
    4278:	05 06       	cpc	r0, r21
    427a:	08 95       	ret

0000427c <__fp_round>:
    427c:	09 2e       	mov	r0, r25
    427e:	03 94       	inc	r0
    4280:	00 0c       	add	r0, r0
    4282:	11 f4       	brne	.+4      	; 0x4288 <__fp_round+0xc>
    4284:	88 23       	and	r24, r24
    4286:	52 f0       	brmi	.+20     	; 0x429c <__fp_round+0x20>
    4288:	bb 0f       	add	r27, r27
    428a:	40 f4       	brcc	.+16     	; 0x429c <__fp_round+0x20>
    428c:	bf 2b       	or	r27, r31
    428e:	11 f4       	brne	.+4      	; 0x4294 <__fp_round+0x18>
    4290:	60 ff       	sbrs	r22, 0
    4292:	04 c0       	rjmp	.+8      	; 0x429c <__fp_round+0x20>
    4294:	6f 5f       	subi	r22, 0xFF	; 255
    4296:	7f 4f       	sbci	r23, 0xFF	; 255
    4298:	8f 4f       	sbci	r24, 0xFF	; 255
    429a:	9f 4f       	sbci	r25, 0xFF	; 255
    429c:	08 95       	ret

0000429e <__fp_split3>:
    429e:	57 fd       	sbrc	r21, 7
    42a0:	90 58       	subi	r25, 0x80	; 128
    42a2:	44 0f       	add	r20, r20
    42a4:	55 1f       	adc	r21, r21
    42a6:	59 f0       	breq	.+22     	; 0x42be <__fp_splitA+0x10>
    42a8:	5f 3f       	cpi	r21, 0xFF	; 255
    42aa:	71 f0       	breq	.+28     	; 0x42c8 <__fp_splitA+0x1a>
    42ac:	47 95       	ror	r20

000042ae <__fp_splitA>:
    42ae:	88 0f       	add	r24, r24
    42b0:	97 fb       	bst	r25, 7
    42b2:	99 1f       	adc	r25, r25
    42b4:	61 f0       	breq	.+24     	; 0x42ce <__fp_splitA+0x20>
    42b6:	9f 3f       	cpi	r25, 0xFF	; 255
    42b8:	79 f0       	breq	.+30     	; 0x42d8 <__fp_splitA+0x2a>
    42ba:	87 95       	ror	r24
    42bc:	08 95       	ret
    42be:	12 16       	cp	r1, r18
    42c0:	13 06       	cpc	r1, r19
    42c2:	14 06       	cpc	r1, r20
    42c4:	55 1f       	adc	r21, r21
    42c6:	f2 cf       	rjmp	.-28     	; 0x42ac <__fp_split3+0xe>
    42c8:	46 95       	lsr	r20
    42ca:	f1 df       	rcall	.-30     	; 0x42ae <__fp_splitA>
    42cc:	08 c0       	rjmp	.+16     	; 0x42de <__fp_splitA+0x30>
    42ce:	16 16       	cp	r1, r22
    42d0:	17 06       	cpc	r1, r23
    42d2:	18 06       	cpc	r1, r24
    42d4:	99 1f       	adc	r25, r25
    42d6:	f1 cf       	rjmp	.-30     	; 0x42ba <__fp_splitA+0xc>
    42d8:	86 95       	lsr	r24
    42da:	71 05       	cpc	r23, r1
    42dc:	61 05       	cpc	r22, r1
    42de:	08 94       	sec
    42e0:	08 95       	ret

000042e2 <__fp_zero>:
    42e2:	e8 94       	clt

000042e4 <__fp_szero>:
    42e4:	bb 27       	eor	r27, r27
    42e6:	66 27       	eor	r22, r22
    42e8:	77 27       	eor	r23, r23
    42ea:	cb 01       	movw	r24, r22
    42ec:	97 f9       	bld	r25, 7
    42ee:	08 95       	ret

000042f0 <__gesf2>:
    42f0:	0e 94 03 21 	call	0x4206	; 0x4206 <__fp_cmp>
    42f4:	08 f4       	brcc	.+2      	; 0x42f8 <__gesf2+0x8>
    42f6:	8f ef       	ldi	r24, 0xFF	; 255
    42f8:	08 95       	ret

000042fa <__mulsf3>:
    42fa:	0e 94 90 21 	call	0x4320	; 0x4320 <__mulsf3x>
    42fe:	0c 94 3e 21 	jmp	0x427c	; 0x427c <__fp_round>
    4302:	0e 94 30 21 	call	0x4260	; 0x4260 <__fp_pscA>
    4306:	38 f0       	brcs	.+14     	; 0x4316 <__mulsf3+0x1c>
    4308:	0e 94 37 21 	call	0x426e	; 0x426e <__fp_pscB>
    430c:	20 f0       	brcs	.+8      	; 0x4316 <__mulsf3+0x1c>
    430e:	95 23       	and	r25, r21
    4310:	11 f0       	breq	.+4      	; 0x4316 <__mulsf3+0x1c>
    4312:	0c 94 27 21 	jmp	0x424e	; 0x424e <__fp_inf>
    4316:	0c 94 2d 21 	jmp	0x425a	; 0x425a <__fp_nan>
    431a:	11 24       	eor	r1, r1
    431c:	0c 94 72 21 	jmp	0x42e4	; 0x42e4 <__fp_szero>

00004320 <__mulsf3x>:
    4320:	0e 94 4f 21 	call	0x429e	; 0x429e <__fp_split3>
    4324:	70 f3       	brcs	.-36     	; 0x4302 <__mulsf3+0x8>

00004326 <__mulsf3_pse>:
    4326:	95 9f       	mul	r25, r21
    4328:	c1 f3       	breq	.-16     	; 0x431a <__mulsf3+0x20>
    432a:	95 0f       	add	r25, r21
    432c:	50 e0       	ldi	r21, 0x00	; 0
    432e:	55 1f       	adc	r21, r21
    4330:	62 9f       	mul	r22, r18
    4332:	f0 01       	movw	r30, r0
    4334:	72 9f       	mul	r23, r18
    4336:	bb 27       	eor	r27, r27
    4338:	f0 0d       	add	r31, r0
    433a:	b1 1d       	adc	r27, r1
    433c:	63 9f       	mul	r22, r19
    433e:	aa 27       	eor	r26, r26
    4340:	f0 0d       	add	r31, r0
    4342:	b1 1d       	adc	r27, r1
    4344:	aa 1f       	adc	r26, r26
    4346:	64 9f       	mul	r22, r20
    4348:	66 27       	eor	r22, r22
    434a:	b0 0d       	add	r27, r0
    434c:	a1 1d       	adc	r26, r1
    434e:	66 1f       	adc	r22, r22
    4350:	82 9f       	mul	r24, r18
    4352:	22 27       	eor	r18, r18
    4354:	b0 0d       	add	r27, r0
    4356:	a1 1d       	adc	r26, r1
    4358:	62 1f       	adc	r22, r18
    435a:	73 9f       	mul	r23, r19
    435c:	b0 0d       	add	r27, r0
    435e:	a1 1d       	adc	r26, r1
    4360:	62 1f       	adc	r22, r18
    4362:	83 9f       	mul	r24, r19
    4364:	a0 0d       	add	r26, r0
    4366:	61 1d       	adc	r22, r1
    4368:	22 1f       	adc	r18, r18
    436a:	74 9f       	mul	r23, r20
    436c:	33 27       	eor	r19, r19
    436e:	a0 0d       	add	r26, r0
    4370:	61 1d       	adc	r22, r1
    4372:	23 1f       	adc	r18, r19
    4374:	84 9f       	mul	r24, r20
    4376:	60 0d       	add	r22, r0
    4378:	21 1d       	adc	r18, r1
    437a:	82 2f       	mov	r24, r18
    437c:	76 2f       	mov	r23, r22
    437e:	6a 2f       	mov	r22, r26
    4380:	11 24       	eor	r1, r1
    4382:	9f 57       	subi	r25, 0x7F	; 127
    4384:	50 40       	sbci	r21, 0x00	; 0
    4386:	9a f0       	brmi	.+38     	; 0x43ae <__mulsf3_pse+0x88>
    4388:	f1 f0       	breq	.+60     	; 0x43c6 <__mulsf3_pse+0xa0>
    438a:	88 23       	and	r24, r24
    438c:	4a f0       	brmi	.+18     	; 0x43a0 <__mulsf3_pse+0x7a>
    438e:	ee 0f       	add	r30, r30
    4390:	ff 1f       	adc	r31, r31
    4392:	bb 1f       	adc	r27, r27
    4394:	66 1f       	adc	r22, r22
    4396:	77 1f       	adc	r23, r23
    4398:	88 1f       	adc	r24, r24
    439a:	91 50       	subi	r25, 0x01	; 1
    439c:	50 40       	sbci	r21, 0x00	; 0
    439e:	a9 f7       	brne	.-22     	; 0x438a <__mulsf3_pse+0x64>
    43a0:	9e 3f       	cpi	r25, 0xFE	; 254
    43a2:	51 05       	cpc	r21, r1
    43a4:	80 f0       	brcs	.+32     	; 0x43c6 <__mulsf3_pse+0xa0>
    43a6:	0c 94 27 21 	jmp	0x424e	; 0x424e <__fp_inf>
    43aa:	0c 94 72 21 	jmp	0x42e4	; 0x42e4 <__fp_szero>
    43ae:	5f 3f       	cpi	r21, 0xFF	; 255
    43b0:	e4 f3       	brlt	.-8      	; 0x43aa <__mulsf3_pse+0x84>
    43b2:	98 3e       	cpi	r25, 0xE8	; 232
    43b4:	d4 f3       	brlt	.-12     	; 0x43aa <__mulsf3_pse+0x84>
    43b6:	86 95       	lsr	r24
    43b8:	77 95       	ror	r23
    43ba:	67 95       	ror	r22
    43bc:	b7 95       	ror	r27
    43be:	f7 95       	ror	r31
    43c0:	e7 95       	ror	r30
    43c2:	9f 5f       	subi	r25, 0xFF	; 255
    43c4:	c1 f7       	brne	.-16     	; 0x43b6 <__mulsf3_pse+0x90>
    43c6:	fe 2b       	or	r31, r30
    43c8:	88 0f       	add	r24, r24
    43ca:	91 1d       	adc	r25, r1
    43cc:	96 95       	lsr	r25
    43ce:	87 95       	ror	r24
    43d0:	97 f9       	bld	r25, 7
    43d2:	08 95       	ret

000043d4 <__mulsi3>:
    43d4:	db 01       	movw	r26, r22
    43d6:	8f 93       	push	r24
    43d8:	9f 93       	push	r25
    43da:	0e 94 44 22 	call	0x4488	; 0x4488 <__muluhisi3>
    43de:	bf 91       	pop	r27
    43e0:	af 91       	pop	r26
    43e2:	a2 9f       	mul	r26, r18
    43e4:	80 0d       	add	r24, r0
    43e6:	91 1d       	adc	r25, r1
    43e8:	a3 9f       	mul	r26, r19
    43ea:	90 0d       	add	r25, r0
    43ec:	b2 9f       	mul	r27, r18
    43ee:	90 0d       	add	r25, r0
    43f0:	11 24       	eor	r1, r1
    43f2:	08 95       	ret

000043f4 <__udivmodsi4>:
    43f4:	a1 e2       	ldi	r26, 0x21	; 33
    43f6:	1a 2e       	mov	r1, r26
    43f8:	aa 1b       	sub	r26, r26
    43fa:	bb 1b       	sub	r27, r27
    43fc:	fd 01       	movw	r30, r26
    43fe:	0d c0       	rjmp	.+26     	; 0x441a <__udivmodsi4_ep>

00004400 <__udivmodsi4_loop>:
    4400:	aa 1f       	adc	r26, r26
    4402:	bb 1f       	adc	r27, r27
    4404:	ee 1f       	adc	r30, r30
    4406:	ff 1f       	adc	r31, r31
    4408:	a2 17       	cp	r26, r18
    440a:	b3 07       	cpc	r27, r19
    440c:	e4 07       	cpc	r30, r20
    440e:	f5 07       	cpc	r31, r21
    4410:	20 f0       	brcs	.+8      	; 0x441a <__udivmodsi4_ep>
    4412:	a2 1b       	sub	r26, r18
    4414:	b3 0b       	sbc	r27, r19
    4416:	e4 0b       	sbc	r30, r20
    4418:	f5 0b       	sbc	r31, r21

0000441a <__udivmodsi4_ep>:
    441a:	66 1f       	adc	r22, r22
    441c:	77 1f       	adc	r23, r23
    441e:	88 1f       	adc	r24, r24
    4420:	99 1f       	adc	r25, r25
    4422:	1a 94       	dec	r1
    4424:	69 f7       	brne	.-38     	; 0x4400 <__udivmodsi4_loop>
    4426:	60 95       	com	r22
    4428:	70 95       	com	r23
    442a:	80 95       	com	r24
    442c:	90 95       	com	r25
    442e:	9b 01       	movw	r18, r22
    4430:	ac 01       	movw	r20, r24
    4432:	bd 01       	movw	r22, r26
    4434:	cf 01       	movw	r24, r30
    4436:	08 95       	ret

00004438 <__divmodsi4>:
    4438:	05 2e       	mov	r0, r21
    443a:	97 fb       	bst	r25, 7
    443c:	1e f4       	brtc	.+6      	; 0x4444 <__divmodsi4+0xc>
    443e:	00 94       	com	r0
    4440:	0e 94 33 22 	call	0x4466	; 0x4466 <__negsi2>
    4444:	57 fd       	sbrc	r21, 7
    4446:	07 d0       	rcall	.+14     	; 0x4456 <__divmodsi4_neg2>
    4448:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <__udivmodsi4>
    444c:	07 fc       	sbrc	r0, 7
    444e:	03 d0       	rcall	.+6      	; 0x4456 <__divmodsi4_neg2>
    4450:	4e f4       	brtc	.+18     	; 0x4464 <__divmodsi4_exit>
    4452:	0c 94 33 22 	jmp	0x4466	; 0x4466 <__negsi2>

00004456 <__divmodsi4_neg2>:
    4456:	50 95       	com	r21
    4458:	40 95       	com	r20
    445a:	30 95       	com	r19
    445c:	21 95       	neg	r18
    445e:	3f 4f       	sbci	r19, 0xFF	; 255
    4460:	4f 4f       	sbci	r20, 0xFF	; 255
    4462:	5f 4f       	sbci	r21, 0xFF	; 255

00004464 <__divmodsi4_exit>:
    4464:	08 95       	ret

00004466 <__negsi2>:
    4466:	90 95       	com	r25
    4468:	80 95       	com	r24
    446a:	70 95       	com	r23
    446c:	61 95       	neg	r22
    446e:	7f 4f       	sbci	r23, 0xFF	; 255
    4470:	8f 4f       	sbci	r24, 0xFF	; 255
    4472:	9f 4f       	sbci	r25, 0xFF	; 255
    4474:	08 95       	ret

00004476 <__tablejump2__>:
    4476:	ee 0f       	add	r30, r30
    4478:	ff 1f       	adc	r31, r31
    447a:	88 1f       	adc	r24, r24
    447c:	8b bf       	out	0x3b, r24	; 59
    447e:	07 90       	elpm	r0, Z+
    4480:	f6 91       	elpm	r31, Z
    4482:	e0 2d       	mov	r30, r0
    4484:	1b be       	out	0x3b, r1	; 59
    4486:	19 94       	eijmp

00004488 <__muluhisi3>:
    4488:	0e 94 4f 22 	call	0x449e	; 0x449e <__umulhisi3>
    448c:	a5 9f       	mul	r26, r21
    448e:	90 0d       	add	r25, r0
    4490:	b4 9f       	mul	r27, r20
    4492:	90 0d       	add	r25, r0
    4494:	a4 9f       	mul	r26, r20
    4496:	80 0d       	add	r24, r0
    4498:	91 1d       	adc	r25, r1
    449a:	11 24       	eor	r1, r1
    449c:	08 95       	ret

0000449e <__umulhisi3>:
    449e:	a2 9f       	mul	r26, r18
    44a0:	b0 01       	movw	r22, r0
    44a2:	b3 9f       	mul	r27, r19
    44a4:	c0 01       	movw	r24, r0
    44a6:	a3 9f       	mul	r26, r19
    44a8:	70 0d       	add	r23, r0
    44aa:	81 1d       	adc	r24, r1
    44ac:	11 24       	eor	r1, r1
    44ae:	91 1d       	adc	r25, r1
    44b0:	b2 9f       	mul	r27, r18
    44b2:	70 0d       	add	r23, r0
    44b4:	81 1d       	adc	r24, r1
    44b6:	11 24       	eor	r1, r1
    44b8:	91 1d       	adc	r25, r1
    44ba:	08 95       	ret

000044bc <memcpy>:
    44bc:	fb 01       	movw	r30, r22
    44be:	dc 01       	movw	r26, r24
    44c0:	02 c0       	rjmp	.+4      	; 0x44c6 <memcpy+0xa>
    44c2:	01 90       	ld	r0, Z+
    44c4:	0d 92       	st	X+, r0
    44c6:	41 50       	subi	r20, 0x01	; 1
    44c8:	50 40       	sbci	r21, 0x00	; 0
    44ca:	d8 f7       	brcc	.-10     	; 0x44c2 <memcpy+0x6>
    44cc:	08 95       	ret

000044ce <memset>:
    44ce:	dc 01       	movw	r26, r24
    44d0:	01 c0       	rjmp	.+2      	; 0x44d4 <memset+0x6>
    44d2:	6d 93       	st	X+, r22
    44d4:	41 50       	subi	r20, 0x01	; 1
    44d6:	50 40       	sbci	r21, 0x00	; 0
    44d8:	e0 f7       	brcc	.-8      	; 0x44d2 <memset+0x4>
    44da:	08 95       	ret

000044dc <strncpy>:
    44dc:	fb 01       	movw	r30, r22
    44de:	dc 01       	movw	r26, r24
    44e0:	41 50       	subi	r20, 0x01	; 1
    44e2:	50 40       	sbci	r21, 0x00	; 0
    44e4:	48 f0       	brcs	.+18     	; 0x44f8 <strncpy+0x1c>
    44e6:	01 90       	ld	r0, Z+
    44e8:	0d 92       	st	X+, r0
    44ea:	00 20       	and	r0, r0
    44ec:	c9 f7       	brne	.-14     	; 0x44e0 <strncpy+0x4>
    44ee:	01 c0       	rjmp	.+2      	; 0x44f2 <strncpy+0x16>
    44f0:	1d 92       	st	X+, r1
    44f2:	41 50       	subi	r20, 0x01	; 1
    44f4:	50 40       	sbci	r21, 0x00	; 0
    44f6:	e0 f7       	brcc	.-8      	; 0x44f0 <strncpy+0x14>
    44f8:	08 95       	ret

000044fa <__itoa_ncheck>:
    44fa:	bb 27       	eor	r27, r27
    44fc:	4a 30       	cpi	r20, 0x0A	; 10
    44fe:	31 f4       	brne	.+12     	; 0x450c <__itoa_ncheck+0x12>
    4500:	99 23       	and	r25, r25
    4502:	22 f4       	brpl	.+8      	; 0x450c <__itoa_ncheck+0x12>
    4504:	bd e2       	ldi	r27, 0x2D	; 45
    4506:	90 95       	com	r25
    4508:	81 95       	neg	r24
    450a:	9f 4f       	sbci	r25, 0xFF	; 255
    450c:	0c 94 c1 22 	jmp	0x4582	; 0x4582 <__utoa_common>

00004510 <ultoa>:
    4510:	25 32       	cpi	r18, 0x25	; 37
    4512:	31 05       	cpc	r19, r1
    4514:	20 f4       	brcc	.+8      	; 0x451e <ultoa+0xe>
    4516:	22 30       	cpi	r18, 0x02	; 2
    4518:	10 f0       	brcs	.+4      	; 0x451e <ultoa+0xe>
    451a:	0c 94 93 22 	jmp	0x4526	; 0x4526 <__ultoa_ncheck>
    451e:	fa 01       	movw	r30, r20
    4520:	10 82       	st	Z, r1
    4522:	ca 01       	movw	r24, r20
    4524:	08 95       	ret

00004526 <__ultoa_ncheck>:
    4526:	bb 27       	eor	r27, r27

00004528 <__ultoa_common>:
    4528:	fa 01       	movw	r30, r20
    452a:	a6 2f       	mov	r26, r22
    452c:	62 17       	cp	r22, r18
    452e:	71 05       	cpc	r23, r1
    4530:	81 05       	cpc	r24, r1
    4532:	91 05       	cpc	r25, r1
    4534:	33 0b       	sbc	r19, r19
    4536:	30 fb       	bst	r19, 0
    4538:	66 f0       	brts	.+24     	; 0x4552 <__ultoa_common+0x2a>
    453a:	aa 27       	eor	r26, r26
    453c:	66 0f       	add	r22, r22
    453e:	77 1f       	adc	r23, r23
    4540:	88 1f       	adc	r24, r24
    4542:	99 1f       	adc	r25, r25
    4544:	aa 1f       	adc	r26, r26
    4546:	a2 17       	cp	r26, r18
    4548:	10 f0       	brcs	.+4      	; 0x454e <__ultoa_common+0x26>
    454a:	a2 1b       	sub	r26, r18
    454c:	63 95       	inc	r22
    454e:	38 50       	subi	r19, 0x08	; 8
    4550:	a9 f7       	brne	.-22     	; 0x453c <__ultoa_common+0x14>
    4552:	a0 5d       	subi	r26, 0xD0	; 208
    4554:	aa 33       	cpi	r26, 0x3A	; 58
    4556:	08 f0       	brcs	.+2      	; 0x455a <__ultoa_common+0x32>
    4558:	a9 5d       	subi	r26, 0xD9	; 217
    455a:	a1 93       	st	Z+, r26
    455c:	36 f7       	brtc	.-52     	; 0x452a <__ultoa_common+0x2>
    455e:	b1 11       	cpse	r27, r1
    4560:	b1 93       	st	Z+, r27
    4562:	10 82       	st	Z, r1
    4564:	ca 01       	movw	r24, r20
    4566:	0c 94 da 22 	jmp	0x45b4	; 0x45b4 <strrev>

0000456a <utoa>:
    456a:	45 32       	cpi	r20, 0x25	; 37
    456c:	51 05       	cpc	r21, r1
    456e:	20 f4       	brcc	.+8      	; 0x4578 <utoa+0xe>
    4570:	42 30       	cpi	r20, 0x02	; 2
    4572:	10 f0       	brcs	.+4      	; 0x4578 <utoa+0xe>
    4574:	0c 94 c0 22 	jmp	0x4580	; 0x4580 <__utoa_ncheck>
    4578:	fb 01       	movw	r30, r22
    457a:	10 82       	st	Z, r1
    457c:	cb 01       	movw	r24, r22
    457e:	08 95       	ret

00004580 <__utoa_ncheck>:
    4580:	bb 27       	eor	r27, r27

00004582 <__utoa_common>:
    4582:	fb 01       	movw	r30, r22
    4584:	55 27       	eor	r21, r21
    4586:	aa 27       	eor	r26, r26
    4588:	88 0f       	add	r24, r24
    458a:	99 1f       	adc	r25, r25
    458c:	aa 1f       	adc	r26, r26
    458e:	a4 17       	cp	r26, r20
    4590:	10 f0       	brcs	.+4      	; 0x4596 <__utoa_common+0x14>
    4592:	a4 1b       	sub	r26, r20
    4594:	83 95       	inc	r24
    4596:	50 51       	subi	r21, 0x10	; 16
    4598:	b9 f7       	brne	.-18     	; 0x4588 <__utoa_common+0x6>
    459a:	a0 5d       	subi	r26, 0xD0	; 208
    459c:	aa 33       	cpi	r26, 0x3A	; 58
    459e:	08 f0       	brcs	.+2      	; 0x45a2 <__utoa_common+0x20>
    45a0:	a9 5d       	subi	r26, 0xD9	; 217
    45a2:	a1 93       	st	Z+, r26
    45a4:	00 97       	sbiw	r24, 0x00	; 0
    45a6:	79 f7       	brne	.-34     	; 0x4586 <__utoa_common+0x4>
    45a8:	b1 11       	cpse	r27, r1
    45aa:	b1 93       	st	Z+, r27
    45ac:	11 92       	st	Z+, r1
    45ae:	cb 01       	movw	r24, r22
    45b0:	0c 94 da 22 	jmp	0x45b4	; 0x45b4 <strrev>

000045b4 <strrev>:
    45b4:	dc 01       	movw	r26, r24
    45b6:	fc 01       	movw	r30, r24
    45b8:	67 2f       	mov	r22, r23
    45ba:	71 91       	ld	r23, Z+
    45bc:	77 23       	and	r23, r23
    45be:	e1 f7       	brne	.-8      	; 0x45b8 <strrev+0x4>
    45c0:	32 97       	sbiw	r30, 0x02	; 2
    45c2:	04 c0       	rjmp	.+8      	; 0x45cc <strrev+0x18>
    45c4:	7c 91       	ld	r23, X
    45c6:	6d 93       	st	X+, r22
    45c8:	70 83       	st	Z, r23
    45ca:	62 91       	ld	r22, -Z
    45cc:	ae 17       	cp	r26, r30
    45ce:	bf 07       	cpc	r27, r31
    45d0:	c8 f3       	brcs	.-14     	; 0x45c4 <strrev+0x10>
    45d2:	08 95       	ret

000045d4 <_exit>:
    45d4:	f8 94       	cli

000045d6 <__stop_program>:
    45d6:	ff cf       	rjmp	.-2      	; 0x45d6 <__stop_program>
