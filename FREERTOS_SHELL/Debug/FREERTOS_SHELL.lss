
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000046ce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  000046ce  00004762  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  008020bc  008020bc  0000481e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000481e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004850  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006a0  00000000  00000000  00004890  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001276f  00000000  00000000  00004f30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000634d  00000000  00000000  0001769f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005572  00000000  00000000  0001d9ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001244  00000000  00000000  00022f60  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000062ce  00000000  00000000  000241a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005ff9  00000000  00000000  0002a472  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000568  00000000  00000000  0003046b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 95 03 	jmp	0x72a	; 0x72a <__ctors_end>
       4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      10:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      14:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      18:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      1c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      20:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      24:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      28:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      2c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      30:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      34:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      38:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      3c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      40:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      44:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      48:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      4c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      50:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      54:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      58:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      5c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      60:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      64:	0c 94 3b 1f 	jmp	0x3e76	; 0x3e76 <__vector_25>
      68:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      6c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      70:	0c 94 99 1f 	jmp	0x3f32	; 0x3f32 <__vector_28>
      74:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      78:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      7c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      80:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      84:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      88:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      8c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      90:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      94:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      98:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      9c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c4:	0c 94 55 0f 	jmp	0x1eaa	; 0x1eaa <__vector_49>
      c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e8:	0c 94 b3 20 	jmp	0x4166	; 0x4166 <__vector_58>
      ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      fc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     100:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     104:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     108:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     10c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     110:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     114:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     118:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     11c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     120:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     124:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     128:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     12c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     130:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     134:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     138:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     13c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     140:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     144:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     148:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     14c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     150:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     154:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     158:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     15c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     160:	0c 94 f7 1f 	jmp	0x3fee	; 0x3fee <__vector_88>
     164:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     168:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     16c:	0c 94 55 20 	jmp	0x40aa	; 0x40aa <__vector_91>
     170:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     174:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     178:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     17c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     180:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     184:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     188:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     18c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     190:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     194:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     198:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     19c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1fc:	9c 0b       	sbc	r25, r28
     1fe:	14 0c       	add	r1, r4
     200:	14 0c       	add	r1, r4
     202:	14 0c       	add	r1, r4
     204:	14 0c       	add	r1, r4
     206:	14 0c       	add	r1, r4
     208:	14 0c       	add	r1, r4
     20a:	14 0c       	add	r1, r4
     20c:	14 0c       	add	r1, r4
     20e:	14 0c       	add	r1, r4
     210:	14 0c       	add	r1, r4
     212:	14 0c       	add	r1, r4
     214:	14 0c       	add	r1, r4
     216:	14 0c       	add	r1, r4
     218:	14 0c       	add	r1, r4
     21a:	14 0c       	add	r1, r4
     21c:	14 0c       	add	r1, r4
     21e:	14 0c       	add	r1, r4
     220:	14 0c       	add	r1, r4
     222:	14 0c       	add	r1, r4
     224:	14 0c       	add	r1, r4
     226:	14 0c       	add	r1, r4
     228:	14 0c       	add	r1, r4
     22a:	14 0c       	add	r1, r4
     22c:	14 0c       	add	r1, r4
     22e:	14 0c       	add	r1, r4
     230:	14 0c       	add	r1, r4
     232:	14 0c       	add	r1, r4
     234:	14 0c       	add	r1, r4
     236:	14 0c       	add	r1, r4
     238:	14 0c       	add	r1, r4
     23a:	14 0c       	add	r1, r4
     23c:	14 0c       	add	r1, r4
     23e:	14 0c       	add	r1, r4
     240:	14 0c       	add	r1, r4
     242:	14 0c       	add	r1, r4
     244:	14 0c       	add	r1, r4
     246:	14 0c       	add	r1, r4
     248:	14 0c       	add	r1, r4
     24a:	14 0c       	add	r1, r4
     24c:	14 0c       	add	r1, r4
     24e:	14 0c       	add	r1, r4
     250:	14 0c       	add	r1, r4
     252:	14 0c       	add	r1, r4
     254:	14 0c       	add	r1, r4
     256:	14 0c       	add	r1, r4
     258:	14 0c       	add	r1, r4
     25a:	14 0c       	add	r1, r4
     25c:	14 0c       	add	r1, r4
     25e:	14 0c       	add	r1, r4
     260:	14 0c       	add	r1, r4
     262:	14 0c       	add	r1, r4
     264:	14 0c       	add	r1, r4
     266:	14 0c       	add	r1, r4
     268:	14 0c       	add	r1, r4
     26a:	14 0c       	add	r1, r4
     26c:	14 0c       	add	r1, r4
     26e:	14 0c       	add	r1, r4
     270:	14 0c       	add	r1, r4
     272:	14 0c       	add	r1, r4
     274:	14 0c       	add	r1, r4
     276:	14 0c       	add	r1, r4
     278:	14 0c       	add	r1, r4
     27a:	14 0c       	add	r1, r4
     27c:	14 0c       	add	r1, r4
     27e:	14 0c       	add	r1, r4
     280:	14 0c       	add	r1, r4
     282:	14 0c       	add	r1, r4
     284:	14 0c       	add	r1, r4
     286:	14 0c       	add	r1, r4
     288:	14 0c       	add	r1, r4
     28a:	b0 0b       	sbc	r27, r16
     28c:	14 0c       	add	r1, r4
     28e:	e2 0b       	sbc	r30, r18
     290:	9c 0b       	sbc	r25, r28
     292:	14 0c       	add	r1, r4
     294:	ca 0b       	sbc	r28, r26
     296:	98 0b       	sbc	r25, r24
     298:	14 0c       	add	r1, r4
     29a:	14 0c       	add	r1, r4
     29c:	14 0c       	add	r1, r4
     29e:	14 0c       	add	r1, r4
     2a0:	14 0c       	add	r1, r4
     2a2:	7e 0b       	sbc	r23, r30
     2a4:	14 0c       	add	r1, r4
     2a6:	14 0c       	add	r1, r4
     2a8:	14 0c       	add	r1, r4
     2aa:	fc 0b       	sbc	r31, r28
     2ac:	90 0b       	sbc	r25, r16
     2ae:	14 0c       	add	r1, r4
     2b0:	14 0c       	add	r1, r4
     2b2:	8c 0b       	sbc	r24, r28
     2b4:	27 1d       	adc	r18, r7
     2b6:	2a 1d       	adc	r18, r10
     2b8:	2d 1d       	adc	r18, r13
     2ba:	30 1d       	adc	r19, r0
     2bc:	33 1d       	adc	r19, r3
     2be:	36 1d       	adc	r19, r6
     2c0:	38 1d       	adc	r19, r8
     2c2:	49 1d       	adc	r20, r9
     2c4:	51 1d       	adc	r21, r1
     2c6:	5b 1d       	adc	r21, r11
     2c8:	59 1d       	adc	r21, r9

000002ca <__trampolines_start>:
     2ca:	0c 94 b5 21 	jmp	0x436a	; 0x436a <_GLOBAL__sub_I_counter>
     2ce:	0c 94 36 1d 	jmp	0x3a6c	; 0x3a6c <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2d2:	0c 94 e2 0b 	jmp	0x17c4	; 0x17c4 <_ZN9task_user3runEv+0x214>
     2d6:	0c 94 08 19 	jmp	0x3210	; 0x3210 <_ZN8frt_task12print_statusER8emstream>
     2da:	0c 94 7e 0b 	jmp	0x16fc	; 0x16fc <_ZN9task_user3runEv+0x14c>
     2de:	0c 94 33 1c 	jmp	0x3866	; 0x3866 <__cxa_pure_virtual>
     2e2:	0c 94 38 1d 	jmp	0x3a70	; 0x3a70 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2e6:	0c 94 59 1d 	jmp	0x3ab2	; 0x3ab2 <_ZN8emstreamlsE15ser_manipulator+0x82>
     2ea:	0c 94 30 1d 	jmp	0x3a60	; 0x3a60 <_ZN8emstreamlsE15ser_manipulator+0x30>
     2ee:	0c 94 9f 1e 	jmp	0x3d3e	; 0x3d3e <_ZN5rs23214check_for_charEv>
     2f2:	0c 94 9c 0b 	jmp	0x1738	; 0x1738 <_ZN9task_user3runEv+0x188>
     2f6:	0c 94 cf 1c 	jmp	0x399e	; 0x399e <_ZN8emstream14check_for_charEv>
     2fa:	0c 94 33 1d 	jmp	0x3a66	; 0x3a66 <_ZN8emstreamlsE15ser_manipulator+0x36>
     2fe:	0c 94 ca 1c 	jmp	0x3994	; 0x3994 <_ZN8emstream13ready_to_sendEv>
     302:	0c 94 79 1e 	jmp	0x3cf2	; 0x3cf2 <_ZN5rs2327getcharEv>
     306:	0c 94 b2 1e 	jmp	0x3d64	; 0x3d64 <_ZN5rs23212clear_screenEv>
     30a:	0c 94 d1 1c 	jmp	0x39a2	; 0x39a2 <_ZN8emstream12transmit_nowEv>
     30e:	0c 94 92 03 	jmp	0x724	; 0x724 <_call_static_run_method>
     312:	0c 94 b4 04 	jmp	0x968	; 0x968 <_ZN13LimitSwitches3runEv>
     316:	0c 94 55 1e 	jmp	0x3caa	; 0x3caa <_ZN5rs2327putcharEc>
     31a:	0c 94 cc 1c 	jmp	0x3998	; 0x3998 <_ZN8emstream7getcharEv>
     31e:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <_ZN15EncoderPendulum3runEv>
     322:	0c 94 d8 0a 	jmp	0x15b0	; 0x15b0 <_ZN9task_user3runEv>
     326:	0c 94 70 1a 	jmp	0x34e0	; 0x34e0 <_ZN14frt_text_queue14check_for_charEv>
     32a:	0c 94 d2 1c 	jmp	0x39a4	; 0x39a4 <_ZN8emstream12clear_screenEv>
     32e:	0c 94 90 0b 	jmp	0x1720	; 0x1720 <_ZN9task_user3runEv+0x170>
     332:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <_ZN9task_user3runEv+0x1e4>
     336:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <_ZN9task_user3runEv+0x1b0>
     33a:	0c 94 2d 1d 	jmp	0x3a5a	; 0x3a5a <_ZN8emstreamlsE15ser_manipulator+0x2a>
     33e:	0c 94 fc 0b 	jmp	0x17f8	; 0x17f8 <_ZN9task_user3runEv+0x248>
     342:	0c 94 98 0b 	jmp	0x1730	; 0x1730 <_ZN9task_user3runEv+0x180>
     346:	0c 94 8c 0b 	jmp	0x1718	; 0x1718 <_ZN9task_user3runEv+0x168>
     34a:	0c 94 51 1d 	jmp	0x3aa2	; 0x3aa2 <_ZN8emstreamlsE15ser_manipulator+0x72>
     34e:	0c 94 cd 03 	jmp	0x79a	; 0x79a <_ZN12EncoderMotor3runEv>
     352:	0c 94 27 1d 	jmp	0x3a4e	; 0x3a4e <_ZN8emstreamlsE15ser_manipulator+0x1e>
     356:	0c 94 14 0c 	jmp	0x1828	; 0x1828 <_ZN9task_user3runEv+0x278>
     35a:	0c 94 49 1d 	jmp	0x3a92	; 0x3a92 <_ZN8emstreamlsE15ser_manipulator+0x62>
     35e:	0c 94 2a 1d 	jmp	0x3a54	; 0x3a54 <_ZN8emstreamlsE15ser_manipulator+0x24>
     362:	0c 94 19 05 	jmp	0xa32	; 0xa32 <_ZN5Motor3runEv>
     366:	0c 94 52 1a 	jmp	0x34a4	; 0x34a4 <_ZN14frt_text_queue7getcharEv>
     36a:	0c 94 5b 1d 	jmp	0x3ab6	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
     36e:	0c 94 7b 1a 	jmp	0x34f6	; 0x34f6 <_ZN14frt_text_queue7putcharEc>
     372:	0c 94 d9 11 	jmp	0x23b2	; 0x23b2 <prvIdleTask>

00000376 <__trampolines_end>:
     376:	2c 20       	and	r2, r12
     378:	54 43       	sbci	r21, 0x34	; 52
     37a:	43 30       	cpi	r20, 0x03	; 3
     37c:	43 43       	sbci	r20, 0x33	; 51
     37e:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000381 <_ZZN9task_user11show_statusEvE3__c_3>:
     381:	2f 00                                               /.

00000383 <_ZZN9task_user11show_statusEvE3__c_2>:
     383:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000391 <_ZZN9task_user11show_statusEvE3__c_1>:
     391:	54 69 6d 65 3a 20 00                                Time: .

00000398 <_ZZN9task_user11show_statusEvE3__c_0>:
     398:	44 65 63 20 20 37 20 32 30 31 37 00                 Dec  7 2017.

000003a4 <_ZZN9task_user11show_statusEvE3__c>:
     3a4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3b4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003c3 <_ZZN9task_user18print_help_messageEvE3__c_14>:
     3c3:	20 20 20 20 72 3a 20 20 20 52 65 73 65 74 20 74         r:   Reset t
     3d3:	6f 20 49 64 6c 65 00                                o Idle.

000003da <_ZZN9task_user18print_help_messageEvE3__c_13>:
     3da:	20 20 20 20 64 3a 20 20 20 45 6d 65 72 67 65 6e         d:   Emergen
     3ea:	63 79 20 53 74 6f 70 00                             cy Stop.

000003f2 <_ZZN9task_user18print_help_messageEvE3__c_12>:
     3f2:	20 20 20 20 67 3a 20 20 20 53 77 69 6e 67 20 50         g:   Swing P
     402:	65 6e 64 75 6c 75 6d 20 55 70 72 69 67 68 74 2c     endulum Upright,
     412:	20 74 68 65 6e 20 47 6f 2e 00                        then Go..

0000041c <_ZZN9task_user18print_help_messageEvE3__c_11>:
     41c:	20 20 20 20 62 3a 20 20 20 42 65 67 69 6e 20 43         b:   Begin C
     42c:	61 6c 69 62 72 61 74 69 6f 6e 20 6f 66 20 49 6e     alibration of In
     43c:	76 65 72 74 65 64 20 50 65 6e 64 75 6c 75 6d 3f     verted Pendulum?
	...

0000044d <_ZZN9task_user18print_help_messageEvE3__c_10>:
     44d:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000045c <_ZZN9task_user18print_help_messageEvE3__c_9>:
     45c:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     46c:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000477 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     477:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     487:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000495 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     495:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     4a5:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     4b5:	6d 61 74 69 6f 6e 00                                mation.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_6>:
     4bc:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     4cc:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000004dd <_ZZN9task_user18print_help_messageEvE3__c_5>:
     4dd:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4ed:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004f5 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4f5:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     505:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000511 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     511:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     521:	68 65 20 41 56 52 00                                he AVR.

00000528 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     528:	20 68 65 6c 70 00                                    help.

0000052e <_ZZN9task_user18print_help_messageEvE3__c_1>:
     52e:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     53e:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000054d <_ZZN9task_user18print_help_messageEvE3__c_0>:
     54d:	1b 5b 33 30 6d 00                                   .[30m.

00000553 <_ZZN9task_user18print_help_messageEvE3__c>:
     553:	1b 5b 34 36 6d 00                                   .[46m.

00000559 <_ZZN9task_user3runEvE3__c_7>:
     559:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     569:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000576 <_ZZN9task_user3runEvE3__c_6>:
     576:	3a 57 54 46 3f 00                                   :WTF?.

0000057c <_ZZN9task_user3runEvE3__c_5>:
     57c:	52 65 73 65 74 2c 20 74 72 79 20 48 6f 6d 69 6e     Reset, try Homin
     58c:	67 20 61 67 61 69 6e 20 62 79 20 70 72 65 73 73     g again by press
     59c:	69 6e 67 20 27 62 27 00                             ing 'b'.

000005a4 <_ZZN9task_user3runEvE3__c_4>:
     5a4:	45 4d 45 52 47 45 4e 43 59 20 53 54 4f 50 00        EMERGENCY STOP.

000005b3 <_ZZN9task_user3runEvE3__c_3>:
     5b3:	43 6f 6d 6d 65 6e 63 65 20 42 61 6c 61 6e 63 65     Commence Balance
	...

000005c4 <_ZZN9task_user3runEvE3__c_2>:
     5c4:	42 65 67 69 6e 20 48 6f 6d 69 6e 67 00              Begin Homing.

000005d1 <_ZZN9task_user3runEvE3__c_1>:
     5d1:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     5e1:	65 00                                               e.

000005e3 <_ZZN9task_user3runEvE3__c_0>:
     5e3:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000005f1 <_ZZN9task_user3runEvE3__c>:
     5f1:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 74 6f 20     Press Ctrl-A to 
     601:	67 65 74 20 74 6f 20 63 6f 6d 6d 61 6e 64 20 6d     get to command m
     611:	6f 64 65 20 66 6f 72 20 49 6e 76 65 72 74 65 64     ode for Inverted
     621:	20 50 65 6e 64 75 6c 75 6d 00                        Pendulum.

0000062b <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     62b:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000635 <_ZZN8frt_task15emergency_resetEvE3__c>:
     635:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000644 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     644:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     654:	61 73 6b 20 00                                      ask .

00000659 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     659:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000667 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     667:	20 63 72 65 61 74 65 64 00                           created.

00000670 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     670:	54 61 73 6b 20 00                                   Task .

00000676 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     676:	1b 5b 32 32 6d 00                                   .[22m.

0000067c <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     67c:	54 61 73 6b 3a 20 00                                Task: .

00000683 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     683:	1b 5b 31 6d 00                                      .[1m.

00000688 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     688:	1b 5b 32 32 6d 00                                   .[22m.

0000068e <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     68e:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000699 <_ZZ17print_task_stacksP8emstreamE3__c>:
     699:	1b 5b 31 6d 00                                      .[1m.

0000069e <_ZZ15print_task_listP8emstreamE3__c_9>:
     69e:	09 09 00                                            ...

000006a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     6a1:	2f 00                                               /.

000006a3 <_ZZ15print_task_listP8emstreamE3__c_7>:
     6a3:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000006ae <_ZZ15print_task_listP8emstreamE3__c_6>:
     6ae:	09 2d 2d 2d 2d 00                                   .----.

000006b4 <_ZZ15print_task_listP8emstreamE3__c_5>:
     6b4:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000006c0 <_ZZ15print_task_listP8emstreamE3__c_4>:
     6c0:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000006d1 <_ZZ15print_task_listP8emstreamE3__c_3>:
     6d1:	09 52 75 6e 73 00                                   .Runs.

000006d7 <_ZZ15print_task_listP8emstreamE3__c_2>:
     6d7:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000006e3 <_ZZ15print_task_listP8emstreamE3__c_1>:
     6e3:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000006f4 <_ZZ15print_task_listP8emstreamE3__c_0>:
     6f4:	09 53 74 61 63 6b 00                                .Stack.

000006fb <_ZZ15print_task_listP8emstreamE3__c>:
     6fb:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000706 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     706:	09 00                                               ..

00000708 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     708:	09 00                                               ..

0000070a <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     70a:	2f 00                                               /.

0000070c <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     70c:	09 00                                               ..

0000070e <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     70e:	09 00                                               ..

00000710 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     710:	1b 5b 32 32 6d 00                                   .[22m.

00000716 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     716:	1b 5b 31 6d 00                                      .[1m.

0000071b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     71b:	1b 5b 31 6d 00                                      .[1m.

00000720 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     720:	20 20 00 00                                           ..

00000724 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     724:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <_ZN8frt_task22_call_users_run_methodEPS_>

00000728 <__ctors_start>:
     728:	b5 21       	and	r27, r5

0000072a <__ctors_end>:
     72a:	11 24       	eor	r1, r1
     72c:	1f be       	out	0x3f, r1	; 63
     72e:	cf ef       	ldi	r28, 0xFF	; 255
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df e3       	ldi	r29, 0x3F	; 63
     734:	de bf       	out	0x3e, r29	; 62
     736:	00 e0       	ldi	r16, 0x00	; 0
     738:	0c bf       	out	0x3c, r16	; 60
     73a:	18 be       	out	0x38, r1	; 56
     73c:	19 be       	out	0x39, r1	; 57
     73e:	1a be       	out	0x3a, r1	; 58
     740:	1b be       	out	0x3b, r1	; 59

00000742 <__do_copy_data>:
     742:	10 e2       	ldi	r17, 0x20	; 32
     744:	a0 e0       	ldi	r26, 0x00	; 0
     746:	b0 e2       	ldi	r27, 0x20	; 32
     748:	ee ec       	ldi	r30, 0xCE	; 206
     74a:	f6 e4       	ldi	r31, 0x46	; 70
     74c:	00 e0       	ldi	r16, 0x00	; 0
     74e:	0b bf       	out	0x3b, r16	; 59
     750:	02 c0       	rjmp	.+4      	; 0x756 <__do_copy_data+0x14>
     752:	07 90       	elpm	r0, Z+
     754:	0d 92       	st	X+, r0
     756:	ac 3b       	cpi	r26, 0xBC	; 188
     758:	b1 07       	cpc	r27, r17
     75a:	d9 f7       	brne	.-10     	; 0x752 <__do_copy_data+0x10>
     75c:	1b be       	out	0x3b, r1	; 59

0000075e <__do_clear_bss>:
     75e:	21 e3       	ldi	r18, 0x31	; 49
     760:	ac eb       	ldi	r26, 0xBC	; 188
     762:	b0 e2       	ldi	r27, 0x20	; 32
     764:	01 c0       	rjmp	.+2      	; 0x768 <.do_clear_bss_start>

00000766 <.do_clear_bss_loop>:
     766:	1d 92       	st	X+, r1

00000768 <.do_clear_bss_start>:
     768:	a6 36       	cpi	r26, 0x66	; 102
     76a:	b2 07       	cpc	r27, r18
     76c:	e1 f7       	brne	.-8      	; 0x766 <.do_clear_bss_loop>

0000076e <__do_global_ctors>:
     76e:	13 e0       	ldi	r17, 0x03	; 3
     770:	c5 e9       	ldi	r28, 0x95	; 149
     772:	d3 e0       	ldi	r29, 0x03	; 3
     774:	00 e0       	ldi	r16, 0x00	; 0
     776:	06 c0       	rjmp	.+12     	; 0x784 <__do_global_ctors+0x16>
     778:	21 97       	sbiw	r28, 0x01	; 1
     77a:	01 09       	sbc	r16, r1
     77c:	80 2f       	mov	r24, r16
     77e:	fe 01       	movw	r30, r28
     780:	0e 94 96 22 	call	0x452c	; 0x452c <__tablejump2__>
     784:	c4 39       	cpi	r28, 0x94	; 148
     786:	d1 07       	cpc	r29, r17
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	08 07       	cpc	r16, r24
     78c:	a9 f7       	brne	.-22     	; 0x778 <__do_global_ctors+0xa>
     78e:	0e 94 26 21 	call	0x424c	; 0x424c <main>
     792:	0c 94 65 23 	jmp	0x46ca	; 0x46ca <_exit>

00000796 <__bad_interrupt>:
     796:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000079a <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <_ZN12EncoderMotor3runEv+0x6>
     7a0:	1f 92       	push	r1
     7a2:	cd b7       	in	r28, 0x3d	; 61
     7a4:	de b7       	in	r29, 0x3e	; 62
     7a6:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7a8:	0e 94 78 13 	call	0x26f0	; 0x26f0 <xTaskGetTickCount>
     7ac:	69 83       	std	Y+1, r22	; 0x01
     7ae:	7a 83       	std	Y+2, r23	; 0x02
     7b0:	8b 83       	std	Y+3, r24	; 0x03
     7b2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     7b4:	e0 e8       	ldi	r30, 0x80	; 128
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	8c e0       	ldi	r24, 0x0C	; 12
     7ba:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     7bc:	82 89       	ldd	r24, Z+18	; 0x12
     7be:	83 60       	ori	r24, 0x03	; 3
     7c0:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     7c2:	83 89       	ldd	r24, Z+19	; 0x13
     7c4:	83 60       	ori	r24, 0x03	; 3
     7c6:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     7c8:	e0 e8       	ldi	r30, 0x80	; 128
     7ca:	f1 e0       	ldi	r31, 0x01	; 1
     7cc:	82 e7       	ldi	r24, 0x72	; 114
     7ce:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     7d0:	89 e0       	ldi	r24, 0x09	; 9
     7d2:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     7d4:	e0 e0       	ldi	r30, 0x00	; 0
     7d6:	f9 e0       	ldi	r31, 0x09	; 9
     7d8:	88 e6       	ldi	r24, 0x68	; 104
     7da:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	9f ef       	ldi	r25, 0xFF	; 255
     7e0:	86 a3       	std	Z+38, r24	; 0x26
     7e2:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     7e8:	0f 2e       	mov	r0, r31
     7ea:	a1 2c       	mov	r10, r1
     7ec:	f9 e0       	ldi	r31, 0x09	; 9
     7ee:	bf 2e       	mov	r11, r31
     7f0:	f0 2d       	mov	r31, r0
     7f2:	f5 01       	movw	r30, r10
     7f4:	00 a1       	ldd	r16, Z+32	; 0x20
     7f6:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     7f8:	0f b6       	in	r0, 0x3f	; 63
     7fa:	f8 94       	cli
     7fc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	0f 92       	push	r0
			the_data = new_data;
     808:	c8 01       	movw	r24, r16
     80a:	01 2e       	mov	r0, r17
     80c:	00 0c       	add	r0, r0
     80e:	aa 0b       	sbc	r26, r26
     810:	bb 0b       	sbc	r27, r27
     812:	ac 01       	movw	r20, r24
     814:	bd 01       	movw	r22, r26
     816:	44 0f       	add	r20, r20
     818:	55 1f       	adc	r21, r21
     81a:	66 1f       	adc	r22, r22
     81c:	77 1f       	adc	r23, r23
     81e:	3a 01       	movw	r6, r20
     820:	4b 01       	movw	r8, r22
     822:	68 0e       	add	r6, r24
     824:	79 1e       	adc	r7, r25
     826:	8a 1e       	adc	r8, r26
     828:	9b 1e       	adc	r9, r27
     82a:	c4 01       	movw	r24, r8
     82c:	b3 01       	movw	r22, r6
     82e:	24 e6       	ldi	r18, 0x64	; 100
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	0e 94 77 22 	call	0x44ee	; 0x44ee <__divmodsi4>
     83a:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <linear_offset>
     83e:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <linear_offset+0x1>
     842:	28 1b       	sub	r18, r24
     844:	39 0b       	sbc	r19, r25
     846:	20 93 52 31 	sts	0x3152, r18	; 0x803152 <linear_position>
     84a:	30 93 53 31 	sts	0x3153, r19	; 0x803153 <linear_position+0x1>
			portEXIT_CRITICAL ();
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
			the_data = new_data;
     858:	c8 01       	movw	r24, r16
     85a:	8c 19       	sub	r24, r12
     85c:	9d 09       	sbc	r25, r13
     85e:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <thdMotor>
     862:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     86a:	f7 01       	movw	r30, r14
     86c:	86 85       	ldd	r24, Z+14	; 0x0e
     86e:	97 85       	ldd	r25, Z+15	; 0x0f
     870:	a0 89       	ldd	r26, Z+16	; 0x10
     872:	b1 89       	ldd	r27, Z+17	; 0x11
     874:	01 96       	adiw	r24, 0x01	; 1
     876:	a1 1d       	adc	r26, r1
     878:	b1 1d       	adc	r27, r1
     87a:	86 87       	std	Z+14, r24	; 0x0e
     87c:	97 87       	std	Z+15, r25	; 0x0f
     87e:	a0 8b       	std	Z+16, r26	; 0x10
     880:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     882:	41 e0       	ldi	r20, 0x01	; 1
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	ce 01       	movw	r24, r28
     88c:	01 96       	adiw	r24, 0x01	; 1
     88e:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     892:	68 01       	movw	r12, r16
     894:	ae cf       	rjmp	.-164    	; 0x7f2 <_ZN12EncoderMotor3runEv+0x58>

00000896 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a0:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <_ZN8frt_taskC1EPKchjP8emstream>
     8a4:	8a e0       	ldi	r24, 0x0A	; 10
     8a6:	90 e2       	ldi	r25, 0x20	; 32
     8a8:	88 83       	st	Y, r24
     8aa:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN15EncoderPendulum3runEv+0x6>
     8bc:	1f 92       	push	r1
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 78 13 	call	0x26f0	; 0x26f0 <xTaskGetTickCount>
     8c8:	69 83       	std	Y+1, r22	; 0x01
     8ca:	7a 83       	std	Y+2, r23	; 0x02
     8cc:	8b 83       	std	Y+3, r24	; 0x03
     8ce:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     8d0:	e0 e8       	ldi	r30, 0x80	; 128
     8d2:	f6 e0       	ldi	r31, 0x06	; 6
     8d4:	83 e0       	ldi	r24, 0x03	; 3
     8d6:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     8d8:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     8da:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     8dc:	e0 e8       	ldi	r30, 0x80	; 128
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	80 e7       	ldi	r24, 0x70	; 112
     8e2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     8e4:	89 e0       	ldi	r24, 0x09	; 9
     8e6:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     8e8:	e0 e4       	ldi	r30, 0x40	; 64
     8ea:	f8 e0       	ldi	r31, 0x08	; 8
     8ec:	8a e6       	ldi	r24, 0x6A	; 106
     8ee:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     8f0:	80 ea       	ldi	r24, 0xA0	; 160
     8f2:	95 e0       	ldi	r25, 0x05	; 5
     8f4:	86 a3       	std	Z+38, r24	; 0x26
     8f6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     8fc:	68 94       	set
     8fe:	ee 24       	eor	r14, r14
     900:	e6 f8       	bld	r14, 6
     902:	ff 24       	eor	r15, r15
     904:	f3 f8       	bld	r15, 3
     906:	f7 01       	movw	r30, r14
     908:	80 a1       	ldd	r24, Z+32	; 0x20
     90a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
			the_data = new_data;
     912:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <thPendulum>
     916:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <thPendulum+0x1>
			portEXIT_CRITICAL ();
     91a:	0f 90       	pop	r0
     91c:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     91e:	f8 01       	movw	r30, r16
     920:	86 85       	ldd	r24, Z+14	; 0x0e
     922:	97 85       	ldd	r25, Z+15	; 0x0f
     924:	a0 89       	ldd	r26, Z+16	; 0x10
     926:	b1 89       	ldd	r27, Z+17	; 0x11
     928:	01 96       	adiw	r24, 0x01	; 1
     92a:	a1 1d       	adc	r26, r1
     92c:	b1 1d       	adc	r27, r1
     92e:	86 87       	std	Z+14, r24	; 0x0e
     930:	97 87       	std	Z+15, r25	; 0x0f
     932:	a0 8b       	std	Z+16, r26	; 0x10
     934:	b1 8b       	std	Z+17, r27	; 0x11
     936:	41 e0       	ldi	r20, 0x01	; 1
     938:	50 e0       	ldi	r21, 0x00	; 0
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	70 e0       	ldi	r23, 0x00	; 0
     93e:	ce 01       	movw	r24, r28
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vTaskDelayUntil>
     946:	df cf       	rjmp	.-66     	; 0x906 <_ZN15EncoderPendulum3runEv+0x50>

00000948 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     952:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <_ZN8frt_taskC1EPKchjP8emstream>
     956:	82 e1       	ldi	r24, 0x12	; 18
     958:	90 e2       	ldi	r25, 0x20	; 32
     95a:	88 83       	st	Y, r24
     95c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	08 95       	ret

00000968 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	00 d0       	rcall	.+0      	; 0x96e <_ZN13LimitSwitches3runEv+0x6>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     976:	0e 94 78 13 	call	0x26f0	; 0x26f0 <xTaskGetTickCount>
     97a:	69 83       	std	Y+1, r22	; 0x01
     97c:	7a 83       	std	Y+2, r23	; 0x02
     97e:	8b 83       	std	Y+3, r24	; 0x03
     980:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     982:	e0 e6       	ldi	r30, 0x60	; 96
     984:	f6 e0       	ldi	r31, 0x06	; 6
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     98a:	84 e0       	ldi	r24, 0x04	; 4
     98c:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     98e:	88 e1       	ldi	r24, 0x18	; 24
     990:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     992:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     994:	08 e6       	ldi	r16, 0x68	; 104
     996:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     998:	dd 24       	eor	r13, r13
     99a:	d3 94       	inc	r13
     99c:	f8 01       	movw	r30, r16
     99e:	80 81       	ld	r24, Z
     9a0:	80 fd       	sbrc	r24, 0
     9a2:	08 c0       	rjmp	.+16     	; 0x9b4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
			the_data = new_data;
     9aa:	d0 92 4d 31 	sts	0x314D, r13	; 0x80314d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9ae:	0f 90       	pop	r0
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	07 c0       	rjmp	.+14     	; 0x9c2 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	0f 92       	push	r0
			the_data = new_data;
     9ba:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     9c2:	f8 01       	movw	r30, r16
     9c4:	80 81       	ld	r24, Z
     9c6:	82 fd       	sbrc	r24, 2
     9c8:	08 c0       	rjmp	.+16     	; 0x9da <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
			the_data = new_data;
     9d0:	d0 92 4c 31 	sts	0x314C, r13	; 0x80314c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	f8 94       	cli
     9de:	0f 92       	push	r0
			the_data = new_data;
     9e0:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     9e8:	f7 01       	movw	r30, r14
     9ea:	86 85       	ldd	r24, Z+14	; 0x0e
     9ec:	97 85       	ldd	r25, Z+15	; 0x0f
     9ee:	a0 89       	ldd	r26, Z+16	; 0x10
     9f0:	b1 89       	ldd	r27, Z+17	; 0x11
     9f2:	01 96       	adiw	r24, 0x01	; 1
     9f4:	a1 1d       	adc	r26, r1
     9f6:	b1 1d       	adc	r27, r1
     9f8:	86 87       	std	Z+14, r24	; 0x0e
     9fa:	97 87       	std	Z+15, r25	; 0x0f
     9fc:	a0 8b       	std	Z+16, r26	; 0x10
     9fe:	b1 8b       	std	Z+17, r27	; 0x11
     a00:	41 e0       	ldi	r20, 0x01	; 1
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	01 96       	adiw	r24, 0x01	; 1
     a0c:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vTaskDelayUntil>
     a10:	c5 cf       	rjmp	.-118    	; 0x99c <_ZN13LimitSwitches3runEv+0x34>

00000a12 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderMotor.h"					// Header for this file
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a1c:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <_ZN8frt_taskC1EPKchjP8emstream>
     a20:	8a e1       	ldi	r24, 0x1A	; 26
     a22:	90 e2       	ldi	r25, 0x20	; 32
     a24:	88 83       	st	Y, r24
     a26:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	08 95       	ret

00000a32 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	6a 97       	sbiw	r28, 0x1a	; 26
     a3c:	cd bf       	out	0x3d, r28	; 61
     a3e:	de bf       	out	0x3e, r29	; 62
     a40:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     a42:	0e 94 78 13 	call	0x26f0	; 0x26f0 <xTaskGetTickCount>
     a46:	69 83       	std	Y+1, r22	; 0x01
     a48:	7a 83       	std	Y+2, r23	; 0x02
     a4a:	8b 83       	std	Y+3, r24	; 0x03
     a4c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     a4e:	f8 01       	movw	r30, r16
     a50:	fe 96       	adiw	r30, 0x3e	; 62
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	a0 e0       	ldi	r26, 0x00	; 0
     a58:	b0 e0       	ldi	r27, 0x00	; 0
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
     a5e:	a2 83       	std	Z+2, r26	; 0x02
     a60:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     a62:	d8 01       	movw	r26, r16
     a64:	dc 96       	adiw	r26, 0x3c	; 60
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     a6c:	a0 e4       	ldi	r26, 0x40	; 64
     a6e:	b6 e0       	ldi	r27, 0x06	; 6
     a70:	87 e0       	ldi	r24, 0x07	; 7
     a72:	11 96       	adiw	r26, 0x01	; 1
     a74:	8c 93       	st	X, r24
     a76:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     a78:	84 e0       	ldi	r24, 0x04	; 4
     a7a:	15 96       	adiw	r26, 0x05	; 5
     a7c:	8c 93       	st	X, r24
     a7e:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     a80:	e0 e0       	ldi	r30, 0x00	; 0
     a82:	f8 e0       	ldi	r31, 0x08	; 8
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     a88:	83 e0       	ldi	r24, 0x03	; 3
     a8a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     a8c:	a6 a3       	std	Z+38, r26	; 0x26
     a8e:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     a90:	10 a6       	std	Z+40, r1	; 0x28
     a92:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     a94:	12 a6       	std	Z+42, r1	; 0x2a
     a96:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     a98:	81 81       	ldd	r24, Z+1	; 0x01
     a9a:	80 63       	ori	r24, 0x30	; 48
     a9c:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	0f 92       	push	r0
			the_data = new_data;
     aa4:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <linear_offset>
     aa8:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     aac:	0f 90       	pop	r0
     aae:	0f be       	out	0x3f, r0	; 63
	linear_offset.put(0);								// Initialize motor offset	
	int16_t left_home;									// Initialize left distance to calculate center
	int16_t position_set;								// Setpoint of cart's position
	int16_t KP_pos = 0.4*256;							// P gain for cart position	0.4			
	int16_t position_error = 0;							// positional error	
	int16_t position_midpoint = 0;						// midpoint calculated from homing sequence
     ab0:	1d 8a       	std	Y+21, r1	; 0x15
     ab2:	1e 8a       	std	Y+22, r1	; 0x16
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(500);
				_integral = 0;
     ab4:	58 01       	movw	r10, r16
     ab6:	b0 e5       	ldi	r27, 0x50	; 80
     ab8:	ab 0e       	add	r10, r27
     aba:	b1 1c       	adc	r11, r1
			case(4) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
     abc:	f8 01       	movw	r30, r16
     abe:	fe 96       	adiw	r30, 0x3e	; 62
     ac0:	ed 83       	std	Y+5, r30	; 0x05
     ac2:	fe 83       	std	Y+6, r31	; 0x06
				_pre_angle_error = angle_error;
				angle_Dout = (_Kd_angle * angle_derivative)/256;

				output_correct = output;
     ac4:	68 01       	movw	r12, r16
     ac6:	fe e5       	ldi	r31, 0x5E	; 94
     ac8:	cf 0e       	add	r12, r31
     aca:	d1 1c       	adc	r13, r1
     acc:	98 01       	movw	r18, r16
     ace:	20 5a       	subi	r18, 0xA0	; 160
     ad0:	3f 4f       	sbci	r19, 0xFF	; 255
     ad2:	2f 87       	std	Y+15, r18	; 0x0f
     ad4:	38 8b       	std	Y+16, r19	; 0x10
				linear_offset.put(0);										// re initialize
				if (begin.get())											// If user begins Calibration Sequence
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     ad6:	0f 2e       	mov	r0, r31
     ad8:	fa e0       	ldi	r31, 0x0A	; 10
     ada:	2f 2e       	mov	r2, r31
     adc:	31 2c       	mov	r3, r1
     ade:	f0 2d       	mov	r31, r0
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     ae0:	c8 01       	movw	r24, r16
     ae2:	88 5b       	subi	r24, 0xB8	; 184
     ae4:	9f 4f       	sbci	r25, 0xFF	; 255
     ae6:	89 8b       	std	Y+17, r24	; 0x11
     ae8:	9a 8b       	std	Y+18, r25	; 0x12
		_Ki = .7*256;
     aea:	d8 01       	movw	r26, r16
     aec:	a4 5b       	subi	r26, 0xB4	; 180
     aee:	bf 4f       	sbci	r27, 0xFF	; 255
     af0:	af 83       	std	Y+7, r26	; 0x07
     af2:	b8 87       	std	Y+8, r27	; 0x08
		_Kd = 0;
     af4:	f8 01       	movw	r30, r16
     af6:	e6 5b       	subi	r30, 0xB6	; 182
     af8:	ff 4f       	sbci	r31, 0xFF	; 255
     afa:	eb 8b       	std	Y+19, r30	; 0x13
     afc:	fc 8b       	std	Y+20, r31	; 0x14
		antiwind_gain = .75*256;
     afe:	2c 5f       	subi	r18, 0xFC	; 252
     b00:	3f 4f       	sbci	r19, 0xFF	; 255
     b02:	29 87       	std	Y+9, r18	; 0x09
     b04:	3a 87       	std	Y+10, r19	; 0x0a
		
		_max = 1600;
     b06:	04 97       	sbiw	r24, 0x04	; 4
     b08:	8b 87       	std	Y+11, r24	; 0x0b
     b0a:	9c 87       	std	Y+12, r25	; 0x0c
		_min = -1600;
     b0c:	16 97       	sbiw	r26, 0x06	; 6
     b0e:	ad 87       	std	Y+13, r26	; 0x0d
     b10:	be 87       	std	Y+14, r27	; 0x0e
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
     b12:	48 01       	movw	r8, r16
     b14:	b6 e6       	ldi	r27, 0x66	; 102
     b16:	8b 0e       	add	r8, r27
     b18:	91 1c       	adc	r9, r1
	int16_t omegam_saturation_point;
	int16_t K_position_antiwind = 0*256;				// position anti windup gain
	
	while(1){
		// Increment counter for debugging
		runs++;
     b1a:	f8 01       	movw	r30, r16
     b1c:	46 85       	ldd	r20, Z+14	; 0x0e
     b1e:	57 85       	ldd	r21, Z+15	; 0x0f
     b20:	60 89       	ldd	r22, Z+16	; 0x10
     b22:	71 89       	ldd	r23, Z+17	; 0x11
     b24:	4f 5f       	subi	r20, 0xFF	; 255
     b26:	5f 4f       	sbci	r21, 0xFF	; 255
     b28:	6f 4f       	sbci	r22, 0xFF	; 255
     b2a:	7f 4f       	sbci	r23, 0xFF	; 255
     b2c:	46 87       	std	Z+14, r20	; 0x0e
     b2e:	57 87       	std	Z+15, r21	; 0x0f
     b30:	60 8b       	std	Z+16, r22	; 0x10
     b32:	71 8b       	std	Z+17, r23	; 0x11
		
		switch (state)
     b34:	84 85       	ldd	r24, Z+12	; 0x0c
     b36:	82 30       	cpi	r24, 0x02	; 2
     b38:	09 f4       	brne	.+2      	; 0xb3c <_ZN5Motor3runEv+0x10a>
     b3a:	99 c0       	rjmp	.+306    	; 0xc6e <_ZN5Motor3runEv+0x23c>
     b3c:	30 f4       	brcc	.+12     	; 0xb4a <_ZN5Motor3runEv+0x118>
     b3e:	88 23       	and	r24, r24
     b40:	69 f0       	breq	.+26     	; 0xb5c <_ZN5Motor3runEv+0x12a>
     b42:	81 30       	cpi	r24, 0x01	; 1
     b44:	09 f4       	brne	.+2      	; 0xb48 <_ZN5Motor3runEv+0x116>
     b46:	58 c0       	rjmp	.+176    	; 0xbf8 <_ZN5Motor3runEv+0x1c6>
     b48:	cc c1       	rjmp	.+920    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
     b4a:	84 30       	cpi	r24, 0x04	; 4
     b4c:	09 f4       	brne	.+2      	; 0xb50 <_ZN5Motor3runEv+0x11e>
     b4e:	08 c1       	rjmp	.+528    	; 0xd60 <_ZN5Motor3runEv+0x32e>
     b50:	08 f4       	brcc	.+2      	; 0xb54 <_ZN5Motor3runEv+0x122>
     b52:	a1 c0       	rjmp	.+322    	; 0xc96 <_ZN5Motor3runEv+0x264>
     b54:	84 36       	cpi	r24, 0x64	; 100
     b56:	09 f4       	brne	.+2      	; 0xb5a <_ZN5Motor3runEv+0x128>
     b58:	90 c1       	rjmp	.+800    	; 0xe7a <_ZN5Motor3runEv+0x448>
     b5a:	c3 c1       	rjmp	.+902    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	0f 92       	push	r0
			the_data = new_data;
     b62:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <linear_offset>
     b66:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     b6a:	0f 90       	pop	r0
     b6c:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b6e:	0f b6       	in	r0, 0x3f	; 63
     b70:	f8 94       	cli
     b72:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b74:	0f 90       	pop	r0
     b76:	0f be       	out	0x3f, r0	; 63
		{
			// Home right
			case(0) :
				linear_offset.put(0);										// re initialize
				if (begin.get())											// If user begins Calibration Sequence
     b78:	80 91 49 31 	lds	r24, 0x3149	; 0x803149 <begin>
     b7c:	88 23       	and	r24, r24
     b7e:	09 f4       	brne	.+2      	; 0xb82 <_ZN5Motor3runEv+0x150>
     b80:	b0 c1       	rjmp	.+864    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b82:	0f b6       	in	r0, 0x3f	; 63
     b84:	f8 94       	cli
     b86:	0f 92       	push	r0
			the_data = new_data;
     b88:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     b8c:	0f 90       	pop	r0
     b8e:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b90:	0f b6       	in	r0, 0x3f	; 63
     b92:	f8 94       	cli
     b94:	0f 92       	push	r0
			the_data = new_data;
     b96:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <stop>
			portEXIT_CRITICAL ();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     b9e:	f8 01       	movw	r30, r16
     ba0:	22 8e       	std	Z+26, r2	; 0x1a
     ba2:	33 8e       	std	Z+27, r3	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ba4:	0f b6       	in	r0, 0x3f	; 63
     ba6:	f8 94       	cli
     ba8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63

					if (rightLimitSwitch.get())
     bae:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rightLimitSwitch>
     bb2:	88 23       	and	r24, r24
     bb4:	09 f4       	brne	.+2      	; 0xbb8 <_ZN5Motor3runEv+0x186>
     bb6:	95 c1       	rjmp	.+810    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bb8:	0f b6       	in	r0, 0x3f	; 63
     bba:	f8 94       	cli
     bbc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bbe:	0f 90       	pop	r0
     bc0:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bc2:	0f b6       	in	r0, 0x3f	; 63
     bc4:	f8 94       	cli
     bc6:	0f 92       	push	r0
			the_data = new_data;
     bc8:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     bcc:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     bd0:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <linear_offset>
     bd4:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
     bdc:	d5 01       	movw	r26, r10
     bde:	1d 92       	st	X+, r1
     be0:	1d 92       	st	X+, r1
     be2:	1d 92       	st	X+, r1
     be4:	1c 92       	st	X, r1
     be6:	13 97       	sbiw	r26, 0x03	; 3
						output_correct = 0;
     be8:	f6 01       	movw	r30, r12
     bea:	10 82       	st	Z, r1
     bec:	11 82       	std	Z+1, r1	; 0x01
						transition_to(1);									// if right Limit Switch is triggered 
     bee:	61 e0       	ldi	r22, 0x01	; 1
     bf0:	c8 01       	movw	r24, r16
     bf2:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
     bf6:	75 c1       	rjmp	.+746    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	0f 92       	push	r0
			the_data = new_data;
     bfe:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <begin>
			portEXIT_CRITICAL ();
     c02:	0f 90       	pop	r0
     c04:	0f be       	out	0x3f, r0	; 63
				break;
				
			// Home left
			case(1) :
				begin.put(0);		// turn off flag
				omegam_set = -10;	// [ticks/ms]
     c06:	86 ef       	ldi	r24, 0xF6	; 246
     c08:	9f ef       	ldi	r25, 0xFF	; 255
     c0a:	82 8f       	std	Z+26, r24	; 0x1a
     c0c:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	f8 94       	cli
     c12:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c14:	0f 90       	pop	r0
     c16:	0f be       	out	0x3f, r0	; 63
				
				if (leftLimitSwitch.get())
     c18:	80 91 4d 31 	lds	r24, 0x314D	; 0x80314d <leftLimitSwitch>
     c1c:	88 23       	and	r24, r24
     c1e:	c1 f0       	breq	.+48     	; 0xc50 <_ZN5Motor3runEv+0x21e>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c20:	0f b6       	in	r0, 0x3f	; 63
     c22:	f8 94       	cli
     c24:	0f 92       	push	r0
			temporary_copy = the_data;
     c26:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <linear_position>
     c2a:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <linear_position+0x1>
     c2e:	ef 8b       	std	Y+23, r30	; 0x17
     c30:	f8 8f       	std	Y+24, r31	; 0x18
			portEXIT_CRITICAL ();
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     c36:	d5 01       	movw	r26, r10
     c38:	1d 92       	st	X+, r1
     c3a:	1d 92       	st	X+, r1
     c3c:	1d 92       	st	X+, r1
     c3e:	1c 92       	st	X, r1
     c40:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     c42:	f6 01       	movw	r30, r12
     c44:	10 82       	st	Z, r1
     c46:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     c48:	62 e0       	ldi	r22, 0x02	; 2
     c4a:	c8 01       	movw	r24, r16
     c4c:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c56:	0f 90       	pop	r0
     c58:	0f be       	out	0x3f, r0	; 63
				}
						
				if (reset.get() == 1)
     c5a:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     c5e:	88 23       	and	r24, r24
     c60:	09 f4       	brne	.+2      	; 0xc64 <_ZN5Motor3runEv+0x232>
     c62:	3f c1       	rjmp	.+638    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				{
					transition_to(0);
     c64:	60 e0       	ldi	r22, 0x00	; 0
     c66:	c8 01       	movw	r24, r16
     c68:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
     c6c:	3a c1       	rjmp	.+628    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     c6e:	64 ef       	ldi	r22, 0xF4	; 244
     c70:	71 e0       	ldi	r23, 0x01	; 1
     c72:	80 e0       	ldi	r24, 0x00	; 0
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	0e 94 83 15 	call	0x2b06	; 0x2b06 <vTaskDelay>
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(500);
				_integral = 0;
     c7a:	d5 01       	movw	r26, r10
     c7c:	1d 92       	st	X+, r1
     c7e:	1d 92       	st	X+, r1
     c80:	1d 92       	st	X+, r1
     c82:	1c 92       	st	X, r1
     c84:	13 97       	sbiw	r26, 0x03	; 3
				omegam_set = 0;
     c86:	f8 01       	movw	r30, r16
     c88:	12 8e       	std	Z+26, r1	; 0x1a
     c8a:	13 8e       	std	Z+27, r1	; 0x1b
				transition_to(3);
     c8c:	63 e0       	ldi	r22, 0x03	; 3
     c8e:	c8 01       	movw	r24, r16
     c90:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
				break;
     c94:	26 c1       	rjmp	.+588    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				
			
			// Center Cart - Position Loop included
			case(3) :
				position_midpoint = left_home/2;
     c96:	8f 89       	ldd	r24, Y+23	; 0x17
     c98:	98 8d       	ldd	r25, Y+24	; 0x18
     c9a:	99 23       	and	r25, r25
     c9c:	0c f4       	brge	.+2      	; 0xca0 <_ZN5Motor3runEv+0x26e>
     c9e:	01 96       	adiw	r24, 0x01	; 1
     ca0:	9c 01       	movw	r18, r24
     ca2:	35 95       	asr	r19
     ca4:	27 95       	ror	r18
     ca6:	2d 8b       	std	Y+21, r18	; 0x15
     ca8:	3e 8b       	std	Y+22, r19	; 0x16
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cb0:	0f 90       	pop	r0
     cb2:	0f be       	out	0x3f, r0	; 63
				
				position_error_windup = position_error - antiwind_pos_correct;			// Subtracts omegam_set windup
				position_windup_integral = (_Ki_position * position_error_windup);	// Integral gain on omegam_set windup difference
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_integral * dt)/256;						// Integrates omegam_set windup difference with gain
				omegam_set_windup = ssadd(omegam_set_Kp, omegam_set_Ki);					// Add proportionality and integral gain
     cb4:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     cb8:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     cbc:	28 1b       	sub	r18, r24
     cbe:	39 0b       	sbc	r19, r25
     cc0:	c9 01       	movw	r24, r18
     cc2:	46 e6       	ldi	r20, 0x66	; 102
     cc4:	48 9f       	mul	r20, r24
     cc6:	90 01       	movw	r18, r0
     cc8:	49 9f       	mul	r20, r25
     cca:	30 0d       	add	r19, r0
     ccc:	11 24       	eor	r1, r1
     cce:	33 23       	and	r19, r19
     cd0:	14 f4       	brge	.+4      	; 0xcd6 <_ZN5Motor3runEv+0x2a4>
     cd2:	21 50       	subi	r18, 0x01	; 1
     cd4:	3f 4f       	sbci	r19, 0xFF	; 255
     cd6:	60 e0       	ldi	r22, 0x00	; 0
     cd8:	70 e0       	ldi	r23, 0x00	; 0
     cda:	83 2f       	mov	r24, r19
     cdc:	93 2f       	mov	r25, r19
     cde:	99 0f       	add	r25, r25
     ce0:	99 0b       	sbc	r25, r25
     ce2:	0e 94 2f 09 	call	0x125e	; 0x125e <_ZN7satmath20signed_saturated_addEii>
				omegam_set = omegam_set_windup;												// Set desired to requested
				
				omegam_saturation_point = 30;
				if( omegam_set > omegam_saturation_point )														// Saturate requested omegam_set
     ce6:	8f 31       	cpi	r24, 0x1F	; 31
     ce8:	91 05       	cpc	r25, r1
     cea:	44 f0       	brlt	.+16     	; 0xcfc <_ZN5Motor3runEv+0x2ca>
				{
					omegam_set = omegam_saturation_point;
     cec:	8e e1       	ldi	r24, 0x1E	; 30
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	d8 01       	movw	r26, r16
     cf2:	5a 96       	adiw	r26, 0x1a	; 26
     cf4:	8d 93       	st	X+, r24
     cf6:	9c 93       	st	X, r25
     cf8:	5b 97       	sbiw	r26, 0x1b	; 27
     cfa:	0f c0       	rjmp	.+30     	; 0xd1a <_ZN5Motor3runEv+0x2e8>
				}
				else if( omegam_set < -omegam_saturation_point )
     cfc:	82 3e       	cpi	r24, 0xE2	; 226
     cfe:	bf ef       	ldi	r27, 0xFF	; 255
     d00:	9b 07       	cpc	r25, r27
     d02:	24 f0       	brlt	.+8      	; 0xd0c <_ZN5Motor3runEv+0x2da>
				position_error_windup = position_error - antiwind_pos_correct;			// Subtracts omegam_set windup
				position_windup_integral = (_Ki_position * position_error_windup);	// Integral gain on omegam_set windup difference
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_integral * dt)/256;						// Integrates omegam_set windup difference with gain
				omegam_set_windup = ssadd(omegam_set_Kp, omegam_set_Ki);					// Add proportionality and integral gain
				omegam_set = omegam_set_windup;												// Set desired to requested
     d04:	f8 01       	movw	r30, r16
     d06:	82 8f       	std	Z+26, r24	; 0x1a
     d08:	93 8f       	std	Z+27, r25	; 0x1b
     d0a:	07 c0       	rjmp	.+14     	; 0xd1a <_ZN5Motor3runEv+0x2e8>
				{
					omegam_set = omegam_saturation_point;
				}
				else if( omegam_set < -omegam_saturation_point )
				{
					omegam_set = -omegam_saturation_point;
     d0c:	82 ee       	ldi	r24, 0xE2	; 226
     d0e:	9f ef       	ldi	r25, 0xFF	; 255
     d10:	d8 01       	movw	r26, r16
     d12:	5a 96       	adiw	r26, 0x1a	; 26
     d14:	8d 93       	st	X+, r24
     d16:	9c 93       	st	X, r25
     d18:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d1a:	0f b6       	in	r0, 0x3f	; 63
     d1c:	f8 94       	cli
     d1e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d20:	0f 90       	pop	r0
     d22:	0f be       	out	0x3f, r0	; 63
				}
				
				antiwind_position = omegam_set_windup - omegam_set;					// Calculate windup error between desired and requested
				antiwind_pos_correct = (antiwind_error*K_position_antiwind)/256;
				
				if (reset.get() == 1)			// if user hits reset
     d24:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     d28:	88 23       	and	r24, r24
     d2a:	59 f0       	breq	.+22     	; 0xd42 <_ZN5Motor3runEv+0x310>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d2c:	0f b6       	in	r0, 0x3f	; 63
     d2e:	f8 94       	cli
     d30:	0f 92       	push	r0
			the_data = new_data;
     d32:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     d36:	0f 90       	pop	r0
     d38:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);				// turn off flag
					transition_to(0);
     d3a:	60 e0       	ldi	r22, 0x00	; 0
     d3c:	c8 01       	movw	r24, r16
     d3e:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d42:	0f b6       	in	r0, 0x3f	; 63
     d44:	f8 94       	cli
     d46:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d48:	0f 90       	pop	r0
     d4a:	0f be       	out	0x3f, r0	; 63
					
				}
				
				if(go.get() == 1)				// If user says pendulum is upright or angle = 720;
     d4c:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <go>
     d50:	88 23       	and	r24, r24
     d52:	09 f4       	brne	.+2      	; 0xd56 <_ZN5Motor3runEv+0x324>
     d54:	c6 c0       	rjmp	.+396    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				{
					transition_to(4);
     d56:	64 e0       	ldi	r22, 0x04	; 4
     d58:	c8 01       	movw	r24, r16
     d5a:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
     d5e:	c1 c0       	rjmp	.+386    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d60:	0f b6       	in	r0, 0x3f	; 63
     d62:	f8 94       	cli
     d64:	0f 92       	push	r0
			the_data = new_data;
     d66:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <go>
			portEXIT_CRITICAL ();
     d6a:	0f 90       	pop	r0
     d6c:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d6e:	0f b6       	in	r0, 0x3f	; 63
     d70:	f8 94       	cli
     d72:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d74:	0f 90       	pop	r0
     d76:	0f be       	out	0x3f, r0	; 63
			break;
			
			// Pendulum Balance if user sets pendulum "Inverted" and presses go
			case(4) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
     d78:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <thPendulum>
     d7c:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <thPendulum+0x1>
     d80:	20 ed       	ldi	r18, 0xD0	; 208
     d82:	32 e0       	ldi	r19, 0x02	; 2
     d84:	79 01       	movw	r14, r18
     d86:	e8 1a       	sub	r14, r24
     d88:	f9 0a       	sbc	r15, r25
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
				angle_Dout = (_Kd_angle * angle_derivative)/256;
     d8a:	b7 01       	movw	r22, r14
     d8c:	e9 8d       	ldd	r30, Y+25	; 0x19
     d8e:	fa 8d       	ldd	r31, Y+26	; 0x1a
     d90:	6e 1b       	sub	r22, r30
     d92:	7f 0b       	sbc	r23, r31
     d94:	07 2e       	mov	r0, r23
     d96:	00 0c       	add	r0, r0
     d98:	88 0b       	sbc	r24, r24
     d9a:	99 0b       	sbc	r25, r25
     d9c:	ad 81       	ldd	r26, Y+5	; 0x05
     d9e:	be 81       	ldd	r27, Y+6	; 0x06
     da0:	2d 91       	ld	r18, X+
     da2:	3d 91       	ld	r19, X+
     da4:	4d 91       	ld	r20, X+
     da6:	5c 91       	ld	r21, X
     da8:	0e 94 77 22 	call	0x44ee	; 0x44ee <__divmodsi4>
     dac:	64 eb       	ldi	r22, 0xB4	; 180
     dae:	62 03       	mulsu	r22, r18
     db0:	c0 01       	movw	r24, r0
     db2:	63 9f       	mul	r22, r19
     db4:	90 0d       	add	r25, r0
     db6:	11 24       	eor	r1, r1
     db8:	99 23       	and	r25, r25
     dba:	14 f4       	brge	.+4      	; 0xdc0 <_ZN5Motor3runEv+0x38e>
     dbc:	81 50       	subi	r24, 0x01	; 1
     dbe:	9f 4f       	sbci	r25, 0xFF	; 255
     dc0:	79 2f       	mov	r23, r25
     dc2:	77 0f       	add	r23, r23
     dc4:	77 0b       	sbc	r23, r23
     dc6:	69 2f       	mov	r22, r25

				output_correct = output;
     dc8:	ef 85       	ldd	r30, Y+15	; 0x0f
     dca:	f8 89       	ldd	r31, Y+16	; 0x10
     dcc:	80 81       	ld	r24, Z
     dce:	91 81       	ldd	r25, Z+1	; 0x01
     dd0:	d6 01       	movw	r26, r12
     dd2:	8d 93       	st	X+, r24
     dd4:	9c 93       	st	X, r25
				Pang_out = position_midpoint + (angle_error*KP_angle)/256;
				
				// Calculate total output
				position_set = ssadd(Pang_out, angle_Dout);
     dd6:	20 e0       	ldi	r18, 0x00	; 0
     dd8:	34 ef       	ldi	r19, 0xF4	; 244
     dda:	e2 9e       	mul	r14, r18
     ddc:	c0 01       	movw	r24, r0
     dde:	e3 9e       	mul	r14, r19
     de0:	90 0d       	add	r25, r0
     de2:	f2 9e       	mul	r15, r18
     de4:	90 0d       	add	r25, r0
     de6:	11 24       	eor	r1, r1
     de8:	99 23       	and	r25, r25
     dea:	14 f4       	brge	.+4      	; 0xdf0 <_ZN5Motor3runEv+0x3be>
     dec:	81 50       	subi	r24, 0x01	; 1
     dee:	9f 4f       	sbci	r25, 0xFF	; 255
     df0:	89 2f       	mov	r24, r25
     df2:	99 0f       	add	r25, r25
     df4:	99 0b       	sbc	r25, r25
     df6:	ed 89       	ldd	r30, Y+21	; 0x15
     df8:	fe 89       	ldd	r31, Y+22	; 0x16
     dfa:	8e 0f       	add	r24, r30
     dfc:	9f 1f       	adc	r25, r31
     dfe:	0e 94 2f 09 	call	0x125e	; 0x125e <_ZN7satmath20signed_saturated_addEii>
				
				// Saturation for limits of tracks
				
				if (position_set >= -100) //20
     e02:	8c 39       	cpi	r24, 0x9C	; 156
     e04:	ff ef       	ldi	r31, 0xFF	; 255
     e06:	9f 07       	cpc	r25, r31
     e08:	3c f4       	brge	.+14     	; 0xe18 <_ZN5Motor3runEv+0x3e6>
				{
					position_set = -100;
					omegam_set = 0;
				}
				else if (position_set <= -300) //325
     e0a:	85 3d       	cpi	r24, 0xD5	; 213
     e0c:	2e ef       	ldi	r18, 0xFE	; 254
     e0e:	92 07       	cpc	r25, r18
     e10:	2c f4       	brge	.+10     	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				{
					position_set = -300; //352
     e12:	84 ed       	ldi	r24, 0xD4	; 212
     e14:	9e ef       	ldi	r25, 0xFE	; 254
     e16:	02 c0       	rjmp	.+4      	; 0xe1c <_ZN5Motor3runEv+0x3ea>
				
				// Saturation for limits of tracks
				
				if (position_set >= -100) //20
				{
					position_set = -100;
     e18:	8c e9       	ldi	r24, 0x9C	; 156
     e1a:	9f ef       	ldi	r25, 0xFF	; 255
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	f8 94       	cli
     e20:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e22:	0f 90       	pop	r0
     e24:	0f be       	out	0x3f, r0	; 63
					position_set = position_set;
				}
				
				position_error = position_set - linear_position.get();  // 
				omegam_set_windup = position_error*KP_pos/256;
				omegam_set = omegam_set_windup;
     e26:	20 91 52 31 	lds	r18, 0x3152	; 0x803152 <linear_position>
     e2a:	30 91 53 31 	lds	r19, 0x3153	; 0x803153 <linear_position+0x1>
     e2e:	82 1b       	sub	r24, r18
     e30:	93 0b       	sbc	r25, r19
     e32:	46 e6       	ldi	r20, 0x66	; 102
     e34:	48 9f       	mul	r20, r24
     e36:	90 01       	movw	r18, r0
     e38:	49 9f       	mul	r20, r25
     e3a:	30 0d       	add	r19, r0
     e3c:	11 24       	eor	r1, r1
     e3e:	33 23       	and	r19, r19
     e40:	14 f4       	brge	.+4      	; 0xe46 <_ZN5Motor3runEv+0x414>
     e42:	21 50       	subi	r18, 0x01	; 1
     e44:	3f 4f       	sbci	r19, 0xFF	; 255
     e46:	83 2f       	mov	r24, r19
     e48:	88 0f       	add	r24, r24
     e4a:	88 0b       	sbc	r24, r24
     e4c:	d8 01       	movw	r26, r16
     e4e:	5a 96       	adiw	r26, 0x1a	; 26
     e50:	3c 93       	st	X, r19
     e52:	5a 97       	sbiw	r26, 0x1a	; 26
     e54:	5b 96       	adiw	r26, 0x1b	; 27
     e56:	8c 93       	st	X, r24
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e58:	0f b6       	in	r0, 0x3f	; 63
     e5a:	f8 94       	cli
     e5c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e5e:	0f 90       	pop	r0
     e60:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get())
     e62:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     e66:	88 23       	and	r24, r24
     e68:	09 f4       	brne	.+2      	; 0xe6c <_ZN5Motor3runEv+0x43a>
     e6a:	39 c0       	rjmp	.+114    	; 0xede <_ZN5Motor3runEv+0x4ac>
				{
					transition_to(0);
     e6c:	60 e0       	ldi	r22, 0x00	; 0
     e6e:	c8 01       	movw	r24, r16
     e70:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
     e74:	e9 8e       	std	Y+25, r14	; 0x19
     e76:	fa 8e       	std	Y+26, r15	; 0x1a
     e78:	34 c0       	rjmp	.+104    	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				}
					
			break;
			
			case(100) :
			omegam_set = 0;
     e7a:	f8 01       	movw	r30, r16
     e7c:	12 8e       	std	Z+26, r1	; 0x1a
     e7e:	13 8e       	std	Z+27, r1	; 0x1b
			
			if (runs%300 == 0)
     e80:	cb 01       	movw	r24, r22
     e82:	ba 01       	movw	r22, r20
     e84:	2c e2       	ldi	r18, 0x2C	; 44
     e86:	31 e0       	ldi	r19, 0x01	; 1
     e88:	40 e0       	ldi	r20, 0x00	; 0
     e8a:	50 e0       	ldi	r21, 0x00	; 0
     e8c:	0e 94 55 22 	call	0x44aa	; 0x44aa <__udivmodsi4>
     e90:	67 2b       	or	r22, r23
     e92:	68 2b       	or	r22, r24
     e94:	69 2b       	or	r22, r25
     e96:	71 f4       	brne	.+28     	; 0xeb4 <_ZN5Motor3runEv+0x482>
			{
				*p_serial << "Error State" << endl;
     e98:	d8 01       	movw	r26, r16
     e9a:	16 96       	adiw	r26, 0x06	; 6
     e9c:	ed 90       	ld	r14, X+
     e9e:	fc 90       	ld	r15, X
     ea0:	17 97       	sbiw	r26, 0x07	; 7
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     ea2:	6e e1       	ldi	r22, 0x1E	; 30
     ea4:	70 e2       	ldi	r23, 0x20	; 32
     ea6:	c7 01       	movw	r24, r14
     ea8:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
     eac:	66 e0       	ldi	r22, 0x06	; 6
     eae:	c7 01       	movw	r24, r14
     eb0:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     eba:	0f 90       	pop	r0
     ebc:	0f be       	out	0x3f, r0	; 63
			}
			
				if (reset.get())										// if user hits reset
     ebe:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     ec2:	88 23       	and	r24, r24
     ec4:	71 f0       	breq	.+28     	; 0xee2 <_ZN5Motor3runEv+0x4b0>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     ec6:	0f b6       	in	r0, 0x3f	; 63
     ec8:	f8 94       	cli
     eca:	0f 92       	push	r0
			the_data = new_data;
     ecc:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     ed0:	0f 90       	pop	r0
     ed2:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);
					transition_to(0);
     ed4:	60 e0       	ldi	r22, 0x00	; 0
     ed6:	c8 01       	movw	r24, r16
     ed8:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
     edc:	02 c0       	rjmp	.+4      	; 0xee2 <_ZN5Motor3runEv+0x4b0>
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
     ede:	e9 8e       	std	Y+25, r14	; 0x19
     ee0:	fa 8e       	std	Y+26, r15	; 0x1a
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ee2:	0f b6       	in	r0, 0x3f	; 63
     ee4:	f8 94       	cli
     ee6:	0f 92       	push	r0
			temporary_copy = the_data;
     ee8:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <thdMotor>
     eec:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     ef0:	0f 90       	pop	r0
     ef2:	0f be       	out	0x3f, r0	; 63
		
		};

		
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     ef4:	f8 01       	movw	r30, r16
     ef6:	86 8f       	std	Z+30, r24	; 0x1e
     ef8:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     efa:	a9 89       	ldd	r26, Y+17	; 0x11
     efc:	ba 89       	ldd	r27, Y+18	; 0x12
     efe:	2d 92       	st	X+, r2
     f00:	3c 92       	st	X, r3
		_Ki = .7*256;
     f02:	23 eb       	ldi	r18, 0xB3	; 179
     f04:	30 e0       	ldi	r19, 0x00	; 0
     f06:	ef 81       	ldd	r30, Y+7	; 0x07
     f08:	f8 85       	ldd	r31, Y+8	; 0x08
     f0a:	20 83       	st	Z, r18
     f0c:	31 83       	std	Z+1, r19	; 0x01
		_Kd = 0;
     f0e:	ab 89       	ldd	r26, Y+19	; 0x13
     f10:	bc 89       	ldd	r27, Y+20	; 0x14
     f12:	1d 92       	st	X+, r1
     f14:	1c 92       	st	X, r1
		antiwind_gain = .75*256;
     f16:	20 ec       	ldi	r18, 0xC0	; 192
     f18:	30 e0       	ldi	r19, 0x00	; 0
     f1a:	e9 85       	ldd	r30, Y+9	; 0x09
     f1c:	fa 85       	ldd	r31, Y+10	; 0x0a
     f1e:	20 83       	st	Z, r18
     f20:	31 83       	std	Z+1, r19	; 0x01
		
		_max = 1600;
     f22:	20 e4       	ldi	r18, 0x40	; 64
     f24:	36 e0       	ldi	r19, 0x06	; 6
     f26:	ab 85       	ldd	r26, Y+11	; 0x0b
     f28:	bc 85       	ldd	r27, Y+12	; 0x0c
     f2a:	2d 93       	st	X+, r18
     f2c:	3c 93       	st	X, r19
		_min = -1600;
     f2e:	20 ec       	ldi	r18, 0xC0	; 192
     f30:	39 ef       	ldi	r19, 0xF9	; 249
     f32:	ed 85       	ldd	r30, Y+13	; 0x0d
     f34:	fe 85       	ldd	r31, Y+14	; 0x0e
     f36:	20 83       	st	Z, r18
     f38:	31 83       	std	Z+1, r19	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     f3a:	d8 01       	movw	r26, r16
     f3c:	5a 96       	adiw	r26, 0x1a	; 26
     f3e:	ed 90       	ld	r14, X+
     f40:	fc 90       	ld	r15, X
     f42:	5b 97       	sbiw	r26, 0x1b	; 27
     f44:	e8 1a       	sub	r14, r24
     f46:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     f48:	b7 01       	movw	r22, r14
     f4a:	c1 01       	movw	r24, r2
     f4c:	0e 94 4b 09 	call	0x1296	; 0x1296 <_ZN7satmath20signed_saturated_mulEii>
     f50:	2b 01       	movw	r4, r22
     f52:	3c 01       	movw	r6, r24
     f54:	f8 01       	movw	r30, r16
     f56:	e4 5a       	subi	r30, 0xA4	; 164
     f58:	ff 4f       	sbci	r31, 0xFF	; 255
     f5a:	60 83       	st	Z, r22
     f5c:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     f5e:	f4 01       	movw	r30, r8
     f60:	80 81       	ld	r24, Z
     f62:	91 81       	ldd	r25, Z+1	; 0x01
     f64:	97 01       	movw	r18, r14
     f66:	28 1b       	sub	r18, r24
     f68:	39 0b       	sbc	r19, r25
     f6a:	c9 01       	movw	r24, r18
     f6c:	f8 01       	movw	r30, r16
     f6e:	e8 59       	subi	r30, 0x98	; 152
     f70:	ff 4f       	sbci	r31, 0xFF	; 255
     f72:	20 83       	st	Z, r18
     f74:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     f76:	af 81       	ldd	r26, Y+7	; 0x07
     f78:	b8 85       	ldd	r27, Y+8	; 0x08
     f7a:	2d 91       	ld	r18, X+
     f7c:	3c 91       	ld	r19, X
     f7e:	82 9f       	mul	r24, r18
     f80:	d0 01       	movw	r26, r0
     f82:	83 9f       	mul	r24, r19
     f84:	b0 0d       	add	r27, r0
     f86:	92 9f       	mul	r25, r18
     f88:	b0 0d       	add	r27, r0
     f8a:	11 24       	eor	r1, r1
     f8c:	32 96       	adiw	r30, 0x02	; 2
     f8e:	a0 83       	st	Z, r26
     f90:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     f92:	ed 81       	ldd	r30, Y+5	; 0x05
     f94:	fe 81       	ldd	r31, Y+6	; 0x06
     f96:	20 81       	ld	r18, Z
     f98:	31 81       	ldd	r19, Z+1	; 0x01
     f9a:	42 81       	ldd	r20, Z+2	; 0x02
     f9c:	53 81       	ldd	r21, Z+3	; 0x03
     f9e:	0e 94 c8 22 	call	0x4590	; 0x4590 <__mulshisi3>
     fa2:	9b 01       	movw	r18, r22
     fa4:	ac 01       	movw	r20, r24
     fa6:	99 23       	and	r25, r25
     fa8:	24 f4       	brge	.+8      	; 0xfb2 <_ZN5Motor3runEv+0x580>
     faa:	21 50       	subi	r18, 0x01	; 1
     fac:	3f 4f       	sbci	r19, 0xFF	; 255
     fae:	4f 4f       	sbci	r20, 0xFF	; 255
     fb0:	5f 4f       	sbci	r21, 0xFF	; 255
     fb2:	bb 27       	eor	r27, r27
     fb4:	57 fd       	sbrc	r21, 7
     fb6:	ba 95       	dec	r27
     fb8:	a5 2f       	mov	r26, r21
     fba:	94 2f       	mov	r25, r20
     fbc:	83 2f       	mov	r24, r19
     fbe:	f5 01       	movw	r30, r10
     fc0:	40 81       	ld	r20, Z
     fc2:	51 81       	ldd	r21, Z+1	; 0x01
     fc4:	62 81       	ldd	r22, Z+2	; 0x02
     fc6:	73 81       	ldd	r23, Z+3	; 0x03
     fc8:	84 0f       	add	r24, r20
     fca:	95 1f       	adc	r25, r21
     fcc:	a6 1f       	adc	r26, r22
     fce:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     fd0:	81 30       	cpi	r24, 0x01	; 1
     fd2:	fa ec       	ldi	r31, 0xCA	; 202
     fd4:	9f 07       	cpc	r25, r31
     fd6:	fa e9       	ldi	r31, 0x9A	; 154
     fd8:	af 07       	cpc	r26, r31
     fda:	fb e3       	ldi	r31, 0x3B	; 59
     fdc:	bf 07       	cpc	r27, r31
     fde:	54 f0       	brlt	.+20     	; 0xff4 <_ZN5Motor3runEv+0x5c2>
		{
			_integral = 1000000000;
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	9a ec       	ldi	r25, 0xCA	; 202
     fe4:	aa e9       	ldi	r26, 0x9A	; 154
     fe6:	bb e3       	ldi	r27, 0x3B	; 59
     fe8:	f5 01       	movw	r30, r10
     fea:	80 83       	st	Z, r24
     fec:	91 83       	std	Z+1, r25	; 0x01
     fee:	a2 83       	std	Z+2, r26	; 0x02
     ff0:	b3 83       	std	Z+3, r27	; 0x03
     ff2:	17 c0       	rjmp	.+46     	; 0x1022 <_ZN5Motor3runEv+0x5f0>
		}
		else if(_integral < -1000000000)
     ff4:	81 15       	cp	r24, r1
     ff6:	f6 e3       	ldi	r31, 0x36	; 54
     ff8:	9f 07       	cpc	r25, r31
     ffa:	f5 e6       	ldi	r31, 0x65	; 101
     ffc:	af 07       	cpc	r26, r31
     ffe:	f4 ec       	ldi	r31, 0xC4	; 196
    1000:	bf 07       	cpc	r27, r31
    1002:	34 f0       	brlt	.+12     	; 0x1010 <_ZN5Motor3runEv+0x5de>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
    1004:	f5 01       	movw	r30, r10
    1006:	80 83       	st	Z, r24
    1008:	91 83       	std	Z+1, r25	; 0x01
    100a:	a2 83       	std	Z+2, r26	; 0x02
    100c:	b3 83       	std	Z+3, r27	; 0x03
    100e:	09 c0       	rjmp	.+18     	; 0x1022 <_ZN5Motor3runEv+0x5f0>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
    1010:	80 e0       	ldi	r24, 0x00	; 0
    1012:	96 e3       	ldi	r25, 0x36	; 54
    1014:	a5 e6       	ldi	r26, 0x65	; 101
    1016:	b4 ec       	ldi	r27, 0xC4	; 196
    1018:	f5 01       	movw	r30, r10
    101a:	80 83       	st	Z, r24
    101c:	91 83       	std	Z+1, r25	; 0x01
    101e:	a2 83       	std	Z+2, r26	; 0x02
    1020:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
    1022:	d5 01       	movw	r26, r10
    1024:	6d 91       	ld	r22, X+
    1026:	7c 91       	ld	r23, X
    1028:	c2 01       	movw	r24, r4
    102a:	0e 94 2f 09 	call	0x125e	; 0x125e <_ZN7satmath20signed_saturated_addEii>
    102e:	ef 85       	ldd	r30, Y+15	; 0x0f
    1030:	f8 89       	ldd	r31, Y+16	; 0x10
    1032:	80 83       	st	Z, r24
    1034:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
    1036:	d6 01       	movw	r26, r12
    1038:	8d 93       	st	X+, r24
    103a:	9c 93       	st	X, r25
    103c:	11 97       	sbiw	r26, 0x01	; 1
		
		// Restrict to max/min
		if( output_correct > _max )
    103e:	eb 85       	ldd	r30, Y+11	; 0x0b
    1040:	fc 85       	ldd	r31, Y+12	; 0x0c
    1042:	20 81       	ld	r18, Z
    1044:	31 81       	ldd	r19, Z+1	; 0x01
    1046:	28 17       	cp	r18, r24
    1048:	39 07       	cpc	r19, r25
    104a:	1c f4       	brge	.+6      	; 0x1052 <_ZN5Motor3runEv+0x620>
		{
		output_correct = _max;
    104c:	2d 93       	st	X+, r18
    104e:	3c 93       	st	X, r19
    1050:	0a c0       	rjmp	.+20     	; 0x1066 <_ZN5Motor3runEv+0x634>
		}
		else if( output_correct < _min )
    1052:	ad 85       	ldd	r26, Y+13	; 0x0d
    1054:	be 85       	ldd	r27, Y+14	; 0x0e
    1056:	2d 91       	ld	r18, X+
    1058:	3c 91       	ld	r19, X
    105a:	82 17       	cp	r24, r18
    105c:	93 07       	cpc	r25, r19
    105e:	1c f4       	brge	.+6      	; 0x1066 <_ZN5Motor3runEv+0x634>
		{
		output_correct = _min;
    1060:	f6 01       	movw	r30, r12
    1062:	20 83       	st	Z, r18
    1064:	31 83       	std	Z+1, r19	; 0x01
		}

		// Save error to previous error
		_pre_error = error;
    1066:	f8 01       	movw	r30, r16
    1068:	e2 5b       	subi	r30, 0xB2	; 178
    106a:	ff 4f       	sbci	r31, 0xFF	; 255
    106c:	e0 82       	st	Z, r14
    106e:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
    1070:	d6 01       	movw	r26, r12
    1072:	2d 91       	ld	r18, X+
    1074:	3c 91       	ld	r19, X
    1076:	82 1b       	sub	r24, r18
    1078:	93 0b       	sbc	r25, r19
    107a:	74 96       	adiw	r30, 0x14	; 20
    107c:	80 83       	st	Z, r24
    107e:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
    1080:	e9 85       	ldd	r30, Y+9	; 0x09
    1082:	fa 85       	ldd	r31, Y+10	; 0x0a
    1084:	40 81       	ld	r20, Z
    1086:	51 81       	ldd	r21, Z+1	; 0x01
    1088:	84 9f       	mul	r24, r20
    108a:	90 01       	movw	r18, r0
    108c:	85 9f       	mul	r24, r21
    108e:	30 0d       	add	r19, r0
    1090:	94 9f       	mul	r25, r20
    1092:	30 0d       	add	r19, r0
    1094:	11 24       	eor	r1, r1
    1096:	33 23       	and	r19, r19
    1098:	14 f4       	brge	.+4      	; 0x109e <_ZN5Motor3runEv+0x66c>
    109a:	21 50       	subi	r18, 0x01	; 1
    109c:	3f 4f       	sbci	r19, 0xFF	; 255
    109e:	83 2f       	mov	r24, r19
    10a0:	88 0f       	add	r24, r24
    10a2:	88 0b       	sbc	r24, r24
    10a4:	d4 01       	movw	r26, r8
    10a6:	3c 93       	st	X, r19
    10a8:	11 96       	adiw	r26, 0x01	; 1
    10aa:	8c 93       	st	X, r24
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10ac:	0f b6       	in	r0, 0x3f	; 63
    10ae:	f8 94       	cli
    10b0:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10b2:	0f 90       	pop	r0
    10b4:	0f be       	out	0x3f, r0	; 63
				//*p_serial << "stop flag" << stop.get() << endl;
				//*p_serial << "reset flag " << reset.get() << endl;
				//*p_serial << position_midpoint << endl;
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get() || stop.get())		// If limit switch or If emergency stop button was hit
    10b6:	80 91 4d 31 	lds	r24, 0x314D	; 0x80314d <leftLimitSwitch>
    10ba:	81 11       	cpse	r24, r1
    10bc:	12 c0       	rjmp	.+36     	; 0x10e2 <_ZN5Motor3runEv+0x6b0>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10be:	0f b6       	in	r0, 0x3f	; 63
    10c0:	f8 94       	cli
    10c2:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10c4:	0f 90       	pop	r0
    10c6:	0f be       	out	0x3f, r0	; 63
    10c8:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rightLimitSwitch>
    10cc:	81 11       	cpse	r24, r1
    10ce:	09 c0       	rjmp	.+18     	; 0x10e2 <_ZN5Motor3runEv+0x6b0>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	f8 94       	cli
    10d4:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10d6:	0f 90       	pop	r0
    10d8:	0f be       	out	0x3f, r0	; 63
    10da:	80 91 47 31 	lds	r24, 0x3147	; 0x803147 <stop>
    10de:	88 23       	and	r24, r24
    10e0:	89 f0       	breq	.+34     	; 0x1104 <_ZN5Motor3runEv+0x6d2>
		{
			_integral = 0;														// prevent anti-wind up
    10e2:	f5 01       	movw	r30, r10
    10e4:	10 82       	st	Z, r1
    10e6:	11 82       	std	Z+1, r1	; 0x01
    10e8:	12 82       	std	Z+2, r1	; 0x02
    10ea:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;													// no PWM signal to motor
    10ec:	d6 01       	movw	r26, r12
    10ee:	1d 92       	st	X+, r1
    10f0:	1c 92       	st	X, r1
			
			if (state == 4 || state == 3)										// if in position or balance mode
    10f2:	f8 01       	movw	r30, r16
    10f4:	84 85       	ldd	r24, Z+12	; 0x0c
    10f6:	83 50       	subi	r24, 0x03	; 3
    10f8:	82 30       	cpi	r24, 0x02	; 2
    10fa:	20 f4       	brcc	.+8      	; 0x1104 <_ZN5Motor3runEv+0x6d2>
			{
				transition_to(100);												// transition to error state to make omegam_set=0
    10fc:	64 e6       	ldi	r22, 0x64	; 100
    10fe:	c8 01       	movw	r24, r16
    1100:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
    1104:	d8 01       	movw	r26, r16
    1106:	98 96       	adiw	r26, 0x28	; 40
    1108:	1d 92       	st	X+, r1
    110a:	1c 92       	st	X, r1
    110c:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
    110e:	92 96       	adiw	r26, 0x22	; 34
    1110:	8d 91       	ld	r24, X+
    1112:	9c 91       	ld	r25, X
    1114:	93 97       	sbiw	r26, 0x23	; 35
    1116:	60 e0       	ldi	r22, 0x00	; 0
    1118:	70 e0       	ldi	r23, 0x00	; 0
    111a:	0e 94 41 22 	call	0x4482	; 0x4482 <__divmodhi4>
    111e:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
    1120:	07 2e       	mov	r0, r23
    1122:	00 0c       	add	r0, r0
    1124:	88 0b       	sbc	r24, r24
    1126:	99 0b       	sbc	r25, r25
    1128:	0e 94 cd 21 	call	0x439a	; 0x439a <__floatsisf>
    112c:	2b 01       	movw	r4, r22
    112e:	3c 01       	movw	r6, r24
    1130:	23 e3       	ldi	r18, 0x33	; 51
    1132:	33 e3       	ldi	r19, 0x33	; 51
    1134:	4b e8       	ldi	r20, 0x8B	; 139
    1136:	51 e4       	ldi	r21, 0x41	; 65
    1138:	0e 94 2c 22 	call	0x4458	; 0x4458 <__gesf2>
    113c:	18 16       	cp	r1, r24
    113e:	34 f4       	brge	.+12     	; 0x114c <_ZN5Motor3runEv+0x71a>
			Im_set = 17.4;
    1140:	81 e1       	ldi	r24, 0x11	; 17
    1142:	90 e0       	ldi	r25, 0x00	; 0
    1144:	f8 01       	movw	r30, r16
    1146:	84 a3       	std	Z+36, r24	; 0x24
    1148:	95 a3       	std	Z+37, r25	; 0x25
    114a:	15 c0       	rjmp	.+42     	; 0x1176 <_ZN5Motor3runEv+0x744>
		} else if(Im_set < -17.4) {
    114c:	23 e3       	ldi	r18, 0x33	; 51
    114e:	33 e3       	ldi	r19, 0x33	; 51
    1150:	4b e8       	ldi	r20, 0x8B	; 139
    1152:	51 ec       	ldi	r21, 0xC1	; 193
    1154:	c3 01       	movw	r24, r6
    1156:	b2 01       	movw	r22, r4
    1158:	0e 94 c6 21 	call	0x438c	; 0x438c <__cmpsf2>
    115c:	88 23       	and	r24, r24
    115e:	34 f0       	brlt	.+12     	; 0x116c <_ZN5Motor3runEv+0x73a>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
    1160:	d8 01       	movw	r26, r16
    1162:	94 96       	adiw	r26, 0x24	; 36
    1164:	ed 92       	st	X+, r14
    1166:	fc 92       	st	X, r15
    1168:	95 97       	sbiw	r26, 0x25	; 37
    116a:	05 c0       	rjmp	.+10     	; 0x1176 <_ZN5Motor3runEv+0x744>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
    116c:	8f ee       	ldi	r24, 0xEF	; 239
    116e:	9f ef       	ldi	r25, 0xFF	; 255
    1170:	f8 01       	movw	r30, r16
    1172:	84 a3       	std	Z+36, r24	; 0x24
    1174:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
    1176:	d8 01       	movw	r26, r16
    1178:	d6 96       	adiw	r26, 0x36	; 54
    117a:	1d 92       	st	X+, r1
    117c:	1c 92       	st	X, r1
    117e:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
    1180:	d2 96       	adiw	r26, 0x32	; 50
    1182:	1d 92       	st	X+, r1
    1184:	1c 92       	st	X, r1
    1186:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
    1188:	d4 96       	adiw	r26, 0x34	; 52
    118a:	1d 92       	st	X+, r1
    118c:	1c 92       	st	X, r1
    118e:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
    1190:	d0 96       	adiw	r26, 0x30	; 48
    1192:	8d 91       	ld	r24, X+
    1194:	9c 91       	ld	r25, X
    1196:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
    1198:	89 31       	cpi	r24, 0x19	; 25
    119a:	91 05       	cpc	r25, r1
    119c:	3c f0       	brlt	.+14     	; 0x11ac <_ZN5Motor3runEv+0x77a>
			V_m = 24;
    119e:	88 e1       	ldi	r24, 0x18	; 24
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	d8 96       	adiw	r26, 0x38	; 56
    11a4:	8d 93       	st	X+, r24
    11a6:	9c 93       	st	X, r25
    11a8:	d9 97       	sbiw	r26, 0x39	; 57
    11aa:	0f c0       	rjmp	.+30     	; 0x11ca <_ZN5Motor3runEv+0x798>
		} else if(V_m < -24) {
    11ac:	88 3e       	cpi	r24, 0xE8	; 232
    11ae:	bf ef       	ldi	r27, 0xFF	; 255
    11b0:	9b 07       	cpc	r25, r27
    11b2:	24 f0       	brlt	.+8      	; 0x11bc <_ZN5Motor3runEv+0x78a>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
    11b4:	f8 01       	movw	r30, r16
    11b6:	80 af       	std	Z+56, r24	; 0x38
    11b8:	91 af       	std	Z+57, r25	; 0x39
    11ba:	07 c0       	rjmp	.+14     	; 0x11ca <_ZN5Motor3runEv+0x798>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
    11bc:	88 ee       	ldi	r24, 0xE8	; 232
    11be:	9f ef       	ldi	r25, 0xFF	; 255
    11c0:	d8 01       	movw	r26, r16
    11c2:	d8 96       	adiw	r26, 0x38	; 56
    11c4:	8d 93       	st	X+, r24
    11c6:	9c 93       	st	X, r25
    11c8:	d9 97       	sbiw	r26, 0x39	; 57
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
    11ca:	f6 01       	movw	r30, r12
    11cc:	80 81       	ld	r24, Z
    11ce:	91 81       	ldd	r25, Z+1	; 0x01
    11d0:	99 23       	and	r25, r25
    11d2:	3c f0       	brlt	.+14     	; 0x11e2 <_ZN5Motor3runEv+0x7b0>
		{
			TCC0.CCA = output_correct;
    11d4:	e0 e0       	ldi	r30, 0x00	; 0
    11d6:	f8 e0       	ldi	r31, 0x08	; 8
    11d8:	80 a7       	std	Z+40, r24	; 0x28
    11da:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
    11dc:	12 a6       	std	Z+42, r1	; 0x2a
    11de:	13 a6       	std	Z+43, r1	; 0x2b
    11e0:	0c c0       	rjmp	.+24     	; 0x11fa <_ZN5Motor3runEv+0x7c8>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
    11e2:	e0 e0       	ldi	r30, 0x00	; 0
    11e4:	f8 e0       	ldi	r31, 0x08	; 8
    11e6:	10 a6       	std	Z+40, r1	; 0x28
    11e8:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
    11ea:	d6 01       	movw	r26, r12
    11ec:	8d 91       	ld	r24, X+
    11ee:	9c 91       	ld	r25, X
    11f0:	91 95       	neg	r25
    11f2:	81 95       	neg	r24
    11f4:	91 09       	sbc	r25, r1
    11f6:	82 a7       	std	Z+42, r24	; 0x2a
    11f8:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
    11fa:	ed 81       	ldd	r30, Y+5	; 0x05
    11fc:	fe 81       	ldd	r31, Y+6	; 0x06
    11fe:	20 81       	ld	r18, Z
    1200:	31 81       	ldd	r19, Z+1	; 0x01
    1202:	42 81       	ldd	r20, Z+2	; 0x02
    1204:	53 81       	ldd	r21, Z+3	; 0x03
    1206:	a8 ee       	ldi	r26, 0xE8	; 232
    1208:	b3 e0       	ldi	r27, 0x03	; 3
    120a:	0e 94 bd 22 	call	0x457a	; 0x457a <__muluhisi3>
    120e:	68 3e       	cpi	r22, 0xE8	; 232
    1210:	f3 e0       	ldi	r31, 0x03	; 3
    1212:	7f 07       	cpc	r23, r31
    1214:	81 05       	cpc	r24, r1
    1216:	91 05       	cpc	r25, r1
    1218:	48 f0       	brcs	.+18     	; 0x122c <_ZN5Motor3runEv+0x7fa>
    121a:	28 ee       	ldi	r18, 0xE8	; 232
    121c:	33 e0       	ldi	r19, 0x03	; 3
    121e:	40 e0       	ldi	r20, 0x00	; 0
    1220:	50 e0       	ldi	r21, 0x00	; 0
    1222:	0e 94 55 22 	call	0x44aa	; 0x44aa <__udivmodsi4>
    1226:	ba 01       	movw	r22, r20
    1228:	a9 01       	movw	r20, r18
    122a:	04 c0       	rjmp	.+8      	; 0x1234 <_ZN5Motor3runEv+0x802>
    122c:	41 e0       	ldi	r20, 0x01	; 1
    122e:	50 e0       	ldi	r21, 0x00	; 0
    1230:	60 e0       	ldi	r22, 0x00	; 0
    1232:	70 e0       	ldi	r23, 0x00	; 0
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
    1234:	ce 01       	movw	r24, r28
    1236:	01 96       	adiw	r24, 0x01	; 1
    1238:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vTaskDelayUntil>
    123c:	6e cc       	rjmp	.-1828   	; 0xb1a <_ZN5Motor3runEv+0xe8>

0000123e <_ZN5MotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
    123e:	0f 93       	push	r16
    1240:	1f 93       	push	r17
    1242:	cf 93       	push	r28
    1244:	df 93       	push	r29
    1246:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    1248:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <_ZN8frt_taskC1EPKchjP8emstream>
    124c:	8e e2       	ldi	r24, 0x2E	; 46
    124e:	90 e2       	ldi	r25, 0x20	; 32
    1250:	88 83       	st	Y, r24
    1252:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	1f 91       	pop	r17
    125a:	0f 91       	pop	r16
    125c:	08 95       	ret

0000125e <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
    125e:	9c 01       	movw	r18, r24
    1260:	93 2f       	mov	r25, r19
    1262:	99 1f       	adc	r25, r25
    1264:	99 27       	eor	r25, r25
    1266:	99 1f       	adc	r25, r25
    1268:	89 2f       	mov	r24, r25
    126a:	90 e0       	ldi	r25, 0x00	; 0
    126c:	81 50       	subi	r24, 0x01	; 1
    126e:	90 48       	sbci	r25, 0x80	; 128
    1270:	43 2f       	mov	r20, r19
    1272:	40 95       	com	r20
    1274:	44 1f       	adc	r20, r20
    1276:	44 27       	eor	r20, r20
    1278:	44 1f       	adc	r20, r20
    127a:	fc 01       	movw	r30, r24
    127c:	e2 1b       	sub	r30, r18
    127e:	f3 0b       	sbc	r31, r19
    1280:	51 e0       	ldi	r21, 0x01	; 1
    1282:	e6 17       	cp	r30, r22
    1284:	f7 07       	cpc	r31, r23
    1286:	0c f0       	brlt	.+2      	; 0x128a <_ZN7satmath20signed_saturated_addEii+0x2c>
    1288:	50 e0       	ldi	r21, 0x00	; 0
    128a:	45 17       	cp	r20, r21
    128c:	19 f0       	breq	.+6      	; 0x1294 <_ZN7satmath20signed_saturated_addEii+0x36>
    128e:	c9 01       	movw	r24, r18
    1290:	86 0f       	add	r24, r22
    1292:	97 1f       	adc	r25, r23
    1294:	08 95       	ret

00001296 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    1296:	81 15       	cp	r24, r1
    1298:	20 e8       	ldi	r18, 0x80	; 128
    129a:	92 07       	cpc	r25, r18
    129c:	21 f4       	brne	.+8      	; 0x12a6 <_ZN7satmath20signed_saturated_mulEii+0x10>
    129e:	61 15       	cp	r22, r1
    12a0:	20 e8       	ldi	r18, 0x80	; 128
    12a2:	72 07       	cpc	r23, r18
    12a4:	29 f0       	breq	.+10     	; 0x12b0 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
    12a6:	9c 01       	movw	r18, r24
    12a8:	db 01       	movw	r26, r22
    12aa:	0e 94 9f 22 	call	0x453e	; 0x453e <__mulhisi3>
    12ae:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    12b0:	6f ef       	ldi	r22, 0xFF	; 255
    12b2:	7f ef       	ldi	r23, 0xFF	; 255
    12b4:	8f ef       	ldi	r24, 0xFF	; 255
    12b6:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
    12b8:	08 95       	ret

000012ba <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    12ba:	0f 93       	push	r16
    12bc:	1f 93       	push	r17
    12be:	cf 93       	push	r28
    12c0:	df 93       	push	r29
    12c2:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    12c4:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <_ZN8frt_taskC1EPKchjP8emstream>
    12c8:	86 e3       	ldi	r24, 0x36	; 54
    12ca:	90 e2       	ldi	r25, 0x20	; 32
    12cc:	88 83       	st	Y, r24
    12ce:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	08 95       	ret

000012da <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    12da:	0f 93       	push	r16
    12dc:	1f 93       	push	r17
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
    12e2:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    12e4:	6a e0       	ldi	r22, 0x0A	; 10
    12e6:	8e 81       	ldd	r24, Y+6	; 0x06
    12e8:	9f 81       	ldd	r25, Y+7	; 0x07
    12ea:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    12ee:	8c 01       	movw	r16, r24
    12f0:	63 e5       	ldi	r22, 0x53	; 83
    12f2:	75 e0       	ldi	r23, 0x05	; 5
    12f4:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    12f8:	6a e0       	ldi	r22, 0x0A	; 10
    12fa:	c8 01       	movw	r24, r16
    12fc:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1300:	8c 01       	movw	r16, r24
    1302:	6d e4       	ldi	r22, 0x4D	; 77
    1304:	75 e0       	ldi	r23, 0x05	; 5
    1306:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    130a:	67 e0       	ldi	r22, 0x07	; 7
    130c:	c8 01       	movw	r24, r16
    130e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    1312:	6a e0       	ldi	r22, 0x0A	; 10
    1314:	8e 81       	ldd	r24, Y+6	; 0x06
    1316:	9f 81       	ldd	r25, Y+7	; 0x07
    1318:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    131c:	8c 01       	movw	r16, r24
    131e:	6e e2       	ldi	r22, 0x2E	; 46
    1320:	75 e0       	ldi	r23, 0x05	; 5
    1322:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1326:	6a e0       	ldi	r22, 0x0A	; 10
    1328:	c8 01       	movw	r24, r16
    132a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    132e:	8c 01       	movw	r16, r24
    1330:	68 e2       	ldi	r22, 0x28	; 40
    1332:	75 e0       	ldi	r23, 0x05	; 5
    1334:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1338:	66 e0       	ldi	r22, 0x06	; 6
    133a:	c8 01       	movw	r24, r16
    133c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1340:	6a e0       	ldi	r22, 0x0A	; 10
    1342:	8e 81       	ldd	r24, Y+6	; 0x06
    1344:	9f 81       	ldd	r25, Y+7	; 0x07
    1346:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    134a:	8c 01       	movw	r16, r24
    134c:	61 e1       	ldi	r22, 0x11	; 17
    134e:	75 e0       	ldi	r23, 0x05	; 5
    1350:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1354:	66 e0       	ldi	r22, 0x06	; 6
    1356:	c8 01       	movw	r24, r16
    1358:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    135c:	6a e0       	ldi	r22, 0x0A	; 10
    135e:	8e 81       	ldd	r24, Y+6	; 0x06
    1360:	9f 81       	ldd	r25, Y+7	; 0x07
    1362:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1366:	8c 01       	movw	r16, r24
    1368:	65 ef       	ldi	r22, 0xF5	; 245
    136a:	74 e0       	ldi	r23, 0x04	; 4
    136c:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1370:	66 e0       	ldi	r22, 0x06	; 6
    1372:	c8 01       	movw	r24, r16
    1374:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1378:	6a e0       	ldi	r22, 0x0A	; 10
    137a:	8e 81       	ldd	r24, Y+6	; 0x06
    137c:	9f 81       	ldd	r25, Y+7	; 0x07
    137e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1382:	8c 01       	movw	r16, r24
    1384:	6d ed       	ldi	r22, 0xDD	; 221
    1386:	74 e0       	ldi	r23, 0x04	; 4
    1388:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    138c:	66 e0       	ldi	r22, 0x06	; 6
    138e:	c8 01       	movw	r24, r16
    1390:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1394:	6a e0       	ldi	r22, 0x0A	; 10
    1396:	8e 81       	ldd	r24, Y+6	; 0x06
    1398:	9f 81       	ldd	r25, Y+7	; 0x07
    139a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    139e:	8c 01       	movw	r16, r24
    13a0:	6c eb       	ldi	r22, 0xBC	; 188
    13a2:	74 e0       	ldi	r23, 0x04	; 4
    13a4:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    13a8:	66 e0       	ldi	r22, 0x06	; 6
    13aa:	c8 01       	movw	r24, r16
    13ac:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    13b0:	6a e0       	ldi	r22, 0x0A	; 10
    13b2:	8e 81       	ldd	r24, Y+6	; 0x06
    13b4:	9f 81       	ldd	r25, Y+7	; 0x07
    13b6:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    13ba:	8c 01       	movw	r16, r24
    13bc:	65 e9       	ldi	r22, 0x95	; 149
    13be:	74 e0       	ldi	r23, 0x04	; 4
    13c0:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    13c4:	66 e0       	ldi	r22, 0x06	; 6
    13c6:	c8 01       	movw	r24, r16
    13c8:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    13cc:	6a e0       	ldi	r22, 0x0A	; 10
    13ce:	8e 81       	ldd	r24, Y+6	; 0x06
    13d0:	9f 81       	ldd	r25, Y+7	; 0x07
    13d2:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    13d6:	8c 01       	movw	r16, r24
    13d8:	67 e7       	ldi	r22, 0x77	; 119
    13da:	74 e0       	ldi	r23, 0x04	; 4
    13dc:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    13e0:	66 e0       	ldi	r22, 0x06	; 6
    13e2:	c8 01       	movw	r24, r16
    13e4:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    13e8:	6a e0       	ldi	r22, 0x0A	; 10
    13ea:	8e 81       	ldd	r24, Y+6	; 0x06
    13ec:	9f 81       	ldd	r25, Y+7	; 0x07
    13ee:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    13f2:	8c 01       	movw	r16, r24
    13f4:	6c e5       	ldi	r22, 0x5C	; 92
    13f6:	74 e0       	ldi	r23, 0x04	; 4
    13f8:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    13fc:	66 e0       	ldi	r22, 0x06	; 6
    13fe:	c8 01       	movw	r24, r16
    1400:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    1404:	6a e0       	ldi	r22, 0x0A	; 10
    1406:	8e 81       	ldd	r24, Y+6	; 0x06
    1408:	9f 81       	ldd	r25, Y+7	; 0x07
    140a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    140e:	8c 01       	movw	r16, r24
    1410:	6d e4       	ldi	r22, 0x4D	; 77
    1412:	74 e0       	ldi	r23, 0x04	; 4
    1414:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1418:	66 e0       	ldi	r22, 0x06	; 6
    141a:	c8 01       	movw	r24, r16
    141c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    b:   Begin Calibration of Inverted Pendulum?") << endl;
    1420:	6a e0       	ldi	r22, 0x0A	; 10
    1422:	8e 81       	ldd	r24, Y+6	; 0x06
    1424:	9f 81       	ldd	r25, Y+7	; 0x07
    1426:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    142a:	8c 01       	movw	r16, r24
    142c:	6c e1       	ldi	r22, 0x1C	; 28
    142e:	74 e0       	ldi	r23, 0x04	; 4
    1430:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1434:	66 e0       	ldi	r22, 0x06	; 6
    1436:	c8 01       	movw	r24, r16
    1438:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    g:   Swing Pendulum Upright, then Go.") << endl;
    143c:	6a e0       	ldi	r22, 0x0A	; 10
    143e:	8e 81       	ldd	r24, Y+6	; 0x06
    1440:	9f 81       	ldd	r25, Y+7	; 0x07
    1442:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1446:	8c 01       	movw	r16, r24
    1448:	62 ef       	ldi	r22, 0xF2	; 242
    144a:	73 e0       	ldi	r23, 0x03	; 3
    144c:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1450:	66 e0       	ldi	r22, 0x06	; 6
    1452:	c8 01       	movw	r24, r16
    1454:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    d:   Emergency Stop") << endl;
    1458:	6a e0       	ldi	r22, 0x0A	; 10
    145a:	8e 81       	ldd	r24, Y+6	; 0x06
    145c:	9f 81       	ldd	r25, Y+7	; 0x07
    145e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1462:	8c 01       	movw	r16, r24
    1464:	6a ed       	ldi	r22, 0xDA	; 218
    1466:	73 e0       	ldi	r23, 0x03	; 3
    1468:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    146c:	66 e0       	ldi	r22, 0x06	; 6
    146e:	c8 01       	movw	r24, r16
    1470:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    r:   Reset to Idle") << endl;
    1474:	6a e0       	ldi	r22, 0x0A	; 10
    1476:	8e 81       	ldd	r24, Y+6	; 0x06
    1478:	9f 81       	ldd	r25, Y+7	; 0x07
    147a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    147e:	ec 01       	movw	r28, r24
    1480:	63 ec       	ldi	r22, 0xC3	; 195
    1482:	73 e0       	ldi	r23, 0x03	; 3
    1484:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1488:	66 e0       	ldi	r22, 0x06	; 6
    148a:	ce 01       	movw	r24, r28
    148c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
}
    1490:	df 91       	pop	r29
    1492:	cf 91       	pop	r28
    1494:	1f 91       	pop	r17
    1496:	0f 91       	pop	r16
    1498:	08 95       	ret

0000149a <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    149a:	af 92       	push	r10
    149c:	bf 92       	push	r11
    149e:	cf 92       	push	r12
    14a0:	df 92       	push	r13
    14a2:	ef 92       	push	r14
    14a4:	ff 92       	push	r15
    14a6:	0f 93       	push	r16
    14a8:	1f 93       	push	r17
    14aa:	cf 93       	push	r28
    14ac:	df 93       	push	r29
    14ae:	00 d0       	rcall	.+0      	; 0x14b0 <_ZN9task_user11show_statusEv+0x16>
    14b0:	00 d0       	rcall	.+0      	; 0x14b2 <_ZN9task_user11show_statusEv+0x18>
    14b2:	cd b7       	in	r28, 0x3d	; 61
    14b4:	de b7       	in	r29, 0x3e	; 62
    14b6:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    14b8:	19 82       	std	Y+1, r1	; 0x01
    14ba:	1a 82       	std	Y+2, r1	; 0x02
    14bc:	1b 82       	std	Y+3, r1	; 0x03
    14be:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    14c0:	1d 82       	std	Y+5, r1	; 0x05
    14c2:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    14c4:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <xPortGetFreeHeapSize>
    14c8:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    14ca:	ce 01       	movw	r24, r28
    14cc:	01 96       	adiw	r24, 0x01	; 1
    14ce:	0e 94 64 1b 	call	0x36c8	; 0x36c8 <_ZN10time_stamp10set_to_nowEv>
    14d2:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    14d4:	66 e0       	ldi	r22, 0x06	; 6
    14d6:	f8 01       	movw	r30, r16
    14d8:	86 81       	ldd	r24, Z+6	; 0x06
    14da:	97 81       	ldd	r25, Z+7	; 0x07
    14dc:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    14e0:	6a e0       	ldi	r22, 0x0A	; 10
    14e2:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    14e6:	7c 01       	movw	r14, r24
    14e8:	64 ea       	ldi	r22, 0xA4	; 164
    14ea:	73 e0       	ldi	r23, 0x03	; 3
    14ec:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    14f0:	6a e0       	ldi	r22, 0x0A	; 10
    14f2:	c7 01       	movw	r24, r14
    14f4:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    14f8:	7c 01       	movw	r14, r24
    14fa:	68 e9       	ldi	r22, 0x98	; 152
    14fc:	73 e0       	ldi	r23, 0x03	; 3
    14fe:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1502:	66 e0       	ldi	r22, 0x06	; 6
    1504:	c7 01       	movw	r24, r14
    1506:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    150a:	6a e0       	ldi	r22, 0x0A	; 10
    150c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1510:	7c 01       	movw	r14, r24
    1512:	61 e9       	ldi	r22, 0x91	; 145
    1514:	73 e0       	ldi	r23, 0x03	; 3
    1516:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    151a:	b5 01       	movw	r22, r10
    151c:	c7 01       	movw	r24, r14
    151e:	0e 94 08 1b 	call	0x3610	; 0x3610 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1522:	6a e0       	ldi	r22, 0x0A	; 10
    1524:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1528:	7c 01       	movw	r14, r24
    152a:	63 e8       	ldi	r22, 0x83	; 131
    152c:	73 e0       	ldi	r23, 0x03	; 3
    152e:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1532:	b6 01       	movw	r22, r12
    1534:	c7 01       	movw	r24, r14
    1536:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <_ZN8emstreamlsEj>
    153a:	6a e0       	ldi	r22, 0x0A	; 10
    153c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1540:	7c 01       	movw	r14, r24
    1542:	61 e8       	ldi	r22, 0x81	; 129
    1544:	73 e0       	ldi	r23, 0x03	; 3
    1546:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    154a:	4f ef       	ldi	r20, 0xFF	; 255
    154c:	5f e0       	ldi	r21, 0x0F	; 15
    154e:	60 e0       	ldi	r22, 0x00	; 0
    1550:	70 e0       	ldi	r23, 0x00	; 0
    1552:	c7 01       	movw	r24, r14
    1554:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1558:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    155c:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1560:	6a e0       	ldi	r22, 0x0A	; 10
    1562:	f8 01       	movw	r30, r16
    1564:	86 81       	ldd	r24, Z+6	; 0x06
    1566:	97 81       	ldd	r25, Z+7	; 0x07
    1568:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    156c:	7c 01       	movw	r14, r24
    156e:	66 e7       	ldi	r22, 0x76	; 118
    1570:	73 e0       	ldi	r23, 0x03	; 3
    1572:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1576:	b6 01       	movw	r22, r12
    1578:	c7 01       	movw	r24, r14
    157a:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <_ZN8emstreamlsEj>
    157e:	66 e0       	ldi	r22, 0x06	; 6
    1580:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1584:	66 e0       	ldi	r22, 0x06	; 6
    1586:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    158a:	f8 01       	movw	r30, r16
    158c:	86 81       	ldd	r24, Z+6	; 0x06
    158e:	97 81       	ldd	r25, Z+7	; 0x07
    1590:	0e 94 c1 19 	call	0x3382	; 0x3382 <_Z15print_task_listP8emstream>
}
    1594:	26 96       	adiw	r28, 0x06	; 6
    1596:	cd bf       	out	0x3d, r28	; 61
    1598:	de bf       	out	0x3e, r29	; 62
    159a:	df 91       	pop	r29
    159c:	cf 91       	pop	r28
    159e:	1f 91       	pop	r17
    15a0:	0f 91       	pop	r16
    15a2:	ff 90       	pop	r15
    15a4:	ef 90       	pop	r14
    15a6:	df 90       	pop	r13
    15a8:	cf 90       	pop	r12
    15aa:	bf 90       	pop	r11
    15ac:	af 90       	pop	r10
    15ae:	08 95       	ret

000015b0 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    15b0:	cf 93       	push	r28
    15b2:	df 93       	push	r29
    15b4:	00 d0       	rcall	.+0      	; 0x15b6 <_ZN9task_user3runEv+0x6>
    15b6:	00 d0       	rcall	.+0      	; 0x15b8 <_ZN9task_user3runEv+0x8>
    15b8:	cd b7       	in	r28, 0x3d	; 61
    15ba:	de b7       	in	r29, 0x3e	; 62
    15bc:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    15be:	19 82       	std	Y+1, r1	; 0x01
    15c0:	1a 82       	std	Y+2, r1	; 0x02
    15c2:	1b 82       	std	Y+3, r1	; 0x03
    15c4:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    15c6:	1d 82       	std	Y+5, r1	; 0x05
    15c8:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;
    15ca:	6a e0       	ldi	r22, 0x0A	; 10
    15cc:	dc 01       	movw	r26, r24
    15ce:	16 96       	adiw	r26, 0x06	; 6
    15d0:	8d 91       	ld	r24, X+
    15d2:	9c 91       	ld	r25, X
    15d4:	17 97       	sbiw	r26, 0x07	; 7
    15d6:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    15da:	7c 01       	movw	r14, r24
    15dc:	61 ef       	ldi	r22, 0xF1	; 241
    15de:	75 e0       	ldi	r23, 0x05	; 5
    15e0:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    15e4:	66 e0       	ldi	r22, 0x06	; 6
    15e6:	c7 01       	movw	r24, r14
    15e8:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    15ec:	f8 01       	movw	r30, r16
    15ee:	84 85       	ldd	r24, Z+12	; 0x0c
    15f0:	88 23       	and	r24, r24
    15f2:	21 f0       	breq	.+8      	; 0x15fc <_ZN9task_user3runEv+0x4c>
    15f4:	81 30       	cpi	r24, 0x01	; 1
    15f6:	09 f4       	brne	.+2      	; 0x15fa <_ZN9task_user3runEv+0x4a>
    15f8:	5d c0       	rjmp	.+186    	; 0x16b4 <_ZN9task_user3runEv+0x104>
    15fa:	32 c1       	rjmp	.+612    	; 0x1860 <_ZN9task_user3runEv+0x2b0>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    15fc:	86 81       	ldd	r24, Z+6	; 0x06
    15fe:	97 81       	ldd	r25, Z+7	; 0x07
    1600:	dc 01       	movw	r26, r24
    1602:	ed 91       	ld	r30, X+
    1604:	fc 91       	ld	r31, X
    1606:	04 80       	ldd	r0, Z+4	; 0x04
    1608:	f5 81       	ldd	r31, Z+5	; 0x05
    160a:	e0 2d       	mov	r30, r0
    160c:	19 95       	eicall
    160e:	88 23       	and	r24, r24
    1610:	a9 f1       	breq	.+106    	; 0x167c <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1612:	f8 01       	movw	r30, r16
    1614:	86 81       	ldd	r24, Z+6	; 0x06
    1616:	97 81       	ldd	r25, Z+7	; 0x07
    1618:	dc 01       	movw	r26, r24
    161a:	ed 91       	ld	r30, X+
    161c:	fc 91       	ld	r31, X
    161e:	06 80       	ldd	r0, Z+6	; 0x06
    1620:	f7 81       	ldd	r31, Z+7	; 0x07
    1622:	e0 2d       	mov	r30, r0
    1624:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1626:	99 27       	eor	r25, r25
    1628:	81 30       	cpi	r24, 0x01	; 1
    162a:	91 05       	cpc	r25, r1
    162c:	f9 f0       	breq	.+62     	; 0x166c <_ZN9task_user3runEv+0xbc>
    162e:	03 97       	sbiw	r24, 0x03	; 3
    1630:	09 f0       	breq	.+2      	; 0x1634 <_ZN9task_user3runEv+0x84>
    1632:	31 c1       	rjmp	.+610    	; 0x1896 <_ZN9task_user3runEv+0x2e6>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1634:	6a e0       	ldi	r22, 0x0A	; 10
    1636:	f8 01       	movw	r30, r16
    1638:	86 81       	ldd	r24, Z+6	; 0x06
    163a:	97 81       	ldd	r25, Z+7	; 0x07
    163c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1640:	8c 01       	movw	r16, r24
    1642:	63 ee       	ldi	r22, 0xE3	; 227
    1644:	75 e0       	ldi	r23, 0x05	; 5
    1646:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    164a:	66 e0       	ldi	r22, 0x06	; 6
    164c:	c8 01       	movw	r24, r16
    164e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1652:	93 e0       	ldi	r25, 0x03	; 3
    1654:	88 ed       	ldi	r24, 0xD8	; 216
    1656:	08 b6       	in	r0, 0x38	; 56
    1658:	18 be       	out	0x38, r1	; 56
    165a:	84 bf       	out	0x34, r24	; 52
    165c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1660:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1664:	81 fd       	sbrc	r24, 1
    1666:	fc cf       	rjmp	.-8      	; 0x1660 <_ZN9task_user3runEv+0xb0>
    1668:	08 be       	out	0x38, r0	; 56
    166a:	ff cf       	rjmp	.-2      	; 0x166a <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    166c:	c8 01       	movw	r24, r16
    166e:	0e 94 6d 09 	call	0x12da	; 0x12da <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1672:	61 e0       	ldi	r22, 0x01	; 1
    1674:	c8 01       	movw	r24, r16
    1676:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
							break;
    167a:	0d c1       	rjmp	.+538    	; 0x1896 <_ZN9task_user3runEv+0x2e6>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    167c:	84 e5       	ldi	r24, 0x54	; 84
    167e:	91 e3       	ldi	r25, 0x31	; 49
    1680:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <_ZN14frt_text_queue14check_for_charEv>
    1684:	88 23       	and	r24, r24
    1686:	09 f4       	brne	.+2      	; 0x168a <_ZN9task_user3runEv+0xda>
    1688:	06 c1       	rjmp	.+524    	; 0x1896 <_ZN9task_user3runEv+0x2e6>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    168a:	d8 01       	movw	r26, r16
    168c:	16 96       	adiw	r26, 0x06	; 6
    168e:	ed 91       	ld	r30, X+
    1690:	fc 91       	ld	r31, X
    1692:	17 97       	sbiw	r26, 0x07	; 7
    1694:	01 90       	ld	r0, Z+
    1696:	f0 81       	ld	r31, Z
    1698:	e0 2d       	mov	r30, r0
    169a:	e2 80       	ldd	r14, Z+2	; 0x02
    169c:	f3 80       	ldd	r15, Z+3	; 0x03
    169e:	84 e5       	ldi	r24, 0x54	; 84
    16a0:	91 e3       	ldi	r25, 0x31	; 49
    16a2:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <_ZN14frt_text_queue7getcharEv>
    16a6:	68 2f       	mov	r22, r24
    16a8:	f8 01       	movw	r30, r16
    16aa:	86 81       	ldd	r24, Z+6	; 0x06
    16ac:	97 81       	ldd	r25, Z+7	; 0x07
    16ae:	f7 01       	movw	r30, r14
    16b0:	19 95       	eicall
    16b2:	f1 c0       	rjmp	.+482    	; 0x1896 <_ZN9task_user3runEv+0x2e6>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    16b4:	86 81       	ldd	r24, Z+6	; 0x06
    16b6:	97 81       	ldd	r25, Z+7	; 0x07
    16b8:	dc 01       	movw	r26, r24
    16ba:	ed 91       	ld	r30, X+
    16bc:	fc 91       	ld	r31, X
    16be:	04 80       	ldd	r0, Z+4	; 0x04
    16c0:	f5 81       	ldd	r31, Z+5	; 0x05
    16c2:	e0 2d       	mov	r30, r0
    16c4:	19 95       	eicall
    16c6:	88 23       	and	r24, r24
    16c8:	09 f4       	brne	.+2      	; 0x16cc <_ZN9task_user3runEv+0x11c>
    16ca:	e5 c0       	rjmp	.+458    	; 0x1896 <_ZN9task_user3runEv+0x2e6>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    16cc:	f8 01       	movw	r30, r16
    16ce:	86 81       	ldd	r24, Z+6	; 0x06
    16d0:	97 81       	ldd	r25, Z+7	; 0x07
    16d2:	dc 01       	movw	r26, r24
    16d4:	ed 91       	ld	r30, X+
    16d6:	fc 91       	ld	r31, X
    16d8:	06 80       	ldd	r0, Z+6	; 0x06
    16da:	f7 81       	ldd	r31, Z+7	; 0x07
    16dc:	e0 2d       	mov	r30, r0
    16de:	19 95       	eicall
    16e0:	bc 01       	movw	r22, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    16e2:	fc 01       	movw	r30, r24
    16e4:	ff 27       	eor	r31, r31
    16e6:	7b 97       	sbiw	r30, 0x1b	; 27
    16e8:	ec 35       	cpi	r30, 0x5C	; 92
    16ea:	f1 05       	cpc	r31, r1
    16ec:	08 f0       	brcs	.+2      	; 0x16f0 <_ZN9task_user3runEv+0x140>
    16ee:	9c c0       	rjmp	.+312    	; 0x1828 <_ZN9task_user3runEv+0x278>
    16f0:	88 27       	eor	r24, r24
    16f2:	e2 50       	subi	r30, 0x02	; 2
    16f4:	ff 4f       	sbci	r31, 0xFF	; 255
    16f6:	8f 4f       	sbci	r24, 0xFF	; 255
    16f8:	0c 94 96 22 	jmp	0x452c	; 0x452c <__tablejump2__>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    16fc:	ce 01       	movw	r24, r28
    16fe:	01 96       	adiw	r24, 0x01	; 1
    1700:	0e 94 64 1b 	call	0x36c8	; 0x36c8 <_ZN10time_stamp10set_to_nowEv>
    1704:	bc 01       	movw	r22, r24
    1706:	f8 01       	movw	r30, r16
    1708:	86 81       	ldd	r24, Z+6	; 0x06
    170a:	97 81       	ldd	r25, Z+7	; 0x07
    170c:	0e 94 08 1b 	call	0x3610	; 0x3610 <_ZlsR8emstreamR10time_stamp>
    1710:	66 e0       	ldi	r22, 0x06	; 6
    1712:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1716:	bf c0       	rjmp	.+382    	; 0x1896 <_ZN9task_user3runEv+0x2e6>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1718:	c8 01       	movw	r24, r16
    171a:	0e 94 4d 0a 	call	0x149a	; 0x149a <_ZN9task_user11show_statusEv>
							break;
    171e:	bb c0       	rjmp	.+374    	; 0x1896 <_ZN9task_user3runEv+0x2e6>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1720:	d8 01       	movw	r26, r16
    1722:	16 96       	adiw	r26, 0x06	; 6
    1724:	8d 91       	ld	r24, X+
    1726:	9c 91       	ld	r25, X
    1728:	17 97       	sbiw	r26, 0x07	; 7
    172a:	0e 94 c8 18 	call	0x3190	; 0x3190 <_Z17print_task_stacksP8emstream>
							break;
    172e:	b3 c0       	rjmp	.+358    	; 0x1896 <_ZN9task_user3runEv+0x2e6>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1730:	c8 01       	movw	r24, r16
    1732:	0e 94 6d 09 	call	0x12da	; 0x12da <_ZN9task_user18print_help_messageEv>
							break;
    1736:	af c0       	rjmp	.+350    	; 0x1896 <_ZN9task_user3runEv+0x2e6>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1738:	6a e0       	ldi	r22, 0x0A	; 10
    173a:	f8 01       	movw	r30, r16
    173c:	86 81       	ldd	r24, Z+6	; 0x06
    173e:	97 81       	ldd	r25, Z+7	; 0x07
    1740:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1744:	7c 01       	movw	r14, r24
    1746:	61 ed       	ldi	r22, 0xD1	; 209
    1748:	75 e0       	ldi	r23, 0x05	; 5
    174a:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    174e:	66 e0       	ldi	r22, 0x06	; 6
    1750:	c7 01       	movw	r24, r14
    1752:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0); 
    1756:	60 e0       	ldi	r22, 0x00	; 0
    1758:	c8 01       	movw	r24, r16
    175a:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <_ZN8frt_task13transition_toEh>
							break;
    175e:	9b c0       	rjmp	.+310    	; 0x1896 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	0f 92       	push	r0
			the_data = new_data;
    1766:	81 e0       	ldi	r24, 0x01	; 1
    1768:	80 93 49 31 	sts	0x3149, r24	; 0x803149 <begin>
			portEXIT_CRITICAL ();
    176c:	0f 90       	pop	r0
    176e:	0f be       	out	0x3f, r0	; 63
							
						case ('b'):
							begin.put(true);
							*p_serial << PMS ("Begin Homing") << endl;
    1770:	6a e0       	ldi	r22, 0x0A	; 10
    1772:	d8 01       	movw	r26, r16
    1774:	16 96       	adiw	r26, 0x06	; 6
    1776:	8d 91       	ld	r24, X+
    1778:	9c 91       	ld	r25, X
    177a:	17 97       	sbiw	r26, 0x07	; 7
    177c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1780:	7c 01       	movw	r14, r24
    1782:	64 ec       	ldi	r22, 0xC4	; 196
    1784:	75 e0       	ldi	r23, 0x05	; 5
    1786:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    178a:	66 e0       	ldi	r22, 0x06	; 6
    178c:	c7 01       	movw	r24, r14
    178e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1792:	81 c0       	rjmp	.+258    	; 0x1896 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	0f 92       	push	r0
			the_data = new_data;
    179a:	81 e0       	ldi	r24, 0x01	; 1
    179c:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <go>
			portEXIT_CRITICAL ();
    17a0:	0f 90       	pop	r0
    17a2:	0f be       	out	0x3f, r0	; 63
						
						case ('g'):
							go.put(true);
							*p_serial << PMS ("Commence Balance") << endl;
    17a4:	6a e0       	ldi	r22, 0x0A	; 10
    17a6:	f8 01       	movw	r30, r16
    17a8:	86 81       	ldd	r24, Z+6	; 0x06
    17aa:	97 81       	ldd	r25, Z+7	; 0x07
    17ac:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    17b0:	7c 01       	movw	r14, r24
    17b2:	63 eb       	ldi	r22, 0xB3	; 179
    17b4:	75 e0       	ldi	r23, 0x05	; 5
    17b6:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    17ba:	66 e0       	ldi	r22, 0x06	; 6
    17bc:	c7 01       	movw	r24, r14
    17be:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
							break;
    17c2:	69 c0       	rjmp	.+210    	; 0x1896 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	0f 92       	push	r0
			the_data = new_data;
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	80 93 47 31 	sts	0x3147, r24	; 0x803147 <stop>
			portEXIT_CRITICAL ();
    17d0:	0f 90       	pop	r0
    17d2:	0f be       	out	0x3f, r0	; 63
						
						case('d'):
							stop.put(true);
							*p_serial << PMS ("EMERGENCY STOP") << endl;
    17d4:	6a e0       	ldi	r22, 0x0A	; 10
    17d6:	d8 01       	movw	r26, r16
    17d8:	16 96       	adiw	r26, 0x06	; 6
    17da:	8d 91       	ld	r24, X+
    17dc:	9c 91       	ld	r25, X
    17de:	17 97       	sbiw	r26, 0x07	; 7
    17e0:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    17e4:	7c 01       	movw	r14, r24
    17e6:	64 ea       	ldi	r22, 0xA4	; 164
    17e8:	75 e0       	ldi	r23, 0x05	; 5
    17ea:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    17ee:	66 e0       	ldi	r22, 0x06	; 6
    17f0:	c7 01       	movw	r24, r14
    17f2:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
							break;
    17f6:	4f c0       	rjmp	.+158    	; 0x1896 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    17f8:	0f b6       	in	r0, 0x3f	; 63
    17fa:	f8 94       	cli
    17fc:	0f 92       	push	r0
			the_data = new_data;
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <reset>
			portEXIT_CRITICAL ();
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63
						
						case('r'):
							reset.put(true);
							*p_serial << PMS ("Reset, try Homing again by pressing 'b'") << endl;
    1808:	6a e0       	ldi	r22, 0x0A	; 10
    180a:	f8 01       	movw	r30, r16
    180c:	86 81       	ldd	r24, Z+6	; 0x06
    180e:	97 81       	ldd	r25, Z+7	; 0x07
    1810:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    1814:	7c 01       	movw	r14, r24
    1816:	6c e7       	ldi	r22, 0x7C	; 124
    1818:	75 e0       	ldi	r23, 0x05	; 5
    181a:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    181e:	66 e0       	ldi	r22, 0x06	; 6
    1820:	c7 01       	movw	r24, r14
    1822:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1826:	37 c0       	rjmp	.+110    	; 0x1896 <_ZN9task_user3runEv+0x2e6>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1828:	d8 01       	movw	r26, r16
    182a:	16 96       	adiw	r26, 0x06	; 6
    182c:	8d 91       	ld	r24, X+
    182e:	9c 91       	ld	r25, X
    1830:	17 97       	sbiw	r26, 0x07	; 7
    1832:	dc 01       	movw	r26, r24
    1834:	ed 91       	ld	r30, X+
    1836:	fc 91       	ld	r31, X
    1838:	02 80       	ldd	r0, Z+2	; 0x02
    183a:	f3 81       	ldd	r31, Z+3	; 0x03
    183c:	e0 2d       	mov	r30, r0
    183e:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1840:	6a e0       	ldi	r22, 0x0A	; 10
    1842:	f8 01       	movw	r30, r16
    1844:	86 81       	ldd	r24, Z+6	; 0x06
    1846:	97 81       	ldd	r25, Z+7	; 0x07
    1848:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    184c:	7c 01       	movw	r14, r24
    184e:	66 e7       	ldi	r22, 0x76	; 118
    1850:	75 e0       	ldi	r23, 0x05	; 5
    1852:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1856:	66 e0       	ldi	r22, 0x06	; 6
    1858:	c7 01       	movw	r24, r14
    185a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
							break;
    185e:	1b c0       	rjmp	.+54     	; 0x1896 <_ZN9task_user3runEv+0x2e6>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1860:	6a e0       	ldi	r22, 0x0A	; 10
    1862:	86 81       	ldd	r24, Z+6	; 0x06
    1864:	97 81       	ldd	r25, Z+7	; 0x07
    1866:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    186a:	8c 01       	movw	r16, r24
    186c:	69 e5       	ldi	r22, 0x59	; 89
    186e:	75 e0       	ldi	r23, 0x05	; 5
    1870:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    1874:	66 e0       	ldi	r22, 0x06	; 6
    1876:	c8 01       	movw	r24, r16
    1878:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    187c:	93 e0       	ldi	r25, 0x03	; 3
    187e:	88 ed       	ldi	r24, 0xD8	; 216
    1880:	08 b6       	in	r0, 0x38	; 56
    1882:	18 be       	out	0x38, r1	; 56
    1884:	84 bf       	out	0x34, r24	; 52
    1886:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    188a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    188e:	81 fd       	sbrc	r24, 1
    1890:	fc cf       	rjmp	.-8      	; 0x188a <_ZN9task_user3runEv+0x2da>
    1892:	08 be       	out	0x38, r0	; 56
    1894:	ff cf       	rjmp	.-2      	; 0x1894 <_ZN9task_user3runEv+0x2e4>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1896:	f8 01       	movw	r30, r16
    1898:	86 85       	ldd	r24, Z+14	; 0x0e
    189a:	97 85       	ldd	r25, Z+15	; 0x0f
    189c:	a0 89       	ldd	r26, Z+16	; 0x10
    189e:	b1 89       	ldd	r27, Z+17	; 0x11
    18a0:	01 96       	adiw	r24, 0x01	; 1
    18a2:	a1 1d       	adc	r26, r1
    18a4:	b1 1d       	adc	r27, r1
    18a6:	86 87       	std	Z+14, r24	; 0x0e
    18a8:	97 87       	std	Z+15, r25	; 0x0f
    18aa:	a0 8b       	std	Z+16, r26	; 0x10
    18ac:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    18ae:	61 e0       	ldi	r22, 0x01	; 1
    18b0:	70 e0       	ldi	r23, 0x00	; 0
    18b2:	80 e0       	ldi	r24, 0x00	; 0
    18b4:	90 e0       	ldi	r25, 0x00	; 0
    18b6:	0e 94 83 15 	call	0x2b06	; 0x2b06 <vTaskDelay>
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;

	
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    18ba:	98 ce       	rjmp	.-720    	; 0x15ec <_ZN9task_user3runEv+0x3c>

000018bc <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    18bc:	0f 93       	push	r16
    18be:	1f 93       	push	r17
    18c0:	cf 93       	push	r28
    18c2:	df 93       	push	r29
    18c4:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    18c6:	0e 94 72 13 	call	0x26e4	; 0x26e4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    18ca:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    18ce:	81 11       	cpse	r24, r1
    18d0:	1d c0       	rjmp	.+58     	; 0x190c <pvPortMalloc+0x50>
		{
			prvHeapInit();
    18d2:	a1 ec       	ldi	r26, 0xC1	; 193
    18d4:	b0 e2       	ldi	r27, 0x20	; 32
    18d6:	e5 ec       	ldi	r30, 0xC5	; 197
    18d8:	f0 e2       	ldi	r31, 0x20	; 32
    18da:	ed 93       	st	X+, r30
    18dc:	fc 93       	st	X, r31
    18de:	11 97       	sbiw	r26, 0x01	; 1
    18e0:	12 96       	adiw	r26, 0x02	; 2
    18e2:	1d 92       	st	X+, r1
    18e4:	1c 92       	st	X, r1
    18e6:	13 97       	sbiw	r26, 0x03	; 3
    18e8:	ad eb       	ldi	r26, 0xBD	; 189
    18ea:	b0 e2       	ldi	r27, 0x20	; 32
    18ec:	8f ef       	ldi	r24, 0xFF	; 255
    18ee:	9f e0       	ldi	r25, 0x0F	; 15
    18f0:	12 96       	adiw	r26, 0x02	; 2
    18f2:	8d 93       	st	X+, r24
    18f4:	9c 93       	st	X, r25
    18f6:	13 97       	sbiw	r26, 0x03	; 3
    18f8:	1d 92       	st	X+, r1
    18fa:	1c 92       	st	X, r1
    18fc:	11 97       	sbiw	r26, 0x01	; 1
    18fe:	82 83       	std	Z+2, r24	; 0x02
    1900:	93 83       	std	Z+3, r25	; 0x03
    1902:	a0 83       	st	Z, r26
    1904:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1906:	81 e0       	ldi	r24, 0x01	; 1
    1908:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    190c:	20 97       	sbiw	r28, 0x00	; 0
    190e:	09 f4       	brne	.+2      	; 0x1912 <pvPortMalloc+0x56>
    1910:	5f c0       	rjmp	.+190    	; 0x19d0 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1912:	9e 01       	movw	r18, r28
    1914:	2b 5f       	subi	r18, 0xFB	; 251
    1916:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1918:	24 96       	adiw	r28, 0x04	; 4
    191a:	ce 3f       	cpi	r28, 0xFE	; 254
    191c:	df 40       	sbci	r29, 0x0F	; 15
    191e:	08 f0       	brcs	.+2      	; 0x1922 <pvPortMalloc+0x66>
    1920:	5a c0       	rjmp	.+180    	; 0x19d6 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1922:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    1926:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    192a:	a1 ec       	ldi	r26, 0xC1	; 193
    192c:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    192e:	02 c0       	rjmp	.+4      	; 0x1934 <pvPortMalloc+0x78>
    1930:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1932:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1934:	82 81       	ldd	r24, Z+2	; 0x02
    1936:	93 81       	ldd	r25, Z+3	; 0x03
    1938:	82 17       	cp	r24, r18
    193a:	93 07       	cpc	r25, r19
    193c:	20 f4       	brcc	.+8      	; 0x1946 <pvPortMalloc+0x8a>
    193e:	80 81       	ld	r24, Z
    1940:	91 81       	ldd	r25, Z+1	; 0x01
    1942:	00 97       	sbiw	r24, 0x00	; 0
    1944:	a9 f7       	brne	.-22     	; 0x1930 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1946:	c0 e2       	ldi	r28, 0x20	; 32
    1948:	ed 3b       	cpi	r30, 0xBD	; 189
    194a:	fc 07       	cpc	r31, r28
    194c:	09 f4       	brne	.+2      	; 0x1950 <pvPortMalloc+0x94>
    194e:	46 c0       	rjmp	.+140    	; 0x19dc <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1950:	cd 91       	ld	r28, X+
    1952:	dc 91       	ld	r29, X
    1954:	11 97       	sbiw	r26, 0x01	; 1
    1956:	8e 01       	movw	r16, r28
    1958:	0b 5f       	subi	r16, 0xFB	; 251
    195a:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    195c:	80 81       	ld	r24, Z
    195e:	91 81       	ldd	r25, Z+1	; 0x01
    1960:	8d 93       	st	X+, r24
    1962:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1964:	82 81       	ldd	r24, Z+2	; 0x02
    1966:	93 81       	ldd	r25, Z+3	; 0x03
    1968:	82 1b       	sub	r24, r18
    196a:	93 0b       	sbc	r25, r19
    196c:	8b 30       	cpi	r24, 0x0B	; 11
    196e:	91 05       	cpc	r25, r1
    1970:	10 f1       	brcs	.+68     	; 0x19b6 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1972:	bf 01       	movw	r22, r30
    1974:	62 0f       	add	r22, r18
    1976:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1978:	db 01       	movw	r26, r22
    197a:	12 96       	adiw	r26, 0x02	; 2
    197c:	8d 93       	st	X+, r24
    197e:	9c 93       	st	X, r25
    1980:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1982:	22 83       	std	Z+2, r18	; 0x02
    1984:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1986:	12 96       	adiw	r26, 0x02	; 2
    1988:	4d 91       	ld	r20, X+
    198a:	5c 91       	ld	r21, X
    198c:	13 97       	sbiw	r26, 0x03	; 3
    198e:	81 ec       	ldi	r24, 0xC1	; 193
    1990:	90 e2       	ldi	r25, 0x20	; 32
    1992:	01 c0       	rjmp	.+2      	; 0x1996 <pvPortMalloc+0xda>
    1994:	cd 01       	movw	r24, r26
    1996:	ec 01       	movw	r28, r24
    1998:	a8 81       	ld	r26, Y
    199a:	b9 81       	ldd	r27, Y+1	; 0x01
    199c:	12 96       	adiw	r26, 0x02	; 2
    199e:	2d 91       	ld	r18, X+
    19a0:	3c 91       	ld	r19, X
    19a2:	13 97       	sbiw	r26, 0x03	; 3
    19a4:	24 17       	cp	r18, r20
    19a6:	35 07       	cpc	r19, r21
    19a8:	a8 f3       	brcs	.-22     	; 0x1994 <pvPortMalloc+0xd8>
    19aa:	eb 01       	movw	r28, r22
    19ac:	a8 83       	st	Y, r26
    19ae:	b9 83       	std	Y+1, r27	; 0x01
    19b0:	dc 01       	movw	r26, r24
    19b2:	6d 93       	st	X+, r22
    19b4:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    19b6:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    19ba:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    19be:	22 81       	ldd	r18, Z+2	; 0x02
    19c0:	33 81       	ldd	r19, Z+3	; 0x03
    19c2:	82 1b       	sub	r24, r18
    19c4:	93 0b       	sbc	r25, r19
    19c6:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    19ca:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    19ce:	08 c0       	rjmp	.+16     	; 0x19e0 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    19d0:	00 e0       	ldi	r16, 0x00	; 0
    19d2:	10 e0       	ldi	r17, 0x00	; 0
    19d4:	05 c0       	rjmp	.+10     	; 0x19e0 <pvPortMalloc+0x124>
    19d6:	00 e0       	ldi	r16, 0x00	; 0
    19d8:	10 e0       	ldi	r17, 0x00	; 0
    19da:	02 c0       	rjmp	.+4      	; 0x19e0 <pvPortMalloc+0x124>
    19dc:	00 e0       	ldi	r16, 0x00	; 0
    19de:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    19e0:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    19e4:	c8 01       	movw	r24, r16
    19e6:	df 91       	pop	r29
    19e8:	cf 91       	pop	r28
    19ea:	1f 91       	pop	r17
    19ec:	0f 91       	pop	r16
    19ee:	08 95       	ret

000019f0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    19f0:	0f 93       	push	r16
    19f2:	1f 93       	push	r17
    19f4:	cf 93       	push	r28
    19f6:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    19f8:	00 97       	sbiw	r24, 0x00	; 0
    19fa:	41 f1       	breq	.+80     	; 0x1a4c <vPortFree+0x5c>
    19fc:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    19fe:	8c 01       	movw	r16, r24
    1a00:	05 50       	subi	r16, 0x05	; 5
    1a02:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1a04:	0e 94 72 13 	call	0x26e4	; 0x26e4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1a08:	f8 01       	movw	r30, r16
    1a0a:	42 81       	ldd	r20, Z+2	; 0x02
    1a0c:	53 81       	ldd	r21, Z+3	; 0x03
    1a0e:	a1 ec       	ldi	r26, 0xC1	; 193
    1a10:	b0 e2       	ldi	r27, 0x20	; 32
    1a12:	01 c0       	rjmp	.+2      	; 0x1a16 <vPortFree+0x26>
    1a14:	df 01       	movw	r26, r30
    1a16:	ed 91       	ld	r30, X+
    1a18:	fc 91       	ld	r31, X
    1a1a:	11 97       	sbiw	r26, 0x01	; 1
    1a1c:	22 81       	ldd	r18, Z+2	; 0x02
    1a1e:	33 81       	ldd	r19, Z+3	; 0x03
    1a20:	24 17       	cp	r18, r20
    1a22:	35 07       	cpc	r19, r21
    1a24:	b8 f3       	brcs	.-18     	; 0x1a14 <vPortFree+0x24>
    1a26:	25 97       	sbiw	r28, 0x05	; 5
    1a28:	e8 83       	st	Y, r30
    1a2a:	f9 83       	std	Y+1, r31	; 0x01
    1a2c:	0d 93       	st	X+, r16
    1a2e:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1a30:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1a34:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1a38:	8a 81       	ldd	r24, Y+2	; 0x02
    1a3a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a3c:	82 0f       	add	r24, r18
    1a3e:	93 1f       	adc	r25, r19
    1a40:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1a44:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1a48:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
	}
}
    1a4c:	df 91       	pop	r29
    1a4e:	cf 91       	pop	r28
    1a50:	1f 91       	pop	r17
    1a52:	0f 91       	pop	r16
    1a54:	08 95       	ret

00001a56 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1a56:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1a5a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1a5e:	08 95       	ret

00001a60 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1a60:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1a62:	03 96       	adiw	r24, 0x03	; 3
    1a64:	81 83       	std	Z+1, r24	; 0x01
    1a66:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1a68:	4f ef       	ldi	r20, 0xFF	; 255
    1a6a:	5f ef       	ldi	r21, 0xFF	; 255
    1a6c:	ba 01       	movw	r22, r20
    1a6e:	43 83       	std	Z+3, r20	; 0x03
    1a70:	54 83       	std	Z+4, r21	; 0x04
    1a72:	65 83       	std	Z+5, r22	; 0x05
    1a74:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1a76:	87 83       	std	Z+7, r24	; 0x07
    1a78:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1a7a:	81 87       	std	Z+9, r24	; 0x09
    1a7c:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1a7e:	10 82       	st	Z, r1
    1a80:	08 95       	ret

00001a82 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1a82:	fc 01       	movw	r30, r24
    1a84:	12 86       	std	Z+10, r1	; 0x0a
    1a86:	13 86       	std	Z+11, r1	; 0x0b
    1a88:	08 95       	ret

00001a8a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1a8a:	cf 93       	push	r28
    1a8c:	df 93       	push	r29
    1a8e:	fc 01       	movw	r30, r24
    1a90:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1a92:	21 81       	ldd	r18, Z+1	; 0x01
    1a94:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1a96:	e9 01       	movw	r28, r18
    1a98:	8c 81       	ldd	r24, Y+4	; 0x04
    1a9a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a9c:	14 96       	adiw	r26, 0x04	; 4
    1a9e:	8d 93       	st	X+, r24
    1aa0:	9c 93       	st	X, r25
    1aa2:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1aa4:	81 81       	ldd	r24, Z+1	; 0x01
    1aa6:	92 81       	ldd	r25, Z+2	; 0x02
    1aa8:	16 96       	adiw	r26, 0x06	; 6
    1aaa:	8d 93       	st	X+, r24
    1aac:	9c 93       	st	X, r25
    1aae:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1ab0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ab2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ab4:	ec 01       	movw	r28, r24
    1ab6:	6e 83       	std	Y+6, r22	; 0x06
    1ab8:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1aba:	e9 01       	movw	r28, r18
    1abc:	6c 83       	std	Y+4, r22	; 0x04
    1abe:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1ac0:	61 83       	std	Z+1, r22	; 0x01
    1ac2:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ac4:	1a 96       	adiw	r26, 0x0a	; 10
    1ac6:	ed 93       	st	X+, r30
    1ac8:	fc 93       	st	X, r31
    1aca:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1acc:	80 81       	ld	r24, Z
    1ace:	8f 5f       	subi	r24, 0xFF	; 255
    1ad0:	80 83       	st	Z, r24
}
    1ad2:	df 91       	pop	r29
    1ad4:	cf 91       	pop	r28
    1ad6:	08 95       	ret

00001ad8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1ad8:	0f 93       	push	r16
    1ada:	1f 93       	push	r17
    1adc:	cf 93       	push	r28
    1ade:	df 93       	push	r29
    1ae0:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1ae2:	08 81       	ld	r16, Y
    1ae4:	19 81       	ldd	r17, Y+1	; 0x01
    1ae6:	2a 81       	ldd	r18, Y+2	; 0x02
    1ae8:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1aea:	0f 3f       	cpi	r16, 0xFF	; 255
    1aec:	4f ef       	ldi	r20, 0xFF	; 255
    1aee:	14 07       	cpc	r17, r20
    1af0:	24 07       	cpc	r18, r20
    1af2:	34 07       	cpc	r19, r20
    1af4:	31 f4       	brne	.+12     	; 0x1b02 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1af6:	dc 01       	movw	r26, r24
    1af8:	19 96       	adiw	r26, 0x09	; 9
    1afa:	ed 91       	ld	r30, X+
    1afc:	fc 91       	ld	r31, X
    1afe:	1a 97       	sbiw	r26, 0x0a	; 10
    1b00:	1f c0       	rjmp	.+62     	; 0x1b40 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1b02:	fc 01       	movw	r30, r24
    1b04:	33 96       	adiw	r30, 0x03	; 3
    1b06:	dc 01       	movw	r26, r24
    1b08:	17 96       	adiw	r26, 0x07	; 7
    1b0a:	4d 91       	ld	r20, X+
    1b0c:	5c 91       	ld	r21, X
    1b0e:	18 97       	sbiw	r26, 0x08	; 8
    1b10:	da 01       	movw	r26, r20
    1b12:	4d 91       	ld	r20, X+
    1b14:	5d 91       	ld	r21, X+
    1b16:	6d 91       	ld	r22, X+
    1b18:	7c 91       	ld	r23, X
    1b1a:	04 17       	cp	r16, r20
    1b1c:	15 07       	cpc	r17, r21
    1b1e:	26 07       	cpc	r18, r22
    1b20:	37 07       	cpc	r19, r23
    1b22:	70 f0       	brcs	.+28     	; 0x1b40 <vListInsert+0x68>
    1b24:	04 80       	ldd	r0, Z+4	; 0x04
    1b26:	f5 81       	ldd	r31, Z+5	; 0x05
    1b28:	e0 2d       	mov	r30, r0
    1b2a:	a4 81       	ldd	r26, Z+4	; 0x04
    1b2c:	b5 81       	ldd	r27, Z+5	; 0x05
    1b2e:	4d 91       	ld	r20, X+
    1b30:	5d 91       	ld	r21, X+
    1b32:	6d 91       	ld	r22, X+
    1b34:	7c 91       	ld	r23, X
    1b36:	04 17       	cp	r16, r20
    1b38:	15 07       	cpc	r17, r21
    1b3a:	26 07       	cpc	r18, r22
    1b3c:	37 07       	cpc	r19, r23
    1b3e:	90 f7       	brcc	.-28     	; 0x1b24 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1b40:	a4 81       	ldd	r26, Z+4	; 0x04
    1b42:	b5 81       	ldd	r27, Z+5	; 0x05
    1b44:	ac 83       	std	Y+4, r26	; 0x04
    1b46:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1b48:	16 96       	adiw	r26, 0x06	; 6
    1b4a:	cd 93       	st	X+, r28
    1b4c:	dc 93       	st	X, r29
    1b4e:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1b50:	ee 83       	std	Y+6, r30	; 0x06
    1b52:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1b54:	c4 83       	std	Z+4, r28	; 0x04
    1b56:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b58:	8a 87       	std	Y+10, r24	; 0x0a
    1b5a:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1b5c:	fc 01       	movw	r30, r24
    1b5e:	20 81       	ld	r18, Z
    1b60:	2f 5f       	subi	r18, 0xFF	; 255
    1b62:	20 83       	st	Z, r18
}
    1b64:	df 91       	pop	r29
    1b66:	cf 91       	pop	r28
    1b68:	1f 91       	pop	r17
    1b6a:	0f 91       	pop	r16
    1b6c:	08 95       	ret

00001b6e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1b6e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1b70:	a4 81       	ldd	r26, Z+4	; 0x04
    1b72:	b5 81       	ldd	r27, Z+5	; 0x05
    1b74:	86 81       	ldd	r24, Z+6	; 0x06
    1b76:	97 81       	ldd	r25, Z+7	; 0x07
    1b78:	16 96       	adiw	r26, 0x06	; 6
    1b7a:	8d 93       	st	X+, r24
    1b7c:	9c 93       	st	X, r25
    1b7e:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1b80:	a6 81       	ldd	r26, Z+6	; 0x06
    1b82:	b7 81       	ldd	r27, Z+7	; 0x07
    1b84:	84 81       	ldd	r24, Z+4	; 0x04
    1b86:	95 81       	ldd	r25, Z+5	; 0x05
    1b88:	14 96       	adiw	r26, 0x04	; 4
    1b8a:	8d 93       	st	X+, r24
    1b8c:	9c 93       	st	X, r25
    1b8e:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1b90:	a2 85       	ldd	r26, Z+10	; 0x0a
    1b92:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1b94:	11 96       	adiw	r26, 0x01	; 1
    1b96:	8d 91       	ld	r24, X+
    1b98:	9c 91       	ld	r25, X
    1b9a:	12 97       	sbiw	r26, 0x02	; 2
    1b9c:	e8 17       	cp	r30, r24
    1b9e:	f9 07       	cpc	r31, r25
    1ba0:	31 f4       	brne	.+12     	; 0x1bae <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1ba2:	86 81       	ldd	r24, Z+6	; 0x06
    1ba4:	97 81       	ldd	r25, Z+7	; 0x07
    1ba6:	11 96       	adiw	r26, 0x01	; 1
    1ba8:	8d 93       	st	X+, r24
    1baa:	9c 93       	st	X, r25
    1bac:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1bae:	12 86       	std	Z+10, r1	; 0x0a
    1bb0:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1bb2:	8c 91       	ld	r24, X
    1bb4:	81 50       	subi	r24, 0x01	; 1
    1bb6:	8c 93       	st	X, r24
    1bb8:	08 95       	ret

00001bba <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1bba:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <portStackTopForTask>
    1bbe:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <portStackTopForTask+0x1>
    1bc2:	31 e1       	ldi	r19, 0x11	; 17
    1bc4:	fc 01       	movw	r30, r24
    1bc6:	30 83       	st	Z, r19
    1bc8:	31 97       	sbiw	r30, 0x01	; 1
    1bca:	22 e2       	ldi	r18, 0x22	; 34
    1bcc:	20 83       	st	Z, r18
    1bce:	31 97       	sbiw	r30, 0x01	; 1
    1bd0:	a3 e3       	ldi	r26, 0x33	; 51
    1bd2:	a0 83       	st	Z, r26
    1bd4:	31 97       	sbiw	r30, 0x01	; 1
    1bd6:	60 83       	st	Z, r22
    1bd8:	31 97       	sbiw	r30, 0x01	; 1
    1bda:	70 83       	st	Z, r23
    1bdc:	31 97       	sbiw	r30, 0x01	; 1
    1bde:	10 82       	st	Z, r1
    1be0:	31 97       	sbiw	r30, 0x01	; 1
    1be2:	10 82       	st	Z, r1
    1be4:	31 97       	sbiw	r30, 0x01	; 1
    1be6:	60 e8       	ldi	r22, 0x80	; 128
    1be8:	60 83       	st	Z, r22
    1bea:	31 97       	sbiw	r30, 0x01	; 1
    1bec:	10 82       	st	Z, r1
    1bee:	31 97       	sbiw	r30, 0x01	; 1
    1bf0:	10 82       	st	Z, r1
    1bf2:	31 97       	sbiw	r30, 0x01	; 1
    1bf4:	10 82       	st	Z, r1
    1bf6:	31 97       	sbiw	r30, 0x01	; 1
    1bf8:	62 e0       	ldi	r22, 0x02	; 2
    1bfa:	60 83       	st	Z, r22
    1bfc:	31 97       	sbiw	r30, 0x01	; 1
    1bfe:	63 e0       	ldi	r22, 0x03	; 3
    1c00:	60 83       	st	Z, r22
    1c02:	31 97       	sbiw	r30, 0x01	; 1
    1c04:	64 e0       	ldi	r22, 0x04	; 4
    1c06:	60 83       	st	Z, r22
    1c08:	31 97       	sbiw	r30, 0x01	; 1
    1c0a:	65 e0       	ldi	r22, 0x05	; 5
    1c0c:	60 83       	st	Z, r22
    1c0e:	31 97       	sbiw	r30, 0x01	; 1
    1c10:	66 e0       	ldi	r22, 0x06	; 6
    1c12:	60 83       	st	Z, r22
    1c14:	31 97       	sbiw	r30, 0x01	; 1
    1c16:	67 e0       	ldi	r22, 0x07	; 7
    1c18:	60 83       	st	Z, r22
    1c1a:	31 97       	sbiw	r30, 0x01	; 1
    1c1c:	68 e0       	ldi	r22, 0x08	; 8
    1c1e:	60 83       	st	Z, r22
    1c20:	31 97       	sbiw	r30, 0x01	; 1
    1c22:	69 e0       	ldi	r22, 0x09	; 9
    1c24:	60 83       	st	Z, r22
    1c26:	31 97       	sbiw	r30, 0x01	; 1
    1c28:	60 e1       	ldi	r22, 0x10	; 16
    1c2a:	60 83       	st	Z, r22
    1c2c:	31 97       	sbiw	r30, 0x01	; 1
    1c2e:	30 83       	st	Z, r19
    1c30:	31 97       	sbiw	r30, 0x01	; 1
    1c32:	32 e1       	ldi	r19, 0x12	; 18
    1c34:	30 83       	st	Z, r19
    1c36:	31 97       	sbiw	r30, 0x01	; 1
    1c38:	33 e1       	ldi	r19, 0x13	; 19
    1c3a:	30 83       	st	Z, r19
    1c3c:	31 97       	sbiw	r30, 0x01	; 1
    1c3e:	34 e1       	ldi	r19, 0x14	; 20
    1c40:	30 83       	st	Z, r19
    1c42:	31 97       	sbiw	r30, 0x01	; 1
    1c44:	35 e1       	ldi	r19, 0x15	; 21
    1c46:	30 83       	st	Z, r19
    1c48:	31 97       	sbiw	r30, 0x01	; 1
    1c4a:	36 e1       	ldi	r19, 0x16	; 22
    1c4c:	30 83       	st	Z, r19
    1c4e:	31 97       	sbiw	r30, 0x01	; 1
    1c50:	37 e1       	ldi	r19, 0x17	; 23
    1c52:	30 83       	st	Z, r19
    1c54:	31 97       	sbiw	r30, 0x01	; 1
    1c56:	38 e1       	ldi	r19, 0x18	; 24
    1c58:	30 83       	st	Z, r19
    1c5a:	31 97       	sbiw	r30, 0x01	; 1
    1c5c:	39 e1       	ldi	r19, 0x19	; 25
    1c5e:	30 83       	st	Z, r19
    1c60:	31 97       	sbiw	r30, 0x01	; 1
    1c62:	30 e2       	ldi	r19, 0x20	; 32
    1c64:	30 83       	st	Z, r19
    1c66:	31 97       	sbiw	r30, 0x01	; 1
    1c68:	31 e2       	ldi	r19, 0x21	; 33
    1c6a:	30 83       	st	Z, r19
    1c6c:	31 97       	sbiw	r30, 0x01	; 1
    1c6e:	20 83       	st	Z, r18
    1c70:	31 97       	sbiw	r30, 0x01	; 1
    1c72:	23 e2       	ldi	r18, 0x23	; 35
    1c74:	20 83       	st	Z, r18
    1c76:	31 97       	sbiw	r30, 0x01	; 1
    1c78:	40 83       	st	Z, r20
    1c7a:	31 97       	sbiw	r30, 0x01	; 1
    1c7c:	50 83       	st	Z, r21
    1c7e:	31 97       	sbiw	r30, 0x01	; 1
    1c80:	26 e2       	ldi	r18, 0x26	; 38
    1c82:	20 83       	st	Z, r18
    1c84:	31 97       	sbiw	r30, 0x01	; 1
    1c86:	27 e2       	ldi	r18, 0x27	; 39
    1c88:	20 83       	st	Z, r18
    1c8a:	31 97       	sbiw	r30, 0x01	; 1
    1c8c:	28 e2       	ldi	r18, 0x28	; 40
    1c8e:	20 83       	st	Z, r18
    1c90:	31 97       	sbiw	r30, 0x01	; 1
    1c92:	29 e2       	ldi	r18, 0x29	; 41
    1c94:	20 83       	st	Z, r18
    1c96:	31 97       	sbiw	r30, 0x01	; 1
    1c98:	20 e3       	ldi	r18, 0x30	; 48
    1c9a:	20 83       	st	Z, r18
    1c9c:	31 97       	sbiw	r30, 0x01	; 1
    1c9e:	21 e3       	ldi	r18, 0x31	; 49
    1ca0:	20 83       	st	Z, r18
    1ca2:	89 97       	sbiw	r24, 0x29	; 41
    1ca4:	08 95       	ret

00001ca6 <xPortStartScheduler>:
    1ca6:	8c e7       	ldi	r24, 0x7C	; 124
    1ca8:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1cac:	8f ef       	ldi	r24, 0xFF	; 255
    1cae:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1cb2:	81 e0       	ldi	r24, 0x01	; 1
    1cb4:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1cb8:	91 e1       	ldi	r25, 0x11	; 17
    1cba:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1cbe:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1cc2:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1cc6:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1cca:	cd 91       	ld	r28, X+
    1ccc:	cd bf       	out	0x3d, r28	; 61
    1cce:	dd 91       	ld	r29, X+
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	ff 91       	pop	r31
    1cd4:	ef 91       	pop	r30
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	bf 91       	pop	r27
    1cdc:	af 91       	pop	r26
    1cde:	9f 91       	pop	r25
    1ce0:	8f 91       	pop	r24
    1ce2:	7f 91       	pop	r23
    1ce4:	6f 91       	pop	r22
    1ce6:	5f 91       	pop	r21
    1ce8:	4f 91       	pop	r20
    1cea:	3f 91       	pop	r19
    1cec:	2f 91       	pop	r18
    1cee:	1f 91       	pop	r17
    1cf0:	0f 91       	pop	r16
    1cf2:	ff 90       	pop	r15
    1cf4:	ef 90       	pop	r14
    1cf6:	df 90       	pop	r13
    1cf8:	cf 90       	pop	r12
    1cfa:	bf 90       	pop	r11
    1cfc:	af 90       	pop	r10
    1cfe:	9f 90       	pop	r9
    1d00:	8f 90       	pop	r8
    1d02:	7f 90       	pop	r7
    1d04:	6f 90       	pop	r6
    1d06:	5f 90       	pop	r5
    1d08:	4f 90       	pop	r4
    1d0a:	3f 90       	pop	r3
    1d0c:	2f 90       	pop	r2
    1d0e:	1f 90       	pop	r1
    1d10:	0f 90       	pop	r0
    1d12:	0c be       	out	0x3c, r0	; 60
    1d14:	0f 90       	pop	r0
    1d16:	0b be       	out	0x3b, r0	; 59
    1d18:	0f 90       	pop	r0
    1d1a:	0f be       	out	0x3f, r0	; 63
    1d1c:	0f 90       	pop	r0
    1d1e:	08 95       	ret
    1d20:	08 95       	ret

00001d22 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d22:	0f 92       	push	r0
    1d24:	0f b6       	in	r0, 0x3f	; 63
    1d26:	f8 94       	cli
    1d28:	0f 92       	push	r0
    1d2a:	0b b6       	in	r0, 0x3b	; 59
    1d2c:	0f 92       	push	r0
    1d2e:	0c b6       	in	r0, 0x3c	; 60
    1d30:	0f 92       	push	r0
    1d32:	1f 92       	push	r1
    1d34:	11 24       	eor	r1, r1
    1d36:	2f 92       	push	r2
    1d38:	3f 92       	push	r3
    1d3a:	4f 92       	push	r4
    1d3c:	5f 92       	push	r5
    1d3e:	6f 92       	push	r6
    1d40:	7f 92       	push	r7
    1d42:	8f 92       	push	r8
    1d44:	9f 92       	push	r9
    1d46:	af 92       	push	r10
    1d48:	bf 92       	push	r11
    1d4a:	cf 92       	push	r12
    1d4c:	df 92       	push	r13
    1d4e:	ef 92       	push	r14
    1d50:	ff 92       	push	r15
    1d52:	0f 93       	push	r16
    1d54:	1f 93       	push	r17
    1d56:	2f 93       	push	r18
    1d58:	3f 93       	push	r19
    1d5a:	4f 93       	push	r20
    1d5c:	5f 93       	push	r21
    1d5e:	6f 93       	push	r22
    1d60:	7f 93       	push	r23
    1d62:	8f 93       	push	r24
    1d64:	9f 93       	push	r25
    1d66:	af 93       	push	r26
    1d68:	bf 93       	push	r27
    1d6a:	cf 93       	push	r28
    1d6c:	df 93       	push	r29
    1d6e:	ef 93       	push	r30
    1d70:	ff 93       	push	r31
    1d72:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1d76:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1d7a:	0d b6       	in	r0, 0x3d	; 61
    1d7c:	0d 92       	st	X+, r0
    1d7e:	0e b6       	in	r0, 0x3e	; 62
    1d80:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1d82:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1d86:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1d8a:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1d8e:	cd 91       	ld	r28, X+
    1d90:	cd bf       	out	0x3d, r28	; 61
    1d92:	dd 91       	ld	r29, X+
    1d94:	de bf       	out	0x3e, r29	; 62
    1d96:	ff 91       	pop	r31
    1d98:	ef 91       	pop	r30
    1d9a:	df 91       	pop	r29
    1d9c:	cf 91       	pop	r28
    1d9e:	bf 91       	pop	r27
    1da0:	af 91       	pop	r26
    1da2:	9f 91       	pop	r25
    1da4:	8f 91       	pop	r24
    1da6:	7f 91       	pop	r23
    1da8:	6f 91       	pop	r22
    1daa:	5f 91       	pop	r21
    1dac:	4f 91       	pop	r20
    1dae:	3f 91       	pop	r19
    1db0:	2f 91       	pop	r18
    1db2:	1f 91       	pop	r17
    1db4:	0f 91       	pop	r16
    1db6:	ff 90       	pop	r15
    1db8:	ef 90       	pop	r14
    1dba:	df 90       	pop	r13
    1dbc:	cf 90       	pop	r12
    1dbe:	bf 90       	pop	r11
    1dc0:	af 90       	pop	r10
    1dc2:	9f 90       	pop	r9
    1dc4:	8f 90       	pop	r8
    1dc6:	7f 90       	pop	r7
    1dc8:	6f 90       	pop	r6
    1dca:	5f 90       	pop	r5
    1dcc:	4f 90       	pop	r4
    1dce:	3f 90       	pop	r3
    1dd0:	2f 90       	pop	r2
    1dd2:	1f 90       	pop	r1
    1dd4:	0f 90       	pop	r0
    1dd6:	0c be       	out	0x3c, r0	; 60
    1dd8:	0f 90       	pop	r0
    1dda:	0b be       	out	0x3b, r0	; 59
    1ddc:	0f 90       	pop	r0
    1dde:	0f be       	out	0x3f, r0	; 63
    1de0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1de2:	08 95       	ret

00001de4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1de4:	0f 92       	push	r0
    1de6:	0f b6       	in	r0, 0x3f	; 63
    1de8:	f8 94       	cli
    1dea:	0f 92       	push	r0
    1dec:	0b b6       	in	r0, 0x3b	; 59
    1dee:	0f 92       	push	r0
    1df0:	0c b6       	in	r0, 0x3c	; 60
    1df2:	0f 92       	push	r0
    1df4:	1f 92       	push	r1
    1df6:	11 24       	eor	r1, r1
    1df8:	2f 92       	push	r2
    1dfa:	3f 92       	push	r3
    1dfc:	4f 92       	push	r4
    1dfe:	5f 92       	push	r5
    1e00:	6f 92       	push	r6
    1e02:	7f 92       	push	r7
    1e04:	8f 92       	push	r8
    1e06:	9f 92       	push	r9
    1e08:	af 92       	push	r10
    1e0a:	bf 92       	push	r11
    1e0c:	cf 92       	push	r12
    1e0e:	df 92       	push	r13
    1e10:	ef 92       	push	r14
    1e12:	ff 92       	push	r15
    1e14:	0f 93       	push	r16
    1e16:	1f 93       	push	r17
    1e18:	2f 93       	push	r18
    1e1a:	3f 93       	push	r19
    1e1c:	4f 93       	push	r20
    1e1e:	5f 93       	push	r21
    1e20:	6f 93       	push	r22
    1e22:	7f 93       	push	r23
    1e24:	8f 93       	push	r24
    1e26:	9f 93       	push	r25
    1e28:	af 93       	push	r26
    1e2a:	bf 93       	push	r27
    1e2c:	cf 93       	push	r28
    1e2e:	df 93       	push	r29
    1e30:	ef 93       	push	r30
    1e32:	ff 93       	push	r31
    1e34:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1e38:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1e3c:	0d b6       	in	r0, 0x3d	; 61
    1e3e:	0d 92       	st	X+, r0
    1e40:	0e b6       	in	r0, 0x3e	; 62
    1e42:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1e44:	0e 94 93 13 	call	0x2726	; 0x2726 <vTaskIncrementTick>
	vTaskSwitchContext();
    1e48:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e4c:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1e50:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1e54:	cd 91       	ld	r28, X+
    1e56:	cd bf       	out	0x3d, r28	; 61
    1e58:	dd 91       	ld	r29, X+
    1e5a:	de bf       	out	0x3e, r29	; 62
    1e5c:	ff 91       	pop	r31
    1e5e:	ef 91       	pop	r30
    1e60:	df 91       	pop	r29
    1e62:	cf 91       	pop	r28
    1e64:	bf 91       	pop	r27
    1e66:	af 91       	pop	r26
    1e68:	9f 91       	pop	r25
    1e6a:	8f 91       	pop	r24
    1e6c:	7f 91       	pop	r23
    1e6e:	6f 91       	pop	r22
    1e70:	5f 91       	pop	r21
    1e72:	4f 91       	pop	r20
    1e74:	3f 91       	pop	r19
    1e76:	2f 91       	pop	r18
    1e78:	1f 91       	pop	r17
    1e7a:	0f 91       	pop	r16
    1e7c:	ff 90       	pop	r15
    1e7e:	ef 90       	pop	r14
    1e80:	df 90       	pop	r13
    1e82:	cf 90       	pop	r12
    1e84:	bf 90       	pop	r11
    1e86:	af 90       	pop	r10
    1e88:	9f 90       	pop	r9
    1e8a:	8f 90       	pop	r8
    1e8c:	7f 90       	pop	r7
    1e8e:	6f 90       	pop	r6
    1e90:	5f 90       	pop	r5
    1e92:	4f 90       	pop	r4
    1e94:	3f 90       	pop	r3
    1e96:	2f 90       	pop	r2
    1e98:	1f 90       	pop	r1
    1e9a:	0f 90       	pop	r0
    1e9c:	0c be       	out	0x3c, r0	; 60
    1e9e:	0f 90       	pop	r0
    1ea0:	0b be       	out	0x3b, r0	; 59
    1ea2:	0f 90       	pop	r0
    1ea4:	0f be       	out	0x3f, r0	; 63
    1ea6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ea8:	08 95       	ret

00001eaa <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1eaa:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1eae:	18 95       	reti

00001eb0 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1eb0:	cf 93       	push	r28
    1eb2:	df 93       	push	r29
    1eb4:	ec 01       	movw	r28, r24
    1eb6:	88 a1       	ldd	r24, Y+32	; 0x20
    1eb8:	81 11       	cpse	r24, r1
    1eba:	0b c0       	rjmp	.+22     	; 0x1ed2 <prvCopyDataToQueue+0x22>
    1ebc:	88 81       	ld	r24, Y
    1ebe:	99 81       	ldd	r25, Y+1	; 0x01
    1ec0:	89 2b       	or	r24, r25
    1ec2:	e1 f5       	brne	.+120    	; 0x1f3c <prvCopyDataToQueue+0x8c>
    1ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ec8:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <vTaskPriorityDisinherit>
    1ecc:	1a 82       	std	Y+2, r1	; 0x02
    1ece:	1b 82       	std	Y+3, r1	; 0x03
    1ed0:	35 c0       	rjmp	.+106    	; 0x1f3c <prvCopyDataToQueue+0x8c>
    1ed2:	41 11       	cpse	r20, r1
    1ed4:	17 c0       	rjmp	.+46     	; 0x1f04 <prvCopyDataToQueue+0x54>
    1ed6:	48 2f       	mov	r20, r24
    1ed8:	50 e0       	ldi	r21, 0x00	; 0
    1eda:	8c 81       	ldd	r24, Y+4	; 0x04
    1edc:	9d 81       	ldd	r25, Y+5	; 0x05
    1ede:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <memcpy>
    1ee2:	28 a1       	ldd	r18, Y+32	; 0x20
    1ee4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ee6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ee8:	82 0f       	add	r24, r18
    1eea:	91 1d       	adc	r25, r1
    1eec:	8c 83       	std	Y+4, r24	; 0x04
    1eee:	9d 83       	std	Y+5, r25	; 0x05
    1ef0:	2a 81       	ldd	r18, Y+2	; 0x02
    1ef2:	3b 81       	ldd	r19, Y+3	; 0x03
    1ef4:	82 17       	cp	r24, r18
    1ef6:	93 07       	cpc	r25, r19
    1ef8:	08 f1       	brcs	.+66     	; 0x1f3c <prvCopyDataToQueue+0x8c>
    1efa:	88 81       	ld	r24, Y
    1efc:	99 81       	ldd	r25, Y+1	; 0x01
    1efe:	8c 83       	std	Y+4, r24	; 0x04
    1f00:	9d 83       	std	Y+5, r25	; 0x05
    1f02:	1c c0       	rjmp	.+56     	; 0x1f3c <prvCopyDataToQueue+0x8c>
    1f04:	48 2f       	mov	r20, r24
    1f06:	50 e0       	ldi	r21, 0x00	; 0
    1f08:	8e 81       	ldd	r24, Y+6	; 0x06
    1f0a:	9f 81       	ldd	r25, Y+7	; 0x07
    1f0c:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <memcpy>
    1f10:	88 a1       	ldd	r24, Y+32	; 0x20
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	91 95       	neg	r25
    1f16:	81 95       	neg	r24
    1f18:	91 09       	sbc	r25, r1
    1f1a:	2e 81       	ldd	r18, Y+6	; 0x06
    1f1c:	3f 81       	ldd	r19, Y+7	; 0x07
    1f1e:	28 0f       	add	r18, r24
    1f20:	39 1f       	adc	r19, r25
    1f22:	2e 83       	std	Y+6, r18	; 0x06
    1f24:	3f 83       	std	Y+7, r19	; 0x07
    1f26:	48 81       	ld	r20, Y
    1f28:	59 81       	ldd	r21, Y+1	; 0x01
    1f2a:	24 17       	cp	r18, r20
    1f2c:	35 07       	cpc	r19, r21
    1f2e:	30 f4       	brcc	.+12     	; 0x1f3c <prvCopyDataToQueue+0x8c>
    1f30:	2a 81       	ldd	r18, Y+2	; 0x02
    1f32:	3b 81       	ldd	r19, Y+3	; 0x03
    1f34:	82 0f       	add	r24, r18
    1f36:	93 1f       	adc	r25, r19
    1f38:	8e 83       	std	Y+6, r24	; 0x06
    1f3a:	9f 83       	std	Y+7, r25	; 0x07
    1f3c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f3e:	8f 5f       	subi	r24, 0xFF	; 255
    1f40:	8e 8f       	std	Y+30, r24	; 0x1e
    1f42:	df 91       	pop	r29
    1f44:	cf 91       	pop	r28
    1f46:	08 95       	ret

00001f48 <prvCopyDataFromQueue>:
    1f48:	fc 01       	movw	r30, r24
    1f4a:	80 81       	ld	r24, Z
    1f4c:	91 81       	ldd	r25, Z+1	; 0x01
    1f4e:	00 97       	sbiw	r24, 0x00	; 0
    1f50:	a1 f0       	breq	.+40     	; 0x1f7a <prvCopyDataFromQueue+0x32>
    1f52:	40 a1       	ldd	r20, Z+32	; 0x20
    1f54:	50 e0       	ldi	r21, 0x00	; 0
    1f56:	26 81       	ldd	r18, Z+6	; 0x06
    1f58:	37 81       	ldd	r19, Z+7	; 0x07
    1f5a:	24 0f       	add	r18, r20
    1f5c:	35 1f       	adc	r19, r21
    1f5e:	26 83       	std	Z+6, r18	; 0x06
    1f60:	37 83       	std	Z+7, r19	; 0x07
    1f62:	a2 81       	ldd	r26, Z+2	; 0x02
    1f64:	b3 81       	ldd	r27, Z+3	; 0x03
    1f66:	2a 17       	cp	r18, r26
    1f68:	3b 07       	cpc	r19, r27
    1f6a:	10 f0       	brcs	.+4      	; 0x1f70 <prvCopyDataFromQueue+0x28>
    1f6c:	86 83       	std	Z+6, r24	; 0x06
    1f6e:	97 83       	std	Z+7, r25	; 0x07
    1f70:	cb 01       	movw	r24, r22
    1f72:	66 81       	ldd	r22, Z+6	; 0x06
    1f74:	77 81       	ldd	r23, Z+7	; 0x07
    1f76:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <memcpy>
    1f7a:	08 95       	ret

00001f7c <prvUnlockQueue>:
    1f7c:	0f 93       	push	r16
    1f7e:	1f 93       	push	r17
    1f80:	cf 93       	push	r28
    1f82:	df 93       	push	r29
    1f84:	ec 01       	movw	r28, r24
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	0f 92       	push	r0
    1f8c:	8a a1       	ldd	r24, Y+34	; 0x22
    1f8e:	18 16       	cp	r1, r24
    1f90:	b4 f4       	brge	.+44     	; 0x1fbe <prvUnlockQueue+0x42>
    1f92:	8b 89       	ldd	r24, Y+19	; 0x13
    1f94:	81 11       	cpse	r24, r1
    1f96:	05 c0       	rjmp	.+10     	; 0x1fa2 <prvUnlockQueue+0x26>
    1f98:	12 c0       	rjmp	.+36     	; 0x1fbe <prvUnlockQueue+0x42>
    1f9a:	8b 89       	ldd	r24, Y+19	; 0x13
    1f9c:	81 11       	cpse	r24, r1
    1f9e:	04 c0       	rjmp	.+8      	; 0x1fa8 <prvUnlockQueue+0x2c>
    1fa0:	0e c0       	rjmp	.+28     	; 0x1fbe <prvUnlockQueue+0x42>
    1fa2:	8e 01       	movw	r16, r28
    1fa4:	0d 5e       	subi	r16, 0xED	; 237
    1fa6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fa8:	c8 01       	movw	r24, r16
    1faa:	0e 94 38 16 	call	0x2c70	; 0x2c70 <xTaskRemoveFromEventList>
    1fae:	81 11       	cpse	r24, r1
    1fb0:	0e 94 f5 16 	call	0x2dea	; 0x2dea <vTaskMissedYield>
    1fb4:	8a a1       	ldd	r24, Y+34	; 0x22
    1fb6:	81 50       	subi	r24, 0x01	; 1
    1fb8:	8a a3       	std	Y+34, r24	; 0x22
    1fba:	18 16       	cp	r1, r24
    1fbc:	74 f3       	brlt	.-36     	; 0x1f9a <prvUnlockQueue+0x1e>
    1fbe:	8f ef       	ldi	r24, 0xFF	; 255
    1fc0:	8a a3       	std	Y+34, r24	; 0x22
    1fc2:	0f 90       	pop	r0
    1fc4:	0f be       	out	0x3f, r0	; 63
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	f8 94       	cli
    1fca:	0f 92       	push	r0
    1fcc:	89 a1       	ldd	r24, Y+33	; 0x21
    1fce:	18 16       	cp	r1, r24
    1fd0:	b4 f4       	brge	.+44     	; 0x1ffe <prvUnlockQueue+0x82>
    1fd2:	88 85       	ldd	r24, Y+8	; 0x08
    1fd4:	81 11       	cpse	r24, r1
    1fd6:	05 c0       	rjmp	.+10     	; 0x1fe2 <prvUnlockQueue+0x66>
    1fd8:	12 c0       	rjmp	.+36     	; 0x1ffe <prvUnlockQueue+0x82>
    1fda:	88 85       	ldd	r24, Y+8	; 0x08
    1fdc:	81 11       	cpse	r24, r1
    1fde:	04 c0       	rjmp	.+8      	; 0x1fe8 <prvUnlockQueue+0x6c>
    1fe0:	0e c0       	rjmp	.+28     	; 0x1ffe <prvUnlockQueue+0x82>
    1fe2:	8e 01       	movw	r16, r28
    1fe4:	08 5f       	subi	r16, 0xF8	; 248
    1fe6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fe8:	c8 01       	movw	r24, r16
    1fea:	0e 94 38 16 	call	0x2c70	; 0x2c70 <xTaskRemoveFromEventList>
    1fee:	81 11       	cpse	r24, r1
    1ff0:	0e 94 f5 16 	call	0x2dea	; 0x2dea <vTaskMissedYield>
    1ff4:	89 a1       	ldd	r24, Y+33	; 0x21
    1ff6:	81 50       	subi	r24, 0x01	; 1
    1ff8:	89 a3       	std	Y+33, r24	; 0x21
    1ffa:	18 16       	cp	r1, r24
    1ffc:	74 f3       	brlt	.-36     	; 0x1fda <prvUnlockQueue+0x5e>
    1ffe:	8f ef       	ldi	r24, 0xFF	; 255
    2000:	89 a3       	std	Y+33, r24	; 0x21
    2002:	0f 90       	pop	r0
    2004:	0f be       	out	0x3f, r0	; 63
    2006:	df 91       	pop	r29
    2008:	cf 91       	pop	r28
    200a:	1f 91       	pop	r17
    200c:	0f 91       	pop	r16
    200e:	08 95       	ret

00002010 <xQueueGenericReset>:
    2010:	1f 93       	push	r17
    2012:	cf 93       	push	r28
    2014:	df 93       	push	r29
    2016:	61 30       	cpi	r22, 0x01	; 1
    2018:	59 f0       	breq	.+22     	; 0x2030 <xQueueGenericReset+0x20>
    201a:	fc 01       	movw	r30, r24
    201c:	23 89       	ldd	r18, Z+19	; 0x13
    201e:	30 85       	ldd	r19, Z+8	; 0x08
    2020:	31 11       	cpse	r19, r1
    2022:	2c c0       	rjmp	.+88     	; 0x207c <xQueueGenericReset+0x6c>
    2024:	11 e0       	ldi	r17, 0x01	; 1
    2026:	21 11       	cpse	r18, r1
    2028:	10 e0       	ldi	r17, 0x00	; 0
    202a:	21 11       	cpse	r18, r1
    202c:	28 c0       	rjmp	.+80     	; 0x207e <xQueueGenericReset+0x6e>
    202e:	01 c0       	rjmp	.+2      	; 0x2032 <xQueueGenericReset+0x22>
    2030:	11 e0       	ldi	r17, 0x01	; 1
    2032:	ec 01       	movw	r28, r24
    2034:	48 81       	ld	r20, Y
    2036:	59 81       	ldd	r21, Y+1	; 0x01
    2038:	28 a1       	ldd	r18, Y+32	; 0x20
    203a:	30 e0       	ldi	r19, 0x00	; 0
    203c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    203e:	62 9f       	mul	r22, r18
    2040:	c0 01       	movw	r24, r0
    2042:	63 9f       	mul	r22, r19
    2044:	90 0d       	add	r25, r0
    2046:	11 24       	eor	r1, r1
    2048:	ba 01       	movw	r22, r20
    204a:	68 0f       	add	r22, r24
    204c:	79 1f       	adc	r23, r25
    204e:	6a 83       	std	Y+2, r22	; 0x02
    2050:	7b 83       	std	Y+3, r23	; 0x03
    2052:	1e 8e       	std	Y+30, r1	; 0x1e
    2054:	4c 83       	std	Y+4, r20	; 0x04
    2056:	5d 83       	std	Y+5, r21	; 0x05
    2058:	82 1b       	sub	r24, r18
    205a:	93 0b       	sbc	r25, r19
    205c:	84 0f       	add	r24, r20
    205e:	95 1f       	adc	r25, r21
    2060:	8e 83       	std	Y+6, r24	; 0x06
    2062:	9f 83       	std	Y+7, r25	; 0x07
    2064:	8f ef       	ldi	r24, 0xFF	; 255
    2066:	89 a3       	std	Y+33, r24	; 0x21
    2068:	8a a3       	std	Y+34, r24	; 0x22
    206a:	ce 01       	movw	r24, r28
    206c:	08 96       	adiw	r24, 0x08	; 8
    206e:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    2072:	ce 01       	movw	r24, r28
    2074:	43 96       	adiw	r24, 0x13	; 19
    2076:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    207a:	01 c0       	rjmp	.+2      	; 0x207e <xQueueGenericReset+0x6e>
    207c:	10 e0       	ldi	r17, 0x00	; 0
    207e:	81 2f       	mov	r24, r17
    2080:	df 91       	pop	r29
    2082:	cf 91       	pop	r28
    2084:	1f 91       	pop	r17
    2086:	08 95       	ret

00002088 <xQueueGenericCreate>:
    2088:	0f 93       	push	r16
    208a:	1f 93       	push	r17
    208c:	cf 93       	push	r28
    208e:	df 93       	push	r29
    2090:	88 23       	and	r24, r24
    2092:	01 f1       	breq	.+64     	; 0x20d4 <xQueueGenericCreate+0x4c>
    2094:	06 2f       	mov	r16, r22
    2096:	18 2f       	mov	r17, r24
    2098:	83 e2       	ldi	r24, 0x23	; 35
    209a:	90 e0       	ldi	r25, 0x00	; 0
    209c:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <pvPortMalloc>
    20a0:	ec 01       	movw	r28, r24
    20a2:	89 2b       	or	r24, r25
    20a4:	c9 f0       	breq	.+50     	; 0x20d8 <xQueueGenericCreate+0x50>
    20a6:	10 9f       	mul	r17, r16
    20a8:	c0 01       	movw	r24, r0
    20aa:	11 24       	eor	r1, r1
    20ac:	01 96       	adiw	r24, 0x01	; 1
    20ae:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <pvPortMalloc>
    20b2:	88 83       	st	Y, r24
    20b4:	99 83       	std	Y+1, r25	; 0x01
    20b6:	89 2b       	or	r24, r25
    20b8:	39 f0       	breq	.+14     	; 0x20c8 <xQueueGenericCreate+0x40>
    20ba:	1f 8f       	std	Y+31, r17	; 0x1f
    20bc:	08 a3       	std	Y+32, r16	; 0x20
    20be:	61 e0       	ldi	r22, 0x01	; 1
    20c0:	ce 01       	movw	r24, r28
    20c2:	0e 94 08 10 	call	0x2010	; 0x2010 <xQueueGenericReset>
    20c6:	08 c0       	rjmp	.+16     	; 0x20d8 <xQueueGenericCreate+0x50>
    20c8:	ce 01       	movw	r24, r28
    20ca:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vPortFree>
    20ce:	c0 e0       	ldi	r28, 0x00	; 0
    20d0:	d0 e0       	ldi	r29, 0x00	; 0
    20d2:	02 c0       	rjmp	.+4      	; 0x20d8 <xQueueGenericCreate+0x50>
    20d4:	c0 e0       	ldi	r28, 0x00	; 0
    20d6:	d0 e0       	ldi	r29, 0x00	; 0
    20d8:	ce 01       	movw	r24, r28
    20da:	df 91       	pop	r29
    20dc:	cf 91       	pop	r28
    20de:	1f 91       	pop	r17
    20e0:	0f 91       	pop	r16
    20e2:	08 95       	ret

000020e4 <xQueueGenericSend>:
    20e4:	af 92       	push	r10
    20e6:	bf 92       	push	r11
    20e8:	cf 92       	push	r12
    20ea:	df 92       	push	r13
    20ec:	ef 92       	push	r14
    20ee:	ff 92       	push	r15
    20f0:	0f 93       	push	r16
    20f2:	1f 93       	push	r17
    20f4:	cf 93       	push	r28
    20f6:	df 93       	push	r29
    20f8:	cd b7       	in	r28, 0x3d	; 61
    20fa:	de b7       	in	r29, 0x3e	; 62
    20fc:	29 97       	sbiw	r28, 0x09	; 9
    20fe:	cd bf       	out	0x3d, r28	; 61
    2100:	de bf       	out	0x3e, r29	; 62
    2102:	7c 01       	movw	r14, r24
    2104:	5b 01       	movw	r10, r22
    2106:	2e 83       	std	Y+6, r18	; 0x06
    2108:	3f 83       	std	Y+7, r19	; 0x07
    210a:	48 87       	std	Y+8, r20	; 0x08
    210c:	59 87       	std	Y+9, r21	; 0x09
    210e:	10 e0       	ldi	r17, 0x00	; 0
    2110:	6c 01       	movw	r12, r24
    2112:	88 e0       	ldi	r24, 0x08	; 8
    2114:	c8 0e       	add	r12, r24
    2116:	d1 1c       	adc	r13, r1
    2118:	0f b6       	in	r0, 0x3f	; 63
    211a:	f8 94       	cli
    211c:	0f 92       	push	r0
    211e:	f7 01       	movw	r30, r14
    2120:	96 8d       	ldd	r25, Z+30	; 0x1e
    2122:	87 8d       	ldd	r24, Z+31	; 0x1f
    2124:	98 17       	cp	r25, r24
    2126:	a8 f4       	brcc	.+42     	; 0x2152 <xQueueGenericSend+0x6e>
    2128:	40 2f       	mov	r20, r16
    212a:	b5 01       	movw	r22, r10
    212c:	c7 01       	movw	r24, r14
    212e:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <prvCopyDataToQueue>
    2132:	f7 01       	movw	r30, r14
    2134:	83 89       	ldd	r24, Z+19	; 0x13
    2136:	88 23       	and	r24, r24
    2138:	41 f0       	breq	.+16     	; 0x214a <xQueueGenericSend+0x66>
    213a:	c7 01       	movw	r24, r14
    213c:	43 96       	adiw	r24, 0x13	; 19
    213e:	0e 94 38 16 	call	0x2c70	; 0x2c70 <xTaskRemoveFromEventList>
    2142:	81 30       	cpi	r24, 0x01	; 1
    2144:	11 f4       	brne	.+4      	; 0x214a <xQueueGenericSend+0x66>
    2146:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
    214a:	0f 90       	pop	r0
    214c:	0f be       	out	0x3f, r0	; 63
    214e:	81 e0       	ldi	r24, 0x01	; 1
    2150:	56 c0       	rjmp	.+172    	; 0x21fe <xQueueGenericSend+0x11a>
    2152:	8e 81       	ldd	r24, Y+6	; 0x06
    2154:	9f 81       	ldd	r25, Y+7	; 0x07
    2156:	a8 85       	ldd	r26, Y+8	; 0x08
    2158:	b9 85       	ldd	r27, Y+9	; 0x09
    215a:	89 2b       	or	r24, r25
    215c:	8a 2b       	or	r24, r26
    215e:	8b 2b       	or	r24, r27
    2160:	21 f4       	brne	.+8      	; 0x216a <xQueueGenericSend+0x86>
    2162:	0f 90       	pop	r0
    2164:	0f be       	out	0x3f, r0	; 63
    2166:	80 e0       	ldi	r24, 0x00	; 0
    2168:	4a c0       	rjmp	.+148    	; 0x21fe <xQueueGenericSend+0x11a>
    216a:	11 11       	cpse	r17, r1
    216c:	05 c0       	rjmp	.+10     	; 0x2178 <xQueueGenericSend+0x94>
    216e:	ce 01       	movw	r24, r28
    2170:	01 96       	adiw	r24, 0x01	; 1
    2172:	0e 94 77 16 	call	0x2cee	; 0x2cee <vTaskSetTimeOutState>
    2176:	11 e0       	ldi	r17, 0x01	; 1
    2178:	0f 90       	pop	r0
    217a:	0f be       	out	0x3f, r0	; 63
    217c:	0e 94 72 13 	call	0x26e4	; 0x26e4 <vTaskSuspendAll>
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	f8 94       	cli
    2184:	0f 92       	push	r0
    2186:	f7 01       	movw	r30, r14
    2188:	81 a1       	ldd	r24, Z+33	; 0x21
    218a:	8f 3f       	cpi	r24, 0xFF	; 255
    218c:	09 f4       	brne	.+2      	; 0x2190 <xQueueGenericSend+0xac>
    218e:	11 a2       	std	Z+33, r1	; 0x21
    2190:	f7 01       	movw	r30, r14
    2192:	82 a1       	ldd	r24, Z+34	; 0x22
    2194:	8f 3f       	cpi	r24, 0xFF	; 255
    2196:	09 f4       	brne	.+2      	; 0x219a <xQueueGenericSend+0xb6>
    2198:	12 a2       	std	Z+34, r1	; 0x22
    219a:	0f 90       	pop	r0
    219c:	0f be       	out	0x3f, r0	; 63
    219e:	be 01       	movw	r22, r28
    21a0:	6a 5f       	subi	r22, 0xFA	; 250
    21a2:	7f 4f       	sbci	r23, 0xFF	; 255
    21a4:	ce 01       	movw	r24, r28
    21a6:	01 96       	adiw	r24, 0x01	; 1
    21a8:	0e 94 88 16 	call	0x2d10	; 0x2d10 <xTaskCheckForTimeOut>
    21ac:	81 11       	cpse	r24, r1
    21ae:	21 c0       	rjmp	.+66     	; 0x21f2 <xQueueGenericSend+0x10e>
    21b0:	0f b6       	in	r0, 0x3f	; 63
    21b2:	f8 94       	cli
    21b4:	0f 92       	push	r0
    21b6:	f7 01       	movw	r30, r14
    21b8:	96 8d       	ldd	r25, Z+30	; 0x1e
    21ba:	0f 90       	pop	r0
    21bc:	0f be       	out	0x3f, r0	; 63
    21be:	87 8d       	ldd	r24, Z+31	; 0x1f
    21c0:	98 13       	cpse	r25, r24
    21c2:	11 c0       	rjmp	.+34     	; 0x21e6 <xQueueGenericSend+0x102>
    21c4:	4e 81       	ldd	r20, Y+6	; 0x06
    21c6:	5f 81       	ldd	r21, Y+7	; 0x07
    21c8:	68 85       	ldd	r22, Y+8	; 0x08
    21ca:	79 85       	ldd	r23, Y+9	; 0x09
    21cc:	c6 01       	movw	r24, r12
    21ce:	0e 94 0e 16 	call	0x2c1c	; 0x2c1c <vTaskPlaceOnEventList>
    21d2:	c7 01       	movw	r24, r14
    21d4:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvUnlockQueue>
    21d8:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
    21dc:	81 11       	cpse	r24, r1
    21de:	9c cf       	rjmp	.-200    	; 0x2118 <xQueueGenericSend+0x34>
    21e0:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
    21e4:	99 cf       	rjmp	.-206    	; 0x2118 <xQueueGenericSend+0x34>
    21e6:	c7 01       	movw	r24, r14
    21e8:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvUnlockQueue>
    21ec:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
    21f0:	93 cf       	rjmp	.-218    	; 0x2118 <xQueueGenericSend+0x34>
    21f2:	c7 01       	movw	r24, r14
    21f4:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvUnlockQueue>
    21f8:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
    21fc:	80 e0       	ldi	r24, 0x00	; 0
    21fe:	29 96       	adiw	r28, 0x09	; 9
    2200:	cd bf       	out	0x3d, r28	; 61
    2202:	de bf       	out	0x3e, r29	; 62
    2204:	df 91       	pop	r29
    2206:	cf 91       	pop	r28
    2208:	1f 91       	pop	r17
    220a:	0f 91       	pop	r16
    220c:	ff 90       	pop	r15
    220e:	ef 90       	pop	r14
    2210:	df 90       	pop	r13
    2212:	cf 90       	pop	r12
    2214:	bf 90       	pop	r11
    2216:	af 90       	pop	r10
    2218:	08 95       	ret

0000221a <xQueueGenericReceive>:
    221a:	af 92       	push	r10
    221c:	bf 92       	push	r11
    221e:	cf 92       	push	r12
    2220:	df 92       	push	r13
    2222:	ef 92       	push	r14
    2224:	ff 92       	push	r15
    2226:	0f 93       	push	r16
    2228:	1f 93       	push	r17
    222a:	cf 93       	push	r28
    222c:	df 93       	push	r29
    222e:	cd b7       	in	r28, 0x3d	; 61
    2230:	de b7       	in	r29, 0x3e	; 62
    2232:	29 97       	sbiw	r28, 0x09	; 9
    2234:	cd bf       	out	0x3d, r28	; 61
    2236:	de bf       	out	0x3e, r29	; 62
    2238:	7c 01       	movw	r14, r24
    223a:	5b 01       	movw	r10, r22
    223c:	2e 83       	std	Y+6, r18	; 0x06
    223e:	3f 83       	std	Y+7, r19	; 0x07
    2240:	48 87       	std	Y+8, r20	; 0x08
    2242:	59 87       	std	Y+9, r21	; 0x09
    2244:	10 e0       	ldi	r17, 0x00	; 0
    2246:	6c 01       	movw	r12, r24
    2248:	83 e1       	ldi	r24, 0x13	; 19
    224a:	c8 0e       	add	r12, r24
    224c:	d1 1c       	adc	r13, r1
    224e:	0f b6       	in	r0, 0x3f	; 63
    2250:	f8 94       	cli
    2252:	0f 92       	push	r0
    2254:	f7 01       	movw	r30, r14
    2256:	86 8d       	ldd	r24, Z+30	; 0x1e
    2258:	88 23       	and	r24, r24
    225a:	99 f1       	breq	.+102    	; 0x22c2 <xQueueGenericReceive+0xa8>
    225c:	c6 80       	ldd	r12, Z+6	; 0x06
    225e:	d7 80       	ldd	r13, Z+7	; 0x07
    2260:	b5 01       	movw	r22, r10
    2262:	c7 01       	movw	r24, r14
    2264:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <prvCopyDataFromQueue>
    2268:	01 11       	cpse	r16, r1
    226a:	1a c0       	rjmp	.+52     	; 0x22a0 <xQueueGenericReceive+0x86>
    226c:	f7 01       	movw	r30, r14
    226e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2270:	81 50       	subi	r24, 0x01	; 1
    2272:	86 8f       	std	Z+30, r24	; 0x1e
    2274:	80 81       	ld	r24, Z
    2276:	91 81       	ldd	r25, Z+1	; 0x01
    2278:	89 2b       	or	r24, r25
    227a:	29 f4       	brne	.+10     	; 0x2286 <xQueueGenericReceive+0x6c>
    227c:	0e 94 12 17 	call	0x2e24	; 0x2e24 <xTaskGetCurrentTaskHandle>
    2280:	f7 01       	movw	r30, r14
    2282:	82 83       	std	Z+2, r24	; 0x02
    2284:	93 83       	std	Z+3, r25	; 0x03
    2286:	f7 01       	movw	r30, r14
    2288:	80 85       	ldd	r24, Z+8	; 0x08
    228a:	88 23       	and	r24, r24
    228c:	b1 f0       	breq	.+44     	; 0x22ba <xQueueGenericReceive+0xa0>
    228e:	c7 01       	movw	r24, r14
    2290:	08 96       	adiw	r24, 0x08	; 8
    2292:	0e 94 38 16 	call	0x2c70	; 0x2c70 <xTaskRemoveFromEventList>
    2296:	81 30       	cpi	r24, 0x01	; 1
    2298:	81 f4       	brne	.+32     	; 0x22ba <xQueueGenericReceive+0xa0>
    229a:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
    229e:	0d c0       	rjmp	.+26     	; 0x22ba <xQueueGenericReceive+0xa0>
    22a0:	f7 01       	movw	r30, r14
    22a2:	c6 82       	std	Z+6, r12	; 0x06
    22a4:	d7 82       	std	Z+7, r13	; 0x07
    22a6:	83 89       	ldd	r24, Z+19	; 0x13
    22a8:	88 23       	and	r24, r24
    22aa:	39 f0       	breq	.+14     	; 0x22ba <xQueueGenericReceive+0xa0>
    22ac:	c7 01       	movw	r24, r14
    22ae:	43 96       	adiw	r24, 0x13	; 19
    22b0:	0e 94 38 16 	call	0x2c70	; 0x2c70 <xTaskRemoveFromEventList>
    22b4:	81 11       	cpse	r24, r1
    22b6:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
    22ba:	0f 90       	pop	r0
    22bc:	0f be       	out	0x3f, r0	; 63
    22be:	81 e0       	ldi	r24, 0x01	; 1
    22c0:	62 c0       	rjmp	.+196    	; 0x2386 <xQueueGenericReceive+0x16c>
    22c2:	8e 81       	ldd	r24, Y+6	; 0x06
    22c4:	9f 81       	ldd	r25, Y+7	; 0x07
    22c6:	a8 85       	ldd	r26, Y+8	; 0x08
    22c8:	b9 85       	ldd	r27, Y+9	; 0x09
    22ca:	89 2b       	or	r24, r25
    22cc:	8a 2b       	or	r24, r26
    22ce:	8b 2b       	or	r24, r27
    22d0:	21 f4       	brne	.+8      	; 0x22da <xQueueGenericReceive+0xc0>
    22d2:	0f 90       	pop	r0
    22d4:	0f be       	out	0x3f, r0	; 63
    22d6:	80 e0       	ldi	r24, 0x00	; 0
    22d8:	56 c0       	rjmp	.+172    	; 0x2386 <xQueueGenericReceive+0x16c>
    22da:	11 11       	cpse	r17, r1
    22dc:	05 c0       	rjmp	.+10     	; 0x22e8 <xQueueGenericReceive+0xce>
    22de:	ce 01       	movw	r24, r28
    22e0:	01 96       	adiw	r24, 0x01	; 1
    22e2:	0e 94 77 16 	call	0x2cee	; 0x2cee <vTaskSetTimeOutState>
    22e6:	11 e0       	ldi	r17, 0x01	; 1
    22e8:	0f 90       	pop	r0
    22ea:	0f be       	out	0x3f, r0	; 63
    22ec:	0e 94 72 13 	call	0x26e4	; 0x26e4 <vTaskSuspendAll>
    22f0:	0f b6       	in	r0, 0x3f	; 63
    22f2:	f8 94       	cli
    22f4:	0f 92       	push	r0
    22f6:	f7 01       	movw	r30, r14
    22f8:	81 a1       	ldd	r24, Z+33	; 0x21
    22fa:	8f 3f       	cpi	r24, 0xFF	; 255
    22fc:	09 f4       	brne	.+2      	; 0x2300 <xQueueGenericReceive+0xe6>
    22fe:	11 a2       	std	Z+33, r1	; 0x21
    2300:	f7 01       	movw	r30, r14
    2302:	82 a1       	ldd	r24, Z+34	; 0x22
    2304:	8f 3f       	cpi	r24, 0xFF	; 255
    2306:	09 f4       	brne	.+2      	; 0x230a <xQueueGenericReceive+0xf0>
    2308:	12 a2       	std	Z+34, r1	; 0x22
    230a:	0f 90       	pop	r0
    230c:	0f be       	out	0x3f, r0	; 63
    230e:	be 01       	movw	r22, r28
    2310:	6a 5f       	subi	r22, 0xFA	; 250
    2312:	7f 4f       	sbci	r23, 0xFF	; 255
    2314:	ce 01       	movw	r24, r28
    2316:	01 96       	adiw	r24, 0x01	; 1
    2318:	0e 94 88 16 	call	0x2d10	; 0x2d10 <xTaskCheckForTimeOut>
    231c:	81 11       	cpse	r24, r1
    231e:	2d c0       	rjmp	.+90     	; 0x237a <xQueueGenericReceive+0x160>
    2320:	0f b6       	in	r0, 0x3f	; 63
    2322:	f8 94       	cli
    2324:	0f 92       	push	r0
    2326:	f7 01       	movw	r30, r14
    2328:	86 8d       	ldd	r24, Z+30	; 0x1e
    232a:	0f 90       	pop	r0
    232c:	0f be       	out	0x3f, r0	; 63
    232e:	81 11       	cpse	r24, r1
    2330:	1e c0       	rjmp	.+60     	; 0x236e <xQueueGenericReceive+0x154>
    2332:	80 81       	ld	r24, Z
    2334:	91 81       	ldd	r25, Z+1	; 0x01
    2336:	89 2b       	or	r24, r25
    2338:	49 f4       	brne	.+18     	; 0x234c <xQueueGenericReceive+0x132>
    233a:	0f b6       	in	r0, 0x3f	; 63
    233c:	f8 94       	cli
    233e:	0f 92       	push	r0
    2340:	82 81       	ldd	r24, Z+2	; 0x02
    2342:	93 81       	ldd	r25, Z+3	; 0x03
    2344:	0e 94 17 17 	call	0x2e2e	; 0x2e2e <vTaskPriorityInherit>
    2348:	0f 90       	pop	r0
    234a:	0f be       	out	0x3f, r0	; 63
    234c:	4e 81       	ldd	r20, Y+6	; 0x06
    234e:	5f 81       	ldd	r21, Y+7	; 0x07
    2350:	68 85       	ldd	r22, Y+8	; 0x08
    2352:	79 85       	ldd	r23, Y+9	; 0x09
    2354:	c6 01       	movw	r24, r12
    2356:	0e 94 0e 16 	call	0x2c1c	; 0x2c1c <vTaskPlaceOnEventList>
    235a:	c7 01       	movw	r24, r14
    235c:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvUnlockQueue>
    2360:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
    2364:	81 11       	cpse	r24, r1
    2366:	73 cf       	rjmp	.-282    	; 0x224e <xQueueGenericReceive+0x34>
    2368:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
    236c:	70 cf       	rjmp	.-288    	; 0x224e <xQueueGenericReceive+0x34>
    236e:	c7 01       	movw	r24, r14
    2370:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvUnlockQueue>
    2374:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
    2378:	6a cf       	rjmp	.-300    	; 0x224e <xQueueGenericReceive+0x34>
    237a:	c7 01       	movw	r24, r14
    237c:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvUnlockQueue>
    2380:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
    2384:	80 e0       	ldi	r24, 0x00	; 0
    2386:	29 96       	adiw	r28, 0x09	; 9
    2388:	cd bf       	out	0x3d, r28	; 61
    238a:	de bf       	out	0x3e, r29	; 62
    238c:	df 91       	pop	r29
    238e:	cf 91       	pop	r28
    2390:	1f 91       	pop	r17
    2392:	0f 91       	pop	r16
    2394:	ff 90       	pop	r15
    2396:	ef 90       	pop	r14
    2398:	df 90       	pop	r13
    239a:	cf 90       	pop	r12
    239c:	bf 90       	pop	r11
    239e:	af 90       	pop	r10
    23a0:	08 95       	ret

000023a2 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    23a2:	0f b6       	in	r0, 0x3f	; 63
    23a4:	f8 94       	cli
    23a6:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    23a8:	fc 01       	movw	r30, r24
    23aa:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    23ac:	0f 90       	pop	r0
    23ae:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    23b0:	08 95       	ret

000023b2 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    23b2:	c8 ef       	ldi	r28, 0xF8	; 248
    23b4:	d0 e3       	ldi	r29, 0x30	; 48
    23b6:	88 81       	ld	r24, Y
    23b8:	82 30       	cpi	r24, 0x02	; 2
    23ba:	e8 f3       	brcs	.-6      	; 0x23b6 <prvIdleTask+0x4>
    23bc:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
    23c0:	fa cf       	rjmp	.-12     	; 0x23b6 <prvIdleTask+0x4>

000023c2 <prvAddCurrentTaskToDelayedList>:
    23c2:	cf 92       	push	r12
    23c4:	df 92       	push	r13
    23c6:	ef 92       	push	r14
    23c8:	ff 92       	push	r15
    23ca:	6b 01       	movw	r12, r22
    23cc:	7c 01       	movw	r14, r24
    23ce:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    23d2:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    23d6:	62 83       	std	Z+2, r22	; 0x02
    23d8:	73 83       	std	Z+3, r23	; 0x03
    23da:	84 83       	std	Z+4, r24	; 0x04
    23dc:	95 83       	std	Z+5, r25	; 0x05
    23de:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    23e2:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    23e6:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    23ea:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    23ee:	c8 16       	cp	r12, r24
    23f0:	d9 06       	cpc	r13, r25
    23f2:	ea 06       	cpc	r14, r26
    23f4:	fb 06       	cpc	r15, r27
    23f6:	68 f4       	brcc	.+26     	; 0x2412 <prvAddCurrentTaskToDelayedList+0x50>
    23f8:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    23fc:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2400:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2404:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    2408:	6e 5f       	subi	r22, 0xFE	; 254
    240a:	7f 4f       	sbci	r23, 0xFF	; 255
    240c:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <vListInsert>
    2410:	21 c0       	rjmp	.+66     	; 0x2454 <prvAddCurrentTaskToDelayedList+0x92>
    2412:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2416:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    241a:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    241e:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2422:	6e 5f       	subi	r22, 0xFE	; 254
    2424:	7f 4f       	sbci	r23, 0xFF	; 255
    2426:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <vListInsert>
    242a:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    242e:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2432:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2436:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    243a:	c8 16       	cp	r12, r24
    243c:	d9 06       	cpc	r13, r25
    243e:	ea 06       	cpc	r14, r26
    2440:	fb 06       	cpc	r15, r27
    2442:	40 f4       	brcc	.+16     	; 0x2454 <prvAddCurrentTaskToDelayedList+0x92>
    2444:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2448:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    244c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2450:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2454:	ff 90       	pop	r15
    2456:	ef 90       	pop	r14
    2458:	df 90       	pop	r13
    245a:	cf 90       	pop	r12
    245c:	08 95       	ret

0000245e <xTaskGenericCreate>:
    245e:	4f 92       	push	r4
    2460:	5f 92       	push	r5
    2462:	6f 92       	push	r6
    2464:	7f 92       	push	r7
    2466:	8f 92       	push	r8
    2468:	9f 92       	push	r9
    246a:	af 92       	push	r10
    246c:	bf 92       	push	r11
    246e:	cf 92       	push	r12
    2470:	df 92       	push	r13
    2472:	ef 92       	push	r14
    2474:	ff 92       	push	r15
    2476:	0f 93       	push	r16
    2478:	1f 93       	push	r17
    247a:	cf 93       	push	r28
    247c:	df 93       	push	r29
    247e:	5c 01       	movw	r10, r24
    2480:	4b 01       	movw	r8, r22
    2482:	3a 01       	movw	r6, r20
    2484:	29 01       	movw	r4, r18
    2486:	88 e2       	ldi	r24, 0x28	; 40
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <pvPortMalloc>
    248e:	ec 01       	movw	r28, r24
    2490:	89 2b       	or	r24, r25
    2492:	09 f4       	brne	.+2      	; 0x2496 <xTaskGenericCreate+0x38>
    2494:	d4 c0       	rjmp	.+424    	; 0x263e <xTaskGenericCreate+0x1e0>
    2496:	c1 14       	cp	r12, r1
    2498:	d1 04       	cpc	r13, r1
    249a:	09 f0       	breq	.+2      	; 0x249e <xTaskGenericCreate+0x40>
    249c:	cc c0       	rjmp	.+408    	; 0x2636 <xTaskGenericCreate+0x1d8>
    249e:	c3 01       	movw	r24, r6
    24a0:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <pvPortMalloc>
    24a4:	8b 8f       	std	Y+27, r24	; 0x1b
    24a6:	9c 8f       	std	Y+28, r25	; 0x1c
    24a8:	00 97       	sbiw	r24, 0x00	; 0
    24aa:	21 f4       	brne	.+8      	; 0x24b4 <xTaskGenericCreate+0x56>
    24ac:	ce 01       	movw	r24, r28
    24ae:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vPortFree>
    24b2:	c5 c0       	rjmp	.+394    	; 0x263e <xTaskGenericCreate+0x1e0>
    24b4:	a3 01       	movw	r20, r6
    24b6:	61 e1       	ldi	r22, 0x11	; 17
    24b8:	70 e0       	ldi	r23, 0x00	; 0
    24ba:	0e 94 ed 22 	call	0x45da	; 0x45da <memset>
    24be:	93 01       	movw	r18, r6
    24c0:	21 50       	subi	r18, 0x01	; 1
    24c2:	31 09       	sbc	r19, r1
    24c4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    24c6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    24c8:	3c 01       	movw	r6, r24
    24ca:	62 0e       	add	r6, r18
    24cc:	73 1e       	adc	r7, r19
    24ce:	4a e0       	ldi	r20, 0x0A	; 10
    24d0:	50 e0       	ldi	r21, 0x00	; 0
    24d2:	b4 01       	movw	r22, r8
    24d4:	ce 01       	movw	r24, r28
    24d6:	4d 96       	adiw	r24, 0x1d	; 29
    24d8:	0e 94 f4 22 	call	0x45e8	; 0x45e8 <strncpy>
    24dc:	1e a2       	std	Y+38, r1	; 0x26
    24de:	10 2f       	mov	r17, r16
    24e0:	04 30       	cpi	r16, 0x04	; 4
    24e2:	08 f0       	brcs	.+2      	; 0x24e6 <xTaskGenericCreate+0x88>
    24e4:	13 e0       	ldi	r17, 0x03	; 3
    24e6:	1a 8f       	std	Y+26, r17	; 0x1a
    24e8:	1f a3       	std	Y+39, r17	; 0x27
    24ea:	6e 01       	movw	r12, r28
    24ec:	22 e0       	ldi	r18, 0x02	; 2
    24ee:	c2 0e       	add	r12, r18
    24f0:	d1 1c       	adc	r13, r1
    24f2:	c6 01       	movw	r24, r12
    24f4:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <vListInitialiseItem>
    24f8:	ce 01       	movw	r24, r28
    24fa:	0e 96       	adiw	r24, 0x0e	; 14
    24fc:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <vListInitialiseItem>
    2500:	ca 87       	std	Y+10, r28	; 0x0a
    2502:	db 87       	std	Y+11, r29	; 0x0b
    2504:	84 e0       	ldi	r24, 0x04	; 4
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	a0 e0       	ldi	r26, 0x00	; 0
    250a:	b0 e0       	ldi	r27, 0x00	; 0
    250c:	81 1b       	sub	r24, r17
    250e:	91 09       	sbc	r25, r1
    2510:	a1 09       	sbc	r26, r1
    2512:	b1 09       	sbc	r27, r1
    2514:	8e 87       	std	Y+14, r24	; 0x0e
    2516:	9f 87       	std	Y+15, r25	; 0x0f
    2518:	a8 8b       	std	Y+16, r26	; 0x10
    251a:	b9 8b       	std	Y+17, r27	; 0x11
    251c:	ce 8b       	std	Y+22, r28	; 0x16
    251e:	df 8b       	std	Y+23, r29	; 0x17
    2520:	a2 01       	movw	r20, r4
    2522:	b5 01       	movw	r22, r10
    2524:	c3 01       	movw	r24, r6
    2526:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <pxPortInitialiseStack>
    252a:	88 83       	st	Y, r24
    252c:	99 83       	std	Y+1, r25	; 0x01
    252e:	e1 14       	cp	r14, r1
    2530:	f1 04       	cpc	r15, r1
    2532:	19 f0       	breq	.+6      	; 0x253a <xTaskGenericCreate+0xdc>
    2534:	f7 01       	movw	r30, r14
    2536:	c0 83       	st	Z, r28
    2538:	d1 83       	std	Z+1, r29	; 0x01
    253a:	0f b6       	in	r0, 0x3f	; 63
    253c:	f8 94       	cli
    253e:	0f 92       	push	r0
    2540:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2544:	8f 5f       	subi	r24, 0xFF	; 255
    2546:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    254a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    254e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2552:	89 2b       	or	r24, r25
    2554:	89 f5       	brne	.+98     	; 0x25b8 <xTaskGenericCreate+0x15a>
    2556:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    255a:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    255e:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2562:	81 30       	cpi	r24, 0x01	; 1
    2564:	c1 f5       	brne	.+112    	; 0x25d6 <xTaskGenericCreate+0x178>
    2566:	88 ef       	ldi	r24, 0xF8	; 248
    2568:	90 e3       	ldi	r25, 0x30	; 48
    256a:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    256e:	83 e0       	ldi	r24, 0x03	; 3
    2570:	91 e3       	ldi	r25, 0x31	; 49
    2572:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    2576:	8e e0       	ldi	r24, 0x0E	; 14
    2578:	91 e3       	ldi	r25, 0x31	; 49
    257a:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    257e:	89 e1       	ldi	r24, 0x19	; 25
    2580:	91 e3       	ldi	r25, 0x31	; 49
    2582:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    2586:	8d ee       	ldi	r24, 0xED	; 237
    2588:	90 e3       	ldi	r25, 0x30	; 48
    258a:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    258e:	82 ee       	ldi	r24, 0xE2	; 226
    2590:	90 e3       	ldi	r25, 0x30	; 48
    2592:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    2596:	83 ed       	ldi	r24, 0xD3	; 211
    2598:	90 e3       	ldi	r25, 0x30	; 48
    259a:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vListInitialise>
    259e:	8d ee       	ldi	r24, 0xED	; 237
    25a0:	90 e3       	ldi	r25, 0x30	; 48
    25a2:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    25a6:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    25aa:	82 ee       	ldi	r24, 0xE2	; 226
    25ac:	90 e3       	ldi	r25, 0x30	; 48
    25ae:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    25b2:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    25b6:	0f c0       	rjmp	.+30     	; 0x25d6 <xTaskGenericCreate+0x178>
    25b8:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    25bc:	81 11       	cpse	r24, r1
    25be:	0b c0       	rjmp	.+22     	; 0x25d6 <xTaskGenericCreate+0x178>
    25c0:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    25c4:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    25c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    25ca:	08 17       	cp	r16, r24
    25cc:	20 f0       	brcs	.+8      	; 0x25d6 <xTaskGenericCreate+0x178>
    25ce:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    25d2:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    25d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    25d8:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    25dc:	98 17       	cp	r25, r24
    25de:	10 f4       	brcc	.+4      	; 0x25e4 <xTaskGenericCreate+0x186>
    25e0:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    25e4:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    25e8:	9f 5f       	subi	r25, 0xFF	; 255
    25ea:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    25ee:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    25f2:	98 17       	cp	r25, r24
    25f4:	10 f4       	brcc	.+4      	; 0x25fa <xTaskGenericCreate+0x19c>
    25f6:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    25fa:	fb e0       	ldi	r31, 0x0B	; 11
    25fc:	8f 9f       	mul	r24, r31
    25fe:	c0 01       	movw	r24, r0
    2600:	11 24       	eor	r1, r1
    2602:	b6 01       	movw	r22, r12
    2604:	88 50       	subi	r24, 0x08	; 8
    2606:	9f 4c       	sbci	r25, 0xCF	; 207
    2608:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vListInsertEnd>
    260c:	0f 90       	pop	r0
    260e:	0f be       	out	0x3f, r0	; 63
    2610:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    2614:	88 23       	and	r24, r24
    2616:	59 f0       	breq	.+22     	; 0x262e <xTaskGenericCreate+0x1d0>
    2618:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    261c:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2620:	82 8d       	ldd	r24, Z+26	; 0x1a
    2622:	80 17       	cp	r24, r16
    2624:	30 f4       	brcc	.+12     	; 0x2632 <xTaskGenericCreate+0x1d4>
    2626:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
    262a:	81 e0       	ldi	r24, 0x01	; 1
    262c:	09 c0       	rjmp	.+18     	; 0x2640 <xTaskGenericCreate+0x1e2>
    262e:	81 e0       	ldi	r24, 0x01	; 1
    2630:	07 c0       	rjmp	.+14     	; 0x2640 <xTaskGenericCreate+0x1e2>
    2632:	81 e0       	ldi	r24, 0x01	; 1
    2634:	05 c0       	rjmp	.+10     	; 0x2640 <xTaskGenericCreate+0x1e2>
    2636:	cb 8e       	std	Y+27, r12	; 0x1b
    2638:	dc 8e       	std	Y+28, r13	; 0x1c
    263a:	c6 01       	movw	r24, r12
    263c:	3b cf       	rjmp	.-394    	; 0x24b4 <xTaskGenericCreate+0x56>
    263e:	8f ef       	ldi	r24, 0xFF	; 255
    2640:	df 91       	pop	r29
    2642:	cf 91       	pop	r28
    2644:	1f 91       	pop	r17
    2646:	0f 91       	pop	r16
    2648:	ff 90       	pop	r15
    264a:	ef 90       	pop	r14
    264c:	df 90       	pop	r13
    264e:	cf 90       	pop	r12
    2650:	bf 90       	pop	r11
    2652:	af 90       	pop	r10
    2654:	9f 90       	pop	r9
    2656:	8f 90       	pop	r8
    2658:	7f 90       	pop	r7
    265a:	6f 90       	pop	r6
    265c:	5f 90       	pop	r5
    265e:	4f 90       	pop	r4
    2660:	08 95       	ret

00002662 <uxTaskPriorityGet>:
    2662:	0f b6       	in	r0, 0x3f	; 63
    2664:	f8 94       	cli
    2666:	0f 92       	push	r0
    2668:	00 97       	sbiw	r24, 0x00	; 0
    266a:	21 f4       	brne	.+8      	; 0x2674 <uxTaskPriorityGet+0x12>
    266c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2670:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2674:	0f 90       	pop	r0
    2676:	0f be       	out	0x3f, r0	; 63
    2678:	fc 01       	movw	r30, r24
    267a:	82 8d       	ldd	r24, Z+26	; 0x1a
    267c:	08 95       	ret

0000267e <vTaskStartScheduler>:
    267e:	af 92       	push	r10
    2680:	bf 92       	push	r11
    2682:	cf 92       	push	r12
    2684:	df 92       	push	r13
    2686:	ef 92       	push	r14
    2688:	ff 92       	push	r15
    268a:	0f 93       	push	r16
    268c:	a1 2c       	mov	r10, r1
    268e:	b1 2c       	mov	r11, r1
    2690:	c1 2c       	mov	r12, r1
    2692:	d1 2c       	mov	r13, r1
    2694:	0f 2e       	mov	r0, r31
    2696:	f1 ed       	ldi	r31, 0xD1	; 209
    2698:	ef 2e       	mov	r14, r31
    269a:	f0 e3       	ldi	r31, 0x30	; 48
    269c:	ff 2e       	mov	r15, r31
    269e:	f0 2d       	mov	r31, r0
    26a0:	00 e0       	ldi	r16, 0x00	; 0
    26a2:	20 e0       	ldi	r18, 0x00	; 0
    26a4:	30 e0       	ldi	r19, 0x00	; 0
    26a6:	44 e6       	ldi	r20, 0x64	; 100
    26a8:	50 e0       	ldi	r21, 0x00	; 0
    26aa:	6a e3       	ldi	r22, 0x3A	; 58
    26ac:	70 e2       	ldi	r23, 0x20	; 32
    26ae:	89 ed       	ldi	r24, 0xD9	; 217
    26b0:	91 e1       	ldi	r25, 0x11	; 17
    26b2:	0e 94 2f 12 	call	0x245e	; 0x245e <xTaskGenericCreate>
    26b6:	81 30       	cpi	r24, 0x01	; 1
    26b8:	69 f4       	brne	.+26     	; 0x26d4 <vTaskStartScheduler+0x56>
    26ba:	f8 94       	cli
    26bc:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    26c0:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    26c4:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    26c8:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    26cc:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    26d0:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <xPortStartScheduler>
    26d4:	0f 91       	pop	r16
    26d6:	ff 90       	pop	r15
    26d8:	ef 90       	pop	r14
    26da:	df 90       	pop	r13
    26dc:	cf 90       	pop	r12
    26de:	bf 90       	pop	r11
    26e0:	af 90       	pop	r10
    26e2:	08 95       	ret

000026e4 <vTaskSuspendAll>:
    26e4:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    26e8:	8f 5f       	subi	r24, 0xFF	; 255
    26ea:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    26ee:	08 95       	ret

000026f0 <xTaskGetTickCount>:
    26f0:	0f b6       	in	r0, 0x3f	; 63
    26f2:	f8 94       	cli
    26f4:	0f 92       	push	r0
    26f6:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    26fa:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    26fe:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2702:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2706:	0f 90       	pop	r0
    2708:	0f be       	out	0x3f, r0	; 63
    270a:	08 95       	ret

0000270c <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    270c:	00 97       	sbiw	r24, 0x00	; 0
    270e:	21 f4       	brne	.+8      	; 0x2718 <pcTaskGetTaskName+0xc>
    2710:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2714:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    2718:	4d 96       	adiw	r24, 0x1d	; 29
    271a:	08 95       	ret

0000271c <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    271c:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    2720:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    2724:	08 95       	ret

00002726 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2726:	ff 92       	push	r15
    2728:	0f 93       	push	r16
    272a:	1f 93       	push	r17
    272c:	cf 93       	push	r28
    272e:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2730:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2734:	81 11       	cpse	r24, r1
    2736:	ed c0       	rjmp	.+474    	; 0x2912 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    2738:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    273c:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2740:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2744:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2748:	01 96       	adiw	r24, 0x01	; 1
    274a:	a1 1d       	adc	r26, r1
    274c:	b1 1d       	adc	r27, r1
    274e:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2752:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    2756:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    275a:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    275e:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2762:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2766:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    276a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    276e:	89 2b       	or	r24, r25
    2770:	8a 2b       	or	r24, r26
    2772:	8b 2b       	or	r24, r27
    2774:	f1 f5       	brne	.+124    	; 0x27f2 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2776:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    277a:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    277e:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2782:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    2786:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    278a:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    278e:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    2792:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2796:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    279a:	8f 5f       	subi	r24, 0xFF	; 255
    279c:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    27a0:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    27a4:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    27a8:	80 81       	ld	r24, Z
    27aa:	81 11       	cpse	r24, r1
    27ac:	0c c0       	rjmp	.+24     	; 0x27c6 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    27ae:	8f ef       	ldi	r24, 0xFF	; 255
    27b0:	9f ef       	ldi	r25, 0xFF	; 255
    27b2:	dc 01       	movw	r26, r24
    27b4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27b8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    27bc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27c0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    27c4:	16 c0       	rjmp	.+44     	; 0x27f2 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    27c6:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    27ca:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    27ce:	07 80       	ldd	r0, Z+7	; 0x07
    27d0:	f0 85       	ldd	r31, Z+8	; 0x08
    27d2:	e0 2d       	mov	r30, r0
    27d4:	00 84       	ldd	r0, Z+8	; 0x08
    27d6:	f1 85       	ldd	r31, Z+9	; 0x09
    27d8:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    27da:	82 81       	ldd	r24, Z+2	; 0x02
    27dc:	93 81       	ldd	r25, Z+3	; 0x03
    27de:	a4 81       	ldd	r26, Z+4	; 0x04
    27e0:	b5 81       	ldd	r27, Z+5	; 0x05
    27e2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27e6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    27ea:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27ee:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    27f2:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    27f6:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    27fa:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    27fe:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2802:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2806:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    280a:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    280e:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2812:	48 17       	cp	r20, r24
    2814:	59 07       	cpc	r21, r25
    2816:	6a 07       	cpc	r22, r26
    2818:	7b 07       	cpc	r23, r27
    281a:	08 f4       	brcc	.+2      	; 0x281e <vTaskIncrementTick+0xf8>
    281c:	7f c0       	rjmp	.+254    	; 0x291c <vTaskIncrementTick+0x1f6>
    281e:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2822:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2826:	80 81       	ld	r24, Z
    2828:	88 23       	and	r24, r24
    282a:	f9 f0       	breq	.+62     	; 0x286a <vTaskIncrementTick+0x144>
    282c:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2830:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2834:	07 80       	ldd	r0, Z+7	; 0x07
    2836:	f0 85       	ldd	r31, Z+8	; 0x08
    2838:	e0 2d       	mov	r30, r0
    283a:	c0 85       	ldd	r28, Z+8	; 0x08
    283c:	d1 85       	ldd	r29, Z+9	; 0x09
    283e:	8a 81       	ldd	r24, Y+2	; 0x02
    2840:	9b 81       	ldd	r25, Y+3	; 0x03
    2842:	ac 81       	ldd	r26, Y+4	; 0x04
    2844:	bd 81       	ldd	r27, Y+5	; 0x05
    2846:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    284a:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    284e:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2852:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2856:	48 17       	cp	r20, r24
    2858:	59 07       	cpc	r21, r25
    285a:	6a 07       	cpc	r22, r26
    285c:	7b 07       	cpc	r23, r27
    285e:	58 f1       	brcs	.+86     	; 0x28b6 <vTaskIncrementTick+0x190>
    2860:	0f 2e       	mov	r0, r31
    2862:	fb e0       	ldi	r31, 0x0B	; 11
    2864:	ff 2e       	mov	r15, r31
    2866:	f0 2d       	mov	r31, r0
    2868:	2f c0       	rjmp	.+94     	; 0x28c8 <vTaskIncrementTick+0x1a2>
    286a:	8f ef       	ldi	r24, 0xFF	; 255
    286c:	9f ef       	ldi	r25, 0xFF	; 255
    286e:	dc 01       	movw	r26, r24
    2870:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2874:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2878:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    287c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2880:	4d c0       	rjmp	.+154    	; 0x291c <vTaskIncrementTick+0x1f6>
    2882:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2886:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    288a:	07 80       	ldd	r0, Z+7	; 0x07
    288c:	f0 85       	ldd	r31, Z+8	; 0x08
    288e:	e0 2d       	mov	r30, r0
    2890:	c0 85       	ldd	r28, Z+8	; 0x08
    2892:	d1 85       	ldd	r29, Z+9	; 0x09
    2894:	8a 81       	ldd	r24, Y+2	; 0x02
    2896:	9b 81       	ldd	r25, Y+3	; 0x03
    2898:	ac 81       	ldd	r26, Y+4	; 0x04
    289a:	bd 81       	ldd	r27, Y+5	; 0x05
    289c:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    28a0:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    28a4:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    28a8:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    28ac:	48 17       	cp	r20, r24
    28ae:	59 07       	cpc	r21, r25
    28b0:	6a 07       	cpc	r22, r26
    28b2:	7b 07       	cpc	r23, r27
    28b4:	48 f4       	brcc	.+18     	; 0x28c8 <vTaskIncrementTick+0x1a2>
    28b6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    28ba:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    28be:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    28c2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    28c6:	2a c0       	rjmp	.+84     	; 0x291c <vTaskIncrementTick+0x1f6>
    28c8:	8e 01       	movw	r16, r28
    28ca:	0e 5f       	subi	r16, 0xFE	; 254
    28cc:	1f 4f       	sbci	r17, 0xFF	; 255
    28ce:	c8 01       	movw	r24, r16
    28d0:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>
    28d4:	88 8d       	ldd	r24, Y+24	; 0x18
    28d6:	99 8d       	ldd	r25, Y+25	; 0x19
    28d8:	89 2b       	or	r24, r25
    28da:	21 f0       	breq	.+8      	; 0x28e4 <vTaskIncrementTick+0x1be>
    28dc:	ce 01       	movw	r24, r28
    28de:	0e 96       	adiw	r24, 0x0e	; 14
    28e0:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>
    28e4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28e6:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    28ea:	98 17       	cp	r25, r24
    28ec:	10 f4       	brcc	.+4      	; 0x28f2 <vTaskIncrementTick+0x1cc>
    28ee:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    28f2:	f8 9e       	mul	r15, r24
    28f4:	c0 01       	movw	r24, r0
    28f6:	11 24       	eor	r1, r1
    28f8:	b8 01       	movw	r22, r16
    28fa:	88 50       	subi	r24, 0x08	; 8
    28fc:	9f 4c       	sbci	r25, 0xCF	; 207
    28fe:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vListInsertEnd>
    2902:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2906:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    290a:	80 81       	ld	r24, Z
    290c:	81 11       	cpse	r24, r1
    290e:	b9 cf       	rjmp	.-142    	; 0x2882 <vTaskIncrementTick+0x15c>
    2910:	ac cf       	rjmp	.-168    	; 0x286a <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    2912:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2916:	8f 5f       	subi	r24, 0xFF	; 255
    2918:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    291c:	df 91       	pop	r29
    291e:	cf 91       	pop	r28
    2920:	1f 91       	pop	r17
    2922:	0f 91       	pop	r16
    2924:	ff 90       	pop	r15
    2926:	08 95       	ret

00002928 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2928:	cf 92       	push	r12
    292a:	df 92       	push	r13
    292c:	ef 92       	push	r14
    292e:	ff 92       	push	r15
    2930:	0f 93       	push	r16
    2932:	1f 93       	push	r17
    2934:	cf 93       	push	r28
    2936:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2938:	0f b6       	in	r0, 0x3f	; 63
    293a:	f8 94       	cli
    293c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    293e:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2942:	81 50       	subi	r24, 0x01	; 1
    2944:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2948:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    294c:	81 11       	cpse	r24, r1
    294e:	60 c0       	rjmp	.+192    	; 0x2a10 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2950:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2954:	81 11       	cpse	r24, r1
    2956:	2c c0       	rjmp	.+88     	; 0x29b0 <xTaskResumeAll+0x88>
    2958:	5e c0       	rjmp	.+188    	; 0x2a16 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    295a:	d7 01       	movw	r26, r14
    295c:	17 96       	adiw	r26, 0x07	; 7
    295e:	ed 91       	ld	r30, X+
    2960:	fc 91       	ld	r31, X
    2962:	18 97       	sbiw	r26, 0x08	; 8
    2964:	c0 85       	ldd	r28, Z+8	; 0x08
    2966:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2968:	ce 01       	movw	r24, r28
    296a:	0e 96       	adiw	r24, 0x0e	; 14
    296c:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2970:	8e 01       	movw	r16, r28
    2972:	0e 5f       	subi	r16, 0xFE	; 254
    2974:	1f 4f       	sbci	r17, 0xFF	; 255
    2976:	c8 01       	movw	r24, r16
    2978:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    297c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    297e:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2982:	98 17       	cp	r25, r24
    2984:	10 f4       	brcc	.+4      	; 0x298a <xTaskResumeAll+0x62>
    2986:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    298a:	d8 9e       	mul	r13, r24
    298c:	c0 01       	movw	r24, r0
    298e:	11 24       	eor	r1, r1
    2990:	b8 01       	movw	r22, r16
    2992:	88 50       	subi	r24, 0x08	; 8
    2994:	9f 4c       	sbci	r25, 0xCF	; 207
    2996:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    299a:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    299e:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    29a2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    29a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    29a6:	98 17       	cp	r25, r24
    29a8:	70 f0       	brcs	.+28     	; 0x29c6 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    29aa:	cc 24       	eor	r12, r12
    29ac:	c3 94       	inc	r12
    29ae:	0b c0       	rjmp	.+22     	; 0x29c6 <xTaskResumeAll+0x9e>
    29b0:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    29b2:	0f 2e       	mov	r0, r31
    29b4:	f3 ed       	ldi	r31, 0xD3	; 211
    29b6:	ef 2e       	mov	r14, r31
    29b8:	f0 e3       	ldi	r31, 0x30	; 48
    29ba:	ff 2e       	mov	r15, r31
    29bc:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    29be:	0f 2e       	mov	r0, r31
    29c0:	fb e0       	ldi	r31, 0x0B	; 11
    29c2:	df 2e       	mov	r13, r31
    29c4:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    29c6:	f7 01       	movw	r30, r14
    29c8:	80 81       	ld	r24, Z
    29ca:	81 11       	cpse	r24, r1
    29cc:	c6 cf       	rjmp	.-116    	; 0x295a <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29ce:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    29d2:	88 23       	and	r24, r24
    29d4:	81 f0       	breq	.+32     	; 0x29f6 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29d6:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    29da:	88 23       	and	r24, r24
    29dc:	99 f0       	breq	.+38     	; 0x2a04 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    29de:	0e 94 93 13 	call	0x2726	; 0x2726 <vTaskIncrementTick>
						--uxMissedTicks;
    29e2:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    29e6:	81 50       	subi	r24, 0x01	; 1
    29e8:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29ec:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    29f0:	81 11       	cpse	r24, r1
    29f2:	f5 cf       	rjmp	.-22     	; 0x29de <xTaskResumeAll+0xb6>
    29f4:	07 c0       	rjmp	.+14     	; 0x2a04 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    29f6:	f1 e0       	ldi	r31, 0x01	; 1
    29f8:	cf 16       	cp	r12, r31
    29fa:	21 f0       	breq	.+8      	; 0x2a04 <xTaskResumeAll+0xdc>
    29fc:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    2a00:	81 30       	cpi	r24, 0x01	; 1
    2a02:	41 f4       	brne	.+16     	; 0x2a14 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2a04:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    2a08:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2a0c:	81 e0       	ldi	r24, 0x01	; 1
    2a0e:	03 c0       	rjmp	.+6      	; 0x2a16 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2a10:	80 e0       	ldi	r24, 0x00	; 0
    2a12:	01 c0       	rjmp	.+2      	; 0x2a16 <xTaskResumeAll+0xee>
    2a14:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2a16:	0f 90       	pop	r0
    2a18:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2a1a:	df 91       	pop	r29
    2a1c:	cf 91       	pop	r28
    2a1e:	1f 91       	pop	r17
    2a20:	0f 91       	pop	r16
    2a22:	ff 90       	pop	r15
    2a24:	ef 90       	pop	r14
    2a26:	df 90       	pop	r13
    2a28:	cf 90       	pop	r12
    2a2a:	08 95       	ret

00002a2c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2a2c:	cf 92       	push	r12
    2a2e:	df 92       	push	r13
    2a30:	ef 92       	push	r14
    2a32:	ff 92       	push	r15
    2a34:	cf 93       	push	r28
    2a36:	df 93       	push	r29
    2a38:	ec 01       	movw	r28, r24
    2a3a:	6a 01       	movw	r12, r20
    2a3c:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2a3e:	0e 94 72 13 	call	0x26e4	; 0x26e4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a42:	88 81       	ld	r24, Y
    2a44:	99 81       	ldd	r25, Y+1	; 0x01
    2a46:	aa 81       	ldd	r26, Y+2	; 0x02
    2a48:	bb 81       	ldd	r27, Y+3	; 0x03
    2a4a:	c8 0e       	add	r12, r24
    2a4c:	d9 1e       	adc	r13, r25
    2a4e:	ea 1e       	adc	r14, r26
    2a50:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2a52:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2a56:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2a5a:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2a5e:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2a62:	48 17       	cp	r20, r24
    2a64:	59 07       	cpc	r21, r25
    2a66:	6a 07       	cpc	r22, r26
    2a68:	7b 07       	cpc	r23, r27
    2a6a:	b8 f4       	brcc	.+46     	; 0x2a9a <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2a6c:	c8 16       	cp	r12, r24
    2a6e:	d9 06       	cpc	r13, r25
    2a70:	ea 06       	cpc	r14, r26
    2a72:	fb 06       	cpc	r15, r27
    2a74:	e0 f5       	brcc	.+120    	; 0x2aee <vTaskDelayUntil+0xc2>
    2a76:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2a7a:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2a7e:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2a82:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2a86:	c8 82       	st	Y, r12
    2a88:	d9 82       	std	Y+1, r13	; 0x01
    2a8a:	ea 82       	std	Y+2, r14	; 0x02
    2a8c:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2a8e:	8c 15       	cp	r24, r12
    2a90:	9d 05       	cpc	r25, r13
    2a92:	ae 05       	cpc	r26, r14
    2a94:	bf 05       	cpc	r27, r15
    2a96:	f8 f4       	brcc	.+62     	; 0x2ad6 <vTaskDelayUntil+0xaa>
    2a98:	13 c0       	rjmp	.+38     	; 0x2ac0 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2a9a:	c8 16       	cp	r12, r24
    2a9c:	d9 06       	cpc	r13, r25
    2a9e:	ea 06       	cpc	r14, r26
    2aa0:	fb 06       	cpc	r15, r27
    2aa2:	00 f1       	brcs	.+64     	; 0x2ae4 <vTaskDelayUntil+0xb8>
    2aa4:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2aa8:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2aac:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2ab0:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2ab4:	8c 15       	cp	r24, r12
    2ab6:	9d 05       	cpc	r25, r13
    2ab8:	ae 05       	cpc	r26, r14
    2aba:	bf 05       	cpc	r27, r15
    2abc:	98 f0       	brcs	.+38     	; 0x2ae4 <vTaskDelayUntil+0xb8>
    2abe:	17 c0       	rjmp	.+46     	; 0x2aee <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ac0:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2ac4:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2ac8:	02 96       	adiw	r24, 0x02	; 2
    2aca:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ace:	c7 01       	movw	r24, r14
    2ad0:	b6 01       	movw	r22, r12
    2ad2:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2ad6:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2ada:	81 11       	cpse	r24, r1
    2adc:	0d c0       	rjmp	.+26     	; 0x2af8 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2ade:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
		}
	}
    2ae2:	0a c0       	rjmp	.+20     	; 0x2af8 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2ae4:	c8 82       	st	Y, r12
    2ae6:	d9 82       	std	Y+1, r13	; 0x01
    2ae8:	ea 82       	std	Y+2, r14	; 0x02
    2aea:	fb 82       	std	Y+3, r15	; 0x03
    2aec:	e9 cf       	rjmp	.-46     	; 0x2ac0 <vTaskDelayUntil+0x94>
    2aee:	c8 82       	st	Y, r12
    2af0:	d9 82       	std	Y+1, r13	; 0x01
    2af2:	ea 82       	std	Y+2, r14	; 0x02
    2af4:	fb 82       	std	Y+3, r15	; 0x03
    2af6:	ef cf       	rjmp	.-34     	; 0x2ad6 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2af8:	df 91       	pop	r29
    2afa:	cf 91       	pop	r28
    2afc:	ff 90       	pop	r15
    2afe:	ef 90       	pop	r14
    2b00:	df 90       	pop	r13
    2b02:	cf 90       	pop	r12
    2b04:	08 95       	ret

00002b06 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2b06:	cf 92       	push	r12
    2b08:	df 92       	push	r13
    2b0a:	ef 92       	push	r14
    2b0c:	ff 92       	push	r15
    2b0e:	6b 01       	movw	r12, r22
    2b10:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2b12:	67 2b       	or	r22, r23
    2b14:	68 2b       	or	r22, r24
    2b16:	69 2b       	or	r22, r25
    2b18:	e9 f0       	breq	.+58     	; 0x2b54 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2b1a:	0e 94 72 13 	call	0x26e4	; 0x26e4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2b1e:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2b22:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2b26:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2b2a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2b2e:	c8 0e       	add	r12, r24
    2b30:	d9 1e       	adc	r13, r25
    2b32:	ea 1e       	adc	r14, r26
    2b34:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b36:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2b3a:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2b3e:	02 96       	adiw	r24, 0x02	; 2
    2b40:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b44:	c7 01       	movw	r24, r14
    2b46:	b6 01       	movw	r22, r12
    2b48:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b4c:	0e 94 94 14 	call	0x2928	; 0x2928 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b50:	81 11       	cpse	r24, r1
    2b52:	02 c0       	rjmp	.+4      	; 0x2b58 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2b54:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <vPortYield>
		}
	}
    2b58:	ff 90       	pop	r15
    2b5a:	ef 90       	pop	r14
    2b5c:	df 90       	pop	r13
    2b5e:	cf 90       	pop	r12
    2b60:	08 95       	ret

00002b62 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2b62:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2b66:	81 11       	cpse	r24, r1
    2b68:	0c c0       	rjmp	.+24     	; 0x2b82 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2b6a:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2b6e:	4b e0       	ldi	r20, 0x0B	; 11
    2b70:	e4 9f       	mul	r30, r20
    2b72:	f0 01       	movw	r30, r0
    2b74:	11 24       	eor	r1, r1
    2b76:	e8 50       	subi	r30, 0x08	; 8
    2b78:	ff 4c       	sbci	r31, 0xCF	; 207
    2b7a:	80 81       	ld	r24, Z
    2b7c:	88 23       	and	r24, r24
    2b7e:	29 f0       	breq	.+10     	; 0x2b8a <vTaskSwitchContext+0x28>
    2b80:	14 c0       	rjmp	.+40     	; 0x2baa <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2b82:	81 e0       	ldi	r24, 0x01	; 1
    2b84:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2b88:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2b8a:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2b8c:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2b90:	81 50       	subi	r24, 0x01	; 1
    2b92:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2b96:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2b9a:	9e 9f       	mul	r25, r30
    2b9c:	f0 01       	movw	r30, r0
    2b9e:	11 24       	eor	r1, r1
    2ba0:	e8 50       	subi	r30, 0x08	; 8
    2ba2:	ff 4c       	sbci	r31, 0xCF	; 207
    2ba4:	80 81       	ld	r24, Z
    2ba6:	88 23       	and	r24, r24
    2ba8:	89 f3       	breq	.-30     	; 0x2b8c <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2baa:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2bae:	28 2f       	mov	r18, r24
    2bb0:	30 e0       	ldi	r19, 0x00	; 0
    2bb2:	4b e0       	ldi	r20, 0x0B	; 11
    2bb4:	84 9f       	mul	r24, r20
    2bb6:	c0 01       	movw	r24, r0
    2bb8:	11 24       	eor	r1, r1
    2bba:	dc 01       	movw	r26, r24
    2bbc:	a8 50       	subi	r26, 0x08	; 8
    2bbe:	bf 4c       	sbci	r27, 0xCF	; 207
    2bc0:	11 96       	adiw	r26, 0x01	; 1
    2bc2:	ed 91       	ld	r30, X+
    2bc4:	fc 91       	ld	r31, X
    2bc6:	12 97       	sbiw	r26, 0x02	; 2
    2bc8:	04 80       	ldd	r0, Z+4	; 0x04
    2bca:	f5 81       	ldd	r31, Z+5	; 0x05
    2bcc:	e0 2d       	mov	r30, r0
    2bce:	11 96       	adiw	r26, 0x01	; 1
    2bd0:	ed 93       	st	X+, r30
    2bd2:	fc 93       	st	X, r31
    2bd4:	12 97       	sbiw	r26, 0x02	; 2
    2bd6:	85 50       	subi	r24, 0x05	; 5
    2bd8:	9f 4c       	sbci	r25, 0xCF	; 207
    2bda:	e8 17       	cp	r30, r24
    2bdc:	f9 07       	cpc	r31, r25
    2bde:	61 f4       	brne	.+24     	; 0x2bf8 <vTaskSwitchContext+0x96>
    2be0:	84 81       	ldd	r24, Z+4	; 0x04
    2be2:	95 81       	ldd	r25, Z+5	; 0x05
    2be4:	4b e0       	ldi	r20, 0x0B	; 11
    2be6:	42 9f       	mul	r20, r18
    2be8:	f0 01       	movw	r30, r0
    2bea:	43 9f       	mul	r20, r19
    2bec:	f0 0d       	add	r31, r0
    2bee:	11 24       	eor	r1, r1
    2bf0:	e8 50       	subi	r30, 0x08	; 8
    2bf2:	ff 4c       	sbci	r31, 0xCF	; 207
    2bf4:	81 83       	std	Z+1, r24	; 0x01
    2bf6:	92 83       	std	Z+2, r25	; 0x02
    2bf8:	8b e0       	ldi	r24, 0x0B	; 11
    2bfa:	82 9f       	mul	r24, r18
    2bfc:	f0 01       	movw	r30, r0
    2bfe:	83 9f       	mul	r24, r19
    2c00:	f0 0d       	add	r31, r0
    2c02:	11 24       	eor	r1, r1
    2c04:	e8 50       	subi	r30, 0x08	; 8
    2c06:	ff 4c       	sbci	r31, 0xCF	; 207
    2c08:	01 80       	ldd	r0, Z+1	; 0x01
    2c0a:	f2 81       	ldd	r31, Z+2	; 0x02
    2c0c:	e0 2d       	mov	r30, r0
    2c0e:	80 85       	ldd	r24, Z+8	; 0x08
    2c10:	91 85       	ldd	r25, Z+9	; 0x09
    2c12:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    2c16:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    2c1a:	08 95       	ret

00002c1c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2c1c:	cf 92       	push	r12
    2c1e:	df 92       	push	r13
    2c20:	ef 92       	push	r14
    2c22:	ff 92       	push	r15
    2c24:	6a 01       	movw	r12, r20
    2c26:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2c28:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2c2c:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2c30:	62 5f       	subi	r22, 0xF2	; 242
    2c32:	7f 4f       	sbci	r23, 0xFF	; 255
    2c34:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c38:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2c3c:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2c40:	02 96       	adiw	r24, 0x02	; 2
    2c42:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2c46:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2c4a:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2c4e:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2c52:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2c56:	bc 01       	movw	r22, r24
    2c58:	cd 01       	movw	r24, r26
    2c5a:	6c 0d       	add	r22, r12
    2c5c:	7d 1d       	adc	r23, r13
    2c5e:	8e 1d       	adc	r24, r14
    2c60:	9f 1d       	adc	r25, r15
    2c62:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2c66:	ff 90       	pop	r15
    2c68:	ef 90       	pop	r14
    2c6a:	df 90       	pop	r13
    2c6c:	cf 90       	pop	r12
    2c6e:	08 95       	ret

00002c70 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2c70:	0f 93       	push	r16
    2c72:	1f 93       	push	r17
    2c74:	cf 93       	push	r28
    2c76:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2c78:	dc 01       	movw	r26, r24
    2c7a:	17 96       	adiw	r26, 0x07	; 7
    2c7c:	ed 91       	ld	r30, X+
    2c7e:	fc 91       	ld	r31, X
    2c80:	18 97       	sbiw	r26, 0x08	; 8
    2c82:	c0 85       	ldd	r28, Z+8	; 0x08
    2c84:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2c86:	8e 01       	movw	r16, r28
    2c88:	02 5f       	subi	r16, 0xF2	; 242
    2c8a:	1f 4f       	sbci	r17, 0xFF	; 255
    2c8c:	c8 01       	movw	r24, r16
    2c8e:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2c92:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2c96:	81 11       	cpse	r24, r1
    2c98:	16 c0       	rjmp	.+44     	; 0x2cc6 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2c9a:	0c 50       	subi	r16, 0x0C	; 12
    2c9c:	11 09       	sbc	r17, r1
    2c9e:	c8 01       	movw	r24, r16
    2ca0:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2ca4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ca6:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2caa:	98 17       	cp	r25, r24
    2cac:	10 f4       	brcc	.+4      	; 0x2cb2 <xTaskRemoveFromEventList+0x42>
    2cae:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2cb2:	bb e0       	ldi	r27, 0x0B	; 11
    2cb4:	8b 9f       	mul	r24, r27
    2cb6:	c0 01       	movw	r24, r0
    2cb8:	11 24       	eor	r1, r1
    2cba:	b8 01       	movw	r22, r16
    2cbc:	88 50       	subi	r24, 0x08	; 8
    2cbe:	9f 4c       	sbci	r25, 0xCF	; 207
    2cc0:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vListInsertEnd>
    2cc4:	05 c0       	rjmp	.+10     	; 0x2cd0 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2cc6:	b8 01       	movw	r22, r16
    2cc8:	83 ed       	ldi	r24, 0xD3	; 211
    2cca:	90 e3       	ldi	r25, 0x30	; 48
    2ccc:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2cd0:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2cd4:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2cd8:	81 e0       	ldi	r24, 0x01	; 1
    2cda:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2cdc:	92 8d       	ldd	r25, Z+26	; 0x1a
    2cde:	29 17       	cp	r18, r25
    2ce0:	08 f4       	brcc	.+2      	; 0x2ce4 <xTaskRemoveFromEventList+0x74>
    2ce2:	80 e0       	ldi	r24, 0x00	; 0
}
    2ce4:	df 91       	pop	r29
    2ce6:	cf 91       	pop	r28
    2ce8:	1f 91       	pop	r17
    2cea:	0f 91       	pop	r16
    2cec:	08 95       	ret

00002cee <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2cee:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2cf2:	fc 01       	movw	r30, r24
    2cf4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2cf6:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2cfa:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2cfe:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d02:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2d06:	41 83       	std	Z+1, r20	; 0x01
    2d08:	52 83       	std	Z+2, r21	; 0x02
    2d0a:	63 83       	std	Z+3, r22	; 0x03
    2d0c:	74 83       	std	Z+4, r23	; 0x04
    2d0e:	08 95       	ret

00002d10 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2d10:	8f 92       	push	r8
    2d12:	9f 92       	push	r9
    2d14:	af 92       	push	r10
    2d16:	bf 92       	push	r11
    2d18:	cf 92       	push	r12
    2d1a:	df 92       	push	r13
    2d1c:	ef 92       	push	r14
    2d1e:	ff 92       	push	r15
    2d20:	0f 93       	push	r16
    2d22:	1f 93       	push	r17
    2d24:	cf 93       	push	r28
    2d26:	df 93       	push	r29
    2d28:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2d2a:	0f b6       	in	r0, 0x3f	; 63
    2d2c:	f8 94       	cli
    2d2e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2d30:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2d34:	90 81       	ld	r25, Z
    2d36:	98 17       	cp	r25, r24
    2d38:	89 f0       	breq	.+34     	; 0x2d5c <xTaskCheckForTimeOut+0x4c>
    2d3a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2d3e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2d42:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d46:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2d4a:	01 81       	ldd	r16, Z+1	; 0x01
    2d4c:	12 81       	ldd	r17, Z+2	; 0x02
    2d4e:	23 81       	ldd	r18, Z+3	; 0x03
    2d50:	34 81       	ldd	r19, Z+4	; 0x04
    2d52:	80 17       	cp	r24, r16
    2d54:	91 07       	cpc	r25, r17
    2d56:	a2 07       	cpc	r26, r18
    2d58:	b3 07       	cpc	r27, r19
    2d5a:	a8 f5       	brcc	.+106    	; 0x2dc6 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2d5c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2d60:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2d64:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d68:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2d6c:	c1 80       	ldd	r12, Z+1	; 0x01
    2d6e:	d2 80       	ldd	r13, Z+2	; 0x02
    2d70:	e3 80       	ldd	r14, Z+3	; 0x03
    2d72:	f4 80       	ldd	r15, Z+4	; 0x04
    2d74:	eb 01       	movw	r28, r22
    2d76:	08 81       	ld	r16, Y
    2d78:	19 81       	ldd	r17, Y+1	; 0x01
    2d7a:	2a 81       	ldd	r18, Y+2	; 0x02
    2d7c:	3b 81       	ldd	r19, Y+3	; 0x03
    2d7e:	8c 19       	sub	r24, r12
    2d80:	9d 09       	sbc	r25, r13
    2d82:	ae 09       	sbc	r26, r14
    2d84:	bf 09       	sbc	r27, r15
    2d86:	80 17       	cp	r24, r16
    2d88:	91 07       	cpc	r25, r17
    2d8a:	a2 07       	cpc	r26, r18
    2d8c:	b3 07       	cpc	r27, r19
    2d8e:	e8 f4       	brcc	.+58     	; 0x2dca <xTaskCheckForTimeOut+0xba>
    2d90:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2d92:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    2d96:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2d9a:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d9e:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2da2:	b5 01       	movw	r22, r10
    2da4:	a4 01       	movw	r20, r8
    2da6:	4c 19       	sub	r20, r12
    2da8:	5d 09       	sbc	r21, r13
    2daa:	6e 09       	sbc	r22, r14
    2dac:	7f 09       	sbc	r23, r15
    2dae:	04 1b       	sub	r16, r20
    2db0:	15 0b       	sbc	r17, r21
    2db2:	26 0b       	sbc	r18, r22
    2db4:	37 0b       	sbc	r19, r23
    2db6:	08 83       	st	Y, r16
    2db8:	19 83       	std	Y+1, r17	; 0x01
    2dba:	2a 83       	std	Y+2, r18	; 0x02
    2dbc:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2dbe:	0e 94 77 16 	call	0x2cee	; 0x2cee <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2dc2:	80 e0       	ldi	r24, 0x00	; 0
    2dc4:	03 c0       	rjmp	.+6      	; 0x2dcc <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2dc6:	81 e0       	ldi	r24, 0x01	; 1
    2dc8:	01 c0       	rjmp	.+2      	; 0x2dcc <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2dca:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2dcc:	0f 90       	pop	r0
    2dce:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2dd0:	df 91       	pop	r29
    2dd2:	cf 91       	pop	r28
    2dd4:	1f 91       	pop	r17
    2dd6:	0f 91       	pop	r16
    2dd8:	ff 90       	pop	r15
    2dda:	ef 90       	pop	r14
    2ddc:	df 90       	pop	r13
    2dde:	cf 90       	pop	r12
    2de0:	bf 90       	pop	r11
    2de2:	af 90       	pop	r10
    2de4:	9f 90       	pop	r9
    2de6:	8f 90       	pop	r8
    2de8:	08 95       	ret

00002dea <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2dea:	81 e0       	ldi	r24, 0x01	; 1
    2dec:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2df0:	08 95       	ret

00002df2 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2df2:	00 97       	sbiw	r24, 0x00	; 0
    2df4:	21 f4       	brne	.+8      	; 0x2dfe <uxTaskGetStackHighWaterMark+0xc>
    2df6:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2dfa:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2dfe:	dc 01       	movw	r26, r24
    2e00:	5b 96       	adiw	r26, 0x1b	; 27
    2e02:	ed 91       	ld	r30, X+
    2e04:	fc 91       	ld	r31, X
    2e06:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e08:	80 81       	ld	r24, Z
    2e0a:	81 31       	cpi	r24, 0x11	; 17
    2e0c:	41 f4       	brne	.+16     	; 0x2e1e <uxTaskGetStackHighWaterMark+0x2c>
    2e0e:	31 96       	adiw	r30, 0x01	; 1
    2e10:	80 e0       	ldi	r24, 0x00	; 0
    2e12:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2e14:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e16:	21 91       	ld	r18, Z+
    2e18:	21 31       	cpi	r18, 0x11	; 17
    2e1a:	e1 f3       	breq	.-8      	; 0x2e14 <uxTaskGetStackHighWaterMark+0x22>
    2e1c:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2e1e:	80 e0       	ldi	r24, 0x00	; 0
    2e20:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2e22:	08 95       	ret

00002e24 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2e24:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2e28:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2e2c:	08 95       	ret

00002e2e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2e2e:	0f 93       	push	r16
    2e30:	1f 93       	push	r17
    2e32:	cf 93       	push	r28
    2e34:	df 93       	push	r29
    2e36:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2e38:	22 8d       	ldd	r18, Z+26	; 0x1a
    2e3a:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2e3e:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2e42:	5a 96       	adiw	r26, 0x1a	; 26
    2e44:	8c 91       	ld	r24, X
    2e46:	28 17       	cp	r18, r24
    2e48:	08 f0       	brcs	.+2      	; 0x2e4c <vTaskPriorityInherit+0x1e>
    2e4a:	41 c0       	rjmp	.+130    	; 0x2ece <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2e4c:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2e50:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2e54:	5a 96       	adiw	r26, 0x1a	; 26
    2e56:	3c 91       	ld	r19, X
    2e58:	84 e0       	ldi	r24, 0x04	; 4
    2e5a:	90 e0       	ldi	r25, 0x00	; 0
    2e5c:	a0 e0       	ldi	r26, 0x00	; 0
    2e5e:	b0 e0       	ldi	r27, 0x00	; 0
    2e60:	83 1b       	sub	r24, r19
    2e62:	91 09       	sbc	r25, r1
    2e64:	a1 09       	sbc	r26, r1
    2e66:	b1 09       	sbc	r27, r1
    2e68:	86 87       	std	Z+14, r24	; 0x0e
    2e6a:	97 87       	std	Z+15, r25	; 0x0f
    2e6c:	a0 8b       	std	Z+16, r26	; 0x10
    2e6e:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2e70:	8b e0       	ldi	r24, 0x0B	; 11
    2e72:	28 9f       	mul	r18, r24
    2e74:	90 01       	movw	r18, r0
    2e76:	11 24       	eor	r1, r1
    2e78:	28 50       	subi	r18, 0x08	; 8
    2e7a:	3f 4c       	sbci	r19, 0xCF	; 207
    2e7c:	84 85       	ldd	r24, Z+12	; 0x0c
    2e7e:	95 85       	ldd	r25, Z+13	; 0x0d
    2e80:	82 17       	cp	r24, r18
    2e82:	93 07       	cpc	r25, r19
    2e84:	e9 f4       	brne	.+58     	; 0x2ec0 <vTaskPriorityInherit+0x92>
    2e86:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2e88:	ef 01       	movw	r28, r30
    2e8a:	22 96       	adiw	r28, 0x02	; 2
    2e8c:	ce 01       	movw	r24, r28
    2e8e:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2e92:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2e96:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2e9a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e9c:	f8 01       	movw	r30, r16
    2e9e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2ea0:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2ea4:	98 17       	cp	r25, r24
    2ea6:	10 f4       	brcc	.+4      	; 0x2eac <vTaskPriorityInherit+0x7e>
    2ea8:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2eac:	fb e0       	ldi	r31, 0x0B	; 11
    2eae:	8f 9f       	mul	r24, r31
    2eb0:	c0 01       	movw	r24, r0
    2eb2:	11 24       	eor	r1, r1
    2eb4:	be 01       	movw	r22, r28
    2eb6:	88 50       	subi	r24, 0x08	; 8
    2eb8:	9f 4c       	sbci	r25, 0xCF	; 207
    2eba:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vListInsertEnd>
    2ebe:	07 c0       	rjmp	.+14     	; 0x2ece <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2ec0:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2ec4:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2ec8:	5a 96       	adiw	r26, 0x1a	; 26
    2eca:	8c 91       	ld	r24, X
    2ecc:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2ece:	df 91       	pop	r29
    2ed0:	cf 91       	pop	r28
    2ed2:	1f 91       	pop	r17
    2ed4:	0f 91       	pop	r16
    2ed6:	08 95       	ret

00002ed8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2ed8:	0f 93       	push	r16
    2eda:	1f 93       	push	r17
    2edc:	cf 93       	push	r28
    2ede:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2ee0:	00 97       	sbiw	r24, 0x00	; 0
    2ee2:	49 f1       	breq	.+82     	; 0x2f36 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2ee4:	fc 01       	movw	r30, r24
    2ee6:	32 8d       	ldd	r19, Z+26	; 0x1a
    2ee8:	27 a1       	ldd	r18, Z+39	; 0x27
    2eea:	32 17       	cp	r19, r18
    2eec:	21 f1       	breq	.+72     	; 0x2f36 <vTaskPriorityDisinherit+0x5e>
    2eee:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2ef0:	8c 01       	movw	r16, r24
    2ef2:	0e 5f       	subi	r16, 0xFE	; 254
    2ef4:	1f 4f       	sbci	r17, 0xFF	; 255
    2ef6:	c8 01       	movw	r24, r16
    2ef8:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2efc:	8f a1       	ldd	r24, Y+39	; 0x27
    2efe:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2f00:	44 e0       	ldi	r20, 0x04	; 4
    2f02:	50 e0       	ldi	r21, 0x00	; 0
    2f04:	60 e0       	ldi	r22, 0x00	; 0
    2f06:	70 e0       	ldi	r23, 0x00	; 0
    2f08:	48 1b       	sub	r20, r24
    2f0a:	51 09       	sbc	r21, r1
    2f0c:	61 09       	sbc	r22, r1
    2f0e:	71 09       	sbc	r23, r1
    2f10:	4e 87       	std	Y+14, r20	; 0x0e
    2f12:	5f 87       	std	Y+15, r21	; 0x0f
    2f14:	68 8b       	std	Y+16, r22	; 0x10
    2f16:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2f18:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2f1c:	98 17       	cp	r25, r24
    2f1e:	10 f4       	brcc	.+4      	; 0x2f24 <vTaskPriorityDisinherit+0x4c>
    2f20:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2f24:	fb e0       	ldi	r31, 0x0B	; 11
    2f26:	8f 9f       	mul	r24, r31
    2f28:	c0 01       	movw	r24, r0
    2f2a:	11 24       	eor	r1, r1
    2f2c:	b8 01       	movw	r22, r16
    2f2e:	88 50       	subi	r24, 0x08	; 8
    2f30:	9f 4c       	sbci	r25, 0xCF	; 207
    2f32:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vListInsertEnd>
			}
		}
	}
    2f36:	df 91       	pop	r29
    2f38:	cf 91       	pop	r28
    2f3a:	1f 91       	pop	r17
    2f3c:	0f 91       	pop	r16
    2f3e:	08 95       	ret

00002f40 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2f40:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2f42:	e8 81       	ld	r30, Y
    2f44:	f9 81       	ldd	r31, Y+1	; 0x01
    2f46:	01 90       	ld	r0, Z+
    2f48:	f0 81       	ld	r31, Z
    2f4a:	e0 2d       	mov	r30, r0
    2f4c:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2f4e:	1a 82       	std	Y+2, r1	; 0x02
    2f50:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2f52:	6f ef       	ldi	r22, 0xFF	; 255
    2f54:	7f ef       	ldi	r23, 0xFF	; 255
    2f56:	cb 01       	movw	r24, r22
    2f58:	0e 94 83 15 	call	0x2b06	; 0x2b06 <vTaskDelay>
    2f5c:	fa cf       	rjmp	.-12     	; 0x2f52 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002f5e <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2f5e:	fc 01       	movw	r30, r24
    2f60:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2f62:	65 87       	std	Z+13, r22	; 0x0d
    2f64:	08 95       	ret

00002f66 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2f66:	4f 92       	push	r4
    2f68:	5f 92       	push	r5
    2f6a:	6f 92       	push	r6
    2f6c:	7f 92       	push	r7
    2f6e:	8f 92       	push	r8
    2f70:	9f 92       	push	r9
    2f72:	af 92       	push	r10
    2f74:	bf 92       	push	r11
    2f76:	cf 92       	push	r12
    2f78:	df 92       	push	r13
    2f7a:	ef 92       	push	r14
    2f7c:	ff 92       	push	r15
    2f7e:	0f 93       	push	r16
    2f80:	1f 93       	push	r17
    2f82:	cf 93       	push	r28
    2f84:	df 93       	push	r29
    2f86:	cd b7       	in	r28, 0x3d	; 61
    2f88:	de b7       	in	r29, 0x3e	; 62
    2f8a:	2a 97       	sbiw	r28, 0x0a	; 10
    2f8c:	cd bf       	out	0x3d, r28	; 61
    2f8e:	de bf       	out	0x3e, r29	; 62
    2f90:	4c 01       	movw	r8, r24
    2f92:	29 01       	movw	r4, r18
    2f94:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2f96:	83 e4       	ldi	r24, 0x43	; 67
    2f98:	90 e2       	ldi	r25, 0x20	; 32
    2f9a:	f4 01       	movw	r30, r8
    2f9c:	80 83       	st	Z, r24
    2f9e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2fa0:	fb 01       	movw	r30, r22
    2fa2:	80 81       	ld	r24, Z
    2fa4:	88 23       	and	r24, r24
    2fa6:	69 f0       	breq	.+26     	; 0x2fc2 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2fa8:	de 01       	movw	r26, r28
    2faa:	11 96       	adiw	r26, 0x01	; 1
    2fac:	31 96       	adiw	r30, 0x01	; 1
    2fae:	90 e0       	ldi	r25, 0x00	; 0
    2fb0:	02 c0       	rjmp	.+4      	; 0x2fb6 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2fb2:	99 30       	cpi	r25, 0x09	; 9
    2fb4:	39 f0       	breq	.+14     	; 0x2fc4 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2fb6:	9f 5f       	subi	r25, 0xFF	; 255
    2fb8:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2fba:	81 91       	ld	r24, Z+
    2fbc:	81 11       	cpse	r24, r1
    2fbe:	f9 cf       	rjmp	.-14     	; 0x2fb2 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2fc0:	01 c0       	rjmp	.+2      	; 0x2fc4 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2fc4:	e1 e0       	ldi	r30, 0x01	; 1
    2fc6:	f0 e0       	ldi	r31, 0x00	; 0
    2fc8:	ec 0f       	add	r30, r28
    2fca:	fd 1f       	adc	r31, r29
    2fcc:	e9 0f       	add	r30, r25
    2fce:	f1 1d       	adc	r31, r1
    2fd0:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2fd2:	74 01       	movw	r14, r8
    2fd4:	f2 e0       	ldi	r31, 0x02	; 2
    2fd6:	ef 0e       	add	r14, r31
    2fd8:	f1 1c       	adc	r15, r1
    2fda:	a1 2c       	mov	r10, r1
    2fdc:	b1 2c       	mov	r11, r1
    2fde:	c1 2c       	mov	r12, r1
    2fe0:	d1 2c       	mov	r13, r1
    2fe2:	04 2f       	mov	r16, r20
    2fe4:	94 01       	movw	r18, r8
    2fe6:	a2 01       	movw	r20, r4
    2fe8:	be 01       	movw	r22, r28
    2fea:	6f 5f       	subi	r22, 0xFF	; 255
    2fec:	7f 4f       	sbci	r23, 0xFF	; 255
    2fee:	82 e9       	ldi	r24, 0x92	; 146
    2ff0:	93 e0       	ldi	r25, 0x03	; 3
    2ff2:	0e 94 2f 12 	call	0x245e	; 0x245e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2ff6:	f4 01       	movw	r30, r8
    2ff8:	66 82       	std	Z+6, r6	; 0x06
    2ffa:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2ffc:	40 86       	std	Z+8, r4	; 0x08
    2ffe:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    3000:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    3004:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    3008:	24 83       	std	Z+4, r18	; 0x04
    300a:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    300c:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    3010:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    3014:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    3016:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    3018:	40 90 64 31 	lds	r4, 0x3164	; 0x803164 <portStackTopForTask>
    301c:	50 90 65 31 	lds	r5, 0x3165	; 0x803165 <portStackTopForTask+0x1>
    3020:	ff ef       	ldi	r31, 0xFF	; 255
    3022:	4f 1a       	sub	r4, r31
    3024:	5f 0a       	sbc	r5, r31
    3026:	40 92 64 31 	sts	0x3164, r4	; 0x803164 <portStackTopForTask>
    302a:	50 92 65 31 	sts	0x3165, r5	; 0x803165 <portStackTopForTask+0x1>
    302e:	f4 01       	movw	r30, r8
    3030:	42 86       	std	Z+10, r4	; 0x0a
    3032:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    3034:	16 86       	std	Z+14, r1	; 0x0e
    3036:	17 86       	std	Z+15, r1	; 0x0f
    3038:	10 8a       	std	Z+16, r1	; 0x10
    303a:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    303c:	61 14       	cp	r6, r1
    303e:	71 04       	cpc	r7, r1
    3040:	09 f4       	brne	.+2      	; 0x3044 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3042:	44 c0       	rjmp	.+136    	; 0x30cc <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    3044:	81 30       	cpi	r24, 0x01	; 1
    3046:	79 f5       	brne	.+94     	; 0x30a6 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    3048:	6a e0       	ldi	r22, 0x0A	; 10
    304a:	c3 01       	movw	r24, r6
    304c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3050:	7c 01       	movw	r14, r24
    3052:	60 e7       	ldi	r22, 0x70	; 112
    3054:	76 e0       	ldi	r23, 0x06	; 6
    3056:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    305a:	be 01       	movw	r22, r28
    305c:	6f 5f       	subi	r22, 0xFF	; 255
    305e:	7f 4f       	sbci	r23, 0xFF	; 255
    3060:	c7 01       	movw	r24, r14
    3062:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    3066:	6a e0       	ldi	r22, 0x0A	; 10
    3068:	c7 01       	movw	r24, r14
    306a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    306e:	7c 01       	movw	r14, r24
    3070:	67 e6       	ldi	r22, 0x67	; 103
    3072:	76 e0       	ldi	r23, 0x06	; 6
    3074:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    3078:	6a e0       	ldi	r22, 0x0A	; 10
    307a:	c7 01       	movw	r24, r14
    307c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3080:	7c 01       	movw	r14, r24
    3082:	69 e5       	ldi	r22, 0x59	; 89
    3084:	76 e0       	ldi	r23, 0x06	; 6
    3086:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    308a:	63 e0       	ldi	r22, 0x03	; 3
    308c:	c7 01       	movw	r24, r14
    308e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3092:	b2 01       	movw	r22, r4
    3094:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <_ZN8emstreamlsEj>
    3098:	62 e0       	ldi	r22, 0x02	; 2
    309a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    309e:	66 e0       	ldi	r22, 0x06	; 6
    30a0:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    30a4:	13 c0       	rjmp	.+38     	; 0x30cc <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    30a6:	6a e0       	ldi	r22, 0x0A	; 10
    30a8:	c3 01       	movw	r24, r6
    30aa:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    30ae:	4c 01       	movw	r8, r24
    30b0:	64 e4       	ldi	r22, 0x44	; 68
    30b2:	76 e0       	ldi	r23, 0x06	; 6
    30b4:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    30b8:	be 01       	movw	r22, r28
    30ba:	6f 5f       	subi	r22, 0xFF	; 255
    30bc:	7f 4f       	sbci	r23, 0xFF	; 255
    30be:	c4 01       	movw	r24, r8
    30c0:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    30c4:	66 e0       	ldi	r22, 0x06	; 6
    30c6:	c4 01       	movw	r24, r8
    30c8:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    30cc:	2a 96       	adiw	r28, 0x0a	; 10
    30ce:	cd bf       	out	0x3d, r28	; 61
    30d0:	de bf       	out	0x3e, r29	; 62
    30d2:	df 91       	pop	r29
    30d4:	cf 91       	pop	r28
    30d6:	1f 91       	pop	r17
    30d8:	0f 91       	pop	r16
    30da:	ff 90       	pop	r15
    30dc:	ef 90       	pop	r14
    30de:	df 90       	pop	r13
    30e0:	cf 90       	pop	r12
    30e2:	bf 90       	pop	r11
    30e4:	af 90       	pop	r10
    30e6:	9f 90       	pop	r9
    30e8:	8f 90       	pop	r8
    30ea:	7f 90       	pop	r7
    30ec:	6f 90       	pop	r6
    30ee:	5f 90       	pop	r5
    30f0:	4f 90       	pop	r4
    30f2:	08 95       	ret

000030f4 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    30f4:	cf 92       	push	r12
    30f6:	df 92       	push	r13
    30f8:	ef 92       	push	r14
    30fa:	ff 92       	push	r15
    30fc:	0f 93       	push	r16
    30fe:	1f 93       	push	r17
    3100:	cf 93       	push	r28
    3102:	df 93       	push	r29
    3104:	ec 01       	movw	r28, r24
    3106:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    3108:	8a 81       	ldd	r24, Y+2	; 0x02
    310a:	9b 81       	ldd	r25, Y+3	; 0x03
    310c:	0e 94 86 13 	call	0x270c	; 0x270c <pcTaskGetTaskName>
    3110:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3112:	6a e0       	ldi	r22, 0x0A	; 10
    3114:	c7 01       	movw	r24, r14
    3116:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    311a:	8c 01       	movw	r16, r24
    311c:	63 e8       	ldi	r22, 0x83	; 131
    311e:	76 e0       	ldi	r23, 0x06	; 6
    3120:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    3124:	6a e0       	ldi	r22, 0x0A	; 10
    3126:	c8 01       	movw	r24, r16
    3128:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    312c:	8c 01       	movw	r16, r24
    312e:	6c e7       	ldi	r22, 0x7C	; 124
    3130:	76 e0       	ldi	r23, 0x06	; 6
    3132:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    3136:	b6 01       	movw	r22, r12
    3138:	c8 01       	movw	r24, r16
    313a:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    313e:	6a e0       	ldi	r22, 0x0A	; 10
    3140:	c8 01       	movw	r24, r16
    3142:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3146:	8c 01       	movw	r16, r24
    3148:	66 e7       	ldi	r22, 0x76	; 118
    314a:	76 e0       	ldi	r23, 0x06	; 6
    314c:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    3150:	66 e0       	ldi	r22, 0x06	; 6
    3152:	c8 01       	movw	r24, r16
    3154:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    3158:	8a 85       	ldd	r24, Y+10	; 0x0a
    315a:	9b 85       	ldd	r25, Y+11	; 0x0b
    315c:	e8 85       	ldd	r30, Y+8	; 0x08
    315e:	f9 85       	ldd	r31, Y+9	; 0x09
    3160:	01 e1       	ldi	r16, 0x11	; 17
    3162:	21 e0       	ldi	r18, 0x01	; 1
    3164:	a7 01       	movw	r20, r14
    3166:	bc 01       	movw	r22, r24
    3168:	8e 1b       	sub	r24, r30
    316a:	9f 0b       	sbc	r25, r31
    316c:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    3170:	8c 81       	ldd	r24, Y+4	; 0x04
    3172:	9d 81       	ldd	r25, Y+5	; 0x05
    3174:	00 97       	sbiw	r24, 0x00	; 0
    3176:	19 f0       	breq	.+6      	; 0x317e <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    3178:	b7 01       	movw	r22, r14
    317a:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    317e:	df 91       	pop	r29
    3180:	cf 91       	pop	r28
    3182:	1f 91       	pop	r17
    3184:	0f 91       	pop	r16
    3186:	ff 90       	pop	r15
    3188:	ef 90       	pop	r14
    318a:	df 90       	pop	r13
    318c:	cf 90       	pop	r12
    318e:	08 95       	ret

00003190 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3190:	0f 93       	push	r16
    3192:	1f 93       	push	r17
    3194:	cf 93       	push	r28
    3196:	df 93       	push	r29
    3198:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    319a:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    319e:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    31a2:	00 97       	sbiw	r24, 0x00	; 0
    31a4:	19 f0       	breq	.+6      	; 0x31ac <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    31a6:	be 01       	movw	r22, r28
    31a8:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    31ac:	6a e0       	ldi	r22, 0x0A	; 10
    31ae:	ce 01       	movw	r24, r28
    31b0:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    31b4:	8c 01       	movw	r16, r24
    31b6:	69 e9       	ldi	r22, 0x99	; 153
    31b8:	76 e0       	ldi	r23, 0x06	; 6
    31ba:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    31be:	6a e0       	ldi	r22, 0x0A	; 10
    31c0:	c8 01       	movw	r24, r16
    31c2:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    31c6:	8c 01       	movw	r16, r24
    31c8:	6e e8       	ldi	r22, 0x8E	; 142
    31ca:	76 e0       	ldi	r23, 0x06	; 6
    31cc:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    31d0:	6a e0       	ldi	r22, 0x0A	; 10
    31d2:	c8 01       	movw	r24, r16
    31d4:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    31d8:	8c 01       	movw	r16, r24
    31da:	68 e8       	ldi	r22, 0x88	; 136
    31dc:	76 e0       	ldi	r23, 0x06	; 6
    31de:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    31e2:	66 e0       	ldi	r22, 0x06	; 6
    31e4:	c8 01       	movw	r24, r16
    31e6:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    31ea:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <portStackTopForTask>
    31ee:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <portStackTopForTask+0x1>
    31f2:	bc 01       	movw	r22, r24
    31f4:	6f 5f       	subi	r22, 0xFF	; 255
    31f6:	7f 4f       	sbci	r23, 0xFF	; 255
    31f8:	01 e1       	ldi	r16, 0x11	; 17
    31fa:	21 e0       	ldi	r18, 0x01	; 1
    31fc:	ae 01       	movw	r20, r28
    31fe:	83 56       	subi	r24, 0x63	; 99
    3200:	91 09       	sbc	r25, r1
    3202:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    3206:	df 91       	pop	r29
    3208:	cf 91       	pop	r28
    320a:	1f 91       	pop	r17
    320c:	0f 91       	pop	r16
    320e:	08 95       	ret

00003210 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3210:	8f 92       	push	r8
    3212:	9f 92       	push	r9
    3214:	af 92       	push	r10
    3216:	bf 92       	push	r11
    3218:	cf 92       	push	r12
    321a:	df 92       	push	r13
    321c:	ef 92       	push	r14
    321e:	ff 92       	push	r15
    3220:	0f 93       	push	r16
    3222:	1f 93       	push	r17
    3224:	cf 93       	push	r28
    3226:	df 93       	push	r29
    3228:	ec 01       	movw	r28, r24
    322a:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    322c:	8a 81       	ldd	r24, Y+2	; 0x02
    322e:	9b 81       	ldd	r25, Y+3	; 0x03
    3230:	0e 94 86 13 	call	0x270c	; 0x270c <pcTaskGetTaskName>
    3234:	bc 01       	movw	r22, r24
    3236:	c8 01       	movw	r24, r16
    3238:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    323c:	d8 01       	movw	r26, r16
    323e:	ed 91       	ld	r30, X+
    3240:	fc 91       	ld	r31, X
    3242:	02 80       	ldd	r0, Z+2	; 0x02
    3244:	f3 81       	ldd	r31, Z+3	; 0x03
    3246:	e0 2d       	mov	r30, r0
    3248:	69 e0       	ldi	r22, 0x09	; 9
    324a:	c8 01       	movw	r24, r16
    324c:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    324e:	8a 81       	ldd	r24, Y+2	; 0x02
    3250:	9b 81       	ldd	r25, Y+3	; 0x03
    3252:	0e 94 86 13 	call	0x270c	; 0x270c <pcTaskGetTaskName>
    3256:	fc 01       	movw	r30, r24
    3258:	01 90       	ld	r0, Z+
    325a:	00 20       	and	r0, r0
    325c:	e9 f7       	brne	.-6      	; 0x3258 <_ZN8frt_task12print_statusER8emstream+0x48>
    325e:	31 97       	sbiw	r30, 0x01	; 1
    3260:	e8 1b       	sub	r30, r24
    3262:	f9 0b       	sbc	r31, r25
    3264:	38 97       	sbiw	r30, 0x08	; 8
    3266:	48 f4       	brcc	.+18     	; 0x327a <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    3268:	d8 01       	movw	r26, r16
    326a:	ed 91       	ld	r30, X+
    326c:	fc 91       	ld	r31, X
    326e:	02 80       	ldd	r0, Z+2	; 0x02
    3270:	f3 81       	ldd	r31, Z+3	; 0x03
    3272:	e0 2d       	mov	r30, r0
    3274:	69 e0       	ldi	r22, 0x09	; 9
    3276:	c8 01       	movw	r24, r16
    3278:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    327a:	ce 84       	ldd	r12, Y+14	; 0x0e
    327c:	df 84       	ldd	r13, Y+15	; 0x0f
    327e:	e8 88       	ldd	r14, Y+16	; 0x10
    3280:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    3282:	a8 84       	ldd	r10, Y+8	; 0x08
    3284:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3286:	8a 81       	ldd	r24, Y+2	; 0x02
    3288:	9b 81       	ldd	r25, Y+3	; 0x03
    328a:	0e 94 f9 16 	call	0x2df2	; 0x2df2 <uxTaskGetStackHighWaterMark>
    328e:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3290:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3292:	8a 81       	ldd	r24, Y+2	; 0x02
    3294:	9b 81       	ldd	r25, Y+3	; 0x03
    3296:	0e 94 31 13 	call	0x2662	; 0x2662 <uxTaskPriorityGet>
    329a:	68 2f       	mov	r22, r24
    329c:	c8 01       	movw	r24, r16
    329e:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
    32a2:	6a e0       	ldi	r22, 0x0A	; 10
    32a4:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    32a8:	ec 01       	movw	r28, r24
    32aa:	6e e0       	ldi	r22, 0x0E	; 14
    32ac:	77 e0       	ldi	r23, 0x07	; 7
    32ae:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
			<< get_state ()
    32b2:	68 2d       	mov	r22, r8
    32b4:	ce 01       	movw	r24, r28
    32b6:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    32ba:	6a e0       	ldi	r22, 0x0A	; 10
    32bc:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    32c0:	ec 01       	movw	r28, r24
    32c2:	6c e0       	ldi	r22, 0x0C	; 12
    32c4:	77 e0       	ldi	r23, 0x07	; 7
    32c6:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    32ca:	69 2d       	mov	r22, r9
    32cc:	ce 01       	movw	r24, r28
    32ce:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
    32d2:	6a e0       	ldi	r22, 0x0A	; 10
    32d4:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    32d8:	ec 01       	movw	r28, r24
    32da:	6a e0       	ldi	r22, 0x0A	; 10
    32dc:	77 e0       	ldi	r23, 0x07	; 7
    32de:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    32e2:	b5 01       	movw	r22, r10
    32e4:	ce 01       	movw	r24, r28
    32e6:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <_ZN8emstreamlsEj>
    32ea:	6a e0       	ldi	r22, 0x0A	; 10
    32ec:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    32f0:	ec 01       	movw	r28, r24
    32f2:	68 e0       	ldi	r22, 0x08	; 8
    32f4:	77 e0       	ldi	r23, 0x07	; 7
    32f6:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    32fa:	6a e0       	ldi	r22, 0x0A	; 10
    32fc:	ce 01       	movw	r24, r28
    32fe:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3302:	ec 01       	movw	r28, r24
    3304:	66 e0       	ldi	r22, 0x06	; 6
    3306:	77 e0       	ldi	r23, 0x07	; 7
    3308:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    330c:	b7 01       	movw	r22, r14
    330e:	a6 01       	movw	r20, r12
    3310:	ce 01       	movw	r24, r28
    3312:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <_ZN8emstreamlsEm>
}
    3316:	df 91       	pop	r29
    3318:	cf 91       	pop	r28
    331a:	1f 91       	pop	r17
    331c:	0f 91       	pop	r16
    331e:	ff 90       	pop	r15
    3320:	ef 90       	pop	r14
    3322:	df 90       	pop	r13
    3324:	cf 90       	pop	r12
    3326:	bf 90       	pop	r11
    3328:	af 90       	pop	r10
    332a:	9f 90       	pop	r9
    332c:	8f 90       	pop	r8
    332e:	08 95       	ret

00003330 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3330:	cf 93       	push	r28
    3332:	df 93       	push	r29
    3334:	ec 01       	movw	r28, r24
    3336:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    3338:	db 01       	movw	r26, r22
    333a:	ed 91       	ld	r30, X+
    333c:	fc 91       	ld	r31, X
    333e:	02 80       	ldd	r0, Z+2	; 0x02
    3340:	f3 81       	ldd	r31, Z+3	; 0x03
    3342:	e0 2d       	mov	r30, r0
    3344:	be 01       	movw	r22, r28
    3346:	19 95       	eicall
	return (ser_dev);
}
    3348:	ce 01       	movw	r24, r28
    334a:	df 91       	pop	r29
    334c:	cf 91       	pop	r28
    334e:	08 95       	ret

00003350 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3350:	0f 93       	push	r16
    3352:	1f 93       	push	r17
    3354:	cf 93       	push	r28
    3356:	df 93       	push	r29
    3358:	ec 01       	movw	r28, r24
    335a:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    335c:	bc 01       	movw	r22, r24
    335e:	c8 01       	movw	r24, r16
    3360:	0e 94 98 19 	call	0x3330	; 0x3330 <_ZlsR8emstreamR8frt_task>
    3364:	66 e0       	ldi	r22, 0x06	; 6
    3366:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    336a:	8c 81       	ldd	r24, Y+4	; 0x04
    336c:	9d 81       	ldd	r25, Y+5	; 0x05
    336e:	00 97       	sbiw	r24, 0x00	; 0
    3370:	19 f0       	breq	.+6      	; 0x3378 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3372:	b8 01       	movw	r22, r16
    3374:	0e 94 a8 19 	call	0x3350	; 0x3350 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    3378:	df 91       	pop	r29
    337a:	cf 91       	pop	r28
    337c:	1f 91       	pop	r17
    337e:	0f 91       	pop	r16
    3380:	08 95       	ret

00003382 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    3382:	0f 93       	push	r16
    3384:	1f 93       	push	r17
    3386:	cf 93       	push	r28
    3388:	df 93       	push	r29
    338a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    338c:	6a e0       	ldi	r22, 0x0A	; 10
    338e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3392:	8c 01       	movw	r16, r24
    3394:	6b ef       	ldi	r22, 0xFB	; 251
    3396:	76 e0       	ldi	r23, 0x06	; 6
    3398:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    339c:	6a e0       	ldi	r22, 0x0A	; 10
    339e:	c8 01       	movw	r24, r16
    33a0:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    33a4:	8c 01       	movw	r16, r24
    33a6:	64 ef       	ldi	r22, 0xF4	; 244
    33a8:	76 e0       	ldi	r23, 0x06	; 6
    33aa:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    33ae:	66 e0       	ldi	r22, 0x06	; 6
    33b0:	c8 01       	movw	r24, r16
    33b2:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    33b6:	6a e0       	ldi	r22, 0x0A	; 10
    33b8:	ce 01       	movw	r24, r28
    33ba:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    33be:	8c 01       	movw	r16, r24
    33c0:	63 ee       	ldi	r22, 0xE3	; 227
    33c2:	76 e0       	ldi	r23, 0x06	; 6
    33c4:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    33c8:	6a e0       	ldi	r22, 0x0A	; 10
    33ca:	c8 01       	movw	r24, r16
    33cc:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    33d0:	8c 01       	movw	r16, r24
    33d2:	67 ed       	ldi	r22, 0xD7	; 215
    33d4:	76 e0       	ldi	r23, 0x06	; 6
    33d6:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    33da:	6a e0       	ldi	r22, 0x0A	; 10
    33dc:	c8 01       	movw	r24, r16
    33de:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    33e2:	8c 01       	movw	r16, r24
    33e4:	61 ed       	ldi	r22, 0xD1	; 209
    33e6:	76 e0       	ldi	r23, 0x06	; 6
    33e8:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    33ec:	66 e0       	ldi	r22, 0x06	; 6
    33ee:	c8 01       	movw	r24, r16
    33f0:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    33f4:	6a e0       	ldi	r22, 0x0A	; 10
    33f6:	ce 01       	movw	r24, r28
    33f8:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    33fc:	8c 01       	movw	r16, r24
    33fe:	60 ec       	ldi	r22, 0xC0	; 192
    3400:	76 e0       	ldi	r23, 0x06	; 6
    3402:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    3406:	6a e0       	ldi	r22, 0x0A	; 10
    3408:	c8 01       	movw	r24, r16
    340a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    340e:	8c 01       	movw	r16, r24
    3410:	64 eb       	ldi	r22, 0xB4	; 180
    3412:	76 e0       	ldi	r23, 0x06	; 6
    3414:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    3418:	6a e0       	ldi	r22, 0x0A	; 10
    341a:	c8 01       	movw	r24, r16
    341c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3420:	8c 01       	movw	r16, r24
    3422:	6e ea       	ldi	r22, 0xAE	; 174
    3424:	76 e0       	ldi	r23, 0x06	; 6
    3426:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    342a:	66 e0       	ldi	r22, 0x06	; 6
    342c:	c8 01       	movw	r24, r16
    342e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3432:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    3436:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    343a:	00 97       	sbiw	r24, 0x00	; 0
    343c:	19 f0       	breq	.+6      	; 0x3444 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    343e:	be 01       	movw	r22, r28
    3440:	0e 94 a8 19 	call	0x3350	; 0x3350 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3444:	0e 94 8e 13 	call	0x271c	; 0x271c <xTaskGetIdleTaskHandle>
    3448:	0e 94 f9 16 	call	0x2df2	; 0x2df2 <uxTaskGetStackHighWaterMark>
    344c:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    344e:	6a e0       	ldi	r22, 0x0A	; 10
    3450:	ce 01       	movw	r24, r28
    3452:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3456:	ec 01       	movw	r28, r24
    3458:	63 ea       	ldi	r22, 0xA3	; 163
    345a:	76 e0       	ldi	r23, 0x06	; 6
    345c:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3460:	61 2f       	mov	r22, r17
    3462:	ce 01       	movw	r24, r28
    3464:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    3468:	6a e0       	ldi	r22, 0x0A	; 10
    346a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    346e:	ec 01       	movw	r28, r24
    3470:	61 ea       	ldi	r22, 0xA1	; 161
    3472:	76 e0       	ldi	r23, 0x06	; 6
    3474:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    3478:	64 e6       	ldi	r22, 0x64	; 100
    347a:	70 e0       	ldi	r23, 0x00	; 0
    347c:	ce 01       	movw	r24, r28
    347e:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <_ZN8emstreamlsEj>
    3482:	6a e0       	ldi	r22, 0x0A	; 10
    3484:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3488:	ec 01       	movw	r28, r24
    348a:	6e e9       	ldi	r22, 0x9E	; 158
    348c:	76 e0       	ldi	r23, 0x06	; 6
    348e:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3492:	66 e0       	ldi	r22, 0x06	; 6
    3494:	ce 01       	movw	r24, r28
    3496:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
}
    349a:	df 91       	pop	r29
    349c:	cf 91       	pop	r28
    349e:	1f 91       	pop	r17
    34a0:	0f 91       	pop	r16
    34a2:	08 95       	ret

000034a4 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    34a4:	0f 93       	push	r16
    34a6:	cf 93       	push	r28
    34a8:	df 93       	push	r29
    34aa:	1f 92       	push	r1
    34ac:	cd b7       	in	r28, 0x3d	; 61
    34ae:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    34b0:	00 e0       	ldi	r16, 0x00	; 0
    34b2:	2f ef       	ldi	r18, 0xFF	; 255
    34b4:	3f ef       	ldi	r19, 0xFF	; 255
    34b6:	a9 01       	movw	r20, r18
    34b8:	be 01       	movw	r22, r28
    34ba:	6f 5f       	subi	r22, 0xFF	; 255
    34bc:	7f 4f       	sbci	r23, 0xFF	; 255
    34be:	fc 01       	movw	r30, r24
    34c0:	80 85       	ldd	r24, Z+8	; 0x08
    34c2:	91 85       	ldd	r25, Z+9	; 0x09
    34c4:	0e 94 0d 11 	call	0x221a	; 0x221a <xQueueGenericReceive>
    34c8:	81 30       	cpi	r24, 0x01	; 1
    34ca:	19 f4       	brne	.+6      	; 0x34d2 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    34cc:	89 81       	ldd	r24, Y+1	; 0x01
    34ce:	90 e0       	ldi	r25, 0x00	; 0
    34d0:	02 c0       	rjmp	.+4      	; 0x34d6 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    34d2:	8f ef       	ldi	r24, 0xFF	; 255
    34d4:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    34d6:	0f 90       	pop	r0
    34d8:	df 91       	pop	r29
    34da:	cf 91       	pop	r28
    34dc:	0f 91       	pop	r16
    34de:	08 95       	ret

000034e0 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    34e0:	fc 01       	movw	r30, r24
    34e2:	80 85       	ldd	r24, Z+8	; 0x08
    34e4:	91 85       	ldd	r25, Z+9	; 0x09
    34e6:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <uxQueueMessagesWaiting>
    34ea:	91 e0       	ldi	r25, 0x01	; 1
    34ec:	81 11       	cpse	r24, r1
    34ee:	01 c0       	rjmp	.+2      	; 0x34f2 <_ZN14frt_text_queue14check_for_charEv+0x12>
    34f0:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    34f2:	89 2f       	mov	r24, r25
    34f4:	08 95       	ret

000034f6 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    34f6:	0f 93       	push	r16
    34f8:	cf 93       	push	r28
    34fa:	df 93       	push	r29
    34fc:	1f 92       	push	r1
    34fe:	cd b7       	in	r28, 0x3d	; 61
    3500:	de b7       	in	r29, 0x3e	; 62
    3502:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3504:	fc 01       	movw	r30, r24
    3506:	22 85       	ldd	r18, Z+10	; 0x0a
    3508:	33 85       	ldd	r19, Z+11	; 0x0b
    350a:	44 85       	ldd	r20, Z+12	; 0x0c
    350c:	55 85       	ldd	r21, Z+13	; 0x0d
    350e:	00 e0       	ldi	r16, 0x00	; 0
    3510:	be 01       	movw	r22, r28
    3512:	6f 5f       	subi	r22, 0xFF	; 255
    3514:	7f 4f       	sbci	r23, 0xFF	; 255
    3516:	80 85       	ldd	r24, Z+8	; 0x08
    3518:	91 85       	ldd	r25, Z+9	; 0x09
    351a:	0e 94 72 10 	call	0x20e4	; 0x20e4 <xQueueGenericSend>
    351e:	91 e0       	ldi	r25, 0x01	; 1
    3520:	81 11       	cpse	r24, r1
    3522:	01 c0       	rjmp	.+2      	; 0x3526 <_ZN14frt_text_queue7putcharEc+0x30>
    3524:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    3526:	89 2f       	mov	r24, r25
    3528:	0f 90       	pop	r0
    352a:	df 91       	pop	r29
    352c:	cf 91       	pop	r28
    352e:	0f 91       	pop	r16
    3530:	08 95       	ret

00003532 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3532:	8f 92       	push	r8
    3534:	9f 92       	push	r9
    3536:	bf 92       	push	r11
    3538:	cf 92       	push	r12
    353a:	df 92       	push	r13
    353c:	ef 92       	push	r14
    353e:	ff 92       	push	r15
    3540:	0f 93       	push	r16
    3542:	1f 93       	push	r17
    3544:	cf 93       	push	r28
    3546:	df 93       	push	r29
    3548:	ec 01       	movw	r28, r24
    354a:	b6 2e       	mov	r11, r22
    354c:	4a 01       	movw	r8, r20
    354e:	68 01       	movw	r12, r16
    3550:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3552:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <_ZN8emstreamC1Ev>
    3556:	8b e4       	ldi	r24, 0x4B	; 75
    3558:	90 e2       	ldi	r25, 0x20	; 32
    355a:	88 83       	st	Y, r24
    355c:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    355e:	8e 86       	std	Y+14, r8	; 0x0e
    3560:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3562:	40 e0       	ldi	r20, 0x00	; 0
    3564:	61 e0       	ldi	r22, 0x01	; 1
    3566:	8b 2d       	mov	r24, r11
    3568:	0e 94 44 10 	call	0x2088	; 0x2088 <xQueueGenericCreate>
    356c:	88 87       	std	Y+8, r24	; 0x08
    356e:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3570:	ca 86       	std	Y+10, r12	; 0x0a
    3572:	db 86       	std	Y+11, r13	; 0x0b
    3574:	ec 86       	std	Y+12, r14	; 0x0c
    3576:	fd 86       	std	Y+13, r15	; 0x0d
}
    3578:	df 91       	pop	r29
    357a:	cf 91       	pop	r28
    357c:	1f 91       	pop	r17
    357e:	0f 91       	pop	r16
    3580:	ff 90       	pop	r15
    3582:	ef 90       	pop	r14
    3584:	df 90       	pop	r13
    3586:	cf 90       	pop	r12
    3588:	bf 90       	pop	r11
    358a:	9f 90       	pop	r9
    358c:	8f 90       	pop	r8
    358e:	08 95       	ret

00003590 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3590:	cf 92       	push	r12
    3592:	df 92       	push	r13
    3594:	ef 92       	push	r14
    3596:	ff 92       	push	r15
    3598:	cf 93       	push	r28
    359a:	df 93       	push	r29
    359c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    359e:	68 81       	ld	r22, Y
    35a0:	79 81       	ldd	r23, Y+1	; 0x01
    35a2:	8a 81       	ldd	r24, Y+2	; 0x02
    35a4:	9b 81       	ldd	r25, Y+3	; 0x03
    35a6:	0f 2e       	mov	r0, r31
    35a8:	f8 ee       	ldi	r31, 0xE8	; 232
    35aa:	cf 2e       	mov	r12, r31
    35ac:	f3 e0       	ldi	r31, 0x03	; 3
    35ae:	df 2e       	mov	r13, r31
    35b0:	e1 2c       	mov	r14, r1
    35b2:	f1 2c       	mov	r15, r1
    35b4:	f0 2d       	mov	r31, r0
    35b6:	a7 01       	movw	r20, r14
    35b8:	96 01       	movw	r18, r12
    35ba:	0e 94 55 22 	call	0x44aa	; 0x44aa <__udivmodsi4>
    35be:	9b 01       	movw	r18, r22
    35c0:	ac 01       	movw	r20, r24
    35c2:	60 e4       	ldi	r22, 0x40	; 64
    35c4:	72 e4       	ldi	r23, 0x42	; 66
    35c6:	8f e0       	ldi	r24, 0x0F	; 15
    35c8:	90 e0       	ldi	r25, 0x00	; 0
    35ca:	0e 94 31 22 	call	0x4462	; 0x4462 <__mulsi3>
    35ce:	a7 01       	movw	r20, r14
    35d0:	96 01       	movw	r18, r12
    35d2:	0e 94 55 22 	call	0x44aa	; 0x44aa <__udivmodsi4>
    35d6:	69 01       	movw	r12, r18
    35d8:	7a 01       	movw	r14, r20
    35da:	ac 81       	ldd	r26, Y+4	; 0x04
    35dc:	bd 81       	ldd	r27, Y+5	; 0x05
    35de:	20 e4       	ldi	r18, 0x40	; 64
    35e0:	32 e4       	ldi	r19, 0x42	; 66
    35e2:	4f e0       	ldi	r20, 0x0F	; 15
    35e4:	50 e0       	ldi	r21, 0x00	; 0
    35e6:	0e 94 bd 22 	call	0x457a	; 0x457a <__muluhisi3>
    35ea:	20 e0       	ldi	r18, 0x00	; 0
    35ec:	38 e4       	ldi	r19, 0x48	; 72
    35ee:	48 ee       	ldi	r20, 0xE8	; 232
    35f0:	51 e0       	ldi	r21, 0x01	; 1
    35f2:	0e 94 55 22 	call	0x44aa	; 0x44aa <__udivmodsi4>
    35f6:	c7 01       	movw	r24, r14
    35f8:	b6 01       	movw	r22, r12
    35fa:	62 0f       	add	r22, r18
    35fc:	73 1f       	adc	r23, r19
    35fe:	84 1f       	adc	r24, r20
    3600:	95 1f       	adc	r25, r21
}
    3602:	df 91       	pop	r29
    3604:	cf 91       	pop	r28
    3606:	ff 90       	pop	r15
    3608:	ef 90       	pop	r14
    360a:	df 90       	pop	r13
    360c:	cf 90       	pop	r12
    360e:	08 95       	ret

00003610 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3610:	cf 92       	push	r12
    3612:	df 92       	push	r13
    3614:	ef 92       	push	r14
    3616:	ff 92       	push	r15
    3618:	0f 93       	push	r16
    361a:	1f 93       	push	r17
    361c:	cf 93       	push	r28
    361e:	df 93       	push	r29
    3620:	cd b7       	in	r28, 0x3d	; 61
    3622:	de b7       	in	r29, 0x3e	; 62
    3624:	2f 97       	sbiw	r28, 0x0f	; 15
    3626:	cd bf       	out	0x3d, r28	; 61
    3628:	de bf       	out	0x3e, r29	; 62
    362a:	6c 01       	movw	r12, r24
    362c:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    362e:	db 01       	movw	r26, r22
    3630:	6d 91       	ld	r22, X+
    3632:	7d 91       	ld	r23, X+
    3634:	8d 91       	ld	r24, X+
    3636:	9c 91       	ld	r25, X
    3638:	28 ee       	ldi	r18, 0xE8	; 232
    363a:	33 e0       	ldi	r19, 0x03	; 3
    363c:	40 e0       	ldi	r20, 0x00	; 0
    363e:	50 e0       	ldi	r21, 0x00	; 0
    3640:	0e 94 55 22 	call	0x44aa	; 0x44aa <__udivmodsi4>
    3644:	ba 01       	movw	r22, r20
    3646:	a9 01       	movw	r20, r18
    3648:	c6 01       	movw	r24, r12
    364a:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    364e:	d6 01       	movw	r26, r12
    3650:	ed 91       	ld	r30, X+
    3652:	fc 91       	ld	r31, X
    3654:	02 80       	ldd	r0, Z+2	; 0x02
    3656:	f3 81       	ldd	r31, Z+3	; 0x03
    3658:	e0 2d       	mov	r30, r0
    365a:	6e e2       	ldi	r22, 0x2E	; 46
    365c:	c6 01       	movw	r24, r12
    365e:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3660:	c8 01       	movw	r24, r16
    3662:	0e 94 c8 1a 	call	0x3590	; 0x3590 <_ZN10time_stamp12get_microsecEv>
    3666:	8e 01       	movw	r16, r28
    3668:	09 5f       	subi	r16, 0xF9	; 249
    366a:	1f 4f       	sbci	r17, 0xFF	; 255
    366c:	fe 01       	movw	r30, r28
    366e:	31 96       	adiw	r30, 0x01	; 1
    3670:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3672:	2a e0       	ldi	r18, 0x0A	; 10
    3674:	30 e0       	ldi	r19, 0x00	; 0
    3676:	40 e0       	ldi	r20, 0x00	; 0
    3678:	50 e0       	ldi	r21, 0x00	; 0
    367a:	0e 94 77 22 	call	0x44ee	; 0x44ee <__divmodsi4>
    367e:	e6 2f       	mov	r30, r22
    3680:	28 87       	std	Y+8, r18	; 0x08
    3682:	39 87       	std	Y+9, r19	; 0x09
    3684:	4a 87       	std	Y+10, r20	; 0x0a
    3686:	5b 87       	std	Y+11, r21	; 0x0b
    3688:	68 85       	ldd	r22, Y+8	; 0x08
    368a:	79 85       	ldd	r23, Y+9	; 0x09
    368c:	8a 85       	ldd	r24, Y+10	; 0x0a
    368e:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3690:	20 e3       	ldi	r18, 0x30	; 48
    3692:	2e 0f       	add	r18, r30
    3694:	d8 01       	movw	r26, r16
    3696:	2e 93       	st	-X, r18
    3698:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    369a:	ae 15       	cp	r26, r14
    369c:	bf 05       	cpc	r27, r15
    369e:	49 f7       	brne	.-46     	; 0x3672 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    36a0:	1f 82       	std	Y+7, r1	; 0x07
    36a2:	be 01       	movw	r22, r28
    36a4:	6f 5f       	subi	r22, 0xFF	; 255
    36a6:	7f 4f       	sbci	r23, 0xFF	; 255
    36a8:	c6 01       	movw	r24, r12
    36aa:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    36ae:	c6 01       	movw	r24, r12
    36b0:	2f 96       	adiw	r28, 0x0f	; 15
    36b2:	cd bf       	out	0x3d, r28	; 61
    36b4:	de bf       	out	0x3e, r29	; 62
    36b6:	df 91       	pop	r29
    36b8:	cf 91       	pop	r28
    36ba:	1f 91       	pop	r17
    36bc:	0f 91       	pop	r16
    36be:	ff 90       	pop	r15
    36c0:	ef 90       	pop	r14
    36c2:	df 90       	pop	r13
    36c4:	cf 90       	pop	r12
    36c6:	08 95       	ret

000036c8 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    36c8:	cf 93       	push	r28
    36ca:	df 93       	push	r29
    36cc:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    36ce:	0f b6       	in	r0, 0x3f	; 63
    36d0:	f8 94       	cli
    36d2:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    36d4:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    36d8:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    36dc:	8c 83       	std	Y+4, r24	; 0x04
    36de:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    36e0:	0e 94 78 13 	call	0x26f0	; 0x26f0 <xTaskGetTickCount>
    36e4:	68 83       	st	Y, r22
    36e6:	79 83       	std	Y+1, r23	; 0x01
    36e8:	8a 83       	std	Y+2, r24	; 0x02
    36ea:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    36ec:	0f 90       	pop	r0
    36ee:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    36f0:	ce 01       	movw	r24, r28
    36f2:	df 91       	pop	r29
    36f4:	cf 91       	pop	r28
    36f6:	08 95       	ret

000036f8 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    36f8:	5f 92       	push	r5
    36fa:	6f 92       	push	r6
    36fc:	7f 92       	push	r7
    36fe:	8f 92       	push	r8
    3700:	9f 92       	push	r9
    3702:	af 92       	push	r10
    3704:	bf 92       	push	r11
    3706:	cf 92       	push	r12
    3708:	df 92       	push	r13
    370a:	ef 92       	push	r14
    370c:	ff 92       	push	r15
    370e:	0f 93       	push	r16
    3710:	1f 93       	push	r17
    3712:	cf 93       	push	r28
    3714:	df 93       	push	r29
    3716:	5c 01       	movw	r10, r24
    3718:	4b 01       	movw	r8, r22
    371a:	7a 01       	movw	r14, r20
    371c:	12 2f       	mov	r17, r18
    371e:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3720:	63 e0       	ldi	r22, 0x03	; 3
    3722:	ca 01       	movw	r24, r20
    3724:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3728:	a8 14       	cp	r10, r8
    372a:	b9 04       	cpc	r11, r9
    372c:	08 f0       	brcs	.+2      	; 0x3730 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    372e:	7d c0       	rjmp	.+250    	; 0x382a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3730:	65 01       	movw	r12, r10
    3732:	84 e1       	ldi	r24, 0x14	; 20
    3734:	c8 0e       	add	r12, r24
    3736:	d1 1c       	adc	r13, r1
    3738:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    373a:	6a 2c       	mov	r6, r10
    373c:	5b 2c       	mov	r5, r11
    373e:	b5 01       	movw	r22, r10
    3740:	c7 01       	movw	r24, r14
    3742:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <_ZN8emstreamlsEj>
    3746:	6a e0       	ldi	r22, 0x0A	; 10
    3748:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    374c:	60 e2       	ldi	r22, 0x20	; 32
    374e:	77 e0       	ldi	r23, 0x07	; 7
    3750:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3754:	11 23       	and	r17, r17
    3756:	09 f4       	brne	.+2      	; 0x375a <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3758:	6d c0       	rjmp	.+218    	; 0x3834 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    375a:	00 23       	and	r16, r16
    375c:	09 f4       	brne	.+2      	; 0x3760 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    375e:	6a c0       	rjmp	.+212    	; 0x3834 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3760:	6a e0       	ldi	r22, 0x0A	; 10
    3762:	c7 01       	movw	r24, r14
    3764:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3768:	6b e1       	ldi	r22, 0x1B	; 27
    376a:	77 e0       	ldi	r23, 0x07	; 7
    376c:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    3770:	61 c0       	rjmp	.+194    	; 0x3834 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3772:	11 23       	and	r17, r17
    3774:	71 f0       	breq	.+28     	; 0x3792 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3776:	01 11       	cpse	r16, r1
    3778:	0c c0       	rjmp	.+24     	; 0x3792 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    377a:	88 81       	ld	r24, Y
    377c:	87 15       	cp	r24, r7
    377e:	49 f0       	breq	.+18     	; 0x3792 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3780:	6a e0       	ldi	r22, 0x0A	; 10
    3782:	c7 01       	movw	r24, r14
    3784:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    3788:	66 e1       	ldi	r22, 0x16	; 22
    378a:	77 e0       	ldi	r23, 0x07	; 7
    378c:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3790:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3792:	69 91       	ld	r22, Y+
    3794:	c7 01       	movw	r24, r14
    3796:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    379a:	dc 01       	movw	r26, r24
    379c:	ed 91       	ld	r30, X+
    379e:	fc 91       	ld	r31, X
    37a0:	02 80       	ldd	r0, Z+2	; 0x02
    37a2:	f3 81       	ldd	r31, Z+3	; 0x03
    37a4:	e0 2d       	mov	r30, r0
    37a6:	60 e2       	ldi	r22, 0x20	; 32
    37a8:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    37aa:	cc 16       	cp	r12, r28
    37ac:	dd 06       	cpc	r13, r29
    37ae:	09 f7       	brne	.-62     	; 0x3772 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    37b0:	11 23       	and	r17, r17
    37b2:	89 f0       	breq	.+34     	; 0x37d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    37b4:	6a e0       	ldi	r22, 0x0A	; 10
    37b6:	c7 01       	movw	r24, r14
    37b8:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    37bc:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    37be:	60 e1       	ldi	r22, 0x10	; 16
    37c0:	77 e0       	ldi	r23, 0x07	; 7
    37c2:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    37c6:	e8 81       	ld	r30, Y
    37c8:	f9 81       	ldd	r31, Y+1	; 0x01
    37ca:	02 80       	ldd	r0, Z+2	; 0x02
    37cc:	f3 81       	ldd	r31, Z+3	; 0x03
    37ce:	e0 2d       	mov	r30, r0
    37d0:	60 e2       	ldi	r22, 0x20	; 32
    37d2:	ce 01       	movw	r24, r28
    37d4:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    37d6:	c6 2d       	mov	r28, r6
    37d8:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    37da:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    37dc:	80 ee       	ldi	r24, 0xE0	; 224
    37de:	86 0f       	add	r24, r22
    37e0:	8f 35       	cpi	r24, 0x5F	; 95
    37e2:	48 f4       	brcc	.+18     	; 0x37f6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    37e4:	d7 01       	movw	r26, r14
    37e6:	ed 91       	ld	r30, X+
    37e8:	fc 91       	ld	r31, X
    37ea:	02 80       	ldd	r0, Z+2	; 0x02
    37ec:	f3 81       	ldd	r31, Z+3	; 0x03
    37ee:	e0 2d       	mov	r30, r0
    37f0:	c7 01       	movw	r24, r14
    37f2:	19 95       	eicall
    37f4:	09 c0       	rjmp	.+18     	; 0x3808 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    37f6:	d7 01       	movw	r26, r14
    37f8:	ed 91       	ld	r30, X+
    37fa:	fc 91       	ld	r31, X
    37fc:	02 80       	ldd	r0, Z+2	; 0x02
    37fe:	f3 81       	ldd	r31, Z+3	; 0x03
    3800:	e0 2d       	mov	r30, r0
    3802:	6e e2       	ldi	r22, 0x2E	; 46
    3804:	c7 01       	movw	r24, r14
    3806:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3808:	cc 16       	cp	r12, r28
    380a:	dd 06       	cpc	r13, r29
    380c:	31 f7       	brne	.-52     	; 0x37da <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    380e:	b4 e1       	ldi	r27, 0x14	; 20
    3810:	ab 0e       	add	r10, r27
    3812:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3814:	66 e0       	ldi	r22, 0x06	; 6
    3816:	c7 01       	movw	r24, r14
    3818:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    381c:	84 e1       	ldi	r24, 0x14	; 20
    381e:	c8 0e       	add	r12, r24
    3820:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3822:	a8 14       	cp	r10, r8
    3824:	b9 04       	cpc	r11, r9
    3826:	08 f4       	brcc	.+2      	; 0x382a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3828:	88 cf       	rjmp	.-240    	; 0x373a <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    382a:	62 e0       	ldi	r22, 0x02	; 2
    382c:	c7 01       	movw	r24, r14
    382e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
}
    3832:	03 c0       	rjmp	.+6      	; 0x383a <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3834:	c6 2d       	mov	r28, r6
    3836:	d5 2d       	mov	r29, r5
    3838:	9c cf       	rjmp	.-200    	; 0x3772 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    383a:	df 91       	pop	r29
    383c:	cf 91       	pop	r28
    383e:	1f 91       	pop	r17
    3840:	0f 91       	pop	r16
    3842:	ff 90       	pop	r15
    3844:	ef 90       	pop	r14
    3846:	df 90       	pop	r13
    3848:	cf 90       	pop	r12
    384a:	bf 90       	pop	r11
    384c:	af 90       	pop	r10
    384e:	9f 90       	pop	r9
    3850:	8f 90       	pop	r8
    3852:	7f 90       	pop	r7
    3854:	6f 90       	pop	r6
    3856:	5f 90       	pop	r5
    3858:	08 95       	ret

0000385a <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    385a:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <pvPortMalloc>
    385e:	08 95       	ret

00003860 <_Znaj>:
    3860:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <pvPortMalloc>
    3864:	08 95       	ret

00003866 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3866:	08 95       	ret

00003868 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3868:	cf 93       	push	r28
    386a:	df 93       	push	r29
    386c:	fc 01       	movw	r30, r24
    386e:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3870:	40 3a       	cpi	r20, 0xA0	; 160
    3872:	68 e0       	ldi	r22, 0x08	; 8
    3874:	56 07       	cpc	r21, r22
    3876:	49 f4       	brne	.+18     	; 0x388a <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3878:	80 e4       	ldi	r24, 0x40	; 64
    387a:	96 e0       	ldi	r25, 0x06	; 6
    387c:	82 83       	std	Z+2, r24	; 0x02
    387e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3880:	82 e0       	ldi	r24, 0x02	; 2
    3882:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3884:	83 e0       	ldi	r24, 0x03	; 3
    3886:	85 83       	std	Z+5, r24	; 0x05
    3888:	32 c0       	rjmp	.+100    	; 0x38ee <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    388a:	40 3b       	cpi	r20, 0xB0	; 176
    388c:	78 e0       	ldi	r23, 0x08	; 8
    388e:	57 07       	cpc	r21, r23
    3890:	49 f4       	brne	.+18     	; 0x38a4 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3892:	80 e4       	ldi	r24, 0x40	; 64
    3894:	96 e0       	ldi	r25, 0x06	; 6
    3896:	82 83       	std	Z+2, r24	; 0x02
    3898:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    389a:	86 e0       	ldi	r24, 0x06	; 6
    389c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    389e:	87 e0       	ldi	r24, 0x07	; 7
    38a0:	85 83       	std	Z+5, r24	; 0x05
    38a2:	25 c0       	rjmp	.+74     	; 0x38ee <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    38a4:	40 3a       	cpi	r20, 0xA0	; 160
    38a6:	89 e0       	ldi	r24, 0x09	; 9
    38a8:	58 07       	cpc	r21, r24
    38aa:	49 f4       	brne	.+18     	; 0x38be <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    38ac:	80 e6       	ldi	r24, 0x60	; 96
    38ae:	96 e0       	ldi	r25, 0x06	; 6
    38b0:	82 83       	std	Z+2, r24	; 0x02
    38b2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    38b4:	82 e0       	ldi	r24, 0x02	; 2
    38b6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    38b8:	83 e0       	ldi	r24, 0x03	; 3
    38ba:	85 83       	std	Z+5, r24	; 0x05
    38bc:	18 c0       	rjmp	.+48     	; 0x38ee <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    38be:	40 3b       	cpi	r20, 0xB0	; 176
    38c0:	69 e0       	ldi	r22, 0x09	; 9
    38c2:	56 07       	cpc	r21, r22
    38c4:	49 f4       	brne	.+18     	; 0x38d8 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    38c6:	80 e6       	ldi	r24, 0x60	; 96
    38c8:	96 e0       	ldi	r25, 0x06	; 6
    38ca:	82 83       	std	Z+2, r24	; 0x02
    38cc:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    38ce:	86 e0       	ldi	r24, 0x06	; 6
    38d0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    38d2:	87 e0       	ldi	r24, 0x07	; 7
    38d4:	85 83       	std	Z+5, r24	; 0x05
    38d6:	0b c0       	rjmp	.+22     	; 0x38ee <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    38d8:	40 3a       	cpi	r20, 0xA0	; 160
    38da:	5a 40       	sbci	r21, 0x0A	; 10
    38dc:	41 f4       	brne	.+16     	; 0x38ee <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    38de:	80 e8       	ldi	r24, 0x80	; 128
    38e0:	96 e0       	ldi	r25, 0x06	; 6
    38e2:	82 83       	std	Z+2, r24	; 0x02
    38e4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    38e6:	82 e0       	ldi	r24, 0x02	; 2
    38e8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    38ea:	83 e0       	ldi	r24, 0x03	; 3
    38ec:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    38ee:	a6 83       	std	Z+6, r26	; 0x06
    38f0:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    38f2:	cd 01       	movw	r24, r26
    38f4:	01 96       	adiw	r24, 0x01	; 1
    38f6:	80 87       	std	Z+8, r24	; 0x08
    38f8:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    38fa:	03 96       	adiw	r24, 0x03	; 3
    38fc:	82 87       	std	Z+10, r24	; 0x0a
    38fe:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3900:	25 81       	ldd	r18, Z+5	; 0x05
    3902:	c2 81       	ldd	r28, Z+2	; 0x02
    3904:	d3 81       	ldd	r29, Z+3	; 0x03
    3906:	4c 81       	ldd	r20, Y+4	; 0x04
    3908:	81 e0       	ldi	r24, 0x01	; 1
    390a:	90 e0       	ldi	r25, 0x00	; 0
    390c:	bc 01       	movw	r22, r24
    390e:	02 c0       	rjmp	.+4      	; 0x3914 <_ZN7base232C1EjP12USART_struct+0xac>
    3910:	66 0f       	add	r22, r22
    3912:	77 1f       	adc	r23, r23
    3914:	2a 95       	dec	r18
    3916:	e2 f7       	brpl	.-8      	; 0x3910 <_ZN7base232C1EjP12USART_struct+0xa8>
    3918:	9b 01       	movw	r18, r22
    391a:	24 2b       	or	r18, r20
    391c:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    391e:	25 81       	ldd	r18, Z+5	; 0x05
    3920:	c2 81       	ldd	r28, Z+2	; 0x02
    3922:	d3 81       	ldd	r29, Z+3	; 0x03
    3924:	48 81       	ld	r20, Y
    3926:	bc 01       	movw	r22, r24
    3928:	02 c0       	rjmp	.+4      	; 0x392e <_ZN7base232C1EjP12USART_struct+0xc6>
    392a:	66 0f       	add	r22, r22
    392c:	77 1f       	adc	r23, r23
    392e:	2a 95       	dec	r18
    3930:	e2 f7       	brpl	.-8      	; 0x392a <_ZN7base232C1EjP12USART_struct+0xc2>
    3932:	9b 01       	movw	r18, r22
    3934:	24 2b       	or	r18, r20
    3936:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3938:	34 81       	ldd	r19, Z+4	; 0x04
    393a:	c2 81       	ldd	r28, Z+2	; 0x02
    393c:	d3 81       	ldd	r29, Z+3	; 0x03
    393e:	28 81       	ld	r18, Y
    3940:	02 c0       	rjmp	.+4      	; 0x3946 <_ZN7base232C1EjP12USART_struct+0xde>
    3942:	88 0f       	add	r24, r24
    3944:	99 1f       	adc	r25, r25
    3946:	3a 95       	dec	r19
    3948:	e2 f7       	brpl	.-8      	; 0x3942 <_ZN7base232C1EjP12USART_struct+0xda>
    394a:	80 95       	com	r24
    394c:	90 95       	com	r25
    394e:	82 23       	and	r24, r18
    3950:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3952:	80 e1       	ldi	r24, 0x10	; 16
    3954:	13 96       	adiw	r26, 0x03	; 3
    3956:	8c 93       	st	X, r24
    3958:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    395a:	83 e0       	ldi	r24, 0x03	; 3
    395c:	15 96       	adiw	r26, 0x05	; 5
    395e:	8c 93       	st	X, r24
    3960:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3962:	80 ef       	ldi	r24, 0xF0	; 240
    3964:	17 96       	adiw	r26, 0x07	; 7
    3966:	8c 93       	st	X, r24
    3968:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    396a:	81 e2       	ldi	r24, 0x21	; 33
    396c:	16 96       	adiw	r26, 0x06	; 6
    396e:	8c 93       	st	X, r24
    3970:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3972:	88 e1       	ldi	r24, 0x18	; 24
    3974:	14 96       	adiw	r26, 0x04	; 4
    3976:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3978:	80 e8       	ldi	r24, 0x80	; 128
    397a:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    397c:	80 e4       	ldi	r24, 0x40	; 64
    397e:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3980:	80 e2       	ldi	r24, 0x20	; 32
    3982:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3984:	06 80       	ldd	r0, Z+6	; 0x06
    3986:	f7 81       	ldd	r31, Z+7	; 0x07
    3988:	e0 2d       	mov	r30, r0
    398a:	80 81       	ld	r24, Z
    398c:	80 81       	ld	r24, Z
}
    398e:	df 91       	pop	r29
    3990:	cf 91       	pop	r28
    3992:	08 95       	ret

00003994 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3994:	81 e0       	ldi	r24, 0x01	; 1
    3996:	08 95       	ret

00003998 <_ZN8emstream7getcharEv>:
    3998:	80 e0       	ldi	r24, 0x00	; 0
    399a:	90 e0       	ldi	r25, 0x00	; 0
    399c:	08 95       	ret

0000399e <_ZN8emstream14check_for_charEv>:
    399e:	80 e0       	ldi	r24, 0x00	; 0
    39a0:	08 95       	ret

000039a2 <_ZN8emstream12transmit_nowEv>:
    39a2:	08 95       	ret

000039a4 <_ZN8emstream12clear_screenEv>:
    39a4:	08 95       	ret

000039a6 <_ZN8emstreamC1Ev>:
    39a6:	fc 01       	movw	r30, r24
    39a8:	8b e5       	ldi	r24, 0x5B	; 91
    39aa:	90 e2       	ldi	r25, 0x20	; 32
    39ac:	80 83       	st	Z, r24
    39ae:	91 83       	std	Z+1, r25	; 0x01
    39b0:	8a e0       	ldi	r24, 0x0A	; 10
    39b2:	82 83       	std	Z+2, r24	; 0x02
    39b4:	13 82       	std	Z+3, r1	; 0x03
    39b6:	83 e0       	ldi	r24, 0x03	; 3
    39b8:	85 83       	std	Z+5, r24	; 0x05
    39ba:	14 82       	std	Z+4, r1	; 0x04
    39bc:	16 82       	std	Z+6, r1	; 0x06
    39be:	17 82       	std	Z+7, r1	; 0x07
    39c0:	08 95       	ret

000039c2 <_ZN8emstream4putsEPKc>:
    39c2:	0f 93       	push	r16
    39c4:	1f 93       	push	r17
    39c6:	cf 93       	push	r28
    39c8:	df 93       	push	r29
    39ca:	8c 01       	movw	r16, r24
    39cc:	fb 01       	movw	r30, r22
    39ce:	dc 01       	movw	r26, r24
    39d0:	14 96       	adiw	r26, 0x04	; 4
    39d2:	8c 91       	ld	r24, X
    39d4:	81 11       	cpse	r24, r1
    39d6:	04 c0       	rjmp	.+8      	; 0x39e0 <_ZN8emstream4putsEPKc+0x1e>
    39d8:	60 81       	ld	r22, Z
    39da:	61 11       	cpse	r22, r1
    39dc:	17 c0       	rjmp	.+46     	; 0x3a0c <_ZN8emstream4putsEPKc+0x4a>
    39de:	23 c0       	rjmp	.+70     	; 0x3a26 <_ZN8emstream4putsEPKc+0x64>
    39e0:	d8 01       	movw	r26, r16
    39e2:	14 96       	adiw	r26, 0x04	; 4
    39e4:	1c 92       	st	X, r1
    39e6:	eb 01       	movw	r28, r22
    39e8:	21 96       	adiw	r28, 0x01	; 1
    39ea:	64 91       	lpm	r22, Z
    39ec:	66 23       	and	r22, r22
    39ee:	d9 f0       	breq	.+54     	; 0x3a26 <_ZN8emstream4putsEPKc+0x64>
    39f0:	d8 01       	movw	r26, r16
    39f2:	ed 91       	ld	r30, X+
    39f4:	fc 91       	ld	r31, X
    39f6:	02 80       	ldd	r0, Z+2	; 0x02
    39f8:	f3 81       	ldd	r31, Z+3	; 0x03
    39fa:	e0 2d       	mov	r30, r0
    39fc:	c8 01       	movw	r24, r16
    39fe:	19 95       	eicall
    3a00:	fe 01       	movw	r30, r28
    3a02:	64 91       	lpm	r22, Z
    3a04:	21 96       	adiw	r28, 0x01	; 1
    3a06:	61 11       	cpse	r22, r1
    3a08:	f3 cf       	rjmp	.-26     	; 0x39f0 <_ZN8emstream4putsEPKc+0x2e>
    3a0a:	0d c0       	rjmp	.+26     	; 0x3a26 <_ZN8emstream4putsEPKc+0x64>
    3a0c:	ef 01       	movw	r28, r30
    3a0e:	21 96       	adiw	r28, 0x01	; 1
    3a10:	d8 01       	movw	r26, r16
    3a12:	ed 91       	ld	r30, X+
    3a14:	fc 91       	ld	r31, X
    3a16:	02 80       	ldd	r0, Z+2	; 0x02
    3a18:	f3 81       	ldd	r31, Z+3	; 0x03
    3a1a:	e0 2d       	mov	r30, r0
    3a1c:	c8 01       	movw	r24, r16
    3a1e:	19 95       	eicall
    3a20:	69 91       	ld	r22, Y+
    3a22:	61 11       	cpse	r22, r1
    3a24:	f5 cf       	rjmp	.-22     	; 0x3a10 <_ZN8emstream4putsEPKc+0x4e>
    3a26:	df 91       	pop	r29
    3a28:	cf 91       	pop	r28
    3a2a:	1f 91       	pop	r17
    3a2c:	0f 91       	pop	r16
    3a2e:	08 95       	ret

00003a30 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3a30:	cf 93       	push	r28
    3a32:	df 93       	push	r29
    3a34:	ec 01       	movw	r28, r24
	switch (new_manip)
    3a36:	86 2f       	mov	r24, r22
    3a38:	90 e0       	ldi	r25, 0x00	; 0
    3a3a:	8b 30       	cpi	r24, 0x0B	; 11
    3a3c:	91 05       	cpc	r25, r1
    3a3e:	d8 f5       	brcc	.+118    	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
    3a40:	fc 01       	movw	r30, r24
    3a42:	88 27       	eor	r24, r24
    3a44:	e6 5a       	subi	r30, 0xA6	; 166
    3a46:	fe 4f       	sbci	r31, 0xFE	; 254
    3a48:	8f 4f       	sbci	r24, 0xFF	; 255
    3a4a:	0c 94 96 22 	jmp	0x452c	; 0x452c <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3a4e:	82 e0       	ldi	r24, 0x02	; 2
    3a50:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a52:	31 c0       	rjmp	.+98     	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3a54:	88 e0       	ldi	r24, 0x08	; 8
    3a56:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a58:	2e c0       	rjmp	.+92     	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3a5a:	8a e0       	ldi	r24, 0x0A	; 10
    3a5c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a5e:	2b c0       	rjmp	.+86     	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3a60:	80 e1       	ldi	r24, 0x10	; 16
    3a62:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a64:	28 c0       	rjmp	.+80     	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3a66:	81 e0       	ldi	r24, 0x01	; 1
    3a68:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3a6a:	25 c0       	rjmp	.+74     	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3a6c:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3a6e:	23 c0       	rjmp	.+70     	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3a70:	e8 81       	ld	r30, Y
    3a72:	f9 81       	ldd	r31, Y+1	; 0x01
    3a74:	02 80       	ldd	r0, Z+2	; 0x02
    3a76:	f3 81       	ldd	r31, Z+3	; 0x03
    3a78:	e0 2d       	mov	r30, r0
    3a7a:	6d e0       	ldi	r22, 0x0D	; 13
    3a7c:	ce 01       	movw	r24, r28
    3a7e:	19 95       	eicall
    3a80:	e8 81       	ld	r30, Y
    3a82:	f9 81       	ldd	r31, Y+1	; 0x01
    3a84:	02 80       	ldd	r0, Z+2	; 0x02
    3a86:	f3 81       	ldd	r31, Z+3	; 0x03
    3a88:	e0 2d       	mov	r30, r0
    3a8a:	6a e0       	ldi	r22, 0x0A	; 10
    3a8c:	ce 01       	movw	r24, r28
    3a8e:	19 95       	eicall
			break;
    3a90:	12 c0       	rjmp	.+36     	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3a92:	e8 81       	ld	r30, Y
    3a94:	f9 81       	ldd	r31, Y+1	; 0x01
    3a96:	02 84       	ldd	r0, Z+10	; 0x0a
    3a98:	f3 85       	ldd	r31, Z+11	; 0x0b
    3a9a:	e0 2d       	mov	r30, r0
    3a9c:	ce 01       	movw	r24, r28
    3a9e:	19 95       	eicall
			break;
    3aa0:	0a c0       	rjmp	.+20     	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3aa2:	e8 81       	ld	r30, Y
    3aa4:	f9 81       	ldd	r31, Y+1	; 0x01
    3aa6:	00 84       	ldd	r0, Z+8	; 0x08
    3aa8:	f1 85       	ldd	r31, Z+9	; 0x09
    3aaa:	e0 2d       	mov	r30, r0
    3aac:	ce 01       	movw	r24, r28
    3aae:	19 95       	eicall
			break;
    3ab0:	02 c0       	rjmp	.+4      	; 0x3ab6 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3ab2:	81 e0       	ldi	r24, 0x01	; 1
    3ab4:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3ab6:	ce 01       	movw	r24, r28
    3ab8:	df 91       	pop	r29
    3aba:	cf 91       	pop	r28
    3abc:	08 95       	ret

00003abe <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3abe:	ff 92       	push	r15
    3ac0:	0f 93       	push	r16
    3ac2:	1f 93       	push	r17
    3ac4:	cf 93       	push	r28
    3ac6:	df 93       	push	r29
    3ac8:	cd b7       	in	r28, 0x3d	; 61
    3aca:	de b7       	in	r29, 0x3e	; 62
    3acc:	61 97       	sbiw	r28, 0x11	; 17
    3ace:	cd bf       	out	0x3d, r28	; 61
    3ad0:	de bf       	out	0x3e, r29	; 62
    3ad2:	8c 01       	movw	r16, r24
    3ad4:	f6 2e       	mov	r15, r22
    3ad6:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3ad8:	f8 01       	movw	r30, r16
    3ada:	42 81       	ldd	r20, Z+2	; 0x02
    3adc:	40 31       	cpi	r20, 0x10	; 16
    3ade:	21 f0       	breq	.+8      	; 0x3ae8 <_ZN8emstreamlsEj+0x2a>
    3ae0:	48 30       	cpi	r20, 0x08	; 8
    3ae2:	11 f0       	breq	.+4      	; 0x3ae8 <_ZN8emstreamlsEj+0x2a>
    3ae4:	42 30       	cpi	r20, 0x02	; 2
    3ae6:	41 f4       	brne	.+16     	; 0x3af8 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3ae8:	69 2f       	mov	r22, r25
    3aea:	c8 01       	movw	r24, r16
    3aec:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
    3af0:	6f 2d       	mov	r22, r15
    3af2:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
    3af6:	0d c0       	rjmp	.+26     	; 0x3b12 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3af8:	50 e0       	ldi	r21, 0x00	; 0
    3afa:	be 01       	movw	r22, r28
    3afc:	6f 5f       	subi	r22, 0xFF	; 255
    3afe:	7f 4f       	sbci	r23, 0xFF	; 255
    3b00:	8f 2d       	mov	r24, r15
    3b02:	0e 94 30 23 	call	0x4660	; 0x4660 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3b06:	be 01       	movw	r22, r28
    3b08:	6f 5f       	subi	r22, 0xFF	; 255
    3b0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b0c:	c8 01       	movw	r24, r16
    3b0e:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3b12:	c8 01       	movw	r24, r16
    3b14:	61 96       	adiw	r28, 0x11	; 17
    3b16:	cd bf       	out	0x3d, r28	; 61
    3b18:	de bf       	out	0x3e, r29	; 62
    3b1a:	df 91       	pop	r29
    3b1c:	cf 91       	pop	r28
    3b1e:	1f 91       	pop	r17
    3b20:	0f 91       	pop	r16
    3b22:	ff 90       	pop	r15
    3b24:	08 95       	ret

00003b26 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3b26:	df 92       	push	r13
    3b28:	ef 92       	push	r14
    3b2a:	ff 92       	push	r15
    3b2c:	0f 93       	push	r16
    3b2e:	1f 93       	push	r17
    3b30:	cf 93       	push	r28
    3b32:	df 93       	push	r29
    3b34:	cd b7       	in	r28, 0x3d	; 61
    3b36:	de b7       	in	r29, 0x3e	; 62
    3b38:	a1 97       	sbiw	r28, 0x21	; 33
    3b3a:	cd bf       	out	0x3d, r28	; 61
    3b3c:	de bf       	out	0x3e, r29	; 62
    3b3e:	8c 01       	movw	r16, r24
    3b40:	d4 2e       	mov	r13, r20
    3b42:	e5 2e       	mov	r14, r21
    3b44:	f6 2e       	mov	r15, r22
    3b46:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3b48:	f8 01       	movw	r30, r16
    3b4a:	22 81       	ldd	r18, Z+2	; 0x02
    3b4c:	20 31       	cpi	r18, 0x10	; 16
    3b4e:	21 f0       	breq	.+8      	; 0x3b58 <_ZN8emstreamlsEm+0x32>
    3b50:	28 30       	cpi	r18, 0x08	; 8
    3b52:	11 f0       	breq	.+4      	; 0x3b58 <_ZN8emstreamlsEm+0x32>
    3b54:	22 30       	cpi	r18, 0x02	; 2
    3b56:	71 f4       	brne	.+28     	; 0x3b74 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3b58:	69 2f       	mov	r22, r25
    3b5a:	c8 01       	movw	r24, r16
    3b5c:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
    3b60:	6f 2d       	mov	r22, r15
    3b62:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
    3b66:	6e 2d       	mov	r22, r14
    3b68:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
    3b6c:	6d 2d       	mov	r22, r13
    3b6e:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <_ZN8emstreamlsEh>
    3b72:	0f c0       	rjmp	.+30     	; 0x3b92 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3b74:	30 e0       	ldi	r19, 0x00	; 0
    3b76:	ae 01       	movw	r20, r28
    3b78:	4f 5f       	subi	r20, 0xFF	; 255
    3b7a:	5f 4f       	sbci	r21, 0xFF	; 255
    3b7c:	6d 2d       	mov	r22, r13
    3b7e:	7e 2d       	mov	r23, r14
    3b80:	8f 2d       	mov	r24, r15
    3b82:	0e 94 03 23 	call	0x4606	; 0x4606 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3b86:	be 01       	movw	r22, r28
    3b88:	6f 5f       	subi	r22, 0xFF	; 255
    3b8a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b8c:	c8 01       	movw	r24, r16
    3b8e:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3b92:	c8 01       	movw	r24, r16
    3b94:	a1 96       	adiw	r28, 0x21	; 33
    3b96:	cd bf       	out	0x3d, r28	; 61
    3b98:	de bf       	out	0x3e, r29	; 62
    3b9a:	df 91       	pop	r29
    3b9c:	cf 91       	pop	r28
    3b9e:	1f 91       	pop	r17
    3ba0:	0f 91       	pop	r16
    3ba2:	ff 90       	pop	r15
    3ba4:	ef 90       	pop	r14
    3ba6:	df 90       	pop	r13
    3ba8:	08 95       	ret

00003baa <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3baa:	cf 92       	push	r12
    3bac:	df 92       	push	r13
    3bae:	ef 92       	push	r14
    3bb0:	ff 92       	push	r15
    3bb2:	0f 93       	push	r16
    3bb4:	1f 93       	push	r17
    3bb6:	cf 93       	push	r28
    3bb8:	df 93       	push	r29
    3bba:	cd b7       	in	r28, 0x3d	; 61
    3bbc:	de b7       	in	r29, 0x3e	; 62
    3bbe:	29 97       	sbiw	r28, 0x09	; 9
    3bc0:	cd bf       	out	0x3d, r28	; 61
    3bc2:	de bf       	out	0x3e, r29	; 62
    3bc4:	8c 01       	movw	r16, r24
    3bc6:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3bc8:	dc 01       	movw	r26, r24
    3bca:	13 96       	adiw	r26, 0x03	; 3
    3bcc:	8c 91       	ld	r24, X
    3bce:	13 97       	sbiw	r26, 0x03	; 3
    3bd0:	88 23       	and	r24, r24
    3bd2:	41 f0       	breq	.+16     	; 0x3be4 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3bd4:	ed 91       	ld	r30, X+
    3bd6:	fc 91       	ld	r31, X
    3bd8:	02 80       	ldd	r0, Z+2	; 0x02
    3bda:	f3 81       	ldd	r31, Z+3	; 0x03
    3bdc:	e0 2d       	mov	r30, r0
    3bde:	c8 01       	movw	r24, r16
    3be0:	19 95       	eicall
    3be2:	56 c0       	rjmp	.+172    	; 0x3c90 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3be4:	f8 01       	movw	r30, r16
    3be6:	42 81       	ldd	r20, Z+2	; 0x02
    3be8:	42 30       	cpi	r20, 0x02	; 2
    3bea:	19 f5       	brne	.+70     	; 0x3c32 <_ZN8emstreamlsEh+0x88>
    3bec:	68 94       	set
    3bee:	cc 24       	eor	r12, r12
    3bf0:	c3 f8       	bld	r12, 3
    3bf2:	d1 2c       	mov	r13, r1
    3bf4:	68 94       	set
    3bf6:	ff 24       	eor	r15, r15
    3bf8:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3bfa:	8e 2d       	mov	r24, r14
    3bfc:	8f 21       	and	r24, r15
    3bfe:	51 f0       	breq	.+20     	; 0x3c14 <_ZN8emstreamlsEh+0x6a>
    3c00:	d8 01       	movw	r26, r16
    3c02:	ed 91       	ld	r30, X+
    3c04:	fc 91       	ld	r31, X
    3c06:	02 80       	ldd	r0, Z+2	; 0x02
    3c08:	f3 81       	ldd	r31, Z+3	; 0x03
    3c0a:	e0 2d       	mov	r30, r0
    3c0c:	61 e3       	ldi	r22, 0x31	; 49
    3c0e:	c8 01       	movw	r24, r16
    3c10:	19 95       	eicall
    3c12:	09 c0       	rjmp	.+18     	; 0x3c26 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3c14:	d8 01       	movw	r26, r16
    3c16:	ed 91       	ld	r30, X+
    3c18:	fc 91       	ld	r31, X
    3c1a:	02 80       	ldd	r0, Z+2	; 0x02
    3c1c:	f3 81       	ldd	r31, Z+3	; 0x03
    3c1e:	e0 2d       	mov	r30, r0
    3c20:	60 e3       	ldi	r22, 0x30	; 48
    3c22:	c8 01       	movw	r24, r16
    3c24:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3c26:	f6 94       	lsr	r15
    3c28:	b1 e0       	ldi	r27, 0x01	; 1
    3c2a:	cb 1a       	sub	r12, r27
    3c2c:	d1 08       	sbc	r13, r1
    3c2e:	29 f7       	brne	.-54     	; 0x3bfa <_ZN8emstreamlsEh+0x50>
    3c30:	2f c0       	rjmp	.+94     	; 0x3c90 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3c32:	40 31       	cpi	r20, 0x10	; 16
    3c34:	f9 f4       	brne	.+62     	; 0x3c74 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3c36:	62 95       	swap	r22
    3c38:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3c3a:	01 90       	ld	r0, Z+
    3c3c:	f0 81       	ld	r31, Z
    3c3e:	e0 2d       	mov	r30, r0
    3c40:	02 80       	ldd	r0, Z+2	; 0x02
    3c42:	f3 81       	ldd	r31, Z+3	; 0x03
    3c44:	e0 2d       	mov	r30, r0
    3c46:	6a 30       	cpi	r22, 0x0A	; 10
    3c48:	10 f0       	brcs	.+4      	; 0x3c4e <_ZN8emstreamlsEh+0xa4>
    3c4a:	69 5c       	subi	r22, 0xC9	; 201
    3c4c:	01 c0       	rjmp	.+2      	; 0x3c50 <_ZN8emstreamlsEh+0xa6>
    3c4e:	60 5d       	subi	r22, 0xD0	; 208
    3c50:	c8 01       	movw	r24, r16
    3c52:	19 95       	eicall
		temp_char = num & 0x0F;
    3c54:	6e 2d       	mov	r22, r14
    3c56:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3c58:	d8 01       	movw	r26, r16
    3c5a:	ed 91       	ld	r30, X+
    3c5c:	fc 91       	ld	r31, X
    3c5e:	02 80       	ldd	r0, Z+2	; 0x02
    3c60:	f3 81       	ldd	r31, Z+3	; 0x03
    3c62:	e0 2d       	mov	r30, r0
    3c64:	6a 30       	cpi	r22, 0x0A	; 10
    3c66:	10 f0       	brcs	.+4      	; 0x3c6c <_ZN8emstreamlsEh+0xc2>
    3c68:	69 5c       	subi	r22, 0xC9	; 201
    3c6a:	01 c0       	rjmp	.+2      	; 0x3c6e <_ZN8emstreamlsEh+0xc4>
    3c6c:	60 5d       	subi	r22, 0xD0	; 208
    3c6e:	c8 01       	movw	r24, r16
    3c70:	19 95       	eicall
    3c72:	0e c0       	rjmp	.+28     	; 0x3c90 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3c74:	50 e0       	ldi	r21, 0x00	; 0
    3c76:	be 01       	movw	r22, r28
    3c78:	6f 5f       	subi	r22, 0xFF	; 255
    3c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    3c7c:	8e 2d       	mov	r24, r14
    3c7e:	90 e0       	ldi	r25, 0x00	; 0
    3c80:	0e 94 30 23 	call	0x4660	; 0x4660 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3c84:	be 01       	movw	r22, r28
    3c86:	6f 5f       	subi	r22, 0xFF	; 255
    3c88:	7f 4f       	sbci	r23, 0xFF	; 255
    3c8a:	c8 01       	movw	r24, r16
    3c8c:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3c90:	c8 01       	movw	r24, r16
    3c92:	29 96       	adiw	r28, 0x09	; 9
    3c94:	cd bf       	out	0x3d, r28	; 61
    3c96:	de bf       	out	0x3e, r29	; 62
    3c98:	df 91       	pop	r29
    3c9a:	cf 91       	pop	r28
    3c9c:	1f 91       	pop	r17
    3c9e:	0f 91       	pop	r16
    3ca0:	ff 90       	pop	r15
    3ca2:	ef 90       	pop	r14
    3ca4:	df 90       	pop	r13
    3ca6:	cf 90       	pop	r12
    3ca8:	08 95       	ret

00003caa <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3caa:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3cac:	50 96       	adiw	r26, 0x10	; 16
    3cae:	ed 91       	ld	r30, X+
    3cb0:	fc 91       	ld	r31, X
    3cb2:	51 97       	sbiw	r26, 0x11	; 17
    3cb4:	80 81       	ld	r24, Z
    3cb6:	54 96       	adiw	r26, 0x14	; 20
    3cb8:	4c 91       	ld	r20, X
    3cba:	54 97       	sbiw	r26, 0x14	; 20
    3cbc:	84 23       	and	r24, r20
    3cbe:	29 f0       	breq	.+10     	; 0x3cca <_ZN5rs2327putcharEc+0x20>
    3cc0:	09 c0       	rjmp	.+18     	; 0x3cd4 <_ZN5rs2327putcharEc+0x2a>
    3cc2:	21 50       	subi	r18, 0x01	; 1
    3cc4:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3cc6:	19 f4       	brne	.+6      	; 0x3cce <_ZN5rs2327putcharEc+0x24>
    3cc8:	12 c0       	rjmp	.+36     	; 0x3cee <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3cca:	21 e2       	ldi	r18, 0x21	; 33
    3ccc:	3e e4       	ldi	r19, 0x4E	; 78
    3cce:	90 81       	ld	r25, Z
    3cd0:	94 23       	and	r25, r20
    3cd2:	b9 f3       	breq	.-18     	; 0x3cc2 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3cd4:	90 81       	ld	r25, Z
    3cd6:	56 96       	adiw	r26, 0x16	; 22
    3cd8:	8c 91       	ld	r24, X
    3cda:	56 97       	sbiw	r26, 0x16	; 22
    3cdc:	89 2b       	or	r24, r25
    3cde:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3ce0:	1e 96       	adiw	r26, 0x0e	; 14
    3ce2:	ed 91       	ld	r30, X+
    3ce4:	fc 91       	ld	r31, X
    3ce6:	1f 97       	sbiw	r26, 0x0f	; 15
    3ce8:	60 83       	st	Z, r22
	return (true);
    3cea:	81 e0       	ldi	r24, 0x01	; 1
    3cec:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3cee:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3cf0:	08 95       	ret

00003cf2 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3cf2:	cf 93       	push	r28
    3cf4:	df 93       	push	r29
    3cf6:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3cf8:	c1 8d       	ldd	r28, Z+25	; 0x19
    3cfa:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3cfc:	28 81       	ld	r18, Y
    3cfe:	39 81       	ldd	r19, Y+1	; 0x01
    3d00:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3d02:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3d04:	4d 91       	ld	r20, X+
    3d06:	5c 91       	ld	r21, X
    3d08:	24 17       	cp	r18, r20
    3d0a:	35 07       	cpc	r19, r21
    3d0c:	e9 f3       	breq	.-6      	; 0x3d08 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3d0e:	a7 89       	ldd	r26, Z+23	; 0x17
    3d10:	b0 8d       	ldd	r27, Z+24	; 0x18
    3d12:	0d 90       	ld	r0, X+
    3d14:	bc 91       	ld	r27, X
    3d16:	a0 2d       	mov	r26, r0
    3d18:	a2 0f       	add	r26, r18
    3d1a:	b3 1f       	adc	r27, r19
    3d1c:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3d1e:	2f 5f       	subi	r18, 0xFF	; 255
    3d20:	3f 4f       	sbci	r19, 0xFF	; 255
    3d22:	28 83       	st	Y, r18
    3d24:	39 83       	std	Y+1, r19	; 0x01
    3d26:	24 36       	cpi	r18, 0x64	; 100
    3d28:	31 05       	cpc	r19, r1
    3d2a:	28 f0       	brcs	.+10     	; 0x3d36 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3d2c:	01 8c       	ldd	r0, Z+25	; 0x19
    3d2e:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3d30:	e0 2d       	mov	r30, r0
    3d32:	10 82       	st	Z, r1
    3d34:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3d36:	90 e0       	ldi	r25, 0x00	; 0
    3d38:	df 91       	pop	r29
    3d3a:	cf 91       	pop	r28
    3d3c:	08 95       	ret

00003d3e <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3d3e:	cf 93       	push	r28
    3d40:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3d42:	ec 01       	movw	r28, r24
    3d44:	a9 8d       	ldd	r26, Y+25	; 0x19
    3d46:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3d48:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3d4a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3d4c:	81 e0       	ldi	r24, 0x01	; 1
    3d4e:	4d 91       	ld	r20, X+
    3d50:	5c 91       	ld	r21, X
    3d52:	20 81       	ld	r18, Z
    3d54:	31 81       	ldd	r19, Z+1	; 0x01
    3d56:	42 17       	cp	r20, r18
    3d58:	53 07       	cpc	r21, r19
    3d5a:	09 f4       	brne	.+2      	; 0x3d5e <_ZN5rs23214check_for_charEv+0x20>
    3d5c:	80 e0       	ldi	r24, 0x00	; 0
}
    3d5e:	df 91       	pop	r29
    3d60:	cf 91       	pop	r28
    3d62:	08 95       	ret

00003d64 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3d64:	dc 01       	movw	r26, r24
    3d66:	ed 91       	ld	r30, X+
    3d68:	fc 91       	ld	r31, X
    3d6a:	02 80       	ldd	r0, Z+2	; 0x02
    3d6c:	f3 81       	ldd	r31, Z+3	; 0x03
    3d6e:	e0 2d       	mov	r30, r0
    3d70:	6c e0       	ldi	r22, 0x0C	; 12
    3d72:	19 95       	eicall
    3d74:	08 95       	ret

00003d76 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3d76:	ef 92       	push	r14
    3d78:	ff 92       	push	r15
    3d7a:	0f 93       	push	r16
    3d7c:	1f 93       	push	r17
    3d7e:	cf 93       	push	r28
    3d80:	df 93       	push	r29
    3d82:	ec 01       	movw	r28, r24
    3d84:	7b 01       	movw	r14, r22
    3d86:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3d88:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <_ZN8emstreamC1Ev>
    3d8c:	a8 01       	movw	r20, r16
    3d8e:	b7 01       	movw	r22, r14
    3d90:	ce 01       	movw	r24, r28
    3d92:	08 96       	adiw	r24, 0x08	; 8
    3d94:	0e 94 34 1c 	call	0x3868	; 0x3868 <_ZN7base232C1EjP12USART_struct>
    3d98:	8b e6       	ldi	r24, 0x6B	; 107
    3d9a:	90 e2       	ldi	r25, 0x20	; 32
    3d9c:	88 83       	st	Y, r24
    3d9e:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3da0:	00 3a       	cpi	r16, 0xA0	; 160
    3da2:	88 e0       	ldi	r24, 0x08	; 8
    3da4:	18 07       	cpc	r17, r24
    3da6:	69 f4       	brne	.+26     	; 0x3dc2 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3da8:	84 e4       	ldi	r24, 0x44	; 68
    3daa:	91 e3       	ldi	r25, 0x31	; 49
    3dac:	8f 8b       	std	Y+23, r24	; 0x17
    3dae:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3db0:	8a e3       	ldi	r24, 0x3A	; 58
    3db2:	91 e3       	ldi	r25, 0x31	; 49
    3db4:	89 8f       	std	Y+25, r24	; 0x19
    3db6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3db8:	80 e3       	ldi	r24, 0x30	; 48
    3dba:	91 e3       	ldi	r25, 0x31	; 49
    3dbc:	8b 8f       	std	Y+27, r24	; 0x1b
    3dbe:	9c 8f       	std	Y+28, r25	; 0x1c
    3dc0:	42 c0       	rjmp	.+132    	; 0x3e46 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3dc2:	00 3b       	cpi	r16, 0xB0	; 176
    3dc4:	e8 e0       	ldi	r30, 0x08	; 8
    3dc6:	1e 07       	cpc	r17, r30
    3dc8:	69 f4       	brne	.+26     	; 0x3de4 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3dca:	82 e4       	ldi	r24, 0x42	; 66
    3dcc:	91 e3       	ldi	r25, 0x31	; 49
    3dce:	8f 8b       	std	Y+23, r24	; 0x17
    3dd0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3dd2:	88 e3       	ldi	r24, 0x38	; 56
    3dd4:	91 e3       	ldi	r25, 0x31	; 49
    3dd6:	89 8f       	std	Y+25, r24	; 0x19
    3dd8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3dda:	8e e2       	ldi	r24, 0x2E	; 46
    3ddc:	91 e3       	ldi	r25, 0x31	; 49
    3dde:	8b 8f       	std	Y+27, r24	; 0x1b
    3de0:	9c 8f       	std	Y+28, r25	; 0x1c
    3de2:	31 c0       	rjmp	.+98     	; 0x3e46 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3de4:	00 3a       	cpi	r16, 0xA0	; 160
    3de6:	f9 e0       	ldi	r31, 0x09	; 9
    3de8:	1f 07       	cpc	r17, r31
    3dea:	69 f4       	brne	.+26     	; 0x3e06 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3dec:	80 e4       	ldi	r24, 0x40	; 64
    3dee:	91 e3       	ldi	r25, 0x31	; 49
    3df0:	8f 8b       	std	Y+23, r24	; 0x17
    3df2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3df4:	86 e3       	ldi	r24, 0x36	; 54
    3df6:	91 e3       	ldi	r25, 0x31	; 49
    3df8:	89 8f       	std	Y+25, r24	; 0x19
    3dfa:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3dfc:	8c e2       	ldi	r24, 0x2C	; 44
    3dfe:	91 e3       	ldi	r25, 0x31	; 49
    3e00:	8b 8f       	std	Y+27, r24	; 0x1b
    3e02:	9c 8f       	std	Y+28, r25	; 0x1c
    3e04:	20 c0       	rjmp	.+64     	; 0x3e46 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3e06:	00 3b       	cpi	r16, 0xB0	; 176
    3e08:	89 e0       	ldi	r24, 0x09	; 9
    3e0a:	18 07       	cpc	r17, r24
    3e0c:	69 f4       	brne	.+26     	; 0x3e28 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3e0e:	8e e3       	ldi	r24, 0x3E	; 62
    3e10:	91 e3       	ldi	r25, 0x31	; 49
    3e12:	8f 8b       	std	Y+23, r24	; 0x17
    3e14:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3e16:	84 e3       	ldi	r24, 0x34	; 52
    3e18:	91 e3       	ldi	r25, 0x31	; 49
    3e1a:	89 8f       	std	Y+25, r24	; 0x19
    3e1c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3e1e:	8a e2       	ldi	r24, 0x2A	; 42
    3e20:	91 e3       	ldi	r25, 0x31	; 49
    3e22:	8b 8f       	std	Y+27, r24	; 0x1b
    3e24:	9c 8f       	std	Y+28, r25	; 0x1c
    3e26:	0f c0       	rjmp	.+30     	; 0x3e46 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3e28:	00 3a       	cpi	r16, 0xA0	; 160
    3e2a:	1a 40       	sbci	r17, 0x0A	; 10
    3e2c:	61 f4       	brne	.+24     	; 0x3e46 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3e2e:	8c e3       	ldi	r24, 0x3C	; 60
    3e30:	91 e3       	ldi	r25, 0x31	; 49
    3e32:	8f 8b       	std	Y+23, r24	; 0x17
    3e34:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3e36:	82 e3       	ldi	r24, 0x32	; 50
    3e38:	91 e3       	ldi	r25, 0x31	; 49
    3e3a:	89 8f       	std	Y+25, r24	; 0x19
    3e3c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3e3e:	88 e2       	ldi	r24, 0x28	; 40
    3e40:	91 e3       	ldi	r25, 0x31	; 49
    3e42:	8b 8f       	std	Y+27, r24	; 0x1b
    3e44:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3e46:	0f 89       	ldd	r16, Y+23	; 0x17
    3e48:	18 8d       	ldd	r17, Y+24	; 0x18
    3e4a:	84 e6       	ldi	r24, 0x64	; 100
    3e4c:	90 e0       	ldi	r25, 0x00	; 0
    3e4e:	0e 94 30 1c 	call	0x3860	; 0x3860 <_Znaj>
    3e52:	f8 01       	movw	r30, r16
    3e54:	80 83       	st	Z, r24
    3e56:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3e58:	e9 8d       	ldd	r30, Y+25	; 0x19
    3e5a:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3e5c:	10 82       	st	Z, r1
    3e5e:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3e60:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3e62:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3e64:	10 82       	st	Z, r1
    3e66:	11 82       	std	Z+1, r1	; 0x01
}
    3e68:	df 91       	pop	r29
    3e6a:	cf 91       	pop	r28
    3e6c:	1f 91       	pop	r17
    3e6e:	0f 91       	pop	r16
    3e70:	ff 90       	pop	r15
    3e72:	ef 90       	pop	r14
    3e74:	08 95       	ret

00003e76 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3e76:	1f 92       	push	r1
    3e78:	0f 92       	push	r0
    3e7a:	0f b6       	in	r0, 0x3f	; 63
    3e7c:	0f 92       	push	r0
    3e7e:	11 24       	eor	r1, r1
    3e80:	08 b6       	in	r0, 0x38	; 56
    3e82:	0f 92       	push	r0
    3e84:	18 be       	out	0x38, r1	; 56
    3e86:	0b b6       	in	r0, 0x3b	; 59
    3e88:	0f 92       	push	r0
    3e8a:	1b be       	out	0x3b, r1	; 59
    3e8c:	2f 93       	push	r18
    3e8e:	3f 93       	push	r19
    3e90:	8f 93       	push	r24
    3e92:	9f 93       	push	r25
    3e94:	ef 93       	push	r30
    3e96:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3e98:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3e9c:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    3ea0:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    3ea4:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3ea8:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3eac:	e8 0f       	add	r30, r24
    3eae:	f9 1f       	adc	r31, r25
    3eb0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3eb2:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3eb6:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3eba:	01 96       	adiw	r24, 0x01	; 1
    3ebc:	84 36       	cpi	r24, 0x64	; 100
    3ebe:	91 05       	cpc	r25, r1
    3ec0:	60 f4       	brcc	.+24     	; 0x3eda <__vector_25+0x64>
    3ec2:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    3ec6:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3eca:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    3ece:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3ed2:	82 17       	cp	r24, r18
    3ed4:	93 07       	cpc	r25, r19
    3ed6:	f1 f4       	brne	.+60     	; 0x3f14 <__vector_25+0x9e>
    3ed8:	0c c0       	rjmp	.+24     	; 0x3ef2 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3eda:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    3ede:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3ee2:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    3ee6:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3eea:	18 16       	cp	r1, r24
    3eec:	19 06       	cpc	r1, r25
    3eee:	91 f4       	brne	.+36     	; 0x3f14 <__vector_25+0x9e>
    3ef0:	0e c0       	rjmp	.+28     	; 0x3f0e <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3ef2:	01 96       	adiw	r24, 0x01	; 1
    3ef4:	84 36       	cpi	r24, 0x64	; 100
    3ef6:	91 05       	cpc	r25, r1
    3ef8:	28 f4       	brcc	.+10     	; 0x3f04 <__vector_25+0x8e>
    3efa:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    3efe:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    3f02:	08 c0       	rjmp	.+16     	; 0x3f14 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3f04:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    3f08:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    3f0c:	03 c0       	rjmp	.+6      	; 0x3f14 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f0e:	81 e0       	ldi	r24, 0x01	; 1
    3f10:	90 e0       	ldi	r25, 0x00	; 0
    3f12:	f3 cf       	rjmp	.-26     	; 0x3efa <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3f14:	ff 91       	pop	r31
    3f16:	ef 91       	pop	r30
    3f18:	9f 91       	pop	r25
    3f1a:	8f 91       	pop	r24
    3f1c:	3f 91       	pop	r19
    3f1e:	2f 91       	pop	r18
    3f20:	0f 90       	pop	r0
    3f22:	0b be       	out	0x3b, r0	; 59
    3f24:	0f 90       	pop	r0
    3f26:	08 be       	out	0x38, r0	; 56
    3f28:	0f 90       	pop	r0
    3f2a:	0f be       	out	0x3f, r0	; 63
    3f2c:	0f 90       	pop	r0
    3f2e:	1f 90       	pop	r1
    3f30:	18 95       	reti

00003f32 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3f32:	1f 92       	push	r1
    3f34:	0f 92       	push	r0
    3f36:	0f b6       	in	r0, 0x3f	; 63
    3f38:	0f 92       	push	r0
    3f3a:	11 24       	eor	r1, r1
    3f3c:	08 b6       	in	r0, 0x38	; 56
    3f3e:	0f 92       	push	r0
    3f40:	18 be       	out	0x38, r1	; 56
    3f42:	0b b6       	in	r0, 0x3b	; 59
    3f44:	0f 92       	push	r0
    3f46:	1b be       	out	0x3b, r1	; 59
    3f48:	2f 93       	push	r18
    3f4a:	3f 93       	push	r19
    3f4c:	8f 93       	push	r24
    3f4e:	9f 93       	push	r25
    3f50:	ef 93       	push	r30
    3f52:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3f54:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3f58:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    3f5c:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3f60:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3f64:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3f68:	e8 0f       	add	r30, r24
    3f6a:	f9 1f       	adc	r31, r25
    3f6c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3f6e:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3f72:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3f76:	01 96       	adiw	r24, 0x01	; 1
    3f78:	84 36       	cpi	r24, 0x64	; 100
    3f7a:	91 05       	cpc	r25, r1
    3f7c:	60 f4       	brcc	.+24     	; 0x3f96 <__vector_28+0x64>
    3f7e:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    3f82:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3f86:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    3f8a:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    3f8e:	82 17       	cp	r24, r18
    3f90:	93 07       	cpc	r25, r19
    3f92:	f1 f4       	brne	.+60     	; 0x3fd0 <__vector_28+0x9e>
    3f94:	0c c0       	rjmp	.+24     	; 0x3fae <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3f96:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    3f9a:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3f9e:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    3fa2:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    3fa6:	18 16       	cp	r1, r24
    3fa8:	19 06       	cpc	r1, r25
    3faa:	91 f4       	brne	.+36     	; 0x3fd0 <__vector_28+0x9e>
    3fac:	0e c0       	rjmp	.+28     	; 0x3fca <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3fae:	01 96       	adiw	r24, 0x01	; 1
    3fb0:	84 36       	cpi	r24, 0x64	; 100
    3fb2:	91 05       	cpc	r25, r1
    3fb4:	28 f4       	brcc	.+10     	; 0x3fc0 <__vector_28+0x8e>
    3fb6:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    3fba:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    3fbe:	08 c0       	rjmp	.+16     	; 0x3fd0 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3fc0:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    3fc4:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    3fc8:	03 c0       	rjmp	.+6      	; 0x3fd0 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3fca:	81 e0       	ldi	r24, 0x01	; 1
    3fcc:	90 e0       	ldi	r25, 0x00	; 0
    3fce:	f3 cf       	rjmp	.-26     	; 0x3fb6 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3fd0:	ff 91       	pop	r31
    3fd2:	ef 91       	pop	r30
    3fd4:	9f 91       	pop	r25
    3fd6:	8f 91       	pop	r24
    3fd8:	3f 91       	pop	r19
    3fda:	2f 91       	pop	r18
    3fdc:	0f 90       	pop	r0
    3fde:	0b be       	out	0x3b, r0	; 59
    3fe0:	0f 90       	pop	r0
    3fe2:	08 be       	out	0x38, r0	; 56
    3fe4:	0f 90       	pop	r0
    3fe6:	0f be       	out	0x3f, r0	; 63
    3fe8:	0f 90       	pop	r0
    3fea:	1f 90       	pop	r1
    3fec:	18 95       	reti

00003fee <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3fee:	1f 92       	push	r1
    3ff0:	0f 92       	push	r0
    3ff2:	0f b6       	in	r0, 0x3f	; 63
    3ff4:	0f 92       	push	r0
    3ff6:	11 24       	eor	r1, r1
    3ff8:	08 b6       	in	r0, 0x38	; 56
    3ffa:	0f 92       	push	r0
    3ffc:	18 be       	out	0x38, r1	; 56
    3ffe:	0b b6       	in	r0, 0x3b	; 59
    4000:	0f 92       	push	r0
    4002:	1b be       	out	0x3b, r1	; 59
    4004:	2f 93       	push	r18
    4006:	3f 93       	push	r19
    4008:	8f 93       	push	r24
    400a:	9f 93       	push	r25
    400c:	ef 93       	push	r30
    400e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    4010:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    4014:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    4018:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    401c:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    4020:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    4024:	e8 0f       	add	r30, r24
    4026:	f9 1f       	adc	r31, r25
    4028:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    402a:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    402e:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    4032:	01 96       	adiw	r24, 0x01	; 1
    4034:	84 36       	cpi	r24, 0x64	; 100
    4036:	91 05       	cpc	r25, r1
    4038:	60 f4       	brcc	.+24     	; 0x4052 <__stack+0x53>
    403a:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    403e:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    4042:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    4046:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    404a:	82 17       	cp	r24, r18
    404c:	93 07       	cpc	r25, r19
    404e:	f1 f4       	brne	.+60     	; 0x408c <__stack+0x8d>
    4050:	0c c0       	rjmp	.+24     	; 0x406a <__stack+0x6b>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    4052:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    4056:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    405a:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    405e:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    4062:	18 16       	cp	r1, r24
    4064:	19 06       	cpc	r1, r25
    4066:	91 f4       	brne	.+36     	; 0x408c <__stack+0x8d>
    4068:	0e c0       	rjmp	.+28     	; 0x4086 <__stack+0x87>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    406a:	01 96       	adiw	r24, 0x01	; 1
    406c:	84 36       	cpi	r24, 0x64	; 100
    406e:	91 05       	cpc	r25, r1
    4070:	28 f4       	brcc	.+10     	; 0x407c <__stack+0x7d>
    4072:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    4076:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    407a:	08 c0       	rjmp	.+16     	; 0x408c <__stack+0x8d>
	rcvD0_read_index = 0;
    407c:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    4080:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    4084:	03 c0       	rjmp	.+6      	; 0x408c <__stack+0x8d>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4086:	81 e0       	ldi	r24, 0x01	; 1
    4088:	90 e0       	ldi	r25, 0x00	; 0
    408a:	f3 cf       	rjmp	.-26     	; 0x4072 <__stack+0x73>
	rcvD0_read_index = 0;
}
    408c:	ff 91       	pop	r31
    408e:	ef 91       	pop	r30
    4090:	9f 91       	pop	r25
    4092:	8f 91       	pop	r24
    4094:	3f 91       	pop	r19
    4096:	2f 91       	pop	r18
    4098:	0f 90       	pop	r0
    409a:	0b be       	out	0x3b, r0	; 59
    409c:	0f 90       	pop	r0
    409e:	08 be       	out	0x38, r0	; 56
    40a0:	0f 90       	pop	r0
    40a2:	0f be       	out	0x3f, r0	; 63
    40a4:	0f 90       	pop	r0
    40a6:	1f 90       	pop	r1
    40a8:	18 95       	reti

000040aa <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    40aa:	1f 92       	push	r1
    40ac:	0f 92       	push	r0
    40ae:	0f b6       	in	r0, 0x3f	; 63
    40b0:	0f 92       	push	r0
    40b2:	11 24       	eor	r1, r1
    40b4:	08 b6       	in	r0, 0x38	; 56
    40b6:	0f 92       	push	r0
    40b8:	18 be       	out	0x38, r1	; 56
    40ba:	0b b6       	in	r0, 0x3b	; 59
    40bc:	0f 92       	push	r0
    40be:	1b be       	out	0x3b, r1	; 59
    40c0:	2f 93       	push	r18
    40c2:	3f 93       	push	r19
    40c4:	8f 93       	push	r24
    40c6:	9f 93       	push	r25
    40c8:	ef 93       	push	r30
    40ca:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    40cc:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    40d0:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    40d4:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    40d8:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    40dc:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    40e0:	e8 0f       	add	r30, r24
    40e2:	f9 1f       	adc	r31, r25
    40e4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    40e6:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    40ea:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    40ee:	01 96       	adiw	r24, 0x01	; 1
    40f0:	84 36       	cpi	r24, 0x64	; 100
    40f2:	91 05       	cpc	r25, r1
    40f4:	60 f4       	brcc	.+24     	; 0x410e <__vector_91+0x64>
    40f6:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    40fa:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    40fe:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    4102:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    4106:	82 17       	cp	r24, r18
    4108:	93 07       	cpc	r25, r19
    410a:	f1 f4       	brne	.+60     	; 0x4148 <__vector_91+0x9e>
    410c:	0c c0       	rjmp	.+24     	; 0x4126 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    410e:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    4112:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4116:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    411a:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    411e:	18 16       	cp	r1, r24
    4120:	19 06       	cpc	r1, r25
    4122:	91 f4       	brne	.+36     	; 0x4148 <__vector_91+0x9e>
    4124:	0e c0       	rjmp	.+28     	; 0x4142 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4126:	01 96       	adiw	r24, 0x01	; 1
    4128:	84 36       	cpi	r24, 0x64	; 100
    412a:	91 05       	cpc	r25, r1
    412c:	28 f4       	brcc	.+10     	; 0x4138 <__vector_91+0x8e>
    412e:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    4132:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    4136:	08 c0       	rjmp	.+16     	; 0x4148 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    4138:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    413c:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    4140:	03 c0       	rjmp	.+6      	; 0x4148 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4142:	81 e0       	ldi	r24, 0x01	; 1
    4144:	90 e0       	ldi	r25, 0x00	; 0
    4146:	f3 cf       	rjmp	.-26     	; 0x412e <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    4148:	ff 91       	pop	r31
    414a:	ef 91       	pop	r30
    414c:	9f 91       	pop	r25
    414e:	8f 91       	pop	r24
    4150:	3f 91       	pop	r19
    4152:	2f 91       	pop	r18
    4154:	0f 90       	pop	r0
    4156:	0b be       	out	0x3b, r0	; 59
    4158:	0f 90       	pop	r0
    415a:	08 be       	out	0x38, r0	; 56
    415c:	0f 90       	pop	r0
    415e:	0f be       	out	0x3f, r0	; 63
    4160:	0f 90       	pop	r0
    4162:	1f 90       	pop	r1
    4164:	18 95       	reti

00004166 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    4166:	1f 92       	push	r1
    4168:	0f 92       	push	r0
    416a:	0f b6       	in	r0, 0x3f	; 63
    416c:	0f 92       	push	r0
    416e:	11 24       	eor	r1, r1
    4170:	08 b6       	in	r0, 0x38	; 56
    4172:	0f 92       	push	r0
    4174:	18 be       	out	0x38, r1	; 56
    4176:	0b b6       	in	r0, 0x3b	; 59
    4178:	0f 92       	push	r0
    417a:	1b be       	out	0x3b, r1	; 59
    417c:	2f 93       	push	r18
    417e:	3f 93       	push	r19
    4180:	8f 93       	push	r24
    4182:	9f 93       	push	r25
    4184:	ef 93       	push	r30
    4186:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    4188:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    418c:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    4190:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    4194:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    4198:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    419c:	e8 0f       	add	r30, r24
    419e:	f9 1f       	adc	r31, r25
    41a0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    41a2:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    41a6:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    41aa:	01 96       	adiw	r24, 0x01	; 1
    41ac:	84 36       	cpi	r24, 0x64	; 100
    41ae:	91 05       	cpc	r25, r1
    41b0:	60 f4       	brcc	.+24     	; 0x41ca <__vector_58+0x64>
    41b2:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    41b6:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    41ba:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    41be:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    41c2:	82 17       	cp	r24, r18
    41c4:	93 07       	cpc	r25, r19
    41c6:	f1 f4       	brne	.+60     	; 0x4204 <__vector_58+0x9e>
    41c8:	0c c0       	rjmp	.+24     	; 0x41e2 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    41ca:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    41ce:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    41d2:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    41d6:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    41da:	18 16       	cp	r1, r24
    41dc:	19 06       	cpc	r1, r25
    41de:	91 f4       	brne	.+36     	; 0x4204 <__vector_58+0x9e>
    41e0:	0e c0       	rjmp	.+28     	; 0x41fe <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    41e2:	01 96       	adiw	r24, 0x01	; 1
    41e4:	84 36       	cpi	r24, 0x64	; 100
    41e6:	91 05       	cpc	r25, r1
    41e8:	28 f4       	brcc	.+10     	; 0x41f4 <__vector_58+0x8e>
    41ea:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    41ee:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    41f2:	08 c0       	rjmp	.+16     	; 0x4204 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    41f4:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    41f8:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    41fc:	03 c0       	rjmp	.+6      	; 0x4204 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    41fe:	81 e0       	ldi	r24, 0x01	; 1
    4200:	90 e0       	ldi	r25, 0x00	; 0
    4202:	f3 cf       	rjmp	.-26     	; 0x41ea <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    4204:	ff 91       	pop	r31
    4206:	ef 91       	pop	r30
    4208:	9f 91       	pop	r25
    420a:	8f 91       	pop	r24
    420c:	3f 91       	pop	r19
    420e:	2f 91       	pop	r18
    4210:	0f 90       	pop	r0
    4212:	0b be       	out	0x3b, r0	; 59
    4214:	0f 90       	pop	r0
    4216:	08 be       	out	0x38, r0	; 56
    4218:	0f 90       	pop	r0
    421a:	0f be       	out	0x3f, r0	; 63
    421c:	0f 90       	pop	r0
    421e:	1f 90       	pop	r1
    4220:	18 95       	reti

00004222 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4222:	0f 93       	push	r16
    4224:	cf 93       	push	r28
    4226:	df 93       	push	r29
    4228:	1f 92       	push	r1
    422a:	cd b7       	in	r28, 0x3d	; 61
    422c:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    422e:	2f b7       	in	r18, 0x3f	; 63
    4230:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4232:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4234:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4236:	fc 01       	movw	r30, r24
    4238:	08 ed       	ldi	r16, 0xD8	; 216
    423a:	04 bf       	out	0x34, r16	; 52
    423c:	60 83       	st	Z, r22

	SREG = saved_sreg;
    423e:	89 81       	ldd	r24, Y+1	; 0x01
    4240:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4242:	0f 90       	pop	r0
    4244:	df 91       	pop	r29
    4246:	cf 91       	pop	r28
    4248:	0f 91       	pop	r16
    424a:	08 95       	ret

0000424c <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    424c:	0f 93       	push	r16
    424e:	1f 93       	push	r17
    4250:	cf 93       	push	r28
    4252:	df 93       	push	r29
    4254:	cd b7       	in	r28, 0x3d	; 61
    4256:	de b7       	in	r29, 0x3e	; 62
    4258:	6d 97       	sbiw	r28, 0x1d	; 29
    425a:	cd bf       	out	0x3d, r28	; 61
    425c:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    425e:	e0 e6       	ldi	r30, 0x60	; 96
    4260:	f6 e0       	ldi	r31, 0x06	; 6
    4262:	80 e4       	ldi	r24, 0x40	; 64
    4264:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    4266:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    4268:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    426a:	e0 e5       	ldi	r30, 0x50	; 80
    426c:	f0 e0       	ldi	r31, 0x00	; 0
    426e:	80 81       	ld	r24, Z
    4270:	82 60       	ori	r24, 0x02	; 2
    4272:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4274:	81 81       	ldd	r24, Z+1	; 0x01
    4276:	81 ff       	sbrs	r24, 1
    4278:	fd cf       	rjmp	.-6      	; 0x4274 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    427a:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    427e:	68 7f       	andi	r22, 0xF8	; 248
    4280:	61 60       	ori	r22, 0x01	; 1
    4282:	80 e4       	ldi	r24, 0x40	; 64
    4284:	90 e0       	ldi	r25, 0x00	; 0
    4286:	0e 94 11 21 	call	0x4222	; 0x4222 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    428a:	e0 e5       	ldi	r30, 0x50	; 80
    428c:	f0 e0       	ldi	r31, 0x00	; 0
    428e:	80 81       	ld	r24, Z
    4290:	8e 7f       	andi	r24, 0xFE	; 254
    4292:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4294:	9d ef       	ldi	r25, 0xFD	; 253
    4296:	88 ed       	ldi	r24, 0xD8	; 216
    4298:	08 b6       	in	r0, 0x38	; 56
    429a:	18 be       	out	0x38, r1	; 56
    429c:	84 bf       	out	0x34, r24	; 52
    429e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    42a2:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    42a4:	40 eb       	ldi	r20, 0xB0	; 176
    42a6:	58 e0       	ldi	r21, 0x08	; 8
    42a8:	60 e0       	ldi	r22, 0x00	; 0
    42aa:	70 e0       	ldi	r23, 0x00	; 0
    42ac:	ce 01       	movw	r24, r28
    42ae:	01 96       	adiw	r24, 0x01	; 1
    42b0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    42b4:	67 e0       	ldi	r22, 0x07	; 7
    42b6:	ce 01       	movw	r24, r28
    42b8:	01 96       	adiw	r24, 0x01	; 1
    42ba:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    42be:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    42c0:	67 e7       	ldi	r22, 0x77	; 119
    42c2:	70 e2       	ldi	r23, 0x20	; 32
    42c4:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <_ZN8emstream4putsEPKc>
    42c8:	66 e0       	ldi	r22, 0x06	; 6
    42ca:	c8 01       	movw	r24, r16
    42cc:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
    42d0:	66 e0       	ldi	r22, 0x06	; 6
    42d2:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    42d6:	82 e1       	ldi	r24, 0x12	; 18
    42d8:	90 e0       	ldi	r25, 0x00	; 0
    42da:	0e 94 2d 1c 	call	0x385a	; 0x385a <_Znwj>
    42de:	8e 01       	movw	r16, r28
    42e0:	0f 5f       	subi	r16, 0xFF	; 255
    42e2:	1f 4f       	sbci	r17, 0xFF	; 255
    42e4:	24 e0       	ldi	r18, 0x04	; 4
    42e6:	31 e0       	ldi	r19, 0x01	; 1
    42e8:	40 e0       	ldi	r20, 0x00	; 0
    42ea:	66 e9       	ldi	r22, 0x96	; 150
    42ec:	70 e2       	ldi	r23, 0x20	; 32
    42ee:	0e 94 5d 09 	call	0x12ba	; 0x12ba <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    42f2:	82 e1       	ldi	r24, 0x12	; 18
    42f4:	90 e0       	ldi	r25, 0x00	; 0
    42f6:	0e 94 2d 1c 	call	0x385a	; 0x385a <_Znwj>
    42fa:	24 e0       	ldi	r18, 0x04	; 4
    42fc:	31 e0       	ldi	r19, 0x01	; 1
    42fe:	42 e0       	ldi	r20, 0x02	; 2
    4300:	6e e9       	ldi	r22, 0x9E	; 158
    4302:	70 e2       	ldi	r23, 0x20	; 32
    4304:	0e 94 4b 04 	call	0x896	; 0x896 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    4308:	82 e1       	ldi	r24, 0x12	; 18
    430a:	90 e0       	ldi	r25, 0x00	; 0
    430c:	0e 94 2d 1c 	call	0x385a	; 0x385a <_Znwj>
    4310:	24 e0       	ldi	r18, 0x04	; 4
    4312:	31 e0       	ldi	r19, 0x01	; 1
    4314:	43 e0       	ldi	r20, 0x03	; 3
    4316:	65 ea       	ldi	r22, 0xA5	; 165
    4318:	70 e2       	ldi	r23, 0x20	; 32
    431a:	0e 94 a4 04 	call	0x948	; 0x948 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    431e:	82 e1       	ldi	r24, 0x12	; 18
    4320:	90 e0       	ldi	r25, 0x00	; 0
    4322:	0e 94 2d 1c 	call	0x385a	; 0x385a <_Znwj>
    4326:	24 e0       	ldi	r18, 0x04	; 4
    4328:	31 e0       	ldi	r19, 0x01	; 1
    432a:	44 e0       	ldi	r20, 0x04	; 4
    432c:	6c ea       	ldi	r22, 0xAC	; 172
    432e:	70 e2       	ldi	r23, 0x20	; 32
    4330:	0e 94 09 05 	call	0xa12	; 0xa12 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    4334:	8c e6       	ldi	r24, 0x6C	; 108
    4336:	90 e0       	ldi	r25, 0x00	; 0
    4338:	0e 94 2d 1c 	call	0x385a	; 0x385a <_Znwj>
    433c:	24 e0       	ldi	r18, 0x04	; 4
    433e:	31 e0       	ldi	r19, 0x01	; 1
    4340:	43 e0       	ldi	r20, 0x03	; 3
    4342:	65 eb       	ldi	r22, 0xB5	; 181
    4344:	70 e2       	ldi	r23, 0x20	; 32
    4346:	0e 94 1f 09 	call	0x123e	; 0x123e <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    434a:	87 e0       	ldi	r24, 0x07	; 7
    434c:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4350:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4352:	0e 94 3f 13 	call	0x267e	; 0x267e <vTaskStartScheduler>
	
	
	return 0;
    4356:	80 e0       	ldi	r24, 0x00	; 0
    4358:	90 e0       	ldi	r25, 0x00	; 0
    435a:	6d 96       	adiw	r28, 0x1d	; 29
    435c:	cd bf       	out	0x3d, r28	; 61
    435e:	de bf       	out	0x3e, r29	; 62
    4360:	df 91       	pop	r29
    4362:	cf 91       	pop	r28
    4364:	1f 91       	pop	r17
    4366:	0f 91       	pop	r16
    4368:	08 95       	ret

0000436a <_GLOBAL__sub_I_counter>:
    436a:	0f 93       	push	r16
    436c:	1f 93       	push	r17
#include "LimitSwitches.h"					// Header for Limit Switches
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    436e:	0a e0       	ldi	r16, 0x0A	; 10
    4370:	10 e0       	ldi	r17, 0x00	; 0
    4372:	20 e0       	ldi	r18, 0x00	; 0
    4374:	30 e0       	ldi	r19, 0x00	; 0
    4376:	40 e0       	ldi	r20, 0x00	; 0
    4378:	50 e0       	ldi	r21, 0x00	; 0
    437a:	60 e2       	ldi	r22, 0x20	; 32
    437c:	70 e0       	ldi	r23, 0x00	; 0
    437e:	84 e5       	ldi	r24, 0x54	; 84
    4380:	91 e3       	ldi	r25, 0x31	; 49
    4382:	0e 94 99 1a 	call	0x3532	; 0x3532 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    4386:	1f 91       	pop	r17
    4388:	0f 91       	pop	r16
    438a:	08 95       	ret

0000438c <__cmpsf2>:
    438c:	0e 94 08 22 	call	0x4410	; 0x4410 <__fp_cmp>
    4390:	08 f4       	brcc	.+2      	; 0x4394 <__cmpsf2+0x8>
    4392:	81 e0       	ldi	r24, 0x01	; 1
    4394:	08 95       	ret

00004396 <__floatunsisf>:
    4396:	e8 94       	clt
    4398:	09 c0       	rjmp	.+18     	; 0x43ac <__floatsisf+0x12>

0000439a <__floatsisf>:
    439a:	97 fb       	bst	r25, 7
    439c:	3e f4       	brtc	.+14     	; 0x43ac <__floatsisf+0x12>
    439e:	90 95       	com	r25
    43a0:	80 95       	com	r24
    43a2:	70 95       	com	r23
    43a4:	61 95       	neg	r22
    43a6:	7f 4f       	sbci	r23, 0xFF	; 255
    43a8:	8f 4f       	sbci	r24, 0xFF	; 255
    43aa:	9f 4f       	sbci	r25, 0xFF	; 255
    43ac:	99 23       	and	r25, r25
    43ae:	a9 f0       	breq	.+42     	; 0x43da <__floatsisf+0x40>
    43b0:	f9 2f       	mov	r31, r25
    43b2:	96 e9       	ldi	r25, 0x96	; 150
    43b4:	bb 27       	eor	r27, r27
    43b6:	93 95       	inc	r25
    43b8:	f6 95       	lsr	r31
    43ba:	87 95       	ror	r24
    43bc:	77 95       	ror	r23
    43be:	67 95       	ror	r22
    43c0:	b7 95       	ror	r27
    43c2:	f1 11       	cpse	r31, r1
    43c4:	f8 cf       	rjmp	.-16     	; 0x43b6 <__floatsisf+0x1c>
    43c6:	fa f4       	brpl	.+62     	; 0x4406 <__floatsisf+0x6c>
    43c8:	bb 0f       	add	r27, r27
    43ca:	11 f4       	brne	.+4      	; 0x43d0 <__floatsisf+0x36>
    43cc:	60 ff       	sbrs	r22, 0
    43ce:	1b c0       	rjmp	.+54     	; 0x4406 <__floatsisf+0x6c>
    43d0:	6f 5f       	subi	r22, 0xFF	; 255
    43d2:	7f 4f       	sbci	r23, 0xFF	; 255
    43d4:	8f 4f       	sbci	r24, 0xFF	; 255
    43d6:	9f 4f       	sbci	r25, 0xFF	; 255
    43d8:	16 c0       	rjmp	.+44     	; 0x4406 <__floatsisf+0x6c>
    43da:	88 23       	and	r24, r24
    43dc:	11 f0       	breq	.+4      	; 0x43e2 <__floatsisf+0x48>
    43de:	96 e9       	ldi	r25, 0x96	; 150
    43e0:	11 c0       	rjmp	.+34     	; 0x4404 <__floatsisf+0x6a>
    43e2:	77 23       	and	r23, r23
    43e4:	21 f0       	breq	.+8      	; 0x43ee <__floatsisf+0x54>
    43e6:	9e e8       	ldi	r25, 0x8E	; 142
    43e8:	87 2f       	mov	r24, r23
    43ea:	76 2f       	mov	r23, r22
    43ec:	05 c0       	rjmp	.+10     	; 0x43f8 <__floatsisf+0x5e>
    43ee:	66 23       	and	r22, r22
    43f0:	71 f0       	breq	.+28     	; 0x440e <__floatsisf+0x74>
    43f2:	96 e8       	ldi	r25, 0x86	; 134
    43f4:	86 2f       	mov	r24, r22
    43f6:	70 e0       	ldi	r23, 0x00	; 0
    43f8:	60 e0       	ldi	r22, 0x00	; 0
    43fa:	2a f0       	brmi	.+10     	; 0x4406 <__floatsisf+0x6c>
    43fc:	9a 95       	dec	r25
    43fe:	66 0f       	add	r22, r22
    4400:	77 1f       	adc	r23, r23
    4402:	88 1f       	adc	r24, r24
    4404:	da f7       	brpl	.-10     	; 0x43fc <__floatsisf+0x62>
    4406:	88 0f       	add	r24, r24
    4408:	96 95       	lsr	r25
    440a:	87 95       	ror	r24
    440c:	97 f9       	bld	r25, 7
    440e:	08 95       	ret

00004410 <__fp_cmp>:
    4410:	99 0f       	add	r25, r25
    4412:	00 08       	sbc	r0, r0
    4414:	55 0f       	add	r21, r21
    4416:	aa 0b       	sbc	r26, r26
    4418:	e0 e8       	ldi	r30, 0x80	; 128
    441a:	fe ef       	ldi	r31, 0xFE	; 254
    441c:	16 16       	cp	r1, r22
    441e:	17 06       	cpc	r1, r23
    4420:	e8 07       	cpc	r30, r24
    4422:	f9 07       	cpc	r31, r25
    4424:	c0 f0       	brcs	.+48     	; 0x4456 <__fp_cmp+0x46>
    4426:	12 16       	cp	r1, r18
    4428:	13 06       	cpc	r1, r19
    442a:	e4 07       	cpc	r30, r20
    442c:	f5 07       	cpc	r31, r21
    442e:	98 f0       	brcs	.+38     	; 0x4456 <__fp_cmp+0x46>
    4430:	62 1b       	sub	r22, r18
    4432:	73 0b       	sbc	r23, r19
    4434:	84 0b       	sbc	r24, r20
    4436:	95 0b       	sbc	r25, r21
    4438:	39 f4       	brne	.+14     	; 0x4448 <__fp_cmp+0x38>
    443a:	0a 26       	eor	r0, r26
    443c:	61 f0       	breq	.+24     	; 0x4456 <__fp_cmp+0x46>
    443e:	23 2b       	or	r18, r19
    4440:	24 2b       	or	r18, r20
    4442:	25 2b       	or	r18, r21
    4444:	21 f4       	brne	.+8      	; 0x444e <__fp_cmp+0x3e>
    4446:	08 95       	ret
    4448:	0a 26       	eor	r0, r26
    444a:	09 f4       	brne	.+2      	; 0x444e <__fp_cmp+0x3e>
    444c:	a1 40       	sbci	r26, 0x01	; 1
    444e:	a6 95       	lsr	r26
    4450:	8f ef       	ldi	r24, 0xFF	; 255
    4452:	81 1d       	adc	r24, r1
    4454:	81 1d       	adc	r24, r1
    4456:	08 95       	ret

00004458 <__gesf2>:
    4458:	0e 94 08 22 	call	0x4410	; 0x4410 <__fp_cmp>
    445c:	08 f4       	brcc	.+2      	; 0x4460 <__gesf2+0x8>
    445e:	8f ef       	ldi	r24, 0xFF	; 255
    4460:	08 95       	ret

00004462 <__mulsi3>:
    4462:	db 01       	movw	r26, r22
    4464:	8f 93       	push	r24
    4466:	9f 93       	push	r25
    4468:	0e 94 bd 22 	call	0x457a	; 0x457a <__muluhisi3>
    446c:	bf 91       	pop	r27
    446e:	af 91       	pop	r26
    4470:	a2 9f       	mul	r26, r18
    4472:	80 0d       	add	r24, r0
    4474:	91 1d       	adc	r25, r1
    4476:	a3 9f       	mul	r26, r19
    4478:	90 0d       	add	r25, r0
    447a:	b2 9f       	mul	r27, r18
    447c:	90 0d       	add	r25, r0
    447e:	11 24       	eor	r1, r1
    4480:	08 95       	ret

00004482 <__divmodhi4>:
    4482:	97 fb       	bst	r25, 7
    4484:	07 2e       	mov	r0, r23
    4486:	16 f4       	brtc	.+4      	; 0x448c <__divmodhi4+0xa>
    4488:	00 94       	com	r0
    448a:	07 d0       	rcall	.+14     	; 0x449a <__divmodhi4_neg1>
    448c:	77 fd       	sbrc	r23, 7
    448e:	09 d0       	rcall	.+18     	; 0x44a2 <__divmodhi4_neg2>
    4490:	0e 94 d0 22 	call	0x45a0	; 0x45a0 <__udivmodhi4>
    4494:	07 fc       	sbrc	r0, 7
    4496:	05 d0       	rcall	.+10     	; 0x44a2 <__divmodhi4_neg2>
    4498:	3e f4       	brtc	.+14     	; 0x44a8 <__divmodhi4_exit>

0000449a <__divmodhi4_neg1>:
    449a:	90 95       	com	r25
    449c:	81 95       	neg	r24
    449e:	9f 4f       	sbci	r25, 0xFF	; 255
    44a0:	08 95       	ret

000044a2 <__divmodhi4_neg2>:
    44a2:	70 95       	com	r23
    44a4:	61 95       	neg	r22
    44a6:	7f 4f       	sbci	r23, 0xFF	; 255

000044a8 <__divmodhi4_exit>:
    44a8:	08 95       	ret

000044aa <__udivmodsi4>:
    44aa:	a1 e2       	ldi	r26, 0x21	; 33
    44ac:	1a 2e       	mov	r1, r26
    44ae:	aa 1b       	sub	r26, r26
    44b0:	bb 1b       	sub	r27, r27
    44b2:	fd 01       	movw	r30, r26
    44b4:	0d c0       	rjmp	.+26     	; 0x44d0 <__udivmodsi4_ep>

000044b6 <__udivmodsi4_loop>:
    44b6:	aa 1f       	adc	r26, r26
    44b8:	bb 1f       	adc	r27, r27
    44ba:	ee 1f       	adc	r30, r30
    44bc:	ff 1f       	adc	r31, r31
    44be:	a2 17       	cp	r26, r18
    44c0:	b3 07       	cpc	r27, r19
    44c2:	e4 07       	cpc	r30, r20
    44c4:	f5 07       	cpc	r31, r21
    44c6:	20 f0       	brcs	.+8      	; 0x44d0 <__udivmodsi4_ep>
    44c8:	a2 1b       	sub	r26, r18
    44ca:	b3 0b       	sbc	r27, r19
    44cc:	e4 0b       	sbc	r30, r20
    44ce:	f5 0b       	sbc	r31, r21

000044d0 <__udivmodsi4_ep>:
    44d0:	66 1f       	adc	r22, r22
    44d2:	77 1f       	adc	r23, r23
    44d4:	88 1f       	adc	r24, r24
    44d6:	99 1f       	adc	r25, r25
    44d8:	1a 94       	dec	r1
    44da:	69 f7       	brne	.-38     	; 0x44b6 <__udivmodsi4_loop>
    44dc:	60 95       	com	r22
    44de:	70 95       	com	r23
    44e0:	80 95       	com	r24
    44e2:	90 95       	com	r25
    44e4:	9b 01       	movw	r18, r22
    44e6:	ac 01       	movw	r20, r24
    44e8:	bd 01       	movw	r22, r26
    44ea:	cf 01       	movw	r24, r30
    44ec:	08 95       	ret

000044ee <__divmodsi4>:
    44ee:	05 2e       	mov	r0, r21
    44f0:	97 fb       	bst	r25, 7
    44f2:	1e f4       	brtc	.+6      	; 0x44fa <__divmodsi4+0xc>
    44f4:	00 94       	com	r0
    44f6:	0e 94 8e 22 	call	0x451c	; 0x451c <__negsi2>
    44fa:	57 fd       	sbrc	r21, 7
    44fc:	07 d0       	rcall	.+14     	; 0x450c <__divmodsi4_neg2>
    44fe:	0e 94 55 22 	call	0x44aa	; 0x44aa <__udivmodsi4>
    4502:	07 fc       	sbrc	r0, 7
    4504:	03 d0       	rcall	.+6      	; 0x450c <__divmodsi4_neg2>
    4506:	4e f4       	brtc	.+18     	; 0x451a <__divmodsi4_exit>
    4508:	0c 94 8e 22 	jmp	0x451c	; 0x451c <__negsi2>

0000450c <__divmodsi4_neg2>:
    450c:	50 95       	com	r21
    450e:	40 95       	com	r20
    4510:	30 95       	com	r19
    4512:	21 95       	neg	r18
    4514:	3f 4f       	sbci	r19, 0xFF	; 255
    4516:	4f 4f       	sbci	r20, 0xFF	; 255
    4518:	5f 4f       	sbci	r21, 0xFF	; 255

0000451a <__divmodsi4_exit>:
    451a:	08 95       	ret

0000451c <__negsi2>:
    451c:	90 95       	com	r25
    451e:	80 95       	com	r24
    4520:	70 95       	com	r23
    4522:	61 95       	neg	r22
    4524:	7f 4f       	sbci	r23, 0xFF	; 255
    4526:	8f 4f       	sbci	r24, 0xFF	; 255
    4528:	9f 4f       	sbci	r25, 0xFF	; 255
    452a:	08 95       	ret

0000452c <__tablejump2__>:
    452c:	ee 0f       	add	r30, r30
    452e:	ff 1f       	adc	r31, r31
    4530:	88 1f       	adc	r24, r24
    4532:	8b bf       	out	0x3b, r24	; 59
    4534:	07 90       	elpm	r0, Z+
    4536:	f6 91       	elpm	r31, Z
    4538:	e0 2d       	mov	r30, r0
    453a:	1b be       	out	0x3b, r1	; 59
    453c:	19 94       	eijmp

0000453e <__mulhisi3>:
    453e:	0e 94 a7 22 	call	0x454e	; 0x454e <__umulhisi3>
    4542:	33 23       	and	r19, r19
    4544:	12 f4       	brpl	.+4      	; 0x454a <__mulhisi3+0xc>
    4546:	8a 1b       	sub	r24, r26
    4548:	9b 0b       	sbc	r25, r27
    454a:	0c 94 b8 22 	jmp	0x4570	; 0x4570 <__usmulhisi3_tail>

0000454e <__umulhisi3>:
    454e:	a2 9f       	mul	r26, r18
    4550:	b0 01       	movw	r22, r0
    4552:	b3 9f       	mul	r27, r19
    4554:	c0 01       	movw	r24, r0
    4556:	a3 9f       	mul	r26, r19
    4558:	70 0d       	add	r23, r0
    455a:	81 1d       	adc	r24, r1
    455c:	11 24       	eor	r1, r1
    455e:	91 1d       	adc	r25, r1
    4560:	b2 9f       	mul	r27, r18
    4562:	70 0d       	add	r23, r0
    4564:	81 1d       	adc	r24, r1
    4566:	11 24       	eor	r1, r1
    4568:	91 1d       	adc	r25, r1
    456a:	08 95       	ret

0000456c <__usmulhisi3>:
    456c:	0e 94 a7 22 	call	0x454e	; 0x454e <__umulhisi3>

00004570 <__usmulhisi3_tail>:
    4570:	b7 ff       	sbrs	r27, 7
    4572:	08 95       	ret
    4574:	82 1b       	sub	r24, r18
    4576:	93 0b       	sbc	r25, r19
    4578:	08 95       	ret

0000457a <__muluhisi3>:
    457a:	0e 94 a7 22 	call	0x454e	; 0x454e <__umulhisi3>
    457e:	a5 9f       	mul	r26, r21
    4580:	90 0d       	add	r25, r0
    4582:	b4 9f       	mul	r27, r20
    4584:	90 0d       	add	r25, r0
    4586:	a4 9f       	mul	r26, r20
    4588:	80 0d       	add	r24, r0
    458a:	91 1d       	adc	r25, r1
    458c:	11 24       	eor	r1, r1
    458e:	08 95       	ret

00004590 <__mulshisi3>:
    4590:	b7 ff       	sbrs	r27, 7
    4592:	0c 94 bd 22 	jmp	0x457a	; 0x457a <__muluhisi3>

00004596 <__mulohisi3>:
    4596:	0e 94 bd 22 	call	0x457a	; 0x457a <__muluhisi3>
    459a:	82 1b       	sub	r24, r18
    459c:	93 0b       	sbc	r25, r19
    459e:	08 95       	ret

000045a0 <__udivmodhi4>:
    45a0:	aa 1b       	sub	r26, r26
    45a2:	bb 1b       	sub	r27, r27
    45a4:	51 e1       	ldi	r21, 0x11	; 17
    45a6:	07 c0       	rjmp	.+14     	; 0x45b6 <__udivmodhi4_ep>

000045a8 <__udivmodhi4_loop>:
    45a8:	aa 1f       	adc	r26, r26
    45aa:	bb 1f       	adc	r27, r27
    45ac:	a6 17       	cp	r26, r22
    45ae:	b7 07       	cpc	r27, r23
    45b0:	10 f0       	brcs	.+4      	; 0x45b6 <__udivmodhi4_ep>
    45b2:	a6 1b       	sub	r26, r22
    45b4:	b7 0b       	sbc	r27, r23

000045b6 <__udivmodhi4_ep>:
    45b6:	88 1f       	adc	r24, r24
    45b8:	99 1f       	adc	r25, r25
    45ba:	5a 95       	dec	r21
    45bc:	a9 f7       	brne	.-22     	; 0x45a8 <__udivmodhi4_loop>
    45be:	80 95       	com	r24
    45c0:	90 95       	com	r25
    45c2:	bc 01       	movw	r22, r24
    45c4:	cd 01       	movw	r24, r26
    45c6:	08 95       	ret

000045c8 <memcpy>:
    45c8:	fb 01       	movw	r30, r22
    45ca:	dc 01       	movw	r26, r24
    45cc:	02 c0       	rjmp	.+4      	; 0x45d2 <memcpy+0xa>
    45ce:	01 90       	ld	r0, Z+
    45d0:	0d 92       	st	X+, r0
    45d2:	41 50       	subi	r20, 0x01	; 1
    45d4:	50 40       	sbci	r21, 0x00	; 0
    45d6:	d8 f7       	brcc	.-10     	; 0x45ce <memcpy+0x6>
    45d8:	08 95       	ret

000045da <memset>:
    45da:	dc 01       	movw	r26, r24
    45dc:	01 c0       	rjmp	.+2      	; 0x45e0 <memset+0x6>
    45de:	6d 93       	st	X+, r22
    45e0:	41 50       	subi	r20, 0x01	; 1
    45e2:	50 40       	sbci	r21, 0x00	; 0
    45e4:	e0 f7       	brcc	.-8      	; 0x45de <memset+0x4>
    45e6:	08 95       	ret

000045e8 <strncpy>:
    45e8:	fb 01       	movw	r30, r22
    45ea:	dc 01       	movw	r26, r24
    45ec:	41 50       	subi	r20, 0x01	; 1
    45ee:	50 40       	sbci	r21, 0x00	; 0
    45f0:	48 f0       	brcs	.+18     	; 0x4604 <strncpy+0x1c>
    45f2:	01 90       	ld	r0, Z+
    45f4:	0d 92       	st	X+, r0
    45f6:	00 20       	and	r0, r0
    45f8:	c9 f7       	brne	.-14     	; 0x45ec <strncpy+0x4>
    45fa:	01 c0       	rjmp	.+2      	; 0x45fe <strncpy+0x16>
    45fc:	1d 92       	st	X+, r1
    45fe:	41 50       	subi	r20, 0x01	; 1
    4600:	50 40       	sbci	r21, 0x00	; 0
    4602:	e0 f7       	brcc	.-8      	; 0x45fc <strncpy+0x14>
    4604:	08 95       	ret

00004606 <ultoa>:
    4606:	25 32       	cpi	r18, 0x25	; 37
    4608:	31 05       	cpc	r19, r1
    460a:	20 f4       	brcc	.+8      	; 0x4614 <ultoa+0xe>
    460c:	22 30       	cpi	r18, 0x02	; 2
    460e:	10 f0       	brcs	.+4      	; 0x4614 <ultoa+0xe>
    4610:	0c 94 0e 23 	jmp	0x461c	; 0x461c <__ultoa_ncheck>
    4614:	fa 01       	movw	r30, r20
    4616:	10 82       	st	Z, r1
    4618:	ca 01       	movw	r24, r20
    461a:	08 95       	ret

0000461c <__ultoa_ncheck>:
    461c:	bb 27       	eor	r27, r27

0000461e <__ultoa_common>:
    461e:	fa 01       	movw	r30, r20
    4620:	a6 2f       	mov	r26, r22
    4622:	62 17       	cp	r22, r18
    4624:	71 05       	cpc	r23, r1
    4626:	81 05       	cpc	r24, r1
    4628:	91 05       	cpc	r25, r1
    462a:	33 0b       	sbc	r19, r19
    462c:	30 fb       	bst	r19, 0
    462e:	66 f0       	brts	.+24     	; 0x4648 <__ultoa_common+0x2a>
    4630:	aa 27       	eor	r26, r26
    4632:	66 0f       	add	r22, r22
    4634:	77 1f       	adc	r23, r23
    4636:	88 1f       	adc	r24, r24
    4638:	99 1f       	adc	r25, r25
    463a:	aa 1f       	adc	r26, r26
    463c:	a2 17       	cp	r26, r18
    463e:	10 f0       	brcs	.+4      	; 0x4644 <__ultoa_common+0x26>
    4640:	a2 1b       	sub	r26, r18
    4642:	63 95       	inc	r22
    4644:	38 50       	subi	r19, 0x08	; 8
    4646:	a9 f7       	brne	.-22     	; 0x4632 <__ultoa_common+0x14>
    4648:	a0 5d       	subi	r26, 0xD0	; 208
    464a:	aa 33       	cpi	r26, 0x3A	; 58
    464c:	08 f0       	brcs	.+2      	; 0x4650 <__ultoa_common+0x32>
    464e:	a9 5d       	subi	r26, 0xD9	; 217
    4650:	a1 93       	st	Z+, r26
    4652:	36 f7       	brtc	.-52     	; 0x4620 <__ultoa_common+0x2>
    4654:	b1 11       	cpse	r27, r1
    4656:	b1 93       	st	Z+, r27
    4658:	10 82       	st	Z, r1
    465a:	ca 01       	movw	r24, r20
    465c:	0c 94 55 23 	jmp	0x46aa	; 0x46aa <strrev>

00004660 <utoa>:
    4660:	45 32       	cpi	r20, 0x25	; 37
    4662:	51 05       	cpc	r21, r1
    4664:	20 f4       	brcc	.+8      	; 0x466e <utoa+0xe>
    4666:	42 30       	cpi	r20, 0x02	; 2
    4668:	10 f0       	brcs	.+4      	; 0x466e <utoa+0xe>
    466a:	0c 94 3b 23 	jmp	0x4676	; 0x4676 <__utoa_ncheck>
    466e:	fb 01       	movw	r30, r22
    4670:	10 82       	st	Z, r1
    4672:	cb 01       	movw	r24, r22
    4674:	08 95       	ret

00004676 <__utoa_ncheck>:
    4676:	bb 27       	eor	r27, r27

00004678 <__utoa_common>:
    4678:	fb 01       	movw	r30, r22
    467a:	55 27       	eor	r21, r21
    467c:	aa 27       	eor	r26, r26
    467e:	88 0f       	add	r24, r24
    4680:	99 1f       	adc	r25, r25
    4682:	aa 1f       	adc	r26, r26
    4684:	a4 17       	cp	r26, r20
    4686:	10 f0       	brcs	.+4      	; 0x468c <__utoa_common+0x14>
    4688:	a4 1b       	sub	r26, r20
    468a:	83 95       	inc	r24
    468c:	50 51       	subi	r21, 0x10	; 16
    468e:	b9 f7       	brne	.-18     	; 0x467e <__utoa_common+0x6>
    4690:	a0 5d       	subi	r26, 0xD0	; 208
    4692:	aa 33       	cpi	r26, 0x3A	; 58
    4694:	08 f0       	brcs	.+2      	; 0x4698 <__utoa_common+0x20>
    4696:	a9 5d       	subi	r26, 0xD9	; 217
    4698:	a1 93       	st	Z+, r26
    469a:	00 97       	sbiw	r24, 0x00	; 0
    469c:	79 f7       	brne	.-34     	; 0x467c <__utoa_common+0x4>
    469e:	b1 11       	cpse	r27, r1
    46a0:	b1 93       	st	Z+, r27
    46a2:	11 92       	st	Z+, r1
    46a4:	cb 01       	movw	r24, r22
    46a6:	0c 94 55 23 	jmp	0x46aa	; 0x46aa <strrev>

000046aa <strrev>:
    46aa:	dc 01       	movw	r26, r24
    46ac:	fc 01       	movw	r30, r24
    46ae:	67 2f       	mov	r22, r23
    46b0:	71 91       	ld	r23, Z+
    46b2:	77 23       	and	r23, r23
    46b4:	e1 f7       	brne	.-8      	; 0x46ae <strrev+0x4>
    46b6:	32 97       	sbiw	r30, 0x02	; 2
    46b8:	04 c0       	rjmp	.+8      	; 0x46c2 <strrev+0x18>
    46ba:	7c 91       	ld	r23, X
    46bc:	6d 93       	st	X+, r22
    46be:	70 83       	st	Z, r23
    46c0:	62 91       	ld	r22, -Z
    46c2:	ae 17       	cp	r26, r30
    46c4:	bf 07       	cpc	r27, r31
    46c6:	c8 f3       	brcs	.-14     	; 0x46ba <strrev+0x10>
    46c8:	08 95       	ret

000046ca <_exit>:
    46ca:	f8 94       	cli

000046cc <__stop_program>:
    46cc:	ff cf       	rjmp	.-2      	; 0x46cc <__stop_program>
