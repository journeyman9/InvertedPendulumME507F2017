
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000045b6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c8  00802000  000045b6  0000464a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ae  008020c8  008020c8  00004712  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004712  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004744  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006d8  00000000  00000000  00004784  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012242  00000000  00000000  00004e5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00007739  00000000  00000000  0001709e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005043  00000000  00000000  0001e7d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000013f8  00000000  00000000  0002381c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006da7  00000000  00000000  00024c14  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006282  00000000  00000000  0002b9bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000590  00000000  00000000  00031c3d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a7 02 	jmp	0x54e	; 0x54e <__ctors_end>
       4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      10:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      14:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      18:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      1c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      20:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      24:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      28:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      2c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      30:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      34:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      38:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      3c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      40:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      44:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      4c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      50:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      54:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      58:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      5c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      60:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      64:	0c 94 64 1c 	jmp	0x38c8	; 0x38c8 <__vector_25>
      68:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      6c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      70:	0c 94 c2 1c 	jmp	0x3984	; 0x3984 <__vector_28>
      74:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      78:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      7c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      80:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      84:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      88:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      8c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      90:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      94:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      98:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      9c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      dc:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__vector_55>
      e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e8:	0c 94 dc 1d 	jmp	0x3bb8	; 0x3bb8 <__vector_58>
      ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f4:	0c 94 3a 1e 	jmp	0x3c74	; 0x3c74 <__vector_61>
      f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      fc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     100:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     104:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     108:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     10c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     110:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     114:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     118:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     11c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     120:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     124:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     128:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     12c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     130:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     134:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     138:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     13c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     140:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     144:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     148:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     14c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     150:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     154:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     158:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     15c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     160:	0c 94 20 1d 	jmp	0x3a40	; 0x3a40 <__vector_88>
     164:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     168:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     16c:	0c 94 7e 1d 	jmp	0x3afc	; 0x3afc <__vector_91>
     170:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     174:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     178:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     17c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     180:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     184:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     188:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     18c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     190:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     194:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     198:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     19c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1dc:	0c 94 98 1e 	jmp	0x3d30	; 0x3d30 <__vector_119>
     1e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1fc:	16 1a       	sub	r1, r22
     1fe:	19 1a       	sub	r1, r25
     200:	1c 1a       	sub	r1, r28
     202:	1f 1a       	sub	r1, r31
     204:	22 1a       	sub	r2, r18
     206:	25 1a       	sub	r2, r21
     208:	27 1a       	sub	r2, r23
     20a:	38 1a       	sub	r3, r24
     20c:	40 1a       	sub	r4, r16
     20e:	4a 1a       	sub	r4, r26
     210:	48 1a       	sub	r4, r24

00000212 <__trampolines_start>:
     212:	0c 94 80 1b 	jmp	0x3700	; 0x3700 <_ZN5rs2327getcharEv>
     216:	0c 94 25 1a 	jmp	0x344a	; 0x344a <_ZN8emstreamlsE15ser_manipulator+0x3c>
     21a:	0c 94 d8 15 	jmp	0x2bb0	; 0x2bb0 <_ZN8frt_task12print_statusER8emstream>
     21e:	0c 94 1c 1a 	jmp	0x3438	; 0x3438 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     222:	0c 94 c0 19 	jmp	0x3380	; 0x3380 <_ZN8emstream12transmit_nowEv>
     226:	0c 94 22 1a 	jmp	0x3444	; 0x3444 <_ZN8emstreamlsE15ser_manipulator+0x36>
     22a:	0c 94 b9 19 	jmp	0x3372	; 0x3372 <_ZN8emstream13ready_to_sendEv>
     22e:	0c 94 bb 19 	jmp	0x3376	; 0x3376 <_ZN8emstream7getcharEv>
     232:	0c 94 be 19 	jmp	0x337c	; 0x337c <_ZN8emstream14check_for_charEv>
     236:	0c 94 16 1a 	jmp	0x342c	; 0x342c <_ZN8emstreamlsE15ser_manipulator+0x1e>
     23a:	0c 94 ff 07 	jmp	0xffe	; 0xffe <_ZN9task_user3runEv>
     23e:	0c 94 4a 1a 	jmp	0x3494	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
     242:	0c 94 40 17 	jmp	0x2e80	; 0x2e80 <_ZN14frt_text_queue14check_for_charEv>
     246:	0c 94 27 1a 	jmp	0x344e	; 0x344e <_ZN8emstreamlsE15ser_manipulator+0x40>
     24a:	0c 94 c1 19 	jmp	0x3382	; 0x3382 <_ZN8emstream12clear_screenEv>
     24e:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <_ZN8emstreamlsE15ser_manipulator+0x30>
     252:	0c 94 ee 03 	jmp	0x7dc	; 0x7dc <_ZN13LimitSwitches3runEv>
     256:	0c 94 9d 03 	jmp	0x73a	; 0x73a <_ZN15EncoderPendulum3runEv>
     25a:	0c 94 40 1a 	jmp	0x3480	; 0x3480 <_ZN8emstreamlsE15ser_manipulator+0x72>
     25e:	0c 94 38 1a 	jmp	0x3470	; 0x3470 <_ZN8emstreamlsE15ser_manipulator+0x62>
     262:	0c 94 08 19 	jmp	0x3210	; 0x3210 <__cxa_pure_virtual>
     266:	0c 94 a4 02 	jmp	0x548	; 0x548 <_call_static_run_method>
     26a:	0c 94 22 17 	jmp	0x2e44	; 0x2e44 <_ZN14frt_text_queue7getcharEv>
     26e:	0c 94 95 1f 	jmp	0x3f2a	; 0x3f2a <_GLOBAL__sub_I_counter>
     272:	0c 94 b9 1b 	jmp	0x3772	; 0x3772 <_ZN5rs23212clear_screenEv>
     276:	0c 94 19 1a 	jmp	0x3432	; 0x3432 <_ZN8emstreamlsE15ser_manipulator+0x24>
     27a:	0c 94 df 02 	jmp	0x5be	; 0x5be <_ZN12EncoderMotor3runEv>
     27e:	0c 94 a9 0e 	jmp	0x1d52	; 0x1d52 <prvIdleTask>
     282:	0c 94 56 04 	jmp	0x8ac	; 0x8ac <_ZN5Motor3runEv>
     286:	0c 94 a6 1b 	jmp	0x374c	; 0x374c <_ZN5rs23214check_for_charEv>
     28a:	0c 94 4b 17 	jmp	0x2e96	; 0x2e96 <_ZN14frt_text_queue7putcharEc>
     28e:	0c 94 48 1a 	jmp	0x3490	; 0x3490 <_ZN8emstreamlsE15ser_manipulator+0x82>
     292:	0c 94 5c 1b 	jmp	0x36b8	; 0x36b8 <_ZN5rs2327putcharEc>

00000296 <__trampolines_end>:
     296:	2c 20       	and	r2, r12
     298:	54 43       	sbci	r21, 0x34	; 52
     29a:	43 30       	cpi	r20, 0x03	; 3
     29c:	43 43       	sbci	r20, 0x33	; 51
     29e:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a1 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a1:	2f 00                                               /.

000002a3 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b1 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b1:	54 69 6d 65 3a 20 00                                Time: .

000002b8 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b8:	4e 6f 76 20 32 36 20 32 30 31 37 00                 Nov 26 2017.

000002c4 <_ZZN9task_user11show_statusEvE3__c>:
     2c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     302:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000030d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     30d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     31d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34b:	6d 61 74 69 6f 6e 00                                mation.

00000352 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     352:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     362:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000373 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     373:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     383:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3a7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3b7:	68 65 20 41 56 52 00                                he AVR.

000003be <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3be:	20 68 65 6c 70 00                                    help.

000003c4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e3:	1b 5b 33 30 6d 00                                   .[30m.

000003e9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e9:	1b 5b 34 36 6d 00                                   .[46m.

000003ef <_ZZN9task_user3runEvE3__c_3>:
     3ef:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ff:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000040c <_ZZN9task_user3runEvE3__c_2>:
     40c:	3a 57 54 46 3f 00                                   :WTF?.

00000412 <_ZZN9task_user3runEvE3__c_1>:
     412:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     422:	65 00                                               e.

00000424 <_ZZN9task_user3runEvE3__c_0>:
     424:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000432 <_ZZN9task_user3runEvE3__c>:
     432:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     442:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000450 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     450:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045a <_ZZN8frt_task15emergency_resetEvE3__c>:
     45a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000469 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     469:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     479:	61 73 6b 20 00                                      ask .

0000047e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     47e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000048c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     48c:	20 63 72 65 61 74 65 64 00                           created.

00000495 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     495:	54 61 73 6b 20 00                                   Task .

0000049b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49b:	1b 5b 32 32 6d 00                                   .[22m.

000004a1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a1:	54 61 73 6b 3a 20 00                                Task: .

000004a8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a8:	1b 5b 31 6d 00                                      .[1m.

000004ad <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4ad:	1b 5b 32 32 6d 00                                   .[22m.

000004b3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004be <_ZZ17print_task_stacksP8emstreamE3__c>:
     4be:	1b 5b 31 6d 00                                      .[1m.

000004c3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c3:	09 09 00                                            ...

000004c6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4c6:	2f 00                                               /.

000004c8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d3:	09 2d 2d 2d 2d 00                                   .----.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004f6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4f6:	09 52 75 6e 73 00                                   .Runs.

000004fc <_ZZ15print_task_listP8emstreamE3__c_2>:
     4fc:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000508 <_ZZ15print_task_listP8emstreamE3__c_1>:
     508:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000519 <_ZZ15print_task_listP8emstreamE3__c_0>:
     519:	09 53 74 61 63 6b 00                                .Stack.

00000520 <_ZZ15print_task_listP8emstreamE3__c>:
     520:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52b:	09 00                                               ..

0000052d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     52d:	09 00                                               ..

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     52f:	2f 00                                               /.

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     533:	09 00                                               ..

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53b:	1b 5b 31 6d 00                                      .[1m.

00000540 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     545:	20 20 00                                              .

00000548 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     548:	0e 94 70 14 	call	0x28e0	; 0x28e0 <_ZN8frt_task22_call_users_run_methodEPS_>

0000054c <__ctors_start>:
     54c:	95 1f       	adc	r25, r21

0000054e <__ctors_end>:
     54e:	11 24       	eor	r1, r1
     550:	1f be       	out	0x3f, r1	; 63
     552:	cf ef       	ldi	r28, 0xFF	; 255
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df e3       	ldi	r29, 0x3F	; 63
     558:	de bf       	out	0x3e, r29	; 62
     55a:	00 e0       	ldi	r16, 0x00	; 0
     55c:	0c bf       	out	0x3c, r16	; 60
     55e:	18 be       	out	0x38, r1	; 56
     560:	19 be       	out	0x39, r1	; 57
     562:	1a be       	out	0x3a, r1	; 58
     564:	1b be       	out	0x3b, r1	; 59

00000566 <__do_copy_data>:
     566:	10 e2       	ldi	r17, 0x20	; 32
     568:	a0 e0       	ldi	r26, 0x00	; 0
     56a:	b0 e2       	ldi	r27, 0x20	; 32
     56c:	e6 eb       	ldi	r30, 0xB6	; 182
     56e:	f5 e4       	ldi	r31, 0x45	; 69
     570:	00 e0       	ldi	r16, 0x00	; 0
     572:	0b bf       	out	0x3b, r16	; 59
     574:	02 c0       	rjmp	.+4      	; 0x57a <__do_copy_data+0x14>
     576:	07 90       	elpm	r0, Z+
     578:	0d 92       	st	X+, r0
     57a:	a8 3c       	cpi	r26, 0xC8	; 200
     57c:	b1 07       	cpc	r27, r17
     57e:	d9 f7       	brne	.-10     	; 0x576 <__do_copy_data+0x10>
     580:	1b be       	out	0x3b, r1	; 59

00000582 <__do_clear_bss>:
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	a8 ec       	ldi	r26, 0xC8	; 200
     586:	b0 e2       	ldi	r27, 0x20	; 32
     588:	01 c0       	rjmp	.+2      	; 0x58c <.do_clear_bss_start>

0000058a <.do_clear_bss_loop>:
     58a:	1d 92       	st	X+, r1

0000058c <.do_clear_bss_start>:
     58c:	a6 37       	cpi	r26, 0x76	; 118
     58e:	b2 07       	cpc	r27, r18
     590:	e1 f7       	brne	.-8      	; 0x58a <.do_clear_bss_loop>

00000592 <__do_global_ctors>:
     592:	12 e0       	ldi	r17, 0x02	; 2
     594:	c7 ea       	ldi	r28, 0xA7	; 167
     596:	d2 e0       	ldi	r29, 0x02	; 2
     598:	00 e0       	ldi	r16, 0x00	; 0
     59a:	06 c0       	rjmp	.+12     	; 0x5a8 <__do_global_ctors+0x16>
     59c:	21 97       	sbiw	r28, 0x01	; 1
     59e:	01 09       	sbc	r16, r1
     5a0:	80 2f       	mov	r24, r16
     5a2:	fe 01       	movw	r30, r28
     5a4:	0e 94 35 22 	call	0x446a	; 0x446a <__tablejump2__>
     5a8:	c6 3a       	cpi	r28, 0xA6	; 166
     5aa:	d1 07       	cpc	r29, r17
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 07       	cpc	r16, r24
     5b0:	a9 f7       	brne	.-22     	; 0x59c <__do_global_ctors+0xa>
     5b2:	0e 94 0b 1f 	call	0x3e16	; 0x3e16 <main>
     5b6:	0c 94 d9 22 	jmp	0x45b2	; 0x45b2 <_exit>

000005ba <__bad_interrupt>:
     5ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005be <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN12EncoderMotor3runEv+0x6>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5cc:	0e 94 48 10 	call	0x2090	; 0x2090 <xTaskGetTickCount>
     5d0:	69 83       	std	Y+1, r22	; 0x01
     5d2:	7a 83       	std	Y+2, r23	; 0x02
     5d4:	8b 83       	std	Y+3, r24	; 0x03
     5d6:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN4_bm | PIN5_bm;										// Set both CHa and CHb for input
     5d8:	e0 e8       	ldi	r30, 0x80	; 128
     5da:	f6 e0       	ldi	r31, 0x06	; 6
     5dc:	80 e3       	ldi	r24, 0x30	; 48
     5de:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN4CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e0:	84 89       	ldd	r24, Z+20	; 0x14
     5e2:	83 60       	ori	r24, 0x03	; 3
     5e4:	84 8b       	std	Z+20, r24	; 0x14
	PORTE.PIN5CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5e6:	85 89       	ldd	r24, Z+21	; 0x15
     5e8:	83 60       	ori	r24, 0x03	; 3
     5ea:	85 8b       	std	Z+21, r24	; 0x15
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN4_gc;								// Configure CHa as a multiplexer input for event channel 1
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	84 e7       	ldi	r24, 0x74	; 116
     5f2:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f4:	89 e0       	ldi	r24, 0x09	; 9
     5f6:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f8:	e0 e0       	ldi	r30, 0x00	; 0
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	88 e6       	ldi	r24, 0x68	; 104
     5fe:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	86 a3       	std	Z+38, r24	; 0x26
     606:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     60c:	0f 2e       	mov	r0, r31
     60e:	21 2c       	mov	r2, r1
     610:	f9 e0       	ldi	r31, 0x09	; 9
     612:	3f 2e       	mov	r3, r31
     614:	f0 2d       	mov	r31, r0
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     616:	0f 2e       	mov	r0, r31
     618:	f5 e0       	ldi	r31, 0x05	; 5
     61a:	4f 2e       	mov	r4, r31
     61c:	51 2c       	mov	r5, r1
     61e:	61 2c       	mov	r6, r1
     620:	71 2c       	mov	r7, r1
     622:	f0 2d       	mov	r31, r0
     624:	f1 01       	movw	r30, r2
     626:	00 a1       	ldd	r16, Z+32	; 0x20
     628:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     62a:	0f b6       	in	r0, 0x3f	; 63
     62c:	f8 94       	cli
     62e:	0f 92       	push	r0
			the_data = new_data;
     630:	c8 01       	movw	r24, r16
     632:	88 0f       	add	r24, r24
     634:	99 1f       	adc	r25, r25
     636:	88 0f       	add	r24, r24
     638:	99 1f       	adc	r25, r25
     63a:	88 0f       	add	r24, r24
     63c:	99 1f       	adc	r25, r25
     63e:	80 0f       	add	r24, r16
     640:	91 1f       	adc	r25, r17
     642:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <thMotor>
     646:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <thMotor+0x1>
			portEXIT_CRITICAL ();
     64a:	0f 90       	pop	r0
     64c:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     64e:	0f b6       	in	r0, 0x3f	; 63
     650:	f8 94       	cli
     652:	0f 92       	push	r0
			the_data = new_data;
     654:	c8 01       	movw	r24, r16
     656:	01 2e       	mov	r0, r17
     658:	00 0c       	add	r0, r0
     65a:	aa 0b       	sbc	r26, r26
     65c:	bb 0b       	sbc	r27, r27
     65e:	ac 01       	movw	r20, r24
     660:	bd 01       	movw	r22, r26
     662:	44 0f       	add	r20, r20
     664:	55 1f       	adc	r21, r21
     666:	66 1f       	adc	r22, r22
     668:	77 1f       	adc	r23, r23
     66a:	4a 01       	movw	r8, r20
     66c:	5b 01       	movw	r10, r22
     66e:	88 0e       	add	r8, r24
     670:	99 1e       	adc	r9, r25
     672:	aa 1e       	adc	r10, r26
     674:	bb 1e       	adc	r11, r27
     676:	c5 01       	movw	r24, r10
     678:	b4 01       	movw	r22, r8
     67a:	24 e6       	ldi	r18, 0x64	; 100
     67c:	30 e0       	ldi	r19, 0x00	; 0
     67e:	40 e0       	ldi	r20, 0x00	; 0
     680:	50 e0       	ldi	r21, 0x00	; 0
     682:	0e 94 16 22 	call	0x442c	; 0x442c <__divmodsi4>
     686:	20 93 62 31 	sts	0x3162, r18	; 0x803162 <linear_position>
     68a:	30 93 63 31 	sts	0x3163, r19	; 0x803163 <linear_position+0x1>
			portEXIT_CRITICAL ();
     68e:	0f 90       	pop	r0
     690:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     692:	0f b6       	in	r0, 0x3f	; 63
     694:	f8 94       	cli
     696:	0f 92       	push	r0
			the_data = new_data;
     698:	c8 01       	movw	r24, r16
     69a:	8c 19       	sub	r24, r12
     69c:	9d 09       	sbc	r25, r13
     69e:	09 2e       	mov	r0, r25
     6a0:	00 0c       	add	r0, r0
     6a2:	aa 0b       	sbc	r26, r26
     6a4:	bb 0b       	sbc	r27, r27
     6a6:	ac 01       	movw	r20, r24
     6a8:	bd 01       	movw	r22, r26
     6aa:	44 0f       	add	r20, r20
     6ac:	55 1f       	adc	r21, r21
     6ae:	66 1f       	adc	r22, r22
     6b0:	77 1f       	adc	r23, r23
     6b2:	84 0f       	add	r24, r20
     6b4:	95 1f       	adc	r25, r21
     6b6:	a6 1f       	adc	r26, r22
     6b8:	b7 1f       	adc	r27, r23
     6ba:	ac 01       	movw	r20, r24
     6bc:	bd 01       	movw	r22, r26
     6be:	44 0f       	add	r20, r20
     6c0:	55 1f       	adc	r21, r21
     6c2:	66 1f       	adc	r22, r22
     6c4:	77 1f       	adc	r23, r23
     6c6:	44 0f       	add	r20, r20
     6c8:	55 1f       	adc	r21, r21
     6ca:	66 1f       	adc	r22, r22
     6cc:	77 1f       	adc	r23, r23
     6ce:	5c 01       	movw	r10, r24
     6d0:	6d 01       	movw	r12, r26
     6d2:	a4 0e       	add	r10, r20
     6d4:	b5 1e       	adc	r11, r21
     6d6:	c6 1e       	adc	r12, r22
     6d8:	d7 1e       	adc	r13, r23
     6da:	c6 01       	movw	r24, r12
     6dc:	b5 01       	movw	r22, r10
     6de:	a3 01       	movw	r20, r6
     6e0:	92 01       	movw	r18, r4
     6e2:	0e 94 16 22 	call	0x442c	; 0x442c <__divmodsi4>
     6e6:	20 93 5e 31 	sts	0x315E, r18	; 0x80315e <thdMotor>
     6ea:	30 93 5f 31 	sts	0x315F, r19	; 0x80315f <thdMotor+0x1>
			portEXIT_CRITICAL ();
     6ee:	0f 90       	pop	r0
     6f0:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     6f2:	f7 01       	movw	r30, r14
     6f4:	86 85       	ldd	r24, Z+14	; 0x0e
     6f6:	97 85       	ldd	r25, Z+15	; 0x0f
     6f8:	a0 89       	ldd	r26, Z+16	; 0x10
     6fa:	b1 89       	ldd	r27, Z+17	; 0x11
     6fc:	01 96       	adiw	r24, 0x01	; 1
     6fe:	a1 1d       	adc	r26, r1
     700:	b1 1d       	adc	r27, r1
     702:	86 87       	std	Z+14, r24	; 0x0e
     704:	97 87       	std	Z+15, r25	; 0x0f
     706:	a0 8b       	std	Z+16, r26	; 0x10
     708:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     70a:	b3 01       	movw	r22, r6
     70c:	a2 01       	movw	r20, r4
     70e:	ce 01       	movw	r24, r28
     710:	01 96       	adiw	r24, 0x01	; 1
     712:	0e 94 e6 11 	call	0x23cc	; 0x23cc <vTaskDelayUntil>
		
		angularVelocity = ((int32_t) (encoder_count-last_encoder_count)*15)/dt;	// d_ec*60/(4*1000)/dt where dt is in ms so * 1000
		//*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		thdMotor.put(angularVelocity);
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     716:	68 01       	movw	r12, r16
     718:	85 cf       	rjmp	.-246    	; 0x624 <_ZN12EncoderMotor3runEv+0x66>

0000071a <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     71a:	0f 93       	push	r16
     71c:	1f 93       	push	r17
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     724:	0e 94 83 14 	call	0x2906	; 0x2906 <_ZN8frt_taskC1EPKchjP8emstream>
     728:	8a e0       	ldi	r24, 0x0A	; 10
     72a:	90 e2       	ldi	r25, 0x20	; 32
     72c:	88 83       	st	Y, r24
     72e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	08 95       	ret

0000073a <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     73a:	cf 93       	push	r28
     73c:	df 93       	push	r29
     73e:	00 d0       	rcall	.+0      	; 0x740 <_ZN15EncoderPendulum3runEv+0x6>
     740:	1f 92       	push	r1
     742:	cd b7       	in	r28, 0x3d	; 61
     744:	de b7       	in	r29, 0x3e	; 62
     746:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     748:	0e 94 48 10 	call	0x2090	; 0x2090 <xTaskGetTickCount>
     74c:	69 83       	std	Y+1, r22	; 0x01
     74e:	7a 83       	std	Y+2, r23	; 0x02
     750:	8b 83       	std	Y+3, r24	; 0x03
     752:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTB.DIRCLR = (PIN4_bm | PIN5_bm);							// set C4 & C5 as inputs
     754:	e0 e2       	ldi	r30, 0x20	; 32
     756:	f6 e0       	ldi	r31, 0x06	; 6
     758:	80 e3       	ldi	r24, 0x30	; 48
     75a:	82 83       	std	Z+2, r24	; 0x02
	PORTB.PIN4CTRL = PORT_ISC_LEVEL_gc;							// set C4 for level sensing
     75c:	83 e0       	ldi	r24, 0x03	; 3
     75e:	84 8b       	std	Z+20, r24	; 0x14
	PORTB.PIN5CTRL = PORT_ISC_LEVEL_gc;							// set C5 for level sensing
     760:	85 8b       	std	Z+21, r24	; 0x15
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTB_PIN4_gc;					// set PC4 as Multiplexer for Event Chan 0
     762:	e0 e8       	ldi	r30, 0x80	; 128
     764:	f1 e0       	ldi	r31, 0x01	; 1
     766:	8c e5       	ldi	r24, 0x5C	; 92
     768:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     76a:	89 e0       	ldi	r24, 0x09	; 9
     76c:	82 87       	std	Z+10, r24	; 0x0a
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     76e:	e0 e4       	ldi	r30, 0x40	; 64
     770:	f8 e0       	ldi	r31, 0x08	; 8
     772:	8a e6       	ldi	r24, 0x6A	; 106
     774:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     776:	80 ea       	ldi	r24, 0xA0	; 160
     778:	95 e0       	ldi	r25, 0x05	; 5
     77a:	86 a3       	std	Z+38, r24	; 0x26
     77c:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     77e:	81 e0       	ldi	r24, 0x01	; 1
     780:	80 83       	st	Z, r24
	int16_t count;												// contains the current encoder value
	int16_t theta_pendulum;
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT; 
     782:	68 94       	set
     784:	ee 24       	eor	r14, r14
     786:	e6 f8       	bld	r14, 6
     788:	ff 24       	eor	r15, r15
     78a:	f3 f8       	bld	r15, 3
     78c:	f7 01       	movw	r30, r14
     78e:	80 a1       	ldd	r24, Z+32	; 0x20
     790:	91 a1       	ldd	r25, Z+33	; 0x21
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     792:	f8 01       	movw	r30, r16
     794:	86 85       	ldd	r24, Z+14	; 0x0e
     796:	97 85       	ldd	r25, Z+15	; 0x0f
     798:	a0 89       	ldd	r26, Z+16	; 0x10
     79a:	b1 89       	ldd	r27, Z+17	; 0x11
     79c:	01 96       	adiw	r24, 0x01	; 1
     79e:	a1 1d       	adc	r26, r1
     7a0:	b1 1d       	adc	r27, r1
     7a2:	86 87       	std	Z+14, r24	; 0x0e
     7a4:	97 87       	std	Z+15, r25	; 0x0f
     7a6:	a0 8b       	std	Z+16, r26	; 0x10
     7a8:	b1 8b       	std	Z+17, r27	; 0x11
     7aa:	48 ec       	ldi	r20, 0xC8	; 200
     7ac:	50 e0       	ldi	r21, 0x00	; 0
     7ae:	60 e0       	ldi	r22, 0x00	; 0
     7b0:	70 e0       	ldi	r23, 0x00	; 0
     7b2:	ce 01       	movw	r24, r28
     7b4:	01 96       	adiw	r24, 0x01	; 1
     7b6:	0e 94 e6 11 	call	0x23cc	; 0x23cc <vTaskDelayUntil>
     7ba:	e8 cf       	rjmp	.-48     	; 0x78c <_ZN15EncoderPendulum3runEv+0x52>

000007bc <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     7bc:	0f 93       	push	r16
     7be:	1f 93       	push	r17
     7c0:	cf 93       	push	r28
     7c2:	df 93       	push	r29
     7c4:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7c6:	0e 94 83 14 	call	0x2906	; 0x2906 <_ZN8frt_taskC1EPKchjP8emstream>
     7ca:	82 e1       	ldi	r24, 0x12	; 18
     7cc:	90 e2       	ldi	r25, 0x20	; 32
     7ce:	88 83       	st	Y, r24
     7d0:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     7d2:	df 91       	pop	r29
     7d4:	cf 91       	pop	r28
     7d6:	1f 91       	pop	r17
     7d8:	0f 91       	pop	r16
     7da:	08 95       	ret

000007dc <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     7dc:	cf 93       	push	r28
     7de:	df 93       	push	r29
     7e0:	00 d0       	rcall	.+0      	; 0x7e2 <_ZN13LimitSwitches3runEv+0x6>
     7e2:	1f 92       	push	r1
     7e4:	cd b7       	in	r28, 0x3d	; 61
     7e6:	de b7       	in	r29, 0x3e	; 62
     7e8:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7ea:	0e 94 48 10 	call	0x2090	; 0x2090 <xTaskGetTickCount>
     7ee:	69 83       	std	Y+1, r22	; 0x01
     7f0:	7a 83       	std	Y+2, r23	; 0x02
     7f2:	8b 83       	std	Y+3, r24	; 0x03
     7f4:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PK0 & PK2) and LED output
	PORTK.DIRCLR = PIN0_bm;									// set K0 as input
     7f6:	e0 e2       	ldi	r30, 0x20	; 32
     7f8:	f7 e0       	ldi	r31, 0x07	; 7
     7fa:	81 e0       	ldi	r24, 0x01	; 1
     7fc:	82 83       	std	Z+2, r24	; 0x02
	PORTK.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set K0 as pullup
     7fe:	88 e1       	ldi	r24, 0x18	; 24
     800:	80 8b       	std	Z+16, r24	; 0x10
	PORTK.DIRCLR = PIN2_bm;									// set K2 as input
     802:	94 e0       	ldi	r25, 0x04	; 4
     804:	92 83       	std	Z+2, r25	; 0x02
	PORTK.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set K2 as pullup
     806:	82 8b       	std	Z+18, r24	; 0x12
	bool rightLimit;
	bool leftLimit;

	while(1){
		
		if(!(PORTK_IN & PIN0_bm))							// check whether limit is pressed (pin K0 is high)
     808:	0f 2e       	mov	r0, r31
     80a:	f8 e2       	ldi	r31, 0x28	; 40
     80c:	ef 2e       	mov	r14, r31
     80e:	f7 e0       	ldi	r31, 0x07	; 7
     810:	ff 2e       	mov	r15, r31
     812:	f0 2d       	mov	r31, r0
     814:	f7 01       	movw	r30, r14
     816:	80 81       	ld	r24, Z
     818:	80 fd       	sbrc	r24, 0
     81a:	10 c0       	rjmp	.+32     	; 0x83c <_ZN13LimitSwitches3runEv+0x60>
		{	
			rightLimit = 1;
			*p_serial << "rightLimit: " << rightLimit << endl;
     81c:	f8 01       	movw	r30, r16
     81e:	c6 80       	ldd	r12, Z+6	; 0x06
     820:	d7 80       	ldd	r13, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     822:	66 e1       	ldi	r22, 0x16	; 22
     824:	70 e2       	ldi	r23, 0x20	; 32
     826:	c6 01       	movw	r24, r12
     828:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     82c:	61 e0       	ldi	r22, 0x01	; 1
     82e:	c6 01       	movw	r24, r12
     830:	0e 94 4e 1a 	call	0x349c	; 0x349c <_ZN8emstreamlsEb>
     834:	66 e0       	ldi	r22, 0x06	; 6
     836:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     83a:	13 c0       	rjmp	.+38     	; 0x862 <_ZN13LimitSwitches3runEv+0x86>
			
		}
		else if (!(PORTK_IN & PIN2_bm))						// check whether limit is pressed (pin K2 is high)
     83c:	f7 01       	movw	r30, r14
     83e:	80 81       	ld	r24, Z
     840:	82 fd       	sbrc	r24, 2
     842:	0f c0       	rjmp	.+30     	; 0x862 <_ZN13LimitSwitches3runEv+0x86>
		{
			leftLimit = 1;
			*p_serial << "leftLimit: " << leftLimit << endl;
     844:	f8 01       	movw	r30, r16
     846:	c6 80       	ldd	r12, Z+6	; 0x06
     848:	d7 80       	ldd	r13, Z+7	; 0x07
     84a:	63 e2       	ldi	r22, 0x23	; 35
     84c:	70 e2       	ldi	r23, 0x20	; 32
     84e:	c6 01       	movw	r24, r12
     850:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     854:	61 e0       	ldi	r22, 0x01	; 1
     856:	c6 01       	movw	r24, r12
     858:	0e 94 4e 1a 	call	0x349c	; 0x349c <_ZN8emstreamlsEb>
     85c:	66 e0       	ldi	r22, 0x06	; 6
     85e:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
			leftLimit = 0;
			//*p_serial << "limits: " << rightLimit << leftLimit << endl;
		}
		
		// Increment counter for debugging
		runs++;
     862:	f8 01       	movw	r30, r16
     864:	86 85       	ldd	r24, Z+14	; 0x0e
     866:	97 85       	ldd	r25, Z+15	; 0x0f
     868:	a0 89       	ldd	r26, Z+16	; 0x10
     86a:	b1 89       	ldd	r27, Z+17	; 0x11
     86c:	01 96       	adiw	r24, 0x01	; 1
     86e:	a1 1d       	adc	r26, r1
     870:	b1 1d       	adc	r27, r1
     872:	86 87       	std	Z+14, r24	; 0x0e
     874:	97 87       	std	Z+15, r25	; 0x0f
     876:	a0 8b       	std	Z+16, r26	; 0x10
     878:	b1 8b       	std	Z+17, r27	; 0x11
     87a:	41 e0       	ldi	r20, 0x01	; 1
     87c:	50 e0       	ldi	r21, 0x00	; 0
     87e:	60 e0       	ldi	r22, 0x00	; 0
     880:	70 e0       	ldi	r23, 0x00	; 0
     882:	ce 01       	movw	r24, r28
     884:	01 96       	adiw	r24, 0x01	; 1
     886:	0e 94 e6 11 	call	0x23cc	; 0x23cc <vTaskDelayUntil>
     88a:	c4 cf       	rjmp	.-120    	; 0x814 <_ZN13LimitSwitches3runEv+0x38>

0000088c <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     88c:	0f 93       	push	r16
     88e:	1f 93       	push	r17
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     896:	0e 94 83 14 	call	0x2906	; 0x2906 <_ZN8frt_taskC1EPKchjP8emstream>
     89a:	83 e3       	ldi	r24, 0x33	; 51
     89c:	90 e2       	ldi	r25, 0x20	; 32
     89e:	88 83       	st	Y, r24
     8a0:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     8a2:	df 91       	pop	r29
     8a4:	cf 91       	pop	r28
     8a6:	1f 91       	pop	r17
     8a8:	0f 91       	pop	r16
     8aa:	08 95       	ret

000008ac <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	00 d0       	rcall	.+0      	; 0x8b2 <_ZN5Motor3runEv+0x6>
     8b2:	00 d0       	rcall	.+0      	; 0x8b4 <_ZN5Motor3runEv+0x8>
     8b4:	cd b7       	in	r28, 0x3d	; 61
     8b6:	de b7       	in	r29, 0x3e	; 62
     8b8:	3c 01       	movw	r6, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8ba:	0e 94 48 10 	call	0x2090	; 0x2090 <xTaskGetTickCount>
     8be:	69 83       	std	Y+1, r22	; 0x01
     8c0:	7a 83       	std	Y+2, r23	; 0x02
     8c2:	8b 83       	std	Y+3, r24	; 0x03
     8c4:	9c 83       	std	Y+4, r25	; 0x04

	dt = .008;
     8c6:	f3 01       	movw	r30, r6
     8c8:	fe 96       	adiw	r30, 0x3e	; 62
     8ca:	8f e6       	ldi	r24, 0x6F	; 111
     8cc:	92 e1       	ldi	r25, 0x12	; 18
     8ce:	a3 e0       	ldi	r26, 0x03	; 3
     8d0:	bc e3       	ldi	r27, 0x3C	; 60
     8d2:	80 83       	st	Z, r24
     8d4:	91 83       	std	Z+1, r25	; 0x01
     8d6:	a2 83       	std	Z+2, r26	; 0x02
     8d8:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	f3 01       	movw	r30, r6
     8e0:	84 af       	std	Z+60, r24	; 0x3c
     8e2:	95 af       	std	Z+61, r25	; 0x3d
		runs++;
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     8e4:	68 94       	set
     8e6:	44 24       	eor	r4, r4
     8e8:	41 f8       	bld	r4, 1
     8ea:	51 2c       	mov	r5, r1
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     8ec:	0f 2e       	mov	r0, r31
     8ee:	ff e3       	ldi	r31, 0x3F	; 63
     8f0:	2f 2e       	mov	r2, r31
     8f2:	f0 2d       	mov	r31, r0
     8f4:	0f 2e       	mov	r0, r31
     8f6:	fc e3       	ldi	r31, 0x3C	; 60
     8f8:	3f 2e       	mov	r3, r31
     8fa:	f0 2d       	mov	r31, r0
	dt = .008;
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     8fc:	f3 01       	movw	r30, r6
     8fe:	86 85       	ldd	r24, Z+14	; 0x0e
     900:	97 85       	ldd	r25, Z+15	; 0x0f
     902:	a0 89       	ldd	r26, Z+16	; 0x10
     904:	b1 89       	ldd	r27, Z+17	; 0x11
     906:	01 96       	adiw	r24, 0x01	; 1
     908:	a1 1d       	adc	r26, r1
     90a:	b1 1d       	adc	r27, r1
     90c:	86 87       	std	Z+14, r24	; 0x0e
     90e:	97 87       	std	Z+15, r25	; 0x0f
     910:	a0 8b       	std	Z+16, r26	; 0x10
     912:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		omegam_set = 2;
     914:	42 8e       	std	Z+26, r4	; 0x1a
     916:	53 8e       	std	Z+27, r5	; 0x1b

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
     918:	16 8e       	std	Z+30, r1	; 0x1e
     91a:	17 8e       	std	Z+31, r1	; 0x1f
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     91c:	2f 92       	push	r2
     91e:	1f 92       	push	r1
     920:	1f 92       	push	r1
     922:	1f 92       	push	r1
     924:	3f 92       	push	r3
     926:	f3 e2       	ldi	r31, 0x23	; 35
     928:	ff 93       	push	r31
     92a:	27 ed       	ldi	r18, 0xD7	; 215
     92c:	2f 93       	push	r18
     92e:	3a e0       	ldi	r19, 0x0A	; 10
     930:	3f 93       	push	r19
     932:	0f 2e       	mov	r0, r31
     934:	fd ec       	ldi	r31, 0xCD	; 205
     936:	8f 2e       	mov	r8, r31
     938:	fc ec       	ldi	r31, 0xCC	; 204
     93a:	9f 2e       	mov	r9, r31
     93c:	a9 2c       	mov	r10, r9
     93e:	fd e3       	ldi	r31, 0x3D	; 61
     940:	bf 2e       	mov	r11, r31
     942:	f0 2d       	mov	r31, r0
     944:	0f 2e       	mov	r0, r31
     946:	f4 e1       	ldi	r31, 0x14	; 20
     948:	cf 2e       	mov	r12, r31
     94a:	fe ea       	ldi	r31, 0xAE	; 174
     94c:	df 2e       	mov	r13, r31
     94e:	ff e8       	ldi	r31, 0x8F	; 143
     950:	ef 2e       	mov	r14, r31
     952:	ff eb       	ldi	r31, 0xBF	; 191
     954:	ff 2e       	mov	r15, r31
     956:	f0 2d       	mov	r31, r0
     958:	04 e1       	ldi	r16, 0x14	; 20
     95a:	1e ea       	ldi	r17, 0xAE	; 174
     95c:	2f e8       	ldi	r18, 0x8F	; 143
     95e:	3f e3       	ldi	r19, 0x3F	; 63
     960:	b5 01       	movw	r22, r10
     962:	a4 01       	movw	r20, r8
     964:	ce 01       	movw	r24, r28
     966:	05 96       	adiw	r24, 0x05	; 5
     968:	0e 94 8b 05 	call	0xb16	; 0xb16 <_ZN3PIDC1Edddddd>
		double Tset = pidTorque.calculate(omegam_set, omegam_measured);
     96c:	f3 01       	movw	r30, r6
     96e:	66 8d       	ldd	r22, Z+30	; 0x1e
     970:	77 8d       	ldd	r23, Z+31	; 0x1f
     972:	02 8d       	ldd	r16, Z+26	; 0x1a
     974:	13 8d       	ldd	r17, Z+27	; 0x1b
     976:	07 2e       	mov	r0, r23
     978:	00 0c       	add	r0, r0
     97a:	88 0b       	sbc	r24, r24
     97c:	99 0b       	sbc	r25, r25
     97e:	0e 94 c2 20 	call	0x4184	; 0x4184 <__floatsisf>
     982:	6b 01       	movw	r12, r22
     984:	7c 01       	movw	r14, r24
     986:	b8 01       	movw	r22, r16
     988:	11 0f       	add	r17, r17
     98a:	88 0b       	sbc	r24, r24
     98c:	99 0b       	sbc	r25, r25
     98e:	0e 94 c2 20 	call	0x4184	; 0x4184 <__floatsisf>
     992:	ab 01       	movw	r20, r22
     994:	bc 01       	movw	r22, r24
     996:	97 01       	movw	r18, r14
     998:	86 01       	movw	r16, r12
     99a:	ce 01       	movw	r24, r28
     99c:	05 96       	adiw	r24, 0x05	; 5
     99e:	0e 94 b2 06 	call	0xd64	; 0xd64 <_ZN3PID9calculateEdd>
     9a2:	6b 01       	movw	r12, r22
     9a4:	7c 01       	movw	r14, r24
		//printf("val:% 7.3f inc:% 7.3f\n", omegam_measured, inc);
		omegam_measured += inc;
     9a6:	f3 01       	movw	r30, r6
     9a8:	24 ad       	ldd	r18, Z+60	; 0x3c
     9aa:	35 ad       	ldd	r19, Z+61	; 0x3d
     9ac:	86 8d       	ldd	r24, Z+30	; 0x1e
     9ae:	97 8d       	ldd	r25, Z+31	; 0x1f
     9b0:	82 0f       	add	r24, r18
     9b2:	93 1f       	adc	r25, r19
     9b4:	86 8f       	std	Z+30, r24	; 0x1e
     9b6:	97 8f       	std	Z+31, r25	; 0x1f

		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     9b8:	10 a6       	std	Z+40, r1	; 0x28
     9ba:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     9bc:	60 a5       	ldd	r22, Z+40	; 0x28
     9be:	71 a5       	ldd	r23, Z+41	; 0x29
     9c0:	07 2e       	mov	r0, r23
     9c2:	00 0c       	add	r0, r0
     9c4:	88 0b       	sbc	r24, r24
     9c6:	99 0b       	sbc	r25, r25
     9c8:	0e 94 c2 20 	call	0x4184	; 0x4184 <__floatsisf>
     9cc:	9b 01       	movw	r18, r22
     9ce:	ac 01       	movw	r20, r24
     9d0:	c7 01       	movw	r24, r14
     9d2:	b6 01       	movw	r22, r12
     9d4:	0e 94 18 20 	call	0x4030	; 0x4030 <__divsf3>
     9d8:	0e 94 8a 20 	call	0x4114	; 0x4114 <__fixsfsi>
     9dc:	f3 01       	movw	r30, r6
     9de:	64 a3       	std	Z+36, r22	; 0x24
     9e0:	75 a3       	std	Z+37, r23	; 0x25

		// Saturater for current
		
		if(Im_set > 17.4) {
     9e2:	64 a1       	ldd	r22, Z+36	; 0x24
     9e4:	75 a1       	ldd	r23, Z+37	; 0x25
     9e6:	07 2e       	mov	r0, r23
     9e8:	00 0c       	add	r0, r0
     9ea:	88 0b       	sbc	r24, r24
     9ec:	99 0b       	sbc	r25, r25
     9ee:	0e 94 c2 20 	call	0x4184	; 0x4184 <__floatsisf>
     9f2:	cd bf       	out	0x3d, r28	; 61
     9f4:	de bf       	out	0x3e, r29	; 62
     9f6:	23 e3       	ldi	r18, 0x33	; 51
     9f8:	33 e3       	ldi	r19, 0x33	; 51
     9fa:	4b e8       	ldi	r20, 0x8B	; 139
     9fc:	51 e4       	ldi	r21, 0x41	; 65
     9fe:	0e 94 72 21 	call	0x42e4	; 0x42e4 <__gesf2>
     a02:	18 16       	cp	r1, r24
     a04:	34 f4       	brge	.+12     	; 0xa12 <_ZN5Motor3runEv+0x166>
			Im_set = 17.4;
     a06:	21 e1       	ldi	r18, 0x11	; 17
     a08:	30 e0       	ldi	r19, 0x00	; 0
     a0a:	f3 01       	movw	r30, r6
     a0c:	24 a3       	std	Z+36, r18	; 0x24
     a0e:	35 a3       	std	Z+37, r19	; 0x25
     a10:	16 c0       	rjmp	.+44     	; 0xa3e <_ZN5Motor3runEv+0x192>
		} else if(Im_set < -17.4) {
     a12:	f3 01       	movw	r30, r6
     a14:	64 a1       	ldd	r22, Z+36	; 0x24
     a16:	75 a1       	ldd	r23, Z+37	; 0x25
     a18:	07 2e       	mov	r0, r23
     a1a:	00 0c       	add	r0, r0
     a1c:	88 0b       	sbc	r24, r24
     a1e:	99 0b       	sbc	r25, r25
     a20:	0e 94 c2 20 	call	0x4184	; 0x4184 <__floatsisf>
     a24:	23 e3       	ldi	r18, 0x33	; 51
     a26:	33 e3       	ldi	r19, 0x33	; 51
     a28:	4b e8       	ldi	r20, 0x8B	; 139
     a2a:	51 ec       	ldi	r21, 0xC1	; 193
     a2c:	0e 94 13 20 	call	0x4026	; 0x4026 <__cmpsf2>
     a30:	88 23       	and	r24, r24
     a32:	2c f4       	brge	.+10     	; 0xa3e <_ZN5Motor3runEv+0x192>
			Im_set = -17.4;
     a34:	2f ee       	ldi	r18, 0xEF	; 239
     a36:	3f ef       	ldi	r19, 0xFF	; 255
     a38:	f3 01       	movw	r30, r6
     a3a:	24 a3       	std	Z+36, r18	; 0x24
     a3c:	35 a3       	std	Z+37, r19	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     a3e:	f3 01       	movw	r30, r6
     a40:	16 aa       	std	Z+54, r1	; 0x36
     a42:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     a44:	60 a5       	ldd	r22, Z+40	; 0x28
     a46:	71 a5       	ldd	r23, Z+41	; 0x29
     a48:	06 a9       	ldd	r16, Z+54	; 0x36
     a4a:	17 a9       	ldd	r17, Z+55	; 0x37
     a4c:	07 2e       	mov	r0, r23
     a4e:	00 0c       	add	r0, r0
     a50:	88 0b       	sbc	r24, r24
     a52:	99 0b       	sbc	r25, r25
     a54:	0e 94 c2 20 	call	0x4184	; 0x4184 <__floatsisf>
     a58:	20 e5       	ldi	r18, 0x50	; 80
     a5a:	3a e6       	ldi	r19, 0x6A	; 106
     a5c:	41 ea       	ldi	r20, 0xA1	; 161
     a5e:	57 e4       	ldi	r21, 0x47	; 71
     a60:	0e 94 77 21 	call	0x42ee	; 0x42ee <__mulsf3>
     a64:	6b 01       	movw	r12, r22
     a66:	7c 01       	movw	r14, r24
     a68:	b8 01       	movw	r22, r16
     a6a:	11 0f       	add	r17, r17
     a6c:	88 0b       	sbc	r24, r24
     a6e:	99 0b       	sbc	r25, r25
     a70:	0e 94 c2 20 	call	0x4184	; 0x4184 <__floatsisf>
     a74:	9b 01       	movw	r18, r22
     a76:	ac 01       	movw	r20, r24
     a78:	c7 01       	movw	r24, r14
     a7a:	b6 01       	movw	r22, r12
     a7c:	0e 94 77 21 	call	0x42ee	; 0x42ee <__mulsf3>
     a80:	0e 94 8a 20 	call	0x4114	; 0x4114 <__fixsfsi>
     a84:	f3 01       	movw	r30, r6
     a86:	62 ab       	std	Z+50, r22	; 0x32
     a88:	73 ab       	std	Z+51, r23	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     a8a:	46 a9       	ldd	r20, Z+54	; 0x36
     a8c:	57 a9       	ldd	r21, Z+55	; 0x37
     a8e:	26 8d       	ldd	r18, Z+30	; 0x1e
     a90:	37 8d       	ldd	r19, Z+31	; 0x1f
     a92:	42 9f       	mul	r20, r18
     a94:	c0 01       	movw	r24, r0
     a96:	43 9f       	mul	r20, r19
     a98:	90 0d       	add	r25, r0
     a9a:	52 9f       	mul	r21, r18
     a9c:	90 0d       	add	r25, r0
     a9e:	11 24       	eor	r1, r1
     aa0:	84 ab       	std	Z+52, r24	; 0x34
     aa2:	95 ab       	std	Z+53, r25	; 0x35

		V_m = V_R + V_E;
     aa4:	20 a9       	ldd	r18, Z+48	; 0x30
     aa6:	31 a9       	ldd	r19, Z+49	; 0x31
     aa8:	84 a9       	ldd	r24, Z+52	; 0x34
     aaa:	95 a9       	ldd	r25, Z+53	; 0x35
     aac:	82 0f       	add	r24, r18
     aae:	93 1f       	adc	r25, r19
     ab0:	80 af       	std	Z+56, r24	; 0x38
     ab2:	91 af       	std	Z+57, r25	; 0x39

		// Saturater for voltage
		if (V_m > 24) {
     ab4:	80 ad       	ldd	r24, Z+56	; 0x38
     ab6:	91 ad       	ldd	r25, Z+57	; 0x39
     ab8:	49 97       	sbiw	r24, 0x19	; 25
     aba:	2c f0       	brlt	.+10     	; 0xac6 <_ZN5Motor3runEv+0x21a>
			V_m = 24;
     abc:	28 e1       	ldi	r18, 0x18	; 24
     abe:	30 e0       	ldi	r19, 0x00	; 0
     ac0:	20 af       	std	Z+56, r18	; 0x38
     ac2:	31 af       	std	Z+57, r19	; 0x39
     ac4:	0b c0       	rjmp	.+22     	; 0xadc <_ZN5Motor3runEv+0x230>
		} else if(V_m < -24) {
     ac6:	f3 01       	movw	r30, r6
     ac8:	80 ad       	ldd	r24, Z+56	; 0x38
     aca:	91 ad       	ldd	r25, Z+57	; 0x39
     acc:	88 3e       	cpi	r24, 0xE8	; 232
     ace:	9f 4f       	sbci	r25, 0xFF	; 255
     ad0:	2c f4       	brge	.+10     	; 0xadc <_ZN5Motor3runEv+0x230>
			V_m = -24;
     ad2:	28 ee       	ldi	r18, 0xE8	; 232
     ad4:	3f ef       	ldi	r19, 0xFF	; 255
     ad6:	f3 01       	movw	r30, r6
     ad8:	20 af       	std	Z+56, r18	; 0x38
     ada:	31 af       	std	Z+57, r19	; 0x39
     adc:	41 e0       	ldi	r20, 0x01	; 1
     ade:	50 e0       	ldi	r21, 0x00	; 0
     ae0:	60 e0       	ldi	r22, 0x00	; 0
     ae2:	70 e0       	ldi	r23, 0x00	; 0
     ae4:	ce 01       	movw	r24, r28
     ae6:	01 96       	adiw	r24, 0x01	; 1
     ae8:	0e 94 e6 11 	call	0x23cc	; 0x23cc <vTaskDelayUntil>
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = 0;
		
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		PID pidTorque = PID(0.1, 1.1225, -1.1225, 0.1, 0.01, 0.5);
     aec:	ce 01       	movw	r24, r28
     aee:	05 96       	adiw	r24, 0x05	; 5
     af0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <_ZN3PIDD1Ev>
	portTickType previousTicks = xTaskGetTickCount ();

	dt = .008;
	inc = 1;
	
	while(1){
     af4:	03 cf       	rjmp	.-506    	; 0x8fc <_ZN5Motor3runEv+0x50>

00000af6 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     af6:	0f 93       	push	r16
     af8:	1f 93       	push	r17
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     b00:	0e 94 83 14 	call	0x2906	; 0x2906 <_ZN8frt_taskC1EPKchjP8emstream>
     b04:	8b e3       	ldi	r24, 0x3B	; 59
     b06:	90 e2       	ldi	r25, 0x20	; 32
     b08:	88 83       	st	Y, r24
     b0a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     b0c:	df 91       	pop	r29
     b0e:	cf 91       	pop	r28
     b10:	1f 91       	pop	r17
     b12:	0f 91       	pop	r16
     b14:	08 95       	ret

00000b16 <_ZN3PIDC1Edddddd>:
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}
     b16:	2f 92       	push	r2
     b18:	3f 92       	push	r3
     b1a:	4f 92       	push	r4
     b1c:	5f 92       	push	r5
     b1e:	6f 92       	push	r6
     b20:	7f 92       	push	r7
     b22:	8f 92       	push	r8
     b24:	9f 92       	push	r9
     b26:	af 92       	push	r10
     b28:	bf 92       	push	r11
     b2a:	cf 92       	push	r12
     b2c:	df 92       	push	r13
     b2e:	ef 92       	push	r14
     b30:	ff 92       	push	r15
     b32:	0f 93       	push	r16
     b34:	1f 93       	push	r17
     b36:	cf 93       	push	r28
     b38:	df 93       	push	r29
     b3a:	00 d0       	rcall	.+0      	; 0xb3c <_ZN3PIDC1Edddddd+0x26>
     b3c:	1f 92       	push	r1
     b3e:	cd b7       	in	r28, 0x3d	; 61
     b40:	de b7       	in	r29, 0x3e	; 62
     b42:	1c 01       	movw	r2, r24
     b44:	2a 01       	movw	r4, r20
     b46:	3b 01       	movw	r6, r22
     b48:	09 83       	std	Y+1, r16	; 0x01
     b4a:	1a 83       	std	Y+2, r17	; 0x02
     b4c:	2b 83       	std	Y+3, r18	; 0x03
     b4e:	3c 83       	std	Y+4, r19	; 0x04
     b50:	80 e2       	ldi	r24, 0x20	; 32
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	0e 94 fd 18 	call	0x31fa	; 0x31fa <_Znwj>
     b58:	fc 01       	movw	r30, r24
     b5a:	40 82       	st	Z, r4
     b5c:	51 82       	std	Z+1, r5	; 0x01
     b5e:	62 82       	std	Z+2, r6	; 0x02
     b60:	73 82       	std	Z+3, r7	; 0x03
     b62:	89 81       	ldd	r24, Y+1	; 0x01
     b64:	9a 81       	ldd	r25, Y+2	; 0x02
     b66:	ab 81       	ldd	r26, Y+3	; 0x03
     b68:	bc 81       	ldd	r27, Y+4	; 0x04
     b6a:	84 83       	std	Z+4, r24	; 0x04
     b6c:	95 83       	std	Z+5, r25	; 0x05
     b6e:	a6 83       	std	Z+6, r26	; 0x06
     b70:	b7 83       	std	Z+7, r27	; 0x07
     b72:	c0 86       	std	Z+8, r12	; 0x08
     b74:	d1 86       	std	Z+9, r13	; 0x09
     b76:	e2 86       	std	Z+10, r14	; 0x0a
     b78:	f3 86       	std	Z+11, r15	; 0x0b
     b7a:	84 86       	std	Z+12, r8	; 0x0c
     b7c:	95 86       	std	Z+13, r9	; 0x0d
     b7e:	a6 86       	std	Z+14, r10	; 0x0e
     b80:	b7 86       	std	Z+15, r11	; 0x0f
     b82:	4a 8d       	ldd	r20, Y+26	; 0x1a
     b84:	5b 8d       	ldd	r21, Y+27	; 0x1b
     b86:	6c 8d       	ldd	r22, Y+28	; 0x1c
     b88:	7d 8d       	ldd	r23, Y+29	; 0x1d
     b8a:	40 8b       	std	Z+16, r20	; 0x10
     b8c:	51 8b       	std	Z+17, r21	; 0x11
     b8e:	62 8b       	std	Z+18, r22	; 0x12
     b90:	73 8b       	std	Z+19, r23	; 0x13
     b92:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b94:	9f 8d       	ldd	r25, Y+31	; 0x1f
     b96:	a8 a1       	ldd	r26, Y+32	; 0x20
     b98:	b9 a1       	ldd	r27, Y+33	; 0x21
     b9a:	84 8b       	std	Z+20, r24	; 0x14
     b9c:	95 8b       	std	Z+21, r25	; 0x15
     b9e:	a6 8b       	std	Z+22, r26	; 0x16
     ba0:	b7 8b       	std	Z+23, r27	; 0x17
     ba2:	10 8e       	std	Z+24, r1	; 0x18
     ba4:	11 8e       	std	Z+25, r1	; 0x19
     ba6:	12 8e       	std	Z+26, r1	; 0x1a
     ba8:	13 8e       	std	Z+27, r1	; 0x1b
     baa:	14 8e       	std	Z+28, r1	; 0x1c
     bac:	15 8e       	std	Z+29, r1	; 0x1d
     bae:	16 8e       	std	Z+30, r1	; 0x1e
     bb0:	17 8e       	std	Z+31, r1	; 0x1f
     bb2:	d1 01       	movw	r26, r2
     bb4:	ed 93       	st	X+, r30
     bb6:	fc 93       	st	X, r31
     bb8:	24 96       	adiw	r28, 0x04	; 4
     bba:	cd bf       	out	0x3d, r28	; 61
     bbc:	de bf       	out	0x3e, r29	; 62
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	1f 91       	pop	r17
     bc4:	0f 91       	pop	r16
     bc6:	ff 90       	pop	r15
     bc8:	ef 90       	pop	r14
     bca:	df 90       	pop	r13
     bcc:	cf 90       	pop	r12
     bce:	bf 90       	pop	r11
     bd0:	af 90       	pop	r10
     bd2:	9f 90       	pop	r9
     bd4:	8f 90       	pop	r8
     bd6:	7f 90       	pop	r7
     bd8:	6f 90       	pop	r6
     bda:	5f 90       	pop	r5
     bdc:	4f 90       	pop	r4
     bde:	3f 90       	pop	r3
     be0:	2f 90       	pop	r2
     be2:	08 95       	ret

00000be4 <_ZN3PIDD1Ev>:
     be4:	fc 01       	movw	r30, r24
     be6:	80 81       	ld	r24, Z
     be8:	91 81       	ldd	r25, Z+1	; 0x01
     bea:	00 97       	sbiw	r24, 0x00	; 0
     bec:	11 f0       	breq	.+4      	; 0xbf2 <_ZN3PIDD1Ev+0xe>
     bee:	0e 94 00 19 	call	0x3200	; 0x3200 <_ZdlPv>
     bf2:	08 95       	ret

00000bf4 <_ZN7PIDImpl9calculateEdd>:

double PIDImpl::calculate( double setpoint, double pv )
{
     bf4:	4f 92       	push	r4
     bf6:	5f 92       	push	r5
     bf8:	6f 92       	push	r6
     bfa:	7f 92       	push	r7
     bfc:	8f 92       	push	r8
     bfe:	9f 92       	push	r9
     c00:	af 92       	push	r10
     c02:	bf 92       	push	r11
     c04:	cf 92       	push	r12
     c06:	df 92       	push	r13
     c08:	ef 92       	push	r14
     c0a:	ff 92       	push	r15
     c0c:	0f 93       	push	r16
     c0e:	1f 93       	push	r17
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	00 d0       	rcall	.+0      	; 0xc16 <_ZN7PIDImpl9calculateEdd+0x22>
     c16:	00 d0       	rcall	.+0      	; 0xc18 <_ZN7PIDImpl9calculateEdd+0x24>
     c18:	cd b7       	in	r28, 0x3d	; 61
     c1a:	de b7       	in	r29, 0x3e	; 62
     c1c:	8d 83       	std	Y+5, r24	; 0x05
     c1e:	9e 83       	std	Y+6, r25	; 0x06
     c20:	cb 01       	movw	r24, r22
     c22:	ba 01       	movw	r22, r20
    
    // Calculate error
    double error = setpoint - pv;
     c24:	a9 01       	movw	r20, r18
     c26:	98 01       	movw	r18, r16
     c28:	0e 94 a6 1f 	call	0x3f4c	; 0x3f4c <__subsf3>
     c2c:	6b 01       	movw	r12, r22
     c2e:	7c 01       	movw	r14, r24

    // Proportional term
    double Pout = _Kp * error;
     c30:	ed 81       	ldd	r30, Y+5	; 0x05
     c32:	fe 81       	ldd	r31, Y+6	; 0x06
     c34:	24 85       	ldd	r18, Z+12	; 0x0c
     c36:	35 85       	ldd	r19, Z+13	; 0x0d
     c38:	46 85       	ldd	r20, Z+14	; 0x0e
     c3a:	57 85       	ldd	r21, Z+15	; 0x0f
     c3c:	0e 94 77 21 	call	0x42ee	; 0x42ee <__mulsf3>
     c40:	69 83       	std	Y+1, r22	; 0x01
     c42:	7a 83       	std	Y+2, r23	; 0x02
     c44:	8b 83       	std	Y+3, r24	; 0x03
     c46:	9c 83       	std	Y+4, r25	; 0x04

    // Integral term
    _integral += error * _dt;
     c48:	ed 81       	ldd	r30, Y+5	; 0x05
     c4a:	fe 81       	ldd	r31, Y+6	; 0x06
     c4c:	40 80       	ld	r4, Z
     c4e:	51 80       	ldd	r5, Z+1	; 0x01
     c50:	62 80       	ldd	r6, Z+2	; 0x02
     c52:	73 80       	ldd	r7, Z+3	; 0x03
     c54:	a3 01       	movw	r20, r6
     c56:	92 01       	movw	r18, r4
     c58:	c7 01       	movw	r24, r14
     c5a:	b6 01       	movw	r22, r12
     c5c:	0e 94 77 21 	call	0x42ee	; 0x42ee <__mulsf3>
     c60:	ed 81       	ldd	r30, Y+5	; 0x05
     c62:	fe 81       	ldd	r31, Y+6	; 0x06
     c64:	24 8d       	ldd	r18, Z+28	; 0x1c
     c66:	35 8d       	ldd	r19, Z+29	; 0x1d
     c68:	46 8d       	ldd	r20, Z+30	; 0x1e
     c6a:	57 8d       	ldd	r21, Z+31	; 0x1f
     c6c:	0e 94 a7 1f 	call	0x3f4e	; 0x3f4e <__addsf3>
     c70:	4b 01       	movw	r8, r22
     c72:	5c 01       	movw	r10, r24
     c74:	ed 81       	ldd	r30, Y+5	; 0x05
     c76:	fe 81       	ldd	r31, Y+6	; 0x06
     c78:	64 8f       	std	Z+28, r22	; 0x1c
     c7a:	75 8f       	std	Z+29, r23	; 0x1d
     c7c:	86 8f       	std	Z+30, r24	; 0x1e
     c7e:	97 8f       	std	Z+31, r25	; 0x1f
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     c80:	20 8d       	ldd	r18, Z+24	; 0x18
     c82:	31 8d       	ldd	r19, Z+25	; 0x19
     c84:	42 8d       	ldd	r20, Z+26	; 0x1a
     c86:	53 8d       	ldd	r21, Z+27	; 0x1b
     c88:	c7 01       	movw	r24, r14
     c8a:	b6 01       	movw	r22, r12
     c8c:	0e 94 a6 1f 	call	0x3f4c	; 0x3f4c <__subsf3>
     c90:	a3 01       	movw	r20, r6
     c92:	92 01       	movw	r18, r4
     c94:	0e 94 18 20 	call	0x4030	; 0x4030 <__divsf3>
     c98:	ed 81       	ldd	r30, Y+5	; 0x05
     c9a:	fe 81       	ldd	r31, Y+6	; 0x06
     c9c:	20 89       	ldd	r18, Z+16	; 0x10
     c9e:	31 89       	ldd	r19, Z+17	; 0x11
     ca0:	42 89       	ldd	r20, Z+18	; 0x12
     ca2:	53 89       	ldd	r21, Z+19	; 0x13
     ca4:	0e 94 77 21 	call	0x42ee	; 0x42ee <__mulsf3>
     ca8:	2b 01       	movw	r4, r22
     caa:	3c 01       	movw	r6, r24
     cac:	ed 81       	ldd	r30, Y+5	; 0x05
     cae:	fe 81       	ldd	r31, Y+6	; 0x06
     cb0:	24 89       	ldd	r18, Z+20	; 0x14
     cb2:	35 89       	ldd	r19, Z+21	; 0x15
     cb4:	46 89       	ldd	r20, Z+22	; 0x16
     cb6:	57 89       	ldd	r21, Z+23	; 0x17
     cb8:	c5 01       	movw	r24, r10
     cba:	b4 01       	movw	r22, r8
     cbc:	0e 94 77 21 	call	0x42ee	; 0x42ee <__mulsf3>
     cc0:	29 81       	ldd	r18, Y+1	; 0x01
     cc2:	3a 81       	ldd	r19, Y+2	; 0x02
     cc4:	4b 81       	ldd	r20, Y+3	; 0x03
     cc6:	5c 81       	ldd	r21, Y+4	; 0x04
     cc8:	0e 94 a7 1f 	call	0x3f4e	; 0x3f4e <__addsf3>
     ccc:	9b 01       	movw	r18, r22
     cce:	ac 01       	movw	r20, r24
     cd0:	c3 01       	movw	r24, r6
     cd2:	b2 01       	movw	r22, r4
     cd4:	0e 94 a7 1f 	call	0x3f4e	; 0x3f4e <__addsf3>
     cd8:	b6 2e       	mov	r11, r22
     cda:	a7 2e       	mov	r10, r23
     cdc:	98 2e       	mov	r9, r24
     cde:	89 2e       	mov	r8, r25

    // Restrict to max/min
    if( output > _max )
     ce0:	ed 81       	ldd	r30, Y+5	; 0x05
     ce2:	fe 81       	ldd	r31, Y+6	; 0x06
     ce4:	74 80       	ldd	r7, Z+4	; 0x04
     ce6:	65 80       	ldd	r6, Z+5	; 0x05
     ce8:	56 80       	ldd	r5, Z+6	; 0x06
     cea:	47 80       	ldd	r4, Z+7	; 0x07
     cec:	27 2d       	mov	r18, r7
     cee:	36 2d       	mov	r19, r6
     cf0:	45 2d       	mov	r20, r5
     cf2:	54 2d       	mov	r21, r4
     cf4:	0e 94 72 21 	call	0x42e4	; 0x42e4 <__gesf2>
     cf8:	18 16       	cp	r1, r24
     cfa:	b4 f0       	brlt	.+44     	; 0xd28 <_ZN7PIDImpl9calculateEdd+0x134>
        output = _max;
    else if( output < _min )
     cfc:	ed 81       	ldd	r30, Y+5	; 0x05
     cfe:	fe 81       	ldd	r31, Y+6	; 0x06
     d00:	70 84       	ldd	r7, Z+8	; 0x08
     d02:	61 84       	ldd	r6, Z+9	; 0x09
     d04:	52 84       	ldd	r5, Z+10	; 0x0a
     d06:	43 84       	ldd	r4, Z+11	; 0x0b
     d08:	27 2d       	mov	r18, r7
     d0a:	36 2d       	mov	r19, r6
     d0c:	45 2d       	mov	r20, r5
     d0e:	54 2d       	mov	r21, r4
     d10:	6b 2d       	mov	r22, r11
     d12:	7a 2d       	mov	r23, r10
     d14:	89 2d       	mov	r24, r9
     d16:	98 2d       	mov	r25, r8
     d18:	0e 94 13 20 	call	0x4026	; 0x4026 <__cmpsf2>
     d1c:	88 23       	and	r24, r24
     d1e:	24 f0       	brlt	.+8      	; 0xd28 <_ZN7PIDImpl9calculateEdd+0x134>
    // Derivative term
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // Calculate total output
    double output = Pout + Iout + Dout;
     d20:	7b 2c       	mov	r7, r11
     d22:	6a 2c       	mov	r6, r10
     d24:	59 2c       	mov	r5, r9
     d26:	48 2c       	mov	r4, r8
        output = _max;
    else if( output < _min )
        output = _min;

    // Save error to previous error
    _pre_error = error;
     d28:	ed 81       	ldd	r30, Y+5	; 0x05
     d2a:	fe 81       	ldd	r31, Y+6	; 0x06
     d2c:	c0 8e       	std	Z+24, r12	; 0x18
     d2e:	d1 8e       	std	Z+25, r13	; 0x19
     d30:	e2 8e       	std	Z+26, r14	; 0x1a
     d32:	f3 8e       	std	Z+27, r15	; 0x1b

    return output;
}
     d34:	67 2d       	mov	r22, r7
     d36:	76 2d       	mov	r23, r6
     d38:	85 2d       	mov	r24, r5
     d3a:	94 2d       	mov	r25, r4
     d3c:	26 96       	adiw	r28, 0x06	; 6
     d3e:	cd bf       	out	0x3d, r28	; 61
     d40:	de bf       	out	0x3e, r29	; 62
     d42:	df 91       	pop	r29
     d44:	cf 91       	pop	r28
     d46:	1f 91       	pop	r17
     d48:	0f 91       	pop	r16
     d4a:	ff 90       	pop	r15
     d4c:	ef 90       	pop	r14
     d4e:	df 90       	pop	r13
     d50:	cf 90       	pop	r12
     d52:	bf 90       	pop	r11
     d54:	af 90       	pop	r10
     d56:	9f 90       	pop	r9
     d58:	8f 90       	pop	r8
     d5a:	7f 90       	pop	r7
     d5c:	6f 90       	pop	r6
     d5e:	5f 90       	pop	r5
     d60:	4f 90       	pop	r4
     d62:	08 95       	ret

00000d64 <_ZN3PID9calculateEdd>:
PID::PID( double dt, double max, double min, double Kp, double Kd, double Ki )
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
double PID::calculate( double setpoint, double pv )
{
     d64:	0f 93       	push	r16
     d66:	1f 93       	push	r17
    return pimpl->calculate(setpoint,pv);
     d68:	fc 01       	movw	r30, r24
     d6a:	80 81       	ld	r24, Z
     d6c:	91 81       	ldd	r25, Z+1	; 0x01
     d6e:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <_ZN7PIDImpl9calculateEdd>
}
     d72:	1f 91       	pop	r17
     d74:	0f 91       	pop	r16
     d76:	08 95       	ret

00000d78 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     d78:	0f 93       	push	r16
     d7a:	1f 93       	push	r17
     d7c:	cf 93       	push	r28
     d7e:	df 93       	push	r29
     d80:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d82:	0e 94 83 14 	call	0x2906	; 0x2906 <_ZN8frt_taskC1EPKchjP8emstream>
     d86:	83 e4       	ldi	r24, 0x43	; 67
     d88:	90 e2       	ldi	r25, 0x20	; 32
     d8a:	88 83       	st	Y, r24
     d8c:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     d8e:	df 91       	pop	r29
     d90:	cf 91       	pop	r28
     d92:	1f 91       	pop	r17
     d94:	0f 91       	pop	r16
     d96:	08 95       	ret

00000d98 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     d98:	0f 93       	push	r16
     d9a:	1f 93       	push	r17
     d9c:	cf 93       	push	r28
     d9e:	df 93       	push	r29
     da0:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     da2:	6a e0       	ldi	r22, 0x0A	; 10
     da4:	8e 81       	ldd	r24, Y+6	; 0x06
     da6:	9f 81       	ldd	r25, Y+7	; 0x07
     da8:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     dac:	8c 01       	movw	r16, r24
     dae:	69 ee       	ldi	r22, 0xE9	; 233
     db0:	73 e0       	ldi	r23, 0x03	; 3
     db2:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     db6:	6a e0       	ldi	r22, 0x0A	; 10
     db8:	c8 01       	movw	r24, r16
     dba:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     dbe:	8c 01       	movw	r16, r24
     dc0:	63 ee       	ldi	r22, 0xE3	; 227
     dc2:	73 e0       	ldi	r23, 0x03	; 3
     dc4:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     dc8:	67 e0       	ldi	r22, 0x07	; 7
     dca:	c8 01       	movw	r24, r16
     dcc:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     dd0:	6a e0       	ldi	r22, 0x0A	; 10
     dd2:	8e 81       	ldd	r24, Y+6	; 0x06
     dd4:	9f 81       	ldd	r25, Y+7	; 0x07
     dd6:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     dda:	8c 01       	movw	r16, r24
     ddc:	64 ec       	ldi	r22, 0xC4	; 196
     dde:	73 e0       	ldi	r23, 0x03	; 3
     de0:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     de4:	6a e0       	ldi	r22, 0x0A	; 10
     de6:	c8 01       	movw	r24, r16
     de8:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     dec:	8c 01       	movw	r16, r24
     dee:	6e eb       	ldi	r22, 0xBE	; 190
     df0:	73 e0       	ldi	r23, 0x03	; 3
     df2:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     df6:	66 e0       	ldi	r22, 0x06	; 6
     df8:	c8 01       	movw	r24, r16
     dfa:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     dfe:	6a e0       	ldi	r22, 0x0A	; 10
     e00:	8e 81       	ldd	r24, Y+6	; 0x06
     e02:	9f 81       	ldd	r25, Y+7	; 0x07
     e04:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     e08:	8c 01       	movw	r16, r24
     e0a:	67 ea       	ldi	r22, 0xA7	; 167
     e0c:	73 e0       	ldi	r23, 0x03	; 3
     e0e:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     e12:	66 e0       	ldi	r22, 0x06	; 6
     e14:	c8 01       	movw	r24, r16
     e16:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e1a:	6a e0       	ldi	r22, 0x0A	; 10
     e1c:	8e 81       	ldd	r24, Y+6	; 0x06
     e1e:	9f 81       	ldd	r25, Y+7	; 0x07
     e20:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     e24:	8c 01       	movw	r16, r24
     e26:	6b e8       	ldi	r22, 0x8B	; 139
     e28:	73 e0       	ldi	r23, 0x03	; 3
     e2a:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     e2e:	66 e0       	ldi	r22, 0x06	; 6
     e30:	c8 01       	movw	r24, r16
     e32:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e36:	6a e0       	ldi	r22, 0x0A	; 10
     e38:	8e 81       	ldd	r24, Y+6	; 0x06
     e3a:	9f 81       	ldd	r25, Y+7	; 0x07
     e3c:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     e40:	8c 01       	movw	r16, r24
     e42:	63 e7       	ldi	r22, 0x73	; 115
     e44:	73 e0       	ldi	r23, 0x03	; 3
     e46:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     e4a:	66 e0       	ldi	r22, 0x06	; 6
     e4c:	c8 01       	movw	r24, r16
     e4e:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e52:	6a e0       	ldi	r22, 0x0A	; 10
     e54:	8e 81       	ldd	r24, Y+6	; 0x06
     e56:	9f 81       	ldd	r25, Y+7	; 0x07
     e58:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     e5c:	8c 01       	movw	r16, r24
     e5e:	62 e5       	ldi	r22, 0x52	; 82
     e60:	73 e0       	ldi	r23, 0x03	; 3
     e62:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     e66:	66 e0       	ldi	r22, 0x06	; 6
     e68:	c8 01       	movw	r24, r16
     e6a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e6e:	6a e0       	ldi	r22, 0x0A	; 10
     e70:	8e 81       	ldd	r24, Y+6	; 0x06
     e72:	9f 81       	ldd	r25, Y+7	; 0x07
     e74:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     e78:	8c 01       	movw	r16, r24
     e7a:	6b e2       	ldi	r22, 0x2B	; 43
     e7c:	73 e0       	ldi	r23, 0x03	; 3
     e7e:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     e82:	66 e0       	ldi	r22, 0x06	; 6
     e84:	c8 01       	movw	r24, r16
     e86:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     e8a:	6a e0       	ldi	r22, 0x0A	; 10
     e8c:	8e 81       	ldd	r24, Y+6	; 0x06
     e8e:	9f 81       	ldd	r25, Y+7	; 0x07
     e90:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     e94:	8c 01       	movw	r16, r24
     e96:	6d e0       	ldi	r22, 0x0D	; 13
     e98:	73 e0       	ldi	r23, 0x03	; 3
     e9a:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     e9e:	66 e0       	ldi	r22, 0x06	; 6
     ea0:	c8 01       	movw	r24, r16
     ea2:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     ea6:	6a e0       	ldi	r22, 0x0A	; 10
     ea8:	8e 81       	ldd	r24, Y+6	; 0x06
     eaa:	9f 81       	ldd	r25, Y+7	; 0x07
     eac:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     eb0:	8c 01       	movw	r16, r24
     eb2:	62 ef       	ldi	r22, 0xF2	; 242
     eb4:	72 e0       	ldi	r23, 0x02	; 2
     eb6:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     eba:	66 e0       	ldi	r22, 0x06	; 6
     ebc:	c8 01       	movw	r24, r16
     ebe:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     ec2:	6a e0       	ldi	r22, 0x0A	; 10
     ec4:	8e 81       	ldd	r24, Y+6	; 0x06
     ec6:	9f 81       	ldd	r25, Y+7	; 0x07
     ec8:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     ecc:	ec 01       	movw	r28, r24
     ece:	63 ee       	ldi	r22, 0xE3	; 227
     ed0:	72 e0       	ldi	r23, 0x02	; 2
     ed2:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     ed6:	66 e0       	ldi	r22, 0x06	; 6
     ed8:	ce 01       	movw	r24, r28
     eda:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
}
     ede:	df 91       	pop	r29
     ee0:	cf 91       	pop	r28
     ee2:	1f 91       	pop	r17
     ee4:	0f 91       	pop	r16
     ee6:	08 95       	ret

00000ee8 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     ee8:	af 92       	push	r10
     eea:	bf 92       	push	r11
     eec:	cf 92       	push	r12
     eee:	df 92       	push	r13
     ef0:	ef 92       	push	r14
     ef2:	ff 92       	push	r15
     ef4:	0f 93       	push	r16
     ef6:	1f 93       	push	r17
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
     efc:	00 d0       	rcall	.+0      	; 0xefe <_ZN9task_user11show_statusEv+0x16>
     efe:	00 d0       	rcall	.+0      	; 0xf00 <_ZN9task_user11show_statusEv+0x18>
     f00:	cd b7       	in	r28, 0x3d	; 61
     f02:	de b7       	in	r29, 0x3e	; 62
     f04:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f06:	19 82       	std	Y+1, r1	; 0x01
     f08:	1a 82       	std	Y+2, r1	; 0x02
     f0a:	1b 82       	std	Y+3, r1	; 0x03
     f0c:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f0e:	1d 82       	std	Y+5, r1	; 0x05
     f10:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f12:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <xPortGetFreeHeapSize>
     f16:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f18:	ce 01       	movw	r24, r28
     f1a:	01 96       	adiw	r24, 0x01	; 1
     f1c:	0e 94 34 18 	call	0x3068	; 0x3068 <_ZN10time_stamp10set_to_nowEv>
     f20:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f22:	66 e0       	ldi	r22, 0x06	; 6
     f24:	f8 01       	movw	r30, r16
     f26:	86 81       	ldd	r24, Z+6	; 0x06
     f28:	97 81       	ldd	r25, Z+7	; 0x07
     f2a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     f2e:	6a e0       	ldi	r22, 0x0A	; 10
     f30:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     f34:	7c 01       	movw	r14, r24
     f36:	64 ec       	ldi	r22, 0xC4	; 196
     f38:	72 e0       	ldi	r23, 0x02	; 2
     f3a:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     f3e:	6a e0       	ldi	r22, 0x0A	; 10
     f40:	c7 01       	movw	r24, r14
     f42:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     f46:	7c 01       	movw	r14, r24
     f48:	68 eb       	ldi	r22, 0xB8	; 184
     f4a:	72 e0       	ldi	r23, 0x02	; 2
     f4c:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     f50:	66 e0       	ldi	r22, 0x06	; 6
     f52:	c7 01       	movw	r24, r14
     f54:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f58:	6a e0       	ldi	r22, 0x0A	; 10
     f5a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     f5e:	7c 01       	movw	r14, r24
     f60:	61 eb       	ldi	r22, 0xB1	; 177
     f62:	72 e0       	ldi	r23, 0x02	; 2
     f64:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     f68:	b5 01       	movw	r22, r10
     f6a:	c7 01       	movw	r24, r14
     f6c:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f70:	6a e0       	ldi	r22, 0x0A	; 10
     f72:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     f76:	7c 01       	movw	r14, r24
     f78:	63 ea       	ldi	r22, 0xA3	; 163
     f7a:	72 e0       	ldi	r23, 0x02	; 2
     f7c:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     f80:	b6 01       	movw	r22, r12
     f82:	c7 01       	movw	r24, r14
     f84:	0e 94 66 1a 	call	0x34cc	; 0x34cc <_ZN8emstreamlsEj>
     f88:	6a e0       	ldi	r22, 0x0A	; 10
     f8a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     f8e:	7c 01       	movw	r14, r24
     f90:	61 ea       	ldi	r22, 0xA1	; 161
     f92:	72 e0       	ldi	r23, 0x02	; 2
     f94:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     f98:	4f ef       	ldi	r20, 0xFF	; 255
     f9a:	5f e0       	ldi	r21, 0x0F	; 15
     f9c:	60 e0       	ldi	r22, 0x00	; 0
     f9e:	70 e0       	ldi	r23, 0x00	; 0
     fa0:	c7 01       	movw	r24, r14
     fa2:	0e 94 9a 1a 	call	0x3534	; 0x3534 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     fa6:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     faa:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     fae:	6a e0       	ldi	r22, 0x0A	; 10
     fb0:	f8 01       	movw	r30, r16
     fb2:	86 81       	ldd	r24, Z+6	; 0x06
     fb4:	97 81       	ldd	r25, Z+7	; 0x07
     fb6:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     fba:	7c 01       	movw	r14, r24
     fbc:	66 e9       	ldi	r22, 0x96	; 150
     fbe:	72 e0       	ldi	r23, 0x02	; 2
     fc0:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
     fc4:	b6 01       	movw	r22, r12
     fc6:	c7 01       	movw	r24, r14
     fc8:	0e 94 66 1a 	call	0x34cc	; 0x34cc <_ZN8emstreamlsEj>
     fcc:	66 e0       	ldi	r22, 0x06	; 6
     fce:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
     fd2:	66 e0       	ldi	r22, 0x06	; 6
     fd4:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     fd8:	f8 01       	movw	r30, r16
     fda:	86 81       	ldd	r24, Z+6	; 0x06
     fdc:	97 81       	ldd	r25, Z+7	; 0x07
     fde:	0e 94 91 16 	call	0x2d22	; 0x2d22 <_Z15print_task_listP8emstream>
}
     fe2:	26 96       	adiw	r28, 0x06	; 6
     fe4:	cd bf       	out	0x3d, r28	; 61
     fe6:	de bf       	out	0x3e, r29	; 62
     fe8:	df 91       	pop	r29
     fea:	cf 91       	pop	r28
     fec:	1f 91       	pop	r17
     fee:	0f 91       	pop	r16
     ff0:	ff 90       	pop	r15
     ff2:	ef 90       	pop	r14
     ff4:	df 90       	pop	r13
     ff6:	cf 90       	pop	r12
     ff8:	bf 90       	pop	r11
     ffa:	af 90       	pop	r10
     ffc:	08 95       	ret

00000ffe <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
    1002:	00 d0       	rcall	.+0      	; 0x1004 <_ZN9task_user3runEv+0x6>
    1004:	00 d0       	rcall	.+0      	; 0x1006 <_ZN9task_user3runEv+0x8>
    1006:	cd b7       	in	r28, 0x3d	; 61
    1008:	de b7       	in	r29, 0x3e	; 62
    100a:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    100c:	19 82       	std	Y+1, r1	; 0x01
    100e:	1a 82       	std	Y+2, r1	; 0x02
    1010:	1b 82       	std	Y+3, r1	; 0x03
    1012:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1014:	1d 82       	std	Y+5, r1	; 0x05
    1016:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1018:	6a e0       	ldi	r22, 0x0A	; 10
    101a:	dc 01       	movw	r26, r24
    101c:	16 96       	adiw	r26, 0x06	; 6
    101e:	8d 91       	ld	r24, X+
    1020:	9c 91       	ld	r25, X
    1022:	17 97       	sbiw	r26, 0x07	; 7
    1024:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    1028:	7c 01       	movw	r14, r24
    102a:	62 e3       	ldi	r22, 0x32	; 50
    102c:	74 e0       	ldi	r23, 0x04	; 4
    102e:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    1032:	66 e0       	ldi	r22, 0x06	; 6
    1034:	c7 01       	movw	r24, r14
    1036:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    103a:	f8 01       	movw	r30, r16
    103c:	84 85       	ldd	r24, Z+12	; 0x0c
    103e:	88 23       	and	r24, r24
    1040:	21 f0       	breq	.+8      	; 0x104a <_ZN9task_user3runEv+0x4c>
    1042:	81 30       	cpi	r24, 0x01	; 1
    1044:	09 f4       	brne	.+2      	; 0x1048 <_ZN9task_user3runEv+0x4a>
    1046:	5d c0       	rjmp	.+186    	; 0x1102 <_ZN9task_user3runEv+0x104>
    1048:	d8 c0       	rjmp	.+432    	; 0x11fa <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    104a:	86 81       	ldd	r24, Z+6	; 0x06
    104c:	97 81       	ldd	r25, Z+7	; 0x07
    104e:	dc 01       	movw	r26, r24
    1050:	ed 91       	ld	r30, X+
    1052:	fc 91       	ld	r31, X
    1054:	04 80       	ldd	r0, Z+4	; 0x04
    1056:	f5 81       	ldd	r31, Z+5	; 0x05
    1058:	e0 2d       	mov	r30, r0
    105a:	19 95       	eicall
    105c:	88 23       	and	r24, r24
    105e:	a9 f1       	breq	.+106    	; 0x10ca <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1060:	f8 01       	movw	r30, r16
    1062:	86 81       	ldd	r24, Z+6	; 0x06
    1064:	97 81       	ldd	r25, Z+7	; 0x07
    1066:	dc 01       	movw	r26, r24
    1068:	ed 91       	ld	r30, X+
    106a:	fc 91       	ld	r31, X
    106c:	06 80       	ldd	r0, Z+6	; 0x06
    106e:	f7 81       	ldd	r31, Z+7	; 0x07
    1070:	e0 2d       	mov	r30, r0
    1072:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1074:	99 27       	eor	r25, r25
    1076:	81 30       	cpi	r24, 0x01	; 1
    1078:	91 05       	cpc	r25, r1
    107a:	f9 f0       	breq	.+62     	; 0x10ba <_ZN9task_user3runEv+0xbc>
    107c:	03 97       	sbiw	r24, 0x03	; 3
    107e:	09 f0       	breq	.+2      	; 0x1082 <_ZN9task_user3runEv+0x84>
    1080:	d8 c0       	rjmp	.+432    	; 0x1232 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1082:	6a e0       	ldi	r22, 0x0A	; 10
    1084:	f8 01       	movw	r30, r16
    1086:	86 81       	ldd	r24, Z+6	; 0x06
    1088:	97 81       	ldd	r25, Z+7	; 0x07
    108a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    108e:	8c 01       	movw	r16, r24
    1090:	64 e2       	ldi	r22, 0x24	; 36
    1092:	74 e0       	ldi	r23, 0x04	; 4
    1094:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    1098:	66 e0       	ldi	r22, 0x06	; 6
    109a:	c8 01       	movw	r24, r16
    109c:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10a0:	93 e0       	ldi	r25, 0x03	; 3
    10a2:	88 ed       	ldi	r24, 0xD8	; 216
    10a4:	08 b6       	in	r0, 0x38	; 56
    10a6:	18 be       	out	0x38, r1	; 56
    10a8:	84 bf       	out	0x34, r24	; 52
    10aa:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10ae:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10b2:	81 fd       	sbrc	r24, 1
    10b4:	fc cf       	rjmp	.-8      	; 0x10ae <_ZN9task_user3runEv+0xb0>
    10b6:	08 be       	out	0x38, r0	; 56
    10b8:	ff cf       	rjmp	.-2      	; 0x10b8 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10ba:	c8 01       	movw	r24, r16
    10bc:	0e 94 cc 06 	call	0xd98	; 0xd98 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10c0:	61 e0       	ldi	r22, 0x01	; 1
    10c2:	c8 01       	movw	r24, r16
    10c4:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_ZN8frt_task13transition_toEh>
							break;
    10c8:	b4 c0       	rjmp	.+360    	; 0x1232 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10ca:	84 e6       	ldi	r24, 0x64	; 100
    10cc:	91 e3       	ldi	r25, 0x31	; 49
    10ce:	0e 94 40 17 	call	0x2e80	; 0x2e80 <_ZN14frt_text_queue14check_for_charEv>
    10d2:	88 23       	and	r24, r24
    10d4:	09 f4       	brne	.+2      	; 0x10d8 <_ZN9task_user3runEv+0xda>
    10d6:	ad c0       	rjmp	.+346    	; 0x1232 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    10d8:	d8 01       	movw	r26, r16
    10da:	16 96       	adiw	r26, 0x06	; 6
    10dc:	ed 91       	ld	r30, X+
    10de:	fc 91       	ld	r31, X
    10e0:	17 97       	sbiw	r26, 0x07	; 7
    10e2:	01 90       	ld	r0, Z+
    10e4:	f0 81       	ld	r31, Z
    10e6:	e0 2d       	mov	r30, r0
    10e8:	e2 80       	ldd	r14, Z+2	; 0x02
    10ea:	f3 80       	ldd	r15, Z+3	; 0x03
    10ec:	84 e6       	ldi	r24, 0x64	; 100
    10ee:	91 e3       	ldi	r25, 0x31	; 49
    10f0:	0e 94 22 17 	call	0x2e44	; 0x2e44 <_ZN14frt_text_queue7getcharEv>
    10f4:	68 2f       	mov	r22, r24
    10f6:	f8 01       	movw	r30, r16
    10f8:	86 81       	ldd	r24, Z+6	; 0x06
    10fa:	97 81       	ldd	r25, Z+7	; 0x07
    10fc:	f7 01       	movw	r30, r14
    10fe:	19 95       	eicall
    1100:	98 c0       	rjmp	.+304    	; 0x1232 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1102:	86 81       	ldd	r24, Z+6	; 0x06
    1104:	97 81       	ldd	r25, Z+7	; 0x07
    1106:	dc 01       	movw	r26, r24
    1108:	ed 91       	ld	r30, X+
    110a:	fc 91       	ld	r31, X
    110c:	04 80       	ldd	r0, Z+4	; 0x04
    110e:	f5 81       	ldd	r31, Z+5	; 0x05
    1110:	e0 2d       	mov	r30, r0
    1112:	19 95       	eicall
    1114:	88 23       	and	r24, r24
    1116:	09 f4       	brne	.+2      	; 0x111a <_ZN9task_user3runEv+0x11c>
    1118:	8c c0       	rjmp	.+280    	; 0x1232 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    111a:	f8 01       	movw	r30, r16
    111c:	86 81       	ldd	r24, Z+6	; 0x06
    111e:	97 81       	ldd	r25, Z+7	; 0x07
    1120:	dc 01       	movw	r26, r24
    1122:	ed 91       	ld	r30, X+
    1124:	fc 91       	ld	r31, X
    1126:	06 80       	ldd	r0, Z+6	; 0x06
    1128:	f7 81       	ldd	r31, Z+7	; 0x07
    112a:	e0 2d       	mov	r30, r0
    112c:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    112e:	9c 01       	movw	r18, r24
    1130:	33 27       	eor	r19, r19
    1132:	28 36       	cpi	r18, 0x68	; 104
    1134:	31 05       	cpc	r19, r1
    1136:	59 f1       	breq	.+86     	; 0x118e <_ZN9task_user3runEv+0x190>
    1138:	3c f4       	brge	.+14     	; 0x1148 <_ZN9task_user3runEv+0x14a>
    113a:	2b 31       	cpi	r18, 0x1B	; 27
    113c:	31 05       	cpc	r19, r1
    113e:	59 f1       	breq	.+86     	; 0x1196 <_ZN9task_user3runEv+0x198>
    1140:	25 36       	cpi	r18, 0x65	; 101
    1142:	31 05       	cpc	r19, r1
    1144:	41 f1       	breq	.+80     	; 0x1196 <_ZN9task_user3runEv+0x198>
    1146:	3b c0       	rjmp	.+118    	; 0x11be <_ZN9task_user3runEv+0x1c0>
    1148:	23 37       	cpi	r18, 0x73	; 115
    114a:	31 05       	cpc	r19, r1
    114c:	c1 f0       	breq	.+48     	; 0x117e <_ZN9task_user3runEv+0x180>
    114e:	26 37       	cpi	r18, 0x76	; 118
    1150:	31 05       	cpc	r19, r1
    1152:	89 f0       	breq	.+34     	; 0x1176 <_ZN9task_user3runEv+0x178>
    1154:	2e 36       	cpi	r18, 0x6E	; 110
    1156:	31 05       	cpc	r19, r1
    1158:	91 f5       	brne	.+100    	; 0x11be <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    115a:	ce 01       	movw	r24, r28
    115c:	01 96       	adiw	r24, 0x01	; 1
    115e:	0e 94 34 18 	call	0x3068	; 0x3068 <_ZN10time_stamp10set_to_nowEv>
    1162:	bc 01       	movw	r22, r24
    1164:	f8 01       	movw	r30, r16
    1166:	86 81       	ldd	r24, Z+6	; 0x06
    1168:	97 81       	ldd	r25, Z+7	; 0x07
    116a:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <_ZlsR8emstreamR10time_stamp>
    116e:	66 e0       	ldi	r22, 0x06	; 6
    1170:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
							break;
    1174:	5e c0       	rjmp	.+188    	; 0x1232 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1176:	c8 01       	movw	r24, r16
    1178:	0e 94 74 07 	call	0xee8	; 0xee8 <_ZN9task_user11show_statusEv>
							break;
    117c:	5a c0       	rjmp	.+180    	; 0x1232 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    117e:	d8 01       	movw	r26, r16
    1180:	16 96       	adiw	r26, 0x06	; 6
    1182:	8d 91       	ld	r24, X+
    1184:	9c 91       	ld	r25, X
    1186:	17 97       	sbiw	r26, 0x07	; 7
    1188:	0e 94 98 15 	call	0x2b30	; 0x2b30 <_Z17print_task_stacksP8emstream>
							break;
    118c:	52 c0       	rjmp	.+164    	; 0x1232 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    118e:	c8 01       	movw	r24, r16
    1190:	0e 94 cc 06 	call	0xd98	; 0xd98 <_ZN9task_user18print_help_messageEv>
							break;
    1194:	4e c0       	rjmp	.+156    	; 0x1232 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1196:	6a e0       	ldi	r22, 0x0A	; 10
    1198:	f8 01       	movw	r30, r16
    119a:	86 81       	ldd	r24, Z+6	; 0x06
    119c:	97 81       	ldd	r25, Z+7	; 0x07
    119e:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    11a2:	7c 01       	movw	r14, r24
    11a4:	62 e1       	ldi	r22, 0x12	; 18
    11a6:	74 e0       	ldi	r23, 0x04	; 4
    11a8:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    11ac:	66 e0       	ldi	r22, 0x06	; 6
    11ae:	c7 01       	movw	r24, r14
    11b0:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11b4:	60 e0       	ldi	r22, 0x00	; 0
    11b6:	c8 01       	movw	r24, r16
    11b8:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_ZN8frt_task13transition_toEh>
							break;
    11bc:	3a c0       	rjmp	.+116    	; 0x1232 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11be:	f8 01       	movw	r30, r16
    11c0:	a6 81       	ldd	r26, Z+6	; 0x06
    11c2:	b7 81       	ldd	r27, Z+7	; 0x07
    11c4:	ed 91       	ld	r30, X+
    11c6:	fc 91       	ld	r31, X
    11c8:	11 97       	sbiw	r26, 0x01	; 1
    11ca:	02 80       	ldd	r0, Z+2	; 0x02
    11cc:	f3 81       	ldd	r31, Z+3	; 0x03
    11ce:	e0 2d       	mov	r30, r0
    11d0:	68 2f       	mov	r22, r24
    11d2:	cd 01       	movw	r24, r26
    11d4:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    11d6:	6a e0       	ldi	r22, 0x0A	; 10
    11d8:	d8 01       	movw	r26, r16
    11da:	16 96       	adiw	r26, 0x06	; 6
    11dc:	8d 91       	ld	r24, X+
    11de:	9c 91       	ld	r25, X
    11e0:	17 97       	sbiw	r26, 0x07	; 7
    11e2:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    11e6:	7c 01       	movw	r14, r24
    11e8:	6c e0       	ldi	r22, 0x0C	; 12
    11ea:	74 e0       	ldi	r23, 0x04	; 4
    11ec:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    11f0:	66 e0       	ldi	r22, 0x06	; 6
    11f2:	c7 01       	movw	r24, r14
    11f4:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
							break;
    11f8:	1c c0       	rjmp	.+56     	; 0x1232 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    11fa:	6a e0       	ldi	r22, 0x0A	; 10
    11fc:	f8 01       	movw	r30, r16
    11fe:	86 81       	ldd	r24, Z+6	; 0x06
    1200:	97 81       	ldd	r25, Z+7	; 0x07
    1202:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    1206:	8c 01       	movw	r16, r24
    1208:	6f ee       	ldi	r22, 0xEF	; 239
    120a:	73 e0       	ldi	r23, 0x03	; 3
    120c:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    1210:	66 e0       	ldi	r22, 0x06	; 6
    1212:	c8 01       	movw	r24, r16
    1214:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1218:	93 e0       	ldi	r25, 0x03	; 3
    121a:	88 ed       	ldi	r24, 0xD8	; 216
    121c:	08 b6       	in	r0, 0x38	; 56
    121e:	18 be       	out	0x38, r1	; 56
    1220:	84 bf       	out	0x34, r24	; 52
    1222:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1226:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    122a:	81 fd       	sbrc	r24, 1
    122c:	fc cf       	rjmp	.-8      	; 0x1226 <_ZN9task_user3runEv+0x228>
    122e:	08 be       	out	0x38, r0	; 56
    1230:	ff cf       	rjmp	.-2      	; 0x1230 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1232:	f8 01       	movw	r30, r16
    1234:	86 85       	ldd	r24, Z+14	; 0x0e
    1236:	97 85       	ldd	r25, Z+15	; 0x0f
    1238:	a0 89       	ldd	r26, Z+16	; 0x10
    123a:	b1 89       	ldd	r27, Z+17	; 0x11
    123c:	01 96       	adiw	r24, 0x01	; 1
    123e:	a1 1d       	adc	r26, r1
    1240:	b1 1d       	adc	r27, r1
    1242:	86 87       	std	Z+14, r24	; 0x0e
    1244:	97 87       	std	Z+15, r25	; 0x0f
    1246:	a0 8b       	std	Z+16, r26	; 0x10
    1248:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    124a:	61 e0       	ldi	r22, 0x01	; 1
    124c:	70 e0       	ldi	r23, 0x00	; 0
    124e:	80 e0       	ldi	r24, 0x00	; 0
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	0e 94 53 12 	call	0x24a6	; 0x24a6 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1256:	f1 ce       	rjmp	.-542    	; 0x103a <_ZN9task_user3runEv+0x3c>

00001258 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1258:	0f 93       	push	r16
    125a:	1f 93       	push	r17
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1262:	0e 94 42 10 	call	0x2084	; 0x2084 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1266:	80 91 c8 20 	lds	r24, 0x20C8	; 0x8020c8 <__data_end>
    126a:	81 11       	cpse	r24, r1
    126c:	1d c0       	rjmp	.+58     	; 0x12a8 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    126e:	ad ec       	ldi	r26, 0xCD	; 205
    1270:	b0 e2       	ldi	r27, 0x20	; 32
    1272:	e1 ed       	ldi	r30, 0xD1	; 209
    1274:	f0 e2       	ldi	r31, 0x20	; 32
    1276:	ed 93       	st	X+, r30
    1278:	fc 93       	st	X, r31
    127a:	11 97       	sbiw	r26, 0x01	; 1
    127c:	12 96       	adiw	r26, 0x02	; 2
    127e:	1d 92       	st	X+, r1
    1280:	1c 92       	st	X, r1
    1282:	13 97       	sbiw	r26, 0x03	; 3
    1284:	a9 ec       	ldi	r26, 0xC9	; 201
    1286:	b0 e2       	ldi	r27, 0x20	; 32
    1288:	8f ef       	ldi	r24, 0xFF	; 255
    128a:	9f e0       	ldi	r25, 0x0F	; 15
    128c:	12 96       	adiw	r26, 0x02	; 2
    128e:	8d 93       	st	X+, r24
    1290:	9c 93       	st	X, r25
    1292:	13 97       	sbiw	r26, 0x03	; 3
    1294:	1d 92       	st	X+, r1
    1296:	1c 92       	st	X, r1
    1298:	11 97       	sbiw	r26, 0x01	; 1
    129a:	82 83       	std	Z+2, r24	; 0x02
    129c:	93 83       	std	Z+3, r25	; 0x03
    129e:	a0 83       	st	Z, r26
    12a0:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	80 93 c8 20 	sts	0x20C8, r24	; 0x8020c8 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12a8:	20 97       	sbiw	r28, 0x00	; 0
    12aa:	09 f4       	brne	.+2      	; 0x12ae <pvPortMalloc+0x56>
    12ac:	5f c0       	rjmp	.+190    	; 0x136c <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12ae:	9e 01       	movw	r18, r28
    12b0:	2b 5f       	subi	r18, 0xFB	; 251
    12b2:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    12b4:	24 96       	adiw	r28, 0x04	; 4
    12b6:	ce 3f       	cpi	r28, 0xFE	; 254
    12b8:	df 40       	sbci	r29, 0x0F	; 15
    12ba:	08 f0       	brcs	.+2      	; 0x12be <pvPortMalloc+0x66>
    12bc:	5a c0       	rjmp	.+180    	; 0x1372 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    12be:	e0 91 cd 20 	lds	r30, 0x20CD	; 0x8020cd <xStart>
    12c2:	f0 91 ce 20 	lds	r31, 0x20CE	; 0x8020ce <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    12c6:	ad ec       	ldi	r26, 0xCD	; 205
    12c8:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12ca:	02 c0       	rjmp	.+4      	; 0x12d0 <pvPortMalloc+0x78>
    12cc:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    12ce:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12d0:	82 81       	ldd	r24, Z+2	; 0x02
    12d2:	93 81       	ldd	r25, Z+3	; 0x03
    12d4:	82 17       	cp	r24, r18
    12d6:	93 07       	cpc	r25, r19
    12d8:	20 f4       	brcc	.+8      	; 0x12e2 <pvPortMalloc+0x8a>
    12da:	80 81       	ld	r24, Z
    12dc:	91 81       	ldd	r25, Z+1	; 0x01
    12de:	00 97       	sbiw	r24, 0x00	; 0
    12e0:	a9 f7       	brne	.-22     	; 0x12cc <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    12e2:	c0 e2       	ldi	r28, 0x20	; 32
    12e4:	e9 3c       	cpi	r30, 0xC9	; 201
    12e6:	fc 07       	cpc	r31, r28
    12e8:	09 f4       	brne	.+2      	; 0x12ec <pvPortMalloc+0x94>
    12ea:	46 c0       	rjmp	.+140    	; 0x1378 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    12ec:	cd 91       	ld	r28, X+
    12ee:	dc 91       	ld	r29, X
    12f0:	11 97       	sbiw	r26, 0x01	; 1
    12f2:	8e 01       	movw	r16, r28
    12f4:	0b 5f       	subi	r16, 0xFB	; 251
    12f6:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    12f8:	80 81       	ld	r24, Z
    12fa:	91 81       	ldd	r25, Z+1	; 0x01
    12fc:	8d 93       	st	X+, r24
    12fe:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1300:	82 81       	ldd	r24, Z+2	; 0x02
    1302:	93 81       	ldd	r25, Z+3	; 0x03
    1304:	82 1b       	sub	r24, r18
    1306:	93 0b       	sbc	r25, r19
    1308:	8b 30       	cpi	r24, 0x0B	; 11
    130a:	91 05       	cpc	r25, r1
    130c:	10 f1       	brcs	.+68     	; 0x1352 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    130e:	bf 01       	movw	r22, r30
    1310:	62 0f       	add	r22, r18
    1312:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1314:	db 01       	movw	r26, r22
    1316:	12 96       	adiw	r26, 0x02	; 2
    1318:	8d 93       	st	X+, r24
    131a:	9c 93       	st	X, r25
    131c:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    131e:	22 83       	std	Z+2, r18	; 0x02
    1320:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1322:	12 96       	adiw	r26, 0x02	; 2
    1324:	4d 91       	ld	r20, X+
    1326:	5c 91       	ld	r21, X
    1328:	13 97       	sbiw	r26, 0x03	; 3
    132a:	8d ec       	ldi	r24, 0xCD	; 205
    132c:	90 e2       	ldi	r25, 0x20	; 32
    132e:	01 c0       	rjmp	.+2      	; 0x1332 <pvPortMalloc+0xda>
    1330:	cd 01       	movw	r24, r26
    1332:	ec 01       	movw	r28, r24
    1334:	a8 81       	ld	r26, Y
    1336:	b9 81       	ldd	r27, Y+1	; 0x01
    1338:	12 96       	adiw	r26, 0x02	; 2
    133a:	2d 91       	ld	r18, X+
    133c:	3c 91       	ld	r19, X
    133e:	13 97       	sbiw	r26, 0x03	; 3
    1340:	24 17       	cp	r18, r20
    1342:	35 07       	cpc	r19, r21
    1344:	a8 f3       	brcs	.-22     	; 0x1330 <pvPortMalloc+0xd8>
    1346:	eb 01       	movw	r28, r22
    1348:	a8 83       	st	Y, r26
    134a:	b9 83       	std	Y+1, r27	; 0x01
    134c:	dc 01       	movw	r26, r24
    134e:	6d 93       	st	X+, r22
    1350:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1352:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1356:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    135a:	22 81       	ldd	r18, Z+2	; 0x02
    135c:	33 81       	ldd	r19, Z+3	; 0x03
    135e:	82 1b       	sub	r24, r18
    1360:	93 0b       	sbc	r25, r19
    1362:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1366:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    136a:	08 c0       	rjmp	.+16     	; 0x137c <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    136c:	00 e0       	ldi	r16, 0x00	; 0
    136e:	10 e0       	ldi	r17, 0x00	; 0
    1370:	05 c0       	rjmp	.+10     	; 0x137c <pvPortMalloc+0x124>
    1372:	00 e0       	ldi	r16, 0x00	; 0
    1374:	10 e0       	ldi	r17, 0x00	; 0
    1376:	02 c0       	rjmp	.+4      	; 0x137c <pvPortMalloc+0x124>
    1378:	00 e0       	ldi	r16, 0x00	; 0
    137a:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    137c:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1380:	c8 01       	movw	r24, r16
    1382:	df 91       	pop	r29
    1384:	cf 91       	pop	r28
    1386:	1f 91       	pop	r17
    1388:	0f 91       	pop	r16
    138a:	08 95       	ret

0000138c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    138c:	0f 93       	push	r16
    138e:	1f 93       	push	r17
    1390:	cf 93       	push	r28
    1392:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1394:	00 97       	sbiw	r24, 0x00	; 0
    1396:	41 f1       	breq	.+80     	; 0x13e8 <vPortFree+0x5c>
    1398:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    139a:	8c 01       	movw	r16, r24
    139c:	05 50       	subi	r16, 0x05	; 5
    139e:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    13a0:	0e 94 42 10 	call	0x2084	; 0x2084 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    13a4:	f8 01       	movw	r30, r16
    13a6:	42 81       	ldd	r20, Z+2	; 0x02
    13a8:	53 81       	ldd	r21, Z+3	; 0x03
    13aa:	ad ec       	ldi	r26, 0xCD	; 205
    13ac:	b0 e2       	ldi	r27, 0x20	; 32
    13ae:	01 c0       	rjmp	.+2      	; 0x13b2 <vPortFree+0x26>
    13b0:	df 01       	movw	r26, r30
    13b2:	ed 91       	ld	r30, X+
    13b4:	fc 91       	ld	r31, X
    13b6:	11 97       	sbiw	r26, 0x01	; 1
    13b8:	22 81       	ldd	r18, Z+2	; 0x02
    13ba:	33 81       	ldd	r19, Z+3	; 0x03
    13bc:	24 17       	cp	r18, r20
    13be:	35 07       	cpc	r19, r21
    13c0:	b8 f3       	brcs	.-18     	; 0x13b0 <vPortFree+0x24>
    13c2:	25 97       	sbiw	r28, 0x05	; 5
    13c4:	e8 83       	st	Y, r30
    13c6:	f9 83       	std	Y+1, r31	; 0x01
    13c8:	0d 93       	st	X+, r16
    13ca:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    13cc:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    13d0:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    13d4:	8a 81       	ldd	r24, Y+2	; 0x02
    13d6:	9b 81       	ldd	r25, Y+3	; 0x03
    13d8:	82 0f       	add	r24, r18
    13da:	93 1f       	adc	r25, r19
    13dc:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    13e0:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    13e4:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
	}
}
    13e8:	df 91       	pop	r29
    13ea:	cf 91       	pop	r28
    13ec:	1f 91       	pop	r17
    13ee:	0f 91       	pop	r16
    13f0:	08 95       	ret

000013f2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    13f2:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    13f6:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    13fa:	08 95       	ret

000013fc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    13fc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    13fe:	03 96       	adiw	r24, 0x03	; 3
    1400:	81 83       	std	Z+1, r24	; 0x01
    1402:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1404:	4f ef       	ldi	r20, 0xFF	; 255
    1406:	5f ef       	ldi	r21, 0xFF	; 255
    1408:	ba 01       	movw	r22, r20
    140a:	43 83       	std	Z+3, r20	; 0x03
    140c:	54 83       	std	Z+4, r21	; 0x04
    140e:	65 83       	std	Z+5, r22	; 0x05
    1410:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1412:	87 83       	std	Z+7, r24	; 0x07
    1414:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1416:	81 87       	std	Z+9, r24	; 0x09
    1418:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    141a:	10 82       	st	Z, r1
    141c:	08 95       	ret

0000141e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    141e:	fc 01       	movw	r30, r24
    1420:	12 86       	std	Z+10, r1	; 0x0a
    1422:	13 86       	std	Z+11, r1	; 0x0b
    1424:	08 95       	ret

00001426 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1426:	cf 93       	push	r28
    1428:	df 93       	push	r29
    142a:	fc 01       	movw	r30, r24
    142c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    142e:	21 81       	ldd	r18, Z+1	; 0x01
    1430:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1432:	e9 01       	movw	r28, r18
    1434:	8c 81       	ldd	r24, Y+4	; 0x04
    1436:	9d 81       	ldd	r25, Y+5	; 0x05
    1438:	14 96       	adiw	r26, 0x04	; 4
    143a:	8d 93       	st	X+, r24
    143c:	9c 93       	st	X, r25
    143e:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1440:	81 81       	ldd	r24, Z+1	; 0x01
    1442:	92 81       	ldd	r25, Z+2	; 0x02
    1444:	16 96       	adiw	r26, 0x06	; 6
    1446:	8d 93       	st	X+, r24
    1448:	9c 93       	st	X, r25
    144a:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    144c:	8c 81       	ldd	r24, Y+4	; 0x04
    144e:	9d 81       	ldd	r25, Y+5	; 0x05
    1450:	ec 01       	movw	r28, r24
    1452:	6e 83       	std	Y+6, r22	; 0x06
    1454:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1456:	e9 01       	movw	r28, r18
    1458:	6c 83       	std	Y+4, r22	; 0x04
    145a:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    145c:	61 83       	std	Z+1, r22	; 0x01
    145e:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1460:	1a 96       	adiw	r26, 0x0a	; 10
    1462:	ed 93       	st	X+, r30
    1464:	fc 93       	st	X, r31
    1466:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1468:	80 81       	ld	r24, Z
    146a:	8f 5f       	subi	r24, 0xFF	; 255
    146c:	80 83       	st	Z, r24
}
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	08 95       	ret

00001474 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1474:	0f 93       	push	r16
    1476:	1f 93       	push	r17
    1478:	cf 93       	push	r28
    147a:	df 93       	push	r29
    147c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    147e:	08 81       	ld	r16, Y
    1480:	19 81       	ldd	r17, Y+1	; 0x01
    1482:	2a 81       	ldd	r18, Y+2	; 0x02
    1484:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1486:	0f 3f       	cpi	r16, 0xFF	; 255
    1488:	4f ef       	ldi	r20, 0xFF	; 255
    148a:	14 07       	cpc	r17, r20
    148c:	24 07       	cpc	r18, r20
    148e:	34 07       	cpc	r19, r20
    1490:	31 f4       	brne	.+12     	; 0x149e <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1492:	dc 01       	movw	r26, r24
    1494:	19 96       	adiw	r26, 0x09	; 9
    1496:	ed 91       	ld	r30, X+
    1498:	fc 91       	ld	r31, X
    149a:	1a 97       	sbiw	r26, 0x0a	; 10
    149c:	1f c0       	rjmp	.+62     	; 0x14dc <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    149e:	fc 01       	movw	r30, r24
    14a0:	33 96       	adiw	r30, 0x03	; 3
    14a2:	dc 01       	movw	r26, r24
    14a4:	17 96       	adiw	r26, 0x07	; 7
    14a6:	4d 91       	ld	r20, X+
    14a8:	5c 91       	ld	r21, X
    14aa:	18 97       	sbiw	r26, 0x08	; 8
    14ac:	da 01       	movw	r26, r20
    14ae:	4d 91       	ld	r20, X+
    14b0:	5d 91       	ld	r21, X+
    14b2:	6d 91       	ld	r22, X+
    14b4:	7c 91       	ld	r23, X
    14b6:	04 17       	cp	r16, r20
    14b8:	15 07       	cpc	r17, r21
    14ba:	26 07       	cpc	r18, r22
    14bc:	37 07       	cpc	r19, r23
    14be:	70 f0       	brcs	.+28     	; 0x14dc <vListInsert+0x68>
    14c0:	04 80       	ldd	r0, Z+4	; 0x04
    14c2:	f5 81       	ldd	r31, Z+5	; 0x05
    14c4:	e0 2d       	mov	r30, r0
    14c6:	a4 81       	ldd	r26, Z+4	; 0x04
    14c8:	b5 81       	ldd	r27, Z+5	; 0x05
    14ca:	4d 91       	ld	r20, X+
    14cc:	5d 91       	ld	r21, X+
    14ce:	6d 91       	ld	r22, X+
    14d0:	7c 91       	ld	r23, X
    14d2:	04 17       	cp	r16, r20
    14d4:	15 07       	cpc	r17, r21
    14d6:	26 07       	cpc	r18, r22
    14d8:	37 07       	cpc	r19, r23
    14da:	90 f7       	brcc	.-28     	; 0x14c0 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    14dc:	a4 81       	ldd	r26, Z+4	; 0x04
    14de:	b5 81       	ldd	r27, Z+5	; 0x05
    14e0:	ac 83       	std	Y+4, r26	; 0x04
    14e2:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    14e4:	16 96       	adiw	r26, 0x06	; 6
    14e6:	cd 93       	st	X+, r28
    14e8:	dc 93       	st	X, r29
    14ea:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    14ec:	ee 83       	std	Y+6, r30	; 0x06
    14ee:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    14f0:	c4 83       	std	Z+4, r28	; 0x04
    14f2:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14f4:	8a 87       	std	Y+10, r24	; 0x0a
    14f6:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    14f8:	fc 01       	movw	r30, r24
    14fa:	20 81       	ld	r18, Z
    14fc:	2f 5f       	subi	r18, 0xFF	; 255
    14fe:	20 83       	st	Z, r18
}
    1500:	df 91       	pop	r29
    1502:	cf 91       	pop	r28
    1504:	1f 91       	pop	r17
    1506:	0f 91       	pop	r16
    1508:	08 95       	ret

0000150a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    150a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    150c:	a4 81       	ldd	r26, Z+4	; 0x04
    150e:	b5 81       	ldd	r27, Z+5	; 0x05
    1510:	86 81       	ldd	r24, Z+6	; 0x06
    1512:	97 81       	ldd	r25, Z+7	; 0x07
    1514:	16 96       	adiw	r26, 0x06	; 6
    1516:	8d 93       	st	X+, r24
    1518:	9c 93       	st	X, r25
    151a:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    151c:	a6 81       	ldd	r26, Z+6	; 0x06
    151e:	b7 81       	ldd	r27, Z+7	; 0x07
    1520:	84 81       	ldd	r24, Z+4	; 0x04
    1522:	95 81       	ldd	r25, Z+5	; 0x05
    1524:	14 96       	adiw	r26, 0x04	; 4
    1526:	8d 93       	st	X+, r24
    1528:	9c 93       	st	X, r25
    152a:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    152c:	a2 85       	ldd	r26, Z+10	; 0x0a
    152e:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1530:	11 96       	adiw	r26, 0x01	; 1
    1532:	8d 91       	ld	r24, X+
    1534:	9c 91       	ld	r25, X
    1536:	12 97       	sbiw	r26, 0x02	; 2
    1538:	e8 17       	cp	r30, r24
    153a:	f9 07       	cpc	r31, r25
    153c:	31 f4       	brne	.+12     	; 0x154a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    153e:	86 81       	ldd	r24, Z+6	; 0x06
    1540:	97 81       	ldd	r25, Z+7	; 0x07
    1542:	11 96       	adiw	r26, 0x01	; 1
    1544:	8d 93       	st	X+, r24
    1546:	9c 93       	st	X, r25
    1548:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    154a:	12 86       	std	Z+10, r1	; 0x0a
    154c:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    154e:	8c 91       	ld	r24, X
    1550:	81 50       	subi	r24, 0x01	; 1
    1552:	8c 93       	st	X, r24
    1554:	08 95       	ret

00001556 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1556:	80 93 74 31 	sts	0x3174, r24	; 0x803174 <portStackTopForTask>
    155a:	90 93 75 31 	sts	0x3175, r25	; 0x803175 <portStackTopForTask+0x1>
    155e:	31 e1       	ldi	r19, 0x11	; 17
    1560:	fc 01       	movw	r30, r24
    1562:	30 83       	st	Z, r19
    1564:	31 97       	sbiw	r30, 0x01	; 1
    1566:	22 e2       	ldi	r18, 0x22	; 34
    1568:	20 83       	st	Z, r18
    156a:	31 97       	sbiw	r30, 0x01	; 1
    156c:	a3 e3       	ldi	r26, 0x33	; 51
    156e:	a0 83       	st	Z, r26
    1570:	31 97       	sbiw	r30, 0x01	; 1
    1572:	60 83       	st	Z, r22
    1574:	31 97       	sbiw	r30, 0x01	; 1
    1576:	70 83       	st	Z, r23
    1578:	31 97       	sbiw	r30, 0x01	; 1
    157a:	10 82       	st	Z, r1
    157c:	31 97       	sbiw	r30, 0x01	; 1
    157e:	10 82       	st	Z, r1
    1580:	31 97       	sbiw	r30, 0x01	; 1
    1582:	60 e8       	ldi	r22, 0x80	; 128
    1584:	60 83       	st	Z, r22
    1586:	31 97       	sbiw	r30, 0x01	; 1
    1588:	10 82       	st	Z, r1
    158a:	31 97       	sbiw	r30, 0x01	; 1
    158c:	10 82       	st	Z, r1
    158e:	31 97       	sbiw	r30, 0x01	; 1
    1590:	10 82       	st	Z, r1
    1592:	31 97       	sbiw	r30, 0x01	; 1
    1594:	62 e0       	ldi	r22, 0x02	; 2
    1596:	60 83       	st	Z, r22
    1598:	31 97       	sbiw	r30, 0x01	; 1
    159a:	63 e0       	ldi	r22, 0x03	; 3
    159c:	60 83       	st	Z, r22
    159e:	31 97       	sbiw	r30, 0x01	; 1
    15a0:	64 e0       	ldi	r22, 0x04	; 4
    15a2:	60 83       	st	Z, r22
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	65 e0       	ldi	r22, 0x05	; 5
    15a8:	60 83       	st	Z, r22
    15aa:	31 97       	sbiw	r30, 0x01	; 1
    15ac:	66 e0       	ldi	r22, 0x06	; 6
    15ae:	60 83       	st	Z, r22
    15b0:	31 97       	sbiw	r30, 0x01	; 1
    15b2:	67 e0       	ldi	r22, 0x07	; 7
    15b4:	60 83       	st	Z, r22
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	68 e0       	ldi	r22, 0x08	; 8
    15ba:	60 83       	st	Z, r22
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	69 e0       	ldi	r22, 0x09	; 9
    15c0:	60 83       	st	Z, r22
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	60 e1       	ldi	r22, 0x10	; 16
    15c6:	60 83       	st	Z, r22
    15c8:	31 97       	sbiw	r30, 0x01	; 1
    15ca:	30 83       	st	Z, r19
    15cc:	31 97       	sbiw	r30, 0x01	; 1
    15ce:	32 e1       	ldi	r19, 0x12	; 18
    15d0:	30 83       	st	Z, r19
    15d2:	31 97       	sbiw	r30, 0x01	; 1
    15d4:	33 e1       	ldi	r19, 0x13	; 19
    15d6:	30 83       	st	Z, r19
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	34 e1       	ldi	r19, 0x14	; 20
    15dc:	30 83       	st	Z, r19
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	35 e1       	ldi	r19, 0x15	; 21
    15e2:	30 83       	st	Z, r19
    15e4:	31 97       	sbiw	r30, 0x01	; 1
    15e6:	36 e1       	ldi	r19, 0x16	; 22
    15e8:	30 83       	st	Z, r19
    15ea:	31 97       	sbiw	r30, 0x01	; 1
    15ec:	37 e1       	ldi	r19, 0x17	; 23
    15ee:	30 83       	st	Z, r19
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	38 e1       	ldi	r19, 0x18	; 24
    15f4:	30 83       	st	Z, r19
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	39 e1       	ldi	r19, 0x19	; 25
    15fa:	30 83       	st	Z, r19
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	30 e2       	ldi	r19, 0x20	; 32
    1600:	30 83       	st	Z, r19
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	31 e2       	ldi	r19, 0x21	; 33
    1606:	30 83       	st	Z, r19
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	20 83       	st	Z, r18
    160c:	31 97       	sbiw	r30, 0x01	; 1
    160e:	23 e2       	ldi	r18, 0x23	; 35
    1610:	20 83       	st	Z, r18
    1612:	31 97       	sbiw	r30, 0x01	; 1
    1614:	40 83       	st	Z, r20
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	50 83       	st	Z, r21
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	26 e2       	ldi	r18, 0x26	; 38
    161e:	20 83       	st	Z, r18
    1620:	31 97       	sbiw	r30, 0x01	; 1
    1622:	27 e2       	ldi	r18, 0x27	; 39
    1624:	20 83       	st	Z, r18
    1626:	31 97       	sbiw	r30, 0x01	; 1
    1628:	28 e2       	ldi	r18, 0x28	; 40
    162a:	20 83       	st	Z, r18
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	29 e2       	ldi	r18, 0x29	; 41
    1630:	20 83       	st	Z, r18
    1632:	31 97       	sbiw	r30, 0x01	; 1
    1634:	20 e3       	ldi	r18, 0x30	; 48
    1636:	20 83       	st	Z, r18
    1638:	31 97       	sbiw	r30, 0x01	; 1
    163a:	21 e3       	ldi	r18, 0x31	; 49
    163c:	20 83       	st	Z, r18
    163e:	89 97       	sbiw	r24, 0x29	; 41
    1640:	08 95       	ret

00001642 <xPortStartScheduler>:
    1642:	8c e7       	ldi	r24, 0x7C	; 124
    1644:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
    1648:	8f ef       	ldi	r24, 0xFF	; 255
    164a:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
    164e:	81 e0       	ldi	r24, 0x01	; 1
    1650:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    1654:	81 e1       	ldi	r24, 0x11	; 17
    1656:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    165a:	83 e0       	ldi	r24, 0x03	; 3
    165c:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
    1660:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1664:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1668:	cd 91       	ld	r28, X+
    166a:	cd bf       	out	0x3d, r28	; 61
    166c:	dd 91       	ld	r29, X+
    166e:	de bf       	out	0x3e, r29	; 62
    1670:	ff 91       	pop	r31
    1672:	ef 91       	pop	r30
    1674:	df 91       	pop	r29
    1676:	cf 91       	pop	r28
    1678:	bf 91       	pop	r27
    167a:	af 91       	pop	r26
    167c:	9f 91       	pop	r25
    167e:	8f 91       	pop	r24
    1680:	7f 91       	pop	r23
    1682:	6f 91       	pop	r22
    1684:	5f 91       	pop	r21
    1686:	4f 91       	pop	r20
    1688:	3f 91       	pop	r19
    168a:	2f 91       	pop	r18
    168c:	1f 91       	pop	r17
    168e:	0f 91       	pop	r16
    1690:	ff 90       	pop	r15
    1692:	ef 90       	pop	r14
    1694:	df 90       	pop	r13
    1696:	cf 90       	pop	r12
    1698:	bf 90       	pop	r11
    169a:	af 90       	pop	r10
    169c:	9f 90       	pop	r9
    169e:	8f 90       	pop	r8
    16a0:	7f 90       	pop	r7
    16a2:	6f 90       	pop	r6
    16a4:	5f 90       	pop	r5
    16a6:	4f 90       	pop	r4
    16a8:	3f 90       	pop	r3
    16aa:	2f 90       	pop	r2
    16ac:	1f 90       	pop	r1
    16ae:	0f 90       	pop	r0
    16b0:	0c be       	out	0x3c, r0	; 60
    16b2:	0f 90       	pop	r0
    16b4:	0b be       	out	0x3b, r0	; 59
    16b6:	0f 90       	pop	r0
    16b8:	0f be       	out	0x3f, r0	; 63
    16ba:	0f 90       	pop	r0
    16bc:	08 95       	ret
    16be:	81 e0       	ldi	r24, 0x01	; 1
    16c0:	08 95       	ret

000016c2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16c2:	0f 92       	push	r0
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	f8 94       	cli
    16c8:	0f 92       	push	r0
    16ca:	0b b6       	in	r0, 0x3b	; 59
    16cc:	0f 92       	push	r0
    16ce:	0c b6       	in	r0, 0x3c	; 60
    16d0:	0f 92       	push	r0
    16d2:	1f 92       	push	r1
    16d4:	11 24       	eor	r1, r1
    16d6:	2f 92       	push	r2
    16d8:	3f 92       	push	r3
    16da:	4f 92       	push	r4
    16dc:	5f 92       	push	r5
    16de:	6f 92       	push	r6
    16e0:	7f 92       	push	r7
    16e2:	8f 92       	push	r8
    16e4:	9f 92       	push	r9
    16e6:	af 92       	push	r10
    16e8:	bf 92       	push	r11
    16ea:	cf 92       	push	r12
    16ec:	df 92       	push	r13
    16ee:	ef 92       	push	r14
    16f0:	ff 92       	push	r15
    16f2:	0f 93       	push	r16
    16f4:	1f 93       	push	r17
    16f6:	2f 93       	push	r18
    16f8:	3f 93       	push	r19
    16fa:	4f 93       	push	r20
    16fc:	5f 93       	push	r21
    16fe:	6f 93       	push	r22
    1700:	7f 93       	push	r23
    1702:	8f 93       	push	r24
    1704:	9f 93       	push	r25
    1706:	af 93       	push	r26
    1708:	bf 93       	push	r27
    170a:	cf 93       	push	r28
    170c:	df 93       	push	r29
    170e:	ef 93       	push	r30
    1710:	ff 93       	push	r31
    1712:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1716:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    171a:	0d b6       	in	r0, 0x3d	; 61
    171c:	0d 92       	st	X+, r0
    171e:	0e b6       	in	r0, 0x3e	; 62
    1720:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1722:	0e 94 81 12 	call	0x2502	; 0x2502 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1726:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    172a:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    172e:	cd 91       	ld	r28, X+
    1730:	cd bf       	out	0x3d, r28	; 61
    1732:	dd 91       	ld	r29, X+
    1734:	de bf       	out	0x3e, r29	; 62
    1736:	ff 91       	pop	r31
    1738:	ef 91       	pop	r30
    173a:	df 91       	pop	r29
    173c:	cf 91       	pop	r28
    173e:	bf 91       	pop	r27
    1740:	af 91       	pop	r26
    1742:	9f 91       	pop	r25
    1744:	8f 91       	pop	r24
    1746:	7f 91       	pop	r23
    1748:	6f 91       	pop	r22
    174a:	5f 91       	pop	r21
    174c:	4f 91       	pop	r20
    174e:	3f 91       	pop	r19
    1750:	2f 91       	pop	r18
    1752:	1f 91       	pop	r17
    1754:	0f 91       	pop	r16
    1756:	ff 90       	pop	r15
    1758:	ef 90       	pop	r14
    175a:	df 90       	pop	r13
    175c:	cf 90       	pop	r12
    175e:	bf 90       	pop	r11
    1760:	af 90       	pop	r10
    1762:	9f 90       	pop	r9
    1764:	8f 90       	pop	r8
    1766:	7f 90       	pop	r7
    1768:	6f 90       	pop	r6
    176a:	5f 90       	pop	r5
    176c:	4f 90       	pop	r4
    176e:	3f 90       	pop	r3
    1770:	2f 90       	pop	r2
    1772:	1f 90       	pop	r1
    1774:	0f 90       	pop	r0
    1776:	0c be       	out	0x3c, r0	; 60
    1778:	0f 90       	pop	r0
    177a:	0b be       	out	0x3b, r0	; 59
    177c:	0f 90       	pop	r0
    177e:	0f be       	out	0x3f, r0	; 63
    1780:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1782:	08 95       	ret

00001784 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1784:	0f 92       	push	r0
    1786:	0f b6       	in	r0, 0x3f	; 63
    1788:	f8 94       	cli
    178a:	0f 92       	push	r0
    178c:	0b b6       	in	r0, 0x3b	; 59
    178e:	0f 92       	push	r0
    1790:	0c b6       	in	r0, 0x3c	; 60
    1792:	0f 92       	push	r0
    1794:	1f 92       	push	r1
    1796:	11 24       	eor	r1, r1
    1798:	2f 92       	push	r2
    179a:	3f 92       	push	r3
    179c:	4f 92       	push	r4
    179e:	5f 92       	push	r5
    17a0:	6f 92       	push	r6
    17a2:	7f 92       	push	r7
    17a4:	8f 92       	push	r8
    17a6:	9f 92       	push	r9
    17a8:	af 92       	push	r10
    17aa:	bf 92       	push	r11
    17ac:	cf 92       	push	r12
    17ae:	df 92       	push	r13
    17b0:	ef 92       	push	r14
    17b2:	ff 92       	push	r15
    17b4:	0f 93       	push	r16
    17b6:	1f 93       	push	r17
    17b8:	2f 93       	push	r18
    17ba:	3f 93       	push	r19
    17bc:	4f 93       	push	r20
    17be:	5f 93       	push	r21
    17c0:	6f 93       	push	r22
    17c2:	7f 93       	push	r23
    17c4:	8f 93       	push	r24
    17c6:	9f 93       	push	r25
    17c8:	af 93       	push	r26
    17ca:	bf 93       	push	r27
    17cc:	cf 93       	push	r28
    17ce:	df 93       	push	r29
    17d0:	ef 93       	push	r30
    17d2:	ff 93       	push	r31
    17d4:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    17d8:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    17dc:	0d b6       	in	r0, 0x3d	; 61
    17de:	0d 92       	st	X+, r0
    17e0:	0e b6       	in	r0, 0x3e	; 62
    17e2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    17e4:	0e 94 63 10 	call	0x20c6	; 0x20c6 <vTaskIncrementTick>
	vTaskSwitchContext();
    17e8:	0e 94 81 12 	call	0x2502	; 0x2502 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17ec:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    17f0:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    17f4:	cd 91       	ld	r28, X+
    17f6:	cd bf       	out	0x3d, r28	; 61
    17f8:	dd 91       	ld	r29, X+
    17fa:	de bf       	out	0x3e, r29	; 62
    17fc:	ff 91       	pop	r31
    17fe:	ef 91       	pop	r30
    1800:	df 91       	pop	r29
    1802:	cf 91       	pop	r28
    1804:	bf 91       	pop	r27
    1806:	af 91       	pop	r26
    1808:	9f 91       	pop	r25
    180a:	8f 91       	pop	r24
    180c:	7f 91       	pop	r23
    180e:	6f 91       	pop	r22
    1810:	5f 91       	pop	r21
    1812:	4f 91       	pop	r20
    1814:	3f 91       	pop	r19
    1816:	2f 91       	pop	r18
    1818:	1f 91       	pop	r17
    181a:	0f 91       	pop	r16
    181c:	ff 90       	pop	r15
    181e:	ef 90       	pop	r14
    1820:	df 90       	pop	r13
    1822:	cf 90       	pop	r12
    1824:	bf 90       	pop	r11
    1826:	af 90       	pop	r10
    1828:	9f 90       	pop	r9
    182a:	8f 90       	pop	r8
    182c:	7f 90       	pop	r7
    182e:	6f 90       	pop	r6
    1830:	5f 90       	pop	r5
    1832:	4f 90       	pop	r4
    1834:	3f 90       	pop	r3
    1836:	2f 90       	pop	r2
    1838:	1f 90       	pop	r1
    183a:	0f 90       	pop	r0
    183c:	0c be       	out	0x3c, r0	; 60
    183e:	0f 90       	pop	r0
    1840:	0b be       	out	0x3b, r0	; 59
    1842:	0f 90       	pop	r0
    1844:	0f be       	out	0x3f, r0	; 63
    1846:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1848:	08 95       	ret

0000184a <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    184a:	0e 94 c2 0b 	call	0x1784	; 0x1784 <vPortYieldFromTick>
		asm volatile ( "reti" );
    184e:	18 95       	reti

00001850 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1850:	cf 93       	push	r28
    1852:	df 93       	push	r29
    1854:	ec 01       	movw	r28, r24
    1856:	88 a1       	ldd	r24, Y+32	; 0x20
    1858:	81 11       	cpse	r24, r1
    185a:	0b c0       	rjmp	.+22     	; 0x1872 <prvCopyDataToQueue+0x22>
    185c:	88 81       	ld	r24, Y
    185e:	99 81       	ldd	r25, Y+1	; 0x01
    1860:	89 2b       	or	r24, r25
    1862:	e1 f5       	brne	.+120    	; 0x18dc <prvCopyDataToQueue+0x8c>
    1864:	8a 81       	ldd	r24, Y+2	; 0x02
    1866:	9b 81       	ldd	r25, Y+3	; 0x03
    1868:	0e 94 3c 14 	call	0x2878	; 0x2878 <vTaskPriorityDisinherit>
    186c:	1a 82       	std	Y+2, r1	; 0x02
    186e:	1b 82       	std	Y+3, r1	; 0x03
    1870:	35 c0       	rjmp	.+106    	; 0x18dc <prvCopyDataToQueue+0x8c>
    1872:	41 11       	cpse	r20, r1
    1874:	17 c0       	rjmp	.+46     	; 0x18a4 <prvCopyDataToQueue+0x54>
    1876:	48 2f       	mov	r20, r24
    1878:	50 e0       	ldi	r21, 0x00	; 0
    187a:	8c 81       	ldd	r24, Y+4	; 0x04
    187c:	9d 81       	ldd	r25, Y+5	; 0x05
    187e:	0e 94 58 22 	call	0x44b0	; 0x44b0 <memcpy>
    1882:	28 a1       	ldd	r18, Y+32	; 0x20
    1884:	8c 81       	ldd	r24, Y+4	; 0x04
    1886:	9d 81       	ldd	r25, Y+5	; 0x05
    1888:	82 0f       	add	r24, r18
    188a:	91 1d       	adc	r25, r1
    188c:	8c 83       	std	Y+4, r24	; 0x04
    188e:	9d 83       	std	Y+5, r25	; 0x05
    1890:	2a 81       	ldd	r18, Y+2	; 0x02
    1892:	3b 81       	ldd	r19, Y+3	; 0x03
    1894:	82 17       	cp	r24, r18
    1896:	93 07       	cpc	r25, r19
    1898:	08 f1       	brcs	.+66     	; 0x18dc <prvCopyDataToQueue+0x8c>
    189a:	88 81       	ld	r24, Y
    189c:	99 81       	ldd	r25, Y+1	; 0x01
    189e:	8c 83       	std	Y+4, r24	; 0x04
    18a0:	9d 83       	std	Y+5, r25	; 0x05
    18a2:	1c c0       	rjmp	.+56     	; 0x18dc <prvCopyDataToQueue+0x8c>
    18a4:	48 2f       	mov	r20, r24
    18a6:	50 e0       	ldi	r21, 0x00	; 0
    18a8:	8e 81       	ldd	r24, Y+6	; 0x06
    18aa:	9f 81       	ldd	r25, Y+7	; 0x07
    18ac:	0e 94 58 22 	call	0x44b0	; 0x44b0 <memcpy>
    18b0:	88 a1       	ldd	r24, Y+32	; 0x20
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	91 95       	neg	r25
    18b6:	81 95       	neg	r24
    18b8:	91 09       	sbc	r25, r1
    18ba:	2e 81       	ldd	r18, Y+6	; 0x06
    18bc:	3f 81       	ldd	r19, Y+7	; 0x07
    18be:	28 0f       	add	r18, r24
    18c0:	39 1f       	adc	r19, r25
    18c2:	2e 83       	std	Y+6, r18	; 0x06
    18c4:	3f 83       	std	Y+7, r19	; 0x07
    18c6:	48 81       	ld	r20, Y
    18c8:	59 81       	ldd	r21, Y+1	; 0x01
    18ca:	24 17       	cp	r18, r20
    18cc:	35 07       	cpc	r19, r21
    18ce:	30 f4       	brcc	.+12     	; 0x18dc <prvCopyDataToQueue+0x8c>
    18d0:	2a 81       	ldd	r18, Y+2	; 0x02
    18d2:	3b 81       	ldd	r19, Y+3	; 0x03
    18d4:	82 0f       	add	r24, r18
    18d6:	93 1f       	adc	r25, r19
    18d8:	8e 83       	std	Y+6, r24	; 0x06
    18da:	9f 83       	std	Y+7, r25	; 0x07
    18dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18de:	8f 5f       	subi	r24, 0xFF	; 255
    18e0:	8e 8f       	std	Y+30, r24	; 0x1e
    18e2:	df 91       	pop	r29
    18e4:	cf 91       	pop	r28
    18e6:	08 95       	ret

000018e8 <prvCopyDataFromQueue>:
    18e8:	fc 01       	movw	r30, r24
    18ea:	80 81       	ld	r24, Z
    18ec:	91 81       	ldd	r25, Z+1	; 0x01
    18ee:	00 97       	sbiw	r24, 0x00	; 0
    18f0:	a1 f0       	breq	.+40     	; 0x191a <prvCopyDataFromQueue+0x32>
    18f2:	40 a1       	ldd	r20, Z+32	; 0x20
    18f4:	50 e0       	ldi	r21, 0x00	; 0
    18f6:	26 81       	ldd	r18, Z+6	; 0x06
    18f8:	37 81       	ldd	r19, Z+7	; 0x07
    18fa:	24 0f       	add	r18, r20
    18fc:	35 1f       	adc	r19, r21
    18fe:	26 83       	std	Z+6, r18	; 0x06
    1900:	37 83       	std	Z+7, r19	; 0x07
    1902:	a2 81       	ldd	r26, Z+2	; 0x02
    1904:	b3 81       	ldd	r27, Z+3	; 0x03
    1906:	2a 17       	cp	r18, r26
    1908:	3b 07       	cpc	r19, r27
    190a:	10 f0       	brcs	.+4      	; 0x1910 <prvCopyDataFromQueue+0x28>
    190c:	86 83       	std	Z+6, r24	; 0x06
    190e:	97 83       	std	Z+7, r25	; 0x07
    1910:	cb 01       	movw	r24, r22
    1912:	66 81       	ldd	r22, Z+6	; 0x06
    1914:	77 81       	ldd	r23, Z+7	; 0x07
    1916:	0e 94 58 22 	call	0x44b0	; 0x44b0 <memcpy>
    191a:	08 95       	ret

0000191c <prvUnlockQueue>:
    191c:	0f 93       	push	r16
    191e:	1f 93       	push	r17
    1920:	cf 93       	push	r28
    1922:	df 93       	push	r29
    1924:	ec 01       	movw	r28, r24
    1926:	0f b6       	in	r0, 0x3f	; 63
    1928:	f8 94       	cli
    192a:	0f 92       	push	r0
    192c:	8a a1       	ldd	r24, Y+34	; 0x22
    192e:	18 16       	cp	r1, r24
    1930:	b4 f4       	brge	.+44     	; 0x195e <prvUnlockQueue+0x42>
    1932:	8b 89       	ldd	r24, Y+19	; 0x13
    1934:	81 11       	cpse	r24, r1
    1936:	05 c0       	rjmp	.+10     	; 0x1942 <prvUnlockQueue+0x26>
    1938:	12 c0       	rjmp	.+36     	; 0x195e <prvUnlockQueue+0x42>
    193a:	8b 89       	ldd	r24, Y+19	; 0x13
    193c:	81 11       	cpse	r24, r1
    193e:	04 c0       	rjmp	.+8      	; 0x1948 <prvUnlockQueue+0x2c>
    1940:	0e c0       	rjmp	.+28     	; 0x195e <prvUnlockQueue+0x42>
    1942:	8e 01       	movw	r16, r28
    1944:	0d 5e       	subi	r16, 0xED	; 237
    1946:	1f 4f       	sbci	r17, 0xFF	; 255
    1948:	c8 01       	movw	r24, r16
    194a:	0e 94 08 13 	call	0x2610	; 0x2610 <xTaskRemoveFromEventList>
    194e:	81 11       	cpse	r24, r1
    1950:	0e 94 c5 13 	call	0x278a	; 0x278a <vTaskMissedYield>
    1954:	8a a1       	ldd	r24, Y+34	; 0x22
    1956:	81 50       	subi	r24, 0x01	; 1
    1958:	8a a3       	std	Y+34, r24	; 0x22
    195a:	18 16       	cp	r1, r24
    195c:	74 f3       	brlt	.-36     	; 0x193a <prvUnlockQueue+0x1e>
    195e:	8f ef       	ldi	r24, 0xFF	; 255
    1960:	8a a3       	std	Y+34, r24	; 0x22
    1962:	0f 90       	pop	r0
    1964:	0f be       	out	0x3f, r0	; 63
    1966:	0f b6       	in	r0, 0x3f	; 63
    1968:	f8 94       	cli
    196a:	0f 92       	push	r0
    196c:	89 a1       	ldd	r24, Y+33	; 0x21
    196e:	18 16       	cp	r1, r24
    1970:	b4 f4       	brge	.+44     	; 0x199e <prvUnlockQueue+0x82>
    1972:	88 85       	ldd	r24, Y+8	; 0x08
    1974:	81 11       	cpse	r24, r1
    1976:	05 c0       	rjmp	.+10     	; 0x1982 <prvUnlockQueue+0x66>
    1978:	12 c0       	rjmp	.+36     	; 0x199e <prvUnlockQueue+0x82>
    197a:	88 85       	ldd	r24, Y+8	; 0x08
    197c:	81 11       	cpse	r24, r1
    197e:	04 c0       	rjmp	.+8      	; 0x1988 <prvUnlockQueue+0x6c>
    1980:	0e c0       	rjmp	.+28     	; 0x199e <prvUnlockQueue+0x82>
    1982:	8e 01       	movw	r16, r28
    1984:	08 5f       	subi	r16, 0xF8	; 248
    1986:	1f 4f       	sbci	r17, 0xFF	; 255
    1988:	c8 01       	movw	r24, r16
    198a:	0e 94 08 13 	call	0x2610	; 0x2610 <xTaskRemoveFromEventList>
    198e:	81 11       	cpse	r24, r1
    1990:	0e 94 c5 13 	call	0x278a	; 0x278a <vTaskMissedYield>
    1994:	89 a1       	ldd	r24, Y+33	; 0x21
    1996:	81 50       	subi	r24, 0x01	; 1
    1998:	89 a3       	std	Y+33, r24	; 0x21
    199a:	18 16       	cp	r1, r24
    199c:	74 f3       	brlt	.-36     	; 0x197a <prvUnlockQueue+0x5e>
    199e:	8f ef       	ldi	r24, 0xFF	; 255
    19a0:	89 a3       	std	Y+33, r24	; 0x21
    19a2:	0f 90       	pop	r0
    19a4:	0f be       	out	0x3f, r0	; 63
    19a6:	df 91       	pop	r29
    19a8:	cf 91       	pop	r28
    19aa:	1f 91       	pop	r17
    19ac:	0f 91       	pop	r16
    19ae:	08 95       	ret

000019b0 <xQueueGenericReset>:
    19b0:	1f 93       	push	r17
    19b2:	cf 93       	push	r28
    19b4:	df 93       	push	r29
    19b6:	61 30       	cpi	r22, 0x01	; 1
    19b8:	59 f0       	breq	.+22     	; 0x19d0 <xQueueGenericReset+0x20>
    19ba:	fc 01       	movw	r30, r24
    19bc:	23 89       	ldd	r18, Z+19	; 0x13
    19be:	30 85       	ldd	r19, Z+8	; 0x08
    19c0:	31 11       	cpse	r19, r1
    19c2:	2c c0       	rjmp	.+88     	; 0x1a1c <xQueueGenericReset+0x6c>
    19c4:	11 e0       	ldi	r17, 0x01	; 1
    19c6:	21 11       	cpse	r18, r1
    19c8:	10 e0       	ldi	r17, 0x00	; 0
    19ca:	21 11       	cpse	r18, r1
    19cc:	28 c0       	rjmp	.+80     	; 0x1a1e <xQueueGenericReset+0x6e>
    19ce:	01 c0       	rjmp	.+2      	; 0x19d2 <xQueueGenericReset+0x22>
    19d0:	11 e0       	ldi	r17, 0x01	; 1
    19d2:	ec 01       	movw	r28, r24
    19d4:	48 81       	ld	r20, Y
    19d6:	59 81       	ldd	r21, Y+1	; 0x01
    19d8:	28 a1       	ldd	r18, Y+32	; 0x20
    19da:	30 e0       	ldi	r19, 0x00	; 0
    19dc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    19de:	62 9f       	mul	r22, r18
    19e0:	c0 01       	movw	r24, r0
    19e2:	63 9f       	mul	r22, r19
    19e4:	90 0d       	add	r25, r0
    19e6:	11 24       	eor	r1, r1
    19e8:	ba 01       	movw	r22, r20
    19ea:	68 0f       	add	r22, r24
    19ec:	79 1f       	adc	r23, r25
    19ee:	6a 83       	std	Y+2, r22	; 0x02
    19f0:	7b 83       	std	Y+3, r23	; 0x03
    19f2:	1e 8e       	std	Y+30, r1	; 0x1e
    19f4:	4c 83       	std	Y+4, r20	; 0x04
    19f6:	5d 83       	std	Y+5, r21	; 0x05
    19f8:	82 1b       	sub	r24, r18
    19fa:	93 0b       	sbc	r25, r19
    19fc:	84 0f       	add	r24, r20
    19fe:	95 1f       	adc	r25, r21
    1a00:	8e 83       	std	Y+6, r24	; 0x06
    1a02:	9f 83       	std	Y+7, r25	; 0x07
    1a04:	8f ef       	ldi	r24, 0xFF	; 255
    1a06:	89 a3       	std	Y+33, r24	; 0x21
    1a08:	8a a3       	std	Y+34, r24	; 0x22
    1a0a:	ce 01       	movw	r24, r28
    1a0c:	08 96       	adiw	r24, 0x08	; 8
    1a0e:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1a12:	ce 01       	movw	r24, r28
    1a14:	43 96       	adiw	r24, 0x13	; 19
    1a16:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1a1a:	01 c0       	rjmp	.+2      	; 0x1a1e <xQueueGenericReset+0x6e>
    1a1c:	10 e0       	ldi	r17, 0x00	; 0
    1a1e:	81 2f       	mov	r24, r17
    1a20:	df 91       	pop	r29
    1a22:	cf 91       	pop	r28
    1a24:	1f 91       	pop	r17
    1a26:	08 95       	ret

00001a28 <xQueueGenericCreate>:
    1a28:	0f 93       	push	r16
    1a2a:	1f 93       	push	r17
    1a2c:	cf 93       	push	r28
    1a2e:	df 93       	push	r29
    1a30:	88 23       	and	r24, r24
    1a32:	01 f1       	breq	.+64     	; 0x1a74 <xQueueGenericCreate+0x4c>
    1a34:	06 2f       	mov	r16, r22
    1a36:	18 2f       	mov	r17, r24
    1a38:	83 e2       	ldi	r24, 0x23	; 35
    1a3a:	90 e0       	ldi	r25, 0x00	; 0
    1a3c:	0e 94 2c 09 	call	0x1258	; 0x1258 <pvPortMalloc>
    1a40:	ec 01       	movw	r28, r24
    1a42:	89 2b       	or	r24, r25
    1a44:	c9 f0       	breq	.+50     	; 0x1a78 <xQueueGenericCreate+0x50>
    1a46:	10 9f       	mul	r17, r16
    1a48:	c0 01       	movw	r24, r0
    1a4a:	11 24       	eor	r1, r1
    1a4c:	01 96       	adiw	r24, 0x01	; 1
    1a4e:	0e 94 2c 09 	call	0x1258	; 0x1258 <pvPortMalloc>
    1a52:	88 83       	st	Y, r24
    1a54:	99 83       	std	Y+1, r25	; 0x01
    1a56:	89 2b       	or	r24, r25
    1a58:	39 f0       	breq	.+14     	; 0x1a68 <xQueueGenericCreate+0x40>
    1a5a:	1f 8f       	std	Y+31, r17	; 0x1f
    1a5c:	08 a3       	std	Y+32, r16	; 0x20
    1a5e:	61 e0       	ldi	r22, 0x01	; 1
    1a60:	ce 01       	movw	r24, r28
    1a62:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <xQueueGenericReset>
    1a66:	08 c0       	rjmp	.+16     	; 0x1a78 <xQueueGenericCreate+0x50>
    1a68:	ce 01       	movw	r24, r28
    1a6a:	0e 94 c6 09 	call	0x138c	; 0x138c <vPortFree>
    1a6e:	c0 e0       	ldi	r28, 0x00	; 0
    1a70:	d0 e0       	ldi	r29, 0x00	; 0
    1a72:	02 c0       	rjmp	.+4      	; 0x1a78 <xQueueGenericCreate+0x50>
    1a74:	c0 e0       	ldi	r28, 0x00	; 0
    1a76:	d0 e0       	ldi	r29, 0x00	; 0
    1a78:	ce 01       	movw	r24, r28
    1a7a:	df 91       	pop	r29
    1a7c:	cf 91       	pop	r28
    1a7e:	1f 91       	pop	r17
    1a80:	0f 91       	pop	r16
    1a82:	08 95       	ret

00001a84 <xQueueGenericSend>:
    1a84:	af 92       	push	r10
    1a86:	bf 92       	push	r11
    1a88:	cf 92       	push	r12
    1a8a:	df 92       	push	r13
    1a8c:	ef 92       	push	r14
    1a8e:	ff 92       	push	r15
    1a90:	0f 93       	push	r16
    1a92:	1f 93       	push	r17
    1a94:	cf 93       	push	r28
    1a96:	df 93       	push	r29
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	29 97       	sbiw	r28, 0x09	; 9
    1a9e:	cd bf       	out	0x3d, r28	; 61
    1aa0:	de bf       	out	0x3e, r29	; 62
    1aa2:	7c 01       	movw	r14, r24
    1aa4:	5b 01       	movw	r10, r22
    1aa6:	2e 83       	std	Y+6, r18	; 0x06
    1aa8:	3f 83       	std	Y+7, r19	; 0x07
    1aaa:	48 87       	std	Y+8, r20	; 0x08
    1aac:	59 87       	std	Y+9, r21	; 0x09
    1aae:	10 e0       	ldi	r17, 0x00	; 0
    1ab0:	6c 01       	movw	r12, r24
    1ab2:	88 e0       	ldi	r24, 0x08	; 8
    1ab4:	c8 0e       	add	r12, r24
    1ab6:	d1 1c       	adc	r13, r1
    1ab8:	0f b6       	in	r0, 0x3f	; 63
    1aba:	f8 94       	cli
    1abc:	0f 92       	push	r0
    1abe:	f7 01       	movw	r30, r14
    1ac0:	96 8d       	ldd	r25, Z+30	; 0x1e
    1ac2:	87 8d       	ldd	r24, Z+31	; 0x1f
    1ac4:	98 17       	cp	r25, r24
    1ac6:	a8 f4       	brcc	.+42     	; 0x1af2 <xQueueGenericSend+0x6e>
    1ac8:	40 2f       	mov	r20, r16
    1aca:	b5 01       	movw	r22, r10
    1acc:	c7 01       	movw	r24, r14
    1ace:	0e 94 28 0c 	call	0x1850	; 0x1850 <prvCopyDataToQueue>
    1ad2:	f7 01       	movw	r30, r14
    1ad4:	83 89       	ldd	r24, Z+19	; 0x13
    1ad6:	88 23       	and	r24, r24
    1ad8:	41 f0       	breq	.+16     	; 0x1aea <xQueueGenericSend+0x66>
    1ada:	c7 01       	movw	r24, r14
    1adc:	43 96       	adiw	r24, 0x13	; 19
    1ade:	0e 94 08 13 	call	0x2610	; 0x2610 <xTaskRemoveFromEventList>
    1ae2:	81 30       	cpi	r24, 0x01	; 1
    1ae4:	11 f4       	brne	.+4      	; 0x1aea <xQueueGenericSend+0x66>
    1ae6:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
    1aea:	0f 90       	pop	r0
    1aec:	0f be       	out	0x3f, r0	; 63
    1aee:	81 e0       	ldi	r24, 0x01	; 1
    1af0:	56 c0       	rjmp	.+172    	; 0x1b9e <xQueueGenericSend+0x11a>
    1af2:	8e 81       	ldd	r24, Y+6	; 0x06
    1af4:	9f 81       	ldd	r25, Y+7	; 0x07
    1af6:	a8 85       	ldd	r26, Y+8	; 0x08
    1af8:	b9 85       	ldd	r27, Y+9	; 0x09
    1afa:	89 2b       	or	r24, r25
    1afc:	8a 2b       	or	r24, r26
    1afe:	8b 2b       	or	r24, r27
    1b00:	21 f4       	brne	.+8      	; 0x1b0a <xQueueGenericSend+0x86>
    1b02:	0f 90       	pop	r0
    1b04:	0f be       	out	0x3f, r0	; 63
    1b06:	80 e0       	ldi	r24, 0x00	; 0
    1b08:	4a c0       	rjmp	.+148    	; 0x1b9e <xQueueGenericSend+0x11a>
    1b0a:	11 11       	cpse	r17, r1
    1b0c:	05 c0       	rjmp	.+10     	; 0x1b18 <xQueueGenericSend+0x94>
    1b0e:	ce 01       	movw	r24, r28
    1b10:	01 96       	adiw	r24, 0x01	; 1
    1b12:	0e 94 47 13 	call	0x268e	; 0x268e <vTaskSetTimeOutState>
    1b16:	11 e0       	ldi	r17, 0x01	; 1
    1b18:	0f 90       	pop	r0
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	0e 94 42 10 	call	0x2084	; 0x2084 <vTaskSuspendAll>
    1b20:	0f b6       	in	r0, 0x3f	; 63
    1b22:	f8 94       	cli
    1b24:	0f 92       	push	r0
    1b26:	f7 01       	movw	r30, r14
    1b28:	81 a1       	ldd	r24, Z+33	; 0x21
    1b2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b2c:	09 f4       	brne	.+2      	; 0x1b30 <xQueueGenericSend+0xac>
    1b2e:	11 a2       	std	Z+33, r1	; 0x21
    1b30:	f7 01       	movw	r30, r14
    1b32:	82 a1       	ldd	r24, Z+34	; 0x22
    1b34:	8f 3f       	cpi	r24, 0xFF	; 255
    1b36:	09 f4       	brne	.+2      	; 0x1b3a <xQueueGenericSend+0xb6>
    1b38:	12 a2       	std	Z+34, r1	; 0x22
    1b3a:	0f 90       	pop	r0
    1b3c:	0f be       	out	0x3f, r0	; 63
    1b3e:	be 01       	movw	r22, r28
    1b40:	6a 5f       	subi	r22, 0xFA	; 250
    1b42:	7f 4f       	sbci	r23, 0xFF	; 255
    1b44:	ce 01       	movw	r24, r28
    1b46:	01 96       	adiw	r24, 0x01	; 1
    1b48:	0e 94 58 13 	call	0x26b0	; 0x26b0 <xTaskCheckForTimeOut>
    1b4c:	81 11       	cpse	r24, r1
    1b4e:	21 c0       	rjmp	.+66     	; 0x1b92 <xQueueGenericSend+0x10e>
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	f8 94       	cli
    1b54:	0f 92       	push	r0
    1b56:	f7 01       	movw	r30, r14
    1b58:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b5a:	0f 90       	pop	r0
    1b5c:	0f be       	out	0x3f, r0	; 63
    1b5e:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b60:	98 13       	cpse	r25, r24
    1b62:	11 c0       	rjmp	.+34     	; 0x1b86 <xQueueGenericSend+0x102>
    1b64:	4e 81       	ldd	r20, Y+6	; 0x06
    1b66:	5f 81       	ldd	r21, Y+7	; 0x07
    1b68:	68 85       	ldd	r22, Y+8	; 0x08
    1b6a:	79 85       	ldd	r23, Y+9	; 0x09
    1b6c:	c6 01       	movw	r24, r12
    1b6e:	0e 94 de 12 	call	0x25bc	; 0x25bc <vTaskPlaceOnEventList>
    1b72:	c7 01       	movw	r24, r14
    1b74:	0e 94 8e 0c 	call	0x191c	; 0x191c <prvUnlockQueue>
    1b78:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
    1b7c:	81 11       	cpse	r24, r1
    1b7e:	9c cf       	rjmp	.-200    	; 0x1ab8 <xQueueGenericSend+0x34>
    1b80:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
    1b84:	99 cf       	rjmp	.-206    	; 0x1ab8 <xQueueGenericSend+0x34>
    1b86:	c7 01       	movw	r24, r14
    1b88:	0e 94 8e 0c 	call	0x191c	; 0x191c <prvUnlockQueue>
    1b8c:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
    1b90:	93 cf       	rjmp	.-218    	; 0x1ab8 <xQueueGenericSend+0x34>
    1b92:	c7 01       	movw	r24, r14
    1b94:	0e 94 8e 0c 	call	0x191c	; 0x191c <prvUnlockQueue>
    1b98:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
    1b9c:	80 e0       	ldi	r24, 0x00	; 0
    1b9e:	29 96       	adiw	r28, 0x09	; 9
    1ba0:	cd bf       	out	0x3d, r28	; 61
    1ba2:	de bf       	out	0x3e, r29	; 62
    1ba4:	df 91       	pop	r29
    1ba6:	cf 91       	pop	r28
    1ba8:	1f 91       	pop	r17
    1baa:	0f 91       	pop	r16
    1bac:	ff 90       	pop	r15
    1bae:	ef 90       	pop	r14
    1bb0:	df 90       	pop	r13
    1bb2:	cf 90       	pop	r12
    1bb4:	bf 90       	pop	r11
    1bb6:	af 90       	pop	r10
    1bb8:	08 95       	ret

00001bba <xQueueGenericReceive>:
    1bba:	af 92       	push	r10
    1bbc:	bf 92       	push	r11
    1bbe:	cf 92       	push	r12
    1bc0:	df 92       	push	r13
    1bc2:	ef 92       	push	r14
    1bc4:	ff 92       	push	r15
    1bc6:	0f 93       	push	r16
    1bc8:	1f 93       	push	r17
    1bca:	cf 93       	push	r28
    1bcc:	df 93       	push	r29
    1bce:	cd b7       	in	r28, 0x3d	; 61
    1bd0:	de b7       	in	r29, 0x3e	; 62
    1bd2:	29 97       	sbiw	r28, 0x09	; 9
    1bd4:	cd bf       	out	0x3d, r28	; 61
    1bd6:	de bf       	out	0x3e, r29	; 62
    1bd8:	7c 01       	movw	r14, r24
    1bda:	5b 01       	movw	r10, r22
    1bdc:	2e 83       	std	Y+6, r18	; 0x06
    1bde:	3f 83       	std	Y+7, r19	; 0x07
    1be0:	48 87       	std	Y+8, r20	; 0x08
    1be2:	59 87       	std	Y+9, r21	; 0x09
    1be4:	10 e0       	ldi	r17, 0x00	; 0
    1be6:	6c 01       	movw	r12, r24
    1be8:	83 e1       	ldi	r24, 0x13	; 19
    1bea:	c8 0e       	add	r12, r24
    1bec:	d1 1c       	adc	r13, r1
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	0f 92       	push	r0
    1bf4:	f7 01       	movw	r30, r14
    1bf6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bf8:	88 23       	and	r24, r24
    1bfa:	99 f1       	breq	.+102    	; 0x1c62 <xQueueGenericReceive+0xa8>
    1bfc:	c6 80       	ldd	r12, Z+6	; 0x06
    1bfe:	d7 80       	ldd	r13, Z+7	; 0x07
    1c00:	b5 01       	movw	r22, r10
    1c02:	c7 01       	movw	r24, r14
    1c04:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <prvCopyDataFromQueue>
    1c08:	01 11       	cpse	r16, r1
    1c0a:	1a c0       	rjmp	.+52     	; 0x1c40 <xQueueGenericReceive+0x86>
    1c0c:	f7 01       	movw	r30, r14
    1c0e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c10:	81 50       	subi	r24, 0x01	; 1
    1c12:	86 8f       	std	Z+30, r24	; 0x1e
    1c14:	80 81       	ld	r24, Z
    1c16:	91 81       	ldd	r25, Z+1	; 0x01
    1c18:	89 2b       	or	r24, r25
    1c1a:	29 f4       	brne	.+10     	; 0x1c26 <xQueueGenericReceive+0x6c>
    1c1c:	0e 94 e2 13 	call	0x27c4	; 0x27c4 <xTaskGetCurrentTaskHandle>
    1c20:	f7 01       	movw	r30, r14
    1c22:	82 83       	std	Z+2, r24	; 0x02
    1c24:	93 83       	std	Z+3, r25	; 0x03
    1c26:	f7 01       	movw	r30, r14
    1c28:	80 85       	ldd	r24, Z+8	; 0x08
    1c2a:	88 23       	and	r24, r24
    1c2c:	b1 f0       	breq	.+44     	; 0x1c5a <xQueueGenericReceive+0xa0>
    1c2e:	c7 01       	movw	r24, r14
    1c30:	08 96       	adiw	r24, 0x08	; 8
    1c32:	0e 94 08 13 	call	0x2610	; 0x2610 <xTaskRemoveFromEventList>
    1c36:	81 30       	cpi	r24, 0x01	; 1
    1c38:	81 f4       	brne	.+32     	; 0x1c5a <xQueueGenericReceive+0xa0>
    1c3a:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
    1c3e:	0d c0       	rjmp	.+26     	; 0x1c5a <xQueueGenericReceive+0xa0>
    1c40:	f7 01       	movw	r30, r14
    1c42:	c6 82       	std	Z+6, r12	; 0x06
    1c44:	d7 82       	std	Z+7, r13	; 0x07
    1c46:	83 89       	ldd	r24, Z+19	; 0x13
    1c48:	88 23       	and	r24, r24
    1c4a:	39 f0       	breq	.+14     	; 0x1c5a <xQueueGenericReceive+0xa0>
    1c4c:	c7 01       	movw	r24, r14
    1c4e:	43 96       	adiw	r24, 0x13	; 19
    1c50:	0e 94 08 13 	call	0x2610	; 0x2610 <xTaskRemoveFromEventList>
    1c54:	81 11       	cpse	r24, r1
    1c56:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
    1c5a:	0f 90       	pop	r0
    1c5c:	0f be       	out	0x3f, r0	; 63
    1c5e:	81 e0       	ldi	r24, 0x01	; 1
    1c60:	62 c0       	rjmp	.+196    	; 0x1d26 <xQueueGenericReceive+0x16c>
    1c62:	8e 81       	ldd	r24, Y+6	; 0x06
    1c64:	9f 81       	ldd	r25, Y+7	; 0x07
    1c66:	a8 85       	ldd	r26, Y+8	; 0x08
    1c68:	b9 85       	ldd	r27, Y+9	; 0x09
    1c6a:	89 2b       	or	r24, r25
    1c6c:	8a 2b       	or	r24, r26
    1c6e:	8b 2b       	or	r24, r27
    1c70:	21 f4       	brne	.+8      	; 0x1c7a <xQueueGenericReceive+0xc0>
    1c72:	0f 90       	pop	r0
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	80 e0       	ldi	r24, 0x00	; 0
    1c78:	56 c0       	rjmp	.+172    	; 0x1d26 <xQueueGenericReceive+0x16c>
    1c7a:	11 11       	cpse	r17, r1
    1c7c:	05 c0       	rjmp	.+10     	; 0x1c88 <xQueueGenericReceive+0xce>
    1c7e:	ce 01       	movw	r24, r28
    1c80:	01 96       	adiw	r24, 0x01	; 1
    1c82:	0e 94 47 13 	call	0x268e	; 0x268e <vTaskSetTimeOutState>
    1c86:	11 e0       	ldi	r17, 0x01	; 1
    1c88:	0f 90       	pop	r0
    1c8a:	0f be       	out	0x3f, r0	; 63
    1c8c:	0e 94 42 10 	call	0x2084	; 0x2084 <vTaskSuspendAll>
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	0f 92       	push	r0
    1c96:	f7 01       	movw	r30, r14
    1c98:	81 a1       	ldd	r24, Z+33	; 0x21
    1c9a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c9c:	09 f4       	brne	.+2      	; 0x1ca0 <xQueueGenericReceive+0xe6>
    1c9e:	11 a2       	std	Z+33, r1	; 0x21
    1ca0:	f7 01       	movw	r30, r14
    1ca2:	82 a1       	ldd	r24, Z+34	; 0x22
    1ca4:	8f 3f       	cpi	r24, 0xFF	; 255
    1ca6:	09 f4       	brne	.+2      	; 0x1caa <xQueueGenericReceive+0xf0>
    1ca8:	12 a2       	std	Z+34, r1	; 0x22
    1caa:	0f 90       	pop	r0
    1cac:	0f be       	out	0x3f, r0	; 63
    1cae:	be 01       	movw	r22, r28
    1cb0:	6a 5f       	subi	r22, 0xFA	; 250
    1cb2:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb4:	ce 01       	movw	r24, r28
    1cb6:	01 96       	adiw	r24, 0x01	; 1
    1cb8:	0e 94 58 13 	call	0x26b0	; 0x26b0 <xTaskCheckForTimeOut>
    1cbc:	81 11       	cpse	r24, r1
    1cbe:	2d c0       	rjmp	.+90     	; 0x1d1a <xQueueGenericReceive+0x160>
    1cc0:	0f b6       	in	r0, 0x3f	; 63
    1cc2:	f8 94       	cli
    1cc4:	0f 92       	push	r0
    1cc6:	f7 01       	movw	r30, r14
    1cc8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cca:	0f 90       	pop	r0
    1ccc:	0f be       	out	0x3f, r0	; 63
    1cce:	81 11       	cpse	r24, r1
    1cd0:	1e c0       	rjmp	.+60     	; 0x1d0e <xQueueGenericReceive+0x154>
    1cd2:	80 81       	ld	r24, Z
    1cd4:	91 81       	ldd	r25, Z+1	; 0x01
    1cd6:	89 2b       	or	r24, r25
    1cd8:	49 f4       	brne	.+18     	; 0x1cec <xQueueGenericReceive+0x132>
    1cda:	0f b6       	in	r0, 0x3f	; 63
    1cdc:	f8 94       	cli
    1cde:	0f 92       	push	r0
    1ce0:	82 81       	ldd	r24, Z+2	; 0x02
    1ce2:	93 81       	ldd	r25, Z+3	; 0x03
    1ce4:	0e 94 e7 13 	call	0x27ce	; 0x27ce <vTaskPriorityInherit>
    1ce8:	0f 90       	pop	r0
    1cea:	0f be       	out	0x3f, r0	; 63
    1cec:	4e 81       	ldd	r20, Y+6	; 0x06
    1cee:	5f 81       	ldd	r21, Y+7	; 0x07
    1cf0:	68 85       	ldd	r22, Y+8	; 0x08
    1cf2:	79 85       	ldd	r23, Y+9	; 0x09
    1cf4:	c6 01       	movw	r24, r12
    1cf6:	0e 94 de 12 	call	0x25bc	; 0x25bc <vTaskPlaceOnEventList>
    1cfa:	c7 01       	movw	r24, r14
    1cfc:	0e 94 8e 0c 	call	0x191c	; 0x191c <prvUnlockQueue>
    1d00:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
    1d04:	81 11       	cpse	r24, r1
    1d06:	73 cf       	rjmp	.-282    	; 0x1bee <xQueueGenericReceive+0x34>
    1d08:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
    1d0c:	70 cf       	rjmp	.-288    	; 0x1bee <xQueueGenericReceive+0x34>
    1d0e:	c7 01       	movw	r24, r14
    1d10:	0e 94 8e 0c 	call	0x191c	; 0x191c <prvUnlockQueue>
    1d14:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
    1d18:	6a cf       	rjmp	.-300    	; 0x1bee <xQueueGenericReceive+0x34>
    1d1a:	c7 01       	movw	r24, r14
    1d1c:	0e 94 8e 0c 	call	0x191c	; 0x191c <prvUnlockQueue>
    1d20:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
    1d24:	80 e0       	ldi	r24, 0x00	; 0
    1d26:	29 96       	adiw	r28, 0x09	; 9
    1d28:	cd bf       	out	0x3d, r28	; 61
    1d2a:	de bf       	out	0x3e, r29	; 62
    1d2c:	df 91       	pop	r29
    1d2e:	cf 91       	pop	r28
    1d30:	1f 91       	pop	r17
    1d32:	0f 91       	pop	r16
    1d34:	ff 90       	pop	r15
    1d36:	ef 90       	pop	r14
    1d38:	df 90       	pop	r13
    1d3a:	cf 90       	pop	r12
    1d3c:	bf 90       	pop	r11
    1d3e:	af 90       	pop	r10
    1d40:	08 95       	ret

00001d42 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d42:	0f b6       	in	r0, 0x3f	; 63
    1d44:	f8 94       	cli
    1d46:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d48:	fc 01       	movw	r30, r24
    1d4a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d4c:	0f 90       	pop	r0
    1d4e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d50:	08 95       	ret

00001d52 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d52:	c4 e0       	ldi	r28, 0x04	; 4
    1d54:	d1 e3       	ldi	r29, 0x31	; 49
    1d56:	88 81       	ld	r24, Y
    1d58:	82 30       	cpi	r24, 0x02	; 2
    1d5a:	e8 f3       	brcs	.-6      	; 0x1d56 <prvIdleTask+0x4>
    1d5c:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
    1d60:	fa cf       	rjmp	.-12     	; 0x1d56 <prvIdleTask+0x4>

00001d62 <prvAddCurrentTaskToDelayedList>:
    1d62:	cf 92       	push	r12
    1d64:	df 92       	push	r13
    1d66:	ef 92       	push	r14
    1d68:	ff 92       	push	r15
    1d6a:	6b 01       	movw	r12, r22
    1d6c:	7c 01       	movw	r14, r24
    1d6e:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1d72:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1d76:	62 83       	std	Z+2, r22	; 0x02
    1d78:	73 83       	std	Z+3, r23	; 0x03
    1d7a:	84 83       	std	Z+4, r24	; 0x04
    1d7c:	95 83       	std	Z+5, r25	; 0x05
    1d7e:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    1d82:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1d86:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    1d8a:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    1d8e:	c8 16       	cp	r12, r24
    1d90:	d9 06       	cpc	r13, r25
    1d92:	ea 06       	cpc	r14, r26
    1d94:	fb 06       	cpc	r15, r27
    1d96:	68 f4       	brcc	.+26     	; 0x1db2 <prvAddCurrentTaskToDelayedList+0x50>
    1d98:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    1d9c:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1da0:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <pxOverflowDelayedTaskList>
    1da4:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    1da8:	6e 5f       	subi	r22, 0xFE	; 254
    1daa:	7f 4f       	sbci	r23, 0xFF	; 255
    1dac:	0e 94 3a 0a 	call	0x1474	; 0x1474 <vListInsert>
    1db0:	21 c0       	rjmp	.+66     	; 0x1df4 <prvAddCurrentTaskToDelayedList+0x92>
    1db2:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    1db6:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1dba:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1dbe:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1dc2:	6e 5f       	subi	r22, 0xFE	; 254
    1dc4:	7f 4f       	sbci	r23, 0xFF	; 255
    1dc6:	0e 94 3a 0a 	call	0x1474	; 0x1474 <vListInsert>
    1dca:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1dce:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dd2:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dd6:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dda:	c8 16       	cp	r12, r24
    1ddc:	d9 06       	cpc	r13, r25
    1dde:	ea 06       	cpc	r14, r26
    1de0:	fb 06       	cpc	r15, r27
    1de2:	40 f4       	brcc	.+16     	; 0x1df4 <prvAddCurrentTaskToDelayedList+0x92>
    1de4:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1de8:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dec:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1df0:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1df4:	ff 90       	pop	r15
    1df6:	ef 90       	pop	r14
    1df8:	df 90       	pop	r13
    1dfa:	cf 90       	pop	r12
    1dfc:	08 95       	ret

00001dfe <xTaskGenericCreate>:
    1dfe:	4f 92       	push	r4
    1e00:	5f 92       	push	r5
    1e02:	6f 92       	push	r6
    1e04:	7f 92       	push	r7
    1e06:	8f 92       	push	r8
    1e08:	9f 92       	push	r9
    1e0a:	af 92       	push	r10
    1e0c:	bf 92       	push	r11
    1e0e:	cf 92       	push	r12
    1e10:	df 92       	push	r13
    1e12:	ef 92       	push	r14
    1e14:	ff 92       	push	r15
    1e16:	0f 93       	push	r16
    1e18:	1f 93       	push	r17
    1e1a:	cf 93       	push	r28
    1e1c:	df 93       	push	r29
    1e1e:	5c 01       	movw	r10, r24
    1e20:	4b 01       	movw	r8, r22
    1e22:	3a 01       	movw	r6, r20
    1e24:	29 01       	movw	r4, r18
    1e26:	88 e2       	ldi	r24, 0x28	; 40
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	0e 94 2c 09 	call	0x1258	; 0x1258 <pvPortMalloc>
    1e2e:	ec 01       	movw	r28, r24
    1e30:	89 2b       	or	r24, r25
    1e32:	09 f4       	brne	.+2      	; 0x1e36 <xTaskGenericCreate+0x38>
    1e34:	d4 c0       	rjmp	.+424    	; 0x1fde <xTaskGenericCreate+0x1e0>
    1e36:	c1 14       	cp	r12, r1
    1e38:	d1 04       	cpc	r13, r1
    1e3a:	09 f0       	breq	.+2      	; 0x1e3e <xTaskGenericCreate+0x40>
    1e3c:	cc c0       	rjmp	.+408    	; 0x1fd6 <xTaskGenericCreate+0x1d8>
    1e3e:	c3 01       	movw	r24, r6
    1e40:	0e 94 2c 09 	call	0x1258	; 0x1258 <pvPortMalloc>
    1e44:	8b 8f       	std	Y+27, r24	; 0x1b
    1e46:	9c 8f       	std	Y+28, r25	; 0x1c
    1e48:	00 97       	sbiw	r24, 0x00	; 0
    1e4a:	21 f4       	brne	.+8      	; 0x1e54 <xTaskGenericCreate+0x56>
    1e4c:	ce 01       	movw	r24, r28
    1e4e:	0e 94 c6 09 	call	0x138c	; 0x138c <vPortFree>
    1e52:	c5 c0       	rjmp	.+394    	; 0x1fde <xTaskGenericCreate+0x1e0>
    1e54:	a3 01       	movw	r20, r6
    1e56:	61 e1       	ldi	r22, 0x11	; 17
    1e58:	70 e0       	ldi	r23, 0x00	; 0
    1e5a:	0e 94 61 22 	call	0x44c2	; 0x44c2 <memset>
    1e5e:	93 01       	movw	r18, r6
    1e60:	21 50       	subi	r18, 0x01	; 1
    1e62:	31 09       	sbc	r19, r1
    1e64:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e66:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e68:	3c 01       	movw	r6, r24
    1e6a:	62 0e       	add	r6, r18
    1e6c:	73 1e       	adc	r7, r19
    1e6e:	4a e0       	ldi	r20, 0x0A	; 10
    1e70:	50 e0       	ldi	r21, 0x00	; 0
    1e72:	b4 01       	movw	r22, r8
    1e74:	ce 01       	movw	r24, r28
    1e76:	4d 96       	adiw	r24, 0x1d	; 29
    1e78:	0e 94 68 22 	call	0x44d0	; 0x44d0 <strncpy>
    1e7c:	1e a2       	std	Y+38, r1	; 0x26
    1e7e:	10 2f       	mov	r17, r16
    1e80:	04 30       	cpi	r16, 0x04	; 4
    1e82:	08 f0       	brcs	.+2      	; 0x1e86 <xTaskGenericCreate+0x88>
    1e84:	13 e0       	ldi	r17, 0x03	; 3
    1e86:	1a 8f       	std	Y+26, r17	; 0x1a
    1e88:	1f a3       	std	Y+39, r17	; 0x27
    1e8a:	6e 01       	movw	r12, r28
    1e8c:	22 e0       	ldi	r18, 0x02	; 2
    1e8e:	c2 0e       	add	r12, r18
    1e90:	d1 1c       	adc	r13, r1
    1e92:	c6 01       	movw	r24, r12
    1e94:	0e 94 0f 0a 	call	0x141e	; 0x141e <vListInitialiseItem>
    1e98:	ce 01       	movw	r24, r28
    1e9a:	0e 96       	adiw	r24, 0x0e	; 14
    1e9c:	0e 94 0f 0a 	call	0x141e	; 0x141e <vListInitialiseItem>
    1ea0:	ca 87       	std	Y+10, r28	; 0x0a
    1ea2:	db 87       	std	Y+11, r29	; 0x0b
    1ea4:	84 e0       	ldi	r24, 0x04	; 4
    1ea6:	90 e0       	ldi	r25, 0x00	; 0
    1ea8:	a0 e0       	ldi	r26, 0x00	; 0
    1eaa:	b0 e0       	ldi	r27, 0x00	; 0
    1eac:	81 1b       	sub	r24, r17
    1eae:	91 09       	sbc	r25, r1
    1eb0:	a1 09       	sbc	r26, r1
    1eb2:	b1 09       	sbc	r27, r1
    1eb4:	8e 87       	std	Y+14, r24	; 0x0e
    1eb6:	9f 87       	std	Y+15, r25	; 0x0f
    1eb8:	a8 8b       	std	Y+16, r26	; 0x10
    1eba:	b9 8b       	std	Y+17, r27	; 0x11
    1ebc:	ce 8b       	std	Y+22, r28	; 0x16
    1ebe:	df 8b       	std	Y+23, r29	; 0x17
    1ec0:	a2 01       	movw	r20, r4
    1ec2:	b5 01       	movw	r22, r10
    1ec4:	c3 01       	movw	r24, r6
    1ec6:	0e 94 ab 0a 	call	0x1556	; 0x1556 <pxPortInitialiseStack>
    1eca:	88 83       	st	Y, r24
    1ecc:	99 83       	std	Y+1, r25	; 0x01
    1ece:	e1 14       	cp	r14, r1
    1ed0:	f1 04       	cpc	r15, r1
    1ed2:	19 f0       	breq	.+6      	; 0x1eda <xTaskGenericCreate+0xdc>
    1ed4:	f7 01       	movw	r30, r14
    1ed6:	c0 83       	st	Z, r28
    1ed8:	d1 83       	std	Z+1, r29	; 0x01
    1eda:	0f b6       	in	r0, 0x3f	; 63
    1edc:	f8 94       	cli
    1ede:	0f 92       	push	r0
    1ee0:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    1ee4:	8f 5f       	subi	r24, 0xFF	; 255
    1ee6:	80 93 dc 30 	sts	0x30DC, r24	; 0x8030dc <uxCurrentNumberOfTasks>
    1eea:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    1eee:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1ef2:	89 2b       	or	r24, r25
    1ef4:	89 f5       	brne	.+98     	; 0x1f58 <xTaskGenericCreate+0x15a>
    1ef6:	c0 93 30 31 	sts	0x3130, r28	; 0x803130 <pxCurrentTCB>
    1efa:	d0 93 31 31 	sts	0x3131, r29	; 0x803131 <pxCurrentTCB+0x1>
    1efe:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    1f02:	81 30       	cpi	r24, 0x01	; 1
    1f04:	c1 f5       	brne	.+112    	; 0x1f76 <xTaskGenericCreate+0x178>
    1f06:	84 e0       	ldi	r24, 0x04	; 4
    1f08:	91 e3       	ldi	r25, 0x31	; 49
    1f0a:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1f0e:	8f e0       	ldi	r24, 0x0F	; 15
    1f10:	91 e3       	ldi	r25, 0x31	; 49
    1f12:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1f16:	8a e1       	ldi	r24, 0x1A	; 26
    1f18:	91 e3       	ldi	r25, 0x31	; 49
    1f1a:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1f1e:	85 e2       	ldi	r24, 0x25	; 37
    1f20:	91 e3       	ldi	r25, 0x31	; 49
    1f22:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1f26:	89 ef       	ldi	r24, 0xF9	; 249
    1f28:	90 e3       	ldi	r25, 0x30	; 48
    1f2a:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1f2e:	8e ee       	ldi	r24, 0xEE	; 238
    1f30:	90 e3       	ldi	r25, 0x30	; 48
    1f32:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1f36:	8f ed       	ldi	r24, 0xDF	; 223
    1f38:	90 e3       	ldi	r25, 0x30	; 48
    1f3a:	0e 94 fe 09 	call	0x13fc	; 0x13fc <vListInitialise>
    1f3e:	89 ef       	ldi	r24, 0xF9	; 249
    1f40:	90 e3       	ldi	r25, 0x30	; 48
    1f42:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxDelayedTaskList>
    1f46:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxDelayedTaskList+0x1>
    1f4a:	8e ee       	ldi	r24, 0xEE	; 238
    1f4c:	90 e3       	ldi	r25, 0x30	; 48
    1f4e:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <pxOverflowDelayedTaskList>
    1f52:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    1f56:	0f c0       	rjmp	.+30     	; 0x1f76 <xTaskGenericCreate+0x178>
    1f58:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <xSchedulerRunning>
    1f5c:	81 11       	cpse	r24, r1
    1f5e:	0b c0       	rjmp	.+22     	; 0x1f76 <xTaskGenericCreate+0x178>
    1f60:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1f64:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1f68:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f6a:	08 17       	cp	r16, r24
    1f6c:	20 f0       	brcs	.+8      	; 0x1f76 <xTaskGenericCreate+0x178>
    1f6e:	c0 93 30 31 	sts	0x3130, r28	; 0x803130 <pxCurrentTCB>
    1f72:	d0 93 31 31 	sts	0x3131, r29	; 0x803131 <pxCurrentTCB+0x1>
    1f76:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f78:	90 91 d7 30 	lds	r25, 0x30D7	; 0x8030d7 <uxTopUsedPriority>
    1f7c:	98 17       	cp	r25, r24
    1f7e:	10 f4       	brcc	.+4      	; 0x1f84 <xTaskGenericCreate+0x186>
    1f80:	80 93 d7 30 	sts	0x30D7, r24	; 0x8030d7 <uxTopUsedPriority>
    1f84:	90 91 d0 30 	lds	r25, 0x30D0	; 0x8030d0 <uxTaskNumber>
    1f88:	9f 5f       	subi	r25, 0xFF	; 255
    1f8a:	90 93 d0 30 	sts	0x30D0, r25	; 0x8030d0 <uxTaskNumber>
    1f8e:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    1f92:	98 17       	cp	r25, r24
    1f94:	10 f4       	brcc	.+4      	; 0x1f9a <xTaskGenericCreate+0x19c>
    1f96:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    1f9a:	fb e0       	ldi	r31, 0x0B	; 11
    1f9c:	8f 9f       	mul	r24, r31
    1f9e:	c0 01       	movw	r24, r0
    1fa0:	11 24       	eor	r1, r1
    1fa2:	b6 01       	movw	r22, r12
    1fa4:	8c 5f       	subi	r24, 0xFC	; 252
    1fa6:	9e 4c       	sbci	r25, 0xCE	; 206
    1fa8:	0e 94 13 0a 	call	0x1426	; 0x1426 <vListInsertEnd>
    1fac:	0f 90       	pop	r0
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <xSchedulerRunning>
    1fb4:	88 23       	and	r24, r24
    1fb6:	59 f0       	breq	.+22     	; 0x1fce <xTaskGenericCreate+0x1d0>
    1fb8:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1fbc:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1fc0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fc2:	80 17       	cp	r24, r16
    1fc4:	30 f4       	brcc	.+12     	; 0x1fd2 <xTaskGenericCreate+0x1d4>
    1fc6:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
    1fca:	81 e0       	ldi	r24, 0x01	; 1
    1fcc:	09 c0       	rjmp	.+18     	; 0x1fe0 <xTaskGenericCreate+0x1e2>
    1fce:	81 e0       	ldi	r24, 0x01	; 1
    1fd0:	07 c0       	rjmp	.+14     	; 0x1fe0 <xTaskGenericCreate+0x1e2>
    1fd2:	81 e0       	ldi	r24, 0x01	; 1
    1fd4:	05 c0       	rjmp	.+10     	; 0x1fe0 <xTaskGenericCreate+0x1e2>
    1fd6:	cb 8e       	std	Y+27, r12	; 0x1b
    1fd8:	dc 8e       	std	Y+28, r13	; 0x1c
    1fda:	c6 01       	movw	r24, r12
    1fdc:	3b cf       	rjmp	.-394    	; 0x1e54 <xTaskGenericCreate+0x56>
    1fde:	8f ef       	ldi	r24, 0xFF	; 255
    1fe0:	df 91       	pop	r29
    1fe2:	cf 91       	pop	r28
    1fe4:	1f 91       	pop	r17
    1fe6:	0f 91       	pop	r16
    1fe8:	ff 90       	pop	r15
    1fea:	ef 90       	pop	r14
    1fec:	df 90       	pop	r13
    1fee:	cf 90       	pop	r12
    1ff0:	bf 90       	pop	r11
    1ff2:	af 90       	pop	r10
    1ff4:	9f 90       	pop	r9
    1ff6:	8f 90       	pop	r8
    1ff8:	7f 90       	pop	r7
    1ffa:	6f 90       	pop	r6
    1ffc:	5f 90       	pop	r5
    1ffe:	4f 90       	pop	r4
    2000:	08 95       	ret

00002002 <uxTaskPriorityGet>:
    2002:	0f b6       	in	r0, 0x3f	; 63
    2004:	f8 94       	cli
    2006:	0f 92       	push	r0
    2008:	00 97       	sbiw	r24, 0x00	; 0
    200a:	21 f4       	brne	.+8      	; 0x2014 <uxTaskPriorityGet+0x12>
    200c:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2010:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2014:	0f 90       	pop	r0
    2016:	0f be       	out	0x3f, r0	; 63
    2018:	fc 01       	movw	r30, r24
    201a:	82 8d       	ldd	r24, Z+26	; 0x1a
    201c:	08 95       	ret

0000201e <vTaskStartScheduler>:
    201e:	af 92       	push	r10
    2020:	bf 92       	push	r11
    2022:	cf 92       	push	r12
    2024:	df 92       	push	r13
    2026:	ef 92       	push	r14
    2028:	ff 92       	push	r15
    202a:	0f 93       	push	r16
    202c:	a1 2c       	mov	r10, r1
    202e:	b1 2c       	mov	r11, r1
    2030:	c1 2c       	mov	r12, r1
    2032:	d1 2c       	mov	r13, r1
    2034:	0f 2e       	mov	r0, r31
    2036:	fd ed       	ldi	r31, 0xDD	; 221
    2038:	ef 2e       	mov	r14, r31
    203a:	f0 e3       	ldi	r31, 0x30	; 48
    203c:	ff 2e       	mov	r15, r31
    203e:	f0 2d       	mov	r31, r0
    2040:	00 e0       	ldi	r16, 0x00	; 0
    2042:	20 e0       	ldi	r18, 0x00	; 0
    2044:	30 e0       	ldi	r19, 0x00	; 0
    2046:	44 e6       	ldi	r20, 0x64	; 100
    2048:	50 e0       	ldi	r21, 0x00	; 0
    204a:	67 e4       	ldi	r22, 0x47	; 71
    204c:	70 e2       	ldi	r23, 0x20	; 32
    204e:	89 ea       	ldi	r24, 0xA9	; 169
    2050:	9e e0       	ldi	r25, 0x0E	; 14
    2052:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <xTaskGenericCreate>
    2056:	81 30       	cpi	r24, 0x01	; 1
    2058:	69 f4       	brne	.+26     	; 0x2074 <vTaskStartScheduler+0x56>
    205a:	f8 94       	cli
    205c:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <xSchedulerRunning>
    2060:	10 92 d8 30 	sts	0x30D8, r1	; 0x8030d8 <xTickCount>
    2064:	10 92 d9 30 	sts	0x30D9, r1	; 0x8030d9 <xTickCount+0x1>
    2068:	10 92 da 30 	sts	0x30DA, r1	; 0x8030da <xTickCount+0x2>
    206c:	10 92 db 30 	sts	0x30DB, r1	; 0x8030db <xTickCount+0x3>
    2070:	0e 94 21 0b 	call	0x1642	; 0x1642 <xPortStartScheduler>
    2074:	0f 91       	pop	r16
    2076:	ff 90       	pop	r15
    2078:	ef 90       	pop	r14
    207a:	df 90       	pop	r13
    207c:	cf 90       	pop	r12
    207e:	bf 90       	pop	r11
    2080:	af 90       	pop	r10
    2082:	08 95       	ret

00002084 <vTaskSuspendAll>:
    2084:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2088:	8f 5f       	subi	r24, 0xFF	; 255
    208a:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <uxSchedulerSuspended>
    208e:	08 95       	ret

00002090 <xTaskGetTickCount>:
    2090:	0f b6       	in	r0, 0x3f	; 63
    2092:	f8 94       	cli
    2094:	0f 92       	push	r0
    2096:	60 91 d8 30 	lds	r22, 0x30D8	; 0x8030d8 <xTickCount>
    209a:	70 91 d9 30 	lds	r23, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    209e:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount+0x2>
    20a2:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x3>
    20a6:	0f 90       	pop	r0
    20a8:	0f be       	out	0x3f, r0	; 63
    20aa:	08 95       	ret

000020ac <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20ac:	00 97       	sbiw	r24, 0x00	; 0
    20ae:	21 f4       	brne	.+8      	; 0x20b8 <pcTaskGetTaskName+0xc>
    20b0:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    20b4:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20b8:	4d 96       	adiw	r24, 0x1d	; 29
    20ba:	08 95       	ret

000020bc <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20bc:	80 91 dd 30 	lds	r24, 0x30DD	; 0x8030dd <xIdleTaskHandle>
    20c0:	90 91 de 30 	lds	r25, 0x30DE	; 0x8030de <xIdleTaskHandle+0x1>
    20c4:	08 95       	ret

000020c6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20c6:	ff 92       	push	r15
    20c8:	0f 93       	push	r16
    20ca:	1f 93       	push	r17
    20cc:	cf 93       	push	r28
    20ce:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20d0:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    20d4:	81 11       	cpse	r24, r1
    20d6:	ed c0       	rjmp	.+474    	; 0x22b2 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    20d8:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    20dc:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    20e0:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    20e4:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    20e8:	01 96       	adiw	r24, 0x01	; 1
    20ea:	a1 1d       	adc	r26, r1
    20ec:	b1 1d       	adc	r27, r1
    20ee:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <xTickCount>
    20f2:	90 93 d9 30 	sts	0x30D9, r25	; 0x8030d9 <xTickCount+0x1>
    20f6:	a0 93 da 30 	sts	0x30DA, r26	; 0x8030da <xTickCount+0x2>
    20fa:	b0 93 db 30 	sts	0x30DB, r27	; 0x8030db <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    20fe:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2102:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2106:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    210a:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    210e:	89 2b       	or	r24, r25
    2110:	8a 2b       	or	r24, r26
    2112:	8b 2b       	or	r24, r27
    2114:	f1 f5       	brne	.+124    	; 0x2192 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2116:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    211a:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    211e:	20 91 ea 30 	lds	r18, 0x30EA	; 0x8030ea <pxOverflowDelayedTaskList>
    2122:	30 91 eb 30 	lds	r19, 0x30EB	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    2126:	20 93 ec 30 	sts	0x30EC, r18	; 0x8030ec <pxDelayedTaskList>
    212a:	30 93 ed 30 	sts	0x30ED, r19	; 0x8030ed <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    212e:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <pxOverflowDelayedTaskList>
    2132:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2136:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    213a:	8f 5f       	subi	r24, 0xFF	; 255
    213c:	80 93 d1 30 	sts	0x30D1, r24	; 0x8030d1 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2140:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    2144:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    2148:	80 81       	ld	r24, Z
    214a:	81 11       	cpse	r24, r1
    214c:	0c c0       	rjmp	.+24     	; 0x2166 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    214e:	8f ef       	ldi	r24, 0xFF	; 255
    2150:	9f ef       	ldi	r25, 0xFF	; 255
    2152:	dc 01       	movw	r26, r24
    2154:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2158:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    215c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2160:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2164:	16 c0       	rjmp	.+44     	; 0x2192 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2166:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    216a:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    216e:	07 80       	ldd	r0, Z+7	; 0x07
    2170:	f0 85       	ldd	r31, Z+8	; 0x08
    2172:	e0 2d       	mov	r30, r0
    2174:	00 84       	ldd	r0, Z+8	; 0x08
    2176:	f1 85       	ldd	r31, Z+9	; 0x09
    2178:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    217a:	82 81       	ldd	r24, Z+2	; 0x02
    217c:	93 81       	ldd	r25, Z+3	; 0x03
    217e:	a4 81       	ldd	r26, Z+4	; 0x04
    2180:	b5 81       	ldd	r27, Z+5	; 0x05
    2182:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2186:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    218a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    218e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2192:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    2196:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    219a:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    219e:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    21a2:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    21a6:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21aa:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21ae:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21b2:	48 17       	cp	r20, r24
    21b4:	59 07       	cpc	r21, r25
    21b6:	6a 07       	cpc	r22, r26
    21b8:	7b 07       	cpc	r23, r27
    21ba:	08 f4       	brcc	.+2      	; 0x21be <vTaskIncrementTick+0xf8>
    21bc:	7f c0       	rjmp	.+254    	; 0x22bc <vTaskIncrementTick+0x1f6>
    21be:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    21c2:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    21c6:	80 81       	ld	r24, Z
    21c8:	88 23       	and	r24, r24
    21ca:	f9 f0       	breq	.+62     	; 0x220a <vTaskIncrementTick+0x144>
    21cc:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    21d0:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    21d4:	07 80       	ldd	r0, Z+7	; 0x07
    21d6:	f0 85       	ldd	r31, Z+8	; 0x08
    21d8:	e0 2d       	mov	r30, r0
    21da:	c0 85       	ldd	r28, Z+8	; 0x08
    21dc:	d1 85       	ldd	r29, Z+9	; 0x09
    21de:	8a 81       	ldd	r24, Y+2	; 0x02
    21e0:	9b 81       	ldd	r25, Y+3	; 0x03
    21e2:	ac 81       	ldd	r26, Y+4	; 0x04
    21e4:	bd 81       	ldd	r27, Y+5	; 0x05
    21e6:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    21ea:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    21ee:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    21f2:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    21f6:	48 17       	cp	r20, r24
    21f8:	59 07       	cpc	r21, r25
    21fa:	6a 07       	cpc	r22, r26
    21fc:	7b 07       	cpc	r23, r27
    21fe:	58 f1       	brcs	.+86     	; 0x2256 <vTaskIncrementTick+0x190>
    2200:	0f 2e       	mov	r0, r31
    2202:	fb e0       	ldi	r31, 0x0B	; 11
    2204:	ff 2e       	mov	r15, r31
    2206:	f0 2d       	mov	r31, r0
    2208:	2f c0       	rjmp	.+94     	; 0x2268 <vTaskIncrementTick+0x1a2>
    220a:	8f ef       	ldi	r24, 0xFF	; 255
    220c:	9f ef       	ldi	r25, 0xFF	; 255
    220e:	dc 01       	movw	r26, r24
    2210:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2214:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2218:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    221c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2220:	4d c0       	rjmp	.+154    	; 0x22bc <vTaskIncrementTick+0x1f6>
    2222:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    2226:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    222a:	07 80       	ldd	r0, Z+7	; 0x07
    222c:	f0 85       	ldd	r31, Z+8	; 0x08
    222e:	e0 2d       	mov	r30, r0
    2230:	c0 85       	ldd	r28, Z+8	; 0x08
    2232:	d1 85       	ldd	r29, Z+9	; 0x09
    2234:	8a 81       	ldd	r24, Y+2	; 0x02
    2236:	9b 81       	ldd	r25, Y+3	; 0x03
    2238:	ac 81       	ldd	r26, Y+4	; 0x04
    223a:	bd 81       	ldd	r27, Y+5	; 0x05
    223c:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    2240:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2244:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    2248:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    224c:	48 17       	cp	r20, r24
    224e:	59 07       	cpc	r21, r25
    2250:	6a 07       	cpc	r22, r26
    2252:	7b 07       	cpc	r23, r27
    2254:	48 f4       	brcc	.+18     	; 0x2268 <vTaskIncrementTick+0x1a2>
    2256:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    225a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    225e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2262:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2266:	2a c0       	rjmp	.+84     	; 0x22bc <vTaskIncrementTick+0x1f6>
    2268:	8e 01       	movw	r16, r28
    226a:	0e 5f       	subi	r16, 0xFE	; 254
    226c:	1f 4f       	sbci	r17, 0xFF	; 255
    226e:	c8 01       	movw	r24, r16
    2270:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
    2274:	88 8d       	ldd	r24, Y+24	; 0x18
    2276:	99 8d       	ldd	r25, Y+25	; 0x19
    2278:	89 2b       	or	r24, r25
    227a:	21 f0       	breq	.+8      	; 0x2284 <vTaskIncrementTick+0x1be>
    227c:	ce 01       	movw	r24, r28
    227e:	0e 96       	adiw	r24, 0x0e	; 14
    2280:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
    2284:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2286:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    228a:	98 17       	cp	r25, r24
    228c:	10 f4       	brcc	.+4      	; 0x2292 <vTaskIncrementTick+0x1cc>
    228e:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    2292:	f8 9e       	mul	r15, r24
    2294:	c0 01       	movw	r24, r0
    2296:	11 24       	eor	r1, r1
    2298:	b8 01       	movw	r22, r16
    229a:	8c 5f       	subi	r24, 0xFC	; 252
    229c:	9e 4c       	sbci	r25, 0xCE	; 206
    229e:	0e 94 13 0a 	call	0x1426	; 0x1426 <vListInsertEnd>
    22a2:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    22a6:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    22aa:	80 81       	ld	r24, Z
    22ac:	81 11       	cpse	r24, r1
    22ae:	b9 cf       	rjmp	.-142    	; 0x2222 <vTaskIncrementTick+0x15c>
    22b0:	ac cf       	rjmp	.-168    	; 0x220a <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22b2:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    22b6:	8f 5f       	subi	r24, 0xFF	; 255
    22b8:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22bc:	df 91       	pop	r29
    22be:	cf 91       	pop	r28
    22c0:	1f 91       	pop	r17
    22c2:	0f 91       	pop	r16
    22c4:	ff 90       	pop	r15
    22c6:	08 95       	ret

000022c8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22c8:	cf 92       	push	r12
    22ca:	df 92       	push	r13
    22cc:	ef 92       	push	r14
    22ce:	ff 92       	push	r15
    22d0:	0f 93       	push	r16
    22d2:	1f 93       	push	r17
    22d4:	cf 93       	push	r28
    22d6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    22d8:	0f b6       	in	r0, 0x3f	; 63
    22da:	f8 94       	cli
    22dc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    22de:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    22e2:	81 50       	subi	r24, 0x01	; 1
    22e4:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22e8:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    22ec:	81 11       	cpse	r24, r1
    22ee:	60 c0       	rjmp	.+192    	; 0x23b0 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    22f0:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    22f4:	81 11       	cpse	r24, r1
    22f6:	2c c0       	rjmp	.+88     	; 0x2350 <xTaskResumeAll+0x88>
    22f8:	5e c0       	rjmp	.+188    	; 0x23b6 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    22fa:	d7 01       	movw	r26, r14
    22fc:	17 96       	adiw	r26, 0x07	; 7
    22fe:	ed 91       	ld	r30, X+
    2300:	fc 91       	ld	r31, X
    2302:	18 97       	sbiw	r26, 0x08	; 8
    2304:	c0 85       	ldd	r28, Z+8	; 0x08
    2306:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2308:	ce 01       	movw	r24, r28
    230a:	0e 96       	adiw	r24, 0x0e	; 14
    230c:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2310:	8e 01       	movw	r16, r28
    2312:	0e 5f       	subi	r16, 0xFE	; 254
    2314:	1f 4f       	sbci	r17, 0xFF	; 255
    2316:	c8 01       	movw	r24, r16
    2318:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    231c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    231e:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2322:	98 17       	cp	r25, r24
    2324:	10 f4       	brcc	.+4      	; 0x232a <xTaskResumeAll+0x62>
    2326:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    232a:	d8 9e       	mul	r13, r24
    232c:	c0 01       	movw	r24, r0
    232e:	11 24       	eor	r1, r1
    2330:	b8 01       	movw	r22, r16
    2332:	8c 5f       	subi	r24, 0xFC	; 252
    2334:	9e 4c       	sbci	r25, 0xCE	; 206
    2336:	0e 94 13 0a 	call	0x1426	; 0x1426 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    233a:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    233e:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2342:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2344:	82 8d       	ldd	r24, Z+26	; 0x1a
    2346:	98 17       	cp	r25, r24
    2348:	70 f0       	brcs	.+28     	; 0x2366 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    234a:	cc 24       	eor	r12, r12
    234c:	c3 94       	inc	r12
    234e:	0b c0       	rjmp	.+22     	; 0x2366 <xTaskResumeAll+0x9e>
    2350:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2352:	0f 2e       	mov	r0, r31
    2354:	ff ed       	ldi	r31, 0xDF	; 223
    2356:	ef 2e       	mov	r14, r31
    2358:	f0 e3       	ldi	r31, 0x30	; 48
    235a:	ff 2e       	mov	r15, r31
    235c:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    235e:	0f 2e       	mov	r0, r31
    2360:	fb e0       	ldi	r31, 0x0B	; 11
    2362:	df 2e       	mov	r13, r31
    2364:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2366:	f7 01       	movw	r30, r14
    2368:	80 81       	ld	r24, Z
    236a:	81 11       	cpse	r24, r1
    236c:	c6 cf       	rjmp	.-116    	; 0x22fa <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    236e:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    2372:	88 23       	and	r24, r24
    2374:	81 f0       	breq	.+32     	; 0x2396 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2376:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    237a:	88 23       	and	r24, r24
    237c:	99 f0       	breq	.+38     	; 0x23a4 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    237e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <vTaskIncrementTick>
						--uxMissedTicks;
    2382:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    2386:	81 50       	subi	r24, 0x01	; 1
    2388:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    238c:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    2390:	81 11       	cpse	r24, r1
    2392:	f5 cf       	rjmp	.-22     	; 0x237e <xTaskResumeAll+0xb6>
    2394:	07 c0       	rjmp	.+14     	; 0x23a4 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2396:	f1 e0       	ldi	r31, 0x01	; 1
    2398:	cf 16       	cp	r12, r31
    239a:	21 f0       	breq	.+8      	; 0x23a4 <xTaskResumeAll+0xdc>
    239c:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <xMissedYield>
    23a0:	81 30       	cpi	r24, 0x01	; 1
    23a2:	41 f4       	brne	.+16     	; 0x23b4 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23a4:	10 92 d2 30 	sts	0x30D2, r1	; 0x8030d2 <xMissedYield>
					portYIELD_WITHIN_API();
    23a8:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23ac:	81 e0       	ldi	r24, 0x01	; 1
    23ae:	03 c0       	rjmp	.+6      	; 0x23b6 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23b0:	80 e0       	ldi	r24, 0x00	; 0
    23b2:	01 c0       	rjmp	.+2      	; 0x23b6 <xTaskResumeAll+0xee>
    23b4:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23b6:	0f 90       	pop	r0
    23b8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23ba:	df 91       	pop	r29
    23bc:	cf 91       	pop	r28
    23be:	1f 91       	pop	r17
    23c0:	0f 91       	pop	r16
    23c2:	ff 90       	pop	r15
    23c4:	ef 90       	pop	r14
    23c6:	df 90       	pop	r13
    23c8:	cf 90       	pop	r12
    23ca:	08 95       	ret

000023cc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    23cc:	cf 92       	push	r12
    23ce:	df 92       	push	r13
    23d0:	ef 92       	push	r14
    23d2:	ff 92       	push	r15
    23d4:	cf 93       	push	r28
    23d6:	df 93       	push	r29
    23d8:	ec 01       	movw	r28, r24
    23da:	6a 01       	movw	r12, r20
    23dc:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    23de:	0e 94 42 10 	call	0x2084	; 0x2084 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    23e2:	88 81       	ld	r24, Y
    23e4:	99 81       	ldd	r25, Y+1	; 0x01
    23e6:	aa 81       	ldd	r26, Y+2	; 0x02
    23e8:	bb 81       	ldd	r27, Y+3	; 0x03
    23ea:	c8 0e       	add	r12, r24
    23ec:	d9 1e       	adc	r13, r25
    23ee:	ea 1e       	adc	r14, r26
    23f0:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    23f2:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    23f6:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    23fa:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    23fe:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    2402:	48 17       	cp	r20, r24
    2404:	59 07       	cpc	r21, r25
    2406:	6a 07       	cpc	r22, r26
    2408:	7b 07       	cpc	r23, r27
    240a:	b8 f4       	brcc	.+46     	; 0x243a <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    240c:	c8 16       	cp	r12, r24
    240e:	d9 06       	cpc	r13, r25
    2410:	ea 06       	cpc	r14, r26
    2412:	fb 06       	cpc	r15, r27
    2414:	e0 f5       	brcc	.+120    	; 0x248e <vTaskDelayUntil+0xc2>
    2416:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    241a:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    241e:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2422:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2426:	c8 82       	st	Y, r12
    2428:	d9 82       	std	Y+1, r13	; 0x01
    242a:	ea 82       	std	Y+2, r14	; 0x02
    242c:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    242e:	8c 15       	cp	r24, r12
    2430:	9d 05       	cpc	r25, r13
    2432:	ae 05       	cpc	r26, r14
    2434:	bf 05       	cpc	r27, r15
    2436:	f8 f4       	brcc	.+62     	; 0x2476 <vTaskDelayUntil+0xaa>
    2438:	13 c0       	rjmp	.+38     	; 0x2460 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    243a:	c8 16       	cp	r12, r24
    243c:	d9 06       	cpc	r13, r25
    243e:	ea 06       	cpc	r14, r26
    2440:	fb 06       	cpc	r15, r27
    2442:	00 f1       	brcs	.+64     	; 0x2484 <vTaskDelayUntil+0xb8>
    2444:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2448:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    244c:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2450:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2454:	8c 15       	cp	r24, r12
    2456:	9d 05       	cpc	r25, r13
    2458:	ae 05       	cpc	r26, r14
    245a:	bf 05       	cpc	r27, r15
    245c:	98 f0       	brcs	.+38     	; 0x2484 <vTaskDelayUntil+0xb8>
    245e:	17 c0       	rjmp	.+46     	; 0x248e <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2460:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    2464:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2468:	02 96       	adiw	r24, 0x02	; 2
    246a:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    246e:	c7 01       	movw	r24, r14
    2470:	b6 01       	movw	r22, r12
    2472:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2476:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    247a:	81 11       	cpse	r24, r1
    247c:	0d c0       	rjmp	.+26     	; 0x2498 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    247e:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
		}
	}
    2482:	0a c0       	rjmp	.+20     	; 0x2498 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2484:	c8 82       	st	Y, r12
    2486:	d9 82       	std	Y+1, r13	; 0x01
    2488:	ea 82       	std	Y+2, r14	; 0x02
    248a:	fb 82       	std	Y+3, r15	; 0x03
    248c:	e9 cf       	rjmp	.-46     	; 0x2460 <vTaskDelayUntil+0x94>
    248e:	c8 82       	st	Y, r12
    2490:	d9 82       	std	Y+1, r13	; 0x01
    2492:	ea 82       	std	Y+2, r14	; 0x02
    2494:	fb 82       	std	Y+3, r15	; 0x03
    2496:	ef cf       	rjmp	.-34     	; 0x2476 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2498:	df 91       	pop	r29
    249a:	cf 91       	pop	r28
    249c:	ff 90       	pop	r15
    249e:	ef 90       	pop	r14
    24a0:	df 90       	pop	r13
    24a2:	cf 90       	pop	r12
    24a4:	08 95       	ret

000024a6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    24a6:	cf 92       	push	r12
    24a8:	df 92       	push	r13
    24aa:	ef 92       	push	r14
    24ac:	ff 92       	push	r15
    24ae:	6b 01       	movw	r12, r22
    24b0:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24b2:	67 2b       	or	r22, r23
    24b4:	68 2b       	or	r22, r24
    24b6:	69 2b       	or	r22, r25
    24b8:	e9 f0       	breq	.+58     	; 0x24f4 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    24ba:	0e 94 42 10 	call	0x2084	; 0x2084 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24be:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    24c2:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    24c6:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    24ca:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    24ce:	c8 0e       	add	r12, r24
    24d0:	d9 1e       	adc	r13, r25
    24d2:	ea 1e       	adc	r14, r26
    24d4:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24d6:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    24da:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    24de:	02 96       	adiw	r24, 0x02	; 2
    24e0:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24e4:	c7 01       	movw	r24, r14
    24e6:	b6 01       	movw	r22, r12
    24e8:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    24ec:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24f0:	81 11       	cpse	r24, r1
    24f2:	02 c0       	rjmp	.+4      	; 0x24f8 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    24f4:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vPortYield>
		}
	}
    24f8:	ff 90       	pop	r15
    24fa:	ef 90       	pop	r14
    24fc:	df 90       	pop	r13
    24fe:	cf 90       	pop	r12
    2500:	08 95       	ret

00002502 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2502:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2506:	81 11       	cpse	r24, r1
    2508:	0c c0       	rjmp	.+24     	; 0x2522 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    250a:	e0 91 d6 30 	lds	r30, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    250e:	4b e0       	ldi	r20, 0x0B	; 11
    2510:	e4 9f       	mul	r30, r20
    2512:	f0 01       	movw	r30, r0
    2514:	11 24       	eor	r1, r1
    2516:	ec 5f       	subi	r30, 0xFC	; 252
    2518:	fe 4c       	sbci	r31, 0xCE	; 206
    251a:	80 81       	ld	r24, Z
    251c:	88 23       	and	r24, r24
    251e:	29 f0       	breq	.+10     	; 0x252a <vTaskSwitchContext+0x28>
    2520:	14 c0       	rjmp	.+40     	; 0x254a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2522:	81 e0       	ldi	r24, 0x01	; 1
    2524:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <xMissedYield>
    2528:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    252a:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    252c:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2530:	81 50       	subi	r24, 0x01	; 1
    2532:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2536:	e0 91 d6 30 	lds	r30, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    253a:	9e 9f       	mul	r25, r30
    253c:	f0 01       	movw	r30, r0
    253e:	11 24       	eor	r1, r1
    2540:	ec 5f       	subi	r30, 0xFC	; 252
    2542:	fe 4c       	sbci	r31, 0xCE	; 206
    2544:	80 81       	ld	r24, Z
    2546:	88 23       	and	r24, r24
    2548:	89 f3       	breq	.-30     	; 0x252c <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    254a:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    254e:	28 2f       	mov	r18, r24
    2550:	30 e0       	ldi	r19, 0x00	; 0
    2552:	4b e0       	ldi	r20, 0x0B	; 11
    2554:	84 9f       	mul	r24, r20
    2556:	c0 01       	movw	r24, r0
    2558:	11 24       	eor	r1, r1
    255a:	dc 01       	movw	r26, r24
    255c:	ac 5f       	subi	r26, 0xFC	; 252
    255e:	be 4c       	sbci	r27, 0xCE	; 206
    2560:	11 96       	adiw	r26, 0x01	; 1
    2562:	ed 91       	ld	r30, X+
    2564:	fc 91       	ld	r31, X
    2566:	12 97       	sbiw	r26, 0x02	; 2
    2568:	04 80       	ldd	r0, Z+4	; 0x04
    256a:	f5 81       	ldd	r31, Z+5	; 0x05
    256c:	e0 2d       	mov	r30, r0
    256e:	11 96       	adiw	r26, 0x01	; 1
    2570:	ed 93       	st	X+, r30
    2572:	fc 93       	st	X, r31
    2574:	12 97       	sbiw	r26, 0x02	; 2
    2576:	89 5f       	subi	r24, 0xF9	; 249
    2578:	9e 4c       	sbci	r25, 0xCE	; 206
    257a:	e8 17       	cp	r30, r24
    257c:	f9 07       	cpc	r31, r25
    257e:	61 f4       	brne	.+24     	; 0x2598 <vTaskSwitchContext+0x96>
    2580:	84 81       	ldd	r24, Z+4	; 0x04
    2582:	95 81       	ldd	r25, Z+5	; 0x05
    2584:	4b e0       	ldi	r20, 0x0B	; 11
    2586:	42 9f       	mul	r20, r18
    2588:	f0 01       	movw	r30, r0
    258a:	43 9f       	mul	r20, r19
    258c:	f0 0d       	add	r31, r0
    258e:	11 24       	eor	r1, r1
    2590:	ec 5f       	subi	r30, 0xFC	; 252
    2592:	fe 4c       	sbci	r31, 0xCE	; 206
    2594:	81 83       	std	Z+1, r24	; 0x01
    2596:	92 83       	std	Z+2, r25	; 0x02
    2598:	8b e0       	ldi	r24, 0x0B	; 11
    259a:	82 9f       	mul	r24, r18
    259c:	f0 01       	movw	r30, r0
    259e:	83 9f       	mul	r24, r19
    25a0:	f0 0d       	add	r31, r0
    25a2:	11 24       	eor	r1, r1
    25a4:	ec 5f       	subi	r30, 0xFC	; 252
    25a6:	fe 4c       	sbci	r31, 0xCE	; 206
    25a8:	01 80       	ldd	r0, Z+1	; 0x01
    25aa:	f2 81       	ldd	r31, Z+2	; 0x02
    25ac:	e0 2d       	mov	r30, r0
    25ae:	80 85       	ldd	r24, Z+8	; 0x08
    25b0:	91 85       	ldd	r25, Z+9	; 0x09
    25b2:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <pxCurrentTCB>
    25b6:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <pxCurrentTCB+0x1>
    25ba:	08 95       	ret

000025bc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25bc:	cf 92       	push	r12
    25be:	df 92       	push	r13
    25c0:	ef 92       	push	r14
    25c2:	ff 92       	push	r15
    25c4:	6a 01       	movw	r12, r20
    25c6:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25c8:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    25cc:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    25d0:	62 5f       	subi	r22, 0xF2	; 242
    25d2:	7f 4f       	sbci	r23, 0xFF	; 255
    25d4:	0e 94 3a 0a 	call	0x1474	; 0x1474 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25d8:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    25dc:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    25e0:	02 96       	adiw	r24, 0x02	; 2
    25e2:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    25e6:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    25ea:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    25ee:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    25f2:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    25f6:	bc 01       	movw	r22, r24
    25f8:	cd 01       	movw	r24, r26
    25fa:	6c 0d       	add	r22, r12
    25fc:	7d 1d       	adc	r23, r13
    25fe:	8e 1d       	adc	r24, r14
    2600:	9f 1d       	adc	r25, r15
    2602:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2606:	ff 90       	pop	r15
    2608:	ef 90       	pop	r14
    260a:	df 90       	pop	r13
    260c:	cf 90       	pop	r12
    260e:	08 95       	ret

00002610 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2610:	0f 93       	push	r16
    2612:	1f 93       	push	r17
    2614:	cf 93       	push	r28
    2616:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2618:	dc 01       	movw	r26, r24
    261a:	17 96       	adiw	r26, 0x07	; 7
    261c:	ed 91       	ld	r30, X+
    261e:	fc 91       	ld	r31, X
    2620:	18 97       	sbiw	r26, 0x08	; 8
    2622:	c0 85       	ldd	r28, Z+8	; 0x08
    2624:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2626:	8e 01       	movw	r16, r28
    2628:	02 5f       	subi	r16, 0xF2	; 242
    262a:	1f 4f       	sbci	r17, 0xFF	; 255
    262c:	c8 01       	movw	r24, r16
    262e:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2632:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2636:	81 11       	cpse	r24, r1
    2638:	16 c0       	rjmp	.+44     	; 0x2666 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    263a:	0c 50       	subi	r16, 0x0C	; 12
    263c:	11 09       	sbc	r17, r1
    263e:	c8 01       	movw	r24, r16
    2640:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2644:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2646:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    264a:	98 17       	cp	r25, r24
    264c:	10 f4       	brcc	.+4      	; 0x2652 <xTaskRemoveFromEventList+0x42>
    264e:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    2652:	bb e0       	ldi	r27, 0x0B	; 11
    2654:	8b 9f       	mul	r24, r27
    2656:	c0 01       	movw	r24, r0
    2658:	11 24       	eor	r1, r1
    265a:	b8 01       	movw	r22, r16
    265c:	8c 5f       	subi	r24, 0xFC	; 252
    265e:	9e 4c       	sbci	r25, 0xCE	; 206
    2660:	0e 94 13 0a 	call	0x1426	; 0x1426 <vListInsertEnd>
    2664:	05 c0       	rjmp	.+10     	; 0x2670 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2666:	b8 01       	movw	r22, r16
    2668:	8f ed       	ldi	r24, 0xDF	; 223
    266a:	90 e3       	ldi	r25, 0x30	; 48
    266c:	0e 94 13 0a 	call	0x1426	; 0x1426 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2670:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    2674:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2678:	81 e0       	ldi	r24, 0x01	; 1
    267a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    267c:	92 8d       	ldd	r25, Z+26	; 0x1a
    267e:	29 17       	cp	r18, r25
    2680:	08 f4       	brcc	.+2      	; 0x2684 <xTaskRemoveFromEventList+0x74>
    2682:	80 e0       	ldi	r24, 0x00	; 0
}
    2684:	df 91       	pop	r29
    2686:	cf 91       	pop	r28
    2688:	1f 91       	pop	r17
    268a:	0f 91       	pop	r16
    268c:	08 95       	ret

0000268e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    268e:	20 91 d1 30 	lds	r18, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    2692:	fc 01       	movw	r30, r24
    2694:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2696:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    269a:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    269e:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    26a2:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    26a6:	41 83       	std	Z+1, r20	; 0x01
    26a8:	52 83       	std	Z+2, r21	; 0x02
    26aa:	63 83       	std	Z+3, r22	; 0x03
    26ac:	74 83       	std	Z+4, r23	; 0x04
    26ae:	08 95       	ret

000026b0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26b0:	8f 92       	push	r8
    26b2:	9f 92       	push	r9
    26b4:	af 92       	push	r10
    26b6:	bf 92       	push	r11
    26b8:	cf 92       	push	r12
    26ba:	df 92       	push	r13
    26bc:	ef 92       	push	r14
    26be:	ff 92       	push	r15
    26c0:	0f 93       	push	r16
    26c2:	1f 93       	push	r17
    26c4:	cf 93       	push	r28
    26c6:	df 93       	push	r29
    26c8:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26ca:	0f b6       	in	r0, 0x3f	; 63
    26cc:	f8 94       	cli
    26ce:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26d0:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    26d4:	90 81       	ld	r25, Z
    26d6:	98 17       	cp	r25, r24
    26d8:	89 f0       	breq	.+34     	; 0x26fc <xTaskCheckForTimeOut+0x4c>
    26da:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    26de:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    26e2:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    26e6:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    26ea:	01 81       	ldd	r16, Z+1	; 0x01
    26ec:	12 81       	ldd	r17, Z+2	; 0x02
    26ee:	23 81       	ldd	r18, Z+3	; 0x03
    26f0:	34 81       	ldd	r19, Z+4	; 0x04
    26f2:	80 17       	cp	r24, r16
    26f4:	91 07       	cpc	r25, r17
    26f6:	a2 07       	cpc	r26, r18
    26f8:	b3 07       	cpc	r27, r19
    26fa:	a8 f5       	brcc	.+106    	; 0x2766 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    26fc:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2700:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2704:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2708:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    270c:	c1 80       	ldd	r12, Z+1	; 0x01
    270e:	d2 80       	ldd	r13, Z+2	; 0x02
    2710:	e3 80       	ldd	r14, Z+3	; 0x03
    2712:	f4 80       	ldd	r15, Z+4	; 0x04
    2714:	eb 01       	movw	r28, r22
    2716:	08 81       	ld	r16, Y
    2718:	19 81       	ldd	r17, Y+1	; 0x01
    271a:	2a 81       	ldd	r18, Y+2	; 0x02
    271c:	3b 81       	ldd	r19, Y+3	; 0x03
    271e:	8c 19       	sub	r24, r12
    2720:	9d 09       	sbc	r25, r13
    2722:	ae 09       	sbc	r26, r14
    2724:	bf 09       	sbc	r27, r15
    2726:	80 17       	cp	r24, r16
    2728:	91 07       	cpc	r25, r17
    272a:	a2 07       	cpc	r26, r18
    272c:	b3 07       	cpc	r27, r19
    272e:	e8 f4       	brcc	.+58     	; 0x276a <xTaskCheckForTimeOut+0xba>
    2730:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2732:	80 90 d8 30 	lds	r8, 0x30D8	; 0x8030d8 <xTickCount>
    2736:	90 90 d9 30 	lds	r9, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    273a:	a0 90 da 30 	lds	r10, 0x30DA	; 0x8030da <xTickCount+0x2>
    273e:	b0 90 db 30 	lds	r11, 0x30DB	; 0x8030db <xTickCount+0x3>
    2742:	b5 01       	movw	r22, r10
    2744:	a4 01       	movw	r20, r8
    2746:	4c 19       	sub	r20, r12
    2748:	5d 09       	sbc	r21, r13
    274a:	6e 09       	sbc	r22, r14
    274c:	7f 09       	sbc	r23, r15
    274e:	04 1b       	sub	r16, r20
    2750:	15 0b       	sbc	r17, r21
    2752:	26 0b       	sbc	r18, r22
    2754:	37 0b       	sbc	r19, r23
    2756:	08 83       	st	Y, r16
    2758:	19 83       	std	Y+1, r17	; 0x01
    275a:	2a 83       	std	Y+2, r18	; 0x02
    275c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    275e:	0e 94 47 13 	call	0x268e	; 0x268e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2762:	80 e0       	ldi	r24, 0x00	; 0
    2764:	03 c0       	rjmp	.+6      	; 0x276c <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	01 c0       	rjmp	.+2      	; 0x276c <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    276a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    276c:	0f 90       	pop	r0
    276e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2770:	df 91       	pop	r29
    2772:	cf 91       	pop	r28
    2774:	1f 91       	pop	r17
    2776:	0f 91       	pop	r16
    2778:	ff 90       	pop	r15
    277a:	ef 90       	pop	r14
    277c:	df 90       	pop	r13
    277e:	cf 90       	pop	r12
    2780:	bf 90       	pop	r11
    2782:	af 90       	pop	r10
    2784:	9f 90       	pop	r9
    2786:	8f 90       	pop	r8
    2788:	08 95       	ret

0000278a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    278a:	81 e0       	ldi	r24, 0x01	; 1
    278c:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <xMissedYield>
    2790:	08 95       	ret

00002792 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2792:	00 97       	sbiw	r24, 0x00	; 0
    2794:	21 f4       	brne	.+8      	; 0x279e <uxTaskGetStackHighWaterMark+0xc>
    2796:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    279a:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    279e:	dc 01       	movw	r26, r24
    27a0:	5b 96       	adiw	r26, 0x1b	; 27
    27a2:	ed 91       	ld	r30, X+
    27a4:	fc 91       	ld	r31, X
    27a6:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27a8:	80 81       	ld	r24, Z
    27aa:	81 31       	cpi	r24, 0x11	; 17
    27ac:	41 f4       	brne	.+16     	; 0x27be <uxTaskGetStackHighWaterMark+0x2c>
    27ae:	31 96       	adiw	r30, 0x01	; 1
    27b0:	80 e0       	ldi	r24, 0x00	; 0
    27b2:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27b4:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27b6:	21 91       	ld	r18, Z+
    27b8:	21 31       	cpi	r18, 0x11	; 17
    27ba:	e1 f3       	breq	.-8      	; 0x27b4 <uxTaskGetStackHighWaterMark+0x22>
    27bc:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27be:	80 e0       	ldi	r24, 0x00	; 0
    27c0:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27c2:	08 95       	ret

000027c4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27c4:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    27c8:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>

		return xReturn;
	}
    27cc:	08 95       	ret

000027ce <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27ce:	0f 93       	push	r16
    27d0:	1f 93       	push	r17
    27d2:	cf 93       	push	r28
    27d4:	df 93       	push	r29
    27d6:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    27d8:	22 8d       	ldd	r18, Z+26	; 0x1a
    27da:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    27de:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    27e2:	5a 96       	adiw	r26, 0x1a	; 26
    27e4:	8c 91       	ld	r24, X
    27e6:	28 17       	cp	r18, r24
    27e8:	08 f0       	brcs	.+2      	; 0x27ec <vTaskPriorityInherit+0x1e>
    27ea:	41 c0       	rjmp	.+130    	; 0x286e <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    27ec:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    27f0:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    27f4:	5a 96       	adiw	r26, 0x1a	; 26
    27f6:	3c 91       	ld	r19, X
    27f8:	84 e0       	ldi	r24, 0x04	; 4
    27fa:	90 e0       	ldi	r25, 0x00	; 0
    27fc:	a0 e0       	ldi	r26, 0x00	; 0
    27fe:	b0 e0       	ldi	r27, 0x00	; 0
    2800:	83 1b       	sub	r24, r19
    2802:	91 09       	sbc	r25, r1
    2804:	a1 09       	sbc	r26, r1
    2806:	b1 09       	sbc	r27, r1
    2808:	86 87       	std	Z+14, r24	; 0x0e
    280a:	97 87       	std	Z+15, r25	; 0x0f
    280c:	a0 8b       	std	Z+16, r26	; 0x10
    280e:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2810:	8b e0       	ldi	r24, 0x0B	; 11
    2812:	28 9f       	mul	r18, r24
    2814:	90 01       	movw	r18, r0
    2816:	11 24       	eor	r1, r1
    2818:	2c 5f       	subi	r18, 0xFC	; 252
    281a:	3e 4c       	sbci	r19, 0xCE	; 206
    281c:	84 85       	ldd	r24, Z+12	; 0x0c
    281e:	95 85       	ldd	r25, Z+13	; 0x0d
    2820:	82 17       	cp	r24, r18
    2822:	93 07       	cpc	r25, r19
    2824:	e9 f4       	brne	.+58     	; 0x2860 <vTaskPriorityInherit+0x92>
    2826:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2828:	ef 01       	movw	r28, r30
    282a:	22 96       	adiw	r28, 0x02	; 2
    282c:	ce 01       	movw	r24, r28
    282e:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2832:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    2836:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    283a:	82 8d       	ldd	r24, Z+26	; 0x1a
    283c:	f8 01       	movw	r30, r16
    283e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2840:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2844:	98 17       	cp	r25, r24
    2846:	10 f4       	brcc	.+4      	; 0x284c <vTaskPriorityInherit+0x7e>
    2848:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    284c:	fb e0       	ldi	r31, 0x0B	; 11
    284e:	8f 9f       	mul	r24, r31
    2850:	c0 01       	movw	r24, r0
    2852:	11 24       	eor	r1, r1
    2854:	be 01       	movw	r22, r28
    2856:	8c 5f       	subi	r24, 0xFC	; 252
    2858:	9e 4c       	sbci	r25, 0xCE	; 206
    285a:	0e 94 13 0a 	call	0x1426	; 0x1426 <vListInsertEnd>
    285e:	07 c0       	rjmp	.+14     	; 0x286e <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2860:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    2864:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2868:	5a 96       	adiw	r26, 0x1a	; 26
    286a:	8c 91       	ld	r24, X
    286c:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    286e:	df 91       	pop	r29
    2870:	cf 91       	pop	r28
    2872:	1f 91       	pop	r17
    2874:	0f 91       	pop	r16
    2876:	08 95       	ret

00002878 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2878:	0f 93       	push	r16
    287a:	1f 93       	push	r17
    287c:	cf 93       	push	r28
    287e:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2880:	00 97       	sbiw	r24, 0x00	; 0
    2882:	49 f1       	breq	.+82     	; 0x28d6 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2884:	fc 01       	movw	r30, r24
    2886:	32 8d       	ldd	r19, Z+26	; 0x1a
    2888:	27 a1       	ldd	r18, Z+39	; 0x27
    288a:	32 17       	cp	r19, r18
    288c:	21 f1       	breq	.+72     	; 0x28d6 <vTaskPriorityDisinherit+0x5e>
    288e:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2890:	8c 01       	movw	r16, r24
    2892:	0e 5f       	subi	r16, 0xFE	; 254
    2894:	1f 4f       	sbci	r17, 0xFF	; 255
    2896:	c8 01       	movw	r24, r16
    2898:	0e 94 85 0a 	call	0x150a	; 0x150a <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    289c:	8f a1       	ldd	r24, Y+39	; 0x27
    289e:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28a0:	44 e0       	ldi	r20, 0x04	; 4
    28a2:	50 e0       	ldi	r21, 0x00	; 0
    28a4:	60 e0       	ldi	r22, 0x00	; 0
    28a6:	70 e0       	ldi	r23, 0x00	; 0
    28a8:	48 1b       	sub	r20, r24
    28aa:	51 09       	sbc	r21, r1
    28ac:	61 09       	sbc	r22, r1
    28ae:	71 09       	sbc	r23, r1
    28b0:	4e 87       	std	Y+14, r20	; 0x0e
    28b2:	5f 87       	std	Y+15, r21	; 0x0f
    28b4:	68 8b       	std	Y+16, r22	; 0x10
    28b6:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28b8:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    28bc:	98 17       	cp	r25, r24
    28be:	10 f4       	brcc	.+4      	; 0x28c4 <vTaskPriorityDisinherit+0x4c>
    28c0:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    28c4:	fb e0       	ldi	r31, 0x0B	; 11
    28c6:	8f 9f       	mul	r24, r31
    28c8:	c0 01       	movw	r24, r0
    28ca:	11 24       	eor	r1, r1
    28cc:	b8 01       	movw	r22, r16
    28ce:	8c 5f       	subi	r24, 0xFC	; 252
    28d0:	9e 4c       	sbci	r25, 0xCE	; 206
    28d2:	0e 94 13 0a 	call	0x1426	; 0x1426 <vListInsertEnd>
			}
		}
	}
    28d6:	df 91       	pop	r29
    28d8:	cf 91       	pop	r28
    28da:	1f 91       	pop	r17
    28dc:	0f 91       	pop	r16
    28de:	08 95       	ret

000028e0 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    28e0:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    28e2:	e8 81       	ld	r30, Y
    28e4:	f9 81       	ldd	r31, Y+1	; 0x01
    28e6:	01 90       	ld	r0, Z+
    28e8:	f0 81       	ld	r31, Z
    28ea:	e0 2d       	mov	r30, r0
    28ec:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    28ee:	1a 82       	std	Y+2, r1	; 0x02
    28f0:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    28f2:	6f ef       	ldi	r22, 0xFF	; 255
    28f4:	7f ef       	ldi	r23, 0xFF	; 255
    28f6:	cb 01       	movw	r24, r22
    28f8:	0e 94 53 12 	call	0x24a6	; 0x24a6 <vTaskDelay>
    28fc:	fa cf       	rjmp	.-12     	; 0x28f2 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000028fe <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    28fe:	fc 01       	movw	r30, r24
    2900:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2902:	65 87       	std	Z+13, r22	; 0x0d
    2904:	08 95       	ret

00002906 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2906:	4f 92       	push	r4
    2908:	5f 92       	push	r5
    290a:	6f 92       	push	r6
    290c:	7f 92       	push	r7
    290e:	8f 92       	push	r8
    2910:	9f 92       	push	r9
    2912:	af 92       	push	r10
    2914:	bf 92       	push	r11
    2916:	cf 92       	push	r12
    2918:	df 92       	push	r13
    291a:	ef 92       	push	r14
    291c:	ff 92       	push	r15
    291e:	0f 93       	push	r16
    2920:	1f 93       	push	r17
    2922:	cf 93       	push	r28
    2924:	df 93       	push	r29
    2926:	cd b7       	in	r28, 0x3d	; 61
    2928:	de b7       	in	r29, 0x3e	; 62
    292a:	2a 97       	sbiw	r28, 0x0a	; 10
    292c:	cd bf       	out	0x3d, r28	; 61
    292e:	de bf       	out	0x3e, r29	; 62
    2930:	4c 01       	movw	r8, r24
    2932:	29 01       	movw	r4, r18
    2934:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2936:	80 e5       	ldi	r24, 0x50	; 80
    2938:	90 e2       	ldi	r25, 0x20	; 32
    293a:	f4 01       	movw	r30, r8
    293c:	80 83       	st	Z, r24
    293e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2940:	fb 01       	movw	r30, r22
    2942:	80 81       	ld	r24, Z
    2944:	88 23       	and	r24, r24
    2946:	69 f0       	breq	.+26     	; 0x2962 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2948:	de 01       	movw	r26, r28
    294a:	11 96       	adiw	r26, 0x01	; 1
    294c:	31 96       	adiw	r30, 0x01	; 1
    294e:	90 e0       	ldi	r25, 0x00	; 0
    2950:	02 c0       	rjmp	.+4      	; 0x2956 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2952:	99 30       	cpi	r25, 0x09	; 9
    2954:	39 f0       	breq	.+14     	; 0x2964 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2956:	9f 5f       	subi	r25, 0xFF	; 255
    2958:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    295a:	81 91       	ld	r24, Z+
    295c:	81 11       	cpse	r24, r1
    295e:	f9 cf       	rjmp	.-14     	; 0x2952 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2960:	01 c0       	rjmp	.+2      	; 0x2964 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2962:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2964:	e1 e0       	ldi	r30, 0x01	; 1
    2966:	f0 e0       	ldi	r31, 0x00	; 0
    2968:	ec 0f       	add	r30, r28
    296a:	fd 1f       	adc	r31, r29
    296c:	e9 0f       	add	r30, r25
    296e:	f1 1d       	adc	r31, r1
    2970:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2972:	74 01       	movw	r14, r8
    2974:	f2 e0       	ldi	r31, 0x02	; 2
    2976:	ef 0e       	add	r14, r31
    2978:	f1 1c       	adc	r15, r1
    297a:	a1 2c       	mov	r10, r1
    297c:	b1 2c       	mov	r11, r1
    297e:	c1 2c       	mov	r12, r1
    2980:	d1 2c       	mov	r13, r1
    2982:	04 2f       	mov	r16, r20
    2984:	94 01       	movw	r18, r8
    2986:	a2 01       	movw	r20, r4
    2988:	be 01       	movw	r22, r28
    298a:	6f 5f       	subi	r22, 0xFF	; 255
    298c:	7f 4f       	sbci	r23, 0xFF	; 255
    298e:	84 ea       	ldi	r24, 0xA4	; 164
    2990:	92 e0       	ldi	r25, 0x02	; 2
    2992:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2996:	f4 01       	movw	r30, r8
    2998:	66 82       	std	Z+6, r6	; 0x06
    299a:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    299c:	40 86       	std	Z+8, r4	; 0x08
    299e:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    29a0:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <last_created_task_pointer>
    29a4:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    29a8:	24 83       	std	Z+4, r18	; 0x04
    29aa:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29ac:	80 92 32 31 	sts	0x3132, r8	; 0x803132 <last_created_task_pointer>
    29b0:	90 92 33 31 	sts	0x3133, r9	; 0x803133 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29b4:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29b6:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29b8:	40 90 74 31 	lds	r4, 0x3174	; 0x803174 <portStackTopForTask>
    29bc:	50 90 75 31 	lds	r5, 0x3175	; 0x803175 <portStackTopForTask+0x1>
    29c0:	ff ef       	ldi	r31, 0xFF	; 255
    29c2:	4f 1a       	sub	r4, r31
    29c4:	5f 0a       	sbc	r5, r31
    29c6:	40 92 74 31 	sts	0x3174, r4	; 0x803174 <portStackTopForTask>
    29ca:	50 92 75 31 	sts	0x3175, r5	; 0x803175 <portStackTopForTask+0x1>
    29ce:	f4 01       	movw	r30, r8
    29d0:	42 86       	std	Z+10, r4	; 0x0a
    29d2:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    29d4:	16 86       	std	Z+14, r1	; 0x0e
    29d6:	17 86       	std	Z+15, r1	; 0x0f
    29d8:	10 8a       	std	Z+16, r1	; 0x10
    29da:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    29dc:	61 14       	cp	r6, r1
    29de:	71 04       	cpc	r7, r1
    29e0:	09 f4       	brne	.+2      	; 0x29e4 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    29e2:	44 c0       	rjmp	.+136    	; 0x2a6c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    29e4:	81 30       	cpi	r24, 0x01	; 1
    29e6:	79 f5       	brne	.+94     	; 0x2a46 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    29e8:	6a e0       	ldi	r22, 0x0A	; 10
    29ea:	c3 01       	movw	r24, r6
    29ec:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    29f0:	7c 01       	movw	r14, r24
    29f2:	65 e9       	ldi	r22, 0x95	; 149
    29f4:	74 e0       	ldi	r23, 0x04	; 4
    29f6:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    29fa:	be 01       	movw	r22, r28
    29fc:	6f 5f       	subi	r22, 0xFF	; 255
    29fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2a00:	c7 01       	movw	r24, r14
    2a02:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2a06:	6a e0       	ldi	r22, 0x0A	; 10
    2a08:	c7 01       	movw	r24, r14
    2a0a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2a0e:	7c 01       	movw	r14, r24
    2a10:	6c e8       	ldi	r22, 0x8C	; 140
    2a12:	74 e0       	ldi	r23, 0x04	; 4
    2a14:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a18:	6a e0       	ldi	r22, 0x0A	; 10
    2a1a:	c7 01       	movw	r24, r14
    2a1c:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2a20:	7c 01       	movw	r14, r24
    2a22:	6e e7       	ldi	r22, 0x7E	; 126
    2a24:	74 e0       	ldi	r23, 0x04	; 4
    2a26:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2a2a:	63 e0       	ldi	r22, 0x03	; 3
    2a2c:	c7 01       	movw	r24, r14
    2a2e:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2a32:	b2 01       	movw	r22, r4
    2a34:	0e 94 66 1a 	call	0x34cc	; 0x34cc <_ZN8emstreamlsEj>
    2a38:	62 e0       	ldi	r22, 0x02	; 2
    2a3a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2a3e:	66 e0       	ldi	r22, 0x06	; 6
    2a40:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2a44:	13 c0       	rjmp	.+38     	; 0x2a6c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a46:	6a e0       	ldi	r22, 0x0A	; 10
    2a48:	c3 01       	movw	r24, r6
    2a4a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2a4e:	4c 01       	movw	r8, r24
    2a50:	69 e6       	ldi	r22, 0x69	; 105
    2a52:	74 e0       	ldi	r23, 0x04	; 4
    2a54:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2a58:	be 01       	movw	r22, r28
    2a5a:	6f 5f       	subi	r22, 0xFF	; 255
    2a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a5e:	c4 01       	movw	r24, r8
    2a60:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2a64:	66 e0       	ldi	r22, 0x06	; 6
    2a66:	c4 01       	movw	r24, r8
    2a68:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a6c:	2a 96       	adiw	r28, 0x0a	; 10
    2a6e:	cd bf       	out	0x3d, r28	; 61
    2a70:	de bf       	out	0x3e, r29	; 62
    2a72:	df 91       	pop	r29
    2a74:	cf 91       	pop	r28
    2a76:	1f 91       	pop	r17
    2a78:	0f 91       	pop	r16
    2a7a:	ff 90       	pop	r15
    2a7c:	ef 90       	pop	r14
    2a7e:	df 90       	pop	r13
    2a80:	cf 90       	pop	r12
    2a82:	bf 90       	pop	r11
    2a84:	af 90       	pop	r10
    2a86:	9f 90       	pop	r9
    2a88:	8f 90       	pop	r8
    2a8a:	7f 90       	pop	r7
    2a8c:	6f 90       	pop	r6
    2a8e:	5f 90       	pop	r5
    2a90:	4f 90       	pop	r4
    2a92:	08 95       	ret

00002a94 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2a94:	cf 92       	push	r12
    2a96:	df 92       	push	r13
    2a98:	ef 92       	push	r14
    2a9a:	ff 92       	push	r15
    2a9c:	0f 93       	push	r16
    2a9e:	1f 93       	push	r17
    2aa0:	cf 93       	push	r28
    2aa2:	df 93       	push	r29
    2aa4:	ec 01       	movw	r28, r24
    2aa6:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2aa8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aaa:	9b 81       	ldd	r25, Y+3	; 0x03
    2aac:	0e 94 56 10 	call	0x20ac	; 0x20ac <pcTaskGetTaskName>
    2ab0:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2ab2:	6a e0       	ldi	r22, 0x0A	; 10
    2ab4:	c7 01       	movw	r24, r14
    2ab6:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2aba:	8c 01       	movw	r16, r24
    2abc:	68 ea       	ldi	r22, 0xA8	; 168
    2abe:	74 e0       	ldi	r23, 0x04	; 4
    2ac0:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2ac4:	6a e0       	ldi	r22, 0x0A	; 10
    2ac6:	c8 01       	movw	r24, r16
    2ac8:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2acc:	8c 01       	movw	r16, r24
    2ace:	61 ea       	ldi	r22, 0xA1	; 161
    2ad0:	74 e0       	ldi	r23, 0x04	; 4
    2ad2:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2ad6:	b6 01       	movw	r22, r12
    2ad8:	c8 01       	movw	r24, r16
    2ada:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2ade:	6a e0       	ldi	r22, 0x0A	; 10
    2ae0:	c8 01       	movw	r24, r16
    2ae2:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2ae6:	8c 01       	movw	r16, r24
    2ae8:	6b e9       	ldi	r22, 0x9B	; 155
    2aea:	74 e0       	ldi	r23, 0x04	; 4
    2aec:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2af0:	66 e0       	ldi	r22, 0x06	; 6
    2af2:	c8 01       	movw	r24, r16
    2af4:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2af8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2afa:	9b 85       	ldd	r25, Y+11	; 0x0b
    2afc:	e8 85       	ldd	r30, Y+8	; 0x08
    2afe:	f9 85       	ldd	r31, Y+9	; 0x09
    2b00:	01 e1       	ldi	r16, 0x11	; 17
    2b02:	21 e0       	ldi	r18, 0x01	; 1
    2b04:	a7 01       	movw	r20, r14
    2b06:	bc 01       	movw	r22, r24
    2b08:	8e 1b       	sub	r24, r30
    2b0a:	9f 0b       	sbc	r25, r31
    2b0c:	0e 94 4c 18 	call	0x3098	; 0x3098 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b10:	8c 81       	ldd	r24, Y+4	; 0x04
    2b12:	9d 81       	ldd	r25, Y+5	; 0x05
    2b14:	00 97       	sbiw	r24, 0x00	; 0
    2b16:	19 f0       	breq	.+6      	; 0x2b1e <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b18:	b7 01       	movw	r22, r14
    2b1a:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b1e:	df 91       	pop	r29
    2b20:	cf 91       	pop	r28
    2b22:	1f 91       	pop	r17
    2b24:	0f 91       	pop	r16
    2b26:	ff 90       	pop	r15
    2b28:	ef 90       	pop	r14
    2b2a:	df 90       	pop	r13
    2b2c:	cf 90       	pop	r12
    2b2e:	08 95       	ret

00002b30 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b30:	0f 93       	push	r16
    2b32:	1f 93       	push	r17
    2b34:	cf 93       	push	r28
    2b36:	df 93       	push	r29
    2b38:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b3a:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <last_created_task_pointer>
    2b3e:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    2b42:	00 97       	sbiw	r24, 0x00	; 0
    2b44:	19 f0       	breq	.+6      	; 0x2b4c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b46:	be 01       	movw	r22, r28
    2b48:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b4c:	6a e0       	ldi	r22, 0x0A	; 10
    2b4e:	ce 01       	movw	r24, r28
    2b50:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2b54:	8c 01       	movw	r16, r24
    2b56:	6e eb       	ldi	r22, 0xBE	; 190
    2b58:	74 e0       	ldi	r23, 0x04	; 4
    2b5a:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2b5e:	6a e0       	ldi	r22, 0x0A	; 10
    2b60:	c8 01       	movw	r24, r16
    2b62:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2b66:	8c 01       	movw	r16, r24
    2b68:	63 eb       	ldi	r22, 0xB3	; 179
    2b6a:	74 e0       	ldi	r23, 0x04	; 4
    2b6c:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2b70:	6a e0       	ldi	r22, 0x0A	; 10
    2b72:	c8 01       	movw	r24, r16
    2b74:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2b78:	8c 01       	movw	r16, r24
    2b7a:	6d ea       	ldi	r22, 0xAD	; 173
    2b7c:	74 e0       	ldi	r23, 0x04	; 4
    2b7e:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2b82:	66 e0       	ldi	r22, 0x06	; 6
    2b84:	c8 01       	movw	r24, r16
    2b86:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2b8a:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <portStackTopForTask>
    2b8e:	90 91 75 31 	lds	r25, 0x3175	; 0x803175 <portStackTopForTask+0x1>
    2b92:	bc 01       	movw	r22, r24
    2b94:	6f 5f       	subi	r22, 0xFF	; 255
    2b96:	7f 4f       	sbci	r23, 0xFF	; 255
    2b98:	01 e1       	ldi	r16, 0x11	; 17
    2b9a:	21 e0       	ldi	r18, 0x01	; 1
    2b9c:	ae 01       	movw	r20, r28
    2b9e:	83 56       	subi	r24, 0x63	; 99
    2ba0:	91 09       	sbc	r25, r1
    2ba2:	0e 94 4c 18 	call	0x3098	; 0x3098 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2ba6:	df 91       	pop	r29
    2ba8:	cf 91       	pop	r28
    2baa:	1f 91       	pop	r17
    2bac:	0f 91       	pop	r16
    2bae:	08 95       	ret

00002bb0 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2bb0:	8f 92       	push	r8
    2bb2:	9f 92       	push	r9
    2bb4:	af 92       	push	r10
    2bb6:	bf 92       	push	r11
    2bb8:	cf 92       	push	r12
    2bba:	df 92       	push	r13
    2bbc:	ef 92       	push	r14
    2bbe:	ff 92       	push	r15
    2bc0:	0f 93       	push	r16
    2bc2:	1f 93       	push	r17
    2bc4:	cf 93       	push	r28
    2bc6:	df 93       	push	r29
    2bc8:	ec 01       	movw	r28, r24
    2bca:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2bcc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bce:	9b 81       	ldd	r25, Y+3	; 0x03
    2bd0:	0e 94 56 10 	call	0x20ac	; 0x20ac <pcTaskGetTaskName>
    2bd4:	bc 01       	movw	r22, r24
    2bd6:	c8 01       	movw	r24, r16
    2bd8:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2bdc:	d8 01       	movw	r26, r16
    2bde:	ed 91       	ld	r30, X+
    2be0:	fc 91       	ld	r31, X
    2be2:	02 80       	ldd	r0, Z+2	; 0x02
    2be4:	f3 81       	ldd	r31, Z+3	; 0x03
    2be6:	e0 2d       	mov	r30, r0
    2be8:	69 e0       	ldi	r22, 0x09	; 9
    2bea:	c8 01       	movw	r24, r16
    2bec:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2bee:	8a 81       	ldd	r24, Y+2	; 0x02
    2bf0:	9b 81       	ldd	r25, Y+3	; 0x03
    2bf2:	0e 94 56 10 	call	0x20ac	; 0x20ac <pcTaskGetTaskName>
    2bf6:	fc 01       	movw	r30, r24
    2bf8:	01 90       	ld	r0, Z+
    2bfa:	00 20       	and	r0, r0
    2bfc:	e9 f7       	brne	.-6      	; 0x2bf8 <_ZN8frt_task12print_statusER8emstream+0x48>
    2bfe:	31 97       	sbiw	r30, 0x01	; 1
    2c00:	e8 1b       	sub	r30, r24
    2c02:	f9 0b       	sbc	r31, r25
    2c04:	38 97       	sbiw	r30, 0x08	; 8
    2c06:	48 f4       	brcc	.+18     	; 0x2c1a <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2c08:	d8 01       	movw	r26, r16
    2c0a:	ed 91       	ld	r30, X+
    2c0c:	fc 91       	ld	r31, X
    2c0e:	02 80       	ldd	r0, Z+2	; 0x02
    2c10:	f3 81       	ldd	r31, Z+3	; 0x03
    2c12:	e0 2d       	mov	r30, r0
    2c14:	69 e0       	ldi	r22, 0x09	; 9
    2c16:	c8 01       	movw	r24, r16
    2c18:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c1a:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c1c:	df 84       	ldd	r13, Y+15	; 0x0f
    2c1e:	e8 88       	ldd	r14, Y+16	; 0x10
    2c20:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c22:	a8 84       	ldd	r10, Y+8	; 0x08
    2c24:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c26:	8a 81       	ldd	r24, Y+2	; 0x02
    2c28:	9b 81       	ldd	r25, Y+3	; 0x03
    2c2a:	0e 94 c9 13 	call	0x2792	; 0x2792 <uxTaskGetStackHighWaterMark>
    2c2e:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c30:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c32:	8a 81       	ldd	r24, Y+2	; 0x02
    2c34:	9b 81       	ldd	r25, Y+3	; 0x03
    2c36:	0e 94 01 10 	call	0x2002	; 0x2002 <uxTaskPriorityGet>
    2c3a:	68 2f       	mov	r22, r24
    2c3c:	c8 01       	movw	r24, r16
    2c3e:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
    2c42:	6a e0       	ldi	r22, 0x0A	; 10
    2c44:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2c48:	ec 01       	movw	r28, r24
    2c4a:	63 e3       	ldi	r22, 0x33	; 51
    2c4c:	75 e0       	ldi	r23, 0x05	; 5
    2c4e:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c52:	68 2d       	mov	r22, r8
    2c54:	ce 01       	movw	r24, r28
    2c56:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c5a:	6a e0       	ldi	r22, 0x0A	; 10
    2c5c:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2c60:	ec 01       	movw	r28, r24
    2c62:	61 e3       	ldi	r22, 0x31	; 49
    2c64:	75 e0       	ldi	r23, 0x05	; 5
    2c66:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2c6a:	69 2d       	mov	r22, r9
    2c6c:	ce 01       	movw	r24, r28
    2c6e:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
    2c72:	6a e0       	ldi	r22, 0x0A	; 10
    2c74:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2c78:	ec 01       	movw	r28, r24
    2c7a:	6f e2       	ldi	r22, 0x2F	; 47
    2c7c:	75 e0       	ldi	r23, 0x05	; 5
    2c7e:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2c82:	b5 01       	movw	r22, r10
    2c84:	ce 01       	movw	r24, r28
    2c86:	0e 94 66 1a 	call	0x34cc	; 0x34cc <_ZN8emstreamlsEj>
    2c8a:	6a e0       	ldi	r22, 0x0A	; 10
    2c8c:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2c90:	ec 01       	movw	r28, r24
    2c92:	6d e2       	ldi	r22, 0x2D	; 45
    2c94:	75 e0       	ldi	r23, 0x05	; 5
    2c96:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2c9a:	6a e0       	ldi	r22, 0x0A	; 10
    2c9c:	ce 01       	movw	r24, r28
    2c9e:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2ca2:	ec 01       	movw	r28, r24
    2ca4:	6b e2       	ldi	r22, 0x2B	; 43
    2ca6:	75 e0       	ldi	r23, 0x05	; 5
    2ca8:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2cac:	b7 01       	movw	r22, r14
    2cae:	a6 01       	movw	r20, r12
    2cb0:	ce 01       	movw	r24, r28
    2cb2:	0e 94 9a 1a 	call	0x3534	; 0x3534 <_ZN8emstreamlsEm>
}
    2cb6:	df 91       	pop	r29
    2cb8:	cf 91       	pop	r28
    2cba:	1f 91       	pop	r17
    2cbc:	0f 91       	pop	r16
    2cbe:	ff 90       	pop	r15
    2cc0:	ef 90       	pop	r14
    2cc2:	df 90       	pop	r13
    2cc4:	cf 90       	pop	r12
    2cc6:	bf 90       	pop	r11
    2cc8:	af 90       	pop	r10
    2cca:	9f 90       	pop	r9
    2ccc:	8f 90       	pop	r8
    2cce:	08 95       	ret

00002cd0 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2cd0:	cf 93       	push	r28
    2cd2:	df 93       	push	r29
    2cd4:	ec 01       	movw	r28, r24
    2cd6:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2cd8:	db 01       	movw	r26, r22
    2cda:	ed 91       	ld	r30, X+
    2cdc:	fc 91       	ld	r31, X
    2cde:	02 80       	ldd	r0, Z+2	; 0x02
    2ce0:	f3 81       	ldd	r31, Z+3	; 0x03
    2ce2:	e0 2d       	mov	r30, r0
    2ce4:	be 01       	movw	r22, r28
    2ce6:	19 95       	eicall
	return (ser_dev);
}
    2ce8:	ce 01       	movw	r24, r28
    2cea:	df 91       	pop	r29
    2cec:	cf 91       	pop	r28
    2cee:	08 95       	ret

00002cf0 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2cf0:	0f 93       	push	r16
    2cf2:	1f 93       	push	r17
    2cf4:	cf 93       	push	r28
    2cf6:	df 93       	push	r29
    2cf8:	ec 01       	movw	r28, r24
    2cfa:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2cfc:	bc 01       	movw	r22, r24
    2cfe:	c8 01       	movw	r24, r16
    2d00:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <_ZlsR8emstreamR8frt_task>
    2d04:	66 e0       	ldi	r22, 0x06	; 6
    2d06:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d0a:	8c 81       	ldd	r24, Y+4	; 0x04
    2d0c:	9d 81       	ldd	r25, Y+5	; 0x05
    2d0e:	00 97       	sbiw	r24, 0x00	; 0
    2d10:	19 f0       	breq	.+6      	; 0x2d18 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d12:	b8 01       	movw	r22, r16
    2d14:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d18:	df 91       	pop	r29
    2d1a:	cf 91       	pop	r28
    2d1c:	1f 91       	pop	r17
    2d1e:	0f 91       	pop	r16
    2d20:	08 95       	ret

00002d22 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d22:	0f 93       	push	r16
    2d24:	1f 93       	push	r17
    2d26:	cf 93       	push	r28
    2d28:	df 93       	push	r29
    2d2a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d2c:	6a e0       	ldi	r22, 0x0A	; 10
    2d2e:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2d32:	8c 01       	movw	r16, r24
    2d34:	60 e2       	ldi	r22, 0x20	; 32
    2d36:	75 e0       	ldi	r23, 0x05	; 5
    2d38:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d3c:	6a e0       	ldi	r22, 0x0A	; 10
    2d3e:	c8 01       	movw	r24, r16
    2d40:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2d44:	8c 01       	movw	r16, r24
    2d46:	69 e1       	ldi	r22, 0x19	; 25
    2d48:	75 e0       	ldi	r23, 0x05	; 5
    2d4a:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d4e:	66 e0       	ldi	r22, 0x06	; 6
    2d50:	c8 01       	movw	r24, r16
    2d52:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d56:	6a e0       	ldi	r22, 0x0A	; 10
    2d58:	ce 01       	movw	r24, r28
    2d5a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2d5e:	8c 01       	movw	r16, r24
    2d60:	68 e0       	ldi	r22, 0x08	; 8
    2d62:	75 e0       	ldi	r23, 0x05	; 5
    2d64:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2d68:	6a e0       	ldi	r22, 0x0A	; 10
    2d6a:	c8 01       	movw	r24, r16
    2d6c:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2d70:	8c 01       	movw	r16, r24
    2d72:	6c ef       	ldi	r22, 0xFC	; 252
    2d74:	74 e0       	ldi	r23, 0x04	; 4
    2d76:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2d7a:	6a e0       	ldi	r22, 0x0A	; 10
    2d7c:	c8 01       	movw	r24, r16
    2d7e:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2d82:	8c 01       	movw	r16, r24
    2d84:	66 ef       	ldi	r22, 0xF6	; 246
    2d86:	74 e0       	ldi	r23, 0x04	; 4
    2d88:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2d8c:	66 e0       	ldi	r22, 0x06	; 6
    2d8e:	c8 01       	movw	r24, r16
    2d90:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2d94:	6a e0       	ldi	r22, 0x0A	; 10
    2d96:	ce 01       	movw	r24, r28
    2d98:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2d9c:	8c 01       	movw	r16, r24
    2d9e:	65 ee       	ldi	r22, 0xE5	; 229
    2da0:	74 e0       	ldi	r23, 0x04	; 4
    2da2:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2da6:	6a e0       	ldi	r22, 0x0A	; 10
    2da8:	c8 01       	movw	r24, r16
    2daa:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2dae:	8c 01       	movw	r16, r24
    2db0:	69 ed       	ldi	r22, 0xD9	; 217
    2db2:	74 e0       	ldi	r23, 0x04	; 4
    2db4:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2db8:	6a e0       	ldi	r22, 0x0A	; 10
    2dba:	c8 01       	movw	r24, r16
    2dbc:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2dc0:	8c 01       	movw	r16, r24
    2dc2:	63 ed       	ldi	r22, 0xD3	; 211
    2dc4:	74 e0       	ldi	r23, 0x04	; 4
    2dc6:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2dca:	66 e0       	ldi	r22, 0x06	; 6
    2dcc:	c8 01       	movw	r24, r16
    2dce:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2dd2:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <last_created_task_pointer>
    2dd6:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    2dda:	00 97       	sbiw	r24, 0x00	; 0
    2ddc:	19 f0       	breq	.+6      	; 0x2de4 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2dde:	be 01       	movw	r22, r28
    2de0:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2de4:	0e 94 5e 10 	call	0x20bc	; 0x20bc <xTaskGetIdleTaskHandle>
    2de8:	0e 94 c9 13 	call	0x2792	; 0x2792 <uxTaskGetStackHighWaterMark>
    2dec:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2dee:	6a e0       	ldi	r22, 0x0A	; 10
    2df0:	ce 01       	movw	r24, r28
    2df2:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2df6:	ec 01       	movw	r28, r24
    2df8:	68 ec       	ldi	r22, 0xC8	; 200
    2dfa:	74 e0       	ldi	r23, 0x04	; 4
    2dfc:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e00:	61 2f       	mov	r22, r17
    2e02:	ce 01       	movw	r24, r28
    2e04:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2e08:	6a e0       	ldi	r22, 0x0A	; 10
    2e0a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2e0e:	ec 01       	movw	r28, r24
    2e10:	66 ec       	ldi	r22, 0xC6	; 198
    2e12:	74 e0       	ldi	r23, 0x04	; 4
    2e14:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    2e18:	64 e6       	ldi	r22, 0x64	; 100
    2e1a:	70 e0       	ldi	r23, 0x00	; 0
    2e1c:	ce 01       	movw	r24, r28
    2e1e:	0e 94 66 1a 	call	0x34cc	; 0x34cc <_ZN8emstreamlsEj>
    2e22:	6a e0       	ldi	r22, 0x0A	; 10
    2e24:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    2e28:	ec 01       	movw	r28, r24
    2e2a:	63 ec       	ldi	r22, 0xC3	; 195
    2e2c:	74 e0       	ldi	r23, 0x04	; 4
    2e2e:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e32:	66 e0       	ldi	r22, 0x06	; 6
    2e34:	ce 01       	movw	r24, r28
    2e36:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
}
    2e3a:	df 91       	pop	r29
    2e3c:	cf 91       	pop	r28
    2e3e:	1f 91       	pop	r17
    2e40:	0f 91       	pop	r16
    2e42:	08 95       	ret

00002e44 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e44:	0f 93       	push	r16
    2e46:	cf 93       	push	r28
    2e48:	df 93       	push	r29
    2e4a:	1f 92       	push	r1
    2e4c:	cd b7       	in	r28, 0x3d	; 61
    2e4e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e50:	00 e0       	ldi	r16, 0x00	; 0
    2e52:	2f ef       	ldi	r18, 0xFF	; 255
    2e54:	3f ef       	ldi	r19, 0xFF	; 255
    2e56:	a9 01       	movw	r20, r18
    2e58:	be 01       	movw	r22, r28
    2e5a:	6f 5f       	subi	r22, 0xFF	; 255
    2e5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e5e:	fc 01       	movw	r30, r24
    2e60:	80 85       	ldd	r24, Z+8	; 0x08
    2e62:	91 85       	ldd	r25, Z+9	; 0x09
    2e64:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <xQueueGenericReceive>
    2e68:	81 30       	cpi	r24, 0x01	; 1
    2e6a:	19 f4       	brne	.+6      	; 0x2e72 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e6c:	89 81       	ldd	r24, Y+1	; 0x01
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
    2e70:	02 c0       	rjmp	.+4      	; 0x2e76 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2e72:	8f ef       	ldi	r24, 0xFF	; 255
    2e74:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2e76:	0f 90       	pop	r0
    2e78:	df 91       	pop	r29
    2e7a:	cf 91       	pop	r28
    2e7c:	0f 91       	pop	r16
    2e7e:	08 95       	ret

00002e80 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2e80:	fc 01       	movw	r30, r24
    2e82:	80 85       	ldd	r24, Z+8	; 0x08
    2e84:	91 85       	ldd	r25, Z+9	; 0x09
    2e86:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <uxQueueMessagesWaiting>
    2e8a:	91 e0       	ldi	r25, 0x01	; 1
    2e8c:	81 11       	cpse	r24, r1
    2e8e:	01 c0       	rjmp	.+2      	; 0x2e92 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2e90:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2e92:	89 2f       	mov	r24, r25
    2e94:	08 95       	ret

00002e96 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2e96:	0f 93       	push	r16
    2e98:	cf 93       	push	r28
    2e9a:	df 93       	push	r29
    2e9c:	1f 92       	push	r1
    2e9e:	cd b7       	in	r28, 0x3d	; 61
    2ea0:	de b7       	in	r29, 0x3e	; 62
    2ea2:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2ea4:	fc 01       	movw	r30, r24
    2ea6:	22 85       	ldd	r18, Z+10	; 0x0a
    2ea8:	33 85       	ldd	r19, Z+11	; 0x0b
    2eaa:	44 85       	ldd	r20, Z+12	; 0x0c
    2eac:	55 85       	ldd	r21, Z+13	; 0x0d
    2eae:	00 e0       	ldi	r16, 0x00	; 0
    2eb0:	be 01       	movw	r22, r28
    2eb2:	6f 5f       	subi	r22, 0xFF	; 255
    2eb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2eb6:	80 85       	ldd	r24, Z+8	; 0x08
    2eb8:	91 85       	ldd	r25, Z+9	; 0x09
    2eba:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <xQueueGenericSend>
    2ebe:	91 e0       	ldi	r25, 0x01	; 1
    2ec0:	81 11       	cpse	r24, r1
    2ec2:	01 c0       	rjmp	.+2      	; 0x2ec6 <_ZN14frt_text_queue7putcharEc+0x30>
    2ec4:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2ec6:	89 2f       	mov	r24, r25
    2ec8:	0f 90       	pop	r0
    2eca:	df 91       	pop	r29
    2ecc:	cf 91       	pop	r28
    2ece:	0f 91       	pop	r16
    2ed0:	08 95       	ret

00002ed2 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ed2:	8f 92       	push	r8
    2ed4:	9f 92       	push	r9
    2ed6:	bf 92       	push	r11
    2ed8:	cf 92       	push	r12
    2eda:	df 92       	push	r13
    2edc:	ef 92       	push	r14
    2ede:	ff 92       	push	r15
    2ee0:	0f 93       	push	r16
    2ee2:	1f 93       	push	r17
    2ee4:	cf 93       	push	r28
    2ee6:	df 93       	push	r29
    2ee8:	ec 01       	movw	r28, r24
    2eea:	b6 2e       	mov	r11, r22
    2eec:	4a 01       	movw	r8, r20
    2eee:	68 01       	movw	r12, r16
    2ef0:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2ef2:	0e 94 c2 19 	call	0x3384	; 0x3384 <_ZN8emstreamC1Ev>
    2ef6:	88 e5       	ldi	r24, 0x58	; 88
    2ef8:	90 e2       	ldi	r25, 0x20	; 32
    2efa:	88 83       	st	Y, r24
    2efc:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2efe:	8e 86       	std	Y+14, r8	; 0x0e
    2f00:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f02:	40 e0       	ldi	r20, 0x00	; 0
    2f04:	61 e0       	ldi	r22, 0x01	; 1
    2f06:	8b 2d       	mov	r24, r11
    2f08:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xQueueGenericCreate>
    2f0c:	88 87       	std	Y+8, r24	; 0x08
    2f0e:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f10:	ca 86       	std	Y+10, r12	; 0x0a
    2f12:	db 86       	std	Y+11, r13	; 0x0b
    2f14:	ec 86       	std	Y+12, r14	; 0x0c
    2f16:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f18:	df 91       	pop	r29
    2f1a:	cf 91       	pop	r28
    2f1c:	1f 91       	pop	r17
    2f1e:	0f 91       	pop	r16
    2f20:	ff 90       	pop	r15
    2f22:	ef 90       	pop	r14
    2f24:	df 90       	pop	r13
    2f26:	cf 90       	pop	r12
    2f28:	bf 90       	pop	r11
    2f2a:	9f 90       	pop	r9
    2f2c:	8f 90       	pop	r8
    2f2e:	08 95       	ret

00002f30 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f30:	cf 92       	push	r12
    2f32:	df 92       	push	r13
    2f34:	ef 92       	push	r14
    2f36:	ff 92       	push	r15
    2f38:	cf 93       	push	r28
    2f3a:	df 93       	push	r29
    2f3c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f3e:	68 81       	ld	r22, Y
    2f40:	79 81       	ldd	r23, Y+1	; 0x01
    2f42:	8a 81       	ldd	r24, Y+2	; 0x02
    2f44:	9b 81       	ldd	r25, Y+3	; 0x03
    2f46:	0f 2e       	mov	r0, r31
    2f48:	f8 ee       	ldi	r31, 0xE8	; 232
    2f4a:	cf 2e       	mov	r12, r31
    2f4c:	f3 e0       	ldi	r31, 0x03	; 3
    2f4e:	df 2e       	mov	r13, r31
    2f50:	e1 2c       	mov	r14, r1
    2f52:	f1 2c       	mov	r15, r1
    2f54:	f0 2d       	mov	r31, r0
    2f56:	a7 01       	movw	r20, r14
    2f58:	96 01       	movw	r18, r12
    2f5a:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <__udivmodsi4>
    2f5e:	9b 01       	movw	r18, r22
    2f60:	ac 01       	movw	r20, r24
    2f62:	60 e4       	ldi	r22, 0x40	; 64
    2f64:	72 e4       	ldi	r23, 0x42	; 66
    2f66:	8f e0       	ldi	r24, 0x0F	; 15
    2f68:	90 e0       	ldi	r25, 0x00	; 0
    2f6a:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <__mulsi3>
    2f6e:	a7 01       	movw	r20, r14
    2f70:	96 01       	movw	r18, r12
    2f72:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <__udivmodsi4>
    2f76:	69 01       	movw	r12, r18
    2f78:	7a 01       	movw	r14, r20
    2f7a:	ac 81       	ldd	r26, Y+4	; 0x04
    2f7c:	bd 81       	ldd	r27, Y+5	; 0x05
    2f7e:	20 e4       	ldi	r18, 0x40	; 64
    2f80:	32 e4       	ldi	r19, 0x42	; 66
    2f82:	4f e0       	ldi	r20, 0x0F	; 15
    2f84:	50 e0       	ldi	r21, 0x00	; 0
    2f86:	0e 94 3e 22 	call	0x447c	; 0x447c <__muluhisi3>
    2f8a:	20 e0       	ldi	r18, 0x00	; 0
    2f8c:	38 e4       	ldi	r19, 0x48	; 72
    2f8e:	48 ee       	ldi	r20, 0xE8	; 232
    2f90:	51 e0       	ldi	r21, 0x01	; 1
    2f92:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <__udivmodsi4>
    2f96:	c7 01       	movw	r24, r14
    2f98:	b6 01       	movw	r22, r12
    2f9a:	62 0f       	add	r22, r18
    2f9c:	73 1f       	adc	r23, r19
    2f9e:	84 1f       	adc	r24, r20
    2fa0:	95 1f       	adc	r25, r21
}
    2fa2:	df 91       	pop	r29
    2fa4:	cf 91       	pop	r28
    2fa6:	ff 90       	pop	r15
    2fa8:	ef 90       	pop	r14
    2faa:	df 90       	pop	r13
    2fac:	cf 90       	pop	r12
    2fae:	08 95       	ret

00002fb0 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2fb0:	cf 92       	push	r12
    2fb2:	df 92       	push	r13
    2fb4:	ef 92       	push	r14
    2fb6:	ff 92       	push	r15
    2fb8:	0f 93       	push	r16
    2fba:	1f 93       	push	r17
    2fbc:	cf 93       	push	r28
    2fbe:	df 93       	push	r29
    2fc0:	cd b7       	in	r28, 0x3d	; 61
    2fc2:	de b7       	in	r29, 0x3e	; 62
    2fc4:	2f 97       	sbiw	r28, 0x0f	; 15
    2fc6:	cd bf       	out	0x3d, r28	; 61
    2fc8:	de bf       	out	0x3e, r29	; 62
    2fca:	6c 01       	movw	r12, r24
    2fcc:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2fce:	db 01       	movw	r26, r22
    2fd0:	6d 91       	ld	r22, X+
    2fd2:	7d 91       	ld	r23, X+
    2fd4:	8d 91       	ld	r24, X+
    2fd6:	9c 91       	ld	r25, X
    2fd8:	28 ee       	ldi	r18, 0xE8	; 232
    2fda:	33 e0       	ldi	r19, 0x03	; 3
    2fdc:	40 e0       	ldi	r20, 0x00	; 0
    2fde:	50 e0       	ldi	r21, 0x00	; 0
    2fe0:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <__udivmodsi4>
    2fe4:	ba 01       	movw	r22, r20
    2fe6:	a9 01       	movw	r20, r18
    2fe8:	c6 01       	movw	r24, r12
    2fea:	0e 94 9a 1a 	call	0x3534	; 0x3534 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2fee:	d6 01       	movw	r26, r12
    2ff0:	ed 91       	ld	r30, X+
    2ff2:	fc 91       	ld	r31, X
    2ff4:	02 80       	ldd	r0, Z+2	; 0x02
    2ff6:	f3 81       	ldd	r31, Z+3	; 0x03
    2ff8:	e0 2d       	mov	r30, r0
    2ffa:	6e e2       	ldi	r22, 0x2E	; 46
    2ffc:	c6 01       	movw	r24, r12
    2ffe:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3000:	c8 01       	movw	r24, r16
    3002:	0e 94 98 17 	call	0x2f30	; 0x2f30 <_ZN10time_stamp12get_microsecEv>
    3006:	8e 01       	movw	r16, r28
    3008:	09 5f       	subi	r16, 0xF9	; 249
    300a:	1f 4f       	sbci	r17, 0xFF	; 255
    300c:	fe 01       	movw	r30, r28
    300e:	31 96       	adiw	r30, 0x01	; 1
    3010:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3012:	2a e0       	ldi	r18, 0x0A	; 10
    3014:	30 e0       	ldi	r19, 0x00	; 0
    3016:	40 e0       	ldi	r20, 0x00	; 0
    3018:	50 e0       	ldi	r21, 0x00	; 0
    301a:	0e 94 16 22 	call	0x442c	; 0x442c <__divmodsi4>
    301e:	e6 2f       	mov	r30, r22
    3020:	28 87       	std	Y+8, r18	; 0x08
    3022:	39 87       	std	Y+9, r19	; 0x09
    3024:	4a 87       	std	Y+10, r20	; 0x0a
    3026:	5b 87       	std	Y+11, r21	; 0x0b
    3028:	68 85       	ldd	r22, Y+8	; 0x08
    302a:	79 85       	ldd	r23, Y+9	; 0x09
    302c:	8a 85       	ldd	r24, Y+10	; 0x0a
    302e:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3030:	20 e3       	ldi	r18, 0x30	; 48
    3032:	2e 0f       	add	r18, r30
    3034:	d8 01       	movw	r26, r16
    3036:	2e 93       	st	-X, r18
    3038:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    303a:	ae 15       	cp	r26, r14
    303c:	bf 05       	cpc	r27, r15
    303e:	49 f7       	brne	.-46     	; 0x3012 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3040:	1f 82       	std	Y+7, r1	; 0x07
    3042:	be 01       	movw	r22, r28
    3044:	6f 5f       	subi	r22, 0xFF	; 255
    3046:	7f 4f       	sbci	r23, 0xFF	; 255
    3048:	c6 01       	movw	r24, r12
    304a:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    304e:	c6 01       	movw	r24, r12
    3050:	2f 96       	adiw	r28, 0x0f	; 15
    3052:	cd bf       	out	0x3d, r28	; 61
    3054:	de bf       	out	0x3e, r29	; 62
    3056:	df 91       	pop	r29
    3058:	cf 91       	pop	r28
    305a:	1f 91       	pop	r17
    305c:	0f 91       	pop	r16
    305e:	ff 90       	pop	r15
    3060:	ef 90       	pop	r14
    3062:	df 90       	pop	r13
    3064:	cf 90       	pop	r12
    3066:	08 95       	ret

00003068 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3068:	cf 93       	push	r28
    306a:	df 93       	push	r29
    306c:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    306e:	0f b6       	in	r0, 0x3f	; 63
    3070:	f8 94       	cli
    3072:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3074:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3078:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    307c:	8c 83       	std	Y+4, r24	; 0x04
    307e:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3080:	0e 94 48 10 	call	0x2090	; 0x2090 <xTaskGetTickCount>
    3084:	68 83       	st	Y, r22
    3086:	79 83       	std	Y+1, r23	; 0x01
    3088:	8a 83       	std	Y+2, r24	; 0x02
    308a:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    308c:	0f 90       	pop	r0
    308e:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3090:	ce 01       	movw	r24, r28
    3092:	df 91       	pop	r29
    3094:	cf 91       	pop	r28
    3096:	08 95       	ret

00003098 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3098:	5f 92       	push	r5
    309a:	6f 92       	push	r6
    309c:	7f 92       	push	r7
    309e:	8f 92       	push	r8
    30a0:	9f 92       	push	r9
    30a2:	af 92       	push	r10
    30a4:	bf 92       	push	r11
    30a6:	cf 92       	push	r12
    30a8:	df 92       	push	r13
    30aa:	ef 92       	push	r14
    30ac:	ff 92       	push	r15
    30ae:	0f 93       	push	r16
    30b0:	1f 93       	push	r17
    30b2:	cf 93       	push	r28
    30b4:	df 93       	push	r29
    30b6:	5c 01       	movw	r10, r24
    30b8:	4b 01       	movw	r8, r22
    30ba:	7a 01       	movw	r14, r20
    30bc:	12 2f       	mov	r17, r18
    30be:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    30c0:	63 e0       	ldi	r22, 0x03	; 3
    30c2:	ca 01       	movw	r24, r20
    30c4:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    30c8:	a8 14       	cp	r10, r8
    30ca:	b9 04       	cpc	r11, r9
    30cc:	08 f0       	brcs	.+2      	; 0x30d0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    30ce:	7d c0       	rjmp	.+250    	; 0x31ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30d0:	65 01       	movw	r12, r10
    30d2:	84 e1       	ldi	r24, 0x14	; 20
    30d4:	c8 0e       	add	r12, r24
    30d6:	d1 1c       	adc	r13, r1
    30d8:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    30da:	6a 2c       	mov	r6, r10
    30dc:	5b 2c       	mov	r5, r11
    30de:	b5 01       	movw	r22, r10
    30e0:	c7 01       	movw	r24, r14
    30e2:	0e 94 66 1a 	call	0x34cc	; 0x34cc <_ZN8emstreamlsEj>
    30e6:	6a e0       	ldi	r22, 0x0A	; 10
    30e8:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    30ec:	65 e4       	ldi	r22, 0x45	; 69
    30ee:	75 e0       	ldi	r23, 0x05	; 5
    30f0:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    30f4:	11 23       	and	r17, r17
    30f6:	09 f4       	brne	.+2      	; 0x30fa <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    30f8:	6d c0       	rjmp	.+218    	; 0x31d4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    30fa:	00 23       	and	r16, r16
    30fc:	09 f4       	brne	.+2      	; 0x3100 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    30fe:	6a c0       	rjmp	.+212    	; 0x31d4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3100:	6a e0       	ldi	r22, 0x0A	; 10
    3102:	c7 01       	movw	r24, r14
    3104:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    3108:	60 e4       	ldi	r22, 0x40	; 64
    310a:	75 e0       	ldi	r23, 0x05	; 5
    310c:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    3110:	61 c0       	rjmp	.+194    	; 0x31d4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3112:	11 23       	and	r17, r17
    3114:	71 f0       	breq	.+28     	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3116:	01 11       	cpse	r16, r1
    3118:	0c c0       	rjmp	.+24     	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    311a:	88 81       	ld	r24, Y
    311c:	87 15       	cp	r24, r7
    311e:	49 f0       	breq	.+18     	; 0x3132 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3120:	6a e0       	ldi	r22, 0x0A	; 10
    3122:	c7 01       	movw	r24, r14
    3124:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    3128:	6b e3       	ldi	r22, 0x3B	; 59
    312a:	75 e0       	ldi	r23, 0x05	; 5
    312c:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3130:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3132:	69 91       	ld	r22, Y+
    3134:	c7 01       	movw	r24, r14
    3136:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    313a:	dc 01       	movw	r26, r24
    313c:	ed 91       	ld	r30, X+
    313e:	fc 91       	ld	r31, X
    3140:	02 80       	ldd	r0, Z+2	; 0x02
    3142:	f3 81       	ldd	r31, Z+3	; 0x03
    3144:	e0 2d       	mov	r30, r0
    3146:	60 e2       	ldi	r22, 0x20	; 32
    3148:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    314a:	cc 16       	cp	r12, r28
    314c:	dd 06       	cpc	r13, r29
    314e:	09 f7       	brne	.-62     	; 0x3112 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3150:	11 23       	and	r17, r17
    3152:	89 f0       	breq	.+34     	; 0x3176 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3154:	6a e0       	ldi	r22, 0x0A	; 10
    3156:	c7 01       	movw	r24, r14
    3158:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    315c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    315e:	65 e3       	ldi	r22, 0x35	; 53
    3160:	75 e0       	ldi	r23, 0x05	; 5
    3162:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3166:	e8 81       	ld	r30, Y
    3168:	f9 81       	ldd	r31, Y+1	; 0x01
    316a:	02 80       	ldd	r0, Z+2	; 0x02
    316c:	f3 81       	ldd	r31, Z+3	; 0x03
    316e:	e0 2d       	mov	r30, r0
    3170:	60 e2       	ldi	r22, 0x20	; 32
    3172:	ce 01       	movw	r24, r28
    3174:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3176:	c6 2d       	mov	r28, r6
    3178:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    317a:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    317c:	80 ee       	ldi	r24, 0xE0	; 224
    317e:	86 0f       	add	r24, r22
    3180:	8f 35       	cpi	r24, 0x5F	; 95
    3182:	48 f4       	brcc	.+18     	; 0x3196 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3184:	d7 01       	movw	r26, r14
    3186:	ed 91       	ld	r30, X+
    3188:	fc 91       	ld	r31, X
    318a:	02 80       	ldd	r0, Z+2	; 0x02
    318c:	f3 81       	ldd	r31, Z+3	; 0x03
    318e:	e0 2d       	mov	r30, r0
    3190:	c7 01       	movw	r24, r14
    3192:	19 95       	eicall
    3194:	09 c0       	rjmp	.+18     	; 0x31a8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3196:	d7 01       	movw	r26, r14
    3198:	ed 91       	ld	r30, X+
    319a:	fc 91       	ld	r31, X
    319c:	02 80       	ldd	r0, Z+2	; 0x02
    319e:	f3 81       	ldd	r31, Z+3	; 0x03
    31a0:	e0 2d       	mov	r30, r0
    31a2:	6e e2       	ldi	r22, 0x2E	; 46
    31a4:	c7 01       	movw	r24, r14
    31a6:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    31a8:	cc 16       	cp	r12, r28
    31aa:	dd 06       	cpc	r13, r29
    31ac:	31 f7       	brne	.-52     	; 0x317a <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31ae:	b4 e1       	ldi	r27, 0x14	; 20
    31b0:	ab 0e       	add	r10, r27
    31b2:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31b4:	66 e0       	ldi	r22, 0x06	; 6
    31b6:	c7 01       	movw	r24, r14
    31b8:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    31bc:	84 e1       	ldi	r24, 0x14	; 20
    31be:	c8 0e       	add	r12, r24
    31c0:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31c2:	a8 14       	cp	r10, r8
    31c4:	b9 04       	cpc	r11, r9
    31c6:	08 f4       	brcc	.+2      	; 0x31ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31c8:	88 cf       	rjmp	.-240    	; 0x30da <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    31ca:	62 e0       	ldi	r22, 0x02	; 2
    31cc:	c7 01       	movw	r24, r14
    31ce:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
}
    31d2:	03 c0       	rjmp	.+6      	; 0x31da <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31d4:	c6 2d       	mov	r28, r6
    31d6:	d5 2d       	mov	r29, r5
    31d8:	9c cf       	rjmp	.-200    	; 0x3112 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    31da:	df 91       	pop	r29
    31dc:	cf 91       	pop	r28
    31de:	1f 91       	pop	r17
    31e0:	0f 91       	pop	r16
    31e2:	ff 90       	pop	r15
    31e4:	ef 90       	pop	r14
    31e6:	df 90       	pop	r13
    31e8:	cf 90       	pop	r12
    31ea:	bf 90       	pop	r11
    31ec:	af 90       	pop	r10
    31ee:	9f 90       	pop	r9
    31f0:	8f 90       	pop	r8
    31f2:	7f 90       	pop	r7
    31f4:	6f 90       	pop	r6
    31f6:	5f 90       	pop	r5
    31f8:	08 95       	ret

000031fa <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    31fa:	0e 94 2c 09 	call	0x1258	; 0x1258 <pvPortMalloc>
    31fe:	08 95       	ret

00003200 <_ZdlPv>:
    3200:	00 97       	sbiw	r24, 0x00	; 0
    3202:	11 f0       	breq	.+4      	; 0x3208 <_ZdlPv+0x8>
    3204:	0e 94 c6 09 	call	0x138c	; 0x138c <vPortFree>
    3208:	08 95       	ret

0000320a <_Znaj>:
    320a:	0e 94 2c 09 	call	0x1258	; 0x1258 <pvPortMalloc>
    320e:	08 95       	ret

00003210 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3210:	08 95       	ret

00003212 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3212:	cf 93       	push	r28
    3214:	df 93       	push	r29
    3216:	fc 01       	movw	r30, r24
    3218:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    321a:	40 3a       	cpi	r20, 0xA0	; 160
    321c:	68 e0       	ldi	r22, 0x08	; 8
    321e:	56 07       	cpc	r21, r22
    3220:	49 f4       	brne	.+18     	; 0x3234 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3222:	80 e4       	ldi	r24, 0x40	; 64
    3224:	96 e0       	ldi	r25, 0x06	; 6
    3226:	82 83       	std	Z+2, r24	; 0x02
    3228:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    322a:	82 e0       	ldi	r24, 0x02	; 2
    322c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    322e:	83 e0       	ldi	r24, 0x03	; 3
    3230:	85 83       	std	Z+5, r24	; 0x05
    3232:	4c c0       	rjmp	.+152    	; 0x32cc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3234:	40 3b       	cpi	r20, 0xB0	; 176
    3236:	78 e0       	ldi	r23, 0x08	; 8
    3238:	57 07       	cpc	r21, r23
    323a:	49 f4       	brne	.+18     	; 0x324e <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    323c:	80 e4       	ldi	r24, 0x40	; 64
    323e:	96 e0       	ldi	r25, 0x06	; 6
    3240:	82 83       	std	Z+2, r24	; 0x02
    3242:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3244:	86 e0       	ldi	r24, 0x06	; 6
    3246:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3248:	87 e0       	ldi	r24, 0x07	; 7
    324a:	85 83       	std	Z+5, r24	; 0x05
    324c:	3f c0       	rjmp	.+126    	; 0x32cc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    324e:	40 3a       	cpi	r20, 0xA0	; 160
    3250:	89 e0       	ldi	r24, 0x09	; 9
    3252:	58 07       	cpc	r21, r24
    3254:	49 f4       	brne	.+18     	; 0x3268 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3256:	80 e6       	ldi	r24, 0x60	; 96
    3258:	96 e0       	ldi	r25, 0x06	; 6
    325a:	82 83       	std	Z+2, r24	; 0x02
    325c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    325e:	82 e0       	ldi	r24, 0x02	; 2
    3260:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3262:	83 e0       	ldi	r24, 0x03	; 3
    3264:	85 83       	std	Z+5, r24	; 0x05
    3266:	32 c0       	rjmp	.+100    	; 0x32cc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3268:	40 3b       	cpi	r20, 0xB0	; 176
    326a:	69 e0       	ldi	r22, 0x09	; 9
    326c:	56 07       	cpc	r21, r22
    326e:	49 f4       	brne	.+18     	; 0x3282 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3270:	80 e6       	ldi	r24, 0x60	; 96
    3272:	96 e0       	ldi	r25, 0x06	; 6
    3274:	82 83       	std	Z+2, r24	; 0x02
    3276:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3278:	86 e0       	ldi	r24, 0x06	; 6
    327a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    327c:	87 e0       	ldi	r24, 0x07	; 7
    327e:	85 83       	std	Z+5, r24	; 0x05
    3280:	25 c0       	rjmp	.+74     	; 0x32cc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3282:	40 3a       	cpi	r20, 0xA0	; 160
    3284:	7a e0       	ldi	r23, 0x0A	; 10
    3286:	57 07       	cpc	r21, r23
    3288:	49 f4       	brne	.+18     	; 0x329c <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    328a:	80 e8       	ldi	r24, 0x80	; 128
    328c:	96 e0       	ldi	r25, 0x06	; 6
    328e:	82 83       	std	Z+2, r24	; 0x02
    3290:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3292:	82 e0       	ldi	r24, 0x02	; 2
    3294:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3296:	83 e0       	ldi	r24, 0x03	; 3
    3298:	85 83       	std	Z+5, r24	; 0x05
    329a:	18 c0       	rjmp	.+48     	; 0x32cc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    329c:	40 3b       	cpi	r20, 0xB0	; 176
    329e:	8a e0       	ldi	r24, 0x0A	; 10
    32a0:	58 07       	cpc	r21, r24
    32a2:	49 f4       	brne	.+18     	; 0x32b6 <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    32a4:	80 e8       	ldi	r24, 0x80	; 128
    32a6:	96 e0       	ldi	r25, 0x06	; 6
    32a8:	82 83       	std	Z+2, r24	; 0x02
    32aa:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    32ac:	86 e0       	ldi	r24, 0x06	; 6
    32ae:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32b0:	87 e0       	ldi	r24, 0x07	; 7
    32b2:	85 83       	std	Z+5, r24	; 0x05
    32b4:	0b c0       	rjmp	.+22     	; 0x32cc <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    32b6:	40 3a       	cpi	r20, 0xA0	; 160
    32b8:	5b 40       	sbci	r21, 0x0B	; 11
    32ba:	41 f4       	brne	.+16     	; 0x32cc <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    32bc:	80 ea       	ldi	r24, 0xA0	; 160
    32be:	96 e0       	ldi	r25, 0x06	; 6
    32c0:	82 83       	std	Z+2, r24	; 0x02
    32c2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32c4:	82 e0       	ldi	r24, 0x02	; 2
    32c6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32c8:	83 e0       	ldi	r24, 0x03	; 3
    32ca:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    32cc:	a6 83       	std	Z+6, r26	; 0x06
    32ce:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    32d0:	cd 01       	movw	r24, r26
    32d2:	01 96       	adiw	r24, 0x01	; 1
    32d4:	80 87       	std	Z+8, r24	; 0x08
    32d6:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    32d8:	03 96       	adiw	r24, 0x03	; 3
    32da:	82 87       	std	Z+10, r24	; 0x0a
    32dc:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    32de:	25 81       	ldd	r18, Z+5	; 0x05
    32e0:	c2 81       	ldd	r28, Z+2	; 0x02
    32e2:	d3 81       	ldd	r29, Z+3	; 0x03
    32e4:	4c 81       	ldd	r20, Y+4	; 0x04
    32e6:	81 e0       	ldi	r24, 0x01	; 1
    32e8:	90 e0       	ldi	r25, 0x00	; 0
    32ea:	bc 01       	movw	r22, r24
    32ec:	02 c0       	rjmp	.+4      	; 0x32f2 <_ZN7base232C1EjP12USART_struct+0xe0>
    32ee:	66 0f       	add	r22, r22
    32f0:	77 1f       	adc	r23, r23
    32f2:	2a 95       	dec	r18
    32f4:	e2 f7       	brpl	.-8      	; 0x32ee <_ZN7base232C1EjP12USART_struct+0xdc>
    32f6:	9b 01       	movw	r18, r22
    32f8:	24 2b       	or	r18, r20
    32fa:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    32fc:	25 81       	ldd	r18, Z+5	; 0x05
    32fe:	c2 81       	ldd	r28, Z+2	; 0x02
    3300:	d3 81       	ldd	r29, Z+3	; 0x03
    3302:	48 81       	ld	r20, Y
    3304:	bc 01       	movw	r22, r24
    3306:	02 c0       	rjmp	.+4      	; 0x330c <_ZN7base232C1EjP12USART_struct+0xfa>
    3308:	66 0f       	add	r22, r22
    330a:	77 1f       	adc	r23, r23
    330c:	2a 95       	dec	r18
    330e:	e2 f7       	brpl	.-8      	; 0x3308 <_ZN7base232C1EjP12USART_struct+0xf6>
    3310:	9b 01       	movw	r18, r22
    3312:	24 2b       	or	r18, r20
    3314:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3316:	34 81       	ldd	r19, Z+4	; 0x04
    3318:	c2 81       	ldd	r28, Z+2	; 0x02
    331a:	d3 81       	ldd	r29, Z+3	; 0x03
    331c:	28 81       	ld	r18, Y
    331e:	02 c0       	rjmp	.+4      	; 0x3324 <_ZN7base232C1EjP12USART_struct+0x112>
    3320:	88 0f       	add	r24, r24
    3322:	99 1f       	adc	r25, r25
    3324:	3a 95       	dec	r19
    3326:	e2 f7       	brpl	.-8      	; 0x3320 <_ZN7base232C1EjP12USART_struct+0x10e>
    3328:	80 95       	com	r24
    332a:	90 95       	com	r25
    332c:	82 23       	and	r24, r18
    332e:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3330:	80 e1       	ldi	r24, 0x10	; 16
    3332:	13 96       	adiw	r26, 0x03	; 3
    3334:	8c 93       	st	X, r24
    3336:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3338:	83 e0       	ldi	r24, 0x03	; 3
    333a:	15 96       	adiw	r26, 0x05	; 5
    333c:	8c 93       	st	X, r24
    333e:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3340:	80 ef       	ldi	r24, 0xF0	; 240
    3342:	17 96       	adiw	r26, 0x07	; 7
    3344:	8c 93       	st	X, r24
    3346:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3348:	81 e2       	ldi	r24, 0x21	; 33
    334a:	16 96       	adiw	r26, 0x06	; 6
    334c:	8c 93       	st	X, r24
    334e:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3350:	88 e1       	ldi	r24, 0x18	; 24
    3352:	14 96       	adiw	r26, 0x04	; 4
    3354:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3356:	80 e8       	ldi	r24, 0x80	; 128
    3358:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    335a:	80 e4       	ldi	r24, 0x40	; 64
    335c:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    335e:	80 e2       	ldi	r24, 0x20	; 32
    3360:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3362:	06 80       	ldd	r0, Z+6	; 0x06
    3364:	f7 81       	ldd	r31, Z+7	; 0x07
    3366:	e0 2d       	mov	r30, r0
    3368:	80 81       	ld	r24, Z
    336a:	80 81       	ld	r24, Z
}
    336c:	df 91       	pop	r29
    336e:	cf 91       	pop	r28
    3370:	08 95       	ret

00003372 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3372:	81 e0       	ldi	r24, 0x01	; 1
    3374:	08 95       	ret

00003376 <_ZN8emstream7getcharEv>:
    3376:	80 e0       	ldi	r24, 0x00	; 0
    3378:	90 e0       	ldi	r25, 0x00	; 0
    337a:	08 95       	ret

0000337c <_ZN8emstream14check_for_charEv>:
    337c:	80 e0       	ldi	r24, 0x00	; 0
    337e:	08 95       	ret

00003380 <_ZN8emstream12transmit_nowEv>:
    3380:	08 95       	ret

00003382 <_ZN8emstream12clear_screenEv>:
    3382:	08 95       	ret

00003384 <_ZN8emstreamC1Ev>:
    3384:	fc 01       	movw	r30, r24
    3386:	88 e6       	ldi	r24, 0x68	; 104
    3388:	90 e2       	ldi	r25, 0x20	; 32
    338a:	80 83       	st	Z, r24
    338c:	91 83       	std	Z+1, r25	; 0x01
    338e:	8a e0       	ldi	r24, 0x0A	; 10
    3390:	82 83       	std	Z+2, r24	; 0x02
    3392:	13 82       	std	Z+3, r1	; 0x03
    3394:	83 e0       	ldi	r24, 0x03	; 3
    3396:	85 83       	std	Z+5, r24	; 0x05
    3398:	14 82       	std	Z+4, r1	; 0x04
    339a:	16 82       	std	Z+6, r1	; 0x06
    339c:	17 82       	std	Z+7, r1	; 0x07
    339e:	08 95       	ret

000033a0 <_ZN8emstream4putsEPKc>:
    33a0:	0f 93       	push	r16
    33a2:	1f 93       	push	r17
    33a4:	cf 93       	push	r28
    33a6:	df 93       	push	r29
    33a8:	8c 01       	movw	r16, r24
    33aa:	fb 01       	movw	r30, r22
    33ac:	dc 01       	movw	r26, r24
    33ae:	14 96       	adiw	r26, 0x04	; 4
    33b0:	8c 91       	ld	r24, X
    33b2:	81 11       	cpse	r24, r1
    33b4:	04 c0       	rjmp	.+8      	; 0x33be <_ZN8emstream4putsEPKc+0x1e>
    33b6:	60 81       	ld	r22, Z
    33b8:	61 11       	cpse	r22, r1
    33ba:	17 c0       	rjmp	.+46     	; 0x33ea <_ZN8emstream4putsEPKc+0x4a>
    33bc:	23 c0       	rjmp	.+70     	; 0x3404 <_ZN8emstream4putsEPKc+0x64>
    33be:	d8 01       	movw	r26, r16
    33c0:	14 96       	adiw	r26, 0x04	; 4
    33c2:	1c 92       	st	X, r1
    33c4:	eb 01       	movw	r28, r22
    33c6:	21 96       	adiw	r28, 0x01	; 1
    33c8:	64 91       	lpm	r22, Z
    33ca:	66 23       	and	r22, r22
    33cc:	d9 f0       	breq	.+54     	; 0x3404 <_ZN8emstream4putsEPKc+0x64>
    33ce:	d8 01       	movw	r26, r16
    33d0:	ed 91       	ld	r30, X+
    33d2:	fc 91       	ld	r31, X
    33d4:	02 80       	ldd	r0, Z+2	; 0x02
    33d6:	f3 81       	ldd	r31, Z+3	; 0x03
    33d8:	e0 2d       	mov	r30, r0
    33da:	c8 01       	movw	r24, r16
    33dc:	19 95       	eicall
    33de:	fe 01       	movw	r30, r28
    33e0:	64 91       	lpm	r22, Z
    33e2:	21 96       	adiw	r28, 0x01	; 1
    33e4:	61 11       	cpse	r22, r1
    33e6:	f3 cf       	rjmp	.-26     	; 0x33ce <_ZN8emstream4putsEPKc+0x2e>
    33e8:	0d c0       	rjmp	.+26     	; 0x3404 <_ZN8emstream4putsEPKc+0x64>
    33ea:	ef 01       	movw	r28, r30
    33ec:	21 96       	adiw	r28, 0x01	; 1
    33ee:	d8 01       	movw	r26, r16
    33f0:	ed 91       	ld	r30, X+
    33f2:	fc 91       	ld	r31, X
    33f4:	02 80       	ldd	r0, Z+2	; 0x02
    33f6:	f3 81       	ldd	r31, Z+3	; 0x03
    33f8:	e0 2d       	mov	r30, r0
    33fa:	c8 01       	movw	r24, r16
    33fc:	19 95       	eicall
    33fe:	69 91       	ld	r22, Y+
    3400:	61 11       	cpse	r22, r1
    3402:	f5 cf       	rjmp	.-22     	; 0x33ee <_ZN8emstream4putsEPKc+0x4e>
    3404:	df 91       	pop	r29
    3406:	cf 91       	pop	r28
    3408:	1f 91       	pop	r17
    340a:	0f 91       	pop	r16
    340c:	08 95       	ret

0000340e <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    340e:	cf 93       	push	r28
    3410:	df 93       	push	r29
    3412:	ec 01       	movw	r28, r24
	switch (new_manip)
    3414:	86 2f       	mov	r24, r22
    3416:	90 e0       	ldi	r25, 0x00	; 0
    3418:	8b 30       	cpi	r24, 0x0B	; 11
    341a:	91 05       	cpc	r25, r1
    341c:	d8 f5       	brcc	.+118    	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
    341e:	fc 01       	movw	r30, r24
    3420:	88 27       	eor	r24, r24
    3422:	e2 50       	subi	r30, 0x02	; 2
    3424:	ff 4f       	sbci	r31, 0xFF	; 255
    3426:	8f 4f       	sbci	r24, 0xFF	; 255
    3428:	0c 94 35 22 	jmp	0x446a	; 0x446a <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    342c:	82 e0       	ldi	r24, 0x02	; 2
    342e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3430:	31 c0       	rjmp	.+98     	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3432:	88 e0       	ldi	r24, 0x08	; 8
    3434:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3436:	2e c0       	rjmp	.+92     	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3438:	8a e0       	ldi	r24, 0x0A	; 10
    343a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    343c:	2b c0       	rjmp	.+86     	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    343e:	80 e1       	ldi	r24, 0x10	; 16
    3440:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3442:	28 c0       	rjmp	.+80     	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3444:	81 e0       	ldi	r24, 0x01	; 1
    3446:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3448:	25 c0       	rjmp	.+74     	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    344a:	1b 82       	std	Y+3, r1	; 0x03
			break;
    344c:	23 c0       	rjmp	.+70     	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    344e:	e8 81       	ld	r30, Y
    3450:	f9 81       	ldd	r31, Y+1	; 0x01
    3452:	02 80       	ldd	r0, Z+2	; 0x02
    3454:	f3 81       	ldd	r31, Z+3	; 0x03
    3456:	e0 2d       	mov	r30, r0
    3458:	6d e0       	ldi	r22, 0x0D	; 13
    345a:	ce 01       	movw	r24, r28
    345c:	19 95       	eicall
    345e:	e8 81       	ld	r30, Y
    3460:	f9 81       	ldd	r31, Y+1	; 0x01
    3462:	02 80       	ldd	r0, Z+2	; 0x02
    3464:	f3 81       	ldd	r31, Z+3	; 0x03
    3466:	e0 2d       	mov	r30, r0
    3468:	6a e0       	ldi	r22, 0x0A	; 10
    346a:	ce 01       	movw	r24, r28
    346c:	19 95       	eicall
			break;
    346e:	12 c0       	rjmp	.+36     	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3470:	e8 81       	ld	r30, Y
    3472:	f9 81       	ldd	r31, Y+1	; 0x01
    3474:	02 84       	ldd	r0, Z+10	; 0x0a
    3476:	f3 85       	ldd	r31, Z+11	; 0x0b
    3478:	e0 2d       	mov	r30, r0
    347a:	ce 01       	movw	r24, r28
    347c:	19 95       	eicall
			break;
    347e:	0a c0       	rjmp	.+20     	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3480:	e8 81       	ld	r30, Y
    3482:	f9 81       	ldd	r31, Y+1	; 0x01
    3484:	00 84       	ldd	r0, Z+8	; 0x08
    3486:	f1 85       	ldd	r31, Z+9	; 0x09
    3488:	e0 2d       	mov	r30, r0
    348a:	ce 01       	movw	r24, r28
    348c:	19 95       	eicall
			break;
    348e:	02 c0       	rjmp	.+4      	; 0x3494 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3490:	81 e0       	ldi	r24, 0x01	; 1
    3492:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3494:	ce 01       	movw	r24, r28
    3496:	df 91       	pop	r29
    3498:	cf 91       	pop	r28
    349a:	08 95       	ret

0000349c <_ZN8emstreamlsEb>:
 *          reference is used to string printable items together with "<<" operators
 *  @param value The boolean value to be written
 */

emstream& emstream::operator<< (bool value)
{
    349c:	cf 93       	push	r28
    349e:	df 93       	push	r29
    34a0:	ec 01       	movw	r28, r24
	if (value)
    34a2:	66 23       	and	r22, r22
    34a4:	41 f0       	breq	.+16     	; 0x34b6 <_ZN8emstreamlsEb+0x1a>
		putchar ('T');
    34a6:	e8 81       	ld	r30, Y
    34a8:	f9 81       	ldd	r31, Y+1	; 0x01
    34aa:	02 80       	ldd	r0, Z+2	; 0x02
    34ac:	f3 81       	ldd	r31, Z+3	; 0x03
    34ae:	e0 2d       	mov	r30, r0
    34b0:	64 e5       	ldi	r22, 0x54	; 84
    34b2:	19 95       	eicall
    34b4:	07 c0       	rjmp	.+14     	; 0x34c4 <_ZN8emstreamlsEb+0x28>
	else
		putchar ('F');
    34b6:	e8 81       	ld	r30, Y
    34b8:	f9 81       	ldd	r31, Y+1	; 0x01
    34ba:	02 80       	ldd	r0, Z+2	; 0x02
    34bc:	f3 81       	ldd	r31, Z+3	; 0x03
    34be:	e0 2d       	mov	r30, r0
    34c0:	66 e4       	ldi	r22, 0x46	; 70
    34c2:	19 95       	eicall

	return (*this);
}
    34c4:	ce 01       	movw	r24, r28
    34c6:	df 91       	pop	r29
    34c8:	cf 91       	pop	r28
    34ca:	08 95       	ret

000034cc <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    34cc:	ff 92       	push	r15
    34ce:	0f 93       	push	r16
    34d0:	1f 93       	push	r17
    34d2:	cf 93       	push	r28
    34d4:	df 93       	push	r29
    34d6:	cd b7       	in	r28, 0x3d	; 61
    34d8:	de b7       	in	r29, 0x3e	; 62
    34da:	61 97       	sbiw	r28, 0x11	; 17
    34dc:	cd bf       	out	0x3d, r28	; 61
    34de:	de bf       	out	0x3e, r29	; 62
    34e0:	8c 01       	movw	r16, r24
    34e2:	f6 2e       	mov	r15, r22
    34e4:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    34e6:	f8 01       	movw	r30, r16
    34e8:	42 81       	ldd	r20, Z+2	; 0x02
    34ea:	40 31       	cpi	r20, 0x10	; 16
    34ec:	21 f0       	breq	.+8      	; 0x34f6 <_ZN8emstreamlsEj+0x2a>
    34ee:	48 30       	cpi	r20, 0x08	; 8
    34f0:	11 f0       	breq	.+4      	; 0x34f6 <_ZN8emstreamlsEj+0x2a>
    34f2:	42 30       	cpi	r20, 0x02	; 2
    34f4:	41 f4       	brne	.+16     	; 0x3506 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    34f6:	69 2f       	mov	r22, r25
    34f8:	c8 01       	movw	r24, r16
    34fa:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
    34fe:	6f 2d       	mov	r22, r15
    3500:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
    3504:	0d c0       	rjmp	.+26     	; 0x3520 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3506:	50 e0       	ldi	r21, 0x00	; 0
    3508:	be 01       	movw	r22, r28
    350a:	6f 5f       	subi	r22, 0xFF	; 255
    350c:	7f 4f       	sbci	r23, 0xFF	; 255
    350e:	8f 2d       	mov	r24, r15
    3510:	0e 94 a4 22 	call	0x4548	; 0x4548 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3514:	be 01       	movw	r22, r28
    3516:	6f 5f       	subi	r22, 0xFF	; 255
    3518:	7f 4f       	sbci	r23, 0xFF	; 255
    351a:	c8 01       	movw	r24, r16
    351c:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3520:	c8 01       	movw	r24, r16
    3522:	61 96       	adiw	r28, 0x11	; 17
    3524:	cd bf       	out	0x3d, r28	; 61
    3526:	de bf       	out	0x3e, r29	; 62
    3528:	df 91       	pop	r29
    352a:	cf 91       	pop	r28
    352c:	1f 91       	pop	r17
    352e:	0f 91       	pop	r16
    3530:	ff 90       	pop	r15
    3532:	08 95       	ret

00003534 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3534:	df 92       	push	r13
    3536:	ef 92       	push	r14
    3538:	ff 92       	push	r15
    353a:	0f 93       	push	r16
    353c:	1f 93       	push	r17
    353e:	cf 93       	push	r28
    3540:	df 93       	push	r29
    3542:	cd b7       	in	r28, 0x3d	; 61
    3544:	de b7       	in	r29, 0x3e	; 62
    3546:	a1 97       	sbiw	r28, 0x21	; 33
    3548:	cd bf       	out	0x3d, r28	; 61
    354a:	de bf       	out	0x3e, r29	; 62
    354c:	8c 01       	movw	r16, r24
    354e:	d4 2e       	mov	r13, r20
    3550:	e5 2e       	mov	r14, r21
    3552:	f6 2e       	mov	r15, r22
    3554:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3556:	f8 01       	movw	r30, r16
    3558:	22 81       	ldd	r18, Z+2	; 0x02
    355a:	20 31       	cpi	r18, 0x10	; 16
    355c:	21 f0       	breq	.+8      	; 0x3566 <_ZN8emstreamlsEm+0x32>
    355e:	28 30       	cpi	r18, 0x08	; 8
    3560:	11 f0       	breq	.+4      	; 0x3566 <_ZN8emstreamlsEm+0x32>
    3562:	22 30       	cpi	r18, 0x02	; 2
    3564:	71 f4       	brne	.+28     	; 0x3582 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3566:	69 2f       	mov	r22, r25
    3568:	c8 01       	movw	r24, r16
    356a:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
    356e:	6f 2d       	mov	r22, r15
    3570:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
    3574:	6e 2d       	mov	r22, r14
    3576:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
    357a:	6d 2d       	mov	r22, r13
    357c:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <_ZN8emstreamlsEh>
    3580:	0f c0       	rjmp	.+30     	; 0x35a0 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3582:	30 e0       	ldi	r19, 0x00	; 0
    3584:	ae 01       	movw	r20, r28
    3586:	4f 5f       	subi	r20, 0xFF	; 255
    3588:	5f 4f       	sbci	r21, 0xFF	; 255
    358a:	6d 2d       	mov	r22, r13
    358c:	7e 2d       	mov	r23, r14
    358e:	8f 2d       	mov	r24, r15
    3590:	0e 94 77 22 	call	0x44ee	; 0x44ee <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3594:	be 01       	movw	r22, r28
    3596:	6f 5f       	subi	r22, 0xFF	; 255
    3598:	7f 4f       	sbci	r23, 0xFF	; 255
    359a:	c8 01       	movw	r24, r16
    359c:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35a0:	c8 01       	movw	r24, r16
    35a2:	a1 96       	adiw	r28, 0x21	; 33
    35a4:	cd bf       	out	0x3d, r28	; 61
    35a6:	de bf       	out	0x3e, r29	; 62
    35a8:	df 91       	pop	r29
    35aa:	cf 91       	pop	r28
    35ac:	1f 91       	pop	r17
    35ae:	0f 91       	pop	r16
    35b0:	ff 90       	pop	r15
    35b2:	ef 90       	pop	r14
    35b4:	df 90       	pop	r13
    35b6:	08 95       	ret

000035b8 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    35b8:	cf 92       	push	r12
    35ba:	df 92       	push	r13
    35bc:	ef 92       	push	r14
    35be:	ff 92       	push	r15
    35c0:	0f 93       	push	r16
    35c2:	1f 93       	push	r17
    35c4:	cf 93       	push	r28
    35c6:	df 93       	push	r29
    35c8:	cd b7       	in	r28, 0x3d	; 61
    35ca:	de b7       	in	r29, 0x3e	; 62
    35cc:	29 97       	sbiw	r28, 0x09	; 9
    35ce:	cd bf       	out	0x3d, r28	; 61
    35d0:	de bf       	out	0x3e, r29	; 62
    35d2:	8c 01       	movw	r16, r24
    35d4:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    35d6:	dc 01       	movw	r26, r24
    35d8:	13 96       	adiw	r26, 0x03	; 3
    35da:	8c 91       	ld	r24, X
    35dc:	13 97       	sbiw	r26, 0x03	; 3
    35de:	88 23       	and	r24, r24
    35e0:	41 f0       	breq	.+16     	; 0x35f2 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    35e2:	ed 91       	ld	r30, X+
    35e4:	fc 91       	ld	r31, X
    35e6:	02 80       	ldd	r0, Z+2	; 0x02
    35e8:	f3 81       	ldd	r31, Z+3	; 0x03
    35ea:	e0 2d       	mov	r30, r0
    35ec:	c8 01       	movw	r24, r16
    35ee:	19 95       	eicall
    35f0:	56 c0       	rjmp	.+172    	; 0x369e <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    35f2:	f8 01       	movw	r30, r16
    35f4:	42 81       	ldd	r20, Z+2	; 0x02
    35f6:	42 30       	cpi	r20, 0x02	; 2
    35f8:	19 f5       	brne	.+70     	; 0x3640 <_ZN8emstreamlsEh+0x88>
    35fa:	68 94       	set
    35fc:	cc 24       	eor	r12, r12
    35fe:	c3 f8       	bld	r12, 3
    3600:	d1 2c       	mov	r13, r1
    3602:	68 94       	set
    3604:	ff 24       	eor	r15, r15
    3606:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3608:	8e 2d       	mov	r24, r14
    360a:	8f 21       	and	r24, r15
    360c:	51 f0       	breq	.+20     	; 0x3622 <_ZN8emstreamlsEh+0x6a>
    360e:	d8 01       	movw	r26, r16
    3610:	ed 91       	ld	r30, X+
    3612:	fc 91       	ld	r31, X
    3614:	02 80       	ldd	r0, Z+2	; 0x02
    3616:	f3 81       	ldd	r31, Z+3	; 0x03
    3618:	e0 2d       	mov	r30, r0
    361a:	61 e3       	ldi	r22, 0x31	; 49
    361c:	c8 01       	movw	r24, r16
    361e:	19 95       	eicall
    3620:	09 c0       	rjmp	.+18     	; 0x3634 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3622:	d8 01       	movw	r26, r16
    3624:	ed 91       	ld	r30, X+
    3626:	fc 91       	ld	r31, X
    3628:	02 80       	ldd	r0, Z+2	; 0x02
    362a:	f3 81       	ldd	r31, Z+3	; 0x03
    362c:	e0 2d       	mov	r30, r0
    362e:	60 e3       	ldi	r22, 0x30	; 48
    3630:	c8 01       	movw	r24, r16
    3632:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3634:	f6 94       	lsr	r15
    3636:	b1 e0       	ldi	r27, 0x01	; 1
    3638:	cb 1a       	sub	r12, r27
    363a:	d1 08       	sbc	r13, r1
    363c:	29 f7       	brne	.-54     	; 0x3608 <_ZN8emstreamlsEh+0x50>
    363e:	2f c0       	rjmp	.+94     	; 0x369e <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3640:	40 31       	cpi	r20, 0x10	; 16
    3642:	f9 f4       	brne	.+62     	; 0x3682 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3644:	62 95       	swap	r22
    3646:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3648:	01 90       	ld	r0, Z+
    364a:	f0 81       	ld	r31, Z
    364c:	e0 2d       	mov	r30, r0
    364e:	02 80       	ldd	r0, Z+2	; 0x02
    3650:	f3 81       	ldd	r31, Z+3	; 0x03
    3652:	e0 2d       	mov	r30, r0
    3654:	6a 30       	cpi	r22, 0x0A	; 10
    3656:	10 f0       	brcs	.+4      	; 0x365c <_ZN8emstreamlsEh+0xa4>
    3658:	69 5c       	subi	r22, 0xC9	; 201
    365a:	01 c0       	rjmp	.+2      	; 0x365e <_ZN8emstreamlsEh+0xa6>
    365c:	60 5d       	subi	r22, 0xD0	; 208
    365e:	c8 01       	movw	r24, r16
    3660:	19 95       	eicall
		temp_char = num & 0x0F;
    3662:	6e 2d       	mov	r22, r14
    3664:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3666:	d8 01       	movw	r26, r16
    3668:	ed 91       	ld	r30, X+
    366a:	fc 91       	ld	r31, X
    366c:	02 80       	ldd	r0, Z+2	; 0x02
    366e:	f3 81       	ldd	r31, Z+3	; 0x03
    3670:	e0 2d       	mov	r30, r0
    3672:	6a 30       	cpi	r22, 0x0A	; 10
    3674:	10 f0       	brcs	.+4      	; 0x367a <_ZN8emstreamlsEh+0xc2>
    3676:	69 5c       	subi	r22, 0xC9	; 201
    3678:	01 c0       	rjmp	.+2      	; 0x367c <_ZN8emstreamlsEh+0xc4>
    367a:	60 5d       	subi	r22, 0xD0	; 208
    367c:	c8 01       	movw	r24, r16
    367e:	19 95       	eicall
    3680:	0e c0       	rjmp	.+28     	; 0x369e <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3682:	50 e0       	ldi	r21, 0x00	; 0
    3684:	be 01       	movw	r22, r28
    3686:	6f 5f       	subi	r22, 0xFF	; 255
    3688:	7f 4f       	sbci	r23, 0xFF	; 255
    368a:	8e 2d       	mov	r24, r14
    368c:	90 e0       	ldi	r25, 0x00	; 0
    368e:	0e 94 a4 22 	call	0x4548	; 0x4548 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3692:	be 01       	movw	r22, r28
    3694:	6f 5f       	subi	r22, 0xFF	; 255
    3696:	7f 4f       	sbci	r23, 0xFF	; 255
    3698:	c8 01       	movw	r24, r16
    369a:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    369e:	c8 01       	movw	r24, r16
    36a0:	29 96       	adiw	r28, 0x09	; 9
    36a2:	cd bf       	out	0x3d, r28	; 61
    36a4:	de bf       	out	0x3e, r29	; 62
    36a6:	df 91       	pop	r29
    36a8:	cf 91       	pop	r28
    36aa:	1f 91       	pop	r17
    36ac:	0f 91       	pop	r16
    36ae:	ff 90       	pop	r15
    36b0:	ef 90       	pop	r14
    36b2:	df 90       	pop	r13
    36b4:	cf 90       	pop	r12
    36b6:	08 95       	ret

000036b8 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    36b8:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36ba:	50 96       	adiw	r26, 0x10	; 16
    36bc:	ed 91       	ld	r30, X+
    36be:	fc 91       	ld	r31, X
    36c0:	51 97       	sbiw	r26, 0x11	; 17
    36c2:	80 81       	ld	r24, Z
    36c4:	54 96       	adiw	r26, 0x14	; 20
    36c6:	4c 91       	ld	r20, X
    36c8:	54 97       	sbiw	r26, 0x14	; 20
    36ca:	84 23       	and	r24, r20
    36cc:	29 f0       	breq	.+10     	; 0x36d8 <_ZN5rs2327putcharEc+0x20>
    36ce:	09 c0       	rjmp	.+18     	; 0x36e2 <_ZN5rs2327putcharEc+0x2a>
    36d0:	21 50       	subi	r18, 0x01	; 1
    36d2:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    36d4:	19 f4       	brne	.+6      	; 0x36dc <_ZN5rs2327putcharEc+0x24>
    36d6:	12 c0       	rjmp	.+36     	; 0x36fc <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36d8:	21 e2       	ldi	r18, 0x21	; 33
    36da:	3e e4       	ldi	r19, 0x4E	; 78
    36dc:	90 81       	ld	r25, Z
    36de:	94 23       	and	r25, r20
    36e0:	b9 f3       	breq	.-18     	; 0x36d0 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    36e2:	90 81       	ld	r25, Z
    36e4:	56 96       	adiw	r26, 0x16	; 22
    36e6:	8c 91       	ld	r24, X
    36e8:	56 97       	sbiw	r26, 0x16	; 22
    36ea:	89 2b       	or	r24, r25
    36ec:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    36ee:	1e 96       	adiw	r26, 0x0e	; 14
    36f0:	ed 91       	ld	r30, X+
    36f2:	fc 91       	ld	r31, X
    36f4:	1f 97       	sbiw	r26, 0x0f	; 15
    36f6:	60 83       	st	Z, r22
	return (true);
    36f8:	81 e0       	ldi	r24, 0x01	; 1
    36fa:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    36fc:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    36fe:	08 95       	ret

00003700 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3700:	cf 93       	push	r28
    3702:	df 93       	push	r29
    3704:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3706:	c1 8d       	ldd	r28, Z+25	; 0x19
    3708:	d2 8d       	ldd	r29, Z+26	; 0x1a
    370a:	28 81       	ld	r18, Y
    370c:	39 81       	ldd	r19, Y+1	; 0x01
    370e:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3710:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3712:	4d 91       	ld	r20, X+
    3714:	5c 91       	ld	r21, X
    3716:	24 17       	cp	r18, r20
    3718:	35 07       	cpc	r19, r21
    371a:	e9 f3       	breq	.-6      	; 0x3716 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    371c:	a7 89       	ldd	r26, Z+23	; 0x17
    371e:	b0 8d       	ldd	r27, Z+24	; 0x18
    3720:	0d 90       	ld	r0, X+
    3722:	bc 91       	ld	r27, X
    3724:	a0 2d       	mov	r26, r0
    3726:	a2 0f       	add	r26, r18
    3728:	b3 1f       	adc	r27, r19
    372a:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    372c:	2f 5f       	subi	r18, 0xFF	; 255
    372e:	3f 4f       	sbci	r19, 0xFF	; 255
    3730:	28 83       	st	Y, r18
    3732:	39 83       	std	Y+1, r19	; 0x01
    3734:	24 36       	cpi	r18, 0x64	; 100
    3736:	31 05       	cpc	r19, r1
    3738:	28 f0       	brcs	.+10     	; 0x3744 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    373a:	01 8c       	ldd	r0, Z+25	; 0x19
    373c:	f2 8d       	ldd	r31, Z+26	; 0x1a
    373e:	e0 2d       	mov	r30, r0
    3740:	10 82       	st	Z, r1
    3742:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3744:	90 e0       	ldi	r25, 0x00	; 0
    3746:	df 91       	pop	r29
    3748:	cf 91       	pop	r28
    374a:	08 95       	ret

0000374c <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    374c:	cf 93       	push	r28
    374e:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3750:	ec 01       	movw	r28, r24
    3752:	a9 8d       	ldd	r26, Y+25	; 0x19
    3754:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3756:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3758:	fc 8d       	ldd	r31, Y+28	; 0x1c
    375a:	81 e0       	ldi	r24, 0x01	; 1
    375c:	4d 91       	ld	r20, X+
    375e:	5c 91       	ld	r21, X
    3760:	20 81       	ld	r18, Z
    3762:	31 81       	ldd	r19, Z+1	; 0x01
    3764:	42 17       	cp	r20, r18
    3766:	53 07       	cpc	r21, r19
    3768:	09 f4       	brne	.+2      	; 0x376c <_ZN5rs23214check_for_charEv+0x20>
    376a:	80 e0       	ldi	r24, 0x00	; 0
}
    376c:	df 91       	pop	r29
    376e:	cf 91       	pop	r28
    3770:	08 95       	ret

00003772 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3772:	dc 01       	movw	r26, r24
    3774:	ed 91       	ld	r30, X+
    3776:	fc 91       	ld	r31, X
    3778:	02 80       	ldd	r0, Z+2	; 0x02
    377a:	f3 81       	ldd	r31, Z+3	; 0x03
    377c:	e0 2d       	mov	r30, r0
    377e:	6c e0       	ldi	r22, 0x0C	; 12
    3780:	19 95       	eicall
    3782:	08 95       	ret

00003784 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3784:	ef 92       	push	r14
    3786:	ff 92       	push	r15
    3788:	0f 93       	push	r16
    378a:	1f 93       	push	r17
    378c:	cf 93       	push	r28
    378e:	df 93       	push	r29
    3790:	ec 01       	movw	r28, r24
    3792:	7b 01       	movw	r14, r22
    3794:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3796:	0e 94 c2 19 	call	0x3384	; 0x3384 <_ZN8emstreamC1Ev>
    379a:	a8 01       	movw	r20, r16
    379c:	b7 01       	movw	r22, r14
    379e:	ce 01       	movw	r24, r28
    37a0:	08 96       	adiw	r24, 0x08	; 8
    37a2:	0e 94 09 19 	call	0x3212	; 0x3212 <_ZN7base232C1EjP12USART_struct>
    37a6:	88 e7       	ldi	r24, 0x78	; 120
    37a8:	90 e2       	ldi	r25, 0x20	; 32
    37aa:	88 83       	st	Y, r24
    37ac:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    37ae:	00 3a       	cpi	r16, 0xA0	; 160
    37b0:	88 e0       	ldi	r24, 0x08	; 8
    37b2:	18 07       	cpc	r17, r24
    37b4:	69 f4       	brne	.+26     	; 0x37d0 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    37b6:	8c e5       	ldi	r24, 0x5C	; 92
    37b8:	91 e3       	ldi	r25, 0x31	; 49
    37ba:	8f 8b       	std	Y+23, r24	; 0x17
    37bc:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    37be:	8e e4       	ldi	r24, 0x4E	; 78
    37c0:	91 e3       	ldi	r25, 0x31	; 49
    37c2:	89 8f       	std	Y+25, r24	; 0x19
    37c4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    37c6:	80 e4       	ldi	r24, 0x40	; 64
    37c8:	91 e3       	ldi	r25, 0x31	; 49
    37ca:	8b 8f       	std	Y+27, r24	; 0x1b
    37cc:	9c 8f       	std	Y+28, r25	; 0x1c
    37ce:	64 c0       	rjmp	.+200    	; 0x3898 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    37d0:	00 3b       	cpi	r16, 0xB0	; 176
    37d2:	e8 e0       	ldi	r30, 0x08	; 8
    37d4:	1e 07       	cpc	r17, r30
    37d6:	69 f4       	brne	.+26     	; 0x37f2 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    37d8:	8a e5       	ldi	r24, 0x5A	; 90
    37da:	91 e3       	ldi	r25, 0x31	; 49
    37dc:	8f 8b       	std	Y+23, r24	; 0x17
    37de:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    37e0:	8c e4       	ldi	r24, 0x4C	; 76
    37e2:	91 e3       	ldi	r25, 0x31	; 49
    37e4:	89 8f       	std	Y+25, r24	; 0x19
    37e6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    37e8:	8e e3       	ldi	r24, 0x3E	; 62
    37ea:	91 e3       	ldi	r25, 0x31	; 49
    37ec:	8b 8f       	std	Y+27, r24	; 0x1b
    37ee:	9c 8f       	std	Y+28, r25	; 0x1c
    37f0:	53 c0       	rjmp	.+166    	; 0x3898 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    37f2:	00 3a       	cpi	r16, 0xA0	; 160
    37f4:	f9 e0       	ldi	r31, 0x09	; 9
    37f6:	1f 07       	cpc	r17, r31
    37f8:	69 f4       	brne	.+26     	; 0x3814 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    37fa:	88 e5       	ldi	r24, 0x58	; 88
    37fc:	91 e3       	ldi	r25, 0x31	; 49
    37fe:	8f 8b       	std	Y+23, r24	; 0x17
    3800:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3802:	8a e4       	ldi	r24, 0x4A	; 74
    3804:	91 e3       	ldi	r25, 0x31	; 49
    3806:	89 8f       	std	Y+25, r24	; 0x19
    3808:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    380a:	8c e3       	ldi	r24, 0x3C	; 60
    380c:	91 e3       	ldi	r25, 0x31	; 49
    380e:	8b 8f       	std	Y+27, r24	; 0x1b
    3810:	9c 8f       	std	Y+28, r25	; 0x1c
    3812:	42 c0       	rjmp	.+132    	; 0x3898 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3814:	00 3b       	cpi	r16, 0xB0	; 176
    3816:	89 e0       	ldi	r24, 0x09	; 9
    3818:	18 07       	cpc	r17, r24
    381a:	69 f4       	brne	.+26     	; 0x3836 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    381c:	86 e5       	ldi	r24, 0x56	; 86
    381e:	91 e3       	ldi	r25, 0x31	; 49
    3820:	8f 8b       	std	Y+23, r24	; 0x17
    3822:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3824:	88 e4       	ldi	r24, 0x48	; 72
    3826:	91 e3       	ldi	r25, 0x31	; 49
    3828:	89 8f       	std	Y+25, r24	; 0x19
    382a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    382c:	8a e3       	ldi	r24, 0x3A	; 58
    382e:	91 e3       	ldi	r25, 0x31	; 49
    3830:	8b 8f       	std	Y+27, r24	; 0x1b
    3832:	9c 8f       	std	Y+28, r25	; 0x1c
    3834:	31 c0       	rjmp	.+98     	; 0x3898 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3836:	00 3a       	cpi	r16, 0xA0	; 160
    3838:	ea e0       	ldi	r30, 0x0A	; 10
    383a:	1e 07       	cpc	r17, r30
    383c:	69 f4       	brne	.+26     	; 0x3858 <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    383e:	84 e5       	ldi	r24, 0x54	; 84
    3840:	91 e3       	ldi	r25, 0x31	; 49
    3842:	8f 8b       	std	Y+23, r24	; 0x17
    3844:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3846:	86 e4       	ldi	r24, 0x46	; 70
    3848:	91 e3       	ldi	r25, 0x31	; 49
    384a:	89 8f       	std	Y+25, r24	; 0x19
    384c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    384e:	88 e3       	ldi	r24, 0x38	; 56
    3850:	91 e3       	ldi	r25, 0x31	; 49
    3852:	8b 8f       	std	Y+27, r24	; 0x1b
    3854:	9c 8f       	std	Y+28, r25	; 0x1c
    3856:	20 c0       	rjmp	.+64     	; 0x3898 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    3858:	00 3b       	cpi	r16, 0xB0	; 176
    385a:	fa e0       	ldi	r31, 0x0A	; 10
    385c:	1f 07       	cpc	r17, r31
    385e:	69 f4       	brne	.+26     	; 0x387a <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    3860:	82 e5       	ldi	r24, 0x52	; 82
    3862:	91 e3       	ldi	r25, 0x31	; 49
    3864:	8f 8b       	std	Y+23, r24	; 0x17
    3866:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    3868:	84 e4       	ldi	r24, 0x44	; 68
    386a:	91 e3       	ldi	r25, 0x31	; 49
    386c:	89 8f       	std	Y+25, r24	; 0x19
    386e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    3870:	86 e3       	ldi	r24, 0x36	; 54
    3872:	91 e3       	ldi	r25, 0x31	; 49
    3874:	8b 8f       	std	Y+27, r24	; 0x1b
    3876:	9c 8f       	std	Y+28, r25	; 0x1c
    3878:	0f c0       	rjmp	.+30     	; 0x3898 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    387a:	00 3a       	cpi	r16, 0xA0	; 160
    387c:	1b 40       	sbci	r17, 0x0B	; 11
    387e:	61 f4       	brne	.+24     	; 0x3898 <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    3880:	80 e5       	ldi	r24, 0x50	; 80
    3882:	91 e3       	ldi	r25, 0x31	; 49
    3884:	8f 8b       	std	Y+23, r24	; 0x17
    3886:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    3888:	82 e4       	ldi	r24, 0x42	; 66
    388a:	91 e3       	ldi	r25, 0x31	; 49
    388c:	89 8f       	std	Y+25, r24	; 0x19
    388e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    3890:	84 e3       	ldi	r24, 0x34	; 52
    3892:	91 e3       	ldi	r25, 0x31	; 49
    3894:	8b 8f       	std	Y+27, r24	; 0x1b
    3896:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3898:	0f 89       	ldd	r16, Y+23	; 0x17
    389a:	18 8d       	ldd	r17, Y+24	; 0x18
    389c:	84 e6       	ldi	r24, 0x64	; 100
    389e:	90 e0       	ldi	r25, 0x00	; 0
    38a0:	0e 94 05 19 	call	0x320a	; 0x320a <_Znaj>
    38a4:	f8 01       	movw	r30, r16
    38a6:	80 83       	st	Z, r24
    38a8:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    38aa:	e9 8d       	ldd	r30, Y+25	; 0x19
    38ac:	fa 8d       	ldd	r31, Y+26	; 0x1a
    38ae:	10 82       	st	Z, r1
    38b0:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    38b2:	eb 8d       	ldd	r30, Y+27	; 0x1b
    38b4:	fc 8d       	ldd	r31, Y+28	; 0x1c
    38b6:	10 82       	st	Z, r1
    38b8:	11 82       	std	Z+1, r1	; 0x01
}
    38ba:	df 91       	pop	r29
    38bc:	cf 91       	pop	r28
    38be:	1f 91       	pop	r17
    38c0:	0f 91       	pop	r16
    38c2:	ff 90       	pop	r15
    38c4:	ef 90       	pop	r14
    38c6:	08 95       	ret

000038c8 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    38c8:	1f 92       	push	r1
    38ca:	0f 92       	push	r0
    38cc:	0f b6       	in	r0, 0x3f	; 63
    38ce:	0f 92       	push	r0
    38d0:	11 24       	eor	r1, r1
    38d2:	08 b6       	in	r0, 0x38	; 56
    38d4:	0f 92       	push	r0
    38d6:	18 be       	out	0x38, r1	; 56
    38d8:	0b b6       	in	r0, 0x3b	; 59
    38da:	0f 92       	push	r0
    38dc:	1b be       	out	0x3b, r1	; 59
    38de:	2f 93       	push	r18
    38e0:	3f 93       	push	r19
    38e2:	8f 93       	push	r24
    38e4:	9f 93       	push	r25
    38e6:	ef 93       	push	r30
    38e8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    38ea:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    38ee:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <rcvC0_buffer>
    38f2:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <rcvC0_buffer+0x1>
    38f6:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC0_write_index>
    38fa:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC0_write_index+0x1>
    38fe:	e8 0f       	add	r30, r24
    3900:	f9 1f       	adc	r31, r25
    3902:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3904:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC0_write_index>
    3908:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC0_write_index+0x1>
    390c:	01 96       	adiw	r24, 0x01	; 1
    390e:	84 36       	cpi	r24, 0x64	; 100
    3910:	91 05       	cpc	r25, r1
    3912:	60 f4       	brcc	.+24     	; 0x392c <__vector_25+0x64>
    3914:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <rcvC0_write_index>
    3918:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    391c:	20 91 4e 31 	lds	r18, 0x314E	; 0x80314e <rcvC0_read_index>
    3920:	30 91 4f 31 	lds	r19, 0x314F	; 0x80314f <rcvC0_read_index+0x1>
    3924:	82 17       	cp	r24, r18
    3926:	93 07       	cpc	r25, r19
    3928:	f1 f4       	brne	.+60     	; 0x3966 <__vector_25+0x9e>
    392a:	0c c0       	rjmp	.+24     	; 0x3944 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    392c:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rcvC0_write_index>
    3930:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3934:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvC0_read_index>
    3938:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvC0_read_index+0x1>
    393c:	18 16       	cp	r1, r24
    393e:	19 06       	cpc	r1, r25
    3940:	91 f4       	brne	.+36     	; 0x3966 <__vector_25+0x9e>
    3942:	0e c0       	rjmp	.+28     	; 0x3960 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3944:	01 96       	adiw	r24, 0x01	; 1
    3946:	84 36       	cpi	r24, 0x64	; 100
    3948:	91 05       	cpc	r25, r1
    394a:	28 f4       	brcc	.+10     	; 0x3956 <__vector_25+0x8e>
    394c:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvC0_read_index>
    3950:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvC0_read_index+0x1>
    3954:	08 c0       	rjmp	.+16     	; 0x3966 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3956:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvC0_read_index>
    395a:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvC0_read_index+0x1>
}
    395e:	03 c0       	rjmp	.+6      	; 0x3966 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3960:	81 e0       	ldi	r24, 0x01	; 1
    3962:	90 e0       	ldi	r25, 0x00	; 0
    3964:	f3 cf       	rjmp	.-26     	; 0x394c <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3966:	ff 91       	pop	r31
    3968:	ef 91       	pop	r30
    396a:	9f 91       	pop	r25
    396c:	8f 91       	pop	r24
    396e:	3f 91       	pop	r19
    3970:	2f 91       	pop	r18
    3972:	0f 90       	pop	r0
    3974:	0b be       	out	0x3b, r0	; 59
    3976:	0f 90       	pop	r0
    3978:	08 be       	out	0x38, r0	; 56
    397a:	0f 90       	pop	r0
    397c:	0f be       	out	0x3f, r0	; 63
    397e:	0f 90       	pop	r0
    3980:	1f 90       	pop	r1
    3982:	18 95       	reti

00003984 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3984:	1f 92       	push	r1
    3986:	0f 92       	push	r0
    3988:	0f b6       	in	r0, 0x3f	; 63
    398a:	0f 92       	push	r0
    398c:	11 24       	eor	r1, r1
    398e:	08 b6       	in	r0, 0x38	; 56
    3990:	0f 92       	push	r0
    3992:	18 be       	out	0x38, r1	; 56
    3994:	0b b6       	in	r0, 0x3b	; 59
    3996:	0f 92       	push	r0
    3998:	1b be       	out	0x3b, r1	; 59
    399a:	2f 93       	push	r18
    399c:	3f 93       	push	r19
    399e:	8f 93       	push	r24
    39a0:	9f 93       	push	r25
    39a2:	ef 93       	push	r30
    39a4:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    39a6:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    39aa:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <rcvC1_buffer>
    39ae:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <rcvC1_buffer+0x1>
    39b2:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvC1_write_index>
    39b6:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvC1_write_index+0x1>
    39ba:	e8 0f       	add	r30, r24
    39bc:	f9 1f       	adc	r31, r25
    39be:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    39c0:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvC1_write_index>
    39c4:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvC1_write_index+0x1>
    39c8:	01 96       	adiw	r24, 0x01	; 1
    39ca:	84 36       	cpi	r24, 0x64	; 100
    39cc:	91 05       	cpc	r25, r1
    39ce:	60 f4       	brcc	.+24     	; 0x39e8 <__vector_28+0x64>
    39d0:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <rcvC1_write_index>
    39d4:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39d8:	20 91 4c 31 	lds	r18, 0x314C	; 0x80314c <rcvC1_read_index>
    39dc:	30 91 4d 31 	lds	r19, 0x314D	; 0x80314d <rcvC1_read_index+0x1>
    39e0:	82 17       	cp	r24, r18
    39e2:	93 07       	cpc	r25, r19
    39e4:	f1 f4       	brne	.+60     	; 0x3a22 <__vector_28+0x9e>
    39e6:	0c c0       	rjmp	.+24     	; 0x3a00 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    39e8:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <rcvC1_write_index>
    39ec:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39f0:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvC1_read_index>
    39f4:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvC1_read_index+0x1>
    39f8:	18 16       	cp	r1, r24
    39fa:	19 06       	cpc	r1, r25
    39fc:	91 f4       	brne	.+36     	; 0x3a22 <__vector_28+0x9e>
    39fe:	0e c0       	rjmp	.+28     	; 0x3a1c <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a00:	01 96       	adiw	r24, 0x01	; 1
    3a02:	84 36       	cpi	r24, 0x64	; 100
    3a04:	91 05       	cpc	r25, r1
    3a06:	28 f4       	brcc	.+10     	; 0x3a12 <__vector_28+0x8e>
    3a08:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvC1_read_index>
    3a0c:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvC1_read_index+0x1>
    3a10:	08 c0       	rjmp	.+16     	; 0x3a22 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3a12:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvC1_read_index>
    3a16:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvC1_read_index+0x1>
}
    3a1a:	03 c0       	rjmp	.+6      	; 0x3a22 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3a1c:	81 e0       	ldi	r24, 0x01	; 1
    3a1e:	90 e0       	ldi	r25, 0x00	; 0
    3a20:	f3 cf       	rjmp	.-26     	; 0x3a08 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3a22:	ff 91       	pop	r31
    3a24:	ef 91       	pop	r30
    3a26:	9f 91       	pop	r25
    3a28:	8f 91       	pop	r24
    3a2a:	3f 91       	pop	r19
    3a2c:	2f 91       	pop	r18
    3a2e:	0f 90       	pop	r0
    3a30:	0b be       	out	0x3b, r0	; 59
    3a32:	0f 90       	pop	r0
    3a34:	08 be       	out	0x38, r0	; 56
    3a36:	0f 90       	pop	r0
    3a38:	0f be       	out	0x3f, r0	; 63
    3a3a:	0f 90       	pop	r0
    3a3c:	1f 90       	pop	r1
    3a3e:	18 95       	reti

00003a40 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3a40:	1f 92       	push	r1
    3a42:	0f 92       	push	r0
    3a44:	0f b6       	in	r0, 0x3f	; 63
    3a46:	0f 92       	push	r0
    3a48:	11 24       	eor	r1, r1
    3a4a:	08 b6       	in	r0, 0x38	; 56
    3a4c:	0f 92       	push	r0
    3a4e:	18 be       	out	0x38, r1	; 56
    3a50:	0b b6       	in	r0, 0x3b	; 59
    3a52:	0f 92       	push	r0
    3a54:	1b be       	out	0x3b, r1	; 59
    3a56:	2f 93       	push	r18
    3a58:	3f 93       	push	r19
    3a5a:	8f 93       	push	r24
    3a5c:	9f 93       	push	r25
    3a5e:	ef 93       	push	r30
    3a60:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3a62:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3a66:	e0 91 58 31 	lds	r30, 0x3158	; 0x803158 <rcvD0_buffer>
    3a6a:	f0 91 59 31 	lds	r31, 0x3159	; 0x803159 <rcvD0_buffer+0x1>
    3a6e:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC0_write_index>
    3a72:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC0_write_index+0x1>
    3a76:	e8 0f       	add	r30, r24
    3a78:	f9 1f       	adc	r31, r25
    3a7a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3a7c:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvD0_write_index>
    3a80:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvD0_write_index+0x1>
    3a84:	01 96       	adiw	r24, 0x01	; 1
    3a86:	84 36       	cpi	r24, 0x64	; 100
    3a88:	91 05       	cpc	r25, r1
    3a8a:	60 f4       	brcc	.+24     	; 0x3aa4 <__vector_88+0x64>
    3a8c:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <rcvD0_write_index>
    3a90:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a94:	20 91 4a 31 	lds	r18, 0x314A	; 0x80314a <rcvD0_read_index>
    3a98:	30 91 4b 31 	lds	r19, 0x314B	; 0x80314b <rcvD0_read_index+0x1>
    3a9c:	82 17       	cp	r24, r18
    3a9e:	93 07       	cpc	r25, r19
    3aa0:	f1 f4       	brne	.+60     	; 0x3ade <__vector_88+0x9e>
    3aa2:	0c c0       	rjmp	.+24     	; 0x3abc <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3aa4:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rcvD0_write_index>
    3aa8:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3aac:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvD0_read_index>
    3ab0:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvD0_read_index+0x1>
    3ab4:	18 16       	cp	r1, r24
    3ab6:	19 06       	cpc	r1, r25
    3ab8:	91 f4       	brne	.+36     	; 0x3ade <__vector_88+0x9e>
    3aba:	0e c0       	rjmp	.+28     	; 0x3ad8 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3abc:	01 96       	adiw	r24, 0x01	; 1
    3abe:	84 36       	cpi	r24, 0x64	; 100
    3ac0:	91 05       	cpc	r25, r1
    3ac2:	28 f4       	brcc	.+10     	; 0x3ace <__vector_88+0x8e>
    3ac4:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <rcvD0_read_index>
    3ac8:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <rcvD0_read_index+0x1>
    3acc:	08 c0       	rjmp	.+16     	; 0x3ade <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3ace:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <rcvD0_read_index>
    3ad2:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <rcvD0_read_index+0x1>
}
    3ad6:	03 c0       	rjmp	.+6      	; 0x3ade <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3ad8:	81 e0       	ldi	r24, 0x01	; 1
    3ada:	90 e0       	ldi	r25, 0x00	; 0
    3adc:	f3 cf       	rjmp	.-26     	; 0x3ac4 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3ade:	ff 91       	pop	r31
    3ae0:	ef 91       	pop	r30
    3ae2:	9f 91       	pop	r25
    3ae4:	8f 91       	pop	r24
    3ae6:	3f 91       	pop	r19
    3ae8:	2f 91       	pop	r18
    3aea:	0f 90       	pop	r0
    3aec:	0b be       	out	0x3b, r0	; 59
    3aee:	0f 90       	pop	r0
    3af0:	08 be       	out	0x38, r0	; 56
    3af2:	0f 90       	pop	r0
    3af4:	0f be       	out	0x3f, r0	; 63
    3af6:	0f 90       	pop	r0
    3af8:	1f 90       	pop	r1
    3afa:	18 95       	reti

00003afc <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3afc:	1f 92       	push	r1
    3afe:	0f 92       	push	r0
    3b00:	0f b6       	in	r0, 0x3f	; 63
    3b02:	0f 92       	push	r0
    3b04:	11 24       	eor	r1, r1
    3b06:	08 b6       	in	r0, 0x38	; 56
    3b08:	0f 92       	push	r0
    3b0a:	18 be       	out	0x38, r1	; 56
    3b0c:	0b b6       	in	r0, 0x3b	; 59
    3b0e:	0f 92       	push	r0
    3b10:	1b be       	out	0x3b, r1	; 59
    3b12:	2f 93       	push	r18
    3b14:	3f 93       	push	r19
    3b16:	8f 93       	push	r24
    3b18:	9f 93       	push	r25
    3b1a:	ef 93       	push	r30
    3b1c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3b1e:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3b22:	e0 91 56 31 	lds	r30, 0x3156	; 0x803156 <rcvD1_buffer>
    3b26:	f0 91 57 31 	lds	r31, 0x3157	; 0x803157 <rcvD1_buffer+0x1>
    3b2a:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvD1_write_index>
    3b2e:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvD1_write_index+0x1>
    3b32:	e8 0f       	add	r30, r24
    3b34:	f9 1f       	adc	r31, r25
    3b36:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3b38:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvD1_write_index>
    3b3c:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvD1_write_index+0x1>
    3b40:	01 96       	adiw	r24, 0x01	; 1
    3b42:	84 36       	cpi	r24, 0x64	; 100
    3b44:	91 05       	cpc	r25, r1
    3b46:	60 f4       	brcc	.+24     	; 0x3b60 <__vector_91+0x64>
    3b48:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvD1_write_index>
    3b4c:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b50:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <rcvD1_read_index>
    3b54:	30 91 49 31 	lds	r19, 0x3149	; 0x803149 <rcvD1_read_index+0x1>
    3b58:	82 17       	cp	r24, r18
    3b5a:	93 07       	cpc	r25, r19
    3b5c:	f1 f4       	brne	.+60     	; 0x3b9a <__vector_91+0x9e>
    3b5e:	0c c0       	rjmp	.+24     	; 0x3b78 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3b60:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvD1_write_index>
    3b64:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b68:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvD1_read_index>
    3b6c:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvD1_read_index+0x1>
    3b70:	18 16       	cp	r1, r24
    3b72:	19 06       	cpc	r1, r25
    3b74:	91 f4       	brne	.+36     	; 0x3b9a <__vector_91+0x9e>
    3b76:	0e c0       	rjmp	.+28     	; 0x3b94 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b78:	01 96       	adiw	r24, 0x01	; 1
    3b7a:	84 36       	cpi	r24, 0x64	; 100
    3b7c:	91 05       	cpc	r25, r1
    3b7e:	28 f4       	brcc	.+10     	; 0x3b8a <__vector_91+0x8e>
    3b80:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <rcvD1_read_index>
    3b84:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <rcvD1_read_index+0x1>
    3b88:	08 c0       	rjmp	.+16     	; 0x3b9a <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3b8a:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rcvD1_read_index>
    3b8e:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <rcvD1_read_index+0x1>
}
    3b92:	03 c0       	rjmp	.+6      	; 0x3b9a <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b94:	81 e0       	ldi	r24, 0x01	; 1
    3b96:	90 e0       	ldi	r25, 0x00	; 0
    3b98:	f3 cf       	rjmp	.-26     	; 0x3b80 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3b9a:	ff 91       	pop	r31
    3b9c:	ef 91       	pop	r30
    3b9e:	9f 91       	pop	r25
    3ba0:	8f 91       	pop	r24
    3ba2:	3f 91       	pop	r19
    3ba4:	2f 91       	pop	r18
    3ba6:	0f 90       	pop	r0
    3ba8:	0b be       	out	0x3b, r0	; 59
    3baa:	0f 90       	pop	r0
    3bac:	08 be       	out	0x38, r0	; 56
    3bae:	0f 90       	pop	r0
    3bb0:	0f be       	out	0x3f, r0	; 63
    3bb2:	0f 90       	pop	r0
    3bb4:	1f 90       	pop	r1
    3bb6:	18 95       	reti

00003bb8 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3bb8:	1f 92       	push	r1
    3bba:	0f 92       	push	r0
    3bbc:	0f b6       	in	r0, 0x3f	; 63
    3bbe:	0f 92       	push	r0
    3bc0:	11 24       	eor	r1, r1
    3bc2:	08 b6       	in	r0, 0x38	; 56
    3bc4:	0f 92       	push	r0
    3bc6:	18 be       	out	0x38, r1	; 56
    3bc8:	0b b6       	in	r0, 0x3b	; 59
    3bca:	0f 92       	push	r0
    3bcc:	1b be       	out	0x3b, r1	; 59
    3bce:	2f 93       	push	r18
    3bd0:	3f 93       	push	r19
    3bd2:	8f 93       	push	r24
    3bd4:	9f 93       	push	r25
    3bd6:	ef 93       	push	r30
    3bd8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3bda:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3bde:	e0 91 54 31 	lds	r30, 0x3154	; 0x803154 <rcvE0_buffer>
    3be2:	f0 91 55 31 	lds	r31, 0x3155	; 0x803155 <rcvE0_buffer+0x1>
    3be6:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvE0_write_index>
    3bea:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvE0_write_index+0x1>
    3bee:	e8 0f       	add	r30, r24
    3bf0:	f9 1f       	adc	r31, r25
    3bf2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3bf4:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvE0_write_index>
    3bf8:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvE0_write_index+0x1>
    3bfc:	01 96       	adiw	r24, 0x01	; 1
    3bfe:	84 36       	cpi	r24, 0x64	; 100
    3c00:	91 05       	cpc	r25, r1
    3c02:	60 f4       	brcc	.+24     	; 0x3c1c <__vector_58+0x64>
    3c04:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvE0_write_index>
    3c08:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c0c:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <rcvE0_read_index>
    3c10:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <rcvE0_read_index+0x1>
    3c14:	82 17       	cp	r24, r18
    3c16:	93 07       	cpc	r25, r19
    3c18:	f1 f4       	brne	.+60     	; 0x3c56 <__vector_58+0x9e>
    3c1a:	0c c0       	rjmp	.+24     	; 0x3c34 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3c1c:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvE0_write_index>
    3c20:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3c24:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvE0_read_index>
    3c28:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvE0_read_index+0x1>
    3c2c:	18 16       	cp	r1, r24
    3c2e:	19 06       	cpc	r1, r25
    3c30:	91 f4       	brne	.+36     	; 0x3c56 <__vector_58+0x9e>
    3c32:	0e c0       	rjmp	.+28     	; 0x3c50 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c34:	01 96       	adiw	r24, 0x01	; 1
    3c36:	84 36       	cpi	r24, 0x64	; 100
    3c38:	91 05       	cpc	r25, r1
    3c3a:	28 f4       	brcc	.+10     	; 0x3c46 <__vector_58+0x8e>
    3c3c:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvE0_read_index>
    3c40:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvE0_read_index+0x1>
    3c44:	08 c0       	rjmp	.+16     	; 0x3c56 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3c46:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvE0_read_index>
    3c4a:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvE0_read_index+0x1>
}
    3c4e:	03 c0       	rjmp	.+6      	; 0x3c56 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c50:	81 e0       	ldi	r24, 0x01	; 1
    3c52:	90 e0       	ldi	r25, 0x00	; 0
    3c54:	f3 cf       	rjmp	.-26     	; 0x3c3c <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3c56:	ff 91       	pop	r31
    3c58:	ef 91       	pop	r30
    3c5a:	9f 91       	pop	r25
    3c5c:	8f 91       	pop	r24
    3c5e:	3f 91       	pop	r19
    3c60:	2f 91       	pop	r18
    3c62:	0f 90       	pop	r0
    3c64:	0b be       	out	0x3b, r0	; 59
    3c66:	0f 90       	pop	r0
    3c68:	08 be       	out	0x38, r0	; 56
    3c6a:	0f 90       	pop	r0
    3c6c:	0f be       	out	0x3f, r0	; 63
    3c6e:	0f 90       	pop	r0
    3c70:	1f 90       	pop	r1
    3c72:	18 95       	reti

00003c74 <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    3c74:	1f 92       	push	r1
    3c76:	0f 92       	push	r0
    3c78:	0f b6       	in	r0, 0x3f	; 63
    3c7a:	0f 92       	push	r0
    3c7c:	11 24       	eor	r1, r1
    3c7e:	08 b6       	in	r0, 0x38	; 56
    3c80:	0f 92       	push	r0
    3c82:	18 be       	out	0x38, r1	; 56
    3c84:	0b b6       	in	r0, 0x3b	; 59
    3c86:	0f 92       	push	r0
    3c88:	1b be       	out	0x3b, r1	; 59
    3c8a:	2f 93       	push	r18
    3c8c:	3f 93       	push	r19
    3c8e:	8f 93       	push	r24
    3c90:	9f 93       	push	r25
    3c92:	ef 93       	push	r30
    3c94:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    3c96:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    3c9a:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <rcvE1_buffer>
    3c9e:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <rcvE1_buffer+0x1>
    3ca2:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvE1_write_index>
    3ca6:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvE1_write_index+0x1>
    3caa:	e8 0f       	add	r30, r24
    3cac:	f9 1f       	adc	r31, r25
    3cae:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    3cb0:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvE1_write_index>
    3cb4:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvE1_write_index+0x1>
    3cb8:	01 96       	adiw	r24, 0x01	; 1
    3cba:	84 36       	cpi	r24, 0x64	; 100
    3cbc:	91 05       	cpc	r25, r1
    3cbe:	60 f4       	brcc	.+24     	; 0x3cd8 <__vector_61+0x64>
    3cc0:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvE1_write_index>
    3cc4:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3cc8:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <rcvE1_read_index>
    3ccc:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <rcvE1_read_index+0x1>
    3cd0:	82 17       	cp	r24, r18
    3cd2:	93 07       	cpc	r25, r19
    3cd4:	f1 f4       	brne	.+60     	; 0x3d12 <__vector_61+0x9e>
    3cd6:	0c c0       	rjmp	.+24     	; 0x3cf0 <__vector_61+0x7c>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    3cd8:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvE1_write_index>
    3cdc:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3ce0:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <rcvE1_read_index>
    3ce4:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <rcvE1_read_index+0x1>
    3ce8:	18 16       	cp	r1, r24
    3cea:	19 06       	cpc	r1, r25
    3cec:	91 f4       	brne	.+36     	; 0x3d12 <__vector_61+0x9e>
    3cee:	0e c0       	rjmp	.+28     	; 0x3d0c <__vector_61+0x98>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3cf0:	01 96       	adiw	r24, 0x01	; 1
    3cf2:	84 36       	cpi	r24, 0x64	; 100
    3cf4:	91 05       	cpc	r25, r1
    3cf6:	28 f4       	brcc	.+10     	; 0x3d02 <__vector_61+0x8e>
    3cf8:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <rcvE1_read_index>
    3cfc:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <rcvE1_read_index+0x1>
    3d00:	08 c0       	rjmp	.+16     	; 0x3d12 <__vector_61+0x9e>
	rcvE1_read_index = 0;
    3d02:	10 92 44 31 	sts	0x3144, r1	; 0x803144 <rcvE1_read_index>
    3d06:	10 92 45 31 	sts	0x3145, r1	; 0x803145 <rcvE1_read_index+0x1>
}
    3d0a:	03 c0       	rjmp	.+6      	; 0x3d12 <__vector_61+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3d0c:	81 e0       	ldi	r24, 0x01	; 1
    3d0e:	90 e0       	ldi	r25, 0x00	; 0
    3d10:	f3 cf       	rjmp	.-26     	; 0x3cf8 <__vector_61+0x84>
	rcvE1_read_index = 0;
}
    3d12:	ff 91       	pop	r31
    3d14:	ef 91       	pop	r30
    3d16:	9f 91       	pop	r25
    3d18:	8f 91       	pop	r24
    3d1a:	3f 91       	pop	r19
    3d1c:	2f 91       	pop	r18
    3d1e:	0f 90       	pop	r0
    3d20:	0b be       	out	0x3b, r0	; 59
    3d22:	0f 90       	pop	r0
    3d24:	08 be       	out	0x38, r0	; 56
    3d26:	0f 90       	pop	r0
    3d28:	0f be       	out	0x3f, r0	; 63
    3d2a:	0f 90       	pop	r0
    3d2c:	1f 90       	pop	r1
    3d2e:	18 95       	reti

00003d30 <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    3d30:	1f 92       	push	r1
    3d32:	0f 92       	push	r0
    3d34:	0f b6       	in	r0, 0x3f	; 63
    3d36:	0f 92       	push	r0
    3d38:	11 24       	eor	r1, r1
    3d3a:	08 b6       	in	r0, 0x38	; 56
    3d3c:	0f 92       	push	r0
    3d3e:	18 be       	out	0x38, r1	; 56
    3d40:	0b b6       	in	r0, 0x3b	; 59
    3d42:	0f 92       	push	r0
    3d44:	1b be       	out	0x3b, r1	; 59
    3d46:	2f 93       	push	r18
    3d48:	3f 93       	push	r19
    3d4a:	8f 93       	push	r24
    3d4c:	9f 93       	push	r25
    3d4e:	ef 93       	push	r30
    3d50:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    3d52:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    3d56:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <rcvF0_buffer>
    3d5a:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <rcvF0_buffer+0x1>
    3d5e:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvF0_write_index>
    3d62:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvF0_write_index+0x1>
    3d66:	e8 0f       	add	r30, r24
    3d68:	f9 1f       	adc	r31, r25
    3d6a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    3d6c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvF0_write_index>
    3d70:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvF0_write_index+0x1>
    3d74:	01 96       	adiw	r24, 0x01	; 1
    3d76:	84 36       	cpi	r24, 0x64	; 100
    3d78:	91 05       	cpc	r25, r1
    3d7a:	60 f4       	brcc	.+24     	; 0x3d94 <__vector_119+0x64>
    3d7c:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvF0_write_index>
    3d80:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3d84:	20 91 42 31 	lds	r18, 0x3142	; 0x803142 <rcvF0_read_index>
    3d88:	30 91 43 31 	lds	r19, 0x3143	; 0x803143 <rcvF0_read_index+0x1>
    3d8c:	82 17       	cp	r24, r18
    3d8e:	93 07       	cpc	r25, r19
    3d90:	f1 f4       	brne	.+60     	; 0x3dce <__vector_119+0x9e>
    3d92:	0c c0       	rjmp	.+24     	; 0x3dac <__vector_119+0x7c>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    3d94:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvF0_write_index>
    3d98:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3d9c:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvF0_read_index>
    3da0:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvF0_read_index+0x1>
    3da4:	18 16       	cp	r1, r24
    3da6:	19 06       	cpc	r1, r25
    3da8:	91 f4       	brne	.+36     	; 0x3dce <__vector_119+0x9e>
    3daa:	0e c0       	rjmp	.+28     	; 0x3dc8 <__vector_119+0x98>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3dac:	01 96       	adiw	r24, 0x01	; 1
    3dae:	84 36       	cpi	r24, 0x64	; 100
    3db0:	91 05       	cpc	r25, r1
    3db2:	28 f4       	brcc	.+10     	; 0x3dbe <__vector_119+0x8e>
    3db4:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <rcvF0_read_index>
    3db8:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <rcvF0_read_index+0x1>
    3dbc:	08 c0       	rjmp	.+16     	; 0x3dce <__vector_119+0x9e>
	rcvF0_read_index = 0;
    3dbe:	10 92 42 31 	sts	0x3142, r1	; 0x803142 <rcvF0_read_index>
    3dc2:	10 92 43 31 	sts	0x3143, r1	; 0x803143 <rcvF0_read_index+0x1>
}
    3dc6:	03 c0       	rjmp	.+6      	; 0x3dce <__vector_119+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3dc8:	81 e0       	ldi	r24, 0x01	; 1
    3dca:	90 e0       	ldi	r25, 0x00	; 0
    3dcc:	f3 cf       	rjmp	.-26     	; 0x3db4 <__vector_119+0x84>
	rcvF0_read_index = 0;
}
    3dce:	ff 91       	pop	r31
    3dd0:	ef 91       	pop	r30
    3dd2:	9f 91       	pop	r25
    3dd4:	8f 91       	pop	r24
    3dd6:	3f 91       	pop	r19
    3dd8:	2f 91       	pop	r18
    3dda:	0f 90       	pop	r0
    3ddc:	0b be       	out	0x3b, r0	; 59
    3dde:	0f 90       	pop	r0
    3de0:	08 be       	out	0x38, r0	; 56
    3de2:	0f 90       	pop	r0
    3de4:	0f be       	out	0x3f, r0	; 63
    3de6:	0f 90       	pop	r0
    3de8:	1f 90       	pop	r1
    3dea:	18 95       	reti

00003dec <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3dec:	0f 93       	push	r16
    3dee:	cf 93       	push	r28
    3df0:	df 93       	push	r29
    3df2:	1f 92       	push	r1
    3df4:	cd b7       	in	r28, 0x3d	; 61
    3df6:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3df8:	2f b7       	in	r18, 0x3f	; 63
    3dfa:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3dfc:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3dfe:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3e00:	fc 01       	movw	r30, r24
    3e02:	08 ed       	ldi	r16, 0xD8	; 216
    3e04:	04 bf       	out	0x34, r16	; 52
    3e06:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3e08:	89 81       	ldd	r24, Y+1	; 0x01
    3e0a:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3e0c:	0f 90       	pop	r0
    3e0e:	df 91       	pop	r29
    3e10:	cf 91       	pop	r28
    3e12:	0f 91       	pop	r16
    3e14:	08 95       	ret

00003e16 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3e16:	0f 93       	push	r16
    3e18:	1f 93       	push	r17
    3e1a:	cf 93       	push	r28
    3e1c:	df 93       	push	r29
    3e1e:	cd b7       	in	r28, 0x3d	; 61
    3e20:	de b7       	in	r29, 0x3e	; 62
    3e22:	6d 97       	sbiw	r28, 0x1d	; 29
    3e24:	cd bf       	out	0x3d, r28	; 61
    3e26:	de bf       	out	0x3e, r29	; 62
	//Clear any interrupts
	cli();
    3e28:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3e2a:	e0 e5       	ldi	r30, 0x50	; 80
    3e2c:	f0 e0       	ldi	r31, 0x00	; 0
    3e2e:	80 81       	ld	r24, Z
    3e30:	82 60       	ori	r24, 0x02	; 2
    3e32:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3e34:	81 81       	ldd	r24, Z+1	; 0x01
    3e36:	81 ff       	sbrs	r24, 1
    3e38:	fd cf       	rjmp	.-6      	; 0x3e34 <main+0x1e>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3e3a:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3e3e:	68 7f       	andi	r22, 0xF8	; 248
    3e40:	61 60       	ori	r22, 0x01	; 1
    3e42:	80 e4       	ldi	r24, 0x40	; 64
    3e44:	90 e0       	ldi	r25, 0x00	; 0
    3e46:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3e4a:	e0 e5       	ldi	r30, 0x50	; 80
    3e4c:	f0 e0       	ldi	r31, 0x00	; 0
    3e4e:	80 81       	ld	r24, Z
    3e50:	8e 7f       	andi	r24, 0xFE	; 254
    3e52:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3e54:	9d ef       	ldi	r25, 0xFD	; 253
    3e56:	88 ed       	ldi	r24, 0xD8	; 216
    3e58:	08 b6       	in	r0, 0x38	; 56
    3e5a:	18 be       	out	0x38, r1	; 56
    3e5c:	84 bf       	out	0x34, r24	; 52
    3e5e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3e62:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
    3e64:	40 ea       	ldi	r20, 0xA0	; 160
    3e66:	58 e0       	ldi	r21, 0x08	; 8
    3e68:	60 e0       	ldi	r22, 0x00	; 0
    3e6a:	70 e0       	ldi	r23, 0x00	; 0
    3e6c:	ce 01       	movw	r24, r28
    3e6e:	01 96       	adiw	r24, 0x01	; 1
    3e70:	0e 94 c2 1b 	call	0x3784	; 0x3784 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3e74:	67 e0       	ldi	r22, 0x07	; 7
    3e76:	ce 01       	movw	r24, r28
    3e78:	01 96       	adiw	r24, 0x01	; 1
    3e7a:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    3e7e:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3e80:	64 e8       	ldi	r22, 0x84	; 132
    3e82:	70 e2       	ldi	r23, 0x20	; 32
    3e84:	0e 94 d0 19 	call	0x33a0	; 0x33a0 <_ZN8emstream4putsEPKc>
    3e88:	66 e0       	ldi	r22, 0x06	; 6
    3e8a:	c8 01       	movw	r24, r16
    3e8c:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
    3e90:	66 e0       	ldi	r22, 0x06	; 6
    3e92:	0e 94 07 1a 	call	0x340e	; 0x340e <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3e96:	82 e1       	ldi	r24, 0x12	; 18
    3e98:	90 e0       	ldi	r25, 0x00	; 0
    3e9a:	0e 94 fd 18 	call	0x31fa	; 0x31fa <_Znwj>
    3e9e:	8e 01       	movw	r16, r28
    3ea0:	0f 5f       	subi	r16, 0xFF	; 255
    3ea2:	1f 4f       	sbci	r17, 0xFF	; 255
    3ea4:	24 e0       	ldi	r18, 0x04	; 4
    3ea6:	31 e0       	ldi	r19, 0x01	; 1
    3ea8:	40 e0       	ldi	r20, 0x00	; 0
    3eaa:	63 ea       	ldi	r22, 0xA3	; 163
    3eac:	70 e2       	ldi	r23, 0x20	; 32
    3eae:	0e 94 bc 06 	call	0xd78	; 0xd78 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3eb2:	82 e1       	ldi	r24, 0x12	; 18
    3eb4:	90 e0       	ldi	r25, 0x00	; 0
    3eb6:	0e 94 fd 18 	call	0x31fa	; 0x31fa <_Znwj>
    3eba:	24 e0       	ldi	r18, 0x04	; 4
    3ebc:	31 e0       	ldi	r19, 0x01	; 1
    3ebe:	42 e0       	ldi	r20, 0x02	; 2
    3ec0:	6b ea       	ldi	r22, 0xAB	; 171
    3ec2:	70 e2       	ldi	r23, 0x20	; 32
    3ec4:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3ec8:	82 e1       	ldi	r24, 0x12	; 18
    3eca:	90 e0       	ldi	r25, 0x00	; 0
    3ecc:	0e 94 fd 18 	call	0x31fa	; 0x31fa <_Znwj>
    3ed0:	24 e0       	ldi	r18, 0x04	; 4
    3ed2:	31 e0       	ldi	r19, 0x01	; 1
    3ed4:	43 e0       	ldi	r20, 0x03	; 3
    3ed6:	62 eb       	ldi	r22, 0xB2	; 178
    3ed8:	70 e2       	ldi	r23, 0x20	; 32
    3eda:	0e 94 de 03 	call	0x7bc	; 0x7bc <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3ede:	82 e1       	ldi	r24, 0x12	; 18
    3ee0:	90 e0       	ldi	r25, 0x00	; 0
    3ee2:	0e 94 fd 18 	call	0x31fa	; 0x31fa <_Znwj>
    3ee6:	24 e0       	ldi	r18, 0x04	; 4
    3ee8:	31 e0       	ldi	r19, 0x01	; 1
    3eea:	44 e0       	ldi	r20, 0x04	; 4
    3eec:	69 eb       	ldi	r22, 0xB9	; 185
    3eee:	70 e2       	ldi	r23, 0x20	; 32
    3ef0:	0e 94 46 04 	call	0x88c	; 0x88c <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(1), 260, &ser_dev);
    3ef4:	82 e4       	ldi	r24, 0x42	; 66
    3ef6:	90 e0       	ldi	r25, 0x00	; 0
    3ef8:	0e 94 fd 18 	call	0x31fa	; 0x31fa <_Znwj>
    3efc:	24 e0       	ldi	r18, 0x04	; 4
    3efe:	31 e0       	ldi	r19, 0x01	; 1
    3f00:	41 e0       	ldi	r20, 0x01	; 1
    3f02:	62 ec       	ldi	r22, 0xC2	; 194
    3f04:	70 e2       	ldi	r23, 0x20	; 32
    3f06:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <_ZN5MotorC1EPKchjP8emstream>

	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3f0a:	87 e0       	ldi	r24, 0x07	; 7
    3f0c:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3f10:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3f12:	0e 94 0f 10 	call	0x201e	; 0x201e <vTaskStartScheduler>
	
	return 0;
    3f16:	80 e0       	ldi	r24, 0x00	; 0
    3f18:	90 e0       	ldi	r25, 0x00	; 0
    3f1a:	6d 96       	adiw	r28, 0x1d	; 29
    3f1c:	cd bf       	out	0x3d, r28	; 61
    3f1e:	de bf       	out	0x3e, r29	; 62
    3f20:	df 91       	pop	r29
    3f22:	cf 91       	pop	r28
    3f24:	1f 91       	pop	r17
    3f26:	0f 91       	pop	r16
    3f28:	08 95       	ret

00003f2a <_GLOBAL__sub_I_counter>:
    3f2a:	0f 93       	push	r16
    3f2c:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3f2e:	0a e0       	ldi	r16, 0x0A	; 10
    3f30:	10 e0       	ldi	r17, 0x00	; 0
    3f32:	20 e0       	ldi	r18, 0x00	; 0
    3f34:	30 e0       	ldi	r19, 0x00	; 0
    3f36:	40 e0       	ldi	r20, 0x00	; 0
    3f38:	50 e0       	ldi	r21, 0x00	; 0
    3f3a:	60 e2       	ldi	r22, 0x20	; 32
    3f3c:	70 e0       	ldi	r23, 0x00	; 0
    3f3e:	84 e6       	ldi	r24, 0x64	; 100
    3f40:	91 e3       	ldi	r25, 0x31	; 49
    3f42:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    3f46:	1f 91       	pop	r17
    3f48:	0f 91       	pop	r16
    3f4a:	08 95       	ret

00003f4c <__subsf3>:
    3f4c:	50 58       	subi	r21, 0x80	; 128

00003f4e <__addsf3>:
    3f4e:	bb 27       	eor	r27, r27
    3f50:	aa 27       	eor	r26, r26
    3f52:	0e 94 be 1f 	call	0x3f7c	; 0x3f7c <__addsf3x>
    3f56:	0c 94 38 21 	jmp	0x4270	; 0x4270 <__fp_round>
    3f5a:	0e 94 2a 21 	call	0x4254	; 0x4254 <__fp_pscA>
    3f5e:	38 f0       	brcs	.+14     	; 0x3f6e <__addsf3+0x20>
    3f60:	0e 94 31 21 	call	0x4262	; 0x4262 <__fp_pscB>
    3f64:	20 f0       	brcs	.+8      	; 0x3f6e <__addsf3+0x20>
    3f66:	39 f4       	brne	.+14     	; 0x3f76 <__addsf3+0x28>
    3f68:	9f 3f       	cpi	r25, 0xFF	; 255
    3f6a:	19 f4       	brne	.+6      	; 0x3f72 <__addsf3+0x24>
    3f6c:	26 f4       	brtc	.+8      	; 0x3f76 <__addsf3+0x28>
    3f6e:	0c 94 27 21 	jmp	0x424e	; 0x424e <__fp_nan>
    3f72:	0e f4       	brtc	.+2      	; 0x3f76 <__addsf3+0x28>
    3f74:	e0 95       	com	r30
    3f76:	e7 fb       	bst	r30, 7
    3f78:	0c 94 21 21 	jmp	0x4242	; 0x4242 <__fp_inf>

00003f7c <__addsf3x>:
    3f7c:	e9 2f       	mov	r30, r25
    3f7e:	0e 94 49 21 	call	0x4292	; 0x4292 <__fp_split3>
    3f82:	58 f3       	brcs	.-42     	; 0x3f5a <__addsf3+0xc>
    3f84:	ba 17       	cp	r27, r26
    3f86:	62 07       	cpc	r22, r18
    3f88:	73 07       	cpc	r23, r19
    3f8a:	84 07       	cpc	r24, r20
    3f8c:	95 07       	cpc	r25, r21
    3f8e:	20 f0       	brcs	.+8      	; 0x3f98 <__addsf3x+0x1c>
    3f90:	79 f4       	brne	.+30     	; 0x3fb0 <__addsf3x+0x34>
    3f92:	a6 f5       	brtc	.+104    	; 0x3ffc <__addsf3x+0x80>
    3f94:	0c 94 6b 21 	jmp	0x42d6	; 0x42d6 <__fp_zero>
    3f98:	0e f4       	brtc	.+2      	; 0x3f9c <__addsf3x+0x20>
    3f9a:	e0 95       	com	r30
    3f9c:	0b 2e       	mov	r0, r27
    3f9e:	ba 2f       	mov	r27, r26
    3fa0:	a0 2d       	mov	r26, r0
    3fa2:	0b 01       	movw	r0, r22
    3fa4:	b9 01       	movw	r22, r18
    3fa6:	90 01       	movw	r18, r0
    3fa8:	0c 01       	movw	r0, r24
    3faa:	ca 01       	movw	r24, r20
    3fac:	a0 01       	movw	r20, r0
    3fae:	11 24       	eor	r1, r1
    3fb0:	ff 27       	eor	r31, r31
    3fb2:	59 1b       	sub	r21, r25
    3fb4:	99 f0       	breq	.+38     	; 0x3fdc <__addsf3x+0x60>
    3fb6:	59 3f       	cpi	r21, 0xF9	; 249
    3fb8:	50 f4       	brcc	.+20     	; 0x3fce <__addsf3x+0x52>
    3fba:	50 3e       	cpi	r21, 0xE0	; 224
    3fbc:	68 f1       	brcs	.+90     	; 0x4018 <__stack+0x19>
    3fbe:	1a 16       	cp	r1, r26
    3fc0:	f0 40       	sbci	r31, 0x00	; 0
    3fc2:	a2 2f       	mov	r26, r18
    3fc4:	23 2f       	mov	r18, r19
    3fc6:	34 2f       	mov	r19, r20
    3fc8:	44 27       	eor	r20, r20
    3fca:	58 5f       	subi	r21, 0xF8	; 248
    3fcc:	f3 cf       	rjmp	.-26     	; 0x3fb4 <__addsf3x+0x38>
    3fce:	46 95       	lsr	r20
    3fd0:	37 95       	ror	r19
    3fd2:	27 95       	ror	r18
    3fd4:	a7 95       	ror	r26
    3fd6:	f0 40       	sbci	r31, 0x00	; 0
    3fd8:	53 95       	inc	r21
    3fda:	c9 f7       	brne	.-14     	; 0x3fce <__addsf3x+0x52>
    3fdc:	7e f4       	brtc	.+30     	; 0x3ffc <__addsf3x+0x80>
    3fde:	1f 16       	cp	r1, r31
    3fe0:	ba 0b       	sbc	r27, r26
    3fe2:	62 0b       	sbc	r22, r18
    3fe4:	73 0b       	sbc	r23, r19
    3fe6:	84 0b       	sbc	r24, r20
    3fe8:	ba f0       	brmi	.+46     	; 0x4018 <__stack+0x19>
    3fea:	91 50       	subi	r25, 0x01	; 1
    3fec:	a1 f0       	breq	.+40     	; 0x4016 <__stack+0x17>
    3fee:	ff 0f       	add	r31, r31
    3ff0:	bb 1f       	adc	r27, r27
    3ff2:	66 1f       	adc	r22, r22
    3ff4:	77 1f       	adc	r23, r23
    3ff6:	88 1f       	adc	r24, r24
    3ff8:	c2 f7       	brpl	.-16     	; 0x3fea <__addsf3x+0x6e>
    3ffa:	0e c0       	rjmp	.+28     	; 0x4018 <__stack+0x19>
    3ffc:	ba 0f       	add	r27, r26
    3ffe:	62 1f       	adc	r22, r18
    4000:	73 1f       	adc	r23, r19
    4002:	84 1f       	adc	r24, r20
    4004:	48 f4       	brcc	.+18     	; 0x4018 <__stack+0x19>
    4006:	87 95       	ror	r24
    4008:	77 95       	ror	r23
    400a:	67 95       	ror	r22
    400c:	b7 95       	ror	r27
    400e:	f7 95       	ror	r31
    4010:	9e 3f       	cpi	r25, 0xFE	; 254
    4012:	08 f0       	brcs	.+2      	; 0x4016 <__stack+0x17>
    4014:	b0 cf       	rjmp	.-160    	; 0x3f76 <__addsf3+0x28>
    4016:	93 95       	inc	r25
    4018:	88 0f       	add	r24, r24
    401a:	08 f0       	brcs	.+2      	; 0x401e <__stack+0x1f>
    401c:	99 27       	eor	r25, r25
    401e:	ee 0f       	add	r30, r30
    4020:	97 95       	ror	r25
    4022:	87 95       	ror	r24
    4024:	08 95       	ret

00004026 <__cmpsf2>:
    4026:	0e 94 fd 20 	call	0x41fa	; 0x41fa <__fp_cmp>
    402a:	08 f4       	brcc	.+2      	; 0x402e <__cmpsf2+0x8>
    402c:	81 e0       	ldi	r24, 0x01	; 1
    402e:	08 95       	ret

00004030 <__divsf3>:
    4030:	0e 94 2c 20 	call	0x4058	; 0x4058 <__divsf3x>
    4034:	0c 94 38 21 	jmp	0x4270	; 0x4270 <__fp_round>
    4038:	0e 94 31 21 	call	0x4262	; 0x4262 <__fp_pscB>
    403c:	58 f0       	brcs	.+22     	; 0x4054 <__divsf3+0x24>
    403e:	0e 94 2a 21 	call	0x4254	; 0x4254 <__fp_pscA>
    4042:	40 f0       	brcs	.+16     	; 0x4054 <__divsf3+0x24>
    4044:	29 f4       	brne	.+10     	; 0x4050 <__divsf3+0x20>
    4046:	5f 3f       	cpi	r21, 0xFF	; 255
    4048:	29 f0       	breq	.+10     	; 0x4054 <__divsf3+0x24>
    404a:	0c 94 21 21 	jmp	0x4242	; 0x4242 <__fp_inf>
    404e:	51 11       	cpse	r21, r1
    4050:	0c 94 6c 21 	jmp	0x42d8	; 0x42d8 <__fp_szero>
    4054:	0c 94 27 21 	jmp	0x424e	; 0x424e <__fp_nan>

00004058 <__divsf3x>:
    4058:	0e 94 49 21 	call	0x4292	; 0x4292 <__fp_split3>
    405c:	68 f3       	brcs	.-38     	; 0x4038 <__divsf3+0x8>

0000405e <__divsf3_pse>:
    405e:	99 23       	and	r25, r25
    4060:	b1 f3       	breq	.-20     	; 0x404e <__divsf3+0x1e>
    4062:	55 23       	and	r21, r21
    4064:	91 f3       	breq	.-28     	; 0x404a <__divsf3+0x1a>
    4066:	95 1b       	sub	r25, r21
    4068:	55 0b       	sbc	r21, r21
    406a:	bb 27       	eor	r27, r27
    406c:	aa 27       	eor	r26, r26
    406e:	62 17       	cp	r22, r18
    4070:	73 07       	cpc	r23, r19
    4072:	84 07       	cpc	r24, r20
    4074:	38 f0       	brcs	.+14     	; 0x4084 <__divsf3_pse+0x26>
    4076:	9f 5f       	subi	r25, 0xFF	; 255
    4078:	5f 4f       	sbci	r21, 0xFF	; 255
    407a:	22 0f       	add	r18, r18
    407c:	33 1f       	adc	r19, r19
    407e:	44 1f       	adc	r20, r20
    4080:	aa 1f       	adc	r26, r26
    4082:	a9 f3       	breq	.-22     	; 0x406e <__divsf3_pse+0x10>
    4084:	35 d0       	rcall	.+106    	; 0x40f0 <__divsf3_pse+0x92>
    4086:	0e 2e       	mov	r0, r30
    4088:	3a f0       	brmi	.+14     	; 0x4098 <__divsf3_pse+0x3a>
    408a:	e0 e8       	ldi	r30, 0x80	; 128
    408c:	32 d0       	rcall	.+100    	; 0x40f2 <__divsf3_pse+0x94>
    408e:	91 50       	subi	r25, 0x01	; 1
    4090:	50 40       	sbci	r21, 0x00	; 0
    4092:	e6 95       	lsr	r30
    4094:	00 1c       	adc	r0, r0
    4096:	ca f7       	brpl	.-14     	; 0x408a <__divsf3_pse+0x2c>
    4098:	2b d0       	rcall	.+86     	; 0x40f0 <__divsf3_pse+0x92>
    409a:	fe 2f       	mov	r31, r30
    409c:	29 d0       	rcall	.+82     	; 0x40f0 <__divsf3_pse+0x92>
    409e:	66 0f       	add	r22, r22
    40a0:	77 1f       	adc	r23, r23
    40a2:	88 1f       	adc	r24, r24
    40a4:	bb 1f       	adc	r27, r27
    40a6:	26 17       	cp	r18, r22
    40a8:	37 07       	cpc	r19, r23
    40aa:	48 07       	cpc	r20, r24
    40ac:	ab 07       	cpc	r26, r27
    40ae:	b0 e8       	ldi	r27, 0x80	; 128
    40b0:	09 f0       	breq	.+2      	; 0x40b4 <__divsf3_pse+0x56>
    40b2:	bb 0b       	sbc	r27, r27
    40b4:	80 2d       	mov	r24, r0
    40b6:	bf 01       	movw	r22, r30
    40b8:	ff 27       	eor	r31, r31
    40ba:	93 58       	subi	r25, 0x83	; 131
    40bc:	5f 4f       	sbci	r21, 0xFF	; 255
    40be:	3a f0       	brmi	.+14     	; 0x40ce <__divsf3_pse+0x70>
    40c0:	9e 3f       	cpi	r25, 0xFE	; 254
    40c2:	51 05       	cpc	r21, r1
    40c4:	78 f0       	brcs	.+30     	; 0x40e4 <__divsf3_pse+0x86>
    40c6:	0c 94 21 21 	jmp	0x4242	; 0x4242 <__fp_inf>
    40ca:	0c 94 6c 21 	jmp	0x42d8	; 0x42d8 <__fp_szero>
    40ce:	5f 3f       	cpi	r21, 0xFF	; 255
    40d0:	e4 f3       	brlt	.-8      	; 0x40ca <__divsf3_pse+0x6c>
    40d2:	98 3e       	cpi	r25, 0xE8	; 232
    40d4:	d4 f3       	brlt	.-12     	; 0x40ca <__divsf3_pse+0x6c>
    40d6:	86 95       	lsr	r24
    40d8:	77 95       	ror	r23
    40da:	67 95       	ror	r22
    40dc:	b7 95       	ror	r27
    40de:	f7 95       	ror	r31
    40e0:	9f 5f       	subi	r25, 0xFF	; 255
    40e2:	c9 f7       	brne	.-14     	; 0x40d6 <__divsf3_pse+0x78>
    40e4:	88 0f       	add	r24, r24
    40e6:	91 1d       	adc	r25, r1
    40e8:	96 95       	lsr	r25
    40ea:	87 95       	ror	r24
    40ec:	97 f9       	bld	r25, 7
    40ee:	08 95       	ret
    40f0:	e1 e0       	ldi	r30, 0x01	; 1
    40f2:	66 0f       	add	r22, r22
    40f4:	77 1f       	adc	r23, r23
    40f6:	88 1f       	adc	r24, r24
    40f8:	bb 1f       	adc	r27, r27
    40fa:	62 17       	cp	r22, r18
    40fc:	73 07       	cpc	r23, r19
    40fe:	84 07       	cpc	r24, r20
    4100:	ba 07       	cpc	r27, r26
    4102:	20 f0       	brcs	.+8      	; 0x410c <__divsf3_pse+0xae>
    4104:	62 1b       	sub	r22, r18
    4106:	73 0b       	sbc	r23, r19
    4108:	84 0b       	sbc	r24, r20
    410a:	ba 0b       	sbc	r27, r26
    410c:	ee 1f       	adc	r30, r30
    410e:	88 f7       	brcc	.-30     	; 0x40f2 <__divsf3_pse+0x94>
    4110:	e0 95       	com	r30
    4112:	08 95       	ret

00004114 <__fixsfsi>:
    4114:	0e 94 91 20 	call	0x4122	; 0x4122 <__fixunssfsi>
    4118:	68 94       	set
    411a:	b1 11       	cpse	r27, r1
    411c:	0c 94 6c 21 	jmp	0x42d8	; 0x42d8 <__fp_szero>
    4120:	08 95       	ret

00004122 <__fixunssfsi>:
    4122:	0e 94 51 21 	call	0x42a2	; 0x42a2 <__fp_splitA>
    4126:	88 f0       	brcs	.+34     	; 0x414a <__fixunssfsi+0x28>
    4128:	9f 57       	subi	r25, 0x7F	; 127
    412a:	98 f0       	brcs	.+38     	; 0x4152 <__fixunssfsi+0x30>
    412c:	b9 2f       	mov	r27, r25
    412e:	99 27       	eor	r25, r25
    4130:	b7 51       	subi	r27, 0x17	; 23
    4132:	b0 f0       	brcs	.+44     	; 0x4160 <__fixunssfsi+0x3e>
    4134:	e1 f0       	breq	.+56     	; 0x416e <__fixunssfsi+0x4c>
    4136:	66 0f       	add	r22, r22
    4138:	77 1f       	adc	r23, r23
    413a:	88 1f       	adc	r24, r24
    413c:	99 1f       	adc	r25, r25
    413e:	1a f0       	brmi	.+6      	; 0x4146 <__fixunssfsi+0x24>
    4140:	ba 95       	dec	r27
    4142:	c9 f7       	brne	.-14     	; 0x4136 <__fixunssfsi+0x14>
    4144:	14 c0       	rjmp	.+40     	; 0x416e <__fixunssfsi+0x4c>
    4146:	b1 30       	cpi	r27, 0x01	; 1
    4148:	91 f0       	breq	.+36     	; 0x416e <__fixunssfsi+0x4c>
    414a:	0e 94 6b 21 	call	0x42d6	; 0x42d6 <__fp_zero>
    414e:	b1 e0       	ldi	r27, 0x01	; 1
    4150:	08 95       	ret
    4152:	0c 94 6b 21 	jmp	0x42d6	; 0x42d6 <__fp_zero>
    4156:	67 2f       	mov	r22, r23
    4158:	78 2f       	mov	r23, r24
    415a:	88 27       	eor	r24, r24
    415c:	b8 5f       	subi	r27, 0xF8	; 248
    415e:	39 f0       	breq	.+14     	; 0x416e <__fixunssfsi+0x4c>
    4160:	b9 3f       	cpi	r27, 0xF9	; 249
    4162:	cc f3       	brlt	.-14     	; 0x4156 <__fixunssfsi+0x34>
    4164:	86 95       	lsr	r24
    4166:	77 95       	ror	r23
    4168:	67 95       	ror	r22
    416a:	b3 95       	inc	r27
    416c:	d9 f7       	brne	.-10     	; 0x4164 <__fixunssfsi+0x42>
    416e:	3e f4       	brtc	.+14     	; 0x417e <__fixunssfsi+0x5c>
    4170:	90 95       	com	r25
    4172:	80 95       	com	r24
    4174:	70 95       	com	r23
    4176:	61 95       	neg	r22
    4178:	7f 4f       	sbci	r23, 0xFF	; 255
    417a:	8f 4f       	sbci	r24, 0xFF	; 255
    417c:	9f 4f       	sbci	r25, 0xFF	; 255
    417e:	08 95       	ret

00004180 <__floatunsisf>:
    4180:	e8 94       	clt
    4182:	09 c0       	rjmp	.+18     	; 0x4196 <__floatsisf+0x12>

00004184 <__floatsisf>:
    4184:	97 fb       	bst	r25, 7
    4186:	3e f4       	brtc	.+14     	; 0x4196 <__floatsisf+0x12>
    4188:	90 95       	com	r25
    418a:	80 95       	com	r24
    418c:	70 95       	com	r23
    418e:	61 95       	neg	r22
    4190:	7f 4f       	sbci	r23, 0xFF	; 255
    4192:	8f 4f       	sbci	r24, 0xFF	; 255
    4194:	9f 4f       	sbci	r25, 0xFF	; 255
    4196:	99 23       	and	r25, r25
    4198:	a9 f0       	breq	.+42     	; 0x41c4 <__floatsisf+0x40>
    419a:	f9 2f       	mov	r31, r25
    419c:	96 e9       	ldi	r25, 0x96	; 150
    419e:	bb 27       	eor	r27, r27
    41a0:	93 95       	inc	r25
    41a2:	f6 95       	lsr	r31
    41a4:	87 95       	ror	r24
    41a6:	77 95       	ror	r23
    41a8:	67 95       	ror	r22
    41aa:	b7 95       	ror	r27
    41ac:	f1 11       	cpse	r31, r1
    41ae:	f8 cf       	rjmp	.-16     	; 0x41a0 <__floatsisf+0x1c>
    41b0:	fa f4       	brpl	.+62     	; 0x41f0 <__floatsisf+0x6c>
    41b2:	bb 0f       	add	r27, r27
    41b4:	11 f4       	brne	.+4      	; 0x41ba <__floatsisf+0x36>
    41b6:	60 ff       	sbrs	r22, 0
    41b8:	1b c0       	rjmp	.+54     	; 0x41f0 <__floatsisf+0x6c>
    41ba:	6f 5f       	subi	r22, 0xFF	; 255
    41bc:	7f 4f       	sbci	r23, 0xFF	; 255
    41be:	8f 4f       	sbci	r24, 0xFF	; 255
    41c0:	9f 4f       	sbci	r25, 0xFF	; 255
    41c2:	16 c0       	rjmp	.+44     	; 0x41f0 <__floatsisf+0x6c>
    41c4:	88 23       	and	r24, r24
    41c6:	11 f0       	breq	.+4      	; 0x41cc <__floatsisf+0x48>
    41c8:	96 e9       	ldi	r25, 0x96	; 150
    41ca:	11 c0       	rjmp	.+34     	; 0x41ee <__floatsisf+0x6a>
    41cc:	77 23       	and	r23, r23
    41ce:	21 f0       	breq	.+8      	; 0x41d8 <__floatsisf+0x54>
    41d0:	9e e8       	ldi	r25, 0x8E	; 142
    41d2:	87 2f       	mov	r24, r23
    41d4:	76 2f       	mov	r23, r22
    41d6:	05 c0       	rjmp	.+10     	; 0x41e2 <__floatsisf+0x5e>
    41d8:	66 23       	and	r22, r22
    41da:	71 f0       	breq	.+28     	; 0x41f8 <__floatsisf+0x74>
    41dc:	96 e8       	ldi	r25, 0x86	; 134
    41de:	86 2f       	mov	r24, r22
    41e0:	70 e0       	ldi	r23, 0x00	; 0
    41e2:	60 e0       	ldi	r22, 0x00	; 0
    41e4:	2a f0       	brmi	.+10     	; 0x41f0 <__floatsisf+0x6c>
    41e6:	9a 95       	dec	r25
    41e8:	66 0f       	add	r22, r22
    41ea:	77 1f       	adc	r23, r23
    41ec:	88 1f       	adc	r24, r24
    41ee:	da f7       	brpl	.-10     	; 0x41e6 <__floatsisf+0x62>
    41f0:	88 0f       	add	r24, r24
    41f2:	96 95       	lsr	r25
    41f4:	87 95       	ror	r24
    41f6:	97 f9       	bld	r25, 7
    41f8:	08 95       	ret

000041fa <__fp_cmp>:
    41fa:	99 0f       	add	r25, r25
    41fc:	00 08       	sbc	r0, r0
    41fe:	55 0f       	add	r21, r21
    4200:	aa 0b       	sbc	r26, r26
    4202:	e0 e8       	ldi	r30, 0x80	; 128
    4204:	fe ef       	ldi	r31, 0xFE	; 254
    4206:	16 16       	cp	r1, r22
    4208:	17 06       	cpc	r1, r23
    420a:	e8 07       	cpc	r30, r24
    420c:	f9 07       	cpc	r31, r25
    420e:	c0 f0       	brcs	.+48     	; 0x4240 <__fp_cmp+0x46>
    4210:	12 16       	cp	r1, r18
    4212:	13 06       	cpc	r1, r19
    4214:	e4 07       	cpc	r30, r20
    4216:	f5 07       	cpc	r31, r21
    4218:	98 f0       	brcs	.+38     	; 0x4240 <__fp_cmp+0x46>
    421a:	62 1b       	sub	r22, r18
    421c:	73 0b       	sbc	r23, r19
    421e:	84 0b       	sbc	r24, r20
    4220:	95 0b       	sbc	r25, r21
    4222:	39 f4       	brne	.+14     	; 0x4232 <__fp_cmp+0x38>
    4224:	0a 26       	eor	r0, r26
    4226:	61 f0       	breq	.+24     	; 0x4240 <__fp_cmp+0x46>
    4228:	23 2b       	or	r18, r19
    422a:	24 2b       	or	r18, r20
    422c:	25 2b       	or	r18, r21
    422e:	21 f4       	brne	.+8      	; 0x4238 <__fp_cmp+0x3e>
    4230:	08 95       	ret
    4232:	0a 26       	eor	r0, r26
    4234:	09 f4       	brne	.+2      	; 0x4238 <__fp_cmp+0x3e>
    4236:	a1 40       	sbci	r26, 0x01	; 1
    4238:	a6 95       	lsr	r26
    423a:	8f ef       	ldi	r24, 0xFF	; 255
    423c:	81 1d       	adc	r24, r1
    423e:	81 1d       	adc	r24, r1
    4240:	08 95       	ret

00004242 <__fp_inf>:
    4242:	97 f9       	bld	r25, 7
    4244:	9f 67       	ori	r25, 0x7F	; 127
    4246:	80 e8       	ldi	r24, 0x80	; 128
    4248:	70 e0       	ldi	r23, 0x00	; 0
    424a:	60 e0       	ldi	r22, 0x00	; 0
    424c:	08 95       	ret

0000424e <__fp_nan>:
    424e:	9f ef       	ldi	r25, 0xFF	; 255
    4250:	80 ec       	ldi	r24, 0xC0	; 192
    4252:	08 95       	ret

00004254 <__fp_pscA>:
    4254:	00 24       	eor	r0, r0
    4256:	0a 94       	dec	r0
    4258:	16 16       	cp	r1, r22
    425a:	17 06       	cpc	r1, r23
    425c:	18 06       	cpc	r1, r24
    425e:	09 06       	cpc	r0, r25
    4260:	08 95       	ret

00004262 <__fp_pscB>:
    4262:	00 24       	eor	r0, r0
    4264:	0a 94       	dec	r0
    4266:	12 16       	cp	r1, r18
    4268:	13 06       	cpc	r1, r19
    426a:	14 06       	cpc	r1, r20
    426c:	05 06       	cpc	r0, r21
    426e:	08 95       	ret

00004270 <__fp_round>:
    4270:	09 2e       	mov	r0, r25
    4272:	03 94       	inc	r0
    4274:	00 0c       	add	r0, r0
    4276:	11 f4       	brne	.+4      	; 0x427c <__fp_round+0xc>
    4278:	88 23       	and	r24, r24
    427a:	52 f0       	brmi	.+20     	; 0x4290 <__fp_round+0x20>
    427c:	bb 0f       	add	r27, r27
    427e:	40 f4       	brcc	.+16     	; 0x4290 <__fp_round+0x20>
    4280:	bf 2b       	or	r27, r31
    4282:	11 f4       	brne	.+4      	; 0x4288 <__fp_round+0x18>
    4284:	60 ff       	sbrs	r22, 0
    4286:	04 c0       	rjmp	.+8      	; 0x4290 <__fp_round+0x20>
    4288:	6f 5f       	subi	r22, 0xFF	; 255
    428a:	7f 4f       	sbci	r23, 0xFF	; 255
    428c:	8f 4f       	sbci	r24, 0xFF	; 255
    428e:	9f 4f       	sbci	r25, 0xFF	; 255
    4290:	08 95       	ret

00004292 <__fp_split3>:
    4292:	57 fd       	sbrc	r21, 7
    4294:	90 58       	subi	r25, 0x80	; 128
    4296:	44 0f       	add	r20, r20
    4298:	55 1f       	adc	r21, r21
    429a:	59 f0       	breq	.+22     	; 0x42b2 <__fp_splitA+0x10>
    429c:	5f 3f       	cpi	r21, 0xFF	; 255
    429e:	71 f0       	breq	.+28     	; 0x42bc <__fp_splitA+0x1a>
    42a0:	47 95       	ror	r20

000042a2 <__fp_splitA>:
    42a2:	88 0f       	add	r24, r24
    42a4:	97 fb       	bst	r25, 7
    42a6:	99 1f       	adc	r25, r25
    42a8:	61 f0       	breq	.+24     	; 0x42c2 <__fp_splitA+0x20>
    42aa:	9f 3f       	cpi	r25, 0xFF	; 255
    42ac:	79 f0       	breq	.+30     	; 0x42cc <__fp_splitA+0x2a>
    42ae:	87 95       	ror	r24
    42b0:	08 95       	ret
    42b2:	12 16       	cp	r1, r18
    42b4:	13 06       	cpc	r1, r19
    42b6:	14 06       	cpc	r1, r20
    42b8:	55 1f       	adc	r21, r21
    42ba:	f2 cf       	rjmp	.-28     	; 0x42a0 <__fp_split3+0xe>
    42bc:	46 95       	lsr	r20
    42be:	f1 df       	rcall	.-30     	; 0x42a2 <__fp_splitA>
    42c0:	08 c0       	rjmp	.+16     	; 0x42d2 <__fp_splitA+0x30>
    42c2:	16 16       	cp	r1, r22
    42c4:	17 06       	cpc	r1, r23
    42c6:	18 06       	cpc	r1, r24
    42c8:	99 1f       	adc	r25, r25
    42ca:	f1 cf       	rjmp	.-30     	; 0x42ae <__fp_splitA+0xc>
    42cc:	86 95       	lsr	r24
    42ce:	71 05       	cpc	r23, r1
    42d0:	61 05       	cpc	r22, r1
    42d2:	08 94       	sec
    42d4:	08 95       	ret

000042d6 <__fp_zero>:
    42d6:	e8 94       	clt

000042d8 <__fp_szero>:
    42d8:	bb 27       	eor	r27, r27
    42da:	66 27       	eor	r22, r22
    42dc:	77 27       	eor	r23, r23
    42de:	cb 01       	movw	r24, r22
    42e0:	97 f9       	bld	r25, 7
    42e2:	08 95       	ret

000042e4 <__gesf2>:
    42e4:	0e 94 fd 20 	call	0x41fa	; 0x41fa <__fp_cmp>
    42e8:	08 f4       	brcc	.+2      	; 0x42ec <__gesf2+0x8>
    42ea:	8f ef       	ldi	r24, 0xFF	; 255
    42ec:	08 95       	ret

000042ee <__mulsf3>:
    42ee:	0e 94 8a 21 	call	0x4314	; 0x4314 <__mulsf3x>
    42f2:	0c 94 38 21 	jmp	0x4270	; 0x4270 <__fp_round>
    42f6:	0e 94 2a 21 	call	0x4254	; 0x4254 <__fp_pscA>
    42fa:	38 f0       	brcs	.+14     	; 0x430a <__mulsf3+0x1c>
    42fc:	0e 94 31 21 	call	0x4262	; 0x4262 <__fp_pscB>
    4300:	20 f0       	brcs	.+8      	; 0x430a <__mulsf3+0x1c>
    4302:	95 23       	and	r25, r21
    4304:	11 f0       	breq	.+4      	; 0x430a <__mulsf3+0x1c>
    4306:	0c 94 21 21 	jmp	0x4242	; 0x4242 <__fp_inf>
    430a:	0c 94 27 21 	jmp	0x424e	; 0x424e <__fp_nan>
    430e:	11 24       	eor	r1, r1
    4310:	0c 94 6c 21 	jmp	0x42d8	; 0x42d8 <__fp_szero>

00004314 <__mulsf3x>:
    4314:	0e 94 49 21 	call	0x4292	; 0x4292 <__fp_split3>
    4318:	70 f3       	brcs	.-36     	; 0x42f6 <__mulsf3+0x8>

0000431a <__mulsf3_pse>:
    431a:	95 9f       	mul	r25, r21
    431c:	c1 f3       	breq	.-16     	; 0x430e <__mulsf3+0x20>
    431e:	95 0f       	add	r25, r21
    4320:	50 e0       	ldi	r21, 0x00	; 0
    4322:	55 1f       	adc	r21, r21
    4324:	62 9f       	mul	r22, r18
    4326:	f0 01       	movw	r30, r0
    4328:	72 9f       	mul	r23, r18
    432a:	bb 27       	eor	r27, r27
    432c:	f0 0d       	add	r31, r0
    432e:	b1 1d       	adc	r27, r1
    4330:	63 9f       	mul	r22, r19
    4332:	aa 27       	eor	r26, r26
    4334:	f0 0d       	add	r31, r0
    4336:	b1 1d       	adc	r27, r1
    4338:	aa 1f       	adc	r26, r26
    433a:	64 9f       	mul	r22, r20
    433c:	66 27       	eor	r22, r22
    433e:	b0 0d       	add	r27, r0
    4340:	a1 1d       	adc	r26, r1
    4342:	66 1f       	adc	r22, r22
    4344:	82 9f       	mul	r24, r18
    4346:	22 27       	eor	r18, r18
    4348:	b0 0d       	add	r27, r0
    434a:	a1 1d       	adc	r26, r1
    434c:	62 1f       	adc	r22, r18
    434e:	73 9f       	mul	r23, r19
    4350:	b0 0d       	add	r27, r0
    4352:	a1 1d       	adc	r26, r1
    4354:	62 1f       	adc	r22, r18
    4356:	83 9f       	mul	r24, r19
    4358:	a0 0d       	add	r26, r0
    435a:	61 1d       	adc	r22, r1
    435c:	22 1f       	adc	r18, r18
    435e:	74 9f       	mul	r23, r20
    4360:	33 27       	eor	r19, r19
    4362:	a0 0d       	add	r26, r0
    4364:	61 1d       	adc	r22, r1
    4366:	23 1f       	adc	r18, r19
    4368:	84 9f       	mul	r24, r20
    436a:	60 0d       	add	r22, r0
    436c:	21 1d       	adc	r18, r1
    436e:	82 2f       	mov	r24, r18
    4370:	76 2f       	mov	r23, r22
    4372:	6a 2f       	mov	r22, r26
    4374:	11 24       	eor	r1, r1
    4376:	9f 57       	subi	r25, 0x7F	; 127
    4378:	50 40       	sbci	r21, 0x00	; 0
    437a:	9a f0       	brmi	.+38     	; 0x43a2 <__mulsf3_pse+0x88>
    437c:	f1 f0       	breq	.+60     	; 0x43ba <__mulsf3_pse+0xa0>
    437e:	88 23       	and	r24, r24
    4380:	4a f0       	brmi	.+18     	; 0x4394 <__mulsf3_pse+0x7a>
    4382:	ee 0f       	add	r30, r30
    4384:	ff 1f       	adc	r31, r31
    4386:	bb 1f       	adc	r27, r27
    4388:	66 1f       	adc	r22, r22
    438a:	77 1f       	adc	r23, r23
    438c:	88 1f       	adc	r24, r24
    438e:	91 50       	subi	r25, 0x01	; 1
    4390:	50 40       	sbci	r21, 0x00	; 0
    4392:	a9 f7       	brne	.-22     	; 0x437e <__mulsf3_pse+0x64>
    4394:	9e 3f       	cpi	r25, 0xFE	; 254
    4396:	51 05       	cpc	r21, r1
    4398:	80 f0       	brcs	.+32     	; 0x43ba <__mulsf3_pse+0xa0>
    439a:	0c 94 21 21 	jmp	0x4242	; 0x4242 <__fp_inf>
    439e:	0c 94 6c 21 	jmp	0x42d8	; 0x42d8 <__fp_szero>
    43a2:	5f 3f       	cpi	r21, 0xFF	; 255
    43a4:	e4 f3       	brlt	.-8      	; 0x439e <__mulsf3_pse+0x84>
    43a6:	98 3e       	cpi	r25, 0xE8	; 232
    43a8:	d4 f3       	brlt	.-12     	; 0x439e <__mulsf3_pse+0x84>
    43aa:	86 95       	lsr	r24
    43ac:	77 95       	ror	r23
    43ae:	67 95       	ror	r22
    43b0:	b7 95       	ror	r27
    43b2:	f7 95       	ror	r31
    43b4:	e7 95       	ror	r30
    43b6:	9f 5f       	subi	r25, 0xFF	; 255
    43b8:	c1 f7       	brne	.-16     	; 0x43aa <__mulsf3_pse+0x90>
    43ba:	fe 2b       	or	r31, r30
    43bc:	88 0f       	add	r24, r24
    43be:	91 1d       	adc	r25, r1
    43c0:	96 95       	lsr	r25
    43c2:	87 95       	ror	r24
    43c4:	97 f9       	bld	r25, 7
    43c6:	08 95       	ret

000043c8 <__mulsi3>:
    43c8:	db 01       	movw	r26, r22
    43ca:	8f 93       	push	r24
    43cc:	9f 93       	push	r25
    43ce:	0e 94 3e 22 	call	0x447c	; 0x447c <__muluhisi3>
    43d2:	bf 91       	pop	r27
    43d4:	af 91       	pop	r26
    43d6:	a2 9f       	mul	r26, r18
    43d8:	80 0d       	add	r24, r0
    43da:	91 1d       	adc	r25, r1
    43dc:	a3 9f       	mul	r26, r19
    43de:	90 0d       	add	r25, r0
    43e0:	b2 9f       	mul	r27, r18
    43e2:	90 0d       	add	r25, r0
    43e4:	11 24       	eor	r1, r1
    43e6:	08 95       	ret

000043e8 <__udivmodsi4>:
    43e8:	a1 e2       	ldi	r26, 0x21	; 33
    43ea:	1a 2e       	mov	r1, r26
    43ec:	aa 1b       	sub	r26, r26
    43ee:	bb 1b       	sub	r27, r27
    43f0:	fd 01       	movw	r30, r26
    43f2:	0d c0       	rjmp	.+26     	; 0x440e <__udivmodsi4_ep>

000043f4 <__udivmodsi4_loop>:
    43f4:	aa 1f       	adc	r26, r26
    43f6:	bb 1f       	adc	r27, r27
    43f8:	ee 1f       	adc	r30, r30
    43fa:	ff 1f       	adc	r31, r31
    43fc:	a2 17       	cp	r26, r18
    43fe:	b3 07       	cpc	r27, r19
    4400:	e4 07       	cpc	r30, r20
    4402:	f5 07       	cpc	r31, r21
    4404:	20 f0       	brcs	.+8      	; 0x440e <__udivmodsi4_ep>
    4406:	a2 1b       	sub	r26, r18
    4408:	b3 0b       	sbc	r27, r19
    440a:	e4 0b       	sbc	r30, r20
    440c:	f5 0b       	sbc	r31, r21

0000440e <__udivmodsi4_ep>:
    440e:	66 1f       	adc	r22, r22
    4410:	77 1f       	adc	r23, r23
    4412:	88 1f       	adc	r24, r24
    4414:	99 1f       	adc	r25, r25
    4416:	1a 94       	dec	r1
    4418:	69 f7       	brne	.-38     	; 0x43f4 <__udivmodsi4_loop>
    441a:	60 95       	com	r22
    441c:	70 95       	com	r23
    441e:	80 95       	com	r24
    4420:	90 95       	com	r25
    4422:	9b 01       	movw	r18, r22
    4424:	ac 01       	movw	r20, r24
    4426:	bd 01       	movw	r22, r26
    4428:	cf 01       	movw	r24, r30
    442a:	08 95       	ret

0000442c <__divmodsi4>:
    442c:	05 2e       	mov	r0, r21
    442e:	97 fb       	bst	r25, 7
    4430:	1e f4       	brtc	.+6      	; 0x4438 <__divmodsi4+0xc>
    4432:	00 94       	com	r0
    4434:	0e 94 2d 22 	call	0x445a	; 0x445a <__negsi2>
    4438:	57 fd       	sbrc	r21, 7
    443a:	07 d0       	rcall	.+14     	; 0x444a <__divmodsi4_neg2>
    443c:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <__udivmodsi4>
    4440:	07 fc       	sbrc	r0, 7
    4442:	03 d0       	rcall	.+6      	; 0x444a <__divmodsi4_neg2>
    4444:	4e f4       	brtc	.+18     	; 0x4458 <__divmodsi4_exit>
    4446:	0c 94 2d 22 	jmp	0x445a	; 0x445a <__negsi2>

0000444a <__divmodsi4_neg2>:
    444a:	50 95       	com	r21
    444c:	40 95       	com	r20
    444e:	30 95       	com	r19
    4450:	21 95       	neg	r18
    4452:	3f 4f       	sbci	r19, 0xFF	; 255
    4454:	4f 4f       	sbci	r20, 0xFF	; 255
    4456:	5f 4f       	sbci	r21, 0xFF	; 255

00004458 <__divmodsi4_exit>:
    4458:	08 95       	ret

0000445a <__negsi2>:
    445a:	90 95       	com	r25
    445c:	80 95       	com	r24
    445e:	70 95       	com	r23
    4460:	61 95       	neg	r22
    4462:	7f 4f       	sbci	r23, 0xFF	; 255
    4464:	8f 4f       	sbci	r24, 0xFF	; 255
    4466:	9f 4f       	sbci	r25, 0xFF	; 255
    4468:	08 95       	ret

0000446a <__tablejump2__>:
    446a:	ee 0f       	add	r30, r30
    446c:	ff 1f       	adc	r31, r31
    446e:	88 1f       	adc	r24, r24
    4470:	8b bf       	out	0x3b, r24	; 59
    4472:	07 90       	elpm	r0, Z+
    4474:	f6 91       	elpm	r31, Z
    4476:	e0 2d       	mov	r30, r0
    4478:	1b be       	out	0x3b, r1	; 59
    447a:	19 94       	eijmp

0000447c <__muluhisi3>:
    447c:	0e 94 49 22 	call	0x4492	; 0x4492 <__umulhisi3>
    4480:	a5 9f       	mul	r26, r21
    4482:	90 0d       	add	r25, r0
    4484:	b4 9f       	mul	r27, r20
    4486:	90 0d       	add	r25, r0
    4488:	a4 9f       	mul	r26, r20
    448a:	80 0d       	add	r24, r0
    448c:	91 1d       	adc	r25, r1
    448e:	11 24       	eor	r1, r1
    4490:	08 95       	ret

00004492 <__umulhisi3>:
    4492:	a2 9f       	mul	r26, r18
    4494:	b0 01       	movw	r22, r0
    4496:	b3 9f       	mul	r27, r19
    4498:	c0 01       	movw	r24, r0
    449a:	a3 9f       	mul	r26, r19
    449c:	70 0d       	add	r23, r0
    449e:	81 1d       	adc	r24, r1
    44a0:	11 24       	eor	r1, r1
    44a2:	91 1d       	adc	r25, r1
    44a4:	b2 9f       	mul	r27, r18
    44a6:	70 0d       	add	r23, r0
    44a8:	81 1d       	adc	r24, r1
    44aa:	11 24       	eor	r1, r1
    44ac:	91 1d       	adc	r25, r1
    44ae:	08 95       	ret

000044b0 <memcpy>:
    44b0:	fb 01       	movw	r30, r22
    44b2:	dc 01       	movw	r26, r24
    44b4:	02 c0       	rjmp	.+4      	; 0x44ba <memcpy+0xa>
    44b6:	01 90       	ld	r0, Z+
    44b8:	0d 92       	st	X+, r0
    44ba:	41 50       	subi	r20, 0x01	; 1
    44bc:	50 40       	sbci	r21, 0x00	; 0
    44be:	d8 f7       	brcc	.-10     	; 0x44b6 <memcpy+0x6>
    44c0:	08 95       	ret

000044c2 <memset>:
    44c2:	dc 01       	movw	r26, r24
    44c4:	01 c0       	rjmp	.+2      	; 0x44c8 <memset+0x6>
    44c6:	6d 93       	st	X+, r22
    44c8:	41 50       	subi	r20, 0x01	; 1
    44ca:	50 40       	sbci	r21, 0x00	; 0
    44cc:	e0 f7       	brcc	.-8      	; 0x44c6 <memset+0x4>
    44ce:	08 95       	ret

000044d0 <strncpy>:
    44d0:	fb 01       	movw	r30, r22
    44d2:	dc 01       	movw	r26, r24
    44d4:	41 50       	subi	r20, 0x01	; 1
    44d6:	50 40       	sbci	r21, 0x00	; 0
    44d8:	48 f0       	brcs	.+18     	; 0x44ec <strncpy+0x1c>
    44da:	01 90       	ld	r0, Z+
    44dc:	0d 92       	st	X+, r0
    44de:	00 20       	and	r0, r0
    44e0:	c9 f7       	brne	.-14     	; 0x44d4 <strncpy+0x4>
    44e2:	01 c0       	rjmp	.+2      	; 0x44e6 <strncpy+0x16>
    44e4:	1d 92       	st	X+, r1
    44e6:	41 50       	subi	r20, 0x01	; 1
    44e8:	50 40       	sbci	r21, 0x00	; 0
    44ea:	e0 f7       	brcc	.-8      	; 0x44e4 <strncpy+0x14>
    44ec:	08 95       	ret

000044ee <ultoa>:
    44ee:	25 32       	cpi	r18, 0x25	; 37
    44f0:	31 05       	cpc	r19, r1
    44f2:	20 f4       	brcc	.+8      	; 0x44fc <ultoa+0xe>
    44f4:	22 30       	cpi	r18, 0x02	; 2
    44f6:	10 f0       	brcs	.+4      	; 0x44fc <ultoa+0xe>
    44f8:	0c 94 82 22 	jmp	0x4504	; 0x4504 <__ultoa_ncheck>
    44fc:	fa 01       	movw	r30, r20
    44fe:	10 82       	st	Z, r1
    4500:	ca 01       	movw	r24, r20
    4502:	08 95       	ret

00004504 <__ultoa_ncheck>:
    4504:	bb 27       	eor	r27, r27

00004506 <__ultoa_common>:
    4506:	fa 01       	movw	r30, r20
    4508:	a6 2f       	mov	r26, r22
    450a:	62 17       	cp	r22, r18
    450c:	71 05       	cpc	r23, r1
    450e:	81 05       	cpc	r24, r1
    4510:	91 05       	cpc	r25, r1
    4512:	33 0b       	sbc	r19, r19
    4514:	30 fb       	bst	r19, 0
    4516:	66 f0       	brts	.+24     	; 0x4530 <__ultoa_common+0x2a>
    4518:	aa 27       	eor	r26, r26
    451a:	66 0f       	add	r22, r22
    451c:	77 1f       	adc	r23, r23
    451e:	88 1f       	adc	r24, r24
    4520:	99 1f       	adc	r25, r25
    4522:	aa 1f       	adc	r26, r26
    4524:	a2 17       	cp	r26, r18
    4526:	10 f0       	brcs	.+4      	; 0x452c <__ultoa_common+0x26>
    4528:	a2 1b       	sub	r26, r18
    452a:	63 95       	inc	r22
    452c:	38 50       	subi	r19, 0x08	; 8
    452e:	a9 f7       	brne	.-22     	; 0x451a <__ultoa_common+0x14>
    4530:	a0 5d       	subi	r26, 0xD0	; 208
    4532:	aa 33       	cpi	r26, 0x3A	; 58
    4534:	08 f0       	brcs	.+2      	; 0x4538 <__ultoa_common+0x32>
    4536:	a9 5d       	subi	r26, 0xD9	; 217
    4538:	a1 93       	st	Z+, r26
    453a:	36 f7       	brtc	.-52     	; 0x4508 <__ultoa_common+0x2>
    453c:	b1 11       	cpse	r27, r1
    453e:	b1 93       	st	Z+, r27
    4540:	10 82       	st	Z, r1
    4542:	ca 01       	movw	r24, r20
    4544:	0c 94 c9 22 	jmp	0x4592	; 0x4592 <strrev>

00004548 <utoa>:
    4548:	45 32       	cpi	r20, 0x25	; 37
    454a:	51 05       	cpc	r21, r1
    454c:	20 f4       	brcc	.+8      	; 0x4556 <utoa+0xe>
    454e:	42 30       	cpi	r20, 0x02	; 2
    4550:	10 f0       	brcs	.+4      	; 0x4556 <utoa+0xe>
    4552:	0c 94 af 22 	jmp	0x455e	; 0x455e <__utoa_ncheck>
    4556:	fb 01       	movw	r30, r22
    4558:	10 82       	st	Z, r1
    455a:	cb 01       	movw	r24, r22
    455c:	08 95       	ret

0000455e <__utoa_ncheck>:
    455e:	bb 27       	eor	r27, r27

00004560 <__utoa_common>:
    4560:	fb 01       	movw	r30, r22
    4562:	55 27       	eor	r21, r21
    4564:	aa 27       	eor	r26, r26
    4566:	88 0f       	add	r24, r24
    4568:	99 1f       	adc	r25, r25
    456a:	aa 1f       	adc	r26, r26
    456c:	a4 17       	cp	r26, r20
    456e:	10 f0       	brcs	.+4      	; 0x4574 <__utoa_common+0x14>
    4570:	a4 1b       	sub	r26, r20
    4572:	83 95       	inc	r24
    4574:	50 51       	subi	r21, 0x10	; 16
    4576:	b9 f7       	brne	.-18     	; 0x4566 <__utoa_common+0x6>
    4578:	a0 5d       	subi	r26, 0xD0	; 208
    457a:	aa 33       	cpi	r26, 0x3A	; 58
    457c:	08 f0       	brcs	.+2      	; 0x4580 <__utoa_common+0x20>
    457e:	a9 5d       	subi	r26, 0xD9	; 217
    4580:	a1 93       	st	Z+, r26
    4582:	00 97       	sbiw	r24, 0x00	; 0
    4584:	79 f7       	brne	.-34     	; 0x4564 <__utoa_common+0x4>
    4586:	b1 11       	cpse	r27, r1
    4588:	b1 93       	st	Z+, r27
    458a:	11 92       	st	Z+, r1
    458c:	cb 01       	movw	r24, r22
    458e:	0c 94 c9 22 	jmp	0x4592	; 0x4592 <strrev>

00004592 <strrev>:
    4592:	dc 01       	movw	r26, r24
    4594:	fc 01       	movw	r30, r24
    4596:	67 2f       	mov	r22, r23
    4598:	71 91       	ld	r23, Z+
    459a:	77 23       	and	r23, r23
    459c:	e1 f7       	brne	.-8      	; 0x4596 <strrev+0x4>
    459e:	32 97       	sbiw	r30, 0x02	; 2
    45a0:	04 c0       	rjmp	.+8      	; 0x45aa <strrev+0x18>
    45a2:	7c 91       	ld	r23, X
    45a4:	6d 93       	st	X+, r22
    45a6:	70 83       	st	Z, r23
    45a8:	62 91       	ld	r22, -Z
    45aa:	ae 17       	cp	r26, r30
    45ac:	bf 07       	cpc	r27, r31
    45ae:	c8 f3       	brcs	.-14     	; 0x45a2 <strrev+0x10>
    45b0:	08 95       	ret

000045b2 <_exit>:
    45b2:	f8 94       	cli

000045b4 <__stop_program>:
    45b4:	ff cf       	rjmp	.-2      	; 0x45b4 <__stop_program>
